{
    "author": "jezdez",
    "message": "Fixed #4992 -- Respect the GET request query string when creating cache keys. Thanks PeterKz and guettli for the initial patch.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15705 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3",
    "files": [
        {
            "sha": "f9e1494e2600333da2a8408138fc23126dd33425",
            "filename": "django/http/__init__.py",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3/django%2Fhttp%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3/django%2Fhttp%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2F__init__.py?ref=f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3",
            "patch": "@@ -166,7 +166,9 @@ def get_host(self):\n         return host\n \n     def get_full_path(self):\n-        return ''\n+        # RFC 3986 requires query string arguments to be in the ASCII range.\n+        # Rather than crash if this doesn't happen, we encode defensively.\n+        return '%s%s' % (self.path, self.META.get('QUERY_STRING', '') and ('?' + iri_to_uri(self.META.get('QUERY_STRING', ''))) or '')\n \n     def build_absolute_uri(self, location=None):\n         \"\"\""
        },
        {
            "sha": "34bf0ca4a46c0bef0cc4ee53bc2cfc762989bad2",
            "filename": "django/middleware/cache.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3/django%2Fmiddleware%2Fcache.py",
            "raw_url": "https://github.com/django/django/raw/f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3/django%2Fmiddleware%2Fcache.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fmiddleware%2Fcache.py?ref=f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3",
            "patch": "@@ -23,7 +23,7 @@\n \n More details about how the caching works:\n \n-* Only parameter-less GET or HEAD-requests with status code 200 are cached.\n+* Only GET or HEAD-requests with status code 200 are cached.\n \n * The number of seconds each page is stored for is set by the \"max-age\" section\n   of the response's \"Cache-Control\" header, falling back to the\n@@ -135,7 +135,7 @@ def process_request(self, request):\n         Checks whether the page is already cached and returns the cached\n         version if available.\n         \"\"\"\n-        if not request.method in ('GET', 'HEAD') or request.GET:\n+        if not request.method in ('GET', 'HEAD'):\n             request._cache_update_cache = False\n             return None # Don't bother checking the cache.\n "
        },
        {
            "sha": "63c4af34949337dff86ff5d87245a39b4f8257b5",
            "filename": "django/utils/cache.py",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3/django%2Futils%2Fcache.py",
            "raw_url": "https://github.com/django/django/raw/f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3/django%2Futils%2Fcache.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fcache.py?ref=f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3",
            "patch": "@@ -160,24 +160,24 @@ def _generate_cache_key(request, method, headerlist, key_prefix):\n         value = request.META.get(header, None)\n         if value is not None:\n             ctx.update(value)\n-    path = md5_constructor(iri_to_uri(request.path))\n+    path = md5_constructor(iri_to_uri(request.get_full_path()))\n     cache_key = 'views.decorators.cache.cache_page.%s.%s.%s.%s' % (\n         key_prefix, request.method, path.hexdigest(), ctx.hexdigest())\n     return _i18n_cache_key_suffix(request, cache_key)\n \n def _generate_cache_header_key(key_prefix, request):\n     \"\"\"Returns a cache key for the header cache.\"\"\"\n-    path = md5_constructor(iri_to_uri(request.path))\n+    path = md5_constructor(iri_to_uri(request.get_full_path()))\n     cache_key = 'views.decorators.cache.cache_header.%s.%s' % (\n         key_prefix, path.hexdigest())\n     return _i18n_cache_key_suffix(request, cache_key)\n \n def get_cache_key(request, key_prefix=None, method='GET', cache=None):\n     \"\"\"\n-    Returns a cache key based on the request path. It can be used in the\n-    request phase because it pulls the list of headers to take into account\n-    from the global path registry and uses those to build a cache key to check\n-    against.\n+    Returns a cache key based on the request path and query. It can be used\n+    in the request phase because it pulls the list of headers to take into\n+    account from the global path registry and uses those to build a cache key\n+    to check against.\n \n     If there is no headerlist stored, the page needs to be rebuilt, so this\n     function returns None.\n@@ -220,7 +220,7 @@ def learn_cache_key(request, response, cache_timeout=None, key_prefix=None, cach\n         return _generate_cache_key(request, request.method, headerlist, key_prefix)\n     else:\n         # if there is no Vary header, we still need a cache key\n-        # for the request.path\n+        # for the request.get_full_path()\n         cache.set(cache_key, [], cache_timeout)\n         return _generate_cache_key(request, request.method, [], key_prefix)\n "
        },
        {
            "sha": "66f78ba0c4d6ba28c9b497be1124220541645392",
            "filename": "docs/releases/1.3.txt",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3/docs%2Freleases%2F1.3.txt",
            "raw_url": "https://github.com/django/django/raw/f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3/docs%2Freleases%2F1.3.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.3.txt?ref=f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3",
            "patch": "@@ -169,6 +169,9 @@ Secondly, :ref:`Versioning <cache_versioning>`, :ref:`site-wide\n prefixing <cache_key_prefixing>` and :ref:`transformation\n <cache_key_transformation>` has been added to the cache API.\n \n+Thirdly, the :ref:`cache key creation <using-vary-headers>` has been\n+updated to take the GET request query string into account.\n+\n Lastly, support for pylibmc_ has been added to the memcached cache\n backend.\n "
        },
        {
            "sha": "4eb9d21536038953c0e40e0e68b3939fdbc76a0c",
            "filename": "docs/topics/cache.txt",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3/docs%2Ftopics%2Fcache.txt",
            "raw_url": "https://github.com/django/django/raw/f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3/docs%2Ftopics%2Fcache.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fcache.txt?ref=f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3",
            "patch": "@@ -962,9 +962,13 @@ mechanism should take into account when building its cache key. For example, if\n the contents of a Web page depend on a user's language preference, the page is\n said to \"vary on language.\"\n \n+.. versionchanged:: 1.3\n+    In Django 1.3 the full request path -- including the query -- is used\n+    to create the cache keys, instead of only the path component in Django 1.2.\n+\n By default, Django's cache system creates its cache keys using the requested\n-path (e.g., ``\"/stories/2005/jun/23/bank_robbed/\"``). This means every request\n-to that URL will use the same cached version, regardless of user-agent\n+path and query -- e.g., ``\"/stories/2005/?order_by=author\"``. This means every\n+request to that URL will use the same cached version, regardless of user-agent\n differences such as cookies or language preferences. However, if this page\n produces different content based on some difference in request headers -- such\n as a cookie, or a language, or a user-agent -- you'll need to use the ``Vary``"
        },
        {
            "sha": "4935bd0e5799627faec273e8ffd15e71b1120d03",
            "filename": "tests/regressiontests/cache/tests.py",
            "status": "modified",
            "additions": 36,
            "deletions": 3,
            "changes": 39,
            "blob_url": "https://github.com/django/django/blob/f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3/tests%2Fregressiontests%2Fcache%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3/tests%2Fregressiontests%2Fcache%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fcache%2Ftests.py?ref=f6c991667f6f1ab8d2fd2afc1ee2b5801e78b7e3",
            "patch": "@@ -12,7 +12,7 @@\n from django.core import management\n from django.core.cache import get_cache, DEFAULT_CACHE_ALIAS\n from django.core.cache.backends.base import CacheKeyWarning\n-from django.http import HttpResponse, HttpRequest\n+from django.http import HttpResponse, HttpRequest, QueryDict\n from django.middleware.cache import FetchFromCacheMiddleware, UpdateCacheMiddleware, CacheMiddleware\n from django.test import RequestFactory\n from django.test.utils import get_warnings_state, restore_warnings_state\n@@ -920,10 +920,20 @@ def test_get_cache_key(self):\n         # Set headers to an empty list.\n         learn_cache_key(request, response)\n         self.assertEqual(get_cache_key(request), 'views.decorators.cache.cache_page.settingsprefix.GET.a8c87a3d8c44853d7f79474f7ffe4ad5.d41d8cd98f00b204e9800998ecf8427e')\n-        # Verify that a specified key_prefix is taken in to account.\n+        # Verify that a specified key_prefix is taken into account.\n         learn_cache_key(request, response, key_prefix=key_prefix)\n         self.assertEqual(get_cache_key(request, key_prefix=key_prefix), 'views.decorators.cache.cache_page.localprefix.GET.a8c87a3d8c44853d7f79474f7ffe4ad5.d41d8cd98f00b204e9800998ecf8427e')\n \n+    def test_get_cache_key_with_query(self):\n+        request = self._get_request(self.path + '?test=1')\n+        response = HttpResponse()\n+        # Expect None if no headers have been set yet.\n+        self.assertEqual(get_cache_key(request), None)\n+        # Set headers to an empty list.\n+        learn_cache_key(request, response)\n+        # Verify that the querystring is taken into account.\n+        self.assertEqual(get_cache_key(request), 'views.decorators.cache.cache_page.settingsprefix.GET.bd889c5a59603af44333ed21504db3cd.d41d8cd98f00b204e9800998ecf8427e')\n+\n     def test_learn_cache_key(self):\n         request = self._get_request(self.path, 'HEAD')\n         response = HttpResponse()\n@@ -1039,12 +1049,15 @@ def _get_request(self):\n         request.path = request.path_info = self.path\n         return request\n \n-    def _get_request_cache(self):\n+    def _get_request_cache(self, query_string=None):\n         request = HttpRequest()\n         request.META = {\n             'SERVER_NAME': 'testserver',\n             'SERVER_PORT': 80,\n         }\n+        if query_string:\n+            request.META['QUERY_STRING'] = query_string\n+            request.GET = QueryDict(query_string)\n         request.path = request.path_info = self.path\n         request._cache_update_cache = True\n         request.method = 'GET'\n@@ -1085,6 +1098,26 @@ def set_cache(request, lang, msg):\n         }\n         settings.USE_ETAGS = True\n         settings.USE_I18N = True\n+\n+        # cache with non empty request.GET\n+        request = self._get_request_cache(query_string='foo=bar&other=true')\n+        get_cache_data = FetchFromCacheMiddleware().process_request(request)\n+        # first access, cache must return None\n+        self.assertEqual(get_cache_data, None)\n+        response = HttpResponse()\n+        content = 'Check for cache with QUERY_STRING'\n+        response.content = content\n+        UpdateCacheMiddleware().process_response(request, response)\n+        get_cache_data = FetchFromCacheMiddleware().process_request(request)\n+        # cache must return content\n+        self.assertNotEqual(get_cache_data, None)\n+        self.assertEqual(get_cache_data.content, content)\n+        # different QUERY_STRING, cache must be empty\n+        request = self._get_request_cache(query_string='foo=bar&somethingelse=true')\n+        get_cache_data = FetchFromCacheMiddleware().process_request(request)\n+        self.assertEqual(get_cache_data, None)\n+\n+        # i18n tests\n         en_message =\"Hello world!\"\n         es_message =\"Hola mundo!\"\n "
        }
    ],
    "stats": {
        "total": 72,
        "additions": 57,
        "deletions": 15
    }
}