{
    "author": "aaugustin",
    "message": "Fixed #16364 -- Clarified why automatically created data shouldn't be saved in fixtures. Thanks Gabriel for the review.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17355 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "d101ed2cb8d5a25e0120764fe5ed86c101a2113a",
    "files": [
        {
            "sha": "2cf2442a52bf24535ae9c748d5d6cd3882276307",
            "filename": "docs/topics/serialization.txt",
            "status": "modified",
            "additions": 41,
            "deletions": 36,
            "changes": 77,
            "blob_url": "https://github.com/django/django/blob/d101ed2cb8d5a25e0120764fe5ed86c101a2113a/docs%2Ftopics%2Fserialization.txt",
            "raw_url": "https://github.com/django/django/raw/d101ed2cb8d5a25e0120764fe5ed86c101a2113a/docs%2Ftopics%2Fserialization.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fserialization.txt?ref=d101ed2cb8d5a25e0120764fe5ed86c101a2113a",
            "patch": "@@ -198,23 +198,32 @@ Natural keys\n ------------\n \n .. versionadded:: 1.2\n+\n    The ability to use natural keys when serializing/deserializing data was\n    added in the 1.2 release.\n \n-The default serialization strategy for foreign keys and many-to-many\n-relations is to serialize the value of the primary key(s) of the\n-objects in the relation. This strategy works well for most types of\n-object, but it can cause difficulty in some circumstances.\n-\n-Consider the case of a list of objects that have foreign key on\n-:class:`ContentType`. If you're going to serialize an object that\n-refers to a content type, you need to have a way to refer to that\n-content type. Content Types are automatically created by Django as\n-part of the database synchronization process, so you don't need to\n-include content types in a fixture or other serialized data. As a\n-result, the primary key of any given content type isn't easy to\n-predict - it will depend on how and when :djadmin:`syncdb` was\n-executed to create the content types.\n+The default serialization strategy for foreign keys and many-to-many relations\n+is to serialize the value of the primary key(s) of the objects in the relation.\n+This strategy works well for most objects, but it can cause difficulty in some\n+circumstances.\n+\n+Consider the case of a list of objects that have a foreign key referencing\n+:class:`~django.contrib.conttenttypes.models.ContentType`. If you're going to\n+serialize an object that refers to a content type, then you need to have a way\n+to refer to that content type to begin with. Since ``ContentType`` objects are\n+automatically created by Django during the database synchronization process,\n+the primary key of a given content type isn't easy to predict; it will\n+depend on how and when :djadmin:`syncdb` was executed. This is true for all\n+models which automatically generate objects, notably including\n+:class:`~django.contrib.auth.models.Permission`.\n+\n+.. warning::\n+\n+    You should never include automatically generated objects in a fixture or\n+    other serialized data. By chance, the primary keys in the fixture\n+    may match those in the database and loading the fixture will\n+    have no effect. In the more likely case that they don't match, the fixture\n+    loading will fail with an :class:`~django.db.IntegrityError`.\n \n There is also the matter of convenience. An integer id isn't always\n the most convenient way to refer to an object; sometimes, a\n@@ -363,13 +372,13 @@ Dependencies during serialization\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n Since natural keys rely on database lookups to resolve references, it\n-is important that data exists before it is referenced. You can't make\n-a `forward reference` with natural keys - the data you are referencing\n+is important that the data exists before it is referenced. You can't make\n+a `forward reference` with natural keys--the data you are referencing\n must exist before you include a natural key reference to that data.\n \n To accommodate this limitation, calls to :djadmin:`dumpdata` that use\n the :djadminopt:`--natural` option will serialize any model with a\n-``natural_key()`` method before it serializes normal key objects.\n+``natural_key()`` method before serializing standard primary key objects.\n \n However, this may not always be enough. If your natural key refers to\n another object (by using a foreign key or natural key to another object\n@@ -381,28 +390,24 @@ To control this ordering, you can define dependencies on your\n ``natural_key()`` methods. You do this by setting a ``dependencies``\n attribute on the ``natural_key()`` method itself.\n \n-For example, consider the ``Permission`` model in ``contrib.auth``.\n-The following is a simplified version of the ``Permission`` model::\n+For example, let's add a natural key to the ``Book`` model from the\n+example above::\n+\n+    class Book(models.Model):\n+        name = models.CharField(max_length=100)\n+        author = models.ForeignKey(Person)\n \n-    class Permission(models.Model):\n-        name = models.CharField(max_length=50)\n-        content_type = models.ForeignKey(ContentType)\n-        codename = models.CharField(max_length=100)\n-        # ...\n         def natural_key(self):\n-            return (self.codename,) + self.content_type.natural_key()\n+            return (self.name,) + self.author.natural_key()\n \n-The natural key for a ``Permission`` is a combination of the codename for the\n-``Permission``, and the ``ContentType`` to which the ``Permission`` applies. This means\n-that ``ContentType`` must be serialized before ``Permission``. To define this\n-dependency, we add one extra line::\n+The natural key for a ``Book`` is a combination of its name and its\n+author.  This means that ``Person`` must be serialized before ``Book``.\n+To define this dependency, we add one extra line::\n \n-    class Permission(models.Model):\n-        # ...\n         def natural_key(self):\n-            return (self.codename,) + self.content_type.natural_key()\n-        natural_key.dependencies = ['contenttypes.contenttype']\n+            return (self.name,) + self.author.natural_key()\n+        natural_key.dependencies = ['example_app.person']\n \n-This definition ensures that ``ContentType`` models are serialized before\n-``Permission`` models. In turn, any object referencing ``Permission`` will\n-be serialized after both ``ContentType`` and ``Permission``.\n+This definition ensures that all ``Person`` objects are serialized before\n+any ``Book`` objects. In turn, any object referencing ``Book`` will be\n+serialized after both ``Person`` and ``Book`` have been serialized."
        }
    ],
    "stats": {
        "total": 77,
        "additions": 41,
        "deletions": 36
    }
}