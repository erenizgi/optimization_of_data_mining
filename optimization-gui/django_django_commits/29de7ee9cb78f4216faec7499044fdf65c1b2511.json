{
    "author": "alex",
    "message": "Fixed #11293 -- fixed using Q objects to generate ORs with aggregates.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15173 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "29de7ee9cb78f4216faec7499044fdf65c1b2511",
    "files": [
        {
            "sha": "b0565524bbcf032727f846b26e8be0d05f1cc722",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 37,
            "deletions": 15,
            "changes": 52,
            "blob_url": "https://github.com/django/django/blob/29de7ee9cb78f4216faec7499044fdf65c1b2511/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/29de7ee9cb78f4216faec7499044fdf65c1b2511/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=29de7ee9cb78f4216faec7499044fdf65c1b2511",
            "patch": "@@ -922,6 +922,19 @@ def remove_inherited_models(self):\n                 self.unref_alias(alias)\n         self.included_inherited_models = {}\n \n+    def need_force_having(self, q_object):\n+        \"\"\"\n+        Returns whether or not all elements of this q_object need to be put\n+        together in the HAVING clause.\n+        \"\"\"\n+        for child in q_object.children:\n+            if isinstance(child, Node):\n+                if self.need_force_having(child):\n+                    return True\n+            else:\n+                if child[0].split(LOOKUP_SEP)[0] in self.aggregates:\n+                    return True\n+        return False\n \n     def add_aggregate(self, aggregate, model, alias, is_summary):\n         \"\"\"\n@@ -972,7 +985,7 @@ def add_aggregate(self, aggregate, model, alias, is_summary):\n         aggregate.add_to_query(self, alias, col=col, source=source, is_summary=is_summary)\n \n     def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n-            can_reuse=None, process_extras=True):\n+            can_reuse=None, process_extras=True, force_having=False):\n         \"\"\"\n         Add a single filter to the query. The 'filter_expr' is a pair:\n         (filter_string, value). E.g. ('name__contains', 'fred')\n@@ -1026,14 +1039,14 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n             value = SQLEvaluator(value, self)\n             having_clause = value.contains_aggregate\n \n-        for alias, aggregate in self.aggregates.items():\n-            if alias == parts[0]:\n-                entry = self.where_class()\n-                entry.add((aggregate, lookup_type, value), AND)\n-                if negate:\n-                    entry.negate()\n-                self.having.add(entry, AND)\n-                return\n+        if parts[0] in self.aggregates:\n+            aggregate = self.aggregates[parts[0]]\n+            entry = self.where_class()\n+            entry.add((aggregate, lookup_type, value), AND)\n+            if negate:\n+                entry.negate()\n+            self.having.add(entry, connector)\n+            return\n \n         opts = self.get_meta()\n         alias = self.get_initial_alias()\n@@ -1082,7 +1095,7 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n             self.promote_alias_chain(table_it, table_promote)\n \n \n-        if having_clause:\n+        if having_clause or force_having:\n             if (alias, col) not in self.group_by:\n                 self.group_by.append((alias, col))\n             self.having.add((Constraint(alias, col, field), lookup_type, value),\n@@ -1123,7 +1136,7 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n                 self.add_filter(filter, negate=negate, can_reuse=can_reuse,\n                         process_extras=False)\n \n-    def add_q(self, q_object, used_aliases=None):\n+    def add_q(self, q_object, used_aliases=None, force_having=False):\n         \"\"\"\n         Adds a Q-object to the current filter.\n \n@@ -1141,16 +1154,25 @@ def add_q(self, q_object, used_aliases=None):\n             else:\n                 subtree = False\n             connector = AND\n+            if q_object.connector == OR and not force_having:\n+                force_having = self.need_force_having(q_object)\n             for child in q_object.children:\n                 if connector == OR:\n                     refcounts_before = self.alias_refcount.copy()\n-                self.where.start_subtree(connector)\n+                if force_having:\n+                    self.having.start_subtree(connector)\n+                else:\n+                    self.where.start_subtree(connector)\n                 if isinstance(child, Node):\n-                    self.add_q(child, used_aliases)\n+                    self.add_q(child, used_aliases, force_having=force_having)\n                 else:\n                     self.add_filter(child, connector, q_object.negated,\n-                            can_reuse=used_aliases)\n-                self.where.end_subtree()\n+                            can_reuse=used_aliases, force_having=force_having)\n+                if force_having:\n+                    self.having.end_subtree()\n+                else:\n+                    self.where.end_subtree()\n+\n                 if connector == OR:\n                     # Aliases that were newly added or not used at all need to\n                     # be promoted to outer joins if they are nullable relations."
        },
        {
            "sha": "ec2603fe1e17507ecc731f0b0f262a178b133790",
            "filename": "tests/regressiontests/aggregation_regress/tests.py",
            "status": "modified",
            "additions": 53,
            "deletions": 1,
            "changes": 54,
            "blob_url": "https://github.com/django/django/blob/29de7ee9cb78f4216faec7499044fdf65c1b2511/tests%2Fregressiontests%2Faggregation_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/29de7ee9cb78f4216faec7499044fdf65c1b2511/tests%2Fregressiontests%2Faggregation_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Faggregation_regress%2Ftests.py?ref=29de7ee9cb78f4216faec7499044fdf65c1b2511",
            "patch": "@@ -4,8 +4,8 @@\n from operator import attrgetter\n \n from django.core.exceptions import FieldError\n+from django.db.models import Count, Max, Avg, Sum, StdDev, Variance, F, Q\n from django.test import TestCase, Approximate, skipUnlessDBFeature\n-from django.db.models import Count, Max, Avg, Sum, StdDev, Variance, F\n \n from models import Author, Book, Publisher, Clues, Entries, HardbackBook\n \n@@ -673,6 +673,58 @@ def test_having_group_by(self):\n             list(qs), list(Book.objects.values_list(\"name\", flat=True))\n         )\n \n+    def test_annotation_disjunction(self):\n+        qs = Book.objects.annotate(n_authors=Count(\"authors\")).filter(\n+            Q(n_authors=2) | Q(name=\"Python Web Development with Django\")\n+        )\n+        self.assertQuerysetEqual(\n+            qs, [\n+                \"Artificial Intelligence: A Modern Approach\",\n+                \"Python Web Development with Django\",\n+                \"The Definitive Guide to Django: Web Development Done Right\",\n+            ],\n+            attrgetter(\"name\")\n+        )\n+\n+        qs = Book.objects.annotate(n_authors=Count(\"authors\")).filter(\n+            Q(name=\"The Definitive Guide to Django: Web Development Done Right\") | (Q(name=\"Artificial Intelligence: A Modern Approach\") & Q(n_authors=3))\n+        )\n+        self.assertQuerysetEqual(\n+            qs, [\n+                \"The Definitive Guide to Django: Web Development Done Right\",\n+            ],\n+            attrgetter(\"name\")\n+        )\n+\n+        qs = Publisher.objects.annotate(\n+            rating_sum=Sum(\"book__rating\"),\n+            book_count=Count(\"book\")\n+        ).filter(\n+            Q(rating_sum__gt=5.5) | Q(rating_sum__isnull=True)\n+        ).order_by('pk')\n+        self.assertQuerysetEqual(\n+            qs, [\n+                \"Apress\",\n+                \"Prentice Hall\",\n+                \"Jonno's House of Books\",\n+            ],\n+            attrgetter(\"name\")\n+        )\n+\n+        qs = Publisher.objects.annotate(\n+            rating_sum=Sum(\"book__rating\"),\n+            book_count=Count(\"book\")\n+        ).filter(\n+            Q(pk__lt=F(\"book_count\")) | Q(rating_sum=None)\n+        ).order_by(\"pk\")\n+        self.assertQuerysetEqual(\n+            qs, [\n+                \"Apress\",\n+                \"Jonno's House of Books\",\n+            ],\n+            attrgetter(\"name\")\n+        )\n+\n     @skipUnlessDBFeature('supports_stddev')\n     def test_stddev(self):\n         self.assertEqual("
        }
    ],
    "stats": {
        "total": 106,
        "additions": 90,
        "deletions": 16
    }
}