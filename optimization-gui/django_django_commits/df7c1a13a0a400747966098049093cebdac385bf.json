{
    "author": "timgraham",
    "message": "Fixed #18804 - Reorganized class based views docs a bit; thanks anthonyb for the initial patch.",
    "sha": "df7c1a13a0a400747966098049093cebdac385bf",
    "files": [
        {
            "sha": "6637bd5fcb33d6b4e1121df761d7d1d07a5a9b17",
            "filename": "docs/topics/class-based-views/index.txt",
            "status": "modified",
            "additions": 33,
            "deletions": 116,
            "changes": 149,
            "blob_url": "https://github.com/django/django/blob/df7c1a13a0a400747966098049093cebdac385bf/docs%2Ftopics%2Fclass-based-views%2Findex.txt",
            "raw_url": "https://github.com/django/django/raw/df7c1a13a0a400747966098049093cebdac385bf/docs%2Ftopics%2Fclass-based-views%2Findex.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fclass-based-views%2Findex.txt?ref=df7c1a13a0a400747966098049093cebdac385bf",
            "patch": "@@ -11,8 +11,7 @@ to structure your views and reuse code by harnessing inheritance and\n mixins. There are also some generic views for simple tasks which we'll\n get to later, but you may want to design your own structure of\n reusable views which suits your use case. For full details, see the\n-:doc:`class-based views reference\n-documentation</ref/class-based-views/index>`.\n+:doc:`class-based views reference documentation</ref/class-based-views/index>`.\n \n .. toctree::\n    :maxdepth: 1\n@@ -32,41 +31,12 @@ redirect, and :class:`~django.views.generic.base.TemplateView` extends the base\n to make it also render a template.\n \n \n-Simple usage\n-============\n-\n-Class-based generic views (and any class-based views that inherit from\n-the base classes Django provides) can be configured in two\n-ways: subclassing, or passing in arguments directly in the URLconf.\n-\n-When you subclass a class-based view, you can override attributes\n-(such as the ``template_name``) or methods (such as ``get_context_data``)\n-in your subclass to provide new values or methods. Consider, for example,\n-a view that just displays one template, ``about.html``. Django has a\n-generic view to do this - :class:`~django.views.generic.base.TemplateView` -\n-so we can just subclass it, and override the template name::\n-\n-    # some_app/views.py\n-    from django.views.generic import TemplateView\n-\n-    class AboutView(TemplateView):\n-        template_name = \"about.html\"\n-\n-Then, we just need to add this new view into our URLconf. As the class-based\n-views themselves are classes, we point the URL to the ``as_view`` class method\n-instead, which is the entry point for class-based views::\n-\n-    # urls.py\n-    from django.conf.urls import patterns, url, include\n-    from some_app.views import AboutView\n-\n-    urlpatterns = patterns('',\n-        (r'^about/', AboutView.as_view()),\n-    )\n+Simple usage in your URLconf\n+============================\n \n-Alternatively, if you're only changing a few simple attributes on a\n-class-based view, you can simply pass the new attributes into the ``as_view``\n-method call itself::\n+The simplest way to use generic views is to create them directly in your\n+URLconf. If you're only changing a few simple attributes on a class-based view,\n+you can simply pass them into the ``as_view`` method call itself::\n \n     from django.conf.urls import patterns, url, include\n     from django.views.generic import TemplateView\n@@ -75,93 +45,41 @@ method call itself::\n         (r'^about/', TemplateView.as_view(template_name=\"about.html\")),\n     )\n \n+Any arguments given will override the ``template_name`` on the\n A similar overriding pattern can be used for the ``url`` attribute on\n :class:`~django.views.generic.base.RedirectView`.\n \n-.. _jsonresponsemixin-example:\n-\n-More than just HTML\n--------------------\n-\n-Where class based views shine is when you want to do the same thing many times.\n-Suppose you're writing an API, and every view should return JSON instead of\n-rendered HTML.\n \n-We can create a mixin class to use in all of our views, handling the\n-conversion to JSON once.\n+Subclassing generic views\n+=========================\n \n-For example, a simple JSON mixin might look something like this::\n+The second, more powerful way to use generic views is to inherit from an\n+existing view and override attributes (such as the ``template_name``) or\n+methods (such as ``get_context_data``) in your subclass to provide new values\n+or methods. Consider, for example, a view that just displays one template,\n+``about.html``. Django has a generic view to do this -\n+:class:`~django.views.generic.base.TemplateView` - so we can just subclass it,\n+and override the template name::\n \n-    import json\n-    from django.http import HttpResponse\n-\n-    class JSONResponseMixin(object):\n-        \"\"\"\n-        A mixin that can be used to render a JSON response.\n-        \"\"\"\n-        response_class = HttpResponse\n+    # some_app/views.py\n+    from django.views.generic import TemplateView\n \n-        def render_to_response(self, context, **response_kwargs):\n-            \"\"\"\n-            Returns a JSON response, transforming 'context' to make the payload.\n-            \"\"\"\n-            response_kwargs['content_type'] = 'application/json'\n-            return self.response_class(\n-                self.convert_context_to_json(context),\n-                **response_kwargs\n-            )\n+    class AboutView(TemplateView):\n+        template_name = \"about.html\"\n \n-        def convert_context_to_json(self, context):\n-            \"Convert the context dictionary into a JSON object\"\n-            # Note: This is *EXTREMELY* naive; in reality, you'll need\n-            # to do much more complex handling to ensure that arbitrary\n-            # objects -- such as Django model instances or querysets\n-            # -- can be serialized as JSON.\n-            return json.dumps(context)\n+Then we just need to add this new view into our URLconf.\n+`~django.views.generic.base.TemplateView` is a class, not a function, so we\n+point the URL to the ``as_view`` class method instead, which provides a\n+function-like entry to class-based views::\n \n-Now we mix this into the base TemplateView::\n+    # urls.py\n+    from django.conf.urls import patterns, url, include\n+    from some_app.views import AboutView\n \n-    from django.views.generic import TemplateView\n+    urlpatterns = patterns('',\n+        (r'^about/', AboutView.as_view()),\n+    )\n \n-    class JSONView(JSONResponseMixin, TemplateView):\n-        pass\n-\n-Equally we could use our mixin with one of the generic views. We can make our\n-own version of :class:`~django.views.generic.detail.DetailView` by mixing\n-:class:`JSONResponseMixin` with the\n-:class:`~django.views.generic.detail.BaseDetailView` -- (the\n-:class:`~django.views.generic.detail.DetailView` before template\n-rendering behavior has been mixed in)::\n-\n-    class JSONDetailView(JSONResponseMixin, BaseDetailView):\n-        pass\n-\n-This view can then be deployed in the same way as any other\n-:class:`~django.views.generic.detail.DetailView`, with exactly the\n-same behavior -- except for the format of the response.\n-\n-If you want to be really adventurous, you could even mix a\n-:class:`~django.views.generic.detail.DetailView` subclass that is able\n-to return *both* HTML and JSON content, depending on some property of\n-the HTTP request, such as a query argument or a HTTP header. Just mix\n-in both the :class:`JSONResponseMixin` and a\n-:class:`~django.views.generic.detail.SingleObjectTemplateResponseMixin`,\n-and override the implementation of :func:`render_to_response()` to defer\n-to the appropriate subclass depending on the type of response that the user\n-requested::\n-\n-    class HybridDetailView(JSONResponseMixin, SingleObjectTemplateResponseMixin, BaseDetailView):\n-        def render_to_response(self, context):\n-            # Look for a 'format=json' GET argument\n-            if self.request.GET.get('format','html') == 'json':\n-                return JSONResponseMixin.render_to_response(self, context)\n-            else:\n-                return SingleObjectTemplateResponseMixin.render_to_response(self, context)\n-\n-Because of the way that Python resolves method overloading, the local\n-``render_to_response()`` implementation will override the versions provided by\n-:class:`JSONResponseMixin` and\n-:class:`~django.views.generic.detail.SingleObjectTemplateResponseMixin`.\n \n For more information on how to use the built in generic views, consult the next\n topic on :doc:`generic class based views</topics/class-based-views/generic-display>`.\n@@ -171,16 +89,15 @@ Decorating class-based views\n \n .. highlightlang:: python\n \n-The extension of class-based views isn't limited to using mixins. You\n-can use also use decorators.\n+Since class-based views aren't functions, decorating them works differently\n+depending on if you're using ``as_view`` or creating a subclass.\n \n Decorating in URLconf\n ---------------------\n \n The simplest way of decorating class-based views is to decorate the\n result of the :meth:`~django.views.generic.base.View.as_view` method.\n-The easiest place to do this is in the URLconf where you deploy your\n-view::\n+The easiest place to do this is in the URLconf where you deploy your view::\n \n     from django.contrib.auth.decorators import login_required, permission_required\n     from django.views.generic import TemplateView"
        },
        {
            "sha": "f07769fb8a3d416522c011c1afc3c652f269e928",
            "filename": "docs/topics/class-based-views/mixins.txt",
            "status": "modified",
            "additions": 115,
            "deletions": 35,
            "changes": 150,
            "blob_url": "https://github.com/django/django/blob/df7c1a13a0a400747966098049093cebdac385bf/docs%2Ftopics%2Fclass-based-views%2Fmixins.txt",
            "raw_url": "https://github.com/django/django/raw/df7c1a13a0a400747966098049093cebdac385bf/docs%2Ftopics%2Fclass-based-views%2Fmixins.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fclass-based-views%2Fmixins.txt?ref=df7c1a13a0a400747966098049093cebdac385bf",
            "patch": "@@ -69,7 +69,7 @@ interface to working with templates in class-based views.\n     add more members to the dictionary.\n \n Building up Django's generic class-based views\n-===============================================\n+==============================================\n \n Let's look at how two of Django's generic class-based views are built\n out of mixins providing discrete functionality. We'll consider\n@@ -222,8 +222,7 @@ we'll want the functionality provided by\n :class:`~django.views.generic.detail.SingleObjectMixin`.\n \n We'll demonstrate this with the publisher modelling we used in the\n-:doc:`generic class-based views\n-introduction<generic-display>`.\n+:doc:`generic class-based views introduction<generic-display>`.\n \n .. code-block:: python\n \n@@ -233,11 +232,11 @@ introduction<generic-display>`.\n     from django.views.generic import View\n     from django.views.generic.detail import SingleObjectMixin\n     from books.models import Author\n-    \n+\n     class RecordInterest(View, SingleObjectMixin):\n         \"\"\"Records the current user's interest in an author.\"\"\"\n         model = Author\n-    \n+\n         def post(self, request, *args, **kwargs):\n             if not request.user.is_authenticated():\n                 return HttpResponseForbidden()\n@@ -256,9 +255,7 @@ we're interested in, which it just does with a simple call to\n ``self.get_object()``. Everything else is taken care of for us by the\n mixin.\n \n-We can hook this into our URLs easily enough:\n-\n-.. code-block:: python\n+We can hook this into our URLs easily enough::\n \n     # urls.py\n     from books.views import RecordInterest\n@@ -294,8 +291,6 @@ object. In order to do this, we need to have two different querysets:\n     We'll figure that out ourselves in :meth:`get_queryset()` so we\n     can take into account the Publisher we're looking at.\n \n-.. highlightlang:: python\n-\n .. note::\n \n     We have to think carefully about :meth:`get_context_data()`.\n@@ -311,15 +306,15 @@ Now we can write a new :class:`PublisherDetail`::\n     from django.views.generic import ListView\n     from django.views.generic.detail import SingleObjectMixin\n     from books.models import Publisher\n-    \n+\n     class PublisherDetail(SingleObjectMixin, ListView):\n         paginate_by = 2\n         template_name = \"books/publisher_detail.html\"\n-    \n+\n         def get_context_data(self, **kwargs):\n             kwargs['publisher'] = self.object\n             return super(PublisherDetail, self).get_context_data(**kwargs)\n-    \n+\n         def get_queryset(self):\n             self.object = self.get_object(Publisher.objects.all())\n             return self.object.book_set.all()\n@@ -339,26 +334,26 @@ have to create lots of books to see the pagination working! Here's the\n template you'd want to use::\n \n     {% extends \"base.html\" %}\n-    \n+\n     {% block content %}\n         <h2>Publisher {{ publisher.name }}</h2>\n-        \n+\n         <ol>\n           {% for book in page_obj %}\n             <li>{{ book.title }}</li>\n           {% endfor %}\n         </ol>\n-        \n+\n         <div class=\"pagination\">\n             <span class=\"step-links\">\n                 {% if page_obj.has_previous %}\n                     <a href=\"?page={{ page_obj.previous_page_number }}\">previous</a>\n                 {% endif %}\n-        \n+\n                 <span class=\"current\">\n                     Page {{ page_obj.number }} of {{ paginator.num_pages }}.\n                 </span>\n-        \n+\n                 {% if page_obj.has_next %}\n                     <a href=\"?page={{ page_obj.next_page_number }}\">next</a>\n                 {% endif %}\n@@ -428,9 +423,9 @@ code so that on ``POST`` the form gets called appropriately.\n     the views implement :meth:`get()`, and things would get much more\n     confusing.\n \n-Our new :class:`AuthorDetail` looks like this:\n+.. highlightlang:: python\n \n-.. code-block:: python\n+Our new :class:`AuthorDetail` looks like this::\n \n     # CAUTION: you almost certainly do not want to do this.\n     # It is provided as part of a discussion of problems you can\n@@ -455,7 +450,7 @@ Our new :class:`AuthorDetail` looks like this:\n                 'author-detail',\n                 kwargs = {'pk': self.object.pk},\n             )\n-    \n+\n         def get_context_data(self, **kwargs):\n             form_class = self.get_form_class()\n             form = self.get_form(form_class)\n@@ -464,22 +459,22 @@ Our new :class:`AuthorDetail` looks like this:\n             }\n             context.update(kwargs)\n             return super(AuthorDetail, self).get_context_data(**context)\n-    \n+\n         def post(self, request, *args, **kwargs):\n             form_class = self.get_form_class()\n             form = self.get_form(form_class)\n             if form.is_valid():\n                 return self.form_valid(form)\n             else:\n                 return self.form_invalid(form)\n-    \n+\n         def form_valid(self, form):\n             if not self.request.user.is_authenticated():\n                 return HttpResponseForbidden()\n             self.object = self.get_object()\n             # record the interest using the message in form.cleaned_data\n             return super(AuthorDetail, self).form_valid(form)\n-    \n+\n :meth:`get_success_url()` is just providing somewhere to redirect to,\n which gets used in the default implementation of\n :meth:`form_valid()`. We have to provide our own :meth:`post()` as\n@@ -525,21 +520,21 @@ write our own :meth:`get_context_data()` to make the\n     from django.views.generic import DetailView\n     from django import forms\n     from books.models import Author\n-    \n+\n     class AuthorInterestForm(forms.Form):\n         message = forms.CharField()\n-    \n+\n     class AuthorDisplay(DetailView):\n-    \n+\n         queryset = Author.objects.all()\n-    \n+\n         def get_context_data(self, **kwargs):\n             context = {\n                 'form': AuthorInterestForm(),\n             }\n             context.update(kwargs)\n             return super(AuthorDisplay, self).get_context_data(**context)\n-    \n+\n Then the :class:`AuthorInterest` is a simple :class:`FormView`, but we\n have to bring in :class:`SingleObjectMixin` so we can find the author\n we're talking about, and we have to remember to set\n@@ -550,7 +545,7 @@ template as :class:`AuthorDisplay` is using on ``GET``.\n \n     from django.views.generic import FormView\n     from django.views.generic.detail import SingleObjectMixin\n-    \n+\n     class AuthorInterest(FormView, SingleObjectMixin):\n         template_name = 'books/author_detail.html'\n         form_class = AuthorInterestForm\n@@ -561,13 +556,13 @@ template as :class:`AuthorDisplay` is using on ``GET``.\n                 'object': self.get_object(),\n             }\n             return super(AuthorInterest, self).get_context_data(**context)\n-    \n+\n         def get_success_url(self):\n             return reverse(\n                 'author-detail',\n                 kwargs = {'pk': self.object.pk},\n             )\n-    \n+\n         def form_valid(self, form):\n             if not self.request.user.is_authenticated():\n                 return HttpResponseForbidden()\n@@ -588,13 +583,13 @@ using a different template.\n .. code-block:: python\n \n     from django.views.generic import View\n-    \n+\n     class AuthorDetail(View):\n-    \n+\n         def get(self, request, *args, **kwargs):\n             view = AuthorDisplay.as_view()\n             return view(request, *args, **kwargs)\n-    \n+\n         def post(self, request, *args, **kwargs):\n             view = AuthorInterest.as_view()\n             return view(request, *args, **kwargs)\n@@ -603,3 +598,88 @@ This approach can also be used with any other generic class-based\n views or your own class-based views inheriting directly from\n :class:`View` or :class:`TemplateView`, as it keeps the different\n views as separate as possible.\n+\n+.. _jsonresponsemixin-example:\n+\n+More than just HTML\n+===================\n+\n+Where class based views shine is when you want to do the same thing many times.\n+Suppose you're writing an API, and every view should return JSON instead of\n+rendered HTML.\n+\n+We can create a mixin class to use in all of our views, handling the\n+conversion to JSON once.\n+\n+For example, a simple JSON mixin might look something like this::\n+\n+    import json\n+    from django.http import HttpResponse\n+\n+    class JSONResponseMixin(object):\n+        \"\"\"\n+        A mixin that can be used to render a JSON response.\n+        \"\"\"\n+        response_class = HttpResponse\n+\n+        def render_to_response(self, context, **response_kwargs):\n+            \"\"\"\n+            Returns a JSON response, transforming 'context' to make the payload.\n+            \"\"\"\n+            response_kwargs['content_type'] = 'application/json'\n+            return self.response_class(\n+                self.convert_context_to_json(context),\n+                **response_kwargs\n+            )\n+\n+        def convert_context_to_json(self, context):\n+            \"Convert the context dictionary into a JSON object\"\n+            # Note: This is *EXTREMELY* naive; in reality, you'll need\n+            # to do much more complex handling to ensure that arbitrary\n+            # objects -- such as Django model instances or querysets\n+            # -- can be serialized as JSON.\n+            return json.dumps(context)\n+\n+Now we mix this into the base TemplateView::\n+\n+    from django.views.generic import TemplateView\n+\n+    class JSONView(JSONResponseMixin, TemplateView):\n+        pass\n+\n+Equally we could use our mixin with one of the generic views. We can make our\n+own version of :class:`~django.views.generic.detail.DetailView` by mixing\n+:class:`JSONResponseMixin` with the\n+:class:`~django.views.generic.detail.BaseDetailView` -- (the\n+:class:`~django.views.generic.detail.DetailView` before template\n+rendering behavior has been mixed in)::\n+\n+    class JSONDetailView(JSONResponseMixin, BaseDetailView):\n+        pass\n+\n+This view can then be deployed in the same way as any other\n+:class:`~django.views.generic.detail.DetailView`, with exactly the\n+same behavior -- except for the format of the response.\n+\n+If you want to be really adventurous, you could even mix a\n+:class:`~django.views.generic.detail.DetailView` subclass that is able\n+to return *both* HTML and JSON content, depending on some property of\n+the HTTP request, such as a query argument or a HTTP header. Just mix\n+in both the :class:`JSONResponseMixin` and a\n+:class:`~django.views.generic.detail.SingleObjectTemplateResponseMixin`,\n+and override the implementation of :func:`render_to_response()` to defer\n+to the appropriate subclass depending on the type of response that the user\n+requested::\n+\n+    class HybridDetailView(JSONResponseMixin, SingleObjectTemplateResponseMixin, BaseDetailView):\n+        def render_to_response(self, context):\n+            # Look for a 'format=json' GET argument\n+            if self.request.GET.get('format','html') == 'json':\n+                return JSONResponseMixin.render_to_response(self, context)\n+            else:\n+                return SingleObjectTemplateResponseMixin.render_to_response(self, context)\n+\n+Because of the way that Python resolves method overloading, the local\n+``render_to_response()`` implementation will override the versions provided by\n+:class:`JSONResponseMixin` and\n+:class:`~django.views.generic.detail.SingleObjectTemplateResponseMixin`."
        }
    ],
    "stats": {
        "total": 299,
        "additions": 148,
        "deletions": 151
    }
}