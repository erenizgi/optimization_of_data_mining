{
    "author": "malcolmt",
    "message": "Extensive copy-editing and cross-referencing in the queryset API docs.\n\nBeen meaning to do this for a long time. Mostly, this is a lot of\nadditions of cross references. Within a particular section about foo() I\ndidn't cross-link foo() calls to itself, but everything else was\ncross-linked to its main documentation.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16699 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "4c8f2dca215299bcba1a1b7547452f3a3944576e",
    "files": [
        {
            "sha": "c0aa840b61b6895692b5e78ad837a6d6c848cd13",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 275,
            "deletions": 254,
            "changes": 529,
            "blob_url": "https://github.com/django/django/blob/4c8f2dca215299bcba1a1b7547452f3a3944576e/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/4c8f2dca215299bcba1a1b7547452f3a3944576e/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=4c8f2dca215299bcba1a1b7547452f3a3944576e",
            "patch": "@@ -74,7 +74,7 @@ You can evaluate a ``QuerySet`` in the following ways:\n \n       Note: *Don't* use this if all you want to do is determine if at least one\n       result exists, and don't need the actual objects. It's more efficient to\n-      use ``exists()`` (see below).\n+      use :meth:`exists() <QuerySet.exists>` (see below).\n \n .. _pickling QuerySets:\n \n@@ -119,8 +119,8 @@ described here.\n QuerySet API\n ============\n \n-Though you usually won't create one manually -- you'll go through a\n-:class:`~django.db.models.Manager` -- here's the formal declaration of a\n+Though you usually won't create one manually — you'll go through a\n+:class:`~django.db.models.Manager` — here's the formal declaration of a\n ``QuerySet``:\n \n .. class:: QuerySet([model=None, query=None, using=None])\n@@ -135,8 +135,9 @@ Though you usually won't create one manually -- you'll go through a\n \n     .. attribute:: ordered\n \n-        ``True`` if the ``QuerySet`` is ordered -- i.e. has an order_by()\n-        clause or a default ordering on the model. ``False`` otherwise.\n+\t``True`` if the ``QuerySet`` is ordered — i.e. has an\n+\t:meth:`order_by()` clause or a default ordering on the model.\n+\t``False`` otherwise.\n \n     .. attribute:: db\n \n@@ -281,7 +282,8 @@ and so on for as many models as you want to join. For example::\n \n If you try to order by a field that is a relation to another model, Django will\n use the default ordering on the related model (or order by the related model's\n-primary key if there is no ``Meta.ordering`` specified. For example::\n+primary key if there is no :attr:`Meta.ordering\n+<django.db.models.Options.ordering>` specified. For example::\n \n     Entry.objects.order_by('blog')\n \n@@ -292,23 +294,24 @@ primary key if there is no ``Meta.ordering`` specified. For example::\n ...since the ``Blog`` model has no default ordering specified.\n \n Be cautious when ordering by fields in related models if you are also using\n-``distinct()``. See the note in :meth:`distinct` for an explanation of how\n+:meth:`distinct()`. See the note in :meth:`distinct` for an explanation of how\n related model ordering can change the expected results.\n \n It is permissible to specify a multi-valued field to order the results by (for\n-example, a ``ManyToMany`` field). Normally this won't be a sensible thing to\n-do and it's really an advanced usage feature. However, if you know that your\n-queryset's filtering or available data implies that there will only be one\n-ordering piece of data for each of the main items you are selecting, the\n-ordering may well be exactly what you want to do. Use ordering on multi-valued\n-fields with care and make sure the results are what you expect.\n+example, a :class:`~django.db.models.ManyToManyField` field). Normally\n+this won't be a sensible thing to do and it's really an advanced usage\n+feature. However, if you know that your queryset's filtering or available data\n+implies that there will only be one ordering piece of data for each of the main\n+items you are selecting, the ordering may well be exactly what you want to do.\n+Use ordering on multi-valued fields with care and make sure the results are\n+what you expect.\n \n There's no way to specify whether ordering should be case sensitive. With\n respect to case-sensitivity, Django will order results however your database\n backend normally orders them.\n \n If you don't want any ordering to be applied to a query, not even the default\n-ordering, call ``order_by()`` with no parameters.\n+ordering, call :meth:`order_by()` with no parameters.\n \n You can tell if a query is ordered or not by checking the\n :attr:`.QuerySet.ordered` attribute, which will be ``True`` if the\n@@ -334,13 +337,12 @@ penultimate item and so on. If we had a Python sequence and looked at\n that mode of access (slicing from the end), because it's not possible to do it\n efficiently in SQL.\n \n-Also, note that ``reverse()`` should generally only be called on a\n-``QuerySet`` which has a defined ordering (e.g., when querying against\n-a model which defines a default ordering, or when using\n-``order_by()``). If no such ordering is defined for a given\n-``QuerySet``, calling ``reverse()`` on it has no real effect (the\n-ordering was undefined prior to calling ``reverse()``, and will remain\n-undefined afterward).\n+Also, note that ``reverse()`` should generally only be called on a ``QuerySet``\n+which has a defined ordering (e.g., when querying against a model which defines\n+a default ordering, or when using :meth:`order_by()`). If no such ordering is\n+defined for a given ``QuerySet``, calling ``reverse()`` on it has no real\n+effect (the ordering was undefined prior to calling ``reverse()``, and will\n+remain undefined afterward).\n \n distinct\n ~~~~~~~~\n@@ -358,30 +360,29 @@ query spans multiple tables, it's possible to get duplicate results when a\n \n .. note::\n     Any fields used in an :meth:`order_by` call are included in the SQL\n-    ``SELECT`` columns. This can sometimes lead to unexpected results when\n-    used in conjunction with ``distinct()``. If you order by fields from a\n-    related model, those fields will be added to the selected columns and they\n-    may make otherwise duplicate rows appear to be distinct. Since the extra\n-    columns don't appear in the returned results (they are only there to\n-    support ordering), it sometimes looks like non-distinct results are being\n-    returned.\n-\n-    Similarly, if you use a ``values()`` query to restrict the columns\n-    selected, the columns used in any ``order_by()`` (or default model\n+    ``SELECT`` columns. This can sometimes lead to unexpected results when used\n+    in conjunction with ``distinct()``. If you order by fields from a related\n+    model, those fields will be added to the selected columns and they may make\n+    otherwise duplicate rows appear to be distinct. Since the extra columns\n+    don't appear in the returned results (they are only there to support\n+    ordering), it sometimes looks like non-distinct results are being returned.\n+\n+    Similarly, if you use a :meth:`values()` query to restrict the columns\n+    selected, the columns used in any :meth:`order_by()` (or default model\n     ordering) will still be involved and may affect uniqueness of the results.\n \n     The moral here is that if you are using ``distinct()`` be careful about\n     ordering by related models. Similarly, when using ``distinct()`` and\n-    ``values()`` together, be careful when ordering by fields not in the\n-    ``values()`` call.\n+    :meth:`values()` together, be careful when ordering by fields not in the\n+    :meth:`values()` call.\n \n values\n ~~~~~~\n \n .. method:: values(*fields)\n \n-Returns a ``ValuesQuerySet`` -- a ``QuerySet`` that returns dictionaries when\n-used as an iterable, rather than model-instance objects.\n+Returns a ``ValuesQuerySet`` — a ``QuerySet`` subclass that returns\n+dictionaries when used as an iterable, rather than model-instance objects.\n \n Each of those dictionaries represents an object, with the keys corresponding to\n the attribute names of model objects.\n@@ -397,11 +398,11 @@ objects::\n     >>> Blog.objects.filter(name__startswith='Beatles').values()\n     [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]\n \n-``values()`` takes optional positional arguments, ``*fields``, which specify\n-field names to which the ``SELECT`` should be limited. If you specify the\n-fields, each dictionary will contain only the field keys/values for the fields\n-you specify. If you don't specify the fields, each dictionary will contain a\n-key and value for every field in the database table.\n+The ``values()`` method takes optional positional arguments, ``*fields``, which\n+specify field names to which the ``SELECT`` should be limited. If you specify\n+the fields, each dictionary will contain only the field keys/values for the\n+fields you specify. If you don't specify the fields, each dictionary will\n+contain a key and value for every field in the database table.\n \n Example::\n \n@@ -432,15 +433,15 @@ A few subtleties that are worth mentioning:\n         >>> Entry.objects.values('blog_id')\n         [{'blog_id': 1}, ...]\n \n-    * When using ``values()`` together with ``distinct()``, be aware that\n+    * When using ``values()`` together with :meth:`distinct()`, be aware that\n       ordering can affect the results. See the note in :meth:`distinct` for\n       details.\n \n-    * If you use a ``values()`` clause after an :py:meth:`extra()` call,\n-      any fields defined by a ``select`` argument in the :py:meth:`extra()`\n-      must be explicitly included in the ``values()`` call. Any\n-      :py:meth:`extra()` call made after a ``values()`` call will have its\n-      extra selected fields ignored.\n+    * If you use a ``values()`` clause after an :meth:`extra()` call,\n+      any fields defined by a ``select`` argument in the :meth:`extra()` must\n+      be explicitly included in the ``values()`` call. Any :meth:`extra()` call\n+      made after a ``values()`` call will have its extra selected fields\n+      ignored.\n \n A ``ValuesQuerySet`` is useful when you know you're only going to need values\n from a small number of the available fields and you won't need the\n@@ -488,7 +489,7 @@ values_list\n \n This is similar to ``values()`` except that instead of returning dictionaries,\n it returns tuples when iterated over. Each tuple contains the value from the\n-respective field passed into the ``values_list()`` call -- so the first item is\n+respective field passed into the ``values_list()`` call — so the first item is\n the first field, etc. For example::\n \n     >>> Entry.objects.values_list('id', 'headline')\n@@ -514,7 +515,7 @@ dates\n \n .. method:: dates(field, kind, order='ASC')\n \n-Returns a ``DateQuerySet`` -- a ``QuerySet`` that evaluates to a list of\n+Returns a ``DateQuerySet`` — a ``QuerySet`` that evaluates to a list of\n ``datetime.datetime`` objects representing all available dates of a particular\n kind within the contents of the ``QuerySet``.\n \n@@ -526,8 +527,10 @@ model.\n ``type``.\n \n     * ``\"year\"`` returns a list of all distinct year values for the field.\n-    * ``\"month\"`` returns a list of all distinct year/month values for the field.\n-    * ``\"day\"`` returns a list of all distinct year/month/day values for the field.\n+    * ``\"month\"`` returns a list of all distinct year/month values for the\n+      field.\n+    * ``\"day\"`` returns a list of all distinct year/month/day values for the\n+      field.\n \n ``order``, which defaults to ``'ASC'``, should be either ``'ASC'`` or\n ``'DESC'``. This specifies how to order the results.\n@@ -550,10 +553,10 @@ none\n \n .. method:: none()\n \n-Returns an ``EmptyQuerySet`` -- a ``QuerySet`` that always evaluates to\n-an empty list. This can be used in cases where you know that you should\n-return an empty result set and your caller is expecting a ``QuerySet``\n-object (instead of returning an empty list, for example.)\n+Returns an ``EmptyQuerySet`` — a ``QuerySet`` subclass that always evaluates to\n+an empty list. This can be used in cases where you know that you should return\n+an empty result set and your caller is expecting a ``QuerySet`` object (instead\n+of returning an empty list, for example.)\n \n Examples::\n \n@@ -565,11 +568,10 @@ all\n \n .. method:: all()\n \n-Returns a *copy* of the current ``QuerySet`` (or ``QuerySet`` subclass you\n-pass in). This can be useful in some situations where you might want to pass\n-in either a model manager or a ``QuerySet`` and do further filtering on the\n-result. You can safely call ``all()`` on either object and then you'll\n-definitely have a ``QuerySet`` to work with.\n+Returns a *copy* of the current ``QuerySet`` (or ``QuerySet`` subclass).  This\n+can be useful in situations where you might want to pass in either a model\n+manager or a ``QuerySet`` and do further filtering on the result. After calling\n+``all()`` on either object, you'll definitely have a ``QuerySet`` to work with.\n \n .. _select-related:\n \n@@ -671,23 +673,24 @@ This is also valid::\n \n ...and would also pull in the ``building`` relation.\n \n-You can refer to any ``ForeignKey`` or ``OneToOneField`` relation in\n-the list of fields passed to ``select_related``. This includes foreign\n-keys that have ``null=True`` (unlike the default ``select_related()``\n-call). It's an error to use both a list of fields and the ``depth``\n-parameter in the same ``select_related()`` call, since they are\n-conflicting options.\n+You can refer to any :class:`~django.db.models.ForeignKey` or\n+:class:`~django.db.models.OneToOneField` relation in the list of fields\n+passed to ``select_related()``. This includes foreign keys that have\n+``null=True`` (which are omitted in a no-parameter ``select_related()`` call).\n+It's an error to use both a list of fields and the ``depth`` parameter in the\n+same ``select_related()`` call; they are conflicting options.\n \n .. versionchanged:: 1.2\n \n-You can also refer to the reverse direction of a ``OneToOneFields`` in\n-the list of fields passed to ``select_related`` -- that is, you can traverse\n-a ``OneToOneField`` back to the object on which the field is defined. Instead\n-of specifying the field name, use the ``related_name`` for the field on the\n-related object.\n+You can also refer to the reverse direction of a\n+:class:`~django.db.models.OneToOneField`` in the list of fields passed to\n+``select_related`` — that is, you can traverse a\n+:class:`~django.db.models.OneToOneField` back to the object on which the field\n+is defined. Instead of specifying the field name, use the :attr:`related_name\n+<django.db.models.ForeignKey.related_name>` for the field on the related object.\n \n-``OneToOneFields`` will not be traversed in the reverse direction if you\n-are performing a depth-based ``select_related``.\n+A :class:`~django.db.models.OneToOneField` is not traversed in the reverse\n+direction if you are performing a depth-based ``select_related()`` call.\n \n extra\n ~~~~~\n@@ -696,7 +699,7 @@ extra\n \n Sometimes, the Django query syntax by itself can't easily express a complex\n ``WHERE`` clause. For these edge cases, Django provides the ``extra()``\n-``QuerySet`` modifier -- a hook for injecting specific clauses into the SQL\n+``QuerySet`` modifier — a hook for injecting specific clauses into the SQL\n generated by a ``QuerySet``.\n \n By definition, these extra lookups may not be portable to different database\n@@ -707,17 +710,17 @@ Specify one or more of ``params``, ``select``, ``where`` or ``tables``. None\n of the arguments is required, but you should use at least one of them.\n \n     * ``select``\n-        The ``select`` argument lets you put extra fields in the ``SELECT`` clause.\n-        It should be a dictionary mapping attribute names to SQL clauses to use to\n-        calculate that attribute.\n+        The ``select`` argument lets you put extra fields in the ``SELECT``\n+        clause.  It should be a dictionary mapping attribute names to SQL\n+        clauses to use to calculate that attribute.\n \n         Example::\n \n             Entry.objects.extra(select={'is_recent': \"pub_date > '2006-01-01'\"})\n \n         As a result, each ``Entry`` object will have an extra attribute,\n-        ``is_recent``, a boolean representing whether the entry's ``pub_date`` is\n-        greater than Jan. 1, 2006.\n+        ``is_recent``, a boolean representing whether the entry's ``pub_date``\n+        is greater than Jan. 1, 2006.\n \n         Django inserts the given SQL snippet directly into the ``SELECT``\n         statement, so the resulting SQL of the above example would be something\n@@ -737,26 +740,27 @@ of the arguments is required, but you should use at least one of them.\n                 },\n             )\n \n-        (In this particular case, we're exploiting the fact that the query will\n-        already contain the ``blog_blog`` table in its ``FROM`` clause.)\n+        In this particular case, we're exploiting the fact that the query will\n+        already contain the ``blog_blog`` table in its ``FROM`` clause.\n \n         The resulting SQL of the above example would be::\n \n             SELECT blog_blog.*, (SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id) AS entry_count\n             FROM blog_blog;\n \n-        Note that the parenthesis required by most database engines around\n-        subqueries are not required in Django's ``select`` clauses. Also note that\n-        some database backends, such as some MySQL versions, don't support\n+        Note that the parentheses required by most database engines around\n+        subqueries are not required in Django's ``select`` clauses. Also note\n+        that some database backends, such as some MySQL versions, don't support\n         subqueries.\n \n-        In some rare cases, you might wish to pass parameters to the SQL fragments\n-        in ``extra(select=...)``. For this purpose, use the ``select_params``\n-        parameter. Since ``select_params`` is a sequence and the ``select``\n-        attribute is a dictionary, some care is required so that the parameters\n-        are matched up correctly with the extra select pieces.  In this situation,\n-        you should use a ``django.utils.datastructures.SortedDict`` for the\n-        ``select`` value, not just a normal Python dictionary.\n+        In some rare cases, you might wish to pass parameters to the SQL\n+        fragments in ``extra(select=...)``. For this purpose, use the\n+        ``select_params`` parameter. Since ``select_params`` is a sequence and\n+        the ``select`` attribute is a dictionary, some care is required so that\n+        the parameters are matched up correctly with the extra select pieces.\n+        In this situation, you should use a\n+        :class:`django.utils.datastructures.SortedDict` for the ``select``\n+        value, not just a normal Python dictionary.\n \n         This will work, for example::\n \n@@ -771,8 +775,8 @@ of the arguments is required, but you should use at least one of them.\n         like this isn't detected. That will lead to incorrect results.\n \n     * ``where`` / ``tables``\n-        You can define explicit SQL ``WHERE`` clauses -- perhaps to perform\n-        non-explicit joins -- by using ``where``. You can manually add tables to\n+        You can define explicit SQL ``WHERE`` clauses — perhaps to perform\n+        non-explicit joins — by using ``where``. You can manually add tables to\n         the SQL ``FROM`` clause by using ``tables``.\n \n         ``where`` and ``tables`` both take a list of strings. All ``where``\n@@ -786,61 +790,62 @@ of the arguments is required, but you should use at least one of them.\n \n             SELECT * FROM blog_entry WHERE id IN (3, 4, 5, 20);\n \n-        Be careful when using the ``tables`` parameter if you're specifying\n-        tables that are already used in the query. When you add extra tables\n-        via the ``tables`` parameter, Django assumes you want that table included\n-        an extra time, if it is already included. That creates a problem,\n-        since the table name will then be given an alias. If a table appears\n-        multiple times in an SQL statement, the second and subsequent occurrences\n-        must use aliases so the database can tell them apart. If you're\n-        referring to the extra table you added in the extra ``where`` parameter\n-        this is going to cause errors.\n-\n-        Normally you'll only be adding extra tables that don't already appear in\n-        the query. However, if the case outlined above does occur, there are a few\n-        solutions. First, see if you can get by without including the extra table\n-        and use the one already in the query. If that isn't possible, put your\n-        ``extra()`` call at the front of the queryset construction so that your\n-        table is the first use of that table. Finally, if all else fails, look at\n-        the query produced and rewrite your ``where`` addition to use the alias\n-        given to your extra table. The alias will be the same each time you\n-        construct the queryset in the same way, so you can rely upon the alias\n-        name to not change.\n+\tBe careful when using the ``tables`` parameter if you're specifying\n+\ttables that are already used in the query. When you add extra tables\n+\tvia the ``tables`` parameter, Django assumes you want that table\n+\tincluded an extra time, if it is already included. That creates a\n+\tproblem, since the table name will then be given an alias. If a table\n+\tappears multiple times in an SQL statement, the second and subsequent\n+\toccurrences must use aliases so the database can tell them apart. If\n+\tyou're referring to the extra table you added in the extra ``where``\n+\tparameter this is going to cause errors.\n+\n+\tNormally you'll only be adding extra tables that don't already appear\n+\tin the query. However, if the case outlined above does occur, there are\n+\ta few solutions. First, see if you can get by without including the\n+\textra table and use the one already in the query. If that isn't\n+\tpossible, put your ``extra()`` call at the front of the queryset\n+\tconstruction so that your table is the first use of that table.\n+\tFinally, if all else fails, look at the query produced and rewrite your\n+\t``where`` addition to use the alias given to your extra table. The\n+\talias will be the same each time you construct the queryset in the same\n+\tway, so you can rely upon the alias name to not change.\n \n     * ``order_by``\n-        If you need to order the resulting queryset using some of the new fields\n-        or tables you have included via ``extra()`` use the ``order_by`` parameter\n-        to ``extra()`` and pass in a sequence of strings. These strings should\n-        either be model fields (as in the normal ``order_by()`` method on\n-        querysets), of the form ``table_name.column_name`` or an alias for a column\n-        that you specified in the ``select`` parameter to ``extra()``.\n+\tIf you need to order the resulting queryset using some of the new\n+\tfields or tables you have included via ``extra()`` use the ``order_by``\n+\tparameter to ``extra()`` and pass in a sequence of strings. These\n+\tstrings should either be model fields (as in the normal\n+\t:meth:`order_by()` method on querysets), of the form\n+\t``table_name.column_name`` or an alias for a column that you specified\n+\tin the ``select`` parameter to ``extra()``.\n \n         For example::\n \n             q = Entry.objects.extra(select={'is_recent': \"pub_date > '2006-01-01'\"})\n             q = q.extra(order_by = ['-is_recent'])\n \n-        This would sort all the items for which ``is_recent`` is true to the front\n-        of the result set (``True`` sorts before ``False`` in a descending\n-        ordering).\n+\tThis would sort all the items for which ``is_recent`` is true to the\n+\tfront of the result set (``True`` sorts before ``False`` in a\n+\tdescending ordering).\n \n-        This shows, by the way, that you can make multiple calls to\n-        ``extra()`` and it will behave as you expect (adding new constraints each\n-        time).\n+\tThis shows, by the way, that you can make multiple calls to ``extra()``\n+\tand it will behave as you expect (adding new constraints each time).\n \n     * ``params``\n-        The ``where`` parameter described above may use standard Python database\n-        string placeholders -- ``'%s'`` to indicate parameters the database engine\n-        should automatically quote. The ``params`` argument is a list of any extra\n-        parameters to be substituted.\n+\tThe ``where`` parameter described above may use standard Python\n+\tdatabase string placeholders — ``'%s'`` to indicate parameters the\n+\tdatabase engine should automatically quote. The ``params`` argument is\n+\ta list of any extra parameters to be substituted.\n \n         Example::\n \n             Entry.objects.extra(where=['headline=%s'], params=['Lennon'])\n \n-        Always use ``params`` instead of embedding values directly into ``where``\n-        because ``params`` will ensure values are quoted correctly according to\n-        your particular backend. (For example, quotes will be escaped correctly.)\n+\tAlways use ``params`` instead of embedding values directly into\n+\t``where`` because ``params`` will ensure values are quoted correctly\n+\taccording to your particular backend. For example, quotes will be\n+\tescaped correctly.\n \n         Bad::\n \n@@ -858,9 +863,9 @@ defer\n In some complex data-modeling situations, your models might contain a lot of\n fields, some of which could contain a lot of data (for example, text fields),\n or require expensive processing to convert them to Python objects. If you are\n-using the results of a queryset in some situation where you know you don't\n-need those particular fields, you can tell Django not to retrieve them from\n-the database.\n+using the results of a queryset in some situation where you know you don't know\n+if you need those particular fields when you initially fetch the data, you can\n+tell Django not to retrieve them from the database.\n \n This is done by passing the names of the fields to not load to ``defer()``::\n \n@@ -881,7 +886,7 @@ Calling ``defer()`` with a field name that has already been deferred is\n harmless (the field will still be deferred).\n \n You can defer loading of fields in related models (if the related models are\n-loading via ``select_related()``) by using the standard double-underscore\n+loading via :meth:`select_related()`) by using the standard double-underscore\n notation to separate related fields::\n \n     Blog.objects.select_related().defer(\"entry__headline\", \"entry__body\")\n@@ -894,19 +899,17 @@ to ``defer()``::\n \n Some fields in a model won't be deferred, even if you ask for them. You can\n never defer the loading of the primary key. If you are using\n-``select_related()`` to retrieve other models at the same time you shouldn't\n-defer the loading of the field that connects from the primary model to the\n-related one (at the moment, that doesn't raise an error, but it will\n-eventually).\n+:meth:`select_related()` to retrieve related models, you shouldn't defer the\n+loading of the field that connects from the primary model to the related one\n+(at the moment, that doesn't raise an error, but it will eventually).\n \n .. note::\n \n-    The ``defer()`` method (and its cousin, ``only()``, below) are only for\n-    advanced use-cases. They provide an optimization for when you have\n-    analyzed your queries closely and understand *exactly* what information\n-    you need and have measured that the difference between returning the\n-    fields you need and the full set of fields for the model will be\n-    significant.\n+    The ``defer()`` method (and its cousin, :meth:`only()`, below) are only for\n+    advanced use-cases. They provide an optimization for when you have analyzed\n+    your queries closely and understand *exactly* what information you need and\n+    have measured that the difference between returning the fields you need and\n+    the full set of fields for the model will be significant.\n \n     Even if you think you are in the advanced use-case situation, **only use\n     defer() when you cannot, at queryset load time, determine if you will need\n@@ -915,25 +918,25 @@ eventually).\n     normalize your models and put the non-loaded data into a separate model\n     (and database table). If the columns *must* stay in the one table for some\n     reason, create a model with ``Meta.managed = False`` (see the\n-    :py:attr:`managed attribute <django.db.models.Options.managed>`\n-    documentation) containing just the fields you normally need to load and use\n-    that where you might otherwise call ``defer()``. This makes your code more\n-    explicit to the reader, is slightly faster and consumes a little less\n-    memory in the Python process.\n+    :attr:`managed attribute <django.db.models.Options.managed>` documentation)\n+    containing just the fields you normally need to load and use that where you\n+    might otherwise call ``defer()``. This makes your code more explicit to the\n+    reader, is slightly faster and consumes a little less memory in the Python\n+    process.\n \n \n only\n ~~~~\n \n .. method:: only(*fields)\n \n-The ``only()`` method is more or less the opposite of ``defer()``. You\n-call it with the fields that should *not* be deferred when retrieving a model.\n-If you have a model where almost all the fields need to be deferred, using\n-``only()`` to specify the complementary set of fields could result in simpler\n+The ``only()`` method is more or less the opposite of :meth:`defer()`. You call\n+it with the fields that should *not* be deferred when retrieving a model.  If\n+you have a model where almost all the fields need to be deferred, using\n+``only()`` to specify the complementary set of fields can result in simpler\n code.\n \n-If you have a model with fields ``name``, ``age`` and ``biography``, the\n+Suppose you have a model with fields ``name``, ``age`` and ``biography``. The\n following two querysets are the same, in terms of deferred fields::\n \n     Person.objects.defer(\"age\", \"biography\")\n@@ -958,7 +961,7 @@ logically::\n     # existing set of fields).\n     Entry.objects.defer(\"body\").only(\"headline\", \"body\")\n \n-All of the cautions in the note for the :py:meth:`defer` documentation apply to\n+All of the cautions in the note for the :meth:`defer` documentation apply to\n ``only()`` as well. Use it cautiously and only after exhausting your other\n options.\n \n@@ -1004,21 +1007,23 @@ Usually, if another transaction has already acquired a lock on one of the\n selected rows, the query will block until the lock is released. If this is\n not the behavior you want, call ``select_for_update(nowait=True)``. This will\n make the call non-blocking. If a conflicting lock is already acquired by\n-another transaction, ``django.db.utils.DatabaseError`` will be raised when\n-the queryset is evaluated.\n+another transaction, :exc:`~django.db.DatabaseError` will be raised when the\n+queryset is evaluated.\n \n-Note that using ``select_for_update`` will cause the current transaction to be\n-set dirty, if under transaction management. This is to ensure that Django issues\n-a ``COMMIT`` or ``ROLLBACK``, releasing any locks held by the ``SELECT FOR\n-UPDATE``.\n+Note that using ``select_for_update()`` will cause the current transaction to be\n+considered dirty, if under transaction management. This is to ensure that\n+Django issues a ``COMMIT`` or ``ROLLBACK``, releasing any locks held by the\n+``SELECT FOR UPDATE``.\n \n-Currently, the ``postgresql_psycopg2``, ``oracle``, and ``mysql``\n-database backends support ``select_for_update()``. However, MySQL has no\n-support for the ``nowait`` argument.\n+Currently, the ``postgresql_psycopg2``, ``oracle``, and ``mysql`` database\n+backends support ``select_for_update()``. However, MySQL has no support for the\n+``nowait`` argument. Obviously, users of external third-party backends should\n+check with their backend's documentation for specifics in those cases.\n \n Passing ``nowait=True`` to ``select_for_update`` using database backends that\n-do not support ``nowait``, such as MySQL, will cause a ``DatabaseError`` to be\n-raised. This is in order to prevent code unexpectedly blocking.\n+do not support ``nowait``, such as MySQL, will cause a\n+:exc:`~django.db.DatabaseError` to be raised. This is in order to prevent code\n+unexpectedly blocking.\n \n Using ``select_for_update`` on backends which do not support\n ``SELECT ... FOR UPDATE`` (such as SQLite) will have no effect.\n@@ -1040,19 +1045,20 @@ get\n Returns the object matching the given lookup parameters, which should be in\n the format described in `Field lookups`_.\n \n-``get()`` raises ``MultipleObjectsReturned`` if more than one object was\n-found. The ``MultipleObjectsReturned`` exception is an attribute of the model\n-class.\n+``get()`` raises :exc:`~django.core.exceptions.MultipleObjectsReturned` if more\n+than one object was found. The\n+:exc:`~django.core.excpetions.MultipleObjectsReturned` exception is an\n+attribute of the model class.\n \n-``get()`` raises a ``DoesNotExist`` exception if an object wasn't found for\n-the given parameters. This exception is also an attribute of the model class.\n-Example::\n+``get()`` raises a :exc:`~django.core.exceptions.DoesNotExist` exception if an\n+object wasn't found for the given parameters. This exception is also an\n+attribute of the model class. Example::\n \n     Entry.objects.get(id='foo') # raises Entry.DoesNotExist\n \n-The ``DoesNotExist`` exception inherits from\n-``django.core.exceptions.ObjectDoesNotExist``, so you can target multiple\n-``DoesNotExist`` exceptions. Example::\n+The :exc:`~django.core.exceptions.DoesNotExist` exception inherits from\n+:exc:`django.core.exceptions.ObjectDoesNotExist`, so you can target multiple\n+:exc:`~django.core.exceptions.DoesNotExist` exceptions. Example::\n \n     from django.core.exceptions import ObjectDoesNotExist\n     try:\n@@ -1082,8 +1088,8 @@ elsewhere, but all it means is that a new object will always be created.\n Normally you won't need to worry about this. However, if your model contains a\n manual primary key value that you set and if that value already exists in the\n database, a call to ``create()`` will fail with an\n-:exc:`~django.db.IntegrityError` since primary keys must be unique. So remember\n-to be prepared to handle the exception if you are using manual primary keys.\n+:exc:`~django.db.IntegrityError` since primary keys must be unique. Be\n+prepared to handle the exception if you are using manual primary keys.\n \n get_or_create\n ~~~~~~~~~~~~~\n@@ -1112,12 +1118,12 @@ The above example can be rewritten using ``get_or_create()`` like so::\n     obj, created = Person.objects.get_or_create(first_name='John', last_name='Lennon',\n                       defaults={'birthday': date(1940, 10, 9)})\n \n-Any keyword arguments passed to ``get_or_create()`` -- *except* an optional one\n-called ``defaults`` -- will be used in a ``get()`` call. If an object is found,\n-``get_or_create()`` returns a tuple of that object and ``False``. If an object\n-is *not* found, ``get_or_create()`` will instantiate and save a new object,\n-returning a tuple of the new object and ``True``. The new object will be\n-created roughly according to this algorithm::\n+Any keyword arguments passed to ``get_or_create()`` — *except* an optional one\n+called ``defaults`` — will be used in a :meth:`get()` call. If an object is\n+found, ``get_or_create()`` returns a tuple of that object and ``False``. If an\n+object is *not* found, ``get_or_create()`` will instantiate and save a new\n+object, returning a tuple of the new object and ``True``. The new object will\n+be created roughly according to this algorithm::\n \n     defaults = kwargs.pop('defaults', {})\n     params = dict([(k, v) for k, v in kwargs.items() if '__' not in k])\n@@ -1139,11 +1145,10 @@ If you have a field named ``defaults`` and want to use it as an exact lookup in\n \n     Foo.objects.get_or_create(defaults__exact='bar', defaults={'defaults': 'baz'})\n \n-\n-The ``get_or_create()`` method has similar error behavior to ``create()``\n-when you are using manually specified primary keys. If an object needs to be\n-created and the key already exists in the database, an ``IntegrityError`` will\n-be raised.\n+The ``get_or_create()`` method has similar error behavior to :meth:`create()`\n+when you're using manually specified primary keys. If an object needs to be\n+created and the key already exists in the database, an\n+:exc:`~django.db.IntegrityError` will be raised.\n \n Finally, a word on using ``get_or_create()`` in Django views. As mentioned\n earlier, ``get_or_create()`` is mostly useful in scripts that need to parse\n@@ -1161,7 +1166,7 @@ count\n .. method:: count()\n \n Returns an integer representing the number of objects in the database matching\n-the ``QuerySet``. ``count()`` never raises exceptions.\n+the ``QuerySet``. The ``count()`` method never raises exceptions.\n \n Example::\n \n@@ -1171,8 +1176,8 @@ Example::\n     # Returns the number of entries whose headline contains 'Lennon'\n     Entry.objects.filter(headline__contains='Lennon').count()\n \n-``count()`` performs a ``SELECT COUNT(*)`` behind the scenes, so you should\n-always use ``count()`` rather than loading all of the record into Python\n+A ``count()`` call performs a ``SELECT COUNT(*)`` behind the scenes, so you\n+should always use ``count()`` rather than loading all of the record into Python\n objects and calling ``len()`` on the result (unless you need to load the\n objects into memory anyway, in which case ``len()`` will be faster).\n \n@@ -1205,16 +1210,17 @@ iterator\n \n .. method:: iterator()\n \n-Evaluates the ``QuerySet`` (by performing the query) and returns an\n-`iterator`_ over the results. A ``QuerySet`` typically caches its\n-results internally so that repeated evaluations do not result in\n-additional queries; ``iterator()`` will instead read results directly,\n-without doing any caching at the ``QuerySet`` level. For a\n-``QuerySet`` which returns a large number of objects, this often\n-results in better performance and a significant reduction in memory\n+Evaluates the ``QuerySet`` (by performing the query) and returns an `iterator`_\n+over the results. A ``QuerySet`` typically caches its results internally so\n+that repeated evaluations do not result in additional queries. In contrast,\n+``iterator()`` will read results directly, without doing any caching at the\n+``QuerySet`` level (internally, the default iterator calls ``iterator()`` and\n+caches the return value). For a ``QuerySet`` which returns a large number of\n+objects that you only need to access once, this can results in better\n+performance and a significant reduction in memory.\n \n-Note that using ``iterator()`` on a ``QuerySet`` which has already\n-been evaluated will force it to evaluate again, repeating the query.\n+Note that using ``iterator()`` on a ``QuerySet`` which has already been\n+evaluated will force it to evaluate again, repeating the query.\n \n .. _iterator: http://www.python.org/dev/peps/pep-0234/\n \n@@ -1231,12 +1237,14 @@ This example returns the latest ``Entry`` in the table, according to the\n \n     Entry.objects.latest('pub_date')\n \n-If your model's ``Meta`` specifies ``get_latest_by``, you can leave off the\n-``field_name`` argument to ``latest()``. Django will use the field specified in\n-``get_latest_by`` by default.\n+If your model's :ref:`Meta <meta-options>` specifies\n+:attr:`~django.db.models.Options.get_latest_by`, you can leave off the\n+``field_name`` argument to ``latest()``. Django will use the field specified\n+in :attr:`~django.db.models.Options.get_latest_by` by default.\n \n-Like ``get()``, ``latest()`` raises ``DoesNotExist`` if an object doesn't\n-exist with the given parameters.\n+Like :meth:`get()`, ``latest()`` raises\n+:exc:`~django.core.exceptions.DoesNotExist` if there is no object with the given\n+parameters.\n \n Note ``latest()`` exists purely for convenience and readability.\n \n@@ -1245,20 +1253,20 @@ aggregate\n \n .. method:: aggregate(*args, **kwargs)\n \n-Returns a dictionary of aggregate values (averages, sums, etc) calculated\n-over the ``QuerySet``. Each argument to ``aggregate()`` specifies\n-a value that will be included in the dictionary that is returned.\n+Returns a dictionary of aggregate values (averages, sums, etc) calculated over\n+the ``QuerySet``. Each argument to ``aggregate()`` specifies a value that will\n+be included in the dictionary that is returned.\n \n-The aggregation functions that are provided by Django are described\n-in `Aggregation Functions`_ below.\n+The aggregation functions that are provided by Django are described in\n+`Aggregation Functions`_ below.\n \n-Aggregates specified using keyword arguments will use the keyword as\n-the name for the annotation. Anonymous arguments will have an name\n-generated for them based upon the name of the aggregate function and\n-the model field that is being aggregated.\n+Aggregates specified using keyword arguments will use the keyword as the name\n+for the annotation. Anonymous arguments will have a name generated for them\n+based upon the name of the aggregate function and the model field that is being\n+aggregated.\n \n-For example, if you were manipulating blog entries, you may want to know\n-the number of authors that have contributed blog entries::\n+For example, when you are working with blog entries, you may want to know the\n+number of authors that have contributed blog entries::\n \n     >>> q = Blog.objects.aggregate(Count('entry'))\n     {'entry__count': 16}\n@@ -1283,10 +1291,11 @@ Returns ``True`` if the :class:`.QuerySet` contains any results, and ``False``\n if not. This tries to perform the query in the simplest and fastest way\n possible, but it *does* execute nearly the same query. This means that calling\n :meth:`.QuerySet.exists` is faster than ``bool(some_query_set)``, but not by\n-a large degree.  If ``some_query_set`` has not yet been evaluated, but you know\n+a large degree. If ``some_query_set`` has not yet been evaluated, but you know\n that it will be at some point, then using ``some_query_set.exists()`` will do\n-more overall work (an additional query) than simply using\n-``bool(some_query_set)``.\n+more overall work (one query for the existence check plus an extra one to later\n+retrieve the results) than simply using ``bool(some_query_set)``, which\n+retrieves the results and then checks if any were returned.\n \n update\n ~~~~~~\n@@ -1303,7 +1312,7 @@ you could do this::\n \n (This assumes your ``Entry`` model has fields ``pub_date`` and ``comments_on``.)\n \n-You can update multiple fields -- there's no limit on how many. For example,\n+You can update multiple fields — there's no limit on how many. For example,\n here we update the ``comments_on`` and ``headline`` fields::\n \n     >>> Entry.objects.filter(pub_date__year=2010).update(comments_on=False, headline='This is old')\n@@ -1333,8 +1342,8 @@ The ``update()`` method returns the number of affected rows::\n     132\n \n If you're just updating a record and don't need to do anything with the model\n-object, you should use ``update()`` rather than loading the model object into\n-memory. The former is more efficient. For example, instead of doing this::\n+object, the most efficient approach is to call ``update()``, rather than\n+loading the model object into memory. For example, instead of doing this::\n \n     e = Entry.objects.get(id=10)\n     e.comments_on = False\n@@ -1344,15 +1353,18 @@ memory. The former is more efficient. For example, instead of doing this::\n \n     Entry.objects.filter(id=10).update(comments_on=False)\n \n-Using ``update()`` instead of loading the object into memory also prevents a\n-race condition where something might change in your database in the short\n-period of time between loading the object and calling ``save()``.\n+Using ``update()`` also prevents a race condition wherein something might\n+change in your database in the short period of time between loading the object\n+and calling ``save()``.\n \n-Finally, note that the ``update()`` method does an update at the SQL level and,\n-thus, does not call any ``save()`` methods on your models, nor does it emit the\n-``pre_save`` or ``post_save`` signals (which are a consequence of calling\n-``save()``). If you want to update a bunch of records for a model that has a\n-custom ``save()`` method, loop over them and call ``save()``, like this::\n+Finally, realize that ``update()`` does an update at the SQL level and, thus,\n+does not call any ``save()`` methods on your models, nor does it emit the\n+:attr:`~django.db.models.signals.pre_save` or\n+:attr:`~django.db.models.signals.post_save` signals (which are a consequence of\n+calling :meth:`Model.save() <~django.db.models.Model.save()>`). If you want to\n+update a bunch of records for a model that has a custom\n+:meth:`~django.db.models.Model.save()`` method, loop over them and call\n+:meth:`~django.db.models.Model.save()`, like this::\n \n     for e in Entry.objects.filter(pub_date__year=2010):\n         e.comments_on = False\n@@ -1376,7 +1388,7 @@ For example, to delete all the entries in a particular blog::\n     >>> Entry.objects.filter(blog=b).delete()\n \n By default, Django's :class:`~django.db.models.ForeignKey` emulates the SQL\n-constraint ``ON DELETE CASCADE`` -- in other words, any objects with foreign\n+constraint ``ON DELETE CASCADE`` — in other words, any objects with foreign\n keys pointing at the objects to be deleted will be deleted along with them.\n For example::\n \n@@ -1401,18 +1413,19 @@ Field lookups\n -------------\n \n Field lookups are how you specify the meat of an SQL ``WHERE`` clause. They're\n-specified as keyword arguments to the ``QuerySet`` methods ``filter()``,\n-``exclude()`` and ``get()``.\n+specified as keyword arguments to the ``QuerySet`` methods :meth:`filter()`,\n+:meth:`exclude()` and :meth:`get()`.\n \n-For an introduction, see :ref:`field-lookups-intro`.\n+For an introduction, see :ref:`models and database queries documentation\n+<field-lookups-intro>`.\n \n .. fieldlookup:: exact\n \n exact\n ~~~~~\n \n-Exact match. If the value provided for comparison is ``None``, it will\n-be interpreted as an SQL ``NULL`` (See isnull_ for more details).\n+Exact match. If the value provided for comparison is ``None``, it will be\n+interpreted as an SQL ``NULL`` (see :lookup:`isnull` for more details).\n \n Examples::\n \n@@ -1473,8 +1486,8 @@ SQL equivalent::\n \n     SELECT ... WHERE headline LIKE '%Lennon%';\n \n-Note this will match the headline ``'Today Lennon honored'`` but not\n-``'today lennon honored'``.\n+Note this will match the headline ``'Lennon honored today'`` but not ``'lennon\n+honored today'``.\n \n .. admonition:: SQLite users\n \n@@ -1667,8 +1680,11 @@ SQL equivalent::\n \n     SELECT ... WHERE headline LIKE '%cats';\n \n-SQLite doesn't support case-sensitive ``LIKE`` statements; ``endswith`` acts\n-like ``iendswith`` for SQLite.\n+.. admonition:: SQLite users\n+\n+    SQLite doesn't support case-sensitive ``LIKE`` statements; ``endswith``\n+    acts like ``iendswith`` for SQLite. Refer to the :ref:`database note\n+    <sqlite-string-matching>` documentation for more.\n \n .. fieldlookup:: iendswith\n \n@@ -1708,7 +1724,7 @@ SQL equivalent::\n \n     SELECT ... WHERE pub_date BETWEEN '2005-01-01' and '2005-03-31';\n \n-You can use ``range`` anywhere you can use ``BETWEEN`` in SQL -- for dates,\n+You can use ``range`` anywhere you can use ``BETWEEN`` in SQL — for dates,\n numbers and even characters.\n \n .. fieldlookup:: year\n@@ -1733,8 +1749,8 @@ SQL equivalent::\n month\n ~~~~~\n \n-For date/datetime fields, exact month match. Takes an integer 1 (January)\n-through 12 (December).\n+For date and datetime fields, an exact month match. Takes an integer 1\n+(January) through 12 (December).\n \n Example::\n \n@@ -1751,7 +1767,7 @@ SQL equivalent::\n day\n ~~~\n \n-For date/datetime fields, exact day match.\n+For date and datetime fields, an exact day match.\n \n Example::\n \n@@ -1771,7 +1787,7 @@ such as January 3, July 3, etc.\n week_day\n ~~~~~~~~\n \n-For date/datetime fields, a 'day of the week' match.\n+For date and datetime fields, a 'day of the week' match.\n \n Takes an integer value representing the day of week from 1 (Sunday) to 7\n (Saturday).\n@@ -1783,8 +1799,8 @@ Example::\n (No equivalent SQL code fragment is included for this lookup because\n implementation of the relevant query varies among different database engines.)\n \n-Note this will match any record with a pub_date that falls on a Monday (day 2\n-of the week), regardless of the month or year in which it occurs. Week days\n+Note this will match any record with a ``pub_date`` that falls on a Monday (day\n+2 of the week), regardless of the month or year in which it occurs. Week days\n are indexed with day 1 being Sunday and day 7 being Saturday.\n \n .. fieldlookup:: isnull\n@@ -1809,7 +1825,7 @@ search\n ~~~~~~\n \n A boolean full-text search, taking advantage of full-text indexing. This is\n-like ``contains`` but is significantly faster due to full-text indexing.\n+like :lookup:`contains` but is significantly faster due to full-text indexing.\n \n Example::\n \n@@ -1821,8 +1837,9 @@ SQL equivalent::\n \n Note this is only available in MySQL and requires direct manipulation of the\n database to add the full-text index. By default Django uses BOOLEAN MODE for\n-full text searches. `See the MySQL documentation for additional details.\n-<http://dev.mysql.com/doc/refman/5.1/en/fulltext-boolean.html>`_\n+full text searches. See the `MySQL documentation`_ for additional details.\n+\n+.. _MySQL documentation: http://dev.mysql.com/doc/refman/5.1/en/fulltext-boolean.html>\n \n \n .. fieldlookup:: regex\n@@ -1986,6 +2003,10 @@ Variance\n \n     .. admonition:: SQLite\n \n-        SQLite doesn't provide ``Variance`` out of the box. An implementation is\n-        available as an extension module for SQLite. Consult the SQlite\n-        documentation for instructions on obtaining and installing this extension.\n+        SQLite doesn't provide ``Variance`` out of the box. An implementation\n+        is available as an extension module for SQLite. Consult the `SQlite\n+        documentation`_ for instructions on obtaining and installing this\n+        extension.\n+\n+.. _SQLite documentation: http://www.sqlite.org/contrib\n+"
        }
    ],
    "stats": {
        "total": 529,
        "additions": 275,
        "deletions": 254
    }
}