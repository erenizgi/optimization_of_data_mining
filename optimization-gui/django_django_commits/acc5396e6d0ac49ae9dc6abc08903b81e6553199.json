{
    "author": "aaugustin",
    "message": "Fixed #19519 -- Fired request_finished in the WSGI iterable's close().",
    "sha": "acc5396e6d0ac49ae9dc6abc08903b81e6553199",
    "files": [
        {
            "sha": "a9fa09442903ab17222d7a5f00de884b32927606",
            "filename": "django/core/handlers/wsgi.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/acc5396e6d0ac49ae9dc6abc08903b81e6553199/django%2Fcore%2Fhandlers%2Fwsgi.py",
            "raw_url": "https://github.com/django/django/raw/acc5396e6d0ac49ae9dc6abc08903b81e6553199/django%2Fcore%2Fhandlers%2Fwsgi.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fhandlers%2Fwsgi.py?ref=acc5396e6d0ac49ae9dc6abc08903b81e6553199",
            "patch": "@@ -253,8 +253,8 @@ def __call__(self, environ, start_response):\n             response = http.HttpResponseBadRequest()\n         else:\n             response = self.get_response(request)\n-        finally:\n-            signals.request_finished.send(sender=self.__class__)\n+\n+        response._handler_class = self.__class__\n \n         try:\n             status_text = STATUS_CODE_TEXT[response.status_code]"
        },
        {
            "sha": "48a401adcb700f55611ae3b8810ce3368539db9f",
            "filename": "django/http/response.py",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/acc5396e6d0ac49ae9dc6abc08903b81e6553199/django%2Fhttp%2Fresponse.py",
            "raw_url": "https://github.com/django/django/raw/acc5396e6d0ac49ae9dc6abc08903b81e6553199/django%2Fhttp%2Fresponse.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2Fresponse.py?ref=acc5396e6d0ac49ae9dc6abc08903b81e6553199",
            "patch": "@@ -10,6 +10,7 @@\n     from urlparse import urlparse\n \n from django.conf import settings\n+from django.core import signals\n from django.core import signing\n from django.core.exceptions import SuspiciousOperation\n from django.http.cookie import SimpleCookie\n@@ -40,6 +41,9 @@ def __init__(self, content_type=None, status=None, mimetype=None):\n         self._headers = {}\n         self._charset = settings.DEFAULT_CHARSET\n         self._closable_objects = []\n+        # This parameter is set by the handler. It's necessary to preserve the\n+        # historical behavior of request_finished.\n+        self._handler_class = None\n         if mimetype:\n             warnings.warn(\"Using mimetype keyword argument is deprecated, use\"\n                           \" content_type instead\",\n@@ -226,7 +230,11 @@ def __next__(self):\n     # See http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html\n     def close(self):\n         for closable in self._closable_objects:\n-            closable.close()\n+            try:\n+                closable.close()\n+            except Exception:\n+                pass\n+        signals.request_finished.send(sender=self._handler_class)\n \n     def write(self, content):\n         raise Exception(\"This %s instance is not writable\" % self.__class__.__name__)"
        },
        {
            "sha": "77d4de05248c648e5c87fc1376ff6b17b7eb3377",
            "filename": "django/test/client.py",
            "status": "modified",
            "additions": 22,
            "deletions": 13,
            "changes": 35,
            "blob_url": "https://github.com/django/django/blob/acc5396e6d0ac49ae9dc6abc08903b81e6553199/django%2Ftest%2Fclient.py",
            "raw_url": "https://github.com/django/django/raw/acc5396e6d0ac49ae9dc6abc08903b81e6553199/django%2Ftest%2Fclient.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Fclient.py?ref=acc5396e6d0ac49ae9dc6abc08903b81e6553199",
            "patch": "@@ -26,7 +26,6 @@\n from django.utils.importlib import import_module\n from django.utils.itercompat import is_iterable\n from django.utils import six\n-from django.db import close_connection\n from django.test.utils import ContextList\n \n __all__ = ('Client', 'RequestFactory', 'encode_file', 'encode_multipart')\n@@ -72,6 +71,14 @@ def write(self, content):\n         self.__len += len(content)\n \n \n+def closing_iterator_wrapper(iterable, close):\n+    try:\n+        for item in iterable:\n+            yield item\n+    finally:\n+        close()\n+\n+\n class ClientHandler(BaseHandler):\n     \"\"\"\n     A HTTP Handler that can be used for testing purposes.\n@@ -92,18 +99,20 @@ def __call__(self, environ):\n             self.load_middleware()\n \n         signals.request_started.send(sender=self.__class__)\n-        try:\n-            request = WSGIRequest(environ)\n-            # sneaky little hack so that we can easily get round\n-            # CsrfViewMiddleware.  This makes life easier, and is probably\n-            # required for backwards compatibility with external tests against\n-            # admin views.\n-            request._dont_enforce_csrf_checks = not self.enforce_csrf_checks\n-            response = self.get_response(request)\n-        finally:\n-            signals.request_finished.disconnect(close_connection)\n-            signals.request_finished.send(sender=self.__class__)\n-            signals.request_finished.connect(close_connection)\n+        request = WSGIRequest(environ)\n+        # sneaky little hack so that we can easily get round\n+        # CsrfViewMiddleware.  This makes life easier, and is probably\n+        # required for backwards compatibility with external tests against\n+        # admin views.\n+        request._dont_enforce_csrf_checks = not self.enforce_csrf_checks\n+        response = self.get_response(request)\n+        # We're emulating a WSGI server; we must call the close method\n+        # on completion.\n+        if response.streaming:\n+            response.streaming_content = closing_iterator_wrapper(\n+                response.streaming_content, response.close)\n+        else:\n+            response.close()\n \n         return response\n "
        },
        {
            "sha": "a1ff826d6ea9f1e67f0bee01c04ea5b977a384de",
            "filename": "django/test/utils.py",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/acc5396e6d0ac49ae9dc6abc08903b81e6553199/django%2Ftest%2Futils.py",
            "raw_url": "https://github.com/django/django/raw/acc5396e6d0ac49ae9dc6abc08903b81e6553199/django%2Ftest%2Futils.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Futils.py?ref=acc5396e6d0ac49ae9dc6abc08903b81e6553199",
            "patch": "@@ -4,6 +4,8 @@\n \n from django.conf import settings, UserSettingsHolder\n from django.core import mail\n+from django.core.signals import request_finished\n+from django.db import close_connection\n from django.test.signals import template_rendered, setting_changed\n from django.template import Template, loader, TemplateDoesNotExist\n from django.template.loaders import cached\n@@ -68,8 +70,10 @@ def setup_test_environment():\n     \"\"\"Perform any global pre-test setup. This involves:\n \n         - Installing the instrumented test renderer\n-        - Set the email backend to the locmem email backend.\n+        - Setting the email backend to the locmem email backend.\n         - Setting the active locale to match the LANGUAGE_CODE setting.\n+        - Disconnecting the request_finished signal to avoid closing\n+          the database connection within tests.\n     \"\"\"\n     Template.original_render = Template._render\n     Template._render = instrumented_test_render\n@@ -81,6 +85,8 @@ def setup_test_environment():\n \n     deactivate()\n \n+    request_finished.disconnect(close_connection)\n+\n \n def teardown_test_environment():\n     \"\"\"Perform any global post-test teardown. This involves:"
        },
        {
            "sha": "a8e0ef3f5107eaad742bd4612a50e04d07165a30",
            "filename": "docs/ref/request-response.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/acc5396e6d0ac49ae9dc6abc08903b81e6553199/docs%2Fref%2Frequest-response.txt",
            "raw_url": "https://github.com/django/django/raw/acc5396e6d0ac49ae9dc6abc08903b81e6553199/docs%2Fref%2Frequest-response.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Frequest-response.txt?ref=acc5396e6d0ac49ae9dc6abc08903b81e6553199",
            "patch": "@@ -790,6 +790,8 @@ types of HTTP responses. Like ``HttpResponse``, these subclasses live in\n     :class:`~django.template.response.SimpleTemplateResponse`, and the\n     ``render`` method must itself return a valid response object.\n \n+.. _httpresponse-streaming:\n+\n StreamingHttpResponse objects\n =============================\n "
        },
        {
            "sha": "f2f1459bf025b2d4da1728eba694df8df643bedb",
            "filename": "docs/ref/signals.txt",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/acc5396e6d0ac49ae9dc6abc08903b81e6553199/docs%2Fref%2Fsignals.txt",
            "raw_url": "https://github.com/django/django/raw/acc5396e6d0ac49ae9dc6abc08903b81e6553199/docs%2Fref%2Fsignals.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fsignals.txt?ref=acc5396e6d0ac49ae9dc6abc08903b81e6553199",
            "patch": "@@ -448,6 +448,18 @@ request_finished\n \n Sent when Django finishes processing an HTTP request.\n \n+.. note::\n+\n+    When a view returns a :ref:`streaming response <httpresponse-streaming>`,\n+    this signal is sent only after the entire response is consumed by the\n+    client (strictly speaking, by the WSGI gateway).\n+\n+.. versionchanged:: 1.5\n+\n+    Before Django 1.5, this signal was fired before sending the content to the\n+    client. In order to accomodate streaming responses, it is now fired after\n+    sending the content.\n+\n Arguments sent with this signal:\n \n ``sender``"
        },
        {
            "sha": "c5e8c6192262ae152419937cc11e1146e40d9d36",
            "filename": "docs/releases/1.5.txt",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/acc5396e6d0ac49ae9dc6abc08903b81e6553199/docs%2Freleases%2F1.5.txt",
            "raw_url": "https://github.com/django/django/raw/acc5396e6d0ac49ae9dc6abc08903b81e6553199/docs%2Freleases%2F1.5.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.5.txt?ref=acc5396e6d0ac49ae9dc6abc08903b81e6553199",
            "patch": "@@ -411,6 +411,19 @@ attribute. Developers wishing to access the raw POST data for these cases,\n should use the :attr:`request.body <django.http.HttpRequest.body>` attribute\n instead.\n \n+:data:`~django.core.signals.request_finished` signal\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Django used to send the :data:`~django.core.signals.request_finished` signal\n+as soon as the view function returned a response. This interacted badly with\n+:ref:`streaming responses <httpresponse-streaming>` that delay content\n+generation.\n+\n+This signal is now sent after the content is fully consumed by the WSGI\n+gateway. This might be backwards incompatible if you rely on the signal being\n+fired before sending the response content to the client. If you do, you should\n+consider using a middleware instead.\n+\n OPTIONS, PUT and DELETE requests in the test client\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "3cab2aca57433464b2577e87ac50fac9cee62f55",
            "filename": "tests/regressiontests/handlers/tests.py",
            "status": "modified",
            "additions": 35,
            "deletions": 3,
            "changes": 38,
            "blob_url": "https://github.com/django/django/blob/acc5396e6d0ac49ae9dc6abc08903b81e6553199/tests%2Fregressiontests%2Fhandlers%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/acc5396e6d0ac49ae9dc6abc08903b81e6553199/tests%2Fregressiontests%2Fhandlers%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fhandlers%2Ftests.py?ref=acc5396e6d0ac49ae9dc6abc08903b81e6553199",
            "patch": "@@ -1,10 +1,11 @@\n from django.core.handlers.wsgi import WSGIHandler\n-from django.test import RequestFactory\n+from django.core import signals\n+from django.test import RequestFactory, TestCase\n from django.test.utils import override_settings\n from django.utils import six\n-from django.utils import unittest\n \n-class HandlerTests(unittest.TestCase):\n+\n+class HandlerTests(TestCase):\n \n     # Mangle settings so the handler will fail\n     @override_settings(MIDDLEWARE_CLASSES=42)\n@@ -27,3 +28,34 @@ def test_bad_path_info(self):\n         handler = WSGIHandler()\n         response = handler(environ, lambda *a, **k: None)\n         self.assertEqual(response.status_code, 400)\n+\n+\n+class SignalsTests(TestCase):\n+    urls = 'regressiontests.handlers.urls'\n+\n+    def setUp(self):\n+        self.signals = []\n+        signals.request_started.connect(self.register_started)\n+        signals.request_finished.connect(self.register_finished)\n+\n+    def tearDown(self):\n+        signals.request_started.disconnect(self.register_started)\n+        signals.request_finished.disconnect(self.register_finished)\n+\n+    def register_started(self, **kwargs):\n+        self.signals.append('started')\n+\n+    def register_finished(self, **kwargs):\n+        self.signals.append('finished')\n+\n+    def test_request_signals(self):\n+        response = self.client.get('/regular/')\n+        self.assertEqual(self.signals, ['started', 'finished'])\n+        self.assertEqual(response.content, b\"regular content\")\n+\n+    def test_request_signals_streaming_response(self):\n+        response = self.client.get('/streaming/')\n+        self.assertEqual(self.signals, ['started'])\n+        # Avoid self.assertContains, because it explicitly calls response.close()\n+        self.assertEqual(b''.join(response.streaming_content), b\"streaming content\")\n+        self.assertEqual(self.signals, ['started', 'finished'])"
        },
        {
            "sha": "8570f04696090aab1ae435ca2633f8a9674f1798",
            "filename": "tests/regressiontests/handlers/urls.py",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/acc5396e6d0ac49ae9dc6abc08903b81e6553199/tests%2Fregressiontests%2Fhandlers%2Furls.py",
            "raw_url": "https://github.com/django/django/raw/acc5396e6d0ac49ae9dc6abc08903b81e6553199/tests%2Fregressiontests%2Fhandlers%2Furls.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fhandlers%2Furls.py?ref=acc5396e6d0ac49ae9dc6abc08903b81e6553199",
            "patch": "@@ -0,0 +1,9 @@\n+from __future__ import unicode_literals\n+\n+from django.conf.urls import patterns, url\n+from django.http import HttpResponse, StreamingHttpResponse\n+\n+urlpatterns = patterns('',\n+    url(r'^regular/$', lambda request: HttpResponse(b\"regular content\")),\n+    url(r'^streaming/$', lambda request: StreamingHttpResponse([b\"streaming\", b\" \", b\"content\"])),\n+)"
        }
    ],
    "stats": {
        "total": 131,
        "additions": 111,
        "deletions": 20
    }
}