{
    "author": "timgraham",
    "message": "Fixed #16936 - Updated javascript for CSRF protection.\n\nThanks Idan Gazit for the patch.",
    "sha": "e376558ed257a4f8ce63779058f3d181ef49caa0",
    "files": [
        {
            "sha": "8d352ff8b2772b9262a203094552bedb0060a9a6",
            "filename": "docs/ref/contrib/csrf.txt",
            "status": "modified",
            "additions": 104,
            "deletions": 43,
            "changes": 147,
            "blob_url": "https://github.com/django/django/blob/e376558ed257a4f8ce63779058f3d181ef49caa0/docs%2Fref%2Fcontrib%2Fcsrf.txt",
            "raw_url": "https://github.com/django/django/raw/e376558ed257a4f8ce63779058f3d181ef49caa0/docs%2Fref%2Fcontrib%2Fcsrf.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fcontrib%2Fcsrf.txt?ref=e376558ed257a4f8ce63779058f3d181ef49caa0",
            "patch": "@@ -84,47 +84,94 @@ AJAX\n While the above method can be used for AJAX POST requests, it has some\n inconveniences: you have to remember to pass the CSRF token in as POST data with\n every POST request. For this reason, there is an alternative method: on each\n-XMLHttpRequest, set a custom `X-CSRFToken` header to the value of the CSRF\n+XMLHttpRequest, set a custom ``X-CSRFToken`` header to the value of the CSRF\n token. This is often easier, because many javascript frameworks provide hooks\n-that allow headers to be set on every request. In jQuery, you can use the\n-``ajaxSend`` event as follows:\n+that allow headers to be set on every request.\n+\n+As a first step, you must get the CSRF token itself. The recommended source for\n+the token is the ``csrftoken`` cookie, which will be set if you've enabled CSRF\n+protection for your views as outlined above.\n+\n+.. note::\n+\n+    The CSRF token cookie is named ``csrftoken`` by default, but you can control\n+    the cookie name via the :setting:`CSRF_COOKIE_NAME` setting.\n+\n+Acquiring the token is straightforward:\n \n .. code-block:: javascript\n \n-    jQuery(document).ajaxSend(function(event, xhr, settings) {\n-        function getCookie(name) {\n-            var cookieValue = null;\n-            if (document.cookie && document.cookie != '') {\n-                var cookies = document.cookie.split(';');\n-                for (var i = 0; i < cookies.length; i++) {\n-                    var cookie = jQuery.trim(cookies[i]);\n-                    // Does this cookie string begin with the name we want?\n-                    if (cookie.substring(0, name.length + 1) == (name + '=')) {\n-                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n-                        break;\n-                    }\n+    // using jQuery\n+    function getCookie(name) {\n+        var cookieValue = null;\n+        if (document.cookie && document.cookie != '') {\n+            var cookies = document.cookie.split(';');\n+            for (var i = 0; i < cookies.length; i++) {\n+                var cookie = jQuery.trim(cookies[i]);\n+                // Does this cookie string begin with the name we want?\n+                if (cookie.substring(0, name.length + 1) == (name + '=')) {\n+                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n+                    break;\n                 }\n             }\n-            return cookieValue;\n-        }\n-        function sameOrigin(url) {\n-            // url could be relative or scheme relative or absolute\n-            var host = document.location.host; // host + port\n-            var protocol = document.location.protocol;\n-            var sr_origin = '//' + host;\n-            var origin = protocol + sr_origin;\n-            // Allow absolute or scheme relative URLs to same origin\n-            return (url == origin || url.slice(0, origin.length + 1) == origin + '/') ||\n-                (url == sr_origin || url.slice(0, sr_origin.length + 1) == sr_origin + '/') ||\n-                // or any other URL that isn't scheme relative or absolute i.e relative.\n-                !(/^(\\/\\/|http:|https:).*/.test(url));\n-        }\n-        function safeMethod(method) {\n-            return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));\n         }\n+        return cookieValue;\n+    }\n+    var csrftoken = getCookie('csrftoken');\n+\n+The above code could be simplified by using the `jQuery cookie plugin\n+<http://plugins.jquery.com/project/Cookie>`_ to replace ``getCookie``:\n+\n+.. code-block:: javascript\n+\n+    var csrftoken = $.cookie('csrftoken');\n+\n+.. note::\n+\n+    The CSRF token is also present in the DOM, but only if explicitly included\n+    using :ttag:`csrf_token` in a template. The cookie contains the canonical\n+    token; the ``CsrfViewMiddleware`` will prefer the cookie to the token in\n+    the DOM. Regardless, you're guaranteed to have the cookie if the token is\n+    present in the DOM, so you should use the cookie!\n \n-        if (!safeMethod(settings.type) && sameOrigin(settings.url)) {\n-            xhr.setRequestHeader(\"X-CSRFToken\", getCookie('csrftoken'));\n+.. warning::\n+\n+    If your view is not rendering a template containing the :ttag:`csrf_token`\n+    template tag, Django might not set the CSRF token cookie. This is common in\n+    cases where forms are dynamically added to the page. To address this case,\n+    Django provides a view decorator which forces setting of the cookie:\n+    :func:`~django.views.decorators.csrf.ensure_csrf_cookie`.\n+\n+Finally, you'll have to actually set the header on your AJAX request, while\n+protecting the CSRF token from being sent to other domains.\n+\n+.. code-block:: javascript\n+\n+    function csrfSafeMethod(method) {\n+        // these HTTP methods do not require CSRF protection\n+        return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));\n+    }\n+    function sameOrigin(url) {\n+        // test that a given url is a same-origin URL\n+        // url could be relative or scheme relative or absolute\n+        var host = document.location.host; // host + port\n+        var protocol = document.location.protocol;\n+        var sr_origin = '//' + host;\n+        var origin = protocol + sr_origin;\n+        // Allow absolute or scheme relative URLs to same origin\n+        return (url == origin || url.slice(0, origin.length + 1) == origin + '/') ||\n+            (url == sr_origin || url.slice(0, sr_origin.length + 1) == sr_origin + '/') ||\n+            // or any other URL that isn't scheme relative or absolute i.e relative.\n+            !(/^(\\/\\/|http:|https:).*/.test(url));\n+    }\n+    $.ajaxSetup({\n+        beforeSend: function(xhr, settings) {\n+            if (!csrfSafeMethod(settings.type) && sameOrigin(settings.url)) {\n+                // Send the token to same-origin, relative URLs only.\n+                // Send the token only if the method warrants CSRF protection\n+                // Using the CSRFToken value acquired earlier\n+                xhr.setRequestHeader(\"X-CSRFToken\", csrftoken);\n+            }\n         }\n     });\n \n@@ -133,18 +180,32 @@ that allow headers to be set on every request. In jQuery, you can use the\n     Due to a bug introduced in jQuery 1.5, the example above will not work\n     correctly on that version. Make sure you are running at least jQuery 1.5.1.\n \n-Adding this to a javascript file that is included on your site will ensure that\n-AJAX POST requests that are made via jQuery will not be caught by the CSRF\n-protection.\n+You can use `settings.crossDomain <http://api.jquery.com/jQuery.ajax>`_ in\n+jQuery 1.5 and newer in order to replace the `sameOrigin` logic above:\n \n-The above code could be simplified by using the `jQuery cookie plugin\n-<http://plugins.jquery.com/project/Cookie>`_ to replace ``getCookie``, and\n-`settings.crossDomain <http://api.jquery.com/jQuery.ajax>`_ in jQuery 1.5 and\n-later to replace ``sameOrigin``.\n+.. code-block:: javascript\n+\n+    function csrfSafeMethod(method) {\n+        // these HTTP methods do not require CSRF protection\n+        return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));\n+    }\n+    $.ajaxSetup({\n+        crossDomain: false, // obviates need for sameOrigin test\n+        beforeSend: function(xhr, settings) {\n+            if (!csrfSafeMethod(settings.type)) {\n+                xhr.setRequestHeader(\"X-CSRFToken\", csrftoken);\n+            }\n+        }\n+    });\n+\n+.. note::\n+\n+    In a `security release blogpost`_, a simpler \"same origin test\" example\n+    was provided which only checked for a relative URL. The ``sameOrigin``\n+    test above supersedes that exampleâ€”it works for edge cases like\n+    scheme-relative or absolute URLs for the same domain.\n \n-In addition, if the CSRF cookie has not been sent to the client by use of\n-:ttag:`csrf_token`, you may need to ensure the client receives the cookie by\n-using :func:`~django.views.decorators.csrf.ensure_csrf_cookie`.\n+.. _security release blogpost: https://www.djangoproject.com/weblog/2011/feb/08/security/\n \n Other template engines\n ----------------------"
        }
    ],
    "stats": {
        "total": 147,
        "additions": 104,
        "deletions": 43
    }
}