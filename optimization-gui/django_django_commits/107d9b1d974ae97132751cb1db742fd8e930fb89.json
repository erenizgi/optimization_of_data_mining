{
    "author": "aaugustin",
    "message": "Added an option to disable the creation of savepoints in atomic.",
    "sha": "107d9b1d974ae97132751cb1db742fd8e930fb89",
    "files": [
        {
            "sha": "2d1de9509e82c46da3d968e3695287569e406868",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/107d9b1d974ae97132751cb1db742fd8e930fb89/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/107d9b1d974ae97132751cb1db742fd8e930fb89/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=107d9b1d974ae97132751cb1db742fd8e930fb89",
            "patch": "@@ -52,6 +52,9 @@ def __init__(self, settings_dict, alias=DEFAULT_DB_ALIAS,\n         self._dirty = False\n         # Tracks if the connection is in a transaction managed by 'atomic'\n         self.in_atomic_block = False\n+        # Tracks if the transaction should be rolled back to the next\n+        # available savepoint because of an exception in an inner block.\n+        self.needs_rollback = False\n         # List of savepoints created by 'atomic'\n         self.savepoint_ids = []\n         # Hack to provide compatibility with legacy transaction management"
        },
        {
            "sha": "be8981f968a5b9227c138592d988712951770cf8",
            "filename": "django/db/transaction.py",
            "status": "modified",
            "additions": 51,
            "deletions": 29,
            "changes": 80,
            "blob_url": "https://github.com/django/django/blob/107d9b1d974ae97132751cb1db742fd8e930fb89/django%2Fdb%2Ftransaction.py",
            "raw_url": "https://github.com/django/django/raw/107d9b1d974ae97132751cb1db742fd8e930fb89/django%2Fdb%2Ftransaction.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Ftransaction.py?ref=107d9b1d974ae97132751cb1db742fd8e930fb89",
            "patch": "@@ -188,8 +188,11 @@ class Atomic(object):\n     __exit__ commits the transaction or releases the savepoint on normal exit,\n     and rolls back the transaction or to the savepoint on exceptions.\n \n+    It's possible to disable the creation of savepoints if the goal is to\n+    ensure that some code runs within a transaction without creating overhead.\n+\n     A stack of savepoints identifiers is maintained as an attribute of the\n-    connection. None denotes a plain transaction.\n+    connection. None denotes the absence of a savepoint.\n \n     This allows reentrancy even if the same AtomicWrapper is reused. For\n     example, it's possible to define `oa = @atomic('other')` and use `@ao` or\n@@ -198,8 +201,9 @@ class Atomic(object):\n     Since database connections are thread-local, this is thread-safe.\n     \"\"\"\n \n-    def __init__(self, using):\n+    def __init__(self, using, savepoint):\n         self.using = using\n+        self.savepoint = savepoint\n \n     def _legacy_enter_transaction_management(self, connection):\n         if not connection.in_atomic_block:\n@@ -228,9 +232,15 @@ def __enter__(self):\n                 \"'atomic' cannot be used when autocommit is disabled.\")\n \n         if connection.in_atomic_block:\n-            # We're already in a transaction; create a savepoint.\n-            sid = connection.savepoint()\n-            connection.savepoint_ids.append(sid)\n+            # We're already in a transaction; create a savepoint, unless we\n+            # were told not to or we're already waiting for a rollback. The\n+            # second condition avoids creating useless savepoints and prevents\n+            # overwriting needs_rollback until the rollback is performed.\n+            if self.savepoint and not connection.needs_rollback:\n+                sid = connection.savepoint()\n+                connection.savepoint_ids.append(sid)\n+            else:\n+                connection.savepoint_ids.append(None)\n         else:\n             # We aren't in a transaction yet; create one.\n             # The usual way to start a transaction is to turn autocommit off.\n@@ -244,13 +254,23 @@ def __enter__(self):\n             else:\n                 connection.set_autocommit(False)\n             connection.in_atomic_block = True\n-            connection.savepoint_ids.append(None)\n+            connection.needs_rollback = False\n \n     def __exit__(self, exc_type, exc_value, traceback):\n         connection = get_connection(self.using)\n-        sid = connection.savepoint_ids.pop()\n-        if exc_value is None:\n-            if sid is None:\n+        if exc_value is None and not connection.needs_rollback:\n+            if connection.savepoint_ids:\n+                # Release savepoint if there is one\n+                sid = connection.savepoint_ids.pop()\n+                if sid is not None:\n+                    try:\n+                        connection.savepoint_commit(sid)\n+                    except DatabaseError:\n+                        connection.savepoint_rollback(sid)\n+                        # Remove this when the legacy transaction management goes away.\n+                        self._legacy_leave_transaction_management(connection)\n+                        raise\n+            else:\n                 # Commit transaction\n                 connection.in_atomic_block = False\n                 try:\n@@ -265,17 +285,19 @@ def __exit__(self, exc_type, exc_value, traceback):\n                         connection.autocommit = True\n                     else:\n                         connection.set_autocommit(True)\n-            else:\n-                # Release savepoint\n-                try:\n-                    connection.savepoint_commit(sid)\n-                except DatabaseError:\n-                    connection.savepoint_rollback(sid)\n-                    # Remove this when the legacy transaction management goes away.\n-                    self._legacy_leave_transaction_management(connection)\n-                    raise\n         else:\n-            if sid is None:\n+            # This flag will be set to True again if there isn't a savepoint\n+            # allowing to perform the rollback at this level.\n+            connection.needs_rollback = False\n+            if connection.savepoint_ids:\n+                # Roll back to savepoint if there is one, mark for rollback\n+                # otherwise.\n+                sid = connection.savepoint_ids.pop()\n+                if sid is None:\n+                    connection.needs_rollback = True\n+                else:\n+                    connection.savepoint_rollback(sid)\n+            else:\n                 # Roll back transaction\n                 connection.in_atomic_block = False\n                 try:\n@@ -285,9 +307,6 @@ def __exit__(self, exc_type, exc_value, traceback):\n                         connection.autocommit = True\n                     else:\n                         connection.set_autocommit(True)\n-            else:\n-                # Roll back to savepoint\n-                connection.savepoint_rollback(sid)\n \n         # Remove this when the legacy transaction management goes away.\n         self._legacy_leave_transaction_management(connection)\n@@ -301,25 +320,25 @@ def inner(*args, **kwargs):\n         return inner\n \n \n-def atomic(using=None):\n+def atomic(using=None, savepoint=True):\n     # Bare decorator: @atomic -- although the first argument is called\n     # `using`, it's actually the function being decorated.\n     if callable(using):\n-        return Atomic(DEFAULT_DB_ALIAS)(using)\n+        return Atomic(DEFAULT_DB_ALIAS, savepoint)(using)\n     # Decorator: @atomic(...) or context manager: with atomic(...): ...\n     else:\n-        return Atomic(using)\n+        return Atomic(using, savepoint)\n \n \n-def atomic_if_autocommit(using=None):\n+def atomic_if_autocommit(using=None, savepoint=True):\n     # This variant only exists to support the ability to disable transaction\n     # management entirely in the DATABASES setting. It doesn't care about the\n     # autocommit state at run time.\n     db = DEFAULT_DB_ALIAS if callable(using) else using\n     autocommit = get_connection(db).settings_dict['AUTOCOMMIT']\n \n     if autocommit:\n-        return atomic(using)\n+        return atomic(using, savepoint)\n     else:\n         # Bare decorator: @atomic_if_autocommit\n         if callable(using):\n@@ -447,18 +466,21 @@ def exiting(exc_value, using):\n \n     return _transaction_func(entering, exiting, using)\n \n-def commit_on_success_unless_managed(using=None):\n+def commit_on_success_unless_managed(using=None, savepoint=False):\n     \"\"\"\n     Transitory API to preserve backwards-compatibility while refactoring.\n \n     Once the legacy transaction management is fully deprecated, this should\n     simply be replaced by atomic_if_autocommit. Until then, it's necessary to\n     avoid making a commit where Django didn't use to, since entering atomic in\n     managed mode triggers a commmit.\n+\n+    Unlike atomic, savepoint defaults to False because that's closer to the\n+    legacy behavior.\n     \"\"\"\n     connection = get_connection(using)\n     if connection.autocommit or connection.in_atomic_block:\n-        return atomic_if_autocommit(using)\n+        return atomic_if_autocommit(using, savepoint)\n     else:\n         def entering(using):\n             pass"
        },
        {
            "sha": "d5c22e17f5636097ecd47e7066dc13e26c48cce0",
            "filename": "docs/topics/db/transactions.txt",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/107d9b1d974ae97132751cb1db742fd8e930fb89/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "raw_url": "https://github.com/django/django/raw/107d9b1d974ae97132751cb1db742fd8e930fb89/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Ftransactions.txt?ref=107d9b1d974ae97132751cb1db742fd8e930fb89",
            "patch": "@@ -89,7 +89,7 @@ Controlling transactions explicitly\n \n Django provides a single API to control database transactions.\n \n-.. function:: atomic(using=None)\n+.. function:: atomic(using=None, savepoint=True)\n \n     This function creates an atomic block for writes to the database.\n     (Atomicity is the defining property of database transactions.)\n@@ -164,6 +164,14 @@ Django provides a single API to control database transactions.\n     - releases or rolls back to the savepoint when exiting an inner block;\n     - commits or rolls back the transaction when exiting the outermost block.\n \n+    You can disable the creation of savepoints for inner blocks by setting the\n+    ``savepoint`` argument to ``False``. If an exception occurs, Django will\n+    perform the rollback when exiting the first parent block with a savepoint\n+    if there is one, and the outermost block otherwise. Atomicity is still\n+    guaranteed by the outer transaction. This option should only be used if\n+    the overhead of savepoints is noticeable. It has the drawback of breaking\n+    the error handling described above.\n+\n .. admonition:: Performance considerations\n \n     Open transactions have a performance cost for your database server. To"
        },
        {
            "sha": "42a78ad4ba5ee78e923fbf342625b84edde3bc41",
            "filename": "tests/transactions/tests.py",
            "status": "modified",
            "additions": 93,
            "deletions": 0,
            "changes": 93,
            "blob_url": "https://github.com/django/django/blob/107d9b1d974ae97132751cb1db742fd8e930fb89/tests%2Ftransactions%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/107d9b1d974ae97132751cb1db742fd8e930fb89/tests%2Ftransactions%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions%2Ftests.py?ref=107d9b1d974ae97132751cb1db742fd8e930fb89",
            "patch": "@@ -106,6 +106,44 @@ def test_nested_rollback_rollback(self):\n                 raise Exception(\"Oops, that's his first name\")\n         self.assertQuerysetEqual(Reporter.objects.all(), [])\n \n+    def test_merged_commit_commit(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with transaction.atomic(savepoint=False):\n+                Reporter.objects.create(first_name=\"Archibald\", last_name=\"Haddock\")\n+        self.assertQuerysetEqual(Reporter.objects.all(),\n+                ['<Reporter: Archibald Haddock>', '<Reporter: Tintin>'])\n+\n+    def test_merged_commit_rollback(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                with transaction.atomic(savepoint=False):\n+                    Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+        # Writes in the outer block are rolled back too.\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_merged_rollback_commit(self):\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with transaction.atomic():\n+                Reporter.objects.create(last_name=\"Tintin\")\n+                with transaction.atomic(savepoint=False):\n+                    Reporter.objects.create(last_name=\"Haddock\")\n+                raise Exception(\"Oops, that's his first name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_merged_rollback_rollback(self):\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with transaction.atomic():\n+                Reporter.objects.create(last_name=\"Tintin\")\n+                with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                    with transaction.atomic(savepoint=False):\n+                        Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+                raise Exception(\"Oops, that's his first name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n     def test_reuse_commit_commit(self):\n         atomic = transaction.atomic()\n         with atomic:\n@@ -171,6 +209,61 @@ def tearDown(self):\n         transaction.leave_transaction_management()\n \n \n+@skipUnless(connection.features.uses_savepoints,\n+        \"'atomic' requires transactions and savepoints.\")\n+class AtomicMergeTests(TransactionTestCase):\n+    \"\"\"Test merging transactions with savepoint=False.\"\"\"\n+\n+    def test_merged_outer_rollback(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with transaction.atomic(savepoint=False):\n+                Reporter.objects.create(first_name=\"Archibald\", last_name=\"Haddock\")\n+                with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                    with transaction.atomic(savepoint=False):\n+                        Reporter.objects.create(first_name=\"Tournesol\")\n+                        raise Exception(\"Oops, that's his last name\")\n+                # It wasn't possible to roll back\n+                self.assertEqual(Reporter.objects.count(), 3)\n+            # It wasn't possible to roll back\n+            self.assertEqual(Reporter.objects.count(), 3)\n+        # The outer block must roll back\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_merged_inner_savepoint_rollback(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with transaction.atomic():\n+                Reporter.objects.create(first_name=\"Archibald\", last_name=\"Haddock\")\n+                with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                    with transaction.atomic(savepoint=False):\n+                        Reporter.objects.create(first_name=\"Tournesol\")\n+                        raise Exception(\"Oops, that's his last name\")\n+                # It wasn't possible to roll back\n+                self.assertEqual(Reporter.objects.count(), 3)\n+            # The first block with a savepoint must roll back\n+            self.assertEqual(Reporter.objects.count(), 1)\n+        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])\n+\n+    def test_merged_outer_rollback_after_inner_failure_and_inner_success(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            # Inner block without a savepoint fails\n+            with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                with transaction.atomic(savepoint=False):\n+                    Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+            # It wasn't possible to roll back\n+            self.assertEqual(Reporter.objects.count(), 2)\n+            # Inner block with a savepoint succeeds\n+            with transaction.atomic(savepoint=False):\n+                Reporter.objects.create(first_name=\"Archibald\", last_name=\"Haddock\")\n+            # It still wasn't possible to roll back\n+            self.assertEqual(Reporter.objects.count(), 3)\n+        # The outer block must rollback\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+\n @skipUnless(connection.features.uses_savepoints,\n         \"'atomic' requires transactions and savepoints.\")\n class AtomicErrorsTests(TransactionTestCase):"
        }
    ],
    "stats": {
        "total": 186,
        "additions": 156,
        "deletions": 30
    }
}