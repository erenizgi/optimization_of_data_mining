{
    "author": "aaugustin",
    "message": "Made the caching of related and reverse related objects consistent in OneToOneFields. Fixed #13839. Refs #17439.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17890 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "b90d4e5b749be3b6caec8ece7729beb3876ea4b8",
    "files": [
        {
            "sha": "fbb40d9175c351d27e351675c60dc3ff6d4be149",
            "filename": "django/db/models/fields/related.py",
            "status": "modified",
            "additions": 32,
            "deletions": 23,
            "changes": 55,
            "blob_url": "https://github.com/django/django/blob/b90d4e5b749be3b6caec8ece7729beb3876ea4b8/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "raw_url": "https://github.com/django/django/raw/b90d4e5b749be3b6caec8ece7729beb3876ea4b8/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2Frelated.py?ref=b90d4e5b749be3b6caec8ece7729beb3876ea4b8",
            "patch": "@@ -249,11 +249,19 @@ def __get__(self, instance, instance_type=None):\n         if instance is None:\n             return self\n         try:\n-            return getattr(instance, self.cache_name)\n+            rel_obj = getattr(instance, self.cache_name)\n         except AttributeError:\n             params = {'%s__pk' % self.related.field.name: instance._get_pk_val()}\n-            rel_obj = self.get_query_set(instance=instance).get(**params)\n+            try:\n+                rel_obj = self.get_query_set(instance=instance).get(**params)\n+            except self.related.model.DoesNotExist:\n+                rel_obj = None\n+            else:\n+                setattr(rel_obj, self.related.field.get_cache_name(), instance)\n             setattr(instance, self.cache_name, rel_obj)\n+        if rel_obj is None:\n+            raise self.related.model.DoesNotExist\n+        else:\n             return rel_obj\n \n     def __set__(self, instance, value):\n@@ -331,24 +339,27 @@ def get_prefetch_query_set(self, instances):\n     def __get__(self, instance, instance_type=None):\n         if instance is None:\n             return self\n-\n         try:\n-            return getattr(instance, self.cache_name)\n+            rel_obj = getattr(instance, self.cache_name)\n         except AttributeError:\n             val = getattr(instance, self.field.attname)\n             if val is None:\n-                # If NULL is an allowed value, return it.\n-                if self.field.null:\n-                    return None\n-                raise self.field.rel.to.DoesNotExist\n-            other_field = self.field.rel.get_related_field()\n-            if other_field.rel:\n-                params = {'%s__pk' % self.field.rel.field_name: val}\n+                rel_obj = None\n             else:\n-                params = {'%s__exact' % self.field.rel.field_name: val}\n-            qs = self.get_query_set(instance=instance)\n-            rel_obj = qs.get(**params)\n+                other_field = self.field.rel.get_related_field()\n+                if other_field.rel:\n+                    params = {'%s__pk' % self.field.rel.field_name: val}\n+                else:\n+                    params = {'%s__exact' % self.field.rel.field_name: val}\n+                qs = self.get_query_set(instance=instance)\n+                # Assuming the database enforces foreign keys, this won't fail.\n+                rel_obj = qs.get(**params)\n+                if not self.field.rel.multiple:\n+                    setattr(rel_obj, self.field.related.get_cache_name(), instance)\n             setattr(instance, self.cache_name, rel_obj)\n+        if rel_obj is None and not self.field.null:\n+            raise self.field.rel.to.DoesNotExist\n+        else:\n             return rel_obj\n \n     def __set__(self, instance, value):\n@@ -385,17 +396,13 @@ def __set__(self, instance, value):\n             # populated the cache, then we don't care - we're only accessing\n             # the object to invalidate the accessor cache, so there's no\n             # need to populate the cache just to expire it again.\n-            related = getattr(instance, self.field.get_cache_name(), None)\n+            related = getattr(instance, self.cache_name, None)\n \n             # If we've got an old related object, we need to clear out its\n             # cache. This cache also might not exist if the related object\n             # hasn't been accessed yet.\n-            if related:\n-                cache_name = self.field.related.get_cache_name()\n-                try:\n-                    delattr(related, cache_name)\n-                except AttributeError:\n-                    pass\n+            if related is not None:\n+                setattr(related, self.field.related.get_cache_name(), None)\n \n         # Set the value of the related field\n         try:\n@@ -405,9 +412,11 @@ def __set__(self, instance, value):\n         setattr(instance, self.field.attname, val)\n \n         # Since we already know what the related object is, seed the related\n-        # object cache now, too. This avoids another db hit if you get the\n+        # object caches now, too. This avoids another db hit if you get the\n         # object you just set.\n-        setattr(instance, self.field.get_cache_name(), value)\n+        setattr(instance, self.cache_name, value)\n+        if value is not None and not self.field.rel.multiple:\n+            setattr(value, self.field.related.get_cache_name(), instance)\n \n class ForeignRelatedObjectsDescriptor(object):\n     # This class provides the functionality that makes the related-object"
        },
        {
            "sha": "eced88598b67702dfdcbb295d81a5e1ea5307af5",
            "filename": "tests/regressiontests/one_to_one_regress/tests.py",
            "status": "modified",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/django/django/blob/b90d4e5b749be3b6caec8ece7729beb3876ea4b8/tests%2Fregressiontests%2Fone_to_one_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/b90d4e5b749be3b6caec8ece7729beb3876ea4b8/tests%2Fregressiontests%2Fone_to_one_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fone_to_one_regress%2Ftests.py?ref=b90d4e5b749be3b6caec8ece7729beb3876ea4b8",
            "patch": "@@ -132,3 +132,73 @@ def test_filter_one_to_one_relations(self):\n                 Target.objects.exclude(pointer2=None),\n                 []\n         )\n+\n+    def test_reverse_object_does_not_exist_cache(self):\n+        \"\"\"\n+        Regression for #13839 and #17439.\n+\n+        DoesNotExist on a reverse one-to-one relation is cached.\n+        \"\"\"\n+        p = Place(name='Zombie Cats', address='Not sure')\n+        p.save()\n+        with self.assertNumQueries(1):\n+            with self.assertRaises(Restaurant.DoesNotExist):\n+                p.restaurant\n+        with self.assertNumQueries(0):\n+            with self.assertRaises(Restaurant.DoesNotExist):\n+                p.restaurant\n+\n+    def test_reverse_object_cached_when_related_is_accessed(self):\n+        \"\"\"\n+        Regression for #13839 and #17439.\n+\n+        The target of a one-to-one relation is cached\n+        when the origin is accessed through the reverse relation.\n+        \"\"\"\n+        # Use a fresh object without caches\n+        r = Restaurant.objects.get(pk=self.r1.pk)\n+        p = r.place\n+        with self.assertNumQueries(0):\n+            self.assertEqual(p.restaurant, r)\n+\n+    def test_related_object_cached_when_reverse_is_accessed(self):\n+        \"\"\"\n+        Regression for #13839 and #17439.\n+\n+        The origin of a one-to-one relation is cached\n+        when the target is accessed through the reverse relation.\n+        \"\"\"\n+        # Use a fresh object without caches\n+        p = Place.objects.get(pk=self.p1.pk)\n+        r = p.restaurant\n+        with self.assertNumQueries(0):\n+            self.assertEqual(r.place, p)\n+\n+    def test_reverse_object_cached_when_related_is_set(self):\n+        \"\"\"\n+        Regression for #13839 and #17439.\n+\n+        The target of a one-to-one relation is always cached.\n+        \"\"\"\n+        p = Place(name='Zombie Cats', address='Not sure')\n+        p.save()\n+        self.r1.place = p\n+        self.r1.save()\n+        with self.assertNumQueries(0):\n+            self.assertEqual(p.restaurant, self.r1)\n+\n+    def test_reverse_object_cached_when_related_is_unset(self):\n+        \"\"\"\n+        Regression for #13839 and #17439.\n+\n+        The target of a one-to-one relation is always cached.\n+        \"\"\"\n+        b = UndergroundBar(place=self.p1, serves_cocktails=True)\n+        b.save()\n+        with self.assertNumQueries(0):\n+            self.assertEqual(self.p1.undergroundbar, b)\n+        b.place = None\n+        b.save()\n+        with self.assertNumQueries(0):\n+            with self.assertRaises(UndergroundBar.DoesNotExist):\n+                self.p1.undergroundbar"
        },
        {
            "sha": "1373f047174c285d5fbf653111711bd259e64f32",
            "filename": "tests/regressiontests/select_related_onetoone/tests.py",
            "status": "modified",
            "additions": 29,
            "deletions": 1,
            "changes": 30,
            "blob_url": "https://github.com/django/django/blob/b90d4e5b749be3b6caec8ece7729beb3876ea4b8/tests%2Fregressiontests%2Fselect_related_onetoone%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/b90d4e5b749be3b6caec8ece7729beb3876ea4b8/tests%2Fregressiontests%2Fselect_related_onetoone%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fselect_related_onetoone%2Ftests.py?ref=b90d4e5b749be3b6caec8ece7729beb3876ea4b8",
            "patch": "@@ -79,4 +79,32 @@ def test_nullable_relation(self):\n         p1 = Product.objects.create(name=\"Django Plushie\", image=im)\n         p2 = Product.objects.create(name=\"Talking Django Plushie\")\n \n-        self.assertEqual(len(Product.objects.select_related(\"image\")), 2)\n+        with self.assertNumQueries(1):\n+            result = sorted(Product.objects.select_related(\"image\"), key=lambda x: x.name)\n+            self.assertEqual([p.name for p in result], [\"Django Plushie\", \"Talking Django Plushie\"])\n+\n+            self.assertEqual(p1.image, im)\n+            # Check for ticket #13839\n+            self.assertIsNone(p2.image)\n+\n+    def test_missing_reverse(self):\n+        \"\"\"\n+        Ticket #13839: select_related() should NOT cache None\n+        for missing objects on a reverse 1-1 relation.\n+        \"\"\"\n+        with self.assertNumQueries(1):\n+            user = User.objects.select_related('userprofile').get(username='bob')\n+            with self.assertRaises(UserProfile.DoesNotExist):\n+                user.userprofile\n+\n+    def test_nullable_missing_reverse(self):\n+        \"\"\"\n+        Ticket #13839: select_related() should NOT cache None\n+        for missing objects on a reverse 0-1 relation.\n+        \"\"\"\n+        Image.objects.create(name=\"imag1\")\n+\n+        with self.assertNumQueries(1):\n+            image = Image.objects.select_related('product').get()\n+            with self.assertRaises(Product.DoesNotExist):\n+                image.product"
        }
    ],
    "stats": {
        "total": 155,
        "additions": 131,
        "deletions": 24
    }
}