{
    "author": "claudep",
    "message": "Modernized contrib.gis layermapping tests.\n\nIn particular, make tests independent of each other.",
    "sha": "f1ebcdc7c2140eca632ed64296ec4e0893feb136",
    "files": [
        {
            "sha": "7e5f43c99d050b39dc26ef11378cbaba625c06a6",
            "filename": "django/contrib/gis/tests/layermap/tests.py",
            "status": "modified",
            "additions": 25,
            "deletions": 31,
            "changes": 56,
            "blob_url": "https://github.com/django/django/blob/f1ebcdc7c2140eca632ed64296ec4e0893feb136/django%2Fcontrib%2Fgis%2Ftests%2Flayermap%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/f1ebcdc7c2140eca632ed64296ec4e0893feb136/django%2Fcontrib%2Fgis%2Ftests%2Flayermap%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Ftests%2Flayermap%2Ftests.py?ref=f1ebcdc7c2140eca632ed64296ec4e0893feb136",
            "patch": "@@ -4,11 +4,11 @@\n from copy import copy\n from decimal import Decimal\n \n-from django.utils.unittest import TestCase\n-\n from django.contrib.gis.gdal import DataSource\n from django.contrib.gis.tests.utils import mysql\n-from django.contrib.gis.utils.layermapping import LayerMapping, LayerMapError, InvalidDecimal, MissingForeignKey\n+from django.contrib.gis.utils.layermapping import (LayerMapping, LayerMapError,\n+    InvalidDecimal, MissingForeignKey)\n+from django.test import TestCase\n \n from .models import (\n     City, County, CountyFeat, Interstate, ICity1, ICity2, Invalid, State,\n@@ -28,7 +28,7 @@\n \n class LayerMapTest(TestCase):\n \n-    def test01_init(self):\n+    def test_init(self):\n         \"Testing LayerMapping initialization.\"\n \n         # Model field that does not exist.\n@@ -46,22 +46,14 @@ def test01_init(self):\n         # Incrementing through the bad mapping dictionaries and\n         # ensuring that a LayerMapError is raised.\n         for bad_map in (bad1, bad2, bad3):\n-            try:\n+            with self.assertRaises(LayerMapError):\n                 lm = LayerMapping(City, city_shp, bad_map)\n-            except LayerMapError:\n-                pass\n-            else:\n-                self.fail('Expected a LayerMapError.')\n \n         # A LookupError should be thrown for bogus encodings.\n-        try:\n+        with self.assertRaises(LookupError):\n             lm = LayerMapping(City, city_shp, city_mapping, encoding='foobar')\n-        except LookupError:\n-            pass\n-        else:\n-            self.fail('Expected a LookupError')\n \n-    def test02_simple_layermap(self):\n+    def test_simple_layermap(self):\n         \"Test LayerMapping import of a simple point shapefile.\"\n         # Setting up for the LayerMapping.\n         lm = LayerMapping(City, city_shp, city_mapping)\n@@ -85,18 +77,14 @@ def test02_simple_layermap(self):\n             self.assertAlmostEqual(pnt1.x, pnt2.x, 5)\n             self.assertAlmostEqual(pnt1.y, pnt2.y, 5)\n \n-    def test03_layermap_strict(self):\n+    def test_layermap_strict(self):\n         \"Testing the `strict` keyword, and import of a LineString shapefile.\"\n         # When the `strict` keyword is set an error encountered will force\n         # the importation to stop.\n-        try:\n+        with self.assertRaises(InvalidDecimal):\n             lm = LayerMapping(Interstate, inter_shp, inter_mapping)\n             lm.save(silent=True, strict=True)\n-        except InvalidDecimal:\n-            # No transactions for geoms on MySQL; delete added features.\n-            if mysql: Interstate.objects.all().delete()\n-        else:\n-            self.fail('Should have failed on strict import with invalid decimal values.')\n+        Interstate.objects.all().delete()\n \n         # This LayerMapping should work b/c `strict` is not set.\n         lm = LayerMapping(Interstate, inter_shp, inter_mapping)\n@@ -137,7 +125,7 @@ def county_helper(self, county_feat=True):\n                 qs = CountyFeat.objects.filter(name=name)\n                 self.assertEqual(n, qs.count())\n \n-    def test04_layermap_unique_multigeometry_fk(self):\n+    def test_layermap_unique_multigeometry_fk(self):\n         \"Testing the `unique`, and `transform`, geometry collection conversion, and ForeignKey mappings.\"\n         # All the following should work.\n         try:\n@@ -176,8 +164,9 @@ def test04_layermap_unique_multigeometry_fk(self):\n         self.assertRaises(MissingForeignKey, lm.save, silent=True, strict=True)\n \n         # Now creating the state models so the ForeignKey mapping may work.\n-        co, hi, tx = State(name='Colorado'), State(name='Hawaii'), State(name='Texas')\n-        co.save(), hi.save(), tx.save()\n+        State.objects.bulk_create([\n+            State(name='Colorado'), State(name='Hawaii'), State(name='Texas')\n+        ])\n \n         # If a mapping is specified as a collection, all OGR fields that\n         # are not collections will be converted into them.  For example,\n@@ -203,16 +192,19 @@ def test04_layermap_unique_multigeometry_fk(self):\n         # The county helper is called to ensure integrity of County models.\n         self.county_helper()\n \n-    def test05_test_fid_range_step(self):\n+    def test_test_fid_range_step(self):\n         \"Tests the `fid_range` keyword and the `step` keyword of .save().\"\n         # Function for clearing out all the counties before testing.\n         def clear_counties(): County.objects.all().delete()\n \n+        State.objects.bulk_create([\n+            State(name='Colorado'), State(name='Hawaii'), State(name='Texas')\n+        ])\n+\n         # Initializing the LayerMapping object to use in these tests.\n         lm = LayerMapping(County, co_shp, co_mapping, transform=False, unique='name')\n \n         # Bad feature id ranges should raise a type error.\n-        clear_counties()\n         bad_ranges = (5.0, 'foo', co_shp)\n         for bad in bad_ranges:\n             self.assertRaises(TypeError, lm.save, fid_range=bad)\n@@ -241,8 +233,10 @@ def clear_counties(): County.objects.all().delete()\n         self.assertEqual(2, qs.count())\n         hi, co = tuple(qs)\n         hi_idx, co_idx = tuple(map(NAMES.index, ('Honolulu', 'Pueblo')))\n-        self.assertEqual('Pueblo', co.name); self.assertEqual(NUMS[co_idx], len(co.mpoly))\n-        self.assertEqual('Honolulu', hi.name); self.assertEqual(NUMS[hi_idx], len(hi.mpoly))\n+        self.assertEqual('Pueblo', co.name)\n+        self.assertEqual(NUMS[co_idx], len(co.mpoly))\n+        self.assertEqual('Honolulu', hi.name)\n+        self.assertEqual(NUMS[hi_idx], len(hi.mpoly))\n \n         # Testing the `step` keyword -- should get the same counties\n         # regardless of we use a step that divides equally, that is odd,\n@@ -252,7 +246,7 @@ def clear_counties(): County.objects.all().delete()\n             lm.save(step=st, strict=True)\n             self.county_helper(county_feat=False)\n \n-    def test06_model_inheritance(self):\n+    def test_model_inheritance(self):\n         \"Tests LayerMapping on inherited models.  See #12093.\"\n         icity_mapping = {'name' : 'Name',\n                          'population' : 'Population',\n@@ -272,7 +266,7 @@ def test06_model_inheritance(self):\n         self.assertEqual(6, ICity1.objects.count())\n         self.assertEqual(3, ICity2.objects.count())\n \n-    def test07_invalid_layer(self):\n+    def test_invalid_layer(self):\n         \"Tests LayerMapping on invalid geometries.  See #15378.\"\n         invalid_mapping = {'point': 'POINT'}\n         lm = LayerMapping(Invalid, invalid_shp, invalid_mapping,"
        }
    ],
    "stats": {
        "total": 56,
        "additions": 25,
        "deletions": 31
    }
}