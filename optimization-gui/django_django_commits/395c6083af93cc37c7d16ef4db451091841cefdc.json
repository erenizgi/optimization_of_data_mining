{
    "author": "claudep",
    "message": "Fixed #12460 -- Improved inspectdb handling of special field names\n\nThanks mihail lukin for the report and elijahr and kgibula for their\nwork on the patch.",
    "sha": "395c6083af93cc37c7d16ef4db451091841cefdc",
    "files": [
        {
            "sha": "c3c0776273614892479b897cb7e49d1f7448b6bd",
            "filename": "django/core/management/commands/inspectdb.py",
            "status": "modified",
            "additions": 78,
            "deletions": 39,
            "changes": 117,
            "blob_url": "https://github.com/django/django/blob/395c6083af93cc37c7d16ef4db451091841cefdc/django%2Fcore%2Fmanagement%2Fcommands%2Finspectdb.py",
            "raw_url": "https://github.com/django/django/raw/395c6083af93cc37c7d16ef4db451091841cefdc/django%2Fcore%2Fmanagement%2Fcommands%2Finspectdb.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Finspectdb.py?ref=395c6083af93cc37c7d16ef4db451091841cefdc",
            "patch": "@@ -1,3 +1,5 @@\n+from __future__ import unicode_literals\n+\n import keyword\n from optparse import make_option\n \n@@ -31,6 +33,7 @@ def handle_inspection(self, options):\n         table_name_filter = options.get('table_name_filter')\n \n         table2model = lambda table_name: table_name.title().replace('_', '').replace(' ', '').replace('-', '')\n+        strip_prefix = lambda s: s.startswith(\"u'\") and s[1:] or s\n \n         cursor = connection.cursor()\n         yield \"# This is an auto-generated Django model module.\"\n@@ -41,6 +44,7 @@ def handle_inspection(self, options):\n         yield \"#\"\n         yield \"# Also note: You'll have to insert the output of 'django-admin.py sqlcustom [appname]'\"\n         yield \"# into your database.\"\n+        yield \"from __future__ import unicode_literals\"\n         yield ''\n         yield 'from %s import models' % self.db_module\n         yield ''\n@@ -59,16 +63,19 @@ def handle_inspection(self, options):\n                 indexes = connection.introspection.get_indexes(cursor, table_name)\n             except NotImplementedError:\n                 indexes = {}\n+            used_column_names = [] # Holds column names used in the table so far\n             for i, row in enumerate(connection.introspection.get_table_description(cursor, table_name)):\n-                column_name = row[0]\n-                att_name = column_name.lower()\n                 comment_notes = [] # Holds Field notes, to be displayed in a Python comment.\n                 extra_params = {}  # Holds Field parameters such as 'db_column'.\n+                column_name = row[0]\n+                is_relation = i in relations\n+\n+                att_name, params, notes = self.normalize_col_name(\n+                    column_name, used_column_names, is_relation)\n+                extra_params.update(params)\n+                comment_notes.extend(notes)\n \n-                # If the column name can't be used verbatim as a Python\n-                # attribute, set the \"db_column\" for this Field.\n-                if ' ' in att_name or '-' in att_name or keyword.iskeyword(att_name) or column_name != att_name:\n-                    extra_params['db_column'] = column_name\n+                used_column_names.append(att_name)\n \n                 # Add primary_key and unique, if necessary.\n                 if column_name in indexes:\n@@ -77,30 +84,12 @@ def handle_inspection(self, options):\n                     elif indexes[column_name]['unique']:\n                         extra_params['unique'] = True\n \n-                # Modify the field name to make it Python-compatible.\n-                if ' ' in att_name:\n-                    att_name = att_name.replace(' ', '_')\n-                    comment_notes.append('Field renamed to remove spaces.')\n-\n-                if '-' in att_name:\n-                    att_name = att_name.replace('-', '_')\n-                    comment_notes.append('Field renamed to remove dashes.')\n-\n-                if column_name != att_name:\n-                    comment_notes.append('Field name made lowercase.')\n-\n-                if i in relations:\n+                if is_relation:\n                     rel_to = relations[i][1] == table_name and \"'self'\" or table2model(relations[i][1])\n-\n                     if rel_to in known_models:\n                         field_type = 'ForeignKey(%s' % rel_to\n                     else:\n                         field_type = \"ForeignKey('%s'\" % rel_to\n-\n-                    if att_name.endswith('_id'):\n-                        att_name = att_name[:-3]\n-                    else:\n-                        extra_params['db_column'] = column_name\n                 else:\n                     # Calling `get_field_type` to get the field type string and any\n                     # additional paramters and notes.\n@@ -110,16 +99,6 @@ def handle_inspection(self, options):\n \n                     field_type += '('\n \n-                if keyword.iskeyword(att_name):\n-                    att_name += '_field'\n-                    comment_notes.append('Field renamed because it was a Python reserved word.')\n-\n-                if att_name[0].isdigit():\n-                    att_name = 'number_%s' % att_name\n-                    extra_params['db_column'] = six.text_type(column_name)\n-                    comment_notes.append(\"Field renamed because it wasn't a \"\n-                        \"valid Python identifier.\")\n-\n                 # Don't output 'id = meta.AutoField(primary_key=True)', because\n                 # that's assumed if it doesn't exist.\n                 if att_name == 'id' and field_type == 'AutoField(' and extra_params == {'primary_key': True}:\n@@ -136,14 +115,74 @@ def handle_inspection(self, options):\n                 if extra_params:\n                     if not field_desc.endswith('('):\n                         field_desc += ', '\n-                    field_desc += ', '.join(['%s=%r' % (k, v) for k, v in extra_params.items()])\n+                    field_desc += ', '.join([\n+                        '%s=%s' % (k, strip_prefix(repr(v)))\n+                        for k, v in extra_params.items()])\n                 field_desc += ')'\n                 if comment_notes:\n                     field_desc += ' # ' + ' '.join(comment_notes)\n                 yield '    %s' % field_desc\n             for meta_line in self.get_meta(table_name):\n                 yield meta_line\n \n+    def normalize_col_name(self, col_name, used_column_names, is_relation):\n+        \"\"\"\n+        Modify the column name to make it Python-compatible as a field name\n+        \"\"\"\n+        field_params = {}\n+        field_notes = []\n+\n+        new_name = col_name.lower()\n+        if new_name != col_name:\n+            field_notes.append('Field name made lowercase.')\n+\n+        if is_relation:\n+            if new_name.endswith('_id'):\n+                new_name = new_name[:-3]\n+            else:\n+                field_params['db_column'] = col_name\n+\n+        if ' ' in new_name:\n+            new_name = new_name.replace(' ', '_')\n+            field_notes.append('Field renamed to remove spaces.')\n+\n+        if '-' in new_name:\n+            new_name = new_name.replace('-', '_')\n+            field_notes.append('Field renamed to remove dashes.')\n+\n+        if new_name.find('__') >= 0:\n+            while new_name.find('__') >= 0:\n+                new_name = new_name.replace('__', '_')\n+            field_notes.append(\"Field renamed because it contained more than one '_' in a row.\")\n+\n+        if new_name.startswith('_'):\n+            new_name = 'field%s' % new_name\n+            field_notes.append(\"Field renamed because it started with '_'.\")\n+\n+        if new_name.endswith('_'):\n+            new_name = '%sfield' % new_name\n+            field_notes.append(\"Field renamed because it ended with '_'.\")\n+\n+        if keyword.iskeyword(new_name):\n+            new_name += '_field'\n+            field_notes.append('Field renamed because it was a Python reserved word.')\n+\n+        if new_name[0].isdigit():\n+            new_name = 'number_%s' % new_name\n+            field_notes.append(\"Field renamed because it wasn't a valid Python identifier.\")\n+\n+        if new_name in used_column_names:\n+            num = 0\n+            while '%s_%d' % (new_name, num) in used_column_names:\n+                num += 1\n+            new_name = '%s_%d' % (new_name, num)\n+            field_notes.append('Field renamed because of name conflict.')\n+\n+        if col_name != new_name and field_notes:\n+            field_params['db_column'] = col_name\n+\n+        return new_name, field_params, field_notes\n+\n     def get_field_type(self, connection, table_name, row):\n         \"\"\"\n         Given the database connection, the table name, and the cursor row\n@@ -181,6 +220,6 @@ def get_meta(self, table_name):\n         to construct the inner Meta class for the model corresponding\n         to the given database table name.\n         \"\"\"\n-        return ['    class Meta:',\n-                '        db_table = %r' % table_name,\n-                '']\n+        return [\"    class Meta:\",\n+                \"        db_table = '%s'\" % table_name,\n+                \"\"]"
        },
        {
            "sha": "352053aafee261759a6dc450cfbdbdaaf6c7ab09",
            "filename": "tests/regressiontests/inspectdb/models.py",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/395c6083af93cc37c7d16ef4db451091841cefdc/tests%2Fregressiontests%2Finspectdb%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/395c6083af93cc37c7d16ef4db451091841cefdc/tests%2Fregressiontests%2Finspectdb%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Finspectdb%2Fmodels.py?ref=395c6083af93cc37c7d16ef4db451091841cefdc",
            "patch": "@@ -19,3 +19,9 @@ class DigitsInColumnName(models.Model):\n     all_digits = models.CharField(max_length=11, db_column='123')\n     leading_digit = models.CharField(max_length=11, db_column='4extra')\n     leading_digits = models.CharField(max_length=11, db_column='45extra')\n+\n+class UnderscoresInColumnName(models.Model):\n+    field = models.IntegerField(db_column='field')\n+    field_field_0 = models.IntegerField(db_column='Field_')\n+    field_field_1 = models.IntegerField(db_column='Field__')\n+    field_field_2 = models.IntegerField(db_column='__field')"
        },
        {
            "sha": "b5647e9e38b09fcc9edfeb059ddcbf660e12a2c9",
            "filename": "tests/regressiontests/inspectdb/tests.py",
            "status": "modified",
            "additions": 25,
            "deletions": 12,
            "changes": 37,
            "blob_url": "https://github.com/django/django/blob/395c6083af93cc37c7d16ef4db451091841cefdc/tests%2Fregressiontests%2Finspectdb%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/395c6083af93cc37c7d16ef4db451091841cefdc/tests%2Fregressiontests%2Finspectdb%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Finspectdb%2Ftests.py?ref=395c6083af93cc37c7d16ef4db451091841cefdc",
            "patch": "@@ -1,3 +1,5 @@\n+from __future__ import unicode_literals\n+\n from django.core.management import call_command\n from django.test import TestCase, skipUnlessDBFeature\n from django.utils.six import StringIO\n@@ -17,7 +19,6 @@ def test_stealth_table_name_filter_option(self):\n         # the Django test suite, check that one of its tables hasn't been\n         # inspected\n         self.assertNotIn(\"class DjangoContentType(models.Model):\", out.getvalue(), msg=error_message)\n-        out.close()\n \n     @skipUnlessDBFeature('can_introspect_foreign_keys')\n     def test_attribute_name_not_python_keyword(self):\n@@ -27,15 +28,16 @@ def test_attribute_name_not_python_keyword(self):\n         call_command('inspectdb',\n                      table_name_filter=lambda tn:tn.startswith('inspectdb_'),\n                      stdout=out)\n+        output = out.getvalue()\n         error_message = \"inspectdb generated an attribute name which is a python keyword\"\n-        self.assertNotIn(\"from = models.ForeignKey(InspectdbPeople)\", out.getvalue(), msg=error_message)\n+        self.assertNotIn(\"from = models.ForeignKey(InspectdbPeople)\", output, msg=error_message)\n         # As InspectdbPeople model is defined after InspectdbMessage, it should be quoted\n-        self.assertIn(\"from_field = models.ForeignKey('InspectdbPeople')\", out.getvalue())\n+        self.assertIn(\"from_field = models.ForeignKey('InspectdbPeople', db_column='from_id')\",\n+            output)\n         self.assertIn(\"people_pk = models.ForeignKey(InspectdbPeople, primary_key=True)\",\n-            out.getvalue())\n+            output)\n         self.assertIn(\"people_unique = models.ForeignKey(InspectdbPeople, unique=True)\",\n-            out.getvalue())\n-        out.close()\n+            output)\n \n     def test_digits_column_name_introspection(self):\n         \"\"\"Introspection of column names consist/start with digits (#16536/#17676)\"\"\"\n@@ -45,13 +47,24 @@ def test_digits_column_name_introspection(self):\n         call_command('inspectdb',\n                      table_name_filter=lambda tn:tn.startswith('inspectdb_'),\n                      stdout=out)\n+        output = out.getvalue()\n         error_message = \"inspectdb generated a model field name which is a number\"\n-        self.assertNotIn(\"    123 = models.CharField\", out.getvalue(), msg=error_message)\n-        self.assertIn(\"number_123 = models.CharField\", out.getvalue())\n+        self.assertNotIn(\"    123 = models.CharField\", output, msg=error_message)\n+        self.assertIn(\"number_123 = models.CharField\", output)\n \n         error_message = \"inspectdb generated a model field name which starts with a digit\"\n-        self.assertNotIn(\"    4extra = models.CharField\", out.getvalue(), msg=error_message)\n-        self.assertIn(\"number_4extra = models.CharField\", out.getvalue())\n+        self.assertNotIn(\"    4extra = models.CharField\", output, msg=error_message)\n+        self.assertIn(\"number_4extra = models.CharField\", output)\n+\n+        self.assertNotIn(\"    45extra = models.CharField\", output, msg=error_message)\n+        self.assertIn(\"number_45extra = models.CharField\", output)\n \n-        self.assertNotIn(\"    45extra = models.CharField\", out.getvalue(), msg=error_message)\n-        self.assertIn(\"number_45extra = models.CharField\", out.getvalue())\n+    def test_underscores_column_name_introspection(self):\n+        \"\"\"Introspection of column names containing underscores (#12460)\"\"\"\n+        out = StringIO()\n+        call_command('inspectdb', stdout=out)\n+        output = out.getvalue()\n+        self.assertIn(\"field = models.IntegerField()\", output)\n+        self.assertIn(\"field_field = models.IntegerField(db_column='Field_')\", output)\n+        self.assertIn(\"field_field_0 = models.IntegerField(db_column='Field__')\", output)\n+        self.assertIn(\"field_field_1 = models.IntegerField(db_column='__field')\", output)"
        }
    ],
    "stats": {
        "total": 160,
        "additions": 109,
        "deletions": 51
    }
}