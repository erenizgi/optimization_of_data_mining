{
    "author": "aaugustin",
    "message": "Fixed tests broken in 2ee21d9.",
    "sha": "cf304691649fbe3b0d7f8e9396358be9df62430f",
    "files": [
        {
            "sha": "69a6d2b18d966acbe42bb4dc1b4edcf216358911",
            "filename": "django/db/__init__.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/cf304691649fbe3b0d7f8e9396358be9df62430f/django%2Fdb%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/cf304691649fbe3b0d7f8e9396358be9df62430f/django%2Fdb%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2F__init__.py?ref=cf304691649fbe3b0d7f8e9396358be9df62430f",
            "patch": "@@ -39,6 +39,9 @@ def __getattr__(self, item):\n     def __setattr__(self, name, value):\n         return setattr(connections[DEFAULT_DB_ALIAS], name, value)\n \n+    def __delattr__(self, name):\n+        return delattr(connections[DEFAULT_DB_ALIAS], name)\n+\n connection = DefaultConnectionProxy()\n backend = load_backend(connection.settings_dict['ENGINE'])\n "
        },
        {
            "sha": "71b89f93fb5a69d380b251aaa3ef505202b70e22",
            "filename": "django/db/utils.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/cf304691649fbe3b0d7f8e9396358be9df62430f/django%2Fdb%2Futils.py",
            "raw_url": "https://github.com/django/django/raw/cf304691649fbe3b0d7f8e9396358be9df62430f/django%2Fdb%2Futils.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Futils.py?ref=cf304691649fbe3b0d7f8e9396358be9df62430f",
            "patch": "@@ -183,6 +183,9 @@ def __getitem__(self, alias):\n     def __setitem__(self, key, value):\n         setattr(self._connections, key, value)\n \n+    def __delitem__(self, key):\n+        delattr(self._connections, key)\n+\n     def __iter__(self):\n         return iter(self.databases)\n "
        },
        {
            "sha": "4fdc17618b6ef5ce4e9443e2ba218482940e0dd1",
            "filename": "tests/requests/tests.py",
            "status": "modified",
            "additions": 29,
            "deletions": 14,
            "changes": 43,
            "blob_url": "https://github.com/django/django/blob/cf304691649fbe3b0d7f8e9396358be9df62430f/tests%2Frequests%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/cf304691649fbe3b0d7f8e9396358be9df62430f/tests%2Frequests%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Frequests%2Ftests.py?ref=cf304691649fbe3b0d7f8e9396358be9df62430f",
            "patch": "@@ -548,8 +548,27 @@ def read(self, len=0):\n         with self.assertRaises(UnreadablePostError):\n             request.body\n \n-class TransactionRequestTests(TransactionTestCase):\n+\n+@unittest.skipIf(connection.vendor == 'sqlite'\n+        and connection.settings_dict['NAME'] in ('', ':memory:'),\n+        \"Cannot establish two connections to an in-memory SQLite database.\")\n+class DatabaseConnectionHandlingTests(TransactionTestCase):\n+\n+    def setUp(self):\n+        # Use a temporary connection to avoid messing with the main one.\n+        self._old_default_connection = connections['default']\n+        del connections['default']\n+\n+    def tearDown(self):\n+        try:\n+            connections['default'].close()\n+        finally:\n+            connections['default'] = self._old_default_connection\n+\n     def test_request_finished_db_state(self):\n+        # Force closing connection on request end\n+        connection.settings_dict['CONN_MAX_AGE'] = 0\n+\n         # The GET below will not succeed, but it will give a response with\n         # defined ._handler_class. That is needed for sending the\n         # request_finished signal.\n@@ -559,31 +578,27 @@ def test_request_finished_db_state(self):\n         connection.enter_transaction_management()\n         connection.managed(True)\n         signals.request_finished.send(sender=response._handler_class)\n-        # In-memory sqlite doesn't actually close connections.\n-        if connection.vendor != 'sqlite':\n-            self.assertIs(connection.connection, None)\n         self.assertEqual(len(connection.transaction_state), 0)\n \n-    @unittest.skipIf(connection.vendor == 'sqlite',\n-                     'This test will close the connection, in-memory '\n-                     'sqlite connections must not be closed.')\n     def test_request_finished_failed_connection(self):\n-        conn = connections[DEFAULT_DB_ALIAS]\n-        conn.enter_transaction_management()\n-        conn.managed(True)\n-        conn.set_dirty()\n+        # Force closing connection on request end\n+        connection.settings_dict['CONN_MAX_AGE'] = 0\n+\n+        connection.enter_transaction_management()\n+        connection.managed(True)\n+        connection.set_dirty()\n         # Test that the rollback doesn't succeed (for example network failure\n         # could cause this).\n         def fail_horribly():\n             raise Exception(\"Horrible failure!\")\n-        conn._rollback = fail_horribly\n+        connection._rollback = fail_horribly\n         try:\n             with self.assertRaises(Exception):\n                 signals.request_finished.send(sender=self.__class__)\n             # The connection's state wasn't cleaned up\n-            self.assertTrue(len(connection.transaction_state), 1)\n+            self.assertEqual(len(connection.transaction_state), 1)\n         finally:\n-            del conn._rollback\n+            del connection._rollback\n         # The connection will be cleaned on next request where the conn\n         # works again.\n         signals.request_finished.send(sender=self.__class__)"
        }
    ],
    "stats": {
        "total": 49,
        "additions": 35,
        "deletions": 14
    }
}