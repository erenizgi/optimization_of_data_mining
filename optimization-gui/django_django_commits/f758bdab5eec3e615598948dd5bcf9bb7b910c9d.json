{
    "author": "ramiro",
    "message": "Fixed #18271 -- Changed stage at which TransactionTestCase flushes DB tables.\n\nPreviously, the flush was done before the test case execution and now\nit is performed after it.\n\nOther changes to the testing infrastructure include:\n\n* TransactionTestCase now doesn't reset autoincrement sequences either\n  (previous behavior can achieved by using `reset_sequences`.)\n  With this, no implicit such reset is performed by any of the provided\n  TestCase classes.\n\n* New ordering of test cases: All unittest tes cases are run first and\n  doctests are run at the end.\n\nTHse changes could be backward-incompatible with test cases that relied\non some kind of state being preserved between tests. Please read the\nrelevant sections of the release notes and testing documentation for\nfurther details.\n\nThanks Andreas Pelme for the initial patch. Karen Tracey and Anssi\nKääriäinen for the feedback and Anssi for reviewing.\n\nThis also fixes #12408.",
    "sha": "f758bdab5eec3e615598948dd5bcf9bb7b910c9d",
    "files": [
        {
            "sha": "ac7b7a359931a9867555cb6ca4dc2fb258067ac7",
            "filename": "django/core/management/commands/flush.py",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Fcore%2Fmanagement%2Fcommands%2Fflush.py",
            "raw_url": "https://github.com/django/django/raw/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Fcore%2Fmanagement%2Fcommands%2Fflush.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Fflush.py?ref=f758bdab5eec3e615598948dd5bcf9bb7b910c9d",
            "patch": "@@ -29,6 +29,8 @@ def handle_noargs(self, **options):\n         connection = connections[db]\n         verbosity = int(options.get('verbosity'))\n         interactive = options.get('interactive')\n+        # 'reset_sequences' is a stealth option\n+        reset_sequences = options.get('reset_sequences', True)\n \n         self.style = no_style()\n \n@@ -40,7 +42,7 @@ def handle_noargs(self, **options):\n             except ImportError:\n                 pass\n \n-        sql_list = sql_flush(self.style, connection, only_django=True)\n+        sql_list = sql_flush(self.style, connection, only_django=True, reset_sequences=reset_sequences)\n \n         if interactive:\n             confirm = raw_input(\"\"\"You have requested a flush of the database."
        },
        {
            "sha": "7579cbe8abde69144229cb2888315a6044377594",
            "filename": "django/core/management/sql.py",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/django/django/blob/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Fcore%2Fmanagement%2Fsql.py",
            "raw_url": "https://github.com/django/django/raw/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Fcore%2Fmanagement%2Fsql.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fsql.py?ref=f758bdab5eec3e615598948dd5bcf9bb7b910c9d",
            "patch": "@@ -98,7 +98,7 @@ def sql_delete(app, style, connection):\n \n     return output[::-1] # Reverse it, to deal with table dependencies.\n \n-def sql_flush(style, connection, only_django=False):\n+def sql_flush(style, connection, only_django=False, reset_sequences=True):\n     \"\"\"\n     Returns a list of the SQL statements used to flush the database.\n \n@@ -109,9 +109,8 @@ def sql_flush(style, connection, only_django=False):\n         tables = connection.introspection.django_table_names(only_existing=True)\n     else:\n         tables = connection.introspection.table_names()\n-    statements = connection.ops.sql_flush(\n-        style, tables, connection.introspection.sequence_list()\n-    )\n+    seqs = connection.introspection.sequence_list() if reset_sequences else ()\n+    statements = connection.ops.sql_flush(style, tables, seqs)\n     return statements\n \n def sql_custom(app, style, connection):"
        },
        {
            "sha": "6e23ad5bb52c331059e73b314c38ede871985d3e",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=f758bdab5eec3e615598948dd5bcf9bb7b910c9d",
            "patch": "@@ -748,11 +748,24 @@ def sql_flush(self, style, tables, sequences):\n         the given database tables (without actually removing the tables\n         themselves).\n \n+        The returned value also includes SQL statements required to reset DB\n+        sequences passed in :param sequences:.\n+\n         The `style` argument is a Style object as returned by either\n         color_style() or no_style() in django.core.management.color.\n         \"\"\"\n         raise NotImplementedError()\n \n+    def sequence_reset_by_name_sql(self, style, sequences):\n+        \"\"\"\n+        Returns a list of the SQL statements required to reset sequences\n+        passed in :param sequences:.\n+\n+        The `style` argument is a Style object as returned by either\n+        color_style() or no_style() in django.core.management.color.\n+        \"\"\"\n+        return []\n+\n     def sequence_reset_sql(self, style, model_list):\n         \"\"\"\n         Returns a list of the SQL statements required to reset sequences for"
        },
        {
            "sha": "2222f89cf0075c8b92eba93017395a53c74b42d7",
            "filename": "django/db/backends/mysql/base.py",
            "status": "modified",
            "additions": 15,
            "deletions": 12,
            "changes": 27,
            "blob_url": "https://github.com/django/django/blob/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py?ref=f758bdab5eec3e615598948dd5bcf9bb7b910c9d",
            "patch": "@@ -262,22 +262,25 @@ def sql_flush(self, style, tables, sequences):\n             for table in tables:\n                 sql.append('%s %s;' % (style.SQL_KEYWORD('TRUNCATE'), style.SQL_FIELD(self.quote_name(table))))\n             sql.append('SET FOREIGN_KEY_CHECKS = 1;')\n-\n-            # Truncate already resets the AUTO_INCREMENT field from\n-            # MySQL version 5.0.13 onwards. Refs #16961.\n-            if self.connection.mysql_version < (5,0,13):\n-                sql.extend(\n-                    [\"%s %s %s %s %s;\" % \\\n-                     (style.SQL_KEYWORD('ALTER'),\n-                      style.SQL_KEYWORD('TABLE'),\n-                      style.SQL_TABLE(self.quote_name(sequence['table'])),\n-                      style.SQL_KEYWORD('AUTO_INCREMENT'),\n-                      style.SQL_FIELD('= 1'),\n-                     ) for sequence in sequences])\n+            sql.extend(self.sequence_reset_by_name_sql(style, sequences))\n             return sql\n         else:\n             return []\n \n+    def sequence_reset_by_name_sql(self, style, sequences):\n+        # Truncate already resets the AUTO_INCREMENT field from\n+        # MySQL version 5.0.13 onwards. Refs #16961.\n+        if self.connection.mysql_version < (5, 0, 13):\n+            return [\"%s %s %s %s %s;\" % \\\n+                    (style.SQL_KEYWORD('ALTER'),\n+                    style.SQL_KEYWORD('TABLE'),\n+                    style.SQL_TABLE(self.quote_name(sequence['table'])),\n+                    style.SQL_KEYWORD('AUTO_INCREMENT'),\n+                    style.SQL_FIELD('= 1'),\n+                    ) for sequence in sequences]\n+        else:\n+            return []\n+\n     def validate_autopk_value(self, value):\n         # MySQLism: zero in AUTO_INCREMENT field does not work. Refs #17653.\n         if value == 0:"
        },
        {
            "sha": "b08113fed76831cb047eacecbe290964371586c3",
            "filename": "django/db/backends/oracle/base.py",
            "status": "modified",
            "additions": 13,
            "deletions": 8,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Foracle%2Fbase.py?ref=f758bdab5eec3e615598948dd5bcf9bb7b910c9d",
            "patch": "@@ -298,18 +298,23 @@ def sql_flush(self, style, tables, sequences):\n                     for table in tables]\n             # Since we've just deleted all the rows, running our sequence\n             # ALTER code will reset the sequence to 0.\n-            for sequence_info in sequences:\n-                sequence_name = self._get_sequence_name(sequence_info['table'])\n-                table_name = self.quote_name(sequence_info['table'])\n-                column_name = self.quote_name(sequence_info['column'] or 'id')\n-                query = _get_sequence_reset_sql() % {'sequence': sequence_name,\n-                                                     'table': table_name,\n-                                                     'column': column_name}\n-                sql.append(query)\n+            sql.extend(self.sequence_reset_by_name_sql(style, sequences))\n             return sql\n         else:\n             return []\n \n+    def sequence_reset_by_name_sql(self, style, sequences):\n+        sql = []\n+        for sequence_info in sequences:\n+            sequence_name = self._get_sequence_name(sequence_info['table'])\n+            table_name = self.quote_name(sequence_info['table'])\n+            column_name = self.quote_name(sequence_info['column'] or 'id')\n+            query = _get_sequence_reset_sql() % {'sequence': sequence_name,\n+                                                    'table': table_name,\n+                                                    'column': column_name}\n+            sql.append(query)\n+        return sql\n+\n     def sequence_reset_sql(self, style, model_list):\n         from django.db import models\n         output = []"
        },
        {
            "sha": "40fe62911023e89276e1917df8374585c64a6d81",
            "filename": "django/db/backends/postgresql_psycopg2/operations.py",
            "status": "modified",
            "additions": 19,
            "deletions": 15,
            "changes": 34,
            "blob_url": "https://github.com/django/django/blob/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Foperations.py",
            "raw_url": "https://github.com/django/django/raw/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Foperations.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Foperations.py?ref=f758bdab5eec3e615598948dd5bcf9bb7b910c9d",
            "patch": "@@ -85,25 +85,29 @@ def sql_flush(self, style, tables, sequences):\n                 (style.SQL_KEYWORD('TRUNCATE'),\n                     style.SQL_FIELD(', '.join([self.quote_name(table) for table in tables]))\n             )]\n-\n-            # 'ALTER SEQUENCE sequence_name RESTART WITH 1;'... style SQL statements\n-            # to reset sequence indices\n-            for sequence_info in sequences:\n-                table_name = sequence_info['table']\n-                column_name = sequence_info['column']\n-                if not (column_name and len(column_name) > 0):\n-                    # This will be the case if it's an m2m using an autogenerated\n-                    # intermediate table (see BaseDatabaseIntrospection.sequence_list)\n-                    column_name = 'id'\n-                sql.append(\"%s setval(pg_get_serial_sequence('%s','%s'), 1, false);\" % \\\n-                    (style.SQL_KEYWORD('SELECT'),\n-                    style.SQL_TABLE(self.quote_name(table_name)),\n-                    style.SQL_FIELD(column_name))\n-                )\n+            sql.extend(self.sequence_reset_by_name_sql(style, sequences))\n             return sql\n         else:\n             return []\n \n+    def sequence_reset_by_name_sql(self, style, sequences):\n+        # 'ALTER SEQUENCE sequence_name RESTART WITH 1;'... style SQL statements\n+        # to reset sequence indices\n+        sql = []\n+        for sequence_info in sequences:\n+            table_name = sequence_info['table']\n+            column_name = sequence_info['column']\n+            if not (column_name and len(column_name) > 0):\n+                # This will be the case if it's an m2m using an autogenerated\n+                # intermediate table (see BaseDatabaseIntrospection.sequence_list)\n+                column_name = 'id'\n+            sql.append(\"%s setval(pg_get_serial_sequence('%s','%s'), 1, false);\" % \\\n+                (style.SQL_KEYWORD('SELECT'),\n+                style.SQL_TABLE(self.quote_name(table_name)),\n+                style.SQL_FIELD(column_name))\n+            )\n+        return sql\n+\n     def tablespace_sql(self, tablespace, inline=False):\n         if inline:\n             return \"USING INDEX TABLESPACE %s\" % self.quote_name(tablespace)"
        },
        {
            "sha": "bf0219d53f011b1e6531b81a07b40ac1c0adda6f",
            "filename": "django/test/simple.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Ftest%2Fsimple.py",
            "raw_url": "https://github.com/django/django/raw/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Ftest%2Fsimple.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Fsimple.py?ref=f758bdab5eec3e615598948dd5bcf9bb7b910c9d",
            "patch": "@@ -5,7 +5,7 @@\n from django.db.models import get_app, get_apps\n from django.test import _doctest as doctest\n from django.test.utils import setup_test_environment, teardown_test_environment\n-from django.test.testcases import OutputChecker, DocTestRunner, TestCase\n+from django.test.testcases import OutputChecker, DocTestRunner\n from django.utils import unittest\n from django.utils.importlib import import_module\n from django.utils.module_loading import module_has_submodule\n@@ -263,7 +263,7 @@ def build_suite(self, test_labels, extra_tests=None, **kwargs):\n             for test in extra_tests:\n                 suite.addTest(test)\n \n-        return reorder_suite(suite, (TestCase,))\n+        return reorder_suite(suite, (unittest.TestCase,))\n \n     def setup_databases(self, **kwargs):\n         from django.db import connections, DEFAULT_DB_ALIAS"
        },
        {
            "sha": "b60188bf303f89c0ff9fdc4409fc84e9d11afe3c",
            "filename": "django/test/testcases.py",
            "status": "modified",
            "additions": 43,
            "deletions": 19,
            "changes": 62,
            "blob_url": "https://github.com/django/django/blob/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Ftest%2Ftestcases.py",
            "raw_url": "https://github.com/django/django/raw/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/django%2Ftest%2Ftestcases.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Ftestcases.py?ref=f758bdab5eec3e615598948dd5bcf9bb7b910c9d",
            "patch": "@@ -23,6 +23,7 @@\n from django.core.exceptions import ValidationError, ImproperlyConfigured\n from django.core.handlers.wsgi import WSGIHandler\n from django.core.management import call_command\n+from django.core.management.color import no_style\n from django.core.signals import request_started\n from django.core.servers.basehttp import (WSGIRequestHandler, WSGIServer,\n     WSGIServerException)\n@@ -444,10 +445,15 @@ def assertHTMLNotEqual(self, html1, html2, msg=None):\n \n \n class TransactionTestCase(SimpleTestCase):\n+\n     # The class we'll use for the test client self.client.\n     # Can be overridden in derived classes.\n     client_class = Client\n \n+    # Subclasses can ask for resetting of auto increment sequence before each\n+    # test case\n+    reset_sequences = False\n+\n     def _pre_setup(self):\n         \"\"\"Performs any pre-test setup. This includes:\n \n@@ -462,22 +468,36 @@ def _pre_setup(self):\n         self._urlconf_setup()\n         mail.outbox = []\n \n+    def _reset_sequences(self, db_name):\n+        conn = connections[db_name]\n+        if conn.features.supports_sequence_reset:\n+            sql_list = \\\n+                conn.ops.sequence_reset_by_name_sql(no_style(),\n+                                                    conn.introspection.sequence_list())\n+            if sql_list:\n+                try:\n+                    cursor = conn.cursor()\n+                    for sql in sql_list:\n+                        cursor.execute(sql)\n+                except Exception:\n+                    transaction.rollback_unless_managed(using=db_name)\n+                    raise\n+                transaction.commit_unless_managed(using=db_name)\n+\n     def _fixture_setup(self):\n-        # If the test case has a multi_db=True flag, flush all databases.\n-        # Otherwise, just flush default.\n-        if getattr(self, 'multi_db', False):\n-            databases = connections\n-        else:\n-            databases = [DEFAULT_DB_ALIAS]\n-        for db in databases:\n-            call_command('flush', verbosity=0, interactive=False, database=db,\n-                         skip_validation=True)\n+        # If the test case has a multi_db=True flag, act on all databases.\n+        # Otherwise, just on the default DB.\n+        db_names = connections if getattr(self, 'multi_db', False) else [DEFAULT_DB_ALIAS]\n+        for db_name in db_names:\n+            # Reset sequences\n+            if self.reset_sequences:\n+                self._reset_sequences(db_name)\n \n             if hasattr(self, 'fixtures'):\n                 # We have to use this slightly awkward syntax due to the fact\n                 # that we're using *args and **kwargs together.\n                 call_command('loaddata', *self.fixtures,\n-                             **{'verbosity': 0, 'database': db, 'skip_validation': True})\n+                             **{'verbosity': 0, 'database': db_name, 'skip_validation': True})\n \n     def _urlconf_setup(self):\n         if hasattr(self, 'urls'):\n@@ -534,7 +554,12 @@ def _post_teardown(self):\n             conn.close()\n \n     def _fixture_teardown(self):\n-        pass\n+        # If the test case has a multi_db=True flag, flush all databases.\n+        # Otherwise, just flush default.\n+        databases = connections if getattr(self, 'multi_db', False) else [DEFAULT_DB_ALIAS]\n+        for db in databases:\n+            call_command('flush', verbosity=0, interactive=False, database=db,\n+                         skip_validation=True, reset_sequences=False)\n \n     def _urlconf_teardown(self):\n         if hasattr(self, '_old_root_urlconf'):\n@@ -808,22 +833,21 @@ def _fixture_setup(self):\n         if not connections_support_transactions():\n             return super(TestCase, self)._fixture_setup()\n \n+        assert not self.reset_sequences, 'reset_sequences cannot be used on TestCase instances'\n+\n         # If the test case has a multi_db=True flag, setup all databases.\n         # Otherwise, just use default.\n-        if getattr(self, 'multi_db', False):\n-            databases = connections\n-        else:\n-            databases = [DEFAULT_DB_ALIAS]\n+        db_names = connections if getattr(self, 'multi_db', False) else [DEFAULT_DB_ALIAS]\n \n-        for db in databases:\n-            transaction.enter_transaction_management(using=db)\n-            transaction.managed(True, using=db)\n+        for db_name in db_names:\n+            transaction.enter_transaction_management(using=db_name)\n+            transaction.managed(True, using=db_name)\n         disable_transaction_methods()\n \n         from django.contrib.sites.models import Site\n         Site.objects.clear_cache()\n \n-        for db in databases:\n+        for db in db_names:\n             if hasattr(self, 'fixtures'):\n                 call_command('loaddata', *self.fixtures,\n                              **{"
        },
        {
            "sha": "aae8b25e0749a62092c4b93efec42b28dd71bfa8",
            "filename": "docs/releases/1.5.txt",
            "status": "modified",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/django/django/blob/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/docs%2Freleases%2F1.5.txt",
            "raw_url": "https://github.com/django/django/raw/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/docs%2Freleases%2F1.5.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.5.txt?ref=f758bdab5eec3e615598948dd5bcf9bb7b910c9d",
            "patch": "@@ -188,6 +188,57 @@ Session not saved on 500 responses\n Django's session middleware will skip saving the session data if the\n response's status code is 500.\n \n+Changes in tests execution\n+~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Some changes have been introduced in the execution of tests that might be\n+backward-incompatible for some testing setups:\n+\n+Database flushing in ``django.test.TransactionTestCase``\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+Previously, the test database was truncated *before* each test run in a\n+:class:`~django.test.TransactionTestCase`.\n+\n+In order to be able to run unit tests in any order and to make sure they are\n+always isolated from each other, :class:`~django.test.TransactionTestCase` will\n+now reset the database *after* each test run instead.\n+\n+No more implict DB sequences reset\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+:class:`~django.test.TransactionTestCase` tests used to reset primary key\n+sequences automatically together with the database flushing actions described\n+above.\n+\n+This has been changed so no sequences are implicitly reset. This can cause\n+:class:`~django.test.TransactionTestCase` tests that depend on hard-coded\n+primary key values to break.\n+\n+The new :attr:`~django.test.TransactionTestCase.reset_sequences` attribute can\n+be used to force the old behavior for :class:`~django.test.TransactionTestCase`\n+that might need it.\n+\n+Ordering of tests\n+^^^^^^^^^^^^^^^^^\n+\n+In order to make sure all ``TestCase`` code starts with a clean database,\n+tests are now executed in the following order:\n+\n+* First, all unittests (including :class:`unittest.TestCase`,\n+  :class:`~django.test.SimpleTestCase`, :class:`~django.test.TestCase` and\n+  :class:`~django.test.TransactionTestCase`) are run with no particular ordering\n+  guaranteed nor enforced among them.\n+\n+* Then any other tests (e.g. doctests) that may alter the database without\n+  restoring it to its original state are run.\n+\n+This should not cause any problems unless you have existing doctests which\n+assume a :class:`~django.test.TransactionTestCase` executed earlier left some\n+database state behind or unit tests that rely on some form of state being\n+preserved after the execution of other tests. Such tests are already very\n+fragile, and must now be changed to be able to run independently.\n+\n Miscellaneous\n ~~~~~~~~~~~~~\n "
        },
        {
            "sha": "1f4c970d3eb2100fb8a296644ad0f39ea7cd7aa2",
            "filename": "docs/topics/testing.txt",
            "status": "modified",
            "additions": 104,
            "deletions": 37,
            "changes": 141,
            "blob_url": "https://github.com/django/django/blob/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/docs%2Ftopics%2Ftesting.txt",
            "raw_url": "https://github.com/django/django/raw/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/docs%2Ftopics%2Ftesting.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Ftesting.txt?ref=f758bdab5eec3e615598948dd5bcf9bb7b910c9d",
            "patch": "@@ -478,6 +478,32 @@ If there are any circular dependencies in the\n :setting:`TEST_DEPENDENCIES` definition, an ``ImproperlyConfigured``\n exception will be raised.\n \n+Order in which tests are executed\n+---------------------------------\n+\n+In order to guarantee that all ``TestCase`` code starts with a clean database,\n+the Django test runner reorders tests in the following way:\n+\n+* First, all unittests (including :class:`unittest.TestCase`,\n+  :class:`~django.test.SimpleTestCase`, :class:`~django.test.TestCase` and\n+  :class:`~django.test.TransactionTestCase`) are run with no particular ordering\n+  guaranteed nor enforced among them.\n+\n+* Then any other tests (e.g. doctests) that may alter the database without\n+  restoring it to its original state are run.\n+\n+.. versionchanged:: 1.5\n+    Before Django 1.5, the only guarantee was that\n+    :class:`~django.test.TestCase` tests were always ran first, before any other\n+    tests.\n+\n+.. note::\n+\n+    The new ordering of tests may reveal unexpected dependencies on test case\n+    ordering. This is the case with doctests that relied on state left in the\n+    database by a given :class:`~django.test.TransactionTestCase` test, they\n+    must be updated to be able to run independently.\n+\n Other test conditions\n ---------------------\n \n@@ -1109,8 +1135,11 @@ The following is a simple unit test using the request factory::\n             response = my_view(request)\n             self.assertEqual(response.status_code, 200)\n \n-TestCase\n---------\n+Test cases\n+----------\n+\n+Provided test case classes\n+~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n .. currentmodule:: django.test\n \n@@ -1124,28 +1153,38 @@ Normal Python unit test classes extend a base class of\n \n    Hierarchy of Django unit testing classes\n \n+TestCase\n+^^^^^^^^\n+\n .. class:: TestCase()\n \n This class provides some additional capabilities that can be useful for testing\n Web sites.\n \n Converting a normal :class:`unittest.TestCase` to a Django :class:`TestCase` is\n-easy: just change the base class of your test from :class:`unittest.TestCase` to\n-:class:`django.test.TestCase`. All of the standard Python unit test\n-functionality will continue to be available, but it will be augmented with some\n-useful additions, including:\n+easy: Just change the base class of your test from `'unittest.TestCase'` to\n+`'django.test.TestCase'`. All of the standard Python unit test functionality\n+will continue to be available, but it will be augmented with some useful\n+additions, including:\n \n * Automatic loading of fixtures.\n \n * Wraps each test in a transaction.\n \n * Creates a TestClient instance.\n \n-* Django-specific assertions for testing for things\n-  like redirection and form errors.\n+* Django-specific assertions for testing for things like redirection and form\n+  errors.\n+\n+.. versionchanged:: 1.5\n+    The order in which tests are run has changed. See `Order in which tests are\n+    executed`_.\n \n ``TestCase`` inherits from :class:`~django.test.TransactionTestCase`.\n \n+TransactionTestCase\n+^^^^^^^^^^^^^^^^^^^\n+\n .. class:: TransactionTestCase()\n \n Django ``TestCase`` classes make use of database transaction facilities, if\n@@ -1157,38 +1196,66 @@ behavior, you should use a Django ``TransactionTestCase``.\n \n ``TransactionTestCase`` and ``TestCase`` are identical except for the manner\n in which the database is reset to a known state and the ability for test code\n-to test the effects of commit and rollback. A ``TransactionTestCase`` resets\n-the database before the test runs by truncating all tables and reloading\n-initial data. A ``TransactionTestCase`` may call commit and rollback and\n-observe the effects of these calls on the database.\n-\n-A ``TestCase``, on the other hand, does not truncate tables and reload initial\n-data at the beginning of a test. Instead, it encloses the test code in a\n-database transaction that is rolled back at the end of the test.  It also\n-prevents the code under test from issuing any commit or rollback operations\n-on the database, to ensure that the rollback at the end of the test restores\n-the database to its initial state. In order to guarantee that all ``TestCase``\n-code starts with a clean database, the Django test runner runs all ``TestCase``\n-tests first, before any other tests (e.g. doctests) that may alter the\n-database without restoring it to its original state.\n-\n-When running on a database that does not support rollback (e.g. MySQL with the\n-MyISAM storage engine), ``TestCase`` falls back to initializing the database\n-by truncating tables and reloading initial data.\n+to test the effects of commit and rollback:\n \n-``TransactionTestCase`` inherits from :class:`~django.test.SimpleTestCase`.\n+* A ``TransactionTestCase`` resets the database after the test runs by\n+  truncating all tables. A ``TransactionTestCase`` may call commit and rollback\n+  and observe the effects of these calls on the database.\n+\n+* A ``TestCase``, on the other hand, does not truncate tables after a test.\n+  Instead, it encloses the test code in a database transaction that is rolled\n+  back at the end of the test.  It also prevents the code under test from\n+  issuing any commit or rollback operations on the database, to ensure that the\n+  rollback at the end of the test restores the database to its initial state.\n+\n+  When running on a database that does not support rollback (e.g. MySQL with the\n+  MyISAM storage engine), ``TestCase`` falls back to initializing the database\n+  by truncating tables and reloading initial data.\n \n .. note::\n-    The ``TestCase`` use of rollback to un-do the effects of the test code\n-    may reveal previously-undetected errors in test code.  For example,\n-    test code that assumes primary keys values will be assigned starting at\n-    one may find that assumption no longer holds true when rollbacks instead\n-    of table truncation are being used to reset the database.  Similarly,\n-    the reordering of tests so that all ``TestCase`` classes run first may\n-    reveal unexpected dependencies on test case ordering.  In such cases a\n-    quick fix is to switch the ``TestCase`` to a ``TransactionTestCase``.\n-    A better long-term fix, that allows the test to take advantage of the\n-    speed benefit of ``TestCase``, is to fix the underlying test problem.\n+\n+    .. versionchanged:: 1.5\n+\n+    Prior to 1.5, ``TransactionTestCase`` flushed the database tables *before*\n+    each test. In Django 1.5, this is instead done *after* the test has been run.\n+\n+    When the flush took place before the test, it was guaranteed that primary\n+    key values started at one in :class:`~django.test.TransactionTestCase`\n+    tests.\n+\n+    Tests should not depend on this behaviour, but for legacy tests that do, the\n+    :attr:`~TransactionTestCase.reset_sequences` attribute can be used until\n+    the test has been properly updated.\n+\n+.. versionchanged:: 1.5\n+    The order in which tests are run has changed. See `Order in which tests are\n+    executed`_.\n+\n+``TransactionTestCase`` inherits from :class:`~django.test.SimpleTestCase`.\n+\n+.. attribute:: TransactionTestCase.reset_sequences\n+\n+    .. versionadded:: 1.5\n+\n+    Setting ``reset_sequences = True`` on a ``TransactionTestCase`` will make\n+    sure sequences are always reset before the test run::\n+\n+        class TestsThatDependsOnPrimaryKeySequences(TransactionTestCase):\n+            reset_sequences = True\n+\n+            def test_animal_pk(self):\n+                lion = Animal.objects.create(name=\"lion\", sound=\"roar\")\n+                # lion.pk is guaranteed to always be 1\n+                self.assertEqual(lion.pk, 1)\n+\n+    Unless you are explicitly testing primary keys sequence numbers, it is\n+    recommended that you do not hard code primary key values in tests.\n+\n+    Using ``reset_sequences = True`` will slow down the test, since the primary\n+    key reset is an relatively expensive database operation.\n+\n+SimpleTestCase\n+^^^^^^^^^^^^^^\n \n .. class:: SimpleTestCase()\n "
        },
        {
            "sha": "c723f162a42f1b835b265e43beb7ccfe4c626506",
            "filename": "tests/regressiontests/test_runner/tests.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/tests%2Fregressiontests%2Ftest_runner%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/f758bdab5eec3e615598948dd5bcf9bb7b910c9d/tests%2Fregressiontests%2Ftest_runner%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftest_runner%2Ftests.py?ref=f758bdab5eec3e615598948dd5bcf9bb7b910c9d",
            "patch": "@@ -267,6 +267,9 @@ class AutoIncrementResetTest(TransactionTestCase):\n     and check that both times they get \"1\" as their PK value. That is, we test\n     that AutoField values start from 1 for each transactional test case.\n     \"\"\"\n+\n+    reset_sequences = True\n+\n     @skipUnlessDBFeature('supports_sequence_reset')\n     def test_autoincrement_reset1(self):\n         p = Person.objects.create(first_name='Jack', last_name='Smith')"
        }
    ],
    "stats": {
        "total": 367,
        "additions": 269,
        "deletions": 98
    }
}