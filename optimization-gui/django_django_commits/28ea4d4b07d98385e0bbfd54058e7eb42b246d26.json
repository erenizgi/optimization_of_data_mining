{
    "author": "aaugustin",
    "message": "Fixed #18852 -- Restored backwards compatibility\n\nin django.core.signing. Specifically, kept the same return types\n(str/unicode) under Python 2. Related to [92b2dec918].",
    "sha": "28ea4d4b07d98385e0bbfd54058e7eb42b246d26",
    "files": [
        {
            "sha": "147e54780c7d91897b480823c559a1267cea0636",
            "filename": "django/core/signing.py",
            "status": "modified",
            "additions": 29,
            "deletions": 19,
            "changes": 48,
            "blob_url": "https://github.com/django/django/blob/28ea4d4b07d98385e0bbfd54058e7eb42b246d26/django%2Fcore%2Fsigning.py",
            "raw_url": "https://github.com/django/django/raw/28ea4d4b07d98385e0bbfd54058e7eb42b246d26/django%2Fcore%2Fsigning.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fsigning.py?ref=28ea4d4b07d98385e0bbfd54058e7eb42b246d26",
            "patch": "@@ -32,6 +32,7 @@\n There are 65 url-safe characters: the 64 used by url-safe base64 and the ':'.\n These functions make use of all of them.\n \"\"\"\n+\n from __future__ import unicode_literals\n \n import base64\n@@ -43,7 +44,7 @@\n from django.core.exceptions import ImproperlyConfigured\n from django.utils import baseconv\n from django.utils.crypto import constant_time_compare, salted_hmac\n-from django.utils.encoding import smart_bytes\n+from django.utils.encoding import force_bytes, force_str, force_text\n from django.utils.importlib import import_module\n \n \n@@ -62,12 +63,12 @@ class SignatureExpired(BadSignature):\n \n \n def b64_encode(s):\n-    return base64.urlsafe_b64encode(smart_bytes(s)).decode('ascii').strip('=')\n+    return base64.urlsafe_b64encode(s).strip(b'=')\n \n \n def b64_decode(s):\n-    pad = '=' * (-len(s) % 4)\n-    return base64.urlsafe_b64decode(smart_bytes(s + pad)).decode('ascii')\n+    pad = b'=' * (-len(s) % 4)\n+    return base64.urlsafe_b64decode(s + pad)\n \n \n def base64_hmac(salt, value, key):\n@@ -116,58 +117,66 @@ def dumps(obj, key=None, salt='django.core.signing', serializer=JSONSerializer,\n     value or re-using a salt value across different parts of your\n     application without good cause is a security risk.\n     \"\"\"\n-    data = serializer().dumps(obj)\n+    data = force_bytes(serializer().dumps(obj))\n \n     # Flag for if it's been compressed or not\n     is_compressed = False\n \n     if compress:\n         # Avoid zlib dependency unless compress is being used\n-        compressed = zlib.compress(smart_bytes(data))\n+        compressed = zlib.compress(data)\n         if len(compressed) < (len(data) - 1):\n             data = compressed\n             is_compressed = True\n     base64d = b64_encode(data)\n     if is_compressed:\n-        base64d = '.' + base64d\n+        base64d = b'.' + base64d\n     return TimestampSigner(key, salt=salt).sign(base64d)\n \n \n def loads(s, key=None, salt='django.core.signing', serializer=JSONSerializer, max_age=None):\n     \"\"\"\n     Reverse of dumps(), raises BadSignature if signature fails\n     \"\"\"\n-    base64d = TimestampSigner(key, salt=salt).unsign(s, max_age=max_age)\n+    # TimestampSigner.unsign always returns unicode but base64 and zlib\n+    # compression operate on bytes.\n+    base64d = force_bytes(TimestampSigner(key, salt=salt).unsign(s, max_age=max_age))\n     decompress = False\n-    if base64d[0] == '.':\n+    if base64d[0] == b'.':\n         # It's compressed; uncompress it first\n         base64d = base64d[1:]\n         decompress = True\n     data = b64_decode(base64d)\n     if decompress:\n         data = zlib.decompress(data)\n-    return serializer().loads(data)\n+    return serializer().loads(force_str(data))\n \n \n class Signer(object):\n+\n     def __init__(self, key=None, sep=':', salt=None):\n-        self.sep = sep\n-        self.key = key or settings.SECRET_KEY\n-        self.salt = salt or ('%s.%s' %\n-            (self.__class__.__module__, self.__class__.__name__))\n+        # Use of native strings in all versions of Python\n+        self.sep = str(sep)\n+        self.key = str(key or settings.SECRET_KEY)\n+        self.salt = str(salt or\n+            '%s.%s' % (self.__class__.__module__, self.__class__.__name__))\n \n     def signature(self, value):\n-        return base64_hmac(self.salt + 'signer', value, self.key)\n+        signature = base64_hmac(self.salt + 'signer', value, self.key)\n+        # Convert the signature from bytes to str only on Python 3\n+        return force_str(signature)\n \n     def sign(self, value):\n-        return '%s%s%s' % (value, self.sep, self.signature(value))\n+        value = force_str(value)\n+        return str('%s%s%s') % (value, self.sep, self.signature(value))\n \n     def unsign(self, signed_value):\n+        signed_value = force_str(signed_value)\n         if not self.sep in signed_value:\n             raise BadSignature('No \"%s\" found in value' % self.sep)\n         value, sig = signed_value.rsplit(self.sep, 1)\n         if constant_time_compare(sig, self.signature(value)):\n-            return value\n+            return force_text(value)\n         raise BadSignature('Signature \"%s\" does not match' % sig)\n \n \n@@ -177,8 +186,9 @@ def timestamp(self):\n         return baseconv.base62.encode(int(time.time()))\n \n     def sign(self, value):\n-        value = '%s%s%s' % (value, self.sep, self.timestamp())\n-        return '%s%s%s' % (value, self.sep, self.signature(value))\n+        value = force_str(value)\n+        value = str('%s%s%s') % (value, self.sep, self.timestamp())\n+        return super(TimestampSigner, self).sign(value)\n \n     def unsign(self, value, max_age=None):\n         result =  super(TimestampSigner, self).unsign(value)"
        },
        {
            "sha": "05c8b3dc749c6ea88e541d13a273ada1caf15cfe",
            "filename": "tests/regressiontests/signing/tests.py",
            "status": "modified",
            "additions": 12,
            "deletions": 8,
            "changes": 20,
            "blob_url": "https://github.com/django/django/blob/28ea4d4b07d98385e0bbfd54058e7eb42b246d26/tests%2Fregressiontests%2Fsigning%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/28ea4d4b07d98385e0bbfd54058e7eb42b246d26/tests%2Fregressiontests%2Fsigning%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fsigning%2Ftests.py?ref=28ea4d4b07d98385e0bbfd54058e7eb42b246d26",
            "patch": "@@ -4,8 +4,8 @@\n \n from django.core import signing\n from django.test import TestCase\n+from django.utils.encoding import force_str\n from django.utils import six\n-from django.utils.encoding import force_text\n \n \n class TestSigner(TestCase):\n@@ -22,7 +22,7 @@ def test_signature(self):\n             self.assertEqual(\n                 signer.signature(s),\n                 signing.base64_hmac(signer.salt + 'signer', s,\n-                    'predictable-secret')\n+                    'predictable-secret').decode()\n             )\n             self.assertNotEqual(signer.signature(s), signer2.signature(s))\n \n@@ -32,25 +32,29 @@ def test_signature_with_salt(self):\n         self.assertEqual(\n             signer.signature('hello'),\n                 signing.base64_hmac('extra-salt' + 'signer',\n-                'hello', 'predictable-secret'))\n+                'hello', 'predictable-secret').decode()\n+            )\n         self.assertNotEqual(\n             signing.Signer('predictable-secret', salt='one').signature('hello'),\n             signing.Signer('predictable-secret', salt='two').signature('hello'))\n \n     def test_sign_unsign(self):\n         \"sign/unsign should be reversible\"\n         signer = signing.Signer('predictable-secret')\n-        examples = (\n+        examples = [\n             'q;wjmbk;wkmb',\n             '3098247529087',\n             '3098247:529:087:',\n             'jkw osanteuh ,rcuh nthu aou oauh ,ud du',\n             '\\u2019',\n-        )\n+        ]\n+        if not six.PY3:\n+            examples.append(b'a byte string')\n         for example in examples:\n-            self.assertNotEqual(\n-                force_text(example), force_text(signer.sign(example)))\n-            self.assertEqual(example, signer.unsign(signer.sign(example)))\n+            signed = signer.sign(example)\n+            self.assertIsInstance(signed, str)\n+            self.assertNotEqual(force_str(example), signed)\n+            self.assertEqual(example, signer.unsign(signed))\n \n     def unsign_detects_tampering(self):\n         \"unsign should raise an exception if the value has been tampered with\""
        }
    ],
    "stats": {
        "total": 68,
        "additions": 41,
        "deletions": 27
    }
}