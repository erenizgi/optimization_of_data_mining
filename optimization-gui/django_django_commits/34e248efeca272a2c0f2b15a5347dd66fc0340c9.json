{
    "author": "jphalip",
    "message": "Fixed #17258 -- Moved `threading.local` from `DatabaseWrapper` to the `django.db.connections` dictionary. This allows connections to be explicitly shared between multiple threads and is particularly useful for enabling the sharing of in-memory SQLite connections. Many thanks to Anssi Kääriäinen for the excellent suggestions and feedback, and to Alex Gaynor for the reviews. Refs #2879.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17205 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "34e248efeca272a2c0f2b15a5347dd66fc0340c9",
    "files": [
        {
            "sha": "26c7add0af53711237c89148b1e7ec61cd6e26d9",
            "filename": "django/db/__init__.py",
            "status": "modified",
            "additions": 14,
            "deletions": 2,
            "changes": 16,
            "blob_url": "https://github.com/django/django/blob/34e248efeca272a2c0f2b15a5347dd66fc0340c9/django%2Fdb%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/34e248efeca272a2c0f2b15a5347dd66fc0340c9/django%2Fdb%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2F__init__.py?ref=34e248efeca272a2c0f2b15a5347dd66fc0340c9",
            "patch": "@@ -22,9 +22,21 @@\n # we manually create the dictionary from the settings, passing only the\n # settings that the database backends care about. Note that TIME_ZONE is used\n # by the PostgreSQL backends.\n-# we load all these up for backwards compatibility, you should use\n+# We load all these up for backwards compatibility, you should use\n # connections['default'] instead.\n-connection = connections[DEFAULT_DB_ALIAS]\n+class DefaultConnectionProxy(object):\n+    \"\"\"\n+    Proxy for accessing the default DatabaseWrapper object's attributes. If you\n+    need to access the DatabaseWrapper object itself, use\n+    connections[DEFAULT_DB_ALIAS] instead.\n+    \"\"\"\n+    def __getattr__(self, item):\n+        return getattr(connections[DEFAULT_DB_ALIAS], item)\n+\n+    def __setattr__(self, name, value):\n+        return setattr(connections[DEFAULT_DB_ALIAS], name, value)\n+\n+connection = DefaultConnectionProxy()\n backend = load_backend(connection.settings_dict['ENGINE'])\n \n # Register an event that closes the database connection"
        },
        {
            "sha": "59c0992af59b23b0051ec3f023a17060ff841619",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 30,
            "deletions": 3,
            "changes": 33,
            "blob_url": "https://github.com/django/django/blob/34e248efeca272a2c0f2b15a5347dd66fc0340c9/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/34e248efeca272a2c0f2b15a5347dd66fc0340c9/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=34e248efeca272a2c0f2b15a5347dd66fc0340c9",
            "patch": "@@ -1,8 +1,9 @@\n+from django.db.utils import DatabaseError\n+\n try:\n     import thread\n except ImportError:\n     import dummy_thread as thread\n-from threading import local\n from contextlib import contextmanager\n \n from django.conf import settings\n@@ -13,14 +14,15 @@\n from django.utils.timezone import is_aware\n \n \n-class BaseDatabaseWrapper(local):\n+class BaseDatabaseWrapper(object):\n     \"\"\"\n     Represents a database connection.\n     \"\"\"\n     ops = None\n     vendor = 'unknown'\n \n-    def __init__(self, settings_dict, alias=DEFAULT_DB_ALIAS):\n+    def __init__(self, settings_dict, alias=DEFAULT_DB_ALIAS,\n+                 allow_thread_sharing=False):\n         # `settings_dict` should be a dictionary containing keys such as\n         # NAME, USER, etc. It's called `settings_dict` instead of `settings`\n         # to disambiguate it from Django settings modules.\n@@ -34,6 +36,8 @@ def __init__(self, settings_dict, alias=DEFAULT_DB_ALIAS):\n         self.transaction_state = []\n         self.savepoint_state = 0\n         self._dirty = None\n+        self._thread_ident = thread.get_ident()\n+        self.allow_thread_sharing = allow_thread_sharing\n \n     def __eq__(self, other):\n         return self.alias == other.alias\n@@ -116,6 +120,21 @@ def leave_transaction_management(self):\n                 \"pending COMMIT/ROLLBACK\")\n         self._dirty = False\n \n+    def validate_thread_sharing(self):\n+        \"\"\"\n+        Validates that the connection isn't accessed by another thread than the\n+        one which originally created it, unless the connection was explicitly\n+        authorized to be shared between threads (via the `allow_thread_sharing`\n+        property). Raises an exception if the validation fails.\n+        \"\"\"\n+        if (not self.allow_thread_sharing\n+            and self._thread_ident != thread.get_ident()):\n+                raise DatabaseError(\"DatabaseWrapper objects created in a \"\n+                    \"thread can only be used in that same thread. The object\"\n+                    \"with alias '%s' was created in thread id %s and this is \"\n+                    \"thread id %s.\"\n+                    % (self.alias, self._thread_ident, thread.get_ident()))\n+\n     def is_dirty(self):\n         \"\"\"\n         Returns True if the current transaction requires a commit for changes to\n@@ -179,6 +198,7 @@ def commit_unless_managed(self):\n         \"\"\"\n         Commits changes if the system is not in managed transaction mode.\n         \"\"\"\n+        self.validate_thread_sharing()\n         if not self.is_managed():\n             self._commit()\n             self.clean_savepoints()\n@@ -189,6 +209,7 @@ def rollback_unless_managed(self):\n         \"\"\"\n         Rolls back changes if the system is not in managed transaction mode.\n         \"\"\"\n+        self.validate_thread_sharing()\n         if not self.is_managed():\n             self._rollback()\n         else:\n@@ -198,13 +219,15 @@ def commit(self):\n         \"\"\"\n         Does the commit itself and resets the dirty flag.\n         \"\"\"\n+        self.validate_thread_sharing()\n         self._commit()\n         self.set_clean()\n \n     def rollback(self):\n         \"\"\"\n         This function does the rollback itself and resets the dirty flag.\n         \"\"\"\n+        self.validate_thread_sharing()\n         self._rollback()\n         self.set_clean()\n \n@@ -228,6 +251,7 @@ def savepoint_rollback(self, sid):\n         Rolls back the most recent savepoint (if one exists). Does nothing if\n         savepoints are not supported.\n         \"\"\"\n+        self.validate_thread_sharing()\n         if self.savepoint_state:\n             self._savepoint_rollback(sid)\n \n@@ -236,6 +260,7 @@ def savepoint_commit(self, sid):\n         Commits the most recent savepoint (if one exists). Does nothing if\n         savepoints are not supported.\n         \"\"\"\n+        self.validate_thread_sharing()\n         if self.savepoint_state:\n             self._savepoint_commit(sid)\n \n@@ -269,11 +294,13 @@ def check_constraints(self, table_names=None):\n         pass\n \n     def close(self):\n+        self.validate_thread_sharing()\n         if self.connection is not None:\n             self.connection.close()\n             self.connection = None\n \n     def cursor(self):\n+        self.validate_thread_sharing()\n         if (self.use_debug_cursor or\n             (self.use_debug_cursor is None and settings.DEBUG)):\n             cursor = self.make_debug_cursor(self._cursor())"
        },
        {
            "sha": "75e8fa027d9f61233a72733c0cf76189b31e0d86",
            "filename": "django/db/backends/sqlite3/base.py",
            "status": "modified",
            "additions": 16,
            "deletions": 1,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/34e248efeca272a2c0f2b15a5347dd66fc0340c9/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/34e248efeca272a2c0f2b15a5347dd66fc0340c9/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py?ref=34e248efeca272a2c0f2b15a5347dd66fc0340c9",
            "patch": "@@ -7,10 +7,10 @@\n \n import datetime\n import decimal\n+import warnings\n import re\n import sys\n \n-from django.conf import settings\n from django.db import utils\n from django.db.backends import *\n from django.db.backends.signals import connection_created\n@@ -241,6 +241,21 @@ def _cursor(self):\n                 'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,\n             }\n             kwargs.update(settings_dict['OPTIONS'])\n+            # Always allow the underlying SQLite connection to be shareable\n+            # between multiple threads. The safe-guarding will be handled at a\n+            # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`\n+            # property. This is necessary as the shareability is disabled by\n+            # default in pysqlite and it cannot be changed once a connection is\n+            # opened.\n+            if 'check_same_thread' in kwargs and kwargs['check_same_thread']:\n+                warnings.warn(\n+                    'The `check_same_thread` option was provided and set to '\n+                    'True. It will be overriden with False. Use the '\n+                    '`DatabaseWrapper.allow_thread_sharing` property instead '\n+                    'for controlling thread shareability.',\n+                    RuntimeWarning\n+                )\n+            kwargs.update({'check_same_thread': False})\n             self.connection = Database.connect(**kwargs)\n             # Register extract, date_trunc, and regexp functions.\n             self.connection.create_function(\"django_extract\", 2, _sqlite_extract)"
        },
        {
            "sha": "41ad6df72877b9f0dc5d6dcea7fd174a60072deb",
            "filename": "django/db/utils.py",
            "status": "modified",
            "additions": 8,
            "deletions": 4,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/34e248efeca272a2c0f2b15a5347dd66fc0340c9/django%2Fdb%2Futils.py",
            "raw_url": "https://github.com/django/django/raw/34e248efeca272a2c0f2b15a5347dd66fc0340c9/django%2Fdb%2Futils.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Futils.py?ref=34e248efeca272a2c0f2b15a5347dd66fc0340c9",
            "patch": "@@ -1,4 +1,5 @@\n import os\n+from threading import local\n \n from django.conf import settings\n from django.core.exceptions import ImproperlyConfigured\n@@ -50,7 +51,7 @@ class ConnectionDoesNotExist(Exception):\n class ConnectionHandler(object):\n     def __init__(self, databases):\n         self.databases = databases\n-        self._connections = {}\n+        self._connections = local()\n \n     def ensure_defaults(self, alias):\n         \"\"\"\n@@ -73,16 +74,19 @@ def ensure_defaults(self, alias):\n             conn.setdefault(setting, None)\n \n     def __getitem__(self, alias):\n-        if alias in self._connections:\n-            return self._connections[alias]\n+        if hasattr(self._connections, alias):\n+            return getattr(self._connections, alias)\n \n         self.ensure_defaults(alias)\n         db = self.databases[alias]\n         backend = load_backend(db['ENGINE'])\n         conn = backend.DatabaseWrapper(db, alias)\n-        self._connections[alias] = conn\n+        setattr(self._connections, alias, conn)\n         return conn\n \n+    def __setitem__(self, key, value):\n+        setattr(self._connections, key, value)\n+\n     def __iter__(self):\n         return iter(self.databases)\n "
        },
        {
            "sha": "f614dee5f8c42ea8f779965159b9368f5bf19435",
            "filename": "docs/releases/1.4.txt",
            "status": "modified",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/django/django/blob/34e248efeca272a2c0f2b15a5347dd66fc0340c9/docs%2Freleases%2F1.4.txt",
            "raw_url": "https://github.com/django/django/raw/34e248efeca272a2c0f2b15a5347dd66fc0340c9/docs%2Freleases%2F1.4.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.4.txt?ref=34e248efeca272a2c0f2b15a5347dd66fc0340c9",
            "patch": "@@ -673,6 +673,32 @@ datetimes are now stored without time zone information in SQLite. When\n :setting:`USE_TZ` is ``False``, if you attempt to save an aware datetime\n object, Django raises an exception.\n \n+Database connection's thread-locality\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+``DatabaseWrapper`` objects (i.e. the connection objects referenced by\n+``django.db.connection`` and ``django.db.connections[\"some_alias\"]``) used to\n+be thread-local. They are now global objects in order to be potentially shared\n+between multiple threads. While the individual connection objects are now\n+global, the ``django.db.connections`` dictionary referencing those objects is\n+still thread-local. Therefore if you just use the ORM or\n+``DatabaseWrapper.cursor()`` then the behavior is still the same as before.\n+Note, however, that ``django.db.connection`` does not directly reference the\n+default ``DatabaseWrapper`` object any more and is now a proxy to access that\n+object's attributes. If you need to access the actual ``DatabaseWrapper``\n+object, use ``django.db.connections[DEFAULT_DB_ALIAS]`` instead.\n+\n+As part of this change, all underlying SQLite connections are now enabled for\n+potential thread-sharing (by passing the ``check_same_thread=False`` attribute\n+to pysqlite). ``DatabaseWrapper`` however preserves the previous behavior by\n+disabling thread-sharing by default, so this does not affect any existing\n+code that purely relies on the ORM or on ``DatabaseWrapper.cursor()``.\n+\n+Finally, while it is now possible to pass connections between threads, Django\n+does not make any effort to synchronize access to the underlying backend.\n+Concurrency behavior is defined by the underlying backend implementation.\n+Check their documentation for details.\n+\n `COMMENTS_BANNED_USERS_GROUP` setting\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "82c21c8c7be78e401bd12bf88b894264798a6681",
            "filename": "tests/regressiontests/backends/tests.py",
            "status": "modified",
            "additions": 93,
            "deletions": 1,
            "changes": 94,
            "blob_url": "https://github.com/django/django/blob/34e248efeca272a2c0f2b15a5347dd66fc0340c9/tests%2Fregressiontests%2Fbackends%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/34e248efeca272a2c0f2b15a5347dd66fc0340c9/tests%2Fregressiontests%2Fbackends%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fbackends%2Ftests.py?ref=34e248efeca272a2c0f2b15a5347dd66fc0340c9",
            "patch": "@@ -3,6 +3,7 @@\n from __future__ import with_statement, absolute_import\n \n import datetime\n+import threading\n \n from django.conf import settings\n from django.core.management.color import no_style\n@@ -283,7 +284,7 @@ def receiver(sender, connection, **kwargs):\n         connection_created.connect(receiver)\n         connection.close()\n         cursor = connection.cursor()\n-        self.assertTrue(data[\"connection\"] is connection)\n+        self.assertTrue(data[\"connection\"].connection is connection.connection)\n \n         connection_created.disconnect(receiver)\n         data.clear()\n@@ -446,3 +447,94 @@ def test_check_constraints(self):\n                         connection.check_constraints()\n             finally:\n                 transaction.rollback()\n+\n+\n+class ThreadTests(TestCase):\n+\n+    def test_default_connection_thread_local(self):\n+        \"\"\"\n+        Ensure that the default connection (i.e. django.db.connection) is\n+        different for each thread.\n+        Refs #17258.\n+        \"\"\"\n+        connections_set = set()\n+        connection.cursor()\n+        connections_set.add(connection.connection)\n+        def runner():\n+            from django.db import connection\n+            connection.cursor()\n+            connections_set.add(connection.connection)\n+        for x in xrange(2):\n+            t = threading.Thread(target=runner)\n+            t.start()\n+            t.join()\n+        self.assertEquals(len(connections_set), 3)\n+        # Finish by closing the connections opened by the other threads (the\n+        # connection opened in the main thread will automatically be closed on\n+        # teardown).\n+        for conn in connections_set:\n+            if conn != connection.connection:\n+                conn.close()\n+\n+    def test_connections_thread_local(self):\n+        \"\"\"\n+        Ensure that the connections are different for each thread.\n+        Refs #17258.\n+        \"\"\"\n+        connections_set = set()\n+        for conn in connections.all():\n+            connections_set.add(conn)\n+        def runner():\n+            from django.db import connections\n+            for conn in connections.all():\n+                connections_set.add(conn)\n+        for x in xrange(2):\n+            t = threading.Thread(target=runner)\n+            t.start()\n+            t.join()\n+        self.assertEquals(len(connections_set), 6)\n+        # Finish by closing the connections opened by the other threads (the\n+        # connection opened in the main thread will automatically be closed on\n+        # teardown).\n+        for conn in connections_set:\n+            if conn != connection:\n+                conn.close()\n+\n+    def test_pass_connection_between_threads(self):\n+        \"\"\"\n+        Ensure that a connection can be passed from one thread to the other.\n+        Refs #17258.\n+        \"\"\"\n+        models.Person.objects.create(first_name=\"John\", last_name=\"Doe\")\n+\n+        def do_thread():\n+            def runner(main_thread_connection):\n+                from django.db import connections\n+                connections['default'] = main_thread_connection\n+                try:\n+                    models.Person.objects.get(first_name=\"John\", last_name=\"Doe\")\n+                except DatabaseError, e:\n+                    exceptions.append(e)\n+            t = threading.Thread(target=runner, args=[connections['default']])\n+            t.start()\n+            t.join()\n+\n+        # Without touching allow_thread_sharing, which should be False by default.\n+        exceptions = []\n+        do_thread()\n+        # Forbidden!\n+        self.assertTrue(isinstance(exceptions[0], DatabaseError))\n+\n+        # If explicitly setting allow_thread_sharing to False\n+        connections['default'].allow_thread_sharing = False\n+        exceptions = []\n+        do_thread()\n+        # Forbidden!\n+        self.assertTrue(isinstance(exceptions[0], DatabaseError))\n+\n+        # If explicitly setting allow_thread_sharing to True\n+        connections['default'].allow_thread_sharing = True\n+        exceptions = []\n+        do_thread()\n+        # All good\n+        self.assertEqual(len(exceptions), 0)\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 198,
        "additions": 187,
        "deletions": 11
    }
}