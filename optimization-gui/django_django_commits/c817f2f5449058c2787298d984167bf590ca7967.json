{
    "author": "jezdez",
    "message": "Fixed #16199 -- Added a Cookie based session backend. Many thanks to Eric Florenzano for his initial work and Florian Apollaner for reviewing.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16466 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "c817f2f5449058c2787298d984167bf590ca7967",
    "files": [
        {
            "sha": "966cbf6e8f1aeeba58a267610279beba3cfc01f5",
            "filename": "django/contrib/sessions/backends/signed_cookies.py",
            "status": "added",
            "additions": 93,
            "deletions": 0,
            "changes": 93,
            "blob_url": "https://github.com/django/django/blob/c817f2f5449058c2787298d984167bf590ca7967/django%2Fcontrib%2Fsessions%2Fbackends%2Fsigned_cookies.py",
            "raw_url": "https://github.com/django/django/raw/c817f2f5449058c2787298d984167bf590ca7967/django%2Fcontrib%2Fsessions%2Fbackends%2Fsigned_cookies.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fsessions%2Fbackends%2Fsigned_cookies.py?ref=c817f2f5449058c2787298d984167bf590ca7967",
            "patch": "@@ -0,0 +1,93 @@\n+try:\n+    import cPickle as pickle\n+except ImportError:\n+    import pickle\n+\n+from django.conf import settings\n+from django.core import signing\n+\n+from django.contrib.sessions.backends.base import SessionBase\n+\n+\n+class PickleSerializer(object):\n+    \"\"\"\n+    Simple wrapper around pickle to be used in signing.dumps and\n+    signing.loads.\n+    \"\"\"\n+    def dumps(self, obj):\n+        return pickle.dumps(obj, pickle.HIGHEST_PROTOCOL)\n+\n+    def loads(self, data):\n+        return pickle.loads(data)\n+\n+\n+class SessionStore(SessionBase):\n+\n+    def load(self):\n+        \"\"\"\n+        We load the data from the key itself instead of fetching from\n+        some external data store. Opposite of _get_session_key(),\n+        raises BadSignature if signature fails.\n+        \"\"\"\n+        try:\n+            return signing.loads(self._session_key,\n+                serializer=PickleSerializer,\n+                max_age=settings.SESSION_COOKIE_AGE,\n+                salt='django.contrib.sessions.backends.cookies')\n+        except (signing.BadSignature, ValueError):\n+            self.create()\n+        return {}\n+\n+    def create(self):\n+        \"\"\"\n+        To create a new key, we simply make sure that the modified flag is set\n+        so that the cookie is set on the client for the current request.\n+        \"\"\"\n+        self.modified = True\n+\n+    def save(self, must_create=False):\n+        \"\"\"\n+        To save, we get the session key as a securely signed string and then\n+        set the modified flag so that the cookie is set on the client for the\n+        current request.\n+        \"\"\"\n+        self._session_key = self._get_session_key()\n+        self.modified = True\n+\n+    def exists(self, session_key=None):\n+        \"\"\"\n+        This method makes sense when you're talking to a shared resource, but\n+        it doesn't matter when you're storing the information in the client's\n+        cookie.\n+        \"\"\"\n+        return False\n+\n+    def delete(self, session_key=None):\n+        \"\"\"\n+        To delete, we clear the session key and the underlying data structure\n+        and set the modified flag so that the cookie is set on the client for\n+        the current request.\n+        \"\"\"\n+        self._session_key = ''\n+        self._session_cache = {}\n+        self.modified = True\n+\n+    def cycle_key(self):\n+        \"\"\"\n+        Keeps the same data but with a new key.  To do this, we just have to\n+        call ``save()`` and it will automatically save a cookie with a new key\n+        at the end of the request.\n+        \"\"\"\n+        self.save()\n+\n+    def _get_session_key(self):\n+        \"\"\"\n+        Most session backends don't need to override this method, but we do,\n+        because instead of generating a random string, we want to actually\n+        generate a secure url-safe Base64-encoded string of data as our\n+        session key.\n+        \"\"\"\n+        session_cache = getattr(self, '_session_cache', {})\n+        return signing.dumps(session_cache, compress=True,\n+            salt='django.contrib.sessions.backends.cookies',\n+            serializer=PickleSerializer)"
        },
        {
            "sha": "25562756b965119760056ab8bca3e3ef54d31aea",
            "filename": "django/contrib/sessions/tests.py",
            "status": "modified",
            "additions": 41,
            "deletions": 36,
            "changes": 77,
            "blob_url": "https://github.com/django/django/blob/c817f2f5449058c2787298d984167bf590ca7967/django%2Fcontrib%2Fsessions%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/c817f2f5449058c2787298d984167bf590ca7967/django%2Fcontrib%2Fsessions%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fsessions%2Ftests.py?ref=c817f2f5449058c2787298d984167bf590ca7967",
            "patch": "@@ -7,11 +7,13 @@\n from django.contrib.sessions.backends.cache import SessionStore as CacheSession\n from django.contrib.sessions.backends.cached_db import SessionStore as CacheDBSession\n from django.contrib.sessions.backends.file import SessionStore as FileSession\n+from django.contrib.sessions.backends.cookies import SessionStore as CookieSession\n from django.contrib.sessions.models import Session\n from django.contrib.sessions.middleware import SessionMiddleware\n from django.core.exceptions import ImproperlyConfigured, SuspiciousOperation\n from django.http import HttpResponse\n from django.test import TestCase, RequestFactory\n+from django.test.utils import override_settings\n from django.utils import unittest\n \n \n@@ -213,35 +215,25 @@ def test_custom_expiry_reset(self):\n     def test_get_expire_at_browser_close(self):\n         # Tests get_expire_at_browser_close with different settings and different\n         # set_expiry calls\n-        try:\n-            try:\n-                original_expire_at_browser_close = settings.SESSION_EXPIRE_AT_BROWSER_CLOSE\n-                settings.SESSION_EXPIRE_AT_BROWSER_CLOSE = False\n-\n-                self.session.set_expiry(10)\n-                self.assertFalse(self.session.get_expire_at_browser_close())\n-\n-                self.session.set_expiry(0)\n-                self.assertTrue(self.session.get_expire_at_browser_close())\n+        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=False):\n+            self.session.set_expiry(10)\n+            self.assertFalse(self.session.get_expire_at_browser_close())\n \n-                self.session.set_expiry(None)\n-                self.assertFalse(self.session.get_expire_at_browser_close())\n+            self.session.set_expiry(0)\n+            self.assertTrue(self.session.get_expire_at_browser_close())\n \n-                settings.SESSION_EXPIRE_AT_BROWSER_CLOSE = True\n+            self.session.set_expiry(None)\n+            self.assertFalse(self.session.get_expire_at_browser_close())\n \n-                self.session.set_expiry(10)\n-                self.assertFalse(self.session.get_expire_at_browser_close())\n+        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=True):\n+            self.session.set_expiry(10)\n+            self.assertFalse(self.session.get_expire_at_browser_close())\n \n-                self.session.set_expiry(0)\n-                self.assertTrue(self.session.get_expire_at_browser_close())\n+            self.session.set_expiry(0)\n+            self.assertTrue(self.session.get_expire_at_browser_close())\n \n-                self.session.set_expiry(None)\n-                self.assertTrue(self.session.get_expire_at_browser_close())\n-\n-            except:\n-                raise\n-        finally:\n-            settings.SESSION_EXPIRE_AT_BROWSER_CLOSE = original_expire_at_browser_close\n+            self.session.set_expiry(None)\n+            self.assertTrue(self.session.get_expire_at_browser_close())\n \n     def test_decode(self):\n         # Ensure we can decode what we encode\n@@ -302,9 +294,10 @@ def tearDown(self):\n         shutil.rmtree(self.temp_session_store)\n         super(FileSessionTests, self).tearDown()\n \n+    @override_settings(\n+        SESSION_FILE_PATH=\"/if/this/directory/exists/you/have/a/weird/computer\")\n     def test_configuration_check(self):\n         # Make sure the file backend checks for a good storage dir\n-        settings.SESSION_FILE_PATH = \"/if/this/directory/exists/you/have/a/weird/computer\"\n         self.assertRaises(ImproperlyConfigured, self.backend)\n \n     def test_invalid_key_backslash(self):\n@@ -324,17 +317,9 @@ class CacheSessionTests(SessionTestsMixin, unittest.TestCase):\n \n \n class SessionMiddlewareTests(unittest.TestCase):\n-    def setUp(self):\n-        self.old_SESSION_COOKIE_SECURE = settings.SESSION_COOKIE_SECURE\n-        self.old_SESSION_COOKIE_HTTPONLY = settings.SESSION_COOKIE_HTTPONLY\n-\n-    def tearDown(self):\n-        settings.SESSION_COOKIE_SECURE = self.old_SESSION_COOKIE_SECURE\n-        settings.SESSION_COOKIE_HTTPONLY = self.old_SESSION_COOKIE_HTTPONLY\n \n+    @override_settings(SESSION_COOKIE_SECURE=True)\n     def test_secure_session_cookie(self):\n-        settings.SESSION_COOKIE_SECURE = True\n-\n         request = RequestFactory().get('/')\n         response = HttpResponse('Session test')\n         middleware = SessionMiddleware()\n@@ -347,9 +332,8 @@ def test_secure_session_cookie(self):\n         response = middleware.process_response(request, response)\n         self.assertTrue(response.cookies[settings.SESSION_COOKIE_NAME]['secure'])\n \n+    @override_settings(SESSION_COOKIE_HTTPONLY=True)\n     def test_httponly_session_cookie(self):\n-        settings.SESSION_COOKIE_HTTPONLY = True\n-\n         request = RequestFactory().get('/')\n         response = HttpResponse('Session test')\n         middleware = SessionMiddleware()\n@@ -361,3 +345,24 @@ def test_httponly_session_cookie(self):\n         # Handle the response through the middleware\n         response = middleware.process_response(request, response)\n         self.assertTrue(response.cookies[settings.SESSION_COOKIE_NAME]['httponly'])\n+\n+\n+class CookieSessionTests(SessionTestsMixin, TestCase):\n+\n+    backend = CookieSession\n+\n+    def test_save(self):\n+        \"\"\"\n+        This test tested exists() in the other session backends, but that\n+        doesn't make sense for us.\n+        \"\"\"\n+        pass\n+\n+    def test_cycle(self):\n+        \"\"\"\n+        This test tested cycle_key() which would create a new session\n+        key for the same session data. But we can't invalidate previously\n+        signed cookies (other than letting them expire naturally) so\n+        testing for this behaviour is meaningless.\n+        \"\"\"\n+        pass"
        },
        {
            "sha": "06b6c78f1c4dc6830799b35c37125acb38433863",
            "filename": "django/core/signing.py",
            "status": "modified",
            "additions": 34,
            "deletions": 21,
            "changes": 55,
            "blob_url": "https://github.com/django/django/blob/c817f2f5449058c2787298d984167bf590ca7967/django%2Fcore%2Fsigning.py",
            "raw_url": "https://github.com/django/django/raw/c817f2f5449058c2787298d984167bf590ca7967/django%2Fcore%2Fsigning.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fsigning.py?ref=c817f2f5449058c2787298d984167bf590ca7967",
            "patch": "@@ -3,33 +3,33 @@\n \n The format used looks like this:\n \n->>> signed.dumps(\"hello\")\n-'ImhlbGxvIg.RjVSUCt6S64WBilMYxG89-l0OA8'\n+>>> signing.dumps(\"hello\")\n+'ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv422nZA4sgmk'\n \n-There are two components here, separatad by a '.'. The first component is a\n+There are two components here, separatad by a ':'. The first component is a\n URLsafe base64 encoded JSON of the object passed to dumps(). The second\n-component is a base64 encoded hmac/SHA1 hash of \"$first_component.$secret\"\n+component is a base64 encoded hmac/SHA1 hash of \"$first_component:$secret\"\n \n-signed.loads(s) checks the signature and returns the deserialised object.\n+signing.loads(s) checks the signature and returns the deserialised object.\n If the signature fails, a BadSignature exception is raised.\n \n->>> signed.loads(\"ImhlbGxvIg.RjVSUCt6S64WBilMYxG89-l0OA8\")\n+>>> signing.loads(\"ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv422nZA4sgmk\")\n u'hello'\n->>> signed.loads(\"ImhlbGxvIg.RjVSUCt6S64WBilMYxG89-l0OA8-modified\")\n+>>> signing.loads(\"ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv422nZA4sgmk-modified\")\n ...\n-BadSignature: Signature failed: RjVSUCt6S64WBilMYxG89-l0OA8-modified\n+BadSignature: Signature failed: ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv422nZA4sgmk-modified\n \n You can optionally compress the JSON prior to base64 encoding it to save\n space, using the compress=True argument. This checks if compression actually\n helps and only applies compression if the result is a shorter string:\n \n->>> signed.dumps(range(1, 20), compress=True)\n-'.eJwFwcERACAIwLCF-rCiILN47r-GyZVJsNgkxaFxoDgxcOHGxMKD_T7vhAml.oFq6lAAEbkHXBHfGnVX7Qx6NlZ8'\n+>>> signing.dumps(range(1, 20), compress=True)\n+'.eJwFwcERACAIwLCF-rCiILN47r-GyZVJsNgkxaFxoDgxcOHGxMKD_T7vhAml:1QaUaL:BA0thEZrp4FQVXIXuOvYJtLJSrQ'\n \n The fact that the string is compressed is signalled by the prefixed '.' at the\n start of the base64 JSON.\n \n-There are 65 url-safe characters: the 64 used by url-safe base64 and the '.'.\n+There are 65 url-safe characters: the 64 used by url-safe base64 and the ':'.\n These functions make use of all of them.\n \"\"\"\n import base64\n@@ -87,7 +87,19 @@ def get_cookie_signer(salt='django.core.signing.get_cookie_signer'):\n     return Signer('django.http.cookies' + settings.SECRET_KEY, salt=salt)\n \n \n-def dumps(obj, key=None, salt='django.core.signing', compress=False):\n+class JSONSerializer(object):\n+    \"\"\"\n+    Simple wrapper around simplejson to be used in signing.dumps and\n+    signing.loads.\n+    \"\"\"\n+    def dumps(self, obj):\n+        return simplejson.dumps(obj, separators=(',', ':'))\n+\n+    def loads(self, data):\n+        return simplejson.loads(data)\n+\n+\n+def dumps(obj, key=None, salt='django.core.signing', serializer=JSONSerializer, compress=False):\n     \"\"\"\n     Returns URL-safe, sha1 signed base64 compressed JSON string. If key is\n     None, settings.SECRET_KEY is used instead.\n@@ -101,24 +113,24 @@ def dumps(obj, key=None, salt='django.core.signing', compress=False):\n     value or re-using a salt value across different parts of your\n     application without good cause is a security risk.\n     \"\"\"\n-    json = simplejson.dumps(obj, separators=(',', ':'))\n+    data = serializer().dumps(obj)\n \n     # Flag for if it's been compressed or not\n     is_compressed = False\n \n     if compress:\n         # Avoid zlib dependency unless compress is being used\n-        compressed = zlib.compress(json)\n-        if len(compressed) < (len(json) - 1):\n-            json = compressed\n+        compressed = zlib.compress(data)\n+        if len(compressed) < (len(data) - 1):\n+            data = compressed\n             is_compressed = True\n-    base64d = b64_encode(json)\n+    base64d = b64_encode(data)\n     if is_compressed:\n         base64d = '.' + base64d\n     return TimestampSigner(key, salt=salt).sign(base64d)\n \n \n-def loads(s, key=None, salt='django.core.signing', max_age=None):\n+def loads(s, key=None, salt='django.core.signing', serializer=JSONSerializer, max_age=None):\n     \"\"\"\n     Reverse of dumps(), raises BadSignature if signature fails\n     \"\"\"\n@@ -129,10 +141,10 @@ def loads(s, key=None, salt='django.core.signing', max_age=None):\n         # It's compressed; uncompress it first\n         base64d = base64d[1:]\n         decompress = True\n-    json = b64_decode(base64d)\n+    data = b64_decode(base64d)\n     if decompress:\n-        json = zlib.decompress(json)\n-    return simplejson.loads(json)\n+        data = zlib.decompress(data)\n+    return serializer().loads(data)\n \n \n class Signer(object):\n@@ -160,6 +172,7 @@ def unsign(self, signed_value):\n \n \n class TimestampSigner(Signer):\n+\n     def timestamp(self):\n         return baseconv.base62.encode(int(time.time()))\n "
        },
        {
            "sha": "c01ff092b8adaa5601e537cf541a5ef4552b45dc",
            "filename": "docs/releases/1.4.txt",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/c817f2f5449058c2787298d984167bf590ca7967/docs%2Freleases%2F1.4.txt",
            "raw_url": "https://github.com/django/django/raw/c817f2f5449058c2787298d984167bf590ca7967/docs%2Freleases%2F1.4.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.4.txt?ref=c817f2f5449058c2787298d984167bf590ca7967",
            "patch": "@@ -89,6 +89,16 @@ signing in Web applications.\n \n See :doc:`cryptographic signing </topics/signing>` docs for more information.\n \n+Cookie-based session backend\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Django 1.4 introduces a new cookie based backend for the session framework\n+which uses the tools for :doc:`cryptographic signing </topics/signing>` to\n+store the session data in the client's browser.\n+\n+See the :ref:`cookie-based backend <cookie-session-backend>` docs for\n+more information.\n+\n New form wizard\n ~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "fb86a98ed98bb15781f0e737f8468fc5b0b9bfd0",
            "filename": "docs/topics/http/sessions.txt",
            "status": "modified",
            "additions": 38,
            "deletions": 4,
            "changes": 42,
            "blob_url": "https://github.com/django/django/blob/c817f2f5449058c2787298d984167bf590ca7967/docs%2Ftopics%2Fhttp%2Fsessions.txt",
            "raw_url": "https://github.com/django/django/raw/c817f2f5449058c2787298d984167bf590ca7967/docs%2Ftopics%2Fhttp%2Fsessions.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fhttp%2Fsessions.txt?ref=c817f2f5449058c2787298d984167bf590ca7967",
            "patch": "@@ -5,10 +5,11 @@ How to use sessions\n .. module:: django.contrib.sessions\n    :synopsis: Provides session management for Django projects.\n \n-Django provides full support for anonymous sessions. The session framework lets\n-you store and retrieve arbitrary data on a per-site-visitor basis. It stores\n-data on the server side and abstracts the sending and receiving of cookies.\n-Cookies contain a session ID -- not the data itself.\n+Django provides full support for anonymous sessions. The session framework\n+lets you store and retrieve arbitrary data on a per-site-visitor basis. It\n+stores data on the server side and abstracts the sending and receiving of\n+cookies. Cookies contain a session ID -- not the data itself (unless you're\n+using the :ref:`cookie based backend<cookie-session-backend>`).\n \n Enabling sessions\n =================\n@@ -95,6 +96,38 @@ defaults to output from ``tempfile.gettempdir()``, most likely ``/tmp``) to\n control where Django stores session files. Be sure to check that your Web\n server has permissions to read and write to this location.\n \n+.. _cookie-session-backend:\n+\n+Using cookie-based sessions\n+---------------------------\n+\n+.. versionadded:: 1.4\n+\n+To use cookies-based sessions, set the :setting:`SESSION_ENGINE` setting to\n+``\"django.contrib.sessions.backends.cookies\"``. The session data will be\n+stored using Django's tools for :doc:`cryptographic signing </topics/signing>`\n+and the :setting:`SECRET_KEY` setting.\n+\n+.. note::\n+\n+    It's recommended to set the :setting:`SESSION_COOKIE_HTTPONLY` setting\n+    to ``True`` to prevent tampering of the stored data from JavaScript.\n+\n+.. warning::\n+\n+    **The session data is signed but not encrypted!**\n+\n+    When using the cookies backend the session data can be read out\n+    and will be invalidated when being tampered with. The same invalidation\n+    happens if the client storing the cookie (e.g. your user's browser)\n+    can't store all of the session cookie and drops data. Even though\n+    Django compresses the data, it's still entirely possible to exceed\n+    the `common limit of 4096 bytes`_ per cookie.\n+\n+    Also, the size of a cookie can have an impact on the `speed of your site`_.\n+\n+.. _`common limit of 4096 bytes`: http://tools.ietf.org/html/rfc2965#section-5.3\n+.. _`speed of your site`: http://yuiblog.com/blog/2007/03/01/performance-research-part-3/\n \n Using sessions in views\n =======================\n@@ -420,6 +453,7 @@ Controls where Django stores session data. Valid values are:\n     * ``'django.contrib.sessions.backends.file'``\n     * ``'django.contrib.sessions.backends.cache'``\n     * ``'django.contrib.sessions.backends.cached_db'``\n+    * ``'django.contrib.sessions.backends.signed_cookies'``\n \n See `configuring the session engine`_ for more details.\n "
        }
    ],
    "stats": {
        "total": 277,
        "additions": 216,
        "deletions": 61
    }
}