{
    "author": "aaugustin",
    "message": "Fixed #18023 -- Removed bundled simplejson.\n\nAnd started the deprecation path for django.utils.simplejson.\n\nThanks Alex Ogier, Clueless, and other contributors for their\nwork on the patch.",
    "sha": "cec6bd5a59547dc97fe98975c570fc27a1e970be",
    "files": [
        {
            "sha": "2dde740b06fdc07594bd1e25b21a129afbb181fe",
            "filename": "MANIFEST.in",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/MANIFEST.in",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/MANIFEST.in",
            "contents_url": "https://api.github.com/repos/django/django/contents/MANIFEST.in?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -6,7 +6,6 @@ include MANIFEST.in\n include django/contrib/gis/gdal/LICENSE\n include django/contrib/gis/geos/LICENSE\n include django/dispatch/license.txt\n-include django/utils/simplejson/LICENSE.txt\n recursive-include docs *\n recursive-include scripts *\n recursive-include extras *"
        },
        {
            "sha": "e80361042f4d86ce4e2995ca43dd604a9add771e",
            "filename": "django/contrib/formtools/wizard/storage/cookie.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Fcontrib%2Fformtools%2Fwizard%2Fstorage%2Fcookie.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Fcontrib%2Fformtools%2Fwizard%2Fstorage%2Fcookie.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fformtools%2Fwizard%2Fstorage%2Fcookie.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -1,6 +1,7 @@\n+import json\n+\n from django.core.exceptions import SuspiciousOperation\n from django.core.signing import BadSignature\n-from django.utils import simplejson as json\n \n from django.contrib.formtools.wizard import storage\n "
        },
        {
            "sha": "f92740248e5474ed0cf763ac7c4e0c0c3fc1a6a4",
            "filename": "django/contrib/gis/geometry/test_data.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Fcontrib%2Fgis%2Fgeometry%2Ftest_data.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Fcontrib%2Fgis%2Fgeometry%2Ftest_data.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fgeometry%2Ftest_data.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -3,10 +3,10 @@\n for the GEOS and GDAL tests.\n \"\"\"\n import gzip\n+import json\n import os\n \n from django.contrib import gis\n-from django.utils import simplejson\n \n \n # This global used to store reference geometry data.\n@@ -100,6 +100,6 @@ def geometries(self):\n         if GEOMETRIES is None:\n             # Load up the test geometry data from fixture into global.\n             gzf = gzip.GzipFile(os.path.join(TEST_DATA, 'geometries.json.gz'))\n-            geometries = simplejson.loads(gzf.read())\n+            geometries = json.loads(gzf.read())\n             GEOMETRIES = TestGeomSet(**strconvert(geometries))\n         return GEOMETRIES"
        },
        {
            "sha": "07620050c7b907830c1fdf41902249ac1528a22f",
            "filename": "django/contrib/messages/storage/cookie.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Fcontrib%2Fmessages%2Fstorage%2Fcookie.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Fcontrib%2Fmessages%2Fstorage%2Fcookie.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fmessages%2Fstorage%2Fcookie.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -1,7 +1,8 @@\n+import json\n+\n from django.conf import settings\n from django.contrib.messages.storage.base import BaseStorage, Message\n from django.http import SimpleCookie\n-from django.utils import simplejson as json\n from django.utils.crypto import salted_hmac, constant_time_compare\n \n "
        },
        {
            "sha": "19d0e083849b57aeb3e0a8e636e1bb9c5be95a7d",
            "filename": "django/contrib/messages/tests/cookie.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Fcontrib%2Fmessages%2Ftests%2Fcookie.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Fcontrib%2Fmessages%2Ftests%2Fcookie.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fmessages%2Ftests%2Fcookie.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -1,10 +1,11 @@\n+import json\n+\n from django.contrib.messages import constants\n from django.contrib.messages.tests.base import BaseTest\n from django.contrib.messages.storage.cookie import (CookieStorage,\n     MessageEncoder, MessageDecoder)\n from django.contrib.messages.storage.base import Message\n from django.test.utils import override_settings\n-from django.utils import simplejson as json\n \n \n def set_cookie_data(storage, messages, invalid=False, encode_empty=False):"
        },
        {
            "sha": "ab0cd0e5908f32d0d05fca0485163acdba6f4d9b",
            "filename": "django/core/serializers/json.py",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Fcore%2Fserializers%2Fjson.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Fcore%2Fserializers%2Fjson.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fserializers%2Fjson.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -2,14 +2,17 @@\n Serialize data to/from JSON\n \"\"\"\n \n+# Avoid shadowing the standard library json module\n+from __future__ import absolute_import\n+\n import datetime\n import decimal\n+import json\n from StringIO import StringIO\n \n from django.core.serializers.base import DeserializationError\n from django.core.serializers.python import Serializer as PythonSerializer\n from django.core.serializers.python import Deserializer as PythonDeserializer\n-from django.utils import simplejson\n from django.utils.timezone import is_aware\n \n class Serializer(PythonSerializer):\n@@ -19,10 +22,10 @@ class Serializer(PythonSerializer):\n     internal_use_only = False\n \n     def end_serialization(self):\n-        if simplejson.__version__.split('.') >= ['2', '1', '3']:\n+        if json.__version__.split('.') >= ['2', '1', '3']:\n             # Use JS strings to represent Python Decimal instances (ticket #16850)\n             self.options.update({'use_decimal': False})\n-        simplejson.dump(self.objects, self.stream, cls=DjangoJSONEncoder, **self.options)\n+        json.dump(self.objects, self.stream, cls=DjangoJSONEncoder, **self.options)\n \n     def getvalue(self):\n         if callable(getattr(self.stream, 'getvalue', None)):\n@@ -38,7 +41,7 @@ def Deserializer(stream_or_string, **options):\n     else:\n         stream = stream_or_string\n     try:\n-        for obj in PythonDeserializer(simplejson.load(stream), **options):\n+        for obj in PythonDeserializer(json.load(stream), **options):\n             yield obj\n     except GeneratorExit:\n         raise\n@@ -47,7 +50,7 @@ def Deserializer(stream_or_string, **options):\n         raise DeserializationError(e)\n \n \n-class DjangoJSONEncoder(simplejson.JSONEncoder):\n+class DjangoJSONEncoder(json.JSONEncoder):\n     \"\"\"\n     JSONEncoder subclass that knows how to encode date/time and decimal types.\n     \"\"\""
        },
        {
            "sha": "f2c79de706eba4622b93748487078efe4e4c97c1",
            "filename": "django/core/signing.py",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Fcore%2Fsigning.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Fcore%2Fsigning.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fsigning.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -33,12 +33,13 @@\n These functions make use of all of them.\n \"\"\"\n import base64\n+import json\n import time\n import zlib\n \n from django.conf import settings\n from django.core.exceptions import ImproperlyConfigured\n-from django.utils import baseconv, simplejson\n+from django.utils import baseconv\n from django.utils.crypto import constant_time_compare, salted_hmac\n from django.utils.encoding import force_unicode, smart_str\n from django.utils.importlib import import_module\n@@ -89,14 +90,14 @@ def get_cookie_signer(salt='django.core.signing.get_cookie_signer'):\n \n class JSONSerializer(object):\n     \"\"\"\n-    Simple wrapper around simplejson to be used in signing.dumps and\n+    Simple wrapper around json to be used in signing.dumps and\n     signing.loads.\n     \"\"\"\n     def dumps(self, obj):\n-        return simplejson.dumps(obj, separators=(',', ':'))\n+        return json.dumps(obj, separators=(',', ':'))\n \n     def loads(self, data):\n-        return simplejson.loads(data)\n+        return json.loads(data)\n \n \n def dumps(obj, key=None, salt='django.core.signing', serializer=JSONSerializer, compress=False):"
        },
        {
            "sha": "b923bde1393bd053b9d4deaeedcb613e56702d0b",
            "filename": "django/test/testcases.py",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Ftest%2Ftestcases.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Ftest%2Ftestcases.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Ftestcases.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -1,4 +1,5 @@\n import difflib\n+import json\n import os\n import re\n import sys\n@@ -33,7 +34,7 @@\n from django.test.utils import (get_warnings_state, restore_warnings_state,\n     override_settings)\n from django.test.utils import ContextList\n-from django.utils import simplejson, unittest as ut2\n+from django.utils import unittest as ut2\n from django.utils.encoding import smart_str, force_unicode\n from django.utils.unittest.util import safe_repr\n from django.views.static import serve\n@@ -189,8 +190,8 @@ def check_output_json(self, want, got, optionsflags):\n         \"\"\"\n         want, got = self._strip_quotes(want, got)\n         try:\n-            want_json = simplejson.loads(want)\n-            got_json = simplejson.loads(got)\n+            want_json = json.loads(want)\n+            got_json = json.loads(got)\n         except Exception:\n             return False\n         return want_json == got_json"
        },
        {
            "sha": "a851a4f8ef869473c92669e380f52122015c3875",
            "filename": "django/utils/simplejson.py",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Futils%2Fsimplejson.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/django%2Futils%2Fsimplejson.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fsimplejson.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -0,0 +1,31 @@\n+# Django 1.5 only supports Python >= 2.6, where the standard library includes\n+# the json module. Previous version of Django shipped a copy for Python < 2.6.\n+\n+# For backwards compatibility, we're keeping an importable json module\n+# at this location, with the same lookup sequence.\n+\n+# Avoid shadowing the simplejson module\n+from __future__ import absolute_import\n+\n+import warnings\n+warnings.warn(\"django.utils.simplejson is deprecated; use json instead.\",\n+              PendingDeprecationWarning)\n+\n+try:\n+    import simplejson\n+except ImportError:\n+    use_simplejson = False\n+else:\n+    # The system-installed version has priority providing it is either not an\n+    # earlier version or it contains the C speedups.\n+    from json import __version__ as stdlib_json_version\n+    use_simplejson = (hasattr(simplejson, '_speedups') or\n+        simplejson.__version__.split('.') >= stdlib_json_version.split('.'))\n+\n+# Make sure we copy over the version. See #17071\n+if use_simplejson:\n+    from simplejson import *\n+    from simplejson import __version__\n+else:\n+    from json import *\n+    from json import __version__"
        },
        {
            "sha": "ad95f29c172aaf259fc3adb087b2d3dd021f10ad",
            "filename": "django/utils/simplejson/LICENSE.txt",
            "status": "removed",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/ee0a7c741e98214bac7eeb60b848cf099ff28836/django%2Futils%2Fsimplejson%2FLICENSE.txt",
            "raw_url": "https://github.com/django/django/raw/ee0a7c741e98214bac7eeb60b848cf099ff28836/django%2Futils%2Fsimplejson%2FLICENSE.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fsimplejson%2FLICENSE.txt?ref=ee0a7c741e98214bac7eeb60b848cf099ff28836",
            "patch": "@@ -1,19 +0,0 @@\n-Copyright (c) 2006 Bob Ippolito\n-\n-Permission is hereby granted, free of charge, to any person obtaining a copy of\n-this software and associated documentation files (the \"Software\"), to deal in\n-the Software without restriction, including without limitation the rights to\n-use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n-of the Software, and to permit persons to whom the Software is furnished to do\n-so, subject to the following conditions:\n-\n-The above copyright notice and this permission notice shall be included in all\n-copies or substantial portions of the Software.\n-\n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n-SOFTWARE."
        },
        {
            "sha": "2fb3733d1151d66eab74f92f760acb60e40ec50f",
            "filename": "django/utils/simplejson/__init__.py",
            "status": "removed",
            "additions": 0,
            "deletions": 354,
            "changes": 354,
            "blob_url": "https://github.com/django/django/blob/ee0a7c741e98214bac7eeb60b848cf099ff28836/django%2Futils%2Fsimplejson%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/ee0a7c741e98214bac7eeb60b848cf099ff28836/django%2Futils%2Fsimplejson%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fsimplejson%2F__init__.py?ref=ee0a7c741e98214bac7eeb60b848cf099ff28836",
            "patch": "@@ -1,354 +0,0 @@\n-r\"\"\"JSON (JavaScript Object Notation) <http://json.org> is a subset of\n-JavaScript syntax (ECMA-262 3rd edition) used as a lightweight data\n-interchange format.\n-\n-:mod:`simplejson` exposes an API familiar to users of the standard library\n-:mod:`marshal` and :mod:`pickle` modules. It is the externally maintained\n-version of the :mod:`json` library contained in Python 2.6, but maintains\n-compatibility with Python 2.4 and Python 2.5 and (currently) has\n-significant performance advantages, even without using the optional C\n-extension for speedups.\n-\n-Encoding basic Python object hierarchies::\n-\n-    >>> import simplejson as json\n-    >>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n-    '[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n-    >>> print json.dumps(\"\\\"foo\\bar\")\n-    \"\\\"foo\\bar\"\n-    >>> print json.dumps(u'\\u1234')\n-    \"\\u1234\"\n-    >>> print json.dumps('\\\\')\n-    \"\\\\\"\n-    >>> print json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True)\n-    {\"a\": 0, \"b\": 0, \"c\": 0}\n-    >>> from StringIO import StringIO\n-    >>> io = StringIO()\n-    >>> json.dump(['streaming API'], io)\n-    >>> io.getvalue()\n-    '[\"streaming API\"]'\n-\n-Compact encoding::\n-\n-    >>> import simplejson as json\n-    >>> json.dumps([1,2,3,{'4': 5, '6': 7}], separators=(',',':'))\n-    '[1,2,3,{\"4\":5,\"6\":7}]'\n-\n-Pretty printing::\n-\n-    >>> import simplejson as json\n-    >>> s = json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4)\n-    >>> print '\\n'.join([l.rstrip() for l in  s.splitlines()])\n-    {\n-        \"4\": 5,\n-        \"6\": 7\n-    }\n-\n-Decoding JSON::\n-\n-    >>> import simplejson as json\n-    >>> obj = [u'foo', {u'bar': [u'baz', None, 1.0, 2]}]\n-    >>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]') == obj\n-    True\n-    >>> json.loads('\"\\\\\"foo\\\\bar\"') == u'\"foo\\x08ar'\n-    True\n-    >>> from StringIO import StringIO\n-    >>> io = StringIO('[\"streaming API\"]')\n-    >>> json.load(io)[0] == 'streaming API'\n-    True\n-\n-Specializing JSON object decoding::\n-\n-    >>> import simplejson as json\n-    >>> def as_complex(dct):\n-    ...     if '__complex__' in dct:\n-    ...         return complex(dct['real'], dct['imag'])\n-    ...     return dct\n-    ...\n-    >>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n-    ...     object_hook=as_complex)\n-    (1+2j)\n-    >>> import decimal\n-    >>> json.loads('1.1', parse_float=decimal.Decimal) == decimal.Decimal('1.1')\n-    True\n-\n-Specializing JSON object encoding::\n-\n-    >>> import simplejson as json\n-    >>> def encode_complex(obj):\n-    ...     if isinstance(obj, complex):\n-    ...         return [obj.real, obj.imag]\n-    ...     raise TypeError(\"%r is not JSON serializable\" % (o,))\n-    ...\n-    >>> json.dumps(2 + 1j, default=encode_complex)\n-    '[2.0, 1.0]'\n-    >>> json.JSONEncoder(default=encode_complex).encode(2 + 1j)\n-    '[2.0, 1.0]'\n-    >>> ''.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j))\n-    '[2.0, 1.0]'\n-\n-\n-Using simplejson.tool from the shell to validate and pretty-print::\n-\n-    $ echo '{\"json\":\"obj\"}' | python -msimplejson.tool\n-    {\n-        \"json\": \"obj\"\n-    }\n-    $ echo '{ 1.2:3.4}' | python -msimplejson.tool\n-    Expecting property name: line 1 column 2 (char 2)\n-\"\"\"\n-\n-# Django modification: try to use the system version first, providing it's\n-# either of a later version of has the C speedups in place. Otherwise, fall\n-# back to our local copy.\n-\n-__version__ = '2.0.7'\n-\n-use_system_version = False\n-try:\n-    # The system-installed version has priority providing it is either not an\n-    # earlier version or it contains the C speedups.\n-    import simplejson\n-    if (simplejson.__version__.split('.') >= __version__.split('.') or\n-            hasattr(simplejson, '_speedups')):\n-        from simplejson import *\n-        use_system_version = True\n-        # Make sure we copy over the version. See #17071\n-        __version__ = simplejson.__version__\n-except ImportError:\n-    pass\n-\n-if not use_system_version:\n-    try:\n-        from json import *      # Python 2.6 preferred over local copy.\n-\n-        # There is a \"json\" package around that is not Python's \"json\", so we\n-        # check for something that is only in the namespace of the version we\n-        # want.\n-        JSONDecoder\n-\n-        use_system_version = True\n-        # Make sure we copy over the version. See #17071\n-        from json import __version__ as json_version\n-        __version__ = json_version\n-    except (ImportError, NameError):\n-        pass\n-\n-# If all else fails, we have a bundled version that can be used.\n-if not use_system_version:\n-    __all__ = [\n-        'dump', 'dumps', 'load', 'loads',\n-        'JSONDecoder', 'JSONEncoder',\n-    ]\n-\n-    from django.utils.simplejson.decoder import JSONDecoder\n-    from django.utils.simplejson.encoder import JSONEncoder\n-\n-    _default_encoder = JSONEncoder(\n-        skipkeys=False,\n-        ensure_ascii=True,\n-        check_circular=True,\n-        allow_nan=True,\n-        indent=None,\n-        separators=None,\n-        encoding='utf-8',\n-        default=None,\n-    )\n-\n-    def dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True,\n-            allow_nan=True, cls=None, indent=None, separators=None,\n-            encoding='utf-8', default=None, **kw):\n-        \"\"\"Serialize ``obj`` as a JSON formatted stream to ``fp`` (a\n-        ``.write()``-supporting file-like object).\n-\n-        If ``skipkeys`` is ``True`` then ``dict`` keys that are not basic types\n-        (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)\n-        will be skipped instead of raising a ``TypeError``.\n-\n-        If ``ensure_ascii`` is ``False``, then the some chunks written to ``fp``\n-        may be ``unicode`` instances, subject to normal Python ``str`` to\n-        ``unicode`` coercion rules. Unless ``fp.write()`` explicitly\n-        understands ``unicode`` (as in ``codecs.getwriter()``) this is likely\n-        to cause an error.\n-\n-        If ``check_circular`` is ``False``, then the circular reference check\n-        for container types will be skipped and a circular reference will\n-        result in an ``OverflowError`` (or worse).\n-\n-        If ``allow_nan`` is ``False``, then it will be a ``ValueError`` to\n-        serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)\n-        in strict compliance of the JSON specification, instead of using the\n-        JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n-\n-        If ``indent`` is a non-negative integer, then JSON array elements and object\n-        members will be pretty-printed with that indent level. An indent level\n-        of 0 will only insert newlines. ``None`` is the most compact representation.\n-\n-        If ``separators`` is an ``(item_separator, dict_separator)`` tuple\n-        then it will be used instead of the default ``(', ', ': ')`` separators.\n-        ``(',', ':')`` is the most compact JSON representation.\n-\n-        ``encoding`` is the character encoding for str instances, default is UTF-8.\n-\n-        ``default(obj)`` is a function that should return a serializable version\n-        of obj or raise TypeError. The default simply raises TypeError.\n-\n-        To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n-        ``.default()`` method to serialize additional types), specify it with\n-        the ``cls`` kwarg.\n-\n-        \"\"\"\n-        # cached encoder\n-        if (skipkeys is False and ensure_ascii is True and\n-            check_circular is True and allow_nan is True and\n-            cls is None and indent is None and separators is None and\n-            encoding == 'utf-8' and default is None and not kw):\n-            iterable = _default_encoder.iterencode(obj)\n-        else:\n-            if cls is None:\n-                cls = JSONEncoder\n-            iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii,\n-                check_circular=check_circular, allow_nan=allow_nan, indent=indent,\n-                separators=separators, encoding=encoding,\n-                default=default, **kw).iterencode(obj)\n-        # could accelerate with writelines in some versions of Python, at\n-        # a debuggability cost\n-        for chunk in iterable:\n-            fp.write(chunk)\n-\n-\n-    def dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True,\n-            allow_nan=True, cls=None, indent=None, separators=None,\n-            encoding='utf-8', default=None, **kw):\n-        \"\"\"Serialize ``obj`` to a JSON formatted ``str``.\n-\n-        If ``skipkeys`` is ``True`` then ``dict`` keys that are not basic types\n-        (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)\n-        will be skipped instead of raising a ``TypeError``.\n-\n-        If ``ensure_ascii`` is ``False``, then the return value will be a\n-        ``unicode`` instance subject to normal Python ``str`` to ``unicode``\n-        coercion rules instead of being escaped to an ASCII ``str``.\n-\n-        If ``check_circular`` is ``False``, then the circular reference check\n-        for container types will be skipped and a circular reference will\n-        result in an ``OverflowError`` (or worse).\n-\n-        If ``allow_nan`` is ``False``, then it will be a ``ValueError`` to\n-        serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in\n-        strict compliance of the JSON specification, instead of using the\n-        JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n-\n-        If ``indent`` is a non-negative integer, then JSON array elements and\n-        object members will be pretty-printed with that indent level. An indent\n-        level of 0 will only insert newlines. ``None`` is the most compact\n-        representation.\n-\n-        If ``separators`` is an ``(item_separator, dict_separator)`` tuple\n-        then it will be used instead of the default ``(', ', ': ')`` separators.\n-        ``(',', ':')`` is the most compact JSON representation.\n-\n-        ``encoding`` is the character encoding for str instances, default is UTF-8.\n-\n-        ``default(obj)`` is a function that should return a serializable version\n-        of obj or raise TypeError. The default simply raises TypeError.\n-\n-        To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n-        ``.default()`` method to serialize additional types), specify it with\n-        the ``cls`` kwarg.\n-\n-        \"\"\"\n-        # cached encoder\n-        if (skipkeys is False and ensure_ascii is True and\n-            check_circular is True and allow_nan is True and\n-            cls is None and indent is None and separators is None and\n-            encoding == 'utf-8' and default is None and not kw):\n-            return _default_encoder.encode(obj)\n-        if cls is None:\n-            cls = JSONEncoder\n-        return cls(\n-            skipkeys=skipkeys, ensure_ascii=ensure_ascii,\n-            check_circular=check_circular, allow_nan=allow_nan, indent=indent,\n-            separators=separators, encoding=encoding, default=default,\n-            **kw).encode(obj)\n-\n-\n-    _default_decoder = JSONDecoder(encoding=None, object_hook=None)\n-\n-\n-    def load(fp, encoding=None, cls=None, object_hook=None, parse_float=None,\n-            parse_int=None, parse_constant=None, **kw):\n-        \"\"\"Deserialize ``fp`` (a ``.read()``-supporting file-like object containing\n-        a JSON document) to a Python object.\n-\n-        If the contents of ``fp`` is encoded with an ASCII based encoding other\n-        than utf-8 (e.g. latin-1), then an appropriate ``encoding`` name must\n-        be specified. Encodings that are not ASCII based (such as UCS-2) are\n-        not allowed, and should be wrapped with\n-        ``codecs.getreader(fp)(encoding)``, or simply decoded to a ``unicode``\n-        object and passed to ``loads()``\n-\n-        ``object_hook`` is an optional function that will be called with the\n-        result of any object literal decode (a ``dict``). The return value of\n-        ``object_hook`` will be used instead of the ``dict``. This feature\n-        can be used to implement custom decoders (e.g. JSON-RPC class hinting).\n-\n-        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n-        kwarg.\n-\n-        \"\"\"\n-        return loads(fp.read(),\n-            encoding=encoding, cls=cls, object_hook=object_hook,\n-            parse_float=parse_float, parse_int=parse_int,\n-            parse_constant=parse_constant, **kw)\n-\n-\n-    def loads(s, encoding=None, cls=None, object_hook=None, parse_float=None,\n-            parse_int=None, parse_constant=None, **kw):\n-        \"\"\"Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON\n-        document) to a Python object.\n-\n-        If ``s`` is a ``str`` instance and is encoded with an ASCII based encoding\n-        other than utf-8 (e.g. latin-1) then an appropriate ``encoding`` name\n-        must be specified. Encodings that are not ASCII based (such as UCS-2)\n-        are not allowed and should be decoded to ``unicode`` first.\n-\n-        ``object_hook`` is an optional function that will be called with the\n-        result of any object literal decode (a ``dict``). The return value of\n-        ``object_hook`` will be used instead of the ``dict``. This feature\n-        can be used to implement custom decoders (e.g. JSON-RPC class hinting).\n-\n-        ``parse_float``, if specified, will be called with the string\n-        of every JSON float to be decoded. By default this is equivalent to\n-        float(num_str). This can be used to use another datatype or parser\n-        for JSON floats (e.g. decimal.Decimal).\n-\n-        ``parse_int``, if specified, will be called with the string\n-        of every JSON int to be decoded. By default this is equivalent to\n-        int(num_str). This can be used to use another datatype or parser\n-        for JSON integers (e.g. float).\n-\n-        ``parse_constant``, if specified, will be called with one of the\n-        following strings: -Infinity, Infinity, NaN, null, true, false.\n-        This can be used to raise an exception if invalid JSON numbers\n-        are encountered.\n-\n-        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n-        kwarg.\n-\n-        \"\"\"\n-        if (cls is None and encoding is None and object_hook is None and\n-                parse_int is None and parse_float is None and\n-                parse_constant is None and not kw):\n-            return _default_decoder.decode(s)\n-        if cls is None:\n-            cls = JSONDecoder\n-        if object_hook is not None:\n-            kw['object_hook'] = object_hook\n-        if parse_float is not None:\n-            kw['parse_float'] = parse_float\n-        if parse_int is not None:\n-            kw['parse_int'] = parse_int\n-        if parse_constant is not None:\n-            kw['parse_constant'] = parse_constant\n-        return cls(encoding=encoding, **kw).decode(s)"
        },
        {
            "sha": "5a845ccfdc713d53ec05e5bfe45cd4638912cb54",
            "filename": "django/utils/simplejson/decoder.py",
            "status": "removed",
            "additions": 0,
            "deletions": 345,
            "changes": 345,
            "blob_url": "https://github.com/django/django/blob/ee0a7c741e98214bac7eeb60b848cf099ff28836/django%2Futils%2Fsimplejson%2Fdecoder.py",
            "raw_url": "https://github.com/django/django/raw/ee0a7c741e98214bac7eeb60b848cf099ff28836/django%2Futils%2Fsimplejson%2Fdecoder.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fsimplejson%2Fdecoder.py?ref=ee0a7c741e98214bac7eeb60b848cf099ff28836",
            "patch": "@@ -1,345 +0,0 @@\n-\"\"\"Implementation of JSONDecoder\n-\"\"\"\n-import re\n-import sys\n-import struct\n-\n-from django.utils.simplejson.scanner import make_scanner\n-c_scanstring = None\n-\n-__all__ = ['JSONDecoder']\n-\n-FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\n-\n-def _floatconstants():\n-    _BYTES = '7FF80000000000007FF0000000000000'.decode('hex')\n-    if sys.byteorder != 'big':\n-        _BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]\n-    nan, inf = struct.unpack('dd', _BYTES)\n-    return nan, inf, -inf\n-\n-NaN, PosInf, NegInf = _floatconstants()\n-\n-\n-def linecol(doc, pos):\n-    lineno = doc.count('\\n', 0, pos) + 1\n-    if lineno == 1:\n-        colno = pos\n-    else:\n-        colno = pos - doc.rindex('\\n', 0, pos)\n-    return lineno, colno\n-\n-\n-def errmsg(msg, doc, pos, end=None):\n-    # Note that this function is called from _speedups\n-    lineno, colno = linecol(doc, pos)\n-    if end is None:\n-        return '%s: line %d column %d (char %d)' % (msg, lineno, colno, pos)\n-    endlineno, endcolno = linecol(doc, end)\n-    return '%s: line %d column %d - line %d column %d (char %d - %d)' % (\n-        msg, lineno, colno, endlineno, endcolno, pos, end)\n-\n-\n-_CONSTANTS = {\n-    '-Infinity': NegInf,\n-    'Infinity': PosInf,\n-    'NaN': NaN,\n-}\n-\n-STRINGCHUNK = re.compile(r'(.*?)([\"\\\\\\x00-\\x1f])', FLAGS)\n-BACKSLASH = {\n-    '\"': u'\"', '\\\\': u'\\\\', '/': u'/',\n-    'b': u'\\b', 'f': u'\\f', 'n': u'\\n', 'r': u'\\r', 't': u'\\t',\n-}\n-\n-DEFAULT_ENCODING = \"utf-8\"\n-\n-def py_scanstring(s, end, encoding=None, strict=True, _b=BACKSLASH, _m=STRINGCHUNK.match):\n-    \"\"\"Scan the string s for a JSON string. End is the index of the\n-    character in s after the quote that started the JSON string.\n-    Unescapes all valid JSON string escape sequences and raises ValueError\n-    on attempt to decode an invalid string. If strict is False then literal\n-    control characters are allowed in the string.\n-    \n-    Returns a tuple of the decoded string and the index of the character in s\n-    after the end quote.\"\"\"\n-    if encoding is None:\n-        encoding = DEFAULT_ENCODING\n-    chunks = []\n-    _append = chunks.append\n-    begin = end - 1\n-    while 1:\n-        chunk = _m(s, end)\n-        if chunk is None:\n-            raise ValueError(\n-                errmsg(\"Unterminated string starting at\", s, begin))\n-        end = chunk.end()\n-        content, terminator = chunk.groups()\n-        # Content is contains zero or more unescaped string characters\n-        if content:\n-            if not isinstance(content, unicode):\n-                content = unicode(content, encoding)\n-            _append(content)\n-        # Terminator is the end of string, a literal control character,\n-        # or a backslash denoting that an escape sequence follows\n-        if terminator == '\"':\n-            break\n-        elif terminator != '\\\\':\n-            if strict:\n-                msg = \"Invalid control character %r at\" % (terminator,)\n-                raise ValueError(msg, s, end)\n-            else:\n-                _append(terminator)\n-                continue\n-        try:\n-            esc = s[end]\n-        except IndexError:\n-            raise ValueError(\n-                errmsg(\"Unterminated string starting at\", s, begin))\n-        # If not a unicode escape sequence, must be in the lookup table\n-        if esc != 'u':\n-            try:\n-                char = _b[esc]\n-            except KeyError:\n-                raise ValueError(\n-                    errmsg(\"Invalid \\\\escape: %r\" % (esc,), s, end))\n-            end += 1\n-        else:\n-            # Unicode escape sequence\n-            esc = s[end + 1:end + 5]\n-            next_end = end + 5\n-            if len(esc) != 4:\n-                msg = \"Invalid \\\\uXXXX escape\"\n-                raise ValueError(errmsg(msg, s, end))\n-            uni = int(esc, 16)\n-            # Check for surrogate pair on UCS-4 systems\n-            if 0xd800 <= uni <= 0xdbff and sys.maxunicode > 65535:\n-                msg = \"Invalid \\\\uXXXX\\\\uXXXX surrogate pair\"\n-                if not s[end + 5:end + 7] == '\\\\u':\n-                    raise ValueError(errmsg(msg, s, end))\n-                esc2 = s[end + 7:end + 11]\n-                if len(esc2) != 4:\n-                    raise ValueError(errmsg(msg, s, end))\n-                uni2 = int(esc2, 16)\n-                uni = 0x10000 + (((uni - 0xd800) << 10) | (uni2 - 0xdc00))\n-                next_end += 6\n-            char = unichr(uni)\n-            end = next_end\n-        # Append the unescaped character\n-        _append(char)\n-    return u''.join(chunks), end\n-\n-\n-# Use speedup if available\n-scanstring = c_scanstring or py_scanstring\n-\n-WHITESPACE = re.compile(r'[ \\t\\n\\r]*', FLAGS)\n-WHITESPACE_STR = ' \\t\\n\\r'\n-\n-def JSONObject((s, end), encoding, strict, scan_once, object_hook, _w=WHITESPACE.match, _ws=WHITESPACE_STR):\n-    pairs = {}\n-    # Use a slice to prevent IndexError from being raised, the following\n-    # check will raise a more specific ValueError if the string is empty\n-    nextchar = s[end:end + 1]\n-    # Normally we expect nextchar == '\"'\n-    if nextchar != '\"':\n-        if nextchar in _ws:\n-            end = _w(s, end).end()\n-            nextchar = s[end:end + 1]\n-        # Trivial empty object\n-        if nextchar == '}':\n-            return pairs, end + 1\n-        elif nextchar != '\"':\n-            raise ValueError(errmsg(\"Expecting property name\", s, end))\n-    end += 1\n-    while True:\n-        key, end = scanstring(s, end, encoding, strict)\n-\n-        # To skip some function call overhead we optimize the fast paths where\n-        # the JSON key separator is \": \" or just \":\".\n-        if s[end:end + 1] != ':':\n-            end = _w(s, end).end()\n-            if s[end:end + 1] != ':':\n-                raise ValueError(errmsg(\"Expecting : delimiter\", s, end))\n-\n-        end += 1\n-\n-        try:\n-            if s[end] in _ws:\n-                end += 1\n-                if s[end] in _ws:\n-                    end = _w(s, end + 1).end()\n-        except IndexError:\n-            pass\n-\n-        try:\n-            value, end = scan_once(s, end)\n-        except StopIteration:\n-            raise ValueError(errmsg(\"Expecting object\", s, end))\n-        pairs[key] = value\n-\n-        try:\n-            nextchar = s[end]\n-            if nextchar in _ws:\n-                end = _w(s, end + 1).end()\n-                nextchar = s[end]\n-        except IndexError:\n-            nextchar = ''\n-        end += 1\n-\n-        if nextchar == '}':\n-            break\n-        elif nextchar != ',':\n-            raise ValueError(errmsg(\"Expecting , delimiter\", s, end - 1))\n-\n-        try:\n-            nextchar = s[end]\n-            if nextchar in _ws:\n-                end += 1\n-                nextchar = s[end]\n-                if nextchar in _ws:\n-                    end = _w(s, end + 1).end()\n-                    nextchar = s[end]\n-        except IndexError:\n-            nextchar = ''\n-\n-        end += 1\n-        if nextchar != '\"':\n-            raise ValueError(errmsg(\"Expecting property name\", s, end - 1))\n-\n-    if object_hook is not None:\n-        pairs = object_hook(pairs)\n-    return pairs, end\n-\n-def JSONArray((s, end), scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):\n-    values = []\n-    nextchar = s[end:end + 1]\n-    if nextchar in _ws:\n-        end = _w(s, end + 1).end()\n-        nextchar = s[end:end + 1]\n-    # Look-ahead for trivial empty array\n-    if nextchar == ']':\n-        return values, end + 1\n-    _append = values.append\n-    while True:\n-        try:\n-            value, end = scan_once(s, end)\n-        except StopIteration:\n-            raise ValueError(errmsg(\"Expecting object\", s, end))\n-        _append(value)\n-        nextchar = s[end:end + 1]\n-        if nextchar in _ws:\n-            end = _w(s, end + 1).end()\n-            nextchar = s[end:end + 1]\n-        end += 1\n-        if nextchar == ']':\n-            break\n-        elif nextchar != ',':\n-            raise ValueError(errmsg(\"Expecting , delimiter\", s, end))\n-\n-        try:\n-            if s[end] in _ws:\n-                end += 1\n-                if s[end] in _ws:\n-                    end = _w(s, end + 1).end()\n-        except IndexError:\n-            pass\n-\n-    return values, end\n-\n-class JSONDecoder(object):\n-    \"\"\"Simple JSON <http://json.org> decoder\n-\n-    Performs the following translations in decoding by default:\n-\n-    +---------------+-------------------+\n-    | JSON          | Python            |\n-    +===============+===================+\n-    | object        | dict              |\n-    +---------------+-------------------+\n-    | array         | list              |\n-    +---------------+-------------------+\n-    | string        | unicode           |\n-    +---------------+-------------------+\n-    | number (int)  | int, long         |\n-    +---------------+-------------------+\n-    | number (real) | float             |\n-    +---------------+-------------------+\n-    | true          | True              |\n-    +---------------+-------------------+\n-    | false         | False             |\n-    +---------------+-------------------+\n-    | null          | None              |\n-    +---------------+-------------------+\n-\n-    It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\n-    their corresponding ``float`` values, which is outside the JSON spec.\n-\n-    \"\"\"\n-\n-    def __init__(self, encoding=None, object_hook=None, parse_float=None,\n-            parse_int=None, parse_constant=None, strict=True):\n-        \"\"\"``encoding`` determines the encoding used to interpret any ``str``\n-        objects decoded by this instance (utf-8 by default).  It has no\n-        effect when decoding ``unicode`` objects.\n-\n-        Note that currently only encodings that are a superset of ASCII work,\n-        strings of other encodings should be passed in as ``unicode``.\n-\n-        ``object_hook``, if specified, will be called with the result\n-        of every JSON object decoded and its return value will be used in\n-        place of the given ``dict``.  This can be used to provide custom\n-        deserializations (e.g. to support JSON-RPC class hinting).\n-\n-        ``parse_float``, if specified, will be called with the string\n-        of every JSON float to be decoded. By default this is equivalent to\n-        float(num_str). This can be used to use another datatype or parser\n-        for JSON floats (e.g. decimal.Decimal).\n-\n-        ``parse_int``, if specified, will be called with the string\n-        of every JSON int to be decoded. By default this is equivalent to\n-        int(num_str). This can be used to use another datatype or parser\n-        for JSON integers (e.g. float).\n-\n-        ``parse_constant``, if specified, will be called with one of the\n-        following strings: -Infinity, Infinity, NaN.\n-        This can be used to raise an exception if invalid JSON numbers\n-        are encountered.\n-\n-        \"\"\"\n-        self.encoding = encoding\n-        self.object_hook = object_hook\n-        self.parse_float = parse_float or float\n-        self.parse_int = parse_int or int\n-        self.parse_constant = parse_constant or _CONSTANTS.__getitem__\n-        self.strict = strict\n-        self.parse_object = JSONObject\n-        self.parse_array = JSONArray\n-        self.parse_string = scanstring\n-        self.scan_once = make_scanner(self)\n-\n-    def decode(self, s, _w=WHITESPACE.match):\n-        \"\"\"Return the Python representation of ``s`` (a ``str`` or ``unicode``\n-        instance containing a JSON document)\n-\n-        \"\"\"\n-        obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n-        end = _w(s, end).end()\n-        if end != len(s):\n-            raise ValueError(errmsg(\"Extra data\", s, end, len(s)))\n-        return obj\n-\n-    def raw_decode(self, s, idx=0):\n-        \"\"\"Decode a JSON document from ``s`` (a ``str`` or ``unicode`` beginning\n-        with a JSON document) and return a 2-tuple of the Python\n-        representation and the index in ``s`` where the document ended.\n-\n-        This can be used to decode a JSON document from a string that may\n-        have extraneous data at the end.\n-\n-        \"\"\"\n-        try:\n-            obj, end = self.scan_once(s, idx)\n-        except StopIteration:\n-            raise ValueError(\"No JSON object could be decoded\")\n-        return obj, end"
        },
        {
            "sha": "06ebe62a3c26988fc4d8285dfadd68711ae52885",
            "filename": "django/utils/simplejson/encoder.py",
            "status": "removed",
            "additions": 0,
            "deletions": 430,
            "changes": 430,
            "blob_url": "https://github.com/django/django/blob/ee0a7c741e98214bac7eeb60b848cf099ff28836/django%2Futils%2Fsimplejson%2Fencoder.py",
            "raw_url": "https://github.com/django/django/raw/ee0a7c741e98214bac7eeb60b848cf099ff28836/django%2Futils%2Fsimplejson%2Fencoder.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fsimplejson%2Fencoder.py?ref=ee0a7c741e98214bac7eeb60b848cf099ff28836",
            "patch": "@@ -1,430 +0,0 @@\n-\"\"\"Implementation of JSONEncoder\n-\"\"\"\n-import re\n-\n-c_encode_basestring_ascii = None\n-c_make_encoder = None\n-\n-ESCAPE = re.compile(r'[\\x00-\\x1f\\\\\"\\b\\f\\n\\r\\t]')\n-ESCAPE_ASCII = re.compile(r'([\\\\\"]|[^\\ -~])')\n-HAS_UTF8 = re.compile(r'[\\x80-\\xff]')\n-ESCAPE_DCT = {\n-    '\\\\': '\\\\\\\\',\n-    '\"': '\\\\\"',\n-    '\\b': '\\\\b',\n-    '\\f': '\\\\f',\n-    '\\n': '\\\\n',\n-    '\\r': '\\\\r',\n-    '\\t': '\\\\t',\n-}\n-for i in range(0x20):\n-    ESCAPE_DCT.setdefault(chr(i), '\\\\u%04x' % (i,))\n-\n-# Assume this produces an infinity on all machines (probably not guaranteed)\n-INFINITY = float('1e66666')\n-FLOAT_REPR = repr\n-\n-def encode_basestring(s):\n-    \"\"\"Return a JSON representation of a Python string\n-\n-    \"\"\"\n-    def replace(match):\n-        return ESCAPE_DCT[match.group(0)]\n-    return '\"' + ESCAPE.sub(replace, s) + '\"'\n-\n-\n-def py_encode_basestring_ascii(s):\n-    \"\"\"Return an ASCII-only JSON representation of a Python string\n-\n-    \"\"\"\n-    if isinstance(s, str) and HAS_UTF8.search(s) is not None:\n-        s = s.decode('utf-8')\n-    def replace(match):\n-        s = match.group(0)\n-        try:\n-            return ESCAPE_DCT[s]\n-        except KeyError:\n-            n = ord(s)\n-            if n < 0x10000:\n-                return '\\\\u%04x' % (n,)\n-            else:\n-                # surrogate pair\n-                n -= 0x10000\n-                s1 = 0xd800 | ((n >> 10) & 0x3ff)\n-                s2 = 0xdc00 | (n & 0x3ff)\n-                return '\\\\u%04x\\\\u%04x' % (s1, s2)\n-    return '\"' + str(ESCAPE_ASCII.sub(replace, s)) + '\"'\n-\n-\n-encode_basestring_ascii = c_encode_basestring_ascii or py_encode_basestring_ascii\n-\n-class JSONEncoder(object):\n-    \"\"\"Extensible JSON <http://json.org> encoder for Python data structures.\n-\n-    Supports the following objects and types by default:\n-\n-    +-------------------+---------------+\n-    | Python            | JSON          |\n-    +===================+===============+\n-    | dict              | object        |\n-    +-------------------+---------------+\n-    | list, tuple       | array         |\n-    +-------------------+---------------+\n-    | str, unicode      | string        |\n-    +-------------------+---------------+\n-    | int, long, float  | number        |\n-    +-------------------+---------------+\n-    | True              | true          |\n-    +-------------------+---------------+\n-    | False             | false         |\n-    +-------------------+---------------+\n-    | None              | null          |\n-    +-------------------+---------------+\n-\n-    To extend this to recognize other objects, subclass and implement a\n-    ``.default()`` method with another method that returns a serializable\n-    object for ``o`` if possible, otherwise it should call the superclass\n-    implementation (to raise ``TypeError``).\n-\n-    \"\"\"\n-    item_separator = ', '\n-    key_separator = ': '\n-    def __init__(self, skipkeys=False, ensure_ascii=True,\n-            check_circular=True, allow_nan=True, sort_keys=False,\n-            indent=None, separators=None, encoding='utf-8', default=None):\n-        \"\"\"Constructor for JSONEncoder, with sensible defaults.\n-\n-        If skipkeys is False, then it is a TypeError to attempt\n-        encoding of keys that are not str, int, long, float or None.  If\n-        skipkeys is True, such items are simply skipped.\n-\n-        If ensure_ascii is True, the output is guaranteed to be str\n-        objects with all incoming unicode characters escaped.  If\n-        ensure_ascii is false, the output will be unicode object.\n-\n-        If check_circular is True, then lists, dicts, and custom encoded\n-        objects will be checked for circular references during encoding to\n-        prevent an infinite recursion (which would cause an OverflowError).\n-        Otherwise, no such check takes place.\n-\n-        If allow_nan is True, then NaN, Infinity, and -Infinity will be\n-        encoded as such.  This behavior is not JSON specification compliant,\n-        but is consistent with most JavaScript based encoders and decoders.\n-        Otherwise, it will be a ValueError to encode such floats.\n-\n-        If sort_keys is True, then the output of dictionaries will be\n-        sorted by key; this is useful for regression tests to ensure\n-        that JSON serializations can be compared on a day-to-day basis.\n-\n-        If indent is a non-negative integer, then JSON array\n-        elements and object members will be pretty-printed with that\n-        indent level.  An indent level of 0 will only insert newlines.\n-        None is the most compact representation.\n-\n-        If specified, separators should be a (item_separator, key_separator)\n-        tuple.  The default is (', ', ': ').  To get the most compact JSON\n-        representation you should specify (',', ':') to eliminate whitespace.\n-\n-        If specified, default is a function that gets called for objects\n-        that can't otherwise be serialized.  It should return a JSON encodable\n-        version of the object or raise a ``TypeError``.\n-\n-        If encoding is not None, then all input strings will be\n-        transformed into unicode using that encoding prior to JSON-encoding.\n-        The default is UTF-8.\n-\n-        \"\"\"\n-\n-        self.skipkeys = skipkeys\n-        self.ensure_ascii = ensure_ascii\n-        self.check_circular = check_circular\n-        self.allow_nan = allow_nan\n-        self.sort_keys = sort_keys\n-        self.indent = indent\n-        if separators is not None:\n-            self.item_separator, self.key_separator = separators\n-        if default is not None:\n-            self.default = default\n-        self.encoding = encoding\n-\n-    def default(self, o):\n-        \"\"\"Implement this method in a subclass such that it returns\n-        a serializable object for ``o``, or calls the base implementation\n-        (to raise a ``TypeError``).\n-\n-        For example, to support arbitrary iterators, you could\n-        implement default like this::\n-\n-            def default(self, o):\n-                try:\n-                    iterable = iter(o)\n-                except TypeError:\n-                    pass\n-                else:\n-                    return list(iterable)\n-                return JSONEncoder.default(self, o)\n-\n-        \"\"\"\n-        raise TypeError(\"%r is not JSON serializable\" % (o,))\n-\n-    def encode(self, o):\n-        \"\"\"Return a JSON string representation of a Python data structure.\n-\n-        >>> JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n-        '{\"foo\": [\"bar\", \"baz\"]}'\n-\n-        \"\"\"\n-        # This is for extremely simple cases and benchmarks.\n-        if isinstance(o, basestring):\n-            if isinstance(o, str):\n-                _encoding = self.encoding\n-                if (_encoding is not None\n-                        and not (_encoding == 'utf-8')):\n-                    o = o.decode(_encoding)\n-            if self.ensure_ascii:\n-                return encode_basestring_ascii(o)\n-            else:\n-                return encode_basestring(o)\n-        # This doesn't pass the iterator directly to ''.join() because the\n-        # exceptions aren't as detailed.  The list call should be roughly\n-        # equivalent to the PySequence_Fast that ''.join() would do.\n-        chunks = self.iterencode(o, _one_shot=True)\n-        if not isinstance(chunks, (list, tuple)):\n-            chunks = list(chunks)\n-        return ''.join(chunks)\n-\n-    def iterencode(self, o, _one_shot=False):\n-        \"\"\"Encode the given object and yield each string\n-        representation as available.\n-\n-        For example::\n-\n-            for chunk in JSONEncoder().iterencode(bigobject):\n-                mysocket.write(chunk)\n-\n-        \"\"\"\n-        if self.check_circular:\n-            markers = {}\n-        else:\n-            markers = None\n-        if self.ensure_ascii:\n-            _encoder = encode_basestring_ascii\n-        else:\n-            _encoder = encode_basestring\n-        if self.encoding != 'utf-8':\n-            def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):\n-                if isinstance(o, str):\n-                    o = o.decode(_encoding)\n-                return _orig_encoder(o)\n-\n-        def floatstr(o, allow_nan=self.allow_nan, _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):\n-            # Check for specials.  Note that this type of test is processor- and/or\n-            # platform-specific, so do tests which don't depend on the internals.\n-\n-            if o != o:\n-                text = 'NaN'\n-            elif o == _inf:\n-                text = 'Infinity'\n-            elif o == _neginf:\n-                text = '-Infinity'\n-            else:\n-                return _repr(o)\n-\n-            if not allow_nan:\n-                raise ValueError(\"Out of range float values are not JSON compliant: %r\"\n-                    % (o,))\n-\n-            return text\n-\n-\n-        if _one_shot and c_make_encoder is not None and not self.indent and not self.sort_keys:\n-            _iterencode = c_make_encoder(\n-                markers, self.default, _encoder, self.indent,\n-                self.key_separator, self.item_separator, self.sort_keys,\n-                self.skipkeys, self.allow_nan)\n-        else:\n-            _iterencode = _make_iterencode(\n-                markers, self.default, _encoder, self.indent, floatstr,\n-                self.key_separator, self.item_separator, self.sort_keys,\n-                self.skipkeys, _one_shot)\n-        return _iterencode(o, 0)\n-\n-def _make_iterencode(markers, _default, _encoder, _indent, _floatstr, _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot,\n-        ## HACK: hand-optimized bytecode; turn globals into locals\n-        False=False,\n-        True=True,\n-        ValueError=ValueError,\n-        basestring=basestring,\n-        dict=dict,\n-        float=float,\n-        id=id,\n-        int=int,\n-        isinstance=isinstance,\n-        list=list,\n-        long=long,\n-        str=str,\n-        tuple=tuple,\n-    ):\n-\n-    def _iterencode_list(lst, _current_indent_level):\n-        if not lst:\n-            yield '[]'\n-            return\n-        if markers is not None:\n-            markerid = id(lst)\n-            if markerid in markers:\n-                raise ValueError(\"Circular reference detected\")\n-            markers[markerid] = lst\n-        buf = '['\n-        if _indent is not None:\n-            _current_indent_level += 1\n-            newline_indent = '\\n' + (' ' * (_indent * _current_indent_level))\n-            separator = _item_separator + newline_indent\n-            buf += newline_indent\n-        else:\n-            newline_indent = None\n-            separator = _item_separator\n-        first = True\n-        for value in lst:\n-            if first:\n-                first = False\n-            else:\n-                buf = separator\n-            if isinstance(value, basestring):\n-                yield buf + _encoder(value)\n-            elif value is None:\n-                yield buf + 'null'\n-            elif value is True:\n-                yield buf + 'true'\n-            elif value is False:\n-                yield buf + 'false'\n-            elif isinstance(value, (int, long)):\n-                yield buf + str(value)\n-            elif isinstance(value, float):\n-                yield buf + _floatstr(value)\n-            else:\n-                yield buf\n-                if isinstance(value, (list, tuple)):\n-                    chunks = _iterencode_list(value, _current_indent_level)\n-                elif isinstance(value, dict):\n-                    chunks = _iterencode_dict(value, _current_indent_level)\n-                else:\n-                    chunks = _iterencode(value, _current_indent_level)\n-                for chunk in chunks:\n-                    yield chunk\n-        if newline_indent is not None:\n-            _current_indent_level -= 1\n-            yield '\\n' + (' ' * (_indent * _current_indent_level))\n-        yield ']'\n-        if markers is not None:\n-            del markers[markerid]\n-\n-    def _iterencode_dict(dct, _current_indent_level):\n-        if not dct:\n-            yield '{}'\n-            return\n-        if markers is not None:\n-            markerid = id(dct)\n-            if markerid in markers:\n-                raise ValueError(\"Circular reference detected\")\n-            markers[markerid] = dct\n-        yield '{'\n-        if _indent is not None:\n-            _current_indent_level += 1\n-            newline_indent = '\\n' + (' ' * (_indent * _current_indent_level))\n-            item_separator = _item_separator + newline_indent\n-            yield newline_indent\n-        else:\n-            newline_indent = None\n-            item_separator = _item_separator\n-        first = True\n-        if _sort_keys:\n-            items = dct.items()\n-            items.sort(key=lambda kv: kv[0])\n-        else:\n-            items = dct.iteritems()\n-        for key, value in items:\n-            if isinstance(key, basestring):\n-                pass\n-            # JavaScript is weakly typed for these, so it makes sense to\n-            # also allow them.  Many encoders seem to do something like this.\n-            elif isinstance(key, float):\n-                key = _floatstr(key)\n-            elif isinstance(key, (int, long)):\n-                key = str(key)\n-            elif key is True:\n-                key = 'true'\n-            elif key is False:\n-                key = 'false'\n-            elif key is None:\n-                key = 'null'\n-            elif _skipkeys:\n-                continue\n-            else:\n-                raise TypeError(\"key %r is not a string\" % (key,))\n-            if first:\n-                first = False\n-            else:\n-                yield item_separator\n-            yield _encoder(key)\n-            yield _key_separator\n-            if isinstance(value, basestring):\n-                yield _encoder(value)\n-            elif value is None:\n-                yield 'null'\n-            elif value is True:\n-                yield 'true'\n-            elif value is False:\n-                yield 'false'\n-            elif isinstance(value, (int, long)):\n-                yield str(value)\n-            elif isinstance(value, float):\n-                yield _floatstr(value)\n-            else:\n-                if isinstance(value, (list, tuple)):\n-                    chunks = _iterencode_list(value, _current_indent_level)\n-                elif isinstance(value, dict):\n-                    chunks = _iterencode_dict(value, _current_indent_level)\n-                else:\n-                    chunks = _iterencode(value, _current_indent_level)\n-                for chunk in chunks:\n-                    yield chunk\n-        if newline_indent is not None:\n-            _current_indent_level -= 1\n-            yield '\\n' + (' ' * (_indent * _current_indent_level))\n-        yield '}'\n-        if markers is not None:\n-            del markers[markerid]\n-\n-    def _iterencode(o, _current_indent_level):\n-        if isinstance(o, basestring):\n-            yield _encoder(o)\n-        elif o is None:\n-            yield 'null'\n-        elif o is True:\n-            yield 'true'\n-        elif o is False:\n-            yield 'false'\n-        elif isinstance(o, (int, long)):\n-            yield str(o)\n-        elif isinstance(o, float):\n-            yield _floatstr(o)\n-        elif isinstance(o, (list, tuple)):\n-            for chunk in _iterencode_list(o, _current_indent_level):\n-                yield chunk\n-        elif isinstance(o, dict):\n-            for chunk in _iterencode_dict(o, _current_indent_level):\n-                yield chunk\n-        else:\n-            if markers is not None:\n-                markerid = id(o)\n-                if markerid in markers:\n-                    raise ValueError(\"Circular reference detected\")\n-                markers[markerid] = o\n-            o = _default(o)\n-            for chunk in _iterencode(o, _current_indent_level):\n-                yield chunk\n-            if markers is not None:\n-                del markers[markerid]\n-\n-    return _iterencode"
        },
        {
            "sha": "adbc6ec979c9f05d54e1556a6fd007499a953ee6",
            "filename": "django/utils/simplejson/scanner.py",
            "status": "removed",
            "additions": 0,
            "deletions": 65,
            "changes": 65,
            "blob_url": "https://github.com/django/django/blob/ee0a7c741e98214bac7eeb60b848cf099ff28836/django%2Futils%2Fsimplejson%2Fscanner.py",
            "raw_url": "https://github.com/django/django/raw/ee0a7c741e98214bac7eeb60b848cf099ff28836/django%2Futils%2Fsimplejson%2Fscanner.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fsimplejson%2Fscanner.py?ref=ee0a7c741e98214bac7eeb60b848cf099ff28836",
            "patch": "@@ -1,65 +0,0 @@\n-\"\"\"JSON token scanner\n-\"\"\"\n-import re\n-try:\n-    from simplejson._speedups import make_scanner as c_make_scanner\n-except ImportError:\n-    c_make_scanner = None\n-\n-__all__ = ['make_scanner']\n-\n-NUMBER_RE = re.compile(\n-    r'(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?',\n-    (re.VERBOSE | re.MULTILINE | re.DOTALL))\n-\n-def py_make_scanner(context):\n-    parse_object = context.parse_object\n-    parse_array = context.parse_array\n-    parse_string = context.parse_string\n-    match_number = NUMBER_RE.match\n-    encoding = context.encoding\n-    strict = context.strict\n-    parse_float = context.parse_float\n-    parse_int = context.parse_int\n-    parse_constant = context.parse_constant\n-    object_hook = context.object_hook\n-\n-    def _scan_once(string, idx):\n-        try:\n-            nextchar = string[idx]\n-        except IndexError:\n-            raise StopIteration\n-\n-        if nextchar == '\"':\n-            return parse_string(string, idx + 1, encoding, strict)\n-        elif nextchar == '{':\n-            return parse_object((string, idx + 1), encoding, strict, _scan_once, object_hook)\n-        elif nextchar == '[':\n-            return parse_array((string, idx + 1), _scan_once)\n-        elif nextchar == 'n' and string[idx:idx + 4] == 'null':\n-            return None, idx + 4\n-        elif nextchar == 't' and string[idx:idx + 4] == 'true':\n-            return True, idx + 4\n-        elif nextchar == 'f' and string[idx:idx + 5] == 'false':\n-            return False, idx + 5\n-\n-        m = match_number(string, idx)\n-        if m is not None:\n-            integer, frac, exp = m.groups()\n-            if frac or exp:\n-                res = parse_float(integer + (frac or '') + (exp or ''))\n-            else:\n-                res = parse_int(integer)\n-            return res, m.end()\n-        elif nextchar == 'N' and string[idx:idx + 3] == 'NaN':\n-            return parse_constant('NaN'), idx + 3\n-        elif nextchar == 'I' and string[idx:idx + 8] == 'Infinity':\n-            return parse_constant('Infinity'), idx + 8\n-        elif nextchar == '-' and string[idx:idx + 9] == '-Infinity':\n-            return parse_constant('-Infinity'), idx + 9\n-        else:\n-            raise StopIteration\n-\n-    return _scan_once\n-\n-make_scanner = c_make_scanner or py_make_scanner"
        },
        {
            "sha": "74401c279a7920245ab9706c954df24a004e4cd0",
            "filename": "django/utils/simplejson/tool.py",
            "status": "removed",
            "additions": 0,
            "deletions": 35,
            "changes": 35,
            "blob_url": "https://github.com/django/django/blob/ee0a7c741e98214bac7eeb60b848cf099ff28836/django%2Futils%2Fsimplejson%2Ftool.py",
            "raw_url": "https://github.com/django/django/raw/ee0a7c741e98214bac7eeb60b848cf099ff28836/django%2Futils%2Fsimplejson%2Ftool.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fsimplejson%2Ftool.py?ref=ee0a7c741e98214bac7eeb60b848cf099ff28836",
            "patch": "@@ -1,35 +0,0 @@\n-r\"\"\"Using simplejson from the shell to validate and\n-pretty-print::\n-\n-    $ echo '{\"json\":\"obj\"}' | python -msimplejson.tool\n-    {\n-        \"json\": \"obj\"\n-    }\n-    $ echo '{ 1.2:3.4}' | python -msimplejson.tool\n-    Expecting property name: line 1 column 2 (char 2)\n-\"\"\"\n-from django.utils import simplejson\n-\n-def main():\n-    import sys\n-    if len(sys.argv) == 1:\n-        infile = sys.stdin\n-        outfile = sys.stdout\n-    elif len(sys.argv) == 2:\n-        infile = open(sys.argv[1], 'rb')\n-        outfile = sys.stdout\n-    elif len(sys.argv) == 3:\n-        infile = open(sys.argv[1], 'rb')\n-        outfile = open(sys.argv[2], 'wb')\n-    else:\n-        raise SystemExit(\"%s [infile [outfile]]\" % (sys.argv[0],))\n-    try:\n-        obj = simplejson.load(infile)\n-    except ValueError, e:\n-        raise SystemExit(e)\n-    simplejson.dump(obj, outfile, sort_keys=True, indent=4)\n-    outfile.write('\\n')\n-\n-\n-if __name__ == '__main__':\n-    main()"
        },
        {
            "sha": "d4b0b43ca7751dfda7fd3c93109f8a88a9f37915",
            "filename": "docs/_ext/djangodocs.py",
            "status": "modified",
            "additions": 1,
            "deletions": 13,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/docs%2F_ext%2Fdjangodocs.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/docs%2F_ext%2Fdjangodocs.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2F_ext%2Fdjangodocs.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -1,20 +1,11 @@\n \"\"\"\n Sphinx plugins for Django documentation.\n \"\"\"\n+import json\n import os\n import re\n \n from docutils import nodes, transforms\n-try:\n-    import json\n-except ImportError:\n-    try:\n-        import simplejson as json\n-    except ImportError:\n-        try:\n-            from django.utils import simplejson as json\n-        except ImportError:\n-            json = None\n \n from sphinx import addnodes, roles, __version__ as sphinx_ver\n from sphinx.builders.html import StandaloneHTMLBuilder\n@@ -210,9 +201,6 @@ class DjangoStandaloneHTMLBuilder(StandaloneHTMLBuilder):\n \n     def finish(self):\n         super(DjangoStandaloneHTMLBuilder, self).finish()\n-        if json is None:\n-            self.warn(\"cannot create templatebuiltins.js due to missing simplejson dependency\")\n-            return\n         self.info(bold(\"writing templatebuiltins.js...\"))\n         xrefs = self.env.domaindata[\"std\"][\"objects\"]\n         templatebuiltins = {"
        },
        {
            "sha": "2f594536c55f3984038680d8547e6491fa5fb68e",
            "filename": "docs/internals/deprecation.txt",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/docs%2Finternals%2Fdeprecation.txt",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/docs%2Finternals%2Fdeprecation.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Finternals%2Fdeprecation.txt?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -268,6 +268,9 @@ these changes.\n See the :doc:`Django 1.5 release notes</releases/1.5>` for more details on\n these changes.\n \n+* The module ``django.utils.simplejson`` will be removed. The standard library\n+provides :mod:`json` which should be used instead.\n+\n * The function ``django.utils.itercompat.product`` will be removed. The Python\n   builtin version should be used instead.\n "
        },
        {
            "sha": "4f6b05f8f42009b84d44344363c99686e030c900",
            "filename": "docs/releases/1.5.txt",
            "status": "modified",
            "additions": 11,
            "deletions": 2,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/docs%2Freleases%2F1.5.txt",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/docs%2Freleases%2F1.5.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.5.txt?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -58,8 +58,17 @@ Backwards incompatible changes in 1.5\n Features deprecated in 1.5\n ==========================\n \n-itercompat.product\n-~~~~~~~~~~~~~~~~~~\n+``django.utils.simplejson``\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Since Django 1.5 drops support for Python 2.5, all supported versions of\n+Python provide the :mod:`json` module in their standard library. This module\n+is actually a version of ``simplejson`` distributed by Python, so Django no\n+longer needs to provide a copy. Any use of :mod:`django.utils.simplejson` can\n+be safely changed to :mod:`json`.\n+\n+``itercompat.product``\n+~~~~~~~~~~~~~~~~~~~~~~\n \n The :func:`~django.utils.itercompat.product` function has been deprecated. Use\n the builtin `itertools.product` instead."
        },
        {
            "sha": "abac22000fa0a8566cd8b4d895b1f38d65473803",
            "filename": "docs/topics/class-based-views.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/docs%2Ftopics%2Fclass-based-views.txt",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/docs%2Ftopics%2Fclass-based-views.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fclass-based-views.txt?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -501,8 +501,8 @@ different rendering behavior.\n \n For example, a simple JSON mixin might look something like this::\n \n+    import json\n     from django import http\n-    from django.utils import simplejson as json\n \n     class JSONResponseMixin(object):\n         def render_to_response(self, context):"
        },
        {
            "sha": "d5a5282945c7c68baf1512e6e05232df26e2cbc1",
            "filename": "docs/topics/serialization.txt",
            "status": "modified",
            "additions": 7,
            "deletions": 16,
            "changes": 23,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/docs%2Ftopics%2Fserialization.txt",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/docs%2Ftopics%2Fserialization.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fserialization.txt?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -143,15 +143,13 @@ Identifier  Information\n ==========  ==============================================================\n ``xml``     Serializes to and from a simple XML dialect.\n \n-``json``    Serializes to and from JSON_ (using a version of simplejson_\n-            bundled with Django).\n+``json``    Serializes to and from JSON_.\n \n ``yaml``    Serializes to YAML (YAML Ain't a Markup Language). This\n             serializer is only available if PyYAML_ is installed.\n ==========  ==============================================================\n \n .. _json: http://json.org/\n-.. _simplejson: http://undefined.org/python/#simplejson\n .. _PyYAML: http://www.pyyaml.org/\n \n Notes for specific serialization formats\n@@ -169,28 +167,21 @@ For example::\n     json_serializer = serializers.get_serializer(\"json\")()\n     json_serializer.serialize(queryset, ensure_ascii=False, stream=response)\n \n-The Django source code includes the simplejson_ module. However, if you're\n-using Python 2.6 or later (which includes a builtin version of the module), Django will\n-use the builtin ``json`` module automatically. If you have a system installed\n-version that includes the C-based speedup extension, or your system version is\n-more recent than the version shipped with Django (currently, 2.0.7), the\n-system version will be used instead of the version included with Django.\n-\n-Be aware that if you're serializing using that module directly, not all Django\n-output can be passed unmodified to simplejson. In particular, :ref:`lazy\n-translation objects <lazy-translations>` need a `special encoder`_ written for\n-them. Something like this will work::\n+Be aware that not all Django output can be passed unmodified to :mod:`json`.\n+In particular, :ref:`lazy translation objects <lazy-translations>` need a\n+`special encoder`_ written for them. Something like this will work::\n \n+    import json\n     from django.utils.functional import Promise\n     from django.utils.encoding import force_unicode\n \n-    class LazyEncoder(simplejson.JSONEncoder):\n+    class LazyEncoder(json.JSONEncoder):\n         def default(self, obj):\n             if isinstance(obj, Promise):\n                 return force_unicode(obj)\n             return super(LazyEncoder, self).default(obj)\n \n-.. _special encoder: http://svn.red-bean.com/bob/simplejson/tags/simplejson-1.7/docs/index.html\n+.. _special encoder: http://docs.python.org/library/json.html#encoders-and-decoders\n \n .. _topics-serialization-natural-keys:\n "
        },
        {
            "sha": "4d809ba6f88d9b93a595f32942ff3ba0eb3ac101",
            "filename": "tests/modeltests/field_subclassing/fields.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/tests%2Fmodeltests%2Ffield_subclassing%2Ffields.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/tests%2Fmodeltests%2Ffield_subclassing%2Ffields.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Ffield_subclassing%2Ffields.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -1,5 +1,6 @@\n+import json\n+\n from django.db import models\n-from django.utils import simplejson as json\n from django.utils.encoding import force_unicode\n \n "
        },
        {
            "sha": "dac098763c3a88d830712a721a522ccf0479d886",
            "filename": "tests/modeltests/serializers/tests.py",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/tests%2Fmodeltests%2Fserializers%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/tests%2Fmodeltests%2Fserializers%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fserializers%2Ftests.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -1,6 +1,7 @@\n from __future__ import absolute_import\n \n # -*- coding: utf-8 -*-\n+import json\n from datetime import datetime\n from xml.dom import minidom\n from StringIO import StringIO\n@@ -9,7 +10,7 @@\n from django.core import serializers\n from django.db import transaction, connection\n from django.test import TestCase, TransactionTestCase, Approximate\n-from django.utils import simplejson, unittest\n+from django.utils import unittest\n \n from .models import (Category, Author, Article, AuthorProfile, Actor, Movie,\n     Score, Player, Team)\n@@ -354,7 +355,7 @@ class JsonSerializerTestCase(SerializersTestBase, TestCase):\n     @staticmethod\n     def _validate_output(serial_str):\n         try:\n-            simplejson.loads(serial_str)\n+            json.loads(serial_str)\n         except Exception:\n             return False\n         else:\n@@ -363,15 +364,15 @@ def _validate_output(serial_str):\n     @staticmethod\n     def _get_pk_values(serial_str):\n         ret_list = []\n-        serial_list = simplejson.loads(serial_str)\n+        serial_list = json.loads(serial_str)\n         for obj_dict in serial_list:\n             ret_list.append(obj_dict[\"pk\"])\n         return ret_list\n \n     @staticmethod\n     def _get_field_values(serial_str, field_name):\n         ret_list = []\n-        serial_list = simplejson.loads(serial_str)\n+        serial_list = json.loads(serial_str)\n         for obj_dict in serial_list:\n             if field_name in obj_dict[\"fields\"]:\n                 ret_list.append(obj_dict[\"fields\"][field_name])"
        },
        {
            "sha": "b6191ba033663ccd1923bc90213d312b5b3f3a94",
            "filename": "tests/regressiontests/file_uploads/tests.py",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/tests%2Fregressiontests%2Ffile_uploads%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/tests%2Fregressiontests%2Ffile_uploads%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ffile_uploads%2Ftests.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -5,6 +5,7 @@\n import base64\n import errno\n import hashlib\n+import json\n import os\n import shutil\n from StringIO import StringIO\n@@ -13,7 +14,7 @@\n from django.core.files.uploadedfile import SimpleUploadedFile\n from django.http.multipartparser import MultiPartParser\n from django.test import TestCase, client\n-from django.utils import simplejson, unittest\n+from django.utils import unittest\n \n from . import uploadhandler\n from .models import FileModel, temp_storage, UPLOAD_TO\n@@ -78,7 +79,7 @@ def test_base64_upload(self):\n             'wsgi.input':     client.FakePayload(payload),\n         }\n         response = self.client.request(**r)\n-        received = simplejson.loads(response.content)\n+        received = json.loads(response.content)\n \n         self.assertEqual(received['file'], test_string)\n \n@@ -150,7 +151,7 @@ def test_dangerous_file_names(self):\n         response = self.client.request(**r)\n \n         # The filenames should have been sanitized by the time it got to the view.\n-        recieved = simplejson.loads(response.content)\n+        recieved = json.loads(response.content)\n         for i, name in enumerate(scary_file_names):\n             got = recieved[\"file%s\" % i]\n             self.assertEqual(got, \"hax0rd.txt\")\n@@ -174,7 +175,7 @@ def test_filename_overflow(self):\n             'REQUEST_METHOD': 'POST',\n             'wsgi.input':     client.FakePayload(payload),\n         }\n-        got = simplejson.loads(self.client.request(**r).content)\n+        got = json.loads(self.client.request(**r).content)\n         self.assertTrue(len(got['file']) < 256, \"Got a long file name (%s characters).\" % len(got['file']))\n \n     def test_truncated_multipart_handled_gracefully(self):\n@@ -200,7 +201,7 @@ def test_truncated_multipart_handled_gracefully(self):\n             'REQUEST_METHOD': 'POST',\n             'wsgi.input': client.FakePayload(payload),\n         }\n-        got = simplejson.loads(self.client.request(**r).content)\n+        got = json.loads(self.client.request(**r).content)\n         self.assertEquals(got, {})\n \n     def test_empty_multipart_handled_gracefully(self):\n@@ -215,7 +216,7 @@ def test_empty_multipart_handled_gracefully(self):\n             'REQUEST_METHOD': 'POST',\n             'wsgi.input': client.FakePayload(''),\n         }\n-        got = simplejson.loads(self.client.request(**r).content)\n+        got = json.loads(self.client.request(**r).content)\n         self.assertEquals(got, {})\n \n     def test_custom_upload_handler(self):\n@@ -231,12 +232,12 @@ def test_custom_upload_handler(self):\n \n         # Small file posting should work.\n         response = self.client.post('/file_uploads/quota/', {'f': smallfile})\n-        got = simplejson.loads(response.content)\n+        got = json.loads(response.content)\n         self.assertTrue('f' in got)\n \n         # Large files don't go through.\n         response = self.client.post(\"/file_uploads/quota/\", {'f': bigfile})\n-        got = simplejson.loads(response.content)\n+        got = json.loads(response.content)\n         self.assertTrue('f' not in got)\n \n     def test_broken_custom_upload_handler(self):\n@@ -274,7 +275,7 @@ def test_fileupload_getlist(self):\n             'field5': u'test7',\n             'file2': (file2, file2a)\n         })\n-        got = simplejson.loads(response.content)\n+        got = json.loads(response.content)\n \n         self.assertEqual(got.get('file1'), 1)\n         self.assertEqual(got.get('file2'), 2)"
        },
        {
            "sha": "ae6842d0a7093855a2b5315c513757c4c83a1f0a",
            "filename": "tests/regressiontests/file_uploads/views.py",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/tests%2Fregressiontests%2Ffile_uploads%2Fviews.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/tests%2Fregressiontests%2Ffile_uploads%2Fviews.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ffile_uploads%2Fviews.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -1,11 +1,11 @@\n from __future__ import absolute_import\n \n import hashlib\n+import json\n import os\n \n from django.core.files.uploadedfile import UploadedFile\n from django.http import HttpResponse, HttpResponseServerError\n-from django.utils import simplejson\n \n from .models import FileModel, UPLOAD_TO\n from .tests import UNICODE_FILENAME\n@@ -88,14 +88,14 @@ def file_upload_echo(request):\n     Simple view to echo back info about uploaded files for tests.\n     \"\"\"\n     r = dict([(k, f.name) for k, f in request.FILES.items()])\n-    return HttpResponse(simplejson.dumps(r))\n+    return HttpResponse(json.dumps(r))\n \n def file_upload_echo_content(request):\n     \"\"\"\n     Simple view to echo back the content of uploaded files for tests.\n     \"\"\"\n     r = dict([(k, f.read()) for k, f in request.FILES.items()])\n-    return HttpResponse(simplejson.dumps(r))\n+    return HttpResponse(json.dumps(r))\n \n def file_upload_quota(request):\n     \"\"\"\n@@ -120,7 +120,7 @@ def file_upload_getlist_count(request):\n \n     for key in request.FILES.keys():\n         file_counts[key] = len(request.FILES.getlist(key))\n-    return HttpResponse(simplejson.dumps(file_counts))\n+    return HttpResponse(json.dumps(file_counts))\n \n def file_upload_errors(request):\n     request.upload_handlers.insert(0, ErroringUploadHandler())"
        },
        {
            "sha": "ffd416655e782d06592c0a2265640be676085aa6",
            "filename": "tests/regressiontests/test_client_regress/views.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/tests%2Fregressiontests%2Ftest_client_regress%2Fviews.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/tests%2Fregressiontests%2Ftest_client_regress%2Fviews.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftest_client_regress%2Fviews.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -1,11 +1,11 @@\n+import json\n import warnings\n \n from django.conf import settings\n from django.contrib.auth.decorators import login_required\n from django.http import HttpResponse, HttpResponseRedirect\n from django.core.exceptions import SuspiciousOperation\n from django.shortcuts import render_to_response\n-from django.utils import simplejson\n from django.utils.encoding import smart_str\n from django.core.serializers.json import DjangoJSONEncoder\n from django.test.client import CONTENT_TYPE_RE\n@@ -81,8 +81,8 @@ def return_json_file(request):\n         charset = settings.DEFAULT_CHARSET\n \n     # This just checks that the uploaded data is JSON\n-    obj_dict = simplejson.loads(request.body.decode(charset))\n-    obj_json = simplejson.dumps(obj_dict, encoding=charset,\n+    obj_dict = json.loads(request.body.decode(charset))\n+    obj_json = json.dumps(obj_dict, encoding=charset,\n                                 cls=DjangoJSONEncoder,\n                                 ensure_ascii=False)\n     response = HttpResponse(smart_str(obj_json, encoding=charset), status=200,"
        },
        {
            "sha": "a277bc999b5696595ad49bd8f4ddce01269315ec",
            "filename": "tests/regressiontests/test_utils/tests.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/cec6bd5a59547dc97fe98975c570fc27a1e970be/tests%2Fregressiontests%2Ftest_utils%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/cec6bd5a59547dc97fe98975c570fc27a1e970be/tests%2Fregressiontests%2Ftest_utils%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftest_utils%2Ftests.py?ref=cec6bd5a59547dc97fe98975c570fc27a1e970be",
            "patch": "@@ -491,7 +491,7 @@ class MyCustomField(IntegerField):\n __test__ = {\"API_TEST\": r\"\"\"\n # Some checks of the doctest output normalizer.\n # Standard doctests do fairly\n->>> from django.utils import simplejson\n+>>> import json\n >>> from django.utils.xmlutils import SimplerXMLGenerator\n >>> from StringIO import StringIO\n \n@@ -502,7 +502,7 @@ class MyCustomField(IntegerField):\n ...     return 42\n \n >>> def produce_json():\n-...     return simplejson.dumps(['foo', {'bar': ('baz', None, 1.0, 2), 'whiz': 42}])\n+...     return json.dumps(['foo', {'bar': ('baz', None, 1.0, 2), 'whiz': 42}])\n \n >>> def produce_xml():\n ...     stream = StringIO()"
        }
    ],
    "stats": {
        "total": 1426,
        "additions": 105,
        "deletions": 1321
    }
}