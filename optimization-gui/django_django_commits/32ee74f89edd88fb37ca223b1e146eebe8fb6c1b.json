{
    "author": "adrianholovaty",
    "message": "Edited testing.txt changes from [17283]\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17306 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "32ee74f89edd88fb37ca223b1e146eebe8fb6c1b",
    "files": [
        {
            "sha": "5eef2dc092b156e897fea31f04d46ff480b95698",
            "filename": "docs/topics/testing.txt",
            "status": "modified",
            "additions": 13,
            "deletions": 14,
            "changes": 27,
            "blob_url": "https://github.com/django/django/blob/32ee74f89edd88fb37ca223b1e146eebe8fb6c1b/docs%2Ftopics%2Ftesting.txt",
            "raw_url": "https://github.com/django/django/raw/32ee74f89edd88fb37ca223b1e146eebe8fb6c1b/docs%2Ftopics%2Ftesting.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Ftesting.txt?ref=32ee74f89edd88fb37ca223b1e146eebe8fb6c1b",
            "patch": "@@ -1870,16 +1870,16 @@ out the `full reference`_ for more details.\n \n     When using an in-memory SQLite database to run the tests, the same database\n     connection will be shared by two threads in parallel: the thread in which\n-    the live server is run, and the thread in which the test case is run. It is\n+    the live server is run and the thread in which the test case is run. It's\n     important to prevent simultaneous database queries via this shared\n-    connection by the two threads as that may sometimes cause the tests to\n-    randomly fail. So you need to ensure that the two threads do not access the\n+    connection by the two threads, as that may sometimes randomly cause the\n+    tests to fail. So you need to ensure that the two threads don't access the\n     database at the same time. In particular, this means that in some cases\n-    (for example just after clicking a link or submitting a form) you might\n+    (for example, just after clicking a link or submitting a form), you might\n     need to check that a response is received by Selenium and that the next\n-    page is loaded before proceeding further with the execution of the tests.\n-    This can be achieved, for example, by making Selenium wait until the\n-    `<body>` HTML tag is found in the response (requires Selenium > 2.13):\n+    page is loaded before proceeding with further test execution.\n+    Do this, for example, by making Selenium wait until the `<body>` HTML tag\n+    is found in the response (requires Selenium > 2.13):\n \n     .. code-block:: python\n \n@@ -1891,13 +1891,12 @@ out the `full reference`_ for more details.\n             WebDriverWait(self.selenium, timeout).until(\n                 lambda driver: driver.find_element_by_tag_name('body'), timeout=10)\n \n-    The difficult point is that there really is no such thing as a \"page load\",\n-    especially in modern Web apps that have dynamically-generated page\n-    components that do not exist in the HTML initially received from the\n-    server. So simply checking for the presence of the `<body>` tag in the\n-    response might not necessarily be appropriate for all use cases. Please\n-    refer to the `Selenium FAQ`_ and the `Selenium documentation`_ for more\n-    information on this topic.\n+    The tricky thing here is that there's really no such thing as a \"page load,\"\n+    especially in modern Web apps that generate HTML dynamically after the\n+    server generates the initial document. So, simply checking for the presence\n+    of `<body>` in the response might not necessarily be appropriate for all\n+    use cases. Please refer to the `Selenium FAQ`_ and\n+    `Selenium documentation`_ for more information.\n \n     .. _Selenium FAQ: http://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions#Q:_WebDriver_fails_to_find_elements_/_Does_not_block_on_page_loa\n     .. _Selenium documentation: http://seleniumhq.org/docs/04_webdriver_advanced.html#explicit-waits"
        }
    ],
    "stats": {
        "total": 27,
        "additions": 13,
        "deletions": 14
    }
}