{
    "author": "timgraham",
    "message": "Fixed #18715 - Refactored tutorial 3. Thank-you Daniel Greenfeld!",
    "sha": "07abb7a6b7af2c45be553acf08d85cd2d72057ad",
    "files": [
        {
            "sha": "b87b280d7c16ceba8543e30e7e0fbce264a21818",
            "filename": "docs/intro/tutorial02.txt",
            "status": "modified",
            "additions": 13,
            "deletions": 3,
            "changes": 16,
            "blob_url": "https://github.com/django/django/blob/07abb7a6b7af2c45be553acf08d85cd2d72057ad/docs%2Fintro%2Ftutorial02.txt",
            "raw_url": "https://github.com/django/django/raw/07abb7a6b7af2c45be553acf08d85cd2d72057ad/docs%2Fintro%2Ftutorial02.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fintro%2Ftutorial02.txt?ref=07abb7a6b7af2c45be553acf08d85cd2d72057ad",
            "patch": "@@ -440,20 +440,30 @@ Open your settings file (``mysite/settings.py``, remember) and look at the\n filesystem directories to check when loading Django templates. It's a search\n path.\n \n+Create a ``mytemplates`` directory in your project directory. Templates can\n+live anywhere on your filesystem that Django can access. (Django runs as\n+whatever user your server runs.) However, keeping your templates within the\n+project is a good convention to follow.\n+\n+When you’ve done that, create a directory polls in your template directory.\n+Within that, create a file called index.html. Note that our\n+``loader.get_template('polls/index.html')`` code from above maps to\n+[template_directory]/polls/index.html” on the filesystem.\n+\n By default, :setting:`TEMPLATE_DIRS` is empty. So, let's add a line to it, to\n tell Django where our templates live::\n \n     TEMPLATE_DIRS = (\n-        '/home/my_username/mytemplates', # Change this to your own directory.\n+        '/path/to/mysite/mytemplates', # Change this to your own directory.\n     )\n \n Now copy the template ``admin/base_site.html`` from within the default Django\n admin template directory in the source code of Django itself\n (``django/contrib/admin/templates``) into an ``admin`` subdirectory of\n whichever directory you're using in :setting:`TEMPLATE_DIRS`. For example, if\n-your :setting:`TEMPLATE_DIRS` includes ``'/home/my_username/mytemplates'``, as\n+your :setting:`TEMPLATE_DIRS` includes ``'/path/to/mysite/mytemplates'``, as\n above, then copy ``django/contrib/admin/templates/admin/base_site.html`` to\n-``/home/my_username/mytemplates/admin/base_site.html``. Don't forget that\n+``/path/to/mysite/mytemplates/admin/base_site.html``. Don't forget that\n ``admin`` subdirectory.\n \n .. admonition:: Where are the Django source files?"
        },
        {
            "sha": "169e6cd59fbefbd56acd9657a5aa83403675934f",
            "filename": "docs/intro/tutorial03.txt",
            "status": "modified",
            "additions": 258,
            "deletions": 264,
            "changes": 522,
            "blob_url": "https://github.com/django/django/blob/07abb7a6b7af2c45be553acf08d85cd2d72057ad/docs%2Fintro%2Ftutorial03.txt",
            "raw_url": "https://github.com/django/django/raw/07abb7a6b7af2c45be553acf08d85cd2d72057ad/docs%2Fintro%2Ftutorial03.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fintro%2Ftutorial03.txt?ref=07abb7a6b7af2c45be553acf08d85cd2d72057ad",
            "patch": "@@ -10,7 +10,7 @@ Philosophy\n ==========\n \n A view is a \"type\" of Web page in your Django application that generally serves\n-a specific function and has a specific template. For example, in a Weblog\n+a specific function and has a specific template. For example, in a blog\n application, you might have the following views:\n \n * Blog homepage -- displays the latest few entries.\n@@ -41,154 +41,212 @@ In our poll application, we'll have the following four views:\n \n In Django, each view is represented by a simple Python function.\n \n-Design your URLs\n-================\n+Write your first view\n+=====================\n+\n+Let's write the first view. Open the file ``polls/views.py``\n+and put the following Python code in it::\n+\n+    from django.http import HttpResponse\n+\n+    def index(request):\n+        return HttpResponse(\"Hello, world. You're at the poll index.\")\n \n-The first step of writing views is to design your URL structure. You do this by\n-creating a Python module, called a URLconf. URLconfs are how Django associates\n-a given URL with given Python code.\n+This is the simplest view possible in Django. Now we have a problem, how does\n+this view get called? For that we need to map it to a URL, in Django this is\n+done in a configuration file called a URLconf.\n \n-When a user requests a Django-powered page, the system looks at the\n-:setting:`ROOT_URLCONF` setting, which contains a string in Python dotted\n-syntax. Django loads that module and looks for a module-level variable called\n-``urlpatterns``, which is a sequence of tuples in the following format::\n+.. admonition:: What is a URLconf?\n \n-    (regular expression, Python callback function [, optional dictionary])\n+    In Django, web pages and other content are delivered by views and\n+    determining which view is called is done by Python modules informally\n+    titled 'URLconfs'. These modules are pure Python code and are a simple\n+    mapping between URL patterns (as simple regular expressions) to Python\n+    callback functions (your views). This tutorial provides basic instruction\n+    in their use, and you can refer to :mod:`django.core.urlresolvers` for\n+    more information.\n \n-Django starts at the first regular expression and makes its way down the list,\n-comparing the requested URL against each regular expression until it finds one\n-that matches.\n+To create a URLconf in the polls directory, create a file called ``urls.py``.\n+Your app directory should now look like::\n \n-When it finds a match, Django calls the Python callback function, with an\n-:class:`~django.http.HttpRequest` object as the first argument, any \"captured\"\n-values from the regular expression as keyword arguments, and, optionally,\n-arbitrary keyword arguments from the dictionary (an optional third item in the\n-tuple).\n+    polls/\n+        __init__.py\n+        admin.py\n+        models.py\n+        tests.py\n+        urls.py\n+        views.py\n \n-For more on :class:`~django.http.HttpRequest` objects, see the\n-:doc:`/ref/request-response`. For more details on URLconfs, see the\n-:doc:`/topics/http/urls`.\n+In the ``polls/urls.py`` file include the following code::\n \n-When you ran ``django-admin.py startproject mysite`` at the beginning of\n-Tutorial 1, it created a default URLconf in ``mysite/urls.py``. It also\n-automatically set your :setting:`ROOT_URLCONF` setting (in ``settings.py``) to\n-point at that file::\n+    from django.conf.urls import patterns, url\n \n-    ROOT_URLCONF = 'mysite.urls'\n+    from polls import views\n \n-Time for an example. Edit ``mysite/urls.py`` so it looks like this::\n+    urlpatterns = patterns('',\n+        url(r'^$', views.index, name='index')\n+    )\n+\n+The next step is to point the root URLconf at the ``polls.urls`` module. In\n+``mysite/urls.py`` insert an :func:`~django.conf.urls.include`, leaving you\n+with::\n \n     from django.conf.urls import patterns, include, url\n \n     from django.contrib import admin\n     admin.autodiscover()\n \n     urlpatterns = patterns('',\n-        url(r'^polls/$', 'polls.views.index'),\n-        url(r'^polls/(?P<poll_id>\\d+)/$', 'polls.views.detail'),\n-        url(r'^polls/(?P<poll_id>\\d+)/results/$', 'polls.views.results'),\n-        url(r'^polls/(?P<poll_id>\\d+)/vote/$', 'polls.views.vote'),\n+        url(r'^polls/', include('polls.urls')),\n         url(r'^admin/', include(admin.site.urls)),\n     )\n \n-This is worth a review. When somebody requests a page from your Web site -- say,\n-\"/polls/23/\", Django will load this Python module, because it's pointed to by\n-the :setting:`ROOT_URLCONF` setting. It finds the variable named ``urlpatterns``\n-and traverses the regular expressions in order. When it finds a regular\n-expression that matches -- ``r'^polls/(?P<poll_id>\\d+)/$'`` -- it loads the\n-function ``detail()`` from ``polls/views.py``. Finally, it calls that\n-``detail()`` function like so::\n+You have now wired an `index` view into the URLconf. Go to\n+http://localhost:8000/polls/ in your browser, and you should see the text\n+\"*Hello, world. You're at the poll index.*\", which you defined in the\n+``index`` view.\n \n-    detail(request=<HttpRequest object>, poll_id='23')\n+The :func:`~django.conf.urls.url` function is passed four arguments, two\n+required: ``regex`` and ``view``, and two optional: ``kwargs``, and ``name``.\n+At this point, it's worth reviewing what these arguments are for.\n \n-The ``poll_id='23'`` part comes from ``(?P<poll_id>\\d+)``. Using parentheses\n-around a pattern \"captures\" the text matched by that pattern and sends it as an\n-argument to the view function; the ``?P<poll_id>`` defines the name that will be\n-used to identify the matched pattern; and ``\\d+`` is a regular expression to\n-match a sequence of digits (i.e., a number).\n+:func:`~django.conf.urls.url` argument: regex\n+---------------------------------------------\n \n-Because the URL patterns are regular expressions, there really is no limit on\n-what you can do with them. And there's no need to add URL cruft such as ``.php``\n--- unless you have a sick sense of humor, in which case you can do something\n-like this::\n-\n-    (r'^polls/latest\\.php$', 'polls.views.index'),\n-\n-But, don't do that. It's silly.\n+The term `regex` is a commonly used short form meaning `regular expression`,\n+which is a syntax for matching patterns in strings, or in this case, url\n+patterns. Django starts at the first regular expression and makes its way down\n+the list,  comparing the requested URL against each regular expression until it\n+finds one that matches.\n \n Note that these regular expressions do not search GET and POST parameters, or\n-the domain name. For example, in a request to ``http://www.example.com/myapp/``,\n-the URLconf will look for ``myapp/``. In a request to\n-``http://www.example.com/myapp/?page=3``, the URLconf will look for ``myapp/``.\n+the domain name. For example, in a request to\n+``http://www.example.com/myapp/``, the URLconf will look for ``myapp/``. In a\n+request to ``http://www.example.com/myapp/?page=3``, the URLconf will also\n+look for ``myapp/``.\n \n If you need help with regular expressions, see `Wikipedia's entry`_ and the\n documentation of the :mod:`re` module. Also, the O'Reilly book \"Mastering\n-Regular Expressions\" by Jeffrey Friedl is fantastic.\n+Regular Expressions\" by Jeffrey Friedl is fantastic. In practice, however,\n+you don't need to be an expert on regular expressions, as you really only need\n+to know how to capture simple patterns. In fact, complex regexes can have poor\n+lookup performance, so you probably shouldn't rely on the full power of regexes.\n \n Finally, a performance note: these regular expressions are compiled the first\n-time the URLconf module is loaded. They're super fast.\n+time the URLconf module is loaded. They're super fast (as long as the lookups\n+aren't too complex as noted above).\n \n .. _Wikipedia's entry: http://en.wikipedia.org/wiki/Regular_expression\n \n-Write your first view\n-=====================\n+:func:`~django.conf.urls.url` argument: view\n+--------------------------------------------\n \n-Well, we haven't created any views yet -- we just have the URLconf. But let's\n-make sure Django is following the URLconf properly.\n+When Django finds a regular expression match, Django calls the specified view\n+function, with an :class:`~django.http.HttpRequest` object as the first\n+argument and any “captured” values from the regular expression as other\n+arguments. If the regex uses simple captures, values are passed as positional\n+arguments; if it uses named captures, values are passed as keyword arguments.\n+We'll give an example of this in a bit.\n \n-Fire up the Django development Web server:\n+:func:`~django.conf.urls.url` argument: kwargs\n+----------------------------------------------\n \n-.. code-block:: bash\n+Arbitrary keyword arguments can be passed in a dictionary to the target view. We\n+aren't going to use this feature of Django in the tutorial.\n \n-    python manage.py runserver\n+:func:`~django.conf.urls.url` argument: name\n+---------------------------------------------\n \n-Now go to \"http://localhost:8000/polls/\" on your domain in your Web browser.\n-You should get a pleasantly-colored error page with the following message::\n+Naming your URL lets you refer to it unambiguously from elsewhere in Django\n+especially templates. This powerful feature allows you to make  global changes\n+to the url patterns of your project while only touching a single file.\n \n-    ViewDoesNotExist at /polls/\n+Writing more views\n+==================\n \n-    Could not import polls.views.index. View does not exist in module polls.views.\n+Now let's add a few more views to ``polls/views.py``. These views are\n+slightly different, because they take an argument::\n \n-This error happened because you haven't written a function ``index()`` in the\n-module ``polls/views.py``.\n+    def detail(request, poll_id):\n+        return HttpResponse(\"You're looking at poll %s.\" % poll_id)\n \n-Try \"/polls/23/\", \"/polls/23/results/\" and \"/polls/23/vote/\". The error\n-messages tell you which view Django tried (and failed to find, because you\n-haven't written any views yet).\n+    def results(request, poll_id):\n+        return HttpResponse(\"You're looking at the results of poll %s.\" % poll_id)\n \n-Time to write the first view. Open the file ``polls/views.py``\n-and put the following Python code in it::\n+    def vote(request, poll_id):\n+        return HttpResponse(\"You're voting on poll %s.\" % poll_id)\n \n-    from django.http import HttpResponse\n+Wire these news views into the ``polls.urls`` module by adding the following\n+:func:`~django.conf.urls.url` calls::\n \n-    def index(request):\n-        return HttpResponse(\"Hello, world. You're at the poll index.\")\n+    from django.conf.urls import patterns, url\n \n-This is the simplest view possible. Go to \"/polls/\" in your browser, and you\n-should see your text.\n+    from polls import views\n \n-Now lets add a few more views. These views are slightly different, because\n-they take an argument (which, remember, is passed in from whatever was\n-captured by the regular expression in the URLconf)::\n+    urlpatterns = patterns('',\n+        # ex: /polls/\n+        url(r'^$', views.index, name='index'),\n+        # ex: /polls/5/\n+        url(r'^(?P<poll_id>\\d+)/$', views.detail, name='detail'),\n+        # ex: /polls/5/results/\n+        url(r'^(?P<poll_id>\\d+)/results/$', views.results, name='results'),\n+        # ex: /polls/5/vote/\n+        url(r'^(?P<poll_id>\\d+)/vote/$', views.vote, name='vote'),\n+    )\n \n-    def detail(request, poll_id):\n-        return HttpResponse(\"You're looking at poll %s.\" % poll_id)\n+Take a look in your browser, at \"/polls/34/\". It'll run the ``detail()``\n+method and display whatever ID you provide in the URL. Try\n+\"/polls/34/results/\" and \"/polls/34/vote/\" too -- these will display the\n+placeholder results and voting pages.\n+\n+When somebody requests a page from your Web site -- say, \"/polls/34/\", Django\n+will load the ``mysite.urls`` Python module because it's pointed to by the\n+:setting:`ROOT_URLCONF` setting. It finds the variable named ``urlpatterns``\n+and traverses the regular expressions in order. The\n+:func:`~django.conf.urls.include` functions we are using simply reference\n+other URLconfs. Note that the regular expressions for the\n+:func:`~django.conf.urls.include` functions don't have a ``$`` (end-of-string\n+match character) but rather a trailing slash. Whenever Django encounters\n+:func:`~django.conf.urls.include`, it chops off whatever part of the URL\n+matched up to that point and sends the remaining string to the included\n+URLconf for further processing.\n \n-    def results(request, poll_id):\n-        return HttpResponse(\"You're looking at the results of poll %s.\" % poll_id)\n+The idea behind :func:`~django.conf.urls.include` is to make it easy to\n+plug-and-play URLs. Since polls are in their own URLconf\n+(``polls/urls.py``), they can be placed under \"/polls/\", or under\n+\"/fun_polls/\", or under \"/content/polls/\", or any other path root, and the\n+app will still work.\n \n-    def vote(request, poll_id):\n-        return HttpResponse(\"You're voting on poll %s.\" % poll_id)\n+Here's what happens if a user goes to \"/polls/34/\" in this system:\n \n-Take a look in your browser, at \"/polls/34/\". It'll run the `detail()` method\n-and display whatever ID you provide in the URL. Try \"/polls/34/results/\" and\n-\"/polls/34/vote/\" too -- these will display the placeholder results and voting\n-pages.\n+* Django will find the match at ``'^polls/'``\n+\n+* Then, Django will strip off the matching text (``\"polls/\"``) and send the\n+  remaining text -- ``\"34/\"`` -- to the 'polls.urls' URLconf for\n+  further processing which matches ``r'^(?P<poll_id>\\d+)/$'`` resulting in a\n+  call to the ``detail()`` view like so::\n+\n+    detail(request=<HttpRequest object>, poll_id='34')\n+\n+The ``poll_id='34'`` part comes from ``(?P<poll_id>\\d+)``. Using parentheses\n+around a pattern \"captures\" the text matched by that pattern and sends it as an\n+argument to the view function; ``?P<poll_id>`` defines the name that will\n+be used to identify the matched pattern; and ``\\d+`` is a regular expression to\n+match a sequence of digits (i.e., a number).\n+\n+Because the URL patterns are regular expressions, there really is no limit on\n+what you can do with them. And there's no need to add URL cruft such as ``.php``\n+-- unless you have a sick sense of humor, in which case you can do something\n+like this::\n+\n+    (r'^polls/latest\\.php$', 'polls.views.index'),\n+\n+But, don't do that. It's silly.\n \n Write views that actually do something\n ======================================\n \n-Each view is responsible for doing one of two things: Returning an\n+Each view is responsible for doing one of two things: returning an\n :class:`~django.http.HttpResponse` object containing the content for the\n requested page, or raising an exception such as :exc:`~django.http.Http404`. The\n rest is up to you.\n@@ -205,51 +263,21 @@ in :doc:`Tutorial 1 </intro/tutorial01>`. Here's one stab at the ``index()``\n view, which displays the latest 5 poll questions in the system, separated by\n commas, according to publication date::\n \n-    from polls.models import Poll\n     from django.http import HttpResponse\n \n+    from polls.models import Poll\n+\n     def index(request):\n-        latest_poll_list = Poll.objects.all().order_by('-pub_date')[:5]\n+        latest_poll_list = Poll.objects.order_by('-pub_date')[:5]\n         output = ', '.join([p.question for p in latest_poll_list])\n         return HttpResponse(output)\n \n-There's a problem here, though: The page's design is hard-coded in the view. If\n+There's a problem here, though: the page's design is hard-coded in the view. If\n you want to change the way the page looks, you'll have to edit this Python code.\n-So let's use Django's template system to separate the design from Python::\n-\n-    from django.template import Context, loader\n-    from polls.models import Poll\n-    from django.http import HttpResponse\n-\n-    def index(request):\n-        latest_poll_list = Poll.objects.all().order_by('-pub_date')[:5]\n-        t = loader.get_template('polls/index.html')\n-        c = Context({\n-            'latest_poll_list': latest_poll_list,\n-        })\n-        return HttpResponse(t.render(c))\n-\n-That code loads the template called \"polls/index.html\" and passes it a context.\n-The context is a dictionary mapping template variable names to Python objects.\n-\n-Reload the page. Now you'll see an error::\n-\n-    TemplateDoesNotExist at /polls/\n-    polls/index.html\n-\n-Ah. There's no template yet. First, create a directory, somewhere on your\n-filesystem, whose contents Django can access. (Django runs as whatever user your\n-server runs.) Don't put them under your document root, though. You probably\n-shouldn't make them public, just for security's sake.\n-Then edit :setting:`TEMPLATE_DIRS` in your ``settings.py`` to tell Django where\n-it can find templates -- just as you did in the \"Customize the admin look and\n-feel\" section of Tutorial 2.\n-\n-When you've done that, create a directory ``polls`` in your template directory.\n-Within that, create a file called ``index.html``. Note that our\n-``loader.get_template('polls/index.html')`` code from above maps to\n-\"[template_directory]/polls/index.html\" on the filesystem.\n+So let's use Django's template system to separate the design from Python.\n \n+First, create a directory ``polls`` in your template directory you specified\n+in setting:`TEMPLATE_DIRS`. Within that, create a file called ``index.html``.\n Put the following code in that template:\n \n .. code-block:: html+django\n@@ -264,36 +292,58 @@ Put the following code in that template:\n         <p>No polls are available.</p>\n     {% endif %}\n \n+Now let's use that html template in our index view::\n+\n+    from django.http import HttpResponse\n+    from django.template import Context, loader\n+\n+    from polls.models import Poll\n+\n+    def index(request):\n+        latest_poll_list = Poll.objects.order_by('-pub_date')[:5]\n+        template = loader.get_template('polls/index.html')\n+        context = Context({\n+            'latest_poll_list': latest_poll_list,\n+        })\n+        return HttpResponse(template.render(context))\n+\n+That code loads the template called  ``polls/index.html`` and passes it a\n+context. The context is a dictionary mapping template variable names to Python\n+objects.\n+\n Load the page in your Web browser, and you should see a bulleted-list\n containing the \"What's up\" poll from Tutorial 1. The link points to the poll's\n detail page.\n \n-A shortcut: render_to_response()\n---------------------------------\n+A shortcut: :func:`~django.shortcuts.render`\n+--------------------------------------------\n \n It's a very common idiom to load a template, fill a context and return an\n :class:`~django.http.HttpResponse` object with the result of the rendered\n template. Django provides a shortcut. Here's the full ``index()`` view,\n rewritten::\n \n-    from django.shortcuts import render_to_response\n+    from django.shortcuts import render\n+\n     from polls.models import Poll\n \n     def index(request):\n         latest_poll_list = Poll.objects.all().order_by('-pub_date')[:5]\n-        return render_to_response('polls/index.html', {'latest_poll_list': latest_poll_list})\n+        context = {'latest_poll_list': latest_poll_list}\n+        return render(request, 'polls/index.html', context)\n \n Note that once we've done this in all these views, we no longer need to import\n :mod:`~django.template.loader`, :class:`~django.template.Context` and\n-:class:`~django.http.HttpResponse`.\n+:class:`~django.http.HttpResponse` (you'll want to keep ``HttpResponse`` if you\n+still have the stub methods for ``detail``, ``results``, and ``vote``).\n \n-The :func:`~django.shortcuts.render_to_response` function takes a template name\n-as its first argument and a dictionary as its optional second argument. It\n-returns an :class:`~django.http.HttpResponse` object of the given template\n-rendered with the given context.\n+The :func:`~django.shortcuts.render` function takes the request object as its\n+first argument, a template name as its second argument and a dictionary as its\n+optional third argument. It returns an :class:`~django.http.HttpResponse`\n+object of the given template rendered with the given context.\n \n-Raising 404\n-===========\n+Raising a 404 error\n+===================\n \n Now, let's tackle the poll detail view -- the page that displays the question\n for a given poll. Here's the view::\n@@ -302,10 +352,10 @@ for a given poll. Here's the view::\n     # ...\n     def detail(request, poll_id):\n         try:\n-            p = Poll.objects.get(pk=poll_id)\n+            poll = Poll.objects.get(pk=poll_id)\n         except Poll.DoesNotExist:\n             raise Http404\n-        return render_to_response('polls/detail.html', {'poll': p})\n+        return render(request, 'polls/detail.html', {'poll': poll})\n \n The new concept here: The view raises the :exc:`~django.http.Http404` exception\n if a poll with the requested ID doesn't exist.\n@@ -317,18 +367,18 @@ later, but if you'd like to quickly get the above example working, just::\n \n will get you started for now.\n \n-A shortcut: get_object_or_404()\n--------------------------------\n+A shortcut: :func:`~django.shortcuts.get_object_or_404`\n+-------------------------------------------------------\n \n It's a very common idiom to use :meth:`~django.db.models.query.QuerySet.get`\n and raise :exc:`~django.http.Http404` if the object doesn't exist. Django\n provides a shortcut. Here's the ``detail()`` view, rewritten::\n \n-    from django.shortcuts import render_to_response, get_object_or_404\n+    from django.shortcuts import render, get_object_or_404\n     # ...\n     def detail(request, poll_id):\n-        p = get_object_or_404(Poll, pk=poll_id)\n-        return render_to_response('polls/detail.html', {'poll': p})\n+        poll = get_object_or_404(Poll, pk=poll_id)\n+        return render(request, 'polls/detail.html', {'poll': poll})\n \n The :func:`~django.shortcuts.get_object_or_404` function takes a Django model\n as its first argument and an arbitrary number of keyword arguments, which it\n@@ -345,7 +395,8 @@ exist.\n     :exc:`~django.core.exceptions.ObjectDoesNotExist`?\n \n     Because that would couple the model layer to the view layer. One of the\n-    foremost design goals of Django is to maintain loose coupling.\n+    foremost design goals of Django is to maintain loose coupling. Some\n+    controlled coupling is introduced in the :mod:`django.shortcuts` module.\n \n There's also a :func:`~django.shortcuts.get_list_or_404` function, which works\n just as :func:`~django.shortcuts.get_object_or_404` -- except using\n@@ -369,7 +420,8 @@ You normally won't have to bother with writing 404 views. If you don't set\n is used by default. Optionally, you can create a ``404.html`` template\n in the root of your template directory. The default 404 view will then use that\n template for all 404 errors when :setting:`DEBUG` is set to ``False`` (in your\n-settings module).\n+settings module). If you do create the template, add at least some dummy\n+content like \"Page not found\".\n \n A couple more things to note about 404 views:\n \n@@ -387,11 +439,14 @@ Similarly, your root URLconf may define a ``handler500``, which points\n to a view to call in case of server errors. Server errors happen when\n you have runtime errors in view code.\n \n+Likewise, you should create a ``500.html`` template at the root of your\n+template directory and add some content like \"Something went wrong\".\n+\n Use the template system\n =======================\n \n Back to the ``detail()`` view for our poll application. Given the context\n-variable ``poll``, here's what the \"polls/detail.html\" template might look\n+variable ``poll``, here's what the ``polls/detail.html`` template might look\n like:\n \n .. code-block:: html+django\n@@ -416,150 +471,89 @@ suitable for use in the :ttag:`{% for %}<for>` tag.\n \n See the :doc:`template guide </topics/templates>` for more about templates.\n \n-Simplifying the URLconfs\n-========================\n+Removing hardcoded URLs in templates\n+====================================\n \n-Take some time to play around with the views and template system. As you edit\n-the URLconf, you may notice there's a fair bit of redundancy in it::\n+Remember, when we wrote the link to a poll in the ``polls/index.html``\n+template, the link was partially hardcoded like this:\n \n-    urlpatterns = patterns('',\n-        url(r'^polls/$', 'polls.views.index'),\n-        url(r'^polls/(?P<poll_id>\\d+)/$', 'polls.views.detail'),\n-        url(r'^polls/(?P<poll_id>\\d+)/results/$', 'polls.views.results'),\n-        url(r'^polls/(?P<poll_id>\\d+)/vote/$', 'polls.views.vote'),\n-    )\n+.. code-block:: html+django\n \n-Namely, ``polls.views`` is in every callback.\n+    <li><a href=\"/polls/{{ poll.id }}/\">{{ poll.question }}</a></li>\n \n-Because this is a common case, the URLconf framework provides a shortcut for\n-common prefixes. You can factor out the common prefixes and add them as the\n-first argument to :func:`~django.conf.urls.patterns`, like so::\n+The problem with this hardcoded, tightly-coupled approach is that it becomes\n+challenging to change URLs on projects with a lot of templates. However, since\n+you defined the name argument in the :func:`~django.conf.urls.url` functions in\n+the ``polls.urls`` module, you can remove a reliance on specific URL paths\n+defined in your url configurations by using the ``{% url %}`` template tag:\n \n-    urlpatterns = patterns('polls.views',\n-        url(r'^polls/$', 'index'),\n-        url(r'^polls/(?P<poll_id>\\d+)/$', 'detail'),\n-        url(r'^polls/(?P<poll_id>\\d+)/results/$', 'results'),\n-        url(r'^polls/(?P<poll_id>\\d+)/vote/$', 'vote'),\n-    )\n+.. code-block:: html+django\n \n-This is functionally identical to the previous formatting. It's just a bit\n-tidier.\n+    <li><a href=\"{% url 'detail' poll.id %}\">{{ poll.question }}</a></li>\n \n-Since you generally don't want the prefix for one app to be applied to every\n-callback in your URLconf, you can concatenate multiple\n-:func:`~django.conf.urls.patterns`. Your full ``mysite/urls.py`` might\n-now look like this::\n+.. note::\n \n-    from django.conf.urls import patterns, include, url\n+    If ``{% url 'detail' poll.id %}`` (with quotes) doesn't work, but\n+    ``{% url detail poll.id %}`` (without quotes) does, that means you're\n+    using a version of Django < 1.5. In this case, add the following\n+    declaration at the top of your template:\n \n-    from django.contrib import admin\n-    admin.autodiscover()\n+    .. code-block:: html+django\n \n-    urlpatterns = patterns('polls.views',\n-        url(r'^polls/$', 'index'),\n-        url(r'^polls/(?P<poll_id>\\d+)/$', 'detail'),\n-        url(r'^polls/(?P<poll_id>\\d+)/results/$', 'results'),\n-        url(r'^polls/(?P<poll_id>\\d+)/vote/$', 'vote'),\n-    )\n+        {% load url from future %}\n \n-    urlpatterns += patterns('',\n-        url(r'^admin/', include(admin.site.urls)),\n-    )\n+The way this works is by looking up the URL definition as specified in the\n+``polls.urls`` module. You can see exactly where the URL name of 'detail' is\n+defined below::\n \n-Decoupling the URLconfs\n-=======================\n+    ...\n+    # the 'name' value as called by the {% url %} template tag\n+    url(r'^(?P<poll_id>\\d+)/$', views.detail, name='detail'),\n+    ...\n \n-While we're at it, we should take the time to decouple our poll-app URLs from\n-our Django project configuration. Django apps are meant to be pluggable -- that\n-is, each particular app should be transferable to another Django installation\n-with minimal fuss.\n+If you want to change the URL of the polls detail view to something else,\n+perhaps to something like ``polls/specifics/12/`` instead of doing it in the\n+template (or templates) you would change it in ``polls/urls.py``::\n \n-Our poll app is pretty decoupled at this point, thanks to the strict directory\n-structure that ``python manage.py startapp`` created, but one part of it is\n-coupled to the Django settings: The URLconf.\n+    ...\n+    # added the word 'specifics'\n+    url(r'^specifics/(?P<poll_id>\\d+)/$', views.detail, name='detail'),\n+    ...\n \n-We've been editing the URLs in ``mysite/urls.py``, but the URL design of an\n-app is specific to the app, not to the Django installation -- so let's move the\n-URLs within the app directory.\n+Namespacing URL names\n+======================\n \n-Copy the file ``mysite/urls.py`` to ``polls/urls.py``. Then, change\n-``mysite/urls.py`` to remove the poll-specific URLs and insert an\n-:func:`~django.conf.urls.include`, leaving you with::\n+The tutorial project has just one app, ``polls``. In real Django projects,\n+there might be five, ten, twenty apps or more. How does Django differentiate\n+the URL names between them? For example, the ``polls`` app has a ``detail``\n+view, and so might an app on the same project that is for a blog. How does one\n+make it so that Django knows which app view to create for a url when using the\n+``{% url %}`` template tag?\n+\n+The answer is to add namespaces to your root URLconf. In the\n+``mysite/urls.py`` file, go ahead and change it to include namespacing::\n \n     from django.conf.urls import patterns, include, url\n \n     from django.contrib import admin\n     admin.autodiscover()\n \n     urlpatterns = patterns('',\n-        url(r'^polls/', include('polls.urls')),\n+        url(r'^polls/', include('polls.urls', namespace=\"polls\")),\n         url(r'^admin/', include(admin.site.urls)),\n     )\n \n-:func:`~django.conf.urls.include` simply references another URLconf.\n-Note that the regular expression doesn't have a ``$`` (end-of-string match\n-character) but has the trailing slash. Whenever Django encounters\n-:func:`~django.conf.urls.include`, it chops off whatever part of the\n-URL matched up to that point and sends the remaining string to the included\n-URLconf for further processing.\n-\n-Here's what happens if a user goes to \"/polls/34/\" in this system:\n-\n-* Django will find the match at ``'^polls/'``\n-\n-* Then, Django will strip off the matching text (``\"polls/\"``) and send the\n-  remaining text -- ``\"34/\"`` -- to the 'polls.urls' URLconf for\n-  further processing.\n-\n-Now that we've decoupled that, we need to decouple the ``polls.urls``\n-URLconf by removing the leading \"polls/\" from each line, removing the\n-lines registering the admin site, and removing the ``include`` import which\n-is no longer used. Your ``polls/urls.py`` file should now look like\n-this::\n-\n-    from django.conf.urls import patterns, url\n-\n-    urlpatterns = patterns('polls.views',\n-        url(r'^$', 'index'),\n-        url(r'^(?P<poll_id>\\d+)/$', 'detail'),\n-        url(r'^(?P<poll_id>\\d+)/results/$', 'results'),\n-        url(r'^(?P<poll_id>\\d+)/vote/$', 'vote'),\n-    )\n-\n-The idea behind :func:`~django.conf.urls.include` and URLconf\n-decoupling is to make it easy to plug-and-play URLs. Now that polls are in their\n-own URLconf, they can be placed under \"/polls/\", or under \"/fun_polls/\", or\n-under \"/content/polls/\", or any other path root, and the app will still work.\n-\n-All the poll app cares about is its relative path, not its absolute path.\n-\n-Removing hardcoded URLs in templates\n-------------------------------------\n-\n-Remember, when we wrote the link to a poll in our template, the link was\n-partially hardcoded like this:\n+Now change your ``polls/index.html`` template from:\n \n .. code-block:: html+django\n \n-    <li><a href=\"/polls/{{ poll.id }}/\">{{ poll.question }}</a></li>\n+    <li><a href=\"{% url 'detail' poll.id %}\">{{ poll.question }}</a></li>\n \n-To use the decoupled URLs we've just introduced, replace the hardcoded link\n-with the :ttag:`url` template tag:\n+to point at the namespaced detail view:\n \n .. code-block:: html+django\n \n-    <li><a href=\"{% url 'polls.views.detail' poll.id %}\">{{ poll.question }}</a></li>\n-\n-.. note::\n-\n-    If ``{% url 'polls.views.detail' poll.id %}`` (with quotes) doesn't work,\n-    but ``{% url polls.views.detail poll.id %}`` (without quotes) does, that\n-    means you're using a version of Django < 1.5. In this case, add the\n-    following declaration at the top of your template:\n-\n-    .. code-block:: html+django\n-\n-        {% load url from future %}\n+    <li><a href=\"{% url 'polls:detail' poll.id %}\">{{ poll.question }}</a></li>\n \n When you're comfortable with writing views, read :doc:`part 4 of this tutorial\n </intro/tutorial04>` to learn about simple form processing and generic views."
        },
        {
            "sha": "8909caf98bf6a68902358a1c9d59430535603473",
            "filename": "docs/intro/tutorial04.txt",
            "status": "modified",
            "additions": 21,
            "deletions": 87,
            "changes": 108,
            "blob_url": "https://github.com/django/django/blob/07abb7a6b7af2c45be553acf08d85cd2d72057ad/docs%2Fintro%2Ftutorial04.txt",
            "raw_url": "https://github.com/django/django/raw/07abb7a6b7af2c45be553acf08d85cd2d72057ad/docs%2Fintro%2Ftutorial04.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fintro%2Ftutorial04.txt?ref=07abb7a6b7af2c45be553acf08d85cd2d72057ad",
            "patch": "@@ -18,7 +18,7 @@ tutorial, so that the template contains an HTML ``<form>`` element:\n \n     {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}\n \n-    <form action=\"{% url 'polls.views.vote' poll.id %}\" method=\"post\">\n+    <form action=\"{% url 'polls:vote' poll.id %}\" method=\"post\">\n     {% csrf_token %}\n     {% for choice in poll.choice_set.all %}\n         <input type=\"radio\" name=\"choice\" id=\"choice{{ forloop.counter }}\" value=\"{{ choice.id }}\" />\n@@ -35,7 +35,7 @@ A quick rundown:\n   selects one of the radio buttons and submits the form, it'll send the\n   POST data ``choice=3``. This is HTML Forms 101.\n \n-* We set the form's ``action`` to ``{% url 'polls.views.vote' poll.id %}``, and we\n+* We set the form's ``action`` to ``{% url 'polls:vote' poll.id %}``, and we\n   set ``method=\"post\"``. Using ``method=\"post\"`` (as opposed to\n   ``method=\"get\"``) is very important, because the act of submitting this\n   form will alter data server-side. Whenever you create a form that alters\n@@ -52,34 +52,18 @@ A quick rundown:\n   forms that are targeted at internal URLs should use the\n   :ttag:`{% csrf_token %}<csrf_token>` template tag.\n \n-The :ttag:`{% csrf_token %}<csrf_token>` tag requires information from the\n-request object, which is not normally accessible from within the template\n-context. To fix this, a small adjustment needs to be made to the ``detail``\n-view, so that it looks like the following::\n-\n-    from django.template import RequestContext\n-    # ...\n-    def detail(request, poll_id):\n-        p = get_object_or_404(Poll, pk=poll_id)\n-        return render_to_response('polls/detail.html', {'poll': p},\n-                                   context_instance=RequestContext(request))\n-\n-The details of how this works are explained in the documentation for\n-:ref:`RequestContext <subclassing-context-requestcontext>`.\n-\n Now, let's create a Django view that handles the submitted data and does\n something with it. Remember, in :doc:`Tutorial 3 </intro/tutorial03>`, we\n created a URLconf for the polls application that includes this line::\n \n-    (r'^(?P<poll_id>\\d+)/vote/$', 'vote'),\n+    url(r'^(?P<poll_id>\\d+)/vote/$', views.vote, name='vote'),\n \n We also created a dummy implementation of the ``vote()`` function. Let's\n create a real version. Add the following to ``polls/views.py``::\n \n-    from django.shortcuts import get_object_or_404, render_to_response\n+    from django.shortcuts import get_object_or_404, render\n     from django.http import HttpResponseRedirect, HttpResponse\n     from django.core.urlresolvers import reverse\n-    from django.template import RequestContext\n     from polls.models import Choice, Poll\n     # ...\n     def vote(request, poll_id):\n@@ -88,17 +72,17 @@ create a real version. Add the following to ``polls/views.py``::\n             selected_choice = p.choice_set.get(pk=request.POST['choice'])\n         except (KeyError, Choice.DoesNotExist):\n             # Redisplay the poll voting form.\n-            return render_to_response('polls/detail.html', {\n+            return render(request, 'polls/detail.html', {\n                 'poll': p,\n                 'error_message': \"You didn't select a choice.\",\n-            }, context_instance=RequestContext(request))\n+            })\n         else:\n             selected_choice.votes += 1\n             selected_choice.save()\n             # Always return an HttpResponseRedirect after successfully dealing\n             # with POST data. This prevents data from being posted twice if a\n             # user hits the Back button.\n-            return HttpResponseRedirect(reverse('polls.views.results', args=(p.id,)))\n+            return HttpResponseRedirect(reverse('polls:results', args=(p.id,)))\n \n This code includes a few things we haven't covered yet in this tutorial:\n \n@@ -142,8 +126,7 @@ This code includes a few things we haven't covered yet in this tutorial:\n     '/polls/3/results/'\n \n   ... where the ``3`` is the value of ``p.id``. This redirected URL will\n-  then call the ``'results'`` view to display the final page. Note that you\n-  need to use the full name of the view here (including the prefix).\n+  then call the ``'results'`` view to display the final page.\n \n As mentioned in Tutorial 3, ``request`` is a :class:`~django.http.HttpRequest`\n object. For more on :class:`~django.http.HttpRequest` objects, see the\n@@ -153,14 +136,14 @@ After somebody votes in a poll, the ``vote()`` view redirects to the results\n page for the poll. Let's write that view::\n \n     def results(request, poll_id):\n-        p = get_object_or_404(Poll, pk=poll_id)\n-        return render_to_response('polls/results.html', {'poll': p})\n+        poll = get_object_or_404(Poll, pk=poll_id)\n+        return render(request, 'polls/results.html', {'poll': poll})\n \n This is almost exactly the same as the ``detail()`` view from :doc:`Tutorial 3\n </intro/tutorial03>`. The only difference is the template name. We'll fix this\n redundancy later.\n \n-Now, create a ``results.html`` template:\n+Now, create a ``polls/results.html`` template:\n \n .. code-block:: html+django\n \n@@ -172,7 +155,7 @@ Now, create a ``results.html`` template:\n     {% endfor %}\n     </ul>\n \n-    <a href=\"{% url 'polls.views.detail' poll.id %}\">Vote again?</a>\n+    <a href=\"{% url 'polls:detail' poll.id %}\">Vote again?</a>\n \n Now, go to ``/polls/1/`` in your browser and vote in the poll. You should see a\n results page that gets updated each time you vote. If you submit the form\n@@ -215,19 +198,7 @@ Read on for details.\n \n     You should know basic math before you start using a calculator.\n \n-First, open the ``polls/urls.py`` URLconf. It looks like this, according to the\n-tutorial so far::\n-\n-    from django.conf.urls import patterns, url\n-\n-    urlpatterns = patterns('polls.views',\n-        url(r'^$', 'index'),\n-        url(r'^(?P<poll_id>\\d+)/$', 'detail'),\n-        url(r'^(?P<poll_id>\\d+)/results/$', 'results'),\n-        url(r'^(?P<poll_id>\\d+)/vote/$', 'vote'),\n-    )\n-\n-Change it like so::\n+First, open the ``polls/urls.py`` URLconf and change it like so::\n \n     from django.conf.urls import patterns, url\n     from django.views.generic import DetailView, ListView\n@@ -239,18 +210,18 @@ Change it like so::\n                 queryset=Poll.objects.order_by('-pub_date')[:5],\n                 context_object_name='latest_poll_list',\n                 template_name='polls/index.html'),\n-            name='poll_index'),\n+            name='index'),\n         url(r'^(?P<pk>\\d+)/$',\n             DetailView.as_view(\n                 model=Poll,\n                 template_name='polls/detail.html'),\n-            name='poll_detail'),\n+            name='detail'),\n         url(r'^(?P<pk>\\d+)/results/$',\n             DetailView.as_view(\n                 model=Poll,\n                 template_name='polls/results.html'),\n-            name='poll_results'),\n-        url(r'^(?P<poll_id>\\d+)/vote/$', 'polls.views.vote'),\n+            name='results'),\n+        url(r'^(?P<poll_id>\\d+)/vote/$', 'polls.views.vote', name='vote'),\n     )\n \n We're using two generic views here:\n@@ -267,15 +238,6 @@ two views abstract the concepts of \"display a list of objects\" and\n   ``\"pk\"``, so we've changed ``poll_id`` to ``pk`` for the generic\n   views.\n \n-* We've added the ``name`` argument to the views (e.g. ``name='poll_results'``)\n-  so that we have a way to refer to their URL later on (see the\n-  documentation about :ref:`naming URL patterns\n-  <naming-url-patterns>` for information). We're also using the\n-  :func:`~django.conf.urls.url` function from\n-  :mod:`django.conf.urls` here. It's a good habit to use\n-  :func:`~django.conf.urls.url` when you are providing a\n-  pattern name like this.\n-\n By default, the :class:`~django.views.generic.list.DetailView` generic\n view uses a template called ``<app name>/<model name>_detail.html``.\n In our case, it'll use the template ``\"polls/poll_detail.html\"``. The\n@@ -308,41 +270,13 @@ You can now delete the ``index()``, ``detail()`` and ``results()``\n views from ``polls/views.py``. We don't need them anymore -- they have\n been replaced by generic views.\n \n-The last thing to do is fix the URL handling to account for the use of\n-generic views. In the vote view above, we used the\n-:func:`~django.core.urlresolvers.reverse` function to avoid\n-hard-coding our URLs. Now that we've switched to a generic view, we'll\n-need to change the :func:`~django.core.urlresolvers.reverse` call to\n-point back to our new generic view. We can't simply use the view\n-function anymore -- generic views can be (and are) used multiple times\n--- but we can use the name we've given::\n-\n-    return HttpResponseRedirect(reverse('poll_results', args=(p.id,)))\n-\n-The same rule apply for the :ttag:`url` template tag. For example in the\n-``results.html`` template:\n-\n-.. code-block:: html+django\n-\n-    <a href=\"{% url 'poll_detail' poll.id %}\">Vote again?</a>\n-\n Run the server, and use your new polling app based on generic views.\n \n For full details on generic views, see the :doc:`generic views documentation\n </topics/class-based-views/index>`.\n \n-Coming soon\n-===========\n-\n-The tutorial ends here for the time being. Future installments of the tutorial\n-will cover:\n-\n-* Advanced form processing\n-* Using the RSS framework\n-* Using the cache framework\n-* Using the comments framework\n-* Advanced admin features: Permissions\n-* Advanced admin features: Custom JavaScript\n+What's next?\n+============\n \n-In the meantime, you might want to check out some pointers on :doc:`where to go\n-from here </intro/whatsnext>`\n+The tutorial ends here for the time being. In the meantime, you might want to\n+check out some pointers on :doc:`where to go from here </intro/whatsnext>`."
        }
    ],
    "stats": {
        "total": 646,
        "additions": 292,
        "deletions": 354
    }
}