{
    "author": "aaugustin",
    "message": "[py3] Explained @python_2_unicode_compatible usage",
    "sha": "031896c5101de83bca65e872fb4a91c15f55a42e",
    "files": [
        {
            "sha": "742731e1a7030f680c8af7f801fd01195556fb47",
            "filename": "docs/topics/python3.txt",
            "status": "modified",
            "additions": 14,
            "deletions": 2,
            "changes": 16,
            "blob_url": "https://github.com/django/django/blob/031896c5101de83bca65e872fb4a91c15f55a42e/docs%2Ftopics%2Fpython3.txt",
            "raw_url": "https://github.com/django/django/raw/031896c5101de83bca65e872fb4a91c15f55a42e/docs%2Ftopics%2Fpython3.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fpython3.txt?ref=031896c5101de83bca65e872fb4a91c15f55a42e",
            "patch": "@@ -36,8 +36,20 @@ In order to enable the same behavior in Python 2, every module must import\n     my_string = \"This is an unicode literal\"\n     my_bytestring = b\"This is a bytestring\"\n \n-If you need a byte string under Python 2 and a unicode string under Python 3,\n-use the :func:`str` builtin::\n+In classes, define ``__str__`` methods returning unicode strings and apply the\n+:func:`~django.utils.encoding.python_2_unicode_compatible` decorator. It will\n+define appropriate ``__unicode__`` and ``__str__`` in Python 2::\n+\n+    from __future__ import unicode_literals\n+    from django.utils.encoding import python_2_unicode_compatible\n+\n+    @python_2_unicode_compatible\n+    class MyClass(object):\n+        def __str__(self):\n+            return \"Instance of my class\"\n+\n+If you need a byte string literal under Python 2 and a unicode string literal\n+under Python 3, use the :func:`str` builtin::\n \n     str('my string')\n "
        }
    ],
    "stats": {
        "total": 16,
        "additions": 14,
        "deletions": 2
    }
}