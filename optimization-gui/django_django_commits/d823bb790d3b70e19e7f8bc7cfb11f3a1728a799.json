{
    "author": "timgraham",
    "message": "Fixed #17156 -- Added documentation examples for exists()\n\nThanks mrmagooey for the draft patch.",
    "sha": "d823bb790d3b70e19e7f8bc7cfb11f3a1728a799",
    "files": [
        {
            "sha": "269e2ce61c7a5fb9dc1aa7b4ad954af865123717",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 39,
            "deletions": 5,
            "changes": 44,
            "blob_url": "https://github.com/django/django/blob/d823bb790d3b70e19e7f8bc7cfb11f3a1728a799/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/d823bb790d3b70e19e7f8bc7cfb11f3a1728a799/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=d823bb790d3b70e19e7f8bc7cfb11f3a1728a799",
            "patch": "@@ -31,6 +31,9 @@ You can evaluate a ``QuerySet`` in the following ways:\n       for e in Entry.objects.all():\n           print(e.headline)\n \n+  Note: Don't use this if all you want to do is determine if at least one\n+  result exists. It's more efficient to use :meth:`~QuerySet.exists`.\n+\n * **Slicing.** As explained in :ref:`limiting-querysets`, a ``QuerySet`` can\n   be sliced, using Python's array-slicing syntax. Slicing an unevaluated\n   ``QuerySet`` usually returns another unevaluated ``QuerySet``, but Django\n@@ -75,7 +78,7 @@ You can evaluate a ``QuerySet`` in the following ways:\n \n   Note: *Don't* use this if all you want to do is determine if at least one\n   result exists, and don't need the actual objects. It's more efficient to\n-  use :meth:`exists() <QuerySet.exists>` (see below).\n+  use :meth:`~QuerySet.exists` (see below).\n \n .. _pickling QuerySets:\n \n@@ -1268,7 +1271,7 @@ The :exc:`~django.core.exceptions.DoesNotExist` exception inherits from\n         e = Entry.objects.get(id=3)\n         b = Blog.objects.get(id=1)\n     except ObjectDoesNotExist:\n-        print(\"Either the entry or blog doesn't exist.\")\n+        print \"Either the entry or blog doesn't exist.\"\n \n create\n ~~~~~~\n@@ -1523,9 +1526,40 @@ exists\n \n Returns ``True`` if the :class:`.QuerySet` contains any results, and ``False``\n if not. This tries to perform the query in the simplest and fastest way\n-possible, but it *does* execute nearly the same query. This means that calling\n-:meth:`.QuerySet.exists` is faster than ``bool(some_query_set)``, but not by\n-a large degree. If ``some_query_set`` has not yet been evaluated, but you know\n+possible, but it *does* execute nearly the same query as a normal\n+:class:`.QuerySet` query.\n+\n+:meth:`~.QuerySet.exists` is useful for searches relating to both\n+object membership in a :class:`.QuerySet` and to the existence of any objects in\n+a :class:`.QuerySet`, particularly in the context of a large :class:`.QuerySet`.\n+\n+The most efficient method of finding whether a model with a unique field\n+(e.g. ``primary_key``) is a member of a :class:`.QuerySet` is::\n+\n+    entry = Entry.objects.get(pk=123)\n+    if some_query_set.filter(pk=entry.pk).exists():\n+        print \"Entry contained in queryset\"\n+\n+Which will be faster than the following which requires evaluating and iterating\n+through the entire queryset::\n+\n+    if entry in some_query_set:\n+       print \"Entry contained in QuerySet\"\n+\n+And to find whether a queryset contains any items::\n+\n+    if some_query_set.exists():\n+        print \"There is at least one object in some_query_set\"\n+\n+Which will be faster than::\n+\n+    if some_query_set:\n+        print \"There is at least one object in some_query_set\"\n+\n+... but not by a large degree (hence needing a large queryset for efficiency\n+gains).\n+\n+Additionally, if a ``some_query_set`` has not yet been evaluated, but you know\n that it will be at some point, then using ``some_query_set.exists()`` will do\n more overall work (one query for the existence check plus an extra one to later\n retrieve the results) than simply using ``bool(some_query_set)``, which"
        }
    ],
    "stats": {
        "total": 44,
        "additions": 39,
        "deletions": 5
    }
}