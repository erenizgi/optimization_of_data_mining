{
    "author": "akaariai",
    "message": "Fixed #18375 -- Removed dict-ordering dependency for F-expressions\n\nF() expressions reuse joins like any lookup in a .filter() call -\nreuse multijoins generated in the same .filter() call else generate\nnew joins. Also, lookups can now reuse joins generated by F().\n\nThis change is backwards incompatible, but it is required to prevent\ndict randomization from generating different queries depending on\n.filter() kwarg ordering. The new way is also more consistent in how\njoins are reused.",
    "sha": "90b86291d022a09031d1df397d7aaebc30e435f7",
    "files": [
        {
            "sha": "c809e25b4963c99bb9504489219456a09f1cc22b",
            "filename": "django/db/models/sql/expressions.py",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/90b86291d022a09031d1df397d7aaebc30e435f7/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py",
            "raw_url": "https://github.com/django/django/raw/90b86291d022a09031d1df397d7aaebc30e435f7/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py?ref=90b86291d022a09031d1df397d7aaebc30e435f7",
            "patch": "@@ -1,14 +1,16 @@\n from django.core.exceptions import FieldError\n from django.db.models.constants import LOOKUP_SEP\n from django.db.models.fields import FieldDoesNotExist\n+from django.db.models.sql.constants import REUSE_ALL\n \n class SQLEvaluator(object):\n-    def __init__(self, expression, query, allow_joins=True):\n+    def __init__(self, expression, query, allow_joins=True, reuse=REUSE_ALL):\n         self.expression = expression\n         self.opts = query.get_meta()\n         self.cols = []\n \n         self.contains_aggregate = False\n+        self.reuse = reuse\n         self.expression.prepare(self, query, allow_joins)\n \n     def prepare(self):\n@@ -50,9 +52,10 @@ def prepare_leaf(self, node, query, allow_joins):\n             try:\n                 field, source, opts, join_list, last, _ = query.setup_joins(\n                     field_list, query.get_meta(),\n-                    query.get_initial_alias(), False)\n+                    query.get_initial_alias(), self.reuse)\n                 col, _, join_list = query.trim_joins(source, join_list, last, False)\n-\n+                if self.reuse is not None and self.reuse != REUSE_ALL:\n+                    self.reuse.update(join_list)\n                 self.cols.append((node, (join_list[-1], col)))\n             except FieldDoesNotExist:\n                 raise FieldError(\"Cannot resolve keyword %r into field. \""
        },
        {
            "sha": "b03465b40287f48383991db1a51529e4f9083d8a",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/90b86291d022a09031d1df397d7aaebc30e435f7/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/90b86291d022a09031d1df397d7aaebc30e435f7/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=90b86291d022a09031d1df397d7aaebc30e435f7",
            "patch": "@@ -1096,7 +1096,7 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n             value = value()\n         elif isinstance(value, ExpressionNode):\n             # If value is a query expression, evaluate it\n-            value = SQLEvaluator(value, self)\n+            value = SQLEvaluator(value, self, reuse=can_reuse)\n             having_clause = value.contains_aggregate\n \n         for alias, aggregate in self.aggregates.items():"
        },
        {
            "sha": "ca6b3acfd9049d3cbacae080157768f13a74fc85",
            "filename": "docs/releases/1.5.txt",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/90b86291d022a09031d1df397d7aaebc30e435f7/docs%2Freleases%2F1.5.txt",
            "raw_url": "https://github.com/django/django/raw/90b86291d022a09031d1df397d7aaebc30e435f7/docs%2Freleases%2F1.5.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.5.txt?ref=90b86291d022a09031d1df397d7aaebc30e435f7",
            "patch": "@@ -589,6 +589,12 @@ Miscellaneous\n   :ref:`Q() expressions <complex-lookups-with-q>` and ``QuerySet`` combining where\n   the operators are used as boolean AND and OR operators.\n \n+* In a ``filter()`` call, when :ref:`F() expressions <query-expressions>`\n+  contained lookups spanning multi-valued relations, they didn't always reuse\n+  the same relations as other lookups along the same chain. This was changed,\n+  and now F() expressions will always use the same relations as other lookups\n+  within the same ``filter()`` call.\n+\n * The :ttag:`csrf_token` template tag is no longer enclosed in a div. If you need\n   HTML validation against pre-HTML5 Strict DTDs, you should add a div around it\n   in your pages."
        },
        {
            "sha": "ca47521ccd231895ce4bab60921bbbc0fc6579d1",
            "filename": "tests/modeltests/expressions/tests.py",
            "status": "modified",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/django/django/blob/90b86291d022a09031d1df397d7aaebc30e435f7/tests%2Fmodeltests%2Fexpressions%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/90b86291d022a09031d1df397d7aaebc30e435f7/tests%2Fmodeltests%2Fexpressions%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fexpressions%2Ftests.py?ref=90b86291d022a09031d1df397d7aaebc30e435f7",
            "patch": "@@ -219,3 +219,42 @@ def test():\n         )\n         acme.num_employees = F(\"num_employees\") + 16\n         self.assertRaises(TypeError, acme.save)\n+\n+    def test_ticket_18375_join_reuse(self):\n+        # Test that reverse multijoin F() references and the lookup target\n+        # the same join. Pre #18375 the F() join was generated first, and the\n+        # lookup couldn't reuse that join.\n+        qs = Employee.objects.filter(\n+            company_ceo_set__num_chairs=F('company_ceo_set__num_employees'))\n+        self.assertEqual(str(qs.query).count('JOIN'), 1)\n+\n+    def test_ticket_18375_kwarg_ordering(self):\n+        # The next query was dict-randomization dependent - if the \"gte=1\"\n+        # was seen first, then the F() will reuse the join generated by the\n+        # gte lookup, if F() was seen first, then it generated a join the\n+        # other lookups could not reuse.\n+        qs = Employee.objects.filter(\n+            company_ceo_set__num_chairs=F('company_ceo_set__num_employees'),\n+            company_ceo_set__num_chairs__gte=1)\n+        self.assertEqual(str(qs.query).count('JOIN'), 1)\n+\n+    def test_ticket_18375_kwarg_ordering_2(self):\n+        # Another similar case for F() than above. Now we have the same join\n+        # in two filter kwargs, one in the lhs lookup, one in F. Here pre\n+        # #18375 the amount of joins generated was random if dict\n+        # randomization was enabled, that is the generated query dependend\n+        # on which clause was seen first.\n+        qs = Employee.objects.filter(\n+            company_ceo_set__num_employees=F('pk'),\n+            pk=F('company_ceo_set__num_employees')\n+        )\n+        self.assertEqual(str(qs.query).count('JOIN'), 1)\n+\n+    def test_ticket_18375_chained_filters(self):\n+        # Test that F() expressions do not reuse joins from previous filter.\n+        qs = Employee.objects.filter(\n+            company_ceo_set__num_employees=F('pk')\n+        ).filter(\n+            company_ceo_set__num_employees=F('company_ceo_set__num_employees')\n+        )\n+        self.assertEqual(str(qs.query).count('JOIN'), 2)"
        }
    ],
    "stats": {
        "total": 56,
        "additions": 52,
        "deletions": 4
    }
}