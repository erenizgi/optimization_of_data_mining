{
    "author": "claudep",
    "message": "Fixed #10200 -- Raised CommandError when errors happen in loaddata.",
    "sha": "6fd1950a4e29c1b5ed071a880db64103715ead51",
    "files": [
        {
            "sha": "078fd6fa27a2c7f2309240c709ab9f56b53863c3",
            "filename": "django/core/management/commands/loaddata.py",
            "status": "modified",
            "additions": 12,
            "deletions": 31,
            "changes": 43,
            "blob_url": "https://github.com/django/django/blob/6fd1950a4e29c1b5ed071a880db64103715ead51/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py",
            "raw_url": "https://github.com/django/django/raw/6fd1950a4e29c1b5ed071a880db64103715ead51/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py?ref=6fd1950a4e29c1b5ed071a880db64103715ead51",
            "patch": "@@ -7,7 +7,7 @@\n \n from django.conf import settings\n from django.core import serializers\n-from django.core.management.base import BaseCommand\n+from django.core.management.base import BaseCommand, CommandError\n from django.core.management.color import no_style\n from django.db import (connections, router, transaction, DEFAULT_DB_ALIAS,\n       IntegrityError, DatabaseError)\n@@ -36,11 +36,10 @@ def handle(self, *fixture_labels, **options):\n         connection = connections[using]\n \n         if not len(fixture_labels):\n-            self.stderr.write(\n+            raise CommandError(\n                 \"No database fixture specified. Please provide the path of at \"\n                 \"least one fixture in the command line.\"\n             )\n-            return\n \n         verbosity = int(options.get('verbosity'))\n         show_traceback = options.get('traceback')\n@@ -126,13 +125,9 @@ def read(self):\n                         if verbosity >= 2:\n                             self.stdout.write(\"Loading '%s' fixtures...\" % fixture_name)\n                     else:\n-                        self.stderr.write(\n+                        raise CommandError(\n                             \"Problem installing fixture '%s': %s is not a known serialization format.\" %\n                                 (fixture_name, format))\n-                        if commit:\n-                            transaction.rollback(using=using)\n-                            transaction.leave_transaction_management(using=using)\n-                        return\n \n                     if os.path.isabs(fixture_name):\n                         fixture_dirs = [fixture_name]\n@@ -167,12 +162,8 @@ def read(self):\n                             else:\n                                 try:\n                                     if label_found:\n-                                        self.stderr.write(\"Multiple fixtures named '%s' in %s. Aborting.\" %\n+                                        raise CommandError(\"Multiple fixtures named '%s' in %s. Aborting.\" %\n                                             (fixture_name, humanize(fixture_dir)))\n-                                        if commit:\n-                                            transaction.rollback(using=using)\n-                                            transaction.leave_transaction_management(using=using)\n-                                        return\n \n                                     fixture_count += 1\n                                     objects_in_fixture = 0\n@@ -191,13 +182,13 @@ def read(self):\n                                             try:\n                                                 obj.save(using=using)\n                                             except (DatabaseError, IntegrityError) as e:\n-                                                msg = \"Could not load %(app_label)s.%(object_name)s(pk=%(pk)s): %(error_msg)s\" % {\n+                                                e.args = (\"Could not load %(app_label)s.%(object_name)s(pk=%(pk)s): %(error_msg)s\" % {\n                                                         'app_label': obj.object._meta.app_label,\n                                                         'object_name': obj.object._meta.object_name,\n                                                         'pk': obj.object.pk,\n                                                         'error_msg': e\n-                                                    }\n-                                                raise e.__class__, e.__class__(msg), sys.exc_info()[2]\n+                                                    },)\n+                                                raise\n \n                                     loaded_object_count += loaded_objects_in_fixture\n                                     fixture_object_count += objects_in_fixture\n@@ -208,13 +199,9 @@ def read(self):\n                                 # If the fixture we loaded contains 0 objects, assume that an\n                                 # error was encountered during fixture loading.\n                                 if objects_in_fixture == 0:\n-                                    self.stderr.write(\n+                                    raise CommandError(\n                                         \"No fixture data found for '%s'. (File format may be invalid.)\" %\n                                             (fixture_name))\n-                                    if commit:\n-                                        transaction.rollback(using=using)\n-                                        transaction.leave_transaction_management(using=using)\n-                                    return\n \n             # Since we disabled constraint checks, we must manually check for\n             # any invalid keys that might have been added\n@@ -223,19 +210,13 @@ def read(self):\n \n         except (SystemExit, KeyboardInterrupt):\n             raise\n-        except Exception:\n+        except Exception as e:\n             if commit:\n                 transaction.rollback(using=using)\n                 transaction.leave_transaction_management(using=using)\n-            if show_traceback:\n-                traceback.print_exc()\n-            else:\n-                self.stderr.write(\n-                    \"Problem installing fixture '%s': %s\" %\n-                         (full_path, ''.join(traceback.format_exception(sys.exc_type,\n-                             sys.exc_value, sys.exc_traceback))))\n-            return\n-\n+            if not isinstance(e, CommandError):\n+                e.args = (\"Problem installing fixture '%s': %s\" % (full_path, e),)\n+            raise\n \n         # If we found even one object in a fixture, we need to reset the\n         # database sequences."
        },
        {
            "sha": "f5176dab0cc8fcb4acedb1b3d25e041ac9c9397c",
            "filename": "tests/modeltests/fixtures/tests.py",
            "status": "modified",
            "additions": 10,
            "deletions": 15,
            "changes": 25,
            "blob_url": "https://github.com/django/django/blob/6fd1950a4e29c1b5ed071a880db64103715ead51/tests%2Fmodeltests%2Ffixtures%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/6fd1950a4e29c1b5ed071a880db64103715ead51/tests%2Fmodeltests%2Ffixtures%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Ffixtures%2Ftests.py?ref=6fd1950a4e29c1b5ed071a880db64103715ead51",
            "patch": "@@ -4,7 +4,7 @@\n \n from django.contrib.sites.models import Site\n from django.core import management\n-from django.db import connection\n+from django.db import connection, IntegrityError\n from django.test import TestCase, TransactionTestCase, skipUnlessDBFeature\n \n from .models import Article, Book, Spy, Tag, Visa\n@@ -232,11 +232,9 @@ def test_compressed_loading(self):\n \n     def test_ambiguous_compressed_fixture(self):\n         # The name \"fixture5\" is ambigous, so loading it will raise an error\n-        new_io = StringIO.StringIO()\n-        management.call_command('loaddata', 'fixture5', verbosity=0, stderr=new_io, commit=False)\n-        output = new_io.getvalue().strip().split('\\n')\n-        self.assertEqual(len(output), 1)\n-        self.assertTrue(output[0].startswith(\"Multiple fixtures named 'fixture5'\"))\n+        with self.assertRaisesRegexp(management.CommandError,\n+                \"Multiple fixtures named 'fixture5'\"):\n+            management.call_command('loaddata', 'fixture5', verbosity=0, commit=False)\n \n     def test_db_loading(self):\n         # Load db fixtures 1 and 2. These will load using the 'default' database identifier implicitly\n@@ -258,10 +256,9 @@ def test_loaddata_error_message(self):\n         # is closed at the end of each test.\n         if connection.vendor == 'mysql':\n             connection.cursor().execute(\"SET sql_mode = 'TRADITIONAL'\")\n-        new_io = StringIO.StringIO()\n-        management.call_command('loaddata', 'invalid.json', verbosity=0, stderr=new_io, commit=False)\n-        output = new_io.getvalue().strip().split('\\n')\n-        self.assertRegexpMatches(output[-1], \"Error: Could not load fixtures.Article\\(pk=1\\): .*$\")\n+        with self.assertRaisesRegexp(IntegrityError,\n+                \"Could not load fixtures.Article\\(pk=1\\): .*$\"):\n+            management.call_command('loaddata', 'invalid.json', verbosity=0, commit=False)\n \n     def test_loading_using(self):\n         # Load db fixtures 1 and 2. These will load using the 'default' database identifier explicitly\n@@ -316,11 +313,9 @@ def test_format_discovery(self):\n \n         # Try to load fixture 2 using format discovery; this will fail\n         # because there are two fixture2's in the fixtures directory\n-        new_io = StringIO.StringIO()\n-        management.call_command('loaddata', 'fixture2', verbosity=0, stderr=new_io)\n-        output = new_io.getvalue().strip().split('\\n')\n-        self.assertEqual(len(output), 1)\n-        self.assertTrue(output[0].startswith(\"Multiple fixtures named 'fixture2'\"))\n+        with self.assertRaisesRegexp(management.CommandError,\n+                \"Multiple fixtures named 'fixture2'\"):\n+            management.call_command('loaddata', 'fixture2', verbosity=0)\n \n         # object list is unaffected\n         self.assertQuerysetEqual(Article.objects.all(), ["
        },
        {
            "sha": "c0b811bea2584f7bc713e8c2d1adb7f8d540b165",
            "filename": "tests/regressiontests/fixtures_regress/tests.py",
            "status": "modified",
            "additions": 59,
            "deletions": 83,
            "changes": 142,
            "blob_url": "https://github.com/django/django/blob/6fd1950a4e29c1b5ed071a880db64103715ead51/tests%2Fregressiontests%2Ffixtures_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/6fd1950a4e29c1b5ed071a880db64103715ead51/tests%2Fregressiontests%2Ffixtures_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ffixtures_regress%2Ftests.py?ref=6fd1950a4e29c1b5ed071a880db64103715ead51",
            "patch": "@@ -9,7 +9,7 @@\n from django.core import management\n from django.core.management.base import CommandError\n from django.core.management.commands.dumpdata import sort_dependencies\n-from django.db import transaction\n+from django.db import transaction, IntegrityError\n from django.db.models import signals\n from django.test import (TestCase, TransactionTestCase, skipIfDBFeature,\n     skipUnlessDBFeature)\n@@ -116,92 +116,73 @@ def test_unknown_format(self):\n         Test for ticket #4371 -- Loading data of an unknown format should fail\n         Validate that error conditions are caught correctly\n         \"\"\"\n-        stderr = BytesIO()\n-        management.call_command(\n-            'loaddata',\n-            'bad_fixture1.unkn',\n-            verbosity=0,\n-            commit=False,\n-            stderr=stderr,\n-        )\n-        self.assertEqual(\n-            stderr.getvalue(),\n-            \"Problem installing fixture 'bad_fixture1': unkn is not a known serialization format.\\n\"\n-        )\n+        with self.assertRaisesRegexp(management.CommandError,\n+                \"Problem installing fixture 'bad_fixture1': \"\n+                \"unkn is not a known serialization format.\"):\n+            management.call_command(\n+                'loaddata',\n+                'bad_fixture1.unkn',\n+                verbosity=0,\n+                commit=False,\n+            )\n \n     def test_invalid_data(self):\n         \"\"\"\n         Test for ticket #4371 -- Loading a fixture file with invalid data\n         using explicit filename.\n         Validate that error conditions are caught correctly\n         \"\"\"\n-        stderr = BytesIO()\n-        management.call_command(\n-            'loaddata',\n-            'bad_fixture2.xml',\n-            verbosity=0,\n-            commit=False,\n-            stderr=stderr,\n-        )\n-        self.assertEqual(\n-            stderr.getvalue(),\n-            \"No fixture data found for 'bad_fixture2'. (File format may be invalid.)\\n\"\n-        )\n+        with self.assertRaisesRegexp(management.CommandError,\n+                \"No fixture data found for 'bad_fixture2'. \\(File format may be invalid.\\)\"):\n+            management.call_command(\n+                'loaddata',\n+                'bad_fixture2.xml',\n+                verbosity=0,\n+                commit=False,\n+            )\n \n     def test_invalid_data_no_ext(self):\n         \"\"\"\n         Test for ticket #4371 -- Loading a fixture file with invalid data\n         without file extension.\n         Validate that error conditions are caught correctly\n         \"\"\"\n-        stderr = BytesIO()\n-        management.call_command(\n-            'loaddata',\n-            'bad_fixture2',\n-            verbosity=0,\n-            commit=False,\n-            stderr=stderr,\n-        )\n-        self.assertEqual(\n-            stderr.getvalue(),\n-            \"No fixture data found for 'bad_fixture2'. (File format may be invalid.)\\n\"\n-        )\n+        with self.assertRaisesRegexp(management.CommandError,\n+                \"No fixture data found for 'bad_fixture2'. \\(File format may be invalid.\\)\"):\n+            management.call_command(\n+                'loaddata',\n+                'bad_fixture2',\n+                verbosity=0,\n+                commit=False,\n+            )\n \n     def test_empty(self):\n         \"\"\"\n         Test for ticket #4371 -- Loading a fixture file with no data returns an error.\n         Validate that error conditions are caught correctly\n         \"\"\"\n-        stderr = BytesIO()\n-        management.call_command(\n-            'loaddata',\n-            'empty',\n-            verbosity=0,\n-            commit=False,\n-            stderr=stderr,\n-        )\n-        self.assertEqual(\n-            stderr.getvalue(),\n-            \"No fixture data found for 'empty'. (File format may be invalid.)\\n\"\n-        )\n+        with self.assertRaisesRegexp(management.CommandError,\n+                \"No fixture data found for 'empty'. \\(File format may be invalid.\\)\"):\n+            management.call_command(\n+                'loaddata',\n+                'empty',\n+                verbosity=0,\n+                commit=False,\n+            )\n \n     def test_error_message(self):\n         \"\"\"\n         (Regression for #9011 - error message is correct)\n         \"\"\"\n-        stderr = BytesIO()\n-        management.call_command(\n-            'loaddata',\n-            'bad_fixture2',\n-            'animal',\n-            verbosity=0,\n-            commit=False,\n-            stderr=stderr,\n-        )\n-        self.assertEqual(\n-            stderr.getvalue(),\n-            \"No fixture data found for 'bad_fixture2'. (File format may be invalid.)\\n\"\n-        )\n+        with self.assertRaisesRegexp(management.CommandError,\n+                \"^No fixture data found for 'bad_fixture2'. \\(File format may be invalid.\\)$\"):\n+            management.call_command(\n+                'loaddata',\n+                'bad_fixture2',\n+                'animal',\n+                verbosity=0,\n+                commit=False,\n+            )\n \n     def test_pg_sequence_resetting_checks(self):\n         \"\"\"\n@@ -357,17 +338,14 @@ def test_loaddata_raises_error_when_fixture_has_invalid_foreign_key(self):\n         \"\"\"\n         Regression for #3615 - Ensure data with nonexistent child key references raises error\n         \"\"\"\n-        stderr = BytesIO()\n-        management.call_command(\n-            'loaddata',\n-            'forward_ref_bad_data.json',\n-            verbosity=0,\n-            commit=False,\n-            stderr=stderr,\n-        )\n-        self.assertTrue(\n-            stderr.getvalue().startswith('Problem installing fixture')\n-        )\n+        with self.assertRaisesRegexp(IntegrityError,\n+                \"Problem installing fixture\"):\n+            management.call_command(\n+                'loaddata',\n+                'forward_ref_bad_data.json',\n+                verbosity=0,\n+                commit=False,\n+            )\n \n     _cur_dir = os.path.dirname(os.path.abspath(__file__))\n \n@@ -392,16 +370,14 @@ def test_loaddata_no_fixture_specified(self):\n         \"\"\"\n         Regression for #7043 - Error is quickly reported when no fixtures is provided in the command line.\n         \"\"\"\n-        stderr = BytesIO()\n-        management.call_command(\n-            'loaddata',\n-            verbosity=0,\n-            commit=False,\n-            stderr=stderr,\n-        )\n-        self.assertEqual(\n-            stderr.getvalue(), 'No database fixture specified. Please provide the path of at least one fixture in the command line.\\n'\n-        )\n+        with self.assertRaisesRegexp(management.CommandError,\n+                \"No database fixture specified. Please provide the path of \"\n+                \"at least one fixture in the command line.\"):\n+            management.call_command(\n+                'loaddata',\n+                verbosity=0,\n+                commit=False,\n+            )\n \n     def test_loaddata_not_existant_fixture_file(self):\n         stdout_output = BytesIO()"
        }
    ],
    "stats": {
        "total": 210,
        "additions": 81,
        "deletions": 129
    }
}