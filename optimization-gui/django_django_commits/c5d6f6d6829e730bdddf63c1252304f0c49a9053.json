{
    "author": "claudep",
    "message": "Reorganized geoapp gis tests\n\nRemoved the numbering of tests and moved lookup/geoqueryset tests\nin their own test class.",
    "sha": "c5d6f6d6829e730bdddf63c1252304f0c49a9053",
    "files": [
        {
            "sha": "fffd7d3cab3bf063c54787c0ab4ce72d3a82facb",
            "filename": "django/contrib/gis/tests/geoapp/test_regress.py",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/c5d6f6d6829e730bdddf63c1252304f0c49a9053/django%2Fcontrib%2Fgis%2Ftests%2Fgeoapp%2Ftest_regress.py",
            "raw_url": "https://github.com/django/django/raw/c5d6f6d6829e730bdddf63c1252304f0c49a9053/django%2Fcontrib%2Fgis%2Ftests%2Fgeoapp%2Ftest_regress.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Ftests%2Fgeoapp%2Ftest_regress.py?ref=c5d6f6d6829e730bdddf63c1252304f0c49a9053",
            "patch": "@@ -12,7 +12,7 @@\n \n class GeoRegressionTests(TestCase):\n \n-    def test01_update(self):\n+    def test_update(self):\n         \"Testing GeoQuerySet.update(). See #10411.\"\n         pnt = City.objects.get(name='Pueblo').point\n         bak = pnt.clone()\n@@ -24,7 +24,7 @@ def test01_update(self):\n         City.objects.filter(name='Pueblo').update(point=bak)\n         self.assertEqual(bak, City.objects.get(name='Pueblo').point)\n \n-    def test02_kmz(self):\n+    def test_kmz(self):\n         \"Testing `render_to_kmz` with non-ASCII data. See #11624.\"\n         name = '\\xc3\\x85land Islands'.decode('iso-8859-1')\n         places = [{'name' : name,\n@@ -35,22 +35,22 @@ def test02_kmz(self):\n \n     @no_spatialite\n     @no_mysql\n-    def test03_extent(self):\n+    def test_extent(self):\n         \"Testing `extent` on a table with a single point. See #11827.\"\n         pnt = City.objects.get(name='Pueblo').point\n         ref_ext = (pnt.x, pnt.y, pnt.x, pnt.y)\n         extent = City.objects.filter(name='Pueblo').extent()\n         for ref_val, val in zip(ref_ext, extent):\n             self.assertAlmostEqual(ref_val, val, 4)\n \n-    def test04_unicode_date(self):\n+    def test_unicode_date(self):\n         \"Testing dates are converted properly, even on SpatiaLite. See #16408.\"\n         founded = datetime(1857, 5, 23)\n         mansfield = PennsylvaniaCity.objects.create(name='Mansfield', county='Tioga', point='POINT(-77.071445 41.823881)',\n                                                     founded=founded)\n         self.assertEqual(founded, PennsylvaniaCity.objects.dates('founded', 'day')[0])\n \n-    def test05_empty_count(self):\n+    def test_empty_count(self):\n          \"Testing that PostGISAdapter.__eq__ does check empty strings. See #13670.\"\n          # contrived example, but need a geo lookup paired with an id__in lookup\n          pueblo = City.objects.get(name='Pueblo')\n@@ -60,12 +60,12 @@ def test05_empty_count(self):\n          # .count() should not throw TypeError in __eq__\n          self.assertEqual(cities_within_state.count(), 1)\n \n-    def test06_defer_or_only_with_annotate(self):\n+    def test_defer_or_only_with_annotate(self):\n         \"Regression for #16409. Make sure defer() and only() work with annotate()\"\n         self.assertIsInstance(list(City.objects.annotate(Count('point')).defer('name')), list)\n         self.assertIsInstance(list(City.objects.annotate(Count('point')).only('name')), list)\n \n-    def test07_boolean_conversion(self):\n+    def test_boolean_conversion(self):\n         \"Testing Boolean value conversion with the spatial backend, see #15169.\"\n         t1 = Truth.objects.create(val=True)\n         t2 = Truth.objects.create(val=False)"
        },
        {
            "sha": "b06d6b5e1bb91098c5f9b1bd94bdf3eae5c490db",
            "filename": "django/contrib/gis/tests/geoapp/tests.py",
            "status": "modified",
            "additions": 404,
            "deletions": 397,
            "changes": 801,
            "blob_url": "https://github.com/django/django/blob/c5d6f6d6829e730bdddf63c1252304f0c49a9053/django%2Fcontrib%2Fgis%2Ftests%2Fgeoapp%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/c5d6f6d6829e730bdddf63c1252304f0c49a9053/django%2Fcontrib%2Fgis%2Ftests%2Fgeoapp%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Ftests%2Fgeoapp%2Ftests.py?ref=c5d6f6d6829e730bdddf63c1252304f0c49a9053",
            "patch": "@@ -15,19 +15,24 @@\n \n from .models import Country, City, PennsylvaniaCity, State, Track\n \n+from .test_feeds import GeoFeedTest\n+from .test_regress import GeoRegressionTests\n+from .test_sitemaps import GeoSitemapTest\n+\n+\n if not spatialite:\n     from .models import Feature, MinusOneSRID\n \n class GeoModelTest(TestCase):\n \n-    def test01_fixtures(self):\n+    def test_fixtures(self):\n         \"Testing geographic model initialization from fixtures.\"\n         # Ensuring that data was loaded from initial data fixtures.\n         self.assertEqual(2, Country.objects.count())\n         self.assertEqual(8, City.objects.count())\n         self.assertEqual(2, State.objects.count())\n \n-    def test02_proxy(self):\n+    def test_proxy(self):\n         \"Testing Lazy-Geometry support (using the GeometryProxy).\"\n         ## Testing on a Point\n         pnt = Point(0, 0)\n@@ -95,165 +100,97 @@ def test02_proxy(self):\n         self.assertEqual(ply, State.objects.get(name='NullState').poly)\n         ns.delete()\n \n-    def test03a_kml(self):\n-        \"Testing KML output from the database using GeoQuerySet.kml().\"\n-        # Only PostGIS and Spatialite (>=2.4.0-RC4) support KML serialization\n-        if not (postgis or (spatialite and connection.ops.kml)):\n-            self.assertRaises(NotImplementedError, State.objects.all().kml, field_name='poly')\n-            return\n-\n-        # Should throw a TypeError when trying to obtain KML from a\n-        #  non-geometry field.\n-        qs = City.objects.all()\n-        self.assertRaises(TypeError, qs.kml, 'name')\n-\n-        # The reference KML depends on the version of PostGIS used\n-        # (the output stopped including altitude in 1.3.3).\n-        if connection.ops.spatial_version >= (1, 3, 3):\n-            ref_kml =  '<Point><coordinates>-104.609252,38.255001</coordinates></Point>'\n-        else:\n-            ref_kml = '<Point><coordinates>-104.609252,38.255001,0</coordinates></Point>'\n-\n-        # Ensuring the KML is as expected.\n-        ptown1 = City.objects.kml(field_name='point', precision=9).get(name='Pueblo')\n-        ptown2 = City.objects.kml(precision=9).get(name='Pueblo')\n-        for ptown in [ptown1, ptown2]:\n-            self.assertEqual(ref_kml, ptown.kml)\n-\n-    def test03b_gml(self):\n-        \"Testing GML output from the database using GeoQuerySet.gml().\"\n-        if mysql or (spatialite and not connection.ops.gml) :\n-            self.assertRaises(NotImplementedError, Country.objects.all().gml, field_name='mpoly')\n-            return\n-\n-        # Should throw a TypeError when tyring to obtain GML from a\n-        # non-geometry field.\n-        qs = City.objects.all()\n-        self.assertRaises(TypeError, qs.gml, field_name='name')\n-        ptown1 = City.objects.gml(field_name='point', precision=9).get(name='Pueblo')\n-        ptown2 = City.objects.gml(precision=9).get(name='Pueblo')\n+    @no_mysql\n+    def test_lookup_insert_transform(self):\n+        \"Testing automatic transform for lookups and inserts.\"\n+        # San Antonio in 'WGS84' (SRID 4326)\n+        sa_4326 = 'POINT (-98.493183 29.424170)'\n+        wgs_pnt = fromstr(sa_4326, srid=4326) # Our reference point in WGS84\n \n+        # Oracle doesn't have SRID 3084, using 41157.\n         if oracle:\n-            # No precision parameter for Oracle :-/\n-            gml_regex = re.compile(r'^<gml:Point srsName=\"SDO:4326\" xmlns:gml=\"http://www.opengis.net/gml\"><gml:coordinates decimal=\"\\.\" cs=\",\" ts=\" \">-104.60925\\d+,38.25500\\d+ </gml:coordinates></gml:Point>')\n-        elif spatialite:\n-            # Spatialite has extra colon in SrsName\n-            gml_regex = re.compile(r'^<gml:Point SrsName=\"EPSG::4326\"><gml:coordinates decimal=\"\\.\" cs=\",\" ts=\" \">-104.609251\\d+,38.255001</gml:coordinates></gml:Point>')\n+            # San Antonio in 'Texas 4205, Southern Zone (1983, meters)' (SRID 41157)\n+            # Used the following Oracle SQL to get this value:\n+            #  SELECT SDO_UTIL.TO_WKTGEOMETRY(SDO_CS.TRANSFORM(SDO_GEOMETRY('POINT (-98.493183 29.424170)', 4326), 41157)) FROM DUAL;\n+            nad_wkt  = 'POINT (300662.034646583 5416427.45974934)'\n+            nad_srid = 41157\n         else:\n-            gml_regex = re.compile(r'^<gml:Point srsName=\"EPSG:4326\"><gml:coordinates>-104\\.60925\\d+,38\\.255001</gml:coordinates></gml:Point>')\n-\n-        for ptown in [ptown1, ptown2]:\n-            self.assertTrue(gml_regex.match(ptown.gml))\n-\n-\n-    def test03c_geojson(self):\n-        \"Testing GeoJSON output from the database using GeoQuerySet.geojson().\"\n-        # Only PostGIS 1.3.4+ supports GeoJSON.\n-        if not connection.ops.geojson:\n-            self.assertRaises(NotImplementedError, Country.objects.all().geojson, field_name='mpoly')\n-            return\n+            # San Antonio in 'NAD83(HARN) / Texas Centric Lambert Conformal' (SRID 3084)\n+            nad_wkt = 'POINT (1645978.362408288754523 6276356.025927528738976)' # Used ogr.py in gdal 1.4.1 for this transform\n+            nad_srid = 3084\n \n-        if connection.ops.spatial_version >= (1, 4, 0):\n-            pueblo_json = '{\"type\":\"Point\",\"coordinates\":[-104.609252,38.255001]}'\n-            houston_json = '{\"type\":\"Point\",\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"EPSG:4326\"}},\"coordinates\":[-95.363151,29.763374]}'\n-            victoria_json = '{\"type\":\"Point\",\"bbox\":[-123.30519600,48.46261100,-123.30519600,48.46261100],\"coordinates\":[-123.305196,48.462611]}'\n-            chicago_json = '{\"type\":\"Point\",\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"EPSG:4326\"}},\"bbox\":[-87.65018,41.85039,-87.65018,41.85039],\"coordinates\":[-87.65018,41.85039]}'\n+        # Constructing & querying with a point from a different SRID. Oracle\n+        # `SDO_OVERLAPBDYINTERSECT` operates differently from\n+        # `ST_Intersects`, so contains is used instead.\n+        nad_pnt = fromstr(nad_wkt, srid=nad_srid)\n+        if oracle:\n+            tx = Country.objects.get(mpoly__contains=nad_pnt)\n         else:\n-            pueblo_json = '{\"type\":\"Point\",\"coordinates\":[-104.60925200,38.25500100]}'\n-            houston_json = '{\"type\":\"Point\",\"crs\":{\"type\":\"EPSG\",\"properties\":{\"EPSG\":4326}},\"coordinates\":[-95.36315100,29.76337400]}'\n-            victoria_json = '{\"type\":\"Point\",\"bbox\":[-123.30519600,48.46261100,-123.30519600,48.46261100],\"coordinates\":[-123.30519600,48.46261100]}'\n-            chicago_json = '{\"type\":\"Point\",\"crs\":{\"type\":\"EPSG\",\"properties\":{\"EPSG\":4326}},\"bbox\":[-87.65018,41.85039,-87.65018,41.85039],\"coordinates\":[-87.65018,41.85039]}'\n+            tx = Country.objects.get(mpoly__intersects=nad_pnt)\n+        self.assertEqual('Texas', tx.name)\n \n-        # Precision argument should only be an integer\n-        self.assertRaises(TypeError, City.objects.geojson, precision='foo')\n+        # Creating San Antonio.  Remember the Alamo.\n+        sa = City.objects.create(name='San Antonio', point=nad_pnt)\n \n-        # Reference queries and values.\n-        # SELECT ST_AsGeoJson(\"geoapp_city\".\"point\", 8, 0) FROM \"geoapp_city\" WHERE \"geoapp_city\".\"name\" = 'Pueblo';\n-        self.assertEqual(pueblo_json, City.objects.geojson().get(name='Pueblo').geojson)\n+        # Now verifying that San Antonio was transformed correctly\n+        sa = City.objects.get(name='San Antonio')\n+        self.assertAlmostEqual(wgs_pnt.x, sa.point.x, 6)\n+        self.assertAlmostEqual(wgs_pnt.y, sa.point.y, 6)\n \n-        # 1.3.x: SELECT ST_AsGeoJson(\"geoapp_city\".\"point\", 8, 1) FROM \"geoapp_city\" WHERE \"geoapp_city\".\"name\" = 'Houston';\n-        # 1.4.x: SELECT ST_AsGeoJson(\"geoapp_city\".\"point\", 8, 2) FROM \"geoapp_city\" WHERE \"geoapp_city\".\"name\" = 'Houston';\n-        # This time we want to include the CRS by using the `crs` keyword.\n-        self.assertEqual(houston_json, City.objects.geojson(crs=True, model_att='json').get(name='Houston').json)\n+        # If the GeometryField SRID is -1, then we shouldn't perform any\n+        # transformation if the SRID of the input geometry is different.\n+        # SpatiaLite does not support missing SRID values.\n+        if not spatialite:\n+            m1 = MinusOneSRID(geom=Point(17, 23, srid=4326))\n+            m1.save()\n+            self.assertEqual(-1, m1.geom.srid)\n \n-        # 1.3.x: SELECT ST_AsGeoJson(\"geoapp_city\".\"point\", 8, 2) FROM \"geoapp_city\" WHERE \"geoapp_city\".\"name\" = 'Victoria';\n-        # 1.4.x: SELECT ST_AsGeoJson(\"geoapp_city\".\"point\", 8, 1) FROM \"geoapp_city\" WHERE \"geoapp_city\".\"name\" = 'Houston';\n-        # This time we include the bounding box by using the `bbox` keyword.\n-        self.assertEqual(victoria_json, City.objects.geojson(bbox=True).get(name='Victoria').geojson)\n+    def test_createnull(self):\n+        \"Testing creating a model instance and the geometry being None\"\n+        c = City()\n+        self.assertEqual(c.point, None)\n \n-        # 1.(3|4).x: SELECT ST_AsGeoJson(\"geoapp_city\".\"point\", 5, 3) FROM \"geoapp_city\" WHERE \"geoapp_city\".\"name\" = 'Chicago';\n-        # Finally, we set every available keyword.\n-        self.assertEqual(chicago_json, City.objects.geojson(bbox=True, crs=True, precision=5).get(name='Chicago').geojson)\n+    @no_spatialite # SpatiaLite does not support abstract geometry columns\n+    def test_geometryfield(self):\n+        \"Testing the general GeometryField.\"\n+        Feature(name='Point', geom=Point(1, 1)).save()\n+        Feature(name='LineString', geom=LineString((0, 0), (1, 1), (5, 5))).save()\n+        Feature(name='Polygon', geom=Polygon(LinearRing((0, 0), (0, 5), (5, 5), (5, 0), (0, 0)))).save()\n+        Feature(name='GeometryCollection',\n+                geom=GeometryCollection(Point(2, 2), LineString((0, 0), (2, 2)),\n+                                        Polygon(LinearRing((0, 0), (0, 5), (5, 5), (5, 0), (0, 0))))).save()\n \n-    def test03d_svg(self):\n-        \"Testing SVG output using GeoQuerySet.svg().\"\n-        if mysql or oracle:\n-            self.assertRaises(NotImplementedError, City.objects.svg)\n-            return\n+        f_1 = Feature.objects.get(name='Point')\n+        self.assertEqual(True, isinstance(f_1.geom, Point))\n+        self.assertEqual((1.0, 1.0), f_1.geom.tuple)\n+        f_2 = Feature.objects.get(name='LineString')\n+        self.assertEqual(True, isinstance(f_2.geom, LineString))\n+        self.assertEqual(((0.0, 0.0), (1.0, 1.0), (5.0, 5.0)), f_2.geom.tuple)\n \n-        self.assertRaises(TypeError, City.objects.svg, precision='foo')\n-        # SELECT AsSVG(geoapp_city.point, 0, 8) FROM geoapp_city WHERE name = 'Pueblo';\n-        svg1 = 'cx=\"-104.609252\" cy=\"-38.255001\"'\n-        # Even though relative, only one point so it's practically the same except for\n-        # the 'c' letter prefix on the x,y values.\n-        svg2 = svg1.replace('c', '')\n-        self.assertEqual(svg1, City.objects.svg().get(name='Pueblo').svg)\n-        self.assertEqual(svg2, City.objects.svg(relative=5).get(name='Pueblo').svg)\n+        f_3 = Feature.objects.get(name='Polygon')\n+        self.assertEqual(True, isinstance(f_3.geom, Polygon))\n+        f_4 = Feature.objects.get(name='GeometryCollection')\n+        self.assertEqual(True, isinstance(f_4.geom, GeometryCollection))\n+        self.assertEqual(f_3.geom, f_4.geom[2])\n \n     @no_mysql\n-    def test04_transform(self):\n-        \"Testing the transform() GeoManager method.\"\n-        # Pre-transformed points for Houston and Pueblo.\n-        htown = fromstr('POINT(1947516.83115183 6322297.06040572)', srid=3084)\n-        ptown = fromstr('POINT(992363.390841912 481455.395105533)', srid=2774)\n-        prec = 3 # Precision is low due to version variations in PROJ and GDAL.\n-\n-        # Asserting the result of the transform operation with the values in\n-        #  the pre-transformed points.  Oracle does not have the 3084 SRID.\n-        if not oracle:\n-            h = City.objects.transform(htown.srid).get(name='Houston')\n-            self.assertEqual(3084, h.point.srid)\n-            self.assertAlmostEqual(htown.x, h.point.x, prec)\n-            self.assertAlmostEqual(htown.y, h.point.y, prec)\n-\n-        p1 = City.objects.transform(ptown.srid, field_name='point').get(name='Pueblo')\n-        p2 = City.objects.transform(srid=ptown.srid).get(name='Pueblo')\n-        for p in [p1, p2]:\n-            self.assertEqual(2774, p.point.srid)\n-            self.assertAlmostEqual(ptown.x, p.point.x, prec)\n-            self.assertAlmostEqual(ptown.y, p.point.y, prec)\n+    def test_inherited_geofields(self):\n+        \"Test GeoQuerySet methods on inherited Geometry fields.\"\n+        # Creating a Pennsylvanian city.\n+        mansfield = PennsylvaniaCity.objects.create(name='Mansfield', county='Tioga', point='POINT(-77.071445 41.823881)')\n \n-    @no_mysql\n-    @no_spatialite # SpatiaLite does not have an Extent function\n-    def test05_extent(self):\n-        \"Testing the `extent` GeoQuerySet method.\"\n-        # Reference query:\n-        # `SELECT ST_extent(point) FROM geoapp_city WHERE (name='Houston' or name='Dallas');`\n-        #   =>  BOX(-96.8016128540039 29.7633724212646,-95.3631439208984 32.7820587158203)\n-        expected = (-96.8016128540039, 29.7633724212646, -95.3631439208984, 32.782058715820)\n+        # All transformation SQL will need to be performed on the\n+        # _parent_ table.\n+        qs = PennsylvaniaCity.objects.transform(32128)\n \n-        qs = City.objects.filter(name__in=('Houston', 'Dallas'))\n-        extent = qs.extent()\n+        self.assertEqual(1, qs.count())\n+        for pc in qs: self.assertEqual(32128, pc.point.srid)\n \n-        for val, exp in zip(extent, expected):\n-            self.assertAlmostEqual(exp, val, 4)\n \n-    # Only PostGIS has support for the MakeLine aggregate.\n-    @no_mysql\n-    @no_oracle\n-    @no_spatialite\n-    def test06_make_line(self):\n-        \"Testing the `make_line` GeoQuerySet method.\"\n-        # Ensuring that a `TypeError` is raised on models without PointFields.\n-        self.assertRaises(TypeError, State.objects.make_line)\n-        self.assertRaises(TypeError, Country.objects.make_line)\n-        # Reference query:\n-        # SELECT AsText(ST_MakeLine(geoapp_city.point)) FROM geoapp_city;\n-        ref_line = GEOSGeometry('LINESTRING(-95.363151 29.763374,-96.801611 32.782057,-97.521157 34.464642,174.783117 -41.315268,-104.609252 38.255001,-95.23506 38.971823,-87.650175 41.850385,-123.305196 48.462611)', srid=4326)\n-        self.assertEqual(ref_line, City.objects.make_line())\n+class GeoLookupTest(TestCase):\n \n     @no_mysql\n-    def test09_disjoint(self):\n+    def test_disjoint_lookup(self):\n         \"Testing the `disjoint` lookup type.\"\n         ptown = City.objects.get(name='Pueblo')\n         qs1 = City.objects.filter(point__disjoint=ptown.point)\n@@ -263,7 +200,7 @@ def test09_disjoint(self):\n         self.assertEqual(1, qs2.count())\n         self.assertEqual('Kansas', qs2[0].name)\n \n-    def test10_contains_contained(self):\n+    def test_contains_contained_lookups(self):\n         \"Testing the 'contained', 'contains', and 'bbcontains' lookup types.\"\n         # Getting Texas, yes we were a country -- once ;)\n         texas = Country.objects.get(name='Texas')\n@@ -308,53 +245,56 @@ def test10_contains_contained(self):\n             self.assertEqual(1, len(qs))\n             self.assertEqual('Texas', qs[0].name)\n \n+    # Only PostGIS has `left` and `right` lookup types.\n     @no_mysql\n-    def test11_lookup_insert_transform(self):\n-        \"Testing automatic transform for lookups and inserts.\"\n-        # San Antonio in 'WGS84' (SRID 4326)\n-        sa_4326 = 'POINT (-98.493183 29.424170)'\n-        wgs_pnt = fromstr(sa_4326, srid=4326) # Our reference point in WGS84\n+    @no_oracle\n+    @no_spatialite\n+    def test_left_right_lookups(self):\n+        \"Testing the 'left' and 'right' lookup types.\"\n+        # Left: A << B => true if xmax(A) < xmin(B)\n+        # Right: A >> B => true if xmin(A) > xmax(B)\n+        # See: BOX2D_left() and BOX2D_right() in lwgeom_box2dfloat4.c in PostGIS source.\n \n-        # Oracle doesn't have SRID 3084, using 41157.\n-        if oracle:\n-            # San Antonio in 'Texas 4205, Southern Zone (1983, meters)' (SRID 41157)\n-            # Used the following Oracle SQL to get this value:\n-            #  SELECT SDO_UTIL.TO_WKTGEOMETRY(SDO_CS.TRANSFORM(SDO_GEOMETRY('POINT (-98.493183 29.424170)', 4326), 41157)) FROM DUAL;\n-            nad_wkt  = 'POINT (300662.034646583 5416427.45974934)'\n-            nad_srid = 41157\n-        else:\n-            # San Antonio in 'NAD83(HARN) / Texas Centric Lambert Conformal' (SRID 3084)\n-            nad_wkt = 'POINT (1645978.362408288754523 6276356.025927528738976)' # Used ogr.py in gdal 1.4.1 for this transform\n-            nad_srid = 3084\n+        # Getting the borders for Colorado & Kansas\n+        co_border = State.objects.get(name='Colorado').poly\n+        ks_border = State.objects.get(name='Kansas').poly\n \n-        # Constructing & querying with a point from a different SRID. Oracle\n-        # `SDO_OVERLAPBDYINTERSECT` operates differently from\n-        # `ST_Intersects`, so contains is used instead.\n-        nad_pnt = fromstr(nad_wkt, srid=nad_srid)\n-        if oracle:\n-            tx = Country.objects.get(mpoly__contains=nad_pnt)\n-        else:\n-            tx = Country.objects.get(mpoly__intersects=nad_pnt)\n-        self.assertEqual('Texas', tx.name)\n+        # Note: Wellington has an 'X' value of 174, so it will not be considered\n+        # to the left of CO.\n \n-        # Creating San Antonio.  Remember the Alamo.\n-        sa = City.objects.create(name='San Antonio', point=nad_pnt)\n+        # These cities should be strictly to the right of the CO border.\n+        cities = ['Houston', 'Dallas', 'Oklahoma City',\n+                  'Lawrence', 'Chicago', 'Wellington']\n+        qs = City.objects.filter(point__right=co_border)\n+        self.assertEqual(6, len(qs))\n+        for c in qs: self.assertEqual(True, c.name in cities)\n \n-        # Now verifying that San Antonio was transformed correctly\n-        sa = City.objects.get(name='San Antonio')\n-        self.assertAlmostEqual(wgs_pnt.x, sa.point.x, 6)\n-        self.assertAlmostEqual(wgs_pnt.y, sa.point.y, 6)\n+        # These cities should be strictly to the right of the KS border.\n+        cities = ['Chicago', 'Wellington']\n+        qs = City.objects.filter(point__right=ks_border)\n+        self.assertEqual(2, len(qs))\n+        for c in qs: self.assertEqual(True, c.name in cities)\n \n-        # If the GeometryField SRID is -1, then we shouldn't perform any\n-        # transformation if the SRID of the input geometry is different.\n-        # SpatiaLite does not support missing SRID values.\n-        if not spatialite:\n-            m1 = MinusOneSRID(geom=Point(17, 23, srid=4326))\n-            m1.save()\n-            self.assertEqual(-1, m1.geom.srid)\n+        # Note: Wellington has an 'X' value of 174, so it will not be considered\n+        #  to the left of CO.\n+        vic = City.objects.get(point__left=co_border)\n+        self.assertEqual('Victoria', vic.name)\n+\n+        cities = ['Pueblo', 'Victoria']\n+        qs = City.objects.filter(point__left=ks_border)\n+        self.assertEqual(2, len(qs))\n+        for c in qs: self.assertEqual(True, c.name in cities)\n+\n+    def test_equals_lookups(self):\n+        \"Testing the 'same_as' and 'equals' lookup types.\"\n+        pnt = fromstr('POINT (-95.363151 29.763374)', srid=4326)\n+        c1 = City.objects.get(point=pnt)\n+        c2 = City.objects.get(point__same_as=pnt)\n+        c3 = City.objects.get(point__equals=pnt)\n+        for c in [c1, c2, c3]: self.assertEqual('Houston', c.name)\n \n     @no_mysql\n-    def test12_null_geometries(self):\n+    def test_null_geometries(self):\n         \"Testing NULL geometry support, and the `isnull` lookup type.\"\n         # Creating a state with a NULL boundary.\n         State.objects.create(name='Puerto Rico')\n@@ -383,56 +323,8 @@ def test12_null_geometries(self):\n         State.objects.filter(name='Northern Mariana Islands').update(poly=None)\n         self.assertEqual(None, State.objects.get(name='Northern Mariana Islands').poly)\n \n-    # Only PostGIS has `left` and `right` lookup types.\n     @no_mysql\n-    @no_oracle\n-    @no_spatialite\n-    def test13_left_right(self):\n-        \"Testing the 'left' and 'right' lookup types.\"\n-        # Left: A << B => true if xmax(A) < xmin(B)\n-        # Right: A >> B => true if xmin(A) > xmax(B)\n-        # See: BOX2D_left() and BOX2D_right() in lwgeom_box2dfloat4.c in PostGIS source.\n-\n-        # Getting the borders for Colorado & Kansas\n-        co_border = State.objects.get(name='Colorado').poly\n-        ks_border = State.objects.get(name='Kansas').poly\n-\n-        # Note: Wellington has an 'X' value of 174, so it will not be considered\n-        # to the left of CO.\n-\n-        # These cities should be strictly to the right of the CO border.\n-        cities = ['Houston', 'Dallas', 'Oklahoma City',\n-                  'Lawrence', 'Chicago', 'Wellington']\n-        qs = City.objects.filter(point__right=co_border)\n-        self.assertEqual(6, len(qs))\n-        for c in qs: self.assertEqual(True, c.name in cities)\n-\n-        # These cities should be strictly to the right of the KS border.\n-        cities = ['Chicago', 'Wellington']\n-        qs = City.objects.filter(point__right=ks_border)\n-        self.assertEqual(2, len(qs))\n-        for c in qs: self.assertEqual(True, c.name in cities)\n-\n-        # Note: Wellington has an 'X' value of 174, so it will not be considered\n-        #  to the left of CO.\n-        vic = City.objects.get(point__left=co_border)\n-        self.assertEqual('Victoria', vic.name)\n-\n-        cities = ['Pueblo', 'Victoria']\n-        qs = City.objects.filter(point__left=ks_border)\n-        self.assertEqual(2, len(qs))\n-        for c in qs: self.assertEqual(True, c.name in cities)\n-\n-    def test14_equals(self):\n-        \"Testing the 'same_as' and 'equals' lookup types.\"\n-        pnt = fromstr('POINT (-95.363151 29.763374)', srid=4326)\n-        c1 = City.objects.get(point=pnt)\n-        c2 = City.objects.get(point__same_as=pnt)\n-        c3 = City.objects.get(point__equals=pnt)\n-        for c in [c1, c2, c3]: self.assertEqual('Houston', c.name)\n-\n-    @no_mysql\n-    def test15_relate(self):\n+    def test_relate_lookup(self):\n         \"Testing the 'relate' lookup type.\"\n         # To make things more interesting, we will have our Texas reference point in\n         # different SRIDs.\n@@ -474,60 +366,12 @@ def test15_relate(self):\n             self.assertEqual('Texas', Country.objects.get(mpoly__relate=(pnt2, intersects_mask)).name)\n             self.assertEqual('Lawrence', City.objects.get(point__relate=(ks.poly, intersects_mask)).name)\n \n-    def test16_createnull(self):\n-        \"Testing creating a model instance and the geometry being None\"\n-        c = City()\n-        self.assertEqual(c.point, None)\n \n-    @no_mysql\n-    def test17_unionagg(self):\n-        \"Testing the `unionagg` (aggregate union) GeoManager method.\"\n-        tx = Country.objects.get(name='Texas').mpoly\n-        # Houston, Dallas -- Oracle has different order.\n-        union1 = fromstr('MULTIPOINT(-96.801611 32.782057,-95.363151 29.763374)')\n-        union2 = fromstr('MULTIPOINT(-96.801611 32.782057,-95.363151 29.763374)')\n-        qs = City.objects.filter(point__within=tx)\n-        self.assertRaises(TypeError, qs.unionagg, 'name')\n-        # Using `field_name` keyword argument in one query and specifying an\n-        # order in the other (which should not be used because this is\n-        # an aggregate method on a spatial column)\n-        u1 = qs.unionagg(field_name='point')\n-        u2 = qs.order_by('name').unionagg()\n-        tol = 0.00001\n-        if oracle:\n-            union = union2\n-        else:\n-            union = union1\n-        self.assertEqual(True, union.equals_exact(u1, tol))\n-        self.assertEqual(True, union.equals_exact(u2, tol))\n-        qs = City.objects.filter(name='NotACity')\n-        self.assertEqual(None, qs.unionagg(field_name='point'))\n-\n-    @no_spatialite # SpatiaLite does not support abstract geometry columns\n-    def test18_geometryfield(self):\n-        \"Testing the general GeometryField.\"\n-        Feature(name='Point', geom=Point(1, 1)).save()\n-        Feature(name='LineString', geom=LineString((0, 0), (1, 1), (5, 5))).save()\n-        Feature(name='Polygon', geom=Polygon(LinearRing((0, 0), (0, 5), (5, 5), (5, 0), (0, 0)))).save()\n-        Feature(name='GeometryCollection',\n-                geom=GeometryCollection(Point(2, 2), LineString((0, 0), (2, 2)),\n-                                        Polygon(LinearRing((0, 0), (0, 5), (5, 5), (5, 0), (0, 0))))).save()\n-\n-        f_1 = Feature.objects.get(name='Point')\n-        self.assertEqual(True, isinstance(f_1.geom, Point))\n-        self.assertEqual((1.0, 1.0), f_1.geom.tuple)\n-        f_2 = Feature.objects.get(name='LineString')\n-        self.assertEqual(True, isinstance(f_2.geom, LineString))\n-        self.assertEqual(((0.0, 0.0), (1.0, 1.0), (5.0, 5.0)), f_2.geom.tuple)\n-\n-        f_3 = Feature.objects.get(name='Polygon')\n-        self.assertEqual(True, isinstance(f_3.geom, Polygon))\n-        f_4 = Feature.objects.get(name='GeometryCollection')\n-        self.assertEqual(True, isinstance(f_4.geom, GeometryCollection))\n-        self.assertEqual(f_3.geom, f_4.geom[2])\n+class GeoQuerySetTest(TestCase):\n+    # Please keep the tests in GeoQuerySet method's alphabetic order\n \n     @no_mysql\n-    def test19_centroid(self):\n+    def test_centroid(self):\n         \"Testing the `centroid` GeoQuerySet method.\"\n         qs = State.objects.exclude(poly__isnull=True).centroid()\n         if oracle:\n@@ -540,60 +384,182 @@ def test19_centroid(self):\n             self.assertEqual(True, s.poly.centroid.equals_exact(s.centroid, tol))\n \n     @no_mysql\n-    def test20_pointonsurface(self):\n-        \"Testing the `point_on_surface` GeoQuerySet method.\"\n-        # Reference values.\n-        if oracle:\n-            # SELECT SDO_UTIL.TO_WKTGEOMETRY(SDO_GEOM.SDO_POINTONSURFACE(GEOAPP_COUNTRY.MPOLY, 0.05)) FROM GEOAPP_COUNTRY;\n-            ref = {'New Zealand' : fromstr('POINT (174.616364 -36.100861)', srid=4326),\n-                   'Texas' : fromstr('POINT (-103.002434 36.500397)', srid=4326),\n-                   }\n+    def test_diff_intersection_union(self):\n+        \"Testing the `difference`, `intersection`, `sym_difference`, and `union` GeoQuerySet methods.\"\n+        geom = Point(5, 23)\n+        tol = 1\n+        qs = Country.objects.all().difference(geom).sym_difference(geom).union(geom)\n \n-        elif postgis or spatialite:\n-            # Using GEOSGeometry to compute the reference point on surface values\n-            # -- since PostGIS also uses GEOS these should be the same.\n-            ref = {'New Zealand' : Country.objects.get(name='New Zealand').mpoly.point_on_surface,\n-                   'Texas' : Country.objects.get(name='Texas').mpoly.point_on_surface\n-                   }\n+        # XXX For some reason SpatiaLite does something screwey with the Texas geometry here.  Also,\n+        # XXX it doesn't like the null intersection.\n+        if spatialite:\n+            qs = qs.exclude(name='Texas')\n+        else:\n+            qs = qs.intersection(geom)\n \n-        for c in Country.objects.point_on_surface():\n-            if spatialite:\n-                # XXX This seems to be a WKT-translation-related precision issue?\n-                tol = 0.00001\n+        for c in qs:\n+            if oracle:\n+                # Should be able to execute the queries; however, they won't be the same\n+                # as GEOS (because Oracle doesn't use GEOS internally like PostGIS or\n+                # SpatiaLite).\n+                pass\n             else:\n-                tol = 0.000000001\n-            self.assertEqual(True, ref[c.name].equals_exact(c.point_on_surface, tol))\n+                self.assertEqual(c.mpoly.difference(geom), c.difference)\n+                if not spatialite:\n+                    self.assertEqual(c.mpoly.intersection(geom), c.intersection)\n+                self.assertEqual(c.mpoly.sym_difference(geom), c.sym_difference)\n+                self.assertEqual(c.mpoly.union(geom), c.union)\n+\n+    @no_mysql\n+    @no_spatialite # SpatiaLite does not have an Extent function\n+    def test_extent(self):\n+        \"Testing the `extent` GeoQuerySet method.\"\n+        # Reference query:\n+        # `SELECT ST_extent(point) FROM geoapp_city WHERE (name='Houston' or name='Dallas');`\n+        #   =>  BOX(-96.8016128540039 29.7633724212646,-95.3631439208984 32.7820587158203)\n+        expected = (-96.8016128540039, 29.7633724212646, -95.3631439208984, 32.782058715820)\n+\n+        qs = City.objects.filter(name__in=('Houston', 'Dallas'))\n+        extent = qs.extent()\n+\n+        for val, exp in zip(extent, expected):\n+            self.assertAlmostEqual(exp, val, 4)\n \n     @no_mysql\n     @no_oracle\n-    def test21_scale(self):\n-        \"Testing the `scale` GeoQuerySet method.\"\n-        xfac, yfac = 2, 3\n-        tol = 5 # XXX The low precision tolerance is for SpatiaLite\n-        qs = Country.objects.scale(xfac, yfac, model_att='scaled')\n-        for c in qs:\n-            for p1, p2 in zip(c.mpoly, c.scaled):\n-                for r1, r2 in zip(p1, p2):\n-                    for c1, c2 in zip(r1.coords, r2.coords):\n-                        self.assertAlmostEqual(c1[0] * xfac, c2[0], tol)\n-                        self.assertAlmostEqual(c1[1] * yfac, c2[1], tol)\n+    @no_spatialite\n+    def test_force_rhr(self):\n+        \"Testing GeoQuerySet.force_rhr().\"\n+        rings = ( ( (0, 0), (5, 0), (0, 5), (0, 0) ),\n+                  ( (1, 1), (1, 3), (3, 1), (1, 1) ),\n+                  )\n+        rhr_rings = ( ( (0, 0), (0, 5), (5, 0), (0, 0) ),\n+                      ( (1, 1), (3, 1), (1, 3), (1, 1) ),\n+                      )\n+        State.objects.create(name='Foo', poly=Polygon(*rings))\n+        s = State.objects.force_rhr().get(name='Foo')\n+        self.assertEqual(rhr_rings, s.force_rhr.coords)\n \n     @no_mysql\n     @no_oracle\n-    def test22_translate(self):\n-        \"Testing the `translate` GeoQuerySet method.\"\n-        xfac, yfac = 5, -23\n-        qs = Country.objects.translate(xfac, yfac, model_att='translated')\n-        for c in qs:\n-            for p1, p2 in zip(c.mpoly, c.translated):\n-                for r1, r2 in zip(p1, p2):\n-                    for c1, c2 in zip(r1.coords, r2.coords):\n-                        # XXX The low precision is for SpatiaLite\n-                        self.assertAlmostEqual(c1[0] + xfac, c2[0], 5)\n-                        self.assertAlmostEqual(c1[1] + yfac, c2[1], 5)\n+    @no_spatialite\n+    def test_geohash(self):\n+        \"Testing GeoQuerySet.geohash().\"\n+        if not connection.ops.geohash: return\n+        # Reference query:\n+        # SELECT ST_GeoHash(point) FROM geoapp_city WHERE name='Houston';\n+        # SELECT ST_GeoHash(point, 5) FROM geoapp_city WHERE name='Houston';\n+        ref_hash = '9vk1mfq8jx0c8e0386z6'\n+        h1 = City.objects.geohash().get(name='Houston')\n+        h2 = City.objects.geohash(precision=5).get(name='Houston')\n+        self.assertEqual(ref_hash, h1.geohash)\n+        self.assertEqual(ref_hash[:5], h2.geohash)\n+\n+    def test_geojson(self):\n+        \"Testing GeoJSON output from the database using GeoQuerySet.geojson().\"\n+        # Only PostGIS 1.3.4+ supports GeoJSON.\n+        if not connection.ops.geojson:\n+            self.assertRaises(NotImplementedError, Country.objects.all().geojson, field_name='mpoly')\n+            return\n+\n+        if connection.ops.spatial_version >= (1, 4, 0):\n+            pueblo_json = '{\"type\":\"Point\",\"coordinates\":[-104.609252,38.255001]}'\n+            houston_json = '{\"type\":\"Point\",\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"EPSG:4326\"}},\"coordinates\":[-95.363151,29.763374]}'\n+            victoria_json = '{\"type\":\"Point\",\"bbox\":[-123.30519600,48.46261100,-123.30519600,48.46261100],\"coordinates\":[-123.305196,48.462611]}'\n+            chicago_json = '{\"type\":\"Point\",\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"EPSG:4326\"}},\"bbox\":[-87.65018,41.85039,-87.65018,41.85039],\"coordinates\":[-87.65018,41.85039]}'\n+        else:\n+            pueblo_json = '{\"type\":\"Point\",\"coordinates\":[-104.60925200,38.25500100]}'\n+            houston_json = '{\"type\":\"Point\",\"crs\":{\"type\":\"EPSG\",\"properties\":{\"EPSG\":4326}},\"coordinates\":[-95.36315100,29.76337400]}'\n+            victoria_json = '{\"type\":\"Point\",\"bbox\":[-123.30519600,48.46261100,-123.30519600,48.46261100],\"coordinates\":[-123.30519600,48.46261100]}'\n+            chicago_json = '{\"type\":\"Point\",\"crs\":{\"type\":\"EPSG\",\"properties\":{\"EPSG\":4326}},\"bbox\":[-87.65018,41.85039,-87.65018,41.85039],\"coordinates\":[-87.65018,41.85039]}'\n+\n+        # Precision argument should only be an integer\n+        self.assertRaises(TypeError, City.objects.geojson, precision='foo')\n+\n+        # Reference queries and values.\n+        # SELECT ST_AsGeoJson(\"geoapp_city\".\"point\", 8, 0) FROM \"geoapp_city\" WHERE \"geoapp_city\".\"name\" = 'Pueblo';\n+        self.assertEqual(pueblo_json, City.objects.geojson().get(name='Pueblo').geojson)\n+\n+        # 1.3.x: SELECT ST_AsGeoJson(\"geoapp_city\".\"point\", 8, 1) FROM \"geoapp_city\" WHERE \"geoapp_city\".\"name\" = 'Houston';\n+        # 1.4.x: SELECT ST_AsGeoJson(\"geoapp_city\".\"point\", 8, 2) FROM \"geoapp_city\" WHERE \"geoapp_city\".\"name\" = 'Houston';\n+        # This time we want to include the CRS by using the `crs` keyword.\n+        self.assertEqual(houston_json, City.objects.geojson(crs=True, model_att='json').get(name='Houston').json)\n+\n+        # 1.3.x: SELECT ST_AsGeoJson(\"geoapp_city\".\"point\", 8, 2) FROM \"geoapp_city\" WHERE \"geoapp_city\".\"name\" = 'Victoria';\n+        # 1.4.x: SELECT ST_AsGeoJson(\"geoapp_city\".\"point\", 8, 1) FROM \"geoapp_city\" WHERE \"geoapp_city\".\"name\" = 'Houston';\n+        # This time we include the bounding box by using the `bbox` keyword.\n+        self.assertEqual(victoria_json, City.objects.geojson(bbox=True).get(name='Victoria').geojson)\n+\n+        # 1.(3|4).x: SELECT ST_AsGeoJson(\"geoapp_city\".\"point\", 5, 3) FROM \"geoapp_city\" WHERE \"geoapp_city\".\"name\" = 'Chicago';\n+        # Finally, we set every available keyword.\n+        self.assertEqual(chicago_json, City.objects.geojson(bbox=True, crs=True, precision=5).get(name='Chicago').geojson)\n+\n+    def test_gml(self):\n+        \"Testing GML output from the database using GeoQuerySet.gml().\"\n+        if mysql or (spatialite and not connection.ops.gml) :\n+            self.assertRaises(NotImplementedError, Country.objects.all().gml, field_name='mpoly')\n+            return\n+\n+        # Should throw a TypeError when tyring to obtain GML from a\n+        # non-geometry field.\n+        qs = City.objects.all()\n+        self.assertRaises(TypeError, qs.gml, field_name='name')\n+        ptown1 = City.objects.gml(field_name='point', precision=9).get(name='Pueblo')\n+        ptown2 = City.objects.gml(precision=9).get(name='Pueblo')\n+\n+        if oracle:\n+            # No precision parameter for Oracle :-/\n+            gml_regex = re.compile(r'^<gml:Point srsName=\"SDO:4326\" xmlns:gml=\"http://www.opengis.net/gml\"><gml:coordinates decimal=\"\\.\" cs=\",\" ts=\" \">-104.60925\\d+,38.25500\\d+ </gml:coordinates></gml:Point>')\n+        elif spatialite:\n+            # Spatialite has extra colon in SrsName\n+            gml_regex = re.compile(r'^<gml:Point SrsName=\"EPSG::4326\"><gml:coordinates decimal=\"\\.\" cs=\",\" ts=\" \">-104.609251\\d+,38.255001</gml:coordinates></gml:Point>')\n+        else:\n+            gml_regex = re.compile(r'^<gml:Point srsName=\"EPSG:4326\"><gml:coordinates>-104\\.60925\\d+,38\\.255001</gml:coordinates></gml:Point>')\n+\n+        for ptown in [ptown1, ptown2]:\n+            self.assertTrue(gml_regex.match(ptown.gml))\n+\n+    def test_kml(self):\n+        \"Testing KML output from the database using GeoQuerySet.kml().\"\n+        # Only PostGIS and Spatialite (>=2.4.0-RC4) support KML serialization\n+        if not (postgis or (spatialite and connection.ops.kml)):\n+            self.assertRaises(NotImplementedError, State.objects.all().kml, field_name='poly')\n+            return\n+\n+        # Should throw a TypeError when trying to obtain KML from a\n+        #  non-geometry field.\n+        qs = City.objects.all()\n+        self.assertRaises(TypeError, qs.kml, 'name')\n+\n+        # The reference KML depends on the version of PostGIS used\n+        # (the output stopped including altitude in 1.3.3).\n+        if connection.ops.spatial_version >= (1, 3, 3):\n+            ref_kml =  '<Point><coordinates>-104.609252,38.255001</coordinates></Point>'\n+        else:\n+            ref_kml = '<Point><coordinates>-104.609252,38.255001,0</coordinates></Point>'\n \n+        # Ensuring the KML is as expected.\n+        ptown1 = City.objects.kml(field_name='point', precision=9).get(name='Pueblo')\n+        ptown2 = City.objects.kml(precision=9).get(name='Pueblo')\n+        for ptown in [ptown1, ptown2]:\n+            self.assertEqual(ref_kml, ptown.kml)\n+\n+    # Only PostGIS has support for the MakeLine aggregate.\n     @no_mysql\n-    def test23_numgeom(self):\n+    @no_oracle\n+    @no_spatialite\n+    def test_make_line(self):\n+        \"Testing the `make_line` GeoQuerySet method.\"\n+        # Ensuring that a `TypeError` is raised on models without PointFields.\n+        self.assertRaises(TypeError, State.objects.make_line)\n+        self.assertRaises(TypeError, Country.objects.make_line)\n+        # Reference query:\n+        # SELECT AsText(ST_MakeLine(geoapp_city.point)) FROM geoapp_city;\n+        ref_line = GEOSGeometry('LINESTRING(-95.363151 29.763374,-96.801611 32.782057,-97.521157 34.464642,174.783117 -41.315268,-104.609252 38.255001,-95.23506 38.971823,-87.650175 41.850385,-123.305196 48.462611)', srid=4326)\n+        self.assertEqual(ref_line, City.objects.make_line())\n+\n+    @no_mysql\n+    def test_num_geom(self):\n         \"Testing the `num_geom` GeoQuerySet method.\"\n         # Both 'countries' only have two geometries.\n         for c in Country.objects.num_geom(): self.assertEqual(2, c.num_geom)\n@@ -607,7 +573,7 @@ def test23_numgeom(self):\n \n     @no_mysql\n     @no_spatialite # SpatiaLite can only count vertices in LineStrings\n-    def test24_numpoints(self):\n+    def test_num_points(self):\n         \"Testing the `num_points` GeoQuerySet method.\"\n         for c in Country.objects.num_points():\n             self.assertEqual(c.mpoly.num_points, c.num_points)\n@@ -617,49 +583,60 @@ def test24_numpoints(self):\n             for c in City.objects.num_points(): self.assertEqual(1, c.num_points)\n \n     @no_mysql\n-    def test25_geoset(self):\n-        \"Testing the `difference`, `intersection`, `sym_difference`, and `union` GeoQuerySet methods.\"\n-        geom = Point(5, 23)\n-        tol = 1\n-        qs = Country.objects.all().difference(geom).sym_difference(geom).union(geom)\n+    def test_point_on_surface(self):\n+        \"Testing the `point_on_surface` GeoQuerySet method.\"\n+        # Reference values.\n+        if oracle:\n+            # SELECT SDO_UTIL.TO_WKTGEOMETRY(SDO_GEOM.SDO_POINTONSURFACE(GEOAPP_COUNTRY.MPOLY, 0.05)) FROM GEOAPP_COUNTRY;\n+            ref = {'New Zealand' : fromstr('POINT (174.616364 -36.100861)', srid=4326),\n+                   'Texas' : fromstr('POINT (-103.002434 36.500397)', srid=4326),\n+                   }\n \n-        # XXX For some reason SpatiaLite does something screwey with the Texas geometry here.  Also,\n-        # XXX it doesn't like the null intersection.\n-        if spatialite:\n-            qs = qs.exclude(name='Texas')\n-        else:\n-            qs = qs.intersection(geom)\n+        elif postgis or spatialite:\n+            # Using GEOSGeometry to compute the reference point on surface values\n+            # -- since PostGIS also uses GEOS these should be the same.\n+            ref = {'New Zealand' : Country.objects.get(name='New Zealand').mpoly.point_on_surface,\n+                   'Texas' : Country.objects.get(name='Texas').mpoly.point_on_surface\n+                   }\n \n-        for c in qs:\n-            if oracle:\n-                # Should be able to execute the queries; however, they won't be the same\n-                # as GEOS (because Oracle doesn't use GEOS internally like PostGIS or\n-                # SpatiaLite).\n-                pass\n+        for c in Country.objects.point_on_surface():\n+            if spatialite:\n+                # XXX This seems to be a WKT-translation-related precision issue?\n+                tol = 0.00001\n             else:\n-                self.assertEqual(c.mpoly.difference(geom), c.difference)\n-                if not spatialite:\n-                    self.assertEqual(c.mpoly.intersection(geom), c.intersection)\n-                self.assertEqual(c.mpoly.sym_difference(geom), c.sym_difference)\n-                self.assertEqual(c.mpoly.union(geom), c.union)\n+                tol = 0.000000001\n+            self.assertEqual(True, ref[c.name].equals_exact(c.point_on_surface, tol))\n \n     @no_mysql\n-    def test26_inherited_geofields(self):\n-        \"Test GeoQuerySet methods on inherited Geometry fields.\"\n-        # Creating a Pennsylvanian city.\n-        mansfield = PennsylvaniaCity.objects.create(name='Mansfield', county='Tioga', point='POINT(-77.071445 41.823881)')\n-\n-        # All transformation SQL will need to be performed on the\n-        # _parent_ table.\n-        qs = PennsylvaniaCity.objects.transform(32128)\n+    @no_spatialite\n+    def test_reverse_geom(self):\n+        \"Testing GeoQuerySet.reverse_geom().\"\n+        coords = [ (-95.363151, 29.763374), (-95.448601, 29.713803) ]\n+        Track.objects.create(name='Foo', line=LineString(coords))\n+        t = Track.objects.reverse_geom().get(name='Foo')\n+        coords.reverse()\n+        self.assertEqual(tuple(coords), t.reverse_geom.coords)\n+        if oracle:\n+            self.assertRaises(TypeError, State.objects.reverse_geom)\n \n-        self.assertEqual(1, qs.count())\n-        for pc in qs: self.assertEqual(32128, pc.point.srid)\n+    @no_mysql\n+    @no_oracle\n+    def test_scale(self):\n+        \"Testing the `scale` GeoQuerySet method.\"\n+        xfac, yfac = 2, 3\n+        tol = 5 # XXX The low precision tolerance is for SpatiaLite\n+        qs = Country.objects.scale(xfac, yfac, model_att='scaled')\n+        for c in qs:\n+            for p1, p2 in zip(c.mpoly, c.scaled):\n+                for r1, r2 in zip(p1, p2):\n+                    for c1, c2 in zip(r1.coords, r2.coords):\n+                        self.assertAlmostEqual(c1[0] * xfac, c2[0], tol)\n+                        self.assertAlmostEqual(c1[1] * yfac, c2[1], tol)\n \n     @no_mysql\n     @no_oracle\n     @no_spatialite\n-    def test27_snap_to_grid(self):\n+    def test_snap_to_grid(self):\n         \"Testing GeoQuerySet.snap_to_grid().\"\n         # Let's try and break snap_to_grid() with bad combinations of arguments.\n         for bad_args in ((), range(3), range(5)):\n@@ -695,48 +672,78 @@ def test27_snap_to_grid(self):\n         ref = fromstr('MULTIPOLYGON(((12.4 43.87,12.45 43.87,12.45 44.1,12.5 44.1,12.5 43.87,12.45 43.87,12.4 43.87)))')\n         self.assertTrue(ref.equals_exact(Country.objects.snap_to_grid(0.05, 0.23, 0.5, 0.17).get(name='San Marino').snap_to_grid, tol))\n \n-    @no_mysql\n-    @no_spatialite\n-    def test28_reverse(self):\n-        \"Testing GeoQuerySet.reverse_geom().\"\n-        coords = [ (-95.363151, 29.763374), (-95.448601, 29.713803) ]\n-        Track.objects.create(name='Foo', line=LineString(coords))\n-        t = Track.objects.reverse_geom().get(name='Foo')\n-        coords.reverse()\n-        self.assertEqual(tuple(coords), t.reverse_geom.coords)\n-        if oracle:\n-            self.assertRaises(TypeError, State.objects.reverse_geom)\n+    def test_svg(self):\n+        \"Testing SVG output using GeoQuerySet.svg().\"\n+        if mysql or oracle:\n+            self.assertRaises(NotImplementedError, City.objects.svg)\n+            return\n+\n+        self.assertRaises(TypeError, City.objects.svg, precision='foo')\n+        # SELECT AsSVG(geoapp_city.point, 0, 8) FROM geoapp_city WHERE name = 'Pueblo';\n+        svg1 = 'cx=\"-104.609252\" cy=\"-38.255001\"'\n+        # Even though relative, only one point so it's practically the same except for\n+        # the 'c' letter prefix on the x,y values.\n+        svg2 = svg1.replace('c', '')\n+        self.assertEqual(svg1, City.objects.svg().get(name='Pueblo').svg)\n+        self.assertEqual(svg2, City.objects.svg(relative=5).get(name='Pueblo').svg)\n \n     @no_mysql\n-    @no_oracle\n-    @no_spatialite\n-    def test29_force_rhr(self):\n-        \"Testing GeoQuerySet.force_rhr().\"\n-        rings = ( ( (0, 0), (5, 0), (0, 5), (0, 0) ),\n-                  ( (1, 1), (1, 3), (3, 1), (1, 1) ),\n-                  )\n-        rhr_rings = ( ( (0, 0), (0, 5), (5, 0), (0, 0) ),\n-                      ( (1, 1), (3, 1), (1, 3), (1, 1) ),\n-                      )\n-        State.objects.create(name='Foo', poly=Polygon(*rings))\n-        s = State.objects.force_rhr().get(name='Foo')\n-        self.assertEqual(rhr_rings, s.force_rhr.coords)\n+    def test_transform(self):\n+        \"Testing the transform() GeoQuerySet method.\"\n+        # Pre-transformed points for Houston and Pueblo.\n+        htown = fromstr('POINT(1947516.83115183 6322297.06040572)', srid=3084)\n+        ptown = fromstr('POINT(992363.390841912 481455.395105533)', srid=2774)\n+        prec = 3 # Precision is low due to version variations in PROJ and GDAL.\n+\n+        # Asserting the result of the transform operation with the values in\n+        #  the pre-transformed points.  Oracle does not have the 3084 SRID.\n+        if not oracle:\n+            h = City.objects.transform(htown.srid).get(name='Houston')\n+            self.assertEqual(3084, h.point.srid)\n+            self.assertAlmostEqual(htown.x, h.point.x, prec)\n+            self.assertAlmostEqual(htown.y, h.point.y, prec)\n+\n+        p1 = City.objects.transform(ptown.srid, field_name='point').get(name='Pueblo')\n+        p2 = City.objects.transform(srid=ptown.srid).get(name='Pueblo')\n+        for p in [p1, p2]:\n+            self.assertEqual(2774, p.point.srid)\n+            self.assertAlmostEqual(ptown.x, p.point.x, prec)\n+            self.assertAlmostEqual(ptown.y, p.point.y, prec)\n \n     @no_mysql\n     @no_oracle\n-    @no_spatialite\n-    def test30_geohash(self):\n-        \"Testing GeoQuerySet.geohash().\"\n-        if not connection.ops.geohash: return\n-        # Reference query:\n-        # SELECT ST_GeoHash(point) FROM geoapp_city WHERE name='Houston';\n-        # SELECT ST_GeoHash(point, 5) FROM geoapp_city WHERE name='Houston';\n-        ref_hash = '9vk1mfq8jx0c8e0386z6'\n-        h1 = City.objects.geohash().get(name='Houston')\n-        h2 = City.objects.geohash(precision=5).get(name='Houston')\n-        self.assertEqual(ref_hash, h1.geohash)\n-        self.assertEqual(ref_hash[:5], h2.geohash)\n+    def test_translate(self):\n+        \"Testing the `translate` GeoQuerySet method.\"\n+        xfac, yfac = 5, -23\n+        qs = Country.objects.translate(xfac, yfac, model_att='translated')\n+        for c in qs:\n+            for p1, p2 in zip(c.mpoly, c.translated):\n+                for r1, r2 in zip(p1, p2):\n+                    for c1, c2 in zip(r1.coords, r2.coords):\n+                        # XXX The low precision is for SpatiaLite\n+                        self.assertAlmostEqual(c1[0] + xfac, c2[0], 5)\n+                        self.assertAlmostEqual(c1[1] + yfac, c2[1], 5)\n \n-from .test_feeds import GeoFeedTest\n-from .test_regress import GeoRegressionTests\n-from .test_sitemaps import GeoSitemapTest\n+    @no_mysql\n+    def test_unionagg(self):\n+        \"Testing the `unionagg` (aggregate union) GeoQuerySet method.\"\n+        tx = Country.objects.get(name='Texas').mpoly\n+        # Houston, Dallas -- Oracle has different order.\n+        union1 = fromstr('MULTIPOINT(-96.801611 32.782057,-95.363151 29.763374)')\n+        union2 = fromstr('MULTIPOINT(-96.801611 32.782057,-95.363151 29.763374)')\n+        qs = City.objects.filter(point__within=tx)\n+        self.assertRaises(TypeError, qs.unionagg, 'name')\n+        # Using `field_name` keyword argument in one query and specifying an\n+        # order in the other (which should not be used because this is\n+        # an aggregate method on a spatial column)\n+        u1 = qs.unionagg(field_name='point')\n+        u2 = qs.order_by('name').unionagg()\n+        tol = 0.00001\n+        if oracle:\n+            union = union2\n+        else:\n+            union = union1\n+        self.assertEqual(True, union.equals_exact(u1, tol))\n+        self.assertEqual(True, union.equals_exact(u2, tol))\n+        qs = City.objects.filter(name='NotACity')\n+        self.assertEqual(None, qs.unionagg(field_name='point'))"
        }
    ],
    "stats": {
        "total": 815,
        "additions": 411,
        "deletions": 404
    }
}