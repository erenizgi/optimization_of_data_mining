{
    "author": "andrewgodwin",
    "message": "Stylistic fixes: triple-quoted docstrings, more comments",
    "sha": "ae6ffd2e7ef69180560eaeae9a00f76cd3721691",
    "files": [
        {
            "sha": "baa8fd3ddb17b4f835d8346485d004d7845f56d6",
            "filename": "django/db/backends/schema.py",
            "status": "modified",
            "additions": 21,
            "deletions": 7,
            "changes": 28,
            "blob_url": "https://github.com/django/django/blob/ae6ffd2e7ef69180560eaeae9a00f76cd3721691/django%2Fdb%2Fbackends%2Fschema.py",
            "raw_url": "https://github.com/django/django/raw/ae6ffd2e7ef69180560eaeae9a00f76cd3721691/django%2Fdb%2Fbackends%2Fschema.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fschema.py?ref=ae6ffd2e7ef69180560eaeae9a00f76cd3721691",
            "patch": "@@ -59,21 +59,27 @@ def __init__(self, connection):\n     # State-managing methods\n \n     def start(self):\n-        \"Marks the start of a schema-altering run\"\n+        \"\"\"\n+        Marks the start of a schema-altering run.\n+        \"\"\"\n         self.deferred_sql = []\n         self.connection.commit_unless_managed()\n         self.connection.enter_transaction_management()\n         self.connection.managed(True)\n \n     def commit(self):\n-        \"Finishes a schema-altering run\"\n+        \"\"\"\n+        Finishes a schema-altering run.\n+        \"\"\"\n         for sql in self.deferred_sql:\n             self.execute(sql)\n         self.connection.commit()\n         self.connection.leave_transaction_management()\n \n     def rollback(self):\n-        \"Tries to roll back a schema-altering run. Call instead of commit()\"\n+        \"\"\"\n+        Tries to roll back a schema-altering run. Call instead of commit().\n+        \"\"\"\n         if not self.connection.features.can_rollback_ddl:\n             raise RuntimeError(\"Cannot rollback schema changes on this backend\")\n         self.connection.rollback()\n@@ -137,7 +143,9 @@ def column_sql(self, model, field, include_default=False):\n         return sql, params\n \n     def effective_default(self, field):\n-        \"Returns a field's effective database default value\"\n+        \"\"\"\n+        Returns a field's effective database default value\n+        \"\"\"\n         if field.has_default():\n             default = field.get_default()\n         elif not field.null and field.blank and field.empty_strings_allowed:\n@@ -580,7 +588,9 @@ def alter_field(self, model, old_field, new_field, strict=False):\n             )\n \n     def _alter_many_to_many(self, model, old_field, new_field, strict):\n-        \"Alters M2Ms to repoint their to= endpoints.\"\n+        \"\"\"\n+        Alters M2Ms to repoint their to= endpoints.\n+        \"\"\"\n         # Rename the through table\n         self.alter_db_table(old_field.rel.through, old_field.rel.through._meta.db_table, new_field.rel.through._meta.db_table)\n         # Repoint the FK to the other side\n@@ -591,7 +601,9 @@ def _alter_many_to_many(self, model, old_field, new_field, strict):\n         )\n \n     def _create_index_name(self, model, column_names, suffix=\"\"):\n-        \"Generates a unique name for an index/unique constraint.\"\n+        \"\"\"\n+        Generates a unique name for an index/unique constraint.\n+        \"\"\"\n         # If there is just one column in the index, use a default algorithm from Django\n         if len(column_names) == 1 and not suffix:\n             return truncate_name(\n@@ -609,7 +621,9 @@ def _create_index_name(self, model, column_names, suffix=\"\"):\n         return index_name\n \n     def _constraint_names(self, model, column_names=None, unique=None, primary_key=None, index=None, foreign_key=None, check=None):\n-        \"Returns all constraint names matching the columns and conditions\"\n+        \"\"\"\n+        Returns all constraint names matching the columns and conditions\n+        \"\"\"\n         column_names = set(column_names) if column_names else None\n         constraints = self.connection.introspection.get_constraints(self.connection.cursor(), model._meta.db_table)\n         result = []"
        },
        {
            "sha": "711ee6fac57bbc0e89fda5543fc27d48649e40f7",
            "filename": "django/db/backends/sqlite3/introspection.py",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/ae6ffd2e7ef69180560eaeae9a00f76cd3721691/django%2Fdb%2Fbackends%2Fsqlite3%2Fintrospection.py",
            "raw_url": "https://github.com/django/django/raw/ae6ffd2e7ef69180560eaeae9a00f76cd3721691/django%2Fdb%2Fbackends%2Fsqlite3%2Fintrospection.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fintrospection.py?ref=ae6ffd2e7ef69180560eaeae9a00f76cd3721691",
            "patch": "@@ -207,10 +207,13 @@ def get_constraints(self, cursor, table_name):\n         # Get the PK\n         pk_column = self.get_primary_key_column(cursor, table_name)\n         if pk_column:\n+            # SQLite doesn't actually give a name to the PK constraint,\n+            # so we invent one. This is fine, as the SQLite backend never\n+            # deletes PK constraints by name.\n             constraints[\"__primary__\"] = {\n                 \"columns\": set([pk_column]),\n                 \"primary_key\": True,\n-                \"unique\": False,  # It's not actually a unique constraint\n+                \"unique\": False,  # It's not actually a unique constraint.\n                 \"foreign_key\": False,\n                 \"check\": False,\n                 \"index\": False,"
        },
        {
            "sha": "e42f2c62d91a6f2ccccecded5dd70b8e78b2ee88",
            "filename": "django/db/backends/sqlite3/schema.py",
            "status": "modified",
            "additions": 18,
            "deletions": 3,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/ae6ffd2e7ef69180560eaeae9a00f76cd3721691/django%2Fdb%2Fbackends%2Fsqlite3%2Fschema.py",
            "raw_url": "https://github.com/django/django/raw/ae6ffd2e7ef69180560eaeae9a00f76cd3721691/django%2Fdb%2Fbackends%2Fsqlite3%2Fschema.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fschema.py?ref=ae6ffd2e7ef69180560eaeae9a00f76cd3721691",
            "patch": "@@ -8,7 +8,9 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n     sql_delete_table = \"DROP TABLE %(table)s\"\n \n     def _remake_table(self, model, create_fields=[], delete_fields=[], alter_fields=[], rename_fields=[], override_uniques=None):\n-        \"Shortcut to transform a model from old_model into new_model\"\n+        \"\"\"\n+        Shortcut to transform a model from old_model into new_model\n+        \"\"\"\n         # Work out the new fields dict / mapping\n         body = dict((f.name, f) for f in model._meta.local_fields)\n         mapping = dict((f.column, f.column) for f in model._meta.local_fields)\n@@ -98,7 +100,13 @@ def delete_field(self, model, field):\n         self._remake_table(model, delete_fields=[field])\n \n     def alter_field(self, model, old_field, new_field, strict=False):\n-        # Ensure this field is even column-based\n+        \"\"\"\n+        Allows a field's type, uniqueness, nullability, default, column,\n+        constraints etc. to be modified.\n+        Requires a copy of the old field as well so we can only perform\n+        changes that are required.\n+        If strict is true, raises errors if the old column does not match old_field precisely.\n+        \"\"\"\n         old_db_params = old_field.db_parameters(connection=self.connection)\n         old_type = old_db_params['type']\n         new_db_params = new_field.db_parameters(connection=self.connection)\n@@ -114,10 +122,17 @@ def alter_field(self, model, old_field, new_field, strict=False):\n         self._remake_table(model, alter_fields=[(old_field, new_field)])\n \n     def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deals with a model changing its unique_together.\n+        Note: The input unique_togethers must be doubly-nested, not the single-\n+        nested [\"foo\", \"bar\"] format.\n+        \"\"\"\n         self._remake_table(model, override_uniques=new_unique_together)\n \n     def _alter_many_to_many(self, model, old_field, new_field, strict):\n-        \"Alters M2Ms to repoint their to= endpoints.\"\n+        \"\"\"\n+        Alters M2Ms to repoint their to= endpoints.\n+        \"\"\"\n         # Make a new through table\n         self.create_model(new_field.rel.through)\n         # Copy the data across"
        }
    ],
    "stats": {
        "total": 54,
        "additions": 43,
        "deletions": 11
    }
}