{
    "author": "claudep",
    "message": "[py3] Fixed Python 3 compatibility of http handling\n\n* Using str() when Python 2 expects bytes and Python 3 Unicode\n* Fixed reraise-ing syntax\n* Fixed slicing of byte strings",
    "sha": "f10a1b06416e59a66cc9c3c8437fe045cb0fb03c",
    "files": [
        {
            "sha": "f2e1cda8ff0e264001f78385dae672ef7463eeeb",
            "filename": "django/http/__init__.py",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/f10a1b06416e59a66cc9c3c8437fe045cb0fb03c/django%2Fhttp%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/f10a1b06416e59a66cc9c3c8437fe045cb0fb03c/django%2Fhttp%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2F__init__.py?ref=f10a1b06416e59a66cc9c3c8437fe045cb0fb03c",
            "patch": "@@ -61,14 +61,14 @@ def value_encode(self, val):\n         if not _cookie_allows_colon_in_names:\n             def load(self, rawdata):\n                 self.bad_cookies = set()\n-                super(SimpleCookie, self).load(smart_bytes(rawdata))\n+                super(SimpleCookie, self).load(str(rawdata))\n                 for key in self.bad_cookies:\n                     del self[key]\n \n             # override private __set() method:\n             # (needed for using our Morsel, and for laxness with CookieError\n             def _BaseCookie__set(self, key, real_value, coded_value):\n-                key = smart_bytes(key)\n+                key = str(key)\n                 try:\n                     M = self.get(key, Morsel())\n                     M.set(key, real_value, coded_value)\n@@ -137,7 +137,7 @@ def build_request_repr(request, path_override=None, GET_override=None,\n     except:\n         meta = '<could not parse>'\n     path = path_override if path_override is not None else request.path\n-    return smart_bytes('<%s\\npath:%s,\\nGET:%s,\\nPOST:%s,\\nCOOKIES:%s,\\nMETA:%s>' %\n+    return str('<%s\\npath:%s,\\nGET:%s,\\nPOST:%s,\\nCOOKIES:%s,\\nMETA:%s>' %\n                      (request.__class__.__name__,\n                       path,\n                       six.text_type(get),\n@@ -294,7 +294,7 @@ def body(self):\n             try:\n                 self._body = self.read()\n             except IOError as e:\n-                six.reraise(UnreadablePostError, e, sys.exc_traceback)\n+                six.reraise(UnreadablePostError, UnreadablePostError(*tuple(e.args)), sys.exc_info()[2])\n             self._stream = BytesIO(self._body)\n         return self._body\n "
        },
        {
            "sha": "a324935d3d375859def584e3bf8e8939893d6892",
            "filename": "django/http/multipartparser.py",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/f10a1b06416e59a66cc9c3c8437fe045cb0fb03c/django%2Fhttp%2Fmultipartparser.py",
            "raw_url": "https://github.com/django/django/raw/f10a1b06416e59a66cc9c3c8437fe045cb0fb03c/django%2Fhttp%2Fmultipartparser.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2Fmultipartparser.py?ref=f10a1b06416e59a66cc9c3c8437fe045cb0fb03c",
            "patch": "@@ -507,9 +507,11 @@ def _find_boundary(self, data, eof = False):\n             end = index\n             next = index + len(self._boundary)\n             # backup over CRLF\n-            if data[max(0,end-1)] == b'\\n':\n+            last = max(0, end-1)\n+            if data[last:last+1] == b'\\n':\n                 end -= 1\n-            if data[max(0,end-1)] == b'\\r':\n+            last = max(0, end-1)\n+            if data[last:last+1] == b'\\r':\n                 end -= 1\n             return end, next\n \n@@ -613,7 +615,7 @@ def parse_header(line):\n         if i >= 0:\n             name = p[:i].strip().lower().decode('ascii')\n             value = p[i+1:].strip()\n-            if len(value) >= 2 and value[0] == value[-1] == b'\"':\n+            if len(value) >= 2 and value[:1] == value[-1:] == b'\"':\n                 value = value[1:-1]\n                 value = value.replace(b'\\\\\\\\', b'\\\\').replace(b'\\\\\"', b'\"')\n             pdict[name] = value"
        }
    ],
    "stats": {
        "total": 16,
        "additions": 9,
        "deletions": 7
    }
}