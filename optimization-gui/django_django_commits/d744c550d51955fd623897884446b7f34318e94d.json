{
    "author": "akaariai",
    "message": "Fixed #19964 -- Removed relabel_aliases from some structs\n\nBefore there was need to have both .relabel_aliases() and .clone() for\nmany structs. Now there is only relabeled_clone() for those structs\nwhere alias is the only mutable attribute.",
    "sha": "d744c550d51955fd623897884446b7f34318e94d",
    "files": [
        {
            "sha": "c0d661eaec155e741dae94b0cc145941f7121192",
            "filename": "django/db/models/fields/__init__.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Ffields%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Ffields%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2F__init__.py?ref=d744c550d51955fd623897884446b7f34318e94d",
            "patch": "@@ -344,9 +344,9 @@ def get_db_prep_lookup(self, lookup_type, value, connection,\n         if hasattr(value, 'get_compiler'):\n             value = value.get_compiler(connection=connection)\n         if hasattr(value, 'as_sql') or hasattr(value, '_as_sql'):\n-            # If the value has a relabel_aliases method, it will need to\n-            # be invoked before the final SQL is evaluated\n-            if hasattr(value, 'relabel_aliases'):\n+            # If the value has a relabeled_clone method it means the\n+            # value will be handled later on.\n+            if hasattr(value, 'relabeled_clone'):\n                 return value\n             if hasattr(value, 'as_sql'):\n                 sql, params = value.as_sql()"
        },
        {
            "sha": "ee1361779accd3d9c2cce70fdbd30aedda08f0e8",
            "filename": "django/db/models/fields/related.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "raw_url": "https://github.com/django/django/raw/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2Frelated.py?ref=d744c550d51955fd623897884446b7f34318e94d",
            "patch": "@@ -153,9 +153,9 @@ def get_db_prep_lookup(self, lookup_type, value, connection, prepared=False):\n         if hasattr(value, 'get_compiler'):\n             value = value.get_compiler(connection=connection)\n         if hasattr(value, 'as_sql') or hasattr(value, '_as_sql'):\n-            # If the value has a relabel_aliases method, it will need to\n-            # be invoked before the final SQL is evaluated\n-            if hasattr(value, 'relabel_aliases'):\n+            # If the value has a relabeled_clone method it means the\n+            # value will be handled later on.\n+            if hasattr(value, 'relabeled_clone'):\n                 return value\n             if hasattr(value, 'as_sql'):\n                 sql, params = value.as_sql()"
        },
        {
            "sha": "1b65847b7f1ea5fe1ac76a261f4713d268531f46",
            "filename": "django/db/models/sql/aggregates.py",
            "status": "modified",
            "additions": 4,
            "deletions": 7,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Fsql%2Faggregates.py",
            "raw_url": "https://github.com/django/django/raw/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Fsql%2Faggregates.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Faggregates.py?ref=d744c550d51955fd623897884446b7f34318e94d",
            "patch": "@@ -63,14 +63,11 @@ def __init__(self, col, source=None, is_summary=False, **extra):\n \n         self.field = tmp\n \n-    def clone(self):\n-        # Different aggregates have different init methods, so use copy here\n-        # deepcopy is not needed, as self.col is only changing variable.\n-        return copy.copy(self)\n-\n-    def relabel_aliases(self, change_map):\n+    def relabeled_clone(self, change_map):\n+        clone = copy.copy(self)\n         if isinstance(self.col, (list, tuple)):\n-            self.col = (change_map.get(self.col[0], self.col[0]), self.col[1])\n+            clone.col = (change_map.get(self.col[0], self.col[0]), self.col[1])\n+        return clone\n \n     def as_sql(self, qn, connection):\n         \"Return the aggregate, rendered as SQL with parameters.\""
        },
        {
            "sha": "daaabbe6da00ceb7b21187f44fd88030bdb620db",
            "filename": "django/db/models/sql/datastructures.py",
            "status": "modified",
            "additions": 4,
            "deletions": 8,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Fsql%2Fdatastructures.py",
            "raw_url": "https://github.com/django/django/raw/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Fsql%2Fdatastructures.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fdatastructures.py?ref=d744c550d51955fd623897884446b7f34318e94d",
            "patch": "@@ -32,10 +32,8 @@ def __init__(self, col, lookup_type):\n         self.col = col\n         self.lookup_type = lookup_type\n \n-    def relabel_aliases(self, change_map):\n-        c = self.col\n-        if isinstance(c, (list, tuple)):\n-            self.col = (change_map.get(c[0], c[0]), c[1])\n+    def relabeled_clone(self, change_map):\n+        return self.__class__((change_map.get(self.col[0], self.col[0]), self.col[1]))\n \n     def as_sql(self, qn, connection):\n         if isinstance(self.col, (list, tuple)):\n@@ -53,10 +51,8 @@ def __init__(self, col, lookup_type, tzname):\n         self.lookup_type = lookup_type\n         self.tzname = tzname\n \n-    def relabel_aliases(self, change_map):\n-        c = self.col\n-        if isinstance(c, (list, tuple)):\n-            self.col = (change_map.get(c[0], c[0]), c[1])\n+    def relabeled_clone(self, change_map):\n+        return self.__class__((change_map.get(self.col[0], self.col[0]), self.col[1]))\n \n     def as_sql(self, qn, connection):\n         if isinstance(self.col, (list, tuple)):"
        },
        {
            "sha": "55ae655cb035509b4b6402db28d167cb25a74b8a",
            "filename": "django/db/models/sql/expressions.py",
            "status": "modified",
            "additions": 12,
            "deletions": 11,
            "changes": 23,
            "blob_url": "https://github.com/django/django/blob/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py",
            "raw_url": "https://github.com/django/django/raw/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py?ref=d744c550d51955fd623897884446b7f34318e94d",
            "patch": "@@ -1,6 +1,7 @@\n from django.core.exceptions import FieldError\n from django.db.models.constants import LOOKUP_SEP\n from django.db.models.fields import FieldDoesNotExist\n+import copy\n \n class SQLEvaluator(object):\n     def __init__(self, expression, query, allow_joins=True, reuse=None):\n@@ -12,23 +13,23 @@ def __init__(self, expression, query, allow_joins=True, reuse=None):\n         self.reuse = reuse\n         self.expression.prepare(self, query, allow_joins)\n \n+    def relabeled_clone(self, change_map):\n+        clone = copy.copy(self)\n+        clone.cols = []\n+        for node, col in self.cols[:]:\n+            if hasattr(col, 'relabeled_clone'):\n+                clone.cols.append((node, col.relabeled_clone(change_map)))\n+            else:\n+                clone.cols.append((node,\n+                                   (change_map.get(col[0], col[0]), col[1])))\n+        return clone\n+\n     def prepare(self):\n         return self\n \n     def as_sql(self, qn, connection):\n         return self.expression.evaluate(self, qn, connection)\n \n-    def relabel_aliases(self, change_map):\n-        new_cols = []\n-        for node, col in self.cols:\n-            if hasattr(col, \"relabel_aliases\"):\n-                col.relabel_aliases(change_map)\n-                new_cols.append((node, col))\n-            else:\n-                new_cols.append((node,\n-                                (change_map.get(col[0], col[0]), col[1])))\n-        self.cols = new_cols\n-\n     #####################################################\n     # Vistor methods for initial expression preparation #\n     #####################################################"
        },
        {
            "sha": "fa583f6120c9d9b2770e3e6f9c557c02ad2c8c44",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 4,
            "deletions": 27,
            "changes": 31,
            "blob_url": "https://github.com/django/django/blob/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=d744c550d51955fd623897884446b7f34318e94d",
            "patch": "@@ -294,8 +294,7 @@ def clone(self, klass=None, memo=None, **kwargs):\n         obj.select_for_update_nowait = self.select_for_update_nowait\n         obj.select_related = self.select_related\n         obj.related_select_cols = []\n-        obj.aggregates = SortedDict((k, v.clone())\n-                                    for k, v in self.aggregates.items())\n+        obj.aggregates = self.aggregates.copy()\n         if self.aggregate_select_mask is None:\n             obj.aggregate_select_mask = None\n         else:\n@@ -559,9 +558,8 @@ def combine(self, rhs, connector):\n                 new_col = change_map.get(col[0], col[0]), col[1]\n                 self.select.append(SelectInfo(new_col, field))\n             else:\n-                item = col.clone()\n-                item.relabel_aliases(change_map)\n-                self.select.append(SelectInfo(item, field))\n+                new_col = col.relabeled_clone(change_map)\n+                self.select.append(SelectInfo(new_col, field))\n \n         if connector == OR:\n             # It would be nice to be able to handle this, but the queries don't\n@@ -769,26 +767,6 @@ def promote_disjunction(self, aliases_before, alias_usage_counts,\n         The principle for promotion is: any alias which is used (it is in\n         alias_usage_counts), is not used by every child of the ORed filter,\n         and isn't pre-existing needs to be promoted to LOUTER join.\n-\n-        Some examples (assume all joins used are nullable):\n-            - existing filter: a__f1=foo\n-            - add filter: b__f1=foo|b__f2=foo\n-            In this case we should not promote either of the joins (using INNER\n-            doesn't remove results). We correctly avoid join promotion, because\n-            a is not used in this branch, and b is used two times.\n-\n-            - add filter a__f1=foo|b__f2=foo\n-            In this case we should promote both a and b, otherwise they will\n-            remove results. We will also correctly do that as both aliases are\n-            used, and in addition both are used only once while there are two\n-            filters.\n-\n-            - existing: a__f1=bar\n-            - add filter: a__f2=foo|b__f2=foo\n-            We will not promote a as it is previously used. If the join results\n-            in null, the existing filter can't succeed.\n-\n-        The above (and some more) are tested in queries.DisjunctionPromotionTests\n         \"\"\"\n         for alias, use_count in alias_usage_counts.items():\n             if use_count < num_childs and alias not in aliases_before:\n@@ -807,8 +785,7 @@ def relabel_column(col):\n                 old_alias = col[0]\n                 return (change_map.get(old_alias, old_alias), col[1])\n             else:\n-                col.relabel_aliases(change_map)\n-                return col\n+                return col.relabeled_clone(change_map)\n         # 1. Update references in \"select\" (normal columns plus aliases),\n         # \"group by\", \"where\" and \"having\".\n         self.where.relabel_aliases(change_map)"
        },
        {
            "sha": "152a3967857af0c731332de5a3da97ca75640dbf",
            "filename": "django/db/models/sql/where.py",
            "status": "modified",
            "additions": 29,
            "deletions": 45,
            "changes": 74,
            "blob_url": "https://github.com/django/django/blob/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Fsql%2Fwhere.py",
            "raw_url": "https://github.com/django/django/raw/d744c550d51955fd623897884446b7f34318e94d/django%2Fdb%2Fmodels%2Fsql%2Fwhere.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fwhere.py?ref=d744c550d51955fd623897884446b7f34318e94d",
            "patch": "@@ -34,9 +34,15 @@ class WhereNode(tree.Node):\n     The class is tied to the Query class that created it (in order to create\n     the correct SQL).\n \n-    The children in this tree are usually either Q-like objects or lists of\n-    [table_alias, field_name, db_type, lookup_type, value_annotation, params].\n-    However, a child could also be any class with as_sql() and relabel_aliases() methods.\n+    A child is usually a tuple of:\n+        (Constraint(alias, targetcol, field), lookup_type, value)\n+    where value can be either raw Python value, or Query, ExpressionNode or\n+    something else knowing how to turn itself into SQL.\n+\n+    However, a child could also be any class with as_sql() and either\n+    relabeled_clone() method or relabel_aliases() and clone() methods. The\n+    second alternative should be used if the alias is not the only mutable\n+    variable.\n     \"\"\"\n     default = AND\n \n@@ -255,30 +261,22 @@ def sql_for_columns(self, data, qn, connection):\n             lhs = qn(name)\n         return connection.ops.field_cast_sql(db_type) % lhs\n \n-    def relabel_aliases(self, change_map, node=None):\n+    def relabel_aliases(self, change_map):\n         \"\"\"\n         Relabels the alias values of any children. 'change_map' is a dictionary\n         mapping old (current) alias values to the new values.\n         \"\"\"\n-        if not node:\n-            node = self\n-        for pos, child in enumerate(node.children):\n+        for pos, child in enumerate(self.children):\n             if hasattr(child, 'relabel_aliases'):\n+                # For example another WhereNode\n                 child.relabel_aliases(change_map)\n-            elif isinstance(child, tree.Node):\n-                self.relabel_aliases(change_map, child)\n             elif isinstance(child, (list, tuple)):\n-                if isinstance(child[0], (list, tuple)):\n-                    elt = list(child[0])\n-                    if elt[0] in change_map:\n-                        elt[0] = change_map[elt[0]]\n-                        node.children[pos] = (tuple(elt),) + child[1:]\n-                else:\n-                    child[0].relabel_aliases(change_map)\n-\n-                # Check if the query value also requires relabelling\n-                if hasattr(child[3], 'relabel_aliases'):\n-                    child[3].relabel_aliases(change_map)\n+                # tuple starting with Constraint\n+                child = (child[0].relabeled_clone(change_map),) + child[1:]\n+                if hasattr(child[3], 'relabeled_clone'):\n+                    child = (child[0], child[1], child[2]) + (\n+                        child[3].relabeled_clone(change_map),)\n+                self.children[pos] = child\n \n     def clone(self):\n         \"\"\"\n@@ -290,11 +288,10 @@ def clone(self):\n         clone = self.__class__._new_instance(\n             children=[], connector=self.connector, negated=self.negated)\n         for child in self.children:\n-            if isinstance(child, tuple):\n-                clone.children.append(\n-                    (child[0].clone(), child[1], child[2], child[3]))\n-            else:\n+            if hasattr(child, 'clone'):\n                 clone.children.append(child.clone())\n+            else:\n+                clone.children.append(child)\n         return clone\n \n class EmptyWhere(WhereNode):\n@@ -313,11 +310,6 @@ class EverythingNode(object):\n     def as_sql(self, qn=None, connection=None):\n         return '', []\n \n-    def relabel_aliases(self, change_map, node=None):\n-        return\n-\n-    def clone(self):\n-        return self\n \n class NothingNode(object):\n     \"\"\"\n@@ -326,11 +318,6 @@ class NothingNode(object):\n     def as_sql(self, qn=None, connection=None):\n         raise EmptyResultSet\n \n-    def relabel_aliases(self, change_map, node=None):\n-        return\n-\n-    def clone(self):\n-        return self\n \n class ExtraWhere(object):\n     def __init__(self, sqls, params):\n@@ -341,8 +328,6 @@ def as_sql(self, qn=None, connection=None):\n         sqls = [\"(%s)\" % sql for sql in self.sqls]\n         return \" AND \".join(sqls), list(self.params or ())\n \n-    def clone(self):\n-        return self\n \n class Constraint(object):\n     \"\"\"\n@@ -405,12 +390,11 @@ def process(self, lookup_type, value, connection):\n \n         return (self.alias, self.col, db_type), params\n \n-    def relabel_aliases(self, change_map):\n-        if self.alias in change_map:\n-            self.alias = change_map[self.alias]\n-\n-    def clone(self):\n-        new = Empty()\n-        new.__class__ = self.__class__\n-        new.alias, new.col, new.field = self.alias, self.col, self.field\n-        return new\n+    def relabeled_clone(self, change_map):\n+        if self.alias not in change_map:\n+            return self\n+        else:\n+            new = Empty()\n+            new.__class__ = self.__class__\n+            new.alias, new.col, new.field = change_map[self.alias], self.col, self.field\n+            return new"
        },
        {
            "sha": "6132544c2f5e8a054e5f3de3714e72daa3452d79",
            "filename": "tests/queries/models.py",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/d744c550d51955fd623897884446b7f34318e94d/tests%2Fqueries%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/d744c550d51955fd623897884446b7f34318e94d/tests%2Fqueries%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fqueries%2Fmodels.py?ref=d744c550d51955fd623897884446b7f34318e94d",
            "patch": "@@ -470,3 +470,8 @@ class Paragraph(models.Model):\n \n class Page(models.Model):\n     text = models.TextField()\n+\n+class MyObject(models.Model):\n+    parent = models.ForeignKey('self', null=True, blank=True, related_name='children')\n+    data = models.CharField(max_length=100)\n+    created_at = models.DateTimeField(auto_now_add=True)"
        },
        {
            "sha": "976a0ab05e654a86dc69d96060f6e201118d23a5",
            "filename": "tests/queries/tests.py",
            "status": "modified",
            "additions": 15,
            "deletions": 1,
            "changes": 16,
            "blob_url": "https://github.com/django/django/blob/d744c550d51955fd623897884446b7f34318e94d/tests%2Fqueries%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/d744c550d51955fd623897884446b7f34318e94d/tests%2Fqueries%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fqueries%2Ftests.py?ref=d744c550d51955fd623897884446b7f34318e94d",
            "patch": "@@ -25,7 +25,7 @@\n     SpecialCategory, OneToOneCategory, NullableName, ProxyCategory,\n     SingleObject, RelatedObject, ModelA, ModelD, Responsibility, Job,\n     JobResponsibilities, BaseA, Identifier, Program, Channel, Page, Paragraph,\n-    Chapter, Book)\n+    Chapter, Book, MyObject)\n \n \n class BaseQuerysetTest(TestCase):\n@@ -2661,3 +2661,17 @@ def test_ticket_12823(self):\n         self.assertNotIn(b1, q)\n         self.assertIn(b2, q)\n         self.assertIn(b3, q)\n+\n+class RelabelCloneTest(TestCase):\n+    def test_ticket_19964(self):\n+        my1 = MyObject.objects.create(data='foo')\n+        my1.parent = my1\n+        my1.save()\n+        my2 = MyObject.objects.create(data='bar', parent=my1)\n+        parents = MyObject.objects.filter(parent=F('id'))\n+        children = MyObject.objects.filter(parent__in=parents).exclude(parent=F('id'))\n+        self.assertEqual(list(parents), [my1])\n+        # Evaluating the children query (which has parents as part of it) does\n+        # not change results for the parents query.\n+        self.assertEqual(list(children), [my2])\n+        self.assertEqual(list(parents), [my1])"
        }
    ],
    "stats": {
        "total": 184,
        "additions": 79,
        "deletions": 105
    }
}