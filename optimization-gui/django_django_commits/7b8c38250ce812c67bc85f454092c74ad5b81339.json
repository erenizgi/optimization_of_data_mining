{
    "author": "spookylukey",
    "message": "Fixed #15057 - documented change in [14992]\n\nThanks to Tai Lee for the patch.\n\nRefs #15025, #7153\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15188 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "7b8c38250ce812c67bc85f454092c74ad5b81339",
    "files": [
        {
            "sha": "bb851b7820eb79aaa6683430f4c98e8f4681698b",
            "filename": "docs/intro/tutorial03.txt",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/7b8c38250ce812c67bc85f454092c74ad5b81339/docs%2Fintro%2Ftutorial03.txt",
            "raw_url": "https://github.com/django/django/raw/7b8c38250ce812c67bc85f454092c74ad5b81339/docs%2Fintro%2Ftutorial03.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fintro%2Ftutorial03.txt?ref=7b8c38250ce812c67bc85f454092c74ad5b81339",
            "patch": "@@ -415,9 +415,9 @@ like:\n \n The template system uses dot-lookup syntax to access variable attributes. In\n the example of ``{{ poll.question }}``, first Django does a dictionary lookup\n-on the object ``poll``. Failing that, it tries attribute lookup -- which works,\n-in this case. If attribute lookup had failed, it would've tried calling the\n-method ``question()`` on the poll object.\n+on the object ``poll``. Failing that, it tries an attribute lookup -- which\n+works, in this case. If attribute lookup had failed, it would've tried a\n+list-index lookup.\n \n Method-calling happens in the ``{% for %}`` loop: ``poll.choice_set.all`` is\n interpreted as the Python code ``poll.choice_set.all()``, which returns an"
        },
        {
            "sha": "0110a63ab692d792048812e18bf6c314c158b4fe",
            "filename": "docs/ref/templates/api.txt",
            "status": "modified",
            "additions": 31,
            "deletions": 26,
            "changes": 57,
            "blob_url": "https://github.com/django/django/blob/7b8c38250ce812c67bc85f454092c74ad5b81339/docs%2Fref%2Ftemplates%2Fapi.txt",
            "raw_url": "https://github.com/django/django/raw/7b8c38250ce812c67bc85f454092c74ad5b81339/docs%2Fref%2Ftemplates%2Fapi.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Ftemplates%2Fapi.txt?ref=7b8c38250ce812c67bc85f454092c74ad5b81339",
            "patch": "@@ -115,18 +115,15 @@ Variable names must consist of any letter (A-Z), any digit (0-9), an underscore\n or a dot.\n \n Dots have a special meaning in template rendering. A dot in a variable name\n-signifies **lookup**. Specifically, when the template system encounters a dot\n-in a variable name, it tries the following lookups, in this order:\n+signifies a **lookup**. Specifically, when the template system encounters a\n+dot in a variable name, it tries the following lookups, in this order:\n \n     * Dictionary lookup. Example: ``foo[\"bar\"]``\n     * Attribute lookup. Example: ``foo.bar``\n-    * Method call. Example: ``foo.bar()``\n     * List-index lookup. Example: ``foo[bar]``\n \n The template system uses the first lookup type that works. It's short-circuit\n-logic.\n-\n-Here are a few examples::\n+logic. Here are a few examples::\n \n     >>> from django.template import Context, Template\n     >>> t = Template(\"My name is {{ person.first_name }}.\")\n@@ -141,26 +138,34 @@ Here are a few examples::\n     >>> t.render(Context({\"person\": p}))\n     \"My name is Ron.\"\n \n-    >>> class PersonClass2:\n-    ...     def first_name(self):\n-    ...         return \"Samantha\"\n-    >>> p = PersonClass2()\n-    >>> t.render(Context({\"person\": p}))\n-    \"My name is Samantha.\"\n-\n     >>> t = Template(\"The first stooge in the list is {{ stooges.0 }}.\")\n     >>> c = Context({\"stooges\": [\"Larry\", \"Curly\", \"Moe\"]})\n     >>> t.render(c)\n     \"The first stooge in the list is Larry.\"\n \n-Method lookups are slightly more complex than the other lookup types. Here are\n-some things to keep in mind:\n+If any part of the variable is callable, the template system will try calling\n+it. Example::\n+\n+    >>> class PersonClass2:\n+    ...     def name(self):\n+    ...         return \"Samantha\"\n+    >>> t = Template(\"My name is {{ person.name }}.\")\n+    >>> t.render(Context({\"person\": PersonClass2}))\n+    \"My name is Samantha.\"\n+\n+.. versionchanged:: 1.3\n+    Previously, only variables that originated with an attribute lookup would\n+    be called by the template system. This change was made for consistency\n+    across lookup types.\n+\n+Callable variables are slightly more complex than variables which only require\n+straight lookups. Here are some things to keep in mind:\n \n-    * If, during the method lookup, a method raises an exception, the exception\n-      will be propagated, unless the exception has an attribute\n+    * If the variable raises an exception when called, the exception will be\n+      propagated, unless the exception has an attribute\n       ``silent_variable_failure`` whose value is ``True``. If the exception\n-      *does* have a ``silent_variable_failure`` attribute, the variable will\n-      render as an empty string. Example::\n+      *does* have a ``silent_variable_failure`` attribute whose value is\n+      ``True``, the variable will render as an empty string. Example::\n \n         >>> t = Template(\"My name is {{ person.first_name }}.\")\n         >>> class PersonClass3:\n@@ -187,21 +192,21 @@ some things to keep in mind:\n       with Django model objects, any ``DoesNotExist`` exception will fail\n       silently.\n \n-    * A method call will only work if the method has no required arguments.\n-      Otherwise, the system will move to the next lookup type (list-index\n-      lookup).\n+    * A variable can only be called if it has no required arguments. Otherwise,\n+      the system will return an empty string.\n \n-    * Obviously, some methods have side effects, and it'd be either foolish or\n-      a security hole to allow the template system to access them.\n+    * Obviously, there can be side effects when calling some variables, and\n+      it'd be either foolish or a security hole to allow the template system\n+      to access them.\n \n       A good example is the :meth:`~django.db.models.Model.delete` method on\n       each Django model object. The template system shouldn't be allowed to do\n       something like this::\n \n         I will now delete this valuable data. {{ data.delete }}\n \n-      To prevent this, set a function attribute ``alters_data`` on the method.\n-      The template system won't execute a method if the method has\n+      To prevent this, set an ``alters_data`` attribute on the callable\n+      variable. The template system won't call a variable if it has\n       ``alters_data=True`` set. The dynamically-generated\n       :meth:`~django.db.models.Model.delete` and\n       :meth:`~django.db.models.Model.save` methods on Django model objects get"
        },
        {
            "sha": "e05b502450a493c0116856b353f4e34cfb953405",
            "filename": "docs/releases/1.3.txt",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/django/django/blob/7b8c38250ce812c67bc85f454092c74ad5b81339/docs%2Freleases%2F1.3.txt",
            "raw_url": "https://github.com/django/django/raw/7b8c38250ce812c67bc85f454092c74ad5b81339/docs%2Freleases%2F1.3.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.3.txt?ref=7b8c38250ce812c67bc85f454092c74ad5b81339",
            "patch": "@@ -392,7 +392,23 @@ if you need to instantiate an empty ``FormSet``, don't pass in the data or use\n     >>> formset = ArticleFormSet()\n     >>> formset = ArticleFormSet(data=None)\n \n+Callables in templates\n+~~~~~~~~~~~~~~~~~~~~~~\n+\n+Previously, a callable in a template would only be called automatically as part\n+of the variable resolution process if it was retrieved via attribute\n+lookup. This was an inconsistency that could result in confusing and unhelpful\n+behaviour::\n+\n+    >>> Template(\"{{ user.get_full_name }}\").render(Context({'user': user}))\n+    u'Joe Bloggs'\n+    >>> Template(\"{{ full_name }}\").render(Context({'full_name': user.get_full_name}))\n+    u'&lt;bound method User.get_full_name of &lt;...\n \n+This has been resolved in Django 1.3 - the result in both cases will be ``u'Joe\n+Bloggs'``. Although the previous behaviour was not useful for a template language\n+designed for web designers, and was never deliberately supported, it is possible\n+that some templates may be broken by this change.\n \n .. _deprecated-features-1.3:\n "
        }
    ],
    "stats": {
        "total": 79,
        "additions": 50,
        "deletions": 29
    }
}