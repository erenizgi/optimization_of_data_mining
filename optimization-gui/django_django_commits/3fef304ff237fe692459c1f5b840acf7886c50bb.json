{
    "author": "akaariai",
    "message": "Refactored negated IS NULL handling\n\nThis one cleaned up add_filter() negated filter generation. As a side\neffect split_exclude() was cleaned up, too.\n\nRefs #19849",
    "sha": "3fef304ff237fe692459c1f5b840acf7886c50bb",
    "files": [
        {
            "sha": "45b9cb202bca86c7fa480ff01b32576bed8e86db",
            "filename": "django/db/models/sql/expressions.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/3fef304ff237fe692459c1f5b840acf7886c50bb/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py",
            "raw_url": "https://github.com/django/django/raw/3fef304ff237fe692459c1f5b840acf7886c50bb/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py?ref=3fef304ff237fe692459c1f5b840acf7886c50bb",
            "patch": "@@ -52,10 +52,10 @@ def prepare_leaf(self, node, query, allow_joins):\n                 field, source, opts, join_list, path = query.setup_joins(\n                     field_list, query.get_meta(),\n                     query.get_initial_alias(), self.reuse)\n-                col, _, join_list = query.trim_joins(source, join_list, path)\n+                target, _, join_list = query.trim_joins(source, join_list, path)\n                 if self.reuse is not None:\n                     self.reuse.update(join_list)\n-                self.cols.append((node, (join_list[-1], col)))\n+                self.cols.append((node, (join_list[-1], target.column)))\n             except FieldDoesNotExist:\n                 raise FieldError(\"Cannot resolve keyword %r into field. \"\n                                  \"Choices are: %s\" % (self.name,"
        },
        {
            "sha": "a0e3225c182907bd3a1d479a66d407500face3cd",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 29,
            "deletions": 53,
            "changes": 82,
            "blob_url": "https://github.com/django/django/blob/3fef304ff237fe692459c1f5b840acf7886c50bb/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/3fef304ff237fe692459c1f5b840acf7886c50bb/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=3fef304ff237fe692459c1f5b840acf7886c50bb",
            "patch": "@@ -1093,14 +1093,14 @@ def add_aggregate(self, aggregate, model, alias, is_summary):\n                 field_list, opts, self.get_initial_alias())\n \n             # Process the join chain to see if it can be trimmed\n-            col, _, join_list = self.trim_joins(source, join_list, path)\n+            target, _, join_list = self.trim_joins(source, join_list, path)\n \n             # If the aggregate references a model or field that requires a join,\n             # those joins must be LEFT OUTER - empty join rows must be returned\n             # in order for zeros to be returned for those aggregates.\n             self.promote_joins(join_list, True)\n \n-            col = (join_list[-1], col)\n+            col = (join_list[-1], target.column)\n         else:\n             # The simplest cases. No joins required -\n             # just reference the provided column alias.\n@@ -1112,7 +1112,7 @@ def add_aggregate(self, aggregate, model, alias, is_summary):\n         aggregate.add_to_query(self, alias, col=col, source=source, is_summary=is_summary)\n \n     def add_filter(self, filter_expr, connector=AND, negate=False,\n-            can_reuse=None, force_having=False):\n+                   can_reuse=None, force_having=False):\n         \"\"\"\n         Add a single filter to the query. The 'filter_expr' is a pair:\n         (filter_string, value). E.g. ('name__contains', 'fred')\n@@ -1214,46 +1214,30 @@ def add_filter(self, filter_expr, connector=AND, negate=False,\n         # the far end (fewer tables in a query is better). Note that join\n         # promotion must happen before join trimming to have the join type\n         # information available when reusing joins.\n-        col, alias, join_list = self.trim_joins(target, join_list, path)\n+        target, alias, join_list = self.trim_joins(target, join_list, path)\n \n         if having_clause or force_having:\n-            if (alias, col) not in self.group_by:\n-                self.group_by.append((alias, col))\n-            self.having.add((Constraint(alias, col, field), lookup_type, value),\n+            if (alias, target.column) not in self.group_by:\n+                self.group_by.append((alias, target.column))\n+            self.having.add((Constraint(alias, target.column, field), lookup_type, value),\n                 connector)\n         else:\n-            self.where.add((Constraint(alias, col, field), lookup_type, value),\n+            self.where.add((Constraint(alias, target.column, field), lookup_type, value),\n                 connector)\n \n         if negate:\n             self.promote_joins(join_list)\n-            if lookup_type != 'isnull':\n-                if len(join_list) > 1:\n-                    for alias in join_list:\n-                        if self.alias_map[alias].join_type == self.LOUTER:\n-                            j_col = self.alias_map[alias].rhs_join_col\n-                            # The join promotion logic should never produce\n-                            # a LOUTER join for the base join - assert that.\n-                            assert j_col is not None\n-                            entry = self.where_class()\n-                            entry.add(\n-                                (Constraint(alias, j_col, None), 'isnull', True),\n-                                AND\n-                            )\n-                            entry.negate()\n-                            self.where.add(entry, AND)\n-                            break\n-                if self.is_nullable(field):\n-                    # In SQL NULL = anyvalue returns unknown, and NOT unknown\n-                    # is still unknown. However, in Python None = anyvalue is False\n-                    # (and not False is True...), and we want to return this Python's\n-                    # view of None handling. So we need to specifically exclude the\n-                    # NULL values, and because we are inside NOT branch they will\n-                    # be included in the final resultset. We are essentially creating\n-                    # SQL like this here: NOT (col IS NOT NULL), where the first NOT\n-                    # is added in upper layers of the code.\n-                    self.where.add((Constraint(alias, col, None), 'isnull', False), AND)\n-\n+            if lookup_type != 'isnull' and (self.is_nullable(target) or len(join_list) > 1):\n+                # The condition added here will be SQL like this:\n+                # NOT (col IS NOT NULL), where the first NOT is added in\n+                # upper layers of code. The reason for addition is that if col\n+                # is null, then col != someval will result in SQL \"unknown\"\n+                # which isn't the same as in Python. The Python None handling\n+                # is wanted, and it can be gotten by\n+                # (col IS NULL OR col != someval)\n+                #   <=>\n+                # NOT (col IS NOT NULL AND col = someval).\n+                self.where.add((Constraint(alias, target.column, None), 'isnull', False), AND)\n \n     def add_q(self, q_object, used_aliases=None, force_having=False):\n         \"\"\"\n@@ -1437,7 +1421,7 @@ def trim_joins(self, target, joins, path):\n         is the full list of join aliases. The 'path' contain the PathInfos\n         used to create the joins.\n \n-        Returns the final active column and table alias and the new active\n+        Returns the final target field and table alias and the new active\n         joins.\n \n         We will always trim any direct join if we have the target column\n@@ -1451,7 +1435,7 @@ def trim_joins(self, target, joins, path):\n                 self.unref_alias(joins.pop())\n             else:\n                 break\n-        return target.column, joins[-1], joins\n+        return target, joins[-1], joins\n \n     def split_exclude(self, filter_expr, prefix, can_reuse, names_with_path):\n         \"\"\"\n@@ -1465,8 +1449,8 @@ def split_exclude(self, filter_expr, prefix, can_reuse, names_with_path):\n         can_reuse is a set of joins usable for filters in the original query.\n \n         We will turn this into equivalent of:\n-            WHERE pk NOT IN (SELECT parent_id FROM thetable\n-                             WHERE name = 'foo' AND parent_id IS NOT NULL)\n+            WHERE NOT (pk IN (SELECT parent_id FROM thetable\n+                              WHERE name = 'foo' AND parent_id IS NOT NULL))\n \n         It might be worth it to consider using WHERE NOT EXISTS as that has\n         saner null handling, and is easier for the backend's optimizer to\n@@ -1484,8 +1468,9 @@ def split_exclude(self, filter_expr, prefix, can_reuse, names_with_path):\n         # since we are adding a IN <subquery> clause. This prevents the\n         # database from tripping over IN (...,NULL,...) selects and returning\n         # nothing\n-        alias, col = query.select[0].col\n-        query.where.add((Constraint(alias, col, None), 'isnull', False), AND)\n+        if self.is_nullable(query.select[0].field):\n+            alias, col = query.select[0].col\n+            query.where.add((Constraint(alias, col, None), 'isnull', False), AND)\n \n         # Still make sure that the trimmed parts in the inner query and\n         # trimmed prefix are in sync. So, use the trimmed_joins to make sure\n@@ -1506,15 +1491,6 @@ def split_exclude(self, filter_expr, prefix, can_reuse, names_with_path):\n         self.add_filter(('%s__in' % trimmed_prefix, query), negate=True,\n                         can_reuse=can_reuse)\n \n-        # If there's more than one join in the inner query, we need to also\n-        # handle the possibility that the earlier joins don't match anything\n-        # by adding a comparison to NULL (e.g. in\n-        #     Tag.objects.exclude(parent__parent__name='t1')\n-        # a tag with no parent would otherwise be overlooked).\n-        if trimmed_joins > 1:\n-            self.add_filter(('%s__isnull' % trimmed_prefix, False), negate=True,\n-                            can_reuse=can_reuse)\n-\n     def set_empty(self):\n         self.where = EmptyWhere()\n         self.having = EmptyWhere()\n@@ -1889,13 +1865,13 @@ def trim_start(self, names_with_path):\n                 if self.alias_map[peek].join_type == self.LOUTER:\n                     # Back up one level and break\n                     select_alias = self.tables[join_pos]\n-                    select_col = path.from_field.column\n+                    select_field = path.from_field\n                     break\n                 select_alias = self.tables[join_pos + 1]\n-                select_col = path.to_field.column\n+                select_field = path.to_field\n                 self.unref_alias(self.tables[join_pos])\n                 join_pos += 1\n-        self.select = [SelectInfo((select_alias, select_col), None)]\n+        self.select = [SelectInfo((select_alias, select_field.column), select_field)]\n         self.remove_inherited_models()\n         return join_pos\n "
        },
        {
            "sha": "5cb23cfb9c8c8f3eed799597c4d4a5ddfd52cf6f",
            "filename": "tests/regressiontests/nested_foreign_keys/tests.py",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/3fef304ff237fe692459c1f5b840acf7886c50bb/tests%2Fregressiontests%2Fnested_foreign_keys%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/3fef304ff237fe692459c1f5b840acf7886c50bb/tests%2Fregressiontests%2Fnested_foreign_keys%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fnested_foreign_keys%2Ftests.py?ref=3fef304ff237fe692459c1f5b840acf7886c50bb",
            "patch": "@@ -71,6 +71,12 @@ def testInheritanceNullFK(self):\n         self.assertEqual(Event.objects.filter(screeningnullfk__movie=self.movie).count(), 1)\n         self.assertEqual(Event.objects.exclude(screeningnullfk__movie=self.movie).count(), 2)\n \n+    def test_null_exclude(self):\n+        screening = ScreeningNullFK.objects.create(movie=None)\n+        ScreeningNullFK.objects.create(movie=self.movie)\n+        self.assertEqual(\n+            list(ScreeningNullFK.objects.exclude(movie__id=self.movie.pk)),\n+            [screening])\n \n     # This test failed in #16715 because in some cases INNER JOIN was selected\n     # for the second foreign key relation instead of LEFT OUTER JOIN."
        }
    ],
    "stats": {
        "total": 92,
        "additions": 37,
        "deletions": 55
    }
}