{
    "author": "andrewgodwin",
    "message": "Add some field schema alteration methods and tests.",
    "sha": "959a3f9791d780062c4efe8765404a8ef95e87f0",
    "files": [
        {
            "sha": "0c1905c6b85cfe8855b72c9d5b7269b520248013",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/959a3f9791d780062c4efe8765404a8ef95e87f0/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/959a3f9791d780062c4efe8765404a8ef95e87f0/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=959a3f9791d780062c4efe8765404a8ef95e87f0",
            "patch": "@@ -419,6 +419,9 @@ class BaseDatabaseFeatures(object):\n     # Can we roll back DDL in a transaction?\n     can_rollback_ddl = False\n \n+    # Can we issue more than one ALTER COLUMN clause in an ALTER TABLE?\n+    supports_combined_alters = False\n+\n     def __init__(self, connection):\n         self.connection = connection\n "
        },
        {
            "sha": "ebb4109f794d107756e65389fe141eea18164606",
            "filename": "django/db/backends/postgresql_psycopg2/base.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/959a3f9791d780062c4efe8765404a8ef95e87f0/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/959a3f9791d780062c4efe8765404a8ef95e87f0/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py?ref=959a3f9791d780062c4efe8765404a8ef95e87f0",
            "patch": "@@ -85,6 +85,7 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     supports_tablespaces = True\n     can_distinct_on_fields = True\n     can_rollback_ddl = True\n+    supports_combined_alters = True\n \n class DatabaseWrapper(BaseDatabaseWrapper):\n     vendor = 'postgresql'"
        },
        {
            "sha": "bf838d20944f242676b12edbc21489af4c8e4f15",
            "filename": "django/db/backends/schema.py",
            "status": "modified",
            "additions": 224,
            "deletions": 40,
            "changes": 264,
            "blob_url": "https://github.com/django/django/blob/959a3f9791d780062c4efe8765404a8ef95e87f0/django%2Fdb%2Fbackends%2Fschema.py",
            "raw_url": "https://github.com/django/django/raw/959a3f9791d780062c4efe8765404a8ef95e87f0/django%2Fdb%2Fbackends%2Fschema.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fschema.py?ref=959a3f9791d780062c4efe8765404a8ef95e87f0",
            "patch": "@@ -5,6 +5,7 @@\n from django.db import transaction\n from django.db.utils import load_backend\n from django.utils.log import getLogger\n+from django.db.models.fields.related import ManyToManyField\n \n logger = getLogger('django.db.backends.schema')\n \n@@ -29,11 +30,15 @@ class BaseDatabaseSchemaEditor(object):\n     sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n     sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n \n-    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(definition)s\"\n+    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n+    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n     sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n     sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n     sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n-    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE;\"\n+    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n+    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n+    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n+    sql_rename_column = \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n \n     sql_create_check = \"ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n     sql_delete_check = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n@@ -91,6 +96,59 @@ def execute(self, sql, params=[], fetch_results=False):\n     def quote_name(self, name):\n         return self.connection.ops.quote_name(name)\n \n+    # Field <-> database mapping functions\n+\n+    def column_sql(self, model, field, include_default=False):\n+        \"\"\"\n+        Takes a field and returns its column definition.\n+        The field must already have had set_attributes_from_name called.\n+        \"\"\"\n+        # Get the column's type and use that as the basis of the SQL\n+        sql = field.db_type(connection=self.connection)\n+        params = []\n+        # Check for fields that aren't actually columns (e.g. M2M)\n+        if sql is None:\n+            return None\n+        # Optionally add the tablespace if it's an implicitly indexed column\n+        tablespace = field.db_tablespace or model._meta.db_tablespace\n+        if tablespace and self.connection.features.supports_tablespaces and field.unique:\n+            sql += \" %s\" % self.connection.ops.tablespace_sql(tablespace, inline=True)\n+        # Work out nullability\n+        null = field.null\n+        # Oracle treats the empty string ('') as null, so coerce the null\n+        # option whenever '' is a possible value.\n+        if (field.empty_strings_allowed and not field.primary_key and\n+                self.connection.features.interprets_empty_strings_as_nulls):\n+            null = True\n+        if null:\n+            sql += \" NULL\"\n+        else:\n+            sql += \" NOT NULL\"\n+        # Primary key/unique outputs\n+        if field.primary_key:\n+            sql += \" PRIMARY KEY\"\n+        elif field.unique:\n+            sql += \" UNIQUE\"\n+        # If we were told to include a default value, do so\n+        if include_default:\n+            sql += \" DEFAULT %s\"\n+            params += [self.effective_default(field)]\n+        # Return the sql\n+        return sql, params\n+\n+    def effective_default(self, field):\n+        \"Returns a field's effective database default value\"\n+        if field.has_default():\n+            default = field.get_default()\n+        elif not field.null and field.blank and field.empty_strings_allowed:\n+            default = \"\"\n+        else:\n+            default = None\n+        # If it's a callable, call it\n+        if callable(default):\n+            default = default()\n+        return default\n+\n     # Actions\n \n     def create_model(self, model):\n@@ -100,18 +158,20 @@ def create_model(self, model):\n         \"\"\"\n         # Do nothing if this is an unmanaged or proxy model\n         if not model._meta.managed or model._meta.proxy:\n-            return [], {}\n+            return\n         # Create column SQL, add FK deferreds if needed\n         column_sqls = []\n+        params = []\n         for field in model._meta.local_fields:\n             # SQL\n-            definition = self.column_sql(model, field)\n+            definition, extra_params = self.column_sql(model, field)\n             if definition is None:\n                 continue\n             column_sqls.append(\"%s %s\" % (\n                 self.quote_name(field.column),\n                 definition,\n             ))\n+            params.extend(extra_params)\n             # FK\n             if field.rel:\n                 to_table = field.rel.to._meta.db_table\n@@ -134,45 +194,169 @@ def create_model(self, model):\n             \"table\": model._meta.db_table,\n             \"definition\": \", \".join(column_sqls)\n         }\n-        self.execute(sql)\n+        self.execute(sql, params)\n \n-    def column_sql(self, model, field, include_default=False):\n+    def delete_model(self, model):\n         \"\"\"\n-        Takes a field and returns its column definition.\n-        The field must already have had set_attributes_from_name called.\n+        Deletes a model from the database.\n         \"\"\"\n-        # Get the column's type and use that as the basis of the SQL\n-        sql = field.db_type(connection=self.connection)\n-        # Check for fields that aren't actually columns (e.g. M2M)\n-        if sql is None:\n-            return None\n-        # Optionally add the tablespace if it's an implicitly indexed column\n-        tablespace = field.db_tablespace or model._meta.db_tablespace\n-        if tablespace and self.connection.features.supports_tablespaces and field.unique:\n-            sql += \" %s\" % self.connection.ops.tablespace_sql(tablespace, inline=True)\n-        # Work out nullability\n-        null = field.null\n-        # Oracle treats the empty string ('') as null, so coerce the null\n-        # option whenever '' is a possible value.\n-        if (field.empty_strings_allowed and not field.primary_key and\n-                self.connection.features.interprets_empty_strings_as_nulls):\n-            null = True\n-        if null:\n-            sql += \" NULL\"\n-        else:\n-            sql += \" NOT NULL\"\n-        # Primary key/unique outputs\n-        if field.primary_key:\n-            sql += \" PRIMARY KEY\"\n-        elif field.unique:\n-            sql += \" UNIQUE\"\n-        # If we were told to include a default value, do so\n-        if include_default:\n-            raise NotImplementedError()\n-        # Return the sql\n-        return sql\n-\n-    def delete_model(self, model):\n+        # Do nothing if this is an unmanaged or proxy model\n+        if not model._meta.managed or model._meta.proxy:\n+            return\n+        # Delete the table\n         self.execute(self.sql_delete_table % {\n             \"table\": self.quote_name(model._meta.db_table),\n         })\n+\n+    def create_field(self, model, field, keep_default=False):\n+        \"\"\"\n+        Creates a field on a model.\n+        Usually involves adding a column, but may involve adding a\n+        table instead (for M2M fields)\n+        \"\"\"\n+        # Special-case implicit M2M tables\n+        if isinstance(field, ManyToManyField) and field.rel.through._meta.auto_created:\n+            return self.create_model(field.rel.through)\n+        # Get the column's definition\n+        definition, params = self.column_sql(model, field, include_default=True)\n+        # It might not actually have a column behind it\n+        if definition is None:\n+            return\n+        # Build the SQL and run it\n+        sql = self.sql_create_column % {\n+            \"table\": self.quote_name(model._meta.db_table),\n+            \"column\": self.quote_name(field.column),\n+            \"definition\": definition,\n+        }\n+        self.execute(sql, params)\n+        # Drop the default if we need to\n+        # (Django usually does not use in-database defaults)\n+        if not keep_default and field.default is not None:\n+            sql = self.sql_alter_column % {\n+                \"table\": self.quote_name(model._meta.db_table),\n+                \"changes\": self.sql_alter_column_no_default % {\n+                    \"column\": self.quote_name(field.column),\n+                }\n+            }\n+        # Add any FK constraints later\n+        if field.rel:\n+            to_table = field.rel.to._meta.db_table\n+            to_column = field.rel.to._meta.get_field(field.rel.field_name).column\n+            self.deferred_sql.append(\n+                self.sql_create_fk % {\n+                    \"name\": '%s_refs_%s_%x' % (\n+                        field.column,\n+                        to_column,\n+                        abs(hash((model._meta.db_table, to_table)))\n+                    ),\n+                    \"table\": self.quote_name(model._meta.db_table),\n+                    \"column\": self.quote_name(field.column),\n+                    \"to_table\": self.quote_name(to_table),\n+                    \"to_column\": self.quote_name(to_column),\n+                }\n+            )\n+\n+    def delete_field(self, model, field):\n+        \"\"\"\n+        Removes a field from a model. Usually involves deleting a column,\n+        but for M2Ms may involve deleting a table.\n+        \"\"\"\n+        # Special-case implicit M2M tables\n+        if isinstance(field, ManyToManyField) and field.rel.through._meta.auto_created:\n+            return self.delete_model(field.rel.through)\n+        # Get the column's definition\n+        definition, params = self.column_sql(model, field)\n+        # It might not actually have a column behind it\n+        if definition is None:\n+            return\n+        # Delete the column\n+        sql = self.sql_delete_column % {\n+            \"table\": self.quote_name(model._meta.db_table),\n+            \"column\": self.quote_name(field.column),\n+        }\n+        self.execute(sql)\n+\n+    def alter_field(self, model, old_field, new_field):\n+        \"\"\"\n+        Allows a field's type, uniqueness, nullability, default, column,\n+        constraints etc. to be modified.\n+        Requires a copy of the old field as well so we can only perform\n+        changes that are required.\n+        \"\"\"\n+        # Ensure this field is even column-based\n+        old_type = old_field.db_type(connection=self.connection)\n+        new_type = new_field.db_type(connection=self.connection)\n+        if old_type is None and new_type is None:\n+            # TODO: Handle M2M fields being repointed\n+            return\n+        elif old_type is None or new_type is None:\n+            raise ValueError(\"Cannot alter field %s into %s - they are not compatible types\" % (\n+                    old_field,\n+                    new_field,\n+                ))\n+        # First, have they renamed the column?\n+        if old_field.column != new_field.column:\n+            self.execute(self.sql_rename_column % {\n+                \"table\": self.quote_name(model._meta.db_table),\n+                \"old_column\": self.quote_name(old_field.column),\n+                \"new_column\": self.quote_name(new_field.column),\n+            })\n+        # Next, start accumulating actions to do\n+        actions = []\n+        # Type change?\n+        if old_type != new_type:\n+            actions.append((\n+                self.sql_alter_column_type % {\n+                    \"column\": self.quote_name(new_field.column),\n+                    \"type\": new_type,\n+                },\n+                [],\n+            ))\n+        # Default change?\n+        old_default = self.effective_default(old_field)\n+        new_default = self.effective_default(new_field)\n+        if old_default != new_default:\n+            if new_default is None:\n+                actions.append((\n+                    self.sql_alter_column_no_default % {\n+                        \"column\": self.quote_name(new_field.column),\n+                    },\n+                    [],\n+                ))\n+            else:\n+                actions.append((\n+                    self.sql_alter_column_default % {\n+                        \"column\": self.quote_name(new_field.column),\n+                        \"default\": \"%s\",\n+                    },\n+                    [new_default],\n+                ))\n+        # Nullability change?\n+        if old_field.null != new_field.null:\n+            if new_field.null:\n+                actions.append((\n+                    self.sql_alter_column_null % {\n+                        \"column\": self.quote_name(new_field.column),\n+                    },\n+                    [],\n+                ))\n+            else:\n+                actions.append((\n+                    self.sql_alter_column_null % {\n+                        \"column\": self.quote_name(new_field.column),\n+                    },\n+                    [],\n+                ))\n+        # Combine actions together if we can (e.g. postgres)\n+        if self.connection.features.supports_combined_alters:\n+            sql, params = tuple(zip(*actions))\n+            actions = [(\", \".join(sql), params)]\n+        # Apply those actions\n+        for sql, params in actions:\n+            self.execute(\n+                self.sql_alter_column % {\n+                    \"table\": self.quote_name(model._meta.db_table),\n+                    \"changes\": sql,\n+                },\n+                params,\n+            )"
        },
        {
            "sha": "83b2dabd45ae2bd995182079c7c41fbb7b92e2de",
            "filename": "tests/modeltests/schema/tests.py",
            "status": "modified",
            "additions": 73,
            "deletions": 1,
            "changes": 74,
            "blob_url": "https://github.com/django/django/blob/959a3f9791d780062c4efe8765404a8ef95e87f0/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/959a3f9791d780062c4efe8765404a8ef95e87f0/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fschema%2Ftests.py?ref=959a3f9791d780062c4efe8765404a8ef95e87f0",
            "patch": "@@ -2,8 +2,9 @@\n import copy\n import datetime\n from django.test import TestCase\n-from django.db.models.loading import cache\n from django.db import connection, DatabaseError, IntegrityError\n+from django.db.models.fields import IntegerField, TextField\n+from django.db.models.loading import cache\n from .models import Author, Book\n \n \n@@ -18,6 +19,8 @@ class SchemaTests(TestCase):\n \n     models = [Author, Book]\n \n+    # Utility functions\n+\n     def setUp(self):\n         # Make sure we're in manual transaction mode\n         connection.commit_unless_managed()\n@@ -51,6 +54,18 @@ def tearDown(self):\n         cache.app_store = self.old_app_store\n         cache._get_models_cache = {}\n \n+    def column_classes(self, model):\n+        cursor = connection.cursor()\n+        return dict(\n+            (d[0], (connection.introspection.get_field_type(d[1], d), d))\n+            for d in connection.introspection.get_table_description(\n+                cursor,\n+                model._meta.db_table,\n+            )\n+        )\n+\n+    # Tests\n+\n     def test_creation_deletion(self):\n         \"\"\"\n         Tries creating a model's table, and then deleting it.\n@@ -100,3 +115,60 @@ def test_creation_fk(self):\n                 pub_date = datetime.datetime.now(),\n             )\n             connection.commit()\n+\n+    def test_create_field(self):\n+        \"\"\"\n+        Tests adding fields to models\n+        \"\"\"\n+        # Create the table\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.create_model(Author)\n+        editor.commit()\n+        # Ensure there's no age field\n+        columns = self.column_classes(Author)\n+        self.assertNotIn(\"age\", columns)\n+        # Alter the name field to a TextField\n+        new_field = IntegerField(null=True)\n+        new_field.set_attributes_from_name(\"age\")\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.create_field(\n+            Author,\n+            new_field,\n+        )\n+        editor.commit()\n+        # Ensure the field is right afterwards\n+        columns = self.column_classes(Author)\n+        self.assertEqual(columns['age'][0], \"IntegerField\")\n+        self.assertEqual(columns['age'][1][6], True)\n+\n+    def test_alter(self):\n+        \"\"\"\n+        Tests simple altering of fields\n+        \"\"\"\n+        # Create the table\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.create_model(Author)\n+        editor.commit()\n+        # Ensure the field is right to begin with\n+        columns = self.column_classes(Author)\n+        self.assertEqual(columns['name'][0], \"CharField\")\n+        self.assertEqual(columns['name'][1][3], 255)\n+        self.assertEqual(columns['name'][1][6], False)\n+        # Alter the name field to a TextField\n+        new_field = TextField(null=True)\n+        new_field.set_attributes_from_name(\"name\")\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.alter_field(\n+            Author,\n+            Author._meta.get_field_by_name(\"name\")[0],\n+            new_field,\n+        )\n+        editor.commit()\n+        # Ensure the field is right afterwards\n+        columns = self.column_classes(Author)\n+        self.assertEqual(columns['name'][0], \"TextField\")\n+        self.assertEqual(columns['name'][1][6], True)"
        }
    ],
    "stats": {
        "total": 342,
        "additions": 301,
        "deletions": 41
    }
}