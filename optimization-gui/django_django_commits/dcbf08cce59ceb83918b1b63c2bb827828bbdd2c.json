{
    "author": "claudep",
    "message": "Fixed #19094 -- Improved FakePayload to support write, len and string input\n\nThanks Ondrej SlintÃ¡k for the suggestion.",
    "sha": "dcbf08cce59ceb83918b1b63c2bb827828bbdd2c",
    "files": [
        {
            "sha": "6d12321075642b4a835e64a2524571ecbad424ab",
            "filename": "django/test/client.py",
            "status": "modified",
            "additions": 19,
            "deletions": 3,
            "changes": 22,
            "blob_url": "https://github.com/django/django/blob/dcbf08cce59ceb83918b1b63c2bb827828bbdd2c/django%2Ftest%2Fclient.py",
            "raw_url": "https://github.com/django/django/raw/dcbf08cce59ceb83918b1b63c2bb827828bbdd2c/django%2Ftest%2Fclient.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Fclient.py?ref=dcbf08cce59ceb83918b1b63c2bb827828bbdd2c",
            "patch": "@@ -43,18 +43,34 @@ class FakePayload(object):\n     length. This makes sure that views can't do anything under the test client\n     that wouldn't work in Real Life.\n     \"\"\"\n-    def __init__(self, content):\n-        self.__content = BytesIO(content)\n-        self.__len = len(content)\n+    def __init__(self, content=None):\n+        self.__content = BytesIO()\n+        self.__len = 0\n+        self.read_started = False\n+        if content is not None:\n+            self.write(content)\n+\n+    def __len__(self):\n+        return self.__len\n \n     def read(self, num_bytes=None):\n+        if not self.read_started:\n+            self.__content.seek(0)\n+            self.read_started = True\n         if num_bytes is None:\n             num_bytes = self.__len or 0\n         assert self.__len >= num_bytes, \"Cannot read more than the available bytes from the HTTP incoming data.\"\n         content = self.__content.read(num_bytes)\n         self.__len -= num_bytes\n         return content\n \n+    def write(self, content):\n+        if self.read_started:\n+            raise ValueError(\"Unable to write a payload after he's been read\")\n+        content = force_bytes(content)\n+        self.__content.write(content)\n+        self.__len += len(content)\n+\n \n class ClientHandler(BaseHandler):\n     \"\"\""
        },
        {
            "sha": "918f77d73c0ef0073f64c9c5955e39df90b65ed9",
            "filename": "tests/regressiontests/file_uploads/tests.py",
            "status": "modified",
            "additions": 18,
            "deletions": 24,
            "changes": 42,
            "blob_url": "https://github.com/django/django/blob/dcbf08cce59ceb83918b1b63c2bb827828bbdd2c/tests%2Fregressiontests%2Ffile_uploads%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/dcbf08cce59ceb83918b1b63c2bb827828bbdd2c/tests%2Fregressiontests%2Ffile_uploads%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ffile_uploads%2Ftests.py?ref=dcbf08cce59ceb83918b1b63c2bb827828bbdd2c",
            "patch": "@@ -62,22 +62,20 @@ def test_large_upload(self):\n \n     def test_base64_upload(self):\n         test_string = \"This data will be transmitted base64-encoded.\"\n-        payload = \"\\r\\n\".join([\n+        payload = client.FakePayload(\"\\r\\n\".join([\n             '--' + client.BOUNDARY,\n             'Content-Disposition: form-data; name=\"file\"; filename=\"test.txt\"',\n             'Content-Type: application/octet-stream',\n             'Content-Transfer-Encoding: base64',\n-            '',\n-            base64.b64encode(force_bytes(test_string)).decode('ascii'),\n-            '--' + client.BOUNDARY + '--',\n-            '',\n-        ]).encode('utf-8')\n+            '',]))\n+        payload.write(b\"\\r\\n\" + base64.b64encode(force_bytes(test_string)) + b\"\\r\\n\")\n+        payload.write('--' + client.BOUNDARY + '--\\r\\n')\n         r = {\n             'CONTENT_LENGTH': len(payload),\n             'CONTENT_TYPE':   client.MULTIPART_CONTENT,\n             'PATH_INFO':      \"/file_uploads/echo_content/\",\n             'REQUEST_METHOD': 'POST',\n-            'wsgi.input':     client.FakePayload(payload),\n+            'wsgi.input':     payload,\n         }\n         response = self.client.request(**r)\n         received = json.loads(response.content.decode('utf-8'))\n@@ -126,27 +124,23 @@ def test_dangerous_file_names(self):\n             \"../..\\\\hax0rd.txt\"         # Relative path, mixed.\n         ]\n \n-        payload = []\n+        payload = client.FakePayload()\n         for i, name in enumerate(scary_file_names):\n-            payload.extend([\n+            payload.write('\\r\\n'.join([\n                 '--' + client.BOUNDARY,\n                 'Content-Disposition: form-data; name=\"file%s\"; filename=\"%s\"' % (i, name),\n                 'Content-Type: application/octet-stream',\n                 '',\n-                'You got pwnd.'\n-            ])\n-        payload.extend([\n-            '--' + client.BOUNDARY + '--',\n-            '',\n-        ])\n+                'You got pwnd.\\r\\n'\n+            ]))\n+        payload.write('\\r\\n--' + client.BOUNDARY + '--\\r\\n')\n \n-        payload = \"\\r\\n\".join(payload).encode('utf-8')\n         r = {\n             'CONTENT_LENGTH': len(payload),\n             'CONTENT_TYPE':   client.MULTIPART_CONTENT,\n             'PATH_INFO':      \"/file_uploads/echo/\",\n             'REQUEST_METHOD': 'POST',\n-            'wsgi.input':     client.FakePayload(payload),\n+            'wsgi.input':     payload,\n         }\n         response = self.client.request(**r)\n \n@@ -159,21 +153,21 @@ def test_dangerous_file_names(self):\n     def test_filename_overflow(self):\n         \"\"\"File names over 256 characters (dangerous on some platforms) get fixed up.\"\"\"\n         name = \"%s.txt\" % (\"f\"*500)\n-        payload = \"\\r\\n\".join([\n+        payload = client.FakePayload(\"\\r\\n\".join([\n             '--' + client.BOUNDARY,\n             'Content-Disposition: form-data; name=\"file\"; filename=\"%s\"' % name,\n             'Content-Type: application/octet-stream',\n             '',\n             'Oops.'\n             '--' + client.BOUNDARY + '--',\n             '',\n-        ]).encode('utf-8')\n+        ]))\n         r = {\n             'CONTENT_LENGTH': len(payload),\n             'CONTENT_TYPE':   client.MULTIPART_CONTENT,\n             'PATH_INFO':      \"/file_uploads/echo/\",\n             'REQUEST_METHOD': 'POST',\n-            'wsgi.input':     client.FakePayload(payload),\n+            'wsgi.input':     payload,\n         }\n         got = json.loads(self.client.request(**r).content.decode('utf-8'))\n         self.assertTrue(len(got['file']) < 256, \"Got a long file name (%s characters).\" % len(got['file']))\n@@ -184,22 +178,22 @@ def test_truncated_multipart_handled_gracefully(self):\n         attempt to read beyond the end of the stream, and simply will handle\n         the part that can be parsed gracefully.\n         \"\"\"\n-        payload = \"\\r\\n\".join([\n+        payload_str = \"\\r\\n\".join([\n             '--' + client.BOUNDARY,\n             'Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"',\n             'Content-Type: application/octet-stream',\n             '',\n             'file contents'\n             '--' + client.BOUNDARY + '--',\n             '',\n-        ]).encode('utf-8')\n-        payload = payload[:-10]\n+        ])\n+        payload = client.FakePayload(payload_str[:-10])\n         r = {\n             'CONTENT_LENGTH': len(payload),\n             'CONTENT_TYPE': client.MULTIPART_CONTENT,\n             'PATH_INFO': '/file_uploads/echo/',\n             'REQUEST_METHOD': 'POST',\n-            'wsgi.input': client.FakePayload(payload),\n+            'wsgi.input': payload,\n         }\n         got = json.loads(self.client.request(**r).content.decode('utf-8'))\n         self.assertEqual(got, {})"
        }
    ],
    "stats": {
        "total": 64,
        "additions": 37,
        "deletions": 27
    }
}