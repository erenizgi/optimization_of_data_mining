{
    "author": "freakboy3742",
    "message": "Fixed #19472 -- Documented the testing requirements and tools for custom User models.\n\nThanks to gcc for the report.",
    "sha": "bd414aed01d48339ed02b9714565939536ffbfcb",
    "files": [
        {
            "sha": "bd5cfdaac2e322ac4dc13702031903cba6a7d2ee",
            "filename": "docs/topics/auth.txt",
            "status": "modified",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/django/django/blob/bd414aed01d48339ed02b9714565939536ffbfcb/docs%2Ftopics%2Fauth.txt",
            "raw_url": "https://github.com/django/django/raw/bd414aed01d48339ed02b9714565939536ffbfcb/docs%2Ftopics%2Fauth.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fauth.txt?ref=bd414aed01d48339ed02b9714565939536ffbfcb",
            "patch": "@@ -2155,6 +2155,61 @@ Another limitation of custom User models is that you can't use\n :func:`django.contrib.auth.get_user_model()` as the sender or target of a signal\n handler. Instead, you must register the handler with the actual User model.\n \n+Custom users and testing/fixtures\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+If you are writing an application that interacts with the User model, you must\n+take some precautions to ensure that your test suite will run regardless of\n+the User model that is being used by a project. Any test that instantiates an\n+instance of User will fail if the User model has been swapped out. This\n+includes any attempt to create an instance of User with a fixture.\n+\n+To ensure that your test suite will pass in any project configuration,\n+``django.contrib.auth.tests.utils`` defines a ``@skipIfCustomUser`` decorator.\n+This decorator will cause a test case to be skipped if any User model other\n+than the default Django user is in use. This decorator can be applied to a\n+single test, or to an entire test class.\n+\n+Depending on your application, tests may also be needed to be added to ensure\n+that the application works with *any* user model, not just the default User\n+model. To assist with this, Django provides two substitute user models that\n+can be used in test suites:\n+\n+* :class:`django.contrib.auth.tests.custom_user.CustomUser`, a custom user\n+  model that uses an ``email`` field as the username, and has a basic\n+  admin-compliant permissions setup\n+\n+* :class:`django.contrib.auth.tests.custom_user.ExtensionUser`, a custom\n+  user model that extends :class:`~django.contrib.auth.models.AbstractUser`,\n+  adding a ``date_of_birth`` field.\n+\n+You can then use the ``@override_settings`` decorator to make that test run\n+with the custom User model. For example, here is a skeleton for a test that\n+would test three possible User models -- the default, plus the two User\n+models provided by ``auth`` app::\n+\n+    from django.contrib.auth.tests.utils import skipIfCustomUser\n+    from django.test import TestCase\n+    from django.test.utils import override_settings\n+\n+\n+    class ApplicationTestCase(TestCase):\n+        @skipIfCustomUser\n+        def test_normal_user(self):\n+            \"Run tests for the normal user model\"\n+            self.assertSomething()\n+\n+        @override_settings(AUTH_USER_MODEL='auth.CustomUser')\n+        def test_custom_user(self):\n+            \"Run tests for a custom user model with email-based authentication\"\n+            self.assertSomething()\n+\n+        @override_settings(AUTH_USER_MODEL='auth.ExtensionUser')\n+        def test_extension_user(self):\n+            \"Run tests for a simple extension of the built-in User.\"\n+            self.assertSomething()\n+\n+\n A full example\n --------------\n "
        }
    ],
    "stats": {
        "total": 55,
        "additions": 55,
        "deletions": 0
    }
}