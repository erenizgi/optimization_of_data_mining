{
    "author": "jezdez",
    "message": "Fixed #12417 -- Added signing functionality, including signing cookies. Many thanks to Simon, Stephan, Paul and everyone else involved.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16253 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "f60d42846365b2bf2f1c9bc7a3007c303122a20b",
    "files": [
        {
            "sha": "c98cab763d0a61316c51a286458bae1ef66dc114",
            "filename": "django/conf/global_settings.py",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/django%2Fconf%2Fglobal_settings.py",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/django%2Fconf%2Fglobal_settings.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fconf%2Fglobal_settings.py?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -476,6 +476,12 @@\n # The number of days a password reset link is valid for\n PASSWORD_RESET_TIMEOUT_DAYS = 3\n \n+###########\n+# SIGNING #\n+###########\n+\n+SIGNING_BACKEND = 'django.core.signing.TimestampSigner'\n+\n ########\n # CSRF #\n ########"
        },
        {
            "sha": "3b0a48be33213783a821e2e659b82eeb31784a11",
            "filename": "django/core/signing.py",
            "status": "added",
            "additions": 178,
            "deletions": 0,
            "changes": 178,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/django%2Fcore%2Fsigning.py",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/django%2Fcore%2Fsigning.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fsigning.py?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -0,0 +1,178 @@\n+\"\"\"\n+Functions for creating and restoring url-safe signed JSON objects.\n+\n+The format used looks like this:\n+\n+>>> signed.dumps(\"hello\")\n+'ImhlbGxvIg.RjVSUCt6S64WBilMYxG89-l0OA8'\n+\n+There are two components here, separatad by a '.'. The first component is a\n+URLsafe base64 encoded JSON of the object passed to dumps(). The second\n+component is a base64 encoded hmac/SHA1 hash of \"$first_component.$secret\"\n+\n+signed.loads(s) checks the signature and returns the deserialised object.\n+If the signature fails, a BadSignature exception is raised.\n+\n+>>> signed.loads(\"ImhlbGxvIg.RjVSUCt6S64WBilMYxG89-l0OA8\")\n+u'hello'\n+>>> signed.loads(\"ImhlbGxvIg.RjVSUCt6S64WBilMYxG89-l0OA8-modified\")\n+...\n+BadSignature: Signature failed: RjVSUCt6S64WBilMYxG89-l0OA8-modified\n+\n+You can optionally compress the JSON prior to base64 encoding it to save\n+space, using the compress=True argument. This checks if compression actually\n+helps and only applies compression if the result is a shorter string:\n+\n+>>> signed.dumps(range(1, 20), compress=True)\n+'.eJwFwcERACAIwLCF-rCiILN47r-GyZVJsNgkxaFxoDgxcOHGxMKD_T7vhAml.oFq6lAAEbkHXBHfGnVX7Qx6NlZ8'\n+\n+The fact that the string is compressed is signalled by the prefixed '.' at the\n+start of the base64 JSON.\n+\n+There are 65 url-safe characters: the 64 used by url-safe base64 and the '.'.\n+These functions make use of all of them.\n+\"\"\"\n+import base64\n+import time\n+import zlib\n+\n+from django.conf import settings\n+from django.core.exceptions import ImproperlyConfigured\n+from django.utils import baseconv, simplejson\n+from django.utils.crypto import constant_time_compare, salted_hmac\n+from django.utils.encoding import force_unicode, smart_str\n+from django.utils.importlib import import_module\n+\n+\n+class BadSignature(Exception):\n+    \"\"\"\n+    Signature does not match\n+    \"\"\"\n+    pass\n+\n+\n+class SignatureExpired(BadSignature):\n+    \"\"\"\n+    Signature timestamp is older than required max_age\n+    \"\"\"\n+    pass\n+\n+\n+def b64_encode(s):\n+    return base64.urlsafe_b64encode(s).strip('=')\n+\n+\n+def b64_decode(s):\n+    pad = '=' * (-len(s) % 4)\n+    return base64.urlsafe_b64decode(s + pad)\n+\n+\n+def base64_hmac(salt, value, key):\n+    return b64_encode(salted_hmac(salt, value, key).digest())\n+\n+\n+def get_cookie_signer(salt='django.core.signing.get_cookie_signer'):\n+    modpath = settings.SIGNING_BACKEND\n+    module, attr = modpath.rsplit('.', 1)\n+    try:\n+        mod = import_module(module)\n+    except ImportError, e:\n+        raise ImproperlyConfigured(\n+            'Error importing cookie signer %s: \"%s\"' % (modpath, e))\n+    try:\n+        Signer = getattr(mod, attr)\n+    except AttributeError, e:\n+        raise ImproperlyConfigured(\n+            'Error importing cookie signer %s: \"%s\"' % (modpath, e))\n+    return Signer('django.http.cookies' + settings.SECRET_KEY, salt=salt)\n+\n+\n+def dumps(obj, key=None, salt='django.core.signing', compress=False):\n+    \"\"\"\n+    Returns URL-safe, sha1 signed base64 compressed JSON string. If key is\n+    None, settings.SECRET_KEY is used instead.\n+\n+    If compress is True (not the default) checks if compressing using zlib can\n+    save some space. Prepends a '.' to signify compression. This is included\n+    in the signature, to protect against zip bombs.\n+\n+    salt can be used to further salt the hash, in case you're worried\n+    that the NSA might try to brute-force your SHA-1 protected secret.\n+    \"\"\"\n+    json = simplejson.dumps(obj, separators=(',', ':'))\n+\n+    # Flag for if it's been compressed or not\n+    is_compressed = False\n+\n+    if compress:\n+        # Avoid zlib dependency unless compress is being used\n+        compressed = zlib.compress(json)\n+        if len(compressed) < (len(json) - 1):\n+            json = compressed\n+            is_compressed = True\n+    base64d = b64_encode(json)\n+    if is_compressed:\n+        base64d = '.' + base64d\n+    return TimestampSigner(key, salt=salt).sign(base64d)\n+\n+\n+def loads(s, key=None, salt='django.core.signing', max_age=None):\n+    \"\"\"\n+    Reverse of dumps(), raises BadSignature if signature fails\n+    \"\"\"\n+    base64d = smart_str(\n+        TimestampSigner(key, salt=salt).unsign(s, max_age=max_age))\n+    decompress = False\n+    if base64d[0] == '.':\n+        # It's compressed; uncompress it first\n+        base64d = base64d[1:]\n+        decompress = True\n+    json = b64_decode(base64d)\n+    if decompress:\n+        json = zlib.decompress(json)\n+    return simplejson.loads(json)\n+\n+\n+class Signer(object):\n+    def __init__(self, key=None, sep=':', salt=None):\n+        self.sep = sep\n+        self.key = key or settings.SECRET_KEY\n+        self.salt = salt or ('%s.%s' %\n+            (self.__class__.__module__, self.__class__.__name__))\n+\n+    def signature(self, value):\n+        return base64_hmac(self.salt + 'signer', value, self.key)\n+\n+    def sign(self, value):\n+        value = smart_str(value)\n+        return '%s%s%s' % (value, self.sep, self.signature(value))\n+\n+    def unsign(self, signed_value):\n+        signed_value = smart_str(signed_value)\n+        if not self.sep in signed_value:\n+            raise BadSignature('No \"%s\" found in value' % self.sep)\n+        value, sig = signed_value.rsplit(self.sep, 1)\n+        if constant_time_compare(sig, self.signature(value)):\n+            return force_unicode(value)\n+        raise BadSignature('Signature \"%s\" does not match' % sig)\n+\n+\n+class TimestampSigner(Signer):\n+    def timestamp(self):\n+        return baseconv.base62.encode(int(time.time()))\n+\n+    def sign(self, value):\n+        value = smart_str('%s%s%s' % (value, self.sep, self.timestamp()))\n+        return '%s%s%s' % (value, self.sep, self.signature(value))\n+\n+    def unsign(self, value, max_age=None):\n+        result =  super(TimestampSigner, self).unsign(value)\n+        value, timestamp = result.rsplit(self.sep, 1)\n+        timestamp = baseconv.base62.decode(timestamp)\n+        if max_age is not None:\n+            # Check timestamp is not older than max_age\n+            age = time.time() - timestamp\n+            if age > max_age:\n+                raise SignatureExpired(\n+                    'Signature age %s > %s seconds' % (age, max_age))\n+        return value"
        },
        {
            "sha": "ae507aac63a75918247a07b23e91d7e6690f4005",
            "filename": "django/http/__init__.py",
            "status": "modified",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/django%2Fhttp%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/django%2Fhttp%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2F__init__.py?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -122,6 +122,7 @@ def __init__(self, *args, **kwargs):\n from django.utils.http import cookie_date\n from django.http.multipartparser import MultiPartParser\n from django.conf import settings\n+from django.core import signing\n from django.core.files import uploadhandler\n from utils import *\n \n@@ -132,6 +133,8 @@ def __init__(self, *args, **kwargs):\n class Http404(Exception):\n     pass\n \n+RAISE_ERROR = object()\n+\n class HttpRequest(object):\n     \"\"\"A basic HTTP request.\"\"\"\n \n@@ -170,6 +173,29 @@ def get_full_path(self):\n         # Rather than crash if this doesn't happen, we encode defensively.\n         return '%s%s' % (self.path, self.META.get('QUERY_STRING', '') and ('?' + iri_to_uri(self.META.get('QUERY_STRING', ''))) or '')\n \n+    def get_signed_cookie(self, key, default=RAISE_ERROR, salt='', max_age=None):\n+        \"\"\"\n+        Attempts to return a signed cookie. If the signature fails or the\n+        cookie has expired, raises an exception... unless you provide the\n+        default argument in which case that value will be returned instead.\n+        \"\"\"\n+        try:\n+            cookie_value = self.COOKIES[key].encode('utf-8')\n+        except KeyError:\n+            if default is not RAISE_ERROR:\n+                return default\n+            else:\n+                raise\n+        try:\n+            value = signing.get_cookie_signer(salt=key + salt).unsign(\n+                cookie_value, max_age=max_age)\n+        except signing.BadSignature:\n+            if default is not RAISE_ERROR:\n+                return default\n+            else:\n+                raise\n+        return value\n+\n     def build_absolute_uri(self, location=None):\n         \"\"\"\n         Builds an absolute URI from the location and the variables available in\n@@ -584,6 +610,10 @@ def set_cookie(self, key, value='', max_age=None, expires=None, path='/',\n         if httponly:\n             self.cookies[key]['httponly'] = True\n \n+    def set_signed_cookie(self, key, value, salt='', **kwargs):\n+        value = signing.get_cookie_signer(salt=key + salt).sign(value)\n+        return self.set_cookie(key, value, **kwargs)\n+\n     def delete_cookie(self, key, path='/', domain=None):\n         self.set_cookie(key, max_age=0, path=path, domain=domain,\n                         expires='Thu, 01-Jan-1970 00:00:00 GMT')"
        },
        {
            "sha": "702c172b34f3424d1128d77e634e915a95813310",
            "filename": "django/utils/baseconv.py",
            "status": "added",
            "additions": 99,
            "deletions": 0,
            "changes": 99,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/django%2Futils%2Fbaseconv.py",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/django%2Futils%2Fbaseconv.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fbaseconv.py?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -0,0 +1,99 @@\n+# Copyright (c) 2010 Taurinus Collective. All rights reserved.\n+# Copyright (c) 2009 Simon Willison. All rights reserved.\n+# Copyright (c) 2002 Drew Perttula. All rights reserved.\n+#\n+# License:\n+#   Python Software Foundation License version 2\n+#\n+# See the file \"LICENSE\" for terms & conditions for usage, and a DISCLAIMER OF\n+# ALL WARRANTIES.\n+#\n+# This Baseconv distribution contains no GNU General Public Licensed (GPLed)\n+# code so it may be used in proprietary projects just like prior ``baseconv``\n+# distributions.\n+#\n+# All trademarks referenced herein are property of their respective holders.\n+#\n+\n+\"\"\"\n+Convert numbers from base 10 integers to base X strings and back again.\n+\n+Sample usage::\n+\n+  >>> base20 = BaseConverter('0123456789abcdefghij')\n+  >>> base20.encode(1234)\n+  '31e'\n+  >>> base20.decode('31e')\n+  1234\n+  >>> base20.encode(-1234)\n+  '-31e'\n+  >>> base20.decode('-31e')\n+  -1234\n+  >>> base11 = BaseConverter('0123456789-', sign='$')\n+  >>> base11.encode('$1234')\n+  '$-22'\n+  >>> base11.decode('$-22')\n+  '$1234'\n+\n+\"\"\"\n+\n+BASE2_ALPHABET = '01'\n+BASE16_ALPHABET = '0123456789ABCDEF'\n+BASE56_ALPHABET = '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz'\n+BASE36_ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz'\n+BASE62_ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n+BASE64_ALPHABET = BASE62_ALPHABET + '-_'\n+\n+class BaseConverter(object):\n+    decimal_digits = '0123456789'\n+\n+    def __init__(self, digits, sign='-'):\n+        self.sign = sign\n+        self.digits = digits\n+        if sign in self.digits:\n+            raise ValueError('Sign character found in converter base digits.')\n+\n+    def __repr__(self):\n+        return \"<BaseConverter: base%s (%s)>\" % (len(self.digits), self.digits)\n+\n+    def encode(self, i):\n+        neg, value = self.convert(i, self.decimal_digits, self.digits, '-')\n+        if neg:\n+            return self.sign + value\n+        return value\n+\n+    def decode(self, s):\n+        neg, value = self.convert(s, self.digits, self.decimal_digits, self.sign)\n+        if neg:\n+            value = '-' + value\n+        return int(value)\n+\n+    def convert(self, number, from_digits, to_digits, sign):\n+        if str(number)[0] == sign:\n+            number = str(number)[1:]\n+            neg = 1\n+        else:\n+            neg = 0\n+\n+        # make an integer out of the number\n+        x = 0\n+        for digit in str(number):\n+            x = x * len(from_digits) + from_digits.index(digit)\n+\n+        # create the result in base 'len(to_digits)'\n+        if x == 0:\n+            res = to_digits[0]\n+        else:\n+            res = ''\n+            while x > 0:\n+                digit = x % len(to_digits)\n+                res = to_digits[digit] + res\n+                x = int(x / len(to_digits))\n+        return neg, res\n+\n+base2 = BaseConverter(BASE2_ALPHABET)\n+base16 = BaseConverter(BASE16_ALPHABET)\n+base36 = BaseConverter(BASE36_ALPHABET)\n+base56 = BaseConverter(BASE56_ALPHABET)\n+base62 = BaseConverter(BASE62_ALPHABET)\n+base64 = BaseConverter(BASE64_ALPHABET, sign='$')"
        },
        {
            "sha": "8b4ae53bc27805ee299b3f134c5a0ca3eaf1b83f",
            "filename": "docs/index.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/docs%2Findex.txt",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/docs%2Findex.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Findex.txt?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -171,6 +171,7 @@ Other batteries included\n     * :doc:`Comments <ref/contrib/comments/index>` | :doc:`Moderation <ref/contrib/comments/moderation>` | :doc:`Custom comments <ref/contrib/comments/custom>`\n     * :doc:`Content types <ref/contrib/contenttypes>`\n     * :doc:`Cross Site Request Forgery protection <ref/contrib/csrf>`\n+    * :doc:`Cryptographic signing <topics/signing>`\n     * :doc:`Databrowse <ref/contrib/databrowse>`\n     * :doc:`E-mail (sending) <topics/email>`\n     * :doc:`Flatpages <ref/contrib/flatpages>`"
        },
        {
            "sha": "d4ff40a74685d20a4c2e1e6e4b2b1c1c32688845",
            "filename": "docs/ref/request-response.txt",
            "status": "modified",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/docs%2Fref%2Frequest-response.txt",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/docs%2Fref%2Frequest-response.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Frequest-response.txt?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -240,6 +240,43 @@ Methods\n \n    Example: ``\"http://example.com/music/bands/the_beatles/?print=true\"``\n \n+.. method:: HttpRequest.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)\n+\n+   .. versionadded:: 1.4\n+\n+   Returns a cookie value for a signed cookie, or raises a\n+   :class:`~django.core.signing.BadSignature` exception if the signature is\n+   no longer valid. If you provide the ``default`` argument the exception\n+   will be suppressed and that default value will be returned instead.\n+\n+   The optional ``salt`` argument can be used to provide extra protection\n+   against brute force attacks on your secret key. If supplied, the\n+   ``max_age`` argument will be checked against the signed timestamp\n+   attached to the cookie value to ensure the cookie is not older than\n+   ``max_age`` seconds.\n+\n+   For example::\n+\n+          >>> request.get_signed_cookie('name')\n+          'Tony'\n+          >>> request.get_signed_cookie('name', salt='name-salt')\n+          'Tony' # assuming cookie was set using the same salt\n+          >>> request.get_signed_cookie('non-existing-cookie')\n+          ...\n+          KeyError: 'non-existing-cookie'\n+          >>> request.get_signed_cookie('non-existing-cookie', False)\n+          False\n+          >>> request.get_signed_cookie('cookie-that-was-tampered-with')\n+          ...\n+          BadSignature: ...\n+          >>> request.get_signed_cookie('name', max_age=60)\n+          ...\n+          SignatureExpired: Signature age 1677.3839159 > 60 seconds\n+          >>> request.get_signed_cookie('name', False, max_age=60)\n+          False\n+\n+   See :doc:`cryptographic signing </topics/signing>` for more information.\n+\n .. method:: HttpRequest.is_secure()\n \n    Returns ``True`` if the request is secure; that is, if it was made with\n@@ -618,6 +655,17 @@ Methods\n     .. _`cookie Morsel`: http://docs.python.org/library/cookie.html#Cookie.Morsel\n     .. _HTTPOnly: http://www.owasp.org/index.php/HTTPOnly\n \n+.. method:: HttpResponse.set_signed_cookie(key, value='', salt='', max_age=None, expires=None, path='/', domain=None, secure=None, httponly=False)\n+\n+    .. versionadded:: 1.4\n+\n+    Like :meth:`~HttpResponse.set_cookie()`, but\n+    :doc:`cryptographic signing </topics/signing>` the cookie before setting\n+    it. Use in conjunction with :meth:`HttpRequest.get_signed_cookie`.\n+    You can use the optional ``salt`` argument for added key strength, but\n+    you will need to remember to pass it to the corresponding\n+    :meth:`HttpRequest.get_signed_cookie` call.\n+\n .. method:: HttpResponse.delete_cookie(key, path='/', domain=None)\n \n     Deletes the cookie with the given key. Fails silently if the key doesn't"
        },
        {
            "sha": "4716fabea75d24dbe79bb4eaa447474faf22617a",
            "filename": "docs/ref/settings.txt",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/docs%2Fref%2Fsettings.txt",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/docs%2Fref%2Fsettings.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fsettings.txt?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -1647,6 +1647,19 @@ See :tfilter:`allowed date format strings <date>`.\n \n See also ``DATE_FORMAT`` and ``SHORT_DATETIME_FORMAT``.\n \n+.. setting:: SIGNING_BACKEND\n+\n+SIGNING_BACKEND\n+---------------\n+\n+.. versionadded:: 1.4\n+\n+Default: 'django.core.signing.TimestampSigner'\n+\n+The backend used for signing cookies and other data.\n+\n+See also the :doc:`/topics/signing` documentation.\n+\n .. setting:: SITE_ID\n \n SITE_ID"
        },
        {
            "sha": "a579e96f93d7aeeb8c038784fb72fe9928f33e93",
            "filename": "docs/releases/1.4.txt",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/docs%2Freleases%2F1.4.txt",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/docs%2Freleases%2F1.4.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.4.txt?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -46,6 +46,15 @@ not custom filters. This has been rectified with a simple API previously\n known as \"FilterSpec\" which was used internally. For more details, see the\n documentation for :attr:`~django.contrib.admin.ModelAdmin.list_filter`.\n \n+Tools for cryptographic signing\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Django 1.4 adds both a low-level API for signing values and a high-level API\n+for setting and reading signed cookies, one of the most common uses of\n+signing in Web applications.\n+\n+See :doc:`cryptographic signing </topics/signing>` docs for more information.\n+\n ``reverse_lazy``\n ~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "84f9e9f6880af0a0a0d3086482777407bc46bac4",
            "filename": "docs/topics/index.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/docs%2Ftopics%2Findex.txt",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/docs%2Ftopics%2Findex.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Findex.txt?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -18,6 +18,7 @@ Introductions to all the key parts of Django you'll need to know:\n    auth\n    cache\n    conditional-view-processing\n+   signing\n    email\n    i18n/index\n    logging"
        },
        {
            "sha": "7989643297dcfb62f9efca42c760f7a48477014b",
            "filename": "docs/topics/signing.txt",
            "status": "added",
            "additions": 135,
            "deletions": 0,
            "changes": 135,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/docs%2Ftopics%2Fsigning.txt",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/docs%2Ftopics%2Fsigning.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fsigning.txt?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -0,0 +1,135 @@\n+=====================\n+Cryptographic signing\n+=====================\n+\n+.. module:: django.core.signing\n+   :synopsis: Django's signing framework.\n+\n+.. versionadded:: 1.4\n+\n+The golden rule of Web application security is to never trust data from\n+untrusted sources. Sometimes it can be useful to pass data through an\n+untrusted medium. Cryptographically signed values can be passed through an\n+untrusted channel safe in the knowledge that any tampering will be detected.\n+\n+Django provides both a low-level API for signing values and a high-level API\n+for setting and reading signed cookies, one of the most common uses of\n+signing in Web applications.\n+\n+You may also find signing useful for the following:\n+\n+    * Generating \"recover my account\" URLs for sending to users who have\n+      lost their password.\n+\n+    * Ensuring data stored in hidden form fields has not been tampered with.\n+\n+    * Generating one-time secret URLs for allowing temporary access to a\n+      protected resource, for example a downloadable file that a user has\n+      paid for.\n+\n+Protecting the SECRET_KEY\n+=========================\n+\n+When you create a new Django project using :djadmin:`startproject`, the\n+``settings.py`` file it generates automatically gets a random\n+:setting:`SECRET_KEY` value. This value is the key to securing signed\n+data -- it is vital you keep this secure, or attackers could use it to\n+generate their own signed values.\n+\n+Using the low-level API\n+=======================\n+\n+.. class:: Signer\n+\n+Django's signing methods live in the ``django.core.signing`` module.\n+To sign a value, first instantiate a ``Signer`` instance::\n+\n+    >>> from django.core.signing import Signer\n+    >>> signer = Signer()\n+    >>> value = signer.sign('My string')\n+    >>> value\n+    'My string:GdMGD6HNQ_qdgxYP8yBZAdAIV1w'\n+\n+The signature is appended to the end of the string, following the colon.\n+You can retrieve the original value using the ``unsign`` method::\n+\n+    >>> original = signer.unsign(value)\n+    >>> original\n+    u'My string'\n+\n+If the signature or value have been altered in any way, a\n+``django.core.signing.BadSigature`` exception will be raised::\n+\n+    >>> value += 'm'\n+    >>> try:\n+    ...    original = signer.unsign(value)\n+    ... except signing.BadSignature:\n+    ...    print \"Tampering detected!\"\n+\n+By default, the ``Signer`` class uses the :setting:`SECRET_KEY` setting to\n+generate signatures. You can use a different secret by passing it to the\n+``Signer`` constructor::\n+\n+    >>> signer = Signer('my-other-secret')\n+    >>> value = signer.sign('My string')\n+    >>> value\n+    'My string:EkfQJafvGyiofrdGnuthdxImIJw'\n+\n+Using the salt argument\n+-----------------------\n+\n+If you do not wish to use the same key for every signing operation in your\n+application, you can use the optional ``salt`` argument to the ``Signer``\n+class to further strengthen your :setting:`SECRET_KEY` against brute force\n+attacks. Using a salt will cause a new key to be derived from both the salt\n+and your :setting:`SECRET_KEY`::\n+\n+    >>> signer = Signer()\n+    >>> signer.sign('My string')\n+    'My string:GdMGD6HNQ_qdgxYP8yBZAdAIV1w'\n+    >>> signer = Signer(salt='extra')\n+    >>> signer.sign('My string')\n+    'My string:Ee7vGi-ING6n02gkcJ-QLHg6vFw'\n+    >>> signer.unsign('My string:Ee7vGi-ING6n02gkcJ-QLHg6vFw')\n+    u'My string'\n+\n+Unlike your :setting:`SECRET_KEY`, your salt argument does not need to stay\n+secret.\n+\n+Verifying timestamped values\n+----------------------------\n+\n+.. class:: TimestampSigner\n+\n+``TimestampSigner`` is a subclass of :class:`~Signer` that appends a signed\n+timestamp to the value. This allows you to confirm that a signed value was\n+created within a specified period of time::\n+\n+    >>> from django.core.signing import TimestampSigner\n+    >>> signer = TimestampSigner()\n+    >>> value = signer.sign('hello')\n+    >>> value\n+    'hello:1NMg5H:oPVuCqlJWmChm1rA2lyTUtelC-c'\n+    >>> signer.unsign(value)\n+    u'hello'\n+    >>> signer.unsign(value, max_age=10)\n+    ...\n+    SignatureExpired: Signature age 15.5289158821 > 10 seconds\n+    >>> signer.unsign(value, max_age=20)\n+    u'hello'\n+\n+Protecting complex data structures\n+----------------------------------\n+\n+If you wish to protect a list, tuple or dictionary you can do so using the\n+signing module's dumps and loads functions. These imitate Python's pickle\n+module, but uses JSON serialization under the hood. JSON ensures that even\n+if your :setting:`SECRET_KEY` is stolen an attacker will not be able to\n+execute arbitrary commands by exploiting the pickle format.::\n+\n+    >>> from django.core import signing\n+    >>> value = signing.dumps({\"foo\": \"bar\"})\n+    >>> value\n+    'eyJmb28iOiJiYXIifQ:1NMg1b:zGcDE4-TCkaeGzLeW9UQwZesciI'\n+    >>> signing.loads(value)\n+    {'foo': 'bar'}"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/regressiontests/signed_cookies_tests/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Fsigned_cookies_tests%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Fsigned_cookies_tests%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fsigned_cookies_tests%2F__init__.py?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b"
        },
        {
            "sha": "71abcc51987fc5a394a172f8de739d9d863e4c04",
            "filename": "tests/regressiontests/signed_cookies_tests/models.py",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Fsigned_cookies_tests%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Fsigned_cookies_tests%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fsigned_cookies_tests%2Fmodels.py?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -0,0 +1 @@\n+# models.py file for tests to run."
        },
        {
            "sha": "c28892af61b6a04435e8be14ba966a385e853247",
            "filename": "tests/regressiontests/signed_cookies_tests/tests.py",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Fsigned_cookies_tests%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Fsigned_cookies_tests%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fsigned_cookies_tests%2Ftests.py?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -0,0 +1,61 @@\n+import time\n+\n+from django.core import signing\n+from django.http import HttpRequest, HttpResponse\n+from django.test import TestCase\n+\n+class SignedCookieTest(TestCase):\n+\n+    def test_can_set_and_read_signed_cookies(self):\n+        response = HttpResponse()\n+        response.set_signed_cookie('c', 'hello')\n+        self.assertIn('c', response.cookies)\n+        self.assertTrue(response.cookies['c'].value.startswith('hello:'))\n+        request = HttpRequest()\n+        request.COOKIES['c'] = response.cookies['c'].value\n+        value = request.get_signed_cookie('c')\n+        self.assertEqual(value, u'hello')\n+\n+    def test_can_use_salt(self):\n+        response = HttpResponse()\n+        response.set_signed_cookie('a', 'hello', salt='one')\n+        request = HttpRequest()\n+        request.COOKIES['a'] = response.cookies['a'].value\n+        value = request.get_signed_cookie('a', salt='one')\n+        self.assertEqual(value, u'hello')\n+        self.assertRaises(signing.BadSignature,\n+            request.get_signed_cookie, 'a', salt='two')\n+\n+    def test_detects_tampering(self):\n+        response = HttpResponse()\n+        response.set_signed_cookie('c', 'hello')\n+        request = HttpRequest()\n+        request.COOKIES['c'] = response.cookies['c'].value[:-2] + '$$'\n+        self.assertRaises(signing.BadSignature,\n+            request.get_signed_cookie, 'c')\n+\n+    def test_default_argument_supresses_exceptions(self):\n+        response = HttpResponse()\n+        response.set_signed_cookie('c', 'hello')\n+        request = HttpRequest()\n+        request.COOKIES['c'] = response.cookies['c'].value[:-2] + '$$'\n+        self.assertEqual(request.get_signed_cookie('c', default=None), None)\n+\n+    def test_max_age_argument(self):\n+        value = u'hello'\n+        _time = time.time\n+        time.time = lambda: 123456789\n+        try:\n+            response = HttpResponse()\n+            response.set_signed_cookie('c', value)\n+            request = HttpRequest()\n+            request.COOKIES['c'] = response.cookies['c'].value\n+            self.assertEqual(request.get_signed_cookie('c'), value)\n+\n+            time.time = lambda: 123456800\n+            self.assertEqual(request.get_signed_cookie('c', max_age=12), value)\n+            self.assertEqual(request.get_signed_cookie('c', max_age=11), value)\n+            self.assertRaises(signing.SignatureExpired,\n+                request.get_signed_cookie, 'c', max_age = 10)\n+        finally:\n+            time.time = _time"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/regressiontests/signing/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Fsigning%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Fsigning%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fsigning%2F__init__.py?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b"
        },
        {
            "sha": "71abcc51987fc5a394a172f8de739d9d863e4c04",
            "filename": "tests/regressiontests/signing/models.py",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Fsigning%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Fsigning%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fsigning%2Fmodels.py?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -0,0 +1 @@\n+# models.py file for tests to run."
        },
        {
            "sha": "0b0cacf10ef7c1d32c8631bfd3e5fcd2bff1c4e9",
            "filename": "tests/regressiontests/signing/tests.py",
            "status": "added",
            "additions": 116,
            "deletions": 0,
            "changes": 116,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Fsigning%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Fsigning%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fsigning%2Ftests.py?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -0,0 +1,116 @@\n+import time\n+\n+from django.core import signing\n+from django.test import TestCase\n+from django.utils.encoding import force_unicode\n+\n+class TestSigner(TestCase):\n+\n+    def test_signature(self):\n+        \"signature() method should generate a signature\"\n+        signer = signing.Signer('predictable-secret')\n+        signer2 = signing.Signer('predictable-secret2')\n+        for s in (\n+            'hello',\n+            '3098247:529:087:',\n+            u'\\u2019'.encode('utf8'),\n+        ):\n+            self.assertEqual(\n+                signer.signature(s),\n+                signing.base64_hmac(signer.salt + 'signer', s,\n+                    'predictable-secret')\n+            )\n+            self.assertNotEqual(signer.signature(s), signer2.signature(s))\n+\n+    def test_signature_with_salt(self):\n+        \"signature(value, salt=...) should work\"\n+        signer = signing.Signer('predictable-secret', salt='extra-salt')\n+        self.assertEqual(\n+            signer.signature('hello'),\n+                signing.base64_hmac('extra-salt' + 'signer',\n+                'hello', 'predictable-secret'))\n+        self.assertNotEqual(\n+            signing.Signer('predictable-secret', salt='one').signature('hello'),\n+            signing.Signer('predictable-secret', salt='two').signature('hello'))\n+\n+    def test_sign_unsign(self):\n+        \"sign/unsign should be reversible\"\n+        signer = signing.Signer('predictable-secret')\n+        examples = (\n+            'q;wjmbk;wkmb',\n+            '3098247529087',\n+            '3098247:529:087:',\n+            'jkw osanteuh ,rcuh nthu aou oauh ,ud du',\n+            u'\\u2019',\n+        )\n+        for example in examples:\n+            self.assertNotEqual(\n+                force_unicode(example), force_unicode(signer.sign(example)))\n+            self.assertEqual(example, signer.unsign(signer.sign(example)))\n+\n+    def unsign_detects_tampering(self):\n+        \"unsign should raise an exception if the value has been tampered with\"\n+        signer = signing.Signer('predictable-secret')\n+        value = 'Another string'\n+        signed_value = signer.sign(value)\n+        transforms = (\n+            lambda s: s.upper(),\n+            lambda s: s + 'a',\n+            lambda s: 'a' + s[1:],\n+            lambda s: s.replace(':', ''),\n+        )\n+        self.assertEqual(value, signer.unsign(signed_value))\n+        for transform in transforms:\n+            self.assertRaises(\n+                signing.BadSignature, signer.unsign, transform(signed_value))\n+\n+    def test_dumps_loads(self):\n+        \"dumps and loads be reversible for any JSON serializable object\"\n+        objects = (\n+            ['a', 'list'],\n+            'a string',\n+            u'a unicode string \\u2019',\n+            {'a': 'dictionary'},\n+        )\n+        for o in objects:\n+            self.assertNotEqual(o, signing.dumps(o))\n+            self.assertEqual(o, signing.loads(signing.dumps(o)))\n+\n+    def test_decode_detects_tampering(self):\n+        \"loads should raise exception for tampered objects\"\n+        transforms = (\n+            lambda s: s.upper(),\n+            lambda s: s + 'a',\n+            lambda s: 'a' + s[1:],\n+            lambda s: s.replace(':', ''),\n+        )\n+        value = {\n+            'foo': 'bar',\n+            'baz': 1,\n+        }\n+        encoded = signing.dumps(value)\n+        self.assertEqual(value, signing.loads(encoded))\n+        for transform in transforms:\n+            self.assertRaises(\n+                signing.BadSignature, signing.loads, transform(encoded))\n+\n+class TestTimestampSigner(TestCase):\n+\n+    def test_timestamp_signer(self):\n+        value = u'hello'\n+        _time = time.time\n+        time.time = lambda: 123456789\n+        try:\n+            signer = signing.TimestampSigner('predictable-key')\n+            ts = signer.sign(value)\n+            self.assertNotEqual(ts,\n+                signing.Signer('predictable-key').sign(value))\n+\n+            self.assertEqual(signer.unsign(ts), value)\n+            time.time = lambda: 123456800\n+            self.assertEqual(signer.unsign(ts, max_age=12), value)\n+            self.assertEqual(signer.unsign(ts, max_age=11), value)\n+            self.assertRaises(\n+                signing.SignatureExpired, signer.unsign, ts, max_age=10)\n+        finally:\n+            time.time = _time"
        },
        {
            "sha": "75660d811989fbabd8d66dabb364226d979732b7",
            "filename": "tests/regressiontests/utils/baseconv.py",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Futils%2Fbaseconv.py",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Futils%2Fbaseconv.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Futils%2Fbaseconv.py?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -0,0 +1,41 @@\n+from unittest import TestCase\n+from django.utils.baseconv import base2, base16, base36, base56, base62, base64, BaseConverter\n+\n+class TestBaseConv(TestCase):\n+\n+    def test_baseconv(self):\n+        nums = [-10 ** 10, 10 ** 10] + range(-100, 100)\n+        for converter in [base2, base16, base36, base56, base62, base64]:\n+            for i in nums:\n+                self.assertEqual(i, converter.decode(converter.encode(i)))\n+\n+    def test_base11(self):\n+        base11 = BaseConverter('0123456789-', sign='$')\n+        self.assertEqual(base11.encode(1234), '-22')\n+        self.assertEqual(base11.decode('-22'), 1234)\n+        self.assertEqual(base11.encode(-1234), '$-22')\n+        self.assertEqual(base11.decode('$-22'), -1234)\n+\n+    def test_base20(self):\n+        base20 = BaseConverter('0123456789abcdefghij')\n+        self.assertEqual(base20.encode(1234), '31e')\n+        self.assertEqual(base20.decode('31e'), 1234)\n+        self.assertEqual(base20.encode(-1234), '-31e')\n+        self.assertEqual(base20.decode('-31e'), -1234)\n+\n+    def test_base64(self):\n+        self.assertEqual(base64.encode(1234), 'JI')\n+        self.assertEqual(base64.decode('JI'), 1234)\n+        self.assertEqual(base64.encode(-1234), '$JI')\n+        self.assertEqual(base64.decode('$JI'), -1234)\n+\n+    def test_base7(self):\n+        base7 = BaseConverter('cjdhel3', sign='g')\n+        self.assertEqual(base7.encode(1234), 'hejd')\n+        self.assertEqual(base7.decode('hejd'), 1234)\n+        self.assertEqual(base7.encode(-1234), 'ghejd')\n+        self.assertEqual(base7.decode('ghejd'), -1234)\n+\n+    def test_exception(self):\n+        self.assertRaises(ValueError, BaseConverter, 'abc', sign='a')\n+        self.assertTrue(isinstance(BaseConverter('abc', sign='d'), BaseConverter))"
        },
        {
            "sha": "2b61627c484f0bbd5f330b0ae3408ec648770c32",
            "filename": "tests/regressiontests/utils/tests.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Futils%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/f60d42846365b2bf2f1c9bc7a3007c303122a20b/tests%2Fregressiontests%2Futils%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Futils%2Ftests.py?ref=f60d42846365b2bf2f1c9bc7a3007c303122a20b",
            "patch": "@@ -17,3 +17,4 @@\n from datastructures import *\n from tzinfo import *\n from datetime_safe import *\n+from baseconv import *"
        }
    ],
    "stats": {
        "total": 741,
        "additions": 741,
        "deletions": 0
    }
}