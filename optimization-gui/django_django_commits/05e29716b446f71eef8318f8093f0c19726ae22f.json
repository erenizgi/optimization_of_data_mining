{
    "author": "jbronn",
    "message": "Fixed #16553 -- Refactored the `GeoIP` module, moving it `django.contrib.gis.geoip`; fixed memory leaks, and encoding issues.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16783 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "05e29716b446f71eef8318f8093f0c19726ae22f",
    "files": [
        {
            "sha": "2e38e636f79089c6e6013f7352931e3287dcca0f",
            "filename": "django/contrib/gis/geoip/__init__.py",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/django/django/blob/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Fgeoip%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Fgeoip%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fgeoip%2F__init__.py?ref=05e29716b446f71eef8318f8093f0c19726ae22f",
            "patch": "@@ -0,0 +1,18 @@\n+\"\"\"\n+ This module houses the GeoIP object, a ctypes wrapper for the MaxMind GeoIP(R)\n+ C API (http://www.maxmind.com/app/c).  This is an alternative to the GPL\n+ licensed Python GeoIP interface provided by MaxMind.\n+\n+ GeoIP(R) is a registered trademark of MaxMind, LLC of Boston, Massachusetts.\n+\n+ For IP-based geolocation, this module requires the GeoLite Country and City\n+ datasets, in binary format (CSV will not work!).  The datasets may be\n+ downloaded from MaxMind at http://www.maxmind.com/download/geoip/database/.\n+ Grab GeoIP.dat.gz and GeoLiteCity.dat.gz, and unzip them in the directory\n+ corresponding to settings.GEOIP_PATH.\n+\"\"\"\n+try:\n+    from django.contrib.gis.geoip.base import GeoIP, GeoIPException\n+    HAS_GEOIP = True\n+except:\n+    HAS_GEOIP = False"
        },
        {
            "sha": "d12f58266b4f279475c0e5ef15922252c2d52819",
            "filename": "django/contrib/gis/geoip/base.py",
            "status": "added",
            "additions": 257,
            "deletions": 0,
            "changes": 257,
            "blob_url": "https://github.com/django/django/blob/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Fgeoip%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Fgeoip%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fgeoip%2Fbase.py?ref=05e29716b446f71eef8318f8093f0c19726ae22f",
            "patch": "@@ -0,0 +1,257 @@\n+import os\n+import re\n+from ctypes import c_char_p\n+\n+from django.core.validators import ipv4_re\n+from django.contrib.gis.geoip.libgeoip import GEOIP_SETTINGS\n+from django.contrib.gis.geoip.prototypes import (\n+    GeoIPRecord, GeoIPTag, GeoIP_open, GeoIP_delete, GeoIP_database_info,\n+    GeoIP_lib_version, GeoIP_record_by_addr, GeoIP_record_by_name,\n+    GeoIP_country_code_by_addr, GeoIP_country_code_by_name,\n+    GeoIP_country_name_by_addr, GeoIP_country_name_by_name)\n+\n+# Regular expressions for recognizing the GeoIP free database editions.\n+free_regex = re.compile(r'^GEO-\\d{3}FREE')\n+lite_regex = re.compile(r'^GEO-\\d{3}LITE')\n+\n+#### GeoIP classes ####\n+class GeoIPException(Exception): pass\n+\n+class GeoIP(object):\n+    # The flags for GeoIP memory caching.\n+    # GEOIP_STANDARD - read database from filesystem, uses least memory.\n+    #\n+    # GEOIP_MEMORY_CACHE - load database into memory, faster performance\n+    #        but uses more memory\n+    #\n+    # GEOIP_CHECK_CACHE - check for updated database.  If database has been\n+    #        updated, reload filehandle and/or memory cache.  This option\n+    #        is not thread safe.\n+    #\n+    # GEOIP_INDEX_CACHE - just cache the most frequently accessed index\n+    #        portion of the database, resulting in faster lookups than\n+    #        GEOIP_STANDARD, but less memory usage than GEOIP_MEMORY_CACHE -\n+    #        useful for larger databases such as GeoIP Organization and\n+    #        GeoIP City.  Note, for GeoIP Country, Region and Netspeed\n+    #        databases, GEOIP_INDEX_CACHE is equivalent to GEOIP_MEMORY_CACHE\n+    #\n+    # GEOIP_MMAP_CACHE - load database into mmap shared memory ( not available\n+    #       on Windows).\n+    GEOIP_STANDARD     = 0\n+    GEOIP_MEMORY_CACHE = 1\n+    GEOIP_CHECK_CACHE  = 2\n+    GEOIP_INDEX_CACHE  = 4\n+    GEOIP_MMAP_CACHE   = 8\n+    cache_options = dict((opt, None) for opt in (0, 1, 2, 4, 8))\n+\n+    # Paths to the city & country binary databases.\n+    _city_file = ''\n+    _country_file = ''\n+\n+    # Initially, pointers to GeoIP file references are NULL.\n+    _city = None\n+    _country = None\n+\n+    def __init__(self, path=None, cache=0, country=None, city=None):\n+        \"\"\"\n+        Initializes the GeoIP object, no parameters are required to use default\n+        settings.  Keyword arguments may be passed in to customize the locations\n+        of the GeoIP data sets.\n+\n+        * path: Base directory to where GeoIP data is located or the full path\n+            to where the city or country data files (*.dat) are located.\n+            Assumes that both the city and country data sets are located in\n+            this directory; overrides the GEOIP_PATH settings attribute.\n+\n+        * cache: The cache settings when opening up the GeoIP datasets,\n+            and may be an integer in (0, 1, 2, 4, 8) corresponding to\n+            the GEOIP_STANDARD, GEOIP_MEMORY_CACHE, GEOIP_CHECK_CACHE,\n+            GEOIP_INDEX_CACHE, and GEOIP_MMAP_CACHE, `GeoIPOptions` C API\n+            settings,  respectively.  Defaults to 0, meaning that the data is read\n+            from the disk.\n+\n+        * country: The name of the GeoIP country data file.  Defaults to\n+            'GeoIP.dat'; overrides the GEOIP_COUNTRY settings attribute.\n+\n+        * city: The name of the GeoIP city data file.  Defaults to\n+            'GeoLiteCity.dat'; overrides the GEOIP_CITY settings attribute.\n+        \"\"\"\n+        # Checking the given cache option.\n+        if cache in self.cache_options:\n+            self._cache = cache\n+        else:\n+            raise GeoIPException('Invalid GeoIP caching option: %s' % cache)\n+\n+        # Getting the GeoIP data path.\n+        if not path:\n+            path = GEOIP_SETTINGS.get('GEOIP_PATH', None)\n+            if not path: raise GeoIPException('GeoIP path must be provided via parameter or the GEOIP_PATH setting.')\n+        if not isinstance(path, basestring):\n+            raise TypeError('Invalid path type: %s' % type(path).__name__)\n+\n+        if os.path.isdir(path):\n+            # Constructing the GeoIP database filenames using the settings\n+            # dictionary.  If the database files for the GeoLite country\n+            # and/or city datasets exist, then try and open them.\n+            country_db = os.path.join(path, country or GEOIP_SETTINGS.get('GEOIP_COUNTRY', 'GeoIP.dat'))\n+            if os.path.isfile(country_db):\n+                self._country = GeoIP_open(country_db, cache)\n+                self._country_file = country_db\n+\n+            city_db = os.path.join(path, city or GEOIP_SETTINGS.get('GEOIP_CITY', 'GeoLiteCity.dat'))\n+            if os.path.isfile(city_db):\n+                self._city = GeoIP_open(city_db, cache)\n+                self._city_file = city_db\n+        elif os.path.isfile(path):\n+            # Otherwise, some detective work will be needed to figure\n+            # out whether the given database path is for the GeoIP country\n+            # or city databases.\n+            ptr = GeoIP_open(path, cache)\n+            info = GeoIP_database_info(ptr)\n+            if lite_regex.match(info):\n+                # GeoLite City database detected.\n+                self._city = ptr\n+                self._city_file = path\n+            elif free_regex.match(info):\n+                # GeoIP Country database detected.\n+                self._country = ptr\n+                self._country_file = path\n+            else:\n+                raise GeoIPException('Unable to recognize database edition: %s' % info)\n+        else:\n+            raise GeoIPException('GeoIP path must be a valid file or directory.')\n+\n+    def __del__(self):\n+        # Cleaning any GeoIP file handles lying around.\n+        if self._country: GeoIP_delete(self._country)\n+        if self._city: GeoIP_delete(self._city)\n+\n+    def _check_query(self, query, country=False, city=False, city_or_country=False):\n+        \"Helper routine for checking the query and database availability.\"\n+        # Making sure a string was passed in for the query.\n+        if not isinstance(query, basestring):\n+            raise TypeError('GeoIP query must be a string, not type %s' % type(query).__name__)\n+\n+        # Extra checks for the existence of country and city databases.\n+        if city_or_country and not (self._country or self._city):\n+            raise GeoIPException('Invalid GeoIP country and city data files.')\n+        elif country and not self._country:\n+            raise GeoIPException('Invalid GeoIP country data file: %s' % self._country_file)\n+        elif city and not self._city:\n+            raise GeoIPException('Invalid GeoIP city data file: %s' % self._city_file)\n+\n+    def city(self, query):\n+        \"\"\"\n+        Returns a dictionary of city information for the given IP address or\n+        Fully Qualified Domain Name (FQDN).  Some information in the dictionary\n+        may be undefined (None).\n+        \"\"\"\n+        self._check_query(query, city=True)\n+        if ipv4_re.match(query):\n+            # If an IP address was passed in\n+            return GeoIP_record_by_addr(self._city, c_char_p(query))\n+        else:\n+            # If a FQDN was passed in.\n+            return GeoIP_record_by_name(self._city, c_char_p(query))\n+\n+    def country_code(self, query):\n+        \"Returns the country code for the given IP Address or FQDN.\"\n+        self._check_query(query, city_or_country=True)\n+        if self._country:\n+            if ipv4_re.match(query):\n+                return GeoIP_country_code_by_addr(self._country, query)\n+            else:\n+                return GeoIP_country_code_by_name(self._country, query)\n+        else:\n+            return self.city(query)['country_code']\n+\n+    def country_name(self, query):\n+        \"Returns the country name for the given IP Address or FQDN.\"\n+        self._check_query(query, city_or_country=True)\n+        if self._country:\n+            if ipv4_re.match(query):\n+                return GeoIP_country_name_by_addr(self._country, query)\n+            else:\n+                return GeoIP_country_name_by_name(self._country, query)\n+        else:\n+            return self.city(query)['country_name']\n+\n+    def country(self, query):\n+        \"\"\"\n+        Returns a dictonary with with the country code and name when given an\n+        IP address or a Fully Qualified Domain Name (FQDN).  For example, both\n+        '24.124.1.80' and 'djangoproject.com' are valid parameters.\n+        \"\"\"\n+        # Returning the country code and name\n+        return {'country_code' : self.country_code(query),\n+                'country_name' : self.country_name(query),\n+                }\n+\n+    #### Coordinate retrieval routines ####\n+    def coords(self, query, ordering=('longitude', 'latitude')):\n+        cdict = self.city(query)\n+        if cdict is None: return None\n+        else: return tuple(cdict[o] for o in ordering)\n+\n+    def lon_lat(self, query):\n+        \"Returns a tuple of the (longitude, latitude) for the given query.\"\n+        return self.coords(query)\n+\n+    def lat_lon(self, query):\n+        \"Returns a tuple of the (latitude, longitude) for the given query.\"\n+        return self.coords(query, ('latitude', 'longitude'))\n+\n+    def geos(self, query):\n+        \"Returns a GEOS Point object for the given query.\"\n+        ll = self.lon_lat(query)\n+        if ll:\n+            from django.contrib.gis.geos import Point\n+            return Point(ll, srid=4326)\n+        else:\n+            return None\n+\n+    #### GeoIP Database Information Routines ####\n+    @property\n+    def country_info(self):\n+        \"Returns information about the GeoIP country database.\"\n+        if self._country is None:\n+            ci = 'No GeoIP Country data in \"%s\"' % self._country_file\n+        else:\n+            ci = GeoIP_database_info(self._country)\n+        return ci\n+\n+    @property\n+    def city_info(self):\n+        \"Retuns information about the GeoIP city database.\"\n+        if self._city is None:\n+            ci = 'No GeoIP City data in \"%s\"' % self._city_file\n+        else:\n+            ci = GeoIP_database_info(self._city)\n+        return ci\n+\n+    @property\n+    def info(self):\n+        \"Returns information about the GeoIP library and databases in use.\"\n+        info = ''\n+        if GeoIP_lib_version:\n+            info += 'GeoIP Library:\\n\\t%s\\n' % GeoIP_lib_version()\n+        return info + 'Country:\\n\\t%s\\nCity:\\n\\t%s' % (self.country_info, self.city_info)\n+\n+    #### Methods for compatibility w/the GeoIP-Python API. ####\n+    @classmethod\n+    def open(cls, full_path, cache):\n+        return GeoIP(full_path, cache)\n+\n+    def _rec_by_arg(self, arg):\n+        if self._city:\n+            return self.city(arg)\n+        else:\n+            return self.country(arg)\n+    region_by_addr = city\n+    region_by_name = city\n+    record_by_addr = _rec_by_arg\n+    record_by_name = _rec_by_arg\n+    country_code_by_addr = country_code\n+    country_code_by_name = country_code\n+    country_name_by_addr = country_name\n+    country_name_by_name = country_name"
        },
        {
            "sha": "613949f8096deea0173436c42f7ef48261e6ff02",
            "filename": "django/contrib/gis/geoip/libgeoip.py",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/django/django/blob/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Fgeoip%2Flibgeoip.py",
            "raw_url": "https://github.com/django/django/raw/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Fgeoip%2Flibgeoip.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fgeoip%2Flibgeoip.py?ref=05e29716b446f71eef8318f8093f0c19726ae22f",
            "patch": "@@ -0,0 +1,31 @@\n+import os\n+from ctypes import CDLL\n+from ctypes.util import find_library\n+from django.conf import settings\n+\n+# Creating the settings dictionary with any settings, if needed.\n+GEOIP_SETTINGS = dict((key, getattr(settings, key))\n+                      for key in ('GEOIP_PATH', 'GEOIP_LIBRARY_PATH', 'GEOIP_COUNTRY', 'GEOIP_CITY')\n+                      if hasattr(settings, key))\n+lib_path = GEOIP_SETTINGS.get('GEOIP_LIBRARY_PATH', None)\n+\n+# The shared library for the GeoIP C API.  May be downloaded\n+#  from http://www.maxmind.com/download/geoip/api/c/\n+if lib_path:\n+    lib_name = None\n+else:\n+    # TODO: Is this really the library name for Windows?\n+    lib_name = 'GeoIP'\n+\n+# Getting the path to the GeoIP library.\n+if lib_name: lib_path = find_library(lib_name)\n+if lib_path is None: raise GeoIPException('Could not find the GeoIP library (tried \"%s\"). '\n+                                          'Try setting GEOIP_LIBRARY_PATH in your settings.' % lib_name)\n+lgeoip = CDLL(lib_path)\n+\n+# Getting the C `free` for the platform.\n+if os.name == 'nt':\n+    libc = CDLL('msvcrt')\n+else:\n+    libc = CDLL(None)\n+free = libc.free"
        },
        {
            "sha": "1cec0d5c246191350fe6adb8e71a688c1eb23ce4",
            "filename": "django/contrib/gis/geoip/prototypes.py",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/django/django/blob/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Fgeoip%2Fprototypes.py",
            "raw_url": "https://github.com/django/django/raw/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Fgeoip%2Fprototypes.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fgeoip%2Fprototypes.py?ref=05e29716b446f71eef8318f8093f0c19726ae22f",
            "patch": "@@ -0,0 +1,109 @@\n+from ctypes import c_char_p, c_float, c_int, string_at, Structure, POINTER\n+from django.contrib.gis.geoip.libgeoip import lgeoip, free\n+\n+#### GeoIP C Structure definitions ####\n+\n+class GeoIPRecord(Structure):\n+    _fields_ = [('country_code', c_char_p),\n+                ('country_code3', c_char_p),\n+                ('country_name', c_char_p),\n+                ('region', c_char_p),\n+                ('city', c_char_p),\n+                ('postal_code', c_char_p),\n+                ('latitude', c_float),\n+                ('longitude', c_float),\n+                # TODO: In 1.4.6 this changed from `int dma_code;` to\n+                # `union {int metro_code; int dma_code;};`.  Change\n+                # to a `ctypes.Union` in to accomodate in future when\n+                # pre-1.4.6 versions are no longer distributed.\n+                ('dma_code', c_int),\n+                ('area_code', c_int),\n+                ('charset', c_int),\n+                ('continent_code', c_char_p),\n+                ]\n+geoip_char_fields = [name for name, ctype in GeoIPRecord._fields_ if ctype is c_char_p]\n+geoip_encodings = { 0: 'iso-8859-1',\n+                    1: 'utf8',\n+                    }\n+\n+class GeoIPTag(Structure): pass\n+\n+RECTYPE = POINTER(GeoIPRecord)\n+DBTYPE = POINTER(GeoIPTag)\n+\n+#### ctypes function prototypes ####\n+\n+# GeoIP_lib_version appeared in version 1.4.7.\n+if hasattr(lgeoip, 'GeoIP_lib_version'):\n+    GeoIP_lib_version = lgeoip.GeoIP_lib_version\n+    GeoIP_lib_version.argtypes = None\n+    GeoIP_lib_version.restype = c_char_p\n+else:\n+    GeoIP_lib_version = None\n+\n+# For freeing memory allocated within a record\n+GeoIPRecord_delete = lgeoip.GeoIPRecord_delete\n+GeoIPRecord_delete.argtypes = [RECTYPE]\n+GeoIPRecord_delete.restype = None\n+\n+# For retrieving records by name or address.\n+def check_record(result, func, cargs):\n+    if bool(result):\n+        # Checking the pointer to the C structure, if valid pull out elements\n+        # into a dicionary.\n+        rec = result.contents\n+        record = dict((fld, getattr(rec, fld)) for fld, ctype in rec._fields_)\n+\n+        # Now converting the strings to unicode using the proper encoding.\n+        encoding = geoip_encodings[record['charset']]\n+        for char_field in geoip_char_fields:\n+            if record[char_field]:\n+                record[char_field] = record[char_field].decode(encoding)\n+\n+        # Free the memory allocated for the struct & return.\n+        GeoIPRecord_delete(result)\n+        return record\n+    else:\n+        return None\n+\n+def record_output(func):\n+    func.argtypes = [DBTYPE, c_char_p]\n+    func.restype = RECTYPE\n+    func.errcheck = check_record\n+    return func\n+GeoIP_record_by_addr = record_output(lgeoip.GeoIP_record_by_addr)\n+GeoIP_record_by_name = record_output(lgeoip.GeoIP_record_by_name)\n+\n+\n+# For opening & closing GeoIP database files.\n+GeoIP_open = lgeoip.GeoIP_open\n+GeoIP_open.restype = DBTYPE\n+GeoIP_delete = lgeoip.GeoIP_delete\n+GeoIP_delete.argtypes = [DBTYPE]\n+GeoIP_delete.restype = None\n+\n+# This is so the string pointer can be freed within Python.\n+class geoip_char_p(c_char_p):\n+    pass\n+\n+def check_string(result, func, cargs):\n+    if result:\n+        s = string_at(result)\n+        free(result)\n+    else:\n+        s = ''\n+    return s\n+\n+GeoIP_database_info = lgeoip.GeoIP_database_info\n+GeoIP_database_info.restype = geoip_char_p\n+GeoIP_database_info.errcheck = check_string\n+\n+# String output routines.\n+def string_output(func):\n+    func.restype = c_char_p\n+    return func\n+\n+GeoIP_country_code_by_addr = string_output(lgeoip.GeoIP_country_code_by_addr)\n+GeoIP_country_code_by_name = string_output(lgeoip.GeoIP_country_code_by_name)\n+GeoIP_country_name_by_addr = string_output(lgeoip.GeoIP_country_name_by_addr)\n+GeoIP_country_name_by_name = string_output(lgeoip.GeoIP_country_name_by_name)"
        },
        {
            "sha": "ba3cd8025f307b79843fdbcba0a51cfe0a32dafd",
            "filename": "django/contrib/gis/geoip/tests.py",
            "status": "renamed",
            "additions": 14,
            "deletions": 7,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Fgeoip%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Fgeoip%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fgeoip%2Ftests.py?ref=05e29716b446f71eef8318f8093f0c19726ae22f",
            "patch": "@@ -1,8 +1,8 @@\n import os\n-import unittest\n-from django.db import settings\n+from django.conf import settings\n from django.contrib.gis.geos import GEOSGeometry\n-from django.contrib.gis.utils import GeoIP, GeoIPException\n+from django.contrib.gis.geoip import GeoIP, GeoIPException\n+from django.utils import unittest\n \n # Note: Requires use of both the GeoIP country and city datasets.\n # The GEOIP_DATA path should be the only setting set (the directory\n@@ -69,8 +69,8 @@ def test04_city(self):\n         \"Testing GeoIP city querying methods.\"\n         g = GeoIP(country='<foo>')\n \n-        addr = '130.80.29.3'\n-        fqdn = 'chron.com'\n+        addr = '128.249.1.1'\n+        fqdn = 'tmc.edu'\n         for query in (fqdn, addr):\n             # Country queries should still work.\n             for func in (g.country_code, g.country_code_by_addr, g.country_code_by_name):\n@@ -88,17 +88,24 @@ def test04_city(self):\n             self.assertEqual(713, d['area_code'])\n             geom = g.geos(query)\n             self.failIf(not isinstance(geom, GEOSGeometry))\n-            lon, lat = (-95.3670, 29.7523)\n+            lon, lat = (-95.4010, 29.7079)\n             lat_lon = g.lat_lon(query)\n             lat_lon = (lat_lon[1], lat_lon[0])\n             for tup in (geom.tuple, g.coords(query), g.lon_lat(query), lat_lon):\n                 self.assertAlmostEqual(lon, tup[0], 4)\n                 self.assertAlmostEqual(lat, tup[1], 4)\n \n+    def test05_unicode(self):\n+        \"Testing that GeoIP strings are properly encoded, see #16553.\"\n+        g = GeoIP()\n+        d = g.city('62.224.93.23')\n+        self.assertEqual(u'Sch\\xf6mberg', d['city'])\n+\n+\n def suite():\n     s = unittest.TestSuite()\n     s.addTest(unittest.makeSuite(GeoIPTest))\n     return s\n \n-def run(verbosity=2):\n+def run(verbosity=1):\n     unittest.TextTestRunner(verbosity=verbosity).run(suite())",
            "previous_filename": "django/contrib/gis/tests/test_geoip.py"
        },
        {
            "sha": "e5bfb2e3671aed4681ff41c212f7f002414aeeaf",
            "filename": "django/contrib/gis/tests/__init__.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Ftests%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Ftests%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Ftests%2F__init__.py?ref=05e29716b446f71eef8318f8093f0c19726ae22f",
            "patch": "@@ -78,10 +78,10 @@ def geodjango_suite(apps=True):\n         sys.stderr.write('GDAL not available - no tests requiring GDAL will be run.\\n')\n \n     # Add GeoIP tests to the suite, if the library and data is available.\n-    from django.contrib.gis.utils import HAS_GEOIP\n+    from django.contrib.gis.geoip import HAS_GEOIP\n     if HAS_GEOIP and hasattr(settings, 'GEOIP_PATH'):\n-        from django.contrib.gis.tests import test_geoip\n-        suite.addTest(test_geoip.suite())\n+        from django.contrib.gis.geoip import tests as geoip_tests\n+        suite.addTest(geoip_tests.suite())\n \n     # Finally, adding the suites for each of the GeoDjango test apps.\n     if apps:"
        },
        {
            "sha": "5d340bd001fdbb61befc4bae4e9b901b572e6c4e",
            "filename": "django/contrib/gis/utils/__init__.py",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/django/django/blob/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Futils%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Futils%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Futils%2F__init__.py?ref=05e29716b446f71eef8318f8093f0c19726ae22f",
            "patch": "@@ -8,18 +8,18 @@\n     from django.contrib.gis.utils.ogrinspect import mapping, ogrinspect\n     from django.contrib.gis.utils.srs import add_postgis_srs, add_srs_entry\n     try:\n-        # LayerMapping requires DJANGO_SETTINGS_MODULE to be set, \n+        # LayerMapping requires DJANGO_SETTINGS_MODULE to be set,\n         # so this needs to be in try/except.\n         from django.contrib.gis.utils.layermapping import LayerMapping, LayerMapError\n     except:\n         pass\n-    \n-# Attempting to import the GeoIP class.\n-try:\n-    from django.contrib.gis.utils.geoip import GeoIP, GeoIPException\n-    HAS_GEOIP = True\n-except:\n-    HAS_GEOIP = False\n \n-from django.contrib.gis.utils.wkt import precision_wkt\n+# GeoIP now lives in `django.contrib.gis.geoip`; this shortcut will be\n+# removed in Django 1.6.\n+from django.contrib.gis.utils import geoip\n+HAS_GEOIP = geoip.HAS_GEOIP\n+if HAS_GEOIP:\n+    GeoIP = geoip.GeoIP\n+    GeoIPException = geoip.GeoIPException\n \n+from django.contrib.gis.utils.wkt import precision_wkt"
        },
        {
            "sha": "2d3b2ae4e6c6cc038538ea14476bfefc1066014f",
            "filename": "django/contrib/gis/utils/geoip.py",
            "status": "modified",
            "additions": 14,
            "deletions": 362,
            "changes": 376,
            "blob_url": "https://github.com/django/django/blob/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Futils%2Fgeoip.py",
            "raw_url": "https://github.com/django/django/raw/05e29716b446f71eef8318f8093f0c19726ae22f/django%2Fcontrib%2Fgis%2Futils%2Fgeoip.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Futils%2Fgeoip.py?ref=05e29716b446f71eef8318f8093f0c19726ae22f",
            "patch": "@@ -1,362 +1,14 @@\n-\"\"\"\n- This module houses the GeoIP object, a ctypes wrapper for the MaxMind GeoIP(R)\n- C API (http://www.maxmind.com/app/c).  This is an alternative to the GPL\n- licensed Python GeoIP interface provided by MaxMind.\n-\n- GeoIP(R) is a registered trademark of MaxMind, LLC of Boston, Massachusetts.\n-\n- For IP-based geolocation, this module requires the GeoLite Country and City\n- datasets, in binary format (CSV will not work!).  The datasets may be\n- downloaded from MaxMind at http://www.maxmind.com/download/geoip/database/.\n- Grab GeoIP.dat.gz and GeoLiteCity.dat.gz, and unzip them in the directory\n- corresponding to settings.GEOIP_PATH.  See the GeoIP docstring and examples\n- below for more details.\n-\n- TODO: Verify compatibility with Windows.\n-\n- Example:\n-\n- >>> from django.contrib.gis.utils import GeoIP\n- >>> g = GeoIP()\n- >>> g.country('google.com')\n- {'country_code': 'US', 'country_name': 'United States'}\n- >>> g.city('72.14.207.99')\n- {'area_code': 650,\n- 'city': 'Mountain View',\n- 'country_code': 'US',\n- 'country_code3': 'USA',\n- 'country_name': 'United States',\n- 'dma_code': 807,\n- 'latitude': 37.419200897216797,\n- 'longitude': -122.05740356445312,\n- 'postal_code': '94043',\n- 'region': 'CA'}\n- >>> g.lat_lon('salon.com')\n- (37.789798736572266, -122.39420318603516)\n- >>> g.lon_lat('uh.edu')\n- (-95.415199279785156, 29.77549934387207)\n- >>> g.geos('24.124.1.80').wkt\n- 'POINT (-95.2087020874023438 39.0392990112304688)'\n-\"\"\"\n-import os\n-import re\n-from ctypes import c_char_p, c_float, c_int, Structure, CDLL, POINTER\n-from ctypes.util import find_library\n-from django.conf import settings\n-if not settings.configured: settings.configure()\n-\n-# Creating the settings dictionary with any settings, if needed.\n-GEOIP_SETTINGS = dict((key, getattr(settings, key))\n-                      for key in ('GEOIP_PATH', 'GEOIP_LIBRARY_PATH', 'GEOIP_COUNTRY', 'GEOIP_CITY')\n-                      if hasattr(settings, key))\n-lib_path = GEOIP_SETTINGS.get('GEOIP_LIBRARY_PATH', None)\n-\n-# GeoIP Exception class.\n-class GeoIPException(Exception): pass\n-\n-# The shared library for the GeoIP C API.  May be downloaded\n-#  from http://www.maxmind.com/download/geoip/api/c/\n-if lib_path:\n-    lib_name = None\n-else:\n-    # TODO: Is this really the library name for Windows?\n-    lib_name = 'GeoIP'\n-\n-# Getting the path to the GeoIP library.\n-if lib_name: lib_path = find_library(lib_name)\n-if lib_path is None: raise GeoIPException('Could not find the GeoIP library (tried \"%s\"). '\n-                                          'Try setting GEOIP_LIBRARY_PATH in your settings.' % lib_name)\n-lgeoip = CDLL(lib_path)\n-\n-# Regular expressions for recognizing IP addresses and the GeoIP\n-# free database editions.\n-ipregex = re.compile(r'^(?P<w>\\d\\d?\\d?)\\.(?P<x>\\d\\d?\\d?)\\.(?P<y>\\d\\d?\\d?)\\.(?P<z>\\d\\d?\\d?)$')\n-free_regex = re.compile(r'^GEO-\\d{3}FREE')\n-lite_regex = re.compile(r'^GEO-\\d{3}LITE')\n-\n-#### GeoIP C Structure definitions ####\n-class GeoIPRecord(Structure):\n-    _fields_ = [('country_code', c_char_p),\n-                ('country_code3', c_char_p),\n-                ('country_name', c_char_p),\n-                ('region', c_char_p),\n-                ('city', c_char_p),\n-                ('postal_code', c_char_p),\n-                ('latitude', c_float),\n-                ('longitude', c_float),\n-                # TODO: In 1.4.6 this changed from `int dma_code;` to\n-                # `union {int metro_code; int dma_code;};`.  Change\n-                # to a `ctypes.Union` in to accomodate in future when\n-                # pre-1.4.6 versions are no longer distributed.\n-                ('dma_code', c_int),\n-                ('area_code', c_int),\n-                # TODO: The following structure fields were added in 1.4.3 --\n-                # uncomment these fields when sure previous versions are no\n-                # longer distributed by package maintainers.\n-                #('charset', c_int),\n-                #('continent_code', c_char_p),\n-                ]\n-class GeoIPTag(Structure): pass\n-\n-#### ctypes function prototypes ####\n-RECTYPE = POINTER(GeoIPRecord)\n-DBTYPE = POINTER(GeoIPTag)\n-\n-# For retrieving records by name or address.\n-def record_output(func):\n-    func.restype = RECTYPE\n-    return func\n-rec_by_addr = record_output(lgeoip.GeoIP_record_by_addr)\n-rec_by_name = record_output(lgeoip.GeoIP_record_by_name)\n-\n-# For opening & closing GeoIP database files.\n-geoip_open = lgeoip.GeoIP_open\n-geoip_open.restype = DBTYPE\n-geoip_close = lgeoip.GeoIP_delete\n-geoip_close.argtypes = [DBTYPE]\n-geoip_close.restype = None\n-\n-# String output routines.\n-def string_output(func):\n-    func.restype = c_char_p\n-    return func\n-geoip_dbinfo = string_output(lgeoip.GeoIP_database_info)\n-cntry_code_by_addr = string_output(lgeoip.GeoIP_country_code_by_addr)\n-cntry_code_by_name = string_output(lgeoip.GeoIP_country_code_by_name)\n-cntry_name_by_addr = string_output(lgeoip.GeoIP_country_name_by_addr)\n-cntry_name_by_name = string_output(lgeoip.GeoIP_country_name_by_name)\n-\n-#### GeoIP class ####\n-class GeoIP(object):\n-    # The flags for GeoIP memory caching.\n-    # GEOIP_STANDARD - read database from filesystem, uses least memory.\n-    #\n-    # GEOIP_MEMORY_CACHE - load database into memory, faster performance\n-    #        but uses more memory\n-    #\n-    # GEOIP_CHECK_CACHE - check for updated database.  If database has been updated,\n-    #        reload filehandle and/or memory cache.\n-    #\n-    # GEOIP_INDEX_CACHE - just cache\n-    #        the most frequently accessed index portion of the database, resulting\n-    #        in faster lookups than GEOIP_STANDARD, but less memory usage than\n-    #        GEOIP_MEMORY_CACHE - useful for larger databases such as\n-    #        GeoIP Organization and GeoIP City.  Note, for GeoIP Country, Region\n-    #        and Netspeed databases, GEOIP_INDEX_CACHE is equivalent to GEOIP_MEMORY_CACHE\n-    #\n-    GEOIP_STANDARD = 0\n-    GEOIP_MEMORY_CACHE = 1\n-    GEOIP_CHECK_CACHE = 2\n-    GEOIP_INDEX_CACHE = 4\n-    cache_options = dict((opt, None) for opt in (0, 1, 2, 4))\n-    _city_file = ''\n-    _country_file = ''\n-\n-    # Initially, pointers to GeoIP file references are NULL.\n-    _city = None\n-    _country = None\n-\n-    def __init__(self, path=None, cache=0, country=None, city=None):\n-        \"\"\"\n-        Initializes the GeoIP object, no parameters are required to use default\n-        settings.  Keyword arguments may be passed in to customize the locations\n-        of the GeoIP data sets.\n-\n-        * path: Base directory to where GeoIP data is located or the full path\n-            to where the city or country data files (*.dat) are located.\n-            Assumes that both the city and country data sets are located in\n-            this directory; overrides the GEOIP_PATH settings attribute.\n-\n-        * cache: The cache settings when opening up the GeoIP datasets,\n-            and may be an integer in (0, 1, 2, 4) corresponding to\n-            the GEOIP_STANDARD, GEOIP_MEMORY_CACHE, GEOIP_CHECK_CACHE,\n-            and GEOIP_INDEX_CACHE `GeoIPOptions` C API settings,\n-            respectively.  Defaults to 0, meaning that the data is read\n-            from the disk.\n-\n-        * country: The name of the GeoIP country data file.  Defaults to\n-            'GeoIP.dat'; overrides the GEOIP_COUNTRY settings attribute.\n-\n-        * city: The name of the GeoIP city data file.  Defaults to\n-            'GeoLiteCity.dat'; overrides the GEOIP_CITY settings attribute.\n-        \"\"\"\n-        # Checking the given cache option.\n-        if cache in self.cache_options:\n-            self._cache = self.cache_options[cache]\n-        else:\n-            raise GeoIPException('Invalid caching option: %s' % cache)\n-\n-        # Getting the GeoIP data path.\n-        if not path:\n-            path = GEOIP_SETTINGS.get('GEOIP_PATH', None)\n-            if not path: raise GeoIPException('GeoIP path must be provided via parameter or the GEOIP_PATH setting.')\n-        if not isinstance(path, basestring):\n-            raise TypeError('Invalid path type: %s' % type(path).__name__)\n-\n-        if os.path.isdir(path):\n-            # Constructing the GeoIP database filenames using the settings\n-            # dictionary.  If the database files for the GeoLite country\n-            # and/or city datasets exist, then try and open them.\n-            country_db = os.path.join(path, country or GEOIP_SETTINGS.get('GEOIP_COUNTRY', 'GeoIP.dat'))\n-            if os.path.isfile(country_db):\n-                self._country = geoip_open(country_db, cache)\n-                self._country_file = country_db\n-\n-            city_db = os.path.join(path, city or GEOIP_SETTINGS.get('GEOIP_CITY', 'GeoLiteCity.dat'))\n-            if os.path.isfile(city_db):\n-                self._city = geoip_open(city_db, cache)\n-                self._city_file = city_db\n-        elif os.path.isfile(path):\n-            # Otherwise, some detective work will be needed to figure\n-            # out whether the given database path is for the GeoIP country\n-            # or city databases.\n-            ptr = geoip_open(path, cache)\n-            info = geoip_dbinfo(ptr)\n-            if lite_regex.match(info):\n-                # GeoLite City database detected.\n-                self._city = ptr\n-                self._city_file = path\n-            elif free_regex.match(info):\n-                # GeoIP Country database detected.\n-                self._country = ptr\n-                self._country_file = path\n-            else:\n-                raise GeoIPException('Unable to recognize database edition: %s' % info)\n-        else:\n-            raise GeoIPException('GeoIP path must be a valid file or directory.')\n-\n-    def __del__(self):\n-        # Cleaning any GeoIP file handles lying around.\n-        if self._country: geoip_close(self._country)\n-        if self._city: geoip_close(self._city)\n-\n-    def _check_query(self, query, country=False, city=False, city_or_country=False):\n-        \"Helper routine for checking the query and database availability.\"\n-        # Making sure a string was passed in for the query.\n-        if not isinstance(query, basestring):\n-            raise TypeError('GeoIP query must be a string, not type %s' % type(query).__name__)\n-\n-        # Extra checks for the existence of country and city databases.\n-        if city_or_country and not (self._country or self._city):\n-            raise GeoIPException('Invalid GeoIP country and city data files.')\n-        elif country and not self._country:\n-            raise GeoIPException('Invalid GeoIP country data file: %s' % self._country_file)\n-        elif city and not self._city:\n-            raise GeoIPException('Invalid GeoIP city data file: %s' % self._city_file)\n-\n-    def city(self, query):\n-        \"\"\"\n-        Returns a dictionary of city information for the given IP address or\n-        Fully Qualified Domain Name (FQDN).  Some information in the dictionary\n-        may be undefined (None).\n-        \"\"\"\n-        self._check_query(query, city=True)\n-        if ipregex.match(query):\n-            # If an IP address was passed in\n-            ptr = rec_by_addr(self._city, c_char_p(query))\n-        else:\n-            # If a FQDN was passed in.\n-            ptr = rec_by_name(self._city, c_char_p(query))\n-\n-        # Checking the pointer to the C structure, if valid pull out elements\n-        # into a dicionary and return.\n-        if bool(ptr):\n-            record = ptr.contents\n-            return dict((tup[0], getattr(record, tup[0])) for tup in record._fields_)\n-        else:\n-            return None\n-\n-    def country_code(self, query):\n-        \"Returns the country code for the given IP Address or FQDN.\"\n-        self._check_query(query, city_or_country=True)\n-        if self._country:\n-            if ipregex.match(query): return cntry_code_by_addr(self._country, query)\n-            else: return cntry_code_by_name(self._country, query)\n-        else:\n-            return self.city(query)['country_code']\n-\n-    def country_name(self, query):\n-        \"Returns the country name for the given IP Address or FQDN.\"\n-        self._check_query(query, city_or_country=True)\n-        if self._country:\n-            if ipregex.match(query): return cntry_name_by_addr(self._country, query)\n-            else: return cntry_name_by_name(self._country, query)\n-        else:\n-            return self.city(query)['country_name']\n-\n-    def country(self, query):\n-        \"\"\"\n-        Returns a dictonary with with the country code and name when given an\n-        IP address or a Fully Qualified Domain Name (FQDN).  For example, both\n-        '24.124.1.80' and 'djangoproject.com' are valid parameters.\n-        \"\"\"\n-        # Returning the country code and name\n-        return {'country_code' : self.country_code(query),\n-                'country_name' : self.country_name(query),\n-                }\n-\n-    #### Coordinate retrieval routines ####\n-    def coords(self, query, ordering=('longitude', 'latitude')):\n-        cdict = self.city(query)\n-        if cdict is None: return None\n-        else: return tuple(cdict[o] for o in ordering)\n-\n-    def lon_lat(self, query):\n-        \"Returns a tuple of the (longitude, latitude) for the given query.\"\n-        return self.coords(query)\n-\n-    def lat_lon(self, query):\n-        \"Returns a tuple of the (latitude, longitude) for the given query.\"\n-        return self.coords(query, ('latitude', 'longitude'))\n-\n-    def geos(self, query):\n-        \"Returns a GEOS Point object for the given query.\"\n-        ll = self.lon_lat(query)\n-        if ll:\n-            from django.contrib.gis.geos import Point\n-            return Point(ll, srid=4326)\n-        else:\n-            return None\n-\n-    #### GeoIP Database Information Routines ####\n-    def country_info(self):\n-        \"Returns information about the GeoIP country database.\"\n-        if self._country is None:\n-            ci = 'No GeoIP Country data in \"%s\"' % self._country_file\n-        else:\n-            ci = geoip_dbinfo(self._country)\n-        return ci\n-    country_info = property(country_info)\n-\n-    def city_info(self):\n-        \"Retuns information about the GeoIP city database.\"\n-        if self._city is None:\n-            ci = 'No GeoIP City data in \"%s\"' % self._city_file\n-        else:\n-            ci = geoip_dbinfo(self._city)\n-        return ci\n-    city_info = property(city_info)\n-\n-    def info(self):\n-        \"Returns information about all GeoIP databases in use.\"\n-        return 'Country:\\n\\t%s\\nCity:\\n\\t%s' % (self.country_info, self.city_info)\n-    info = property(info)\n-\n-    #### Methods for compatibility w/the GeoIP-Python API. ####\n-    @classmethod\n-    def open(cls, full_path, cache):\n-        return GeoIP(full_path, cache)\n-\n-    def _rec_by_arg(self, arg):\n-        if self._city:\n-            return self.city(arg)\n-        else:\n-            return self.country(arg)\n-    region_by_addr = city\n-    region_by_name = city\n-    record_by_addr = _rec_by_arg\n-    record_by_name = _rec_by_arg\n-    country_code_by_addr = country_code\n-    country_code_by_name = country_code\n-    country_name_by_addr = country_name\n-    country_name_by_name = country_name\n+import warnings\n+\n+from django.contrib.gis import geoip\n+HAS_GEOIP = geoip.HAS_GEOIP\n+if HAS_GEOIP:\n+    BaseGeoIP = geoip.GeoIP\n+    GeoIPException = geoip.GeoIPException\n+\n+    class GeoIP(BaseGeoIP):\n+        def __init__(self, *args, **kwargs):\n+            warnings.warn('GeoIP class has been moved to `django.contrib.gis.geoip`, and '\n+                          'this shortcut will disappear in Django v1.6.',\n+                          PendingDeprecationWarning, stacklevel=2)\n+            super(GeoIP, self).__init__(*args, **kwargs)"
        },
        {
            "sha": "88354e1b4162579c1897fbc9c8a2615eaea56497",
            "filename": "docs/internals/deprecation.txt",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/05e29716b446f71eef8318f8093f0c19726ae22f/docs%2Finternals%2Fdeprecation.txt",
            "raw_url": "https://github.com/django/django/raw/05e29716b446f71eef8318f8093f0c19726ae22f/docs%2Finternals%2Fdeprecation.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Finternals%2Fdeprecation.txt?ref=05e29716b446f71eef8318f8093f0c19726ae22f",
            "patch": "@@ -239,6 +239,10 @@ their deprecation, as per the :ref:`deprecation policy\n       were deprecated since Django 1.4 and will be removed in favor\n       of the ``django.utils.text.Truncator`` class.\n \n+    * The :class:`~django.contrib.gis.geoip.GeoIP` class was moved to\n+      :mod:`django.contrib.gis.geoip` in 1.4 -- the shortcut in\n+      :mod:`django.contrib.gis.utils` will be removed.\n+\n 2.0\n ---\n "
        },
        {
            "sha": "62185834ca21e30e55e8adc29756f41e8a64c2c7",
            "filename": "docs/ref/contrib/gis/geoip.txt",
            "status": "modified",
            "additions": 12,
            "deletions": 5,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/05e29716b446f71eef8318f8093f0c19726ae22f/docs%2Fref%2Fcontrib%2Fgis%2Fgeoip.txt",
            "raw_url": "https://github.com/django/django/raw/05e29716b446f71eef8318f8093f0c19726ae22f/docs%2Fref%2Fcontrib%2Fgis%2Fgeoip.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fcontrib%2Fgis%2Fgeoip.txt?ref=05e29716b446f71eef8318f8093f0c19726ae22f",
            "patch": "@@ -4,10 +4,17 @@\n Geolocation with GeoIP\n ======================\n \n-.. module:: django.contrib.gis.utils.geoip\n+.. module:: django.contrib.gis.geoip\n    :synopsis: High-level Python interface for MaxMind's GeoIP C library.\n \n-.. currentmodule:: django.contrib.gis.utils\n+.. versionchanged:: 1.4\n+\n+.. note::\n+\n+    In Django 1.4, the :class:`GeoIP` object was moved out of\n+    :mod:`django.contrib.gis.utils` and into its own module, \n+    :mod:`django.contrib.gis.geoip`. A shortcut is still provided\n+    in ``utils``, but will be removed in Django 1.6.\n \n The :class:`GeoIP` object is a ctypes wrapper for the\n `MaxMind GeoIP C API`__. [#]_  This interface is a BSD-licensed alternative\n@@ -136,15 +143,15 @@ Querying\n \n All the following querying routines may take either a string IP address\n or a fully qualified domain name (FQDN).  For example, both \n-``'24.124.1.80'`` and ``'djangoproject.com'`` would be valid query \n+``'205.186.163.125'`` and ``'djangoproject.com'`` would be valid query \n parameters. \n \n .. method:: GeoIP.city(query)\n \n Returns a dictionary of city information for the given query.  Some\n of the values in the dictionary may be undefined (``None``).\n \n-.. method:: GeoIPcountry(query)\n+.. method:: GeoIP.country(query)\n \n Returns a dictionary with the country code and country for the given \n query.\n@@ -190,7 +197,7 @@ This property returns information about the GeoIP city database.\n .. attribute:: GeoIP.info\n \n This property returns information about all GeoIP databases (both city\n-and country).\n+and country), and the version of the GeoIP C library (if supported).\n \n GeoIP-Python API compatibility methods\n ----------------------------------------"
        },
        {
            "sha": "1b1e7688d066274e84d8b1d4e1ec1c0f6d4081ef",
            "filename": "docs/ref/contrib/gis/index.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/05e29716b446f71eef8318f8093f0c19726ae22f/docs%2Fref%2Fcontrib%2Fgis%2Findex.txt",
            "raw_url": "https://github.com/django/django/raw/05e29716b446f71eef8318f8093f0c19726ae22f/docs%2Fref%2Fcontrib%2Fgis%2Findex.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fcontrib%2Fgis%2Findex.txt?ref=05e29716b446f71eef8318f8093f0c19726ae22f",
            "patch": "@@ -22,6 +22,7 @@ of spatially enabled data.\n    measure\n    geos\n    gdal\n+   geoip\n    utils\n    commands\n    admin"
        },
        {
            "sha": "fee6325437d1e90475461417676cb0626a259cd7",
            "filename": "docs/ref/contrib/gis/utils.txt",
            "status": "modified",
            "additions": 0,
            "deletions": 15,
            "changes": 15,
            "blob_url": "https://github.com/django/django/blob/05e29716b446f71eef8318f8093f0c19726ae22f/docs%2Fref%2Fcontrib%2Fgis%2Futils.txt",
            "raw_url": "https://github.com/django/django/raw/05e29716b446f71eef8318f8093f0c19726ae22f/docs%2Fref%2Fcontrib%2Fgis%2Futils.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fcontrib%2Fgis%2Futils.txt?ref=05e29716b446f71eef8318f8093f0c19726ae22f",
            "patch": "@@ -13,20 +13,5 @@ useful in creating geospatial Web applications.\n .. toctree::\n    :maxdepth: 2\n \n-   geoip\n    layermapping\n    ogrinspect\n-\n-GeoIP\n-=====\n-\n-Interface to the MaxMind GeoIP library for performing IP-based geolocation\n-from GeoDjango.  See :ref:`GeoIP reference <ref-geoip>` documentation for\n-more information.\n-\n-LayerMapping\n-============\n-\n-The :class:`~django.contrib.gis.utils.LayerMapping` simplifies the process\n-of importing spatial data and attributes into your GeoDjango models.\n-"
        }
    ],
    "stats": {
        "total": 873,
        "additions": 472,
        "deletions": 401
    }
}