{
    "author": "ubernostrum",
    "message": "Merge pull request #363 from ubernostrum/multidb-examples-18657\n\nTicket 18657: Fix inconsistent DB names in router example.",
    "sha": "c26dd4f154fe9d7aedeb28b0de4bb8cca85b55f9",
    "files": [
        {
            "sha": "d2ff8645a96c2f45943d85e243a1555ab5cec4e7",
            "filename": "docs/topics/db/multi-db.txt",
            "status": "modified",
            "additions": 92,
            "deletions": 36,
            "changes": 128,
            "blob_url": "https://github.com/django/django/blob/c26dd4f154fe9d7aedeb28b0de4bb8cca85b55f9/docs%2Ftopics%2Fdb%2Fmulti-db.txt",
            "raw_url": "https://github.com/django/django/raw/c26dd4f154fe9d7aedeb28b0de4bb8cca85b55f9/docs%2Ftopics%2Fdb%2Fmulti-db.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Fmulti-db.txt?ref=c26dd4f154fe9d7aedeb28b0de4bb8cca85b55f9",
            "patch": "@@ -201,73 +201,129 @@ An example\n     write to propagate to the slaves). It also doesn't consider the\n     interaction of transactions with the database utilization strategy.\n \n-So - what does this mean in practice? Say you want ``myapp`` to\n-exist on the ``other`` database, and you want all other models in a\n-master/slave relationship between the databases ``master``, ``slave1`` and\n-``slave2``. To implement this, you would need 2 routers::\n+So - what does this mean in practice? Let's consider another sample\n+configuration. This one will have several databases: one for the\n+``auth`` application, and all other apps using a master/slave setup\n+with two read slaves. Here are the settings specifying these\n+databases::\n \n-    class MyAppRouter(object):\n-        \"\"\"A router to control all database operations on models in\n-        the myapp application\"\"\"\n+    DATABASES = {\n+        'auth_db': {\n+            'NAME': 'auth_db',\n+            'ENGINE': 'django.db.backends.mysql',\n+            'USER': 'mysql_user',\n+            'PASSWORD': 'swordfish',\n+        },\n+        'master': {\n+            'NAME': 'master',\n+            'ENGINE': 'django.db.backends.mysql',\n+            'USER': 'mysql_user',\n+            'PASSWORD': 'spam',\n+        },\n+        'slave1': {\n+            'NAME': 'slave1',\n+            'ENGINE': 'django.db.backends.mysql',\n+            'USER': 'mysql_user',\n+            'PASSWORD': 'eggs',\n+        },\n+        'slave2': {\n+            'NAME': 'slave2',\n+            'ENGINE': 'django.db.backends.mysql',\n+            'USER': 'mysql_user',\n+            'PASSWORD': 'bacon',\n+        },\n+    }\n+\n+Now we'll need to handle routing. First we want a router that knows to\n+send queries for the ``auth`` app to ``auth_db``::\n \n+    class AuthRouter(object):\n+        \"\"\"\n+        A router to control all database operations on models in the\n+        auth application.\n+        \"\"\"\n         def db_for_read(self, model, **hints):\n-            \"Point all operations on myapp models to 'other'\"\n-            if model._meta.app_label == 'myapp':\n-                return 'other'\n+            \"\"\"\n+            Attempts to read auth models go to auth_db.\n+            \"\"\"\n+            if model._meta.app_label == 'auth':\n+                return 'auth_db'\n             return None\n \n         def db_for_write(self, model, **hints):\n-            \"Point all operations on myapp models to 'other'\"\n-            if model._meta.app_label == 'myapp':\n-                return 'other'\n+            \"\"\"\n+            Attempts to write auth models go to auth_db.\n+            \"\"\"\n+            if model._meta.app_label == 'auth':\n+                return 'auth_db'\n             return None\n \n         def allow_relation(self, obj1, obj2, **hints):\n-            \"Allow any relation if a model in myapp is involved\"\n-            if obj1._meta.app_label == 'myapp' or obj2._meta.app_label == 'myapp':\n-                return True\n+            \"\"\"\n+            Allow relations if a model in the auth app is involved.\n+            \"\"\"\n+            if obj1._meta.app_label == 'auth' or \\\n+               obj2._meta.app_label == 'auth':\n+               return True\n             return None\n \n         def allow_syncdb(self, db, model):\n-            \"Make sure the myapp app only appears on the 'other' db\"\n-            if db == 'other':\n-                return model._meta.app_label == 'myapp'\n-            elif model._meta.app_label == 'myapp':\n+            \"\"\"\n+            Make sure the auth app only appears in the 'auth_db'\n+            database.\n+            \"\"\"\n+            if db == 'auth_db':\n+                return model._meta.app_label == 'auth'\n+            elif model._meta.app_label == 'auth':\n                 return False\n             return None\n \n-    class MasterSlaveRouter(object):\n-        \"\"\"A router that sets up a simple master/slave configuration\"\"\"\n+And we also want a router that sends all other apps to the\n+master/slave configuration, and randomly chooses a slave to read\n+from::\n \n+    import random\n+\n+    class MasterSlaveRouter(object):\n         def db_for_read(self, model, **hints):\n-            \"Point all read operations to a random slave\"\n-            return random.choice(['slave1','slave2'])\n+            \"\"\"\n+            Reads go to a randomly-chosen slave.\n+            \"\"\"\n+            return random.choice(['slave1', 'slave2'])\n \n         def db_for_write(self, model, **hints):\n-            \"Point all write operations to the master\"\n+            \"\"\"\n+            Writes always go to master.\n+            \"\"\"\n             return 'master'\n \n         def allow_relation(self, obj1, obj2, **hints):\n-            \"Allow any relation between two objects in the db pool\"\n-            db_list = ('master','slave1','slave2')\n-            if obj1._state.db in db_list and obj2._state.db in db_list:\n+            \"\"\"\n+            Relations between objects are allowed if both objects are\n+            in the master/slave pool.\n+            \"\"\"\n+            db_list = ('master', 'slave1', 'slave2')\n+            if obj1.state.db in db_list and obj2.state.db in db_list:\n                 return True\n             return None\n \n         def allow_syncdb(self, db, model):\n-            \"Explicitly put all models on all databases.\"\n+            \"\"\"\n+            All non-auth models end up in this pool.\n+            \"\"\"\n             return True\n \n-Then, in your settings file, add the following (substituting ``path.to.`` with\n-the actual python path to the module where you define the routers)::\n+Finally, in the settings file, we add the following (substituting\n+``path.to.`` with the actual python path to the module(s) where the\n+routers are defined)::\n \n-    DATABASE_ROUTERS = ['path.to.MyAppRouter', 'path.to.MasterSlaveRouter']\n+    DATABASE_ROUTERS = ['path.to.AuthRouter', 'path.to.MasterSlaveRouter']\n \n The order in which routers are processed is significant. Routers will\n be queried in the order the are listed in the\n :setting:`DATABASE_ROUTERS` setting . In this example, the\n-``MyAppRouter`` is processed before the ``MasterSlaveRouter``, and as a\n-result, decisions concerning the models in ``myapp`` are processed\n+``AuthRouter`` is processed before the ``MasterSlaveRouter``, and as a\n+result, decisions concerning the models in ``auth`` are processed\n before any other decision is made. If the :setting:`DATABASE_ROUTERS`\n setting listed the two routers in the other order,\n ``MasterSlaveRouter.allow_syncdb()`` would be processed first. The\n@@ -276,11 +332,11 @@ that all models would be available on all databases.\n \n With this setup installed, lets run some Django code::\n \n-    >>> # This retrieval will be performed on the 'credentials' database\n+    >>> # This retrieval will be performed on the 'auth_db' database\n     >>> fred = User.objects.get(username='fred')\n     >>> fred.first_name = 'Frederick'\n \n-    >>> # This save will also be directed to 'credentials'\n+    >>> # This save will also be directed to 'auth_db'\n     >>> fred.save()\n \n     >>> # These retrieval will be randomly allocated to a slave database"
        }
    ],
    "stats": {
        "total": 128,
        "additions": 92,
        "deletions": 36
    }
}