{
    "author": "aaugustin",
    "message": "[py3] Wrote Django-specific porting tips\n\nand extended the existing Python 3 documentation.",
    "sha": "500fe9c639f37533fb8525d53dacbe986c0e3a9f",
    "files": [
        {
            "sha": "589856bd4ed421327c60007170f59a477d1714a2",
            "filename": "docs/topics/python3.txt",
            "status": "modified",
            "additions": 276,
            "deletions": 35,
            "changes": 311,
            "blob_url": "https://github.com/django/django/blob/500fe9c639f37533fb8525d53dacbe986c0e3a9f/docs%2Ftopics%2Fpython3.txt",
            "raw_url": "https://github.com/django/django/raw/500fe9c639f37533fb8525d53dacbe986c0e3a9f/docs%2Ftopics%2Fpython3.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fpython3.txt?ref=500fe9c639f37533fb8525d53dacbe986c0e3a9f",
            "patch": "@@ -1,25 +1,212 @@\n-======================\n-Python 3 compatibility\n-======================\n+===================\n+Porting to Python 3\n+===================\n \n Django 1.5 is the first version of Django to support Python 3. The same code\n runs both on Python 2 (≥ 2.6.5) and Python 3 (≥ 3.2), thanks to the six_\n-compatibility layer and ``unicode_literals``.\n+compatibility layer.\n \n .. _six: http://packages.python.org/six/\n \n-This document is not meant as a Python 2 to Python 3 migration guide. There\n-are many existing resources, including `Python's official porting guide`_.\n-Rather, it describes guidelines that apply to Django's code and are\n-recommended for pluggable apps that run with both Python 2 and 3.\n+This document is primarily targeted at authors of pluggable application\n+who want to support both Python 2 and 3. It also describes guidelines that\n+apply to Django's code.\n+\n+Philosophy\n+==========\n+\n+This document assumes that you are familiar with the changes between Python 2\n+and Python 3. If you aren't, read `Python's official porting guide`_ first.\n+Refreshing your knowledge of unicode handling on Python 2 and 3 will help; the\n+`Pragmatic Unicode`_ presentation is a good resource.\n+\n+Django uses the *Python 2/3 Compatible Source* strategy. Of course, you're\n+free to chose another strategy for your own code, especially if you don't need\n+to stay compatible with Python 2. But authors of pluggable applications are\n+encouraged to use the same porting strategy as Django itself.\n+\n+Writing compatible code is much easier if you target Python ≥ 2.6. You will\n+most likely take advantage of the compatibility functions introduced in Django\n+1.5, like :mod:`django.utils.six`, so your application will also require\n+Django ≥ 1.5.\n+\n+Obviously, writing compatible source code adds some overhead, and that can\n+cause frustration. Django's developers have found that attempting to write\n+Python 3 code that's compatible with Python 2 is much more rewarding than the\n+opposite. Not only does that make your code more future-proof, but Python 3's\n+advantages (like the saner string handling) start shining quickly. Dealing\n+with Python 2 becomes a backwards compatibility requirement, and we as\n+developers are used to dealing with such constraints.\n+\n+Porting tools provided by Django are inspired by this philosophy, and it's\n+reflected throughout this guide.\n \n .. _Python's official porting guide: http://docs.python.org/py3k/howto/pyporting.html\n+.. _Pragmatic Unicode: http://nedbatchelder.com/text/unipain.html\n+\n+Porting tips\n+============\n+\n+Unicode literals\n+----------------\n+\n+This step consists in:\n+\n+- Adding ``from __future__ import unicode_literals`` at the top of your Python\n+  modules -- it's best to put it in each and every module, otherwise you'll\n+  keep checking the top of your files to see which mode is in effect;\n+- Removing the ``u`` prefix before unicode strings;\n+- Adding a ``b`` prefix before bytestrings.\n+\n+Performing these changes systematically guarantees backwards compatibility.\n+\n+However, Django applications generally don't need bytestrings, since Django\n+only exposes unicode interfaces to the programmer. Python 3 discourages using\n+bytestrings, except for binary data or byte-oriented interfaces. Python 2\n+makes bytestrings and unicode strings effectively interchangeable, as long as\n+they only contain ASCII data. Take advantage of this to use unicode strings\n+wherever possible and avoid the ``b`` prefixes.\n+\n+.. note::\n+\n+    Python 2's ``u`` prefix is a syntax error in Python 3.2 but it will be\n+    allowed again in Python 3.3 thanks to :pep:`414`. Thus, this\n+    transformation is optional if you target Python ≥ 3.3. It's still\n+    recommended, per the \"write Python 3 code\" philosophy.\n+\n+String handling\n+---------------\n+\n+Python 2's :class:`unicode` type was renamed :class:`str` in Python 3,\n+:class:`str` was renamed :class:`bytes`, and :class:`basestring` disappeared.\n+six_ provides :ref:`tools <string-handling-with-six>` to deal with these\n+changes.\n+\n+Django also contains several string related classes and functions in the\n+:mod:`django.utils.encoding` and :mod:`django.utils.safestring` modules. Their\n+names used the words ``str``, which doesn't mean the same thing in Python 2\n+and Python 3, and ``unicode``, which doesn't exist in Python 3. In order to\n+avoid ambiguity and confusion these concepts were renamed ``bytes`` and\n+``text``.\n+\n+Here are the name changes in :mod:`django.utils.encoding`:\n+\n+==================  ==================\n+Old name            New name\n+==================  ==================\n+``smart_str``       ``smart_bytes``\n+``smart_unicode``   ``smart_text``\n+``force_unicode``   ``force_text``\n+==================  ==================\n+\n+For backwards compatibility, the old names still work on Python 2. Under\n+Python 3, ``smart_str`` is an alias for ``smart_text``.\n+\n+.. note::\n+\n+    :mod:`django.utils.encoding` was deeply refactored in Django 1.5 to\n+    provide a more consistent API. Check its documentation for more\n+    information.\n+\n+:mod:`django.utils.safestring` is mostly used via the\n+:func:`~django.utils.safestring.mark_safe` and\n+:func:`~django.utils.safestring.mark_for_escaping` functions, which didn't\n+change. In case you're using the internals, here are the name changes:\n+\n+==================  ==================\n+Old name            New name\n+==================  ==================\n+``EscapeString``    ``EscapeBytes``\n+``EscapeUnicode``   ``EscapeText``\n+``SafeString``      ``SafeBytes``\n+``SafeUnicode``     ``SafeText``\n+==================  ==================\n+\n+For backwards compatibility, the old names still work on Python 2. Under\n+Python 3, ``EscapeString`` and ``SafeString`` are aliases for ``EscapeText``\n+and ``SafeText`` respectively.\n+\n+:meth:`__str__` and :meth:`__unicode__` methods\n+-----------------------------------------------\n+\n+In Python 2, the object model specifies :meth:`__str__` and\n+:meth:`__unicode__` methods. If these methods exist, they must return\n+:class:`str` (bytes) and :class:`unicode` (text) respectively.\n+\n+The ``print`` statement and the :func:`str` built-in call :meth:`__str__` to\n+determine the human-readable representation of an object. The :func:`unicode`\n+built-in calls :meth:`__unicode__` if it exists, and otherwise falls back to\n+:meth:`__str__` and decodes the result with the system encoding. Conversely,\n+the :class:`~django.db.models.Model` base class automatically derives\n+:meth:`__str__` from :meth:`__unicode__` by encoding to UTF-8.\n+\n+In Python 3, there's simply :meth:`__str__`, which must return :class:`str`\n+(text).\n+\n+(It is also possible to define :meth:`__bytes__`, but Django application have\n+little use for that method, because they hardly ever deal with\n+:class:`bytes`.)\n+\n+Django provides a simple way to define :meth:`__str__` and :meth:`__unicode__`\n+methods that work on Python 2 and 3: you must define a :meth:`__str__` method\n+returning text and to apply the\n+:func:`~django.utils.encoding.python_2_unicode_compatible` decorator.\n+\n+On Python 3, the decorator is a no-op. On Python 2, it defines appropriate\n+:meth:`__unicode__` and :meth:`__str__` methods (replacing the original\n+:meth:`__str__` method in the process). Here's an example::\n+\n+    from __future__ import unicode_literals\n+    from django.utils.encoding import python_2_unicode_compatible\n+\n+    @python_2_unicode_compatible\n+    class MyClass(object):\n+        def __str__(self):\n+            return \"Instance of my class\"\n+\n+This technique is the best match for Django's porting philosophy.\n+\n+Finally, note that :meth:`__repr__` must return a :class:`str` on all versions\n+of Python.\n+\n+:class:`dict` and :class:`dict`-like classes\n+--------------------------------------------\n+\n+:meth:`dict.keys`, :meth:`dict.items` and :meth:`dict.values` return lists in\n+Python 2 and iterators in Python 3. :class:`~django.http.QueryDict` and the\n+:class:`dict`-like classes defined in :mod:`django.utils.datastructures`\n+behave likewise in Python 3.\n+\n+six_ provides compatibility functions to work around this change:\n+:func:`~six.iterkeys`, :func:`~six.iteritems`, and :func:`~six.itervalues`.\n+Django's bundled version adds :func:`~django.utils.six.iterlists` for\n+:class:`~django.utils.datastructures.MultiValueDict` and its subclasses.\n+\n+:class:`~django.http.HttpRequest` and :class:`~django.http.HttpResponse` objects\n+--------------------------------------------------------------------------------\n+\n+According to :pep:`3333`:\n+\n+- headers are always :class:`str` objects,\n+- input and output streams are always :class:`bytes` objects.\n+\n+Specifically, :attr:`HttpResponse.content <django.http.HttpResponse.content>`\n+contains :class:`bytes`, which may require refactoring your tests.This won't\n+be an issue if you use :meth:`~django.test.TestCase.assertContains` and\n+:meth:`~django.test.TestCase.assertNotContains`: these methods expect a\n+unicode string.\n+\n+Coding guidelines\n+=================\n+\n+The following guidelines are enforced in Django's source code. They're also\n+recommended for third-party application who follow the same porting strategy.\n \n Syntax requirements\n-===================\n+-------------------\n \n Unicode\n--------\n+~~~~~~~\n \n In Python 3, all strings are considered Unicode by default. The ``unicode``\n type from Python 2 is called ``str`` in Python 3, and ``str`` becomes\n@@ -36,29 +223,25 @@ In order to enable the same behavior in Python 2, every module must import\n     my_string = \"This is an unicode literal\"\n     my_bytestring = b\"This is a bytestring\"\n \n-In classes, define ``__str__`` methods returning unicode strings and apply the\n-:func:`~django.utils.encoding.python_2_unicode_compatible` decorator. It will\n-define appropriate ``__unicode__`` and ``__str__`` in Python 2::\n-\n-    from __future__ import unicode_literals\n-    from django.utils.encoding import python_2_unicode_compatible\n-\n-    @python_2_unicode_compatible\n-    class MyClass(object):\n-        def __str__(self):\n-            return \"Instance of my class\"\n-\n If you need a byte string literal under Python 2 and a unicode string literal\n under Python 3, use the :func:`str` builtin::\n \n     str('my string')\n \n+In Python 3, there aren't any automatic conversions between :class:`str` and\n+:class:`bytes`, and the :mod:`codecs` module became more strict.\n+:meth:`str.decode` always returns :class:`bytes`, and :meth:`bytes.decode`\n+always returns :class:`str`. As a consequence, the following pattern is\n+sometimes necessary::\n+\n+    value = value.encode('ascii', 'ignore').decode('ascii')\n+\n Be cautious if you have to `slice bytestrings`_.\n \n .. _slice bytestrings: http://docs.python.org/py3k/howto/pyporting.html#bytes-literals\n \n Exceptions\n-----------\n+~~~~~~~~~~\n \n When you capture exceptions, use the ``as`` keyword::\n \n@@ -71,17 +254,64 @@ This older syntax was removed in Python 3::\n \n     try:\n         ...\n-    except MyException, exc:\n+    except MyException, exc:    # Don't do that!\n         ...\n \n The syntax to reraise an exception with a different traceback also changed.\n Use :func:`six.reraise`.\n \n+Magic methods\n+-------------\n+\n+Use the patterns below to handle magic methods renamed in Python 3.\n+\n+Iterators\n+~~~~~~~~~\n+\n+::\n+\n+    class MyIterator(object):\n+        def __iter__(self):\n+            return self             # implement some logic here\n+\n+        def __next__(self):\n+            raise StopIteration     # implement some logic here\n+\n+        next = __next__             # Python 2 compatibility\n+\n+Boolean evaluation\n+~~~~~~~~~~~~~~~~~~\n+\n+::\n+\n+    class MyBoolean(object):\n+\n+        def __bool__(self):\n+            return True             # implement some logic here\n+\n+        __nonzero__ = __bool__      # Python 2 compatibility\n+\n+Division\n+~~~~~~~~\n+\n+::\n+\n+    class MyDivisible(object):\n+\n+        def __truediv__(self, other):\n+            return self / other     # implement some logic here\n+\n+    __div__ = __truediv__           # Python 2 compatibility\n+\n+    def __itruediv__(self, other):\n+            return self // other    # implement some logic here\n+\n+    __idiv__ = __itruediv__         # Python 2 compatibility\n \n .. module: django.utils.six\n \n Writing compatible code with six\n-================================\n+--------------------------------\n \n six_ is the canonical compatibility library for supporting Python 2 and 3 in\n a single codebase. Read its documentation!\n@@ -90,8 +320,10 @@ a single codebase. Read its documentation!\n \n Here are the most common changes required to write compatible code.\n \n-String types\n-------------\n+.. _string-handling-with-six:\n+\n+String handling\n+~~~~~~~~~~~~~~~\n \n The ``basestring`` and ``unicode`` types were removed in Python 3, and the\n meaning of ``str`` changed. To test these types, use the following idioms::\n@@ -104,29 +336,35 @@ Python ≥ 2.6 provides ``bytes`` as an alias for ``str``, so you don't need\n :attr:`six.binary_type`.\n \n ``long``\n---------\n+~~~~~~~~\n \n The ``long`` type no longer exists in Python 3. ``1L`` is a syntax error. Use\n :data:`six.integer_types` check if a value is an integer or a long::\n \n     isinstance(myvalue, six.integer_types)      # replacement for (int, long)\n \n ``xrange``\n-----------\n+~~~~~~~~~~\n \n Import :func:`six.moves.xrange` wherever you use ``xrange``.\n \n Moved modules\n--------------\n+~~~~~~~~~~~~~\n \n Some modules were renamed in Python 3. The :mod:`django.utils.six.moves\n <six.moves>` module provides a compatible location to import them.\n \n-In addition to six' defaults, Django's version provides ``thread`` as\n-``_thread`` and ``dummy_thread`` as ``_dummy_thread``.\n+The ``urllib``, ``urllib2`` and ``urlparse`` modules were reworked in depth\n+and :mod:`django.utils.six.moves <six.moves>` doesn't handle them. Django\n+explicitly tries both locations, as follows::\n+\n+    try:\n+        from urllib.parse import urlparse, urlunparse\n+    except ImportError:     # Python 2\n+        from urlparse import urlparse, urlunparse\n \n PY3\n----\n+~~~\n \n If you need different code in Python 2 and Python 3, check :data:`six.PY3`::\n \n@@ -141,9 +379,9 @@ function.\n .. module:: django.utils.six\n \n Customizations of six\n-=====================\n+---------------------\n \n-The version of six bundled with Django includes a few additional tools:\n+The version of six bundled with Django includes one extra function:\n \n .. function:: iterlists(MultiValueDict)\n \n@@ -152,3 +390,6 @@ The version of six bundled with Django includes a few additional tools:\n     :meth:`~django.utils.datastructures.MultiValueDict.iterlists()` on Python\n     2 and :meth:`~django.utils.datastructures.MultiValueDict.lists()` on\n     Python 3.\n+\n+In addition to six' defaults moves, Django's version provides ``thread`` as\n+``_thread`` and ``dummy_thread`` as ``_dummy_thread``."
        }
    ],
    "stats": {
        "total": 311,
        "additions": 276,
        "deletions": 35
    }
}