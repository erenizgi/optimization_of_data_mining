{
    "author": "freakboy3742",
    "message": "Fixed #9964 -- Ensure that all database operations make transactions dirty, not just write operations. Many thanks to Shai Berger for his work and persistence on this issue.\n\nThis is BACKWARDS INCOMPATIBLE for anyone relying on the current behavior that allows manually managed read-only transactions to be left dangling without a manual commit or rollback.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15493 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "6314a1b42e4f695b4c575585375fe91697911d5c",
    "files": [
        {
            "sha": "6c90cd09f318400b2f1fc9bd281c427f6da1996d",
            "filename": "AUTHORS",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/6314a1b42e4f695b4c575585375fe91697911d5c/AUTHORS",
            "raw_url": "https://github.com/django/django/raw/6314a1b42e4f695b4c575585375fe91697911d5c/AUTHORS",
            "contents_url": "https://api.github.com/repos/django/django/contents/AUTHORS?ref=6314a1b42e4f695b4c575585375fe91697911d5c",
            "patch": "@@ -78,6 +78,7 @@ answer newbie questions, and generally made Django that much better:\n     Esdras Beleza <linux@esdrasbeleza.com>\n     Chris Bennett <chrisrbennett@yahoo.com>\n     James Bennett\n+    Shai Berger <shai@platonix.com>\n     Julian Bez\n     Arvis Bickovskis <viestards.lists@gmail.com>\n     Natalia Bidart <nataliabidart@gmail.com>"
        },
        {
            "sha": "9be6e83ee1c80a3b2a8aa4531d4a52caca8f5ca5",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/6314a1b42e4f695b4c575585375fe91697911d5c/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/6314a1b42e4f695b4c575585375fe91697911d5c/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=6314a1b42e4f695b4c575585375fe91697911d5c",
            "patch": "@@ -245,10 +245,11 @@ def close(self):\n             self.connection = None\n \n     def cursor(self):\n-        cursor = self._cursor()\n         if (self.use_debug_cursor or\n             (self.use_debug_cursor is None and settings.DEBUG)):\n-            return self.make_debug_cursor(cursor)\n+            cursor = self.make_debug_cursor(self._cursor())\n+        else:\n+            cursor = util.CursorWrapper(self._cursor(), self)\n         return cursor\n \n     def make_debug_cursor(self, cursor):"
        },
        {
            "sha": "6438657b718c72daf60e70f799b237a327aa7050",
            "filename": "django/db/backends/util.py",
            "status": "modified",
            "additions": 23,
            "deletions": 6,
            "changes": 29,
            "blob_url": "https://github.com/django/django/blob/6314a1b42e4f695b4c575585375fe91697911d5c/django%2Fdb%2Fbackends%2Futil.py",
            "raw_url": "https://github.com/django/django/raw/6314a1b42e4f695b4c575585375fe91697911d5c/django%2Fdb%2Fbackends%2Futil.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Futil.py?ref=6314a1b42e4f695b4c575585375fe91697911d5c",
            "patch": "@@ -5,12 +5,28 @@\n from django.utils.hashcompat import md5_constructor\n from django.utils.log import getLogger\n \n+\n logger = getLogger('django.db.backends')\n \n-class CursorDebugWrapper(object):\n-    def __init__(self, cursor, db):\n+\n+class CursorWrapper(object):\n+    def __init__(self, cursor, connection):\n         self.cursor = cursor\n-        self.db = db # Instance of a BaseDatabaseWrapper subclass\n+        self.connection = connection\n+\n+    def __getattr__(self, attr):\n+        if self.connection.is_managed():\n+            self.connection.set_dirty()\n+        if attr in self.__dict__:\n+            return self.__dict__[attr]\n+        else:\n+            return getattr(self.cursor, attr)\n+\n+    def __iter__(self):\n+        return iter(self.cursor)\n+\n+\n+class CursorDebugWrapper(CursorWrapper):\n \n     def execute(self, sql, params=()):\n         start = time()\n@@ -19,8 +35,8 @@ def execute(self, sql, params=()):\n         finally:\n             stop = time()\n             duration = stop - start\n-            sql = self.db.ops.last_executed_query(self.cursor, sql, params)\n-            self.db.queries.append({\n+            sql = self.connection.ops.last_executed_query(self.cursor, sql, params)\n+            self.connection.queries.append({\n                 'sql': sql,\n                 'time': \"%.3f\" % duration,\n             })\n@@ -35,7 +51,7 @@ def executemany(self, sql, param_list):\n         finally:\n             stop = time()\n             duration = stop - start\n-            self.db.queries.append({\n+            self.connection.queries.append({\n                 'sql': '%s times: %s' % (len(param_list), sql),\n                 'time': \"%.3f\" % duration,\n             })\n@@ -52,6 +68,7 @@ def __getattr__(self, attr):\n     def __iter__(self):\n         return iter(self.cursor)\n \n+\n ###############################################\n # Converters from database (string) to Python #\n ###############################################"
        },
        {
            "sha": "aca227f8963bf11cba806b8e596d498c35b3da3c",
            "filename": "docs/releases/1.3.txt",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/django/django/blob/6314a1b42e4f695b4c575585375fe91697911d5c/docs%2Freleases%2F1.3.txt",
            "raw_url": "https://github.com/django/django/raw/6314a1b42e4f695b4c575585375fe91697911d5c/docs%2Freleases%2F1.3.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.3.txt?ref=6314a1b42e4f695b4c575585375fe91697911d5c",
            "patch": "@@ -604,6 +604,42 @@ domain):\n \n .. _corresponding deprecated features section: loading_of_translations_from_the_project_directory_\n \n+Transaction management\n+~~~~~~~~~~~~~~~~~~~~~~\n+\n+When using managed transactions -- that is, anything but the default\n+autocommit mode -- it is important when a transaction is marked as\n+\"dirty\". Dirty transactions are committed by the\n+:func:`~django.db.transaction.commit_on_success` decorator or the\n+:class:`~django.middleware.transaction.TransactionMiddleware`, and\n+:func:`~django.db.transaction.commit_manually` forces them to be\n+closed explicitly; clean transactions \"get a pass\", which means they\n+are usually rolled back at the end of a request when the connection is\n+closed.\n+\n+Until Django 1.3, transactions were only marked dirty when Django was\n+aware of a modifying operation performed in them; that is, either some\n+model was saved, some bulk update or delete was performed, or the user\n+explicitly called ``transaction.set_dirty()``. In Django 1.3, a\n+transaction is marked dirty when *any* database operation is\n+performed.\n+\n+As a result of this change, you no longer need to set a transaction\n+dirty explicitly when you execute raw SQL or use a data-modifying\n+``SELECT``. However, you *do* need to explicitly close any read-only\n+transactions that are being managed using\n+:func:`~django.db.transaction.commit_manually`. For example::\n+\n+      @transaction.commit_manually\n+      def my_view(request, name):\n+      \t  obj = get_object_or_404(MyObject, name__iexact=name)\n+\t  return render_to_response('template', {'object':obj})\n+\n+Prior to Django 1.3, this would work without error. However, under\n+Django 1.3, this will raise a :class:`TransactionManagementError` because\n+the read operation that retrieves the ``MyObject`` instance leaves the\n+transaction in a dirty state.\n+\n .. _deprecated-features-1.3:\n \n Features deprecated in 1.3"
        },
        {
            "sha": "6be59c5d5ae61b5ab6bff6f5767d42c56aa8e87d",
            "filename": "docs/topics/db/sql.txt",
            "status": "modified",
            "additions": 8,
            "deletions": 28,
            "changes": 36,
            "blob_url": "https://github.com/django/django/blob/6314a1b42e4f695b4c575585375fe91697911d5c/docs%2Ftopics%2Fdb%2Fsql.txt",
            "raw_url": "https://github.com/django/django/raw/6314a1b42e4f695b4c575585375fe91697911d5c/docs%2Ftopics%2Fdb%2Fsql.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Fsql.txt?ref=6314a1b42e4f695b4c575585375fe91697911d5c",
            "patch": "@@ -233,37 +233,17 @@ alias::\n \n Transactions and raw SQL\n ------------------------\n-If you are using transaction decorators (such as ``commit_on_success``) to\n-wrap your views and provide transaction control, you don't have to make a\n-manual call to ``transaction.commit_unless_managed()`` -- you can manually\n-commit if you want to, but you aren't required to, since the decorator will\n-commit for you. However, if you don't manually commit your changes, you will\n-need to manually mark the transaction as dirty, using\n-``transaction.set_dirty()``::\n-\n-    @commit_on_success\n-    def my_custom_sql_view(request, value):\n-        from django.db import connection, transaction\n-        cursor = connection.cursor()\n-\n-        # Data modifying operation\n-        cursor.execute(\"UPDATE bar SET foo = 1 WHERE baz = %s\", [value])\n \n-        # Since we modified data, mark the transaction as dirty\n-        transaction.set_dirty()\n-\n-        # Data retrieval operation. This doesn't dirty the transaction,\n-        # so no call to set_dirty() is required.\n-        cursor.execute(\"SELECT foo FROM bar WHERE baz = %s\", [value])\n-        row = cursor.fetchone()\n+When you make a raw SQL call, Django will automatically mark the\n+current transaction as dirty. You must then ensure that the\n+transaction containing those calls is closed correctly. See :ref:`the\n+notes on the requirements of Django's transaction handling\n+<topics-db-transactions-requirements>` for more details.\n \n-        return render_to_response('template.html', {'row': row})\n+.. versionchanged:: 1.3\n \n-The call to ``set_dirty()`` is made automatically when you use the Django ORM\n-to make data modifying database calls. However, when you use raw SQL, Django\n-has no way of knowing if your SQL modifies data or not. The manual call to\n-``set_dirty()`` ensures that Django knows that there are modifications that\n-must be committed.\n+Prior to Django 1.3, it was necessary to manually mark a transaction\n+as dirty using ``transaction.set_dirty()`` when using raw SQL calls.\n \n Connections and cursors\n -----------------------"
        },
        {
            "sha": "6e7288ec1d976b8d41c9b3278ff07df30d6b3a0b",
            "filename": "docs/topics/db/transactions.txt",
            "status": "modified",
            "additions": 30,
            "deletions": 11,
            "changes": 41,
            "blob_url": "https://github.com/django/django/blob/6314a1b42e4f695b4c575585375fe91697911d5c/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "raw_url": "https://github.com/django/django/raw/6314a1b42e4f695b4c575585375fe91697911d5c/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Ftransactions.txt?ref=6314a1b42e4f695b4c575585375fe91697911d5c",
            "patch": "@@ -70,43 +70,43 @@ per-function or per-code-block basis.\n These functions, described in detail below, can be used in two different ways:\n \n     * As a decorator_ on a particular function. For example::\n-    \n+\n             from django.db import transaction\n-            \n+\n             @transaction.commit_on_success()\n             def viewfunc(request):\n                 # ...\n                 # this code executes inside a transaction\n                 # ...\n-                \n+\n       This technique works with all supported version of Python (that is, with\n       Python 2.4 and greater).\n-      \n+\n     * As a `context manager`_ around a particular block of code::\n-    \n+\n             from django.db import transaction\n-            \n+\n             def viewfunc(request):\n                 # ...\n                 # this code executes using default transaction management\n-                # ... \n-                \n+                # ...\n+\n                 with transaction.commit_on_success():\n                     # ...\n                     # this code executes inside a transaction\n                     # ...\n-                    \n+\n       The ``with`` statement is new in Python 2.5, and so this syntax can only\n       be used with Python 2.5 and above.\n-      \n+\n .. _decorator: http://docs.python.org/glossary.html#term-decorator\n .. _context manager: http://docs.python.org/glossary.html#term-context-manager\n \n For maximum compatibility, all of the examples below show transactions using the\n decorator syntax, but all of the follow functions may be used as context\n managers, too.\n \n-.. note:: \n+.. note::\n \n     Although the examples below use view functions as examples, these\n     decorators and context managers can be used anywhere in your code\n@@ -187,6 +187,25 @@ managers, too.\n         def viewfunc2(request):\n             ....\n \n+.. _topics-db-transactions-requirements:\n+\n+Requirements for transaction handling\n+=====================================\n+\n+.. versionadded:: 1.3\n+\n+Django requires that every transaction that is opened is closed before\n+the completion of a request. If you are using :func:`autocommit` (the\n+default commit mode) or :func:`commit_on_success`, this will be done\n+for you automatically. However, if you are manually managing\n+transactions (using the :func:`commit_manually` decorator), you must\n+ensure that the transaction is either committed or rolled back before\n+a request is completed.\n+\n+This applies to all database operations, not just write operations. Even\n+if your transaction only reads from the database, the transaction must\n+be committed or rolled back before you complete a request.\n+\n How to globally deactivate transaction management\n =================================================\n "
        },
        {
            "sha": "b339935013d4f351196b382c7669d9613413cfa5",
            "filename": "tests/regressiontests/delete_regress/tests.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/6314a1b42e4f695b4c575585375fe91697911d5c/tests%2Fregressiontests%2Fdelete_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/6314a1b42e4f695b4c575585375fe91697911d5c/tests%2Fregressiontests%2Fdelete_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fdelete_regress%2Ftests.py?ref=6314a1b42e4f695b4c575585375fe91697911d5c",
            "patch": "@@ -62,6 +62,7 @@ def test_concurrent_delete(self):\n         Book.objects.filter(pagecount__lt=250).delete()\n         transaction.commit()\n         self.assertEqual(1, Book.objects.count())\n+        transaction.commit()\n \n \n class DeleteCascadeTests(TestCase):"
        },
        {
            "sha": "e7f24585a0adb2979605f32b92919a7a79db9ae7",
            "filename": "tests/regressiontests/fixtures_regress/tests.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/6314a1b42e4f695b4c575585375fe91697911d5c/tests%2Fregressiontests%2Ffixtures_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/6314a1b42e4f695b4c575585375fe91697911d5c/tests%2Fregressiontests%2Ffixtures_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ffixtures_regress%2Ftests.py?ref=6314a1b42e4f695b4c575585375fe91697911d5c",
            "patch": "@@ -610,6 +610,7 @@ def ticket_11101(self):\n         self.assertEqual(Thingy.objects.count(), 1)\n         transaction.rollback()\n         self.assertEqual(Thingy.objects.count(), 0)\n+        transaction.commit()\n \n     @skipUnlessDBFeature('supports_transactions')\n     def test_ticket_11101(self):"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/regressiontests/transactions_regress/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/django/django/blob/6314a1b42e4f695b4c575585375fe91697911d5c/tests%2Fregressiontests%2Ftransactions_regress%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/6314a1b42e4f695b4c575585375fe91697911d5c/tests%2Fregressiontests%2Ftransactions_regress%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftransactions_regress%2F__init__.py?ref=6314a1b42e4f695b4c575585375fe91697911d5c"
        },
        {
            "sha": "54e6f4f37ba83eabcb5888badad00da7211a0e22",
            "filename": "tests/regressiontests/transactions_regress/models.py",
            "status": "added",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/6314a1b42e4f695b4c575585375fe91697911d5c/tests%2Fregressiontests%2Ftransactions_regress%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/6314a1b42e4f695b4c575585375fe91697911d5c/tests%2Fregressiontests%2Ftransactions_regress%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftransactions_regress%2Fmodels.py?ref=6314a1b42e4f695b4c575585375fe91697911d5c",
            "patch": "@@ -0,0 +1,4 @@\n+from django.db import models\n+\n+class Mod(models.Model):\n+    fld = models.IntegerField()"
        },
        {
            "sha": "a7ff029ed11679939a364ef1470fdc7ca954ab49",
            "filename": "tests/regressiontests/transactions_regress/tests.py",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/django/django/blob/6314a1b42e4f695b4c575585375fe91697911d5c/tests%2Fregressiontests%2Ftransactions_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/6314a1b42e4f695b4c575585375fe91697911d5c/tests%2Fregressiontests%2Ftransactions_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftransactions_regress%2Ftests.py?ref=6314a1b42e4f695b4c575585375fe91697911d5c",
            "patch": "@@ -0,0 +1,164 @@\n+from django.core.exceptions import ImproperlyConfigured\n+from django.db import connection, transaction\n+from django.db.transaction import commit_on_success, commit_manually, TransactionManagementError\n+from django.test import TransactionTestCase, skipUnlessDBFeature\n+\n+from models import Mod\n+\n+\n+class TestTransactionClosing(TransactionTestCase):\n+    \"\"\"\n+    Tests to make sure that transactions are properly closed\n+    when they should be, and aren't left pending after operations\n+    have been performed in them. Refs #9964.\n+    \"\"\"\n+    def test_raw_committed_on_success(self):\n+        \"\"\"\n+        Make sure a transaction consisting of raw SQL execution gets\n+        committed by the commit_on_success decorator.\n+        \"\"\"\n+        @commit_on_success\n+        def raw_sql():\n+            \"Write a record using raw sql under a commit_on_success decorator\"\n+            cursor = connection.cursor()\n+            cursor.execute(\"INSERT into transactions_regress_mod (id,fld) values (17,18)\")\n+\n+        raw_sql()\n+        # Rollback so that if the decorator didn't commit, the record is unwritten\n+        transaction.rollback()\n+        try:\n+            # Check that the record is in the DB\n+            obj = Mod.objects.get(pk=17)\n+            self.assertEqual(obj.fld, 18)\n+        except Mod.DoesNotExist:\n+            self.fail(\"transaction with raw sql not committed\")\n+\n+    def test_commit_manually_enforced(self):\n+        \"\"\"\n+        Make sure that under commit_manually, even \"read-only\" transaction require closure\n+        (commit or rollback), and a transaction left pending is treated as an error.\n+        \"\"\"\n+        @commit_manually\n+        def non_comitter():\n+            \"Execute a managed transaction with read-only operations and fail to commit\"\n+            _ = Mod.objects.count()\n+\n+        self.assertRaises(TransactionManagementError, non_comitter)\n+\n+    def test_commit_manually_commit_ok(self):\n+        \"\"\"\n+        Test that under commit_manually, a committed transaction is accepted by the transaction\n+        management mechanisms\n+        \"\"\"\n+        @commit_manually\n+        def committer():\n+            \"\"\"\n+            Perform a database query, then commit the transaction\n+            \"\"\"\n+            _ = Mod.objects.count()\n+            transaction.commit()\n+\n+        try:\n+            committer()\n+        except TransactionManagementError:\n+            self.fail(\"Commit did not clear the transaction state\")\n+\n+    def test_commit_manually_rollback_ok(self):\n+        \"\"\"\n+        Test that under commit_manually, a rolled-back transaction is accepted by the transaction\n+        management mechanisms\n+        \"\"\"\n+        @commit_manually\n+        def roller_back():\n+            \"\"\"\n+            Perform a database query, then rollback the transaction\n+            \"\"\"\n+            _ = Mod.objects.count()\n+            transaction.rollback()\n+\n+        try:\n+            roller_back()\n+        except TransactionManagementError:\n+            self.fail(\"Rollback did not clear the transaction state\")\n+\n+    def test_commit_manually_enforced_after_commit(self):\n+        \"\"\"\n+        Test that under commit_manually, if a transaction is committed and an operation is\n+        performed later, we still require the new transaction to be closed\n+        \"\"\"\n+        @commit_manually\n+        def fake_committer():\n+            \"Query, commit, then query again, leaving with a pending transaction\"\n+            _ = Mod.objects.count()\n+            transaction.commit()\n+            _ = Mod.objects.count()\n+\n+        self.assertRaises(TransactionManagementError, fake_committer)\n+\n+    @skipUnlessDBFeature('supports_transactions')\n+    def test_reuse_cursor_reference(self):\n+        \"\"\"\n+        Make sure transaction closure is enforced even when the queries are performed\n+        through a single cursor reference retrieved in the beginning\n+        (this is to show why it is wrong to set the transaction dirty only when a cursor\n+        is fetched from the connection).\n+        \"\"\"\n+        @commit_on_success\n+        def reuse_cursor_ref():\n+            \"\"\"\n+            Fetch a cursor, perform an query, rollback to close the transaction,\n+            then write a record (in a new transaction) using the same cursor object\n+            (reference). All this under commit_on_success, so the second insert should\n+            be committed.\n+            \"\"\"\n+            cursor = connection.cursor()\n+            cursor.execute(\"INSERT into transactions_regress_mod (id,fld) values (1,2)\")\n+            transaction.rollback()\n+            cursor.execute(\"INSERT into transactions_regress_mod (id,fld) values (1,2)\")\n+\n+        reuse_cursor_ref()\n+        # Rollback so that if the decorator didn't commit, the record is unwritten\n+        transaction.rollback()\n+        try:\n+            # Check that the record is in the DB\n+            obj = Mod.objects.get(pk=1)\n+            self.assertEquals(obj.fld, 2)\n+        except Mod.DoesNotExist:\n+            self.fail(\"After ending a transaction, cursor use no longer sets dirty\")\n+\n+    def test_failing_query_transaction_closed(self):\n+        \"\"\"\n+        Make sure that under commit_on_success, a transaction is rolled back even if\n+        the first database-modifying operation fails.\n+        This is prompted by http://code.djangoproject.com/ticket/6669 (and based on sample\n+        code posted there to exemplify the problem): Before Django 1.3,\n+        transactions were only marked \"dirty\" by the save() function after it successfully\n+        wrote the object to the database.\n+        \"\"\"\n+        from django.contrib.auth.models import User\n+\n+        @transaction.commit_on_success\n+        def create_system_user():\n+            \"Create a user in a transaction\"\n+            user = User.objects.create_user(username='system', password='iamr00t', email='root@SITENAME.com')\n+            # Redundant, just makes sure the user id was read back from DB\n+            Mod.objects.create(fld=user.id)\n+\n+        # Create a user\n+        create_system_user()\n+\n+        try:\n+            # The second call to create_system_user should fail for violating a unique constraint\n+            # (it's trying to re-create the same user)\n+            create_system_user()\n+        except:\n+            pass\n+        else:\n+            raise ImproperlyConfigured('Unique constraint not enforced on django.contrib.auth.models.User')\n+\n+        try:\n+            # Try to read the database. If the last transaction was indeed closed,\n+            # this should cause no problems\n+            _ = User.objects.all()[0]\n+        except:\n+            self.fail(\"A transaction consisting of a failed operation was not closed.\")"
        }
    ],
    "stats": {
        "total": 318,
        "additions": 271,
        "deletions": 47
    }
}