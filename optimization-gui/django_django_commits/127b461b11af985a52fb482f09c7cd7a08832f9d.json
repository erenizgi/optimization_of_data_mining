{
    "author": "aaugustin",
    "message": "[py3] Ported django.utils.crypto.",
    "sha": "127b461b11af985a52fb482f09c7cd7a08832f9d",
    "files": [
        {
            "sha": "70a07e7fde4465ac9a35a6c8cc2819a7995c1c85",
            "filename": "django/utils/crypto.py",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/127b461b11af985a52fb482f09c7cd7a08832f9d/django%2Futils%2Fcrypto.py",
            "raw_url": "https://github.com/django/django/raw/127b461b11af985a52fb482f09c7cd7a08832f9d/django%2Futils%2Fcrypto.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fcrypto.py?ref=127b461b11af985a52fb482f09c7cd7a08832f9d",
            "patch": "@@ -50,7 +50,7 @@ def salted_hmac(key_salt, value, secret=None):\n     # line is redundant and could be replaced by key = key_salt + secret, since\n     # the hmac module does the same thing for keys longer than the block size.\n     # However, we need to ensure that we *always* do this.\n-    return hmac.new(key, msg=value, digestmod=hashlib.sha1)\n+    return hmac.new(key, msg=smart_bytes(value), digestmod=hashlib.sha1)\n \n \n def get_random_string(length=12,\n@@ -99,7 +99,7 @@ def _bin_to_long(x):\n \n     This is a clever optimization for fast xor vector math\n     \"\"\"\n-    return int(x.encode('hex'), 16)\n+    return int(binascii.hexlify(x), 16)\n \n \n def _long_to_bin(x, hex_format_string):\n@@ -112,13 +112,14 @@ def _long_to_bin(x, hex_format_string):\n \n def _fast_hmac(key, msg, digest):\n     \"\"\"\n-    A trimmed down version of Python's HMAC implementation\n+    A trimmed down version of Python's HMAC implementation.\n+\n+    This function operates on bytes.\n     \"\"\"\n     dig1, dig2 = digest(), digest()\n-    key = smart_bytes(key)\n     if len(key) > dig1.block_size:\n         key = digest(key).digest()\n-    key += chr(0) * (dig1.block_size - len(key))\n+    key += b'\\x00' * (dig1.block_size - len(key))\n     dig1.update(key.translate(_trans_36))\n     dig1.update(msg)\n     dig2.update(key.translate(_trans_5c))"
        },
        {
            "sha": "52a286cb27e03e9699427f51f3b21ad864474717",
            "filename": "tests/regressiontests/utils/crypto.py",
            "status": "modified",
            "additions": 16,
            "deletions": 12,
            "changes": 28,
            "blob_url": "https://github.com/django/django/blob/127b461b11af985a52fb482f09c7cd7a08832f9d/tests%2Fregressiontests%2Futils%2Fcrypto.py",
            "raw_url": "https://github.com/django/django/raw/127b461b11af985a52fb482f09c7cd7a08832f9d/tests%2Fregressiontests%2Futils%2Fcrypto.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Futils%2Fcrypto.py?ref=127b461b11af985a52fb482f09c7cd7a08832f9d",
            "patch": "@@ -1,4 +1,6 @@\n+from __future__ import unicode_literals\n \n+import binascii\n import math\n import timeit\n import hashlib\n@@ -108,28 +110,30 @@ class TestUtilsCryptoPBKDF2(unittest.TestCase):\n                        \"c4007d5298f9033c0241d5ab69305e7b64eceeb8d\"\n                        \"834cfec\"),\n         },\n-        # Check leading zeros are not stripped (#17481) \n+        # Check leading zeros are not stripped (#17481)\n         {\n-            \"args\": { \n-                \"password\": chr(186), \n-                \"salt\": \"salt\", \n-                \"iterations\": 1, \n-                \"dklen\": 20, \n-                \"digest\": hashlib.sha1, \n-            }, \n+            \"args\": {\n+                \"password\": b'\\xba',\n+                \"salt\": \"salt\",\n+                \"iterations\": 1,\n+                \"dklen\": 20,\n+                \"digest\": hashlib.sha1,\n+            },\n             \"result\": '0053d3b91a7f1e54effebd6d68771e8a6e0b2c5b',\n         },\n     ]\n \n     def test_public_vectors(self):\n         for vector in self.rfc_vectors:\n             result = pbkdf2(**vector['args'])\n-            self.assertEqual(result.encode('hex'), vector['result'])\n+            self.assertEqual(binascii.hexlify(result).decode('ascii'),\n+                             vector['result'])\n \n     def test_regression_vectors(self):\n         for vector in self.regression_vectors:\n             result = pbkdf2(**vector['args'])\n-            self.assertEqual(result.encode('hex'), vector['result'])\n+            self.assertEqual(binascii.hexlify(result).decode('ascii'),\n+                             vector['result'])\n \n     def test_performance_scalability(self):\n         \"\"\"\n@@ -140,11 +144,11 @@ def test_performance_scalability(self):\n         # to run the test suite and false positives caused by imprecise\n         # measurement.\n         n1, n2 = 200000, 800000\n-        elapsed = lambda f: timeit.Timer(f, \n+        elapsed = lambda f: timeit.Timer(f,\n                     'from django.utils.crypto import pbkdf2').timeit(number=1)\n         t1 = elapsed('pbkdf2(\"password\", \"salt\", iterations=%d)' % n1)\n         t2 = elapsed('pbkdf2(\"password\", \"salt\", iterations=%d)' % n2)\n         measured_scale_exponent = math.log(t2 / t1, n2 / n1)\n-        # This should be less than 1. We allow up to 1.2 so that tests don't \n+        # This should be less than 1. We allow up to 1.2 so that tests don't\n         # fail nondeterministically too often.\n         self.assertLess(measured_scale_exponent, 1.2)"
        }
    ],
    "stats": {
        "total": 39,
        "additions": 22,
        "deletions": 17
    }
}