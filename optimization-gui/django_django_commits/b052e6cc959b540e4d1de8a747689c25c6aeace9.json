{
    "author": "timgraham",
    "message": "Fixed #9962 - Added a testing tutorial.\n\nThank-you Daniele Procida for the first draft\nand shaibi, Aymeric, and others for the reviews.",
    "sha": "b052e6cc959b540e4d1de8a747689c25c6aeace9",
    "files": [
        {
            "sha": "9fea8ff3f2b33d124e759890d33de50d9c6b5d8d",
            "filename": "docs/index.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/b052e6cc959b540e4d1de8a747689c25c6aeace9/docs%2Findex.txt",
            "raw_url": "https://github.com/django/django/raw/b052e6cc959b540e4d1de8a747689c25c6aeace9/docs%2Findex.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Findex.txt?ref=b052e6cc959b540e4d1de8a747689c25c6aeace9",
            "patch": "@@ -44,7 +44,8 @@ Are you new to Django or to programming? This is the place to start!\n   :doc:`Part 1 <intro/tutorial01>` |\n   :doc:`Part 2 <intro/tutorial02>` |\n   :doc:`Part 3 <intro/tutorial03>` |\n-  :doc:`Part 4 <intro/tutorial04>`\n+  :doc:`Part 4 <intro/tutorial04>` |\n+  :doc:`Part 5 <intro/tutorial05>`\n \n * **Advanced Tutorials:**\n   :doc:`How to write reusable apps <intro/reusable-apps>` |"
        },
        {
            "sha": "ea6a3c4d29b78cd146f634cd198cc6ea1a071756",
            "filename": "docs/intro/index.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/b052e6cc959b540e4d1de8a747689c25c6aeace9/docs%2Fintro%2Findex.txt",
            "raw_url": "https://github.com/django/django/raw/b052e6cc959b540e4d1de8a747689c25c6aeace9/docs%2Fintro%2Findex.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fintro%2Findex.txt?ref=b052e6cc959b540e4d1de8a747689c25c6aeace9",
            "patch": "@@ -13,6 +13,7 @@ place: read this material to quickly get up and running.\n    tutorial02\n    tutorial03\n    tutorial04\n+   tutorial05\n    reusable-apps\n    whatsnext\n    contributing"
        },
        {
            "sha": "6aade4997e3832741e8e42842c23f05675a831a7",
            "filename": "docs/intro/reusable-apps.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/b052e6cc959b540e4d1de8a747689c25c6aeace9/docs%2Fintro%2Freusable-apps.txt",
            "raw_url": "https://github.com/django/django/raw/b052e6cc959b540e4d1de8a747689c25c6aeace9/docs%2Fintro%2Freusable-apps.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fintro%2Freusable-apps.txt?ref=b052e6cc959b540e4d1de8a747689c25c6aeace9",
            "patch": "@@ -2,11 +2,11 @@\n Advanced tutorial: How to write reusable apps\n =============================================\n \n-This advanced tutorial begins where :doc:`Tutorial 4 </intro/tutorial04>` left\n+This advanced tutorial begins where :doc:`Tutorial 5 </intro/tutorial05>` left\n off. We'll be turning our Web-poll into a standalone Python package you can\n reuse in new projects and share with other people.\n \n-If you haven't recently completed Tutorials 1–4, we encourage you to review\n+If you haven't recently completed Tutorials 1–5, we encourage you to review\n these so that your example project matches the one described below.\n \n Reusability matters"
        },
        {
            "sha": "1619b599bbeee957acf1634192d1f70c0af30ad1",
            "filename": "docs/intro/tutorial04.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 10,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/b052e6cc959b540e4d1de8a747689c25c6aeace9/docs%2Fintro%2Ftutorial04.txt",
            "raw_url": "https://github.com/django/django/raw/b052e6cc959b540e4d1de8a747689c25c6aeace9/docs%2Fintro%2Ftutorial04.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fintro%2Ftutorial04.txt?ref=b052e6cc959b540e4d1de8a747689c25c6aeace9",
            "patch": "@@ -275,13 +275,5 @@ Run the server, and use your new polling app based on generic views.\n For full details on generic views, see the :doc:`generic views documentation\n </topics/class-based-views/index>`.\n \n-What's next?\n-============\n-\n-The beginner tutorial ends here for the time being. In the meantime, you might\n-want to check out some pointers on :doc:`where to go from here\n-</intro/whatsnext>`.\n-\n-If you are familiar with Python packaging and interested in learning how to\n-turn polls into a \"reusable app\", check out :doc:`Advanced tutorial: How to\n-write reusable apps</intro/reusable-apps>`.\n+When you're comfortable with forms and generic views, read :doc:`part 5 of this\n+tutorial</intro/tutorial05>` to learn about testing our polls app."
        },
        {
            "sha": "163b7cdd0fc49720acf17634b892c8ad9fedee3a",
            "filename": "docs/intro/tutorial05.txt",
            "status": "added",
            "additions": 650,
            "deletions": 0,
            "changes": 650,
            "blob_url": "https://github.com/django/django/blob/b052e6cc959b540e4d1de8a747689c25c6aeace9/docs%2Fintro%2Ftutorial05.txt",
            "raw_url": "https://github.com/django/django/raw/b052e6cc959b540e4d1de8a747689c25c6aeace9/docs%2Fintro%2Ftutorial05.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fintro%2Ftutorial05.txt?ref=b052e6cc959b540e4d1de8a747689c25c6aeace9",
            "patch": "@@ -0,0 +1,650 @@\n+=====================================\n+Writing your first Django app, part 5\n+=====================================\n+\n+This tutorial begins where :doc:`Tutorial 4 </intro/tutorial04>` left off.\n+We've built a Web-poll application, and we'll now create some automated tests\n+for it.\n+\n+Introducing automated testing\n+=============================\n+\n+What are automated tests?\n+-------------------------\n+\n+Tests are simple routines that check the operation of your code.\n+\n+Testing operates at different levels. Some tests might apply to a tiny detail\n+- *does a particular model method return values as expected?*, while others\n+examine the overall operation of the software - *does a sequence of user inputs\n+on the site produce the desired result?* That's no different from the kind of\n+testing you did earlier in :doc:`Tutorial 1 </intro/tutorial01>`, using the\n+shell to examine the behavior of a method, or running the application and\n+entering data to check how it behaves.\n+\n+What's different in *automated* tests is that the testing work is done for\n+you by the system. You create a set of tests once, and then as you make changes\n+to your app, you can check that your code still works as you originally\n+intended, without having to perform time consuming manual testing.\n+\n+Why you need to create tests\n+----------------------------\n+\n+So why create tests, and why now?\n+\n+You may feel that you have quite enough on your plate just learning\n+Python/Django, and having yet another thing to learn and do may seem\n+overwhelming and perhaps unnecessary. After all, our polls application is\n+working quite happily now; going through the trouble of creating automated\n+tests is not going to make it work any better. If creating the polls\n+application is the last bit of Django programming you will ever do, then true,\n+you don't need to know how to create automated tests. But, if that's not the\n+case, now is an excellent time to learn.\n+\n+Tests will save you time\n+~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Up to a certain point, 'checking that it seems to work' will be a satisfactory\n+test. In a more sophisticated application, you might have dozens of complex\n+interactions between components.\n+\n+A change in any of those components could have unexpected consequences on the\n+application's behavior. Checking that it still 'seems to work' could mean\n+running through your code's functionality with twenty different variations of\n+your test data just to make sure you haven't broken something - not a good use\n+of your time.\n+\n+That's especially true when automated tests could do this for you in seconds.\n+If something's gone wrong, tests will also assist in identifying the code\n+that's causing the unexpected behavior.\n+\n+Sometimes it may seem a chore to tear yourself away from your productive,\n+creative programming work to face the unglamorous and unexciting business\n+of writing tests, particularly when you know your code is working properly.\n+\n+However, the task of writing tests is a lot more fulfilling than spending hours\n+testing your application manually or trying to identify the cause of a\n+newly-introduced problem.\n+\n+Tests don't just identify problems, they prevent them\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+It's a mistake to think of tests merely as a negative aspect of development.\n+\n+Without tests, the purpose or intended behavior of an application might be\n+rather opaque. Even when it's your own code, you will sometimes find yourself\n+poking around in it trying to find out what exactly it's doing.\n+\n+Tests change that; they light up your code from the inside, and when something\n+goes wrong, they focus light on the part that has gone wrong - *even if you\n+hadn't even realized it had gone wrong*.\n+\n+Tests make your code more attractive\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+You might have created a brilliant piece of software, but you will find that\n+many other developers will simply refuse to look at it because it lacks tests;\n+without tests, they won't trust it. Jacob Kaplan-Moss, one of Django's\n+original developers, says \"Code without tests is broken by design.\"\n+\n+That other developers want to see tests in your software before they take it\n+seriously is yet another reason for you to start writing tests.\n+\n+Tests help teams work together\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The previous points are written from the point of view of a single developer\n+maintaining an application. Complex applications will be maintained by teams.\n+Tests guarantee that colleagues don't inadvertently break your code (and that\n+you don't break theirs without knowing). If you want to make a living as a\n+Django programmer, you must be good at writing tests!\n+\n+Basic testing strategies\n+========================\n+\n+There are many ways to approach writing tests.\n+\n+Some programmers follow a discipline called \"`test-driven development`_\"; they\n+actually write their tests before they write their code. This might seem\n+counter-intuitive, but in fact it's similar to what most people will often do\n+anyway: they describe a problem, then create some code to solve it. Test-driven\n+development simply formalizes the problem in a Python test case.\n+\n+More often, a newcomer to testing will create some code and later decide that\n+it should have some tests. Perhaps it would have been better to write some\n+tests earlier, but it's never too late to get started.\n+\n+Sometimes it's difficult to figure out where to get started with writing tests.\n+If you have written several thousand lines of Python, choosing something to\n+test might not be easy. In such a case, it's fruitful to write your first test\n+the next time you make a change, either when you add a new feature or fix a bug.\n+\n+So let's do that right away.\n+\n+.. _test-driven development: http://en.wikipedia.org/wiki/Test-driven_development/\n+\n+Writing our first test\n+======================\n+\n+We identify a bug\n+-----------------\n+\n+Fortunately, there's a little bug in the ``polls`` application for us to fix\n+right away: the ``Poll.was_published_recently()`` method returns ``True`` if\n+the ``Poll`` was published within the last day (which is correct) but also if\n+the ``Poll``'s ``pub_date`` field is in the future (which certainly isn't).\n+\n+You can see this in the Admin; create a poll whose date lies in the future;\n+you'll see that the ``Poll`` change list claims it was published recently.\n+\n+You can also see this using the shell::\n+\n+    >>> import datetime\n+    >>> from django.utils import timezone\n+    >>> from polls.models import Poll\n+    >>> # create a Poll instance with pub_date 30 days in the future\n+    >>> future_poll = Poll(pub_date=timezone.now() + datetime.timedelta(days=30))\n+    >>> # was it published recently?\n+    >>> future_poll.was_published_recently()\n+    True\n+\n+Since things in the future are not 'recent', this is clearly wrong.\n+\n+Create a test to expose the bug\n+-------------------------------\n+\n+What we've just done in the shell to test for the problem is exactly what we\n+can do in an automated test, so let's turn that into an automated test.\n+\n+The best place for an application's tests is in the application's ``tests.py``\n+file - the testing system will look there for tests automatically.\n+\n+Put the following in the ``tests.py`` file in the ``polls`` application (you'll\n+notice  ``tests.py`` contains some dummy tests, you can remove those)::\n+\n+    import datetime\n+\n+    from django.utils import timezone\n+    from django.test import TestCase\n+\n+    from polls.models import Poll\n+\n+    class PollMethodTests(TestCase):\n+\n+        def test_was_published_recently_with_future_poll(self):\n+            \"\"\"\n+            was_published_recently() should return False for polls whose\n+            pub_date is in the future\n+            \"\"\"\n+            future_poll = Poll(pub_date=timezone.now() + datetime.timedelta(days=30))\n+            self.assertEqual(future_poll.was_published_recently(), False)\n+\n+What we have done here is created a :class:`django.test.TestCase` subclass\n+with a method that creates a ``Poll`` instance with a ``pub_date`` in the\n+future. We then check the output of ``was_published_recently()`` - which\n+*ought* to be False.\n+\n+Running tests\n+-------------\n+\n+In the terminal, we can run our test::\n+\n+    python manage.py test polls\n+\n+and you'll see something like::\n+\n+    Creating test database for alias 'default'...\n+    F\n+    ======================================================================\n+    FAIL: test_was_published_recently_with_future_poll (polls.tests.PollMethodTests)\n+    ----------------------------------------------------------------------\n+    Traceback (most recent call last):\n+      File \"/path/to/mysite/polls/tests.py\", line 16, in test_was_published_recently_with_future_poll\n+        self.assertEqual(future_poll.was_published_recently(), False)\n+    AssertionError: True != False\n+\n+    ----------------------------------------------------------------------\n+    Ran 1 test in 0.001s\n+\n+    FAILED (failures=1)\n+    Destroying test database for alias 'default'...\n+\n+What happened is this:\n+\n+* ``python manage.py test polls`` looked for tests in the ``polls`` application\n+\n+* it found a subclass of the :class:`django.test.TestCase` class\n+\n+* it created a special database for the purpose of testing\n+\n+* it looked for test methods - ones whose names begin with ``test``\n+\n+* in ``test_was_published_recently_with_future_poll`` it created a ``Poll``\n+  instance whose ``pub_date`` field is 30 days in the future\n+\n+* ... and using the ``assertEqual()`` method, it discovered that its\n+  ``was_published_recently()`` returns ``True``, though we wanted it to return\n+  ``False``\n+\n+The test informs us which test failed and even the line on which the failure\n+occurred.\n+\n+Fixing the bug\n+--------------\n+\n+We already know what the problem is: ``Poll.was_published_recently()`` should\n+return ``False`` if its ``pub_date`` is in the future. Amend the method in\n+``models.py``, so that it will only return ``True`` if the date is also in the\n+past::\n+\n+    def was_published_recently(self):\n+        now = timezone.now()\n+        return now - datetime.timedelta(days=1) <= self.pub_date <  now\n+\n+and run the test again::\n+\n+    Creating test database for alias 'default'...\n+    .\n+    ----------------------------------------------------------------------\n+    Ran 1 test in 0.001s\n+\n+    OK\n+    Destroying test database for alias 'default'...\n+\n+After identifying a bug, we wrote a test that exposes it and corrected the bug\n+in the code so our test passes.\n+\n+Many other things might go wrong with our application in the future, but we can\n+be sure that we won't inadvertently reintroduce this bug, because simply\n+running the test will warn us immediately. We can consider this little portion\n+of the application pinned down safely forever.\n+\n+More comprehensive tests\n+------------------------\n+\n+While we're here, we can further pin down the ``was_published_recently()``\n+method; in fact, it would be positively embarrassing if in fixing one bug we had\n+introduced another.\n+\n+Add two more test methods to the same class, to test the behavior of the method\n+more comprehensively::\n+\n+    def test_was_published_recently_with_old_poll(self):\n+        \"\"\"\n+        was_published_recently() should return False for polls whose pub_date\n+        is older than 1 day\n+        \"\"\"\n+        old_poll = Poll(pub_date=timezone.now() - datetime.timedelta(days=30))\n+        self.assertEqual(old_poll.was_published_recently(), False)\n+\n+    def test_was_published_recently_with_recent_poll(self):\n+        \"\"\"\n+        was_published_recently() should return True for polls whose pub_date\n+        is within the last day\n+        \"\"\"\n+        recent_poll = Poll(pub_date=timezone.now() - datetime.timedelta(hours=1))\n+        self.assertEqual(recent_poll.was_published_recently(), True)\n+\n+And now we have three tests that confirm that ``Poll.was_published_recently()``\n+returns sensible values for past, recent, and future polls.\n+\n+Again, ``polls`` is a simple application, but however complex it grows in the\n+future and whatever other code it interacts with, we now have some guarantee\n+that the method we have written tests for will behave in expected ways.\n+\n+Test a view\n+===========\n+\n+The polls application is fairly undiscriminating: it will publish any poll,\n+including ones whose ``pub_date`` field lies in the future. We should improve\n+this. Setting a ``pub_date`` in the future should mean that the Poll is\n+published at that moment, but invisible until then.\n+\n+A test for a view\n+-----------------\n+\n+When we fixed the bug above, we wrote the test first and then the code to fix\n+it. In fact that was a simple example of test-driven development, but it\n+doesn't really matter in which order we do the work.\n+\n+In our first test, we focused closely on the internal behavior of the code. For\n+this test, we want to check its behavior as it would be experienced by a user\n+through a web browser.\n+\n+Before we try to fix anything, let's have a look at the tools at our disposal.\n+\n+The Django test client\n+----------------------\n+\n+Django provides a test :class:`~django.test.client.Client` to simulate a user\n+interacting with the code at the view level.  We can use it in ``tests.py``\n+or even in the shell.\n+\n+We will start again with the shell, where we need to do a couple of things that\n+won't be necessary in ``tests.py``. The first is to set up the test environment\n+in the shell::\n+\n+    >>> from django.test.utils import setup_test_environment\n+    >>> setup_test_environment()\n+\n+Next we need to import the test client class (later in ``tests.py`` we will use\n+the :class:`django.test.TestCase` class, which comes with its own client, so\n+this won't be required)::\n+\n+    >>> from django.test.client import Client\n+    >>> # create an instance of the client for our use\n+    >>> client = Client()\n+\n+With that ready, we can ask the client to do some work for us::\n+\n+    >>> # get a response from '/'\n+    >>> response = client.get('/')\n+    >>> # we should expect a 404 from that address\n+    >>> response.status_code\n+    404\n+    >>> # on the other hand we should expect to find something at '/polls/'\n+    >>> # we'll use 'reverse()' rather than a harcoded URL\n+    >>> from django.core.urlresolvers import reverse\n+    >>> response = client.get(reverse('polls:index'))\n+    >>> response.status_code\n+    200\n+    >>> response.content\n+    '\\n\\n\\n    <p>No polls are available.</p>\\n\\n'\n+    >>> # note - you might get unexpected results if your ``TIME_ZONE``\n+    >>> # in ``settings.py`` is not correct. If you need to change it,\n+    >>> # you will also need to restart your shell session\n+    >>> from polls.models import Poll\n+    >>> from django.utils import timezone\n+    >>> # create a Poll and save it\n+    >>> p = Poll(question=\"Who is your favorite Beatle?\", pub_date=timezone.now())\n+    >>> p.save()\n+    >>> # check the response once again\n+    >>> response = client.get('/polls/')\n+    >>> response.content\n+    '\\n\\n\\n    <ul>\\n    \\n        <li><a href=\"/polls/1/\">Who is your favorite Beatle?</a></li>\\n    \\n    </ul>\\n\\n'\n+    >>> response.context['latest_poll_list']\n+    [<Poll: Who is your favorite Beatle?>]\n+\n+Improving our view\n+------------------\n+\n+The list of polls shows polls that aren't published yet (i.e. those that have a\n+``pub_date`` in the future). Let's fix that.\n+\n+In :doc:`Tutorial 4 </intro/tutorial04>` we deleted the view functions from\n+``views.py`` in favor of a :class:`~django.views.generic.list.ListView` in\n+``urls.py``::\n+\n+    url(r'^$',\n+        ListView.as_view(\n+            queryset=Poll.objects.order_by('-pub_date')[:5],\n+            context_object_name='latest_poll_list',\n+            template_name='polls/index.html'),\n+        name='index'),\n+\n+``response.context_data['latest_poll_list']`` extracts the data this view\n+places into the context.\n+\n+We need to amend the line that gives us the ``queryset``::\n+\n+    queryset=Poll.objects.order_by('-pub_date')[:5],\n+\n+Let's change the queryset so that it also checks the date by comparing it with\n+``timezone.now()``. First we need to add an import::\n+\n+    from django.utils import timezone\n+\n+and then we must amend the existing ``url`` function to::\n+\n+    url(r'^$',\n+        ListView.as_view(\n+            queryset=Poll.objects.filter(pub_date__lte=timezone.now) \\\n+                .order_by('-pub_date')[:5],\n+            context_object_name='latest_poll_list',\n+            template_name='polls/index.html'),\n+        name='index'),\n+\n+``Poll.objects.filter(pub_date__lte=timezone.now)`` returns a queryset\n+containing Polls whose ``pub_date`` is less than or equal to - that is, earlier\n+than or equal to - ``timezone.now``. Notice that we use a callable queryset\n+argument, ``timezone.now``, which will be evaluated at request time. If we had\n+included the parentheses, ``timezone.now()`` would be evaluated just once when\n+the web server is started.\n+\n+Testing our new view\n+--------------------\n+\n+Now you can satisfy yourself that this behaves as expected by firing up the\n+runserver, loading the site in your browser, creating ``Polls`` with dates in\n+the past and future, and checking that only those that have been published are\n+listed.  You don't want to have to do that *every single time you make any\n+change that might affect this* - so let's also create a test, based on our\n+shell session above.\n+\n+Add the following to ``polls/tests.py``::\n+\n+    from django.core.urlresolvers import reverse\n+\n+and we'll create a factory method to create polls as well as a new test class::\n+\n+    def create_poll(question, days):\n+        \"\"\"\n+        Creates a poll with the given `question` published the given number of\n+        `days` offset to now (negative for polls published in the past,\n+        positive for polls that have yet to be published).\n+        \"\"\"\n+        return Poll.objects.create(question=question,\n+            pub_date=timezone.now() + datetime.timedelta(days=days))\n+\n+    class PollViewTests(TestCase):\n+        def test_index_view_with_no_polls(self):\n+            \"\"\"\n+            If no polls exist, an appropriate message should be displayed.\n+            \"\"\"\n+            response = self.client.get(reverse('polls:index'))\n+            self.assertEqual(response.status_code, 200)\n+            self.assertContains(response, \"No polls are available.\")\n+            self.assertQuerysetEqual(response.context['latest_poll_list'], [])\n+\n+        def test_index_view_with_a_past_poll(self):\n+            \"\"\"\n+            Polls with a pub_date in the past should be displayed on the index page.\n+            \"\"\"\n+            create_poll(question=\"Past poll.\", days=-30)\n+            response = self.client.get(reverse('polls:index'))\n+            self.assertQuerysetEqual(\n+                response.context['latest_poll_list'],\n+                ['<Poll: Past poll.>']\n+            )\n+\n+        def test_index_view_with_a_future_poll(self):\n+            \"\"\"\n+            Polls with a pub_date in the future should not be displayed on the\n+            index page.\n+            \"\"\"\n+            create_poll(question=\"Future poll.\", days=30)\n+            response = self.client.get(reverse('polls:index'))\n+            self.assertContains(response, \"No polls are available.\", status_code=200)\n+            self.assertQuerysetEqual(response.context['latest_poll_list'], [])\n+\n+        def test_index_view_with_future_poll_and_past_poll(self):\n+            \"\"\"\n+            Even if both past and future polls exist, only past polls should be\n+            displayed.\n+            \"\"\"\n+            create_poll(question=\"Past poll.\", days=-30)\n+            create_poll(question=\"Future poll.\", days=30)\n+            response = self.client.get(reverse('polls:index'))\n+            self.assertQuerysetEqual(\n+                response.context['latest_poll_list'],\n+                ['<Poll: Past poll.>']\n+            )\n+\n+        def test_index_view_with_two_past_polls(self):\n+            \"\"\"\n+            The polls index page may display multiple polls.\n+            \"\"\"\n+            create_poll(question=\"Past poll 1.\", days=-30)\n+            create_poll(question=\"Past poll 2.\", days=-5)\n+            response = self.client.get(reverse('polls:index'))\n+            self.assertQuerysetEqual(\n+                response.context['latest_poll_list'],\n+                 ['<Poll: Past poll 2.>', '<Poll: Past poll 1.>']\n+            )\n+\n+Let's look at some of these more closely.\n+\n+First is a poll factory method, ``create_poll``, to take some repetition out\n+of the process of creating polls.\n+\n+``test_index_view_with_no_polls`` doesn't create any polls, but checks the\n+message: \"No polls are available.\" and verifies the ``latest_poll_list`` is\n+empty. Note that the :class:`django.test.TestCase` class provides some\n+additional assertion methods. In these examples, we use\n+:meth:`~django.test.TestCase.assertContains()` and\n+:meth:`~django.test.TestCase.assertQuerysetEqual()`.\n+\n+In ``test_index_view_with_a_past_poll``, we create a poll and verify that it\n+appears in the list.\n+\n+In ``test_index_view_with_a_future_poll``, we create a poll with a ``pub_date``\n+in the future. The database is reset for each test method, so the first poll is\n+no longer there, and so again the index shouldn't have any polls in it.\n+\n+And so on. In effect, we are using the tests to tell a story of admin input\n+and user experience on the site, and checking that at every state and for every\n+new change in the state of the system, the expected results are published.\n+\n+Testing the ``DetailView``\n+--------------------------\n+\n+What we have works well; however, even though future polls don't appear in the\n+*index*, users can still reach them if they know or guess the right URL. So we\n+need similar constraints in the ``DetailViews``, by adding::\n+\n+    queryset=Poll.objects.filter(pub_date__lte=timezone.now)\n+\n+to them - for example::\n+\n+    url(r'^(?P<pk>\\d+)/$',\n+        DetailView.as_view(\n+            queryset=Poll.objects.filter(pub_date__lte=timezone.now),\n+            model=Poll,\n+            template_name='polls/detail.html'),\n+        name='detail'),\n+\n+and of course, we will add some tests, to check that a ``Poll`` whose\n+``pub_date`` is in the past can be displayed, and that one with a ``pub_date``\n+in the future is not::\n+\n+    class PollIndexDetailTests(TestCase):\n+        def test_detail_view_with_a_future_poll(self):\n+            \"\"\"\n+            The detail view of a poll with a pub_date in the future should\n+            return a 404 not found.\n+            \"\"\"\n+            future_poll = create_poll(question='Future poll.', days=5)\n+            response = self.client.get(reverse('polls:detail', args=(future_poll.id,)))\n+            self.assertEqual(response.status_code, 404)\n+\n+        def test_detail_view_with_a_past_poll(self):\n+            \"\"\"\n+            The detail view of a poll with a pub_date in the past should display\n+            the poll's question.\n+            \"\"\"\n+            past_poll = create_poll(question='Past Poll.', days=-5)\n+            response = self.client.get(reverse('polls:detail', args=(past_poll.id,)))\n+            self.assertContains(response, past_poll.question, status_code=200)\n+\n+Ideas for more tests\n+--------------------\n+\n+We ought to add similar ``queryset`` arguments to the other ``DetailView``\n+URLs, and create a new test class for each view. They'll be very similar to\n+what we have just created; in fact there will be a lot of repetition.\n+\n+We could also improve our application in other ways, adding tests along the\n+way. For example, it's silly that ``Polls`` can be published on the site that\n+have no ``Choices``. So, our views could check for this, and exclude such\n+``Polls``. Our tests would create a ``Poll`` without ``Choices`` and then test\n+that it's not published, as well as create a similar ``Poll`` *with*\n+``Choices``, and test that it *is* published.\n+\n+Perhaps logged-in admin users should be allowed to see unpublished ``Polls``,\n+but not ordinary visitors. Again: whatever needs to be added to the software to\n+accomplish this should be accompanied by a test, whether you write the test\n+first and then make the code pass the test, or work out the logic in your code\n+first and then write a test to prove it.\n+\n+At a certain point you are bound to look at your tests and wonder whether your\n+code is suffering from test bloat, which brings us to:\n+\n+When testing, more is better\n+============================\n+\n+It might seem that our tests are growing out of control. At this rate there will\n+soon be more code in our tests than in our application, and the repetition\n+is unaesthetic, compared to the elegant conciseness of the rest of our code.\n+\n+**It doesn't matter**. Let them grow. For the most part, you can write a test\n+once and then forget about it. It will continue performing its useful function\n+as you continue to develop your program.\n+\n+Sometimes tests will need to be updated. Suppose that we amend our views so that\n+only ``Polls`` with ``Choices`` are published. In that case, many of our\n+existing tests will fail - *telling us exactly which tests need to be amended to\n+bring them up to date*, so to that extent tests help look after themselves.\n+\n+At worst, as you continue developing, you might find that you have some tests\n+that are now redundant. Even that's not a problem; in testing redundancy is\n+a *good* thing.\n+\n+As long as your tests are sensibly arranged, they won't become unmanageable.\n+Good rules-of-thumb include having:\n+\n+* a separate ``TestClass`` for each model or view\n+* a separate test method for each set of conditions you want to test\n+* test method names that describe their function\n+\n+Further testing\n+===============\n+\n+This tutorial only introduces some of the basics of testing. There's a great\n+deal more you can do, and a number of very useful tools at your disposal to\n+achieve some very clever things.\n+\n+For example, while our tests here have covered some of the internal logic of a\n+model and the way our views publish information, you can use an \"in-browser\"\n+framework such as Selenium_ to test the way your HTML actually renders in a\n+browser. These tools allow you to check not just the behavior of your Django\n+code, but also, for example, of your JavaScript. It's quite something to see\n+the tests launch a browser, and start interacting with your site, as if a human\n+being were driving it! Django includes :class:`~django.test.LiveServerTestCase`\n+to facilitate integration with tools like Selenium.\n+\n+If you have a complex application, you may want to run tests automatically\n+with every commit for the purposes of `continuous integration`_, so that\n+quality control is itself - at least partially - automated.\n+\n+A good way to spot untested parts of your application is to check code\n+coverage. This also helps identify fragile or even dead code. If you can't test\n+a piece of code, it usually means that code should be refactored or removed.\n+Coverage will help to identify dead code. See\n+:ref:`topics-testing-code-coverage` for details.\n+\n+:doc:`Testing Django applications </topics/testing>` has comprehensive\n+information about testing.\n+\n+.. _Selenium: http://seleniumhq.org/\n+.. _continuous integration: http://en.wikipedia.org/wiki/Continuous_integration\n+\n+What's next?\n+============\n+\n+The beginner tutorial ends here for the time being. In the meantime, you might\n+want to check out some pointers on :doc:`where to go from here\n+</intro/whatsnext>`.\n+\n+If you are familiar with Python packaging and interested in learning how to\n+turn polls into a \"reusable app\", check out :doc:`Advanced tutorial: How to\n+write reusable apps</intro/reusable-apps>`."
        }
    ],
    "stats": {
        "total": 670,
        "additions": 657,
        "deletions": 13
    }
}