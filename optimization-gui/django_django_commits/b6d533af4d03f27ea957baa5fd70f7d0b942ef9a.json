{
    "author": "charettes",
    "message": "Fixed #18399 – Added a way to get ContentTypes for proxy models\n\nAdded kwargs for_concrete_model and for_concrete_models to ContentType\nmethods get_for_model() and get_for_models(). By setting the flag to\nFalse, it is possible to get the contenttype for proxy models.",
    "sha": "b6d533af4d03f27ea957baa5fd70f7d0b942ef9a",
    "files": [
        {
            "sha": "867351f6c8d9022f580c90334bd5e2616ac87efa",
            "filename": "django/contrib/contenttypes/models.py",
            "status": "modified",
            "additions": 11,
            "deletions": 6,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/b6d533af4d03f27ea957baa5fd70f7d0b942ef9a/django%2Fcontrib%2Fcontenttypes%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/b6d533af4d03f27ea957baa5fd70f7d0b942ef9a/django%2Fcontrib%2Fcontenttypes%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fcontenttypes%2Fmodels.py?ref=b6d533af4d03f27ea957baa5fd70f7d0b942ef9a",
            "patch": "@@ -16,20 +16,24 @@ def get_by_natural_key(self, app_label, model):\n             self._add_to_cache(self.db, ct)\n         return ct\n \n-    def _get_opts(self, model):\n-        return model._meta.concrete_model._meta\n+    def _get_opts(self, model, for_concrete_model):\n+        if for_concrete_model:\n+            model = model._meta.concrete_model\n+        elif model._deferred:\n+            model = model._meta.proxy_for_model\n+        return model._meta\n \n     def _get_from_cache(self, opts):\n         key = (opts.app_label, opts.object_name.lower())\n         return self.__class__._cache[self.db][key]\n \n-    def get_for_model(self, model):\n+    def get_for_model(self, model, for_concrete_model=True):\n         \"\"\"\n         Returns the ContentType object for a given model, creating the\n         ContentType if necessary. Lookups are cached so that subsequent lookups\n         for the same model don't hit the database.\n         \"\"\"\n-        opts = self._get_opts(model)\n+        opts = self._get_opts(model, for_concrete_model)\n         try:\n             ct = self._get_from_cache(opts)\n         except KeyError:\n@@ -45,18 +49,19 @@ def get_for_model(self, model):\n \n         return ct\n \n-    def get_for_models(self, *models):\n+    def get_for_models(self, *models, **kwargs):\n         \"\"\"\n         Given *models, returns a dictionary mapping {model: content_type}.\n         \"\"\"\n+        for_concrete_models = kwargs.pop('for_concrete_models', True)\n         # Final results\n         results = {}\n         # models that aren't already in the cache\n         needed_app_labels = set()\n         needed_models = set()\n         needed_opts = set()\n         for model in models:\n-            opts = self._get_opts(model)\n+            opts = self._get_opts(model, for_concrete_models)\n             try:\n                 ct = self._get_from_cache(opts)\n             except KeyError:"
        },
        {
            "sha": "0efc5222c0427433f345a0ccf7b3f6d8b3c8e16c",
            "filename": "django/contrib/contenttypes/tests.py",
            "status": "modified",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/django/django/blob/b6d533af4d03f27ea957baa5fd70f7d0b942ef9a/django%2Fcontrib%2Fcontenttypes%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/b6d533af4d03f27ea957baa5fd70f7d0b942ef9a/django%2Fcontrib%2Fcontenttypes%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fcontenttypes%2Ftests.py?ref=b6d533af4d03f27ea957baa5fd70f7d0b942ef9a",
            "patch": "@@ -11,6 +11,13 @@\n from django.utils.encoding import smart_str\n \n \n+class ConcreteModel(models.Model):\n+    name = models.CharField(max_length=10)\n+\n+class ProxyModel(ConcreteModel):\n+    class Meta:\n+        proxy = True\n+\n class FooWithoutUrl(models.Model):\n     \"\"\"\n     Fake model not defining ``get_absolute_url`` for\n@@ -114,6 +121,87 @@ def test_get_for_models_full_cache(self):\n             FooWithUrl: ContentType.objects.get_for_model(FooWithUrl),\n         })\n \n+    def test_get_for_concrete_model(self):\n+        \"\"\"\n+        Make sure the `for_concrete_model` kwarg correctly works\n+        with concrete, proxy and deferred models\n+        \"\"\"\n+        concrete_model_ct = ContentType.objects.get_for_model(ConcreteModel)\n+\n+        self.assertEqual(concrete_model_ct,\n+            ContentType.objects.get_for_model(ProxyModel))\n+\n+        self.assertEqual(concrete_model_ct,\n+            ContentType.objects.get_for_model(ConcreteModel,\n+                                              for_concrete_model=False))\n+\n+        proxy_model_ct = ContentType.objects.get_for_model(ProxyModel,\n+                                                           for_concrete_model=False)\n+\n+        self.assertNotEqual(concrete_model_ct, proxy_model_ct)\n+\n+        # Make sure deferred model are correctly handled\n+        ConcreteModel.objects.create(name=\"Concrete\")\n+        DeferredConcreteModel = ConcreteModel.objects.only('pk').get().__class__\n+        DeferredProxyModel = ProxyModel.objects.only('pk').get().__class__\n+\n+        self.assertEqual(concrete_model_ct,\n+            ContentType.objects.get_for_model(DeferredConcreteModel))\n+\n+        self.assertEqual(concrete_model_ct,\n+            ContentType.objects.get_for_model(DeferredConcreteModel,\n+                                              for_concrete_model=False))\n+        \n+        self.assertEqual(concrete_model_ct,\n+            ContentType.objects.get_for_model(DeferredProxyModel))\n+\n+        self.assertEqual(proxy_model_ct,\n+            ContentType.objects.get_for_model(DeferredProxyModel,\n+                                              for_concrete_model=False))\n+        \n+    def test_get_for_concrete_models(self):\n+        \"\"\"\n+        Make sure the `for_concrete_models` kwarg correctly works\n+        with concrete, proxy and deferred models.\n+        \"\"\"\n+        concrete_model_ct = ContentType.objects.get_for_model(ConcreteModel)\n+\n+        cts = ContentType.objects.get_for_models(ConcreteModel, ProxyModel)\n+        self.assertEqual(cts, {\n+            ConcreteModel: concrete_model_ct,\n+            ProxyModel: concrete_model_ct,\n+        })\n+\n+        proxy_model_ct = ContentType.objects.get_for_model(ProxyModel,\n+                                                           for_concrete_model=False)\n+        cts = ContentType.objects.get_for_models(ConcreteModel, ProxyModel,\n+                                                 for_concrete_models=False)\n+        self.assertEqual(cts, {\n+            ConcreteModel: concrete_model_ct,\n+            ProxyModel: proxy_model_ct,\n+        })\n+\n+        # Make sure deferred model are correctly handled\n+        ConcreteModel.objects.create(name=\"Concrete\")\n+        DeferredConcreteModel = ConcreteModel.objects.only('pk').get().__class__\n+        DeferredProxyModel = ProxyModel.objects.only('pk').get().__class__\n+        \n+        cts = ContentType.objects.get_for_models(DeferredConcreteModel,\n+                                                 DeferredProxyModel)\n+        self.assertEqual(cts, {\n+            DeferredConcreteModel: concrete_model_ct,\n+            DeferredProxyModel: concrete_model_ct,\n+        })\n+\n+        cts = ContentType.objects.get_for_models(DeferredConcreteModel,\n+                                                 DeferredProxyModel,\n+                                                 for_concrete_models=False)\n+        self.assertEqual(cts, {\n+            DeferredConcreteModel: concrete_model_ct,\n+            DeferredProxyModel: proxy_model_ct,\n+        })\n+        \n+\n     def test_shortcut_view(self):\n         \"\"\"\n         Check that the shortcut view (used for the admin \"view on site\""
        },
        {
            "sha": "1e9e21a4b75e9b4491c524f0059fb31b312899fe",
            "filename": "docs/ref/contrib/contenttypes.txt",
            "status": "modified",
            "additions": 15,
            "deletions": 2,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/b6d533af4d03f27ea957baa5fd70f7d0b942ef9a/docs%2Fref%2Fcontrib%2Fcontenttypes.txt",
            "raw_url": "https://github.com/django/django/raw/b6d533af4d03f27ea957baa5fd70f7d0b942ef9a/docs%2Fref%2Fcontrib%2Fcontenttypes.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fcontrib%2Fcontenttypes.txt?ref=b6d533af4d03f27ea957baa5fd70f7d0b942ef9a",
            "patch": "@@ -187,13 +187,13 @@ The ``ContentTypeManager``\n         probably won't ever need to call this method yourself; Django will call\n         it automatically when it's needed.\n \n-    .. method:: get_for_model(model)\n+    .. method:: get_for_model(model[, for_concrete_model=True])\n \n         Takes either a model class or an instance of a model, and returns the\n         :class:`~django.contrib.contenttypes.models.ContentType` instance\n         representing that model.\n \n-    .. method:: get_for_models(*models)\n+    .. method:: get_for_models(*models[, for_concrete_models=True])\n \n         Takes a variadic number of model classes, and returns a dictionary\n         mapping the model classes to the\n@@ -224,6 +224,19 @@ lookup::\n \n .. _generic-relations:\n \n+.. versionadded:: 1.5\n+\n+Prior to Django 1.5 :meth:`~ContentTypeManager.get_for_model()` and \n+:meth:`~ContentTypeManager.get_for_models()` always returned the \n+:class:`~django.contrib.contenttypes.models.ContentType` associated with the \n+concrete model of the specified one(s). That means there was no way to retreive \n+the :class:`~django.contrib.contenttypes.models.ContentType` of a proxy model \n+using those methods. As of Django 1.5 you can now pass a boolean flag – \n+respectively ``for_concrete_model`` and ``for_concrete_models`` – to specify\n+wether or not you want to retreive the \n+:class:`~django.contrib.contenttypes.models.ContentType` for the concrete or \n+direct model.\n+\n Generic relations\n =================\n "
        },
        {
            "sha": "575bd8d0f891344be513e580462562889d287426",
            "filename": "docs/releases/1.5.txt",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/b6d533af4d03f27ea957baa5fd70f7d0b942ef9a/docs%2Freleases%2F1.5.txt",
            "raw_url": "https://github.com/django/django/raw/b6d533af4d03f27ea957baa5fd70f7d0b942ef9a/docs%2Freleases%2F1.5.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.5.txt?ref=b6d533af4d03f27ea957baa5fd70f7d0b942ef9a",
            "patch": "@@ -69,6 +69,16 @@ To make it easier to deal with javascript templates which collide with Django's\n syntax, you can now use the :ttag:`verbatim` block tag to avoid parsing the\n tag's content.\n \n+Retreival of ``ContentType`` instances associated with proxy models\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The methods :meth:`ContentTypeManager.get_for_model() <django.contrib.contenttypes.models.ContentTypeManager.get_for_model()>` \n+and :meth:`ContentTypeManager.get_for_models() <django.contrib.contenttypes.models.ContentTypeManager.get_for_models()>` \n+have a new keyword argument – respectively ``for_concrete_model`` and ``for_concrete_models``. \n+By passing ``False`` using this argument it is now possible to retreive the\n+:class:`ContentType <django.contrib.contenttypes.models.ContentType>` \n+associated with proxy models.\n+\n Minor features\n ~~~~~~~~~~~~~~\n "
        }
    ],
    "stats": {
        "total": 132,
        "additions": 124,
        "deletions": 8
    }
}