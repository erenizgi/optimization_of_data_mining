{
    "author": "andrewgodwin",
    "message": "Add M2M tests and some unique support",
    "sha": "b139315f1c5e3eb05c76237c2824bdf03bd689b6",
    "files": [
        {
            "sha": "b9c642d09396f495e3259e8aa68868614c3b1bc7",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/b139315f1c5e3eb05c76237c2824bdf03bd689b6/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/b139315f1c5e3eb05c76237c2824bdf03bd689b6/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=b139315f1c5e3eb05c76237c2824bdf03bd689b6",
            "patch": "@@ -427,6 +427,9 @@ class BaseDatabaseFeatures(object):\n     # Can we issue more than one ALTER COLUMN clause in an ALTER TABLE?\n     supports_combined_alters = False\n \n+    # What's the maximum length for index names?\n+    max_index_name_length = 63\n+\n     def __init__(self, connection):\n         self.connection = connection\n \n@@ -1056,6 +1059,15 @@ def get_indexes(self, cursor, table_name):\n         \"\"\"\n         raise NotImplementedError\n \n+    def get_constraints(self, cursor, table_name):\n+        \"\"\"\n+        Returns {'cnname': {'columns': set(columns), 'primary_key': bool, 'unique': bool}}\n+        \n+        Both single- and multi-column constraints are introspected.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+\n class BaseDatabaseClient(object):\n     \"\"\"\n     This class encapsulates all backend-specific methods for opening a"
        },
        {
            "sha": "4dffd78f44d77fec5410cfea1aa297bdf907f6b4",
            "filename": "django/db/backends/creation.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/b139315f1c5e3eb05c76237c2824bdf03bd689b6/django%2Fdb%2Fbackends%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/b139315f1c5e3eb05c76237c2824bdf03bd689b6/django%2Fdb%2Fbackends%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fcreation.py?ref=b139315f1c5e3eb05c76237c2824bdf03bd689b6",
            "patch": "@@ -21,7 +21,8 @@ class BaseDatabaseCreation(object):\n     def __init__(self, connection):\n         self.connection = connection\n \n-    def _digest(self, *args):\n+    @classmethod\n+    def _digest(cls, *args):\n         \"\"\"\n         Generates a 32-bit digest of a set of arguments that can be used to\n         shorten identifying names."
        },
        {
            "sha": "c8b8ec833bc9d6979f0624744d7b3386b302645f",
            "filename": "django/db/backends/postgresql_psycopg2/introspection.py",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/django/django/blob/b139315f1c5e3eb05c76237c2824bdf03bd689b6/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fintrospection.py",
            "raw_url": "https://github.com/django/django/raw/b139315f1c5e3eb05c76237c2824bdf03bd689b6/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fintrospection.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fintrospection.py?ref=b139315f1c5e3eb05c76237c2824bdf03bd689b6",
            "patch": "@@ -88,3 +88,35 @@ def get_indexes(self, cursor, table_name):\n                 continue\n             indexes[row[0]] = {'primary_key': row[3], 'unique': row[2]}\n         return indexes\n+\n+    def get_constraints(self, cursor, table_name):\n+        \"\"\"\n+        Retrieves any constraints (unique, pk, check) across one or more columns.\n+        Returns {'cnname': {'columns': set(columns), 'primary_key': bool, 'unique': bool}}\n+        \"\"\"\n+        constraints = {}\n+        # Loop over the constraint tables, collecting things as constraints\n+        ifsc_tables = [\"constraint_column_usage\", \"key_column_usage\"]\n+        for ifsc_table in ifsc_tables:\n+            cursor.execute(\"\"\"\n+                SELECT kc.constraint_name, kc.column_name, c.constraint_type\n+                FROM information_schema.%s AS kc\n+                JOIN information_schema.table_constraints AS c ON\n+                    kc.table_schema = c.table_schema AND\n+                    kc.table_name = c.table_name AND\n+                    kc.constraint_name = c.constraint_name\n+                WHERE\n+                    kc.table_schema = %%s AND\n+                    kc.table_name = %%s\n+            \"\"\" % ifsc_table, [\"public\", table_name])\n+            for constraint, column, kind in cursor.fetchall():\n+                # If we're the first column, make the record\n+                if constraint not in constraints:\n+                    constraints[constraint] = {\n+                        \"columns\": set(),\n+                        \"primary_key\": kind.lower() == \"primary key\",\n+                        \"unique\": kind.lower() in [\"primary key\", \"unique\"],\n+                    }\n+                # Record the details\n+                constraints[constraint]['columns'].add(column)\n+        return constraints"
        },
        {
            "sha": "5f4e0146b46e8a9403b9f4abc30da24b3b95258c",
            "filename": "django/db/backends/schema.py",
            "status": "modified",
            "additions": 71,
            "deletions": 11,
            "changes": 82,
            "blob_url": "https://github.com/django/django/blob/b139315f1c5e3eb05c76237c2824bdf03bd689b6/django%2Fdb%2Fbackends%2Fschema.py",
            "raw_url": "https://github.com/django/django/raw/b139315f1c5e3eb05c76237c2824bdf03bd689b6/django%2Fdb%2Fbackends%2Fschema.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fschema.py?ref=b139315f1c5e3eb05c76237c2824bdf03bd689b6",
            "patch": "@@ -4,6 +4,8 @@\n from django.conf import settings\n from django.db import transaction\n from django.db.utils import load_backend\n+from django.db.backends.creation import BaseDatabaseCreation\n+from django.db.backends.util import truncate_name\n from django.utils.log import getLogger\n from django.db.models.fields.related import ManyToManyField\n \n@@ -294,7 +296,23 @@ def alter_field(self, model, old_field, new_field):\n                     old_field,\n                     new_field,\n                 ))\n-        # First, have they renamed the column?\n+        # Has unique been removed?\n+        if old_field.unique and not new_field.unique:\n+            # Find the unique constraint for this field\n+            constraint_names = self._constraint_names(model, [old_field.column], unique=True)\n+            if len(constraint_names) != 1:\n+                raise ValueError(\"Found wrong number (%s) of constraints for %s.%s\" % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    old_field.column,\n+                ))\n+            self.execute(\n+                self.sql_delete_unique % {\n+                    \"table\": self.quote_name(model._meta.db_table),\n+                    \"name\": constraint_names[0],\n+                },\n+            )\n+        # Have they renamed the column?\n         if old_field.column != new_field.column:\n             self.execute(self.sql_rename_column % {\n                 \"table\": self.quote_name(model._meta.db_table),\n@@ -347,16 +365,58 @@ def alter_field(self, model, old_field, new_field):\n                     },\n                     [],\n                 ))\n-        # Combine actions together if we can (e.g. postgres)\n-        if self.connection.features.supports_combined_alters:\n-            sql, params = tuple(zip(*actions))\n-            actions = [(\", \".join(sql), params)]\n-        # Apply those actions\n-        for sql, params in actions:\n+        if actions:\n+            # Combine actions together if we can (e.g. postgres)\n+            if self.connection.features.supports_combined_alters:\n+                sql, params = tuple(zip(*actions))\n+                actions = [(\", \".join(sql), params)]\n+            # Apply those actions\n+            for sql, params in actions:\n+                self.execute(\n+                    self.sql_alter_column % {\n+                        \"table\": self.quote_name(model._meta.db_table),\n+                        \"changes\": sql,\n+                    },\n+                    params,\n+                )\n+        # Added a unique?\n+        if not old_field.unique and new_field.unique:\n             self.execute(\n-                self.sql_alter_column % {\n+                self.sql_create_unique % {\n                     \"table\": self.quote_name(model._meta.db_table),\n-                    \"changes\": sql,\n-                },\n-                params,\n+                    \"name\": self._create_index_name(model, [new_field.column], suffix=\"_uniq\"),\n+                    \"columns\": self.quote_name(new_field.column),\n+                }\n             )\n+\n+    def _create_index_name(self, model, column_names, suffix=\"\"):\n+        \"Generates a unique name for an index/unique constraint.\"\n+        # If there is just one column in the index, use a default algorithm from Django\n+        if len(column_names) == 1 and not suffix:\n+            return truncate_name(\n+                '%s_%s' % (model._meta.db_table, BaseDatabaseCreation._digest(column_names[0])),\n+                self.connection.ops.max_name_length()\n+            )\n+        # Else generate the name for the index by South\n+        table_name = model._meta.db_table.replace('\"', '').replace('.', '_')\n+        index_unique_name = '_%x' % abs(hash((table_name, ','.join(column_names))))\n+        # If the index name is too long, truncate it\n+        index_name = ('%s_%s%s%s' % (table_name, column_names[0], index_unique_name, suffix)).replace('\"', '').replace('.', '_')\n+        if len(index_name) > self.connection.features.max_index_name_length:\n+            part = ('_%s%s%s' % (column_names[0], index_unique_name, suffix))\n+            index_name = '%s%s' % (table_name[:(self.connection.features.max_index_name_length - len(part))], part)\n+        return index_name\n+\n+    def _constraint_names(self, model, column_names, unique=None, primary_key=None):\n+        \"Returns all constraint names matching the columns and conditions\"\n+        column_names = set(column_names)\n+        constraints = self.connection.introspection.get_constraints(self.connection.cursor(), model._meta.db_table)\n+        result = []\n+        for name, infodict in constraints.items():\n+            if column_names == infodict['columns']:\n+                if unique is not None and infodict['unique'] != unique:\n+                    continue\n+                if primary_key is not None and infodict['primary_key'] != unique:\n+                    continue\n+                result.append(name)\n+        return result"
        },
        {
            "sha": "2362718bf3d17a2d5c05d139a41436b2a10c760a",
            "filename": "tests/modeltests/schema/models.py",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/b139315f1c5e3eb05c76237c2824bdf03bd689b6/tests%2Fmodeltests%2Fschema%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/b139315f1c5e3eb05c76237c2824bdf03bd689b6/tests%2Fmodeltests%2Fschema%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fschema%2Fmodels.py?ref=b139315f1c5e3eb05c76237c2824bdf03bd689b6",
            "patch": "@@ -12,10 +12,23 @@ class Meta:\n         managed = False\n \n \n+class AuthorWithM2M(models.Model):\n+    name = models.CharField(max_length=255)\n+\n+    class Meta:\n+        managed = False\n+\n+\n class Book(models.Model):\n     author = models.ForeignKey(Author)\n     title = models.CharField(max_length=100)\n     pub_date = models.DateTimeField()\n+    #tags = models.ManyToManyField(\"Tag\", related_name=\"books\")\n \n     class Meta:\n         managed = False\n+\n+\n+class Tag(models.Model):\n+    title = models.CharField(max_length=255)\n+    slug = models.SlugField(unique=True)"
        },
        {
            "sha": "8708fd7c8d40905effd9265d69db9e706579d408",
            "filename": "tests/modeltests/schema/tests.py",
            "status": "modified",
            "additions": 129,
            "deletions": 3,
            "changes": 132,
            "blob_url": "https://github.com/django/django/blob/b139315f1c5e3eb05c76237c2824bdf03bd689b6/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/b139315f1c5e3eb05c76237c2824bdf03bd689b6/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fschema%2Ftests.py?ref=b139315f1c5e3eb05c76237c2824bdf03bd689b6",
            "patch": "@@ -3,9 +3,10 @@\n import datetime\n from django.test import TestCase\n from django.db import connection, DatabaseError, IntegrityError\n-from django.db.models.fields import IntegerField, TextField\n+from django.db.models.fields import IntegerField, TextField, CharField, SlugField\n+from django.db.models.fields.related import ManyToManyField\n from django.db.models.loading import cache\n-from .models import Author, Book\n+from .models import Author, Book, AuthorWithM2M, Tag\n \n \n class SchemaTests(TestCase):\n@@ -17,7 +18,7 @@ class SchemaTests(TestCase):\n     as the code it is testing.\n     \"\"\"\n \n-    models = [Author, Book]\n+    models = [Author, Book, AuthorWithM2M, Tag]\n \n     # Utility functions\n \n@@ -39,6 +40,17 @@ def tearDown(self):\n         # Delete any tables made for our models\n         cursor = connection.cursor()\n         for model in self.models:\n+            # Remove any M2M tables first\n+            for field in model._meta.local_many_to_many:\n+                try:\n+                    cursor.execute(\"DROP TABLE %s CASCADE\" % (\n+                        connection.ops.quote_name(field.rel.through._meta.db_table),\n+                    ))\n+                except DatabaseError:\n+                    connection.rollback()\n+                else:\n+                    connection.commit()\n+            # Then remove the main tables\n             try:\n                 cursor.execute(\"DROP TABLE %s CASCADE\" % (\n                     connection.ops.quote_name(model._meta.db_table),\n@@ -172,3 +184,117 @@ def test_alter(self):\n         columns = self.column_classes(Author)\n         self.assertEqual(columns['name'][0], \"TextField\")\n         self.assertEqual(columns['name'][1][6], True)\n+\n+    def test_rename(self):\n+        \"\"\"\n+        Tests simple altering of fields\n+        \"\"\"\n+        # Create the table\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.create_model(Author)\n+        editor.commit()\n+        # Ensure the field is right to begin with\n+        columns = self.column_classes(Author)\n+        self.assertEqual(columns['name'][0], \"CharField\")\n+        self.assertEqual(columns['name'][1][3], 255)\n+        self.assertNotIn(\"display_name\", columns)\n+        # Alter the name field's name\n+        new_field = CharField(max_length=254)\n+        new_field.set_attributes_from_name(\"display_name\")\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.alter_field(\n+            Author,\n+            Author._meta.get_field_by_name(\"name\")[0],\n+            new_field,\n+        )\n+        editor.commit()\n+        # Ensure the field is right afterwards\n+        columns = self.column_classes(Author)\n+        self.assertEqual(columns['display_name'][0], \"CharField\")\n+        self.assertEqual(columns['display_name'][1][3], 254)\n+        self.assertNotIn(\"name\", columns)\n+\n+    def test_m2m(self):\n+        \"\"\"\n+        Tests adding/removing M2M fields on models\n+        \"\"\"\n+        # Create the tables\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.create_model(AuthorWithM2M)\n+        editor.create_model(Tag)\n+        editor.commit()\n+        # Create an M2M field\n+        new_field = ManyToManyField(\"schema.Tag\", related_name=\"authors\")\n+        new_field.contribute_to_class(AuthorWithM2M, \"tags\")\n+        # Ensure there's no m2m table there\n+        self.assertRaises(DatabaseError, self.column_classes, new_field.rel.through)\n+        connection.rollback()\n+        # Add the field\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.create_field(\n+            Author,\n+            new_field,\n+        )\n+        editor.commit()\n+        # Ensure there is now an m2m table there\n+        columns = self.column_classes(new_field.rel.through)\n+        self.assertEqual(columns['tag_id'][0], \"IntegerField\")\n+        # Remove the M2M table again\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.delete_field(\n+            Author,\n+            new_field,\n+        )\n+        editor.commit()\n+        # Ensure there's no m2m table there\n+        self.assertRaises(DatabaseError, self.column_classes, new_field.rel.through)\n+        connection.rollback()\n+\n+    def test_unique(self):\n+        \"\"\"\n+        Tests removing and adding unique constraints to a single column.\n+        \"\"\"\n+        # Create the table\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.create_model(Tag)\n+        editor.commit()\n+        # Ensure the field is unique to begin with\n+        Tag.objects.create(title=\"foo\", slug=\"foo\")\n+        self.assertRaises(IntegrityError, Tag.objects.create, title=\"bar\", slug=\"foo\")\n+        connection.rollback()\n+        # Alter the slug field to be non-unique\n+        new_field = SlugField(unique=False)\n+        new_field.set_attributes_from_name(\"slug\")\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.alter_field(\n+            Tag,\n+            Tag._meta.get_field_by_name(\"slug\")[0],\n+            new_field,\n+        )\n+        editor.commit()\n+        # Ensure the field is no longer unique\n+        Tag.objects.create(title=\"foo\", slug=\"foo\")\n+        Tag.objects.create(title=\"bar\", slug=\"foo\")\n+        connection.rollback()\n+        # Alter the slug field to be non-unique\n+        new_new_field = SlugField(unique=True)\n+        new_new_field.set_attributes_from_name(\"slug\")\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.alter_field(\n+            Tag,\n+            new_field,\n+            new_new_field,\n+        )\n+        editor.commit()\n+        # Ensure the field is unique again\n+        Tag.objects.create(title=\"foo\", slug=\"foo\")\n+        self.assertRaises(IntegrityError, Tag.objects.create, title=\"bar\", slug=\"foo\")\n+        connection.rollback()"
        }
    ],
    "stats": {
        "total": 274,
        "additions": 259,
        "deletions": 15
    }
}