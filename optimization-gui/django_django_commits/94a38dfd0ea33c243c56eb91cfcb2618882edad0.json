{
    "author": "jezdez",
    "message": "Fixed #16161 -- Added `--clear` option to `collectstatic` management command to be able to explicitly clear the files stored in the destination storage before collecting.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16509 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "94a38dfd0ea33c243c56eb91cfcb2618882edad0",
    "files": [
        {
            "sha": "6038cbceee5360086cd64ca4db5f50d64c66dde3",
            "filename": "django/contrib/staticfiles/management/commands/collectstatic.py",
            "status": "modified",
            "additions": 74,
            "deletions": 38,
            "changes": 112,
            "blob_url": "https://github.com/django/django/blob/94a38dfd0ea33c243c56eb91cfcb2618882edad0/django%2Fcontrib%2Fstaticfiles%2Fmanagement%2Fcommands%2Fcollectstatic.py",
            "raw_url": "https://github.com/django/django/raw/94a38dfd0ea33c243c56eb91cfcb2618882edad0/django%2Fcontrib%2Fstaticfiles%2Fmanagement%2Fcommands%2Fcollectstatic.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fstaticfiles%2Fmanagement%2Fcommands%2Fcollectstatic.py?ref=94a38dfd0ea33c243c56eb91cfcb2618882edad0",
            "patch": "@@ -1,12 +1,11 @@\n import os\n import sys\n-import shutil\n from optparse import make_option\n \n from django.conf import settings\n-from django.core.files.storage import get_storage_class\n+from django.core.files.storage import FileSystemStorage, get_storage_class\n from django.core.management.base import CommandError, NoArgsCommand\n-from django.utils.encoding import smart_str\n+from django.utils.encoding import smart_str, smart_unicode\n \n from django.contrib.staticfiles import finders\n \n@@ -24,6 +23,9 @@ class Command(NoArgsCommand):\n                 \"pattern. Use multiple times to ignore more.\"),\n         make_option('-n', '--dry-run', action='store_true', dest='dry_run',\n             default=False, help=\"Do everything except modify the filesystem.\"),\n+        make_option('-c', '--clear', action='store_true', dest='clear',\n+            default=False, help=\"Clear the existing files using the storage \"\n+                \"before trying to copy or link the original file.\"),\n         make_option('-l', '--link', action='store_true', dest='link',\n             default=False, help=\"Create a symbolic link to each file instead of copying.\"),\n         make_option('--no-default-ignore', action='store_false',\n@@ -49,54 +51,76 @@ def __init__(self, *args, **kwargs):\n         os.stat_float_times(False)\n \n     def handle_noargs(self, **options):\n-        symlink = options['link']\n+        self.clear = options['clear']\n+        self.dry_run = options['dry_run']\n         ignore_patterns = options['ignore_patterns']\n         if options['use_default_ignore_patterns']:\n             ignore_patterns += ['CVS', '.*', '*~']\n-        ignore_patterns = list(set(ignore_patterns))\n+        self.ignore_patterns = list(set(ignore_patterns))\n+        self.interactive = options['interactive']\n+        self.symlink = options['link']\n         self.verbosity = int(options.get('verbosity', 1))\n \n-        if symlink:\n+        if self.symlink:\n             if sys.platform == 'win32':\n                 raise CommandError(\"Symlinking is not supported by this \"\n                                    \"platform (%s).\" % sys.platform)\n             if not self.local:\n                 raise CommandError(\"Can't symlink to a remote destination.\")\n \n         # Warn before doing anything more.\n-        if options.get('interactive'):\n+        if (isinstance(self.storage, FileSystemStorage) and\n+                self.storage.location):\n+            destination_path = self.storage.location\n+            destination_display = ':\\n\\n    %s' % destination_path\n+        else:\n+            destination_path = None\n+            destination_display = '.'\n+\n+        if self.clear:\n+            clear_display = 'This will DELETE EXISTING FILES!'\n+        else:\n+            clear_display = 'This will overwrite existing files!'\n+\n+        if self.interactive:\n             confirm = raw_input(u\"\"\"\n You have requested to collect static files at the destination\n-location as specified in your settings file.\n+location as specified in your settings%s\n \n-This will overwrite existing files.\n+%s\n Are you sure you want to do this?\n \n-Type 'yes' to continue, or 'no' to cancel: \"\"\")\n+Type 'yes' to continue, or 'no' to cancel: \"\"\"\n+% (destination_display, clear_display))\n             if confirm != 'yes':\n                 raise CommandError(\"Collecting static files cancelled.\")\n \n+        if self.clear:\n+            self.clear_dir('')\n+\n+        handler = {\n+            True: self.link_file,\n+            False: self.copy_file\n+        }[self.symlink]\n+\n         for finder in finders.get_finders():\n-            for path, storage in finder.list(ignore_patterns):\n+            for path, storage in finder.list(self.ignore_patterns):\n                 # Prefix the relative path if the source storage contains it\n                 if getattr(storage, 'prefix', None):\n-                    prefixed_path = os.path.join(storage.prefix, path)\n-                else:\n-                    prefixed_path = path\n-                if symlink:\n-                    self.link_file(path, prefixed_path, storage, **options)\n-                else:\n-                    self.copy_file(path, prefixed_path, storage, **options)\n+                    path = os.path.join(storage.prefix, path)\n+                handler(path, path, storage)\n \n         actual_count = len(self.copied_files) + len(self.symlinked_files)\n         unmodified_count = len(self.unmodified_files)\n         if self.verbosity >= 1:\n-            self.stdout.write(smart_str(u\"\\n%s static file%s %s to '%s'%s.\\n\"\n-                              % (actual_count, actual_count != 1 and 's' or '',\n-                                 symlink and 'symlinked' or 'copied',\n-                                 settings.STATIC_ROOT,\n+            self.stdout.write(smart_str(u\"\\n%s static file%s %s %s%s.\\n\"\n+                              % (actual_count,\n+                                 actual_count != 1 and 's' or '',\n+                                 self.symlink and 'symlinked' or 'copied',\n+                                 destination_path and \"to '%s'\"\n+                                    % destination_path or '',\n                                  unmodified_count and ' (%s unmodified)'\n-                                 % unmodified_count or '')))\n+                                    % unmodified_count or '')))\n \n     def log(self, msg, level=2):\n         \"\"\"\n@@ -108,9 +132,23 @@ def log(self, msg, level=2):\n         if self.verbosity >= level:\n             self.stdout.write(msg)\n \n-    def delete_file(self, path, prefixed_path, source_storage, **options):\n+    def clear_dir(self, path):\n+        \"\"\"\n+        Deletes the given relative path using the destinatin storage backend.\n+        \"\"\"\n+        dirs, files = self.storage.listdir(path)\n+        for f in files:\n+            fpath = os.path.join(path, f)\n+            if self.dry_run:\n+                self.log(u\"Pretending to delete '%s'\" % smart_unicode(fpath), level=1)\n+            else:\n+                self.log(u\"Deleting '%s'\" % smart_unicode(fpath), level=1)\n+                self.storage.delete(fpath)\n+        for d in dirs:\n+            self.clear_dir(os.path.join(path, d))\n+\n+    def delete_file(self, path, prefixed_path, source_storage):\n         # Whether we are in symlink mode\n-        symlink = options['link']\n         # Checks if the target file should be deleted if it already exists\n         if self.storage.exists(prefixed_path):\n             try:\n@@ -133,34 +171,34 @@ def delete_file(self, path, prefixed_path, source_storage, **options):\n                         full_path = None\n                     # Skip the file if the source file is younger\n                     if target_last_modified >= source_last_modified:\n-                        if not ((symlink and full_path and not os.path.islink(full_path)) or\n-                                (not symlink and full_path and os.path.islink(full_path))):\n+                        if not ((self.symlink and full_path and not os.path.islink(full_path)) or\n+                                (not self.symlink and full_path and os.path.islink(full_path))):\n                             if prefixed_path not in self.unmodified_files:\n                                 self.unmodified_files.append(prefixed_path)\n                             self.log(u\"Skipping '%s' (not modified)\" % path)\n                             return False\n             # Then delete the existing file if really needed\n-            if options['dry_run']:\n+            if self.dry_run:\n                 self.log(u\"Pretending to delete '%s'\" % path)\n             else:\n                 self.log(u\"Deleting '%s'\" % path)\n                 self.storage.delete(prefixed_path)\n         return True\n \n-    def link_file(self, path, prefixed_path, source_storage, **options):\n+    def link_file(self, path, prefixed_path, source_storage):\n         \"\"\"\n         Attempt to link ``path``\n         \"\"\"\n         # Skip this file if it was already copied earlier\n         if prefixed_path in self.symlinked_files:\n             return self.log(u\"Skipping '%s' (already linked earlier)\" % path)\n         # Delete the target file if needed or break\n-        if not self.delete_file(path, prefixed_path, source_storage, **options):\n+        if not self.delete_file(path, prefixed_path, source_storage):\n             return\n         # The full path of the source file\n         source_path = source_storage.path(path)\n         # Finally link the file\n-        if options['dry_run']:\n+        if self.dry_run:\n             self.log(u\"Pretending to link '%s'\" % source_path, level=1)\n         else:\n             self.log(u\"Linking '%s'\" % source_path, level=1)\n@@ -173,20 +211,20 @@ def link_file(self, path, prefixed_path, source_storage, **options):\n         if prefixed_path not in self.symlinked_files:\n             self.symlinked_files.append(prefixed_path)\n \n-    def copy_file(self, path, prefixed_path, source_storage, **options):\n+    def copy_file(self, path, prefixed_path, source_storage):\n         \"\"\"\n         Attempt to copy ``path`` with storage\n         \"\"\"\n         # Skip this file if it was already copied earlier\n         if prefixed_path in self.copied_files:\n             return self.log(u\"Skipping '%s' (already copied earlier)\" % path)\n         # Delete the target file if needed or break\n-        if not self.delete_file(path, prefixed_path, source_storage, **options):\n+        if not self.delete_file(path, prefixed_path, source_storage):\n             return\n         # The full path of the source file\n         source_path = source_storage.path(path)\n         # Finally start copying\n-        if options['dry_run']:\n+        if self.dry_run:\n             self.log(u\"Pretending to copy '%s'\" % source_path, level=1)\n         else:\n             self.log(u\"Copying '%s'\" % source_path, level=1)\n@@ -196,9 +234,7 @@ def copy_file(self, path, prefixed_path, source_storage, **options):\n                     os.makedirs(os.path.dirname(full_path))\n                 except OSError:\n                     pass\n-                shutil.copy2(source_path, full_path)\n-            else:\n-                source_file = source_storage.open(path)\n-                self.storage.save(prefixed_path, source_file)\n+            source_file = source_storage.open(path)\n+            self.storage.save(prefixed_path, source_file)\n         if not prefixed_path in self.copied_files:\n             self.copied_files.append(prefixed_path)"
        },
        {
            "sha": "5ab3c1e02fa04ba8f1f203306bed7fbf5afd6ace",
            "filename": "docs/ref/contrib/staticfiles.txt",
            "status": "modified",
            "additions": 19,
            "deletions": 5,
            "changes": 24,
            "blob_url": "https://github.com/django/django/blob/94a38dfd0ea33c243c56eb91cfcb2618882edad0/docs%2Fref%2Fcontrib%2Fstaticfiles.txt",
            "raw_url": "https://github.com/django/django/raw/94a38dfd0ea33c243c56eb91cfcb2618882edad0/docs%2Fref%2Fcontrib%2Fstaticfiles.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fcontrib%2Fstaticfiles.txt?ref=94a38dfd0ea33c243c56eb91cfcb2618882edad0",
            "patch": "@@ -143,20 +143,34 @@ specified by the :setting:`INSTALLED_APPS` setting.\n \n Some commonly used options are:\n \n-``--noinput``\n+.. django-admin-option:: --noinput\n+\n     Do NOT prompt the user for input of any kind.\n \n-``-i PATTERN`` or ``--ignore=PATTERN``\n+.. django-admin-option:: -i <pattern>\n+.. django-admin-option:: --ignore <pattern>\n+\n     Ignore files or directories matching this glob-style pattern. Use multiple\n     times to ignore more.\n \n-``-n`` or ``--dry-run``\n+.. django-admin-option:: -n\n+.. django-admin-option:: --dry-run\n+\n     Do everything except modify the filesystem.\n \n-``-l`` or ``--link``\n+.. django-admin-option:: -c\n+.. django-admin-option:: --clear\n+.. versionadded:: 1.4\n+\n+    Clear the existing files before trying to copy or link the original file.\n+\n+.. django-admin-option:: -l\n+.. django-admin-option:: --link\n+\n     Create a symbolic link to each file instead of copying.\n \n-``--no-default-ignore``\n+.. django-admin-option:: --no-default-ignore\n+\n     Don't ignore the common private glob-style patterns ``'CVS'``, ``'.*'``\n     and ``'*~'``.\n "
        },
        {
            "sha": "55d845305cf41821bba414068eae8aee3d286a73",
            "filename": "docs/releases/1.4.txt",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/94a38dfd0ea33c243c56eb91cfcb2618882edad0/docs%2Freleases%2F1.4.txt",
            "raw_url": "https://github.com/django/django/raw/94a38dfd0ea33c243c56eb91cfcb2618882edad0/docs%2Freleases%2F1.4.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.4.txt?ref=94a38dfd0ea33c243c56eb91cfcb2618882edad0",
            "patch": "@@ -213,6 +213,9 @@ Django 1.4 also includes several smaller improvements worth noting:\n   to the :mod:`django.contrib.auth.utils` module. Importing it from the old\n   location will still work, but you should update your imports.\n \n+* The :djadmin:`collectstatic` management command gained a ``--clear`` option\n+  to delete all files at the destination before copying or linking the static\n+  files.\n \n .. _backwards-incompatible-changes-1.4:\n "
        },
        {
            "sha": "8a6012653a04b5d7375658a69922cbd04b9a249a",
            "filename": "tests/regressiontests/staticfiles_tests/tests.py",
            "status": "modified",
            "additions": 18,
            "deletions": 10,
            "changes": 28,
            "blob_url": "https://github.com/django/django/blob/94a38dfd0ea33c243c56eb91cfcb2618882edad0/tests%2Fregressiontests%2Fstaticfiles_tests%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/94a38dfd0ea33c243c56eb91cfcb2618882edad0/tests%2Fregressiontests%2Fstaticfiles_tests%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fstaticfiles_tests%2Ftests.py?ref=94a38dfd0ea33c243c56eb91cfcb2618882edad0",
            "patch": "@@ -1,4 +1,5 @@\n # -*- encoding: utf-8 -*-\n+from __future__ import with_statement\n import codecs\n import os\n import posixpath\n@@ -36,11 +37,8 @@ def setUp(self):\n         # during checkout, we actually create one file dynamically.\n         _nonascii_filepath = os.path.join(\n             TEST_ROOT, 'apps', 'test', 'static', 'test', u'fi\\u015fier.txt')\n-        f = codecs.open(_nonascii_filepath, 'w', 'utf-8')\n-        try:\n+        with codecs.open(_nonascii_filepath, 'w', 'utf-8') as f:\n             f.write(u\"fi\\u015fier in the app dir\")\n-        finally:\n-            f.close()\n         self.addCleanup(os.unlink, _nonascii_filepath)\n \n     def assertFileContains(self, filepath, text):\n@@ -94,12 +92,8 @@ def run_collectstatic(self, **kwargs):\n     def _get_file(self, filepath):\n         assert filepath, 'filepath is empty.'\n         filepath = os.path.join(settings.STATIC_ROOT, filepath)\n-        f = codecs.open(filepath, \"r\", \"utf-8\")\n-        try:\n+        with codecs.open(filepath, \"r\", \"utf-8\") as f:\n             return f.read()\n-        finally:\n-            f.close()\n-\n \n \n class TestDefaults(object):\n@@ -197,9 +191,23 @@ def test_common_ignore_patterns(self):\n         self.assertFileNotFound('test/CVS')\n \n \n+class TestBuildStaticClear(BuildStaticTestCase):\n+    \"\"\"\n+    Test the ``--clear`` option of the ``collectstatic`` managemenet command.\n+    \"\"\"\n+    def run_collectstatic(self, **kwargs):\n+        clear_filepath = os.path.join(settings.STATIC_ROOT, 'cleared.txt')\n+        with open(clear_filepath, 'w') as f:\n+            f.write('should be cleared')\n+        super(TestBuildStaticClear, self).run_collectstatic(clear=True)\n+\n+    def test_cleared_not_found(self):\n+        self.assertFileNotFound('cleared.txt')\n+\n+\n class TestBuildStaticExcludeNoDefaultIgnore(BuildStaticTestCase, TestDefaults):\n     \"\"\"\n-    Test ``--exclude-dirs`` and ``--no-default-ignore`` options for\n+    Test ``--exclude-dirs`` and ``--no-default-ignore`` options of the\n     ``collectstatic`` management command.\n     \"\"\"\n     def run_collectstatic(self):"
        }
    ],
    "stats": {
        "total": 167,
        "additions": 114,
        "deletions": 53
    }
}