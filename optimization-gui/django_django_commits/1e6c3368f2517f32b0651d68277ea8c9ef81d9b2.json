{
    "author": "aaugustin",
    "message": "Fixed #18177 -- Cached known related instances.\n\nThis was recently fixed for one-to-one relations; this patch adds\nsupport for foreign keys. Thanks kaiser.yann for the report and\nthe initial version of the patch.",
    "sha": "1e6c3368f2517f32b0651d68277ea8c9ef81d9b2",
    "files": [
        {
            "sha": "c4f95a12d24691a6f06fb3f9b1451568cd435052",
            "filename": "django/db/models/fields/related.py",
            "status": "modified",
            "additions": 40,
            "deletions": 23,
            "changes": 63,
            "blob_url": "https://github.com/django/django/blob/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "raw_url": "https://github.com/django/django/raw/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2Frelated.py?ref=1e6c3368f2517f32b0651d68277ea8c9ef81d9b2",
            "patch": "@@ -237,13 +237,18 @@ def get_query_set(self, **db_hints):\n         return self.related.model._base_manager.using(db)\n \n     def get_prefetch_query_set(self, instances):\n-        vals = set(instance._get_pk_val() for instance in instances)\n-        params = {'%s__pk__in' % self.related.field.name: vals}\n-        return (self.get_query_set(instance=instances[0]).filter(**params),\n-                attrgetter(self.related.field.attname),\n-                lambda obj: obj._get_pk_val(),\n-                True,\n-                self.cache_name)\n+        rel_obj_attr = attrgetter(self.related.field.attname)\n+        instance_attr = lambda obj: obj._get_pk_val()\n+        instances_dict = dict((instance_attr(inst), inst) for inst in instances)\n+        params = {'%s__pk__in' % self.related.field.name: instances_dict.keys()}\n+        qs = self.get_query_set(instance=instances[0]).filter(**params)\n+        # Since we're going to assign directly in the cache,\n+        # we must manage the reverse relation cache manually.\n+        rel_obj_cache_name = self.related.field.get_cache_name()\n+        for rel_obj in qs:\n+            instance = instances_dict[rel_obj_attr(rel_obj)]\n+            setattr(rel_obj, rel_obj_cache_name, instance)\n+        return qs, rel_obj_attr, instance_attr, True, self.cache_name\n \n     def __get__(self, instance, instance_type=None):\n         if instance is None:\n@@ -324,17 +329,23 @@ def get_query_set(self, **db_hints):\n             return QuerySet(self.field.rel.to).using(db)\n \n     def get_prefetch_query_set(self, instances):\n-        vals = set(getattr(instance, self.field.attname) for instance in instances)\n+        rel_obj_attr = attrgetter(self.field.rel.field_name)\n+        instance_attr = attrgetter(self.field.attname)\n+        instances_dict = dict((instance_attr(inst), inst) for inst in instances)\n         other_field = self.field.rel.get_related_field()\n         if other_field.rel:\n-            params = {'%s__pk__in' % self.field.rel.field_name: vals}\n+            params = {'%s__pk__in' % self.field.rel.field_name: instances_dict.keys()}\n         else:\n-            params = {'%s__in' % self.field.rel.field_name: vals}\n-        return (self.get_query_set(instance=instances[0]).filter(**params),\n-                attrgetter(self.field.rel.field_name),\n-                attrgetter(self.field.attname),\n-                True,\n-                self.cache_name)\n+            params = {'%s__in' % self.field.rel.field_name: instances_dict.keys()}\n+        qs = self.get_query_set(instance=instances[0]).filter(**params)\n+        # Since we're going to assign directly in the cache,\n+        # we must manage the reverse relation cache manually.\n+        if not self.field.rel.multiple:\n+            rel_obj_cache_name = self.field.related.get_cache_name()\n+            for rel_obj in qs:\n+                instance = instances_dict[rel_obj_attr(rel_obj)]\n+                setattr(rel_obj, rel_obj_cache_name, instance)\n+        return qs, rel_obj_attr, instance_attr, True, self.cache_name\n \n     def __get__(self, instance, instance_type=None):\n         if instance is None:\n@@ -467,18 +478,24 @@ def get_query_set(self):\n                     return self.instance._prefetched_objects_cache[rel_field.related_query_name()]\n                 except (AttributeError, KeyError):\n                     db = self._db or router.db_for_read(self.model, instance=self.instance)\n-                    return super(RelatedManager, self).get_query_set().using(db).filter(**self.core_filters)\n+                    qs = super(RelatedManager, self).get_query_set().using(db).filter(**self.core_filters)\n+                    qs._known_related_object = (rel_field.name, self.instance)\n+                    return qs\n \n             def get_prefetch_query_set(self, instances):\n+                rel_obj_attr = attrgetter(rel_field.get_attname())\n+                instance_attr = attrgetter(attname)\n+                instances_dict = dict((instance_attr(inst), inst) for inst in instances)\n                 db = self._db or router.db_for_read(self.model, instance=instances[0])\n-                query = {'%s__%s__in' % (rel_field.name, attname):\n-                             set(getattr(obj, attname) for obj in instances)}\n+                query = {'%s__%s__in' % (rel_field.name, attname): instances_dict.keys()}\n                 qs = super(RelatedManager, self).get_query_set().using(db).filter(**query)\n-                return (qs,\n-                        attrgetter(rel_field.get_attname()),\n-                        attrgetter(attname),\n-                        False,\n-                        rel_field.related_query_name())\n+                # Since we just bypassed this class' get_query_set(), we must manage\n+                # the reverse relation manually.\n+                for rel_obj in qs:\n+                    instance = instances_dict[rel_obj_attr(rel_obj)]\n+                    setattr(rel_obj, rel_field.name, instance)\n+                cache_name = rel_field.related_query_name()\n+                return qs, rel_obj_attr, instance_attr, False, cache_name\n \n             def add(self, *objs):\n                 for obj in objs:"
        },
        {
            "sha": "755820c3b0bad4111f85c770e879a8b67a22bd9b",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 13,
            "deletions": 8,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=1e6c3368f2517f32b0651d68277ea8c9ef81d9b2",
            "patch": "@@ -41,6 +41,7 @@ def __init__(self, model=None, query=None, using=None):\n         self._for_write = False\n         self._prefetch_related_lookups = []\n         self._prefetch_done = False\n+        self._known_related_object = None       # (attname, rel_obj)\n \n     ########################\n     # PYTHON MAGIC METHODS #\n@@ -282,9 +283,10 @@ def iterator(self):\n                     init_list.append(field.attname)\n             model_cls = deferred_class_factory(self.model, skip)\n \n-        # Cache db and model outside the loop\n+        # Cache db, model and known_related_object outside the loop\n         db = self.db\n         model = self.model\n+        kro_attname, kro_instance = self._known_related_object or (None, None)\n         compiler = self.query.get_compiler(using=db)\n         if fill_cache:\n             klass_info = get_klass_info(model, max_depth=max_depth,\n@@ -294,12 +296,12 @@ def iterator(self):\n                 obj, _ = get_cached_row(row, index_start, db, klass_info,\n                                         offset=len(aggregate_select))\n             else:\n+                # Omit aggregates in object creation.\n+                row_data = row[index_start:aggregate_start]\n                 if skip:\n-                    row_data = row[index_start:aggregate_start]\n                     obj = model_cls(**dict(zip(init_list, row_data)))\n                 else:\n-                    # Omit aggregates in object creation.\n-                    obj = model(*row[index_start:aggregate_start])\n+                    obj = model(*row_data)\n \n                 # Store the source database of the object\n                 obj._state.db = db\n@@ -313,7 +315,11 @@ def iterator(self):\n             # Add the aggregates to the model\n             if aggregate_select:\n                 for i, aggregate in enumerate(aggregate_select):\n-                    setattr(obj, aggregate, row[i+aggregate_start])\n+                    setattr(obj, aggregate, row[i + aggregate_start])\n+\n+            # Add the known related object to the model, if there is one\n+            if kro_instance:\n+                setattr(obj, kro_attname, kro_instance)\n \n             yield obj\n \n@@ -864,6 +870,7 @@ def _clone(self, klass=None, setup=False, **kwargs):\n         c = klass(model=self.model, query=query, using=self._db)\n         c._for_write = self._for_write\n         c._prefetch_related_lookups = self._prefetch_related_lookups[:]\n+        c._known_related_object = self._known_related_object\n         c.__dict__.update(kwargs)\n         if setup and hasattr(c, '_setup_query'):\n             c._setup_query()\n@@ -1781,9 +1788,7 @@ def prefetch_one_level(instances, prefetcher, attname):\n     rel_obj_cache = {}\n     for rel_obj in all_related_objects:\n         rel_attr_val = rel_obj_attr(rel_obj)\n-        if rel_attr_val not in rel_obj_cache:\n-            rel_obj_cache[rel_attr_val] = []\n-        rel_obj_cache[rel_attr_val].append(rel_obj)\n+        rel_obj_cache.setdefault(rel_attr_val, []).append(rel_obj)\n \n     for obj in instances:\n         instance_attr_val = instance_attr(obj)"
        },
        {
            "sha": "46b599a622a095796007dbf860d42207f6b1426c",
            "filename": "docs/releases/1.5.txt",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/django/django/blob/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/docs%2Freleases%2F1.5.txt",
            "raw_url": "https://github.com/django/django/raw/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/docs%2Freleases%2F1.5.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.5.txt?ref=1e6c3368f2517f32b0651d68277ea8c9ef81d9b2",
            "patch": "@@ -44,6 +44,24 @@ reasons or when trying to avoid overwriting concurrent changes.\n See the :meth:`Model.save() <django.db.models.Model.save()>` documentation for\n more details.\n \n+Caching of related model instances\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+When traversing relations, the ORM will avoid re-fetching objects that were\n+previously loaded. For example, with the tutorial's models::\n+\n+    >>> first_poll = Poll.objects.all()[0]\n+    >>> first_choice = first_poll.choice_set.all()[0]\n+    >>> first_choice.poll is first_poll\n+    True\n+\n+In Django 1.5, the third line no longer triggers a new SQL query to fetch\n+``first_choice.poll``; it was set when by the second line.\n+\n+For one-to-one relationships, both sides can be cached. For many-to-one\n+relationships, only the single side of the relationship can be cached. This\n+is particularly helpful in combination with ``prefetch_related``.\n+\n Minor features\n ~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/modeltests/known_related_objects/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/django/django/blob/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/tests%2Fmodeltests%2Fknown_related_objects%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/tests%2Fmodeltests%2Fknown_related_objects%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fknown_related_objects%2F__init__.py?ref=1e6c3368f2517f32b0651d68277ea8c9ef81d9b2"
        },
        {
            "sha": "2f2b1c56276688a023ee2c416657d500c5539b2a",
            "filename": "tests/modeltests/known_related_objects/fixtures/tournament.json",
            "status": "added",
            "additions": 65,
            "deletions": 0,
            "changes": 65,
            "blob_url": "https://github.com/django/django/blob/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/tests%2Fmodeltests%2Fknown_related_objects%2Ffixtures%2Ftournament.json",
            "raw_url": "https://github.com/django/django/raw/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/tests%2Fmodeltests%2Fknown_related_objects%2Ffixtures%2Ftournament.json",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fknown_related_objects%2Ffixtures%2Ftournament.json?ref=1e6c3368f2517f32b0651d68277ea8c9ef81d9b2",
            "patch": "@@ -0,0 +1,65 @@\n+[\n+    {\n+        \"pk\": 1,\n+        \"model\": \"known_related_objects.tournament\",\n+        \"fields\": {\n+            \"name\": \"Tourney 1\"\n+            }\n+        },\n+    {\n+        \"pk\": 2,\n+        \"model\": \"known_related_objects.tournament\",\n+        \"fields\": {\n+            \"name\": \"Tourney 2\"\n+            }\n+        },\n+    {\n+        \"pk\": 1,\n+        \"model\": \"known_related_objects.pool\",\n+        \"fields\": {\n+            \"tournament\": 1,\n+            \"name\": \"T1 Pool 1\"\n+            }\n+        },\n+    {\n+        \"pk\": 2,\n+        \"model\": \"known_related_objects.pool\",\n+        \"fields\": {\n+            \"tournament\": 1,\n+            \"name\": \"T1 Pool 2\"\n+            }\n+        },\n+    {\n+        \"pk\": 3,\n+        \"model\": \"known_related_objects.pool\",\n+        \"fields\": {\n+            \"tournament\": 2,\n+            \"name\": \"T2 Pool 1\"\n+            }\n+        },\n+    {\n+        \"pk\": 4,\n+        \"model\": \"known_related_objects.pool\",\n+        \"fields\": {\n+            \"tournament\": 2,\n+            \"name\": \"T2 Pool 2\"\n+            }\n+        },\n+    {\n+        \"pk\": 1,\n+        \"model\": \"known_related_objects.poolstyle\",\n+        \"fields\": {\n+            \"name\": \"T1 Pool 2 Style\",\n+            \"pool\": 2\n+            }\n+        },\n+    {\n+        \"pk\": 2,\n+        \"model\": \"known_related_objects.poolstyle\",\n+        \"fields\": {\n+            \"name\": \"T2 Pool 1 Style\",\n+            \"pool\": 3\n+            }\n+        }\n+]\n+"
        },
        {
            "sha": "4c516dd7e89f79c505e7508a0bd9ea0465f174ea",
            "filename": "tests/modeltests/known_related_objects/models.py",
            "status": "added",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/tests%2Fmodeltests%2Fknown_related_objects%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/tests%2Fmodeltests%2Fknown_related_objects%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fknown_related_objects%2Fmodels.py?ref=1e6c3368f2517f32b0651d68277ea8c9ef81d9b2",
            "patch": "@@ -0,0 +1,19 @@\n+\"\"\"\n+Existing related object instance caching.\n+\n+Test that queries are not redone when going back through known relations.\n+\"\"\"\n+\n+from django.db import models\n+\n+class Tournament(models.Model):\n+    name = models.CharField(max_length=30)\n+\n+class Pool(models.Model):\n+    name = models.CharField(max_length=30)\n+    tournament = models.ForeignKey(Tournament)\n+\n+class PoolStyle(models.Model):\n+    name = models.CharField(max_length=30)\n+    pool = models.OneToOneField(Pool)\n+"
        },
        {
            "sha": "24feab22419cd5e3a46d09fa0a78a70861bf44af",
            "filename": "tests/modeltests/known_related_objects/tests.py",
            "status": "added",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/django/django/blob/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/tests%2Fmodeltests%2Fknown_related_objects%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/1e6c3368f2517f32b0651d68277ea8c9ef81d9b2/tests%2Fmodeltests%2Fknown_related_objects%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fknown_related_objects%2Ftests.py?ref=1e6c3368f2517f32b0651d68277ea8c9ef81d9b2",
            "patch": "@@ -0,0 +1,88 @@\n+from __future__ import absolute_import\n+\n+from django.test import TestCase\n+\n+from .models import Tournament, Pool, PoolStyle\n+\n+class ExistingRelatedInstancesTests(TestCase):\n+    fixtures = ['tournament.json']\n+\n+    def test_foreign_key(self):\n+        with self.assertNumQueries(2):\n+            tournament = Tournament.objects.get(pk=1)\n+            pool = tournament.pool_set.all()[0]\n+            self.assertIs(tournament, pool.tournament)\n+\n+    def test_foreign_key_prefetch_related(self):\n+        with self.assertNumQueries(2):\n+            tournament = (Tournament.objects.prefetch_related('pool_set').get(pk=1))\n+            pool = tournament.pool_set.all()[0]\n+            self.assertIs(tournament, pool.tournament)\n+\n+    def test_foreign_key_multiple_prefetch(self):\n+        with self.assertNumQueries(2):\n+            tournaments = list(Tournament.objects.prefetch_related('pool_set'))\n+            pool1 = tournaments[0].pool_set.all()[0]\n+            self.assertIs(tournaments[0], pool1.tournament)\n+            pool2 = tournaments[1].pool_set.all()[0]\n+            self.assertIs(tournaments[1], pool2.tournament)\n+\n+    def test_one_to_one(self):\n+        with self.assertNumQueries(2):\n+            style = PoolStyle.objects.get(pk=1)\n+            pool = style.pool\n+            self.assertIs(style, pool.poolstyle)\n+\n+    def test_one_to_one_select_related(self):\n+        with self.assertNumQueries(1):\n+            style = PoolStyle.objects.select_related('pool').get(pk=1)\n+            pool = style.pool\n+            self.assertIs(style, pool.poolstyle)\n+\n+    def test_one_to_one_multi_select_related(self):\n+        with self.assertNumQueries(1):\n+            poolstyles = list(PoolStyle.objects.select_related('pool'))\n+            self.assertIs(poolstyles[0], poolstyles[0].pool.poolstyle)\n+            self.assertIs(poolstyles[1], poolstyles[1].pool.poolstyle)\n+\n+    def test_one_to_one_prefetch_related(self):\n+        with self.assertNumQueries(2):\n+            style = PoolStyle.objects.prefetch_related('pool').get(pk=1)\n+            pool = style.pool\n+            self.assertIs(style, pool.poolstyle)\n+\n+    def test_one_to_one_multi_prefetch_related(self):\n+        with self.assertNumQueries(2):\n+            poolstyles = list(PoolStyle.objects.prefetch_related('pool'))\n+            self.assertIs(poolstyles[0], poolstyles[0].pool.poolstyle)\n+            self.assertIs(poolstyles[1], poolstyles[1].pool.poolstyle)\n+\n+    def test_reverse_one_to_one(self):\n+        with self.assertNumQueries(2):\n+            pool = Pool.objects.get(pk=2)\n+            style = pool.poolstyle\n+            self.assertIs(pool, style.pool)\n+\n+    def test_reverse_one_to_one_select_related(self):\n+        with self.assertNumQueries(1):\n+            pool = Pool.objects.select_related('poolstyle').get(pk=2)\n+            style = pool.poolstyle\n+            self.assertIs(pool, style.pool)\n+\n+    def test_reverse_one_to_one_prefetch_related(self):\n+        with self.assertNumQueries(2):\n+            pool = Pool.objects.prefetch_related('poolstyle').get(pk=2)\n+            style = pool.poolstyle\n+            self.assertIs(pool, style.pool)\n+\n+    def test_reverse_one_to_one_multi_select_related(self):\n+        with self.assertNumQueries(1):\n+            pools = list(Pool.objects.select_related('poolstyle'))\n+            self.assertIs(pools[1], pools[1].poolstyle.pool)\n+            self.assertIs(pools[2], pools[2].poolstyle.pool)\n+\n+    def test_reverse_one_to_one_multi_prefetch_related(self):\n+        with self.assertNumQueries(2):\n+            pools = list(Pool.objects.prefetch_related('poolstyle'))\n+            self.assertIs(pools[1], pools[1].poolstyle.pool)\n+            self.assertIs(pools[2], pools[2].poolstyle.pool)"
        }
    ],
    "stats": {
        "total": 274,
        "additions": 243,
        "deletions": 31
    }
}