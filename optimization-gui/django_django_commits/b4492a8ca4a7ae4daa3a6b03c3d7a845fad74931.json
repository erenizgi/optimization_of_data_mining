{
    "author": "akaariai",
    "message": "Fixed #19837 -- Refactored split_exclude() join generation\n\nThe refactoring mainly concentrates on making sure the inner and outer\nquery agree about the split position. The split position is where the\nmultijoin happens, and thus the split position also determines the\ncolumns used in the \"WHERE col1 IN (SELECT col2 from ...)\" condition.\n\nThis commit fixes a regression caused by #10790 and commit\n69597e5bcc89aadafd1b76abf7efab30ee0b8b1a. The regression was caused\nby wrong cols in the split position.",
    "sha": "b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931",
    "files": [
        {
            "sha": "4bc9e6ed3401e6727abc22eff431888587c1e577",
            "filename": "django/db/models/sql/datastructures.py",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931/django%2Fdb%2Fmodels%2Fsql%2Fdatastructures.py",
            "raw_url": "https://github.com/django/django/raw/b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931/django%2Fdb%2Fmodels%2Fsql%2Fdatastructures.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fdatastructures.py?ref=b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931",
            "patch": "@@ -12,8 +12,10 @@ class MultiJoin(Exception):\n     multi-valued join was attempted (if the caller wants to treat that\n     exceptionally).\n     \"\"\"\n-    def __init__(self, level):\n-        self.level = level\n+    def __init__(self, names_pos, path_with_names):\n+        self.level = names_pos\n+        # The path travelled, this includes the path to the multijoin.\n+        self.names_with_path = path_with_names\n \n class Empty(object):\n     pass"
        },
        {
            "sha": "422029c5e01e7bb5062bcc41c6b03e6de573c6a4",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 67,
            "deletions": 74,
            "changes": 141,
            "blob_url": "https://github.com/django/django/blob/b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931",
            "patch": "@@ -1200,7 +1200,7 @@ def add_filter(self, filter_expr, connector=AND, negate=False,\n                 can_reuse.update(join_list)\n         except MultiJoin as e:\n             self.split_exclude(filter_expr, LOOKUP_SEP.join(parts[:e.level]),\n-                    can_reuse)\n+                               can_reuse, e.names_with_path)\n             return\n \n         if (lookup_type == 'isnull' and value is True and not negate and\n@@ -1324,7 +1324,7 @@ def names_to_path(self, names, opts, allow_many=False,\n         (the last used join field), and target (which is a field guaranteed to\n         contain the same value as the final field).\n         \"\"\"\n-        path = []\n+        path, names_with_path = [], []\n         for pos, name in enumerate(names):\n             if name == 'pk':\n                 name = opts.pk.name\n@@ -1361,16 +1361,17 @@ def names_to_path(self, names, opts, allow_many=False,\n                                              opts, final_field, False, True))\n             if hasattr(field, 'get_path_info'):\n                 pathinfos, opts, target, final_field = field.get_path_info()\n+                if not allow_many:\n+                    for inner_pos, p in enumerate(pathinfos):\n+                        if p.m2m:\n+                            names_with_path.append((name, pathinfos[0:inner_pos + 1]))\n+                            raise MultiJoin(pos + 1, names_with_path)\n                 path.extend(pathinfos)\n+                names_with_path.append((name, pathinfos))\n             else:\n                 # Local non-relational field.\n                 final_field = target = field\n                 break\n-        multijoin_pos = None\n-        for m2mpos, pathinfo in enumerate(path):\n-            if pathinfo.m2m:\n-                multijoin_pos = m2mpos\n-                break\n \n         if pos != len(names) - 1:\n             if pos == len(names) - 2:\n@@ -1379,8 +1380,6 @@ def names_to_path(self, names, opts, allow_many=False,\n                     \"the lookup type?\" % (name, names[pos + 1]))\n             else:\n                 raise FieldError(\"Join on field %r not permitted.\" % name)\n-        if multijoin_pos is not None and len(path) >= multijoin_pos and not allow_many:\n-            raise MultiJoin(multijoin_pos + 1)\n         return path, final_field, target\n \n     def setup_joins(self, names, opts, alias, can_reuse=None, allow_many=True,\n@@ -1454,64 +1453,67 @@ def trim_joins(self, target, joins, path):\n                 break\n         return target.column, joins[-1], joins\n \n-    def split_exclude(self, filter_expr, prefix, can_reuse):\n+    def split_exclude(self, filter_expr, prefix, can_reuse, names_with_path):\n         \"\"\"\n         When doing an exclude against any kind of N-to-many relation, we need\n         to use a subquery. This method constructs the nested query, given the\n         original exclude filter (filter_expr) and the portion up to the first\n         N-to-many relation field.\n \n         As an example we could have original filter ~Q(child__name='foo').\n-        We would get here with filter_expr = child_name, prefix = child and\n-        can_reuse is a set of joins we can reuse for filtering in the original\n-        query.\n+        We would get here with filter_expr = child__name, prefix = child and\n+        can_reuse is a set of joins usable for filters in the original query.\n \n-        We will turn this into\n+        We will turn this into equivalent of:\n             WHERE pk NOT IN (SELECT parent_id FROM thetable\n                              WHERE name = 'foo' AND parent_id IS NOT NULL)\n \n         It might be worth it to consider using WHERE NOT EXISTS as that has\n         saner null handling, and is easier for the backend's optimizer to\n         handle.\n         \"\"\"\n+        # Generate the inner query.\n         query = Query(self.model)\n         query.add_filter(filter_expr)\n         query.bump_prefix()\n         query.clear_ordering(True)\n-        query.set_start(prefix)\n-        # Adding extra check to make sure the selected field will not be null\n+        # Try to have as simple as possible subquery -> trim leading joins from\n+        # the subquery.\n+        trimmed_joins = query.trim_start(names_with_path)\n+        # Add extra check to make sure the selected field will not be null\n         # since we are adding a IN <subquery> clause. This prevents the\n         # database from tripping over IN (...,NULL,...) selects and returning\n         # nothing\n         alias, col = query.select[0].col\n         query.where.add((Constraint(alias, col, None), 'isnull', False), AND)\n-        # We need to trim the last part from the prefix.\n-        trimmed_prefix = LOOKUP_SEP.join(prefix.split(LOOKUP_SEP)[0:-1])\n-        if not trimmed_prefix:\n-            rel, _, direct, m2m = self.model._meta.get_field_by_name(prefix)\n-            if not m2m:\n-                trimmed_prefix = rel.field.rel.field_name\n-            else:\n-                if direct:\n-                    trimmed_prefix = rel.m2m_target_field_name()\n-                else:\n-                    trimmed_prefix = rel.field.m2m_reverse_target_field_name()\n \n+        # Still make sure that the trimmed parts in the inner query and\n+        # trimmed prefix are in sync. So, use the trimmed_joins to make sure\n+        # as many path elements are in the prefix as there were trimmed joins.\n+        # In addition, convert the path elements back to names so that\n+        # add_filter() can handle them.\n+        trimmed_prefix = []\n+        paths_in_prefix = trimmed_joins\n+        for name, path in names_with_path:\n+            if paths_in_prefix - len(path) > 0:\n+                trimmed_prefix.append(name)\n+                paths_in_prefix -= len(path)\n+            else:\n+                trimmed_prefix.append(\n+                    path[paths_in_prefix - len(path)].from_field.name)\n+                break\n+        trimmed_prefix = LOOKUP_SEP.join(trimmed_prefix)\n         self.add_filter(('%s__in' % trimmed_prefix, query), negate=True,\n-                can_reuse=can_reuse)\n-\n-        # If there's more than one join in the inner query (before any initial\n-        # bits were trimmed -- which means the last active table is more than\n-        # two places into the alias list), we need to also handle the\n-        # possibility that the earlier joins don't match anything by adding a\n-        # comparison to NULL (e.g. in\n-        # Tag.objects.exclude(parent__parent__name='t1'), a tag with no parent\n-        # would otherwise be overlooked).\n-        active_positions = len([count for count\n-                                in query.alias_refcount.items() if count])\n-        if active_positions > 1:\n+                        can_reuse=can_reuse)\n+\n+        # If there's more than one join in the inner query, we need to also\n+        # handle the possibility that the earlier joins don't match anything\n+        # by adding a comparison to NULL (e.g. in\n+        #     Tag.objects.exclude(parent__parent__name='t1')\n+        # a tag with no parent would otherwise be overlooked).\n+        if trimmed_joins > 1:\n             self.add_filter(('%s__isnull' % trimmed_prefix, False), negate=True,\n-                    can_reuse=can_reuse)\n+                            can_reuse=can_reuse)\n \n     def set_empty(self):\n         self.where = EmptyWhere()\n@@ -1869,42 +1871,33 @@ def _extra_select(self):\n             return self.extra\n     extra_select = property(_extra_select)\n \n-    def set_start(self, start):\n-        \"\"\"\n-        Sets the table from which to start joining. The start position is\n-        specified by the related attribute from the base model. This will\n-        automatically set to the select column to be the column linked from the\n-        previous table.\n-\n-        This method is primarily for internal use and the error checking isn't\n-        as friendly as add_filter(). Mostly useful for querying directly\n-        against the join table of many-to-many relation in a subquery.\n-        \"\"\"\n-        opts = self.model._meta\n-        alias = self.get_initial_alias()\n-        field, col, opts, joins, extra = self.setup_joins(\n-                start.split(LOOKUP_SEP), opts, alias)\n-        select_col = self.alias_map[joins[1]].lhs_join_col\n-        select_alias = alias\n-\n-        # The call to setup_joins added an extra reference to everything in\n-        # joins. Reverse that.\n-        for alias in joins:\n-            self.unref_alias(alias)\n-\n-        # We might be able to trim some joins from the front of this query,\n-        # providing that we only traverse \"always equal\" connections (i.e. rhs\n-        # is *always* the same value as lhs).\n-        for alias in joins[1:]:\n-            join_info = self.alias_map[alias]\n-            if (join_info.lhs_join_col != select_col\n-                    or join_info.join_type != self.INNER):\n-                break\n-            self.unref_alias(select_alias)\n-            select_alias = join_info.rhs_alias\n-            select_col = join_info.rhs_join_col\n+    def trim_start(self, names_with_path):\n+        \"\"\"\n+        Trims joins from the start of the join path. The candidates for trim\n+        are the PathInfos in names_with_path structure. Outer joins are not\n+        eligible for removal. Also sets the select column so the start\n+        matches the join.\n+\n+        This method is mostly useful for generating the subquery joins & col\n+        in \"WHERE somecol IN (subquery)\". This construct is needed by\n+        split_exclude().\n+        _\"\"\"\n+        join_pos = 0\n+        for _, paths in names_with_path:\n+            for path in paths:\n+                peek = self.tables[join_pos + 1]\n+                if self.alias_map[peek].join_type == self.LOUTER:\n+                    # Back up one level and break\n+                    select_alias = self.tables[join_pos]\n+                    select_col = path.from_field.column\n+                    break\n+                select_alias = self.tables[join_pos + 1]\n+                select_col = path.to_field.column\n+                self.unref_alias(self.tables[join_pos])\n+                join_pos += 1\n         self.select = [SelectInfo((select_alias, select_col), None)]\n         self.remove_inherited_models()\n+        return join_pos\n \n     def is_nullable(self, field):\n         \"\"\""
        },
        {
            "sha": "91edf71aeb2a6ade6f7e988c7e7af144d175d784",
            "filename": "tests/regressiontests/queries/models.py",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931/tests%2Fregressiontests%2Fqueries%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931/tests%2Fregressiontests%2Fqueries%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Fmodels.py?ref=b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931",
            "patch": "@@ -439,3 +439,17 @@ class BaseA(models.Model):\n     a = models.ForeignKey(FK1, null=True)\n     b = models.ForeignKey(FK2, null=True)\n     c = models.ForeignKey(FK3, null=True)\n+\n+@python_2_unicode_compatible\n+class Identifier(models.Model):\n+    name = models.CharField(max_length=100)\n+\n+    def __str__(self):\n+        return self.name\n+\n+class Program(models.Model):\n+    identifier = models.OneToOneField(Identifier)\n+\n+class Channel(models.Model):\n+    programs = models.ManyToManyField(Program)\n+    identifier = models.OneToOneField(Identifier)"
        },
        {
            "sha": "34bfea0b944f42929e5a90864d3f63278b00c445",
            "filename": "tests/regressiontests/queries/tests.py",
            "status": "modified",
            "additions": 20,
            "deletions": 1,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Ftests.py?ref=b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931",
            "patch": "@@ -24,7 +24,7 @@\n     Node, ObjectA, ObjectB, ObjectC, CategoryItem, SimpleCategory,\n     SpecialCategory, OneToOneCategory, NullableName, ProxyCategory,\n     SingleObject, RelatedObject, ModelA, ModelD, Responsibility, Job,\n-    JobResponsibilities, BaseA)\n+    JobResponsibilities, BaseA, Identifier, Program, Channel)\n \n \n class BaseQuerysetTest(TestCase):\n@@ -2612,3 +2612,22 @@ def test_disjunction_promotion_fexpression(self):\n         qs = BaseA.objects.filter(Q(a__f1=F('c__f1')) | (Q(pk=1) & Q(pk=2)))\n         self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 2)\n         self.assertEqual(str(qs.query).count('INNER JOIN'), 0)\n+\n+\n+class ManyToManyExcludeTest(TestCase):\n+    def test_exclude_many_to_many(self):\n+        Identifier.objects.create(name='extra')\n+        program = Program.objects.create(identifier=Identifier.objects.create(name='program'))\n+        channel = Channel.objects.create(identifier=Identifier.objects.create(name='channel'))\n+        channel.programs.add(program)\n+\n+        # channel contains 'program1', so all Identifiers except that one\n+        # should be returned\n+        self.assertQuerysetEqual(\n+            Identifier.objects.exclude(program__channel=channel).order_by('name'),\n+            ['<Identifier: channel>', '<Identifier: extra>']\n+        )\n+        self.assertQuerysetEqual(\n+            Identifier.objects.exclude(program__channel=None).order_by('name'),\n+            ['<Identifier: program>']\n+        )"
        },
        {
            "sha": "4e812b2c237fdbed71ac9372527c2516039744c9",
            "filename": "tests/tmp.txt",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931/tests%2Ftmp.txt",
            "raw_url": "https://github.com/django/django/raw/b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931/tests%2Ftmp.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftmp.txt?ref=b4492a8ca4a7ae4daa3a6b03c3d7a845fad74931",
            "patch": "@@ -0,0 +1 @@\n+SELECT \"queries_tag\".\"id\", \"queries_tag\".\"name\", \"queries_tag\".\"parent_id\", \"queries_tag\".\"category_id\" FROM \"queries_tag\" WHERE NOT ((\"queries_tag\".\"id\" IN (SELECT U0.\"id\" FROM \"queries_tag\" U0 LEFT OUTER JOIN \"queries_tag\" U1 ON (U0.\"id\" = U1.\"parent_id\") WHERE (U1.\"id\" IS NULL AND U0.\"id\" IS NOT NULL)) AND \"queries_tag\".\"id\" IS NOT NULL)) ORDER BY \"queries_tag\".\"name\" ASC"
        }
    ],
    "stats": {
        "total": 183,
        "additions": 106,
        "deletions": 77
    }
}