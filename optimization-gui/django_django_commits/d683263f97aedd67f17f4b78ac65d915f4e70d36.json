{
    "author": "andrewgodwin",
    "message": "Added SQLite backend which passes all current tests",
    "sha": "d683263f97aedd67f17f4b78ac65d915f4e70d36",
    "files": [
        {
            "sha": "39883de35ca08ac2ce8e947dd470983efccd532f",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/d683263f97aedd67f17f4b78ac65d915f4e70d36/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/d683263f97aedd67f17f4b78ac65d915f4e70d36/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=d683263f97aedd67f17f4b78ac65d915f4e70d36",
            "patch": "@@ -432,6 +432,9 @@ class BaseDatabaseFeatures(object):\n     # What's the maximum length for index names?\n     max_index_name_length = 63\n \n+    # Does it support foreign keys?\n+    supports_foreign_keys = True\n+\n     def __init__(self, connection):\n         self.connection = connection\n "
        },
        {
            "sha": "a9601221bb21650e848b6db375c6b679ea73a80e",
            "filename": "django/db/backends/schema.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/d683263f97aedd67f17f4b78ac65d915f4e70d36/django%2Fdb%2Fbackends%2Fschema.py",
            "raw_url": "https://github.com/django/django/raw/d683263f97aedd67f17f4b78ac65d915f4e70d36/django%2Fdb%2Fbackends%2Fschema.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fschema.py?ref=d683263f97aedd67f17f4b78ac65d915f4e70d36",
            "patch": "@@ -187,7 +187,7 @@ def create_model(self, model):\n                     }\n                 )\n             # FK\n-            if field.rel:\n+            if field.rel and self.connection.features.supports_foreign_keys:\n                 to_table = field.rel.to._meta.db_table\n                 to_column = field.rel.to._meta.get_field(field.rel.field_name).column\n                 self.deferred_sql.append(\n@@ -311,7 +311,7 @@ def create_field(self, model, field, keep_default=False):\n                 }\n             }\n         # Add any FK constraints later\n-        if field.rel:\n+        if field.rel and self.connection.features.supports_foreign_keys:\n             to_table = field.rel.to._meta.db_table\n             to_column = field.rel.to._meta.get_field(field.rel.field_name).column\n             self.deferred_sql.append("
        },
        {
            "sha": "45e7264e5c4255f9486f77b1e6c7d4e0075b1e8a",
            "filename": "django/db/backends/sqlite3/base.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/d683263f97aedd67f17f4b78ac65d915f4e70d36/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/d683263f97aedd67f17f4b78ac65d915f4e70d36/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py?ref=d683263f97aedd67f17f4b78ac65d915f4e70d36",
            "patch": "@@ -96,6 +96,7 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     supports_mixed_date_datetime_comparisons = False\n     has_bulk_insert = True\n     can_combine_inserts_with_and_without_auto_increment_pk = False\n+    supports_foreign_keys = False\n \n     @cached_property\n     def supports_stddev(self):"
        },
        {
            "sha": "62c53e075aecc46e1f7b1cb1d177670cc6c76a99",
            "filename": "django/db/backends/sqlite3/introspection.py",
            "status": "modified",
            "additions": 35,
            "deletions": 1,
            "changes": 36,
            "blob_url": "https://github.com/django/django/blob/d683263f97aedd67f17f4b78ac65d915f4e70d36/django%2Fdb%2Fbackends%2Fsqlite3%2Fintrospection.py",
            "raw_url": "https://github.com/django/django/raw/d683263f97aedd67f17f4b78ac65d915f4e70d36/django%2Fdb%2Fbackends%2Fsqlite3%2Fintrospection.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fintrospection.py?ref=d683263f97aedd67f17f4b78ac65d915f4e70d36",
            "patch": "@@ -154,7 +154,7 @@ def get_indexes(self, cursor, table_name):\n             if len(info) != 1:\n                 continue\n             name = info[0][2] # seqno, cid, name\n-            indexes[name] = {'primary_key': False,\n+            indexes[name] = {'primary_key': indexes.get(name, {}).get(\"primary_key\", False),\n                              'unique': unique}\n         return indexes\n \n@@ -182,3 +182,37 @@ def _table_info(self, cursor, name):\n                  'null_ok': not field[3],\n                  'pk': field[5]     # undocumented\n                  } for field in cursor.fetchall()]\n+\n+    def get_constraints(self, cursor, table_name):\n+        \"\"\"\n+        Retrieves any constraints or keys (unique, pk, fk, check, index) across one or more columns.\n+        \"\"\"\n+        constraints = {}\n+        # Get the index info\n+        cursor.execute(\"PRAGMA index_list(%s)\" % self.connection.ops.quote_name(table_name))\n+        for number, index, unique in cursor.fetchall():\n+            # Get the index info for that index\n+            cursor.execute('PRAGMA index_info(%s)' % self.connection.ops.quote_name(index))\n+            for index_rank, column_rank, column in cursor.fetchall():\n+                if index not in constraints:\n+                    constraints[index] = {\n+                        \"columns\": set(),\n+                        \"primary_key\": False,\n+                        \"unique\": bool(unique),\n+                        \"foreign_key\": False,\n+                        \"check\": False,\n+                        \"index\": True,\n+                    }\n+                constraints[index]['columns'].add(column)\n+        # Get the PK\n+        pk_column = self.get_primary_key_column(cursor, table_name)\n+        if pk_column:\n+            constraints[\"__primary__\"] = {\n+                \"columns\": set([pk_column]),\n+                \"primary_key\": True,\n+                \"unique\": False,  # It's not actually a unique constraint\n+                \"foreign_key\": False,\n+                \"check\": False,\n+                \"index\": False,\n+            }\n+        return constraints"
        },
        {
            "sha": "7938ad79cfd3ad9543b1d77bd370a7784673500f",
            "filename": "django/db/backends/sqlite3/schema.py",
            "status": "modified",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/django/django/blob/d683263f97aedd67f17f4b78ac65d915f4e70d36/django%2Fdb%2Fbackends%2Fsqlite3%2Fschema.py",
            "raw_url": "https://github.com/django/django/raw/d683263f97aedd67f17f4b78ac65d915f4e70d36/django%2Fdb%2Fbackends%2Fsqlite3%2Fschema.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fschema.py?ref=d683263f97aedd67f17f4b78ac65d915f4e70d36",
            "patch": "@@ -1,6 +1,116 @@\n from django.db.backends.schema import BaseDatabaseSchemaEditor\n+from django.db.models.loading import cache\n+from django.db.models.fields.related import ManyToManyField\n \n \n class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n \n     sql_delete_table = \"DROP TABLE %(table)s\"\n+\n+    def _remake_table(self, model, create_fields=[], delete_fields=[], alter_fields=[], rename_fields=[], override_uniques=None):\n+        \"Shortcut to transform a model from old_model into new_model\"\n+        # Work out the new fields dict / mapping\n+        body = dict((f.name, f) for f in model._meta.local_fields)\n+        mapping = dict((f.column, f.column) for f in model._meta.local_fields)\n+        # If any of the new or altered fields is introducing a new PK,\n+        # remove the old one\n+        restore_pk_field = None\n+        if any(f.primary_key for f in create_fields) or any(n.primary_key for o, n in alter_fields):\n+            for name, field in list(body.items()):\n+                if field.primary_key:\n+                    field.primary_key = False\n+                    restore_pk_field = field\n+                    if field.auto_created:\n+                        del body[name]\n+                        del mapping[field.column]\n+        # Add in any created fields\n+        for field in create_fields:\n+            body[field.name] = field\n+        # Add in any altered fields\n+        for (old_field, new_field) in alter_fields:\n+            del body[old_field.name]\n+            del mapping[old_field.column]\n+            body[new_field.name] = new_field\n+            mapping[new_field.column] = old_field.column\n+        # Remove any deleted fields\n+        for field in delete_fields:\n+            del body[field.name]\n+            del mapping[field.column]\n+        # Construct a new model for the new state\n+        meta_contents = {\n+            'app_label': model._meta.app_label,\n+            'db_table': model._meta.db_table + \"__new\",\n+            'unique_together': model._meta.unique_together if override_uniques is None else override_uniques,\n+        }\n+        meta = type(\"Meta\", tuple(), meta_contents)\n+        body['Meta'] = meta\n+        body['__module__'] = \"__fake__\"\n+        with cache.temporary_state():\n+            del cache.app_models[model._meta.app_label][model._meta.object_name.lower()]\n+            temp_model = type(model._meta.object_name, model.__bases__, body)\n+        # Create a new table with that format\n+        self.create_model(temp_model)\n+        # Copy data from the old table\n+        field_maps = list(mapping.items())\n+        self.execute(\"INSERT INTO %s (%s) SELECT %s FROM %s;\" % (\n+            self.quote_name(temp_model._meta.db_table),\n+            ', '.join([x for x, y in field_maps]),\n+            ', '.join([y for x, y in field_maps]),\n+            self.quote_name(model._meta.db_table),\n+        ))\n+        # Delete the old table\n+        self.delete_model(model)\n+        # Rename the new to the old\n+        self.alter_db_table(model, temp_model._meta.db_table, model._meta.db_table)\n+        # Run deferred SQL on correct table\n+        for sql in self.deferred_sql:\n+            self.execute(sql.replace(temp_model._meta.db_table, model._meta.db_table))\n+        self.deferred_sql = []\n+        # Fix any PK-removed field\n+        if restore_pk_field:\n+            restore_pk_field.primary_key = True\n+\n+    def create_field(self, model, field):\n+        \"\"\"\n+        Creates a field on a model.\n+        Usually involves adding a column, but may involve adding a\n+        table instead (for M2M fields)\n+        \"\"\"\n+        # Special-case implicit M2M tables\n+        if isinstance(field, ManyToManyField) and field.rel.through._meta.auto_created:\n+            return self.create_model(field.rel.through)\n+        # Detect bad field combinations\n+        if (not field.null and\n+           (not field.has_default() or field.get_default() is None) and\n+           not field.empty_strings_allowed):\n+            raise ValueError(\"You cannot add a null=False column without a default value on SQLite.\")\n+        self._remake_table(model, create_fields=[field])\n+\n+    def delete_field(self, model, field):\n+        \"\"\"\n+        Removes a field from a model. Usually involves deleting a column,\n+        but for M2Ms may involve deleting a table.\n+        \"\"\"\n+        # Special-case implicit M2M tables\n+        if isinstance(field, ManyToManyField) and field.rel.through._meta.auto_created:\n+            return self.delete_model(field.rel.through)\n+        # For everything else, remake.\n+        self._remake_table(model, delete_fields=[field])\n+\n+    def alter_field(self, model, old_field, new_field, strict=False):\n+        # Ensure this field is even column-based\n+        old_type = old_field.db_type(connection=self.connection)\n+        new_type = self._type_for_alter(new_field)\n+        if old_type is None and new_type is None:\n+            # TODO: Handle M2M fields being repointed\n+            return\n+        elif old_type is None or new_type is None:\n+            raise ValueError(\"Cannot alter field %s into %s - they are not compatible types\" % (\n+                    old_field,\n+                    new_field,\n+                ))\n+        # Alter by remaking table\n+        self._remake_table(model, alter_fields=[(old_field, new_field)])\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        self._remake_table(model, override_uniques=new_unique_together)"
        },
        {
            "sha": "e0d943853b4c686fb57fabad924eb6f8bf2841ca",
            "filename": "django/db/models/loading.py",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/d683263f97aedd67f17f4b78ac65d915f4e70d36/django%2Fdb%2Fmodels%2Floading.py",
            "raw_url": "https://github.com/django/django/raw/d683263f97aedd67f17f4b78ac65d915f4e70d36/django%2Fdb%2Fmodels%2Floading.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Floading.py?ref=d683263f97aedd67f17f4b78ac65d915f4e70d36",
            "patch": "@@ -265,6 +265,10 @@ def restore_state(self, state):\n         self.app_models = state['app_models']\n         self.app_errors = state['app_errors']\n \n+    def temporary_state(self):\n+        \"Returns a context manager that restores the state on exit\"\n+        return StateContextManager(self)\n+\n     def unregister_all(self):\n         \"\"\"\n         Wipes the AppCache clean of all registered models.\n@@ -275,6 +279,23 @@ def unregister_all(self):\n         self.app_models = SortedDict()\n         self.app_errors = {}\n \n+\n+class StateContextManager(object):\n+    \"\"\"\n+    Context manager for locking cache state.\n+    Useful for making temporary models you don't want to stay in the cache.\n+    \"\"\"\n+\n+    def __init__(self, cache):\n+        self.cache = cache\n+\n+    def __enter__(self):\n+        self.state = self.cache.save_state()\n+\n+    def __exit__(self, type, value, traceback):\n+        self.cache.restore_state(self.state)\n+\n+\n cache = AppCache()\n \n # These methods were always module level, so are kept that way for backwards"
        },
        {
            "sha": "b18d2a9c166389956578b1d3bb697fddbac8c7bc",
            "filename": "tests/modeltests/schema/models.py",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/d683263f97aedd67f17f4b78ac65d915f4e70d36/tests%2Fmodeltests%2Fschema%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/d683263f97aedd67f17f4b78ac65d915f4e70d36/tests%2Fmodeltests%2Fschema%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fschema%2Fmodels.py?ref=d683263f97aedd67f17f4b78ac65d915f4e70d36",
            "patch": "@@ -29,6 +29,17 @@ class Meta:\n         managed = False\n \n \n+class BookWithSlug(models.Model):\n+    author = models.ForeignKey(Author)\n+    title = models.CharField(max_length=100, db_index=True)\n+    pub_date = models.DateTimeField()\n+    slug = models.CharField(max_length=20, unique=True)\n+\n+    class Meta:\n+        managed = False\n+        db_table = \"schema_book\"\n+\n+\n class Tag(models.Model):\n     title = models.CharField(max_length=255)\n     slug = models.SlugField(unique=True)"
        },
        {
            "sha": "c76ca8ca169662257ab04c29e12fa376f42bea64",
            "filename": "tests/modeltests/schema/tests.py",
            "status": "modified",
            "additions": 16,
            "deletions": 8,
            "changes": 24,
            "blob_url": "https://github.com/django/django/blob/d683263f97aedd67f17f4b78ac65d915f4e70d36/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/d683263f97aedd67f17f4b78ac65d915f4e70d36/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fschema%2Ftests.py?ref=d683263f97aedd67f17f4b78ac65d915f4e70d36",
            "patch": "@@ -2,11 +2,12 @@\n import copy\n import datetime\n from django.test import TestCase\n+from django.utils.unittest import skipUnless\n from django.db import connection, DatabaseError, IntegrityError\n from django.db.models.fields import IntegerField, TextField, CharField, SlugField\n from django.db.models.fields.related import ManyToManyField\n from django.db.models.loading import cache\n-from .models import Author, Book, AuthorWithM2M, Tag, TagUniqueRename, UniqueTest\n+from .models import Author, Book, BookWithSlug, AuthorWithM2M, Tag, TagUniqueRename, UniqueTest\n \n \n class SchemaTests(TestCase):\n@@ -18,7 +19,7 @@ class SchemaTests(TestCase):\n     as the code it is testing.\n     \"\"\"\n \n-    models = [Author, Book, AuthorWithM2M, Tag, UniqueTest]\n+    models = [Author, Book, BookWithSlug, AuthorWithM2M, Tag, TagUniqueRename, UniqueTest]\n \n     # Utility functions\n \n@@ -70,13 +71,21 @@ def tearDown(self):\n \n     def column_classes(self, model):\n         cursor = connection.cursor()\n-        return dict(\n+        columns = dict(\n             (d[0], (connection.introspection.get_field_type(d[1], d), d))\n             for d in connection.introspection.get_table_description(\n                 cursor,\n                 model._meta.db_table,\n             )\n         )\n+        # SQLite has a different format for field_type\n+        for name, (type, desc) in columns.items():\n+            if isinstance(type, tuple):\n+                columns[name] = (type[0], desc)\n+        # SQLite also doesn't error properly\n+        if not columns:\n+            raise DatabaseError(\"Table does not exist (empty pragma)\")\n+        return columns\n \n     # Tests\n \n@@ -104,6 +113,7 @@ def test_creation_deletion(self):\n             lambda: list(Author.objects.all()),\n         )\n \n+    @skipUnless(connection.features.supports_foreign_keys, \"No FK support\")\n     def test_creation_fk(self):\n         \"Tests that creating tables out of FK order works\"\n         # Create the table\n@@ -449,13 +459,11 @@ def test_indexes(self):\n             connection.introspection.get_indexes(connection.cursor(), Book._meta.db_table),\n         )\n         # Add a unique column, verify that creates an implicit index\n-        new_field = CharField(max_length=20, unique=True)\n-        new_field.set_attributes_from_name(\"slug\")\n         editor = connection.schema_editor()\n         editor.start()\n         editor.create_field(\n             Book,\n-            new_field,\n+            BookWithSlug._meta.get_field_by_name(\"slug\")[0],\n         )\n         editor.commit()\n         self.assertIn(\n@@ -468,8 +476,8 @@ def test_indexes(self):\n         editor = connection.schema_editor()\n         editor.start()\n         editor.alter_field(\n-            Book,\n-            new_field,\n+            BookWithSlug,\n+            BookWithSlug._meta.get_field_by_name(\"slug\")[0],\n             new_field2,\n             strict = True,\n         )"
        }
    ],
    "stats": {
        "total": 210,
        "additions": 199,
        "deletions": 11
    }
}