{
    "author": "aaugustin",
    "message": "Reordered methods in database wrappers.\n\n* Grouped related methods together -- with banner comments :/\n* Described which methods are intended to be implemented in backends.\n* Added docstrings.\n* Used the same order in all wrappers.",
    "sha": "d63e55039d42c2ba8bb6c8f8d133ede085b60969",
    "files": [
        {
            "sha": "fe26c98baf9bf0607f2ccfe04a2a38db5a52bece",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 170,
            "deletions": 115,
            "changes": 285,
            "blob_url": "https://github.com/django/django/blob/d63e55039d42c2ba8bb6c8f8d133ede085b60969/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/d63e55039d42c2ba8bb6c8f8d133ede085b60969/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=d63e55039d42c2ba8bb6c8f8d133ede085b60969",
            "patch": "@@ -40,20 +40,24 @@ def __init__(self, settings_dict, alias=DEFAULT_DB_ALIAS,\n         self.alias = alias\n         self.use_debug_cursor = None\n \n-        # Transaction related attributes\n-        self.transaction_state = []\n+        # Savepoint management related attributes\n         self.savepoint_state = 0\n+\n+        # Transaction management related attributes\n+        self.transaction_state = []\n         # Tracks if the connection is believed to be in transaction. This is\n         # set somewhat aggressively, as the DBAPI doesn't make it easy to\n         # deduce if the connection is in transaction or not.\n         self._dirty = False\n-        self._thread_ident = thread.get_ident()\n-        self.allow_thread_sharing = allow_thread_sharing\n \n         # Connection termination related attributes\n         self.close_at = None\n         self.errors_occurred = False\n \n+        # Thread-safety related attributes\n+        self.allow_thread_sharing = allow_thread_sharing\n+        self._thread_ident = thread.get_ident()\n+\n     def __eq__(self, other):\n         return self.alias == other.alias\n \n@@ -63,21 +67,26 @@ def __ne__(self, other):\n     def __hash__(self):\n         return hash(self.alias)\n \n-    def wrap_database_errors(self):\n-        return DatabaseErrorWrapper(self)\n+    ##### Backend-specific methods for creating connections and cursors #####\n \n     def get_connection_params(self):\n+        \"\"\"Returns a dict of parameters suitable for get_new_connection.\"\"\"\n         raise NotImplementedError\n \n     def get_new_connection(self, conn_params):\n+        \"\"\"Opens a connection to the database.\"\"\"\n         raise NotImplementedError\n \n     def init_connection_state(self):\n+        \"\"\"Initializes the database connection settings.\"\"\"\n         raise NotImplementedError\n \n     def create_cursor(self):\n+        \"\"\"Creates a cursor. Assumes that a connection is established.\"\"\"\n         raise NotImplementedError\n \n+    ##### Backend-specific wrappers for PEP-249 connection methods #####\n+\n     def _cursor(self):\n         with self.wrap_database_errors():\n             if self.connection is None:\n@@ -107,20 +116,48 @@ def _close(self):\n             with self.wrap_database_errors():\n                 return self.connection.close()\n \n-    def _enter_transaction_management(self, managed):\n+    ##### Generic wrappers for PEP-249 connection methods #####\n+\n+    def cursor(self):\n         \"\"\"\n-        A hook for backend-specific changes required when entering manual\n-        transaction handling.\n+        Creates a cursor, opening a connection if necessary.\n         \"\"\"\n-        pass\n+        self.validate_thread_sharing()\n+        if (self.use_debug_cursor or\n+            (self.use_debug_cursor is None and settings.DEBUG)):\n+            cursor = self.make_debug_cursor(self._cursor())\n+        else:\n+            cursor = util.CursorWrapper(self._cursor(), self)\n+        return cursor\n \n-    def _leave_transaction_management(self, managed):\n+    def commit(self):\n         \"\"\"\n-        A hook for backend-specific changes required when leaving manual\n-        transaction handling. Will usually be implemented only when\n-        _enter_transaction_management() is also required.\n+        Does the commit itself and resets the dirty flag.\n         \"\"\"\n-        pass\n+        self.validate_thread_sharing()\n+        self._commit()\n+        self.set_clean()\n+\n+    def rollback(self):\n+        \"\"\"\n+        Does the rollback itself and resets the dirty flag.\n+        \"\"\"\n+        self.validate_thread_sharing()\n+        self._rollback()\n+        self.set_clean()\n+\n+    def close(self):\n+        \"\"\"\n+        Closes the connection to the database.\n+        \"\"\"\n+        self.validate_thread_sharing()\n+        try:\n+            self._close()\n+        finally:\n+            self.connection = None\n+        self.set_clean()\n+\n+    ##### Backend-specific savepoint management methods #####\n \n     def _savepoint(self, sid):\n         if not self.features.uses_savepoints:\n@@ -137,15 +174,65 @@ def _savepoint_commit(self, sid):\n             return\n         self.cursor().execute(self.ops.savepoint_commit_sql(sid))\n \n-    def abort(self):\n+    ##### Generic savepoint management methods #####\n+\n+    def savepoint(self):\n         \"\"\"\n-        Roll back any ongoing transaction and clean the transaction state\n-        stack.\n+        Creates a savepoint (if supported and required by the backend) inside the\n+        current transaction. Returns an identifier for the savepoint that will be\n+        used for the subsequent rollback or commit.\n         \"\"\"\n-        if self._dirty:\n-            self.rollback()\n-        while self.transaction_state:\n-            self.leave_transaction_management()\n+        thread_ident = thread.get_ident()\n+\n+        self.savepoint_state += 1\n+\n+        tid = str(thread_ident).replace('-', '')\n+        sid = \"s%s_x%d\" % (tid, self.savepoint_state)\n+        self._savepoint(sid)\n+        return sid\n+\n+    def savepoint_rollback(self, sid):\n+        \"\"\"\n+        Rolls back the most recent savepoint (if one exists). Does nothing if\n+        savepoints are not supported.\n+        \"\"\"\n+        self.validate_thread_sharing()\n+        if self.savepoint_state:\n+            self._savepoint_rollback(sid)\n+\n+    def savepoint_commit(self, sid):\n+        \"\"\"\n+        Commits the most recent savepoint (if one exists). Does nothing if\n+        savepoints are not supported.\n+        \"\"\"\n+        self.validate_thread_sharing()\n+        if self.savepoint_state:\n+            self._savepoint_commit(sid)\n+\n+    def clean_savepoints(self):\n+        \"\"\"\n+        Resets the counter used to generate unique savepoint ids in this thread.\n+        \"\"\"\n+        self.savepoint_state = 0\n+\n+    ##### Backend-specific transaction management methods #####\n+\n+    def _enter_transaction_management(self, managed):\n+        \"\"\"\n+        A hook for backend-specific changes required when entering manual\n+        transaction handling.\n+        \"\"\"\n+        pass\n+\n+    def _leave_transaction_management(self, managed):\n+        \"\"\"\n+        A hook for backend-specific changes required when leaving manual\n+        transaction handling. Will usually be implemented only when\n+        _enter_transaction_management() is also required.\n+        \"\"\"\n+        pass\n+\n+    ##### Generic transaction management methods #####\n \n     def enter_transaction_management(self, managed=True):\n         \"\"\"\n@@ -185,20 +272,15 @@ def leave_transaction_management(self):\n             raise TransactionManagementError(\n                 \"Transaction managed block ended with pending COMMIT/ROLLBACK\")\n \n-    def validate_thread_sharing(self):\n+    def abort(self):\n         \"\"\"\n-        Validates that the connection isn't accessed by another thread than the\n-        one which originally created it, unless the connection was explicitly\n-        authorized to be shared between threads (via the `allow_thread_sharing`\n-        property). Raises an exception if the validation fails.\n+        Roll back any ongoing transaction and clean the transaction state\n+        stack.\n         \"\"\"\n-        if (not self.allow_thread_sharing\n-            and self._thread_ident != thread.get_ident()):\n-                raise DatabaseError(\"DatabaseWrapper objects created in a \"\n-                    \"thread can only be used in that same thread. The object \"\n-                    \"with alias '%s' was created in thread id %s and this is \"\n-                    \"thread id %s.\"\n-                    % (self.alias, self._thread_ident, thread.get_ident()))\n+        if self._dirty:\n+            self.rollback()\n+        while self.transaction_state:\n+            self.leave_transaction_management()\n \n     def is_dirty(self):\n         \"\"\"\n@@ -224,12 +306,6 @@ def set_clean(self):\n         self._dirty = False\n         self.clean_savepoints()\n \n-    def clean_savepoints(self):\n-        \"\"\"\n-        Resets the counter used to generate unique savepoint ids in this thread.\n-        \"\"\"\n-        self.savepoint_state = 0\n-\n     def is_managed(self):\n         \"\"\"\n         Checks whether the transaction manager is in manual or in auto state.\n@@ -275,57 +351,13 @@ def rollback_unless_managed(self):\n         else:\n             self.set_dirty()\n \n-    def commit(self):\n-        \"\"\"\n-        Does the commit itself and resets the dirty flag.\n-        \"\"\"\n-        self.validate_thread_sharing()\n-        self._commit()\n-        self.set_clean()\n-\n-    def rollback(self):\n-        \"\"\"\n-        This function does the rollback itself and resets the dirty flag.\n-        \"\"\"\n-        self.validate_thread_sharing()\n-        self._rollback()\n-        self.set_clean()\n-\n-    def savepoint(self):\n-        \"\"\"\n-        Creates a savepoint (if supported and required by the backend) inside the\n-        current transaction. Returns an identifier for the savepoint that will be\n-        used for the subsequent rollback or commit.\n-        \"\"\"\n-        thread_ident = thread.get_ident()\n-\n-        self.savepoint_state += 1\n-\n-        tid = str(thread_ident).replace('-', '')\n-        sid = \"s%s_x%d\" % (tid, self.savepoint_state)\n-        self._savepoint(sid)\n-        return sid\n-\n-    def savepoint_rollback(self, sid):\n-        \"\"\"\n-        Rolls back the most recent savepoint (if one exists). Does nothing if\n-        savepoints are not supported.\n-        \"\"\"\n-        self.validate_thread_sharing()\n-        if self.savepoint_state:\n-            self._savepoint_rollback(sid)\n-\n-    def savepoint_commit(self, sid):\n-        \"\"\"\n-        Commits the most recent savepoint (if one exists). Does nothing if\n-        savepoints are not supported.\n-        \"\"\"\n-        self.validate_thread_sharing()\n-        if self.savepoint_state:\n-            self._savepoint_commit(sid)\n+    ##### Foreign key constraints checks handling #####\n \n     @contextmanager\n     def constraint_checks_disabled(self):\n+        \"\"\"\n+        Context manager that disables foreign key constraint checking.\n+        \"\"\"\n         disabled = self.disable_constraint_checking()\n         try:\n             yield\n@@ -335,33 +367,40 @@ def constraint_checks_disabled(self):\n \n     def disable_constraint_checking(self):\n         \"\"\"\n-        Backends can implement as needed to temporarily disable foreign key constraint\n-        checking.\n+        Backends can implement as needed to temporarily disable foreign key\n+        constraint checking.\n         \"\"\"\n         pass\n \n     def enable_constraint_checking(self):\n         \"\"\"\n-        Backends can implement as needed to re-enable foreign key constraint checking.\n+        Backends can implement as needed to re-enable foreign key constraint\n+        checking.\n         \"\"\"\n         pass\n \n     def check_constraints(self, table_names=None):\n         \"\"\"\n-        Backends can override this method if they can apply constraint checking (e.g. via \"SET CONSTRAINTS\n-        ALL IMMEDIATE\"). Should raise an IntegrityError if any invalid foreign key references are encountered.\n+        Backends can override this method if they can apply constraint\n+        checking (e.g. via \"SET CONSTRAINTS ALL IMMEDIATE\"). Should raise an\n+        IntegrityError if any invalid foreign key references are encountered.\n         \"\"\"\n         pass\n \n-    def close(self):\n-        self.validate_thread_sharing()\n-        try:\n-            self._close()\n-        finally:\n-            self.connection = None\n-        self.set_clean()\n+    ##### Connection termination handling #####\n+\n+    def is_usable(self):\n+        \"\"\"\n+        Tests if the database connection is usable.\n+        This function may assume that self.connection is not None.\n+        \"\"\"\n+        raise NotImplementedError\n \n     def close_if_unusable_or_obsolete(self):\n+        \"\"\"\n+        Closes the current connection if unrecoverable errors have occurred,\n+        or if it outlived its maximum age.\n+        \"\"\"\n         if self.connection is not None:\n             if self.errors_occurred:\n                 if self.is_usable():\n@@ -373,30 +412,45 @@ def close_if_unusable_or_obsolete(self):\n                 self.close()\n                 return\n \n-    def is_usable(self):\n-        \"\"\"\n-        Test if the database connection is usable.\n+    ##### Thread safety handling #####\n \n-        This function may assume that self.connection is not None.\n+    def validate_thread_sharing(self):\n         \"\"\"\n-        raise NotImplementedError\n+        Validates that the connection isn't accessed by another thread than the\n+        one which originally created it, unless the connection was explicitly\n+        authorized to be shared between threads (via the `allow_thread_sharing`\n+        property). Raises an exception if the validation fails.\n+        \"\"\"\n+        if not (self.allow_thread_sharing\n+                or self._thread_ident == thread.get_ident()):\n+            raise DatabaseError(\"DatabaseWrapper objects created in a \"\n+                \"thread can only be used in that same thread. The object \"\n+                \"with alias '%s' was created in thread id %s and this is \"\n+                \"thread id %s.\"\n+                % (self.alias, self._thread_ident, thread.get_ident()))\n \n-    def cursor(self):\n-        self.validate_thread_sharing()\n-        if (self.use_debug_cursor or\n-            (self.use_debug_cursor is None and settings.DEBUG)):\n-            cursor = self.make_debug_cursor(self._cursor())\n-        else:\n-            cursor = util.CursorWrapper(self._cursor(), self)\n-        return cursor\n+    ##### Miscellaneous #####\n+\n+    def wrap_database_errors(self):\n+        \"\"\"\n+        Context manager and decorator that re-throws backend-specific database\n+        exceptions using Django's common wrappers.\n+        \"\"\"\n+        return DatabaseErrorWrapper(self)\n \n     def make_debug_cursor(self, cursor):\n+        \"\"\"\n+        Creates a cursor that logs all queries in self.queries.\n+        \"\"\"\n         return util.CursorDebugWrapper(cursor, self)\n \n     @contextmanager\n     def temporary_connection(self):\n-        # Ensure a connection is established, and avoid leaving a dangling\n-        # connection, for operations outside of the request-response cycle.\n+        \"\"\"\n+        Context manager that ensures that a connection is established, and\n+        if it opened one, closes it to avoid leaving a dangling connection.\n+        This is useful for operations outside of the request-response cycle.\n+        \"\"\"\n         must_close = self.connection is None\n         cursor = self.cursor()\n         try:\n@@ -406,6 +460,7 @@ def temporary_connection(self):\n             if must_close:\n                 self.close()\n \n+\n class BaseDatabaseFeatures(object):\n     allows_group_by_pk = False\n     # True if django.db.backend.utils.typecast_timestamp is used on values"
        },
        {
            "sha": "720b0176d63fd71a2c2264261e377174edafcc8c",
            "filename": "django/db/backends/dummy/base.py",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/d63e55039d42c2ba8bb6c8f8d133ede085b60969/django%2Fdb%2Fbackends%2Fdummy%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/d63e55039d42c2ba8bb6c8f8d133ede085b60969/django%2Fdb%2Fbackends%2Fdummy%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fdummy%2Fbase.py?ref=d63e55039d42c2ba8bb6c8f8d133ede085b60969",
            "patch": "@@ -48,19 +48,19 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     # implementations. Anything that tries to actually\n     # do something raises complain; anything that tries\n     # to rollback or undo something raises ignore.\n+    _cursor = complain\n     _commit = complain\n     _rollback = ignore\n-    enter_transaction_management = complain\n-    leave_transaction_management = ignore\n+    _close = ignore\n+    _savepoint = ignore\n+    _savepoint_commit = complain\n+    _savepoint_rollback = ignore\n+    _enter_transaction_management = complain\n+    _leave_transaction_management = ignore\n     set_dirty = complain\n     set_clean = complain\n     commit_unless_managed = complain\n     rollback_unless_managed = ignore\n-    savepoint = ignore\n-    savepoint_commit = complain\n-    savepoint_rollback = ignore\n-    close = ignore\n-    cursor = complain\n \n     def __init__(self, *args, **kwargs):\n         super(DatabaseWrapper, self).__init__(*args, **kwargs)"
        },
        {
            "sha": "400fe6cdac0420df4f8d64fb494c7fbfc62d1ba3",
            "filename": "django/db/backends/mysql/base.py",
            "status": "modified",
            "additions": 17,
            "deletions": 17,
            "changes": 34,
            "blob_url": "https://github.com/django/django/blob/d63e55039d42c2ba8bb6c8f8d133ede085b60969/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/d63e55039d42c2ba8bb6c8f8d133ede085b60969/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py?ref=d63e55039d42c2ba8bb6c8f8d133ede085b60969",
            "patch": "@@ -439,29 +439,12 @@ def create_cursor(self):\n         cursor = self.connection.cursor()\n         return CursorWrapper(cursor)\n \n-    def is_usable(self):\n-        try:\n-            self.connection.ping()\n-        except DatabaseError:\n-            return False\n-        else:\n-            return True\n-\n     def _rollback(self):\n         try:\n             BaseDatabaseWrapper._rollback(self)\n         except Database.NotSupportedError:\n             pass\n \n-    @cached_property\n-    def mysql_version(self):\n-        with self.temporary_connection():\n-            server_info = self.connection.get_server_info()\n-        match = server_version_re.match(server_info)\n-        if not match:\n-            raise Exception('Unable to determine MySQL version from version string %r' % server_info)\n-        return tuple([int(x) for x in match.groups()])\n-\n     def disable_constraint_checking(self):\n         \"\"\"\n         Disables foreign key checks, primarily for use in adding rows with forward references. Always returns True,\n@@ -510,3 +493,20 @@ def check_constraints(self, table_names=None):\n                         % (table_name, bad_row[0],\n                         table_name, column_name, bad_row[1],\n                         referenced_table_name, referenced_column_name))\n+\n+    def is_usable(self):\n+        try:\n+            self.connection.ping()\n+        except DatabaseError:\n+            return False\n+        else:\n+            return True\n+\n+    @cached_property\n+    def mysql_version(self):\n+        with self.temporary_connection():\n+            server_info = self.connection.get_server_info()\n+        match = server_version_re.match(server_info)\n+        if not match:\n+            raise Exception('Unable to determine MySQL version from version string %r' % server_info)\n+        return tuple([int(x) for x in match.groups()])"
        },
        {
            "sha": "a56813e28e07343010ce88a6b1d3299334e864e5",
            "filename": "django/db/backends/oracle/base.py",
            "status": "modified",
            "additions": 26,
            "deletions": 26,
            "changes": 52,
            "blob_url": "https://github.com/django/django/blob/d63e55039d42c2ba8bb6c8f8d133ede085b60969/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/d63e55039d42c2ba8bb6c8f8d133ede085b60969/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Foracle%2Fbase.py?ref=d63e55039d42c2ba8bb6c8f8d133ede085b60969",
            "patch": "@@ -515,14 +515,6 @@ def __init__(self, *args, **kwargs):\n         self.introspection = DatabaseIntrospection(self)\n         self.validation = BaseDatabaseValidation(self)\n \n-    def check_constraints(self, table_names=None):\n-        \"\"\"\n-        To check constraints, we set constraints to immediate. Then, when, we're done we must ensure they\n-        are returned to deferred.\n-        \"\"\"\n-        self.cursor().execute('SET CONSTRAINTS ALL IMMEDIATE')\n-        self.cursor().execute('SET CONSTRAINTS ALL DEFERRED')\n-\n     def _connect_string(self):\n         settings_dict = self.settings_dict\n         if not settings_dict['HOST'].strip():\n@@ -536,9 +528,6 @@ def _connect_string(self):\n         return \"%s/%s@%s\" % (settings_dict['USER'],\n                              settings_dict['PASSWORD'], dsn)\n \n-    def create_cursor(self):\n-        return FormatStylePlaceholderCursor(self.connection)\n-\n     def get_connection_params(self):\n         conn_params = self.settings_dict['OPTIONS'].copy()\n         if 'use_returning_into' in conn_params:\n@@ -598,21 +587,8 @@ def init_connection_state(self):\n             # stmtcachesize is available only in 4.3.2 and up.\n             pass\n \n-    def is_usable(self):\n-        try:\n-            if hasattr(self.connection, 'ping'):    # Oracle 10g R2 and higher\n-                self.connection.ping()\n-            else:\n-                # Use a cx_Oracle cursor directly, bypassing Django's utilities.\n-                self.connection.cursor().execute(\"SELECT 1 FROM DUAL\")\n-        except DatabaseError:\n-            return False\n-        else:\n-            return True\n-\n-    # Oracle doesn't support savepoint commits.  Ignore them.\n-    def _savepoint_commit(self, sid):\n-        pass\n+    def create_cursor(self):\n+        return FormatStylePlaceholderCursor(self.connection)\n \n     def _commit(self):\n         if self.connection is not None:\n@@ -632,6 +608,30 @@ def _commit(self):\n                     six.reraise(utils.IntegrityError, utils.IntegrityError(*tuple(e.args)), sys.exc_info()[2])\n                 raise\n \n+    # Oracle doesn't support savepoint commits.  Ignore them.\n+    def _savepoint_commit(self, sid):\n+        pass\n+\n+    def check_constraints(self, table_names=None):\n+        \"\"\"\n+        To check constraints, we set constraints to immediate. Then, when, we're done we must ensure they\n+        are returned to deferred.\n+        \"\"\"\n+        self.cursor().execute('SET CONSTRAINTS ALL IMMEDIATE')\n+        self.cursor().execute('SET CONSTRAINTS ALL DEFERRED')\n+\n+    def is_usable(self):\n+        try:\n+            if hasattr(self.connection, 'ping'):    # Oracle 10g R2 and higher\n+                self.connection.ping()\n+            else:\n+                # Use a cx_Oracle cursor directly, bypassing Django's utilities.\n+                self.connection.cursor().execute(\"SELECT 1 FROM DUAL\")\n+        except DatabaseError:\n+            return False\n+        else:\n+            return True\n+\n     @cached_property\n     def oracle_version(self):\n         with self.temporary_connection():"
        },
        {
            "sha": "d5b6f136961f64d4c7214959c8296a93d6f9498e",
            "filename": "django/db/backends/postgresql_psycopg2/base.py",
            "status": "modified",
            "additions": 41,
            "deletions": 41,
            "changes": 82,
            "blob_url": "https://github.com/django/django/blob/d63e55039d42c2ba8bb6c8f8d133ede085b60969/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/d63e55039d42c2ba8bb6c8f8d133ede085b60969/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py?ref=d63e55039d42c2ba8bb6c8f8d133ede085b60969",
            "patch": "@@ -91,40 +91,6 @@ def __init__(self, *args, **kwargs):\n         self.introspection = DatabaseIntrospection(self)\n         self.validation = BaseDatabaseValidation(self)\n \n-    def check_constraints(self, table_names=None):\n-        \"\"\"\n-        To check constraints, we set constraints to immediate. Then, when, we're done we must ensure they\n-        are returned to deferred.\n-        \"\"\"\n-        self.cursor().execute('SET CONSTRAINTS ALL IMMEDIATE')\n-        self.cursor().execute('SET CONSTRAINTS ALL DEFERRED')\n-\n-    def close(self):\n-        self.validate_thread_sharing()\n-        if self.connection is None:\n-            return\n-\n-        try:\n-            self.connection.close()\n-            self.connection = None\n-        except Database.Error:\n-            # In some cases (database restart, network connection lost etc...)\n-            # the connection to the database is lost without giving Django a\n-            # notification. If we don't set self.connection to None, the error\n-            # will occur a every request.\n-            self.connection = None\n-            logger.warning('psycopg2 error while closing the connection.',\n-                exc_info=sys.exc_info()\n-            )\n-            raise\n-        finally:\n-            self.set_clean()\n-\n-    @cached_property\n-    def pg_version(self):\n-        with self.temporary_connection():\n-            return get_version(self.connection)\n-\n     def get_connection_params(self):\n         settings_dict = self.settings_dict\n         if not settings_dict['NAME']:\n@@ -177,14 +143,26 @@ def create_cursor(self):\n         cursor.tzinfo_factory = utc_tzinfo_factory if settings.USE_TZ else None\n         return cursor\n \n-    def is_usable(self):\n+    def close(self):\n+        self.validate_thread_sharing()\n+        if self.connection is None:\n+            return\n+\n         try:\n-            # Use a psycopg cursor directly, bypassing Django's utilities.\n-            self.connection.cursor().execute(\"SELECT 1\")\n-        except DatabaseError:\n-            return False\n-        else:\n-            return True\n+            self.connection.close()\n+            self.connection = None\n+        except Database.Error:\n+            # In some cases (database restart, network connection lost etc...)\n+            # the connection to the database is lost without giving Django a\n+            # notification. If we don't set self.connection to None, the error\n+            # will occur a every request.\n+            self.connection = None\n+            logger.warning('psycopg2 error while closing the connection.',\n+                exc_info=sys.exc_info()\n+            )\n+            raise\n+        finally:\n+            self.set_clean()\n \n     def _enter_transaction_management(self, managed):\n         \"\"\"\n@@ -222,3 +200,25 @@ def set_dirty(self):\n         if ((self.transaction_state and self.transaction_state[-1]) or\n                 not self.features.uses_autocommit):\n             super(DatabaseWrapper, self).set_dirty()\n+\n+    def check_constraints(self, table_names=None):\n+        \"\"\"\n+        To check constraints, we set constraints to immediate. Then, when, we're done we must ensure they\n+        are returned to deferred.\n+        \"\"\"\n+        self.cursor().execute('SET CONSTRAINTS ALL IMMEDIATE')\n+        self.cursor().execute('SET CONSTRAINTS ALL DEFERRED')\n+\n+    def is_usable(self):\n+        try:\n+            # Use a psycopg cursor directly, bypassing Django's utilities.\n+            self.connection.cursor().execute(\"SELECT 1\")\n+        except DatabaseError:\n+            return False\n+        else:\n+            return True\n+\n+    @cached_property\n+    def pg_version(self):\n+        with self.temporary_connection():\n+            return get_version(self.connection)"
        },
        {
            "sha": "416a6293f550277dd3874c573566f2cff4f28b2f",
            "filename": "django/db/backends/sqlite3/base.py",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/d63e55039d42c2ba8bb6c8f8d133ede085b60969/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/d63e55039d42c2ba8bb6c8f8d133ede085b60969/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py?ref=d63e55039d42c2ba8bb6c8f8d133ede085b60969",
            "patch": "@@ -347,8 +347,13 @@ def init_connection_state(self):\n     def create_cursor(self):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n-    def is_usable(self):\n-        return True\n+    def close(self):\n+        self.validate_thread_sharing()\n+        # If database is in memory, closing the connection destroys the\n+        # database. To prevent accidental data loss, ignore close requests on\n+        # an in-memory db.\n+        if self.settings_dict['NAME'] != \":memory:\":\n+            BaseDatabaseWrapper.close(self)\n \n     def check_constraints(self, table_names=None):\n         \"\"\"\n@@ -384,13 +389,9 @@ def check_constraints(self, table_names=None):\n                         % (table_name, bad_row[0], table_name, column_name, bad_row[1],\n                         referenced_table_name, referenced_column_name))\n \n-    def close(self):\n-        self.validate_thread_sharing()\n-        # If database is in memory, closing the connection destroys the\n-        # database. To prevent accidental data loss, ignore close requests on\n-        # an in-memory db.\n-        if self.settings_dict['NAME'] != \":memory:\":\n-            BaseDatabaseWrapper.close(self)\n+    def is_usable(self):\n+        return True\n+\n \n FORMAT_QMARK_REGEX = re.compile(r'(?<!%)%s')\n "
        }
    ],
    "stats": {
        "total": 486,
        "additions": 271,
        "deletions": 215
    }
}