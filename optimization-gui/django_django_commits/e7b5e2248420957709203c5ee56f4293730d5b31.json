{
    "author": "ramiro",
    "message": "Expanded section about lazy translation in i18n docs.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17203 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "e7b5e2248420957709203c5ee56f4293730d5b31",
    "files": [
        {
            "sha": "886e29115ac8a214d7ee68f1ab04e0fd7bfc5feb",
            "filename": "docs/topics/i18n/translation.txt",
            "status": "modified",
            "additions": 71,
            "deletions": 59,
            "changes": 130,
            "blob_url": "https://github.com/django/django/blob/e7b5e2248420957709203c5ee56f4293730d5b31/docs%2Ftopics%2Fi18n%2Ftranslation.txt",
            "raw_url": "https://github.com/django/django/raw/e7b5e2248420957709203c5ee56f4293730d5b31/docs%2Ftopics%2Fi18n%2Ftranslation.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fi18n%2Ftranslation.txt?ref=e7b5e2248420957709203c5ee56f4293730d5b31",
            "patch": "@@ -294,21 +294,83 @@ Contextual markers are also supported by the :ttag:`trans` and\n Lazy translation\n ----------------\n \n-Use the function :func:`django.utils.translation.ugettext_lazy()` to translate\n-strings lazily -- when the value is accessed rather than when the\n-``ugettext_lazy()`` function is called.\n+Use the lazy versions of translation functions in\n+:mod:`django.utils.translation` (easily recognizable by the ``lazy`` suffix in\n+their names) to translate strings lazily -- when the value is accessed rather\n+than when they are called.\n \n-For example, to translate a model's ``help_text``, do the following::\n+These functions store a lazy reference to the string -- not the actual\n+translation. The translation itself will be done when the string is used in a\n+string context, such as in template rendering.\n+\n+This is essential when calls to these functions are located in code paths that\n+are executed at module load time.\n+\n+As this is something that can easily happen when defining models (the\n+declarative notation of Django models is implemented in a way such that model\n+fields are actually class level attributes) this means you need to make sure to\n+use lazy translations in the following cases:\n+\n+Model fields and relationship ``verbose_name`` and ``help_text`` option values\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For example, to translate the help text of the *name* field in the following\n+model, do the following::\n \n     from django.utils.translation import ugettext_lazy\n \n     class MyThing(models.Model):\n         name = models.CharField(help_text=ugettext_lazy('This is the help text'))\n \n-In this example, ``ugettext_lazy()`` stores a lazy reference to the string --\n-not the actual translation. The translation itself will be done when the string\n-is used in a string context, such as template rendering on the Django admin\n-site.\n+You can mark names of ``ForeignKey``, ``ManyTomanyField`` or ``OneToOneField``\n+relationship as translatable by using their ``verbose_name`` options::\n+\n+    from django.utils.translation import ugettext_lazy as _\n+\n+    class MyThing(models.Model):\n+        kind = models.ForeignKey(ThingKind, related_name='kinds',\n+                                 verbose_name=_('kind'))\n+\n+Just like you would do in :attr:`~django.db.models.Options.verbose_name` you\n+should provide a lowercase verbose name text for the relation as Django will\n+automatically titlecase it when required.\n+\n+Model verbose names values\n+~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+It is recommended to always provide explicit\n+:attr:`~django.db.models.Options.verbose_name` and\n+:attr:`~django.db.models.Options.verbose_name_plural` options rather than\n+relying on the fallback English-centric and somewhat na√Øve determination of\n+verbose names Django performs bu looking at the model's class name::\n+\n+    from django.utils.translation import ugettext_lazy\n+\n+    class MyThing(models.Model):\n+        name = models.CharField(_('name'), help_text=ugettext_lazy('This is the help text'))\n+\n+        class Meta:\n+            verbose_name = ugettext_lazy('my thing')\n+            verbose_name_plural = ugettext_lazy('my things')\n+\n+Model methods ``short_description`` attribute values\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+For model methods, you can provide translations to Django and the admin site\n+with the ``short_description`` attribute::\n+\n+    from django.utils.translation import ugettext_lazy as _\n+\n+    class MyThing(models.Model):\n+        kind = models.ForeignKey(ThingKind, related_name='kinds',\n+                                 verbose_name=_('kind'))\n+\n+        def is_mouse(self):\n+            return self.kind.type == MOUSE_TYPE\n+        is_mouse.short_description = _('Is it a mouse?')\n+\n+Notes on translation in models\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n The result of a ``ugettext_lazy()`` call can be used wherever you would use a\n unicode string (an object with type ``unicode``) in Python. If you try to use\n@@ -328,64 +390,14 @@ If you ever see output that looks like ``\"hello\n <django.utils.functional...>\"``, you have tried to insert the result of\n ``ugettext_lazy()`` into a bytestring. That's a bug in your code.\n \n-If you don't like the verbose name ``ugettext_lazy``, you can just alias it as\n+If you don't like the long ``ugettext_lazy`` name, you can just alias it as\n ``_`` (underscore), like so::\n \n     from django.utils.translation import ugettext_lazy as _\n \n     class MyThing(models.Model):\n         name = models.CharField(help_text=_('This is the help text'))\n \n-Always use lazy translations in :doc:`Django models </topics/db/models>`.\n-Field names and table names should be marked for translation (otherwise, they\n-won't be translated in the admin interface). This means writing explicit\n-``verbose_name`` and ``verbose_name_plural`` options in the ``Meta`` class,\n-though, rather than relying on Django's default determination of\n-``verbose_name`` and ``verbose_name_plural`` by looking at the model's class\n-name::\n-\n-    from django.utils.translation import ugettext_lazy as _\n-\n-    class MyThing(models.Model):\n-        name = models.CharField(_('name'), help_text=_('This is the help text'))\n-\n-        class Meta:\n-            verbose_name = _('my thing')\n-            verbose_name_plural = _('my things')\n-\n-Notes on model classes translation\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-Your model classes may not only contain normal fields: you may have relations\n-(with a ``ForeignKey`` field) or additional model methods you may use for\n-columns in the Django admin site.\n-\n-If you have models with foreign keys and you use the Django admin site, you can\n-provide translations for the relation itself by using the ``verbose_name``\n-parameter on the ``ForeignKey`` object::\n-\n-    class MyThing(models.Model):\n-        kind = models.ForeignKey(ThingKind, related_name='kinds',\n-                                 verbose_name=_('kind'))\n-\n-As you would do for the ``verbose_name`` and ``verbose_name_plural`` settings of\n-a model Meta class, you should provide a lowercase verbose name text for the\n-relation as Django will automatically titlecase it when required.\n-\n-For model methods, you can provide translations to Django and the admin site\n-with the ``short_description`` parameter set on the corresponding method::\n-\n-    class MyThing(models.Model):\n-        kind = models.ForeignKey(ThingKind, related_name='kinds',\n-                                 verbose_name=_('kind'))\n-\n-        def is_mouse(self):\n-            return self.kind.type == MOUSE_TYPE\n-        is_mouse.short_description = _('Is it a mouse?')\n-\n-As always with model classes translations, don't forget to use the lazy\n-translation method!\n-\n Working with lazy translation objects\n -------------------------------------\n "
        }
    ],
    "stats": {
        "total": 130,
        "additions": 71,
        "deletions": 59
    }
}