{
    "author": "unknown",
    "message": "Fixed #18306 -- Made deferred models issue update_fields on save\n\nDeferred models now automatically update only the fields which are\nloaded from the db (with .only() or .defer()). In addition, any field\nset manually after the load is updated on save.",
    "sha": "99321e30cebbffeafc6ae19f4f92a0a665cbf19b",
    "files": [
        {
            "sha": "1e1a13871469780217bdb0c7224718ca597b68c0",
            "filename": "django/db/models/base.py",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/django/django/blob/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/django%2Fdb%2Fmodels%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/django%2Fdb%2Fmodels%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fbase.py?ref=99321e30cebbffeafc6ae19f4f92a0a665cbf19b",
            "patch": "@@ -475,6 +475,7 @@ def save(self, force_insert=False, force_update=False, using=None,\n         that the \"save\" must be an SQL insert or update (or equivalent for\n         non-SQL backends), respectively. Normally, they should not be set.\n         \"\"\"\n+        using = using or router.db_for_write(self.__class__, instance=self)\n         if force_insert and (force_update or update_fields):\n             raise ValueError(\"Cannot force both insert and updating in model saving.\")\n \n@@ -502,6 +503,23 @@ def save(self, force_insert=False, force_update=False, using=None,\n                                  \"model or are m2m fields: %s\"\n                                  % ', '.join(non_model_fields))\n \n+        # If saving to the same database, and this model is deferred, then\n+        # automatically do a \"update_fields\" save on the loaded fields.\n+        elif not force_insert and self._deferred and using == self._state.db:\n+            field_names = set()\n+            for field in self._meta.fields:\n+                if not field.primary_key and not hasattr(field, 'through'):\n+                    field_names.add(field.attname)\n+            deferred_fields = [\n+                f.attname for f in self._meta.fields\n+                if f.attname not in self.__dict__\n+                   and isinstance(self.__class__.__dict__[f.attname],\n+                                  DeferredAttribute)]\n+\n+            loaded_fields = field_names.difference(deferred_fields)\n+            if loaded_fields:\n+                update_fields = frozenset(loaded_fields)\n+\n         self.save_base(using=using, force_insert=force_insert,\n                        force_update=force_update, update_fields=update_fields)\n     save.alters_data = True"
        },
        {
            "sha": "b7ae3890cff96769a6789a7200e0b6269b4f04fb",
            "filename": "docs/ref/models/instances.txt",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/docs%2Fref%2Fmodels%2Finstances.txt",
            "raw_url": "https://github.com/django/django/raw/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/docs%2Fref%2Fmodels%2Finstances.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Finstances.txt?ref=99321e30cebbffeafc6ae19f4f92a0a665cbf19b",
            "patch": "@@ -386,6 +386,12 @@ perform an update on all fields.\n \n Specifying ``update_fields`` will force an update.\n \n+When saving a model fetched through deferred model loading\n+(:meth:`~Model.only()` or :meth:`~Model.defer()`) only the fields loaded from\n+the DB will get updated. In effect there is an automatic ``update_fields`` in\n+this case. If you assign or change any deferred field value, these fields will\n+be added to the updated fields.\n+\n Deleting objects\n ================\n "
        },
        {
            "sha": "b59b2ece82f3710ad1de2f5d10654b8419cf240a",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/django/django/blob/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=99321e30cebbffeafc6ae19f4f92a0a665cbf19b",
            "patch": "@@ -1110,6 +1110,14 @@ one, doing so will result in an error.\n     reader, is slightly faster and consumes a little less memory in the Python\n     process.\n \n+.. versionchanged:: 1.5\n+\n+.. note::\n+\n+    When calling :meth:`~Model.save()` for instances with deferred fields,\n+    only the loaded fields will be saved. See :meth:`~Model.save()` for more\n+    details.\n+\n \n only\n ~~~~\n@@ -1154,6 +1162,14 @@ All of the cautions in the note for the :meth:`defer` documentation apply to\n options. Also note that using :meth:`only` and omitting a field requested\n using :meth:`select_related` is an error as well.\n \n+.. versionchanged:: 1.5\n+\n+.. note::\n+\n+    When calling :meth:`~Model.save()` for instances with deferred fields,\n+    only the loaded fields will be saved. See :meth:`~Model.save()` for more\n+    details.\n+\n using\n ~~~~~\n "
        },
        {
            "sha": "2896acb36b4ecf144534bd4cf2302994bd13d2e7",
            "filename": "docs/releases/1.5.txt",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/docs%2Freleases%2F1.5.txt",
            "raw_url": "https://github.com/django/django/raw/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/docs%2Freleases%2F1.5.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.5.txt?ref=99321e30cebbffeafc6ae19f4f92a0a665cbf19b",
            "patch": "@@ -42,6 +42,10 @@ keyword argument ``update_fields``. By using this argument it is possible to\n save only a select list of model's fields. This can be useful for performance\n reasons or when trying to avoid overwriting concurrent changes.\n \n+Deferred instances (those loaded by .only() or .defer()) will automatically\n+save just the loaded fields. If any field is set manually after load, that\n+field will also get updated on save.\n+\n See the :meth:`Model.save() <django.db.models.Model.save()>` documentation for\n more details.\n "
        },
        {
            "sha": "bf5dd99166b7bb495753f477ea1bf9bdc6d6c473",
            "filename": "tests/modeltests/update_only_fields/models.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/tests%2Fmodeltests%2Fupdate_only_fields%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/tests%2Fmodeltests%2Fupdate_only_fields%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fupdate_only_fields%2Fmodels.py?ref=99321e30cebbffeafc6ae19f4f92a0a665cbf19b",
            "patch": "@@ -15,6 +15,7 @@ class Account(models.Model):\n class Person(models.Model):\n     name = models.CharField(max_length=20)\n     gender = models.CharField(max_length=1, choices=GENDER_CHOICES)\n+    pid = models.IntegerField(null=True, default=None)\n \n     def __str__(self):\n         return self.name"
        },
        {
            "sha": "c904c972369012a7e32311114ddafad86c75ac18",
            "filename": "tests/modeltests/update_only_fields/tests.py",
            "status": "modified",
            "additions": 101,
            "deletions": 0,
            "changes": 101,
            "blob_url": "https://github.com/django/django/blob/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/tests%2Fmodeltests%2Fupdate_only_fields%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/tests%2Fmodeltests%2Fupdate_only_fields%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fupdate_only_fields%2Ftests.py?ref=99321e30cebbffeafc6ae19f4f92a0a665cbf19b",
            "patch": "@@ -18,6 +18,107 @@ def test_update_fields_basic(self):\n         self.assertEqual(s.gender, 'F')\n         self.assertEqual(s.name, 'Ian')\n \n+    def test_update_fields_deferred(self):\n+        s = Person.objects.create(name='Sara', gender='F', pid=22)\n+        self.assertEqual(s.gender, 'F')\n+\n+        s1 = Person.objects.defer(\"gender\", \"pid\").get(pk=s.pk)\n+        s1.name = \"Emily\"\n+        s1.gender = \"M\"\n+\n+        with self.assertNumQueries(1):\n+            s1.save()\n+\n+        s2 = Person.objects.get(pk=s1.pk)\n+        self.assertEqual(s2.name, \"Emily\")\n+        self.assertEqual(s2.gender, \"M\")\n+\n+    def test_update_fields_only_1(self):\n+        s = Person.objects.create(name='Sara', gender='F')\n+        self.assertEqual(s.gender, 'F')\n+\n+        s1 = Person.objects.only('name').get(pk=s.pk)\n+        s1.name = \"Emily\"\n+        s1.gender = \"M\"\n+\n+        with self.assertNumQueries(1):\n+            s1.save()\n+\n+        s2 = Person.objects.get(pk=s1.pk)\n+        self.assertEqual(s2.name, \"Emily\")\n+        self.assertEqual(s2.gender, \"M\")\n+\n+    def test_update_fields_only_2(self):\n+        s = Person.objects.create(name='Sara', gender='F', pid=22)\n+        self.assertEqual(s.gender, 'F')\n+\n+        s1 = Person.objects.only('name').get(pk=s.pk)\n+        s1.name = \"Emily\"\n+        s1.gender = \"M\"\n+\n+        with self.assertNumQueries(2):\n+            s1.save(update_fields=['pid'])\n+\n+        s2 = Person.objects.get(pk=s1.pk)\n+        self.assertEqual(s2.name, \"Sara\")\n+        self.assertEqual(s2.gender, \"F\")\n+\n+    def test_update_fields_only_repeated(self):\n+        s = Person.objects.create(name='Sara', gender='F')\n+        self.assertEqual(s.gender, 'F')\n+\n+        s1 = Person.objects.only('name').get(pk=s.pk)\n+        s1.gender = 'M'\n+        with self.assertNumQueries(1):\n+            s1.save()\n+        # Test that the deferred class does not remember that gender was\n+        # set, instead the instace should remember this.\n+        s1 = Person.objects.only('name').get(pk=s.pk)\n+        with self.assertNumQueries(1):\n+            s1.save()\n+\n+    def test_update_fields_inheritance_defer(self):\n+        profile_boss = Profile.objects.create(name='Boss', salary=3000)\n+        e1 = Employee.objects.create(name='Sara', gender='F',\n+            employee_num=1, profile=profile_boss)\n+        e1 = Employee.objects.only('name').get(pk=e1.pk)\n+        e1.name = 'Linda'\n+        with self.assertNumQueries(1):\n+            e1.save()\n+        self.assertEqual(Employee.objects.get(pk=e1.pk).name,\n+                         'Linda')\n+\n+    def test_update_fields_fk_defer(self):\n+        profile_boss = Profile.objects.create(name='Boss', salary=3000)\n+        profile_receptionist = Profile.objects.create(name='Receptionist', salary=1000)\n+        e1 = Employee.objects.create(name='Sara', gender='F',\n+            employee_num=1, profile=profile_boss)\n+        e1 = Employee.objects.only('profile').get(pk=e1.pk)\n+        e1.profile = profile_receptionist\n+        with self.assertNumQueries(1):\n+            e1.save()\n+        self.assertEqual(Employee.objects.get(pk=e1.pk).profile, profile_receptionist)\n+        e1.profile_id = profile_boss.pk\n+        with self.assertNumQueries(1):\n+            e1.save()\n+        self.assertEqual(Employee.objects.get(pk=e1.pk).profile, profile_boss)\n+\n+    def test_select_related_only_interaction(self):\n+        profile_boss = Profile.objects.create(name='Boss', salary=3000)\n+        e1 = Employee.objects.create(name='Sara', gender='F',\n+            employee_num=1, profile=profile_boss)\n+        e1 = Employee.objects.only('profile__salary').select_related('profile').get(pk=e1.pk)\n+        profile_boss.name = 'Clerk'\n+        profile_boss.salary = 1000\n+        profile_boss.save()\n+        # The loaded salary of 3000 gets saved, the name of 'Clerk' isn't\n+        # overwritten.\n+        with self.assertNumQueries(1):\n+            e1.profile.save()\n+        reloaded_profile = Profile.objects.get(pk=profile_boss.pk)\n+        self.assertEqual(reloaded_profile.name, profile_boss.name)\n+        self.assertEqual(reloaded_profile.salary, 3000)\n+\n     def test_update_fields_m2m(self):\n         profile_boss = Profile.objects.create(name='Boss', salary=3000)\n         e1 = Employee.objects.create(name='Sara', gender='F',"
        },
        {
            "sha": "782fe2bfc681762eb41cd53044d6d0dd541dbd1a",
            "filename": "tests/regressiontests/multiple_database/tests.py",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/django/django/blob/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/tests%2Fregressiontests%2Fmultiple_database%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/99321e30cebbffeafc6ae19f4f92a0a665cbf19b/tests%2Fregressiontests%2Fmultiple_database%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fmultiple_database%2Ftests.py?ref=99321e30cebbffeafc6ae19f4f92a0a665cbf19b",
            "patch": "@@ -1546,6 +1546,21 @@ def test_subquery(self):\n         # If you evaluate the query, it should work, running on 'other'\n         self.assertEqual(list(qs.values_list('title', flat=True)), ['Dive into Python'])\n \n+    def test_deferred_models(self):\n+        mark_def = Person.objects.using('default').create(name=\"Mark Pilgrim\")\n+        mark_other = Person.objects.using('other').create(name=\"Mark Pilgrim\")\n+        orig_b = Book.objects.using('other').create(title=\"Dive into Python\",\n+                                                    published=datetime.date(2009, 5, 4),\n+                                                    editor=mark_other)\n+        b = Book.objects.using('other').only('title').get(pk=orig_b.pk)\n+        self.assertEqual(b.published, datetime.date(2009, 5, 4))\n+        b = Book.objects.using('other').only('title').get(pk=orig_b.pk)\n+        b.editor = mark_def\n+        b.save(using='default')\n+        self.assertEqual(Book.objects.using('default').get(pk=b.pk).published,\n+                         datetime.date(2009, 5, 4))\n+\n+\n class AuthTestCase(TestCase):\n     multi_db = True\n "
        }
    ],
    "stats": {
        "total": 161,
        "additions": 161,
        "deletions": 0
    }
}