{
    "author": "kmtracey",
    "message": "Fixed #10154: Allow combining F expressions with timedelta values.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15018 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6",
    "files": [
        {
            "sha": "971e3622edf664d1e78afb2008d1c8a743c5b737",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6",
            "patch": "@@ -154,6 +154,9 @@ class BaseDatabaseFeatures(object):\n     # deferred\n     can_defer_constraint_checks = False\n \n+    # date_interval_sql can properly handle mixed Date/DateTime fields and timedeltas\n+    supports_mixed_date_datetime_comparisons = True\n+\n     # Features that need to be confirmed at runtime\n     # Cache whether the confirmation has been performed.\n     _confirmed = False\n@@ -220,6 +223,12 @@ def date_extract_sql(self, lookup_type, field_name):\n         \"\"\"\n         raise NotImplementedError()\n \n+    def date_interval_sql(self, sql, connector, timedelta):\n+        \"\"\"\n+        Implements the date interval functionality for expressions\n+        \"\"\"\n+        raise NotImplementedError()\n+\n     def date_trunc_sql(self, lookup_type, field_name):\n         \"\"\"\n         Given a lookup_type of 'year', 'month' or 'day', returns the SQL that"
        },
        {
            "sha": "9b49a8f0ea2b0bd33f03ba86f57b99dc3df6efd3",
            "filename": "django/db/backends/mysql/base.py",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py?ref=b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6",
            "patch": "@@ -158,6 +158,10 @@ def date_trunc_sql(self, lookup_type, field_name):\n             sql = \"CAST(DATE_FORMAT(%s, '%s') AS DATETIME)\" % (field_name, format_str)\n         return sql\n \n+    def date_interval_sql(self, sql, connector, timedelta):\n+        return \"(%s %s INTERVAL '%d 0:0:%d:%d' DAY_MICROSECOND)\" % (sql, connector,\n+                timedelta.days, timedelta.seconds, timedelta.microseconds)\n+\n     def drop_foreignkey_sql(self):\n         return \"DROP FOREIGN KEY\"\n "
        },
        {
            "sha": "231f4d5d6234e6f32e1fb9f3eadd1a7c3e08de01",
            "filename": "django/db/backends/oracle/base.py",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Foracle%2Fbase.py?ref=b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6",
            "patch": "@@ -118,6 +118,20 @@ def date_extract_sql(self, lookup_type, field_name):\n         else:\n             return \"EXTRACT(%s FROM %s)\" % (lookup_type, field_name)\n \n+    def date_interval_sql(self, sql, connector, timedelta):\n+        \"\"\"\n+        Implements the interval functionality for expressions\n+        format for Oracle:\n+        (datefield + INTERVAL '3 00:03:20.000000' DAY(1) TO SECOND(6))\n+        \"\"\"\n+        minutes, seconds = divmod(timedelta.seconds, 60)\n+        hours, minutes = divmod(minutes, 60)\n+        days = str(timedelta.days)\n+        day_precision = len(days)\n+        fmt = \"(%s %s INTERVAL '%s %02d:%02d:%02d.%06d' DAY(%d) TO SECOND(6))\"\n+        return fmt % (sql, connector, days, hours, minutes, seconds,\n+                timedelta.microseconds, day_precision)\n+\n     def date_trunc_sql(self, lookup_type, field_name):\n         # Oracle uses TRUNC() for both dates and numbers.\n         # http://download-east.oracle.com/docs/cd/B10501_01/server.920/a96540/functions155a.htm#SQLRF06151"
        },
        {
            "sha": "83fe7c21ec64587e4bcf55173851c1ca21127340",
            "filename": "django/db/backends/postgresql/operations.py",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fbackends%2Fpostgresql%2Foperations.py",
            "raw_url": "https://github.com/django/django/raw/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fbackends%2Fpostgresql%2Foperations.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql%2Foperations.py?ref=b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6",
            "patch": "@@ -27,6 +27,23 @@ def date_extract_sql(self, lookup_type, field_name):\n         else:\n             return \"EXTRACT('%s' FROM %s)\" % (lookup_type, field_name)\n \n+    def date_interval_sql(self, sql, connector, timedelta):\n+        \"\"\"\n+        implements the interval functionality for expressions\n+        format for Postgres:\n+            (datefield + interval '3 days 200 seconds 5 microseconds')\n+        \"\"\"\n+        modifiers = []\n+        if timedelta.days:\n+            modifiers.append(u'%s days' % timedelta.days)\n+        if timedelta.seconds:\n+            modifiers.append(u'%s seconds' % timedelta.seconds)\n+        if timedelta.microseconds:\n+            modifiers.append(u'%s microseconds' % timedelta.microseconds)\n+        mods = u' '.join(modifiers)\n+        conn = u' %s ' % connector\n+        return u'(%s)' % conn.join([sql, u'interval \\'%s\\'' % mods])\n+\n     def date_trunc_sql(self, lookup_type, field_name):\n         # http://www.postgresql.org/docs/8.0/static/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC\n         return \"DATE_TRUNC('%s', %s)\" % (lookup_type, field_name)"
        },
        {
            "sha": "8344bad2a0919e21a20cefcf1239d11144cdd1d9",
            "filename": "django/db/backends/sqlite3/base.py",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/django/django/blob/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py?ref=b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6",
            "patch": "@@ -9,6 +9,7 @@\n \n import re\n import sys\n+import datetime\n \n from django.db import utils\n from django.db.backends import *\n@@ -63,6 +64,7 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     test_db_allows_multiple_connections = False\n     supports_unspecified_pk = True\n     supports_1000_query_parameters = False\n+    supports_mixed_date_datetime_comparisons = False\n \n     def _supports_stddev(self):\n         \"\"\"Confirm support for STDDEV and related stats functions\n@@ -90,6 +92,16 @@ def date_extract_sql(self, lookup_type, field_name):\n         # cause a collision with a field name).\n         return \"django_extract('%s', %s)\" % (lookup_type.lower(), field_name)\n \n+    def date_interval_sql(self, sql, connector, timedelta):\n+        # It would be more straightforward if we could use the sqlite strftime\n+        # function, but it does not allow for keeping six digits of fractional\n+        # second information, nor does it allow for formatting date and datetime\n+        # values differently. So instead we register our own function that \n+        # formats the datetime combined with the delta in a manner suitable \n+        # for comparisons.\n+        return  u'django_format_dtdelta(%s, \"%s\", \"%d\", \"%d\", \"%d\")' % (sql, \n+            connector, timedelta.days, timedelta.seconds, timedelta.microseconds)\n+\n     def date_trunc_sql(self, lookup_type, field_name):\n         # sqlite doesn't support DATE_TRUNC, so we fake it with a user-defined\n         # function django_date_trunc that's registered in connect(). Note that\n@@ -197,6 +209,7 @@ def _cursor(self):\n             self.connection.create_function(\"django_extract\", 2, _sqlite_extract)\n             self.connection.create_function(\"django_date_trunc\", 2, _sqlite_date_trunc)\n             self.connection.create_function(\"regexp\", 2, _sqlite_regexp)\n+            self.connection.create_function(\"django_format_dtdelta\", 5, _sqlite_format_dtdelta)\n             connection_created.send(sender=self.__class__, connection=self)\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n@@ -260,6 +273,25 @@ def _sqlite_date_trunc(lookup_type, dt):\n     elif lookup_type == 'day':\n         return \"%i-%02i-%02i 00:00:00\" % (dt.year, dt.month, dt.day)\n \n+def _sqlite_format_dtdelta(dt, conn, days, secs, usecs):\n+    try:\n+        dt = util.typecast_timestamp(dt)\n+        delta = datetime.timedelta(int(days), int(secs), int(usecs))\n+        if conn.strip() == '+':\n+            dt = dt + delta\n+        else:\n+            dt = dt - delta\n+    except (ValueError, TypeError):\n+        return None\n+\n+    if isinstance(dt, datetime.datetime):\n+        rv = dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n+        if dt.microsecond:\n+            rv = \"%s.%0.6d\" % (rv, dt.microsecond)\n+    else:\n+        rv = dt.strftime(\"%Y-%m-%d\")\n+    return rv\n+\n def _sqlite_regexp(re_pattern, re_string):\n     import re\n     try:"
        },
        {
            "sha": "8b9c934bbbc18ce2a0b608357e1fe2f32c42fdcd",
            "filename": "django/db/models/expressions.py",
            "status": "modified",
            "additions": 42,
            "deletions": 1,
            "changes": 43,
            "blob_url": "https://github.com/django/django/blob/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fmodels%2Fexpressions.py",
            "raw_url": "https://github.com/django/django/raw/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fmodels%2Fexpressions.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fexpressions.py?ref=b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6",
            "patch": "@@ -1,4 +1,4 @@\n-from datetime import datetime\n+import datetime\n \n from django.utils import tree\n from django.utils.copycompat import deepcopy\n@@ -26,6 +26,9 @@ def __init__(self, children=None, connector=None, negated=False):\n         super(ExpressionNode, self).__init__(children, connector, negated)\n \n     def _combine(self, other, connector, reversed, node=None):\n+        if isinstance(other, datetime.timedelta):\n+            return DateModifierNode([self, other], connector)\n+\n         if reversed:\n             obj = ExpressionNode([other], connector)\n             obj.add(node or self, connector)\n@@ -111,3 +114,41 @@ def prepare(self, evaluator, query, allow_joins):\n \n     def evaluate(self, evaluator, qn, connection):\n         return evaluator.evaluate_leaf(self, qn, connection)\n+\n+class DateModifierNode(ExpressionNode):\n+    \"\"\"\n+    Node that implements the following syntax:\n+    filter(end_date__gt=F('start_date') + datetime.timedelta(days=3, seconds=200))\n+\n+    which translates into:\n+    POSTGRES:\n+        WHERE end_date > (start_date + INTERVAL '3 days 200 seconds')\n+\n+    MYSQL:\n+        WHERE end_date > (start_date + INTERVAL '3 0:0:200:0' DAY_MICROSECOND)\n+\n+    ORACLE:\n+        WHERE end_date > (start_date + INTERVAL '3 00:03:20.000000' DAY(1) TO SECOND(6))\n+\n+    SQLITE:\n+        WHERE end_date > django_format_dtdelta(start_date, \"+\" \"3\", \"200\", \"0\")\n+        (A custom function is used in order to preserve six digits of fractional\n+        second information on sqlite, and to format both date and datetime values.)\n+\n+    Note that microsecond comparisons are not well supported with MySQL, since \n+    MySQL does not store microsecond information.\n+\n+    Only adding and subtracting timedeltas is supported, attempts to use other \n+    operations raise a TypeError.\n+    \"\"\"\n+    def __init__(self, children, connector, negated=False):\n+        if len(children) != 2:\n+            raise TypeError('Must specify a node and a timedelta.')\n+        if not isinstance(children[1], datetime.timedelta):\n+            raise TypeError('Second child must be a timedelta.')\n+        if connector not in (self.ADD, self.SUB):\n+            raise TypeError('Connector must be + or -, not %s' % connector)\n+        super(DateModifierNode, self).__init__(children, connector, negated)\n+\n+    def evaluate(self, evaluator, qn, connection):\n+        return evaluator.evaluate_date_modifier_node(self, qn, connection)"
        },
        {
            "sha": "1bbf742b5c195167ae501fdb98f423600c3c6dc9",
            "filename": "django/db/models/sql/expressions.py",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py",
            "raw_url": "https://github.com/django/django/raw/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py?ref=b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6",
            "patch": "@@ -85,3 +85,13 @@ def evaluate_leaf(self, node, qn, connection):\n             return col.as_sql(qn, connection), ()\n         else:\n             return '%s.%s' % (qn(col[0]), qn(col[1])), ()\n+\n+    def evaluate_date_modifier_node(self, node, qn, connection):\n+        timedelta = node.children.pop()\n+        sql, params = self.evaluate_node(node, qn, connection)\n+\n+        if timedelta.days == 0 and timedelta.seconds == 0 and \\\n+                timedelta.microseconds == 0:\n+            return sql, params\n+\n+        return connection.ops.date_interval_sql(sql, node.connector, timedelta), params"
        },
        {
            "sha": "7992c95e5f427f975d7c1ef849a4ab1209455ac4",
            "filename": "docs/releases/1.3.txt",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/docs%2Freleases%2F1.3.txt",
            "raw_url": "https://github.com/django/django/raw/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/docs%2Freleases%2F1.3.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.3.txt?ref=b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6",
            "patch": "@@ -235,6 +235,9 @@ requests. These include:\n       providing a :class:`~django.template.RequestContext` by\n       default.\n \n+    * Support for combining :ref:`F() expressions <query-expressions>`\n+      with timedelta values when retrieving or updating database values.\n+\n .. _HTTPOnly: http://www.owasp.org/index.php/HTTPOnly\n \n .. _backwards-incompatible-changes-1.3:"
        },
        {
            "sha": "cbbf073d39d4737f7e8e5776b3ebe981c103eac0",
            "filename": "docs/topics/db/queries.txt",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/docs%2Ftopics%2Fdb%2Fqueries.txt",
            "raw_url": "https://github.com/django/django/raw/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/docs%2Ftopics%2Fdb%2Fqueries.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Fqueries.txt?ref=b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6",
            "patch": "@@ -36,6 +36,7 @@ models, which comprise a Weblog application:\n         headline = models.CharField(max_length=255)\n         body_text = models.TextField()\n         pub_date = models.DateTimeField()\n+        mod_date = models.DateTimeField()\n         authors = models.ManyToManyField(Author)\n         n_comments = models.IntegerField()\n         n_pingbacks = models.IntegerField()\n@@ -566,10 +567,19 @@ You can also use the double underscore notation to span relationships in\n an ``F()`` object. An ``F()`` object with a double underscore will introduce\n any joins needed to access the related object. For example, to retrieve all\n the entries where the author's name is the same as the blog name, we could\n-issue the query:\n+issue the query::\n \n     >>> Entry.objects.filter(authors__name=F('blog__name'))\n \n+.. versionadded:: 1.3\n+\n+For date and date/time fields, you can add or subtract a ``datetime.timedelta``\n+object.  The following would return all entries that were modified more than 3 days\n+after they were published::\n+   \n+    >>> from datetime import timedelta\n+    >>> Entry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3))\n+\n The pk lookup shortcut\n ----------------------\n "
        },
        {
            "sha": "56c3746b91b523bc156de83f75d6650dd6dca425",
            "filename": "tests/regressiontests/expressions_regress/models.py",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/tests%2Fregressiontests%2Fexpressions_regress%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/tests%2Fregressiontests%2Fexpressions_regress%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fexpressions_regress%2Fmodels.py?ref=b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6",
            "patch": "@@ -10,3 +10,16 @@ class Number(models.Model):\n     def __unicode__(self):\n         return u'%i, %.3f' % (self.integer, self.float)\n \n+class Experiment(models.Model):\n+    name = models.CharField(max_length=24)\n+    assigned = models.DateField()\n+    completed = models.DateField()\n+    start = models.DateTimeField()\n+    end = models.DateTimeField()\n+\n+    class Meta:\n+        ordering = ('name',)\n+\n+    def duration(self):\n+        return self.end - self.start\n+"
        },
        {
            "sha": "a900c6c5fd22785d43f3361f4a663fb0bd91cf9b",
            "filename": "tests/regressiontests/expressions_regress/tests.py",
            "status": "modified",
            "additions": 205,
            "deletions": 2,
            "changes": 207,
            "blob_url": "https://github.com/django/django/blob/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/tests%2Fregressiontests%2Fexpressions_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6/tests%2Fregressiontests%2Fexpressions_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fexpressions_regress%2Ftests.py?ref=b1f6a4d66fd7f987a41c1e1aaa43907d9d347ba6",
            "patch": "@@ -1,12 +1,14 @@\n \"\"\"\n Spanning tests for all the operations that F() expressions can perform.\n \"\"\"\n+import datetime\n+\n from django.conf import settings\n-from django.db import models, DEFAULT_DB_ALIAS\n+from django.db import models, connection\n from django.db.models import F\n from django.test import TestCase, Approximate, skipUnlessDBFeature\n \n-from regressiontests.expressions_regress.models import Number\n+from regressiontests.expressions_regress.models import Number, Experiment\n \n \n class ExpressionsRegressTests(TestCase):\n@@ -193,3 +195,204 @@ def test_right_hand_bitwise_or(self):\n         self.assertEqual(Number.objects.get(pk=self.n.pk).integer, 47)\n         self.assertEqual(Number.objects.get(pk=self.n.pk).float, Approximate(15.500, places=3))\n \n+class FTimeDeltaTests(TestCase):\n+\n+    def setUp(self):\n+        sday = datetime.date(2010, 6, 25)\n+        stime = datetime.datetime(2010, 6, 25, 12, 15, 30, 747000)\n+        midnight = datetime.time(0)\n+\n+        delta0 = datetime.timedelta(0)\n+        delta1 = datetime.timedelta(microseconds=253000)\n+        delta2 = datetime.timedelta(seconds=44)\n+        delta3 = datetime.timedelta(hours=21, minutes=8)\n+        delta4 = datetime.timedelta(days=10)\n+\n+        # Test data is set so that deltas and delays will be\n+        # strictly increasing.\n+        self.deltas = []\n+        self.delays = []\n+        self.days_long = []\n+\n+        # e0: started same day as assigned, zero duration\n+        end = stime+delta0\n+        e0 = Experiment.objects.create(name='e0', assigned=sday, start=stime,\n+            end=end, completed=end.date())\n+        self.deltas.append(delta0)\n+        self.delays.append(e0.start-\n+            datetime.datetime.combine(e0.assigned, midnight))\n+        self.days_long.append(e0.completed-e0.assigned)\n+\n+        # e1: started one day after assigned, tiny duration, data\n+        # set so that end time has no fractional seconds, which\n+        # tests an edge case on sqlite. This Experiment is only\n+        # included in the test data when the DB supports microsecond\n+        # precision.\n+        if connection.features.supports_microsecond_precision:\n+            delay = datetime.timedelta(1)\n+            end = stime + delay + delta1\n+            e1 = Experiment.objects.create(name='e1', assigned=sday,\n+                start=stime+delay, end=end, completed=end.date())\n+            self.deltas.append(delta1)\n+            self.delays.append(e1.start-\n+                datetime.datetime.combine(e1.assigned, midnight))\n+            self.days_long.append(e1.completed-e1.assigned)\n+\n+        # e2: started three days after assigned, small duration\n+        end = stime+delta2\n+        e2 = Experiment.objects.create(name='e2',\n+            assigned=sday-datetime.timedelta(3), start=stime, end=end, \n+            completed=end.date())\n+        self.deltas.append(delta2)\n+        self.delays.append(e2.start-\n+            datetime.datetime.combine(e2.assigned, midnight))\n+        self.days_long.append(e2.completed-e2.assigned)\n+\n+        # e3: started four days after assigned, medium duration\n+        delay = datetime.timedelta(4)\n+        end = stime + delay + delta3\n+        e3 = Experiment.objects.create(name='e3',\n+            assigned=sday, start=stime+delay, end=end, completed=end.date())\n+        self.deltas.append(delta3)\n+        self.delays.append(e3.start-\n+            datetime.datetime.combine(e3.assigned, midnight))\n+        self.days_long.append(e3.completed-e3.assigned)\n+\n+        # e4: started 10 days after assignment, long duration\n+        end = stime + delta4\n+        e4 = Experiment.objects.create(name='e4',\n+            assigned=sday-datetime.timedelta(10), start=stime, end=end,\n+            completed=end.date())\n+        self.deltas.append(delta4)\n+        self.delays.append(e4.start-\n+            datetime.datetime.combine(e4.assigned, midnight))\n+        self.days_long.append(e4.completed-e4.assigned)\n+        self.expnames = [e.name for e in Experiment.objects.all()]\n+\n+    def test_delta_add(self):\n+        for i in range(len(self.deltas)):\n+            delta = self.deltas[i]\n+            test_set = [e.name for e in\n+                Experiment.objects.filter(end__lt=F('start')+delta)]\n+            self.assertEqual(test_set, self.expnames[:i])\n+\n+            test_set = [e.name for e in\n+                Experiment.objects.filter(end__lte=F('start')+delta)]\n+            self.assertEqual(test_set, self.expnames[:i+1])\n+\n+    def test_delta_subtract(self):\n+        for i in range(len(self.deltas)):\n+            delta = self.deltas[i]\n+            test_set = [e.name for e in\n+                Experiment.objects.filter(start__gt=F('end')-delta)]\n+            self.assertEqual(test_set, self.expnames[:i])\n+\n+            test_set = [e.name for e in\n+                Experiment.objects.filter(start__gte=F('end')-delta)]\n+            self.assertEqual(test_set, self.expnames[:i+1])\n+\n+    def test_exclude(self):\n+        for i in range(len(self.deltas)):\n+            delta = self.deltas[i]\n+            test_set = [e.name for e in \n+                Experiment.objects.exclude(end__lt=F('start')+delta)]\n+            self.assertEqual(test_set, self.expnames[i:])\n+\n+            test_set = [e.name for e in \n+                Experiment.objects.exclude(end__lte=F('start')+delta)]\n+            self.assertEqual(test_set, self.expnames[i+1:])\n+\n+    def test_date_comparison(self):\n+        for i in range(len(self.days_long)):\n+            days = self.days_long[i]\n+            test_set = [e.name for e in \n+                Experiment.objects.filter(completed__lt=F('assigned')+days)]\n+            self.assertEqual(test_set, self.expnames[:i])\n+\n+            test_set = [e.name for e in \n+                Experiment.objects.filter(completed__lte=F('assigned')+days)]\n+            self.assertEqual(test_set, self.expnames[:i+1])\n+\n+    @skipUnlessDBFeature(\"supports_mixed_date_datetime_comparisons\")\n+    def test_mixed_comparisons1(self):\n+        for i in range(len(self.delays)):\n+            delay = self.delays[i]\n+            if not connection.features.supports_microsecond_precision:\n+                delay = datetime.timedelta(delay.days, delay.seconds)\n+            test_set = [e.name for e in\n+                Experiment.objects.filter(assigned__gt=F('start')-delay)]\n+            self.assertEqual(test_set, self.expnames[:i])\n+\n+            test_set = [e.name for e in\n+                Experiment.objects.filter(assigned__gte=F('start')-delay)]\n+            self.assertEqual(test_set, self.expnames[:i+1])\n+\n+    def test_mixed_comparisons2(self):\n+        delays = [datetime.timedelta(delay.days) for delay in self.delays]\n+        for i in range(len(delays)):\n+            delay = delays[i]\n+            test_set = [e.name for e in\n+                Experiment.objects.filter(start__lt=F('assigned')+delay)]\n+            self.assertEqual(test_set, self.expnames[:i])\n+\n+            test_set = [e.name for e in\n+                Experiment.objects.filter(start__lte=F('assigned')+delay+\n+                    datetime.timedelta(1))]\n+            self.assertEqual(test_set, self.expnames[:i+1])\n+\n+    def test_delta_update(self):\n+        for i in range(len(self.deltas)):\n+            delta = self.deltas[i]\n+            exps = Experiment.objects.all()\n+            expected_durations = [e.duration() for e in exps]\n+            expected_starts = [e.start+delta for e in exps]\n+            expected_ends = [e.end+delta for e in exps]\n+\n+            Experiment.objects.update(start=F('start')+delta, end=F('end')+delta)\n+            exps = Experiment.objects.all()\n+            new_starts = [e.start for e in exps]\n+            new_ends = [e.end for e in exps]\n+            new_durations = [e.duration() for e in exps]\n+            self.assertEqual(expected_starts, new_starts)\n+            self.assertEqual(expected_ends, new_ends)\n+            self.assertEqual(expected_durations, new_durations)\n+\n+    def test_delta_invalid_op_mult(self):\n+        raised = False\n+        try:\n+            r = repr(Experiment.objects.filter(end__lt=F('start')*self.deltas[0]))\n+        except TypeError:\n+            raised = True\n+        self.assertTrue(raised, \"TypeError not raised on attempt to multiply datetime by timedelta.\")\n+\n+    def test_delta_invalid_op_div(self):\n+        raised = False\n+        try:\n+            r = repr(Experiment.objects.filter(end__lt=F('start')/self.deltas[0]))\n+        except TypeError:\n+            raised = True\n+        self.assertTrue(raised, \"TypeError not raised on attempt to divide datetime by timedelta.\")\n+\n+    def test_delta_invalid_op_mod(self):\n+        raised = False\n+        try:\n+            r = repr(Experiment.objects.filter(end__lt=F('start')%self.deltas[0]))\n+        except TypeError:\n+            raised = True\n+        self.assertTrue(raised, \"TypeError not raised on attempt to modulo divide datetime by timedelta.\")\n+\n+    def test_delta_invalid_op_and(self):\n+        raised = False\n+        try:\n+            r = repr(Experiment.objects.filter(end__lt=F('start')&self.deltas[0]))\n+        except TypeError:\n+            raised = True\n+        self.assertTrue(raised, \"TypeError not raised on attempt to binary and a datetime with a timedelta.\")\n+\n+    def test_delta_invalid_op_or(self):\n+        raised = False\n+        try:\n+            r = repr(Experiment.objects.filter(end__lt=F('start')|self.deltas[0]))\n+        except TypeError:\n+            raised = True\n+        self.assertTrue(raised, \"TypeError not raised on attempt to binary or a datetime with a timedelta.\")"
        }
    ],
    "stats": {
        "total": 364,
        "additions": 360,
        "deletions": 4
    }
}