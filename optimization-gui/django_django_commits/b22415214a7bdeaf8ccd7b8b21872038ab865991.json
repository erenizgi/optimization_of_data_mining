{
    "author": "freakboy3742",
    "message": "Beefed up the tests for multi-cache handling of the cache middleware and view decorators, and made a couple of tweaks for edge cases as a result.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15021 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "b22415214a7bdeaf8ccd7b8b21872038ab865991",
    "files": [
        {
            "sha": "31a8147eeca6bae5fb99b84c05f97f74688db284",
            "filename": "django/middleware/cache.py",
            "status": "modified",
            "additions": 21,
            "deletions": 18,
            "changes": 39,
            "blob_url": "https://github.com/django/django/blob/b22415214a7bdeaf8ccd7b8b21872038ab865991/django%2Fmiddleware%2Fcache.py",
            "raw_url": "https://github.com/django/django/raw/b22415214a7bdeaf8ccd7b8b21872038ab865991/django%2Fmiddleware%2Fcache.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fmiddleware%2Fcache.py?ref=b22415214a7bdeaf8ccd7b8b21872038ab865991",
            "patch": "@@ -85,7 +85,7 @@ def process_response(self, request, response):\n             return response\n         patch_response_headers(response, timeout)\n         if timeout:\n-            cache_key = learn_cache_key(request, response, timeout, self.key_prefix)\n+            cache_key = learn_cache_key(request, response, timeout, self.key_prefix, cache=self.cache)\n             self.cache.set(cache_key, response, timeout)\n         return response\n \n@@ -120,17 +120,14 @@ def process_request(self, request):\n             return None # Don't cache requests from authenticated users.\n \n         # try and get the cached GET response\n-        cache_key = get_cache_key(request, self.key_prefix, 'GET')\n-\n+        cache_key = get_cache_key(request, self.key_prefix, 'GET', cache=self.cache)\n         if cache_key is None:\n             request._cache_update_cache = True\n             return None # No cache information available, need to rebuild.\n-\n         response = self.cache.get(cache_key, None)\n-\n         # if it wasn't found and we are looking for a HEAD, try looking just for that\n         if response is None and request.method == 'HEAD':\n-            cache_key = get_cache_key(request, self.key_prefix, 'HEAD')\n+            cache_key = get_cache_key(request, self.key_prefix, 'HEAD', cache=self.cache)\n             response = self.cache.get(cache_key, None)\n \n         if response is None:\n@@ -149,32 +146,38 @@ class CacheMiddleware(UpdateCacheMiddleware, FetchFromCacheMiddleware):\n     using the decorator-from-middleware utility.\n     \"\"\"\n     def __init__(self, cache_timeout=None, cache_anonymous_only=None, **kwargs):\n-        self.cache_timeout = cache_timeout\n-        if cache_timeout is None:\n-            self.cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS\n-\n         # We need to differentiate between \"provided, but using default value\",\n         # and \"not provided\". If the value is provided using a default, then\n         # we fall back to system defaults. If it is not provided at all,\n         # we need to use middleware defaults.\n+\n+        cache_kwargs = {}\n+        try:\n+            self.key_prefix = kwargs.get('key_prefix')\n+            if self.key_prefix is not None:\n+                cache_kwargs['KEY_PREFIX'] = self.key_prefix\n+            else:\n+                self.key_prefix = ''\n+        except KeyError:\n+            self.key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n+            cache_kwargs['KEY_PREFIX'] = self.key_prefix\n         try:\n             cache_alias = kwargs.get('cache_alias')\n             if cache_alias is None:\n                 cache_alias = DEFAULT_CACHE_ALIAS\n+            if cache_timeout is not None:\n+                cache_kwargs['TIMEOUT'] = cache_timeout\n         except KeyError:\n             cache_alias = settings.CACHE_MIDDLEWARE_ALIAS\n-\n-        cache_kwargs = {}\n-        try:\n-            key_prefix = kwargs.get('key_prefix')\n-            if key_prefix is not None:\n-                cache_kwargs['KEY_PREFIX'] = key_prefix\n-        except KeyError:\n-            cache_kwargs['KEY_PREFIX'] = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n+            if cache_timeout is None:\n+                cache_kwargs['TIMEOUT'] = settings.CACHE_MIDDLEWARE_SECONDS\n+            else:\n+                cache_kwargs['TIMEOUT'] = cache_timeout\n \n         if cache_anonymous_only is None:\n             self.cache_anonymous_only = getattr(settings, 'CACHE_MIDDLEWARE_ANONYMOUS_ONLY', False)\n         else:\n             self.cache_anonymous_only = cache_anonymous_only\n \n         self.cache = get_cache(cache_alias, **cache_kwargs)\n+        self.cache_timeout = self.cache.default_timeout"
        },
        {
            "sha": "ba647ac420fae99d9d401b31357290c91e137af2",
            "filename": "django/utils/cache.py",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/b22415214a7bdeaf8ccd7b8b21872038ab865991/django%2Futils%2Fcache.py",
            "raw_url": "https://github.com/django/django/raw/b22415214a7bdeaf8ccd7b8b21872038ab865991/django%2Futils%2Fcache.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fcache.py?ref=b22415214a7bdeaf8ccd7b8b21872038ab865991",
            "patch": "@@ -21,7 +21,7 @@\n import time\n \n from django.conf import settings\n-from django.core.cache import cache\n+from django.core.cache import get_cache\n from django.utils.encoding import smart_str, iri_to_uri\n from django.utils.http import http_date\n from django.utils.hashcompat import md5_constructor\n@@ -162,7 +162,7 @@ def _generate_cache_header_key(key_prefix, request):\n         key_prefix, path.hexdigest())\n     return _i18n_cache_key_suffix(request, cache_key)\n \n-def get_cache_key(request, key_prefix=None, method='GET'):\n+def get_cache_key(request, key_prefix=None, method='GET', cache=None):\n     \"\"\"\n     Returns a cache key based on the request path. It can be used in the\n     request phase because it pulls the list of headers to take into account\n@@ -175,13 +175,15 @@ def get_cache_key(request, key_prefix=None, method='GET'):\n     if key_prefix is None:\n         key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n     cache_key = _generate_cache_header_key(key_prefix, request)\n+    if cache is None:\n+        cache = get_cache(settings.CACHE_MIDDLEWARE_ALIAS)\n     headerlist = cache.get(cache_key, None)\n     if headerlist is not None:\n         return _generate_cache_key(request, method, headerlist, key_prefix)\n     else:\n         return None\n \n-def learn_cache_key(request, response, cache_timeout=None, key_prefix=None):\n+def learn_cache_key(request, response, cache_timeout=None, key_prefix=None, cache=None):\n     \"\"\"\n     Learns what headers to take into account for some request path from the\n     response object. It stores those headers in a global path registry so that\n@@ -199,6 +201,8 @@ def learn_cache_key(request, response, cache_timeout=None, key_prefix=None):\n     if cache_timeout is None:\n         cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS\n     cache_key = _generate_cache_header_key(key_prefix, request)\n+    if cache is None:\n+        cache = get_cache(settings.CACHE_MIDDLEWARE_ALIAS)\n     if response.has_header('Vary'):\n         headerlist = ['HTTP_'+header.upper().replace('-', '_')\n                       for header in cc_delim_re.split(response['Vary'])]"
        },
        {
            "sha": "f2cfcb37da8be888b009f07c1fba9259c9bd8cef",
            "filename": "tests/regressiontests/cache/tests.py",
            "status": "modified",
            "additions": 153,
            "deletions": 1,
            "changes": 154,
            "blob_url": "https://github.com/django/django/blob/b22415214a7bdeaf8ccd7b8b21872038ab865991/tests%2Fregressiontests%2Fcache%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/b22415214a7bdeaf8ccd7b8b21872038ab865991/tests%2Fregressiontests%2Fcache%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fcache%2Ftests.py?ref=b22415214a7bdeaf8ccd7b8b21872038ab865991",
            "patch": "@@ -14,12 +14,14 @@\n from django.core.cache import get_cache, DEFAULT_CACHE_ALIAS\n from django.core.cache.backends.base import InvalidCacheBackendError, CacheKeyWarning\n from django.http import HttpResponse, HttpRequest\n-from django.middleware.cache import FetchFromCacheMiddleware, UpdateCacheMiddleware\n+from django.middleware.cache import FetchFromCacheMiddleware, UpdateCacheMiddleware, CacheMiddleware\n+from django.test import RequestFactory\n from django.test.utils import get_warnings_state, restore_warnings_state\n from django.utils import translation\n from django.utils import unittest\n from django.utils.cache import patch_vary_headers, get_cache_key, learn_cache_key\n from django.utils.hashcompat import md5_constructor\n+from django.views.decorators.cache import cache_page\n from regressiontests.cache.models import Poll, expensive_calculation\n \n # functions/classes for complex data type tests\n@@ -759,6 +761,15 @@ def test_old_initialization(self):\n         self.cache = get_cache('locmem://?max_entries=30&cull_frequency=0')\n         self.perform_cull_test(50, 19)\n \n+    def test_multiple_caches(self):\n+        \"Check that multiple locmem caches are isolated\"\n+        mirror_cache = get_cache('django.core.cache.backends.locmem.LocMemCache')\n+        other_cache = get_cache('django.core.cache.backends.locmem.LocMemCache', LOCATION='other')\n+\n+        self.cache.set('value1', 42)\n+        self.assertEquals(mirror_cache.get('value1'), 42)\n+        self.assertEquals(other_cache.get('value1'), None)\n+\n # memcached backend isn't guaranteed to be available.\n # To check the memcached backend, the test settings file will\n # need to contain a cache backend setting that points at\n@@ -1117,5 +1128,146 @@ def tearDown(self):\n         else:\n             settings.CACHES['default']['KEY_PREFIX'] = self.old_cache_key_prefix\n \n+class CacheMiddlewareTest(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.orig_cache_middleware_alias = settings.CACHE_MIDDLEWARE_ALIAS\n+        self.orig_cache_middleware_key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n+        self.orig_caches = settings.CACHES\n+\n+        settings.CACHE_MIDDLEWARE_ALIAS = 'other'\n+        settings.CACHE_MIDDLEWARE_KEY_PREFIX = 'middlewareprefix'\n+        settings.CACHES = {\n+            'default': {\n+                'BACKEND': 'django.core.cache.backends.locmem.LocMemCache'\n+            },\n+            'other': {\n+                'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',\n+                'LOCATION': 'other',\n+                'TIMEOUT': '1'\n+            }\n+        }\n+\n+    def tearDown(self):\n+        settings.CACHE_MIDDLEWARE_ALIAS = self.orig_cache_middleware_alias\n+        settings.CACHE_MIDDLEWARE_KEY_PREFIX = self.orig_cache_middleware_key_prefix\n+        settings.CACHES = self.orig_caches\n+\n+    def test_middleware(self):\n+        def view(request, value):\n+            return HttpResponse('Hello World %s' % value)\n+\n+        factory = RequestFactory()\n+\n+        middleware = CacheMiddleware()\n+        prefix_middleware = CacheMiddleware(key_prefix='prefix1')\n+        timeout_middleware = CacheMiddleware(cache_timeout=1)\n+\n+        request = factory.get('/view/')\n+\n+        # Put the request through the request middleware\n+        result = middleware.process_request(request)\n+        self.assertEquals(result, None)\n+\n+        response = view(request, '1')\n+\n+        # Now put the response through the response middleware\n+        response = middleware.process_response(request, response)\n+\n+        # Repeating the request should result in a cache hit\n+        result = middleware.process_request(request)\n+        self.assertNotEquals(result, None)\n+        self.assertEquals(result.content, 'Hello World 1')\n+\n+        # The same request through a different middleware won't hit\n+        result = prefix_middleware.process_request(request)\n+        self.assertEquals(result, None)\n+\n+        # The same request with a timeout _will_ hit\n+        result = timeout_middleware.process_request(request)\n+        self.assertNotEquals(result, None)\n+        self.assertEquals(result.content, 'Hello World 1')\n+\n+    def test_view_decorator(self):\n+        def view(request, value):\n+            return HttpResponse('Hello World %s' % value)\n+\n+        # decorate the same view with different cache decorators\n+        default_view = cache_page(view)\n+        default_with_prefix_view = cache_page(key_prefix='prefix1')(view)\n+\n+        explicit_default_view = cache_page(cache='default')(view)\n+        explicit_default_with_prefix_view = cache_page(cache='default', key_prefix='prefix1')(view)\n+\n+        other_view = cache_page(cache='other')(view)\n+        other_with_prefix_view = cache_page(cache='other', key_prefix='prefix2')(view)\n+\n+        factory = RequestFactory()\n+        request = factory.get('/view/')\n+\n+        # Request the view once\n+        response = default_view(request, '1')\n+        self.assertEquals(response.content, 'Hello World 1')\n+\n+        # Request again -- hit the cache\n+        response = default_view(request, '2')\n+        self.assertEquals(response.content, 'Hello World 1')\n+\n+        # Requesting the same view with the explicit cache should yield the same result\n+        response = explicit_default_view(request, '3')\n+        self.assertEquals(response.content, 'Hello World 1')\n+\n+        # Requesting with a prefix will hit a different cache key\n+        response = explicit_default_with_prefix_view(request, '4')\n+        self.assertEquals(response.content, 'Hello World 4')\n+\n+        # Hitting the same view again gives a cache hit\n+        response = explicit_default_with_prefix_view(request, '5')\n+        self.assertEquals(response.content, 'Hello World 4')\n+\n+        # And going back to the implicit cache will hit the same cache\n+        response = default_with_prefix_view(request, '6')\n+        self.assertEquals(response.content, 'Hello World 4')\n+\n+        # Requesting from an alternate cache won't hit cache\n+        response = other_view(request, '7')\n+        self.assertEquals(response.content, 'Hello World 7')\n+\n+        # But a repeated hit will hit cache\n+        response = other_view(request, '8')\n+        self.assertEquals(response.content, 'Hello World 7')\n+\n+        # And prefixing the alternate cache yields yet another cache entry\n+        response = other_with_prefix_view(request, '9')\n+        self.assertEquals(response.content, 'Hello World 9')\n+\n+        # But if we wait a couple of seconds...\n+        time.sleep(2)\n+\n+        # ... the default cache will still hit\n+        cache = get_cache('default')\n+        response = default_view(request, '10')\n+        self.assertEquals(response.content, 'Hello World 1')\n+\n+        # ... the default cache with a prefix will still hit\n+        response = default_with_prefix_view(request, '11')\n+        self.assertEquals(response.content, 'Hello World 4')\n+\n+        # ... the explicit default cache will still hit\n+        response = explicit_default_view(request, '12')\n+        self.assertEquals(response.content, 'Hello World 1')\n+\n+        # ... the explicit default cache with a prefix will still hit\n+        response = explicit_default_with_prefix_view(request, '13')\n+        self.assertEquals(response.content, 'Hello World 4')\n+\n+        # .. but a rapidly expiring cache won't hit\n+        response = other_view(request, '14')\n+        self.assertEquals(response.content, 'Hello World 14')\n+\n+        # .. even if it has a prefix\n+        response = other_with_prefix_view(request, '15')\n+        self.assertEquals(response.content, 'Hello World 15')\n+\n if __name__ == '__main__':\n     unittest.main()"
        }
    ],
    "stats": {
        "total": 203,
        "additions": 181,
        "deletions": 22
    }
}