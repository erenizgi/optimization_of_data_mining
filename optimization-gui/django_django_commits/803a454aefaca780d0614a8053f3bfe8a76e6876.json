{
    "author": "SmileyChris",
    "message": "Fixes #15732 -- better introduction of template filter decorator concepts (first register, then stringfilter). Thanks for the patch, hahasee.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16251 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "803a454aefaca780d0614a8053f3bfe8a76e6876",
    "files": [
        {
            "sha": "1b56cf85c34258298ee6403ed512efa370cc2d8c",
            "filename": "docs/howto/custom-template-tags.txt",
            "status": "modified",
            "additions": 21,
            "deletions": 19,
            "changes": 40,
            "blob_url": "https://github.com/django/django/blob/803a454aefaca780d0614a8053f3bfe8a76e6876/docs%2Fhowto%2Fcustom-template-tags.txt",
            "raw_url": "https://github.com/django/django/raw/803a454aefaca780d0614a8053f3bfe8a76e6876/docs%2Fhowto%2Fcustom-template-tags.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fhowto%2Fcustom-template-tags.txt?ref=803a454aefaca780d0614a8053f3bfe8a76e6876",
            "patch": "@@ -105,23 +105,6 @@ your function. Example::\n         \"Converts a string into all lowercase\"\n         return value.lower()\n \n-Template filters that expect strings\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-If you're writing a template filter that only expects a string as the first\n-argument, you should use the decorator ``stringfilter``. This will\n-convert an object to its string value before being passed to your function::\n-\n-    from django.template.defaultfilters import stringfilter\n-\n-    @stringfilter\n-    def lower(value):\n-        return value.lower()\n-\n-This way, you'll be able to pass, say, an integer to this filter, and it\n-won't cause an ``AttributeError`` (because integers don't have ``lower()``\n-methods).\n-\n Registering custom filters\n ~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n@@ -140,18 +123,37 @@ The ``Library.filter()`` method takes two arguments:\n You can use ``register.filter()`` as a decorator instead::\n \n     @register.filter(name='cut')\n-    @stringfilter\n     def cut(value, arg):\n         return value.replace(arg, '')\n \n     @register.filter\n-    @stringfilter\n     def lower(value):\n         return value.lower()\n \n If you leave off the ``name`` argument, as in the second example above, Django\n will use the function's name as the filter name.\n \n+Template filters that expect strings\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+If you're writing a template filter that only expects a string as the first\n+argument, you should use the decorator ``stringfilter``. This will\n+convert an object to its string value before being passed to your function::\n+\n+    from django import template\n+    from django.template.defaultfilters import stringfilter\n+\n+    register = template.Library()\n+\n+    @register.filter\n+    @stringfilter\n+    def lower(value):\n+        return value.lower()\n+\n+This way, you'll be able to pass, say, an integer to this filter, and it\n+won't cause an ``AttributeError`` (because integers don't have ``lower()``\n+methods).\n+\n Filters and auto-escaping\n ~~~~~~~~~~~~~~~~~~~~~~~~~\n "
        }
    ],
    "stats": {
        "total": 40,
        "additions": 21,
        "deletions": 19
    }
}