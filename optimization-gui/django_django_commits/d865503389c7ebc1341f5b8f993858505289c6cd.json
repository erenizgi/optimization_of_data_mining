{
    "author": "andrewgodwin",
    "message": "db_index alteration mostly working",
    "sha": "d865503389c7ebc1341f5b8f993858505289c6cd",
    "files": [
        {
            "sha": "022e3b74cbb938280d1ff3ed5d4e71bc42104cd9",
            "filename": "django/db/backends/mysql/introspection.py",
            "status": "modified",
            "additions": 17,
            "deletions": 2,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/d865503389c7ebc1341f5b8f993858505289c6cd/django%2Fdb%2Fbackends%2Fmysql%2Fintrospection.py",
            "raw_url": "https://github.com/django/django/raw/d865503389c7ebc1341f5b8f993858505289c6cd/django%2Fdb%2Fbackends%2Fmysql%2Fintrospection.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fintrospection.py?ref=d865503389c7ebc1341f5b8f993858505289c6cd",
            "patch": "@@ -104,8 +104,7 @@ def get_indexes(self, cursor, table_name):\n \n     def get_constraints(self, cursor, table_name):\n         \"\"\"\n-        Retrieves any constraints (unique, pk, fk, check) across one or more columns.\n-        Returns {'cnname': {'columns': set(columns), 'primary_key': bool, 'unique': bool, 'foreign_key': None|(tbl, col)}}\n+        Retrieves any constraints or keys (unique, pk, fk, check, index) across one or more columns.\n         \"\"\"\n         constraints = {}\n         # Get the actual constraint names and columns\n@@ -124,6 +123,8 @@ def get_constraints(self, cursor, table_name):\n                     'columns': set(),\n                     'primary_key': False,\n                     'unique': False,\n+                    'index': False,\n+                    'check': False,\n                     'foreign_key': (ref_table, ref_column) if ref_column else None,\n                 }\n             constraints[constraint]['columns'].add(column)\n@@ -142,5 +143,19 @@ def get_constraints(self, cursor, table_name):\n                 constraints[constraint]['unique'] = True\n             elif kind.lower() == \"unique\":\n                 constraints[constraint]['unique'] = True\n+        # Now add in the indexes\n+        cursor.execute(\"SHOW INDEX FROM %s\" % self.connection.ops.quote_name(table_name))\n+        for table, non_unique, index, colseq, column in [x[:5] for x in cursor.fetchall()]:\n+            if index not in constraints:\n+                constraints[index] = {\n+                    'columns': set(),\n+                    'primary_key': False,\n+                    'unique': False,\n+                    'index': True,\n+                    'check': False,\n+                    'foreign_key': None,\n+                }\n+            constraints[index]['index'] = True\n+            constraints[index]['columns'].add(column)\n         # Return\n         return constraints"
        },
        {
            "sha": "c5c2e5cf1fd7d3719f822a08a98cc2ed122d40a0",
            "filename": "django/db/backends/mysql/schema.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/d865503389c7ebc1341f5b8f993858505289c6cd/django%2Fdb%2Fbackends%2Fmysql%2Fschema.py",
            "raw_url": "https://github.com/django/django/raw/d865503389c7ebc1341f5b8f993858505289c6cd/django%2Fdb%2Fbackends%2Fmysql%2Fschema.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fschema.py?ref=d865503389c7ebc1341f5b8f993858505289c6cd",
            "patch": "@@ -15,7 +15,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n     sql_create_fk = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) REFERENCES %(to_table)s (%(to_column)s)\"\n     sql_delete_fk = \"ALTER TABLE %(table)s DROP FOREIGN KEY %(name)s\"\n \n-    sql_delete_index = \"DROP INDEX %(name)s ON %(table_name)s\"\n+    sql_delete_index = \"DROP INDEX %(name)s ON %(table)s\"\n \n     sql_delete_pk = \"ALTER TABLE %(table)s DROP PRIMARY KEY\"\n "
        },
        {
            "sha": "1a08984bd29e8a35a4d379d05ef2576c53309725",
            "filename": "django/db/backends/postgresql_psycopg2/introspection.py",
            "status": "modified",
            "additions": 81,
            "deletions": 26,
            "changes": 107,
            "blob_url": "https://github.com/django/django/blob/d865503389c7ebc1341f5b8f993858505289c6cd/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fintrospection.py",
            "raw_url": "https://github.com/django/django/raw/d865503389c7ebc1341f5b8f993858505289c6cd/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fintrospection.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fintrospection.py?ref=d865503389c7ebc1341f5b8f993858505289c6cd",
            "patch": "@@ -91,32 +91,87 @@ def get_indexes(self, cursor, table_name):\n \n     def get_constraints(self, cursor, table_name):\n         \"\"\"\n-        Retrieves any constraints (unique, pk, fk, check) across one or more columns.\n-        Returns {'cnname': {'columns': set(columns), 'primary_key': bool, 'unique': bool}}\n+        Retrieves any constraints or keys (unique, pk, fk, check, index) across one or more columns.\n         \"\"\"\n         constraints = {}\n-        # Loop over the constraint tables, collecting things as constraints\n-        ifsc_tables = [\"constraint_column_usage\", \"key_column_usage\"]\n-        for ifsc_table in ifsc_tables:\n-            cursor.execute(\"\"\"\n-                SELECT kc.constraint_name, kc.column_name, c.constraint_type\n-                FROM information_schema.%s AS kc\n-                JOIN information_schema.table_constraints AS c ON\n-                    kc.table_schema = c.table_schema AND\n-                    kc.table_name = c.table_name AND\n-                    kc.constraint_name = c.constraint_name\n-                WHERE\n-                    kc.table_schema = %%s AND\n-                    kc.table_name = %%s\n-            \"\"\" % ifsc_table, [\"public\", table_name])\n-            for constraint, column, kind in cursor.fetchall():\n-                # If we're the first column, make the record\n-                if constraint not in constraints:\n-                    constraints[constraint] = {\n-                        \"columns\": set(),\n-                        \"primary_key\": kind.lower() == \"primary key\",\n-                        \"unique\": kind.lower() in [\"primary key\", \"unique\"],\n-                    }\n-                # Record the details\n-                constraints[constraint]['columns'].add(column)\n+        # Loop over the key table, collecting things as constraints\n+        # This will get PKs, FKs, and uniques, but not CHECK\n+        cursor.execute(\"\"\"\n+            SELECT\n+                kc.constraint_name,\n+                kc.column_name,\n+                c.constraint_type,\n+                array(SELECT table_name::text || '.' || column_name::text FROM information_schema.constraint_column_usage WHERE constraint_name = kc.constraint_name)\n+            FROM information_schema.key_column_usage AS kc\n+            JOIN information_schema.table_constraints AS c ON\n+                kc.table_schema = c.table_schema AND\n+                kc.table_name = c.table_name AND\n+                kc.constraint_name = c.constraint_name\n+            WHERE\n+                kc.table_schema = %s AND\n+                kc.table_name = %s\n+        \"\"\", [\"public\", table_name])\n+        for constraint, column, kind, used_cols in cursor.fetchall():\n+            # If we're the first column, make the record\n+            if constraint not in constraints:\n+                constraints[constraint] = {\n+                    \"columns\": set(),\n+                    \"primary_key\": kind.lower() == \"primary key\",\n+                    \"unique\": kind.lower() in [\"primary key\", \"unique\"],\n+                    \"foreign_key\": set([tuple(x.split(\".\", 1)) for x in used_cols]) if kind.lower() == \"foreign key\" else None,\n+                    \"check\": False,\n+                    \"index\": False,\n+                }\n+            # Record the details\n+            constraints[constraint]['columns'].add(column)\n+        # Now get CHECK constraint columns\n+        cursor.execute(\"\"\"\n+            SELECT kc.constraint_name, kc.column_name\n+            FROM information_schema.constraint_column_usage AS kc\n+            JOIN information_schema.table_constraints AS c ON\n+                kc.table_schema = c.table_schema AND\n+                kc.table_name = c.table_name AND\n+                kc.constraint_name = c.constraint_name\n+            WHERE\n+                c.constraint_type = 'CHECK' AND\n+                kc.table_schema = %s AND\n+                kc.table_name = %s\n+        \"\"\", [\"public\", table_name])\n+        for constraint, column, kind in cursor.fetchall():\n+            # If we're the first column, make the record\n+            if constraint not in constraints:\n+                constraints[constraint] = {\n+                    \"columns\": set(),\n+                    \"primary_key\": False,\n+                    \"unique\": False,\n+                    \"foreign_key\": False,\n+                    \"check\": True,\n+                    \"index\": False,\n+                }\n+            # Record the details\n+            constraints[constraint]['columns'].add(column)\n+        # Now get indexes\n+        cursor.execute(\"\"\"\n+            SELECT c2.relname, attr.attname, idx.indkey, idx.indisunique, idx.indisprimary\n+            FROM pg_catalog.pg_class c, pg_catalog.pg_class c2,\n+                pg_catalog.pg_index idx, pg_catalog.pg_attribute attr\n+            WHERE c.oid = idx.indrelid\n+                AND idx.indexrelid = c2.oid\n+                AND attr.attrelid = c.oid\n+                AND attr.attnum = idx.indkey[0]\n+                AND c.relname = %s\n+        \"\"\", [table_name])\n+        for index, column, coli, unique, primary in cursor.fetchall():\n+            # If we're the first column, make the record\n+            if index not in constraints:\n+                constraints[index] = {\n+                    \"columns\": set(),\n+                    \"primary_key\": False,\n+                    \"unique\": False,\n+                    \"foreign_key\": False,\n+                    \"check\": False,\n+                    \"index\": True,\n+                }\n+            # Record the details\n+            constraints[index]['columns'].add(column)\n         return constraints"
        },
        {
            "sha": "88fc4b7e624bfd7710e0f06f478bde9d87817c80",
            "filename": "django/db/backends/schema.py",
            "status": "modified",
            "additions": 41,
            "deletions": 11,
            "changes": 52,
            "blob_url": "https://github.com/django/django/blob/d865503389c7ebc1341f5b8f993858505289c6cd/django%2Fdb%2Fbackends%2Fschema.py",
            "raw_url": "https://github.com/django/django/raw/d865503389c7ebc1341f5b8f993858505289c6cd/django%2Fdb%2Fbackends%2Fschema.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fschema.py?ref=d865503389c7ebc1341f5b8f993858505289c6cd",
            "patch": "@@ -54,7 +54,7 @@ class BaseDatabaseSchemaEditor(object):\n     sql_create_fk = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n     sql_delete_fk = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n \n-    sql_create_index = \"CREATE %(unique)s INDEX %(name)s ON %(table)s (%(columns)s)%(extra)s;\"\n+    sql_create_index = \"CREATE INDEX %(name)s ON %(table)s (%(columns)s)%(extra)s;\"\n     sql_delete_index = \"DROP INDEX %(name)s\"\n \n     sql_create_pk = \"ALTER TABLE %(table)s ADD CONSTRAINT %(constraint)s PRIMARY KEY (%(columns)s)\"\n@@ -181,7 +181,6 @@ def create_model(self, model):\n             if field.db_index:\n                 self.deferred_sql.append(\n                     self.sql_create_index % {\n-                        \"unique\": \"\",\n                         \"name\": self._create_index_name(model, [field.column], suffix=\"\"),\n                         \"table\": self.quote_name(model._meta.db_table),\n                         \"columns\": self.quote_name(field.column),\n@@ -350,12 +349,13 @@ def delete_field(self, model, field):\n         }\n         self.execute(sql)\n \n-    def alter_field(self, model, old_field, new_field):\n+    def alter_field(self, model, old_field, new_field, strict=False):\n         \"\"\"\n         Allows a field's type, uniqueness, nullability, default, column,\n         constraints etc. to be modified.\n         Requires a copy of the old field as well so we can only perform\n         changes that are required.\n+        If strict is true, raises errors if the old column does not match old_field precisely.\n         \"\"\"\n         # Ensure this field is even column-based\n         old_type = old_field.db_type(connection=self.connection)\n@@ -372,18 +372,36 @@ def alter_field(self, model, old_field, new_field):\n         if old_field.unique and not new_field.unique:\n             # Find the unique constraint for this field\n             constraint_names = self._constraint_names(model, [old_field.column], unique=True)\n-            if len(constraint_names) != 1:\n+            if strict and len(constraint_names) != 1:\n                 raise ValueError(\"Found wrong number (%s) of constraints for %s.%s\" % (\n                     len(constraint_names),\n                     model._meta.db_table,\n                     old_field.column,\n                 ))\n-            self.execute(\n-                self.sql_delete_unique % {\n-                    \"table\": self.quote_name(model._meta.db_table),\n-                    \"name\": constraint_names[0],\n-                },\n-            )\n+            for constraint_name in constraint_names:\n+                self.execute(\n+                    self.sql_delete_unique % {\n+                        \"table\": self.quote_name(model._meta.db_table),\n+                        \"name\": constraint_name,\n+                    },\n+                )\n+        # Removed an index?\n+        if old_field.db_index and not new_field.db_index and not old_field.unique and not new_field.unique:\n+            # Find the index for this field\n+            index_names = self._constraint_names(model, [old_field.column], index=True)\n+            if strict and len(index_names) != 1:\n+                raise ValueError(\"Found wrong number (%s) of indexes for %s.%s\" % (\n+                    len(index_names),\n+                    model._meta.db_table,\n+                    old_field.column,\n+                ))\n+            for index_name in index_names:\n+                self.execute(\n+                    self.sql_delete_index % {\n+                        \"table\": self.quote_name(model._meta.db_table),\n+                        \"name\": index_name,\n+                    }\n+                )\n         # Have they renamed the column?\n         if old_field.column != new_field.column:\n             self.execute(self.sql_rename_column % {\n@@ -463,6 +481,16 @@ def alter_field(self, model, old_field, new_field):\n                     \"columns\": self.quote_name(new_field.column),\n                 }\n             )\n+        # Added an index?\n+        if not old_field.db_index and new_field.db_index and not old_field.unique and not new_field.unique:\n+            self.execute(\n+                self.sql_create_index % {\n+                    \"table\": self.quote_name(model._meta.db_table),\n+                    \"name\": self._create_index_name(model, [new_field.column], suffix=\"_uniq\"),\n+                    \"columns\": self.quote_name(new_field.column),\n+                    \"extra\": \"\",\n+                }\n+            )\n \n     def _type_for_alter(self, field):\n         \"\"\"\n@@ -490,7 +518,7 @@ def _create_index_name(self, model, column_names, suffix=\"\"):\n             index_name = '%s%s' % (table_name[:(self.connection.features.max_index_name_length - len(part))], part)\n         return index_name\n \n-    def _constraint_names(self, model, column_names, unique=None, primary_key=None):\n+    def _constraint_names(self, model, column_names, unique=None, primary_key=None, index=None):\n         \"Returns all constraint names matching the columns and conditions\"\n         column_names = set(column_names)\n         constraints = self.connection.introspection.get_constraints(self.connection.cursor(), model._meta.db_table)\n@@ -501,5 +529,7 @@ def _constraint_names(self, model, column_names, unique=None, primary_key=None):\n                     continue\n                 if primary_key is not None and infodict['primary_key'] != unique:\n                     continue\n+                if index is not None and infodict['index'] != index:\n+                    continue\n                 result.append(name)\n         return result"
        },
        {
            "sha": "9d0a8a2074f88e3065194ef11b209f9f2a8929ba",
            "filename": "tests/modeltests/schema/models.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/d865503389c7ebc1341f5b8f993858505289c6cd/tests%2Fmodeltests%2Fschema%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/d865503389c7ebc1341f5b8f993858505289c6cd/tests%2Fmodeltests%2Fschema%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fschema%2Fmodels.py?ref=d865503389c7ebc1341f5b8f993858505289c6cd",
            "patch": "@@ -21,7 +21,7 @@ class Meta:\n \n class Book(models.Model):\n     author = models.ForeignKey(Author)\n-    title = models.CharField(max_length=100)\n+    title = models.CharField(max_length=100, db_index=True)\n     pub_date = models.DateTimeField()\n     #tags = models.ManyToManyField(\"Tag\", related_name=\"books\")\n "
        },
        {
            "sha": "6ef24ca11ea0940b63d4dc838c69c669d3deedd0",
            "filename": "tests/modeltests/schema/tests.py",
            "status": "modified",
            "additions": 84,
            "deletions": 1,
            "changes": 85,
            "blob_url": "https://github.com/django/django/blob/d865503389c7ebc1341f5b8f993858505289c6cd/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/d865503389c7ebc1341f5b8f993858505289c6cd/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fschema%2Ftests.py?ref=d865503389c7ebc1341f5b8f993858505289c6cd",
            "patch": "@@ -179,7 +179,8 @@ def test_alter(self):\n             Author,\n             Author._meta.get_field_by_name(\"name\")[0],\n             new_field,\n-        )\n+            strict=True,\n+          )\n         editor.commit()\n         # Ensure the field is right afterwards\n         columns = self.column_classes(Author)\n@@ -208,6 +209,7 @@ def test_rename(self):\n             Author,\n             Author._meta.get_field_by_name(\"name\")[0],\n             new_field,\n+            strict = True,\n         )\n         editor.commit()\n         # Ensure the field is right afterwards\n@@ -276,6 +278,7 @@ def test_unique(self):\n             Tag,\n             Tag._meta.get_field_by_name(\"slug\")[0],\n             new_field,\n+            strict = True,\n         )\n         editor.commit()\n         # Ensure the field is no longer unique\n@@ -291,6 +294,7 @@ def test_unique(self):\n             Tag,\n             new_field,\n             new_new_field,\n+            strict = True,\n         )\n         editor.commit()\n         # Ensure the field is unique again\n@@ -306,6 +310,7 @@ def test_unique(self):\n             Tag,\n             Tag._meta.get_field_by_name(\"slug\")[0],\n             TagUniqueRename._meta.get_field_by_name(\"slug2\")[0],\n+            strict = True,\n         )\n         editor.commit()\n         # Ensure the field is still unique\n@@ -395,3 +400,81 @@ def test_db_table(self):\n         Author._meta.db_table = \"schema_author\"\n         columns = self.column_classes(Author)\n         self.assertEqual(columns['name'][0], \"CharField\")\n+\n+    def test_indexes(self):\n+        \"\"\"\n+        Tests creation/altering of indexes\n+        \"\"\"\n+        # Create the table\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.create_model(Author)\n+        editor.create_model(Book)\n+        editor.commit()\n+        # Ensure the table is there and has the right index\n+        self.assertIn(\n+            \"title\",\n+            connection.introspection.get_indexes(connection.cursor(), Book._meta.db_table),\n+        )\n+        # Alter to remove the index\n+        new_field = CharField(max_length=100, db_index=False)\n+        new_field.set_attributes_from_name(\"title\")\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.alter_field(\n+            Book,\n+            Book._meta.get_field_by_name(\"title\")[0],\n+            new_field,\n+            strict = True,\n+        )\n+        editor.commit()\n+        # Ensure the table is there and has no index\n+        self.assertNotIn(\n+            \"title\",\n+            connection.introspection.get_indexes(connection.cursor(), Book._meta.db_table),\n+        )\n+        # Alter to re-add the index\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.alter_field(\n+            Book,\n+            new_field,\n+            Book._meta.get_field_by_name(\"title\")[0],\n+            strict = True,\n+        )\n+        editor.commit()\n+        # Ensure the table is there and has the index again\n+        self.assertIn(\n+            \"title\",\n+            connection.introspection.get_indexes(connection.cursor(), Book._meta.db_table),\n+        )\n+        # Add a unique column, verify that creates an implicit index\n+        new_field = CharField(max_length=20, unique=True)\n+        new_field.set_attributes_from_name(\"slug\")\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.create_field(\n+            Book,\n+            new_field,\n+        )\n+        editor.commit()\n+        self.assertIn(\n+            \"slug\",\n+            connection.introspection.get_indexes(connection.cursor(), Book._meta.db_table),\n+        )\n+        # Remove the unique, check the index goes with it\n+        new_field2 = CharField(max_length=20, unique=False)\n+        new_field2.set_attributes_from_name(\"slug\")\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.alter_field(\n+            Book,\n+            new_field,\n+            new_field2,\n+            strict = True,\n+        )\n+        editor.commit()\n+        self.assertNotIn(\n+            \"slug\",\n+            connection.introspection.get_indexes(connection.cursor(), Book._meta.db_table),\n+        )"
        }
    ],
    "stats": {
        "total": 267,
        "additions": 225,
        "deletions": 42
    }
}