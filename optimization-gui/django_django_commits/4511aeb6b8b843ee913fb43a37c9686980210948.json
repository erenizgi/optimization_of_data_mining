{
    "author": "akaariai",
    "message": "Moved join path generation to Field\n\nRefs #19385",
    "sha": "4511aeb6b8b843ee913fb43a37c9686980210948",
    "files": [
        {
            "sha": "be7a5e5a2258c0a1eb720bc4926fe9a5339c1d8f",
            "filename": "django/contrib/contenttypes/generic.py",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/4511aeb6b8b843ee913fb43a37c9686980210948/django%2Fcontrib%2Fcontenttypes%2Fgeneric.py",
            "raw_url": "https://github.com/django/django/raw/4511aeb6b8b843ee913fb43a37c9686980210948/django%2Fcontrib%2Fcontenttypes%2Fgeneric.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fcontenttypes%2Fgeneric.py?ref=4511aeb6b8b843ee913fb43a37c9686980210948",
            "patch": "@@ -11,6 +11,7 @@\n from django.db.models import signals\n from django.db import models, router, DEFAULT_DB_ALIAS\n from django.db.models.fields.related import RelatedField, Field, ManyToManyRel\n+from django.db.models.related import PathInfo\n from django.forms import ModelForm\n from django.forms.models import BaseModelFormSet, modelformset_factory, save_instance\n from django.contrib.admin.options import InlineModelAdmin, flatten_fieldsets\n@@ -160,6 +161,16 @@ def __init__(self, to, **kwargs):\n         kwargs['serialize'] = False\n         Field.__init__(self, **kwargs)\n \n+    def get_path_info(self):\n+        from_field = self.model._meta.pk\n+        opts = self.rel.to._meta\n+        target = opts.get_field_by_name(self.object_id_field_name)[0]\n+        # Note that we are using different field for the join_field\n+        # than from_field or to_field. This is a hack, but we need the\n+        # GenericRelation to generate the extra SQL.\n+        return ([PathInfo(from_field, target, self.model._meta, opts, self, True, False)],\n+                opts, target, self)\n+\n     def get_choices_default(self):\n         return Field.get_choices(self, include_blank=False)\n "
        },
        {
            "sha": "4b6a5b0aed9fe482e9e0c6d41b755bf840b5e80b",
            "filename": "django/db/models/fields/related.py",
            "status": "modified",
            "additions": 50,
            "deletions": 2,
            "changes": 52,
            "blob_url": "https://github.com/django/django/blob/4511aeb6b8b843ee913fb43a37c9686980210948/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "raw_url": "https://github.com/django/django/raw/4511aeb6b8b843ee913fb43a37c9686980210948/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2Frelated.py?ref=4511aeb6b8b843ee913fb43a37c9686980210948",
            "patch": "@@ -5,7 +5,7 @@\n from django.db.models import signals, get_model\n from django.db.models.fields import (AutoField, Field, IntegerField,\n     PositiveIntegerField, PositiveSmallIntegerField, FieldDoesNotExist)\n-from django.db.models.related import RelatedObject\n+from django.db.models.related import RelatedObject, PathInfo\n from django.db.models.query import QuerySet\n from django.db.models.query_utils import QueryWrapper\n from django.db.models.deletion import CASCADE\n@@ -16,7 +16,6 @@\n from django.core import exceptions\n from django import forms\n \n-\n RECURSIVE_RELATIONSHIP_CONSTANT = 'self'\n \n pending_lookups = {}\n@@ -1004,6 +1003,31 @@ def __init__(self, to, to_field=None, rel_class=ManyToOneRel, **kwargs):\n         )\n         Field.__init__(self, **kwargs)\n \n+    def get_path_info(self):\n+        \"\"\"\n+        Get path from this field to the related model.\n+        \"\"\"\n+        opts = self.rel.to._meta\n+        target = self.rel.get_related_field()\n+        from_opts = self.model._meta\n+        return [PathInfo(self, target, from_opts, opts, self, False, True)], opts, target, self\n+\n+    def get_reverse_path_info(self):\n+        \"\"\"\n+        Get path from the related model to this field's model.\n+        \"\"\"\n+        opts = self.model._meta\n+        from_field = self.rel.get_related_field()\n+        from_opts = from_field.model._meta\n+        pathinfos = [PathInfo(from_field, self, from_opts, opts, self, not self.unique, False)]\n+        if from_field.model is self.model:\n+            # Recursive foreign key to self.\n+            target = opts.get_field_by_name(\n+                self.rel.field_name)[0]\n+        else:\n+            target = opts.pk\n+        return pathinfos, opts, target, self\n+\n     def validate(self, value, model_instance):\n         if self.rel.parent_link:\n             return\n@@ -1198,6 +1222,30 @@ def __init__(self, to, **kwargs):\n         msg = _('Hold down \"Control\", or \"Command\" on a Mac, to select more than one.')\n         self.help_text = string_concat(self.help_text, ' ', msg)\n \n+    def _get_path_info(self, direct=False):\n+        \"\"\"\n+        Called by both direct an indirect m2m traversal.\n+        \"\"\"\n+        pathinfos = []\n+        int_model = self.rel.through\n+        linkfield1 = int_model._meta.get_field_by_name(self.m2m_field_name())[0]\n+        linkfield2 = int_model._meta.get_field_by_name(self.m2m_reverse_field_name())[0]\n+        if direct:\n+            join1infos, _, _, _ = linkfield1.get_reverse_path_info()\n+            join2infos, opts, target, final_field = linkfield2.get_path_info()\n+        else:\n+            join1infos, _, _, _ = linkfield2.get_reverse_path_info()\n+            join2infos, opts, target, final_field = linkfield1.get_path_info()\n+        pathinfos.extend(join1infos)\n+        pathinfos.extend(join2infos)\n+        return pathinfos, opts, target, final_field\n+\n+    def get_path_info(self):\n+        return self._get_path_info(direct=True)\n+\n+    def get_reverse_path_info(self):\n+        return self._get_path_info(direct=False)\n+\n     def get_choices_default(self):\n         return Field.get_choices(self, include_blank=False)\n "
        },
        {
            "sha": "702853533dee43dfb877d071c34bdd0ba47d5bca",
            "filename": "django/db/models/related.py",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/4511aeb6b8b843ee913fb43a37c9686980210948/django%2Fdb%2Fmodels%2Frelated.py",
            "raw_url": "https://github.com/django/django/raw/4511aeb6b8b843ee913fb43a37c9686980210948/django%2Fdb%2Fmodels%2Frelated.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Frelated.py?ref=4511aeb6b8b843ee913fb43a37c9686980210948",
            "patch": "@@ -1,6 +1,15 @@\n+from collections import namedtuple\n+\n from django.utils.encoding import smart_text\n from django.db.models.fields import BLANK_CHOICE_DASH\n \n+# PathInfo is used when converting lookups (fk__somecol). The contents\n+# describe the relation in Model terms (model Options and Fields for both\n+# sides of the relation. The join_field is the field backing the relation.\n+PathInfo = namedtuple('PathInfo',\n+                      'from_field to_field from_opts to_opts join_field '\n+                      'm2m direct')\n+\n class BoundRelatedObject(object):\n     def __init__(self, related_object, field_mapping, original):\n         self.relation = related_object\n@@ -67,3 +76,6 @@ def get_accessor_name(self):\n \n     def get_cache_name(self):\n         return \"_%s_cache\" % self.get_accessor_name()\n+\n+    def get_path_info(self):\n+        return self.field.get_reverse_path_info()"
        },
        {
            "sha": "1764db7fcc826a73bc3197507f22833f43c7bbbe",
            "filename": "django/db/models/sql/constants.py",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/4511aeb6b8b843ee913fb43a37c9686980210948/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py",
            "raw_url": "https://github.com/django/django/raw/4511aeb6b8b843ee913fb43a37c9686980210948/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py?ref=4511aeb6b8b843ee913fb43a37c9686980210948",
            "patch": "@@ -26,12 +26,6 @@\n                       'table_name rhs_alias join_type lhs_alias '\n                       'lhs_join_col rhs_join_col nullable join_field')\n \n-# PathInfo is used when converting lookups (fk__somecol). The contents\n-# describe the join in Model terms (model Options and Fields for both\n-# sides of the join. The rel_field is the field we are joining along.\n-PathInfo = namedtuple('PathInfo',\n-                      'from_field to_field from_opts to_opts join_field')\n-\n # Pairs of column clauses to select, and (possibly None) field for the clause.\n SelectInfo = namedtuple('SelectInfo', 'col field')\n "
        },
        {
            "sha": "e5833b2b51ef0a1c88d9c32edc59237ed3f17f80",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 18,
            "deletions": 92,
            "changes": 110,
            "blob_url": "https://github.com/django/django/blob/4511aeb6b8b843ee913fb43a37c9686980210948/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/4511aeb6b8b843ee913fb43a37c9686980210948/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=4511aeb6b8b843ee913fb43a37c9686980210948",
            "patch": "@@ -18,9 +18,10 @@\n from django.db.models.expressions import ExpressionNode\n from django.db.models.fields import FieldDoesNotExist\n from django.db.models.loading import get_model\n+from django.db.models.related import PathInfo\n from django.db.models.sql import aggregates as base_aggregates_module\n from django.db.models.sql.constants import (QUERY_TERMS, ORDER_DIR, SINGLE,\n-        ORDER_PATTERN, JoinInfo, SelectInfo, PathInfo)\n+        ORDER_PATTERN, JoinInfo, SelectInfo)\n from django.db.models.sql.datastructures import EmptyResultSet, Empty, MultiJoin\n from django.db.models.sql.expressions import SQLEvaluator\n from django.db.models.sql.where import (WhereNode, Constraint, EverythingNode,\n@@ -1294,7 +1295,6 @@ def names_to_path(self, names, opts, allow_many=False,\n         contain the same value as the final field).\n         \"\"\"\n         path = []\n-        multijoin_pos = None\n         for pos, name in enumerate(names):\n             if name == 'pk':\n                 name = opts.pk.name\n@@ -1328,92 +1328,19 @@ def names_to_path(self, names, opts, allow_many=False,\n                         target = final_field.rel.get_related_field()\n                         opts = int_model._meta\n                         path.append(PathInfo(final_field, target, final_field.model._meta,\n-                                             opts, final_field))\n-            # We have five different cases to solve: foreign keys, reverse\n-            # foreign keys, m2m fields (also reverse) and non-relational\n-            # fields. We are mostly just using the related field API to\n-            # fetch the from and to fields. The m2m fields are handled as\n-            # two foreign keys, first one reverse, the second one direct.\n-            if direct and not field.rel and not m2m:\n+                                             opts, final_field, False, True))\n+            if hasattr(field, 'get_path_info'):\n+                pathinfos, opts, target, final_field = field.get_path_info()\n+                path.extend(pathinfos)\n+            else:\n                 # Local non-relational field.\n                 final_field = target = field\n                 break\n-            elif direct and not m2m:\n-                # Foreign Key\n-                opts = field.rel.to._meta\n-                target = field.rel.get_related_field()\n-                final_field = field\n-                from_opts = field.model._meta\n-                path.append(PathInfo(field, target, from_opts, opts, field))\n-            elif not direct and not m2m:\n-                # Revere foreign key\n-                final_field = to_field = field.field\n-                opts = to_field.model._meta\n-                from_field = to_field.rel.get_related_field()\n-                from_opts = from_field.model._meta\n-                path.append(\n-                    PathInfo(from_field, to_field, from_opts, opts, to_field))\n-                if from_field.model is to_field.model:\n-                    # Recursive foreign key to self.\n-                    target = opts.get_field_by_name(\n-                        field.field.rel.field_name)[0]\n-                else:\n-                    target = opts.pk\n-            elif direct and m2m:\n-                if not field.rel.through:\n-                    # Gotcha! This is just a fake m2m field - a generic relation\n-                    # field).\n-                    from_field = opts.pk\n-                    opts = field.rel.to._meta\n-                    target = opts.get_field_by_name(field.object_id_field_name)[0]\n-                    final_field = field\n-                    # Note that we are using different field for the join_field\n-                    # than from_field or to_field. This is a hack, but we need the\n-                    # GenericRelation to generate the extra SQL.\n-                    path.append(PathInfo(from_field, target, field.model._meta, opts,\n-                                         field))\n-                else:\n-                    # m2m field. We are travelling first to the m2m table along a\n-                    # reverse relation, then from m2m table to the target table.\n-                    from_field1 = opts.get_field_by_name(\n-                        field.m2m_target_field_name())[0]\n-                    opts = field.rel.through._meta\n-                    to_field1 = opts.get_field_by_name(field.m2m_field_name())[0]\n-                    path.append(\n-                        PathInfo(from_field1, to_field1, from_field1.model._meta,\n-                                 opts, to_field1))\n-                    final_field = from_field2 = opts.get_field_by_name(\n-                        field.m2m_reverse_field_name())[0]\n-                    opts = field.rel.to._meta\n-                    target = to_field2 = opts.get_field_by_name(\n-                        field.m2m_reverse_target_field_name())[0]\n-                    path.append(\n-                        PathInfo(from_field2, to_field2, from_field2.model._meta,\n-                                 opts, from_field2))\n-            elif not direct and m2m:\n-                # This one is just like above, except we are travelling the\n-                # fields in opposite direction.\n-                field = field.field\n-                from_field1 = opts.get_field_by_name(\n-                    field.m2m_reverse_target_field_name())[0]\n-                int_opts = field.rel.through._meta\n-                to_field1 = int_opts.get_field_by_name(\n-                    field.m2m_reverse_field_name())[0]\n-                path.append(\n-                    PathInfo(from_field1, to_field1, from_field1.model._meta,\n-                             int_opts, to_field1))\n-                final_field = from_field2 = int_opts.get_field_by_name(\n-                    field.m2m_field_name())[0]\n-                opts = field.opts\n-                target = to_field2 = opts.get_field_by_name(\n-                    field.m2m_target_field_name())[0]\n-                path.append(PathInfo(from_field2, to_field2, from_field2.model._meta,\n-                                     opts, from_field2))\n-\n-            if m2m and multijoin_pos is None:\n-                multijoin_pos = pos\n-            if not direct and not path[-1].to_field.unique and multijoin_pos is None:\n-                multijoin_pos = pos\n+        multijoin_pos = None\n+        for m2mpos, pathinfo in enumerate(path):\n+            if pathinfo.m2m:\n+                multijoin_pos = m2mpos\n+                break\n \n         if pos != len(names) - 1:\n             if pos == len(names) - 2:\n@@ -1463,16 +1390,15 @@ def setup_joins(self, names, opts, alias, can_reuse=None, allow_many=True,\n         # joins at this stage - we will need the information about join type\n         # of the trimmed joins.\n         for pos, join in enumerate(path):\n-            from_field, to_field, from_opts, opts, join_field = join\n-            direct = join_field == from_field\n-            if direct:\n-                nullable = self.is_nullable(from_field)\n+            opts = join.to_opts\n+            if join.direct:\n+                nullable = self.is_nullable(join.from_field)\n             else:\n                 nullable = True\n-            connection = alias, opts.db_table, from_field.column, to_field.column\n-            reuse = None if direct or to_field.unique else can_reuse\n+            connection = alias, opts.db_table, join.from_field.column, join.to_field.column\n+            reuse = can_reuse if join.m2m else None\n             alias = self.join(connection, reuse=reuse,\n-                              nullable=nullable, join_field=join_field)\n+                              nullable=nullable, join_field=join.join_field)\n             joins.append(alias)\n         return final_field, target, opts, joins, path\n "
        }
    ],
    "stats": {
        "total": 191,
        "additions": 91,
        "deletions": 100
    }
}