{
    "author": "spookylukey",
    "message": "Fixed #14270 - related manager classes should be cached\n\nThanks to Alex Gaynor for the report and initial patch, and mrmachine for\nmore work on it.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16916 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "5009e45dfe366ebf520eecb49d72d5a11cee1623",
    "files": [
        {
            "sha": "95c4cac25303cf86414cf7f6f439838913a58d7e",
            "filename": "django/db/models/fields/related.py",
            "status": "modified",
            "additions": 50,
            "deletions": 39,
            "changes": 89,
            "blob_url": "https://github.com/django/django/blob/5009e45dfe366ebf520eecb49d72d5a11cee1623/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "raw_url": "https://github.com/django/django/raw/5009e45dfe366ebf520eecb49d72d5a11cee1623/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2Frelated.py?ref=5009e45dfe366ebf520eecb49d72d5a11cee1623",
            "patch": "@@ -9,7 +9,7 @@\n from django.db.models.deletion import CASCADE\n from django.utils.encoding import smart_unicode\n from django.utils.translation import ugettext_lazy as _, string_concat\n-from django.utils.functional import curry\n+from django.utils.functional import curry, memoize, cached_property\n from django.core import exceptions\n from django import forms\n \n@@ -386,8 +386,8 @@ def __get__(self, instance, instance_type=None):\n         if instance is None:\n             return self\n \n-        return self.create_manager(instance,\n-                self.related.model._default_manager.__class__)\n+        manager = self.create_manager(self.related.model._default_manager.__class__)\n+        return manager(instance)\n \n     def __set__(self, instance, value):\n         if instance is None:\n@@ -406,22 +406,30 @@ def delete_manager(self, instance):\n         than the default manager, as returned by __get__). Used by\n         Model.delete().\n         \"\"\"\n-        return self.create_manager(instance,\n-                self.related.model._base_manager.__class__)\n+        manager = self.create_manager(self.related.model._base_manager.__class__)\n+        return manager(instance)\n \n-    def create_manager(self, instance, superclass):\n+    def create_manager(self, superclass):\n         \"\"\"\n         Creates the managers used by other methods (__get__() and delete()).\n         \"\"\"\n+\n+        # We use closures for these values so that we only need to memoize this\n+        # function on the one argument of 'superclass', and the two places that\n+        # call create_manager simply need to pass instance to the manager\n+        # __init__\n         rel_field = self.related.field\n+        rel_model = self.related.model\n+        attname = rel_field.rel.get_related_field().attname\n+\n         class RelatedManager(superclass):\n-            def __init__(self, model=None, core_filters=None, instance=None,\n-                         rel_field=None):\n+            def __init__(self, instance):\n                 super(RelatedManager, self).__init__()\n-                self.model = model\n-                self.core_filters = core_filters\n                 self.instance = instance\n-                self.rel_field = rel_field\n+                self.core_filters = {\n+                    '%s__%s' % (rel_field.name, attname): getattr(instance, attname)\n+                }\n+                self.model = rel_model\n \n             def get_query_set(self):\n                 db = self._db or router.db_for_read(self.model, instance=self.instance)\n@@ -431,48 +439,43 @@ def add(self, *objs):\n                 for obj in objs:\n                     if not isinstance(obj, self.model):\n                         raise TypeError(\"'%s' instance expected\" % self.model._meta.object_name)\n-                    setattr(obj, self.rel_field.name, self.instance)\n+                    setattr(obj, rel_field.name, self.instance)\n                     obj.save()\n             add.alters_data = True\n \n             def create(self, **kwargs):\n-                kwargs[self.rel_field.name] = self.instance\n+                kwargs[rel_field.name] = self.instance\n                 db = router.db_for_write(self.model, instance=self.instance)\n                 return super(RelatedManager, self.db_manager(db)).create(**kwargs)\n             create.alters_data = True\n \n             def get_or_create(self, **kwargs):\n                 # Update kwargs with the related object that this\n                 # ForeignRelatedObjectsDescriptor knows about.\n-                kwargs[self.rel_field.name] = self.instance\n+                kwargs[rel_field.name] = self.instance\n                 db = router.db_for_write(self.model, instance=self.instance)\n                 return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)\n             get_or_create.alters_data = True\n \n             # remove() and clear() are only provided if the ForeignKey can have a value of null.\n             if rel_field.null:\n                 def remove(self, *objs):\n-                    val = getattr(self.instance, self.rel_field.rel.get_related_field().attname)\n+                    val = getattr(self.instance, attname)\n                     for obj in objs:\n                         # Is obj actually part of this descriptor set?\n-                        if getattr(obj, self.rel_field.attname) == val:\n-                            setattr(obj, self.rel_field.name, None)\n+                        if getattr(obj, rel_field.attname) == val:\n+                            setattr(obj, rel_field.name, None)\n                             obj.save()\n                         else:\n-                            raise self.rel_field.rel.to.DoesNotExist(\"%r is not related to %r.\" % (obj, self.instance))\n+                            raise rel_field.rel.to.DoesNotExist(\"%r is not related to %r.\" % (obj, self.instance))\n                 remove.alters_data = True\n \n                 def clear(self):\n-                    self.update(**{self.rel_field.name: None})\n+                    self.update(**{rel_field.name: None})\n                 clear.alters_data = True\n \n-        attname = rel_field.rel.get_related_field().name\n-        return RelatedManager(model=self.related.model,\n-                              core_filters = {'%s__%s' % (rel_field.name, attname):\n-                                                  getattr(instance, attname)},\n-                              instance=instance,\n-                              rel_field=rel_field,\n-                              )\n+        return RelatedManager\n+    create_manager = memoize(create_manager, {}, 2)\n \n \n def create_many_related_manager(superclass, rel):\n@@ -663,17 +666,22 @@ class ManyRelatedObjectsDescriptor(object):\n     def __init__(self, related):\n         self.related = related   # RelatedObject instance\n \n+    @cached_property\n+    def related_manager_cls(self):\n+        # Dynamically create a class that subclasses the related\n+        # model's default manager.\n+        return create_many_related_manager(\n+            self.related.model._default_manager.__class__,\n+            self.related.field.rel\n+        )\n+\n     def __get__(self, instance, instance_type=None):\n         if instance is None:\n             return self\n \n-        # Dynamically create a class that subclasses the related\n-        # model's default manager.\n         rel_model = self.related.model\n-        superclass = rel_model._default_manager.__class__\n-        RelatedManager = create_many_related_manager(superclass, self.related.field.rel)\n \n-        manager = RelatedManager(\n+        manager = self.related_manager_cls(\n             model=rel_model,\n             core_filters={'%s__pk' % self.related.field.name: instance._get_pk_val()},\n             instance=instance,\n@@ -716,18 +724,21 @@ def through(self):\n         # a property to ensure that the fully resolved value is returned.\n         return self.field.rel.through\n \n+    @cached_property\n+    def related_manager_cls(self):\n+        # Dynamically create a class that subclasses the related model's\n+        # default manager.\n+        return create_many_related_manager(\n+            self.field.rel.to._default_manager.__class__,\n+            self.field.rel\n+        )\n+\n     def __get__(self, instance, instance_type=None):\n         if instance is None:\n             return self\n \n-        # Dynamically create a class that subclasses the related\n-        # model's default manager.\n-        rel_model=self.field.rel.to\n-        superclass = rel_model._default_manager.__class__\n-        RelatedManager = create_many_related_manager(superclass, self.field.rel)\n-\n-        manager = RelatedManager(\n-            model=rel_model,\n+        manager = self.related_manager_cls(\n+            model=self.field.rel.to,\n             core_filters={'%s__pk' % self.field.related_query_name(): instance._get_pk_val()},\n             instance=instance,\n             symmetrical=self.field.rel.symmetrical,"
        },
        {
            "sha": "67b727f0127b84cf366a27025bbda52855f1ed14",
            "filename": "django/utils/functional.py",
            "status": "modified",
            "additions": 13,
            "deletions": 1,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/5009e45dfe366ebf520eecb49d72d5a11cee1623/django%2Futils%2Ffunctional.py",
            "raw_url": "https://github.com/django/django/raw/5009e45dfe366ebf520eecb49d72d5a11cee1623/django%2Futils%2Ffunctional.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Ffunctional.py?ref=5009e45dfe366ebf520eecb49d72d5a11cee1623",
            "patch": "@@ -28,6 +28,18 @@ def wrapper(*args):\n         return result\n     return wrapper\n \n+class cached_property(object):\n+    \"\"\"\n+    Decorator that creates converts a method with a single\n+    self argument into a property cached on the instance.\n+    \"\"\"\n+    def __init__(self, func):\n+        self.func = func\n+\n+    def __get__(self, instance, type):\n+        res = instance.__dict__[self.func.__name__] = self.func(instance)\n+        return res\n+\n class Promise(object):\n     \"\"\"\n     This is just a base class for the proxy class created in\n@@ -288,4 +300,4 @@ def partition(predicate, values):\n     results = ([], [])\n     for item in values:\n         results[predicate(item)].append(item)\n-    return results\n\\ No newline at end of file\n+    return results"
        },
        {
            "sha": "4f561b40ca5d4a0671951102d5d9242a20c1a58c",
            "filename": "tests/modeltests/many_to_one/tests.py",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/5009e45dfe366ebf520eecb49d72d5a11cee1623/tests%2Fmodeltests%2Fmany_to_one%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/5009e45dfe366ebf520eecb49d72d5a11cee1623/tests%2Fmodeltests%2Fmany_to_one%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fmany_to_one%2Ftests.py?ref=5009e45dfe366ebf520eecb49d72d5a11cee1623",
            "patch": "@@ -399,3 +399,13 @@ def test_explicit_fk(self):\n         self.assertEqual(repr(a3),\n                          repr(Article.objects.get(reporter_id=self.r2.id,\n                                              pub_date=datetime(2011, 5, 7))))\n+\n+    def test_manager_class_caching(self):\n+        r1 = Reporter.objects.create(first_name='Mike')\n+        r2 = Reporter.objects.create(first_name='John')\n+\n+        # Same twice\n+        self.assertTrue(r1.article_set.__class__ is r1.article_set.__class__)\n+\n+        # Same as each other\n+        self.assertTrue(r1.article_set.__class__ is r2.article_set.__class__)"
        },
        {
            "sha": "9ae888a6ced7d1716524748a1a46fabb6a1a7d29",
            "filename": "tests/regressiontests/m2m_regress/tests.py",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/5009e45dfe366ebf520eecb49d72d5a11cee1623/tests%2Fregressiontests%2Fm2m_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/5009e45dfe366ebf520eecb49d72d5a11cee1623/tests%2Fregressiontests%2Fm2m_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fm2m_regress%2Ftests.py?ref=5009e45dfe366ebf520eecb49d72d5a11cee1623",
            "patch": "@@ -73,3 +73,17 @@ def test_add_m2m_with_base_class(self):\n \n         self.assertQuerysetEqual(c1.tags.all(), [\"<Tag: t1>\", \"<Tag: t2>\"])\n         self.assertQuerysetEqual(t1.tag_collections.all(), [\"<TagCollection: c1>\"])\n+\n+    def test_manager_class_caching(self):\n+        e1 = Entry.objects.create()\n+        e2 = Entry.objects.create()\n+        t1 = Tag.objects.create()\n+        t2 = Tag.objects.create()\n+\n+        # Get same manager twice in a row:\n+        self.assertTrue(t1.entry_set.__class__ is t1.entry_set.__class__)\n+        self.assertTrue(e1.topics.__class__ is e1.topics.__class__)\n+\n+        # Get same manager for different instances\n+        self.assertTrue(e1.topics.__class__ is e2.topics.__class__)\n+        self.assertTrue(t1.entry_set.__class__ is t2.entry_set.__class__)"
        }
    ],
    "stats": {
        "total": 127,
        "additions": 87,
        "deletions": 40
    }
}