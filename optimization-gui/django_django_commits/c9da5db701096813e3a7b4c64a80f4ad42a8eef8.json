{
    "author": "malcolmt",
    "message": "Fixed documentation about use of salt parameter in signing functions.\n\nFixes #16369.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16693 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "c9da5db701096813e3a7b4c64a80f4ad42a8eef8",
    "files": [
        {
            "sha": "9e3cb7a4c1721142d9bba278c12458d3a912d69b",
            "filename": "docs/topics/signing.txt",
            "status": "modified",
            "additions": 12,
            "deletions": 5,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/c9da5db701096813e3a7b4c64a80f4ad42a8eef8/docs%2Ftopics%2Fsigning.txt",
            "raw_url": "https://github.com/django/django/raw/c9da5db701096813e3a7b4c64a80f4ad42a8eef8/docs%2Ftopics%2Fsigning.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fsigning.txt?ref=c9da5db701096813e3a7b4c64a80f4ad42a8eef8",
            "patch": "@@ -78,11 +78,10 @@ generate signatures. You can use a different secret by passing it to the\n Using the salt argument\n -----------------------\n \n-If you do not wish to use the same key for every signing operation in your\n-application, you can use the optional ``salt`` argument to the ``Signer``\n-class to further strengthen your :setting:`SECRET_KEY` against brute force\n-attacks. Using a salt will cause a new key to be derived from both the salt\n-and your :setting:`SECRET_KEY`::\n+If you do not wish for every occurrence of a particular string to have the same\n+signature hash, you can use the optional ``salt`` argument to the ``Signer``\n+class. Using a salt will seed the signing hash function with both the salt and\n+your :setting:`SECRET_KEY`::\n \n     >>> signer = Signer()\n     >>> signer.sign('My string')\n@@ -93,6 +92,14 @@ and your :setting:`SECRET_KEY`::\n     >>> signer.unsign('My string:Ee7vGi-ING6n02gkcJ-QLHg6vFw')\n     u'My string'\n \n+Using salt in this way puts the different signatures into different\n+namespaces.  A signature that comes from one namespace (a particular salt\n+value) cannot be used to validate the same plaintext string in a different\n+namespace that is using a different salt setting. The result is to prevent an\n+attacker from using a signed string generated in one place in the code as input\n+to another piece of code that is generating (and verifying) signatures using a\n+different salt.\n+\n Unlike your :setting:`SECRET_KEY`, your salt argument does not need to stay\n secret.\n "
        }
    ],
    "stats": {
        "total": 17,
        "additions": 12,
        "deletions": 5
    }
}