{
    "author": "spookylukey",
    "message": "Fixed #17003 - prefetch_related should support foreign keys/one-to-one\n\nSupport for `GenericForeignKey` is also included.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16939 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "052a011ee6122482a471795c1994bbcfdb069611",
    "files": [
        {
            "sha": "23abe01f514f74885abf08d1114253a1f1a66e99",
            "filename": "django/contrib/contenttypes/generic.py",
            "status": "modified",
            "additions": 51,
            "deletions": 1,
            "changes": 52,
            "blob_url": "https://github.com/django/django/blob/052a011ee6122482a471795c1994bbcfdb069611/django%2Fcontrib%2Fcontenttypes%2Fgeneric.py",
            "raw_url": "https://github.com/django/django/raw/052a011ee6122482a471795c1994bbcfdb069611/django%2Fcontrib%2Fcontenttypes%2Fgeneric.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fcontenttypes%2Fgeneric.py?ref=052a011ee6122482a471795c1994bbcfdb069611",
            "patch": "@@ -2,7 +2,10 @@\n Classes allowing \"generic\" relations through ContentType and object-id fields.\n \"\"\"\n \n+from collections import defaultdict\n from functools import partial\n+from operator import attrgetter\n+\n from django.core.exceptions import ObjectDoesNotExist\n from django.db import connection\n from django.db.models import signals\n@@ -59,6 +62,49 @@ def get_content_type(self, obj=None, id=None, using=None):\n             # This should never happen. I love comments like this, don't you?\n             raise Exception(\"Impossible arguments to GFK.get_content_type!\")\n \n+    def get_prefetch_query_set(self, instances):\n+        # For efficiency, group the instances by content type and then do one\n+        # query per model\n+        fk_dict = defaultdict(list)\n+        # We need one instance for each group in order to get the right db:\n+        instance_dict = {}\n+        ct_attname = self.model._meta.get_field(self.ct_field).get_attname()\n+        for instance in instances:\n+            # We avoid looking for values if either ct_id or fkey value is None\n+            ct_id = getattr(instance, ct_attname)\n+            if ct_id is not None:\n+                fk_val = getattr(instance, self.fk_field)\n+                if fk_val is not None:\n+                    fk_dict[ct_id].append(fk_val)\n+                    instance_dict[ct_id] = instance\n+\n+        ret_val = []\n+        for ct_id, fkeys in fk_dict.items():\n+            instance = instance_dict[ct_id]\n+            ct = self.get_content_type(id=ct_id, using=instance._state.db)\n+            ret_val.extend(ct.get_all_objects_for_this_type(pk__in=fkeys))\n+\n+        # For doing the join in Python, we have to match both the FK val and the\n+        # content type, so the 'attr' vals we return need to be callables that\n+        # will return a (fk, class) pair.\n+        def gfk_key(obj):\n+            ct_id = getattr(obj, ct_attname)\n+            if ct_id is None:\n+                return None\n+            else:\n+                return (getattr(obj, self.fk_field),\n+                        self.get_content_type(id=ct_id,\n+                                              using=obj._state.db).model_class())\n+\n+        return (ret_val,\n+                lambda obj: (obj._get_pk_val(), obj.__class__),\n+                gfk_key,\n+                True,\n+                self.cache_attr)\n+\n+    def is_cached(self, instance):\n+        return hasattr(instance, self.cache_attr)\n+\n     def __get__(self, instance, instance_type=None):\n         if instance is None:\n             return self\n@@ -282,7 +328,11 @@ def get_prefetch_query_set(self, instances):\n                     [obj._get_pk_val() for obj in instances]\n                 }\n             qs = super(GenericRelatedObjectManager, self).get_query_set().using(db).filter(**query)\n-            return (qs, self.object_id_field_name, 'pk')\n+            return (qs,\n+                    attrgetter(self.object_id_field_name),\n+                    lambda obj: obj._get_pk_val(),\n+                    False,\n+                    self.prefetch_cache_name)\n \n         def add(self, *objs):\n             for obj in objs:"
        },
        {
            "sha": "c7e3dd79af2509c17f9a664aec2b09265502daf1",
            "filename": "django/contrib/contenttypes/models.py",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/052a011ee6122482a471795c1994bbcfdb069611/django%2Fcontrib%2Fcontenttypes%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/052a011ee6122482a471795c1994bbcfdb069611/django%2Fcontrib%2Fcontenttypes%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fcontenttypes%2Fmodels.py?ref=052a011ee6122482a471795c1994bbcfdb069611",
            "patch": "@@ -113,5 +113,11 @@ def get_object_for_this_type(self, **kwargs):\n         \"\"\"\n         return self.model_class()._base_manager.using(self._state.db).get(**kwargs)\n \n+    def get_all_objects_for_this_type(self, **kwargs):\n+        \"\"\"\n+        Returns all objects of this type for the keyword arguments given.\n+        \"\"\"\n+        return self.model_class()._base_manager.using(self._state.db).filter(**kwargs)\n+\n     def natural_key(self):\n         return (self.app_label, self.model)"
        },
        {
            "sha": "c82c3972883259034592fbd26d13a255abaa8b67",
            "filename": "django/db/models/fields/related.py",
            "status": "modified",
            "additions": 60,
            "deletions": 26,
            "changes": 86,
            "blob_url": "https://github.com/django/django/blob/052a011ee6122482a471795c1994bbcfdb069611/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "raw_url": "https://github.com/django/django/raw/052a011ee6122482a471795c1994bbcfdb069611/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2Frelated.py?ref=052a011ee6122482a471795c1994bbcfdb069611",
            "patch": "@@ -1,3 +1,5 @@\n+from operator import attrgetter\n+\n from django.db import connection, router\n from django.db.backends import util\n from django.db.models import signals, get_model\n@@ -227,15 +229,30 @@ def __init__(self, related):\n         self.related = related\n         self.cache_name = related.get_cache_name()\n \n+    def is_cached(self, instance):\n+        return hasattr(instance, self.cache_name)\n+\n+    def get_query_set(self, **db_hints):\n+        db = router.db_for_read(self.related.model, **db_hints)\n+        return self.related.model._base_manager.using(db)\n+\n+    def get_prefetch_query_set(self, instances):\n+        vals = [instance._get_pk_val() for instance in instances]\n+        params = {'%s__pk__in' % self.related.field.name: vals}\n+        return (self.get_query_set(),\n+                attrgetter(self.related.field.attname),\n+                lambda obj: obj._get_pk_val(),\n+                True,\n+                self.cache_name)\n+\n     def __get__(self, instance, instance_type=None):\n         if instance is None:\n             return self\n         try:\n             return getattr(instance, self.cache_name)\n         except AttributeError:\n             params = {'%s__pk' % self.related.field.name: instance._get_pk_val()}\n-            db = router.db_for_read(self.related.model, instance=instance)\n-            rel_obj = self.related.model._base_manager.using(db).get(**params)\n+            rel_obj = self.get_query_set(instance=instance).get(**params)\n             setattr(instance, self.cache_name, rel_obj)\n             return rel_obj\n \n@@ -283,14 +300,40 @@ class ReverseSingleRelatedObjectDescriptor(object):\n     # ReverseSingleRelatedObjectDescriptor instance.\n     def __init__(self, field_with_rel):\n         self.field = field_with_rel\n+        self.cache_name = self.field.get_cache_name()\n+\n+    def is_cached(self, instance):\n+        return hasattr(instance, self.cache_name)\n+\n+    def get_query_set(self, **db_hints):\n+        db = router.db_for_read(self.field.rel.to, **db_hints)\n+        rel_mgr = self.field.rel.to._default_manager\n+        # If the related manager indicates that it should be used for\n+        # related fields, respect that.\n+        if getattr(rel_mgr, 'use_for_related_fields', False):\n+            return rel_mgr.using(db)\n+        else:\n+            return QuerySet(self.field.rel.to).using(db)\n+\n+    def get_prefetch_query_set(self, instances):\n+        vals = [getattr(instance, self.field.attname) for instance in instances]\n+        other_field = self.field.rel.get_related_field()\n+        if other_field.rel:\n+            params = {'%s__pk__in' % self.field.rel.field_name: vals}\n+        else:\n+            params = {'%s__in' % self.field.rel.field_name: vals}\n+        return (self.get_query_set().filter(**params),\n+                attrgetter(self.field.rel.field_name),\n+                attrgetter(self.field.attname),\n+                True,\n+                self.cache_name)\n \n     def __get__(self, instance, instance_type=None):\n         if instance is None:\n             return self\n \n-        cache_name = self.field.get_cache_name()\n         try:\n-            return getattr(instance, cache_name)\n+            return getattr(instance, self.cache_name)\n         except AttributeError:\n             val = getattr(instance, self.field.attname)\n             if val is None:\n@@ -303,16 +346,9 @@ def __get__(self, instance, instance_type=None):\n                 params = {'%s__pk' % self.field.rel.field_name: val}\n             else:\n                 params = {'%s__exact' % self.field.rel.field_name: val}\n-\n-            # If the related manager indicates that it should be used for\n-            # related fields, respect that.\n-            rel_mgr = self.field.rel.to._default_manager\n-            db = router.db_for_read(self.field.rel.to, instance=instance)\n-            if getattr(rel_mgr, 'use_for_related_fields', False):\n-                rel_obj = rel_mgr.using(db).get(**params)\n-            else:\n-                rel_obj = QuerySet(self.field.rel.to).using(db).get(**params)\n-            setattr(instance, cache_name, rel_obj)\n+            qs = self.get_query_set(instance=instance)\n+            rel_obj = qs.get(**params)\n+            setattr(instance, self.cache_name, rel_obj)\n             return rel_obj\n \n     def __set__(self, instance, value):\n@@ -425,15 +461,15 @@ def get_query_set(self):\n                     return super(RelatedManager, self).get_query_set().using(db).filter(**self.core_filters)\n \n             def get_prefetch_query_set(self, instances):\n-                \"\"\"\n-                Return a queryset that does the bulk lookup needed\n-                by prefetch_related functionality.\n-                \"\"\"\n                 db = self._db or router.db_for_read(self.model)\n                 query = {'%s__%s__in' % (rel_field.name, attname):\n                              [getattr(obj, attname) for obj in instances]}\n                 qs = super(RelatedManager, self).get_query_set().using(db).filter(**query)\n-                return (qs, rel_field.get_attname(), attname)\n+                return (qs,\n+                        attrgetter(rel_field.get_attname()),\n+                        attrgetter(attname),\n+                        False,\n+                        rel_field.related_query_name())\n \n             def add(self, *objs):\n                 for obj in objs:\n@@ -507,12 +543,6 @@ def get_query_set(self):\n                 return super(ManyRelatedManager, self).get_query_set().using(db)._next_is_sticky().filter(**self.core_filters)\n \n         def get_prefetch_query_set(self, instances):\n-            \"\"\"\n-            Returns a tuple:\n-            (queryset of instances of self.model that are related to passed in instances\n-             attr of returned instances needed for matching\n-             attr of passed in instances needed for matching)\n-            \"\"\"\n             from django.db import connections\n             db = self._db or router.db_for_read(self.model)\n             query = {'%s__pk__in' % self.query_field_name:\n@@ -534,7 +564,11 @@ def get_prefetch_query_set(self, instances):\n             qs = qs.extra(select={'_prefetch_related_val':\n                                       '%s.%s' % (qn(join_table), qn(source_col))})\n             select_attname = fk.rel.get_related_field().get_attname()\n-            return (qs, '_prefetch_related_val', select_attname)\n+            return (qs,\n+                    attrgetter('_prefetch_related_val'),\n+                    attrgetter(select_attname),\n+                    False,\n+                    self.prefetch_cache_name)\n \n         # If the ManyToMany relation has an intermediary model,\n         # the add and remove methods do not exist."
        },
        {
            "sha": "1461125af4839bca9b6f0039db396a5333e2ef78",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 97,
            "deletions": 28,
            "changes": 125,
            "blob_url": "https://github.com/django/django/blob/052a011ee6122482a471795c1994bbcfdb069611/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/052a011ee6122482a471795c1994bbcfdb069611/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=052a011ee6122482a471795c1994bbcfdb069611",
            "patch": "@@ -1612,55 +1612,116 @@ def prefetch_related_objects(result_cache, related_lookups):\n                 break\n \n             # Descend down tree\n-            try:\n-                rel_obj = getattr(obj_list[0], attr)\n-            except AttributeError:\n+\n+            # We assume that objects retrieved are homogenous (which is the premise\n+            # of prefetch_related), so what applies to first object applies to all.\n+            first_obj = obj_list[0]\n+            prefetcher, attr_found, is_fetched = get_prefetcher(first_obj, attr)\n+\n+            if not attr_found:\n                 raise AttributeError(\"Cannot find '%s' on %s object, '%s' is an invalid \"\n                                      \"parameter to prefetch_related()\" %\n-                                     (attr, obj_list[0].__class__.__name__, lookup))\n+                                     (attr, first_obj.__class__.__name__, lookup))\n \n-            can_prefetch = hasattr(rel_obj, 'get_prefetch_query_set')\n-            if level == len(attrs) - 1 and not can_prefetch:\n-                # Last one, this *must* resolve to a related manager.\n-                raise ValueError(\"'%s' does not resolve to a supported 'many related\"\n-                                 \" manager' for model %s - this is an invalid\"\n-                                 \" parameter to prefetch_related().\"\n-                                 % (lookup, model.__name__))\n+            if level == len(attrs) - 1 and prefetcher is None:\n+                # Last one, this *must* resolve to something that supports\n+                # prefetching, otherwise there is no point adding it and the\n+                # developer asking for it has made a mistake.\n+                raise ValueError(\"'%s' does not resolve to a item that supports \"\n+                                 \"prefetching - this is an invalid parameter to \"\n+                                 \"prefetch_related().\" % lookup)\n \n-            if can_prefetch:\n+            if prefetcher is not None and not is_fetched:\n                 # Check we didn't do this already\n                 current_lookup = LOOKUP_SEP.join(attrs[0:level+1])\n                 if current_lookup in done_queries:\n                     obj_list = done_queries[current_lookup]\n                 else:\n-                    relmanager = rel_obj\n-                    obj_list, additional_prl = prefetch_one_level(obj_list, relmanager, attr)\n+                    obj_list, additional_prl = prefetch_one_level(obj_list, prefetcher, attr)\n                     for f in additional_prl:\n                         new_prl = LOOKUP_SEP.join([current_lookup, f])\n                         related_lookups.append(new_prl)\n                     done_queries[current_lookup] = obj_list\n             else:\n-                # Assume we've got some singly related object. We replace\n-                # the current list of parent objects with that list.\n+                # Either a singly related object that has already been fetched\n+                # (e.g. via select_related), or hopefully some other property\n+                # that doesn't support prefetching but needs to be traversed.\n+\n+                # We replace the current list of parent objects with that list.\n                 obj_list = [getattr(obj, attr) for obj in obj_list]\n \n                 # Filter out 'None' so that we can continue with nullable\n                 # relations.\n                 obj_list = [obj for obj in obj_list if obj is not None]\n \n \n-def prefetch_one_level(instances, relmanager, attname):\n+def get_prefetcher(instance, attr):\n+    \"\"\"\n+    For the attribute 'attr' on the given instance, finds\n+    an object that has a get_prefetch_query_set().\n+    Return a 3 tuple containing:\n+    (the object with get_prefetch_query_set (or None),\n+     a boolean that is False if the attribute was not found at all,\n+     a boolean that is True if the attribute has already been fetched)\n+    \"\"\"\n+    prefetcher = None\n+    attr_found = False\n+    is_fetched = False\n+\n+    # For singly related objects, we have to avoid getting the attribute\n+    # from the object, as this will trigger the query. So we first try\n+    # on the class, in order to get the descriptor object.\n+    rel_obj_descriptor = getattr(instance.__class__, attr, None)\n+    if rel_obj_descriptor is None:\n+        try:\n+            rel_obj = getattr(instance, attr)\n+            attr_found = True\n+        except AttributeError:\n+            pass\n+    else:\n+        attr_found = True\n+        if rel_obj_descriptor:\n+            # singly related object, descriptor object has the\n+            # get_prefetch_query_set() method.\n+            if hasattr(rel_obj_descriptor, 'get_prefetch_query_set'):\n+                prefetcher = rel_obj_descriptor\n+                if rel_obj_descriptor.is_cached(instance):\n+                    is_fetched = True\n+            else:\n+                # descriptor doesn't support prefetching, so we go ahead and get\n+                # the attribute on the instance rather than the class to\n+                # support many related managers\n+                rel_obj = getattr(instance, attr)\n+                if hasattr(rel_obj, 'get_prefetch_query_set'):\n+                    prefetcher = rel_obj\n+    return prefetcher, attr_found, is_fetched\n+\n+\n+def prefetch_one_level(instances, prefetcher, attname):\n     \"\"\"\n     Helper function for prefetch_related_objects\n \n-    Runs prefetches on all instances using the manager relmanager,\n-    assigning results to queryset against instance.attname.\n+    Runs prefetches on all instances using the prefetcher object,\n+    assigning results to relevant caches in instance.\n \n     The prefetched objects are returned, along with any additional\n     prefetches that must be done due to prefetch_related lookups\n     found from default managers.\n     \"\"\"\n-    rel_qs, rel_obj_attr, instance_attr = relmanager.get_prefetch_query_set(instances)\n+    # prefetcher must have a method get_prefetch_query_set() which takes a list\n+    # of instances, and returns a tuple:\n+\n+    # (queryset of instances of self.model that are related to passed in instances,\n+    #  callable that gets value to be matched for returned instances,\n+    #  callable that gets value to be matched for passed in instances,\n+    #  boolean that is True for singly related objects,\n+    #  cache name to assign to).\n+\n+    # The 'values to be matched' must be hashable as they will be used\n+    # in a dictionary.\n+\n+    rel_qs, rel_obj_attr, instance_attr, single, cache_name =\\\n+        prefetcher.get_prefetch_query_set(instances)\n     # We have to handle the possibility that the default manager itself added\n     # prefetch_related lookups to the QuerySet we just got back. We don't want to\n     # trigger the prefetch_related functionality by evaluating the query.\n@@ -1676,17 +1737,25 @@ def prefetch_one_level(instances, relmanager, attname):\n \n     rel_obj_cache = {}\n     for rel_obj in all_related_objects:\n-        rel_attr_val = getattr(rel_obj, rel_obj_attr)\n+        rel_attr_val = rel_obj_attr(rel_obj)\n         if rel_attr_val not in rel_obj_cache:\n             rel_obj_cache[rel_attr_val] = []\n         rel_obj_cache[rel_attr_val].append(rel_obj)\n \n     for obj in instances:\n-        qs = getattr(obj, attname).all()\n-        instance_attr_val = getattr(obj, instance_attr)\n-        qs._result_cache = rel_obj_cache.get(instance_attr_val, [])\n-        # We don't want the individual qs doing prefetch_related now, since we\n-        # have merged this into the current work.\n-        qs._prefetch_done = True\n-        obj._prefetched_objects_cache[attname] = qs\n+        instance_attr_val = instance_attr(obj)\n+        vals = rel_obj_cache.get(instance_attr_val, [])\n+        if single:\n+            # Need to assign to single cache on instance\n+            if vals:\n+                setattr(obj, cache_name, vals[0])\n+        else:\n+            # Multi, attribute represents a manager with an .all() method that\n+            # returns a QuerySet\n+            qs = getattr(obj, attname).all()\n+            qs._result_cache = vals\n+            # We don't want the individual qs doing prefetch_related now, since we\n+            # have merged this into the current work.\n+            qs._prefetch_done = True\n+            obj._prefetched_objects_cache[cache_name] = qs\n     return all_related_objects, additional_prl"
        },
        {
            "sha": "238fe649158209f78eb096e759a7f99435a0a5aa",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 57,
            "deletions": 32,
            "changes": 89,
            "blob_url": "https://github.com/django/django/blob/052a011ee6122482a471795c1994bbcfdb069611/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/052a011ee6122482a471795c1994bbcfdb069611/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=052a011ee6122482a471795c1994bbcfdb069611",
            "patch": "@@ -696,14 +696,26 @@ prefetch_related\n .. versionadded:: 1.4\n \n Returns a ``QuerySet`` that will automatically retrieve, in a single batch,\n-related many-to-many and many-to-one objects for each of the specified lookups.\n-\n-This is similar to ``select_related`` for the 'many related objects' case, but\n-note that ``prefetch_related`` causes a separate query to be issued for each set\n-of related objects that you request, unlike ``select_related`` which modifies\n-the original query with joins in order to get the related objects. With\n-``prefetch_related``, the additional queries are done as soon as the QuerySet\n-begins to be evaluated.\n+related objects for each of the specified lookups.\n+\n+This has a similar purpose to ``select_related``, in that both are designed to\n+stop the deluge of database queries that is caused by accessing related objects,\n+but the strategy is quite different.\n+\n+``select_related`` works by creating a SQL join and including the fields of the\n+related object in the SELECT statement. For this reason, ``select_related`` gets\n+the related objects in the same database query. However, to avoid the much\n+larger result set that would result from joining across a 'many' relationship,\n+``select_related`` is limited to single-valued relationships - foreign key and\n+one-to-one.\n+\n+``prefetch_related``, on the other hand, does a separate lookup for each\n+relationship, and does the 'joining' in Python. This allows it to prefetch\n+many-to-many and many-to-one objects, which cannot be done using\n+``select_related``, in addition to the foreign key and one-to-one relationships\n+that are supported by ``select_related``. It also supports prefetching of\n+:class:`~django.contrib.contenttypes.generic.GenericRelation` and\n+:class:`~django.contrib.contenttypes.generic.GenericForeignKey`.\n \n For example, suppose you have these models::\n \n@@ -733,14 +745,17 @@ All the relevant toppings will be fetched in a single query, and used to make\n ``QuerySets`` that have a pre-filled cache of the relevant results. These\n ``QuerySets`` are then used in the ``self.toppings.all()`` calls.\n \n-Please note that use of ``prefetch_related`` will mean that the additional\n-queries run will **always** be executed - even if you never use the related\n-objects - and it always fully populates the result cache on the primary\n-``QuerySet`` (which can sometimes be avoided in other cases).\n+The additional queries are executed after the QuerySet has begun to be evaluated\n+and the primary query has been executed. Note that the result cache of the\n+primary QuerySet and all specified related objects will then be fully loaded\n+into memory, which is often avoided in other cases - even after a query has been\n+executed in the database, QuerySet normally tries to make uses of chunking\n+between the database to avoid loading all objects into memory before you need\n+them.\n \n Also remember that, as always with QuerySets, any subsequent chained methods\n-will ignore previously cached results, and retrieve data using a fresh database\n-query. So, if you write the following:\n+which imply a different database query will ignore previously cached results,\n+and retrieve data using a fresh database query. So, if you write the following:\n \n     >>> pizzas = Pizza.objects.prefetch_related('toppings')\n     >>> [list(pizza.toppings.filter(spicy=True)) for pizza in pizzas]\n@@ -749,12 +764,6 @@ query. So, if you write the following:\n you - in fact it hurts performance, since you have done a database query that\n you haven't used. So use this feature with caution!\n \n-The lookups that must be supplied to this method can be any attributes on the\n-model instances which represent related queries that return multiple\n-objects. This includes attributes representing the 'many' side of ``ForeignKey``\n-relationships, forward and reverse ``ManyToManyField`` attributes, and also any\n-``GenericRelations``.\n-\n You can also use the normal join syntax to do related fields of related\n fields. Suppose we have an additional model to the example above::\n \n@@ -770,24 +779,40 @@ This will prefetch all pizzas belonging to restaurants, and all toppings\n belonging to those pizzas. This will result in a total of 3 database queries -\n one for the restaurants, one for the pizzas, and one for the toppings.\n \n-    >>> Restaurant.objects.select_related('best_pizza').prefetch_related('best_pizza__toppings')\n+    >>> Restaurant.objects.prefetch_related('best_pizza__toppings')\n \n This will fetch the best pizza and all the toppings for the best pizza for each\n-restaurant. This will be done in 2 database queries - one for the restaurants\n-and 'best pizzas' combined (achieved through use of ``select_related``), and one\n-for the toppings.\n+restaurant. This will be done in 3 database queries - one for the restaurants,\n+one for the 'best pizzas', and one for one for the toppings.\n+\n+Of course, the ``best_pizza`` relationship could also be fetched using\n+``select_related`` to reduce the query count to 2:\n+\n+    >>> Restaurant.objects.select_related('best_pizza').prefetch_related('best_pizza__toppings')\n+\n+Since the prefetch is executed after the main query (which includes the joins\n+needed by ``select_related``), it is able to detect that the ``best_pizza``\n+objects have already been fetched, and it will skip fetching them again.\n \n-Chaining ``prefetch_related`` calls will accumulate the fields that should have\n-this behavior applied. To clear any ``prefetch_related`` behavior, pass `None`\n-as a parameter::\n+Chaining ``prefetch_related`` calls will accumulate the lookups that are\n+prefetched. To clear any ``prefetch_related`` behavior, pass `None` as a\n+parameter::\n \n    >>> non_prefetched = qs.prefetch_related(None)\n \n-One difference when using ``prefetch_related`` is that, in some circumstances,\n-objects created by a query can be shared between the different objects that they\n-are related to i.e. a single Python model instance can appear at more than one\n-point in the tree of objects that are returned. Normally this behavior will not\n-be a problem, and will in fact save both memory and CPU time.\n+One difference to note when using ``prefetch_related`` is that objects created\n+by a query can be shared between the different objects that they are related to\n+i.e. a single Python model instance can appear at more than one point in the\n+tree of objects that are returned. This will normally happen with foreign key\n+relationships. Typically this behavior will not be a problem, and will in fact\n+save both memory and CPU time.\n+\n+While ``prefetch_related`` supports prefetching ``GenericForeignKey``\n+relationships, the number of queries will depend on the data. Since a\n+``GenericForeignKey`` can reference data in multiple tables, one query per table\n+referenced is needed, rather than one query for all the items. There could be\n+additional queries on the ``ContentType`` table if the relevant rows have not\n+already been fetched.\n \n extra\n ~~~~~"
        },
        {
            "sha": "c6b547dab6dacc968ab1c0caa9ff5a107bb139f0",
            "filename": "docs/releases/1.4.txt",
            "status": "modified",
            "additions": 11,
            "deletions": 8,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/052a011ee6122482a471795c1994bbcfdb069611/docs%2Freleases%2F1.4.txt",
            "raw_url": "https://github.com/django/django/raw/052a011ee6122482a471795c1994bbcfdb069611/docs%2Freleases%2F1.4.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.4.txt?ref=052a011ee6122482a471795c1994bbcfdb069611",
            "patch": "@@ -66,15 +66,18 @@ information.\n ``QuerySet.prefetch_related``\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-Analagous to :meth:`~django.db.models.query.QuerySet.select_related` but for\n-many-to-many relationships,\n+Similar to :meth:`~django.db.models.query.QuerySet.select_related` but with a\n+different strategy and broader scope,\n :meth:`~django.db.models.query.QuerySet.prefetch_related` has been added to\n-:class:`~django.db.models.query.QuerySet`. This method returns a new ``QuerySet``\n-that will prefetch in a single batch each of the specified related lookups as\n-soon as it begins to be evaluated (e.g. by iterating over it). This enables you\n-to fix many instances of a very common performance problem, in which your code\n-ends up doing O(n) database queries (or worse) if objects on your primary\n-``QuerySet`` each have many related objects that you also need.\n+:class:`~django.db.models.query.QuerySet`. This method returns a new\n+``QuerySet`` that will prefetch in a single batch each of the specified related\n+lookups as soon as it begins to be evaluated. Unlike ``select_related``, it does\n+the joins in Python, not in the database, and supports many-to-many\n+relationships, :class:`~django.contrib.contenttypes.generic.GenericForeignKey`\n+and more. This enables you to fix many instances of a very common performance\n+problem, in which your code ends up doing O(n) database queries (or worse) if\n+objects on your primary ``QuerySet`` each have many related objects that you\n+also need.\n \n HTML5\n ~~~~~"
        },
        {
            "sha": "1c14c888181af2effeadf5e88c96df13cb7cdc8f",
            "filename": "tests/modeltests/prefetch_related/models.py",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/052a011ee6122482a471795c1994bbcfdb069611/tests%2Fmodeltests%2Fprefetch_related%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/052a011ee6122482a471795c1994bbcfdb069611/tests%2Fmodeltests%2Fprefetch_related%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fprefetch_related%2Fmodels.py?ref=052a011ee6122482a471795c1994bbcfdb069611",
            "patch": "@@ -104,13 +104,17 @@ class Meta:\n         ordering = ['id']\n \n \n-## Generic relation tests\n+## GenericRelation/GenericForeignKey tests\n \n class TaggedItem(models.Model):\n     tag = models.SlugField()\n     content_type = models.ForeignKey(ContentType, related_name=\"taggeditem_set2\")\n     object_id = models.PositiveIntegerField()\n     content_object = generic.GenericForeignKey('content_type', 'object_id')\n+    created_by_ct = models.ForeignKey(ContentType, null=True,\n+                                      related_name='taggeditem_set3')\n+    created_by_fkey = models.PositiveIntegerField(null=True)\n+    created_by = generic.GenericForeignKey('created_by_ct', 'created_by_fkey',)\n \n     def __unicode__(self):\n         return self.tag"
        },
        {
            "sha": "bdbb0568c3547260dc0d8e171485689f25ea2207",
            "filename": "tests/modeltests/prefetch_related/tests.py",
            "status": "modified",
            "additions": 80,
            "deletions": 24,
            "changes": 104,
            "blob_url": "https://github.com/django/django/blob/052a011ee6122482a471795c1994bbcfdb069611/tests%2Fmodeltests%2Fprefetch_related%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/052a011ee6122482a471795c1994bbcfdb069611/tests%2Fmodeltests%2Fprefetch_related%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fprefetch_related%2Ftests.py?ref=052a011ee6122482a471795c1994bbcfdb069611",
            "patch": "@@ -54,6 +54,13 @@ def test_m2m_reverse(self):\n         normal_lists = [list(a.books.all()) for a in Author.objects.all()]\n         self.assertEqual(lists, normal_lists)\n \n+    def test_foreignkey_forward(self):\n+        with self.assertNumQueries(2):\n+            books = [a.first_book for a in Author.objects.prefetch_related('first_book')]\n+\n+        normal_books = [a.first_book for a in Author.objects.all()]\n+        self.assertEqual(books, normal_books)\n+\n     def test_foreignkey_reverse(self):\n         with self.assertNumQueries(2):\n             lists = [list(b.first_time_authors.all())\n@@ -175,12 +182,12 @@ def test_attribute_error(self):\n         self.assertTrue('prefetch_related' in str(cm.exception))\n \n     def test_invalid_final_lookup(self):\n-        qs = Book.objects.prefetch_related('authors__first_book')\n+        qs = Book.objects.prefetch_related('authors__name')\n         with self.assertRaises(ValueError) as cm:\n             list(qs)\n \n         self.assertTrue('prefetch_related' in str(cm.exception))\n-        self.assertTrue(\"first_book\" in str(cm.exception))\n+        self.assertTrue(\"name\" in str(cm.exception))\n \n \n class DefaultManagerTests(TestCase):\n@@ -222,39 +229,68 @@ def test_m2m_then_m2m(self):\n \n class GenericRelationTests(TestCase):\n \n-    def test_traverse_GFK(self):\n-        \"\"\"\n-        Test that we can traverse a 'content_object' with prefetch_related()\n-        \"\"\"\n-        # In fact, there is no special support for this in prefetch_related code\n-        # - we can traverse any object that will lead us to objects that have\n-        # related managers.\n-\n+    def setUp(self):\n         book1 = Book.objects.create(title=\"Winnie the Pooh\")\n         book2 = Book.objects.create(title=\"Do you like green eggs and spam?\")\n+        book3 = Book.objects.create(title=\"Three Men In A Boat\")\n \n         reader1 = Reader.objects.create(name=\"me\")\n         reader2 = Reader.objects.create(name=\"you\")\n+        reader3 = Reader.objects.create(name=\"someone\")\n \n-        book1.read_by.add(reader1)\n+        book1.read_by.add(reader1, reader2)\n         book2.read_by.add(reader2)\n+        book3.read_by.add(reader3)\n+\n+        self.book1, self.book2, self.book3 = book1, book2, book3\n+        self.reader1, self.reader2, self.reader3 = reader1, reader2, reader3\n \n-        TaggedItem.objects.create(tag=\"awesome\", content_object=book1)\n-        TaggedItem.objects.create(tag=\"awesome\", content_object=book2)\n+    def test_prefetch_GFK(self):\n+        TaggedItem.objects.create(tag=\"awesome\", content_object=self.book1)\n+        TaggedItem.objects.create(tag=\"great\", content_object=self.reader1)\n+        TaggedItem.objects.create(tag=\"stupid\", content_object=self.book2)\n+        TaggedItem.objects.create(tag=\"amazing\", content_object=self.reader3)\n+\n+        # 1 for TaggedItem table, 1 for Book table, 1 for Reader table\n+        with self.assertNumQueries(3):\n+            qs = TaggedItem.objects.prefetch_related('content_object')\n+            list(qs)\n+\n+    def test_traverse_GFK(self):\n+        \"\"\"\n+        Test that we can traverse a 'content_object' with prefetch_related() and\n+        get to related objects on the other side (assuming it is suitably\n+        filtered)\n+        \"\"\"\n+        TaggedItem.objects.create(tag=\"awesome\", content_object=self.book1)\n+        TaggedItem.objects.create(tag=\"awesome\", content_object=self.book2)\n+        TaggedItem.objects.create(tag=\"awesome\", content_object=self.book3)\n+        TaggedItem.objects.create(tag=\"awesome\", content_object=self.reader1)\n+        TaggedItem.objects.create(tag=\"awesome\", content_object=self.reader2)\n \n         ct = ContentType.objects.get_for_model(Book)\n \n-        # We get 4 queries - 1 for main query, 2 for each access to\n-        # 'content_object' because these can't be handled by select_related, and\n-        # 1 for the 'read_by' relation.\n-        with self.assertNumQueries(4):\n+        # We get 3 queries - 1 for main query, 1 for content_objects since they\n+        # all use the same table, and 1 for the 'read_by' relation.\n+        with self.assertNumQueries(3):\n             # If we limit to books, we know that they will have 'read_by'\n             # attributes, so the following makes sense:\n-            qs = TaggedItem.objects.select_related('content_type').prefetch_related('content_object__read_by').filter(tag='awesome').filter(content_type=ct, tag='awesome')\n-            readers_of_awesome_books = [r.name for tag in qs\n-                                        for r in tag.content_object.read_by.all()]\n-            self.assertEqual(readers_of_awesome_books, [\"me\", \"you\"])\n+            qs = TaggedItem.objects.filter(content_type=ct, tag='awesome').prefetch_related('content_object__read_by')\n+            readers_of_awesome_books = set([r.name for tag in qs\n+                                            for r in tag.content_object.read_by.all()])\n+            self.assertEqual(readers_of_awesome_books, set([\"me\", \"you\", \"someone\"]))\n \n+    def test_nullable_GFK(self):\n+        TaggedItem.objects.create(tag=\"awesome\", content_object=self.book1,\n+                                  created_by=self.reader1)\n+        TaggedItem.objects.create(tag=\"great\", content_object=self.book2)\n+        TaggedItem.objects.create(tag=\"rubbish\", content_object=self.book3)\n+\n+        with self.assertNumQueries(2):\n+            result = [t.created_by for t in TaggedItem.objects.prefetch_related('created_by')]\n+\n+        self.assertEqual(result,\n+                         [t.created_by for t in TaggedItem.objects.all()])\n \n     def test_generic_relation(self):\n         b = Bookmark.objects.create(url='http://www.djangoproject.com/')\n@@ -311,9 +347,14 @@ def test_m2m_to_inheriting_model(self):\n         self.assertEquals(lst, lst2)\n \n     def test_parent_link_prefetch(self):\n-        with self.assertRaises(ValueError) as cm:\n-            qs = list(AuthorWithAge.objects.prefetch_related('author'))\n-        self.assertTrue('prefetch_related' in str(cm.exception))\n+        with self.assertNumQueries(2):\n+            [a.author for a in AuthorWithAge.objects.prefetch_related('author')]\n+\n+    def test_child_link_prefetch(self):\n+        with self.assertNumQueries(2):\n+            l = [a.authorwithage for a in Author.objects.prefetch_related('authorwithage')]\n+\n+        self.assertEqual(l, [a.authorwithage for a in Author.objects.all()])\n \n \n class ForeignKeyToFieldTest(TestCase):\n@@ -406,6 +447,8 @@ def setUp(self):\n         worker2 = Employee.objects.create(name=\"Angela\", boss=boss)\n \n     def test_traverse_nullable(self):\n+        # Because we use select_related() for 'boss', it doesn't need to be\n+        # prefetched, but we can still traverse it although it contains some nulls\n         with self.assertNumQueries(2):\n             qs = Employee.objects.select_related('boss').prefetch_related('boss__serfs')\n             co_serfs = [list(e.boss.serfs.all()) if e.boss is not None else []\n@@ -416,3 +459,16 @@ def test_traverse_nullable(self):\n                         for e in qs2]\n \n         self.assertEqual(co_serfs, co_serfs2)\n+\n+    def test_prefetch_nullable(self):\n+        # One for main employee, one for boss, one for serfs\n+        with self.assertNumQueries(3):\n+            qs = Employee.objects.prefetch_related('boss__serfs')\n+            co_serfs = [list(e.boss.serfs.all()) if e.boss is not None else []\n+                        for e in qs]\n+\n+        qs2 =  Employee.objects.all()\n+        co_serfs2 =  [list(e.boss.serfs.all()) if e.boss is not None else []\n+                        for e in qs2]\n+\n+        self.assertEqual(co_serfs, co_serfs2)"
        }
    ],
    "stats": {
        "total": 487,
        "additions": 367,
        "deletions": 120
    }
}