{
    "author": "charettes",
    "message": "Fixed #10399 -- Tested that o2o field updates are not constrained by an inner query.",
    "sha": "fb3d85bd14f1f7a8969ef8c54f2f0603e161f428",
    "files": [
        {
            "sha": "46cef3a55d75710ce958e8414652db71014aa901",
            "filename": "tests/model_inheritance/tests.py",
            "status": "modified",
            "additions": 25,
            "deletions": 1,
            "changes": 26,
            "blob_url": "https://github.com/django/django/blob/fb3d85bd14f1f7a8969ef8c54f2f0603e161f428/tests%2Fmodel_inheritance%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/fb3d85bd14f1f7a8969ef8c54f2f0603e161f428/tests%2Fmodel_inheritance%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodel_inheritance%2Ftests.py?ref=fb3d85bd14f1f7a8969ef8c54f2f0603e161f428",
            "patch": "@@ -1,9 +1,11 @@\n-from __future__ import absolute_import\n+from __future__ import absolute_import, unicode_literals\n \n from operator import attrgetter\n \n from django.core.exceptions import FieldError\n+from django.db import connection\n from django.test import TestCase\n+from django.test.testcases import CaptureQueriesContext\n from django.utils import six\n \n from .models import (Chef, CommonInfo, ItalianRestaurant, ParkingLot, Place,\n@@ -294,3 +296,25 @@ def test_update_query_counts(self):\n         )\n         with self.assertNumQueries(6):\n             ir.save()\n+\n+    def test_update_parent_filtering(self):\n+        \"\"\"\n+        Test that updating a field of a model subclass doesn't issue an UPDATE\n+        query constrained by an inner query.\n+        Refs #10399\n+        \"\"\"\n+        supplier = Supplier.objects.create(\n+            name='Central market',\n+            address='610 some street'\n+        )\n+        # Capture the expected query in a database agnostic way\n+        with CaptureQueriesContext(connection) as captured_queries:\n+            Place.objects.filter(pk=supplier.pk).update(name=supplier.name)\n+        expected_sql = captured_queries[0]['sql']\n+        # Capture the queries executed when a subclassed model instance is saved.\n+        with CaptureQueriesContext(connection) as captured_queries:\n+            supplier.save(update_fields=('name',))\n+        for query in captured_queries:\n+            sql = query['sql']\n+            if 'UPDATE' in sql:\n+                self.assertEqual(expected_sql, sql)"
        }
    ],
    "stats": {
        "total": 26,
        "additions": 25,
        "deletions": 1
    }
}