{
    "author": "claudep",
    "message": "Replaced im_func and im_self by __func__ and __self__.\n\nThe new names are Python 3 compatible.",
    "sha": "bbb12581dbd91945857cb4731368671776d4d388",
    "files": [
        {
            "sha": "54e71c01cc1b9cc28986a485875898a94e937ad7",
            "filename": "django/dispatch/dispatcher.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/bbb12581dbd91945857cb4731368671776d4d388/django%2Fdispatch%2Fdispatcher.py",
            "raw_url": "https://github.com/django/django/raw/bbb12581dbd91945857cb4731368671776d4d388/django%2Fdispatch%2Fdispatcher.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdispatch%2Fdispatcher.py?ref=bbb12581dbd91945857cb4731368671776d4d388",
            "patch": "@@ -6,8 +6,8 @@\n WEAKREF_TYPES = (weakref.ReferenceType, saferef.BoundMethodWeakref)\n \n def _make_id(target):\n-    if hasattr(target, 'im_func'):\n-        return (id(target.im_self), id(target.im_func))\n+    if hasattr(target, '__func__'):\n+        return (id(target.__self__), id(target.__func__))\n     return id(target)\n \n class Signal(object):"
        },
        {
            "sha": "e060e619f8b4cc0852204f8c167f39488b1be5b1",
            "filename": "django/dispatch/saferef.py",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/django/django/blob/bbb12581dbd91945857cb4731368671776d4d388/django%2Fdispatch%2Fsaferef.py",
            "raw_url": "https://github.com/django/django/raw/bbb12581dbd91945857cb4731368671776d4d388/django%2Fdispatch%2Fsaferef.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdispatch%2Fsaferef.py?ref=bbb12581dbd91945857cb4731368671776d4d388",
            "patch": "@@ -19,11 +19,11 @@ def safeRef(target, onDelete = None):\n         goes out of scope with the reference object, (either a\n         weakref or a BoundMethodWeakref) as argument.\n     \"\"\"\n-    if hasattr(target, 'im_self'):\n-        if target.im_self is not None:\n+    if hasattr(target, '__self__'):\n+        if target.__self__ is not None:\n             # Turn a bound method into a BoundMethodWeakref instance.\n             # Keep track of these instances for lookup by disconnect().\n-            assert hasattr(target, 'im_func'), \"\"\"safeRef target %r has im_self, but no im_func, don't know how to create reference\"\"\"%( target,)\n+            assert hasattr(target, '__func__'), \"\"\"safeRef target %r has __self__, but no __func__, don't know how to create reference\"\"\"%( target,)\n             reference = get_bound_method_weakref(\n                 target=target,\n                 onDelete=onDelete\n@@ -97,9 +97,9 @@ def __init__(self, target, onDelete=None):\n         \"\"\"Return a weak-reference-like instance for a bound method\n \n         target -- the instance-method target for the weak\n-            reference, must have im_self and im_func attributes\n+            reference, must have __self__ and __func__ attributes\n             and be reconstructable via:\n-                target.im_func.__get__( target.im_self )\n+                target.__func__.__get__( target.__self__ )\n             which is true of built-in instance methods.\n         onDelete -- optional callback which will be called\n             when this weak reference ceases to be valid\n@@ -128,18 +128,18 @@ def remove(weak, self=self):\n                         )\n         self.deletionMethods = [onDelete]\n         self.key = self.calculateKey( target )\n-        self.weakSelf = weakref.ref(target.im_self, remove)\n-        self.weakFunc = weakref.ref(target.im_func, remove)\n-        self.selfName = str(target.im_self)\n-        self.funcName = str(target.im_func.__name__)\n+        self.weakSelf = weakref.ref(target.__self__, remove)\n+        self.weakFunc = weakref.ref(target.__func__, remove)\n+        self.selfName = str(target.__self__)\n+        self.funcName = str(target.__func__.__name__)\n     \n     def calculateKey( cls, target ):\n         \"\"\"Calculate the reference key for this reference\n \n         Currently this is a two-tuple of the id()'s of the\n         target object and the target function respectively.\n         \"\"\"\n-        return (id(target.im_self),id(target.im_func))\n+        return (id(target.__self__),id(target.__func__))\n     calculateKey = classmethod( calculateKey )\n     \n     def __str__(self):\n@@ -201,19 +201,19 @@ def __init__(self, target, onDelete=None):\n         \"\"\"Return a weak-reference-like instance for a bound method\n \n         target -- the instance-method target for the weak\n-            reference, must have im_self and im_func attributes\n+            reference, must have __self__ and __func__ attributes\n             and be reconstructable via:\n-                target.im_func.__get__( target.im_self )\n+                target.__func__.__get__( target.__self__ )\n             which is true of built-in instance methods.\n         onDelete -- optional callback which will be called\n             when this weak reference ceases to be valid\n             (i.e. either the object or the function is garbage\n             collected).  Should take a single argument,\n             which will be passed a pointer to this object.\n         \"\"\"\n-        assert getattr(target.im_self, target.__name__) == target, \\\n+        assert getattr(target.__self__, target.__name__) == target, \\\n                (\"method %s isn't available as the attribute %s of %s\" %\n-                (target, target.__name__, target.im_self))\n+                (target, target.__name__, target.__self__))\n         super(BoundNonDescriptorMethodWeakref, self).__init__(target, onDelete)\n \n     def __call__(self):"
        },
        {
            "sha": "dceaa62abc416f4baf3eda12843e89b68b03523d",
            "filename": "tests/regressiontests/decorators/tests.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/bbb12581dbd91945857cb4731368671776d4d388/tests%2Fregressiontests%2Fdecorators%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/bbb12581dbd91945857cb4731368671776d4d388/tests%2Fregressiontests%2Fdecorators%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fdecorators%2Ftests.py?ref=bbb12581dbd91945857cb4731368671776d4d388",
            "patch": "@@ -220,7 +220,7 @@ def method(self):\n         self.assertEqual(getattr(Test.method, 'myattr2', False), True)\n \n         self.assertEqual(Test.method.__doc__, 'A method')\n-        self.assertEqual(Test.method.im_func.__name__, 'method')\n+        self.assertEqual(Test.method.__func__.__name__, 'method')\n \n \n class XFrameOptionsDecoratorsTests(TestCase):"
        }
    ],
    "stats": {
        "total": 34,
        "additions": 17,
        "deletions": 17
    }
}