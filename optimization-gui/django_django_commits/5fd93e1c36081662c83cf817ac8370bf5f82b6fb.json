{
    "author": "timgraham",
    "message": "Fixed #13628 - Discourage the use of doctests; thanks d0ugal for the suggestion.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15227 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "5fd93e1c36081662c83cf817ac8370bf5f82b6fb",
    "files": [
        {
            "sha": "78590ddb2b2841c89e4fdf2589cf8888ef624778",
            "filename": "docs/topics/testing.txt",
            "status": "modified",
            "additions": 103,
            "deletions": 107,
            "changes": 210,
            "blob_url": "https://github.com/django/django/blob/5fd93e1c36081662c83cf817ac8370bf5f82b6fb/docs%2Ftopics%2Ftesting.txt",
            "raw_url": "https://github.com/django/django/raw/5fd93e1c36081662c83cf817ac8370bf5f82b6fb/docs%2Ftopics%2Ftesting.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Ftesting.txt?ref=5fd93e1c36081662c83cf817ac8370bf5f82b6fb",
            "patch": "@@ -35,6 +35,17 @@ There are two primary ways to write tests with Django, corresponding to the\n two test frameworks that ship in the Python standard library. The two\n frameworks are:\n \n+    * **Unit tests** -- tests that are expressed as methods on a Python class\n+      that subclasses ``unittest.TestCase``. For example::\n+\n+          import unittest\n+\n+          class MyFuncTestCase(unittest.TestCase):\n+              def testBasic(self):\n+                  a = ['larry', 'curly', 'moe']\n+                  self.assertEqual(my_func(a, 0), 'larry')\n+                  self.assertEqual(my_func(a, 1), 'curly')\n+\n     * **Doctests** -- tests that are embedded in your functions' docstrings and\n       are written in a way that emulates a session of the Python interactive\n       interpreter. For example::\n@@ -49,21 +60,87 @@ frameworks are:\n               \"\"\"\n               return a_list[idx]\n \n-    * **Unit tests** -- tests that are expressed as methods on a Python class\n-      that subclasses ``unittest.TestCase``. For example::\n+We'll discuss choosing the appropriate test framework later, however, most\n+experienced developers prefer unit tests. You can also use any *other* Python\n+test framework, as we'll explain in a bit.\n \n-          import unittest\n+Writing unit tests\n+------------------\n \n-          class MyFuncTestCase(unittest.TestCase):\n-              def testBasic(self):\n-                  a = ['larry', 'curly', 'moe']\n-                  self.assertEqual(my_func(a, 0), 'larry')\n-                  self.assertEqual(my_func(a, 1), 'curly')\n+Django's unit tests use a Python standard library module: unittest_. This\n+module defines tests in class-based approach.\n+\n+.. admonition:: unittest2\n+\n+    .. versionchanged:: 1.3\n+\n+    Python 2.7 introduced some major changes to the unittest library,\n+    adding some extremely useful features. To ensure that every Django\n+    project can benefit from these new features, Django ships with a\n+    copy of unittest2_, a copy of the Python 2.7 unittest library,\n+    backported for Python 2.4 compatibility.\n+\n+    To access this library, Django provides the\n+    ``django.utils.unittest`` module alias. If you are using Python\n+    2.7, or you have installed unittest2 locally, Django will map the\n+    alias to the installed version of the unittest library. Otherwise,\n+    Django will use it's own bundled version of unittest2.\n+\n+    To use this alias, simply use::\n+\n+        from django.utils import unittest\n+\n+    wherever you would have historically used::\n+\n+        import unittest\n+\n+    If you want to continue to use the base unittest libary, you can --\n+    you just won't get any of the nice new unittest2 features.\n+\n+.. _unittest2: http://pypi.python.org/pypi/unittest2\n+\n+For a given Django application, the test runner looks for unit tests in two\n+places:\n+\n+    * The ``models.py`` file. The test runner looks for any subclass of\n+      ``unittest.TestCase`` in this module.\n+\n+    * A file called ``tests.py`` in the application directory -- i.e., the\n+      directory that holds ``models.py``. Again, the test runner looks for any\n+      subclass of ``unittest.TestCase`` in this module.\n+\n+Here is an example ``unittest.TestCase`` subclass::\n+\n+    from django.utils import unittest\n+    from myapp.models import Animal\n+\n+    class AnimalTestCase(unittest.TestCase):\n+        def setUp(self):\n+            self.lion = Animal.objects.create(name=\"lion\", sound=\"roar\")\n+            self.cat = Animal.objects.create(name=\"cat\", sound=\"meow\")\n+\n+        def testSpeaking(self):\n+            self.assertEqual(self.lion.speak(), 'The lion says \"roar\"')\n+            self.assertEqual(self.cat.speak(), 'The cat says \"meow\"')\n+\n+When you :ref:`run your tests <running-tests>`, the default behavior of the\n+test utility is to find all the test cases (that is, subclasses of\n+``unittest.TestCase``) in ``models.py`` and ``tests.py``, automatically build a\n+test suite out of those test cases, and run that suite.\n+\n+There is a second way to define the test suite for a module: if you define a\n+function called ``suite()`` in either ``models.py`` or ``tests.py``, the\n+Django test runner will use that function to construct the test suite for that\n+module. This follows the `suggested organization`_ for unit tests. See the\n+Python documentation for more details on how to construct a complex test\n+suite.\n \n-You can choose the test framework you like, depending on which syntax you\n-prefer, or you can mix and match, using one framework for some of your code and\n-the other framework for other code. You can also use any *other* Python test\n-frameworks, as we'll explain in a bit.\n+For more details about ``unittest``, see the `standard library unittest\n+documentation`_.\n+\n+.. _unittest: http://docs.python.org/library/unittest.html\n+.. _standard library unittest documentation: unittest_\n+.. _suggested organization: http://docs.python.org/library/unittest.html#organizing-tests\n \n Writing doctests\n ----------------\n@@ -85,14 +162,14 @@ read Python's official documentation for the details.\n     For example, this function has a docstring that describes what it does::\n \n         def add_two(num):\n-          \"Return the result of adding two to the provided number.\"\n-           return num + 2\n+            \"Return the result of adding two to the provided number.\"\n+            return num + 2\n \n     Because tests often make great documentation, putting tests directly in\n     your docstrings is an effective way to document *and* test your code.\n \n-For a given Django application, the test runner looks for doctests in two\n-places:\n+As with unit tests, for a given Django application, the test runner looks for\n+doctests in two places:\n \n     * The ``models.py`` file. You can define module-level doctests and/or a\n       doctest for individual models. It's common practice to put\n@@ -103,7 +180,8 @@ places:\n       directory that holds ``models.py``. This file is a hook for any and all\n       doctests you want to write that aren't necessarily related to models.\n \n-Here is an example model doctest::\n+This example doctest is equivalent to the example given in the unittest section\n+above::\n \n     # models.py\n \n@@ -148,86 +226,6 @@ documentation for doctest`_.\n .. _doctest: http://docs.python.org/library/doctest.html\n .. _standard library documentation for doctest: doctest_\n \n-Writing unit tests\n-------------------\n-\n-Like doctests, Django's unit tests use a Python standard library\n-module: unittest_. This module uses a different way of defining tests,\n-taking a class-based approach.\n-\n-.. admonition:: unittest2\n-\n-    .. versionchanged:: 1.3\n-\n-    Python 2.7 introduced some major changes to the unittest library,\n-    adding some extremely useful features. To ensure that every Django\n-    project can benefit from these new features, Django ships with a\n-    copy of unittest2_, a copy of the Python 2.7 unittest library,\n-    backported for Python 2.4 compatibility.\n-\n-    To access this library, Django provides the\n-    ``django.utils.unittest`` module alias. If you are using Python\n-    2.7, or you have installed unittest2 locally, Django will map the\n-    alias to the installed version of the unittest library. Otherwise,\n-    Django will use it's own bundled version of unittest2.\n-\n-    To use this alias, simply use::\n-\n-        from django.utils import unittest\n-\n-    wherever you would have historically used::\n-\n-        import unittest\n-\n-    If you want to continue to use the base unittest libary, you can --\n-    you just won't get any of the nice new unittest2 features.\n-\n-.. _unittest2: http://pypi.python.org/pypi/unittest2\n-\n-As with doctests, for a given Django application, the test runner looks for\n-unit tests in two places:\n-\n-    * The ``models.py`` file. The test runner looks for any subclass of\n-      ``unittest.TestCase`` in this module.\n-\n-    * A file called ``tests.py`` in the application directory -- i.e., the\n-      directory that holds ``models.py``. Again, the test runner looks for any\n-      subclass of ``unittest.TestCase`` in this module.\n-\n-This example ``unittest.TestCase`` subclass is equivalent to the example given\n-in the doctest section above::\n-\n-    from django.utils import unittest\n-    from myapp.models import Animal\n-\n-    class AnimalTestCase(unittest.TestCase):\n-        def setUp(self):\n-            self.lion = Animal.objects.create(name=\"lion\", sound=\"roar\")\n-            self.cat = Animal.objects.create(name=\"cat\", sound=\"meow\")\n-\n-        def testSpeaking(self):\n-            self.assertEqual(self.lion.speak(), 'The lion says \"roar\"')\n-            self.assertEqual(self.cat.speak(), 'The cat says \"meow\"')\n-\n-When you :ref:`run your tests <running-tests>`, the default behavior of the\n-test utility is to find all the test cases (that is, subclasses of\n-``unittest.TestCase``) in ``models.py`` and ``tests.py``, automatically build a\n-test suite out of those test cases, and run that suite.\n-\n-There is a second way to define the test suite for a module: if you define a\n-function called ``suite()`` in either ``models.py`` or ``tests.py``, the\n-Django test runner will use that function to construct the test suite for that\n-module. This follows the `suggested organization`_ for unit tests. See the\n-Python documentation for more details on how to construct a complex test\n-suite.\n-\n-For more details about ``unittest``, see the `standard library unittest\n-documentation`_.\n-\n-.. _unittest: http://docs.python.org/library/unittest.html\n-.. _standard library unittest documentation: unittest_\n-.. _suggested organization: http://docs.python.org/library/unittest.html#organizing-tests\n-\n \n Which should I use?\n -------------------\n@@ -244,10 +242,12 @@ you:\n       more \"pythonic\". It's designed to make writing tests as easy as possible,\n       so it requires no overhead of writing classes or methods. You simply put\n       tests in docstrings. This has the added advantage of serving as\n-      documentation (and correct documentation, at that!).\n-\n-      If you're just getting started with testing, using doctests will probably\n-      get you started faster.\n+      documentation (and correct documentation, at that!). However, while\n+      doctests are good for some simple example code, they are not very good if\n+      you want to produce either high quality, comprehensive tests or high\n+      quality documentation. Test failures are often difficult to debug\n+      as it can be unclear exactly why the test failed. Thus, doctests should\n+      generally be avoided and used primarily for documentation examples only.\n \n     * The ``unittest`` framework will probably feel very familiar to developers\n       coming from Java. ``unittest`` is inspired by Java's JUnit, so you'll\n@@ -263,10 +263,6 @@ you:\n \n     * If you're writing tests for Django itself, you should use ``unittest``.\n \n-Again, remember that you can use both systems side-by-side (even in the same\n-app). In the end, most projects will eventually end up using both. Each shines\n-in different circumstances.\n-\n .. _running-tests:\n \n Running tests\n@@ -710,7 +706,7 @@ arguments at time of construction:\n             ...       HTTP_X_REQUESTED_WITH='XMLHttpRequest')\n \n         ...will send the HTTP header ``HTTP_X_REQUESTED_WITH`` to the\n-        details\tview, which is a good way to test code paths that use the\n+        details view, which is a good way to test code paths that use the\n         :meth:`django.http.HttpRequest.is_ajax()` method.\n \n         If you already have the GET arguments in URL-encoded form, you can\n@@ -1715,7 +1711,7 @@ set up, execute and tear down the test suite.\n .. method:: DjangoTestSuiteRunner.suite_result(suite, result, **kwargs)\n \n     Computes and returns a return code based on a test suite, and the result\n-\tfrom that test suite.\n+    from that test suite.\n \n \n Testing utilities"
        }
    ],
    "stats": {
        "total": 210,
        "additions": 103,
        "deletions": 107
    }
}