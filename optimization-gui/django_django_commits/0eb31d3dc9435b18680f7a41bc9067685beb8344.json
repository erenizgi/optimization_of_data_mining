{
    "author": "alex",
    "message": "Fixed #14423 -- corrected incorrect SQL being generated when a nullable, inherited field was used in an exclude.  Thanks to PhiR_42 for the patch.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@14600 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "0eb31d3dc9435b18680f7a41bc9067685beb8344",
    "files": [
        {
            "sha": "b8638fe9091cdcb4fcaec4ac337fa2544e07a389",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/0eb31d3dc9435b18680f7a41bc9067685beb8344/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/0eb31d3dc9435b18680f7a41bc9067685beb8344/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=0eb31d3dc9435b18680f7a41bc9067685beb8344",
            "patch": "@@ -921,8 +921,7 @@ def add_aggregate(self, aggregate, model, alias, is_summary):\n         \"\"\"\n         opts = model._meta\n         field_list = aggregate.lookup.split(LOOKUP_SEP)\n-        if (len(field_list) == 1 and\n-            aggregate.lookup in self.aggregates.keys()):\n+        if len(field_list) == 1 and aggregate.lookup in self.aggregates:\n             # Aggregate is over an annotation\n             field_name = field_list[0]\n             col = field_name\n@@ -1090,11 +1089,14 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n                         if self.alias_map[alias][JOIN_TYPE] == self.LOUTER:\n                             j_col = self.alias_map[alias][RHS_JOIN_COL]\n                             entry = self.where_class()\n-                            entry.add((Constraint(alias, j_col, None), 'isnull', True), AND)\n+                            entry.add(\n+                                (Constraint(alias, j_col, None), 'isnull', True),\n+                                AND\n+                            )\n                             entry.negate()\n                             self.where.add(entry, AND)\n                             break\n-                elif not (lookup_type == 'in'\n+                if not (lookup_type == 'in'\n                             and not hasattr(value, 'as_sql')\n                             and not hasattr(value, '_as_sql')\n                             and not value) and field.null:"
        },
        {
            "sha": "dac2cb5de5400c748733a854ece5adf0f3dfd467",
            "filename": "tests/regressiontests/model_inheritance_regress/tests.py",
            "status": "modified",
            "additions": 28,
            "deletions": 6,
            "changes": 34,
            "blob_url": "https://github.com/django/django/blob/0eb31d3dc9435b18680f7a41bc9067685beb8344/tests%2Fregressiontests%2Fmodel_inheritance_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/0eb31d3dc9435b18680f7a41bc9067685beb8344/tests%2Fregressiontests%2Fmodel_inheritance_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fmodel_inheritance_regress%2Ftests.py?ref=0eb31d3dc9435b18680f7a41bc9067685beb8344",
            "patch": "@@ -3,12 +3,16 @@\n \"\"\"\n \n import datetime\n+from operator import attrgetter\n+\n from django.test import TestCase\n-from regressiontests.model_inheritance_regress.models import (\n-    Place, Restaurant, ItalianRestaurant, ParkingLot, ParkingLot2,\n-    ParkingLot3, Supplier, Wholesaler, Child, SelfRefChild, ArticleWithAuthor,\n-    M2MChild, QualityControl, DerivedM, Person, BirthdayParty, BachelorParty,\n-    MessyBachelorParty, InternalCertificationAudit)\n+\n+from models import (Place, Restaurant, ItalianRestaurant, ParkingLot,\n+    ParkingLot2, ParkingLot3, Supplier, Wholesaler, Child, SelfRefParent,\n+    SelfRefChild, ArticleWithAuthor, M2MChild, QualityControl, DerivedM,\n+    Person, BirthdayParty, BachelorParty, MessyBachelorParty,\n+    InternalCertificationAudit)\n+\n \n class ModelInheritanceTest(TestCase):\n     def test_model_inheritance(self):\n@@ -355,7 +359,10 @@ def test_abstract_base_class_m2m_relation_inheritance(self):\n         self.assertEqual(parties, [bachelor, messy_parent])\n \n     def test_11369(self):\n-        \"\"\"verbose_name_plural correctly inherited from ABC if inheritance chain includes an abstract model.\"\"\"\n+        \"\"\"\n+        verbose_name_plural correctly inherited from ABC if inheritance chain\n+        includes an abstract model.\n+        \"\"\"\n         # Regression test for #11369: verbose_name_plural should be inherited\n         # from an ABC even when there are one or more intermediate\n         # abstract models in the inheritance chain, for consistency with\n@@ -364,3 +371,18 @@ def test_11369(self):\n                 InternalCertificationAudit._meta.verbose_name_plural,\n                 u'Audits'\n         )\n+\n+    def test_inherited_nullable_exclude(self):\n+        obj = SelfRefChild.objects.create(child_data=37, parent_data=42)\n+        self.assertQuerysetEqual(\n+            SelfRefParent.objects.exclude(self_data=72), [\n+                obj.pk\n+            ],\n+            attrgetter(\"pk\")\n+        )\n+        self.assertQuerysetEqual(\n+            SelfRefChild.objects.exclude(self_data=72), [\n+                obj.pk\n+            ],\n+            attrgetter(\"pk\")\n+        )"
        }
    ],
    "stats": {
        "total": 44,
        "additions": 34,
        "deletions": 10
    }
}