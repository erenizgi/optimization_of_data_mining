{
    "author": "aaugustin",
    "message": "Fixed #17738 -- Extended the time zone documentation with a FAQ. Thanks Anssi for the questions and Jannis for the review.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17645 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "af3791fa7ff559e96e142efbc4f90c75093200c8",
    "files": [
        {
            "sha": "d66a49a2ab3b336f5ce2f09fcb6a6e80f19dc563",
            "filename": "docs/topics/i18n/timezones.txt",
            "status": "modified",
            "additions": 249,
            "deletions": 9,
            "changes": 258,
            "blob_url": "https://github.com/django/django/blob/af3791fa7ff559e96e142efbc4f90c75093200c8/docs%2Ftopics%2Fi18n%2Ftimezones.txt",
            "raw_url": "https://github.com/django/django/raw/af3791fa7ff559e96e142efbc4f90c75093200c8/docs%2Ftopics%2Fi18n%2Ftimezones.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fi18n%2Ftimezones.txt?ref=af3791fa7ff559e96e142efbc4f90c75093200c8",
            "patch": "@@ -6,6 +6,8 @@ Time zones\n \n .. versionadded:: 1.4\n \n+.. _time-zones-overview:\n+\n Overview\n ========\n \n@@ -30,7 +32,11 @@ interacting with end users.\n \n Time zone support is disabled by default. To enable it, set :setting:`USE_TZ =\n True <USE_TZ>` in your settings file. Installing pytz_ is highly recommended,\n-but not mandatory.\n+but not mandatory. It's as simple as::\n+\n+.. code-block::\n+\n+    $ sudo pip install pytz\n \n .. note::\n \n@@ -44,6 +50,9 @@ but not mandatory.\n     controls if Django should activate format localization. See\n     :doc:`/topics/i18n/formatting` for more details.\n \n+If you're stumbling on a particular problem, start with the :ref:`time zone\n+FAQ <time-zones-faq>`.\n+\n Concepts\n ========\n \n@@ -132,15 +141,9 @@ Default time zone and current time zone\n The **default time zone** is the time zone defined by the :setting:`TIME_ZONE`\n setting.\n \n-When pytz_ is available, Django loads the definition of the default time zone\n-from the `tz database`_. This is the most accurate solution. Otherwise, it\n-relies on the difference between local time and UTC, as reported by the\n-operating system, to compute conversions. This is less reliable, especially\n-around DST transitions.\n-\n The **current time zone** is the time zone that's used for rendering.\n \n-You should set it to the end user's actual time zone with\n+You should set the current time zone to the end user's actual time zone with\n :func:`~django.utils.timezone.activate`. Otherwise, the default time zone is\n used.\n \n@@ -173,7 +176,7 @@ selection logic that makes sense for you.\n Most websites who care about time zones just ask users in which time zone they\n live and store this information in the user's profile. For anonymous users,\n they use the time zone of their primary audience or UTC. pytz_ provides\n-helpers, like a list of time zones per country, that you can use to pre-select\n+helpers_, like a list of time zones per country, that you can use to pre-select\n the most likely choices.\n \n Here's an example that stores the current timezone in the session. (It skips\n@@ -217,6 +220,8 @@ Include a form in ``template.html`` that will ``POST`` to this view:\n         <input type=\"submit\" value=\"Set\" />\n     </form>\n \n+.. _time-zones-in-forms:\n+\n Time zone aware input in forms\n ==============================\n \n@@ -464,6 +469,241 @@ You can regenerate fixtures with :djadmin:`loaddata` then :djadmin:`dumpdata`.\n Or, if they're small enough, you can simply edit them to add the UTC offset\n that matches your :setting:`TIME_ZONE` to each serialized datetime.\n \n+.. _time-zones-faq:\n+\n+FAQ\n+===\n+\n+Setup\n+-----\n+\n+1. **I don't need multiple time zones. Should I enable time zone support?**\n+\n+   Yes. When time zone support is enabled, Django uses a more accurate model\n+   of local time. This shields you from subtle and unreproducible bugs around\n+   daylight saving time (DST) transitions. Remember that your website runs 24/7!\n+\n+   In this regard, time zones is comparable to ``unicode`` in Python. At first\n+   it's hard. You get encoding and decoding errors. Then you learn the rules.\n+   And some problems disappear -- you never get mangled output again when your\n+   application receives non-ASCII input.\n+\n+   When you enable time zone support, you'll encounter some errors because\n+   you're using naive datetimes where Django expects aware datetimes. Such\n+   errors show up when running tests and they're easy to fix. You'll quickly\n+   learn how to avoid invalid operations.\n+\n+   On the other hand, bugs caused by the lack of time zone support are much\n+   harder to prevent, diagnose and fix. Anything that involves scheduled tasks\n+   or datetime arithmetic is a candidate for subtle bugs that will bite you\n+   only once or twice a year.\n+\n+   For these reasons, time zone support is enabled by default in new projects,\n+   and you should keep it unless you have a very good reason not to.\n+\n+2. **I've enabled time zone support, am I safe?**\n+\n+   Maybe. You're better protected from DST-related bugs, but you can still\n+   shoot yourself in the foot by carelessly turning naive datetimes into aware\n+   datetimes, and vice-versa.\n+\n+   If your application connects to other systems, for instance if it queries\n+   a webservice, make sure datetimes are properly specified. To transmit\n+   datetimes safely, their representation should include the UTC offset, or\n+   their values should be in UTC (or both!).\n+\n+   Finally, our calendar system contains interesting traps for computers::\n+\n+       >>> import datetime\n+       >>> def substract_one_year(value):       # DON'T DO THAT!\n+       ...     return value.replace(year=value.year - 1)\n+       >>> one_year_before(datetime.datetime(2012, 3, 1, 10, 0))\n+       datetime.datetime(2011, 3, 1, 10, 0)\n+       >>> one_year_before(datetime.datetime(2012, 2, 29, 10, 0))\n+       Traceback (most recent call last):\n+       ...\n+       ValueError: day is out of range for month\n+\n+   (To implement this function, you must decide whether 2012-02-29 minus\n+   one year is 2011-02-28 or 2011-03-01, which depends on your business\n+   requirements.)\n+\n+3. **Should I install pytz?**\n+\n+   Yes. Django has a policy of not requiring external dependencies, and for\n+   this reason pytz_ is optional. However, it's much safer to install it.\n+\n+   As soon as you activate time zone support, Django needs a definition of the\n+   default time zone. When pytz is available, Django loads this definition\n+   from the `tz database`_. This is the most accurate solution. Otherwise, it\n+   relies on the difference between local time and UTC, as reported by the\n+   operating system, to compute conversions. This is less reliable, especially\n+   around DST transitions.\n+\n+   Furthermore, if you want to support users in more than one time zone, pytz\n+   is the reference for time zone definitions.\n+\n+Troubleshooting\n+---------------\n+\n+1. **My application crashes with** ``TypeError: can't compare offset-naive``\n+   ``and offset-aware datetimes`` **-- what's wrong?**\n+\n+   First, don't panic. Then, let's reproduce this error, simply by comparing a\n+   naive and an aware datetime::\n+\n+       >>> import datetime\n+       >>> from django.utils import timezone\n+       >>> naive = datetime.datetime.utcnow()\n+       >>> aware = naive.replace(tzinfo=timezone.utc)\n+       >>> naive == aware\n+       Traceback (most recent call last):\n+       ...\n+       TypeError: can't compare offset-naive and offset-aware datetimes\n+\n+   If you encounter this error, most likely, your code is comparing:\n+\n+   - a datetime provided by Django, for instance a value read from a form or\n+     a model field: since you enabled time zone support, it is aware;\n+   - a datetime generated by your code, which is naive (or you wouldn't be\n+     reading this).\n+\n+   Generally, the correct solution is to change your code to use an aware\n+   datetime instead.\n+\n+   If you're writing a pluggable application that's expected to work\n+   independently of the value of :setting:`USE_TZ`, you may find\n+   :func:`django.utils.timezone.now` useful. This function returns the current\n+   date and time as a naive datetime when ``USE_TZ = False`` and as an aware\n+   datetime when ``USE_TZ = True``. You can add or substract\n+   :class:`datetime.timedelta` as needed.\n+\n+2. **I see lots of** ``RuntimeWarning: DateTimeField received a naive\n+   datetime`` ``(YYYY-MM-DD HH:MM:SS)`` ``while time zone support is active``\n+   **-- is it bad?**\n+\n+   When time zone support is enabled, the database layer expects to receive\n+   only aware datetimes from your code. This warning occurs when it receives a\n+   naive datetime. This indicates that you haven't finished porting your code\n+   for time zone support. Please refer to the :ref:`migration guide\n+   <time-zones-migration-guide>` for tips on this process.\n+\n+   In the meantime, for backwards compatibility, the datetime is considered to\n+   be in the default time zone, which is generally what you expect.\n+\n+3. ``now.date()`` **is yesterday! (or tomorrow)**\n+\n+   If you've always used naive datetimes, you probably believe that you can\n+   convert a datetime to a date by calling its :meth:`~datetime.datetime.date`\n+   method. You also consider that a :class:`~datetime.date` is a lot like a\n+   :class:`~datetime.datetime`, except that it's less accurate.\n+\n+   None of this is true in a time zone aware environment::\n+\n+       >>> import datetime\n+       >>> import pytz\n+       >>> paris_tz = pytz.timezone(\"Europe/Paris\")\n+       >>> new_york_tz = pytz.timezone(\"America/New_York\")\n+       >>> paris = paris_tz.localize(datetime.datetime(2012, 3, 3, 1, 30))\n+       # This is the correct way to convert between time zones with pytz.\n+       >>> new_york = new_york_tz.normalize(paris.astimezone(new_york_tz))\n+       >>> paris == new_york, paris.date() == new_york.date()\n+       (True, False)\n+       >>> paris - new_york, paris.date() - new_york.date()\n+       (datetime.timedelta(0), datetime.timedelta(1))\n+       >>> paris\n+       datetime.datetime(2012, 3, 3, 1, 30, tzinfo=<DstTzInfo 'Europe/Paris' CET+1:00:00 STD>)\n+       >>> new_york\n+       datetime.datetime(2012, 3, 2, 19, 30, tzinfo=<DstTzInfo 'America/New_York' EST-1 day, 19:00:00 STD>)\n+\n+   As this example shows, the same datetime has a different date, depending on\n+   the time zone in which it is representend. But the real problem is more\n+   fundamental.\n+\n+   A datetime represents a **point in time**. It's absolute: it doesn't depend\n+   on anything (barring relativistic effects). On the contrary, a date is a\n+   **calendaring concept**. It's a period of time whose bounds depend on the\n+   time zone in which the date is considered. As you can see, these two\n+   concepts are fundamentally different and converting a datetime to a date\n+   isn't a deterministic operation.\n+\n+   What does this mean in practice?\n+\n+   Generally, you should avoid converting a :class:`~datetime.datetime` to\n+   :class:`~datetime.date`. For instance, you can use the :tfilter:`date`\n+   template filter to only show the date part of a datetime. This filter will\n+   convert the datetime into the current time zone before formatting it,\n+   ensuring the results appear correct for the user.\n+\n+   If you really need to do the conversion yourself, you must ensure the\n+   datetime is converted to the appropriate time zone first. Usually, this\n+   will be the current timezone::\n+\n+       >>> from django.utils import timezone\n+       >>> timezone.activate(pytz.timezone(\"Asia/Singapore\"))\n+       # For this example, we just set the time zone to Singapore, but here's how\n+       # you would obtain the current time zone in the general case.\n+       >>> current_tz = timezone.get_current_timezone()\n+       # Again, this is the correct way to convert between time zones with pytz.\n+       >>> local = current_tz.normalize(paris.astimezone(current_tz))\n+       >>> local\n+       datetime.datetime(2012, 3, 3, 8, 30, tzinfo=<DstTzInfo 'Asia/Singapore' SGT+8:00:00 STD>)\n+       >>> local.date()\n+       datetime.date(2012, 3, 3)\n+\n+Usage\n+-----\n+\n+1. **I have this string** ``\"2012-02-21 10:28:45\"`` **and I know it's in the**\n+   ``\"Europe/Helsinki\"`` **time zone. How do I turn that into an aware\n+   datetime?**\n+\n+   This is exactly what pytz_ is for.\n+\n+       >>> from django.utils.dateparse import parse_datetime\n+       >>> naive = parse_datetime(\"2012-02-21 10:28:45\")\n+       >>> import pytz\n+       >>> pytz.timezone(\"Europe/Helsinki\").localize(naive)\n+       datetime.datetime(2012, 2, 21, 10, 28, 45, tzinfo=<DstTzInfo 'Europe/Helsinki' EET+2:00:00 STD>)\n+\n+   Note that ``localize`` is a pytz extension to the :class:`~datetime.tzinfo`\n+   API. Also, you may want to catch :exc:`~pytz.InvalidTimeError`. The\n+   documentation of pytz contains `more examples`_; you should review it\n+   before attempting to manipulate aware datetimes.\n+\n+2. **How can I obtain the current time in the local time zone?**\n+\n+   Well, the first question is, do you really need to?\n+\n+   You should only use local time when you're interacting with humans, and the\n+   template layer provides :ref:`filters and tags <time-zones-in-templates>`\n+   to convert datetimes to the time zone of your choice.\n+\n+   Furthermore, Python knows how to compare aware datetimes, taking into\n+   account UTC offsets when necessary. It's much easier (and possibly faster)\n+   to write all your model and view code in UTC. So, in most circumstances,\n+   the datetime in UTC returned by :func:`django.utils.timezone.now` will be\n+   sufficient.\n+\n+   For the shake of completeness, if you really wanted the current time in the\n+   local time zone, here's how you would obtain it::\n+\n+       >>> import datetime\n+       >>> from django.utils import timezone\n+       >>> datetime.datetime.now(tz=timezone.get_default_timezone())\n+       datetime.datetime(2012, 3, 3, 20, 10, 53, 873365, tzinfo=<DstTzInfo 'Europe/Paris' CET+1:00:00 STD>)\n+\n+   In this example, pytz_ is installed and :setting:`TIME_ZONE` is\n+   ``\"Europe/Paris\"``.\n+\n+3. **How can I see all available time zones?**\n+\n+   pytz_ provides helpers_, including a list of current time zones and a list\n+   of all available time zones -- some of which are only of historical\n+   interest.\n+\n .. _pytz: http://pytz.sourceforge.net/\n+.. _more examples: http://pytz.sourceforge.net/#example-usage\n .. _these issues: http://pytz.sourceforge.net/#problems-with-localtime\n+.. _helpers: http://pytz.sourceforge.net/#helpers\n .. _tz database: http://en.wikipedia.org/wiki/Tz_database"
        }
    ],
    "stats": {
        "total": 258,
        "additions": 249,
        "deletions": 9
    }
}