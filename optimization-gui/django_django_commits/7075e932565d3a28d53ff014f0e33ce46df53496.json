{
    "author": "aaugustin",
    "message": "Made the database cache backend, which bypasses the ORM, compatible with time zone support.\n\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17119 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "7075e932565d3a28d53ff014f0e33ce46df53496",
    "files": [
        {
            "sha": "2baa12893e942d08967954bdc2005f3e57294c62",
            "filename": "django/core/cache/backends/db.py",
            "status": "modified",
            "additions": 52,
            "deletions": 15,
            "changes": 67,
            "blob_url": "https://github.com/django/django/blob/7075e932565d3a28d53ff014f0e33ce46df53496/django%2Fcore%2Fcache%2Fbackends%2Fdb.py",
            "raw_url": "https://github.com/django/django/raw/7075e932565d3a28d53ff014f0e33ce46df53496/django%2Fcore%2Fcache%2Fbackends%2Fdb.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Fdb.py?ref=7075e932565d3a28d53ff014f0e33ce46df53496",
            "patch": "@@ -8,8 +8,10 @@\n except ImportError:\n     import pickle\n \n+from django.conf import settings\n from django.core.cache.backends.base import BaseCache\n from django.db import connections, router, transaction, DatabaseError\n+from django.utils import timezone\n \n \n class Options(object):\n@@ -38,22 +40,35 @@ class CacheEntry(object):\n         self.cache_model_class = CacheEntry\n \n class DatabaseCache(BaseDatabaseCache):\n+\n+    # This class uses cursors provided by the database connection. This means\n+    # it reads expiration values as aware or naive datetimes depending on the\n+    # value of USE_TZ. They must be compared to aware or naive representations\n+    # of \"now\" respectively.\n+\n+    # But it bypasses the ORM for write operations. As a consequence, aware\n+    # datetimes aren't made naive for databases that don't support time zones.\n+    # We work around this problem by always using naive datetimes when writing\n+    # expiration values, in UTC when USE_TZ = True and in local time otherwise.\n+\n     def get(self, key, default=None, version=None):\n         key = self.make_key(key, version=version)\n         self.validate_key(key)\n         db = router.db_for_read(self.cache_model_class)\n         table = connections[db].ops.quote_name(self._table)\n         cursor = connections[db].cursor()\n \n-        cursor.execute(\"SELECT cache_key, value, expires FROM %s WHERE cache_key = %%s\" % table, [key])\n+        cursor.execute(\"SELECT cache_key, value, expires FROM %s \"\n+                       \"WHERE cache_key = %%s\" % table, [key])\n         row = cursor.fetchone()\n         if row is None:\n             return default\n-        now = datetime.now()\n+        now = timezone.now()\n         if row[2] < now:\n             db = router.db_for_write(self.cache_model_class)\n             cursor = connections[db].cursor()\n-            cursor.execute(\"DELETE FROM %s WHERE cache_key = %%s\" % table, [key])\n+            cursor.execute(\"DELETE FROM %s \"\n+                           \"WHERE cache_key = %%s\" % table, [key])\n             transaction.commit_unless_managed(using=db)\n             return default\n         value = connections[db].ops.process_clob(row[1])\n@@ -78,20 +93,28 @@ def _base_set(self, mode, key, value, timeout=None):\n \n         cursor.execute(\"SELECT COUNT(*) FROM %s\" % table)\n         num = cursor.fetchone()[0]\n-        now = datetime.now().replace(microsecond=0)\n-        exp = datetime.fromtimestamp(time.time() + timeout).replace(microsecond=0)\n+        now = timezone.now()\n+        now = now.replace(microsecond=0)\n+        if settings.USE_TZ:\n+            exp = datetime.utcfromtimestamp(time.time() + timeout)\n+        else:\n+            exp = datetime.fromtimestamp(time.time() + timeout)\n+        exp = exp.replace(microsecond=0)\n         if num > self._max_entries:\n             self._cull(db, cursor, now)\n         encoded = base64.encodestring(pickle.dumps(value, 2)).strip()\n-        cursor.execute(\"SELECT cache_key, expires FROM %s WHERE cache_key = %%s\" % table, [key])\n+        cursor.execute(\"SELECT cache_key, expires FROM %s \"\n+                       \"WHERE cache_key = %%s\" % table, [key])\n         try:\n             result = cursor.fetchone()\n             if result and (mode == 'set' or\n                     (mode == 'add' and result[1] < now)):\n-                cursor.execute(\"UPDATE %s SET value = %%s, expires = %%s WHERE cache_key = %%s\" % table,\n+                cursor.execute(\"UPDATE %s SET value = %%s, expires = %%s \"\n+                               \"WHERE cache_key = %%s\" % table,\n                                [encoded, connections[db].ops.value_to_db_datetime(exp), key])\n             else:\n-                cursor.execute(\"INSERT INTO %s (cache_key, value, expires) VALUES (%%s, %%s, %%s)\" % table,\n+                cursor.execute(\"INSERT INTO %s (cache_key, value, expires) \"\n+                               \"VALUES (%%s, %%s, %%s)\" % table,\n                                [key, encoded, connections[db].ops.value_to_db_datetime(exp)])\n         except DatabaseError:\n             # To be threadsafe, updates/inserts are allowed to fail silently\n@@ -120,15 +143,22 @@ def has_key(self, key, version=None):\n         table = connections[db].ops.quote_name(self._table)\n         cursor = connections[db].cursor()\n \n-        now = datetime.now().replace(microsecond=0)\n-        cursor.execute(\"SELECT cache_key FROM %s WHERE cache_key = %%s and expires > %%s\" % table,\n+        if settings.USE_TZ:\n+            now = datetime.utcnow()\n+        else:\n+            now = datetime.now()\n+        now = now.replace(microsecond=0)\n+        cursor.execute(\"SELECT cache_key FROM %s \"\n+                       \"WHERE cache_key = %%s and expires > %%s\" % table,\n                        [key, connections[db].ops.value_to_db_datetime(now)])\n         return cursor.fetchone() is not None\n \n     def _cull(self, db, cursor, now):\n         if self._cull_frequency == 0:\n             self.clear()\n         else:\n+            # When USE_TZ is True, 'now' will be an aware datetime in UTC.\n+            now = now.replace(tzinfo=None)\n             table = connections[db].ops.quote_name(self._table)\n             cursor.execute(\"DELETE FROM %s WHERE expires < %%s\" % table,\n                            [connections[db].ops.value_to_db_datetime(now)])\n@@ -137,12 +167,19 @@ def _cull(self, db, cursor, now):\n             if num > self._max_entries:\n                 cull_num = num / self._cull_frequency\n                 if connections[db].vendor == 'oracle':\n-                    # Special case for Oracle because it doesn't support LIMIT + OFFSET\n-                    cursor.execute(\"SELECT cache_key FROM (SELECT ROW_NUMBER() OVER (ORDER BY cache_key) AS counter, cache_key FROM %s) WHERE counter > %%s AND COUNTER <= %%s\" % table, [cull_num, cull_num + 1])\n+                    # Oracle doesn't support LIMIT + OFFSET\n+                    cursor.execute(\"\"\"SELECT cache_key FROM\n+(SELECT ROW_NUMBER() OVER (ORDER BY cache_key) AS counter, cache_key FROM %s)\n+WHERE counter > %%s AND COUNTER <= %%s\"\"\" % table, [cull_num, cull_num + 1])\n                 else:\n-                    # This isn't standard SQL, it's likely to break with some non officially supported databases             \n-                    cursor.execute(\"SELECT cache_key FROM %s ORDER BY cache_key LIMIT 1 OFFSET %%s\" % table, [cull_num])\n-                cursor.execute(\"DELETE FROM %s WHERE cache_key < %%s\" % table, [cursor.fetchone()[0]])\n+                    # This isn't standard SQL, it's likely to break\n+                    # with some non officially supported databases\n+                    cursor.execute(\"SELECT cache_key FROM %s \"\n+                                   \"ORDER BY cache_key \"\n+                                   \"LIMIT 1 OFFSET %%s\" % table, [cull_num])\n+                cursor.execute(\"DELETE FROM %s \"\n+                               \"WHERE cache_key < %%s\" % table,\n+                               [cursor.fetchone()[0]])\n \n     def clear(self):\n         db = router.db_for_write(self.cache_model_class)"
        },
        {
            "sha": "2cd648b780df0cf8f1f193fdefcd414165d4369c",
            "filename": "tests/regressiontests/cache/models.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/7075e932565d3a28d53ff014f0e33ce46df53496/tests%2Fregressiontests%2Fcache%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/7075e932565d3a28d53ff014f0e33ce46df53496/tests%2Fregressiontests%2Fcache%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fcache%2Fmodels.py?ref=7075e932565d3a28d53ff014f0e33ce46df53496",
            "patch": "@@ -1,11 +1,11 @@\n-from datetime import datetime\n+from django.utils import timezone\n \n from django.db import models\n \n \n def expensive_calculation():\n     expensive_calculation.num_runs += 1\n-    return datetime.now()\n+    return timezone.now()\n \n class Poll(models.Model):\n     question = models.CharField(max_length=200)"
        },
        {
            "sha": "8cb7c2e4ec642e1c9d22e3d40c81ca339a0500e6",
            "filename": "tests/regressiontests/cache/tests.py",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/7075e932565d3a28d53ff014f0e33ce46df53496/tests%2Fregressiontests%2Fcache%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/7075e932565d3a28d53ff014f0e33ce46df53496/tests%2Fregressiontests%2Fcache%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fcache%2Ftests.py?ref=7075e932565d3a28d53ff014f0e33ce46df53496",
            "patch": "@@ -746,7 +746,7 @@ def custom_key_func(key, key_prefix, version):\n     return 'CUSTOM-' + '-'.join([key_prefix, str(version), key])\n \n \n-class DBCacheTests(unittest.TestCase, BaseCacheTests):\n+class DBCacheTests(BaseCacheTests, TestCase):\n     backend_name = 'django.core.cache.backends.db.DatabaseCache'\n \n     def setUp(self):\n@@ -763,6 +763,7 @@ def tearDown(self):\n         from django.db import connection\n         cursor = connection.cursor()\n         cursor.execute('DROP TABLE %s' % connection.ops.quote_name(self._table_name))\n+        connection.commit()\n \n     def test_cull(self):\n         self.perform_cull_test(50, 29)\n@@ -776,6 +777,9 @@ def test_old_initialization(self):\n         self.perform_cull_test(50, 18)\n \n \n+DBCacheWithTimeZoneTests = override_settings(USE_TZ=True)(DBCacheTests)\n+\n+\n class DBCacheRouter(object):\n     \"\"\"A router that puts the cache table on the 'other' database.\"\"\"\n "
        }
    ],
    "stats": {
        "total": 77,
        "additions": 59,
        "deletions": 18
    }
}