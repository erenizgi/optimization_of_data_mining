{
    "author": "aaugustin",
    "message": "Updated the release process docs to reflect the current practices.\n\nFixed #17919.",
    "sha": "5d883589a8f6950e98538c9509a201d61573460d",
    "files": [
        {
            "sha": "29ce3914b42a781bf782445efe5839d29180762e",
            "filename": "docs/internals/release-process.txt",
            "status": "modified",
            "additions": 82,
            "deletions": 74,
            "changes": 156,
            "blob_url": "https://github.com/django/django/blob/5d883589a8f6950e98538c9509a201d61573460d/docs%2Finternals%2Frelease-process.txt",
            "raw_url": "https://github.com/django/django/raw/5d883589a8f6950e98538c9509a201d61573460d/docs%2Finternals%2Frelease-process.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Finternals%2Frelease-process.txt?ref=5d883589a8f6950e98538c9509a201d61573460d",
            "patch": "@@ -13,12 +13,12 @@ Since version 1.0, Django's release numbering works as follows:\n \n * ``A`` is the *major version* number, which is only incremented for major\n   changes to Django, and these changes are not necessarily\n-  backwards-compatible. That is, code you wrote for Django 1.2 may break\n+  backwards-compatible. That is, code you wrote for Django 1.6 may break\n   when we release Django 2.0.\n \n * ``B`` is the *minor version* number, which is incremented for large yet\n-  backwards compatible changes.  Code written for Django 1.2 will continue\n-  to work under Django 1.3. Exceptions to this rule will be listed in the\n+  backwards compatible changes.  Code written for Django 1.6 will continue\n+  to work under Django 1.7. Exceptions to this rule will be listed in the\n   release notes.\n \n * ``C`` is the *micro version* number, which is incremented for bug and\n@@ -27,67 +27,62 @@ Since version 1.0, Django's release numbering works as follows:\n   can't be fixed without breaking backwards-compatibility. If this happens,\n   the release notes will provide detailed upgrade instructions.\n \n-* In some cases, we'll make alpha, beta, or release candidate releases.\n-  These are of the form ``A.B alpha/beta/rc N``, which means the ``Nth``\n-  alpha/beta/release candidate of version ``A.B``.\n+* Before a new minor release, we'll make alpha, beta, and release candidate\n+  releases. These are of the form ``A.B alpha/beta/rc N``, which means the\n+  ``Nth`` alpha/beta/release candidate of version ``A.B``.\n \n-In git, each Django release will have a tag indicating its version\n-number, signed with the Django release key. Additionally, each release\n-series (X.Y) has its own branch, and bugfix/security releases will be\n+In git, each Django release will have a tag indicating its version number,\n+signed with the Django release key. Additionally, each release series has its\n+own branch, called ``stable/A.B.x``, and bugfix/security releases will be\n issued from those branches.\n \n-For more information about how the Django project issues new releases\n-for security purposes, please see :doc:`our security policies\n-<security>`.\n+For more information about how the Django project issues new releases for\n+security purposes, please see :doc:`our security policies <security>`.\n \n Major releases\n --------------\n \n Major releases (1.0, 2.0, etc.) will happen very infrequently (think \"years\",\n-not \"months\"), and will probably represent major, sweeping changes to Django.\n+not \"months\"), and may represent major, sweeping changes to Django.\n \n Minor releases\n --------------\n \n-Minor release (1.1, 1.2, etc.) will happen roughly every nine months -- see\n-`release process`_, below for details.\n+Minor release (1.5, 1.6, etc.) will happen roughly every nine months -- see\n+`release process`_, below for details. These releases will contain new\n+features, improvements to existing features, and such.\n \n .. _internal-release-deprecation-policy:\n \n-These releases will contain new features, improvements to existing features, and\n-such. A minor release may deprecate certain features from previous releases. If a\n-feature in version ``A.B`` is deprecated, it will continue to work in version\n-``A.B+1``. In version ``A.B+2``, use of the feature will raise a\n-``DeprecationWarning`` but will continue to work. Version ``A.B+3`` will\n-remove the feature entirely.\n+A minor release may deprecate certain features from previous releases. If a\n+feature is deprecated in version ``A.B``, it will continue to work in versions\n+``A.B`` and  ``A.B+1`` but raise warnings. It will be removed in version\n+``A.B+2``.\n \n-So, for example, if we decided to remove a function that existed in Django 1.0:\n+So, for example, if we decided to start the deprecation of a function in\n+Django 1.5:\n \n-* Django 1.1 will contain a backwards-compatible replica of the function\n-  which will raise a ``PendingDeprecationWarning``. This warning is silent\n-  by default; you need to explicitly turn on display of these warnings.\n+* Django 1.5 will contain a backwards-compatible replica of the function which\n+  will raise a ``PendingDeprecationWarning``. This warning is silent by\n+  default; you can turn on display of these warnings with the ``-Wd`` option\n+  of Python.\n \n-* Django 1.2 will contain the backwards-compatible replica, but the warning\n+* Django 1.6 will contain the backwards-compatible replica, but the warning\n   will be promoted to a full-fledged ``DeprecationWarning``. This warning is\n   *loud* by default, and will likely be quite annoying.\n \n-* Django 1.3 will remove the feature outright.\n+* Django 1.7 will remove the feature outright.\n \n Micro releases\n --------------\n \n-Micro releases (1.0.1, 1.0.2, 1.1.1, etc.) will be issued at least once half-way\n-between minor releases, and probably more often as needed.\n+Micro releases (1.5.1, 1.6.2, 1.6.1, etc.) will be issued as needed, often to\n+fix security issues.\n \n These releases will be 100% compatible with the associated minor release, unless\n this is impossible for security reasons. So the answer to \"should I upgrade to\n the latest micro release?\" will always be \"yes.\"\n \n-Each minor release of Django will have a \"release maintainer\" appointed. This\n-person will be responsible for making sure that bug fixes are applied to both\n-trunk and the maintained micro-release branch. This person will also work with\n-the release manager to decide when to release the micro releases.\n-\n .. _backwards-compatibility-policy:\n \n Supported versions\n@@ -96,10 +91,10 @@ Supported versions\n At any moment in time, Django's developer team will support a set of releases to\n varying levels:\n \n-* The current development trunk will get new features and bug fixes\n+* The current development master will get new features and bug fixes\n   requiring major refactoring.\n \n-* Patches applied to the trunk will also be applied to the last minor\n+* Patches applied to the master branch must also be applied to the last minor\n   release, to be released as the next micro release, when they fix critical\n   problems:\n \n@@ -111,40 +106,42 @@ varying levels:\n \n   * Major functionality bugs in newly-introduced features.\n \n-  The rule of thumb is that fixes will be backported to the last minor\n-  release for bugs that would have prevented a release in the first place.\n+  The rule of thumb is that fixes will be backported to the last minor release\n+  for bugs that would have prevented a release in the first place (release\n+  blockers).\n \n-* Security fixes will be applied to the current trunk and the previous two\n+* Security fixes will be applied to the current master and the previous two\n   minor releases.\n \n+* Committers may choose to backport bugfixes at their own discretion,\n+  provided they do not introduce backwards incompatibilities.\n+\n * Documentation fixes generally will be more freely backported to the last\n-  release branch, at the discretion of the committer, and they don't need to\n-  meet the \"critical fixes only\" bar. That's because it's highly advantageous\n-  to have the docs for the last release be up-to-date and correct, and the\n-  downside of backporting (risk of introducing regressions) is much less of a\n-  concern.\n+  release branch. That's because it's highly advantageous to have the docs for\n+  the last release be up-to-date and correct, and the risk of introducing\n+  regressions is much less of a concern.\n \n As a concrete example, consider a moment in time halfway between the release of\n-Django 1.3 and 1.4. At this point in time:\n+Django 1.6 and 1.7. At this point in time:\n \n-* Features will be added to development trunk, to be released as Django 1.4.\n+* Features will be added to development master, to be released as Django 1.7.\n \n-* Critical bug fixes will be applied to a ``1.3.X`` branch, and released as\n-  1.3.1, 1.3.2, etc.\n+* Critical bug fixes will be applied to the ``stable/1.6.X`` branch, and\n+  released as 1.6.1, 1.6.2, etc.\n \n-* Security fixes will be applied to trunk, a ``1.3.X`` branch and a\n-  ``1.2.X`` branch. They will trigger the release of ``1.3.1``, ``1.2.1``,\n-  etc.\n+* Security fixes will be applied to ``master``, to the ``stable/1.6.X``\n+  branch, and to the ``stable/1.5.X`` branch. They will trigger the release of\n+  ``1.6.1``, ``1.5.1``, etc.\n \n-* Documentation fixes will be applied to trunk, and, if easily backported, to\n-  the ``1.3.X`` branch.\n+* Documentation fixes will be applied to master, and, if easily backported, to\n+  the ``1.6.X`` branch. Bugfixes may also be backported.\n \n .. _release-process:\n \n Release process\n ===============\n \n-Django uses a time-based release schedule, with minor (i.e. 1.1, 1.2, etc.)\n+Django uses a time-based release schedule, with minor (i.e. 1.6, 1.7, etc.)\n releases every nine months, or more, depending on features.\n \n After each release, and after a suitable cooling-off period of a few weeks, the\n@@ -190,45 +187,56 @@ At the end of phase two, any unfinished \"maybe\" features will be postponed until\n the next release. Though it shouldn't happen, any \"must-have\" features will\n extend phase two, and thus postpone the final release.\n \n-Phase two will culminate with an alpha release.\n+Phase two will culminate with an alpha release. At this point, the\n+``stable/A.B.x`` branch will be forked from ``master``.\n \n Phase three: bugfixes\n ~~~~~~~~~~~~~~~~~~~~~\n \n The last third of a release is spent fixing bugs -- no new features will be\n-accepted during this time. We'll release a beta release about halfway through,\n-and an rc complete with string freeze two weeks before the end of the schedule.\n+accepted during this time. We'll try to release a beta release after one month\n+and a release candidate after two months.\n+\n+The release candidate marks the string freeze, and it happens at least two\n+weeks before the final release. After this point, new translatable strings\n+must not be added.\n+\n+During this phase, committers will be more and more conservative with\n+backports, to avoid introducing regressions. After the release candidate, only\n+release blockers and documentation fixes should be backported.\n+\n+In parallel to this phase, ``master`` can receive new features, to be released\n+in the ``A.B+1`` cycle.\n \n Bug-fix releases\n ----------------\n \n-After a minor release (e.g. 1.1), the previous release will go into bugfix\n+After a minor release (e.g. 1.6), the previous release will go into bugfix\n mode.\n \n-A branch will be created of the form ``branches/releases/1.0.X`` to track\n-bugfixes to the previous release. Critical bugs fixed on trunk must\n-*also* be fixed on the bugfix branch; this means that commits need to cleanly\n-separate bug fixes from feature additions. The developer who commits a fix to\n-trunk will be responsible for also applying the fix to the current bugfix\n-branch.  Each bugfix branch will have a maintainer who will work with the\n-committers to keep them honest on backporting bug fixes.\n+A branch will be created of the form ``stable/1.5.x`` to track bugfixes to the\n+previous release. Critical bugs fixed on master must *also* be fixed on the\n+bugfix branch; this means that commits need to cleanly separate bug fixes from\n+feature additions. The developer who commits a fix to master will be\n+responsible for also applying the fix to the current bugfix branch.\n \n How this all fits together\n --------------------------\n \n Let's look at a hypothetical example for how this all first together. Imagine,\n-if you will, a point about halfway between 1.1 and 1.2. At this point,\n+if you will, a point about halfway between 1.5 and 1.6. At this point,\n development will be happening in a bunch of places:\n \n-* On trunk, development towards 1.2 proceeds with small additions, bugs\n+* On master, development towards 1.6 proceeds with small additions, bugs\n   fixes, etc. being checked in daily.\n \n-* On the branch \"branches/releases/1.1.X\", fixes for critical bugs found in\n-  the 1.1 release are checked in as needed. At some point, this branch will\n-  be released as \"1.1.1\", \"1.1.2\", etc.\n+* On the branch ``stable/1.5.x``, fixes for critical bugs found in\n+  the 1.5 release are checked in as needed. At some point, this branch will\n+  be released as \"1.5.1\", \"1.5.2\", etc.\n \n-* On the branch \"branches/releases/1.0.X\", security fixes are made if\n-  needed and released as \"1.0.2\", \"1.0.3\", etc.\n+* On the branch ``stable/1.4.x``, security fixes are made if\n+  needed and released as \"1.4.2\", \"1.4.3\", etc.\n \n-* On feature branches, development of major features is done. These\n-  branches will be merged into trunk before the end of phase two.\n+* Development of major features is done in branches in forks of the main\n+  repository. These branches will be merged into ``master`` before \"1.6\n+  alpha 1\"."
        }
    ],
    "stats": {
        "total": 156,
        "additions": 82,
        "deletions": 74
    }
}