{
    "author": "freakboy3742",
    "message": "Fixed #10571 -- Factored out the payload encoding code to make sure it is used for PUT requests. Thanks to kennu for the report, pterk for the patch, and wildfire for the review comments.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16651 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "d310f91ee7cb76db4d3dd2d1d2304a561cca3a29",
    "files": [
        {
            "sha": "e143c748b91fca90fa62ca782e598bc3f9334be5",
            "filename": "django/test/client.py",
            "status": "modified",
            "additions": 17,
            "deletions": 23,
            "changes": 40,
            "blob_url": "https://github.com/django/django/blob/d310f91ee7cb76db4d3dd2d1d2304a561cca3a29/django%2Ftest%2Fclient.py",
            "raw_url": "https://github.com/django/django/raw/d310f91ee7cb76db4d3dd2d1d2304a561cca3a29/django%2Ftest%2Fclient.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Fclient.py?ref=d310f91ee7cb76db4d3dd2d1d2304a561cca3a29",
            "patch": "@@ -207,6 +207,18 @@ def request(self, **request):\n         \"Construct a generic request object.\"\n         return WSGIRequest(self._base_environ(**request))\n \n+    def _encode_data(self, data, content_type, ):\n+        if content_type is MULTIPART_CONTENT:\n+            return encode_multipart(BOUNDARY, data)\n+        else:\n+            # Encode the content so that the byte representation is correct.\n+            match = CONTENT_TYPE_RE.match(content_type)\n+            if match:\n+                charset = match.group(1)\n+            else:\n+                charset = settings.DEFAULT_CHARSET\n+            return smart_str(data, encoding=charset)\n+\n     def _get_path(self, parsed):\n         # If there are parameters, add them\n         if parsed[3]:\n@@ -232,16 +244,7 @@ def post(self, path, data={}, content_type=MULTIPART_CONTENT,\n              **extra):\n         \"Construct a POST request.\"\n \n-        if content_type is MULTIPART_CONTENT:\n-            post_data = encode_multipart(BOUNDARY, data)\n-        else:\n-            # Encode the content so that the byte representation is correct.\n-            match = CONTENT_TYPE_RE.match(content_type)\n-            if match:\n-                charset = match.group(1)\n-            else:\n-                charset = settings.DEFAULT_CHARSET\n-            post_data = smart_str(data, encoding=charset)\n+        post_data = self._encode_data(data, content_type)\n \n         parsed = urlparse(path)\n         r = {\n@@ -286,25 +289,16 @@ def put(self, path, data={}, content_type=MULTIPART_CONTENT,\n             **extra):\n         \"Construct a PUT request.\"\n \n-        if content_type is MULTIPART_CONTENT:\n-            post_data = encode_multipart(BOUNDARY, data)\n-        else:\n-            post_data = data\n-\n-        # Make `data` into a querystring only if it's not already a string. If\n-        # it is a string, we'll assume that the caller has already encoded it.\n-        query_string = None\n-        if not isinstance(data, basestring):\n-            query_string = urlencode(data, doseq=True)\n+        put_data = self._encode_data(data, content_type)\n \n         parsed = urlparse(path)\n         r = {\n-            'CONTENT_LENGTH': len(post_data),\n+            'CONTENT_LENGTH': len(put_data),\n             'CONTENT_TYPE':   content_type,\n             'PATH_INFO':      self._get_path(parsed),\n-            'QUERY_STRING':   query_string or parsed[4],\n+            'QUERY_STRING':   parsed[4],\n             'REQUEST_METHOD': 'PUT',\n-            'wsgi.input':     FakePayload(post_data),\n+            'wsgi.input':     FakePayload(put_data),\n         }\n         r.update(extra)\n         return self.request(**r)"
        },
        {
            "sha": "18ffffde1ae975c08f25a60498bc8b28f9b7be50",
            "filename": "tests/regressiontests/test_client_regress/models.py",
            "status": "modified",
            "additions": 15,
            "deletions": 1,
            "changes": 16,
            "blob_url": "https://github.com/django/django/blob/d310f91ee7cb76db4d3dd2d1d2304a561cca3a29/tests%2Fregressiontests%2Ftest_client_regress%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/d310f91ee7cb76db4d3dd2d1d2304a561cca3a29/tests%2Fregressiontests%2Ftest_client_regress%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftest_client_regress%2Fmodels.py?ref=d310f91ee7cb76db4d3dd2d1d2304a561cca3a29",
            "patch": "@@ -770,7 +770,9 @@ def test_put(self):\n \n class QueryStringTests(TestCase):\n     def test_get_like_requests(self):\n-        for method_name in ('get','head','options','put','delete'):\n+        # See: https://code.djangoproject.com/ticket/10571.\n+        # Removed 'put' and 'delete' here as they are 'GET-like requests'\n+        for method_name in ('get','head','options'):\n             # A GET-like request can pass a query string as data\n             method = getattr(self.client, method_name)\n             response = method(\"/test_client_regress/request_data/\", data={'foo':'whiz'})\n@@ -827,6 +829,9 @@ def test_simple_unicode_payload(self):\n         response = self.client.post(\"/test_client_regress/parse_unicode_json/\", json,\n                                     content_type=\"application/json\")\n         self.assertEqual(response.content, json)\n+        response = self.client.put(\"/test_client_regress/parse_unicode_json/\", json,\n+                                    content_type=\"application/json\")\n+        self.assertEqual(response.content, json)\n \n     def test_unicode_payload_utf8(self):\n         \"A non-ASCII unicode data encoded as UTF-8 can be POSTed\"\n@@ -835,6 +840,9 @@ def test_unicode_payload_utf8(self):\n         response = self.client.post(\"/test_client_regress/parse_unicode_json/\", json,\n                                     content_type=\"application/json; charset=utf-8\")\n         self.assertEqual(response.content, json.encode('utf-8'))\n+        response = self.client.put(\"/test_client_regress/parse_unicode_json/\", json,\n+                                    content_type=\"application/json; charset=utf-8\")\n+        self.assertEqual(response.content, json.encode('utf-8'))\n \n     def test_unicode_payload_utf16(self):\n         \"A non-ASCII unicode data encoded as UTF-16 can be POSTed\"\n@@ -843,6 +851,9 @@ def test_unicode_payload_utf16(self):\n         response = self.client.post(\"/test_client_regress/parse_unicode_json/\", json,\n                                     content_type=\"application/json; charset=utf-16\")\n         self.assertEqual(response.content, json.encode('utf-16'))\n+        response = self.client.put(\"/test_client_regress/parse_unicode_json/\", json,\n+                                    content_type=\"application/json; charset=utf-16\")\n+        self.assertEqual(response.content, json.encode('utf-16'))\n \n     def test_unicode_payload_non_utf(self):\n         \"A non-ASCII unicode data as a non-UTF based encoding can be POSTed\"\n@@ -851,6 +862,9 @@ def test_unicode_payload_non_utf(self):\n         response = self.client.post(\"/test_client_regress/parse_unicode_json/\", json,\n                                     content_type=\"application/json; charset=koi8-r\")\n         self.assertEqual(response.content, json.encode('koi8-r'))\n+        response = self.client.put(\"/test_client_regress/parse_unicode_json/\", json,\n+                                    content_type=\"application/json; charset=koi8-r\")\n+        self.assertEqual(response.content, json.encode('koi8-r'))\n \n class DummyFile(object):\n     def __init__(self, filename):"
        }
    ],
    "stats": {
        "total": 56,
        "additions": 32,
        "deletions": 24
    }
}