{
    "author": "freakboy3742",
    "message": "Fixed #14876 -- Ensure that join promotion works correctly when there are nullable related fields. Thanks to simonpercivall for the report, oinopion and Aleksandra Sendecka for the original patch, and to Malcolm for helping me wrestle the edge cases to the ground.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16648 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "3afe409d0ea9d2e3e1dc70abd4bc1cc1a916daf9",
    "files": [
        {
            "sha": "d906cb1132487583726184599577ef7fc1e6bb39",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 36,
            "deletions": 14,
            "changes": 50,
            "blob_url": "https://github.com/django/django/blob/3afe409d0ea9d2e3e1dc70abd4bc1cc1a916daf9/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/3afe409d0ea9d2e3e1dc70abd4bc1cc1a916daf9/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=3afe409d0ea9d2e3e1dc70abd4bc1cc1a916daf9",
            "patch": "@@ -445,8 +445,6 @@ def combine(self, rhs, connector):\n             \"Cannot combine a unique query with a non-unique query.\"\n \n         self.remove_inherited_models()\n-        l_tables = set([a for a in self.tables if self.alias_refcount[a]])\n-        r_tables = set([a for a in rhs.tables if rhs.alias_refcount[a]])\n         # Work out how to relabel the rhs aliases, if necessary.\n         change_map = {}\n         used = set()\n@@ -471,16 +469,27 @@ def combine(self, rhs, connector):\n         # all joins exclusive to either the lhs or the rhs must be converted\n         # to an outer join.\n         if not conjunction:\n+            l_tables = set(self.tables)\n+            r_tables = set(rhs.tables)\n             # Update r_tables aliases.\n             for alias in change_map:\n                 if alias in r_tables:\n-                    r_tables.remove(alias)\n-                    r_tables.add(change_map[alias])\n+                    # r_tables may contain entries that have a refcount of 0\n+                    # if the query has references to a table that can be\n+                    # trimmed because only the foreign key is used.\n+                    # We only need to fix the aliases for the tables that\n+                    # actually have aliases.\n+                    if rhs.alias_refcount[alias]:\n+                        r_tables.remove(alias)\n+                        r_tables.add(change_map[alias])\n             # Find aliases that are exclusive to rhs or lhs.\n             # These are promoted to outer joins.\n-            outer_aliases = (l_tables | r_tables) - (l_tables & r_tables)\n-            for alias in outer_aliases:\n-                self.promote_alias(alias, True)\n+            outer_tables = (l_tables | r_tables) - (l_tables & r_tables)\n+            for alias in outer_tables:\n+                # Again, some of the tables won't have aliases due to\n+                # the trimming of unnecessary tables.\n+                if self.alias_refcount.get(alias) or rhs.alias_refcount.get(alias):\n+                    self.promote_alias(alias, True)\n \n         # Now relabel a copy of the rhs where-clause and add it to the current\n         # one.\n@@ -668,7 +677,7 @@ def promote_alias(self, alias, unconditional=False):\n         False, the join is only promoted if it is nullable, otherwise it is\n         always promoted.\n \n-        Returns True if the join was promoted.\n+        Returns True if the join was promoted by this call.\n         \"\"\"\n         if ((unconditional or self.alias_map[alias][NULLABLE]) and\n                 self.alias_map[alias][JOIN_TYPE] != self.LOUTER):\n@@ -1076,17 +1085,20 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n                     can_reuse)\n             return\n \n+        table_promote = False\n+        join_promote = False\n+\n         if (lookup_type == 'isnull' and value is True and not negate and\n                 len(join_list) > 1):\n             # If the comparison is against NULL, we may need to use some left\n             # outer joins when creating the join chain. This is only done when\n             # needed, as it's less efficient at the database level.\n             self.promote_alias_chain(join_list)\n+            join_promote = True\n \n         # Process the join list to see if we can remove any inner joins from\n         # the far end (fewer tables in a query is better).\n         col, alias, join_list = self.trim_joins(target, join_list, last, trim)\n-\n         if connector == OR:\n             # Some joins may need to be promoted when adding a new filter to a\n             # disjunction. We walk the list of new joins and where it diverges\n@@ -1096,19 +1108,29 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n             join_it = iter(join_list)\n             table_it = iter(self.tables)\n             join_it.next(), table_it.next()\n-            table_promote = False\n-            join_promote = False\n+            unconditional = False\n             for join in join_it:\n                 table = table_it.next()\n+                # Once we hit an outer join, all subsequent joins must\n+                # also be promoted, regardless of whether they have been\n+                # promoted as a result of this pass through the tables.\n+                unconditional = (unconditional or\n+                    self.alias_map[join][JOIN_TYPE] == self.LOUTER)\n                 if join == table and self.alias_refcount[join] > 1:\n+                    # We have more than one reference to this join table.\n+                    # This means that we are dealing with two different query\n+                    # subtrees, so we don't need to do any join promotion.\n                     continue\n-                join_promote = self.promote_alias(join)\n+                join_promote = join_promote or self.promote_alias(join, unconditional)\n                 if table != join:\n                     table_promote = self.promote_alias(table)\n+                # We only get here if we have found a table that exists\n+                # in the join list, but isn't on the original tables list.\n+                # This means we've reached the point where we only have\n+                # new tables, so we can break out of this promotion loop.\n                 break\n             self.promote_alias_chain(join_it, join_promote)\n-            self.promote_alias_chain(table_it, table_promote)\n-\n+            self.promote_alias_chain(table_it, table_promote or join_promote)\n \n         if having_clause or force_having:\n             if (alias, col) not in self.group_by:"
        },
        {
            "sha": "4181ea51709fc05340d60876ec43062f9f951478",
            "filename": "tests/regressiontests/queries/tests.py",
            "status": "modified",
            "additions": 29,
            "deletions": 5,
            "changes": 34,
            "blob_url": "https://github.com/django/django/blob/3afe409d0ea9d2e3e1dc70abd4bc1cc1a916daf9/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/3afe409d0ea9d2e3e1dc70abd4bc1cc1a916daf9/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Ftests.py?ref=3afe409d0ea9d2e3e1dc70abd4bc1cc1a916daf9",
            "patch": "@@ -959,12 +959,36 @@ def setUp(self):\n         e1 = ExtraInfo.objects.create(info='e1', note=n1)\n         e2 = ExtraInfo.objects.create(info='e2', note=n2)\n \n-        a1 = Author.objects.create(name='a1', num=1001, extra=e1)\n-        a3 = Author.objects.create(name='a3', num=3003, extra=e2)\n+        self.a1 = Author.objects.create(name='a1', num=1001, extra=e1)\n+        self.a3 = Author.objects.create(name='a3', num=3003, extra=e2)\n \n-        Report.objects.create(name='r1', creator=a1)\n-        Report.objects.create(name='r2', creator=a3)\n-        Report.objects.create(name='r3')\n+        self.r1 = Report.objects.create(name='r1', creator=self.a1)\n+        self.r2 = Report.objects.create(name='r2', creator=self.a3)\n+        self.r3 = Report.objects.create(name='r3')\n+\n+        Item.objects.create(name='i1', created=datetime.datetime.now(), note=n1, creator=self.a1)\n+        Item.objects.create(name='i2', created=datetime.datetime.now(), note=n1, creator=self.a3)\n+\n+    def test_ticket14876(self):\n+        q1 = Report.objects.filter(Q(creator__isnull=True) | Q(creator__extra__info='e1'))\n+        q2 = Report.objects.filter(Q(creator__isnull=True)) | Report.objects.filter(Q(creator__extra__info='e1'))\n+        self.assertQuerysetEqual(q1, [\"<Report: r1>\", \"<Report: r3>\"])\n+        self.assertEqual(str(q1.query), str(q2.query))\n+\n+        q1 = Report.objects.filter(Q(creator__extra__info='e1') | Q(creator__isnull=True))\n+        q2 = Report.objects.filter(Q(creator__extra__info='e1')) | Report.objects.filter(Q(creator__isnull=True))\n+        self.assertQuerysetEqual(q1, [\"<Report: r1>\", \"<Report: r3>\"])\n+        self.assertEqual(str(q1.query), str(q2.query))\n+\n+        q1 = Item.objects.filter(Q(creator=self.a1) | Q(creator__report__name='r1')).order_by()\n+        q2 = Item.objects.filter(Q(creator=self.a1)).order_by() | Item.objects.filter(Q(creator__report__name='r1')).order_by()\n+        self.assertQuerysetEqual(q1, [\"<Item: i1>\"])\n+        self.assertEqual(str(q1.query), str(q2.query))\n+\n+        q1 = Item.objects.filter(Q(creator__report__name='e1') | Q(creator=self.a1)).order_by()\n+        q2 = Item.objects.filter(Q(creator__report__name='e1')).order_by() | Item.objects.filter(Q(creator=self.a1)).order_by()\n+        self.assertQuerysetEqual(q1, [\"<Item: i1>\"])\n+        self.assertEqual(str(q1.query), str(q2.query))\n \n     def test_ticket7095(self):\n         # Updates that are filtered on the model being updated are somewhat"
        }
    ],
    "stats": {
        "total": 84,
        "additions": 65,
        "deletions": 19
    }
}