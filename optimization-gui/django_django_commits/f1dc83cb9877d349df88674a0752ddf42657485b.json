{
    "author": "jphalip",
    "message": "Fixed #10868 -- Stopped restoring database connections after the tests' execution in order to prevent the production database from being exposed to potential threads that would still be running. Also did a bit of PEP8-cleaning while I was in the area. Many thanks to ovidiu for the report and to Anssi Kääriäinen for thoroughly investigating this issue.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17411 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "f1dc83cb9877d349df88674a0752ddf42657485b",
    "files": [
        {
            "sha": "2db0acca7cdcafa5b221d5400647d848d8ab9f1e",
            "filename": "django/db/backends/creation.py",
            "status": "modified",
            "additions": 108,
            "deletions": 49,
            "changes": 157,
            "blob_url": "https://github.com/django/django/blob/f1dc83cb9877d349df88674a0752ddf42657485b/django%2Fdb%2Fbackends%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/f1dc83cb9877d349df88674a0752ddf42657485b/django%2Fdb%2Fbackends%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fcreation.py?ref=f1dc83cb9877d349df88674a0752ddf42657485b",
            "patch": "@@ -2,11 +2,13 @@\n import time\n \n from django.conf import settings\n+from django.db.utils import load_backend\n \n # The prefix to put on the default database name when creating\n # the test database.\n TEST_DATABASE_PREFIX = 'test_'\n \n+\n class BaseDatabaseCreation(object):\n     \"\"\"\n     This class encapsulates all backend-specific differences that pertain to\n@@ -57,48 +59,61 @@ def sql_create_model(self, model, style, known_models=set()):\n             if tablespace and f.unique:\n                 # We must specify the index tablespace inline, because we\n                 # won't be generating a CREATE INDEX statement for this field.\n-                tablespace_sql = self.connection.ops.tablespace_sql(tablespace, inline=True)\n+                tablespace_sql = self.connection.ops.tablespace_sql(\n+                    tablespace, inline=True)\n                 if tablespace_sql:\n                     field_output.append(tablespace_sql)\n             if f.rel:\n-                ref_output, pending = self.sql_for_inline_foreign_key_references(f, known_models, style)\n+                ref_output, pending = self.sql_for_inline_foreign_key_references(\n+                    f, known_models, style)\n                 if pending:\n-                    pending_references.setdefault(f.rel.to, []).append((model, f))\n+                    pending_references.setdefault(f.rel.to, []).append(\n+                        (model, f))\n                 else:\n                     field_output.extend(ref_output)\n             table_output.append(' '.join(field_output))\n         for field_constraints in opts.unique_together:\n-            table_output.append(style.SQL_KEYWORD('UNIQUE') + ' (%s)' % \\\n-                \", \".join([style.SQL_FIELD(qn(opts.get_field(f).column)) for f in field_constraints]))\n+            table_output.append(style.SQL_KEYWORD('UNIQUE') + ' (%s)' %\n+                \", \".join(\n+                    [style.SQL_FIELD(qn(opts.get_field(f).column))\n+                     for f in field_constraints]))\n \n-        full_statement = [style.SQL_KEYWORD('CREATE TABLE') + ' ' + style.SQL_TABLE(qn(opts.db_table)) + ' (']\n+        full_statement = [style.SQL_KEYWORD('CREATE TABLE') + ' ' +\n+                          style.SQL_TABLE(qn(opts.db_table)) + ' (']\n         for i, line in enumerate(table_output): # Combine and add commas.\n-            full_statement.append('    %s%s' % (line, i < len(table_output)-1 and ',' or ''))\n+            full_statement.append(\n+                '    %s%s' % (line, i < len(table_output)-1 and ',' or ''))\n         full_statement.append(')')\n         if opts.db_tablespace:\n-            tablespace_sql = self.connection.ops.tablespace_sql(opts.db_tablespace)\n+            tablespace_sql = self.connection.ops.tablespace_sql(\n+                opts.db_tablespace)\n             if tablespace_sql:\n                 full_statement.append(tablespace_sql)\n         full_statement.append(';')\n         final_output.append('\\n'.join(full_statement))\n \n         if opts.has_auto_field:\n-            # Add any extra SQL needed to support auto-incrementing primary keys.\n+            # Add any extra SQL needed to support auto-incrementing primary\n+            # keys.\n             auto_column = opts.auto_field.db_column or opts.auto_field.name\n-            autoinc_sql = self.connection.ops.autoinc_sql(opts.db_table, auto_column)\n+            autoinc_sql = self.connection.ops.autoinc_sql(opts.db_table,\n+                                                          auto_column)\n             if autoinc_sql:\n                 for stmt in autoinc_sql:\n                     final_output.append(stmt)\n \n         return final_output, pending_references\n \n     def sql_for_inline_foreign_key_references(self, field, known_models, style):\n-        \"Return the SQL snippet defining the foreign key reference for a field\"\n+        \"\"\"\n+        Return the SQL snippet defining the foreign key reference for a field.\n+        \"\"\"\n         qn = self.connection.ops.quote_name\n         if field.rel.to in known_models:\n-            output = [style.SQL_KEYWORD('REFERENCES') + ' ' + \\\n-                style.SQL_TABLE(qn(field.rel.to._meta.db_table)) + ' (' + \\\n-                style.SQL_FIELD(qn(field.rel.to._meta.get_field(field.rel.field_name).column)) + ')' +\n+            output = [style.SQL_KEYWORD('REFERENCES') + ' ' +\n+                style.SQL_TABLE(qn(field.rel.to._meta.db_table)) + ' (' +\n+                style.SQL_FIELD(qn(field.rel.to._meta.get_field(\n+                    field.rel.field_name).column)) + ')' +\n                 self.connection.ops.deferrable_sql()\n             ]\n             pending = False\n@@ -111,7 +126,9 @@ def sql_for_inline_foreign_key_references(self, field, known_models, style):\n         return output, pending\n \n     def sql_for_pending_references(self, model, style, pending_references):\n-        \"Returns any ALTER TABLE statements to add constraints after the fact.\"\n+        \"\"\"\n+        Returns any ALTER TABLE statements to add constraints after the fact.\n+        \"\"\"\n         from django.db.backends.util import truncate_name\n \n         if not model._meta.managed or model._meta.proxy:\n@@ -128,16 +145,21 @@ def sql_for_pending_references(self, model, style, pending_references):\n                 col = opts.get_field(f.rel.field_name).column\n                 # For MySQL, r_name must be unique in the first 64 characters.\n                 # So we are careful with character usage here.\n-                r_name = '%s_refs_%s_%s' % (r_col, col, self._digest(r_table, table))\n-                final_output.append(style.SQL_KEYWORD('ALTER TABLE') + ' %s ADD CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s (%s)%s;' % \\\n-                    (qn(r_table), qn(truncate_name(r_name, self.connection.ops.max_name_length())),\n+                r_name = '%s_refs_%s_%s' % (\n+                    r_col, col, self._digest(r_table, table))\n+                final_output.append(style.SQL_KEYWORD('ALTER TABLE') +\n+                    ' %s ADD CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s (%s)%s;' %\n+                    (qn(r_table), qn(truncate_name(\n+                        r_name, self.connection.ops.max_name_length())),\n                     qn(r_col), qn(table), qn(col),\n                     self.connection.ops.deferrable_sql()))\n             del pending_references[model]\n         return final_output\n \n     def sql_indexes_for_model(self, model, style):\n-        \"Returns the CREATE INDEX SQL statements for a single model\"\n+        \"\"\"\n+        Returns the CREATE INDEX SQL statements for a single model.\n+        \"\"\"\n         if not model._meta.managed or model._meta.proxy:\n             return []\n         output = []\n@@ -146,7 +168,9 @@ def sql_indexes_for_model(self, model, style):\n         return output\n \n     def sql_indexes_for_field(self, model, f, style):\n-        \"Return the CREATE INDEX SQL statements for a single model field\"\n+        \"\"\"\n+        Return the CREATE INDEX SQL statements for a single model field.\n+        \"\"\"\n         from django.db.backends.util import truncate_name\n \n         if f.db_index and not f.unique:\n@@ -160,7 +184,8 @@ def sql_indexes_for_field(self, model, f, style):\n                 tablespace_sql = ''\n             i_name = '%s_%s' % (model._meta.db_table, self._digest(f.column))\n             output = [style.SQL_KEYWORD('CREATE INDEX') + ' ' +\n-                style.SQL_TABLE(qn(truncate_name(i_name, self.connection.ops.max_name_length()))) + ' ' +\n+                style.SQL_TABLE(qn(truncate_name(\n+                    i_name, self.connection.ops.max_name_length()))) + ' ' +\n                 style.SQL_KEYWORD('ON') + ' ' +\n                 style.SQL_TABLE(qn(model._meta.db_table)) + ' ' +\n                 \"(%s)\" % style.SQL_FIELD(qn(f.column)) +\n@@ -170,16 +195,19 @@ def sql_indexes_for_field(self, model, f, style):\n         return output\n \n     def sql_destroy_model(self, model, references_to_delete, style):\n-        \"Return the DROP TABLE and restraint dropping statements for a single model\"\n+        \"\"\"\n+        Return the DROP TABLE and restraint dropping statements for a single\n+        model.\n+        \"\"\"\n         if not model._meta.managed or model._meta.proxy:\n             return []\n         # Drop the table now\n         qn = self.connection.ops.quote_name\n         output = ['%s %s;' % (style.SQL_KEYWORD('DROP TABLE'),\n                               style.SQL_TABLE(qn(model._meta.db_table)))]\n         if model in references_to_delete:\n-            output.extend(self.sql_remove_table_constraints(model, references_to_delete, style))\n-\n+            output.extend(self.sql_remove_table_constraints(\n+                model, references_to_delete, style))\n         if model._meta.has_auto_field:\n             ds = self.connection.ops.drop_sequence_sql(model._meta.db_table)\n             if ds:\n@@ -188,7 +216,6 @@ def sql_destroy_model(self, model, references_to_delete, style):\n \n     def sql_remove_table_constraints(self, model, references_to_delete, style):\n         from django.db.backends.util import truncate_name\n-\n         if not model._meta.managed or model._meta.proxy:\n             return []\n         output = []\n@@ -198,12 +225,14 @@ def sql_remove_table_constraints(self, model, references_to_delete, style):\n             col = f.column\n             r_table = model._meta.db_table\n             r_col = model._meta.get_field(f.rel.field_name).column\n-            r_name = '%s_refs_%s_%s' % (col, r_col, self._digest(table, r_table))\n+            r_name = '%s_refs_%s_%s' % (\n+                col, r_col, self._digest(table, r_table))\n             output.append('%s %s %s %s;' % \\\n                 (style.SQL_KEYWORD('ALTER TABLE'),\n                 style.SQL_TABLE(qn(table)),\n                 style.SQL_KEYWORD(self.connection.ops.drop_foreignkey_sql()),\n-                style.SQL_FIELD(qn(truncate_name(r_name, self.connection.ops.max_name_length())))))\n+                style.SQL_FIELD(qn(truncate_name(\n+                    r_name, self.connection.ops.max_name_length())))))\n         del references_to_delete[model]\n         return output\n \n@@ -221,7 +250,8 @@ def create_test_db(self, verbosity=1, autoclobber=False):\n             test_db_repr = ''\n             if verbosity >= 2:\n                 test_db_repr = \" ('%s')\" % test_database_name\n-            print \"Creating test database for alias '%s'%s...\" % (self.connection.alias, test_db_repr)\n+            print \"Creating test database for alias '%s'%s...\" % (\n+                self.connection.alias, test_db_repr)\n \n         self._create_test_db(verbosity, autoclobber)\n \n@@ -255,7 +285,8 @@ def create_test_db(self, verbosity=1, autoclobber=False):\n         for cache_alias in settings.CACHES:\n             cache = get_cache(cache_alias)\n             if isinstance(cache, BaseDatabaseCache):\n-                call_command('createcachetable', cache._table, database=self.connection.alias)\n+                call_command('createcachetable', cache._table,\n+                             database=self.connection.alias)\n \n         # Get a cursor (even though we don't need one yet). This has\n         # the side effect of initializing the test database.\n@@ -275,7 +306,9 @@ def _get_test_db_name(self):\n         return TEST_DATABASE_PREFIX + self.connection.settings_dict['NAME']\n \n     def _create_test_db(self, verbosity, autoclobber):\n-        \"Internal implementation - creates the test db tables.\"\n+        \"\"\"\n+        Internal implementation - creates the test db tables.\n+        \"\"\"\n         suffix = self.sql_table_creation_suffix()\n \n         test_database_name = self._get_test_db_name()\n@@ -288,19 +321,28 @@ def _create_test_db(self, verbosity, autoclobber):\n         cursor = self.connection.cursor()\n         self._prepare_for_test_db_ddl()\n         try:\n-            cursor.execute(\"CREATE DATABASE %s %s\" % (qn(test_database_name), suffix))\n+            cursor.execute(\n+                \"CREATE DATABASE %s %s\" % (qn(test_database_name), suffix))\n         except Exception, e:\n-            sys.stderr.write(\"Got an error creating the test database: %s\\n\" % e)\n+            sys.stderr.write(\n+                \"Got an error creating the test database: %s\\n\" % e)\n             if not autoclobber:\n-                confirm = raw_input(\"Type 'yes' if you would like to try deleting the test database '%s', or 'no' to cancel: \" % test_database_name)\n+                confirm = raw_input(\n+                    \"Type 'yes' if you would like to try deleting the test \"\n+                    \"database '%s', or 'no' to cancel: \" % test_database_name)\n             if autoclobber or confirm == 'yes':\n                 try:\n                     if verbosity >= 1:\n-                        print \"Destroying old test database '%s'...\" % self.connection.alias\n-                    cursor.execute(\"DROP DATABASE %s\" % qn(test_database_name))\n-                    cursor.execute(\"CREATE DATABASE %s %s\" % (qn(test_database_name), suffix))\n+                        print (\"Destroying old test database '%s'...\"\n+                               % self.connection.alias)\n+                    cursor.execute(\n+                        \"DROP DATABASE %s\" % qn(test_database_name))\n+                    cursor.execute(\n+                        \"CREATE DATABASE %s %s\" % (qn(test_database_name),\n+                                                   suffix))\n                 except Exception, e:\n-                    sys.stderr.write(\"Got an error recreating the test database: %s\\n\" % e)\n+                    sys.stderr.write(\n+                        \"Got an error recreating the test database: %s\\n\" % e)\n                     sys.exit(2)\n             else:\n                 print \"Tests cancelled.\"\n@@ -319,21 +361,36 @@ def destroy_test_db(self, old_database_name, verbosity=1):\n             test_db_repr = ''\n             if verbosity >= 2:\n                 test_db_repr = \" ('%s')\" % test_database_name\n-            print \"Destroying test database for alias '%s'%s...\" % (self.connection.alias, test_db_repr)\n-        self.connection.settings_dict['NAME'] = old_database_name\n-\n-        self._destroy_test_db(test_database_name, verbosity)\n+            print \"Destroying test database for alias '%s'%s...\" % (\n+                self.connection.alias, test_db_repr)\n+\n+        # Temporarily use a new connection and a copy of the settings dict.\n+        # This prevents the production database from being exposed to potential\n+        # child threads while (or after) the test database is destroyed.\n+        # Refs #10868.\n+        settings_dict = self.connection.settings_dict.copy()\n+        settings_dict['NAME'] = old_database_name\n+        backend = load_backend(settings_dict['ENGINE'])\n+        new_connection = backend.DatabaseWrapper(\n+                             settings_dict,\n+                             alias='__destroy_test_db__',\n+                             allow_thread_sharing=False)\n+        new_connection.creation._destroy_test_db(test_database_name, verbosity)\n \n     def _destroy_test_db(self, test_database_name, verbosity):\n-        \"Internal implementation - remove the test db tables.\"\n+        \"\"\"\n+        Internal implementation - remove the test db tables.\n+        \"\"\"\n         # Remove the test database to clean up after\n         # ourselves. Connect to the previous database (not the test database)\n         # to do so, because it's not allowed to delete a database while being\n         # connected to it.\n         cursor = self.connection.cursor()\n         self._prepare_for_test_db_ddl()\n-        time.sleep(1) # To avoid \"database is being accessed by other users\" errors.\n-        cursor.execute(\"DROP DATABASE %s\" % self.connection.ops.quote_name(test_database_name))\n+        # Wait to avoid \"database is being accessed by other users\" errors.\n+        time.sleep(1)\n+        cursor.execute(\"DROP DATABASE %s\"\n+                       % self.connection.ops.quote_name(test_database_name))\n         self.connection.close()\n \n     def set_autocommit(self):\n@@ -346,15 +403,17 @@ def set_autocommit(self):\n \n     def _prepare_for_test_db_ddl(self):\n         \"\"\"\n-        Internal implementation - Hook for tasks that should be performed before\n-        the ``CREATE DATABASE``/``DROP DATABASE`` clauses used by testing code\n-        to create/ destroy test databases. Needed e.g. in PostgreSQL to rollback\n-        and close any active transaction.\n+        Internal implementation - Hook for tasks that should be performed\n+        before the ``CREATE DATABASE``/``DROP DATABASE`` clauses used by\n+        testing code to create/ destroy test databases. Needed e.g. in\n+        PostgreSQL to rollback and close any active transaction.\n         \"\"\"\n         pass\n \n     def sql_table_creation_suffix(self):\n-        \"SQL to append to the end of the test table creation statements\"\n+        \"\"\"\n+        SQL to append to the end of the test table creation statements.\n+        \"\"\"\n         return ''\n \n     def test_db_signature(self):"
        },
        {
            "sha": "0c6a21bb373bddd88c069294c78e3eec4ac9cf64",
            "filename": "django/test/simple.py",
            "status": "modified",
            "additions": 61,
            "deletions": 35,
            "changes": 96,
            "blob_url": "https://github.com/django/django/blob/f1dc83cb9877d349df88674a0752ddf42657485b/django%2Ftest%2Fsimple.py",
            "raw_url": "https://github.com/django/django/raw/f1dc83cb9877d349df88674a0752ddf42657485b/django%2Ftest%2Fsimple.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Fsimple.py?ref=f1dc83cb9877d349df88674a0752ddf42657485b",
            "patch": "@@ -17,15 +17,18 @@\n \n doctestOutputChecker = OutputChecker()\n \n+\n class DjangoTestRunner(unittest.TextTestRunner):\n     def __init__(self, *args, **kwargs):\n         import warnings\n         warnings.warn(\n-            \"DjangoTestRunner is deprecated; it's functionality is indistinguishable from TextTestRunner\",\n+            \"DjangoTestRunner is deprecated; it's functionality is \"\n+            \"indistinguishable from TextTestRunner\",\n             DeprecationWarning\n         )\n         super(DjangoTestRunner, self).__init__(*args, **kwargs)\n \n+\n def get_tests(app_module):\n     parts = app_module.__name__.split('.')\n     prefix, last = parts[:-1], parts[-1]\n@@ -49,16 +52,20 @@ def get_tests(app_module):\n             raise\n     return test_module\n \n+\n def build_suite(app_module):\n-    \"Create a complete Django test suite for the provided application module\"\n+    \"\"\"\n+    Create a complete Django test suite for the provided application module.\n+    \"\"\"\n     suite = unittest.TestSuite()\n \n     # Load unit and doctests in the models.py module. If module has\n     # a suite() method, use it. Otherwise build the test suite ourselves.\n     if hasattr(app_module, 'suite'):\n         suite.addTest(app_module.suite())\n     else:\n-        suite.addTest(unittest.defaultTestLoader.loadTestsFromModule(app_module))\n+        suite.addTest(unittest.defaultTestLoader.loadTestsFromModule(\n+            app_module))\n         try:\n             suite.addTest(doctest.DocTestSuite(app_module,\n                                                checker=doctestOutputChecker,\n@@ -76,25 +83,29 @@ def build_suite(app_module):\n         if hasattr(test_module, 'suite'):\n             suite.addTest(test_module.suite())\n         else:\n-            suite.addTest(unittest.defaultTestLoader.loadTestsFromModule(test_module))\n+            suite.addTest(unittest.defaultTestLoader.loadTestsFromModule(\n+                test_module))\n             try:\n-                suite.addTest(doctest.DocTestSuite(test_module,\n-                                                   checker=doctestOutputChecker,\n-                                                   runner=DocTestRunner))\n+                suite.addTest(doctest.DocTestSuite(\n+                    test_module, checker=doctestOutputChecker,\n+                    runner=DocTestRunner))\n             except ValueError:\n                 # No doc tests in tests.py\n                 pass\n     return suite\n \n+\n def build_test(label):\n-    \"\"\"Construct a test case with the specified label. Label should be of the\n+    \"\"\"\n+    Construct a test case with the specified label. Label should be of the\n     form model.TestClass or model.TestClass.test_method. Returns an\n     instantiated test or test suite corresponding to the label provided.\n \n     \"\"\"\n     parts = label.split('.')\n     if len(parts) < 2 or len(parts) > 3:\n-        raise ValueError(\"Test label '%s' should be of the form app.TestCase or app.TestCase.test_method\" % label)\n+        raise ValueError(\"Test label '%s' should be of the form app.TestCase \"\n+                         \"or app.TestCase.test_method\" % label)\n \n     #\n     # First, look for TestCase instances with a name that matches\n@@ -112,9 +123,12 @@ def build_test(label):\n         if issubclass(TestClass, (unittest.TestCase, real_unittest.TestCase)):\n             if len(parts) == 2: # label is app.TestClass\n                 try:\n-                    return unittest.TestLoader().loadTestsFromTestCase(TestClass)\n+                    return unittest.TestLoader().loadTestsFromTestCase(\n+                        TestClass)\n                 except TypeError:\n-                    raise ValueError(\"Test label '%s' does not refer to a test class\" % label)\n+                    raise ValueError(\n+                        \"Test label '%s' does not refer to a test class\"\n+                        % label)\n             else: # label is app.TestClass.test_method\n                 return TestClass(parts[2])\n     except TypeError:\n@@ -135,7 +149,8 @@ def build_test(label):\n             for test in doctests:\n                 if test._dt_test.name in (\n                         '%s.%s' % (module.__name__, '.'.join(parts[1:])),\n-                        '%s.__test__.%s' % (module.__name__, '.'.join(parts[1:]))):\n+                        '%s.__test__.%s' % (\n+                            module.__name__, '.'.join(parts[1:]))):\n                     tests.append(test)\n         except ValueError:\n             # No doctests found.\n@@ -148,6 +163,7 @@ def build_test(label):\n     # Construct a suite out of the tests that matched.\n     return unittest.TestSuite(tests)\n \n+\n def partition_suite(suite, classes, bins):\n     \"\"\"\n     Partitions a test suite by test type.\n@@ -169,14 +185,15 @@ def partition_suite(suite, classes, bins):\n             else:\n                 bins[-1].addTest(test)\n \n+\n def reorder_suite(suite, classes):\n     \"\"\"\n     Reorders a test suite by test type.\n \n-    classes is a sequence of types\n+    `classes` is a sequence of types\n \n-    All tests of type clases[0] are placed first, then tests of type classes[1], etc.\n-    Tests with no match in classes are placed last.\n+    All tests of type classes[0] are placed first, then tests of type\n+    classes[1], etc. Tests with no match in classes are placed last.\n     \"\"\"\n     class_count = len(classes)\n     bins = [unittest.TestSuite() for i in range(class_count+1)]\n@@ -185,6 +202,7 @@ def reorder_suite(suite, classes):\n         bins[0].addTests(bins[i+1])\n     return bins[0]\n \n+\n def dependency_ordered(test_databases, dependencies):\n     \"\"\"Reorder test_databases into an order that honors the dependencies\n     described in TEST_DEPENDENCIES.\n@@ -200,7 +218,8 @@ def dependency_ordered(test_databases, dependencies):\n             dependencies_satisfied = True\n             for alias in aliases:\n                 if alias in dependencies:\n-                    if all(a in resolved_databases for a in dependencies[alias]):\n+                    if all(a in resolved_databases\n+                           for a in dependencies[alias]):\n                         # all dependencies for this alias are satisfied\n                         dependencies.pop(alias)\n                         resolved_databases.add(alias)\n@@ -216,10 +235,12 @@ def dependency_ordered(test_databases, dependencies):\n                 deferred.append((signature, (db_name, aliases)))\n \n         if not changed:\n-            raise ImproperlyConfigured(\"Circular dependency in TEST_DEPENDENCIES\")\n+            raise ImproperlyConfigured(\n+                \"Circular dependency in TEST_DEPENDENCIES\")\n         test_databases = deferred\n     return ordered_test_databases\n \n+\n class DjangoTestSuiteRunner(object):\n     def __init__(self, verbosity=1, interactive=True, failfast=True, **kwargs):\n         self.verbosity = verbosity\n@@ -264,7 +285,8 @@ def setup_databases(self, **kwargs):\n             if connection.settings_dict['TEST_MIRROR']:\n                 # If the database is marked as a test mirror, save\n                 # the alias.\n-                mirrored_aliases[alias] = connection.settings_dict['TEST_MIRROR']\n+                mirrored_aliases[alias] = (\n+                    connection.settings_dict['TEST_MIRROR'])\n             else:\n                 # Store a tuple with DB parameters that uniquely identify it.\n                 # If we have two aliases with the same values for that tuple,\n@@ -276,53 +298,57 @@ def setup_databases(self, **kwargs):\n                 item[1].append(alias)\n \n                 if 'TEST_DEPENDENCIES' in connection.settings_dict:\n-                    dependencies[alias] = connection.settings_dict['TEST_DEPENDENCIES']\n+                    dependencies[alias] = (\n+                        connection.settings_dict['TEST_DEPENDENCIES'])\n                 else:\n                     if alias != DEFAULT_DB_ALIAS:\n-                        dependencies[alias] = connection.settings_dict.get('TEST_DEPENDENCIES', [DEFAULT_DB_ALIAS])\n+                        dependencies[alias] = connection.settings_dict.get(\n+                            'TEST_DEPENDENCIES', [DEFAULT_DB_ALIAS])\n \n         # Second pass -- actually create the databases.\n         old_names = []\n         mirrors = []\n-        for signature, (db_name, aliases) in dependency_ordered(test_databases.items(), dependencies):\n+        for signature, (db_name, aliases) in dependency_ordered(\n+            test_databases.items(), dependencies):\n             # Actually create the database for the first connection\n             connection = connections[aliases[0]]\n             old_names.append((connection, db_name, True))\n-            test_db_name = connection.creation.create_test_db(self.verbosity, autoclobber=not self.interactive)\n+            test_db_name = connection.creation.create_test_db(\n+                self.verbosity, autoclobber=not self.interactive)\n             for alias in aliases[1:]:\n                 connection = connections[alias]\n                 if db_name:\n                     old_names.append((connection, db_name, False))\n                     connection.settings_dict['NAME'] = test_db_name\n                 else:\n-                    # If settings_dict['NAME'] isn't defined, we have a backend where\n-                    # the name isn't important -- e.g., SQLite, which uses :memory:.\n-                    # Force create the database instead of assuming it's a duplicate.\n+                    # If settings_dict['NAME'] isn't defined, we have a backend\n+                    # where the name isn't important -- e.g., SQLite, which\n+                    # uses :memory:. Force create the database instead of\n+                    # assuming it's a duplicate.\n                     old_names.append((connection, db_name, True))\n-                    connection.creation.create_test_db(self.verbosity, autoclobber=not self.interactive)\n+                    connection.creation.create_test_db(\n+                        self.verbosity, autoclobber=not self.interactive)\n \n         for alias, mirror_alias in mirrored_aliases.items():\n             mirrors.append((alias, connections[alias].settings_dict['NAME']))\n-            connections[alias].settings_dict['NAME'] = connections[mirror_alias].settings_dict['NAME']\n+            connections[alias].settings_dict['NAME'] = (\n+                connections[mirror_alias].settings_dict['NAME'])\n             connections[alias].features = connections[mirror_alias].features\n \n         return old_names, mirrors\n \n     def run_suite(self, suite, **kwargs):\n-        return unittest.TextTestRunner(verbosity=self.verbosity, failfast=self.failfast).run(suite)\n+        return unittest.TextTestRunner(\n+            verbosity=self.verbosity, failfast=self.failfast).run(suite)\n \n     def teardown_databases(self, old_config, **kwargs):\n-        from django.db import connections\n+        \"\"\"\n+        Destroys all the non-mirror databases.\n+        \"\"\"\n         old_names, mirrors = old_config\n-        # Point all the mirrors back to the originals\n-        for alias, old_name in mirrors:\n-            connections[alias].settings_dict['NAME'] = old_name\n-        # Destroy all the non-mirror databases\n         for connection, old_name, destroy in old_names:\n             if destroy:\n                 connection.creation.destroy_test_db(old_name, self.verbosity)\n-            else:\n-                connection.settings_dict['NAME'] = old_name\n \n     def teardown_test_environment(self, **kwargs):\n         unittest.removeHandler()"
        },
        {
            "sha": "8a7bfb201170a21949bcee71e1edbcd84d4c5a05",
            "filename": "docs/releases/1.4.txt",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/f1dc83cb9877d349df88674a0752ddf42657485b/docs%2Freleases%2F1.4.txt",
            "raw_url": "https://github.com/django/django/raw/f1dc83cb9877d349df88674a0752ddf42657485b/docs%2Freleases%2F1.4.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.4.txt?ref=f1dc83cb9877d349df88674a0752ddf42657485b",
            "patch": "@@ -946,6 +946,19 @@ apply URL escaping again. This is wrong for URLs whose unquoted form contains\n a ``%xx`` sequence, but such URLs are very unlikely to happen in the wild,\n since they would confuse browsers too.\n \n+Database connections after running the test suite\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The default test runner now does not restore the database connections after the\n+tests' execution any more. This prevents the production database from being\n+exposed to potential threads that would still be running and attempting to\n+create new connections.\n+\n+If your code relied on connections to the production database being created\n+after the tests' execution, then you may restore the previous behavior by\n+subclassing ``DjangoTestRunner`` and overriding its ``teardown_databases()``\n+method.\n+\n Features deprecated in 1.4\n ==========================\n "
        }
    ],
    "stats": {
        "total": 266,
        "additions": 182,
        "deletions": 84
    }
}