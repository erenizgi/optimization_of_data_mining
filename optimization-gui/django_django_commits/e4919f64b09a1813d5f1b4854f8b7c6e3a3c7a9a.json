{
    "author": "alex",
    "message": "Clean up the the locmem cache backend and utils.synch by using context managers.  Puch prettier.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17152 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "e4919f64b09a1813d5f1b4854f8b7c6e3a3c7a9a",
    "files": [
        {
            "sha": "6ba0c98945e909af71af391fd2dc5c2d0fdbb99c",
            "filename": "django/core/cache/backends/locmem.py",
            "status": "modified",
            "additions": 20,
            "deletions": 40,
            "changes": 60,
            "blob_url": "https://github.com/django/django/blob/e4919f64b09a1813d5f1b4854f8b7c6e3a3c7a9a/django%2Fcore%2Fcache%2Fbackends%2Flocmem.py",
            "raw_url": "https://github.com/django/django/raw/e4919f64b09a1813d5f1b4854f8b7c6e3a3c7a9a/django%2Fcore%2Fcache%2Fbackends%2Flocmem.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Flocmem.py?ref=e4919f64b09a1813d5f1b4854f8b7c6e3a3c7a9a",
            "patch": "@@ -1,5 +1,7 @@\n \"Thread-safe in-memory cache backend.\"\n \n+from __future__ import with_statement\n+\n import time\n try:\n     import cPickle as pickle\n@@ -26,8 +28,7 @@ def __init__(self, name, params):\n     def add(self, key, value, timeout=None, version=None):\n         key = self.make_key(key, version=version)\n         self.validate_key(key)\n-        self._lock.writer_enters()\n-        try:\n+        with self._lock.writer():\n             exp = self._expire_info.get(key)\n             if exp is None or exp <= time.time():\n                 try:\n@@ -37,14 +38,11 @@ def add(self, key, value, timeout=None, version=None):\n                 except pickle.PickleError:\n                     pass\n             return False\n-        finally:\n-            self._lock.writer_leaves()\n \n     def get(self, key, default=None, version=None):\n         key = self.make_key(key, version=version)\n         self.validate_key(key)\n-        self._lock.reader_enters()\n-        try:\n+        with self._lock.reader():\n             exp = self._expire_info.get(key)\n             if exp is None:\n                 return default\n@@ -54,18 +52,13 @@ def get(self, key, default=None, version=None):\n                     return pickle.loads(pickled)\n                 except pickle.PickleError:\n                     return default\n-        finally:\n-            self._lock.reader_leaves()\n-        self._lock.writer_enters()\n-        try:\n+        with self._lock.writer():\n             try:\n                 del self._cache[key]\n                 del self._expire_info[key]\n             except KeyError:\n                 pass\n             return default\n-        finally:\n-            self._lock.writer_leaves()\n \n     def _set(self, key, value, timeout=None):\n         if len(self._cache) >= self._max_entries:\n@@ -78,54 +71,44 @@ def _set(self, key, value, timeout=None):\n     def set(self, key, value, timeout=None, version=None):\n         key = self.make_key(key, version=version)\n         self.validate_key(key)\n-        self._lock.writer_enters()\n-        try:\n-            pickled = pickle.dumps(value, pickle.HIGHEST_PROTOCOL)\n-            self._set(key, pickled, timeout)\n-        except pickle.PickleError:\n-            pass\n-        finally:\n-            self._lock.writer_leaves()\n+        with self._lock.writer():\n+            try:\n+                pickled = pickle.dumps(value, pickle.HIGHEST_PROTOCOL)\n+                self._set(key, pickled, timeout)\n+            except pickle.PickleError:\n+                pass\n \n     def incr(self, key, delta=1, version=None):\n         value = self.get(key, version=version)\n         if value is None:\n             raise ValueError(\"Key '%s' not found\" % key)\n         new_value = value + delta\n         key = self.make_key(key, version=version)\n-        self._lock.writer_enters()\n-        try:\n-            pickled = pickle.dumps(new_value, pickle.HIGHEST_PROTOCOL)\n-            self._cache[key] = pickled\n-        except pickle.PickleError:\n-            pass\n-        finally:\n-            self._lock.writer_leaves()\n+        with self._lock.writer():\n+            try:\n+                pickled = pickle.dumps(new_value, pickle.HIGHEST_PROTOCOL)\n+                self._cache[key] = pickled\n+            except pickle.PickleError:\n+                pass\n         return new_value\n \n     def has_key(self, key, version=None):\n         key = self.make_key(key, version=version)\n         self.validate_key(key)\n-        self._lock.reader_enters()\n-        try:\n+        with self._lock.reader():\n             exp = self._expire_info.get(key)\n             if exp is None:\n                 return False\n             elif exp > time.time():\n                 return True\n-        finally:\n-            self._lock.reader_leaves()\n \n-        self._lock.writer_enters()\n-        try:\n+        with self._lock.writer():\n             try:\n                 del self._cache[key]\n                 del self._expire_info[key]\n             except KeyError:\n                 pass\n             return False\n-        finally:\n-            self._lock.writer_leaves()\n \n     def _cull(self):\n         if self._cull_frequency == 0:\n@@ -148,11 +131,8 @@ def _delete(self, key):\n     def delete(self, key, version=None):\n         key = self.make_key(key, version=version)\n         self.validate_key(key)\n-        self._lock.writer_enters()\n-        try:\n+        with self._lock.writer():\n             self._delete(key)\n-        finally:\n-            self._lock.writer_leaves()\n \n     def clear(self):\n         self._cache.clear()"
        },
        {
            "sha": "d6ae2f0a72d70a72422322c1071f79af077932da",
            "filename": "django/utils/synch.py",
            "status": "modified",
            "additions": 23,
            "deletions": 15,
            "changes": 38,
            "blob_url": "https://github.com/django/django/blob/e4919f64b09a1813d5f1b4854f8b7c6e3a3c7a9a/django%2Futils%2Fsynch.py",
            "raw_url": "https://github.com/django/django/raw/e4919f64b09a1813d5f1b4854f8b7c6e3a3c7a9a/django%2Futils%2Fsynch.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fsynch.py?ref=e4919f64b09a1813d5f1b4854f8b7c6e3a3c7a9a",
            "patch": "@@ -6,12 +6,16 @@\n (Contributed to Django by eugene@lazutkin.com)\n \"\"\"\n \n+from __future__ import with_statement\n+\n+import contextlib\n try:\n     import threading\n except ImportError:\n     import dummy_threading as threading\n \n-class RWLock:\n+\n+class RWLock(object):\n     \"\"\"\n     Classic implementation of reader-writer lock with preference to writers.\n \n@@ -34,43 +38,41 @@ def __init__(self):\n         self.waiting_writers = 0\n \n     def reader_enters(self):\n-        self.mutex.acquire()\n-        try:\n+        with self.mutex:\n             if self.active_writers == 0 and self.waiting_writers == 0:\n                 self.active_readers += 1\n                 self.can_read.release()\n             else:\n                 self.waiting_readers += 1\n-        finally:\n-            self.mutex.release()\n         self.can_read.acquire()\n \n     def reader_leaves(self):\n-        self.mutex.acquire()\n-        try:\n+        with self.mutex:\n             self.active_readers -= 1\n             if self.active_readers == 0 and self.waiting_writers != 0:\n                 self.active_writers  += 1\n                 self.waiting_writers -= 1\n                 self.can_write.release()\n+\n+    @contextlib.contextmanager\n+    def reader(self):\n+        self.reader_enters()\n+        try:\n+            yield\n         finally:\n-            self.mutex.release()\n+            self.reader_leaves()\n \n     def writer_enters(self):\n-        self.mutex.acquire()\n-        try:\n+        with self.mutex:\n             if self.active_writers == 0 and self.waiting_writers == 0 and self.active_readers == 0:\n                 self.active_writers += 1\n                 self.can_write.release()\n             else:\n                 self.waiting_writers += 1\n-        finally:\n-            self.mutex.release()\n         self.can_write.acquire()\n \n     def writer_leaves(self):\n-        self.mutex.acquire()\n-        try:\n+        with self.mutex:\n             self.active_writers -= 1\n             if self.waiting_writers != 0:\n                 self.active_writers  += 1\n@@ -83,5 +85,11 @@ def writer_leaves(self):\n                 while t > 0:\n                     self.can_read.release()\n                     t -= 1\n+\n+    @contextlib.contextmanager\n+    def writer(self):\n+        self.writer_enters()\n+        try:\n+            yield\n         finally:\n-            self.mutex.release()\n+            self.writer_leaves()\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 98,
        "additions": 43,
        "deletions": 55
    }
}