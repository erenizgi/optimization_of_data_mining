{
    "author": "malcolmt",
    "message": "Documentation edits for model instance docs.\n\nFirst of two parts. Mostly adding cross references to other parts of the\ndocumentation.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16701 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "a0eb58e90b16fd620196ca2e30219d04b86bceb2",
    "files": [
        {
            "sha": "1b9f77a35f614bd9924cff62583cd5407f7571d6",
            "filename": "docs/ref/models/instances.txt",
            "status": "modified",
            "additions": 130,
            "deletions": 122,
            "changes": 252,
            "blob_url": "https://github.com/django/django/blob/a0eb58e90b16fd620196ca2e30219d04b86bceb2/docs%2Fref%2Fmodels%2Finstances.txt",
            "raw_url": "https://github.com/django/django/raw/a0eb58e90b16fd620196ca2e30219d04b86bceb2/docs%2Fref%2Fmodels%2Finstances.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Finstances.txt?ref=a0eb58e90b16fd620196ca2e30219d04b86bceb2",
            "patch": "@@ -23,7 +23,7 @@ class:\n \n The keyword arguments are simply the names of the fields you've defined on your\n model. Note that instantiating a model in no way touches your database; for\n-that, you need to ``save()``.\n+that, you need to :meth:`~Model.save()`.\n \n .. _validating-objects:\n \n@@ -39,31 +39,34 @@ There are three steps involved in validating a model:\n     3. Validate the field uniqueness\n \n All three steps are performed when you call a model's\n-``full_clean()`` method.\n+:meth:`~Model.full_clean()` method.\n \n-When you use a ``ModelForm``, the call to ``is_valid()`` will perform\n-these validation steps for all the fields that are included on the\n-form. (See the :doc:`ModelForm documentation\n-</topics/forms/modelforms>` for more information.) You should only need\n-to call a model's ``full_clean()`` method if you plan to handle\n+When you use a :class:`~django.forms.ModelForm`, the call to\n+:meth:`~django.forms.Form.is_valid()` will perform these validation steps for\n+all the fields that are included on the form. See the :doc:`ModelForm\n+documentation </topics/forms/modelforms>` for more information. You should only\n+need to call a model's :meth:`~Model.full_clean()` method if you plan to handle\n validation errors yourself, or if you have excluded fields from the\n-ModelForm that require validation.\n+:class:`~django.forms.ModelForm` that require validation.\n \n .. method:: Model.full_clean(exclude=None)\n \n-This method calls ``Model.clean_fields()``, ``Model.clean()``, and\n-``Model.validate_unique()``, in that order and raises a ``ValidationError``\n-that has a ``message_dict`` attribute containing errors from all three stages.\n+This method calls :meth:`Model.clean_fields()`, :meth:`Model.clean()`, and\n+:meth:`Model.validate_unique()`, in that order and raises a\n+:exc:`~django.core.exceptions.ValidationError` that has a ``message_dict``\n+attribute containing errors from all three stages.\n \n The optional ``exclude`` argument can be used to provide a list of field names\n-that can be excluded from validation and cleaning. ``ModelForm`` uses this\n-argument to exclude fields that aren't present on your form from being\n-validated since any errors raised could not be corrected by the user.\n+that can be excluded from validation and cleaning.\n+:class:`~django.forms.ModelForm` uses this argument to exclude fields that\n+aren't present on your form from being validated since any errors raised could\n+not be corrected by the user.\n \n-Note that ``full_clean()`` will *not* be called automatically when you\n-call your model's ``save()`` method, nor as a result of ``ModelForm``\n-validation. You'll need to call it manually when you want to run model\n-validation outside of a ``ModelForm``.\n+Note that ``full_clean()`` will *not* be called automatically when you call\n+your model's :meth:`~Model.save()` method, nor as a result of\n+:class:`~django.forms.ModelForm` validation. You'll need to call it manually\n+when you want to run one-step model validation for your own manually created\n+models.\n \n Example::\n \n@@ -79,9 +82,10 @@ The first step ``full_clean()`` performs is to clean each individual field.\n \n This method will validate all fields on your model. The optional ``exclude``\n argument lets you provide a list of field names to exclude from validation. It\n-will raise a ``ValidationError`` if any fields fail validation.\n+will raise a :exc:`~django.core.exceptions.ValidationError` if any fields fail\n+validation.\n \n-The second step ``full_clean()`` performs is to call ``Model.clean()``.\n+The second step ``full_clean()`` performs is to call :meth:`Model.clean()`.\n This method should be overridden to perform custom validation on your model.\n \n .. method:: Model.clean()\n@@ -100,10 +104,10 @@ access to more than a single field::\n         if self.status == 'published' and self.pub_date is None:\n             self.pub_date = datetime.datetime.now()\n \n-Any ``ValidationError`` raised by ``Model.clean()`` will be stored under a\n-special key that is used for errors that are tied to the entire model instead\n-of to a specific field. You can access these errors with ``NON_FIELD_ERRORS``::\n-\n+Any :exc:`~django.core.exceptions.ValidationError` exceptions raised by\n+``Model.clean()`` will be stored in a special key error dictionary key,\n+``NON_FIELD_ERRORS``, that is used for errors that are tied to the entire model\n+instead of to a specific field::\n \n     from django.core.exceptions import ValidationError, NON_FIELD_ERRORS\n     try:\n@@ -115,15 +119,15 @@ Finally, ``full_clean()`` will check any unique constraints on your model.\n \n .. method:: Model.validate_unique(exclude=None)\n \n-This method is similar to ``clean_fields``, but validates all uniqueness\n-constraints on your model instead of individual field values. The optional\n-``exclude`` argument allows you to provide a list of field names to exclude\n-from validation. It will raise a ``ValidationError`` if any fields fail\n-validation.\n+This method is similar to :meth:`~Model.clean_fields`, but validates all\n+uniqueness constraints on your model instead of individual field values. The\n+optional ``exclude`` argument allows you to provide a list of field names to\n+exclude from validation. It will raise a\n+:exc:`~django.core.exceptions.ValidationError` if any fields fail validation.\n \n-Note that if you provide an ``exclude`` argument to ``validate_unique``, any\n-``unique_together`` constraint that contains one of the fields you provided\n-will not be checked.\n+Note that if you provide an ``exclude`` argument to ``validate_unique()``, any\n+:attr:`~django.db.models.Options.unique_together` constraint involving one of\n+the fields you provided will not be checked.\n \n \n Saving objects\n@@ -136,19 +140,17 @@ To save an object back to the database, call ``save()``:\n .. versionadded:: 1.2\n    The ``using`` argument was added.\n \n-If you want customized saving behavior, you can override this\n-``save()`` method. See :ref:`overriding-model-methods` for more\n-details.\n+If you want customized saving behavior, you can override this ``save()``\n+method. See :ref:`overriding-model-methods` for more details.\n \n-The model save process also has some subtleties; see the sections\n-below.\n+The model save process also has some subtleties; see the sections below.\n \n Auto-incrementing primary keys\n ------------------------------\n \n-If a model has an ``AutoField`` -- an auto-incrementing primary key -- then\n-that auto-incremented value will be calculated and saved as an attribute on\n-your object the first time you call ``save()``::\n+If a model has an :class:`~django.db.models.AutoField` — an auto-incrementing\n+primary key — then that auto-incremented value will be calculated and saved as\n+an attribute on your object the first time you call ``save()``::\n \n     >>> b2 = Blog(name='Cheddar Talk', tagline='Thoughts on cheese.')\n     >>> b2.id     # Returns None, because b doesn't have an ID yet.\n@@ -158,9 +160,10 @@ your object the first time you call ``save()``::\n There's no way to tell what the value of an ID will be before you call\n ``save()``, because that value is calculated by your database, not by Django.\n \n-(For convenience, each model has an ``AutoField`` named ``id`` by default\n-unless you explicitly specify ``primary_key=True`` on a field. See the\n-documentation for ``AutoField`` for more details.\n+For convenience, each model has an :class:`~django.db.models.AutoField` named\n+``id`` by default unless you explicitly specify ``primary_key=True`` on a field\n+in your model. See the documentation for :class:`~django.db.models.AutoField`\n+for more details.\n \n The ``pk`` property\n ~~~~~~~~~~~~~~~~~~~\n@@ -177,9 +180,9 @@ correct field in the model.\n Explicitly specifying auto-primary-key values\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-If a model has an ``AutoField`` but you want to define a new object's ID\n-explicitly when saving, just define it explicitly before saving, rather than\n-relying on the auto-assignment of the ID::\n+If a model has an :class:`~django.db.models.AutoField` but you want to define a\n+new object's ID explicitly when saving, just define it explicitly before\n+saving, rather than relying on the auto-assignment of the ID::\n \n     >>> b3 = Blog(id=3, name='Cheddar Talk', tagline='Thoughts on cheese.')\n     >>> b3.id     # Returns 3.\n@@ -217,13 +220,13 @@ When you save an object, Django performs the following steps:\n        perform any automated data modification that the field may need\n        to perform.\n \n-       Most fields do *no* pre-processing -- the field data is kept as-is.\n-       Pre-processing is only used on fields that have special behavior.\n-       For example, if your model has a ``DateField`` with ``auto_now=True``,\n-       the pre-save phase will alter the data in the object to ensure that\n-       the date field contains the current date stamp. (Our documentation\n-       doesn't yet include a list of all the fields with this \"special\n-       behavior.\")\n+       Most fields do *no* pre-processing — the field data is kept as-is.\n+       Pre-processing is only used on fields that have special behavior.  For\n+       example, if your model has a :class:`~django.db.models.DateField` with\n+       ``auto_now=True``, the pre-save phase will alter the data in the object\n+       to ensure that the date field contains the current date stamp. (Our\n+       documentation doesn't yet include a list of all the fields with this\n+       \"special behavior.\")\n \n     3. **Prepare the data for the database.** Each field is asked to provide\n        its current value in a data type that can be written to the database.\n@@ -232,10 +235,10 @@ When you save an object, Django performs the following steps:\n        integers and strings, are 'ready to write' as a Python object. However,\n        more complex data types often require some modification.\n \n-       For example, ``DateFields`` use a Python ``datetime`` object to store\n-       data. Databases don't store ``datetime`` objects, so the field value\n-       must be converted into an ISO-compliant date string for insertion\n-       into the database.\n+       For example, :class:`~django.db.models.DateField` fields use a Python\n+       ``datetime`` object to store data. Databases don't store ``datetime``\n+       objects, so the field value must be converted into an ISO-compliant date\n+       string for insertion into the database.\n \n     4. **Insert the data into the database.** The pre-processed, prepared\n        data is then composed into an SQL statement for insertion into the\n@@ -273,12 +276,13 @@ auto-primary-key values`_ above and `Forcing an INSERT or UPDATE`_ below.\n Forcing an INSERT or UPDATE\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-In some rare circumstances, it's necessary to be able to force the ``save()``\n-method to perform an SQL ``INSERT`` and not fall back to doing an ``UPDATE``.\n-Or vice-versa: update, if possible, but not insert a new row. In these cases\n-you can pass the ``force_insert=True`` or ``force_update=True`` parameters to\n-the ``save()`` method. Passing both parameters is an error, since you cannot\n-both insert *and* update at the same time.\n+In some rare circumstances, it's necessary to be able to force the\n+:meth:`~Model.save()` method to perform an SQL ``INSERT`` and not fall back to\n+doing an ``UPDATE``. Or vice-versa: update, if possible, but not insert a new\n+row. In these cases you can pass the ``force_insert=True`` or\n+``force_update=True`` parameters to the :meth:`~Model.save()` method.\n+Obviously, passing both parameters is an error: you cannot both insert *and*\n+update at the same time!\n \n It should be very rare that you'll need to use these parameters. Django will\n almost always do the right thing and trying to override that will lead to\n@@ -299,20 +303,25 @@ achieve this is to do something like::\n If the old ``number_sold`` value retrieved from the database was 10, then\n the value of 11 will be written back to the database.\n \n-This can be optimized slightly by expressing the update relative to the\n-original field value, rather than as an explicit assignment of a new value.\n-Django provides :ref:`F() expressions <query-expressions>` as a way of\n+This sequence has a standard update problem in that it contains a race\n+condition. If another thread of execution has already saved an updated value\n+after the current thread retrieved the old value, the current thread will only\n+save the old value plus one, rather than the new (current) value plus one.\n+\n+The process can be made robust and slightly faster by expressing the update\n+relative to the original field value, rather than as an explicit assignment of\n+a new value. Django provides :ref:`F() expressions <query-expressions>` for\n performing this kind of relative update. Using ``F()`` expressions, the\n-previous example would be expressed as::\n+previous example is expressed as::\n \n     >>> from django.db.models import F\n     >>> product = Product.objects.get(name='Venezuelan Beaver Cheese')\n     >>> product.number_sold = F('number_sold') + 1\n     >>> product.save()\n \n This approach doesn't use the initial value from the database. Instead, it\n-makes the database do the update based on whatever value is current at the\n-time that the save() is executed.\n+makes the database do the update based on whatever value is current at the time\n+that the :meth:`~Model.save()` is executed.\n \n Once the object has been saved, you must reload the object in order to access\n the actual value that was applied to the updated field::\n@@ -333,16 +342,15 @@ Deleting objects\n .. versionadded:: 1.2\n    The ``using`` argument was added.\n \n-Issues a SQL ``DELETE`` for the object. This only deletes the object\n-in the database; the Python instance will still be around, and will\n-still have data in its fields.\n+Issues a SQL ``DELETE`` for the object. This only deletes the object in the\n+database; the Python instance will still exist and will still have data in\n+its fields.\n \n For more details, including how to delete objects in bulk, see\n :ref:`topics-db-queries-delete`.\n \n-If you want customized deletion behavior, you can override this\n-``delete()`` method. See :ref:`overriding-model-methods` for more\n-details.\n+If you want customized deletion behavior, you can override the ``delete()``\n+method. See :ref:`overriding-model-methods` for more details.\n \n .. _model-instance-methods:\n \n@@ -351,63 +359,62 @@ Other model instance methods\n \n A few object methods have special purposes.\n \n-``__str__``\n------------\n+``__unicode__``\n+---------------\n \n-.. method:: Model.__str__()\n+.. method:: Model.__unicode__()\n \n-``__str__()`` is a Python \"magic method\" that defines what should be returned\n-if you call ``str()`` on the object. Django uses ``str(obj)`` (or the related\n-function, ``unicode(obj)`` -- see below) in a number of places, most notably\n-as the value displayed to render an object in the Django admin site and as the\n-value inserted into a template when it displays an object. Thus, you should\n-always return a nice, human-readable string for the object's ``__str__``.\n-Although this isn't required, it's strongly encouraged (see the description of\n-``__unicode__``, below, before putting ``__str__`` methods everywhere).\n+The ``__unicode__()`` method is called whenever you call ``unicode()`` on an\n+object. Django uses ``unicode(obj)`` (or the related function, :meth:`str(obj)\n+<Model.__str__>`) in a number of places. Most notably, to display an object in\n+the Django admin site and as the value inserted into a template when it\n+displays an object. Thus, you should always return a nice, human-readable\n+representation of the model from the ``__unicode__()`` method.\n \n For example::\n \n     class Person(models.Model):\n         first_name = models.CharField(max_length=50)\n         last_name = models.CharField(max_length=50)\n \n-        def __str__(self):\n-            # Note use of django.utils.encoding.smart_str() here because\n-            # first_name and last_name will be unicode strings.\n-            return smart_str('%s %s' % (self.first_name, self.last_name))\n+        def __unicode__(self):\n+            return u'%s %s' % (self.first_name, self.last_name)\n \n-``__unicode__``\n----------------\n+If you define a ``__unicode__()`` method on your model and not a\n+:meth:`~Model.__str__()` method, Django will automatically provide you with a\n+:meth:`~Model.__str__()` that calls ``__unicode__()`` and then converts the\n+result correctly to a UTF-8 encoded string object. This is recommended\n+development practice: define only ``__unicode__()`` and let Django take care of\n+the conversion to string objects when required.\n \n-.. method:: Model.__unicode__()\n+``__str__``\n+-----------\n \n-The ``__unicode__()`` method is called whenever you call ``unicode()`` on an\n-object. Since Django's database backends will return Unicode strings in your\n-model's attributes, you would normally want to write a ``__unicode__()``\n-method for your model. The example in the previous section could be written\n-more simply as::\n+.. method:: Model.__str__()\n+\n+The ``__str__()`` method is called whenever you call ``str()`` on an object. The main use for this method directly inside Django is when the ``repr()`` output of a model is displayed anywhere (for example, in debugging output).\n+Thus, you should return a nice, human-readable string for the object's\n+``__str__()``.  It isn't required to put ``__str__()`` methods everywhere if you have sensible :meth:`~Model.__unicode__()` methods.\n+\n+The previous :meth:`~Model.__unicode__()` example could be similarly written\n+using ``__str__()`` like this::\n \n     class Person(models.Model):\n         first_name = models.CharField(max_length=50)\n         last_name = models.CharField(max_length=50)\n \n-        def __unicode__(self):\n-            return u'%s %s' % (self.first_name, self.last_name)\n-\n-If you define a ``__unicode__()`` method on your model and not a ``__str__()``\n-method, Django will automatically provide you with a ``__str__()`` that calls\n-``__unicode__()`` and then converts the result correctly to a UTF-8 encoded\n-string object. This is recommended development practice: define only\n-``__unicode__()`` and let Django take care of the conversion to string objects\n-when required.\n+        def __str__(self):\n+            # Note use of django.utils.encoding.smart_str() here because\n+            # first_name and last_name will be unicode strings.\n+            return smart_str('%s %s' % (self.first_name, self.last_name))\n \n ``get_absolute_url``\n --------------------\n \n .. method:: Model.get_absolute_url()\n \n Define a ``get_absolute_url()`` method to tell Django how to calculate the\n-URL for an object. For example::\n+canonical URL for an object. For example::\n \n     def get_absolute_url(self):\n         return \"/people/%i/\" % self.id\n@@ -520,15 +527,15 @@ More details on named URL patterns are in the :doc:`URL dispatch documentation\n Extra instance methods\n ======================\n \n-In addition to ``save()``, ``delete()``, a model object might get any or all\n-of the following methods:\n+In addition to :meth:`~Model.save()`, :meth:`~Model.delete()`, a model object\n+might have some of the following methods:\n \n .. method:: Model.get_FOO_display()\n \n-For every field that has ``choices`` set, the object will have a\n-``get_FOO_display()`` method, where ``FOO`` is the name of the field. This\n-method returns the \"human-readable\" value of the field. For example, in the\n-following model::\n+For every field that has :attr:`~django.db.models.Field.choices` set, the\n+object will have a ``get_FOO_display()`` method, where ``FOO`` is the name of\n+the field. This method returns the \"human-readable\" value of the field. For\n+example, in the following model::\n \n     GENDER_CHOICES = (\n         ('M', 'Male'),\n@@ -550,16 +557,17 @@ following model::\n .. method:: Model.get_next_by_FOO(\\**kwargs)\n .. method:: Model.get_previous_by_FOO(\\**kwargs)\n \n-For every ``DateField`` and ``DateTimeField`` that does not have ``null=True``,\n-the object will have ``get_next_by_FOO()`` and ``get_previous_by_FOO()``\n-methods, where ``FOO`` is the name of the field. This returns the next and\n-previous object with respect to the date field, raising the appropriate\n-``DoesNotExist`` exception when appropriate.\n+For every :class:`~django.db.models.DateField` and\n+:class:`~django.db.models.DateTimeField` that does not have :attr:`null=True\n+<django.db.models.Field.null>`, the object will have ``get_next_by_FOO()`` and\n+``get_previous_by_FOO()`` methods, where ``FOO`` is the name of the field. This\n+returns the next and previous object with respect to the date field, raising\n+the appropriate :exc:`~django.db.DoesNotExist` exception when appropriate.\n \n Both methods accept optional keyword arguments, which should be in the format\n described in :ref:`Field lookups <field-lookups>`.\n \n-Note that in the case of identical date values, these methods will use the ID\n-as a fallback check. This guarantees that no records are skipped or duplicated.\n+Note that in the case of identical date values, these methods will use the\n+primary key as a tie-breaker. This guarantees that no records are skipped or\n+duplicated. That also means you cannot use those methods on unsaved objects.\n \n-That also means you cannot use those methods on unsaved objects."
        }
    ],
    "stats": {
        "total": 252,
        "additions": 130,
        "deletions": 122
    }
}