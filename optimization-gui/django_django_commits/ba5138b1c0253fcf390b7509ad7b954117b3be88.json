{
    "author": "aaugustin",
    "message": "Deprecated transaction.commit/rollback_unless_managed.\n\nSince \"unless managed\" now means \"if database-level autocommit\",\ncommitting or rolling back doesn't have any effect.\n\nRestored transactional integrity in a few places that relied on\nautomatically-started transactions with a transitory API.",
    "sha": "ba5138b1c0253fcf390b7509ad7b954117b3be88",
    "files": [
        {
            "sha": "51f70f53500fef4482bdad7e103e5b833c8b492f",
            "filename": "django/contrib/gis/utils/layermapping.py",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcontrib%2Fgis%2Futils%2Flayermapping.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcontrib%2Fgis%2Futils%2Flayermapping.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Futils%2Flayermapping.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -555,10 +555,6 @@ def _save(feat_range=default_range, num_feat=0, num_saved=0):\n                     except SystemExit:\n                         raise\n                     except Exception as msg:\n-                        if self.transaction_mode == 'autocommit':\n-                            # Rolling back the transaction so that other model saves\n-                            # will work.\n-                            transaction.rollback_unless_managed()\n                         if strict:\n                             # Bailing out if the `strict` keyword is set.\n                             if not silent:"
        },
        {
            "sha": "30da0b7a10a06d744b5aeb4492428fa89d2db6c1",
            "filename": "django/contrib/sessions/backends/db.py",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcontrib%2Fsessions%2Fbackends%2Fdb.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcontrib%2Fsessions%2Fbackends%2Fdb.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fsessions%2Fbackends%2Fdb.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -74,7 +74,6 @@ def delete(self, session_key=None):\n     @classmethod\n     def clear_expired(cls):\n         Session.objects.filter(expire_date__lt=timezone.now()).delete()\n-        transaction.commit_unless_managed()\n \n \n # At bottom to avoid circular import"
        },
        {
            "sha": "53d7f4d22a87b378df206f40b5fbb5033a0e6c75",
            "filename": "django/core/cache/backends/db.py",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcore%2Fcache%2Fbackends%2Fdb.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcore%2Fcache%2Fbackends%2Fdb.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Fdb.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -10,7 +10,7 @@\n \n from django.conf import settings\n from django.core.cache.backends.base import BaseCache\n-from django.db import connections, router, transaction, DatabaseError\n+from django.db import connections, router, DatabaseError\n from django.utils import timezone, six\n from django.utils.encoding import force_bytes\n \n@@ -70,7 +70,6 @@ def get(self, key, default=None, version=None):\n             cursor = connections[db].cursor()\n             cursor.execute(\"DELETE FROM %s \"\n                            \"WHERE cache_key = %%s\" % table, [key])\n-            transaction.commit_unless_managed(using=db)\n             return default\n         value = connections[db].ops.process_clob(row[1])\n         return pickle.loads(base64.b64decode(force_bytes(value)))\n@@ -124,10 +123,8 @@ def _base_set(self, mode, key, value, timeout=None):\n                                [key, b64encoded, connections[db].ops.value_to_db_datetime(exp)])\n         except DatabaseError:\n             # To be threadsafe, updates/inserts are allowed to fail silently\n-            transaction.rollback_unless_managed(using=db)\n             return False\n         else:\n-            transaction.commit_unless_managed(using=db)\n             return True\n \n     def delete(self, key, version=None):\n@@ -139,7 +136,6 @@ def delete(self, key, version=None):\n         cursor = connections[db].cursor()\n \n         cursor.execute(\"DELETE FROM %s WHERE cache_key = %%s\" % table, [key])\n-        transaction.commit_unless_managed(using=db)\n \n     def has_key(self, key, version=None):\n         key = self.make_key(key, version=version)\n@@ -184,7 +180,6 @@ def clear(self):\n         table = connections[db].ops.quote_name(self._table)\n         cursor = connections[db].cursor()\n         cursor.execute('DELETE FROM %s' % table)\n-        transaction.commit_unless_managed(using=db)\n \n # For backwards compatibility\n class CacheClass(DatabaseCache):"
        },
        {
            "sha": "94b6b09400a953b70d0bfe27f7eaf910ec196027",
            "filename": "django/core/management/commands/createcachetable.py",
            "status": "modified",
            "additions": 10,
            "deletions": 11,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcore%2Fmanagement%2Fcommands%2Fcreatecachetable.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcore%2Fmanagement%2Fcommands%2Fcreatecachetable.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Fcreatecachetable.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -53,14 +53,13 @@ def handle_label(self, tablename, **options):\n         for i, line in enumerate(table_output):\n             full_statement.append('    %s%s' % (line, i < len(table_output)-1 and ',' or ''))\n         full_statement.append(');')\n-        curs = connection.cursor()\n-        try:\n-            curs.execute(\"\\n\".join(full_statement))\n-        except DatabaseError as e:\n-            transaction.rollback_unless_managed(using=db)\n-            raise CommandError(\n-                \"Cache table '%s' could not be created.\\nThe error was: %s.\" %\n-                    (tablename, force_text(e)))\n-        for statement in index_output:\n-            curs.execute(statement)\n-        transaction.commit_unless_managed(using=db)\n+        with transaction.commit_on_success_unless_managed():\n+            curs = connection.cursor()\n+            try:\n+                curs.execute(\"\\n\".join(full_statement))\n+            except DatabaseError as e:\n+                raise CommandError(\n+                    \"Cache table '%s' could not be created.\\nThe error was: %s.\" %\n+                        (tablename, force_text(e)))\n+            for statement in index_output:\n+                curs.execute(statement)"
        },
        {
            "sha": "9bd65e735c3ec9ba8e84ddf4e0f9ee19d51b5901",
            "filename": "django/core/management/commands/flush.py",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcore%2Fmanagement%2Fcommands%2Fflush.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcore%2Fmanagement%2Fcommands%2Fflush.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Fflush.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -57,18 +57,17 @@ def handle_noargs(self, **options):\n \n         if confirm == 'yes':\n             try:\n-                cursor = connection.cursor()\n-                for sql in sql_list:\n-                    cursor.execute(sql)\n+                with transaction.commit_on_success_unless_managed():\n+                    cursor = connection.cursor()\n+                    for sql in sql_list:\n+                        cursor.execute(sql)\n             except Exception as e:\n-                transaction.rollback_unless_managed(using=db)\n                 raise CommandError(\"\"\"Database %s couldn't be flushed. Possible reasons:\n   * The database isn't running or isn't configured correctly.\n   * At least one of the expected database tables doesn't exist.\n   * The SQL was invalid.\n Hint: Look at the output of 'django-admin.py sqlflush'. That's the SQL this command wasn't able to run.\n The full error: %s\"\"\" % (connection.settings_dict['NAME'], e))\n-            transaction.commit_unless_managed(using=db)\n \n             # Emit the post sync signal. This allows individual\n             # applications to respond as if the database had been"
        },
        {
            "sha": "674e6be7b0bb12e52fcf73d4f77cd40b0904262c",
            "filename": "django/core/management/commands/loaddata.py",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -73,7 +73,6 @@ def handle(self, *fixture_labels, **options):\n         # Start transaction management. All fixtures are installed in a\n         # single transaction to ensure that all references are resolved.\n         if commit:\n-            transaction.commit_unless_managed(using=self.using)\n             transaction.enter_transaction_management(using=self.using)\n \n         class SingleZipReader(zipfile.ZipFile):"
        },
        {
            "sha": "e7e11a8c90e403334054930b1f2990a1d3a6c045",
            "filename": "django/core/management/commands/syncdb.py",
            "status": "modified",
            "additions": 37,
            "deletions": 40,
            "changes": 77,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcore%2Fmanagement%2Fcommands%2Fsyncdb.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fcore%2Fmanagement%2Fcommands%2Fsyncdb.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Fsyncdb.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -83,26 +83,25 @@ def model_installed(model):\n         # Create the tables for each model\n         if verbosity >= 1:\n             self.stdout.write(\"Creating tables ...\\n\")\n-        for app_name, model_list in manifest.items():\n-            for model in model_list:\n-                # Create the model's database table, if it doesn't already exist.\n-                if verbosity >= 3:\n-                    self.stdout.write(\"Processing %s.%s model\\n\" % (app_name, model._meta.object_name))\n-                sql, references = connection.creation.sql_create_model(model, self.style, seen_models)\n-                seen_models.add(model)\n-                created_models.add(model)\n-                for refto, refs in references.items():\n-                    pending_references.setdefault(refto, []).extend(refs)\n-                    if refto in seen_models:\n-                        sql.extend(connection.creation.sql_for_pending_references(refto, self.style, pending_references))\n-                sql.extend(connection.creation.sql_for_pending_references(model, self.style, pending_references))\n-                if verbosity >= 1 and sql:\n-                    self.stdout.write(\"Creating table %s\\n\" % model._meta.db_table)\n-                for statement in sql:\n-                    cursor.execute(statement)\n-                tables.append(connection.introspection.table_name_converter(model._meta.db_table))\n-\n-        transaction.commit_unless_managed(using=db)\n+        with transaction.commit_on_success_unless_managed(using=db):\n+            for app_name, model_list in manifest.items():\n+                for model in model_list:\n+                    # Create the model's database table, if it doesn't already exist.\n+                    if verbosity >= 3:\n+                        self.stdout.write(\"Processing %s.%s model\\n\" % (app_name, model._meta.object_name))\n+                    sql, references = connection.creation.sql_create_model(model, self.style, seen_models)\n+                    seen_models.add(model)\n+                    created_models.add(model)\n+                    for refto, refs in references.items():\n+                        pending_references.setdefault(refto, []).extend(refs)\n+                        if refto in seen_models:\n+                            sql.extend(connection.creation.sql_for_pending_references(refto, self.style, pending_references))\n+                    sql.extend(connection.creation.sql_for_pending_references(model, self.style, pending_references))\n+                    if verbosity >= 1 and sql:\n+                        self.stdout.write(\"Creating table %s\\n\" % model._meta.db_table)\n+                    for statement in sql:\n+                        cursor.execute(statement)\n+                    tables.append(connection.introspection.table_name_converter(model._meta.db_table))\n \n         # Send the post_syncdb signal, so individual apps can do whatever they need\n         # to do at this point.\n@@ -122,17 +121,16 @@ def model_installed(model):\n                     if custom_sql:\n                         if verbosity >= 2:\n                             self.stdout.write(\"Installing custom SQL for %s.%s model\\n\" % (app_name, model._meta.object_name))\n-                        try:\n-                            for sql in custom_sql:\n-                                cursor.execute(sql)\n-                        except Exception as e:\n-                            self.stderr.write(\"Failed to install custom SQL for %s.%s model: %s\\n\" % \\\n-                                                (app_name, model._meta.object_name, e))\n-                            if show_traceback:\n-                                traceback.print_exc()\n-                            transaction.rollback_unless_managed(using=db)\n-                        else:\n-                            transaction.commit_unless_managed(using=db)\n+                        with transaction.commit_on_success_unless_managed(using=db):\n+                            try:\n+                                for sql in custom_sql:\n+                                    cursor.execute(sql)\n+                            except Exception as e:\n+                                self.stderr.write(\"Failed to install custom SQL for %s.%s model: %s\\n\" % \\\n+                                                    (app_name, model._meta.object_name, e))\n+                                if show_traceback:\n+                                    traceback.print_exc()\n+                                raise\n                     else:\n                         if verbosity >= 3:\n                             self.stdout.write(\"No custom SQL for %s.%s model\\n\" % (app_name, model._meta.object_name))\n@@ -147,15 +145,14 @@ def model_installed(model):\n                     if index_sql:\n                         if verbosity >= 2:\n                             self.stdout.write(\"Installing index for %s.%s model\\n\" % (app_name, model._meta.object_name))\n-                        try:\n-                            for sql in index_sql:\n-                                cursor.execute(sql)\n-                        except Exception as e:\n-                            self.stderr.write(\"Failed to install index for %s.%s model: %s\\n\" % \\\n-                                                (app_name, model._meta.object_name, e))\n-                            transaction.rollback_unless_managed(using=db)\n-                        else:\n-                            transaction.commit_unless_managed(using=db)\n+                        with transaction.commit_on_success_unless_managed(using=db):\n+                            try:\n+                                for sql in index_sql:\n+                                    cursor.execute(sql)\n+                            except Exception as e:\n+                                self.stderr.write(\"Failed to install index for %s.%s model: %s\\n\" % \\\n+                                                    (app_name, model._meta.object_name, e))\n+                                raise\n \n         # Load initial_data fixtures (unless that has been disabled)\n         if load_initial_data:"
        },
        {
            "sha": "13ba68ba7e054a9fd5f533ea395797e1695435ea",
            "filename": "django/db/__init__.py",
            "status": "modified",
            "additions": 0,
            "deletions": 11,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2F__init__.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -77,14 +77,3 @@ def close_old_connections(**kwargs):\n         conn.close_if_unusable_or_obsolete()\n signals.request_started.connect(close_old_connections)\n signals.request_finished.connect(close_old_connections)\n-\n-# Register an event that rolls back the connections\n-# when a Django request has an exception.\n-def _rollback_on_exception(**kwargs):\n-    from django.db import transaction\n-    for conn in connections:\n-        try:\n-            transaction.rollback_unless_managed(using=conn)\n-        except DatabaseError:\n-            pass\n-signals.got_request_exception.connect(_rollback_on_exception)"
        },
        {
            "sha": "848f6df2d6f6960e63ccc94b520c0aa673a42ec0",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -339,27 +339,6 @@ def is_managed(self):\n             return self.transaction_state[-1]\n         return settings.TRANSACTIONS_MANAGED\n \n-    def commit_unless_managed(self):\n-        \"\"\"\n-        Commits changes if the system is not in managed transaction mode.\n-        \"\"\"\n-        self.validate_thread_sharing()\n-        if not self.is_managed():\n-            self.commit()\n-            self.clean_savepoints()\n-        else:\n-            self.set_dirty()\n-\n-    def rollback_unless_managed(self):\n-        \"\"\"\n-        Rolls back changes if the system is not in managed transaction mode.\n-        \"\"\"\n-        self.validate_thread_sharing()\n-        if not self.is_managed():\n-            self.rollback()\n-        else:\n-            self.set_dirty()\n-\n     ##### Foreign key constraints checks handling #####\n \n     @contextmanager"
        },
        {
            "sha": "9a220ffd8b5ca233f8a3e4b37e41d6e351d7b8fd",
            "filename": "django/db/backends/dummy/base.py",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2Fbackends%2Fdummy%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2Fbackends%2Fdummy%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fdummy%2Fbase.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -58,8 +58,6 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     _set_autocommit = complain\n     set_dirty = complain\n     set_clean = complain\n-    commit_unless_managed = complain\n-    rollback_unless_managed = ignore\n \n     def __init__(self, *args, **kwargs):\n         super(DatabaseWrapper, self).__init__(*args, **kwargs)"
        },
        {
            "sha": "ab0e42d4619fc0546da9d7ff06b5114cea245e6a",
            "filename": "django/db/models/base.py",
            "status": "modified",
            "additions": 42,
            "deletions": 42,
            "changes": 84,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2Fmodels%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2Fmodels%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fbase.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -609,48 +609,48 @@ def save_base(self, raw=False, cls=None, origin=None, force_insert=False,\n             if update_fields:\n                 non_pks = [f for f in non_pks if f.name in update_fields or f.attname in update_fields]\n \n-            # First, try an UPDATE. If that doesn't update anything, do an INSERT.\n-            pk_val = self._get_pk_val(meta)\n-            pk_set = pk_val is not None\n-            record_exists = True\n-            manager = cls._base_manager\n-            if pk_set:\n-                # Determine if we should do an update (pk already exists, forced update,\n-                # no force_insert)\n-                if ((force_update or update_fields) or (not force_insert and\n-                        manager.using(using).filter(pk=pk_val).exists())):\n-                    if force_update or non_pks:\n-                        values = [(f, None, (raw and getattr(self, f.attname) or f.pre_save(self, False))) for f in non_pks]\n-                        if values:\n-                            rows = manager.using(using).filter(pk=pk_val)._update(values)\n-                            if force_update and not rows:\n-                                raise DatabaseError(\"Forced update did not affect any rows.\")\n-                            if update_fields and not rows:\n-                                raise DatabaseError(\"Save with update_fields did not affect any rows.\")\n-                else:\n-                    record_exists = False\n-            if not pk_set or not record_exists:\n-                if meta.order_with_respect_to:\n-                    # If this is a model with an order_with_respect_to\n-                    # autopopulate the _order field\n-                    field = meta.order_with_respect_to\n-                    order_value = manager.using(using).filter(**{field.name: getattr(self, field.attname)}).count()\n-                    self._order = order_value\n-\n-                fields = meta.local_fields\n-                if not pk_set:\n-                    if force_update or update_fields:\n-                        raise ValueError(\"Cannot force an update in save() with no primary key.\")\n-                    fields = [f for f in fields if not isinstance(f, AutoField)]\n+            with transaction.commit_on_success_unless_managed(using=using):\n+                # First, try an UPDATE. If that doesn't update anything, do an INSERT.\n+                pk_val = self._get_pk_val(meta)\n+                pk_set = pk_val is not None\n+                record_exists = True\n+                manager = cls._base_manager\n+                if pk_set:\n+                    # Determine if we should do an update (pk already exists, forced update,\n+                    # no force_insert)\n+                    if ((force_update or update_fields) or (not force_insert and\n+                            manager.using(using).filter(pk=pk_val).exists())):\n+                        if force_update or non_pks:\n+                            values = [(f, None, (raw and getattr(self, f.attname) or f.pre_save(self, False))) for f in non_pks]\n+                            if values:\n+                                rows = manager.using(using).filter(pk=pk_val)._update(values)\n+                                if force_update and not rows:\n+                                    raise DatabaseError(\"Forced update did not affect any rows.\")\n+                                if update_fields and not rows:\n+                                    raise DatabaseError(\"Save with update_fields did not affect any rows.\")\n+                    else:\n+                        record_exists = False\n+                if not pk_set or not record_exists:\n+                    if meta.order_with_respect_to:\n+                        # If this is a model with an order_with_respect_to\n+                        # autopopulate the _order field\n+                        field = meta.order_with_respect_to\n+                        order_value = manager.using(using).filter(**{field.name: getattr(self, field.attname)}).count()\n+                        self._order = order_value\n+\n+                    fields = meta.local_fields\n+                    if not pk_set:\n+                        if force_update or update_fields:\n+                            raise ValueError(\"Cannot force an update in save() with no primary key.\")\n+                        fields = [f for f in fields if not isinstance(f, AutoField)]\n \n-                record_exists = False\n+                    record_exists = False\n \n-                update_pk = bool(meta.has_auto_field and not pk_set)\n-                result = manager._insert([self], fields=fields, return_id=update_pk, using=using, raw=raw)\n+                    update_pk = bool(meta.has_auto_field and not pk_set)\n+                    result = manager._insert([self], fields=fields, return_id=update_pk, using=using, raw=raw)\n \n-                if update_pk:\n-                    setattr(self, meta.pk.attname, result)\n-            transaction.commit_unless_managed(using=using)\n+                    if update_pk:\n+                        setattr(self, meta.pk.attname, result)\n \n         # Store the database on which the object was saved\n         self._state.db = using\n@@ -963,9 +963,9 @@ def method_set_order(ordered_obj, self, id_list, using=None):\n     order_name = ordered_obj._meta.order_with_respect_to.name\n     # FIXME: It would be nice if there was an \"update many\" version of update\n     # for situations like this.\n-    for i, j in enumerate(id_list):\n-        ordered_obj.objects.filter(**{'pk': j, order_name: rel_val}).update(_order=i)\n-    transaction.commit_unless_managed(using=using)\n+    with transaction.commit_on_success_unless_managed(using=using):\n+        for i, j in enumerate(id_list):\n+            ordered_obj.objects.filter(**{'pk': j, order_name: rel_val}).update(_order=i)\n \n \n def method_get_order(ordered_obj, self):"
        },
        {
            "sha": "26f63391d52258bad1dac6a9324c6cf55a29e737",
            "filename": "django/db/models/deletion.py",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2Fmodels%2Fdeletion.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2Fmodels%2Fdeletion.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fdeletion.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -62,8 +62,6 @@ def decorated(self, *args, **kwargs):\n             func(self, *args, **kwargs)\n             if forced_managed:\n                 transaction.commit(using=self.using)\n-            else:\n-                transaction.commit_unless_managed(using=self.using)\n         finally:\n             if forced_managed:\n                 transaction.leave_transaction_management(using=self.using)"
        },
        {
            "sha": "22f71c6aee16a88afbf5fe7013053b15125c54cc",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -460,8 +460,6 @@ def bulk_create(self, objs, batch_size=None):\n                     self._batched_insert(objs_without_pk, fields, batch_size)\n             if forced_managed:\n                 transaction.commit(using=self.db)\n-            else:\n-                transaction.commit_unless_managed(using=self.db)\n         finally:\n             if forced_managed:\n                 transaction.leave_transaction_management(using=self.db)\n@@ -590,8 +588,6 @@ def update(self, **kwargs):\n             rows = query.get_compiler(self.db).execute_sql(None)\n             if forced_managed:\n                 transaction.commit(using=self.db)\n-            else:\n-                transaction.commit_unless_managed(using=self.db)\n         finally:\n             if forced_managed:\n                 transaction.leave_transaction_management(using=self.db)"
        },
        {
            "sha": "a8e80c6c02237f89131bfd9b7312157e2bc00de2",
            "filename": "django/db/transaction.py",
            "status": "modified",
            "additions": 19,
            "deletions": 8,
            "changes": 27,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2Ftransaction.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Fdb%2Ftransaction.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Ftransaction.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -123,16 +123,12 @@ def managed(flag=True, using=None):\n         PendingDeprecationWarning, stacklevel=2)\n \n def commit_unless_managed(using=None):\n-    \"\"\"\n-    Commits changes if the system is not in managed transaction mode.\n-    \"\"\"\n-    get_connection(using).commit_unless_managed()\n+    warnings.warn(\"'commit_unless_managed' is now a no-op.\",\n+        PendingDeprecationWarning, stacklevel=2)\n \n def rollback_unless_managed(using=None):\n-    \"\"\"\n-    Rolls back changes if the system is not in managed transaction mode.\n-    \"\"\"\n-    get_connection(using).rollback_unless_managed()\n+    warnings.warn(\"'rollback_unless_managed' is now a no-op.\",\n+        PendingDeprecationWarning, stacklevel=2)\n \n ###############\n # Public APIs #\n@@ -280,3 +276,18 @@ def exiting(exc_value, using):\n         leave_transaction_management(using=using)\n \n     return _transaction_func(entering, exiting, using)\n+\n+def commit_on_success_unless_managed(using=None):\n+    \"\"\"\n+    Transitory API to preserve backwards-compatibility while refactoring.\n+    \"\"\"\n+    if is_managed(using):\n+        def entering(using):\n+            pass\n+\n+        def exiting(exc_value, using):\n+            set_dirty(using=using)\n+\n+        return _transaction_func(entering, exiting, using)\n+    else:\n+        return commit_on_success(using)"
        },
        {
            "sha": "55673dca25c94246e2e237200cdcfaddd9aa74c5",
            "filename": "django/test/testcases.py",
            "status": "modified",
            "additions": 1,
            "deletions": 18,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Ftest%2Ftestcases.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/django%2Ftest%2Ftestcases.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Ftestcases.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -157,14 +157,6 @@ def __init__(self, *args, **kwargs):\n         doctest.DocTestRunner.__init__(self, *args, **kwargs)\n         self.optionflags = doctest.ELLIPSIS\n \n-    def report_unexpected_exception(self, out, test, example, exc_info):\n-        doctest.DocTestRunner.report_unexpected_exception(self, out, test,\n-                                                          example, exc_info)\n-        # Rollback, in case of database errors. Otherwise they'd have\n-        # side effects on other tests.\n-        for conn in connections:\n-            transaction.rollback_unless_managed(using=conn)\n-\n \n class _AssertNumQueriesContext(CaptureQueriesContext):\n     def __init__(self, test_case, num, connection):\n@@ -490,14 +482,10 @@ def _reset_sequences(self, db_name):\n                 conn.ops.sequence_reset_by_name_sql(no_style(),\n                                                     conn.introspection.sequence_list())\n             if sql_list:\n-                try:\n+                with transaction.commit_on_success_unless_managed(using=db_name):\n                     cursor = conn.cursor()\n                     for sql in sql_list:\n                         cursor.execute(sql)\n-                except Exception:\n-                    transaction.rollback_unless_managed(using=db_name)\n-                    raise\n-                transaction.commit_unless_managed(using=db_name)\n \n     def _fixture_setup(self):\n         for db_name in self._databases_names(include_mirrors=False):\n@@ -537,11 +525,6 @@ def _post_teardown(self):\n             conn.close()\n \n     def _fixture_teardown(self):\n-        # Roll back any pending transactions in order to avoid a deadlock\n-        # during flush when TEST_MIRROR is used (#18984).\n-        for conn in connections.all():\n-            conn.rollback_unless_managed()\n-\n         for db in self._databases_names(include_mirrors=False):\n             call_command('flush', verbosity=0, interactive=False, database=db,\n                          skip_validation=True, reset_sequences=False)"
        },
        {
            "sha": "a81b16278fd4c1b5e4054b9c8f452c438bb9de79",
            "filename": "docs/internals/deprecation.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/docs%2Finternals%2Fdeprecation.txt",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/docs%2Finternals%2Fdeprecation.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Finternals%2Fdeprecation.txt?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -352,6 +352,8 @@ these changes.\n   - ``django.db.close_connection()``\n   - ``django.db.backends.creation.BaseDatabaseCreation.set_autocommit()``\n   - ``django.db.transaction.managed()``\n+  - ``django.db.transaction.commit_unless_managed()``\n+  - ``django.db.transaction.rollback_unless_managed()``\n \n 2.0\n ---"
        },
        {
            "sha": "3d571fba2f1ea2018de676246b2e3baee037f706",
            "filename": "tests/transactions_regress/tests.py",
            "status": "modified",
            "additions": 0,
            "deletions": 32,
            "changes": 32,
            "blob_url": "https://github.com/django/django/blob/ba5138b1c0253fcf390b7509ad7b954117b3be88/tests%2Ftransactions_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/ba5138b1c0253fcf390b7509ad7b954117b3be88/tests%2Ftransactions_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions_regress%2Ftests.py?ref=ba5138b1c0253fcf390b7509ad7b954117b3be88",
            "patch": "@@ -208,38 +208,6 @@ def test_enter_exit_management(self):\n         connection.leave_transaction_management()\n         self.assertEqual(orig_dirty, connection._dirty)\n \n-    # TODO: update this test to account for database-level autocommit.\n-    @expectedFailure\n-    def test_commit_unless_managed(self):\n-        cursor = connection.cursor()\n-        cursor.execute(\"INSERT into transactions_regress_mod (fld) values (2)\")\n-        connection.commit_unless_managed()\n-        self.assertFalse(connection.is_dirty())\n-        self.assertEqual(len(Mod.objects.all()), 1)\n-        self.assertTrue(connection.is_dirty())\n-        connection.commit_unless_managed()\n-        self.assertFalse(connection.is_dirty())\n-\n-    # TODO: update this test to account for database-level autocommit.\n-    @expectedFailure\n-    def test_commit_unless_managed_in_managed(self):\n-        cursor = connection.cursor()\n-        connection.enter_transaction_management()\n-        cursor.execute(\"INSERT into transactions_regress_mod (fld) values (2)\")\n-        connection.commit_unless_managed()\n-        self.assertTrue(connection.is_dirty())\n-        connection.rollback()\n-        self.assertFalse(connection.is_dirty())\n-        self.assertEqual(len(Mod.objects.all()), 0)\n-        connection.commit()\n-        connection.leave_transaction_management()\n-        self.assertFalse(connection.is_dirty())\n-        self.assertEqual(len(Mod.objects.all()), 0)\n-        self.assertTrue(connection.is_dirty())\n-        connection.commit_unless_managed()\n-        self.assertFalse(connection.is_dirty())\n-        self.assertEqual(len(Mod.objects.all()), 0)\n-\n \n @skipUnless(connection.vendor == 'postgresql',\n             \"This test only valid for PostgreSQL\")"
        }
    ],
    "stats": {
        "total": 324,
        "additions": 116,
        "deletions": 208
    }
}