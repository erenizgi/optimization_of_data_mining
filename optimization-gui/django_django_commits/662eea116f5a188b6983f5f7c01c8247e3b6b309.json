{
    "author": "spookylukey",
    "message": "Fixed #16937 - added `QuerySet.prefetch_related` to prefetch many related objects.\n\nMany thanks to akaariai for lots of review and feedback, bug finding,\nadditional unit tests and performance testing.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16930 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "662eea116f5a188b6983f5f7c01c8247e3b6b309",
    "files": [
        {
            "sha": "f475c08812b22fcb9be665ee40b87f79ae7398bf",
            "filename": "django/contrib/contenttypes/generic.py",
            "status": "modified",
            "additions": 24,
            "deletions": 10,
            "changes": 34,
            "blob_url": "https://github.com/django/django/blob/662eea116f5a188b6983f5f7c01c8247e3b6b309/django%2Fcontrib%2Fcontenttypes%2Fgeneric.py",
            "raw_url": "https://github.com/django/django/raw/662eea116f5a188b6983f5f7c01c8247e3b6b309/django%2Fcontrib%2Fcontenttypes%2Fgeneric.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fcontenttypes%2Fgeneric.py?ref=662eea116f5a188b6983f5f7c01c8247e3b6b309",
            "patch": "@@ -225,11 +225,7 @@ def __get__(self, instance, instance_type=None):\n             content_type = content_type,\n             content_type_field_name = self.field.content_type_field_name,\n             object_id_field_name = self.field.object_id_field_name,\n-            core_filters = {\n-                '%s__pk' % self.field.content_type_field_name: content_type.id,\n-                '%s__exact' % self.field.object_id_field_name: instance._get_pk_val(),\n-            }\n-\n+            prefetch_cache_name = self.field.attname,\n         )\n \n         return manager\n@@ -250,12 +246,12 @@ def create_generic_related_manager(superclass):\n     \"\"\"\n \n     class GenericRelatedObjectManager(superclass):\n-        def __init__(self, model=None, core_filters=None, instance=None, symmetrical=None,\n+        def __init__(self, model=None, instance=None, symmetrical=None,\n                      source_col_name=None, target_col_name=None, content_type=None,\n-                     content_type_field_name=None, object_id_field_name=None):\n+                     content_type_field_name=None, object_id_field_name=None,\n+                     prefetch_cache_name=None):\n \n             super(GenericRelatedObjectManager, self).__init__()\n-            self.core_filters = core_filters\n             self.model = model\n             self.content_type = content_type\n             self.symmetrical = symmetrical\n@@ -264,11 +260,29 @@ def __init__(self, model=None, core_filters=None, instance=None, symmetrical=Non\n             self.target_col_name = target_col_name\n             self.content_type_field_name = content_type_field_name\n             self.object_id_field_name = object_id_field_name\n+            self.prefetch_cache_name = prefetch_cache_name\n             self.pk_val = self.instance._get_pk_val()\n+            self.core_filters = {\n+                '%s__pk' % content_type_field_name: content_type.id,\n+                '%s__exact' % object_id_field_name: instance._get_pk_val(),\n+            }\n \n         def get_query_set(self):\n-            db = self._db or router.db_for_read(self.model, instance=self.instance)\n-            return super(GenericRelatedObjectManager, self).get_query_set().using(db).filter(**self.core_filters)\n+            try:\n+                return self.instance._prefetched_objects_cache[self.prefetch_cache_name]\n+            except (AttributeError, KeyError):\n+                db = self._db or router.db_for_read(self.model, instance=self.instance)\n+                return super(GenericRelatedObjectManager, self).get_query_set().using(db).filter(**self.core_filters)\n+\n+        def get_prefetch_query_set(self, instances):\n+            db = self._db or router.db_for_read(self.model)\n+            query = {\n+                '%s__pk' % self.content_type_field_name: self.content_type.id,\n+                '%s__in' % self.object_id_field_name:\n+                    [obj._get_pk_val() for obj in instances]\n+                }\n+            qs = super(GenericRelatedObjectManager, self).get_query_set().using(db).filter(**query)\n+            return (qs, self.object_id_field_name, 'pk')\n \n         def add(self, *objs):\n             for obj in objs:"
        },
        {
            "sha": "8bf9d247b17f92e04a83e6d76801e4329c57e804",
            "filename": "django/db/models/fields/related.py",
            "status": "modified",
            "additions": 60,
            "deletions": 9,
            "changes": 69,
            "blob_url": "https://github.com/django/django/blob/662eea116f5a188b6983f5f7c01c8247e3b6b309/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "raw_url": "https://github.com/django/django/raw/662eea116f5a188b6983f5f7c01c8247e3b6b309/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2Frelated.py?ref=662eea116f5a188b6983f5f7c01c8247e3b6b309",
            "patch": "@@ -432,8 +432,22 @@ def __init__(self, instance):\n                 self.model = rel_model\n \n             def get_query_set(self):\n-                db = self._db or router.db_for_read(self.model, instance=self.instance)\n-                return super(RelatedManager, self).get_query_set().using(db).filter(**(self.core_filters))\n+                try:\n+                    return self.instance._prefetched_objects_cache[rel_field.related_query_name()]\n+                except (AttributeError, KeyError):\n+                    db = self._db or router.db_for_read(self.model, instance=self.instance)\n+                    return super(RelatedManager, self).get_query_set().using(db).filter(**self.core_filters)\n+\n+            def get_prefetch_query_set(self, instances):\n+                \"\"\"\n+                Return a queryset that does the bulk lookup needed\n+                by prefetch_related functionality.\n+                \"\"\"\n+                db = self._db or router.db_for_read(self.model)\n+                query = {'%s__%s__in' % (rel_field.name, attname):\n+                             [getattr(obj, attname) for obj in instances]}\n+                qs = super(RelatedManager, self).get_query_set().using(db).filter(**query)\n+                return (qs, rel_field.get_attname(), attname)\n \n             def add(self, *objs):\n                 for obj in objs:\n@@ -482,25 +496,60 @@ def create_many_related_manager(superclass, rel):\n     \"\"\"Creates a manager that subclasses 'superclass' (which is a Manager)\n     and adds behavior for many-to-many related objects.\"\"\"\n     class ManyRelatedManager(superclass):\n-        def __init__(self, model=None, core_filters=None, instance=None, symmetrical=None,\n+        def __init__(self, model=None, query_field_name=None, instance=None, symmetrical=None,\n                      source_field_name=None, target_field_name=None, reverse=False,\n-                     through=None):\n+                     through=None, prefetch_cache_name=None):\n             super(ManyRelatedManager, self).__init__()\n             self.model = model\n-            self.core_filters = core_filters\n+            self.query_field_name = query_field_name\n+            self.core_filters = {'%s__pk' % query_field_name: instance._get_pk_val()}\n             self.instance = instance\n             self.symmetrical = symmetrical\n             self.source_field_name = source_field_name\n             self.target_field_name = target_field_name\n             self.reverse = reverse\n             self.through = through\n+            self.prefetch_cache_name = prefetch_cache_name\n             self._pk_val = self.instance.pk\n             if self._pk_val is None:\n                 raise ValueError(\"%r instance needs to have a primary key value before a many-to-many relationship can be used.\" % instance.__class__.__name__)\n \n         def get_query_set(self):\n-            db = self._db or router.db_for_read(self.instance.__class__, instance=self.instance)\n-            return super(ManyRelatedManager, self).get_query_set().using(db)._next_is_sticky().filter(**(self.core_filters))\n+            try:\n+                return self.instance._prefetched_objects_cache[self.prefetch_cache_name]\n+            except (AttributeError, KeyError):\n+                db = self._db or router.db_for_read(self.instance.__class__, instance=self.instance)\n+                return super(ManyRelatedManager, self).get_query_set().using(db)._next_is_sticky().filter(**self.core_filters)\n+\n+        def get_prefetch_query_set(self, instances):\n+            \"\"\"\n+            Returns a tuple:\n+            (queryset of instances of self.model that are related to passed in instances\n+             attr of returned instances needed for matching\n+             attr of passed in instances needed for matching)\n+            \"\"\"\n+            from django.db import connections\n+            db = self._db or router.db_for_read(self.model)\n+            query = {'%s__pk__in' % self.query_field_name:\n+                         [obj._get_pk_val() for obj in instances]}\n+            qs = super(ManyRelatedManager, self).get_query_set().using(db)._next_is_sticky().filter(**query)\n+\n+            # M2M: need to annotate the query in order to get the primary model\n+            # that the secondary model was actually related to. We know that\n+            # there will already be a join on the join table, so we can just add\n+            # the select.\n+\n+            # For non-autocreated 'through' models, can't assume we are\n+            # dealing with PK values.\n+            fk = self.through._meta.get_field(self.source_field_name)\n+            source_col = fk.column\n+            join_table = self.through._meta.db_table\n+            connection = connections[db]\n+            qn = connection.ops.quote_name\n+            qs = qs.extra(select={'_prefetch_related_val':\n+                                      '%s.%s' % (qn(join_table), qn(source_col))})\n+            select_attname = fk.rel.get_related_field().get_attname()\n+            return (qs, '_prefetch_related_val', select_attname)\n \n         # If the ManyToMany relation has an intermediary model,\n         # the add and remove methods do not exist.\n@@ -683,7 +732,8 @@ def __get__(self, instance, instance_type=None):\n \n         manager = self.related_manager_cls(\n             model=rel_model,\n-            core_filters={'%s__pk' % self.related.field.name: instance._get_pk_val()},\n+            query_field_name=self.related.field.name,\n+            prefetch_cache_name=self.related.field.related_query_name(),\n             instance=instance,\n             symmetrical=False,\n             source_field_name=self.related.field.m2m_reverse_field_name(),\n@@ -739,7 +789,8 @@ def __get__(self, instance, instance_type=None):\n \n         manager = self.related_manager_cls(\n             model=self.field.rel.to,\n-            core_filters={'%s__pk' % self.field.related_query_name(): instance._get_pk_val()},\n+            query_field_name=self.field.related_query_name(),\n+            prefetch_cache_name=self.field.name,\n             instance=instance,\n             symmetrical=self.field.rel.symmetrical,\n             source_field_name=self.field.m2m_field_name(),"
        },
        {
            "sha": "e1bbf6ebc59b596953b180ff58e850d07012eaf3",
            "filename": "django/db/models/manager.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/662eea116f5a188b6983f5f7c01c8247e3b6b309/django%2Fdb%2Fmodels%2Fmanager.py",
            "raw_url": "https://github.com/django/django/raw/662eea116f5a188b6983f5f7c01c8247e3b6b309/django%2Fdb%2Fmodels%2Fmanager.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fmanager.py?ref=662eea116f5a188b6983f5f7c01c8247e3b6b309",
            "patch": "@@ -172,6 +172,9 @@ def select_for_update(self, *args, **kwargs):\n     def select_related(self, *args, **kwargs):\n         return self.get_query_set().select_related(*args, **kwargs)\n \n+    def prefetch_related(self, *args, **kwargs):\n+        return self.get_query_set().prefetch_related(*args, **kwargs)\n+\n     def values(self, *args, **kwargs):\n         return self.get_query_set().values(*args, **kwargs)\n "
        },
        {
            "sha": "b21db2e5212b034738ddbb787169608513b697e0",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 179,
            "deletions": 0,
            "changes": 179,
            "blob_url": "https://github.com/django/django/blob/662eea116f5a188b6983f5f7c01c8247e3b6b309/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/662eea116f5a188b6983f5f7c01c8247e3b6b309/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=662eea116f5a188b6983f5f7c01c8247e3b6b309",
            "patch": "@@ -36,6 +36,8 @@ def __init__(self, model=None, query=None, using=None):\n         self._iter = None\n         self._sticky_filter = False\n         self._for_write = False\n+        self._prefetch_related_lookups = []\n+        self._prefetch_done = False\n \n     ########################\n     # PYTHON MAGIC METHODS #\n@@ -81,9 +83,17 @@ def __len__(self):\n                 self._result_cache = list(self.iterator())\n         elif self._iter:\n             self._result_cache.extend(self._iter)\n+        if self._prefetch_related_lookups and not self._prefetch_done:\n+            self._prefetch_related_objects()\n         return len(self._result_cache)\n \n     def __iter__(self):\n+        if self._prefetch_related_lookups and not self._prefetch_done:\n+            # We need all the results in order to be able to do the prefetch\n+            # in one go. To minimize code duplication, we use the __len__\n+            # code path which also forces this, and also does the prefetch\n+            len(self)\n+\n         if self._result_cache is None:\n             self._iter = self.iterator()\n             self._result_cache = []\n@@ -106,6 +116,12 @@ def _result_iter(self):\n                 self._fill_cache()\n \n     def __nonzero__(self):\n+        if self._prefetch_related_lookups and not self._prefetch_done:\n+            # We need all the results in order to be able to do the prefetch\n+            # in one go. To minimize code duplication, we use the __len__\n+            # code path which also forces this, and also does the prefetch\n+            len(self)\n+\n         if self._result_cache is not None:\n             return bool(self._result_cache)\n         try:\n@@ -527,6 +543,11 @@ def exists(self):\n             return self.query.has_results(using=self.db)\n         return bool(self._result_cache)\n \n+    def _prefetch_related_objects(self):\n+        # This method can only be called once the result cache has been filled.\n+        prefetch_related_objects(self._result_cache, self._prefetch_related_lookups)\n+        self._prefetch_done = True\n+\n     ##################################################\n     # PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS #\n     ##################################################\n@@ -650,6 +671,23 @@ def select_related(self, *fields, **kwargs):\n             obj.query.max_depth = depth\n         return obj\n \n+    def prefetch_related(self, *lookups):\n+        \"\"\"\n+        Returns a new QuerySet instance that will prefetch the specified\n+        Many-To-One and Many-To-Many related objects when the QuerySet is\n+        evaluated.\n+\n+        When prefetch_related() is called more than once, the list of lookups to\n+        prefetch is appended to. If prefetch_related(None) is called, the\n+        the list is cleared.\n+        \"\"\"\n+        clone = self._clone()\n+        if lookups == (None,):\n+            clone._prefetch_related_lookups = []\n+        else:\n+            clone._prefetch_related_lookups.extend(lookups)\n+        return clone\n+\n     def dup_select_related(self, other):\n         \"\"\"\n         Copies the related selection status from the QuerySet 'other' to the\n@@ -799,6 +837,7 @@ def _clone(self, klass=None, setup=False, **kwargs):\n             query.filter_is_sticky = True\n         c = klass(model=self.model, query=query, using=self._db)\n         c._for_write = self._for_write\n+        c._prefetch_related_lookups = self._prefetch_related_lookups[:]\n         c.__dict__.update(kwargs)\n         if setup and hasattr(c, '_setup_query'):\n             c._setup_query()\n@@ -864,6 +903,7 @@ def _as_sql(self, connection):\n     # empty\" result.\n     value_annotation = True\n \n+\n class ValuesQuerySet(QuerySet):\n     def __init__(self, *args, **kwargs):\n         super(ValuesQuerySet, self).__init__(*args, **kwargs)\n@@ -993,6 +1033,7 @@ def _prepare(self):\n                     % self.__class__.__name__)\n         return self\n \n+\n class ValuesListQuerySet(ValuesQuerySet):\n     def iterator(self):\n         if self.flat and len(self._fields) == 1:\n@@ -1502,6 +1543,7 @@ def model_fields(self):\n                 self._model_fields[converter(column)] = field\n         return self._model_fields\n \n+\n def insert_query(model, objs, fields, return_id=False, raw=False, using=None):\n     \"\"\"\n     Inserts a new record for the given model. This provides an interface to\n@@ -1511,3 +1553,140 @@ def insert_query(model, objs, fields, return_id=False, raw=False, using=None):\n     query = sql.InsertQuery(model)\n     query.insert_values(fields, objs, raw=raw)\n     return query.get_compiler(using=using).execute_sql(return_id)\n+\n+\n+def prefetch_related_objects(result_cache, related_lookups):\n+    \"\"\"\n+    Helper function for prefetch_related functionality\n+\n+    Populates prefetched objects caches for a list of results\n+    from a QuerySet\n+    \"\"\"\n+    from django.db.models.sql.constants import LOOKUP_SEP\n+\n+    if len(result_cache) == 0:\n+        return # nothing to do\n+\n+    model = result_cache[0].__class__\n+\n+    # We need to be able to dynamically add to the list of prefetch_related\n+    # lookups that we look up (see below).  So we need some book keeping to\n+    # ensure we don't do duplicate work.\n+    done_lookups = set() # list of lookups like foo__bar__baz\n+    done_queries = {}    # dictionary of things like 'foo__bar': [results]\n+    related_lookups = list(related_lookups)\n+\n+    # We may expand related_lookups, so need a loop that allows for that\n+    for lookup in related_lookups:\n+        if lookup in done_lookups:\n+            # We've done exactly this already, skip the whole thing\n+            continue\n+        done_lookups.add(lookup)\n+\n+        # Top level, the list of objects to decorate is the the result cache\n+        # from the primary QuerySet. It won't be for deeper levels.\n+        obj_list = result_cache\n+\n+        attrs = lookup.split(LOOKUP_SEP)\n+        for level, attr in enumerate(attrs):\n+            # Prepare main instances\n+            if len(obj_list) == 0:\n+                break\n+\n+            good_objects = True\n+            for obj in obj_list:\n+                if not hasattr(obj, '_prefetched_objects_cache'):\n+                    try:\n+                        obj._prefetched_objects_cache = {}\n+                    except AttributeError:\n+                        # Must be in a QuerySet subclass that is not returning\n+                        # Model instances, either in Django or 3rd\n+                        # party. prefetch_related() doesn't make sense, so quit\n+                        # now.\n+                        good_objects = False\n+                        break\n+                else:\n+                    # We already did this list\n+                    break\n+            if not good_objects:\n+                break\n+\n+            # Descend down tree\n+            try:\n+                rel_obj = getattr(obj_list[0], attr)\n+            except AttributeError:\n+                raise AttributeError(\"Cannot find '%s' on %s object, '%s' is an invalid \"\n+                                     \"parameter to prefetch_related()\" %\n+                                     (attr, obj_list[0].__class__.__name__, lookup))\n+\n+            can_prefetch = hasattr(rel_obj, 'get_prefetch_query_set')\n+            if level == len(attrs) - 1 and not can_prefetch:\n+                # Last one, this *must* resolve to a related manager.\n+                raise ValueError(\"'%s' does not resolve to a supported 'many related\"\n+                                 \" manager' for model %s - this is an invalid\"\n+                                 \" parameter to prefetch_related().\"\n+                                 % (lookup, model.__name__))\n+\n+            if can_prefetch:\n+                # Check we didn't do this already\n+                current_lookup = LOOKUP_SEP.join(attrs[0:level+1])\n+                if current_lookup in done_queries:\n+                    obj_list = done_queries[current_lookup]\n+                else:\n+                    relmanager = rel_obj\n+                    obj_list, additional_prl = prefetch_one_level(obj_list, relmanager, attr)\n+                    for f in additional_prl:\n+                        new_prl = LOOKUP_SEP.join([current_lookup, f])\n+                        related_lookups.append(new_prl)\n+                    done_queries[current_lookup] = obj_list\n+            else:\n+                # Assume we've got some singly related object. We replace\n+                # the current list of parent objects with that list.\n+                obj_list = [getattr(obj, attr) for obj in obj_list]\n+\n+                # Filter out 'None' so that we can continue with nullable\n+                # relations.\n+                obj_list = [obj for obj in obj_list if obj is not None]\n+\n+\n+def prefetch_one_level(instances, relmanager, attname):\n+    \"\"\"\n+    Helper function for prefetch_related_objects\n+\n+    Runs prefetches on all instances using the manager relmanager,\n+    assigning results to queryset against instance.attname.\n+\n+    The prefetched objects are returned, along with any additional\n+    prefetches that must be done due to prefetch_related lookups\n+    found from default managers.\n+    \"\"\"\n+    rel_qs, rel_obj_attr, instance_attr = relmanager.get_prefetch_query_set(instances)\n+    # We have to handle the possibility that the default manager itself added\n+    # prefetch_related lookups to the QuerySet we just got back. We don't want to\n+    # trigger the prefetch_related functionality by evaluating the query.\n+    # Rather, we need to merge in the prefetch_related lookups.\n+    additional_prl = getattr(rel_qs, '_prefetch_related_lookups', [])\n+    if additional_prl:\n+        # Don't need to clone because the manager should have given us a fresh\n+        # instance, so we access an internal instead of using public interface\n+        # for performance reasons.\n+        rel_qs._prefetch_related_lookups = []\n+\n+    all_related_objects = list(rel_qs)\n+\n+    rel_obj_cache = {}\n+    for rel_obj in all_related_objects:\n+        rel_attr_val = getattr(rel_obj, rel_obj_attr)\n+        if rel_attr_val not in rel_obj_cache:\n+            rel_obj_cache[rel_attr_val] = []\n+        rel_obj_cache[rel_attr_val].append(rel_obj)\n+\n+    for obj in instances:\n+        qs = getattr(obj, attname).all()\n+        instance_attr_val = getattr(obj, instance_attr)\n+        qs._result_cache = rel_obj_cache.get(instance_attr_val, [])\n+        # We don't want the individual qs doing prefetch_related now, since we\n+        # have merged this into the current work.\n+        qs._prefetch_done = True\n+        obj._prefetched_objects_cache[attname] = qs\n+    return all_related_objects, additional_prl"
        },
        {
            "sha": "ea8e0ff6e38d195213fabcd25e811ae20d90d0e5",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 101,
            "deletions": 2,
            "changes": 103,
            "blob_url": "https://github.com/django/django/blob/662eea116f5a188b6983f5f7c01c8247e3b6b309/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/662eea116f5a188b6983f5f7c01c8247e3b6b309/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=662eea116f5a188b6983f5f7c01c8247e3b6b309",
            "patch": "@@ -571,8 +571,6 @@ can be useful in situations where you might want to pass in either a model\n manager or a ``QuerySet`` and do further filtering on the result. After calling\n ``all()`` on either object, you'll definitely have a ``QuerySet`` to work with.\n \n-.. _select-related:\n-\n select_related\n ~~~~~~~~~~~~~~\n \n@@ -690,6 +688,107 @@ is defined. Instead of specifying the field name, use the :attr:`related_name\n A :class:`~django.db.models.OneToOneField` is not traversed in the reverse\n direction if you are performing a depth-based ``select_related()`` call.\n \n+prefetch_related\n+~~~~~~~~~~~~~~~~\n+\n+.. method:: prefetch_related(*lookups)\n+\n+.. versionadded:: 1.4\n+\n+Returns a ``QuerySet`` that will automatically retrieve, in a single batch,\n+related many-to-many and many-to-one objects for each of the specified lookups.\n+\n+This is similar to ``select_related`` for the 'many related objects' case, but\n+note that ``prefetch_related`` causes a separate query to be issued for each set\n+of related objects that you request, unlike ``select_related`` which modifies\n+the original query with joins in order to get the related objects. With\n+``prefetch_related``, the additional queries are done as soon as the QuerySet\n+begins to be evaluated.\n+\n+For example, suppose you have these models::\n+\n+    class Topping(models.Model):\n+        name = models.CharField(max_length=30)\n+\n+    class Pizza(models.Model):\n+        name = models.CharField(max_length=50)\n+        toppings = models.ManyToManyField(Topping)\n+\n+        def __unicode__(self):\n+            return u\"%s (%s)\" % (self.name, u\", \".join([topping.name\n+                                                        for topping in self.toppings.all()]))\n+\n+and run this code::\n+\n+    >>> Pizza.objects.all()\n+    [u\"Hawaiian (ham, pineapple)\", u\"Seafood (prawns, smoked salmon)\"...\n+\n+The problem with this code is that it will run a query on the Toppings table for\n+**every** item in the Pizza ``QuerySet``.  Using ``prefetch_related``, this can\n+be reduced to two:\n+\n+    >>> Pizza.objects.all().prefetch_related('toppings')\n+\n+All the relevant toppings will be fetched in a single query, and used to make\n+``QuerySets`` that have a pre-filled cache of the relevant results. These\n+``QuerySets`` are then used in the ``self.toppings.all()`` calls.\n+\n+Please note that use of ``prefetch_related`` will mean that the additional\n+queries run will **always** be executed - even if you never use the related\n+objects - and it always fully populates the result cache on the primary\n+``QuerySet`` (which can sometimes be avoided in other cases).\n+\n+Also remember that, as always with QuerySets, any subsequent chained methods\n+will ignore previously cached results, and retrieve data using a fresh database\n+query. So, if you write the following:\n+\n+    >>> pizzas = Pizza.objects.prefetch_related('toppings')\n+    >>> [list(pizza.toppings.filter(spicy=True)) for pizza in pizzas]\n+\n+...then the fact that `pizza.toppings.all()` has been prefetched will not help\n+you - in fact it hurts performance, since you have done a database query that\n+you haven't used. So use this feature with caution!\n+\n+The lookups that must be supplied to this method can be any attributes on the\n+model instances which represent related queries that return multiple\n+objects. This includes attributes representing the 'many' side of ``ForeignKey``\n+relationships, forward and reverse ``ManyToManyField`` attributes, and also any\n+``GenericRelations``.\n+\n+You can also use the normal join syntax to do related fields of related\n+fields. Suppose we have an additional model to the example above::\n+\n+    class Restaurant(models.Model):\n+        pizzas = models.ManyToMany(Pizza, related_name='restaurants')\n+        best_pizza = models.ForeignKey(Pizza, related_name='championed_by')\n+\n+The following are all legal:\n+\n+    >>> Restaurant.objects.prefetch_related('pizzas__toppings')\n+\n+This will prefetch all pizzas belonging to restaurants, and all toppings\n+belonging to those pizzas. This will result in a total of 3 database queries -\n+one for the restaurants, one for the pizzas, and one for the toppings.\n+\n+    >>> Restaurant.objects.select_related('best_pizza').prefetch_related('best_pizza__toppings')\n+\n+This will fetch the best pizza and all the toppings for the best pizza for each\n+restaurant. This will be done in 2 database queries - one for the restaurants\n+and 'best pizzas' combined (achieved through use of ``select_related``), and one\n+for the toppings.\n+\n+Chaining ``prefetch_related`` calls will accumulate the fields that should have\n+this behavior applied. To clear any ``prefetch_related`` behavior, pass `None`\n+as a parameter::\n+\n+   >>> non_prefetched = qs.prefetch_related(None)\n+\n+One difference when using ``prefetch_related`` is that, in some circumstances,\n+objects created by a query can be shared between the different objects that they\n+are related to i.e. a single Python model instance can appear at more than one\n+point in the tree of objects that are returned. Normally this behavior will not\n+be a problem, and will in fact save both memory and CPU time.\n+\n extra\n ~~~~~\n "
        },
        {
            "sha": "5580b67dce7c62403dacc95e1f3559bc47596f32",
            "filename": "docs/releases/1.4.txt",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/662eea116f5a188b6983f5f7c01c8247e3b6b309/docs%2Freleases%2F1.4.txt",
            "raw_url": "https://github.com/django/django/raw/662eea116f5a188b6983f5f7c01c8247e3b6b309/docs%2Freleases%2F1.4.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.4.txt?ref=662eea116f5a188b6983f5f7c01c8247e3b6b309",
            "patch": "@@ -63,6 +63,19 @@ setup for test suites) has seen a performance benefit as a result.\n See the :meth:`~django.db.models.query.QuerySet.bulk_create` docs for more\n information.\n \n+``QuerySet.prefetch_related``\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Analagous to :meth:`~django.db.models.query.QuerySet.select_related` but for\n+many-to-many relationships,\n+:meth:`~django.db.models.query.QuerySet.prefetch_related` has been added to\n+:class:`~django.db.models.query.QuerySet`. This method returns a new ``QuerySet``\n+that will prefetch in a single batch each of the specified related lookups as\n+soon as it begins to be evaluated (e.g. by iterating over it). This enables you\n+to fix many instances of a very common performance problem, in which your code\n+ends up doing O(n) database queries (or worse) if objects on your primary\n+``QuerySet`` each have many related objects that you also need.\n+\n HTML5\n ~~~~~\n "
        },
        {
            "sha": "dda7e9504a5a788875ece90b0ecf107c007fcf21",
            "filename": "docs/topics/db/optimization.txt",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/662eea116f5a188b6983f5f7c01c8247e3b6b309/docs%2Ftopics%2Fdb%2Foptimization.txt",
            "raw_url": "https://github.com/django/django/raw/662eea116f5a188b6983f5f7c01c8247e3b6b309/docs%2Ftopics%2Fdb%2Foptimization.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Foptimization.txt?ref=662eea116f5a188b6983f5f7c01c8247e3b6b309",
            "patch": "@@ -141,10 +141,12 @@ retrieving it all in one query. This is particularly important if you have a\n query that is executed in a loop, and could therefore end up doing many database\n queries, when only one was needed. So:\n \n-Use ``QuerySet.select_related()``\n----------------------------------\n+Use ``QuerySet.select_related()`` and ``prefetch_related()``\n+------------------------------------------------------------\n \n-Understand :ref:`QuerySet.select_related() <select-related>` thoroughly, and use it:\n+Understand :meth:`~django.db.models.query.QuerySet.select_related` and\n+:meth:`~django.db.models.query.QuerySet.prefetch_related` thoroughly, and use\n+them:\n \n * in view code,\n "
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/modeltests/prefetch_related/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/django/django/blob/662eea116f5a188b6983f5f7c01c8247e3b6b309/tests%2Fmodeltests%2Fprefetch_related%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/662eea116f5a188b6983f5f7c01c8247e3b6b309/tests%2Fmodeltests%2Fprefetch_related%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fprefetch_related%2F__init__.py?ref=662eea116f5a188b6983f5f7c01c8247e3b6b309"
        },
        {
            "sha": "ab28496f3709e1c4dec07c6cc155529480c38453",
            "filename": "tests/modeltests/prefetch_related/models.py",
            "status": "added",
            "additions": 165,
            "deletions": 0,
            "changes": 165,
            "blob_url": "https://github.com/django/django/blob/662eea116f5a188b6983f5f7c01c8247e3b6b309/tests%2Fmodeltests%2Fprefetch_related%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/662eea116f5a188b6983f5f7c01c8247e3b6b309/tests%2Fmodeltests%2Fprefetch_related%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fprefetch_related%2Fmodels.py?ref=662eea116f5a188b6983f5f7c01c8247e3b6b309",
            "patch": "@@ -0,0 +1,165 @@\n+from django.contrib.contenttypes.models import ContentType\n+from django.contrib.contenttypes import generic\n+from django.db import models\n+\n+## Basic tests\n+\n+class Author(models.Model):\n+    name = models.CharField(max_length=50, unique=True)\n+    first_book = models.ForeignKey('Book', related_name='first_time_authors')\n+    favorite_authors = models.ManyToManyField(\n+        'self', through='FavoriteAuthors', symmetrical=False, related_name='favors_me')\n+\n+    def __unicode__(self):\n+        return self.name\n+\n+    class Meta:\n+        ordering = ['id']\n+\n+\n+class AuthorWithAge(Author):\n+    author = models.OneToOneField(Author, parent_link=True)\n+    age = models.IntegerField()\n+\n+\n+class FavoriteAuthors(models.Model):\n+    author = models.ForeignKey(Author, to_field='name', related_name='i_like')\n+    likes_author = models.ForeignKey(Author, to_field='name', related_name='likes_me')\n+\n+    class Meta:\n+         ordering = ['id']\n+\n+\n+class AuthorAddress(models.Model):\n+    author = models.ForeignKey(Author, to_field='name', related_name='addresses')\n+    address = models.TextField()\n+\n+    class Meta:\n+        ordering = ['id']\n+\n+    def __unicode__(self):\n+        return self.address\n+\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=255)\n+    authors = models.ManyToManyField(Author, related_name='books')\n+\n+    def __unicode__(self):\n+        return self.title\n+\n+    class Meta:\n+        ordering = ['id']\n+\n+class BookWithYear(Book):\n+    book = models.OneToOneField(Book, parent_link=True)\n+    published_year = models.IntegerField()\n+    aged_authors = models.ManyToManyField(\n+        AuthorWithAge, related_name='books_with_year')\n+\n+\n+class Reader(models.Model):\n+    name = models.CharField(max_length=50)\n+    books_read = models.ManyToManyField(Book, related_name='read_by')\n+\n+    def __unicode__(self):\n+        return self.name\n+\n+    class Meta:\n+        ordering = ['id']\n+\n+\n+## Models for default manager tests\n+\n+class Qualification(models.Model):\n+    name = models.CharField(max_length=10)\n+\n+    class Meta:\n+        ordering = ['id']\n+\n+\n+class TeacherManager(models.Manager):\n+    def get_query_set(self):\n+        return super(TeacherManager, self).get_query_set().prefetch_related('qualifications')\n+\n+\n+class Teacher(models.Model):\n+    name = models.CharField(max_length=50)\n+    qualifications = models.ManyToManyField(Qualification)\n+\n+    objects = TeacherManager()\n+\n+    def __unicode__(self):\n+        return \"%s (%s)\" % (self.name, \", \".join(q.name for q in self.qualifications.all()))\n+\n+    class Meta:\n+        ordering = ['id']\n+\n+\n+class Department(models.Model):\n+    name = models.CharField(max_length=50)\n+    teachers = models.ManyToManyField(Teacher)\n+\n+    class Meta:\n+        ordering = ['id']\n+\n+\n+## Generic relation tests\n+\n+class TaggedItem(models.Model):\n+    tag = models.SlugField()\n+    content_type = models.ForeignKey(ContentType, related_name=\"taggeditem_set2\")\n+    object_id = models.PositiveIntegerField()\n+    content_object = generic.GenericForeignKey('content_type', 'object_id')\n+\n+    def __unicode__(self):\n+        return self.tag\n+\n+\n+class Bookmark(models.Model):\n+    url = models.URLField()\n+    tags = generic.GenericRelation(TaggedItem)\n+\n+\n+## Models for lookup ordering tests\n+\n+\n+class House(models.Model):\n+    address = models.CharField(max_length=255)\n+\n+    class Meta:\n+        ordering = ['id']\n+\n+class Room(models.Model):\n+    name = models.CharField(max_length=50)\n+    house = models.ForeignKey(House, related_name='rooms')\n+\n+    class Meta:\n+        ordering = ['id']\n+\n+\n+class Person(models.Model):\n+    name = models.CharField(max_length=50)\n+    houses = models.ManyToManyField(House, related_name='occupants')\n+\n+    @property\n+    def primary_house(self):\n+        # Assume business logic forces every person to have at least one house.\n+        return sorted(self.houses.all(), key=lambda house: -house.rooms.count())[0]\n+\n+    class Meta:\n+        ordering = ['id']\n+\n+\n+## Models for nullable FK tests\n+\n+class Employee(models.Model):\n+    name = models.CharField(max_length=50)\n+    boss = models.ForeignKey('self', null=True,\n+                             related_name='serfs')\n+\n+    def __unicode__(self):\n+        return self.name\n+\n+    class Meta:\n+        ordering = ['id']"
        },
        {
            "sha": "45202f2af8d92745799adf869044026f489cebc2",
            "filename": "tests/modeltests/prefetch_related/tests.py",
            "status": "added",
            "additions": 418,
            "deletions": 0,
            "changes": 418,
            "blob_url": "https://github.com/django/django/blob/662eea116f5a188b6983f5f7c01c8247e3b6b309/tests%2Fmodeltests%2Fprefetch_related%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/662eea116f5a188b6983f5f7c01c8247e3b6b309/tests%2Fmodeltests%2Fprefetch_related%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fprefetch_related%2Ftests.py?ref=662eea116f5a188b6983f5f7c01c8247e3b6b309",
            "patch": "@@ -0,0 +1,418 @@\n+from __future__ import with_statement\n+\n+from django.contrib.contenttypes.models import ContentType\n+from django.test import TestCase\n+from django.utils import unittest\n+\n+from models import (Author, Book, Reader, Qualification, Teacher, Department,\n+                    TaggedItem, Bookmark, AuthorAddress, FavoriteAuthors,\n+                    AuthorWithAge, BookWithYear, Person, House, Room,\n+                    Employee)\n+\n+\n+class PrefetchRelatedTests(TestCase):\n+\n+    def setUp(self):\n+\n+        self.book1 = Book.objects.create(title=\"Poems\")\n+        self.book2 = Book.objects.create(title=\"Jane Eyre\")\n+        self.book3 = Book.objects.create(title=\"Wuthering Heights\")\n+        self.book4 = Book.objects.create(title=\"Sense and Sensibility\")\n+\n+        self.author1 = Author.objects.create(name=\"Charlotte\",\n+                                             first_book=self.book1)\n+        self.author2 = Author.objects.create(name=\"Anne\",\n+                                             first_book=self.book1)\n+        self.author3 = Author.objects.create(name=\"Emily\",\n+                                             first_book=self.book1)\n+        self.author4 = Author.objects.create(name=\"Jane\",\n+                                             first_book=self.book4)\n+\n+        self.book1.authors.add(self.author1, self.author2, self.author3)\n+        self.book2.authors.add(self.author1)\n+        self.book3.authors.add(self.author3)\n+        self.book4.authors.add(self.author4)\n+\n+        self.reader1 = Reader.objects.create(name=\"Amy\")\n+        self.reader2 = Reader.objects.create(name=\"Belinda\")\n+\n+        self.reader1.books_read.add(self.book1, self.book4)\n+        self.reader2.books_read.add(self.book2, self.book4)\n+\n+    def test_m2m_forward(self):\n+        with self.assertNumQueries(2):\n+            lists = [list(b.authors.all()) for b in Book.objects.prefetch_related('authors')]\n+\n+        normal_lists = [list(b.authors.all()) for b in Book.objects.all()]\n+        self.assertEqual(lists, normal_lists)\n+\n+\n+    def test_m2m_reverse(self):\n+        with self.assertNumQueries(2):\n+            lists = [list(a.books.all()) for a in Author.objects.prefetch_related('books')]\n+\n+        normal_lists = [list(a.books.all()) for a in Author.objects.all()]\n+        self.assertEqual(lists, normal_lists)\n+\n+    def test_foreignkey_reverse(self):\n+        with self.assertNumQueries(2):\n+            lists = [list(b.first_time_authors.all())\n+                     for b in Book.objects.prefetch_related('first_time_authors')]\n+\n+        self.assertQuerysetEqual(self.book2.authors.all(), [u\"<Author: Charlotte>\"])\n+\n+    def test_survives_clone(self):\n+        with self.assertNumQueries(2):\n+            lists = [list(b.first_time_authors.all())\n+                     for b in Book.objects.prefetch_related('first_time_authors').exclude(id=1000)]\n+\n+    def test_len(self):\n+        with self.assertNumQueries(2):\n+            qs = Book.objects.prefetch_related('first_time_authors')\n+            length = len(qs)\n+            lists = [list(b.first_time_authors.all())\n+                     for b in qs]\n+\n+    def test_bool(self):\n+        with self.assertNumQueries(2):\n+            qs = Book.objects.prefetch_related('first_time_authors')\n+            x = bool(qs)\n+            lists = [list(b.first_time_authors.all())\n+                     for b in qs]\n+\n+    def test_count(self):\n+        with self.assertNumQueries(2):\n+            qs = Book.objects.prefetch_related('first_time_authors')\n+            [b.first_time_authors.count() for b in qs]\n+\n+    def test_exists(self):\n+        with self.assertNumQueries(2):\n+            qs = Book.objects.prefetch_related('first_time_authors')\n+            [b.first_time_authors.exists() for b in qs]\n+\n+    def test_clear(self):\n+        \"\"\"\n+        Test that we can clear the behavior by calling prefetch_related()\n+        \"\"\"\n+        with self.assertNumQueries(5):\n+            with_prefetch = Author.objects.prefetch_related('books')\n+            without_prefetch = with_prefetch.prefetch_related(None)\n+            lists = [list(a.books.all()) for a in without_prefetch]\n+\n+    def test_m2m_then_m2m(self):\n+        \"\"\"\n+        Test we can follow a m2m and another m2m\n+        \"\"\"\n+        with self.assertNumQueries(3):\n+            qs = Author.objects.prefetch_related('books__read_by')\n+            lists = [[[unicode(r) for r in b.read_by.all()]\n+                      for b in a.books.all()]\n+                     for a in qs]\n+            self.assertEqual(lists,\n+            [\n+                [[u\"Amy\"], [u\"Belinda\"]],  # Charlotte - Poems, Jane Eyre\n+                [[u\"Amy\"]],                # Anne - Poems\n+                [[u\"Amy\"], []],            # Emily - Poems, Wuthering Heights\n+                [[u\"Amy\", u\"Belinda\"]],    # Jane - Sense and Sense\n+            ])\n+\n+    def test_overriding_prefetch(self):\n+        with self.assertNumQueries(3):\n+            qs = Author.objects.prefetch_related('books', 'books__read_by')\n+            lists = [[[unicode(r) for r in b.read_by.all()]\n+                      for b in a.books.all()]\n+                     for a in qs]\n+            self.assertEqual(lists,\n+            [\n+                [[u\"Amy\"], [u\"Belinda\"]],  # Charlotte - Poems, Jane Eyre\n+                [[u\"Amy\"]],                # Anne - Poems\n+                [[u\"Amy\"], []],            # Emily - Poems, Wuthering Heights\n+                [[u\"Amy\", u\"Belinda\"]],    # Jane - Sense and Sense\n+            ])\n+        with self.assertNumQueries(3):\n+            qs = Author.objects.prefetch_related('books__read_by', 'books')\n+            lists = [[[unicode(r) for r in b.read_by.all()]\n+                      for b in a.books.all()]\n+                     for a in qs]\n+            self.assertEqual(lists,\n+            [\n+                [[u\"Amy\"], [u\"Belinda\"]],  # Charlotte - Poems, Jane Eyre\n+                [[u\"Amy\"]],                # Anne - Poems\n+                [[u\"Amy\"], []],            # Emily - Poems, Wuthering Heights\n+                [[u\"Amy\", u\"Belinda\"]],    # Jane - Sense and Sense\n+            ])\n+\n+    def test_get(self):\n+        \"\"\"\n+        Test that objects retrieved with .get() get the prefetch behaviour\n+        \"\"\"\n+        # Need a double\n+        with self.assertNumQueries(3):\n+            author = Author.objects.prefetch_related('books__read_by').get(name=\"Charlotte\")\n+            lists = [[unicode(r) for r in b.read_by.all()]\n+                      for b in author.books.all()]\n+            self.assertEqual(lists, [[u\"Amy\"], [u\"Belinda\"]])  # Poems, Jane Eyre\n+\n+    def test_foreign_key_then_m2m(self):\n+        \"\"\"\n+        Test we can follow an m2m relation after a relation like ForeignKey\n+        that doesn't have many objects\n+        \"\"\"\n+        with self.assertNumQueries(2):\n+            qs = Author.objects.select_related('first_book').prefetch_related('first_book__read_by')\n+            lists = [[unicode(r) for r in a.first_book.read_by.all()]\n+                     for a in qs]\n+            self.assertEqual(lists, [[u\"Amy\"],\n+                                     [u\"Amy\"],\n+                                     [u\"Amy\"],\n+                                     [u\"Amy\", \"Belinda\"]])\n+\n+    def test_attribute_error(self):\n+        qs = Reader.objects.all().prefetch_related('books_read__xyz')\n+        with self.assertRaises(AttributeError) as cm:\n+            list(qs)\n+\n+        self.assertTrue('prefetch_related' in str(cm.exception))\n+\n+    def test_invalid_final_lookup(self):\n+        qs = Book.objects.prefetch_related('authors__first_book')\n+        with self.assertRaises(ValueError) as cm:\n+            list(qs)\n+\n+        self.assertTrue('prefetch_related' in str(cm.exception))\n+        self.assertTrue(\"first_book\" in str(cm.exception))\n+\n+\n+class DefaultManagerTests(TestCase):\n+\n+    def setUp(self):\n+        self.qual1 = Qualification.objects.create(name=\"BA\")\n+        self.qual2 = Qualification.objects.create(name=\"BSci\")\n+        self.qual3 = Qualification.objects.create(name=\"MA\")\n+        self.qual4 = Qualification.objects.create(name=\"PhD\")\n+\n+        self.teacher1 = Teacher.objects.create(name=\"Mr Cleese\")\n+        self.teacher2 = Teacher.objects.create(name=\"Mr Idle\")\n+        self.teacher3 = Teacher.objects.create(name=\"Mr Chapman\")\n+\n+        self.teacher1.qualifications.add(self.qual1, self.qual2, self.qual3, self.qual4)\n+        self.teacher2.qualifications.add(self.qual1)\n+        self.teacher3.qualifications.add(self.qual2)\n+\n+        self.dept1 = Department.objects.create(name=\"English\")\n+        self.dept2 = Department.objects.create(name=\"Physics\")\n+\n+        self.dept1.teachers.add(self.teacher1, self.teacher2)\n+        self.dept2.teachers.add(self.teacher1, self.teacher3)\n+\n+    def test_m2m_then_m2m(self):\n+        with self.assertNumQueries(3):\n+            # When we prefetch the teachers, and force the query, we don't want\n+            # the default manager on teachers to immediately get all the related\n+            # qualifications, since this will do one query per teacher.\n+            qs = Department.objects.prefetch_related('teachers')\n+            depts = \"\".join([\"%s department: %s\\n\" %\n+                             (dept.name, \", \".join(unicode(t) for t in dept.teachers.all()))\n+                             for dept in qs])\n+\n+            self.assertEqual(depts,\n+                             \"English department: Mr Cleese (BA, BSci, MA, PhD), Mr Idle (BA)\\n\"\n+                             \"Physics department: Mr Cleese (BA, BSci, MA, PhD), Mr Chapman (BSci)\\n\")\n+\n+\n+class GenericRelationTests(TestCase):\n+\n+    def test_traverse_GFK(self):\n+        \"\"\"\n+        Test that we can traverse a 'content_object' with prefetch_related()\n+        \"\"\"\n+        # In fact, there is no special support for this in prefetch_related code\n+        # - we can traverse any object that will lead us to objects that have\n+        # related managers.\n+\n+        book1 = Book.objects.create(title=\"Winnie the Pooh\")\n+        book2 = Book.objects.create(title=\"Do you like green eggs and spam?\")\n+\n+        reader1 = Reader.objects.create(name=\"me\")\n+        reader2 = Reader.objects.create(name=\"you\")\n+\n+        book1.read_by.add(reader1)\n+        book2.read_by.add(reader2)\n+\n+        TaggedItem.objects.create(tag=\"awesome\", content_object=book1)\n+        TaggedItem.objects.create(tag=\"awesome\", content_object=book2)\n+\n+        ct = ContentType.objects.get_for_model(Book)\n+\n+        # We get 4 queries - 1 for main query, 2 for each access to\n+        # 'content_object' because these can't be handled by select_related, and\n+        # 1 for the 'read_by' relation.\n+        with self.assertNumQueries(4):\n+            # If we limit to books, we know that they will have 'read_by'\n+            # attributes, so the following makes sense:\n+            qs = TaggedItem.objects.select_related('content_type').prefetch_related('content_object__read_by').filter(tag='awesome').filter(content_type=ct, tag='awesome')\n+            readers_of_awesome_books = [r.name for tag in qs\n+                                        for r in tag.content_object.read_by.all()]\n+            self.assertEqual(readers_of_awesome_books, [\"me\", \"you\"])\n+\n+\n+    def test_generic_relation(self):\n+        b = Bookmark.objects.create(url='http://www.djangoproject.com/')\n+        t1 = TaggedItem.objects.create(content_object=b, tag='django')\n+        t2 = TaggedItem.objects.create(content_object=b, tag='python')\n+\n+        with self.assertNumQueries(2):\n+            tags = [t.tag for b in Bookmark.objects.prefetch_related('tags')\n+                    for t in b.tags.all()]\n+            self.assertEqual(sorted(tags), [\"django\", \"python\"])\n+\n+\n+class MultiTableInheritanceTest(TestCase):\n+\n+    def setUp(self):\n+        self.book1 = BookWithYear.objects.create(\n+            title=\"Poems\", published_year=2010)\n+        self.book2 = BookWithYear.objects.create(\n+            title=\"More poems\", published_year=2011)\n+        self.author1 = AuthorWithAge.objects.create(\n+            name='Jane', first_book=self.book1, age=50)\n+        self.author2 = AuthorWithAge.objects.create(\n+            name='Tom', first_book=self.book1, age=49)\n+        self.author3 = AuthorWithAge.objects.create(\n+            name='Robert', first_book=self.book2, age=48)\n+        self.authorAddress = AuthorAddress.objects.create(\n+            author=self.author1, address='SomeStreet 1')\n+        self.book2.aged_authors.add(self.author2, self.author3)\n+\n+    def test_foreignkey(self):\n+        with self.assertNumQueries(2):\n+            qs = AuthorWithAge.objects.prefetch_related('addresses')\n+            addresses = [[unicode(address) for address in obj.addresses.all()]\n+                         for obj in qs]\n+        self.assertEquals(addresses, [[unicode(self.authorAddress)], [], []])\n+\n+    def test_m2m_to_inheriting_model(self):\n+        qs = AuthorWithAge.objects.prefetch_related('books_with_year')\n+        with self.assertNumQueries(2):\n+            lst = [[unicode(book) for book in author.books_with_year.all()]\n+                   for author in qs]\n+        qs = AuthorWithAge.objects.all()\n+        lst2 = [[unicode(book) for book in author.books_with_year.all()]\n+                for author in qs]\n+        self.assertEquals(lst, lst2)\n+\n+        qs = BookWithYear.objects.prefetch_related('aged_authors')\n+        with self.assertNumQueries(2):\n+            lst = [[unicode(author) for author in book.aged_authors.all()]\n+                   for book in qs]\n+        qs = BookWithYear.objects.all()\n+        lst2 = [[unicode(author) for author in book.aged_authors.all()]\n+               for book in qs]\n+        self.assertEquals(lst, lst2)\n+\n+    def test_parent_link_prefetch(self):\n+        with self.assertRaises(ValueError) as cm:\n+            qs = list(AuthorWithAge.objects.prefetch_related('author'))\n+        self.assertTrue('prefetch_related' in str(cm.exception))\n+\n+\n+class ForeignKeyToFieldTest(TestCase):\n+\n+    def setUp(self):\n+        self.book = Book.objects.create(title=\"Poems\")\n+        self.author1 = Author.objects.create(name='Jane', first_book=self.book)\n+        self.author2 = Author.objects.create(name='Tom', first_book=self.book)\n+        self.author3 = Author.objects.create(name='Robert', first_book=self.book)\n+        self.authorAddress = AuthorAddress.objects.create(\n+            author=self.author1, address='SomeStreet 1'\n+        )\n+        FavoriteAuthors.objects.create(author=self.author1,\n+                                       likes_author=self.author2)\n+        FavoriteAuthors.objects.create(author=self.author2,\n+                                       likes_author=self.author3)\n+        FavoriteAuthors.objects.create(author=self.author3,\n+                                       likes_author=self.author1)\n+\n+    def test_foreignkey(self):\n+        with self.assertNumQueries(2):\n+            qs = Author.objects.prefetch_related('addresses')\n+            addresses = [[unicode(address) for address in obj.addresses.all()]\n+                         for obj in qs]\n+        self.assertEquals(addresses, [[unicode(self.authorAddress)], [], []])\n+\n+    def test_m2m(self):\n+        with self.assertNumQueries(3):\n+            qs = Author.objects.all().prefetch_related('favorite_authors', 'favors_me')\n+            favorites = [(\n+                 [unicode(i_like) for i_like in author.favorite_authors.all()],\n+                 [unicode(likes_me) for likes_me in author.favors_me.all()]\n+                ) for author in qs]\n+            self.assertEquals(\n+                favorites,\n+                [\n+                    ([unicode(self.author2)],[unicode(self.author3)]),\n+                    ([unicode(self.author3)],[unicode(self.author1)]),\n+                    ([unicode(self.author1)],[unicode(self.author2)])\n+                ]\n+            )\n+\n+\n+class LookupOrderingTest(TestCase):\n+    \"\"\"\n+    Test cases that demonstrate that ordering of lookups is important, and\n+    ensure it is preserved.\n+    \"\"\"\n+\n+    def setUp(self):\n+        self.person1 = Person.objects.create(name=\"Joe\")\n+        self.person2 = Person.objects.create(name=\"Mary\")\n+\n+        self.house1 = House.objects.create(address=\"123 Main St\")\n+        self.house2 = House.objects.create(address=\"45 Side St\")\n+        self.house3 = House.objects.create(address=\"6 Downing St\")\n+        self.house4 = House.objects.create(address=\"7 Regents St\")\n+\n+        self.room1_1 = Room.objects.create(name=\"Dining room\", house=self.house1)\n+        self.room1_2 = Room.objects.create(name=\"Lounge\", house=self.house1)\n+        self.room1_3 = Room.objects.create(name=\"Kitchen\", house=self.house1)\n+\n+        self.room2_1 = Room.objects.create(name=\"Dining room\", house=self.house2)\n+        self.room2_2 = Room.objects.create(name=\"Lounge\", house=self.house2)\n+\n+        self.room3_1 = Room.objects.create(name=\"Dining room\", house=self.house3)\n+        self.room3_2 = Room.objects.create(name=\"Lounge\", house=self.house3)\n+        self.room3_3 = Room.objects.create(name=\"Kitchen\", house=self.house3)\n+\n+        self.room4_1 = Room.objects.create(name=\"Dining room\", house=self.house4)\n+        self.room4_2 = Room.objects.create(name=\"Lounge\", house=self.house4)\n+\n+        self.person1.houses.add(self.house1, self.house2)\n+        self.person2.houses.add(self.house3, self.house4)\n+\n+    def test_order(self):\n+        with self.assertNumQueries(4):\n+            # The following two queries must be done in the same order as written,\n+            # otherwise 'primary_house' will cause non-prefetched lookups\n+            qs = Person.objects.prefetch_related('houses__rooms',\n+                                                 'primary_house__occupants')\n+            [list(p.primary_house.occupants.all()) for p in qs]\n+\n+\n+class NullableTest(TestCase):\n+\n+    def setUp(self):\n+        boss = Employee.objects.create(name=\"Peter\")\n+        worker1 = Employee.objects.create(name=\"Joe\", boss=boss)\n+        worker2 = Employee.objects.create(name=\"Angela\", boss=boss)\n+\n+    def test_traverse_nullable(self):\n+        with self.assertNumQueries(2):\n+            qs = Employee.objects.select_related('boss').prefetch_related('boss__serfs')\n+            co_serfs = [list(e.boss.serfs.all()) if e.boss is not None else []\n+                        for e in qs]\n+\n+        qs2 =  Employee.objects.select_related('boss')\n+        co_serfs2 =  [list(e.boss.serfs.all()) if e.boss is not None else []\n+                        for e in qs2]\n+\n+        self.assertEqual(co_serfs, co_serfs2)"
        }
    ],
    "stats": {
        "total": 992,
        "additions": 968,
        "deletions": 24
    }
}