{
    "author": "jezdez",
    "message": "Fixed #811 -- Added support for IPv6 to forms and model fields. Many thanks to Erik Romijn.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16366 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "ce3c281090320172d22e8a6057250d103c93438e",
    "files": [
        {
            "sha": "458f4195e0a93f98e2fa7907c1e45d306e204785",
            "filename": "django/core/validators.py",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/django%2Fcore%2Fvalidators.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/django%2Fcore%2Fvalidators.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fvalidators.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -5,6 +5,7 @@\n from django.core.exceptions import ValidationError\n from django.utils.translation import ugettext_lazy as _\n from django.utils.encoding import smart_unicode\n+from django.utils.ipv6 import is_valid_ipv6_address\n \n # These values, if given to validate(), will trigger the self.required check.\n EMPTY_VALUES = (None, '', [], (), {})\n@@ -145,6 +146,41 @@ def __call__(self, value):\n ipv4_re = re.compile(r'^(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}$')\n validate_ipv4_address = RegexValidator(ipv4_re, _(u'Enter a valid IPv4 address.'), 'invalid')\n \n+def validate_ipv6_address(value):\n+    if not is_valid_ipv6_address(value):\n+        raise ValidationError(_(u'Enter a valid IPv6 address.'), code='invalid')\n+\n+def validate_ipv46_address(value):\n+    try:\n+        validate_ipv4_address(value)\n+    except ValidationError:\n+        try:\n+            validate_ipv6_address(value)\n+        except ValidationError:\n+            raise ValidationError(_(u'Enter a valid IPv4 or IPv6 address.'), code='invalid')\n+\n+ip_address_validator_map = {\n+    'both': ([validate_ipv46_address], _('Enter a valid IPv4 or IPv6 address.')),\n+    'ipv4': ([validate_ipv4_address], _('Enter a valid IPv4 address.')),\n+    'ipv6': ([validate_ipv6_address], _('Enter a valid IPv6 address.')),\n+}\n+\n+def ip_address_validators(protocol, unpack_ipv4):\n+    \"\"\"\n+    Depending on the given parameters returns the appropriate validators for\n+    the GenericIPAddressField.\n+\n+    This code is here, because it is exactly the same for the model and the form field.\n+    \"\"\"\n+    if protocol != 'both' and unpack_ipv4:\n+        raise ValueError(\n+            \"You can only use `unpack_ipv4` if `protocol` is set to 'both'\")\n+    try:\n+        return ip_address_validator_map[protocol.lower()]\n+    except KeyError:\n+        raise ValueError(\"The protocol '%s' is unknown. Supported: %s\"\n+                         % (protocol, ip_address_validator_map.keys()))\n+\n comma_separated_int_list_re = re.compile('^[\\d,]+$')\n validate_comma_separated_integer_list = RegexValidator(comma_separated_int_list_re, _(u'Enter only digits separated by commas.'), 'invalid')\n "
        },
        {
            "sha": "53bd57effc1d454763e6afd1b9f1f2dc7fbc3ce3",
            "filename": "django/db/backends/mysql/creation.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/django%2Fdb%2Fbackends%2Fmysql%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/django%2Fdb%2Fbackends%2Fmysql%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fcreation.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -19,6 +19,7 @@ class DatabaseCreation(BaseDatabaseCreation):\n         'IntegerField':      'integer',\n         'BigIntegerField':   'bigint',\n         'IPAddressField':    'char(15)',\n+        'GenericIPAddressField': 'char(39)',\n         'NullBooleanField':  'bool',\n         'OneToOneField':     'integer',\n         'PositiveIntegerField': 'integer UNSIGNED',"
        },
        {
            "sha": "0403e0a145af7183905210840e2893256b5632c7",
            "filename": "django/db/backends/oracle/creation.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/django%2Fdb%2Fbackends%2Foracle%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/django%2Fdb%2Fbackends%2Foracle%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Foracle%2Fcreation.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -27,6 +27,7 @@ class DatabaseCreation(BaseDatabaseCreation):\n         'IntegerField':                 'NUMBER(11)',\n         'BigIntegerField':              'NUMBER(19)',\n         'IPAddressField':               'VARCHAR2(15)',\n+        'GenericIPAddressField':        'VARCHAR2(39)',\n         'NullBooleanField':             'NUMBER(1) CHECK ((%(qn_column)s IN (0,1)) OR (%(qn_column)s IS NULL))',\n         'OneToOneField':                'NUMBER(11)',\n         'PositiveIntegerField':         'NUMBER(11) CHECK (%(qn_column)s >= 0)',"
        },
        {
            "sha": "bdd817db4c9b22dfd585374de262f3b067646819",
            "filename": "django/db/backends/postgresql_psycopg2/creation.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fcreation.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -21,6 +21,7 @@ class DatabaseCreation(BaseDatabaseCreation):\n         'IntegerField':      'integer',\n         'BigIntegerField':   'bigint',\n         'IPAddressField':    'inet',\n+        'GenericIPAddressField': 'inet',\n         'NullBooleanField':  'boolean',\n         'OneToOneField':     'integer',\n         'PositiveIntegerField': 'integer CHECK (\"%(column)s\" >= 0)',"
        },
        {
            "sha": "b1dac3f8ca4e5dec2218754a67e6472bf19c1632",
            "filename": "django/db/backends/postgresql_psycopg2/introspection.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fintrospection.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fintrospection.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fintrospection.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -12,6 +12,7 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n         700: 'FloatField',\n         701: 'FloatField',\n         869: 'IPAddressField',\n+        869: 'GenericIPAddressField',\n         1043: 'CharField',\n         1082: 'DateField',\n         1083: 'TimeField',"
        },
        {
            "sha": "f6fe6a453413e3b7f08ba8479a9250737cb216ff",
            "filename": "django/db/backends/sqlite3/creation.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/django%2Fdb%2Fbackends%2Fsqlite3%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/django%2Fdb%2Fbackends%2Fsqlite3%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fcreation.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -20,6 +20,7 @@ class DatabaseCreation(BaseDatabaseCreation):\n         'IntegerField':                 'integer',\n         'BigIntegerField':              'bigint',\n         'IPAddressField':               'char(15)',\n+        'GenericIPAddressField':        'char(39)',\n         'NullBooleanField':             'bool',\n         'OneToOneField':                'integer',\n         'PositiveIntegerField':         'integer unsigned',"
        },
        {
            "sha": "4707cb4a4cf0234f35d81b60ec393c055f055bbb",
            "filename": "django/db/models/fields/__init__.py",
            "status": "modified",
            "additions": 37,
            "deletions": 1,
            "changes": 38,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/django%2Fdb%2Fmodels%2Ffields%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/django%2Fdb%2Fmodels%2Ffields%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2F__init__.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -17,6 +17,7 @@\n from django.utils.translation import ugettext_lazy as _\n from django.utils.encoding import smart_unicode, force_unicode, smart_str\n from django.utils import datetime_safe\n+from django.utils.ipv6 import clean_ipv6_address, is_valid_ipv6_address\n \n class NOT_PROVIDED:\n     pass\n@@ -920,7 +921,7 @@ def formfield(self, **kwargs):\n \n class IPAddressField(Field):\n     empty_strings_allowed = False\n-    description = _(\"IP address\")\n+    description = _(\"IPv4 address\")\n     def __init__(self, *args, **kwargs):\n         kwargs['max_length'] = 15\n         Field.__init__(self, *args, **kwargs)\n@@ -933,6 +934,41 @@ def formfield(self, **kwargs):\n         defaults.update(kwargs)\n         return super(IPAddressField, self).formfield(**defaults)\n \n+class GenericIPAddressField(Field):\n+    empty_strings_allowed = True\n+    description = _(\"IP address\")\n+\n+    def __init__(self, protocol='both', unpack_ipv4=False, *args, **kwargs):\n+        self.unpack_ipv4 = unpack_ipv4\n+        self.default_validators, invalid_error_message = \\\n+            validators.ip_address_validators(protocol, unpack_ipv4)\n+        self.default_error_messages['invalid'] = invalid_error_message\n+        kwargs['max_length'] = 39\n+        Field.__init__(self, *args, **kwargs)\n+\n+    def get_internal_type(self):\n+        return \"GenericIPAddressField\"\n+\n+    def to_python(self, value):\n+        if value and ':' in value:\n+            return clean_ipv6_address(value,\n+                self.unpack_ipv4, self.error_messages['invalid'])\n+        return value\n+\n+    def get_prep_value(self, value):\n+        if value and ':' in value:\n+            try:\n+                return clean_ipv6_address(value, self.unpack_ipv4)\n+            except ValidationError:\n+                pass\n+        return value\n+\n+    def formfield(self, **kwargs):\n+        defaults = {'form_class': forms.GenericIPAddressField}\n+        defaults.update(kwargs)\n+        return super(GenericIPAddressField, self).formfield(**defaults)\n+\n+\n class NullBooleanField(Field):\n     empty_strings_allowed = False\n     default_error_messages = {"
        },
        {
            "sha": "d7b1bbe5db7414df1c0eb14c36e52d4cc753abbd",
            "filename": "django/forms/fields.py",
            "status": "modified",
            "additions": 22,
            "deletions": 2,
            "changes": 24,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/django%2Fforms%2Ffields.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/django%2Fforms%2Ffields.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fforms%2Ffields.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -18,6 +18,7 @@\n from django.utils import formats\n from django.utils.translation import ugettext_lazy as _\n from django.utils.encoding import smart_unicode, smart_str, force_unicode\n+from django.utils.ipv6 import clean_ipv6_address\n \n # Provide this import for backwards compatibility.\n from django.core.validators import EMPTY_VALUES\n@@ -34,8 +35,8 @@\n     'RegexField', 'EmailField', 'FileField', 'ImageField', 'URLField',\n     'BooleanField', 'NullBooleanField', 'ChoiceField', 'MultipleChoiceField',\n     'ComboField', 'MultiValueField', 'FloatField', 'DecimalField',\n-    'SplitDateTimeField', 'IPAddressField', 'FilePathField', 'SlugField',\n-    'TypedChoiceField', 'TypedMultipleChoiceField'\n+    'SplitDateTimeField', 'IPAddressField', 'GenericIPAddressField', 'FilePathField',\n+    'SlugField', 'TypedChoiceField', 'TypedMultipleChoiceField'\n )\n \n \n@@ -953,6 +954,25 @@ class IPAddressField(CharField):\n     default_validators = [validators.validate_ipv4_address]\n \n \n+class GenericIPAddressField(CharField):\n+    default_error_messages = {}\n+\n+    def __init__(self, protocol='both', unpack_ipv4=False, *args, **kwargs):\n+        self.unpack_ipv4 = unpack_ipv4\n+        self.default_validators, invalid_error_message = \\\n+            validators.ip_address_validators(protocol, unpack_ipv4)\n+        self.default_error_messages['invalid'] = invalid_error_message\n+        super(GenericIPAddressField, self).__init__(*args, **kwargs)\n+\n+    def to_python(self, value):\n+        if not value:\n+            return ''\n+        if value and ':' in value:\n+                return clean_ipv6_address(value,\n+                    self.unpack_ipv4, self.error_messages['invalid'])\n+        return value\n+\n+\n class SlugField(CharField):\n     default_error_messages = {\n         'invalid': _(u\"Enter a valid 'slug' consisting of letters, numbers,\""
        },
        {
            "sha": "e80a0e205f91a9d4e08bd148dbff4adda2e90d77",
            "filename": "django/utils/ipv6.py",
            "status": "added",
            "additions": 267,
            "deletions": 0,
            "changes": 267,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/django%2Futils%2Fipv6.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/django%2Futils%2Fipv6.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fipv6.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -0,0 +1,267 @@\n+# This code was mostly based on ipaddr-py\n+# Copyright 2007 Google Inc. http://code.google.com/p/ipaddr-py/\n+# Licensed under the Apache License, Version 2.0 (the \"License\").\n+from django.core.exceptions import ValidationError\n+\n+def clean_ipv6_address(ip_str, unpack_ipv4=False,\n+        error_message=\"This is not a valid IPv6 address\"):\n+    \"\"\"\n+    Cleans a IPv6 address string.\n+\n+    Validity is checked by calling is_valid_ipv6_address() - if an\n+    invalid address is passed, ValidationError is raised.\n+\n+    Replaces the longest continious zero-sequence with \"::\" and\n+    removes leading zeroes and makes sure all hextets are lowercase.\n+\n+    Args:\n+        ip_str: A valid IPv6 address.\n+        unpack_ipv4: if an IPv4-mapped address is found,\n+        return the plain IPv4 address (default=False).\n+        error_message: A error message for in the ValidationError.\n+\n+    Returns:\n+        A compressed IPv6 address, or the same value\n+\n+    \"\"\"\n+    best_doublecolon_start = -1\n+    best_doublecolon_len = 0\n+    doublecolon_start = -1\n+    doublecolon_len = 0\n+\n+    if not is_valid_ipv6_address(ip_str):\n+        raise ValidationError(error_message)\n+\n+    # This algorithm can only handle fully exploded\n+    # IP strings\n+    ip_str = _explode_shorthand_ip_string(ip_str)\n+\n+    ip_str = _sanitize_ipv4_mapping(ip_str)\n+\n+    # If needed, unpack the IPv4 and return straight away\n+    # - no need in running the rest of the algorithm\n+    if unpack_ipv4:\n+        ipv4_unpacked = _unpack_ipv4(ip_str)\n+\n+        if ipv4_unpacked:\n+            return ipv4_unpacked\n+\n+    hextets = ip_str.split(\":\")\n+\n+    for index in range(len(hextets)):\n+        # Remove leading zeroes\n+        hextets[index] = hextets[index].lstrip('0')\n+        if not hextets[index]:\n+            hextets[index] = '0'\n+\n+        # Determine best hextet to compress\n+        if hextets[index] == '0':\n+            doublecolon_len += 1\n+            if doublecolon_start == -1:\n+                # Start of a sequence of zeros.\n+                doublecolon_start = index\n+            if doublecolon_len > best_doublecolon_len:\n+                # This is the longest sequence of zeros so far.\n+                best_doublecolon_len = doublecolon_len\n+                best_doublecolon_start = doublecolon_start\n+        else:\n+            doublecolon_len = 0\n+            doublecolon_start = -1\n+\n+    # Compress the most suitable hextet\n+    if best_doublecolon_len > 1:\n+        best_doublecolon_end = (best_doublecolon_start +\n+                                best_doublecolon_len)\n+        # For zeros at the end of the address.\n+        if best_doublecolon_end == len(hextets):\n+            hextets += ['']\n+        hextets[best_doublecolon_start:best_doublecolon_end] = ['']\n+        # For zeros at the beginning of the address.\n+        if best_doublecolon_start == 0:\n+            hextets = [''] + hextets\n+\n+    result = \":\".join(hextets)\n+\n+    return result.lower()\n+\n+\n+def _sanitize_ipv4_mapping(ip_str):\n+    \"\"\"\n+    Sanitize IPv4 mapping in a expanded IPv6 address.\n+\n+    This converts ::ffff:0a0a:0a0a to ::ffff:10.10.10.10.\n+    If there is nothing to sanitize, returns an unchanged\n+    string.\n+\n+    Args:\n+        ip_str: A string, the expanded IPv6 address.\n+\n+    Returns:\n+        The sanitized output string, if applicable.\n+    \"\"\"\n+    if not ip_str.lower().startswith('0000:0000:0000:0000:0000:ffff:'):\n+        # not an ipv4 mapping\n+        return ip_str\n+\n+    hextets = ip_str.split(':')\n+\n+    if '.' in hextets[-1]:\n+        # already sanitized\n+        return ip_str\n+\n+    ipv4_address = \"%d.%d.%d.%d\" % (\n+        int(hextets[6][0:2], 16),\n+        int(hextets[6][2:4], 16),\n+        int(hextets[7][0:2], 16),\n+        int(hextets[7][2:4], 16),\n+    )\n+\n+    result = ':'.join(hextets[0:6])\n+    result += ':' + ipv4_address\n+\n+    return result\n+\n+def _unpack_ipv4(ip_str):\n+    \"\"\"\n+    Unpack an IPv4 address that was mapped in a compressed IPv6 address.\n+\n+    This converts 0000:0000:0000:0000:0000:ffff:10.10.10.10 to 10.10.10.10.\n+    If there is nothing to sanitize, returns None.\n+\n+    Args:\n+        ip_str: A string, the expanded IPv6 address.\n+\n+    Returns:\n+        The unpacked IPv4 address, or None if there was nothing to unpack.\n+    \"\"\"\n+    if not ip_str.lower().startswith('0000:0000:0000:0000:0000:ffff:'):\n+        return None\n+\n+    hextets = ip_str.split(':')\n+    return hextets[-1]\n+\n+def is_valid_ipv6_address(ip_str):\n+    \"\"\"\n+    Ensure we have a valid IPv6 address.\n+\n+    Args:\n+        ip_str: A string, the IPv6 address.\n+\n+    Returns:\n+        A boolean, True if this is a valid IPv6 address.\n+\n+    \"\"\"\n+    from django.core.validators import validate_ipv4_address\n+\n+    # We need to have at least one ':'.\n+    if ':' not in ip_str:\n+        return False\n+\n+    # We can only have one '::' shortener.\n+    if ip_str.count('::') > 1:\n+        return False\n+\n+    # '::' should be encompassed by start, digits or end.\n+    if ':::' in ip_str:\n+        return False\n+\n+    # A single colon can neither start nor end an address.\n+    if ((ip_str.startswith(':') and not ip_str.startswith('::')) or\n+            (ip_str.endswith(':') and not ip_str.endswith('::'))):\n+        return False\n+\n+    # We can never have more than 7 ':' (1::2:3:4:5:6:7:8 is invalid)\n+    if ip_str.count(':') > 7:\n+        return False\n+\n+    # If we have no concatenation, we need to have 8 fields with 7 ':'.\n+    if '::' not in ip_str and ip_str.count(':') != 7:\n+        # We might have an IPv4 mapped address.\n+        if ip_str.count('.') != 3:\n+            return False\n+\n+    ip_str = _explode_shorthand_ip_string(ip_str)\n+\n+    # Now that we have that all squared away, let's check that each of the\n+    # hextets are between 0x0 and 0xFFFF.\n+    for hextet in ip_str.split(':'):\n+        if hextet.count('.') == 3:\n+            # If we have an IPv4 mapped address, the IPv4 portion has to\n+            # be at the end of the IPv6 portion.\n+            if not ip_str.split(':')[-1] == hextet:\n+                return False\n+            try:\n+                validate_ipv4_address(hextet)\n+            except ValidationError:\n+                return False\n+        else:\n+            try:\n+                # a value error here means that we got a bad hextet,\n+                # something like 0xzzzz\n+                if int(hextet, 16) < 0x0 or int(hextet, 16) > 0xFFFF:\n+                    return False\n+            except ValueError:\n+                return False\n+    return True\n+\n+\n+def _explode_shorthand_ip_string(ip_str):\n+    \"\"\"\n+    Expand a shortened IPv6 address.\n+\n+    Args:\n+        ip_str: A string, the IPv6 address.\n+\n+    Returns:\n+        A string, the expanded IPv6 address.\n+\n+    \"\"\"\n+    if not _is_shorthand_ip(ip_str):\n+        # We've already got a longhand ip_str.\n+        return ip_str\n+\n+    new_ip = []\n+    hextet = ip_str.split('::')\n+\n+    # If there is a ::, we need to expand it with zeroes\n+    # to get to 8 hextets - unless there is a dot in the last hextet,\n+    # meaning we're doing v4-mapping\n+    if '.' in ip_str.split(':')[-1]:\n+        fill_to = 7\n+    else:\n+        fill_to = 8\n+\n+    if len(hextet) > 1:\n+        sep = len(hextet[0].split(':')) + len(hextet[1].split(':'))\n+        new_ip = hextet[0].split(':')\n+\n+        for _ in xrange(fill_to - sep):\n+            new_ip.append('0000')\n+        new_ip += hextet[1].split(':')\n+\n+    else:\n+        new_ip = ip_str.split(':')\n+\n+    # Now need to make sure every hextet is 4 lower case characters.\n+    # If a hextet is < 4 characters, we've got missing leading 0's.\n+    ret_ip = []\n+    for hextet in new_ip:\n+        ret_ip.append(('0' * (4 - len(hextet)) + hextet).lower())\n+    return ':'.join(ret_ip)\n+\n+\n+def _is_shorthand_ip(ip_str):\n+    \"\"\"Determine if the address is shortened.\n+\n+    Args:\n+        ip_str: A string, the IPv6 address.\n+\n+    Returns:\n+        A boolean, True if the address is shortened.\n+\n+    \"\"\"\n+    if ip_str.count('::') == 1:\n+        return True\n+    if filter(lambda x: len(x) < 4, ip_str.split(':')):\n+        return True\n+    return False"
        },
        {
            "sha": "3fc5b8aabf96d440680dcd455b88f9e1b20547a8",
            "filename": "docs/ref/forms/fields.txt",
            "status": "modified",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/docs%2Fref%2Fforms%2Ffields.txt",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/docs%2Fref%2Fforms%2Ffields.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fforms%2Ffields.txt?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -622,6 +622,45 @@ Takes two optional arguments for validation:\n       expression.\n     * Error message keys: ``required``, ``invalid``\n \n+``GenericIPAddressField``\n+~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+.. class:: GenericIPAddressField(**kwargs)\n+\n+.. versionadded:: 1.4\n+\n+A field containing either an IPv4 or an IPv6 address.\n+\n+    * Default widget: ``TextInput``\n+    * Empty value: ``''`` (an empty string)\n+    * Normalizes to: A Unicode object. IPv6 addresses are\n+      normalized as described below.\n+    * Validates that the given value is a valid IP address.\n+    * Error message keys: ``required``, ``invalid``\n+\n+The IPv6 address normalization follows `RFC4291 section 2.2`_, including using\n+the IPv4 format suggested in paragraph 3 of that section, like\n+``::ffff:192.0.2.0``. For example, ``2001:0::0:01`` would be normalized to\n+``2001::1``, and ``::ffff:0a0a:0a0a`` to ``::ffff:10.10.10.10``. All\n+characters are converted to lowercase.\n+\n+.. _RFC4291 section 2.2: http://tools.ietf.org/html/rfc4291#section-2.2\n+\n+Takes two optional arguments:\n+\n+.. attribute:: GenericIPAddressField.protocol\n+\n+    Limits valid inputs to the specified protocol.\n+    Accepted values are ``both`` (default), ``IPv4``\n+    or ``IPv6``. Matching is case insensitive.\n+\n+.. attribute:: GenericIPAddressField.unpack_ipv4\n+\n+    Unpacks IPv4 mapped addresses like ``::ffff::192.0.2.1``.\n+    If this option is enabled that address would be unpacked to\n+    ``192.0.2.1``. Default is disabled. Can only be used\n+    when ``protocol`` is set to ``'both'``.\n+\n ``MultipleChoiceField``\n ~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "7765f2f8ebb553105ab7e73bac208a7353d9672e",
            "filename": "docs/ref/models/fields.txt",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/docs%2Fref%2Fmodels%2Ffields.txt",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/docs%2Fref%2Fmodels%2Ffields.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Ffields.txt?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -760,6 +760,38 @@ single-line input).\n An IP address, in string format (e.g. \"192.0.2.30\"). The admin represents this\n as an ``<input type=\"text\">`` (a single-line input).\n \n+``GenericIPAddressField``\n+-------------------------\n+\n+.. class:: GenericIPAddressField([protocols=both, unpack_ipv4=False, **options])\n+\n+.. versionadded:: 1.4\n+\n+An IPv4 or IPv6 address, in string format (e.g. ``192.0.2.30`` or\n+``2a02:42fe::4``). The admin represents this as an ``<input type=\"text\">``\n+(a single-line input).\n+\n+The IPv6 address normalization follows `RFC4291 section 2.2`_, including using\n+the IPv4 format suggested in paragraph 3 of that section, like\n+``::ffff:192.0.2.0``. For example, ``2001:0::0:01`` would be normalized to\n+``2001::1``, and ``::ffff:0a0a:0a0a`` to ``::ffff:10.10.10.10``. All\n+characters are converted to lowercase.\n+\n+.. _RFC4291 section 2.2: http://tools.ietf.org/html/rfc4291#section-2.2\n+\n+.. attribute:: GenericIPAddressField.protocol\n+\n+    Limits valid inputs to the specified protocol.\n+    Accepted values are ``'both'`` (default), ``'IPv4'``\n+    or ``'IPv6'``. Matching is case insensitive.\n+\n+.. attribute:: GenericIPAddressField.unpack_ipv4\n+\n+    Unpacks IPv4 mapped addresses like ``::ffff::192.0.2.1``.\n+    If this option is enabled that address would be unpacked to\n+    ``192.0.2.1``. Default is disabled. Can only be used\n+    when ``protocol`` is set to ``'both'``.\n+\n ``NullBooleanField``\n --------------------\n "
        },
        {
            "sha": "0f299895c574d0dec602fd648a2f4bab2eb26dad",
            "filename": "docs/ref/validators.txt",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/docs%2Fref%2Fvalidators.txt",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/docs%2Fref%2Fvalidators.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fvalidators.txt?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -130,6 +130,23 @@ to, or in lieu of custom ``field.clean()`` methods.\n     A :class:`RegexValidator` instance that ensures a value looks like an IPv4\n     address.\n \n+``validate_ipv6_address``\n+-------------------------\n+.. versionadded:: 1.4\n+\n+.. data:: validate_ipv6_address\n+\n+    Uses :mod:`django.utils.ipv6` to check the validity of an IPv6 address.\n+\n+``validate_ipv46_address``\n+--------------------------\n+.. versionadded:: 1.4\n+\n+.. data:: validate_ipv46_address\n+\n+    Uses both ``validate_ipv4_address`` and ``validate_ipv6_address`` to\n+    ensure a value is either a valid IPv4 or IPv6 address.\n+\n ``validate_comma_separated_integer_list``\n -----------------------------------------\n .. data:: validate_comma_separated_integer_list"
        },
        {
            "sha": "0fbcd34d77a4c3f7ae75a24ce207561dd318eae1",
            "filename": "docs/releases/1.4.txt",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/docs%2Freleases%2F1.4.txt",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/docs%2Freleases%2F1.4.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.4.txt?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -155,6 +155,15 @@ You may override or customize the default filtering by writing a\n :ref:`custom filter<custom-error-reports>`. Learn more on\n :ref:`Filtering error reports<filtering-error-reports>`.\n \n+Extended IPv6 support\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+The previously added support for IPv6 addresses when using the runserver\n+management command in Django 1.3 has now been further extended by adding\n+a :class:`~django.db.models.fields.GenericIPAddressField` model field,\n+a :class:`~django.forms.fields.GenericIPAddressField` form field and\n+the validators :data:`~django.core.validators.validate_ipv46_address` and\n+:data:`~django.core.validators.validate_ipv6_address`\n \n Minor features\n ~~~~~~~~~~~~~~"
        },
        {
            "sha": "031408a1512313015032a94b4c5ca3bb047864a1",
            "filename": "docs/topics/forms/modelforms.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/docs%2Ftopics%2Fforms%2Fmodelforms.txt",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/docs%2Ftopics%2Fforms%2Fmodelforms.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fforms%2Fmodelforms.txt?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -83,6 +83,8 @@ the full list of conversions:\n \n     ``IPAddressField``               ``IPAddressField``\n \n+    ``GenericIPAddressField``        ``GenericIPAddressField``\n+\n     ``ManyToManyField``              ``ModelMultipleChoiceField`` (see\n                                      below)\n "
        },
        {
            "sha": "f92fc1f4ec8f455083cc3f0b3ba3f91160eb05a0",
            "filename": "tests/modeltests/validation/models.py",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fmodeltests%2Fvalidation%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fmodeltests%2Fvalidation%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fvalidation%2Fmodels.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -81,4 +81,12 @@ class FlexibleDatePost(models.Model):\n \n class UniqueErrorsModel(models.Model):\n     name = models.CharField(max_length=100, unique=True, error_messages={'unique': u'Custom unique name message.'})\n-    number = models.IntegerField(unique=True, error_messages={'unique': u'Custom unique number message.'})\n\\ No newline at end of file\n+    number = models.IntegerField(unique=True, error_messages={'unique': u'Custom unique number message.'})\n+\n+class GenericIPAddressTestModel(models.Model):\n+    generic_ip = models.GenericIPAddressField(blank=True, unique=True)\n+    v4_ip = models.GenericIPAddressField(blank=True, protocol=\"ipv4\")\n+    v6_ip = models.GenericIPAddressField(blank=True, protocol=\"ipv6\")\n+\n+class GenericIPAddressWithUnpackUniqueTestModel(models.Model):\n+    generic_v4unpack_ip = models.GenericIPAddressField(blank=True, unique=True, unpack_ipv4=True)"
        },
        {
            "sha": "bb60267ff092536f95e26de1f52b3d0d6542e11e",
            "filename": "tests/modeltests/validation/tests.py",
            "status": "modified",
            "additions": 58,
            "deletions": 1,
            "changes": 59,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fmodeltests%2Fvalidation%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fmodeltests%2Fvalidation%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fvalidation%2Ftests.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -2,7 +2,8 @@\n from django.test import TestCase\n from django.core.exceptions import NON_FIELD_ERRORS\n from modeltests.validation import ValidationTestCase\n-from modeltests.validation.models import Author, Article, ModelToValidate\n+from modeltests.validation.models import (Author, Article, ModelToValidate,\n+    GenericIPAddressTestModel, GenericIPAddressWithUnpackUniqueTestModel)\n \n # Import other tests for this package.\n from modeltests.validation.validators import TestModelsWithValidators\n@@ -77,6 +78,7 @@ def test_text_greater_that_charfields_max_length_raises_erros(self):\n         mtv = ModelToValidate(number=10, name='Some Name'*100)\n         self.assertFailsValidation(mtv.full_clean, ['name',])\n \n+\n class ArticleForm(forms.ModelForm):\n     class Meta:\n         model = Article\n@@ -124,3 +126,58 @@ def test_validation_with_invalid_blank_field(self):\n         article = Article(author_id=self.author.id)\n         form = ArticleForm(data, instance=article)\n         self.assertEqual(form.errors.keys(), ['pub_date'])\n+\n+\n+class GenericIPAddressFieldTests(ValidationTestCase):\n+\n+    def test_correct_generic_ip_passes(self):\n+        giptm = GenericIPAddressTestModel(generic_ip=\"1.2.3.4\")\n+        self.assertEqual(None, giptm.full_clean())\n+        giptm = GenericIPAddressTestModel(generic_ip=\"2001::2\")\n+        self.assertEqual(None, giptm.full_clean())\n+\n+    def test_invalid_generic_ip_raises_error(self):\n+        giptm = GenericIPAddressTestModel(generic_ip=\"294.4.2.1\")\n+        self.assertFailsValidation(giptm.full_clean, ['generic_ip',])\n+        giptm = GenericIPAddressTestModel(generic_ip=\"1:2\")\n+        self.assertFailsValidation(giptm.full_clean, ['generic_ip',])\n+\n+    def test_correct_v4_ip_passes(self):\n+        giptm = GenericIPAddressTestModel(v4_ip=\"1.2.3.4\")\n+        self.assertEqual(None, giptm.full_clean())\n+\n+    def test_invalid_v4_ip_raises_error(self):\n+        giptm = GenericIPAddressTestModel(v4_ip=\"294.4.2.1\")\n+        self.assertFailsValidation(giptm.full_clean, ['v4_ip',])\n+        giptm = GenericIPAddressTestModel(v4_ip=\"2001::2\")\n+        self.assertFailsValidation(giptm.full_clean, ['v4_ip',])\n+\n+    def test_correct_v6_ip_passes(self):\n+        giptm = GenericIPAddressTestModel(v6_ip=\"2001::2\")\n+        self.assertEqual(None, giptm.full_clean())\n+\n+    def test_invalid_v6_ip_raises_error(self):\n+        giptm = GenericIPAddressTestModel(v6_ip=\"1.2.3.4\")\n+        self.assertFailsValidation(giptm.full_clean, ['v6_ip',])\n+        giptm = GenericIPAddressTestModel(v6_ip=\"1:2\")\n+        self.assertFailsValidation(giptm.full_clean, ['v6_ip',])\n+\n+    def test_v6_uniqueness_detection(self):\n+        # These two addresses are the same with different syntax\n+        giptm = GenericIPAddressTestModel(generic_ip=\"2001::1:0:0:0:0:2\")\n+        giptm.save()\n+        giptm = GenericIPAddressTestModel(generic_ip=\"2001:0:1:2\")\n+        self.assertFailsValidation(giptm.full_clean, ['generic_ip',])\n+\n+    def test_v4_unpack_uniqueness_detection(self):\n+        # These two are different, because we are not doing IPv4 unpacking\n+        giptm = GenericIPAddressTestModel(generic_ip=\"::ffff:10.10.10.10\")\n+        giptm.save()\n+        giptm = GenericIPAddressTestModel(generic_ip=\"10.10.10.10\")\n+        self.assertEqual(None, giptm.full_clean())\n+\n+        # These two are the same, because we are doing IPv4 unpacking\n+        giptm = GenericIPAddressWithUnpackUniqueTestModel(generic_v4unpack_ip=\"::ffff:18.52.18.52\")\n+        giptm.save()\n+        giptm = GenericIPAddressWithUnpackUniqueTestModel(generic_v4unpack_ip=\"18.52.18.52\")\n+        self.assertFailsValidation(giptm.full_clean, ['generic_v4unpack_ip',])"
        },
        {
            "sha": "9e254b9b9002a1cc9e4b1c1323b8f42825bda572",
            "filename": "tests/modeltests/validators/tests.py",
            "status": "modified",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fmodeltests%2Fvalidators%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fmodeltests%2Fvalidators%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fvalidators%2Ftests.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -52,6 +52,31 @@\n     (validate_ipv4_address, '25,1,1,1', ValidationError),\n     (validate_ipv4_address, '25.1 .1.1', ValidationError),\n \n+    # validate_ipv6_address uses django.utils.ipv6, which\n+    # is tested in much greater detail in it's own testcase\n+    (validate_ipv6_address, 'fe80::1', None),\n+    (validate_ipv6_address, '::1', None),\n+    (validate_ipv6_address, '1:2:3:4:5:6:7:8', None),\n+\n+    (validate_ipv6_address, '1:2', ValidationError),\n+    (validate_ipv6_address, '::zzz', ValidationError),\n+    (validate_ipv6_address, '12345::', ValidationError),\n+\n+    (validate_ipv46_address, '1.1.1.1', None),\n+    (validate_ipv46_address, '255.0.0.0', None),\n+    (validate_ipv46_address, '0.0.0.0', None),\n+    (validate_ipv46_address, 'fe80::1', None),\n+    (validate_ipv46_address, '::1', None),\n+    (validate_ipv46_address, '1:2:3:4:5:6:7:8', None),\n+\n+    (validate_ipv46_address, '256.1.1.1', ValidationError),\n+    (validate_ipv46_address, '25.1.1.', ValidationError),\n+    (validate_ipv46_address, '25,1,1,1', ValidationError),\n+    (validate_ipv46_address, '25.1 .1.1', ValidationError),\n+    (validate_ipv46_address, '1:2', ValidationError),\n+    (validate_ipv46_address, '::zzz', ValidationError),\n+    (validate_ipv46_address, '12345::', ValidationError),\n+\n     (validate_comma_separated_integer_list, '1', None),\n     (validate_comma_separated_integer_list, '1,2,3', None),\n     (validate_comma_separated_integer_list, '1,2,3,', None),"
        },
        {
            "sha": "981016f184e030ca5c21b3d1268a32385677f2bb",
            "filename": "tests/regressiontests/forms/tests/error_messages.py",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fregressiontests%2Fforms%2Ftests%2Ferror_messages.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fregressiontests%2Fforms%2Ftests%2Ferror_messages.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fforms%2Ftests%2Ferror_messages.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -196,6 +196,15 @@ def test_ipaddressfield(self):\n         self.assertFormErrors([u'REQUIRED'], f.clean, '')\n         self.assertFormErrors([u'INVALID IP ADDRESS'], f.clean, '127.0.0')\n \n+    def test_generic_ipaddressfield(self):\n+        e = {\n+            'required': 'REQUIRED',\n+            'invalid': 'INVALID IP ADDRESS',\n+        }\n+        f = GenericIPAddressField(error_messages=e)\n+        self.assertFormErrors([u'REQUIRED'], f.clean, '')\n+        self.assertFormErrors([u'INVALID IP ADDRESS'], f.clean, '127.0.0')\n+\n     def test_subclassing_errorlist(self):\n         class TestForm(Form):\n             first_name = CharField()"
        },
        {
            "sha": "b8b32cb1515f3656d4e7125cddc59fb3b4c7e9b9",
            "filename": "tests/regressiontests/forms/tests/extra.py",
            "status": "modified",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fregressiontests%2Fforms%2Ftests%2Fextra.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fregressiontests%2Fforms%2Ftests%2Fextra.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fforms%2Ftests%2Fextra.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -460,6 +460,86 @@ def test_ipaddress(self):\n         self.assertFormErrors([u'Enter a valid IPv4 address.'], f.clean, '1.2.3.4.5')\n         self.assertFormErrors([u'Enter a valid IPv4 address.'], f.clean, '256.125.1.5')\n \n+    def test_generic_ipaddress_invalid_arguments(self):\n+        self.assertRaises(ValueError, GenericIPAddressField, protocol=\"hamster\")\n+        self.assertRaises(ValueError, GenericIPAddressField, protocol=\"ipv4\", unpack_ipv4=True)\n+\n+    def test_generic_ipaddress_as_generic(self):\n+        # The edge cases of the IPv6 validation code are not deeply tested\n+        # here, they are covered in the tests for django.utils.ipv6\n+        f = GenericIPAddressField()\n+        self.assertFormErrors([u'This field is required.'], f.clean, '')\n+        self.assertFormErrors([u'This field is required.'], f.clean, None)\n+        self.assertEqual(f.clean('127.0.0.1'), u'127.0.0.1')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, 'foo')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '127.0.0.')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '1.2.3.4.5')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '256.125.1.5')\n+        self.assertEqual(f.clean('fe80::223:6cff:fe8a:2e8a'), u'fe80::223:6cff:fe8a:2e8a')\n+        self.assertEqual(f.clean('2a02::223:6cff:fe8a:2e8a'), u'2a02::223:6cff:fe8a:2e8a')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '12345:2:3:4')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '1::2:3::4')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, 'foo::223:6cff:fe8a:2e8a')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '1::2:3:4:5:6:7:8')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '1:2')\n+\n+    def test_generic_ipaddress_as_ipv4_only(self):\n+        f = GenericIPAddressField(protocol=\"IPv4\")\n+        self.assertFormErrors([u'This field is required.'], f.clean, '')\n+        self.assertFormErrors([u'This field is required.'], f.clean, None)\n+        self.assertEqual(f.clean('127.0.0.1'), u'127.0.0.1')\n+        self.assertFormErrors([u'Enter a valid IPv4 address.'], f.clean, 'foo')\n+        self.assertFormErrors([u'Enter a valid IPv4 address.'], f.clean, '127.0.0.')\n+        self.assertFormErrors([u'Enter a valid IPv4 address.'], f.clean, '1.2.3.4.5')\n+        self.assertFormErrors([u'Enter a valid IPv4 address.'], f.clean, '256.125.1.5')\n+        self.assertFormErrors([u'Enter a valid IPv4 address.'], f.clean, 'fe80::223:6cff:fe8a:2e8a')\n+        self.assertFormErrors([u'Enter a valid IPv4 address.'], f.clean, '2a02::223:6cff:fe8a:2e8a')\n+\n+    def test_generic_ipaddress_as_ipv4_only(self):\n+        f = GenericIPAddressField(protocol=\"IPv6\")\n+        self.assertFormErrors([u'This field is required.'], f.clean, '')\n+        self.assertFormErrors([u'This field is required.'], f.clean, None)\n+        self.assertFormErrors([u'Enter a valid IPv6 address.'], f.clean, '127.0.0.1')\n+        self.assertFormErrors([u'Enter a valid IPv6 address.'], f.clean, 'foo')\n+        self.assertFormErrors([u'Enter a valid IPv6 address.'], f.clean, '127.0.0.')\n+        self.assertFormErrors([u'Enter a valid IPv6 address.'], f.clean, '1.2.3.4.5')\n+        self.assertFormErrors([u'Enter a valid IPv6 address.'], f.clean, '256.125.1.5')\n+        self.assertEqual(f.clean('fe80::223:6cff:fe8a:2e8a'), u'fe80::223:6cff:fe8a:2e8a')\n+        self.assertEqual(f.clean('2a02::223:6cff:fe8a:2e8a'), u'2a02::223:6cff:fe8a:2e8a')\n+        self.assertFormErrors([u'Enter a valid IPv6 address.'], f.clean, '12345:2:3:4')\n+        self.assertFormErrors([u'Enter a valid IPv6 address.'], f.clean, '1::2:3::4')\n+        self.assertFormErrors([u'Enter a valid IPv6 address.'], f.clean, 'foo::223:6cff:fe8a:2e8a')\n+        self.assertFormErrors([u'Enter a valid IPv6 address.'], f.clean, '1::2:3:4:5:6:7:8')\n+        self.assertFormErrors([u'Enter a valid IPv6 address.'], f.clean, '1:2')\n+\n+    def test_generic_ipaddress_as_generic_not_required(self):\n+        f = GenericIPAddressField(required=False)\n+        self.assertEqual(f.clean(''), u'')\n+        self.assertEqual(f.clean(None), u'')\n+        self.assertEqual(f.clean('127.0.0.1'), u'127.0.0.1')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, 'foo')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '127.0.0.')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '1.2.3.4.5')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '256.125.1.5')\n+        self.assertEqual(f.clean('fe80::223:6cff:fe8a:2e8a'), u'fe80::223:6cff:fe8a:2e8a')\n+        self.assertEqual(f.clean('2a02::223:6cff:fe8a:2e8a'), u'2a02::223:6cff:fe8a:2e8a')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '12345:2:3:4')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '1::2:3::4')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, 'foo::223:6cff:fe8a:2e8a')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '1::2:3:4:5:6:7:8')\n+        self.assertFormErrors([u'Enter a valid IPv4 or IPv6 address.'], f.clean, '1:2')\n+\n+    def test_generic_ipaddress_normalization(self):\n+        # Test the normalising code\n+        f = GenericIPAddressField()\n+        self.assertEqual(f.clean('::ffff:0a0a:0a0a'), u'::ffff:10.10.10.10')\n+        self.assertEqual(f.clean('::ffff:10.10.10.10'), u'::ffff:10.10.10.10')\n+        self.assertEqual(f.clean('2001:000:a:0000:0:fe:fe:beef'), u'2001:0:a::fe:fe:beef')\n+        self.assertEqual(f.clean('2001::a:0000:0:fe:fe:beef'), u'2001:0:a::fe:fe:beef')\n+\n+        f = GenericIPAddressField(unpack_ipv4=True)\n+        self.assertEqual(f.clean('::ffff:0a0a:0a0a'), u'10.10.10.10')\n+\n     def test_smart_unicode(self):\n         class Test:\n             def __str__(self):"
        },
        {
            "sha": "b3ae1feaa56b2f2b63d022bdbc2d11b2df781397",
            "filename": "tests/regressiontests/serializers_regress/models.py",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fregressiontests%2Fserializers_regress%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fregressiontests%2Fserializers_regress%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fserializers_regress%2Fmodels.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -52,6 +52,9 @@ class BigIntegerData(models.Model):\n class IPAddressData(models.Model):\n     data = models.IPAddressField(null=True)\n \n+class GenericIPAddressData(models.Model):\n+    data = models.GenericIPAddressField(null=True)\n+\n class NullBooleanData(models.Model):\n     data = models.NullBooleanField(null=True)\n \n@@ -187,6 +190,9 @@ class IntegerPKData(models.Model):\n class IPAddressPKData(models.Model):\n     data = models.IPAddressField(primary_key=True)\n \n+class GenericIPAddressPKData(models.Model):\n+    data = models.GenericIPAddressField(primary_key=True)\n+\n # This is just a Boolean field with null=True, and we can't test a PK value of NULL.\n # class NullBooleanPKData(models.Model):\n #     data = models.NullBooleanField(primary_key=True)"
        },
        {
            "sha": "90a438c43a7844c51070b65c8cdd506378a4d0a9",
            "filename": "tests/regressiontests/serializers_regress/tests.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fregressiontests%2Fserializers_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fregressiontests%2Fserializers_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fserializers_regress%2Ftests.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -196,6 +196,8 @@ def inherited_compare(testcase, pk, klass, data):\n     #(XX, ImageData\n     (data_obj, 90, IPAddressData, \"127.0.0.1\"),\n     (data_obj, 91, IPAddressData, None),\n+    (data_obj, 95, GenericIPAddressData, \"fe80:1424:2223:6cff:fe8a:2e8a:2151:abcd\"),\n+    (data_obj, 96, GenericIPAddressData, None),\n     (data_obj, 100, NullBooleanData, True),\n     (data_obj, 101, NullBooleanData, False),\n     (data_obj, 102, NullBooleanData, None),\n@@ -298,6 +300,7 @@ def inherited_compare(testcase, pk, klass, data):\n     (pk_obj, 682, IntegerPKData, 0),\n #     (XX, ImagePKData\n     (pk_obj, 690, IPAddressPKData, \"127.0.0.1\"),\n+    (pk_obj, 695, GenericIPAddressPKData, \"fe80:1424:2223:6cff:fe8a:2e8a:2151:abcd\"),\n     # (pk_obj, 700, NullBooleanPKData, True),\n     # (pk_obj, 701, NullBooleanPKData, False),\n     (pk_obj, 710, PhonePKData, \"212-634-5789\"),"
        },
        {
            "sha": "86d1ad1573fa8c02cf4677b9fd80470d80d0a020",
            "filename": "tests/regressiontests/utils/ipv6.py",
            "status": "added",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fregressiontests%2Futils%2Fipv6.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fregressiontests%2Futils%2Fipv6.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Futils%2Fipv6.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -0,0 +1,51 @@\n+from django.utils import unittest\n+from django.utils.ipv6 import is_valid_ipv6_address, clean_ipv6_address\n+\n+class TestUtilsIPv6(unittest.TestCase):\n+\n+    def test_validates_correct_plain_address(self):\n+        self.assertTrue(is_valid_ipv6_address('fe80::223:6cff:fe8a:2e8a'))\n+        self.assertTrue(is_valid_ipv6_address('2a02::223:6cff:fe8a:2e8a'))\n+        self.assertTrue(is_valid_ipv6_address('1::2:3:4:5:6:7'))\n+        self.assertTrue(is_valid_ipv6_address('::'))\n+        self.assertTrue(is_valid_ipv6_address('::a'))\n+        self.assertTrue(is_valid_ipv6_address('2::'))\n+\n+    def test_validates_correct_with_v4mapping(self):\n+        self.assertTrue(is_valid_ipv6_address('::ffff:254.42.16.14'))\n+        self.assertTrue(is_valid_ipv6_address('::ffff:0a0a:0a0a'))\n+\n+    def test_validates_incorrect_plain_address(self):\n+        self.assertFalse(is_valid_ipv6_address('foo'))\n+        self.assertFalse(is_valid_ipv6_address('127.0.0.1'))\n+        self.assertFalse(is_valid_ipv6_address('12345::'))\n+        self.assertFalse(is_valid_ipv6_address('1::2:3::4'))\n+        self.assertFalse(is_valid_ipv6_address('1::zzz'))\n+        self.assertFalse(is_valid_ipv6_address('1::2:3:4:5:6:7:8'))\n+        self.assertFalse(is_valid_ipv6_address('1:2'))\n+        self.assertFalse(is_valid_ipv6_address('1:::2'))\n+\n+    def test_validates_incorrect_with_v4mapping(self):\n+        self.assertFalse(is_valid_ipv6_address('::ffff:999.42.16.14'))\n+        self.assertFalse(is_valid_ipv6_address('::ffff:zzzz:0a0a'))\n+        # The ::1.2.3.4 format used to be valid but was deprecated\n+        # in rfc4291 section 2.5.5.1\n+        self.assertTrue(is_valid_ipv6_address('::254.42.16.14'))\n+        self.assertTrue(is_valid_ipv6_address('::0a0a:0a0a'))\n+        self.assertFalse(is_valid_ipv6_address('::999.42.16.14'))\n+        self.assertFalse(is_valid_ipv6_address('::zzzz:0a0a'))\n+\n+    def test_cleanes_plain_address(self):\n+        self.assertEqual(clean_ipv6_address('DEAD::0:BEEF'), u'dead::beef')\n+        self.assertEqual(clean_ipv6_address('2001:000:a:0000:0:fe:fe:beef'), u'2001:0:a::fe:fe:beef')\n+        self.assertEqual(clean_ipv6_address('2001::a:0000:0:fe:fe:beef'), u'2001:0:a::fe:fe:beef')\n+\n+    def test_cleanes_with_v4_mapping(self):\n+        self.assertEqual(clean_ipv6_address('::ffff:0a0a:0a0a'), u'::ffff:10.10.10.10')\n+        self.assertEqual(clean_ipv6_address('::ffff:1234:1234'), u'::ffff:18.52.18.52')\n+        self.assertEqual(clean_ipv6_address('::ffff:18.52.18.52'), u'::ffff:18.52.18.52')\n+\n+    def test_unpacks_ipv4(self):\n+        self.assertEqual(clean_ipv6_address('::ffff:0a0a:0a0a', unpack_ipv4=True), u'10.10.10.10')\n+        self.assertEqual(clean_ipv6_address('::ffff:1234:1234', unpack_ipv4=True), u'18.52.18.52')\n+        self.assertEqual(clean_ipv6_address('::ffff:18.52.18.52', unpack_ipv4=True), u'18.52.18.52')"
        },
        {
            "sha": "e91adc94e5d08333a7578515dab5ccd4d8879aa3",
            "filename": "tests/regressiontests/utils/tests.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fregressiontests%2Futils%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/ce3c281090320172d22e8a6057250d103c93438e/tests%2Fregressiontests%2Futils%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Futils%2Ftests.py?ref=ce3c281090320172d22e8a6057250d103c93438e",
            "patch": "@@ -19,3 +19,4 @@\n from datetime_safe import *\n from baseconv import *\n from jslex import *\n+from ipv6 import *"
        }
    ],
    "stats": {
        "total": 713,
        "additions": 708,
        "deletions": 5
    }
}