{
    "author": "spookylukey",
    "message": "Fixed #17530 - Fixture loading with deferred constraints broken for Postgres for fixtures from multiple dirs/files\n\nThanks to claudep for the review.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17372 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "4e29b70b9dfb836a6ece537728f1ad9702786948",
    "files": [
        {
            "sha": "0c234fb7463ce73ceb1fe80227edddd8c644602c",
            "filename": "django/core/management/commands/loaddata.py",
            "status": "modified",
            "additions": 111,
            "deletions": 107,
            "changes": 218,
            "blob_url": "https://github.com/django/django/blob/4e29b70b9dfb836a6ece537728f1ad9702786948/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py",
            "raw_url": "https://github.com/django/django/raw/4e29b70b9dfb836a6ece537728f1ad9702786948/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py?ref=4e29b70b9dfb836a6ece537728f1ad9702786948",
            "patch": "@@ -104,87 +104,89 @@ def read(self):\n                 app_module_paths.append(app.__file__)\n \n         app_fixtures = [os.path.join(os.path.dirname(path), 'fixtures') for path in app_module_paths]\n-        for fixture_label in fixture_labels:\n-            parts = fixture_label.split('.')\n \n-            if len(parts) > 1 and parts[-1] in compression_types:\n-                compression_formats = [parts[-1]]\n-                parts = parts[:-1]\n-            else:\n-                compression_formats = compression_types.keys()\n+        try:\n+            with connection.constraint_checks_disabled():\n+                for fixture_label in fixture_labels:\n+                    parts = fixture_label.split('.')\n \n-            if len(parts) == 1:\n-                fixture_name = parts[0]\n-                formats = serializers.get_public_serializer_formats()\n-            else:\n-                fixture_name, format = '.'.join(parts[:-1]), parts[-1]\n-                if format in serializers.get_public_serializer_formats():\n-                    formats = [format]\n-                else:\n-                    formats = []\n+                    if len(parts) > 1 and parts[-1] in compression_types:\n+                        compression_formats = [parts[-1]]\n+                        parts = parts[:-1]\n+                    else:\n+                        compression_formats = compression_types.keys()\n \n-            if formats:\n-                if verbosity >= 2:\n-                    self.stdout.write(\"Loading '%s' fixtures...\\n\" % fixture_name)\n-            else:\n-                self.stderr.write(\n-                    self.style.ERROR(\"Problem installing fixture '%s': %s is not a known serialization format.\\n\" %\n-                        (fixture_name, format)))\n-                if commit:\n-                    transaction.rollback(using=using)\n-                    transaction.leave_transaction_management(using=using)\n-                return\n-\n-            if os.path.isabs(fixture_name):\n-                fixture_dirs = [fixture_name]\n-            else:\n-                fixture_dirs = app_fixtures + list(settings.FIXTURE_DIRS) + ['']\n+                    if len(parts) == 1:\n+                        fixture_name = parts[0]\n+                        formats = serializers.get_public_serializer_formats()\n+                    else:\n+                        fixture_name, format = '.'.join(parts[:-1]), parts[-1]\n+                        if format in serializers.get_public_serializer_formats():\n+                            formats = [format]\n+                        else:\n+                            formats = []\n \n-            for fixture_dir in fixture_dirs:\n-                if verbosity >= 2:\n-                    self.stdout.write(\"Checking %s for fixtures...\\n\" % humanize(fixture_dir))\n-\n-                label_found = False\n-                for combo in product([using, None], formats, compression_formats):\n-                    database, format, compression_format = combo\n-                    file_name = '.'.join(\n-                        p for p in [\n-                            fixture_name, database, format, compression_format\n-                        ]\n-                        if p\n-                    )\n-\n-                    if verbosity >= 3:\n-                        self.stdout.write(\"Trying %s for %s fixture '%s'...\\n\" % \\\n-                            (humanize(fixture_dir), file_name, fixture_name))\n-                    full_path = os.path.join(fixture_dir, file_name)\n-                    open_method = compression_types[compression_format]\n-                    try:\n-                        fixture = open_method(full_path, 'r')\n-                    except IOError:\n+                    if formats:\n                         if verbosity >= 2:\n-                            self.stdout.write(\"No %s fixture '%s' in %s.\\n\" % \\\n-                                (format, fixture_name, humanize(fixture_dir)))\n+                            self.stdout.write(\"Loading '%s' fixtures...\\n\" % fixture_name)\n                     else:\n-                        if label_found:\n-                            fixture.close()\n-                            self.stderr.write(self.style.ERROR(\"Multiple fixtures named '%s' in %s. Aborting.\\n\" %\n-                                (fixture_name, humanize(fixture_dir))))\n-                            if commit:\n-                                transaction.rollback(using=using)\n-                                transaction.leave_transaction_management(using=using)\n-                            return\n-                        else:\n-                            fixture_count += 1\n-                            objects_in_fixture = 0\n-                            loaded_objects_in_fixture = 0\n-                            if verbosity >= 2:\n-                                self.stdout.write(\"Installing %s fixture '%s' from %s.\\n\" % \\\n-                                    (format, fixture_name, humanize(fixture_dir)))\n+                        self.stderr.write(\n+                            self.style.ERROR(\"Problem installing fixture '%s': %s is not a known serialization format.\\n\" %\n+                                (fixture_name, format)))\n+                        if commit:\n+                            transaction.rollback(using=using)\n+                            transaction.leave_transaction_management(using=using)\n+                        return\n+\n+                    if os.path.isabs(fixture_name):\n+                        fixture_dirs = [fixture_name]\n+                    else:\n+                        fixture_dirs = app_fixtures + list(settings.FIXTURE_DIRS) + ['']\n+\n+                    for fixture_dir in fixture_dirs:\n+                        if verbosity >= 2:\n+                            self.stdout.write(\"Checking %s for fixtures...\\n\" % humanize(fixture_dir))\n+\n+                        label_found = False\n+                        for combo in product([using, None], formats, compression_formats):\n+                            database, format, compression_format = combo\n+                            file_name = '.'.join(\n+                                p for p in [\n+                                    fixture_name, database, format, compression_format\n+                                ]\n+                                if p\n+                            )\n+\n+                            if verbosity >= 3:\n+                                self.stdout.write(\"Trying %s for %s fixture '%s'...\\n\" % \\\n+                                    (humanize(fixture_dir), file_name, fixture_name))\n+                            full_path = os.path.join(fixture_dir, file_name)\n+                            open_method = compression_types[compression_format]\n                             try:\n-                                objects = serializers.deserialize(format, fixture, using=using)\n+                                fixture = open_method(full_path, 'r')\n+                            except IOError:\n+                                if verbosity >= 2:\n+                                    self.stdout.write(\"No %s fixture '%s' in %s.\\n\" % \\\n+                                        (format, fixture_name, humanize(fixture_dir)))\n+                            else:\n+                                try:\n+                                    if label_found:\n+                                        self.stderr.write(self.style.ERROR(\"Multiple fixtures named '%s' in %s. Aborting.\\n\" %\n+                                            (fixture_name, humanize(fixture_dir))))\n+                                        if commit:\n+                                            transaction.rollback(using=using)\n+                                            transaction.leave_transaction_management(using=using)\n+                                        return\n+\n+                                    fixture_count += 1\n+                                    objects_in_fixture = 0\n+                                    loaded_objects_in_fixture = 0\n+                                    if verbosity >= 2:\n+                                        self.stdout.write(\"Installing %s fixture '%s' from %s.\\n\" % \\\n+                                            (format, fixture_name, humanize(fixture_dir)))\n+\n+                                    objects = serializers.deserialize(format, fixture, using=using)\n \n-                                with connection.constraint_checks_disabled():\n                                     for obj in objects:\n                                         objects_in_fixture += 1\n                                         if router.allow_syncdb(using, obj.object.__class__):\n@@ -201,41 +203,43 @@ def read(self):\n                                                     }\n                                                 raise e.__class__, e.__class__(msg), sys.exc_info()[2]\n \n-                                # Since we disabled constraint checks, we must manually check for\n-                                # any invalid keys that might have been added\n-                                table_names = [model._meta.db_table for model in models]\n-                                connection.check_constraints(table_names=table_names)\n-\n-                                loaded_object_count += loaded_objects_in_fixture\n-                                fixture_object_count += objects_in_fixture\n-                                label_found = True\n-                            except (SystemExit, KeyboardInterrupt):\n-                                raise\n-                            except Exception:\n-                                fixture.close()\n-                                if commit:\n-                                    transaction.rollback(using=using)\n-                                    transaction.leave_transaction_management(using=using)\n-                                if show_traceback:\n-                                    traceback.print_exc()\n-                                else:\n+                                    loaded_object_count += loaded_objects_in_fixture\n+                                    fixture_object_count += objects_in_fixture\n+                                    label_found = True\n+                                finally:\n+                                    fixture.close()\n+\n+                                # If the fixture we loaded contains 0 objects, assume that an\n+                                # error was encountered during fixture loading.\n+                                if objects_in_fixture == 0:\n                                     self.stderr.write(\n-                                        self.style.ERROR(\"Problem installing fixture '%s': %s\\n\" %\n-                                             (full_path, ''.join(traceback.format_exception(sys.exc_type,\n-                                                 sys.exc_value, sys.exc_traceback)))))\n-                                return\n-                            fixture.close()\n-\n-                            # If the fixture we loaded contains 0 objects, assume that an\n-                            # error was encountered during fixture loading.\n-                            if objects_in_fixture == 0:\n-                                self.stderr.write(\n-                                    self.style.ERROR(\"No fixture data found for '%s'. (File format may be invalid.)\\n\" %\n-                                        (fixture_name)))\n-                                if commit:\n-                                    transaction.rollback(using=using)\n-                                    transaction.leave_transaction_management(using=using)\n-                                return\n+                                        self.style.ERROR(\"No fixture data found for '%s'. (File format may be invalid.)\\n\" %\n+                                            (fixture_name)))\n+                                    if commit:\n+                                        transaction.rollback(using=using)\n+                                        transaction.leave_transaction_management(using=using)\n+                                    return\n+\n+            # Since we disabled constraint checks, we must manually check for\n+            # any invalid keys that might have been added\n+            table_names = [model._meta.db_table for model in models]\n+            connection.check_constraints(table_names=table_names)\n+\n+        except (SystemExit, KeyboardInterrupt):\n+            raise\n+        except Exception:\n+            if commit:\n+                transaction.rollback(using=using)\n+                transaction.leave_transaction_management(using=using)\n+            if show_traceback:\n+                traceback.print_exc()\n+            else:\n+                self.stderr.write(\n+                    self.style.ERROR(\"Problem installing fixture '%s': %s\\n\" %\n+                         (full_path, ''.join(traceback.format_exception(sys.exc_type,\n+                             sys.exc_value, sys.exc_traceback)))))\n+            return\n+\n \n         # If we found even one object in a fixture, we need to reset the\n         # database sequences."
        },
        {
            "sha": "1a75037b4892bfa7e6440cde3cbdb796e60f7a20",
            "filename": "tests/regressiontests/fixtures_regress/fixtures_1/forward_ref_1.json",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/4e29b70b9dfb836a6ece537728f1ad9702786948/tests%2Fregressiontests%2Ffixtures_regress%2Ffixtures_1%2Fforward_ref_1.json",
            "raw_url": "https://github.com/django/django/raw/4e29b70b9dfb836a6ece537728f1ad9702786948/tests%2Fregressiontests%2Ffixtures_regress%2Ffixtures_1%2Fforward_ref_1.json",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ffixtures_regress%2Ffixtures_1%2Fforward_ref_1.json?ref=4e29b70b9dfb836a6ece537728f1ad9702786948",
            "patch": "@@ -0,0 +1,10 @@\n+[\n+    {\n+        \"pk\": 1,\n+        \"model\": \"fixtures_regress.book\",\n+        \"fields\": {\n+            \"name\": \"Cryptonomicon\",\n+            \"author\": 4\n+        }\n+    }\n+]"
        },
        {
            "sha": "9cb63085a4a4acf0eb715d00bfc0a50e3aeded5c",
            "filename": "tests/regressiontests/fixtures_regress/fixtures_2/forward_ref_2.json",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/4e29b70b9dfb836a6ece537728f1ad9702786948/tests%2Fregressiontests%2Ffixtures_regress%2Ffixtures_2%2Fforward_ref_2.json",
            "raw_url": "https://github.com/django/django/raw/4e29b70b9dfb836a6ece537728f1ad9702786948/tests%2Fregressiontests%2Ffixtures_regress%2Ffixtures_2%2Fforward_ref_2.json",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ffixtures_regress%2Ffixtures_2%2Fforward_ref_2.json?ref=4e29b70b9dfb836a6ece537728f1ad9702786948",
            "patch": "@@ -0,0 +1,9 @@\n+[\n+    {\n+        \"pk\": \"4\",\n+        \"model\": \"fixtures_regress.person\",\n+        \"fields\": {\n+            \"name\": \"Neal Stephenson\"\n+        }\n+    }\n+]"
        },
        {
            "sha": "ed8b4047884698bc051ddf69d631a71f8ba4eafa",
            "filename": "tests/regressiontests/fixtures_regress/tests.py",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/django/django/blob/4e29b70b9dfb836a6ece537728f1ad9702786948/tests%2Fregressiontests%2Ffixtures_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/4e29b70b9dfb836a6ece537728f1ad9702786948/tests%2Fregressiontests%2Ffixtures_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ffixtures_regress%2Ftests.py?ref=4e29b70b9dfb836a6ece537728f1ad9702786948",
            "patch": "@@ -16,6 +16,7 @@\n from django.db.models import signals\n from django.test import (TestCase, TransactionTestCase, skipIfDBFeature,\n     skipUnlessDBFeature)\n+from django.test.utils import override_settings\n \n from .models import (Animal, Stuff, Absolute, Parent, Child, Article, Widget,\n     Store, Person, Book, NKChild, RefToNKChild, Circle1, Circle2, Circle3,\n@@ -390,6 +391,25 @@ def test_loaddata_raises_error_when_fixture_has_invalid_foreign_key(self):\n             stderr.getvalue().startswith('Problem installing fixture')\n         )\n \n+    _cur_dir = os.path.dirname(os.path.abspath(__file__))\n+\n+    @override_settings(FIXTURE_DIRS=[os.path.join(_cur_dir, 'fixtures_1'),\n+                                     os.path.join(_cur_dir, 'fixtures_2')])\n+    def test_loaddata_forward_refs_split_fixtures(self):\n+        \"\"\"\n+        Regression for #17530 - should be able to cope with forward references\n+        when the fixtures are not in the same files or directories.\n+        \"\"\"\n+        management.call_command(\n+            'loaddata',\n+            'forward_ref_1.json',\n+            'forward_ref_2.json',\n+            verbosity=0,\n+            commit=False\n+        )\n+        self.assertEqual(Book.objects.all()[0].id, 1)\n+        self.assertEqual(Person.objects.all()[0].id, 4)\n+\n     def test_loaddata_no_fixture_specified(self):\n         \"\"\"\n         Regression for #7043 - Error is quickly reported when no fixtures is provided in the command line."
        }
    ],
    "stats": {
        "total": 257,
        "additions": 150,
        "deletions": 107
    }
}