{
    "author": "freakboy3742",
    "message": "Fixed #16809 -- Forced MySQL to behave like a database. This avoids a problem where queries that do IS NONE checks can return the wrong result the first time they are executed if there is a recently inserted row. Thanks to James Pyrich for the debug work and patch.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16785 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "fcee0c1b66019a0e84bc338e76fa31695d5bd4ca",
    "files": [
        {
            "sha": "e9f5b8b6a974cba8ac81cdeb41ee40708487037a",
            "filename": "django/db/backends/mysql/base.py",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/fcee0c1b66019a0e84bc338e76fa31695d5bd4ca/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/fcee0c1b66019a0e84bc338e76fa31695d5bd4ca/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py?ref=fcee0c1b66019a0e84bc338e76fa31695d5bd4ca",
            "patch": "@@ -309,7 +309,9 @@ def _valid_connection(self):\n         return False\n \n     def _cursor(self):\n+        new_connection = False\n         if not self._valid_connection():\n+            new_connection = True\n             kwargs = {\n                 'conv': django_conversions,\n                 'charset': 'utf8',\n@@ -336,8 +338,14 @@ def _cursor(self):\n             self.connection.encoders[SafeUnicode] = self.connection.encoders[unicode]\n             self.connection.encoders[SafeString] = self.connection.encoders[str]\n             connection_created.send(sender=self.__class__, connection=self)\n-        cursor = CursorWrapper(self.connection.cursor())\n-        return cursor\n+        cursor = self.connection.cursor()\n+        if new_connection:\n+            # SQL_AUTO_IS_NULL in MySQL controls whether an AUTO_INCREMENT column\n+            # on a recently-inserted row will return when the field is tested for\n+            # NULL.  Disabling this value brings this aspect of MySQL in line with\n+            # SQL standards.\n+            cursor.execute('SET SQL_AUTO_IS_NULL = 0')\n+        return CursorWrapper(cursor)\n \n     def _rollback(self):\n         try:"
        },
        {
            "sha": "d8fd5bc9cecd2296ec6a0df3bd1633f78a310f5c",
            "filename": "tests/regressiontests/queries/tests.py",
            "status": "modified",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/fcee0c1b66019a0e84bc338e76fa31695d5bd4ca/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/fcee0c1b66019a0e84bc338e76fa31695d5bd4ca/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Ftests.py?ref=fcee0c1b66019a0e84bc338e76fa31695d5bd4ca",
            "patch": "@@ -1070,10 +1070,6 @@ def test_ticket15316_exclude_false(self):\n         ci3 = CategoryItem.objects.create(category=c3)\n \n         qs = CategoryItem.objects.exclude(category__specialcategory__isnull=False)\n-        # Under MySQL, this query gives incorrect values on the first attempt.\n-        # If you run exactly the same query twice, it yields the right answer\n-        # the second attempt. Oh, how we do love MySQL.\n-        qs.count()\n         self.assertEqual(qs.count(), 1)\n         self.assertQuerysetEqual(qs, [ci1.pk], lambda x: x.pk)\n \n@@ -1136,10 +1132,6 @@ def test_ticket15316_one2one_exclude_false(self):\n         ci3 = CategoryItem.objects.create(category=c1)\n \n         qs = CategoryItem.objects.exclude(category__onetoonecategory__isnull=False)\n-        # Under MySQL, this query gives incorrect values on the first attempt.\n-        # If you run exactly the same query twice, it yields the right answer\n-        # the second attempt. Oh, how we do love MySQL.\n-        qs.count()\n         self.assertEqual(qs.count(), 1)\n         self.assertQuerysetEqual(qs, [ci1.pk], lambda x: x.pk)\n \n@@ -1421,11 +1413,6 @@ def test_tickets_8921_9188(self):\n             []\n         )\n \n-        # This next makes exactly *zero* sense, but it works. It's needed\n-        # because MySQL fails to give the right results the first time this\n-        # query is executed. If you run the same query a second time, it\n-        # works fine. It's a hack, but it works...\n-        list(Tag.objects.exclude(children=None))\n         self.assertQuerysetEqual(\n             Tag.objects.exclude(children=None),\n             ['<Tag: t1>', '<Tag: t3>']"
        }
    ],
    "stats": {
        "total": 25,
        "additions": 10,
        "deletions": 15
    }
}