{
    "author": "freakboy3742",
    "message": "Fixed #19384 -- Documented the behavior of custom managers on abstract models.\n\nThis documents the behavior introduced by cc337a74, which is BACKWARDS\nINCOMPATIBLE for any attempt to invoke a method on a manager using the\nabstract class as the calling class (e.g., AbstractBase.objects.do_something())\n\nThanks to mhsparks for the report.",
    "sha": "1b646e656e46909af447056b4f98b9744aae4978",
    "files": [
        {
            "sha": "6ac5120617079b52ae83684a2d1ab5fcf32dd0ba",
            "filename": "docs/releases/1.5.txt",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/django/django/blob/1b646e656e46909af447056b4f98b9744aae4978/docs%2Freleases%2F1.5.txt",
            "raw_url": "https://github.com/django/django/raw/1b646e656e46909af447056b4f98b9744aae4978/docs%2Freleases%2F1.5.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.5.txt?ref=1b646e656e46909af447056b4f98b9744aae4978",
            "patch": "@@ -341,6 +341,21 @@ Backwards incompatible changes in 1.5\n     deprecation timeline for a given feature, its removal may appear as a\n     backwards incompatible change.\n \n+Managers on abstract models\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Abstract models are able to define a custom manager, and that manager\n+:ref:`will be inherited by any concrete models extending the abstract model\n+<custom-managers-and-inheritance>`. However, if you try to use the abstract\n+model to call a method on the manager, an exception will now be raised.\n+Previously, the call would have been permitted, but would have failed as soon\n+as any database operation was attempted (usually with a \"table does not exist\"\n+error from the database).\n+\n+If you have functionality on a manager that you have been invoking using\n+the abstract class, you should migrate that logic to a Python\n+``staticmethod`` or ``classmethod`` on the abstract class.\n+\n Context in year archive class-based views\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "a14616a17c189401f01d9fb67633fb2e9dee9def",
            "filename": "docs/topics/db/managers.txt",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/django/django/blob/1b646e656e46909af447056b4f98b9744aae4978/docs%2Ftopics%2Fdb%2Fmanagers.txt",
            "raw_url": "https://github.com/django/django/raw/1b646e656e46909af447056b4f98b9744aae4978/docs%2Ftopics%2Fdb%2Fmanagers.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Fmanagers.txt?ref=1b646e656e46909af447056b4f98b9744aae4978",
            "patch": "@@ -274,6 +274,21 @@ it into the inheritance hierarchy *after* the defaults::\n         # Default manager is CustomManager, but OtherManager is\n         # also available via the \"extra_manager\" attribute.\n \n+Note that while you can *define* a custom manager on the abstract model, you\n+can't *invoke* any methods using the abstract model. That is::\n+\n+    ClassA.objects.do_something()\n+\n+is legal, but::\n+\n+    AbstractBase.objects.do_something()\n+\n+will raise an exception. This is because managers are intended to encapsulate\n+logic for managing collections of objects. Since you can't have a collection of\n+abstract objects, it doesn't make sense to be managing them. If you have\n+functionality that applies to the abstract model, you should put that functionality\n+in a ``staticmethod`` or ``classmethod`` on the abstract model.\n+\n Implementation concerns\n -----------------------\n "
        }
    ],
    "stats": {
        "total": 30,
        "additions": 30,
        "deletions": 0
    }
}