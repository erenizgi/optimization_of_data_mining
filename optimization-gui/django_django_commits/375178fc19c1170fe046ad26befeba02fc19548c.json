{
    "author": "andrewgodwin",
    "message": "Add M2M repointing",
    "sha": "375178fc19c1170fe046ad26befeba02fc19548c",
    "files": [
        {
            "sha": "bd86d52e8883283eca67266949f5a137d727b7b7",
            "filename": "django/db/backends/schema.py",
            "status": "modified",
            "additions": 22,
            "deletions": 10,
            "changes": 32,
            "blob_url": "https://github.com/django/django/blob/375178fc19c1170fe046ad26befeba02fc19548c/django%2Fdb%2Fbackends%2Fschema.py",
            "raw_url": "https://github.com/django/django/raw/375178fc19c1170fe046ad26befeba02fc19548c/django%2Fdb%2Fbackends%2Fschema.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fschema.py?ref=375178fc19c1170fe046ad26befeba02fc19548c",
            "patch": "@@ -21,7 +21,6 @@ class BaseDatabaseSchemaEditor(object):\n     commit() is called.\n \n     TODO:\n-        - Repointing of M2Ms\n         - Check constraints (PosIntField)\n     \"\"\"\n \n@@ -154,13 +153,13 @@ def effective_default(self, field):\n \n     # Actions\n \n-    def create_model(self, model):\n+    def create_model(self, model, force=False):\n         \"\"\"\n         Takes a model and creates a table for it in the database.\n         Will also create any accompanying indexes or unique constraints.\n         \"\"\"\n         # Do nothing if this is an unmanaged or proxy model\n-        if not model._meta.managed or model._meta.proxy:\n+        if not force and (not model._meta.managed or model._meta.proxy):\n             return\n         # Create column SQL, add FK deferreds if needed\n         column_sqls = []\n@@ -214,13 +213,16 @@ def create_model(self, model):\n             \"definition\": \", \".join(column_sqls)\n         }\n         self.execute(sql, params)\n+        # Make M2M tables\n+        for field in model._meta.local_many_to_many:\n+            self.create_model(field.rel.through, force=True)\n \n-    def delete_model(self, model):\n+    def delete_model(self, model, force=False):\n         \"\"\"\n         Deletes a model from the database.\n         \"\"\"\n         # Do nothing if this is an unmanaged or proxy model\n-        if not model._meta.managed or model._meta.proxy:\n+        if not force and (not model._meta.managed or model._meta.proxy):\n             return\n         # Delete the table\n         self.execute(self.sql_delete_table % {\n@@ -287,7 +289,7 @@ def create_field(self, model, field, keep_default=False):\n         \"\"\"\n         # Special-case implicit M2M tables\n         if isinstance(field, ManyToManyField) and field.rel.through._meta.auto_created:\n-            return self.create_model(field.rel.through)\n+            return self.create_model(field.rel.through, force=True)\n         # Get the column's definition\n         definition, params = self.column_sql(model, field, include_default=True)\n         # It might not actually have a column behind it\n@@ -358,11 +360,10 @@ def alter_field(self, model, old_field, new_field, strict=False):\n         # Ensure this field is even column-based\n         old_type = old_field.db_type(connection=self.connection)\n         new_type = self._type_for_alter(new_field)\n-        if old_type is None and new_type is None:\n-            # TODO: Handle M2M fields being repointed\n-            return\n+        if old_type is None and new_type is None and (old_field.rel.through and new_field.rel.through and old_field.rel.through._meta.auto_created and new_field.rel.through._meta.auto_created):\n+            return self._alter_many_to_many(model, old_field, new_field, strict)\n         elif old_type is None or new_type is None:\n-            raise ValueError(\"Cannot alter field %s into %s - they are not compatible types\" % (\n+            raise ValueError(\"Cannot alter field %s into %s - they are not compatible types (probably means only one is an M2M with implicit through model)\" % (\n                     old_field,\n                     new_field,\n                 ))\n@@ -543,6 +544,17 @@ def alter_field(self, model, old_field, new_field, strict=False):\n                 }\n             )\n \n+    def _alter_many_to_many(self, model, old_field, new_field, strict):\n+        \"Alters M2Ms to repoint their to= endpoints.\"\n+        # Rename the through table\n+        self.alter_db_table(old_field.rel.through, old_field.rel.through._meta.db_table, new_field.rel.through._meta.db_table)\n+        # Repoint the FK to the other side\n+        self.alter_field(\n+            new_field.rel.through,\n+            old_field.rel.through._meta.get_field_by_name(old_field.m2m_reverse_field_name())[0],\n+            new_field.rel.through._meta.get_field_by_name(new_field.m2m_reverse_field_name())[0],\n+        )\n+\n     def _type_for_alter(self, field):\n         \"\"\"\n         Returns a field's type suitable for ALTER COLUMN."
        },
        {
            "sha": "e660f26c875c1e45ddea74fe26d29016b711a11a",
            "filename": "django/db/backends/sqlite3/schema.py",
            "status": "modified",
            "additions": 25,
            "deletions": 4,
            "changes": 29,
            "blob_url": "https://github.com/django/django/blob/375178fc19c1170fe046ad26befeba02fc19548c/django%2Fdb%2Fbackends%2Fsqlite3%2Fschema.py",
            "raw_url": "https://github.com/django/django/raw/375178fc19c1170fe046ad26befeba02fc19548c/django%2Fdb%2Fbackends%2Fsqlite3%2Fschema.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fschema.py?ref=375178fc19c1170fe046ad26befeba02fc19548c",
            "patch": "@@ -101,11 +101,10 @@ def alter_field(self, model, old_field, new_field, strict=False):\n         # Ensure this field is even column-based\n         old_type = old_field.db_type(connection=self.connection)\n         new_type = self._type_for_alter(new_field)\n-        if old_type is None and new_type is None:\n-            # TODO: Handle M2M fields being repointed\n-            return\n+        if old_type is None and new_type is None and (old_field.rel.through and new_field.rel.through and old_field.rel.through._meta.auto_created and new_field.rel.through._meta.auto_created):\n+            return self._alter_many_to_many(model, old_field, new_field, strict)\n         elif old_type is None or new_type is None:\n-            raise ValueError(\"Cannot alter field %s into %s - they are not compatible types\" % (\n+            raise ValueError(\"Cannot alter field %s into %s - they are not compatible types (probably means only one is an M2M with implicit through model)\" % (\n                     old_field,\n                     new_field,\n                 ))\n@@ -114,3 +113,25 @@ def alter_field(self, model, old_field, new_field, strict=False):\n \n     def alter_unique_together(self, model, old_unique_together, new_unique_together):\n         self._remake_table(model, override_uniques=new_unique_together)\n+\n+    def _alter_many_to_many(self, model, old_field, new_field, strict):\n+        \"Alters M2Ms to repoint their to= endpoints.\"\n+        # Make a new through table\n+        self.create_model(new_field.rel.through)\n+        # Copy the data across\n+        self.execute(\"INSERT INTO %s (%s) SELECT %s FROM %s;\" % (\n+            self.quote_name(new_field.rel.through._meta.db_table),\n+            ', '.join([\n+                \"id\",\n+                new_field.m2m_column_name(),\n+                new_field.m2m_reverse_name(),\n+            ]),\n+            ', '.join([\n+                \"id\",\n+                old_field.m2m_column_name(),\n+                old_field.m2m_reverse_name(),\n+            ]),\n+            self.quote_name(old_field.rel.through._meta.db_table),\n+        ))\n+        # Delete the old through table\n+        self.delete_model(old_field.rel.through, force=True)"
        },
        {
            "sha": "76a8cf36877ac8ca107a56bd9ec3c227ef687377",
            "filename": "tests/modeltests/schema/models.py",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/375178fc19c1170fe046ad26befeba02fc19548c/tests%2Fmodeltests%2Fschema%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/375178fc19c1170fe046ad26befeba02fc19548c/tests%2Fmodeltests%2Fschema%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fschema%2Fmodels.py?ref=375178fc19c1170fe046ad26befeba02fc19548c",
            "patch": "@@ -29,6 +29,16 @@ class Meta:\n         managed = False\n \n \n+class BookWithM2M(models.Model):\n+    author = models.ForeignKey(Author)\n+    title = models.CharField(max_length=100, db_index=True)\n+    pub_date = models.DateTimeField()\n+    tags = models.ManyToManyField(\"Tag\", related_name=\"books\")\n+\n+    class Meta:\n+        managed = False\n+\n+\n class BookWithSlug(models.Model):\n     author = models.ForeignKey(Author)\n     title = models.CharField(max_length=100, db_index=True)"
        },
        {
            "sha": "b3fc5d1c80236a02a805a35d6c2023f031f6982d",
            "filename": "tests/modeltests/schema/tests.py",
            "status": "modified",
            "additions": 62,
            "deletions": 2,
            "changes": 64,
            "blob_url": "https://github.com/django/django/blob/375178fc19c1170fe046ad26befeba02fc19548c/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/375178fc19c1170fe046ad26befeba02fc19548c/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fschema%2Ftests.py?ref=375178fc19c1170fe046ad26befeba02fc19548c",
            "patch": "@@ -7,7 +7,7 @@\n from django.db.models.fields import IntegerField, TextField, CharField, SlugField\n from django.db.models.fields.related import ManyToManyField, ForeignKey\n from django.db.models.loading import cache\n-from .models import Author, Book, BookWithSlug, AuthorWithM2M, Tag, TagUniqueRename, UniqueTest\n+from .models import Author, Book, BookWithSlug, BookWithM2M, AuthorWithM2M, Tag, TagUniqueRename, UniqueTest\n \n \n class SchemaTests(TestCase):\n@@ -19,7 +19,7 @@ class SchemaTests(TestCase):\n     as the code it is testing.\n     \"\"\"\n \n-    models = [Author, Book, BookWithSlug, AuthorWithM2M, Tag, TagUniqueRename, UniqueTest]\n+    models = [Author, Book, BookWithSlug, BookWithM2M, AuthorWithM2M, Tag, TagUniqueRename, UniqueTest]\n \n     # Utility functions\n \n@@ -248,6 +248,21 @@ def test_rename(self):\n         self.assertEqual(columns['display_name'][0], \"CharField\")\n         self.assertNotIn(\"name\", columns)\n \n+    def test_m2m_create(self):\n+        \"\"\"\n+        Tests M2M fields on models during creation\n+        \"\"\"\n+        # Create the tables\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.create_model(Author)\n+        editor.create_model(Tag)\n+        editor.create_model(BookWithM2M)\n+        editor.commit()\n+        # Ensure there is now an m2m table there\n+        columns = self.column_classes(BookWithM2M._meta.get_field_by_name(\"tags\")[0].rel.through)\n+        self.assertEqual(columns['tag_id'][0], \"IntegerField\")\n+\n     def test_m2m(self):\n         \"\"\"\n         Tests adding/removing M2M fields on models\n@@ -287,6 +302,51 @@ def test_m2m(self):\n         self.assertRaises(DatabaseError, self.column_classes, new_field.rel.through)\n         connection.rollback()\n \n+    def test_m2m_repoint(self):\n+        \"\"\"\n+        Tests repointing M2M fields\n+        \"\"\"\n+        # Create the tables\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.create_model(Author)\n+        editor.create_model(BookWithM2M)\n+        editor.create_model(Tag)\n+        editor.create_model(UniqueTest)\n+        editor.commit()\n+        # Ensure the M2M exists and points to Tag\n+        constraints = connection.introspection.get_constraints(connection.cursor(), BookWithM2M._meta.get_field_by_name(\"tags\")[0].rel.through._meta.db_table)\n+        if connection.features.supports_foreign_keys:\n+            for name, details in constraints.items():\n+                if details['columns'] == set([\"tag_id\"]) and details['foreign_key']:\n+                    self.assertEqual(details['foreign_key'], ('schema_tag', 'id'))\n+                    break\n+            else:\n+                self.fail(\"No FK constraint for tag_id found\")\n+        # Repoint the M2M\n+        new_field = ManyToManyField(UniqueTest)\n+        new_field.contribute_to_class(BookWithM2M, \"uniques\")\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.alter_field(\n+            Author,\n+            BookWithM2M._meta.get_field_by_name(\"tags\")[0],\n+            new_field,\n+        )\n+        editor.commit()\n+        # Ensure old M2M is gone\n+        self.assertRaises(DatabaseError, self.column_classes, BookWithM2M._meta.get_field_by_name(\"tags\")[0].rel.through)\n+        connection.rollback()\n+        # Ensure the new M2M exists and points to UniqueTest\n+        constraints = connection.introspection.get_constraints(connection.cursor(), new_field.rel.through._meta.db_table)\n+        if connection.features.supports_foreign_keys:\n+            for name, details in constraints.items():\n+                if details['columns'] == set([\"uniquetest_id\"]) and details['foreign_key']:\n+                    self.assertEqual(details['foreign_key'], ('schema_uniquetest', 'id'))\n+                    break\n+            else:\n+                self.fail(\"No FK constraint for tag_id found\")\n+\n     def test_unique(self):\n         \"\"\"\n         Tests removing and adding unique constraints to a single column."
        }
    ],
    "stats": {
        "total": 135,
        "additions": 119,
        "deletions": 16
    }
}