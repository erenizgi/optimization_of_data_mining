{
    "author": "akaariai",
    "message": "Some changes to SortedDict to make it faster under py2\n\nRefs #19276",
    "sha": "fa18b0ac89723f4ed6e46e744039bf375c8945a5",
    "files": [
        {
            "sha": "f81fb88a19907a6be98cc6f8413ba1b3deb6d7b7",
            "filename": "django/utils/datastructures.py",
            "status": "modified",
            "additions": 14,
            "deletions": 19,
            "changes": 33,
            "blob_url": "https://github.com/django/django/blob/fa18b0ac89723f4ed6e46e744039bf375c8945a5/django%2Futils%2Fdatastructures.py",
            "raw_url": "https://github.com/django/django/raw/fa18b0ac89723f4ed6e46e744039bf375c8945a5/django%2Futils%2Fdatastructures.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fdatastructures.py?ref=fa18b0ac89723f4ed6e46e744039bf375c8945a5",
            "patch": "@@ -1,6 +1,5 @@\n import copy\n import warnings\n-from types import GeneratorType\n from django.utils import six\n \n \n@@ -120,27 +119,23 @@ def __new__(cls, *args, **kwargs):\n         return instance\n \n     def __init__(self, data=None):\n-        if data is None:\n-            data = {}\n-        elif isinstance(data, GeneratorType):\n-            # Unfortunately we need to be able to read a generator twice.  Once\n-            # to get the data into self with our super().__init__ call and a\n-            # second time to setup keyOrder correctly\n-            data = list(data)\n-        super(SortedDict, self).__init__(data)\n-        if isinstance(data, dict):\n-            self.keyOrder = list(data)\n+        if data is None or isinstance(data, dict):\n+            data = data or []\n+            super(SortedDict, self).__init__(data)\n+            self.keyOrder = list(data) if data else []\n         else:\n-            self.keyOrder = []\n-            seen = set()\n+            super(SortedDict, self).__init__()\n+            super_set = super(SortedDict, self).__setitem__\n             for key, value in data:\n-                if key not in seen:\n+                # Take the ordering from first key\n+                if key not in self:\n                     self.keyOrder.append(key)\n-                    seen.add(key)\n+                # But override with last value in data (dict() does this)\n+                super_set(key, value)\n \n     def __deepcopy__(self, memo):\n         return self.__class__([(key, copy.deepcopy(value, memo))\n-                               for key, value in six.iteritems(self)])\n+                               for key, value in self.items()])\n \n     def __copy__(self):\n         # The Python's default copy implementation will alter the state\n@@ -199,13 +194,13 @@ def _itervalues(self):\n         itervalues = _itervalues\n \n         def items(self):\n-            return list(self.iteritems())\n+            return [(k, self[k]) for k in self.keyOrder]\n \n         def keys(self):\n-            return list(self.iterkeys())\n+            return self.keyOrder[:]\n \n         def values(self):\n-            return list(self.itervalues())\n+            return [self[k] for k in self.keyOrder]\n \n     def update(self, dict_):\n         for k, v in six.iteritems(dict_):"
        }
    ],
    "stats": {
        "total": 33,
        "additions": 14,
        "deletions": 19
    }
}