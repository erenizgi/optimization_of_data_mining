{
    "author": "adrianholovaty",
    "message": "Improved update() docs in querysets.txt\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16516 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "8b34a010171d728e3e8c26b04ed46fcb386310c4",
    "files": [
        {
            "sha": "68a37ab6fd46279931978e58e12d3495a391cae3",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 55,
            "deletions": 14,
            "changes": 69,
            "blob_url": "https://github.com/django/django/blob/8b34a010171d728e3e8c26b04ed46fcb386310c4/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/8b34a010171d728e3e8c26b04ed46fcb386310c4/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=8b34a010171d728e3e8c26b04ed46fcb386310c4",
            "patch": "@@ -1278,24 +1278,65 @@ update\n .. method:: update(**kwargs)\n \n Performs an SQL update query for the specified fields, and returns\n-the number of rows affected. The ``update()`` method is applied instantly and\n-the only restriction on the :class:`.QuerySet` that is updated is that it can\n-only update columns in the model's main table. Filtering based on related\n-fields is still possible. You cannot call ``update()`` on a\n-:class:`.QuerySet` that has had a slice taken or can otherwise no longer be\n-filtered.\n+the number of rows affected.\n \n-For example, if you wanted to update all the entries in a particular blog\n-to use the same headline::\n+For example, to turn comments off for all blog entries published in 2010,\n+you could do this::\n \n-    >>> b = Blog.objects.get(pk=1)\n+    >>> Entry.objects.filter(pub_date__year=2010).update(comments_on=False)\n+\n+(This assumes your ``Entry`` model has fields ``pub_date`` and ``comments_on``.)\n+\n+You can update multiple fields -- there's no limit on how many. For example,\n+here we update the ``comments_on`` and ``headline`` fields::\n+\n+    >>> Entry.objects.filter(pub_date__year=2010).update(comments_on=False, headline='This is old')\n+\n+The ``update()`` method is applied instantly, and the only restriction on the\n+:class:`.QuerySet` that is updated is that it can only update columns in the\n+model's main table, not on related models. You can't do this, for example::\n+\n+    >>> Entry.objects.update(blog__name='foo') # Won't work!\n+\n+Filtering based on related fields is still possible, though::\n+\n+    >>> Entry.objects.filter(blog__id=1).update(comments_on=True)\n+\n+You cannot call ``update()`` on a :class:`.QuerySet` that has had a slice taken\n+or can otherwise no longer be filtered.\n+\n+The ``update()`` method returns the number of affected rows::\n+\n+    >>> Entry.objects.filter(id=64).update(comments_on=True)\n+    1\n+\n+    >>> Entry.objects.filter(slug='nonexistent-slug').update(comments_on=True)\n+    0\n+\n+    >>> Entry.objects.filter(pub_date__year=2010).update(comments_on=False)\n+    132\n+\n+If you're just updating a record and don't need to do anything with the model\n+object, you should use ``update()`` rather than loading the model object into\n+memory. The former is more efficient. For example, instead of doing this::\n+\n+    e = Entry.objects.get(id=10)\n+    e.comments_on = False\n+    e.save()\n+\n+...do this::\n+\n+    Entry.objects.get(id=10).update(comments_on=False)\n \n-    # Update all the headlines belonging to this Blog.\n-    >>> Entry.objects.select_related().filter(blog=b).update(headline='Everything is the same')\n+Finally, note that the ``update()`` method does an update at the SQL level and,\n+thus, does not call any ``save()`` methods on your models, nor does it emit the\n+``pre_save`` or ``post_save`` signals (which are a consequence of calling\n+``save()``). If you want to update a bunch of records for a model that has a\n+custom ``save()`` method, loop over them and call ``save()``, like this::\n \n-The ``update()`` method does a bulk update and does not call any ``save()``\n-methods on your models, nor does it emit the ``pre_save`` or ``post_save``\n-signals (which are a consequence of calling ``save()``).\n+    for e in Entry.objects.filter(pub_date__year=2010):\n+        e.comments_on = False\n+        e.save()\n \n delete\n ~~~~~~"
        }
    ],
    "stats": {
        "total": 69,
        "additions": 55,
        "deletions": 14
    }
}