{
    "author": "akaariai",
    "message": "Fixed #16679 -- Use caching to speed up signal sending",
    "sha": "704ee33f503c96b96c2682b946a11b3b42318ba7",
    "files": [
        {
            "sha": "2ef54a7ca780a4f91f377985e3171ecb7ca6c42c",
            "filename": "django/db/models/signals.py",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/704ee33f503c96b96c2682b946a11b3b42318ba7/django%2Fdb%2Fmodels%2Fsignals.py",
            "raw_url": "https://github.com/django/django/raw/704ee33f503c96b96c2682b946a11b3b42318ba7/django%2Fdb%2Fmodels%2Fsignals.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsignals.py?ref=704ee33f503c96b96c2682b946a11b3b42318ba7",
            "patch": "@@ -2,15 +2,16 @@\n \n class_prepared = Signal(providing_args=[\"class\"])\n \n-pre_init = Signal(providing_args=[\"instance\", \"args\", \"kwargs\"])\n-post_init = Signal(providing_args=[\"instance\"])\n+pre_init = Signal(providing_args=[\"instance\", \"args\", \"kwargs\"], use_caching=True)\n+post_init = Signal(providing_args=[\"instance\"], use_caching=True)\n \n-pre_save = Signal(providing_args=[\"instance\", \"raw\", \"using\", \"update_fields\"])\n-post_save = Signal(providing_args=[\"instance\", \"raw\", \"created\", \"using\", \"update_fields\"])\n+pre_save = Signal(providing_args=[\"instance\", \"raw\", \"using\", \"update_fields\"],\n+                 use_caching=True)\n+post_save = Signal(providing_args=[\"instance\", \"raw\", \"created\", \"using\", \"update_fields\"], use_caching=True)\n \n-pre_delete = Signal(providing_args=[\"instance\", \"using\"])\n-post_delete = Signal(providing_args=[\"instance\", \"using\"])\n+pre_delete = Signal(providing_args=[\"instance\", \"using\"], use_caching=True)\n+post_delete = Signal(providing_args=[\"instance\", \"using\"], use_caching=True)\n \n-post_syncdb = Signal(providing_args=[\"class\", \"app\", \"created_models\", \"verbosity\", \"interactive\"])\n+post_syncdb = Signal(providing_args=[\"class\", \"app\", \"created_models\", \"verbosity\", \"interactive\"], use_caching=True)\n \n-m2m_changed = Signal(providing_args=[\"action\", \"instance\", \"reverse\", \"model\", \"pk_set\", \"using\"])\n+m2m_changed = Signal(providing_args=[\"action\", \"instance\", \"reverse\", \"model\", \"pk_set\", \"using\"], use_caching=True)"
        },
        {
            "sha": "65c5c408ff2c49560d6c18ffc553a00354eb1b48",
            "filename": "django/dispatch/dispatcher.py",
            "status": "modified",
            "additions": 51,
            "deletions": 22,
            "changes": 73,
            "blob_url": "https://github.com/django/django/blob/704ee33f503c96b96c2682b946a11b3b42318ba7/django%2Fdispatch%2Fdispatcher.py",
            "raw_url": "https://github.com/django/django/raw/704ee33f503c96b96c2682b946a11b3b42318ba7/django%2Fdispatch%2Fdispatcher.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdispatch%2Fdispatcher.py?ref=704ee33f503c96b96c2682b946a11b3b42318ba7",
            "patch": "@@ -10,6 +10,10 @@ def _make_id(target):\n     if hasattr(target, '__func__'):\n         return (id(target.__self__), id(target.__func__))\n     return id(target)\n+NONE_ID = _make_id(None)\n+\n+# A marker for caching\n+NO_RECEIVERS = object()\n \n class Signal(object):\n     \"\"\"\n@@ -20,8 +24,7 @@ class Signal(object):\n         receivers\n             { receriverkey (id) : weakref(receiver) }\n     \"\"\"\n-\n-    def __init__(self, providing_args=None):\n+    def __init__(self, providing_args=None, use_caching=False):\n         \"\"\"\n         Create a new signal.\n \n@@ -33,6 +36,13 @@ def __init__(self, providing_args=None):\n             providing_args = []\n         self.providing_args = set(providing_args)\n         self.lock = threading.Lock()\n+        self.use_caching = use_caching\n+        # For convenience we create empty caches even if they are not used.\n+        # A note about caching: if use_caching is defined, then for each\n+        # distinct sender we cache the receivers that sender has in\n+        # 'sender_receivers_cache'. The cache is cleaned when .connect() or\n+        # .disconnect() is called and populated on send().\n+        self.sender_receivers_cache = {}\n \n     def connect(self, receiver, sender=None, weak=True, dispatch_uid=None):\n         \"\"\"\n@@ -106,6 +116,7 @@ def connect(self, receiver, sender=None, weak=True, dispatch_uid=None):\n                     break\n             else:\n                 self.receivers.append((lookup_key, receiver))\n+            self.sender_receivers_cache = {}\n \n     def disconnect(self, receiver=None, sender=None, weak=True, dispatch_uid=None):\n         \"\"\"\n@@ -140,9 +151,10 @@ def disconnect(self, receiver=None, sender=None, weak=True, dispatch_uid=None):\n                 if r_key == lookup_key:\n                     del self.receivers[index]\n                     break\n+            self.sender_receivers_cache = {}\n \n     def has_listeners(self, sender=None):\n-        return bool(self._live_receivers(_make_id(sender)))\n+        return bool(self._live_receivers(sender))\n \n     def send(self, sender, **named):\n         \"\"\"\n@@ -163,10 +175,10 @@ def send(self, sender, **named):\n         Returns a list of tuple pairs [(receiver, response), ... ].\n         \"\"\"\n         responses = []\n-        if not self.receivers:\n+        if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS:\n             return responses\n \n-        for receiver in self._live_receivers(_make_id(sender)):\n+        for receiver in self._live_receivers(sender):\n             response = receiver(signal=self, sender=sender, **named)\n             responses.append((receiver, response))\n         return responses\n@@ -195,12 +207,12 @@ def send_robust(self, sender, **named):\n         receiver.\n         \"\"\"\n         responses = []\n-        if not self.receivers:\n+        if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS:\n             return responses\n \n         # Call each receiver with whatever arguments it can accept.\n         # Return a list of tuple pairs [(receiver, response), ... ].\n-        for receiver in self._live_receivers(_make_id(sender)):\n+        for receiver in self._live_receivers(sender):\n             try:\n                 response = receiver(signal=self, sender=sender, **named)\n             except Exception as err:\n@@ -209,26 +221,43 @@ def send_robust(self, sender, **named):\n                 responses.append((receiver, response))\n         return responses\n \n-    def _live_receivers(self, senderkey):\n+    def _live_receivers(self, sender):\n         \"\"\"\n         Filter sequence of receivers to get resolved, live receivers.\n \n         This checks for weak references and resolves them, then returning only\n         live receivers.\n         \"\"\"\n-        none_senderkey = _make_id(None)\n-        receivers = []\n-\n-        for (receiverkey, r_senderkey), receiver in self.receivers:\n-            if r_senderkey == none_senderkey or r_senderkey == senderkey:\n-                if isinstance(receiver, WEAKREF_TYPES):\n-                    # Dereference the weak reference.\n-                    receiver = receiver()\n-                    if receiver is not None:\n+        receivers = None\n+        if self.use_caching:\n+            receivers = self.sender_receivers_cache.get(sender)\n+            # We could end up here with NO_RECEIVERS even if we do check this case in\n+            # .send() prior to calling _live_receivers() due to concurrent .send() call.\n+            if receivers is NO_RECEIVERS:\n+                return []\n+        if receivers is None:\n+            with self.lock:\n+                senderkey = _make_id(sender)\n+                receivers = []\n+                for (receiverkey, r_senderkey), receiver in self.receivers:\n+                    if r_senderkey == NONE_ID or r_senderkey == senderkey:\n                         receivers.append(receiver)\n-                else:\n-                    receivers.append(receiver)\n-        return receivers\n+                if self.use_caching:\n+                    if not receivers:\n+                        self.sender_receivers_cache[sender] = NO_RECEIVERS\n+                    else:\n+                        # Note, we must cache the weakref versions.\n+                        self.sender_receivers_cache[sender] = receivers\n+        non_weak_receivers = []\n+        for receiver in receivers:\n+            if isinstance(receiver, WEAKREF_TYPES):\n+                # Dereference the weak reference.\n+                receiver = receiver()\n+                if receiver is not None:\n+                    non_weak_receivers.append(receiver)\n+            else:\n+                non_weak_receivers.append(receiver)\n+        return non_weak_receivers\n \n     def _remove_receiver(self, receiver):\n         \"\"\"\n@@ -246,8 +275,8 @@ def _remove_receiver(self, receiver):\n                 # after we delete some items\n                 for idx, (r_key, _) in enumerate(reversed(self.receivers)):\n                     if r_key == key:\n-                        del self.receivers[last_idx-idx]\n-\n+                        del self.receivers[last_idx - idx]\n+            self.sender_receivers_cache = {}\n \n def receiver(signal, **kwargs):\n     \"\"\""
        }
    ],
    "stats": {
        "total": 90,
        "additions": 60,
        "deletions": 30
    }
}