{
    "author": "malcolmt",
    "message": "Small reorganisation of initial parts of URL documentation.\n\nTrying to move most of the introductory example stuff up to the top and\npushing the reference bits further down.",
    "sha": "6add6170c0aa7c870c4a66f8e33ecde93f7fd975",
    "files": [
        {
            "sha": "4503bbd6ef16f4aee012c59d6513b931738f0644",
            "filename": "docs/topics/http/urls.txt",
            "status": "modified",
            "additions": 52,
            "deletions": 50,
            "changes": 102,
            "blob_url": "https://github.com/django/django/blob/6add6170c0aa7c870c4a66f8e33ecde93f7fd975/docs%2Ftopics%2Fhttp%2Furls.txt",
            "raw_url": "https://github.com/django/django/raw/6add6170c0aa7c870c4a66f8e33ecde93f7fd975/docs%2Ftopics%2Fhttp%2Furls.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fhttp%2Furls.txt?ref=6add6170c0aa7c870c4a66f8e33ecde93f7fd975",
            "patch": "@@ -20,18 +20,18 @@ Overview\n ========\n \n To design URLs for an app, you create a Python module informally called a\n-**URLconf** (URL configuration). This module is pure Python code and\n-is a simple mapping between URL patterns (as simple regular expressions) to\n-Python callback functions (your views).\n+**URLconf** (URL configuration). This module is pure Python code and is a\n+simple mapping between URL patterns (simple regular expressions) to Python\n+functions (your views).\n \n This mapping can be as short or as long as needed. It can reference other\n mappings. And, because it's pure Python code, it can be constructed\n dynamically.\n \n .. versionadded:: 1.4\n-    Django also allows to translate URLs according to the active language.\n-    This process is described in the\n-    :ref:`internationalization docs <url-internationalization>`.\n+    Django also provides a way to translate URLs according to the active\n+    language. See the :ref:`internationalization documentation\n+    <url-internationalization>` for more information.\n \n .. _how-django-processes-a-request:\n \n@@ -154,11 +154,12 @@ The matching/grouping algorithm\n Here's the algorithm the URLconf parser follows, with respect to named groups\n vs. non-named groups in a regular expression:\n \n-If there are any named arguments, it will use those, ignoring non-named arguments.\n-Otherwise, it will pass all non-named arguments as positional arguments.\n+1. If there are any named arguments, it will use those, ignoring non-named\n+   arguments.\n \n-In both cases, it will pass any extra keyword arguments as keyword arguments.\n-See \"Passing extra options to view functions\" below.\n+2. Otherwise, it will pass all non-named arguments as positional arguments.\n+\n+In both cases, any extra keyword arguments that have been given as per `Passing extra options to view functions`_ (below) will also be passed to the view.\n \n What the URLconf searches against\n =================================\n@@ -176,6 +177,44 @@ The URLconf doesn't look at the request method. In other words, all request\n methods -- ``POST``, ``GET``, ``HEAD``, etc. -- will be routed to the same\n function for the same URL.\n \n+Notes on capturing text in URLs\n+===============================\n+\n+Each captured argument is sent to the view as a plain Python string, regardless\n+of what sort of match the regular expression makes. For example, in this\n+URLconf line::\n+\n+    (r'^articles/(?P<year>\\d{4})/$', 'news.views.year_archive'),\n+\n+...the ``year`` argument to ``news.views.year_archive()`` will be a string, not\n+an integer, even though the ``\\d{4}`` will only match integer strings.\n+\n+A convenient trick is to specify default parameters for your views' arguments.\n+Here's an example URLconf and view::\n+\n+    # URLconf\n+    urlpatterns = patterns('',\n+        (r'^blog/$', 'blog.views.page'),\n+        (r'^blog/page(?P<num>\\d+)/$', 'blog.views.page'),\n+    )\n+\n+    # View (in blog/views.py)\n+    def page(request, num=\"1\"):\n+        # Output the appropriate page of blog entries, according to num.\n+\n+In the above example, both URL patterns point to the same view --\n+``blog.views.page`` -- but the first pattern doesn't capture anything from the\n+URL. If the first pattern matches, the ``page()`` function will use its\n+default argument for ``num``, ``\"1\"``. If the second pattern matches,\n+``page()`` will use whatever ``num`` value was captured by the regex.\n+\n+Performance\n+===========\n+\n+Each regular expression in a ``urlpatterns`` is compiled the first time it's\n+accessed. This makes the system blazingly fast.\n+\n+\n Syntax of the urlpatterns variable\n ==================================\n \n@@ -209,10 +248,10 @@ The first argument to ``patterns()`` is a string ``prefix``. See\n \n The remaining arguments should be tuples in this format::\n \n-    (regular expression, Python callback function [, optional dictionary [, optional name]])\n+    (regular expression, Python callback function [, optional_dictionary [, optional_name]])\n \n-...where ``optional dictionary`` and ``optional name`` are optional. (See\n-`Passing extra options to view functions`_ below.)\n+The ``optional_dictionary`` and ``optional_name`` parameters are described in\n+`Passing extra options to view functions`_ below.\n \n .. note::\n     Because `patterns()` is a function call, it accepts a maximum of 255\n@@ -332,43 +371,6 @@ value should suffice.\n See the documentation about :ref:`the 500 (HTTP Internal Server Error) view\n <http_internal_server_error_view>` for more information.\n \n-Notes on capturing text in URLs\n-===============================\n-\n-Each captured argument is sent to the view as a plain Python string, regardless\n-of what sort of match the regular expression makes. For example, in this\n-URLconf line::\n-\n-    (r'^articles/(?P<year>\\d{4})/$', 'news.views.year_archive'),\n-\n-...the ``year`` argument to ``news.views.year_archive()`` will be a string, not\n-an integer, even though the ``\\d{4}`` will only match integer strings.\n-\n-A convenient trick is to specify default parameters for your views' arguments.\n-Here's an example URLconf and view::\n-\n-    # URLconf\n-    urlpatterns = patterns('',\n-        (r'^blog/$', 'blog.views.page'),\n-        (r'^blog/page(?P<num>\\d+)/$', 'blog.views.page'),\n-    )\n-\n-    # View (in blog/views.py)\n-    def page(request, num=\"1\"):\n-        # Output the appropriate page of blog entries, according to num.\n-\n-In the above example, both URL patterns point to the same view --\n-``blog.views.page`` -- but the first pattern doesn't capture anything from the\n-URL. If the first pattern matches, the ``page()`` function will use its\n-default argument for ``num``, ``\"1\"``. If the second pattern matches,\n-``page()`` will use whatever ``num`` value was captured by the regex.\n-\n-Performance\n-===========\n-\n-Each regular expression in a ``urlpatterns`` is compiled the first time it's\n-accessed. This makes the system blazingly fast.\n-\n The view prefix\n ===============\n "
        }
    ],
    "stats": {
        "total": 102,
        "additions": 52,
        "deletions": 50
    }
}