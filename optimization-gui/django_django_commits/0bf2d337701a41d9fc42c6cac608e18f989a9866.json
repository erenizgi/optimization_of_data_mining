{
    "author": "jphalip",
    "message": "Added the ability to specify multiple ports available for the `LiveServerTestCase` WSGI server. This allows multiple processes to run the tests simultaneously and is particularly useful in a continuous integration context. Many thanks to Aymeric Augustin for the suggestions and feedback.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17289 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "0bf2d337701a41d9fc42c6cac608e18f989a9866",
    "files": [
        {
            "sha": "4de4750aeee8d2d981c18952508d05a37edc3f4a",
            "filename": "django/test/testcases.py",
            "status": "modified",
            "additions": 56,
            "deletions": 12,
            "changes": 68,
            "blob_url": "https://github.com/django/django/blob/0bf2d337701a41d9fc42c6cac608e18f989a9866/django%2Ftest%2Ftestcases.py",
            "raw_url": "https://github.com/django/django/raw/0bf2d337701a41d9fc42c6cac608e18f989a9866/django%2Ftest%2Ftestcases.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Ftestcases.py?ref=0bf2d337701a41d9fc42c6cac608e18f989a9866",
            "patch": "@@ -9,6 +9,7 @@\n import select\n import socket\n import threading\n+import errno\n \n from django.conf import settings\n from django.contrib.staticfiles.handlers import StaticFilesHandler\n@@ -17,7 +18,8 @@\n from django.core.handlers.wsgi import WSGIHandler\n from django.core.management import call_command\n from django.core.signals import request_started\n-from django.core.servers.basehttp import (WSGIRequestHandler, WSGIServer)\n+from django.core.servers.basehttp import (WSGIRequestHandler, WSGIServer,\n+    WSGIServerException)\n from django.core.urlresolvers import clear_url_caches\n from django.core.validators import EMPTY_VALUES\n from django.db import (transaction, connection, connections, DEFAULT_DB_ALIAS,\n@@ -877,9 +879,10 @@ class LiveServerThread(threading.Thread):\n     Thread for running a live http server while the tests are running.\n     \"\"\"\n \n-    def __init__(self, address, port, connections_override=None):\n-        self.address = address\n-        self.port = port\n+    def __init__(self, host, possible_ports, connections_override=None):\n+        self.host = host\n+        self.port = None\n+        self.possible_ports = possible_ports\n         self.is_ready = threading.Event()\n         self.error = None\n         self.connections_override = connections_override\n@@ -899,9 +902,33 @@ def run(self):\n         try:\n             # Create the handler for serving static and media files\n             handler = StaticFilesHandler(_MediaFilesHandler(WSGIHandler()))\n-            # Instantiate and start the WSGI server\n-            self.httpd = StoppableWSGIServer(\n-                (self.address, self.port), QuietWSGIRequestHandler)\n+\n+            # Go through the list of possible ports, hoping that we can find\n+            # one that is free to use for the WSGI server.\n+            for index, port in enumerate(self.possible_ports):\n+                try:\n+                    self.httpd = StoppableWSGIServer(\n+                        (self.host, port), QuietWSGIRequestHandler)\n+                except WSGIServerException, e:\n+                    if sys.version_info < (2, 6):\n+                        error_code = e.args[0].args[0]\n+                    else:\n+                        error_code = e.args[0].errno\n+                    if (index + 1 < len(self.possible_ports) and\n+                        error_code == errno.EADDRINUSE):\n+                        # This port is already in use, so we go on and try with\n+                        # the next one in the list.\n+                        continue\n+                    else:\n+                        # Either none of the given ports are free or the error\n+                        # is something else than \"Address already in use\". So\n+                        # we let that error bubble up to the main thread.\n+                        raise\n+                else:\n+                    # A free port was found.\n+                    self.port = port\n+                    break\n+\n             self.httpd.set_app(handler)\n             self.is_ready.set()\n             self.httpd.serve_forever()\n@@ -931,7 +958,8 @@ class LiveServerTestCase(TransactionTestCase):\n \n     @property\n     def live_server_url(self):\n-        return 'http://%s' % self.__test_server_address\n+        return 'http://%s:%s' % (\n+            self.server_thread.host, self.server_thread.port)\n \n     @classmethod\n     def setUpClass(cls):\n@@ -946,15 +974,31 @@ def setUpClass(cls):\n                 connections_override[conn.alias] = conn\n \n         # Launch the live server's thread\n-        cls.__test_server_address = os.environ.get(\n+        specified_address = os.environ.get(\n             'DJANGO_LIVE_TEST_SERVER_ADDRESS', 'localhost:8081')\n+\n+        # The specified ports may be of the form '8000-8010,8080,9200-9300'\n+        # i.e. a comma-separated list of ports or ranges of ports, so we break\n+        # it down into a detailed list of all possible ports.\n+        possible_ports = []\n         try:\n-            host, port = cls.__test_server_address.split(':')\n+            host, port_ranges = specified_address.split(':')\n+            for port_range in port_ranges.split(','):\n+                # A port range can be of either form: '8000' or '8000-8010'.\n+                extremes = map(int, port_range.split('-'))\n+                assert len(extremes) in [1, 2]\n+                if len(extremes) == 1:\n+                    # Port range of the form '8000'\n+                    possible_ports.append(extremes[0])\n+                else:\n+                    # Port range of the form '8000-8010'\n+                    for port in range(extremes[0], extremes[1] + 1):\n+                        possible_ports.append(port)\n         except Exception:\n             raise ImproperlyConfigured('Invalid address (\"%s\") for live '\n-                'server.' % cls.__test_server_address)\n+                'server.' % specified_address)\n         cls.server_thread = LiveServerThread(\n-            host, int(port), connections_override)\n+            host, possible_ports, connections_override)\n         cls.server_thread.daemon = True\n         cls.server_thread.start()\n "
        },
        {
            "sha": "3c25577400c68649b6306f2db763f51bc90cd2be",
            "filename": "docs/topics/testing.txt",
            "status": "modified",
            "additions": 26,
            "deletions": 3,
            "changes": 29,
            "blob_url": "https://github.com/django/django/blob/0bf2d337701a41d9fc42c6cac608e18f989a9866/docs%2Ftopics%2Ftesting.txt",
            "raw_url": "https://github.com/django/django/raw/0bf2d337701a41d9fc42c6cac608e18f989a9866/docs%2Ftopics%2Ftesting.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Ftesting.txt?ref=0bf2d337701a41d9fc42c6cac608e18f989a9866",
            "patch": "@@ -1772,15 +1772,38 @@ simulate a real user's actions.\n By default the live server's address is `'localhost:8081'` and the full URL\n can be accessed during the tests with ``self.live_server_url``. If you'd like\n to change the default address (in the case, for example, where the 8081 port is\n-already taken) you may pass a different one to the :djadmin:`test` command via\n-the :djadminopt:`--liveserver` option, for example:\n+already taken) then you may pass a different one to the :djadmin:`test` command\n+via the :djadminopt:`--liveserver` option, for example:\n \n .. code-block:: bash\n \n     ./manage.py test --liveserver=localhost:8082\n \n Another way of changing the default server address is by setting the\n-`DJANGO_LIVE_TEST_SERVER_ADDRESS` environment variable.\n+`DJANGO_LIVE_TEST_SERVER_ADDRESS` environment variable somewhere in your\n+code (for example in a :ref:`custom test runner<topics-testing-test_runner>`\n+if you're using one):\n+\n+.. code-block:: python\n+\n+    import os\n+    os.environ['DJANGO_LIVE_TEST_SERVER_ADDRESS'] = 'localhost:8082'\n+\n+In the case where the tests are run by multiple processes in parallel (for\n+example in the context of several simultaneous `continuous integration`_\n+builds), the processes will compete for the same address and therefore your\n+tests might randomly fail with an \"Address already in use\" error. To avoid this\n+problem, you can pass a comma-separated list of ports or ranges of ports (at\n+least as many as the number of potential parallel processes), for example:\n+\n+.. code-block:: bash\n+\n+    ./manage.py test --liveserver=localhost:8082,8090-8100,9000-9200,7041\n+\n+Then, during the execution of the tests, each new live test server will try\n+every specified port until it finds one that is free and takes it.\n+\n+.. _continuous integration: http://en.wikipedia.org/wiki/Continuous_integration\n \n To demonstrate how to use ``LiveServerTestCase``, let's write a simple Selenium\n test. First of all, you need to install the `selenium package`_ into your"
        },
        {
            "sha": "d237c83c659ee069cf3c61a6a93e3a3c14923d58",
            "filename": "tests/regressiontests/servers/tests.py",
            "status": "modified",
            "additions": 20,
            "deletions": 22,
            "changes": 42,
            "blob_url": "https://github.com/django/django/blob/0bf2d337701a41d9fc42c6cac608e18f989a9866/tests%2Fregressiontests%2Fservers%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/0bf2d337701a41d9fc42c6cac608e18f989a9866/tests%2Fregressiontests%2Fservers%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fservers%2Ftests.py?ref=0bf2d337701a41d9fc42c6cac608e18f989a9866",
            "patch": "@@ -101,10 +101,7 @@ def tearDownClass(cls):\n         super(LiveServerBase, cls).tearDownClass()\n \n     def urlopen(self, url):\n-        server_address = os.environ.get(\n-            'DJANGO_LIVE_TEST_SERVER_ADDRESS', 'localhost:8081')\n-        base = 'http://%s' % server_address\n-        return urllib2.urlopen(base + url)\n+        return urllib2.urlopen(self.live_server_url + url)\n \n \n class LiveServerAddress(LiveServerBase):\n@@ -120,31 +117,23 @@ def setUpClass(cls):\n         old_address = os.environ.get('DJANGO_LIVE_TEST_SERVER_ADDRESS')\n \n         # Just the host is not accepted\n-        os.environ['DJANGO_LIVE_TEST_SERVER_ADDRESS'] = 'localhost'\n-        try:\n-            super(LiveServerAddress, cls).setUpClass()\n-            raise Exception(\"The line above should have raised an exception\")\n-        except ImproperlyConfigured:\n-            pass\n+        cls.raises_exception('localhost', ImproperlyConfigured)\n \n         # The host must be valid\n-        os.environ['DJANGO_LIVE_TEST_SERVER_ADDRESS'] = 'blahblahblah:8081'\n-        try:\n-            super(LiveServerAddress, cls).setUpClass()\n-            raise Exception(\"The line above should have raised an exception\")\n-        except WSGIServerException:\n-            pass\n+        cls.raises_exception('blahblahblah:8081', WSGIServerException)\n+\n+        # The list of ports must be in a valid format\n+        cls.raises_exception('localhost:8081,', ImproperlyConfigured)\n+        cls.raises_exception('localhost:8081,blah', ImproperlyConfigured)\n+        cls.raises_exception('localhost:8081-', ImproperlyConfigured)\n+        cls.raises_exception('localhost:8081-blah', ImproperlyConfigured)\n+        cls.raises_exception('localhost:8081-8082-8083', ImproperlyConfigured)\n \n         # If contrib.staticfiles isn't configured properly, the exception\n         # should bubble up to the main thread.\n         old_STATIC_URL = TEST_SETTINGS['STATIC_URL']\n         TEST_SETTINGS['STATIC_URL'] = None\n-        os.environ['DJANGO_LIVE_TEST_SERVER_ADDRESS'] = 'localhost:8081'\n-        try:\n-            super(LiveServerAddress, cls).setUpClass()\n-            raise Exception(\"The line above should have raised an exception\")\n-        except ImproperlyConfigured:\n-            pass\n+        cls.raises_exception('localhost:8081', ImproperlyConfigured)\n         TEST_SETTINGS['STATIC_URL'] = old_STATIC_URL\n \n         # Restore original environment variable\n@@ -153,6 +142,15 @@ def setUpClass(cls):\n         else:\n             del os.environ['DJANGO_LIVE_TEST_SERVER_ADDRESS']\n \n+    @classmethod\n+    def raises_exception(cls, address, exception):\n+        os.environ['DJANGO_LIVE_TEST_SERVER_ADDRESS'] = address\n+        try:\n+            super(LiveServerAddress, cls).setUpClass()\n+            raise Exception(\"The line above should have raised an exception\")\n+        except exception:\n+            pass\n+\n     def test_test_test(self):\n         # Intentionally empty method so that the test is picked up by the\n         # test runner and the overriden setUpClass() method is executed."
        }
    ],
    "stats": {
        "total": 139,
        "additions": 102,
        "deletions": 37
    }
}