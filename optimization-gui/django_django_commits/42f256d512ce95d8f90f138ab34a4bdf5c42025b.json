{
    "author": "ramiro",
    "message": "Removed unused files from under django.utils.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16595 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "42f256d512ce95d8f90f138ab34a4bdf5c42025b",
    "files": [
        {
            "sha": "9225d01e638e019139ca2dff956761a8fbfdf559",
            "filename": "django/utils/_threading_local.py",
            "status": "removed",
            "additions": 0,
            "deletions": 240,
            "changes": 240,
            "blob_url": "https://github.com/django/django/blob/1d32bdd3c9586ff10d0799264105850fa7e3f512/django%2Futils%2F_threading_local.py",
            "raw_url": "https://github.com/django/django/raw/1d32bdd3c9586ff10d0799264105850fa7e3f512/django%2Futils%2F_threading_local.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2F_threading_local.py?ref=1d32bdd3c9586ff10d0799264105850fa7e3f512",
            "patch": "@@ -1,240 +0,0 @@\n-\"\"\"Thread-local objects\n-\n-(Note that this module provides a Python version of thread\n- threading.local class.  Depending on the version of Python you're\n- using, there may be a faster one available.  You should always import\n- the local class from threading.)\n-\n-Thread-local objects support the management of thread-local data.\n-If you have data that you want to be local to a thread, simply create\n-a thread-local object and use its attributes:\n-\n-  >>> mydata = local()\n-  >>> mydata.number = 42\n-  >>> mydata.number\n-  42\n-\n-You can also access the local-object's dictionary:\n-\n-  >>> mydata.__dict__\n-  {'number': 42}\n-  >>> mydata.__dict__.setdefault('widgets', [])\n-  []\n-  >>> mydata.widgets\n-  []\n-\n-What's important about thread-local objects is that their data are\n-local to a thread. If we access the data in a different thread:\n-\n-  >>> log = []\n-  >>> def f():\n-  ...     items = mydata.__dict__.items()\n-  ...     items.sort()\n-  ...     log.append(items)\n-  ...     mydata.number = 11\n-  ...     log.append(mydata.number)\n-\n-  >>> import threading\n-  >>> thread = threading.Thread(target=f)\n-  >>> thread.start()\n-  >>> thread.join()\n-  >>> log\n-  [[], 11]\n-\n-we get different data.  Furthermore, changes made in the other thread\n-don't affect data seen in this thread:\n-\n-  >>> mydata.number\n-  42\n-\n-Of course, values you get from a local object, including a __dict__\n-attribute, are for whatever thread was current at the time the\n-attribute was read.  For that reason, you generally don't want to save\n-these values across threads, as they apply only to the thread they\n-came from.\n-\n-You can create custom local objects by subclassing the local class:\n-\n-  >>> class MyLocal(local):\n-  ...     number = 2\n-  ...     initialized = False\n-  ...     def __init__(self, **kw):\n-  ...         if self.initialized:\n-  ...             raise SystemError('__init__ called too many times')\n-  ...         self.initialized = True\n-  ...         self.__dict__.update(kw)\n-  ...     def squared(self):\n-  ...         return self.number ** 2\n-\n-This can be useful to support default values, methods and\n-initialization.  Note that if you define an __init__ method, it will be\n-called each time the local object is used in a separate thread.  This\n-is necessary to initialize each thread's dictionary.\n-\n-Now if we create a local object:\n-\n-  >>> mydata = MyLocal(color='red')\n-\n-Now we have a default number:\n-\n-  >>> mydata.number\n-  2\n-\n-an initial color:\n-\n-  >>> mydata.color\n-  'red'\n-  >>> del mydata.color\n-\n-And a method that operates on the data:\n-\n-  >>> mydata.squared()\n-  4\n-\n-As before, we can access the data in a separate thread:\n-\n-  >>> log = []\n-  >>> thread = threading.Thread(target=f)\n-  >>> thread.start()\n-  >>> thread.join()\n-  >>> log\n-  [[('color', 'red'), ('initialized', True)], 11]\n-\n-without affecting this thread's data:\n-\n-  >>> mydata.number\n-  2\n-  >>> mydata.color\n-  Traceback (most recent call last):\n-  ...\n-  AttributeError: 'MyLocal' object has no attribute 'color'\n-\n-Note that subclasses can define slots, but they are not thread\n-local. They are shared across threads:\n-\n-  >>> class MyLocal(local):\n-  ...     __slots__ = 'number'\n-\n-  >>> mydata = MyLocal()\n-  >>> mydata.number = 42\n-  >>> mydata.color = 'red'\n-\n-So, the separate thread:\n-\n-  >>> thread = threading.Thread(target=f)\n-  >>> thread.start()\n-  >>> thread.join()\n-\n-affects what we see:\n-\n-  >>> mydata.number\n-  11\n-\n->>> del mydata\n-\"\"\"\n-\n-# Threading import is at end\n-\n-class _localbase(object):\n-    __slots__ = '_local__key', '_local__args', '_local__lock'\n-\n-    def __new__(cls, *args, **kw):\n-        self = object.__new__(cls)\n-        key = '_local__key', 'thread.local.' + str(id(self))\n-        object.__setattr__(self, '_local__key', key)\n-        object.__setattr__(self, '_local__args', (args, kw))\n-        object.__setattr__(self, '_local__lock', RLock())\n-\n-        if (args or kw) and (cls.__init__ is object.__init__):\n-            raise TypeError(\"Initialization arguments are not supported\")\n-\n-        # We need to create the thread dict in anticipation of\n-        # __init__ being called, to make sure we don't call it\n-        # again ourselves.\n-        dict = object.__getattribute__(self, '__dict__')\n-        currentThread().__dict__[key] = dict\n-\n-        return self\n-\n-def _patch(self):\n-    key = object.__getattribute__(self, '_local__key')\n-    d = currentThread().__dict__.get(key)\n-    if d is None:\n-        d = {}\n-        currentThread().__dict__[key] = d\n-        object.__setattr__(self, '__dict__', d)\n-\n-        # we have a new instance dict, so call out __init__ if we have\n-        # one\n-        cls = type(self)\n-        if cls.__init__ is not object.__init__:\n-            args, kw = object.__getattribute__(self, '_local__args')\n-            cls.__init__(self, *args, **kw)\n-    else:\n-        object.__setattr__(self, '__dict__', d)\n-\n-class local(_localbase):\n-\n-    def __getattribute__(self, name):\n-        lock = object.__getattribute__(self, '_local__lock')\n-        lock.acquire()\n-        try:\n-            _patch(self)\n-            return object.__getattribute__(self, name)\n-        finally:\n-            lock.release()\n-\n-    def __setattr__(self, name, value):\n-        lock = object.__getattribute__(self, '_local__lock')\n-        lock.acquire()\n-        try:\n-            _patch(self)\n-            return object.__setattr__(self, name, value)\n-        finally:\n-            lock.release()\n-\n-    def __delattr__(self, name):\n-        lock = object.__getattribute__(self, '_local__lock')\n-        lock.acquire()\n-        try:\n-            _patch(self)\n-            return object.__delattr__(self, name)\n-        finally:\n-            lock.release()\n-\n-\n-    def __del__():\n-        threading_enumerate = enumerate\n-        __getattribute__ = object.__getattribute__\n-\n-        def __del__(self):\n-            key = __getattribute__(self, '_local__key')\n-\n-            try:\n-                threads = list(threading_enumerate())\n-            except:\n-                # if enumerate fails, as it seems to do during\n-                # shutdown, we'll skip cleanup under the assumption\n-                # that there is nothing to clean up\n-                return\n-\n-            for thread in threads:\n-                try:\n-                    __dict__ = thread.__dict__\n-                except AttributeError:\n-                    # Thread is dying, rest in peace\n-                    continue\n-\n-                if key in __dict__:\n-                    try:\n-                        del __dict__[key]\n-                    except KeyError:\n-                        pass # didn't have anything in this thread\n-\n-        return __del__\n-    __del__ = __del__()\n-\n-try:\n-    from threading import currentThread, enumerate, RLock\n-except ImportError:\n-    from dummy_threading import currentThread, enumerate, RLock"
        },
        {
            "sha": "18aeb7f5d3898b9e8b19cfe57f51692a1de13396",
            "filename": "django/utils/stopwords.py",
            "status": "removed",
            "additions": 0,
            "deletions": 42,
            "changes": 42,
            "blob_url": "https://github.com/django/django/blob/1d32bdd3c9586ff10d0799264105850fa7e3f512/django%2Futils%2Fstopwords.py",
            "raw_url": "https://github.com/django/django/raw/1d32bdd3c9586ff10d0799264105850fa7e3f512/django%2Futils%2Fstopwords.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fstopwords.py?ref=1d32bdd3c9586ff10d0799264105850fa7e3f512",
            "patch": "@@ -1,42 +0,0 @@\n-# Performance note: I benchmarked this code using a set instead of\n-# a list for the stopwords and was surprised to find that the list\n-# performed /better/ than the set - maybe because it's only a small\n-# list.\n-\n-stopwords = '''\n-i\n-a\n-an\n-are\n-as\n-at\n-be\n-by\n-for\n-from\n-how\n-in\n-is\n-it\n-of\n-on\n-or\n-that\n-the\n-this\n-to\n-was\n-what\n-when\n-where\n-'''.split()\n-\n-def strip_stopwords(sentence):\n-    \"Removes stopwords - also normalizes whitespace\"\n-    words = sentence.split()\n-    sentence = []\n-    for word in words:\n-        if word.lower() not in stopwords:\n-            sentence.append(word)\n-    return u' '.join(sentence)\n-"
        }
    ],
    "stats": {
        "total": 282,
        "additions": 0,
        "deletions": 282
    }
}