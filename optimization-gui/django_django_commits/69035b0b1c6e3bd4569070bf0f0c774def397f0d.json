{
    "author": "ramiro",
    "message": "More URL mapping documentation fixes.",
    "sha": "69035b0b1c6e3bd4569070bf0f0c774def397f0d",
    "files": [
        {
            "sha": "b9a0199984a06a3aec990adb113bfbe3c4575945",
            "filename": "docs/ref/urls.txt",
            "status": "modified",
            "additions": 26,
            "deletions": 9,
            "changes": 35,
            "blob_url": "https://github.com/django/django/blob/69035b0b1c6e3bd4569070bf0f0c774def397f0d/docs%2Fref%2Furls.txt",
            "raw_url": "https://github.com/django/django/raw/69035b0b1c6e3bd4569070bf0f0c774def397f0d/docs%2Fref%2Furls.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Furls.txt?ref=69035b0b1c6e3bd4569070bf0f0c774def397f0d",
            "patch": "@@ -80,15 +80,32 @@ The ``prefix`` parameter has the same meaning as the first argument to\n include()\n ---------\n \n-.. function:: include(<module or pattern_list>)\n-\n-A function that takes a full Python import path to another URLconf module that\n-should be \"included\" in this place.\n-\n-:func:`include` also accepts as an argument an iterable that returns URL\n-patterns.\n-\n-See :ref:`Including other URLconfs <including-other-urlconfs>`.\n+.. function:: include(module[, namespace=None, app_name=None])\n+              include(pattern_list)\n+              include((pattern_list, app_namespace, instance_namespace))\n+\n+    A function that takes a full Python import path to another URLconf module\n+    that should be \"included\" in this place. Optionally, the :term:`application\n+    namespace` and :term:`instance namespace` where the entries will be included\n+    into can also be specified.\n+\n+    ``include()`` also accepts as an argument either an iterable that returns\n+    URL patterns or a 3-tuple containing such iterable plus the names of the\n+    application and instance namespaces.\n+\n+    :arg module: URLconf module (or module name)\n+    :type module: Module or string\n+    :arg namespace: Instance namespace for the URL entries being included\n+    :type namespace: string\n+    :arg app_name: Application namespace for the URL entries being included\n+    :type app_name: string\n+    :arg pattern_list: Iterable of URL entries as returned by :func:`patterns`\n+    :arg app_namespace: Application namespace for the URL entries being included\n+    :type app_namespace: string\n+    :arg instance_namespace: Instance namespace for the URL entries being included\n+    :type instance_namespace: string\n+\n+See :ref:`including-other-urlconfs` and :ref:`namespaces-and-include`.\n \n handler403\n ----------"
        },
        {
            "sha": "d7b3b03d84668108172608458df1003755b57498",
            "filename": "docs/topics/http/urls.txt",
            "status": "modified",
            "additions": 58,
            "deletions": 52,
            "changes": 110,
            "blob_url": "https://github.com/django/django/blob/69035b0b1c6e3bd4569070bf0f0c774def397f0d/docs%2Ftopics%2Fhttp%2Furls.txt",
            "raw_url": "https://github.com/django/django/raw/69035b0b1c6e3bd4569070bf0f0c774def397f0d/docs%2Ftopics%2Fhttp%2Furls.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fhttp%2Furls.txt?ref=69035b0b1c6e3bd4569070bf0f0c774def397f0d",
            "patch": "@@ -327,7 +327,7 @@ essentially \"roots\" a set of URLs below other ones.\n For example, here's an excerpt of the URLconf for the `Django Web site`_\n itself. It includes a number of other URLconfs::\n \n-    from django.conf.urls import patterns, url, include\n+    from django.conf.urls import patterns, include\n \n     urlpatterns = patterns('',\n         # ... snip ...\n@@ -347,28 +347,23 @@ string to the included URLconf for further processing.\n Another possibility is to include additional URL patterns not by specifying the\n URLconf Python module defining them as the ``include()`` argument but by using\n directly the pattern list as returned by :func:`~django.conf.urls.patterns`\n-instead. For example::\n+instead. For example, consider this URLconf::\n \n     from django.conf.urls import patterns, url, include\n \n     extra_patterns = patterns('',\n-        url(r'^reports/(?P<id>\\d+)/$', 'credit.views.report', name='credit-reports'),\n-        url(r'^charge/$', 'credit.views.charge', name='credit-charge'),\n+        url(r'^reports/(?P<id>\\d+)/$', 'credit.views.report'),\n+        url(r'^charge/$', 'credit.views.charge'),\n     )\n \n     urlpatterns = patterns('',\n-        url(r'^$', 'apps.main.views.homepage', name='site-homepage'),\n+        url(r'^$', 'apps.main.views.homepage'),\n         (r'^help/', include('apps.help.urls')),\n         (r'^credit/', include(extra_patterns)),\n     )\n \n-This approach can be seen in use when you deploy an instance of the Django\n-Admin application. The Django Admin is deployed as instances of a\n-:class:`~django.contrib.admin.AdminSite`; each\n-:class:`~django.contrib.admin.AdminSite` instance has an attribute ``urls``\n-that returns the url patterns available to that instance. It is this attribute\n-that you ``include()`` into your projects ``urlpatterns`` when you deploy the\n-admin instance.\n+In this example, the ``/credit/reports/`` URL will be handled by the\n+``credit.views.report()`` Django view.\n \n .. _`Django Web site`: https://www.djangoproject.com/\n \n@@ -595,33 +590,33 @@ A URL namespace comes in two parts, both of which are strings:\n     This describes the name of the application that is being deployed. Every\n     instance of a single application will have the same application namespace.\n     For example, Django's admin application has the somewhat predictable\n-    application namespace of ``admin``.\n+    application namespace of ``'admin'``.\n \n   instance namespace\n     This identifies a specific instance of an application. Instance namespaces\n     should be unique across your entire project. However, an instance namespace\n     can be the same as the application namespace. This is used to specify a\n     default instance of an application. For example, the default Django Admin\n-    instance has an instance namespace of ``admin``.\n+    instance has an instance namespace of ``'admin'``.\n \n-Namespaced URLs are specified using the ``:`` operator. For example, the main\n-index page of the admin application is referenced using ``admin:index``. This\n-indicates a namespace of ``admin``, and a named URL of ``index``.\n+Namespaced URLs are specified using the ``':'`` operator. For example, the main\n+index page of the admin application is referenced using ``'admin:index'``. This\n+indicates a namespace of ``'admin'``, and a named URL of ``'index'``.\n \n-Namespaces can also be nested. The named URL ``foo:bar:whiz`` would look for\n-a pattern named ``whiz`` in the namespace ``bar`` that is itself defined within\n-the top-level namespace ``foo``.\n+Namespaces can also be nested. The named URL ``'foo:bar:whiz'`` would look for\n+a pattern named ``'whiz'`` in the namespace ``'bar'`` that is itself defined\n+within the top-level namespace ``'foo'``.\n \n .. _topics-http-reversing-url-namespaces:\n \n Reversing namespaced URLs\n -------------------------\n \n-When given a namespaced URL (e.g. ``myapp:index``) to resolve, Django splits\n+When given a namespaced URL (e.g. ``'myapp:index'``) to resolve, Django splits\n the fully qualified name into parts, and then tries the following lookup:\n \n-1. First, Django looks for a matching application namespace (in this\n-   example, ``myapp``). This will yield a list of instances of that\n+1. First, Django looks for a matching :term:`application namespace` (in this\n+   example, ``'myapp'``). This will yield a list of instances of that\n    application.\n \n 2. If there is a *current* application defined, Django finds and returns\n@@ -632,19 +627,20 @@ the fully qualified name into parts, and then tries the following lookup:\n    render a template.\n \n    The current application can also be specified manually as an argument\n-   to the :func:`reverse()` function.\n+   to the :func:`django.core.urlresolvers.reverse()` function.\n \n 3. If there is no current application. Django looks for a default\n    application instance. The default application instance is the instance\n-   that has an instance namespace matching the application namespace (in\n-   this example, an instance of the ``myapp`` called ``myapp``).\n+   that has an :term:`instance namespace` matching the :term:`application\n+   namespace` (in this example, an instance of the ``myapp`` called\n+   ``'myapp'``).\n \n 4. If there is no default application instance, Django will pick the last\n    deployed instance of the application, whatever its instance name may be.\n \n-5. If the provided namespace doesn't match an application namespace in\n+5. If the provided namespace doesn't match an :term:`application namespace` in\n    step 1, Django will attempt a direct lookup of the namespace as an\n-   instance namespace.\n+   :term:`instance namespace`.\n \n If there are nested namespaces, these steps are repeated for each part of the\n namespace until only the view name is unresolved. The view name will then be\n@@ -654,58 +650,68 @@ Example\n ~~~~~~~\n \n To show this resolution strategy in action, consider an example of two instances\n-of ``myapp``: one called ``foo``, and one called ``bar``. ``myapp`` has a main\n-index page with a URL named `index`. Using this setup, the following lookups are\n-possible:\n+of ``myapp``: one called ``'foo'``, and one called ``'bar'``. ``myapp`` has a\n+main index page with a URL named ``'index'``. Using this setup, the following\n+lookups are possible:\n \n * If one of the instances is current - say, if we were rendering a utility page\n-  in the instance ``bar`` - ``myapp:index`` will resolve to the index page of\n-  the instance ``bar``.\n+  in the instance ``'bar'`` - ``'myapp:index'`` will resolve to the index page\n+  of the instance ``'bar'``.\n \n * If there is no current instance - say, if we were rendering a page\n-  somewhere else on the site - ``myapp:index`` will resolve to the last\n+  somewhere else on the site - ``'myapp:index'`` will resolve to the last\n   registered instance of ``myapp``. Since there is no default instance,\n   the last instance of ``myapp`` that is registered will be used. This could\n-  be ``foo`` or ``bar``, depending on the order they are introduced into the\n+  be ``'foo'`` or ``'bar'``, depending on the order they are introduced into the\n   urlpatterns of the project.\n \n-* ``foo:index`` will always resolve to the index page of the instance ``foo``.\n+* ``'foo:index'`` will always resolve to the index page of the instance\n+  ``'foo'``.\n \n-If there was also a default instance - i.e., an instance named `myapp` - the\n+If there was also a default instance - i.e., an instance named ``'myapp'`` - the\n following would happen:\n \n * If one of the instances is current - say, if we were rendering a utility page\n-  in the instance ``bar`` - ``myapp:index`` will resolve to the index page of\n-  the instance ``bar``.\n+  in the instance ``'bar'`` - ``'myapp:index'`` will resolve to the index page\n+  of the instance ``'bar'``.\n \n * If there is no current instance - say, if we were rendering a page somewhere\n-  else on the site - ``myapp:index`` will resolve to the index page of the\n+  else on the site - ``'myapp:index'`` will resolve to the index page of the\n   default instance.\n \n-* ``foo:index`` will again resolve to the index page of the instance ``foo``.\n+* ``'foo:index'`` will again resolve to the index page of the instance\n+  ``'foo'``.\n+\n+.. _namespaces-and-include:\n \n URL namespaces and included URLconfs\n ------------------------------------\n \n URL namespaces of included URLconfs can be specified in two ways.\n \n-Firstly, you can provide the application and instance namespace as arguments\n-to ``include()`` when you construct your URL patterns. For example,::\n+Firstly, you can provide the application and :term:`instance namespace` as\n+arguments to :func:`django.conf.urls.include()` when you construct your URL\n+patterns. For example,::\n \n     (r'^help/', include('apps.help.urls', namespace='foo', app_name='bar')),\n \n-This will include the URLs defined in ``apps.help.urls`` into the application\n-namespace ``bar``, with the instance namespace ``foo``.\n+This will include the URLs defined in ``apps.help.urls`` into the\n+:term:`application namespace` ``'bar'``, with the :term:`instance namespace`\n+``'foo'``.\n \n Secondly, you can include an object that contains embedded namespace data. If\n-you ``include()`` a ``patterns`` object, that object will be added to the\n-global namespace. However, you can also ``include()`` an object that contains\n-a 3-tuple containing::\n+you ``include()`` an object as returned by :func:`~django.conf.urls.patterns`,\n+the URLs contained in that object will be added to the global namespace.\n+However, you can also ``include()`` a 3-tuple containing::\n \n     (<patterns object>, <application namespace>, <instance namespace>)\n \n This will include the nominated URL patterns into the given application and\n-instance namespace. For example, the ``urls`` attribute of Django's\n-:class:`~django.contrib.admin.AdminSite` object returns a 3-tuple that contains\n-all the patterns in an admin site, plus the name of the admin instance, and the\n-application namespace ``admin``.\n+instance namespace.\n+\n+For example, the Django Admin is deployed as instances of\n+:class:`~django.contrib.admin.AdminSite`.  ``AdminSite`` objects have a ``urls``\n+attribute: A 3-tuple that contains all the patterns in the corresponding admin\n+site, plus the application namespace ``'admin'``, and the name of the admin\n+instance. It is this ``urls`` attribute that you ``include()`` into your\n+projects ``urlpatterns`` when you deploy an Admin instance."
        }
    ],
    "stats": {
        "total": 145,
        "additions": 84,
        "deletions": 61
    }
}