{
    "author": "aaugustin",
    "message": "[py3] Updated dict-like data structures for Python 3.\n\nThe keys/items/values methods return iterators in Python 3, and the\niterkeys/items/values methods don't exist in Python 3. The behavior\nunder Python 2 is unchanged.",
    "sha": "ab6cd1c839b136cbc94178da433b2e97ab7f6061",
    "files": [
        {
            "sha": "bbd31ad36cfa7bf80cb3e59db5216db3c24963c0",
            "filename": "django/utils/datastructures.py",
            "status": "modified",
            "additions": 80,
            "deletions": 55,
            "changes": 135,
            "blob_url": "https://github.com/django/django/blob/ab6cd1c839b136cbc94178da433b2e97ab7f6061/django%2Futils%2Fdatastructures.py",
            "raw_url": "https://github.com/django/django/raw/ab6cd1c839b136cbc94178da433b2e97ab7f6061/django%2Futils%2Fdatastructures.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fdatastructures.py?ref=ab6cd1c839b136cbc94178da433b2e97ab7f6061",
            "patch": "@@ -1,6 +1,7 @@\n import copy\n import warnings\n from types import GeneratorType\n+from django.utils import six\n \n \n class MergeDict(object):\n@@ -31,38 +32,48 @@ def get(self, key, default=None):\n         except KeyError:\n             return default\n \n+    # This is used by MergeDicts of MultiValueDicts.\n     def getlist(self, key):\n         for dict_ in self.dicts:\n-            if key in dict_.keys():\n+            if key in dict_:\n                 return dict_.getlist(key)\n         return []\n \n-    def iteritems(self):\n+    def _iteritems(self):\n         seen = set()\n         for dict_ in self.dicts:\n-            for item in dict_.iteritems():\n-                k, v = item\n+            for item in six.iteritems(dict_):\n+                k = item[0]\n                 if k in seen:\n                     continue\n                 seen.add(k)\n                 yield item\n \n-    def iterkeys(self):\n-        for k, v in self.iteritems():\n+    def _iterkeys(self):\n+        for k, v in self._iteritems():\n             yield k\n \n-    def itervalues(self):\n-        for k, v in self.iteritems():\n+    def _itervalues(self):\n+        for k, v in self._iteritems():\n             yield v\n \n-    def items(self):\n-        return list(self.iteritems())\n+    if six.PY3:\n+        items = _iteritems\n+        keys = _iterkeys\n+        values = _itervalues\n+    else:\n+        iteritems = _iteritems\n+        iterkeys = _iterkeys\n+        itervalues = _itervalues\n+\n+        def items(self):\n+            return list(self.iteritems())\n \n-    def keys(self):\n-        return list(self.iterkeys())\n+        def keys(self):\n+            return list(self.iterkeys())\n \n-    def values(self):\n-        return list(self.itervalues())\n+        def values(self):\n+            return list(self.itervalues())\n \n     def has_key(self, key):\n         for dict_ in self.dicts:\n@@ -71,7 +82,8 @@ def has_key(self, key):\n         return False\n \n     __contains__ = has_key\n-    __iter__ = iterkeys\n+\n+    __iter__ = _iterkeys\n \n     def copy(self):\n         \"\"\"Returns a copy of this object.\"\"\"\n@@ -117,7 +129,7 @@ def __init__(self, data=None):\n             data = list(data)\n         super(SortedDict, self).__init__(data)\n         if isinstance(data, dict):\n-            self.keyOrder = data.keys()\n+            self.keyOrder = list(six.iterkeys(data))\n         else:\n             self.keyOrder = []\n             seen = set()\n@@ -128,7 +140,7 @@ def __init__(self, data=None):\n \n     def __deepcopy__(self, memo):\n         return self.__class__([(key, copy.deepcopy(value, memo))\n-                               for key, value in self.iteritems()])\n+                               for key, value in six.iteritems(self)])\n \n     def __copy__(self):\n         # The Python's default copy implementation will alter the state\n@@ -162,28 +174,38 @@ def popitem(self):\n         self.keyOrder.remove(result[0])\n         return result\n \n-    def items(self):\n-        return zip(self.keyOrder, self.values())\n-\n-    def iteritems(self):\n+    def _iteritems(self):\n         for key in self.keyOrder:\n             yield key, self[key]\n \n-    def keys(self):\n-        return self.keyOrder[:]\n-\n-    def iterkeys(self):\n-        return iter(self.keyOrder)\n-\n-    def values(self):\n-        return map(self.__getitem__, self.keyOrder)\n+    def _iterkeys(self):\n+        for key in self.keyOrder:\n+            yield key\n \n-    def itervalues(self):\n+    def _itervalues(self):\n         for key in self.keyOrder:\n             yield self[key]\n \n+    if six.PY3:\n+        items = _iteritems\n+        keys = _iterkeys\n+        values = _itervalues\n+    else:\n+        iteritems = _iteritems\n+        iterkeys = _iterkeys\n+        itervalues = _itervalues\n+\n+        def items(self):\n+            return list(self.iteritems())\n+\n+        def keys(self):\n+            return list(self.iterkeys())\n+\n+        def values(self):\n+            return list(self.itervalues())\n+\n     def update(self, dict_):\n-        for k, v in dict_.iteritems():\n+        for k, v in six.iteritems(dict_):\n             self[k] = v\n \n     def setdefault(self, key, default):\n@@ -226,7 +248,7 @@ def __repr__(self):\n         Replaces the normal dict.__repr__ with a version that returns the keys\n         in their sorted order.\n         \"\"\"\n-        return '{%s}' % ', '.join(['%r: %r' % (k, v) for k, v in self.items()])\n+        return '{%s}' % ', '.join(['%r: %r' % (k, v) for k, v in six.iteritems(self)])\n \n     def clear(self):\n         super(SortedDict, self).clear()\n@@ -356,38 +378,41 @@ def appendlist(self, key, value):\n         \"\"\"Appends an item to the internal list associated with key.\"\"\"\n         self.setlistdefault(key).append(value)\n \n-    def items(self):\n-        \"\"\"\n-        Returns a list of (key, value) pairs, where value is the last item in\n-        the list associated with the key.\n-        \"\"\"\n-        return [(key, self[key]) for key in self.keys()]\n-\n-    def iteritems(self):\n+    def _iteritems(self):\n         \"\"\"\n         Yields (key, value) pairs, where value is the last item in the list\n         associated with the key.\n         \"\"\"\n-        for key in self.keys():\n-            yield (key, self[key])\n-\n-    def lists(self):\n-        \"\"\"Returns a list of (key, list) pairs.\"\"\"\n-        return super(MultiValueDict, self).items()\n+        for key in self:\n+            yield key, self[key]\n \n-    def iterlists(self):\n+    def _iterlists(self):\n         \"\"\"Yields (key, list) pairs.\"\"\"\n-        return super(MultiValueDict, self).iteritems()\n+        return six.iteritems(super(MultiValueDict, self))\n \n-    def values(self):\n-        \"\"\"Returns a list of the last value on every key list.\"\"\"\n-        return [self[key] for key in self.keys()]\n-\n-    def itervalues(self):\n+    def _itervalues(self):\n         \"\"\"Yield the last value on every key list.\"\"\"\n-        for key in self.iterkeys():\n+        for key in self:\n             yield self[key]\n \n+    if six.PY3:\n+        items = _iteritems\n+        lists = _iterlists\n+        values = _itervalues\n+    else:\n+        iteritems = _iteritems\n+        iterlists = _iterlists\n+        itervalues = _itervalues\n+\n+        def items(self):\n+            return list(self.iteritems())\n+\n+        def lists(self):\n+            return list(self.iterlists())\n+\n+        def values(self):\n+            return list(self.itervalues())\n+\n     def copy(self):\n         \"\"\"Returns a shallow copy of this object.\"\"\"\n         return copy.copy(self)\n@@ -410,7 +435,7 @@ def update(self, *args, **kwargs):\n                         self.setlistdefault(key).append(value)\n                 except TypeError:\n                     raise ValueError(\"MultiValueDict.update() takes either a MultiValueDict or dictionary\")\n-        for key, value in kwargs.iteritems():\n+        for key, value in six.iteritems(kwargs):\n             self.setlistdefault(key).append(value)\n \n     def dict(self):"
        },
        {
            "sha": "e226bba09e4acdece089514f71b0ee40a3325a0b",
            "filename": "django/utils/six.py",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/ab6cd1c839b136cbc94178da433b2e97ab7f6061/django%2Futils%2Fsix.py",
            "raw_url": "https://github.com/django/django/raw/ab6cd1c839b136cbc94178da433b2e97ab7f6061/django%2Futils%2Fsix.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fsix.py?ref=ab6cd1c839b136cbc94178da433b2e97ab7f6061",
            "patch": "@@ -355,4 +355,13 @@ def with_metaclass(meta, base=object):\n \n ### Additional customizations for Django ###\n \n+if PY3:\n+    _iterlists = \"lists\"\n+else:\n+    _iterlists = \"iterlists\"\n+\n+def iterlists(d):\n+    \"\"\"Return an iterator over the values of a MultiValueDict.\"\"\"\n+    return getattr(d, _iterlists)()\n+\n add_move(MovedModule(\"_dummy_thread\", \"dummy_thread\"))"
        },
        {
            "sha": "3f799edac77b85a30ccb008caa916f3545882109",
            "filename": "docs/topics/python3.txt",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/django/django/blob/ab6cd1c839b136cbc94178da433b2e97ab7f6061/docs%2Ftopics%2Fpython3.txt",
            "raw_url": "https://github.com/django/django/raw/ab6cd1c839b136cbc94178da433b2e97ab7f6061/docs%2Ftopics%2Fpython3.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fpython3.txt?ref=ab6cd1c839b136cbc94178da433b2e97ab7f6061",
            "patch": "@@ -120,3 +120,18 @@ If you need different code in Python 2 and Python 3, check :data:`six.PY3`::\n \n This is a last resort solution when :mod:`six` doesn't provide an appropriate\n function.\n+\n+.. module:: django.utils.six\n+\n+Customizations of six\n+=====================\n+\n+The version of six bundled with Django includes a few additional tools:\n+\n+.. function:: iterlists(MultiValueDict)\n+\n+    Returns an iterator over the lists of values of a\n+    :class:`~django.utils.datastructures.MultiValueDict`. This replaces\n+    :meth:`~django.utils.datastructures.MultiValueDict.iterlists()` on Python\n+    2 and :meth:`~django.utils.datastructures.MultiValueDict.lists()` on\n+    Python 3."
        },
        {
            "sha": "dbc65d37a86cf561fb36a3c470b212b72f606b15",
            "filename": "tests/regressiontests/utils/datastructures.py",
            "status": "modified",
            "additions": 36,
            "deletions": 32,
            "changes": 68,
            "blob_url": "https://github.com/django/django/blob/ab6cd1c839b136cbc94178da433b2e97ab7f6061/tests%2Fregressiontests%2Futils%2Fdatastructures.py",
            "raw_url": "https://github.com/django/django/raw/ab6cd1c839b136cbc94178da433b2e97ab7f6061/tests%2Fregressiontests%2Futils%2Fdatastructures.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Futils%2Fdatastructures.py?ref=ab6cd1c839b136cbc94178da433b2e97ab7f6061",
            "patch": "@@ -9,6 +9,7 @@\n from django.test import SimpleTestCase\n from django.utils.datastructures import (DictWrapper, ImmutableList,\n     MultiValueDict, MultiValueDictKeyError, MergeDict, SortedDict)\n+from django.utils import six\n \n \n class SortedDictTests(SimpleTestCase):\n@@ -25,38 +26,42 @@ def setUp(self):\n         self.d2[7] = 'seven'\n \n     def test_basic_methods(self):\n-        self.assertEqual(self.d1.keys(), [7, 1, 9])\n-        self.assertEqual(self.d1.values(), ['seven', 'one', 'nine'])\n-        self.assertEqual(self.d1.items(), [(7, 'seven'), (1, 'one'), (9, 'nine')])\n+        self.assertEqual(list(six.iterkeys(self.d1)), [7, 1, 9])\n+        self.assertEqual(list(six.itervalues(self.d1)), ['seven', 'one', 'nine'])\n+        self.assertEqual(list(six.iteritems(self.d1)), [(7, 'seven'), (1, 'one'), (9, 'nine')])\n \n     def test_overwrite_ordering(self):\n-        \"\"\" Overwriting an item keeps it's place. \"\"\"\n+        \"\"\" Overwriting an item keeps its place. \"\"\"\n         self.d1[1] = 'ONE'\n-        self.assertEqual(self.d1.values(), ['seven', 'ONE', 'nine'])\n+        self.assertEqual(list(six.itervalues(self.d1)), ['seven', 'ONE', 'nine'])\n \n     def test_append_items(self):\n         \"\"\" New items go to the end. \"\"\"\n         self.d1[0] = 'nil'\n-        self.assertEqual(self.d1.keys(), [7, 1, 9, 0])\n+        self.assertEqual(list(six.iterkeys(self.d1)), [7, 1, 9, 0])\n \n     def test_delete_and_insert(self):\n         \"\"\"\n         Deleting an item, then inserting the same key again will place it\n         at the end.\n         \"\"\"\n         del self.d2[7]\n-        self.assertEqual(self.d2.keys(), [1, 9, 0])\n+        self.assertEqual(list(six.iterkeys(self.d2)), [1, 9, 0])\n         self.d2[7] = 'lucky number 7'\n-        self.assertEqual(self.d2.keys(), [1, 9, 0, 7])\n+        self.assertEqual(list(six.iterkeys(self.d2)), [1, 9, 0, 7])\n \n-    def test_change_keys(self):\n-        \"\"\"\n-        Changing the keys won't do anything, it's only a copy of the\n-        keys dict.\n-        \"\"\"\n-        k = self.d2.keys()\n-        k.remove(9)\n-        self.assertEqual(self.d2.keys(), [1, 9, 0, 7])\n+    if not six.PY3:\n+        def test_change_keys(self):\n+            \"\"\"\n+            Changing the keys won't do anything, it's only a copy of the\n+            keys dict.\n+\n+            This test doesn't make sense under Python 3 because keys is\n+            an iterator.\n+            \"\"\"\n+            k = self.d2.keys()\n+            k.remove(9)\n+            self.assertEqual(self.d2.keys(), [1, 9, 0, 7])\n \n     def test_init_keys(self):\n         \"\"\"\n@@ -68,18 +73,18 @@ def test_init_keys(self):\n         tuples = ((2, 'two'), (1, 'one'), (2, 'second-two'))\n         d = SortedDict(tuples)\n \n-        self.assertEqual(d.keys(), [2, 1])\n+        self.assertEqual(list(six.iterkeys(d)), [2, 1])\n \n         real_dict = dict(tuples)\n-        self.assertEqual(sorted(real_dict.values()), ['one', 'second-two'])\n+        self.assertEqual(sorted(six.itervalues(real_dict)), ['one', 'second-two'])\n \n         # Here the order of SortedDict values *is* what we are testing\n-        self.assertEqual(d.values(), ['second-two', 'one'])\n+        self.assertEqual(list(six.itervalues(d)), ['second-two', 'one'])\n \n     def test_overwrite(self):\n         self.d1[1] = 'not one'\n         self.assertEqual(self.d1[1], 'not one')\n-        self.assertEqual(self.d1.keys(), self.d1.copy().keys())\n+        self.assertEqual(list(six.iterkeys(self.d1)), list(six.iterkeys(self.d1.copy())))\n \n     def test_append(self):\n         self.d1[13] = 'thirteen'\n@@ -115,8 +120,8 @@ def test_pickle(self):\n     def test_copy(self):\n         orig = SortedDict(((1, \"one\"), (0, \"zero\"), (2, \"two\")))\n         copied = copy.copy(orig)\n-        self.assertEqual(orig.keys(), [1, 0, 2])\n-        self.assertEqual(copied.keys(), [1, 0, 2])\n+        self.assertEqual(list(six.iterkeys(orig)), [1, 0, 2])\n+        self.assertEqual(list(six.iterkeys(copied)), [1, 0, 2])\n \n     def test_clear(self):\n         self.d1.clear()\n@@ -178,12 +183,12 @@ def test_mergedict_merges_multivaluedict(self):\n         self.assertEqual(mm.getlist('key4'), ['value5', 'value6'])\n         self.assertEqual(mm.getlist('undefined'), [])\n \n-        self.assertEqual(sorted(mm.keys()), ['key1', 'key2', 'key4'])\n-        self.assertEqual(len(mm.values()), 3)\n+        self.assertEqual(sorted(six.iterkeys(mm)), ['key1', 'key2', 'key4'])\n+        self.assertEqual(len(list(six.itervalues(mm))), 3)\n \n-        self.assertTrue('value1' in mm.values())\n+        self.assertTrue('value1' in six.itervalues(mm))\n \n-        self.assertEqual(sorted(mm.items(), key=lambda k: k[0]),\n+        self.assertEqual(sorted(six.iteritems(mm), key=lambda k: k[0]),\n                           [('key1', 'value1'), ('key2', 'value3'),\n                            ('key4', 'value6')])\n \n@@ -201,10 +206,10 @@ def test_multivaluedict(self):\n         self.assertEqual(d['name'], 'Simon')\n         self.assertEqual(d.get('name'), 'Simon')\n         self.assertEqual(d.getlist('name'), ['Adrian', 'Simon'])\n-        self.assertEqual(list(d.iteritems()),\n+        self.assertEqual(list(six.iteritems(d)),\n                           [('position', 'Developer'), ('name', 'Simon')])\n \n-        self.assertEqual(list(d.iterlists()),\n+        self.assertEqual(list(six.iterlists(d)),\n                           [('position', ['Developer']),\n                            ('name', ['Adrian', 'Simon'])])\n \n@@ -224,8 +229,7 @@ def test_multivaluedict(self):\n \n         d.setlist('lastname', ['Holovaty', 'Willison'])\n         self.assertEqual(d.getlist('lastname'), ['Holovaty', 'Willison'])\n-        self.assertEqual(d.values(), ['Developer', 'Simon', 'Willison'])\n-        self.assertEqual(list(d.itervalues()),\n+        self.assertEqual(list(six.itervalues(d)),\n                           ['Developer', 'Simon', 'Willison'])\n \n     def test_appendlist(self):\n@@ -260,8 +264,8 @@ def test_dict_translation(self):\n             'pm': ['Rory'],\n         })\n         d = mvd.dict()\n-        self.assertEqual(d.keys(), mvd.keys())\n-        for key in mvd.keys():\n+        self.assertEqual(list(six.iterkeys(d)), list(six.iterkeys(mvd)))\n+        for key in six.iterkeys(mvd):\n             self.assertEqual(d[key], mvd[key])\n \n         self.assertEqual({}, MultiValueDict().dict())"
        }
    ],
    "stats": {
        "total": 227,
        "additions": 140,
        "deletions": 87
    }
}