{
    "author": "claudep",
    "message": "Refactored makemessages command",
    "sha": "755f215590af5a9bc70917412b28cd710318ec63",
    "files": [
        {
            "sha": "72128eb93109472adf17611187c1834600abcfac",
            "filename": "django/core/management/commands/makemessages.py",
            "status": "modified",
            "additions": 313,
            "deletions": 313,
            "changes": 626,
            "blob_url": "https://github.com/django/django/blob/755f215590af5a9bc70917412b28cd710318ec63/django%2Fcore%2Fmanagement%2Fcommands%2Fmakemessages.py",
            "raw_url": "https://github.com/django/django/raw/755f215590af5a9bc70917412b28cd710318ec63/django%2Fcore%2Fmanagement%2Fcommands%2Fmakemessages.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Fmakemessages.py?ref=755f215590af5a9bc70917412b28cd710318ec63",
            "patch": "@@ -9,35 +9,105 @@\n \n import django\n from django.core.management.base import CommandError, NoArgsCommand\n+from django.utils.functional import total_ordering\n from django.utils.text import get_text_list\n from django.utils.jslex import prepare_js_for_gettext\n \n plural_forms_re = re.compile(r'^(?P<value>\"Plural-Forms.+?\\\\n\")\\s*$', re.MULTILINE | re.DOTALL)\n STATUS_OK = 0\n \n-def handle_extensions(extensions=('html',), ignored=('py',)):\n-    \"\"\"\n-    Organizes multiple extensions that are separated with commas or passed by\n-    using --extension/-e multiple times. Note that the .py extension is ignored\n-    here because of the way non-*.py files are handled in make_messages() (they\n-    are copied to file.ext.py files to trick xgettext to parse them as Python\n-    files).\n \n-    For example: running 'django-admin makemessages -e js,txt -e xhtml -a'\n-    would result in an extension list: ['.js', '.txt', '.xhtml']\n+@total_ordering\n+class TranslatableFile(object):\n+    def __init__(self, dirpath, file_name):\n+        self.file = file_name\n+        self.dirpath = dirpath\n+\n+    def __repr__(self):\n+        return \"<TranslatableFile: %s>\" % os.sep.join([self.dirpath, self.file])\n+\n+    def __eq__(self, other):\n+        return self.dirpath == other.dirpath and self.file == other.file\n+\n+    def __lt__(self, other):\n+        if self.dirpath == other.dirpath:\n+            return self.file < other.file\n+        return self.dirpath < other.dirpath\n+\n+    def process(self, command, potfile, domain, keep_pot=False):\n+        \"\"\"\n+        Extract translatable literals from self.file for :param domain:\n+        creating or updating the :param potfile: POT file.\n+\n+        Uses the xgettext GNU gettext utility.\n+        \"\"\"\n+\n+        from django.utils.translation import templatize\n+\n+        if command.verbosity > 1:\n+            command.stdout.write('processing file %s in %s\\n' % (self.file, self.dirpath))\n+        _, file_ext = os.path.splitext(self.file)\n+        if domain == 'djangojs' and file_ext in command.extensions:\n+            is_templatized = True\n+            orig_file = os.path.join(self.dirpath, self.file)\n+            with open(orig_file) as fp:\n+                src_data = fp.read()\n+            src_data = prepare_js_for_gettext(src_data)\n+            thefile = '%s.c' % self.file\n+            work_file = os.path.join(self.dirpath, thefile)\n+            with open(work_file, \"w\") as fp:\n+                fp.write(src_data)\n+            cmd = (\n+                'xgettext -d %s -L C %s %s --keyword=gettext_noop '\n+                '--keyword=gettext_lazy --keyword=ngettext_lazy:1,2 '\n+                '--keyword=pgettext:1c,2 --keyword=npgettext:1c,2,3 '\n+                '--from-code UTF-8 --add-comments=Translators -o - \"%s\"' %\n+                (domain, command.wrap, command.location, work_file))\n+        elif domain == 'django' and (file_ext == '.py' or file_ext in command.extensions):\n+            thefile = self.file\n+            orig_file = os.path.join(self.dirpath, self.file)\n+            is_templatized = file_ext in command.extensions\n+            if is_templatized:\n+                with open(orig_file, \"rU\") as fp:\n+                    src_data = fp.read()\n+                thefile = '%s.py' % self.file\n+                content = templatize(src_data, orig_file[2:])\n+                with open(os.path.join(self.dirpath, thefile), \"w\") as fp:\n+                    fp.write(content)\n+            work_file = os.path.join(self.dirpath, thefile)\n+            cmd = (\n+                'xgettext -d %s -L Python %s %s --keyword=gettext_noop '\n+                '--keyword=gettext_lazy --keyword=ngettext_lazy:1,2 '\n+                '--keyword=ugettext_noop --keyword=ugettext_lazy '\n+                '--keyword=ungettext_lazy:1,2 --keyword=pgettext:1c,2 '\n+                '--keyword=npgettext:1c,2,3 --keyword=pgettext_lazy:1c,2 '\n+                '--keyword=npgettext_lazy:1c,2,3 --from-code UTF-8 '\n+                '--add-comments=Translators -o - \"%s\"' %\n+                (domain, command.wrap, command.location, work_file))\n+        else:\n+            return\n+        msgs, errors, status = _popen(cmd)\n+        if errors:\n+            if status != STATUS_OK:\n+                if is_templatized:\n+                    os.unlink(work_file)\n+                if not keep_pot and os.path.exists(potfile):\n+                    os.unlink(potfile)\n+                raise CommandError(\n+                    \"errors happened while running xgettext on %s\\n%s\" %\n+                    (self.file, errors))\n+            elif command.verbosity > 0:\n+                # Print warnings\n+                command.stdout.write(errors)\n+        if msgs:\n+            if is_templatized:\n+                old = '#: ' + work_file[2:]\n+                new = '#: ' + orig_file[2:]\n+                msgs = msgs.replace(old, new)\n+            write_pot_file(potfile, msgs)\n+        if is_templatized:\n+            os.unlink(work_file)\n \n-    >>> handle_extensions(['.html', 'html,js,py,py,py,.py', 'py,.py'])\n-    set(['.html', '.js'])\n-    >>> handle_extensions(['.html, txt,.tpl'])\n-    set(['.html', '.tpl', '.txt'])\n-    \"\"\"\n-    ext_list = []\n-    for ext in extensions:\n-        ext_list.extend(ext.replace(' ', '').split(','))\n-    for i, ext in enumerate(ext_list):\n-        if not ext.startswith('.'):\n-            ext_list[i] = '.%s' % ext_list[i]\n-    return set([x for x in ext_list if x.strip('.') not in ignored])\n \n def _popen(cmd):\n     \"\"\"\n@@ -47,76 +117,11 @@ def _popen(cmd):\n     output, errors = p.communicate()\n     return output, errors, p.returncode\n \n-def find_files(root, ignore_patterns, verbosity, stdout=sys.stdout, symlinks=False):\n-    \"\"\"\n-    Helper function to get all files in the given root.\n-    \"\"\"\n-    dir_suffix = '%s*' % os.sep\n-    norm_patterns = [p[:-len(dir_suffix)] if p.endswith(dir_suffix) else p for p in ignore_patterns]\n-    all_files = []\n-    for dirpath, dirnames, filenames in os.walk(root, topdown=True, followlinks=symlinks):\n-        for dirname in dirnames[:]:\n-            if is_ignored(os.path.normpath(os.path.join(dirpath, dirname)), norm_patterns):\n-                dirnames.remove(dirname)\n-                if verbosity > 1:\n-                    stdout.write('ignoring directory %s\\n' % dirname)\n-        for filename in filenames:\n-            if is_ignored(os.path.normpath(os.path.join(dirpath, filename)), ignore_patterns):\n-                if verbosity > 1:\n-                    stdout.write('ignoring file %s in %s\\n' % (filename, dirpath))\n-            else:\n-                all_files.extend([(dirpath, filename)])\n-    all_files.sort()\n-    return all_files\n-\n-def is_ignored(path, ignore_patterns):\n-    \"\"\"\n-    Helper function to check if the given path should be ignored or not.\n-    \"\"\"\n-    for pattern in ignore_patterns:\n-        if fnmatch.fnmatchcase(path, pattern):\n-            return True\n-    return False\n-\n-def copy_plural_forms(msgs, locale, domain, verbosity, stdout=sys.stdout):\n-    \"\"\"\n-    Copies plural forms header contents from a Django catalog of locale to\n-    the msgs string, inserting it at the right place. msgs should be the\n-    contents of a newly created .po file.\n-    \"\"\"\n-    django_dir = os.path.normpath(os.path.join(os.path.dirname(django.__file__)))\n-    if domain == 'djangojs':\n-        domains = ('djangojs', 'django')\n-    else:\n-        domains = ('django',)\n-    for domain in domains:\n-        django_po = os.path.join(django_dir, 'conf', 'locale', locale, 'LC_MESSAGES', '%s.po' % domain)\n-        if os.path.exists(django_po):\n-            with open(django_po, 'rU') as fp:\n-                m = plural_forms_re.search(fp.read())\n-            if m:\n-                if verbosity > 1:\n-                    stdout.write(\"copying plural forms: %s\\n\" % m.group('value'))\n-                lines = []\n-                seen = False\n-                for line in msgs.split('\\n'):\n-                    if not line and not seen:\n-                        line = '%s\\n' % m.group('value')\n-                        seen = True\n-                    lines.append(line)\n-                msgs = '\\n'.join(lines)\n-                break\n-    return msgs\n-\n-def write_pot_file(potfile, msgs, file, work_file, is_templatized):\n+def write_pot_file(potfile, msgs):\n     \"\"\"\n     Write the :param potfile: POT file with the :param msgs: contents,\n     previously making sure its format is valid.\n     \"\"\"\n-    if is_templatized:\n-        old = '#: ' + work_file[2:]\n-        new = '#: ' + file[2:]\n-        msgs = msgs.replace(old, new)\n     if os.path.exists(potfile):\n         # Strip the header\n         msgs = '\\n'.join(dropwhile(len, msgs.split('\\n')))\n@@ -125,224 +130,36 @@ def write_pot_file(potfile, msgs, file, work_file, is_templatized):\n     with open(potfile, 'a') as fp:\n         fp.write(msgs)\n \n-def process_file(file, dirpath, potfile, domain, verbosity,\n-                 extensions, wrap, location, keep_pot, stdout=sys.stdout):\n-    \"\"\"\n-    Extract translatable literals from :param file: for :param domain:\n-    creating or updating the :param potfile: POT file.\n-\n-    Uses the xgettext GNU gettext utility.\n-    \"\"\"\n-\n-    from django.utils.translation import templatize\n-\n-    if verbosity > 1:\n-        stdout.write('processing file %s in %s\\n' % (file, dirpath))\n-    _, file_ext = os.path.splitext(file)\n-    if domain == 'djangojs' and file_ext in extensions:\n-        is_templatized = True\n-        orig_file = os.path.join(dirpath, file)\n-        with open(orig_file) as fp:\n-            src_data = fp.read()\n-        src_data = prepare_js_for_gettext(src_data)\n-        thefile = '%s.c' % file\n-        work_file = os.path.join(dirpath, thefile)\n-        with open(work_file, \"w\") as fp:\n-            fp.write(src_data)\n-        cmd = (\n-            'xgettext -d %s -L C %s %s --keyword=gettext_noop '\n-            '--keyword=gettext_lazy --keyword=ngettext_lazy:1,2 '\n-            '--keyword=pgettext:1c,2 --keyword=npgettext:1c,2,3 '\n-            '--from-code UTF-8 --add-comments=Translators -o - \"%s\"' %\n-            (domain, wrap, location, work_file))\n-    elif domain == 'django' and (file_ext == '.py' or file_ext in extensions):\n-        thefile = file\n-        orig_file = os.path.join(dirpath, file)\n-        is_templatized = file_ext in extensions\n-        if is_templatized:\n-            with open(orig_file, \"rU\") as fp:\n-                src_data = fp.read()\n-            thefile = '%s.py' % file\n-            content = templatize(src_data, orig_file[2:])\n-            with open(os.path.join(dirpath, thefile), \"w\") as fp:\n-                fp.write(content)\n-        work_file = os.path.join(dirpath, thefile)\n-        cmd = (\n-            'xgettext -d %s -L Python %s %s --keyword=gettext_noop '\n-            '--keyword=gettext_lazy --keyword=ngettext_lazy:1,2 '\n-            '--keyword=ugettext_noop --keyword=ugettext_lazy '\n-            '--keyword=ungettext_lazy:1,2 --keyword=pgettext:1c,2 '\n-            '--keyword=npgettext:1c,2,3 --keyword=pgettext_lazy:1c,2 '\n-            '--keyword=npgettext_lazy:1c,2,3 --from-code UTF-8 '\n-            '--add-comments=Translators -o - \"%s\"' %\n-            (domain, wrap, location, work_file))\n-    else:\n-        return\n-    msgs, errors, status = _popen(cmd)\n-    if errors:\n-        if status != STATUS_OK:\n-            if is_templatized:\n-                os.unlink(work_file)\n-            if not keep_pot and os.path.exists(potfile):\n-                os.unlink(potfile)\n-            raise CommandError(\n-                \"errors happened while running xgettext on %s\\n%s\" %\n-                (file, errors))\n-        elif verbosity > 0:\n-            # Print warnings\n-            stdout.write(errors)\n-    if msgs:\n-        write_pot_file(potfile, msgs, orig_file, work_file, is_templatized)\n-    if is_templatized:\n-        os.unlink(work_file)\n-\n-def write_po_file(pofile, potfile, domain, locale, verbosity, stdout,\n-                  copy_pforms, wrap, location, no_obsolete, keep_pot):\n-    \"\"\"\n-    Creates of updates the :param pofile: PO file for :param domain: and :param\n-    locale:.  Uses contents of the existing :param potfile:.\n-\n-    Uses mguniq, msgmerge, and msgattrib GNU gettext utilities.\n+def handle_extensions(extensions=('html',), ignored=('py',)):\n     \"\"\"\n-    msgs, errors, status = _popen('msguniq %s %s --to-code=utf-8 \"%s\"' %\n-                                    (wrap, location, potfile))\n-    if errors:\n-        if status != STATUS_OK:\n-            if not keep_pot:\n-                os.unlink(potfile)\n-            raise CommandError(\n-                \"errors happened while running msguniq\\n%s\" % errors)\n-        elif verbosity > 0:\n-            stdout.write(errors)\n+    Organizes multiple extensions that are separated with commas or passed by\n+    using --extension/-e multiple times. Note that the .py extension is ignored\n+    here because of the way non-*.py files are handled in make_messages() (they\n+    are copied to file.ext.py files to trick xgettext to parse them as Python\n+    files).\n \n-    if os.path.exists(pofile):\n-        with open(potfile, 'w') as fp:\n-            fp.write(msgs)\n-        msgs, errors, status = _popen('msgmerge %s %s -q \"%s\" \"%s\"' %\n-                                        (wrap, location, pofile, potfile))\n-        if errors:\n-            if status != STATUS_OK:\n-                if not keep_pot:\n-                    os.unlink(potfile)\n-                raise CommandError(\n-                    \"errors happened while running msgmerge\\n%s\" % errors)\n-            elif verbosity > 0:\n-                stdout.write(errors)\n-    elif copy_pforms:\n-        msgs = copy_plural_forms(msgs, locale, domain, verbosity, stdout)\n-    msgs = msgs.replace(\n-        \"#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\\n\" % domain, \"\")\n-    with open(pofile, 'w') as fp:\n-        fp.write(msgs)\n-    if no_obsolete:\n-        msgs, errors, status = _popen(\n-            'msgattrib %s %s -o \"%s\" --no-obsolete \"%s\"' %\n-            (wrap, location, pofile, pofile))\n-        if errors:\n-            if status != STATUS_OK:\n-                raise CommandError(\n-                    \"errors happened while running msgattrib\\n%s\" % errors)\n-            elif verbosity > 0:\n-                stdout.write(errors)\n+    For example: running 'django-admin makemessages -e js,txt -e xhtml -a'\n+    would result in an extension list: ['.js', '.txt', '.xhtml']\n \n-def make_messages(locale=None, domain='django', verbosity=1, all=False,\n-        extensions=None, symlinks=False, ignore_patterns=None, no_wrap=False,\n-        no_location=False, no_obsolete=False, stdout=sys.stdout, keep_pot=False):\n-    \"\"\"\n-    Uses the ``locale/`` directory from the Django Git tree or an\n-    application/project to process all files with translatable literals for\n-    the :param domain: domain and :param locale: locale.\n+    >>> handle_extensions(['.html', 'html,js,py,py,py,.py', 'py,.py'])\n+    set(['.html', '.js'])\n+    >>> handle_extensions(['.html, txt,.tpl'])\n+    set(['.html', '.tpl', '.txt'])\n     \"\"\"\n-    # Need to ensure that the i18n framework is enabled\n-    from django.conf import settings\n-    if settings.configured:\n-        settings.USE_I18N = True\n-    else:\n-        settings.configure(USE_I18N = True)\n-\n-    if ignore_patterns is None:\n-        ignore_patterns = []\n-\n-    invoked_for_django = False\n-    if os.path.isdir(os.path.join('conf', 'locale')):\n-        localedir = os.path.abspath(os.path.join('conf', 'locale'))\n-        invoked_for_django = True\n-        # Ignoring all contrib apps\n-        ignore_patterns += ['contrib/*']\n-    elif os.path.isdir('locale'):\n-        localedir = os.path.abspath('locale')\n-    else:\n-        raise CommandError(\"This script should be run from the Django Git \"\n-                \"tree or your project or app tree. If you did indeed run it \"\n-                \"from the Git checkout or your project or application, \"\n-                \"maybe you are just missing the conf/locale (in the django \"\n-                \"tree) or locale (for project and application) directory? It \"\n-                \"is not created automatically, you have to create it by hand \"\n-                \"if you want to enable i18n for your project or application.\")\n-\n-    if domain not in ('django', 'djangojs'):\n-        raise CommandError(\"currently makemessages only supports domains \"\n-                           \"'django' and 'djangojs'\")\n-\n-    if (locale is None and not all) or domain is None:\n-        message = \"Type '%s help %s' for usage information.\" % (\n-                  os.path.basename(sys.argv[0]), sys.argv[1])\n-        raise CommandError(message)\n-\n-    # We require gettext version 0.15 or newer.\n-    output, errors, status = _popen('xgettext --version')\n-    if status != STATUS_OK:\n-        raise CommandError(\"Error running xgettext. Note that Django \"\n-                    \"internationalization requires GNU gettext 0.15 or newer.\")\n-    match = re.search(r'(?P<major>\\d+)\\.(?P<minor>\\d+)', output)\n-    if match:\n-        xversion = (int(match.group('major')), int(match.group('minor')))\n-        if xversion < (0, 15):\n-            raise CommandError(\"Django internationalization requires GNU \"\n-                    \"gettext 0.15 or newer. You are using version %s, please \"\n-                    \"upgrade your gettext toolset.\" % match.group())\n-\n-    locales = []\n-    if locale is not None:\n-        locales += locale.split(',') if not isinstance(locale, list) else locale\n-    elif all:\n-        locale_dirs = filter(os.path.isdir, glob.glob('%s/*' % localedir))\n-        locales = [os.path.basename(l) for l in locale_dirs]\n-\n-    wrap = '--no-wrap' if no_wrap else ''\n-    location = '--no-location' if no_location else ''\n-\n-    potfile = os.path.join(localedir, '%s.pot' % str(domain))\n-\n-    if os.path.exists(potfile):\n-        os.unlink(potfile)\n-\n-    for dirpath, file in find_files(\".\", ignore_patterns, verbosity,\n-            stdout, symlinks=symlinks):\n-        process_file(file, dirpath, potfile, domain, verbosity, extensions,\n-                wrap, location, keep_pot, stdout)\n-\n-    for locale in locales:\n-        if verbosity > 0:\n-            stdout.write(\"processing language %s\\n\" % locale)\n-        basedir = os.path.join(localedir, locale, 'LC_MESSAGES')\n-        if not os.path.isdir(basedir):\n-            os.makedirs(basedir)\n-\n-        pofile = os.path.join(basedir, '%s.po' % str(domain))\n-\n-        if os.path.exists(potfile):\n-            write_po_file(pofile, potfile, domain, locale, verbosity, stdout,\n-                    not invoked_for_django, wrap, location, no_obsolete, keep_pot)\n-\n-    if not keep_pot:\n-        os.unlink(potfile)\n+    ext_list = []\n+    for ext in extensions:\n+        ext_list.extend(ext.replace(' ', '').split(','))\n+    for i, ext in enumerate(ext_list):\n+        if not ext.startswith('.'):\n+            ext_list[i] = '.%s' % ext_list[i]\n+    return set([x for x in ext_list if x.strip('.') not in ignored])\n \n \n class Command(NoArgsCommand):\n     option_list = NoArgsCommand.option_list + (\n         make_option('--locale', '-l', default=None, dest='locale', action='append',\n-            help='Creates or updates the message files for the given locale(s) (e.g. pt_BR). Can be used multiple times, accepts a comma-separated list of locale names.'),\n+            help='Creates or updates the message files for the given locale(s) (e.g. pt_BR). '\n+                 'Can be used multiple times, accepts a comma-separated list of locale names.'),\n         make_option('--domain', '-d', default='django', dest='domain',\n             help='The domain of the message files (default: \"django\").'),\n         make_option('--all', '-a', action='store_true', dest='all',\n@@ -355,7 +172,7 @@ class Command(NoArgsCommand):\n         make_option('--ignore', '-i', action='append', dest='ignore_patterns',\n             default=[], metavar='PATTERN', help='Ignore files or directories matching this glob-style pattern. Use multiple times to ignore more.'),\n         make_option('--no-default-ignore', action='store_false', dest='use_default_ignore_patterns',\n-            default=True, help=\"Don't ignore the common glob-style patterns 'CVS', '.*' and '*~'.\"),\n+            default=True, help=\"Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'.\"),\n         make_option('--no-wrap', action='store_true', dest='no_wrap',\n             default=False, help=\"Don't break long message lines into several lines\"),\n         make_option('--no-location', action='store_true', dest='no_location',\n@@ -376,29 +193,212 @@ class Command(NoArgsCommand):\n \n     def handle_noargs(self, *args, **options):\n         locale = options.get('locale')\n-        domain = options.get('domain')\n-        verbosity = int(options.get('verbosity'))\n+        self.domain = options.get('domain')\n+        self.verbosity = int(options.get('verbosity'))\n         process_all = options.get('all')\n         extensions = options.get('extensions')\n-        symlinks = options.get('symlinks')\n+        self.symlinks = options.get('symlinks')\n         ignore_patterns = options.get('ignore_patterns')\n         if options.get('use_default_ignore_patterns'):\n-            ignore_patterns += ['CVS', '.*', '*~']\n-        ignore_patterns = list(set(ignore_patterns))\n-        no_wrap = options.get('no_wrap')\n-        no_location = options.get('no_location')\n-        no_obsolete = options.get('no_obsolete')\n-        keep_pot = options.get('keep_pot')\n-        if domain == 'djangojs':\n+            ignore_patterns += ['CVS', '.*', '*~', '*.pyc']\n+        self.ignore_patterns = list(set(ignore_patterns))\n+        self.wrap = '--no-wrap' if options.get('no_wrap') else ''\n+        self.location = '--no-location' if options.get('no_location') else ''\n+        self.no_obsolete = options.get('no_obsolete')\n+        self.keep_pot = options.get('keep_pot')\n+\n+        if self.domain not in ('django', 'djangojs'):\n+            raise CommandError(\"currently makemessages only supports domains \"\n+                               \"'django' and 'djangojs'\")\n+        if self.domain == 'djangojs':\n             exts = extensions if extensions else ['js']\n         else:\n             exts = extensions if extensions else ['html', 'txt']\n-        extensions = handle_extensions(exts)\n+        self.extensions = handle_extensions(exts)\n \n-        if verbosity > 1:\n+        if (locale is None and not process_all) or self.domain is None:\n+            raise CommandError(\"Type '%s help %s' for usage information.\" % (\n+                                os.path.basename(sys.argv[0]), sys.argv[1]))\n+\n+        if self.verbosity > 1:\n             self.stdout.write('examining files with the extensions: %s\\n'\n-                             % get_text_list(list(extensions), 'and'))\n+                             % get_text_list(list(self.extensions), 'and'))\n \n-        make_messages(locale, domain, verbosity, process_all, extensions,\n-                      symlinks, ignore_patterns, no_wrap, no_location,\n-                      no_obsolete, self.stdout, keep_pot)\n+        # Need to ensure that the i18n framework is enabled\n+        from django.conf import settings\n+        if settings.configured:\n+            settings.USE_I18N = True\n+        else:\n+            settings.configure(USE_I18N = True)\n+\n+        self.invoked_for_django = False\n+        if os.path.isdir(os.path.join('conf', 'locale')):\n+            localedir = os.path.abspath(os.path.join('conf', 'locale'))\n+            self.invoked_for_django = True\n+            # Ignoring all contrib apps\n+            self.ignore_patterns += ['contrib/*']\n+        elif os.path.isdir('locale'):\n+            localedir = os.path.abspath('locale')\n+        else:\n+            raise CommandError(\"This script should be run from the Django Git \"\n+                    \"tree or your project or app tree. If you did indeed run it \"\n+                    \"from the Git checkout or your project or application, \"\n+                    \"maybe you are just missing the conf/locale (in the django \"\n+                    \"tree) or locale (for project and application) directory? It \"\n+                    \"is not created automatically, you have to create it by hand \"\n+                    \"if you want to enable i18n for your project or application.\")\n+\n+        # We require gettext version 0.15 or newer.\n+        output, errors, status = _popen('xgettext --version')\n+        if status != STATUS_OK:\n+            raise CommandError(\"Error running xgettext. Note that Django \"\n+                        \"internationalization requires GNU gettext 0.15 or newer.\")\n+        match = re.search(r'(?P<major>\\d+)\\.(?P<minor>\\d+)', output)\n+        if match:\n+            xversion = (int(match.group('major')), int(match.group('minor')))\n+            if xversion < (0, 15):\n+                raise CommandError(\"Django internationalization requires GNU \"\n+                        \"gettext 0.15 or newer. You are using version %s, please \"\n+                        \"upgrade your gettext toolset.\" % match.group())\n+\n+        potfile = self.build_pot_file(localedir)\n+\n+        # Build po files for each selected locale\n+        locales = []\n+        if locale is not None:\n+            locales += locale.split(',') if not isinstance(locale, list) else locale\n+        elif process_all:\n+            locale_dirs = filter(os.path.isdir, glob.glob('%s/*' % localedir))\n+            locales = [os.path.basename(l) for l in locale_dirs]\n+\n+        try:\n+            for locale in locales:\n+                if self.verbosity > 0:\n+                    self.stdout.write(\"processing language %s\\n\" % locale)\n+                self.write_po_file(potfile, locale)\n+        finally:\n+            if not self.keep_pot and os.path.exists(potfile):\n+                os.unlink(potfile)\n+\n+    def build_pot_file(self, localedir):\n+        file_list = self.find_files(\".\")\n+\n+        potfile = os.path.join(localedir, '%s.pot' % str(self.domain))\n+        if os.path.exists(potfile):\n+            # Remove a previous undeleted potfile, if any\n+            os.unlink(potfile)\n+\n+        for f in file_list:\n+            f.process(self, potfile, self.domain, self.keep_pot)\n+        return potfile\n+\n+    def find_files(self, root):\n+        \"\"\"\n+        Helper method to get all files in the given root.\n+        \"\"\"\n+\n+        def is_ignored(path, ignore_patterns):\n+            \"\"\"\n+            Check if the given path should be ignored or not.\n+            \"\"\"\n+            for pattern in ignore_patterns:\n+                if fnmatch.fnmatchcase(path, pattern):\n+                    return True\n+            return False\n+\n+        dir_suffix = '%s*' % os.sep\n+        norm_patterns = [p[:-len(dir_suffix)] if p.endswith(dir_suffix) else p for p in self.ignore_patterns]\n+        all_files = []\n+        for dirpath, dirnames, filenames in os.walk(root, topdown=True, followlinks=self.symlinks):\n+            for dirname in dirnames[:]:\n+                if is_ignored(os.path.normpath(os.path.join(dirpath, dirname)), norm_patterns):\n+                    dirnames.remove(dirname)\n+                    if self.verbosity > 1:\n+                        self.stdout.write('ignoring directory %s\\n' % dirname)\n+            for filename in filenames:\n+                if is_ignored(os.path.normpath(os.path.join(dirpath, filename)), self.ignore_patterns):\n+                    if self.verbosity > 1:\n+                        self.stdout.write('ignoring file %s in %s\\n' % (filename, dirpath))\n+                else:\n+                    all_files.append(TranslatableFile(dirpath, filename))\n+        return sorted(all_files)\n+\n+    def write_po_file(self, potfile, locale):\n+        \"\"\"\n+        Creates or updates the PO file for self.domain and :param locale:.\n+        Uses contents of the existing :param potfile:.\n+\n+        Uses mguniq, msgmerge, and msgattrib GNU gettext utilities.\n+        \"\"\"\n+        msgs, errors, status = _popen('msguniq %s %s --to-code=utf-8 \"%s\"' %\n+                                        (self.wrap, self.location, potfile))\n+        if errors:\n+            if status != STATUS_OK:\n+                raise CommandError(\n+                    \"errors happened while running msguniq\\n%s\" % errors)\n+            elif self.verbosity > 0:\n+                self.stdout.write(errors)\n+\n+        basedir = os.path.join(os.path.dirname(potfile), locale, 'LC_MESSAGES')\n+        if not os.path.isdir(basedir):\n+            os.makedirs(basedir)\n+        pofile = os.path.join(basedir, '%s.po' % str(self.domain))\n+\n+        if os.path.exists(pofile):\n+            with open(potfile, 'w') as fp:\n+                fp.write(msgs)\n+            msgs, errors, status = _popen('msgmerge %s %s -q \"%s\" \"%s\"' %\n+                                            (self.wrap, self.location, pofile, potfile))\n+            if errors:\n+                if status != STATUS_OK:\n+                    raise CommandError(\n+                        \"errors happened while running msgmerge\\n%s\" % errors)\n+                elif self.verbosity > 0:\n+                    self.stdout.write(errors)\n+        elif not self.invoked_for_django:\n+            msgs = self.copy_plural_forms(msgs, locale)\n+        msgs = msgs.replace(\n+            \"#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\\n\" % self.domain, \"\")\n+        with open(pofile, 'w') as fp:\n+            fp.write(msgs)\n+\n+        if self.no_obsolete:\n+            msgs, errors, status = _popen(\n+                'msgattrib %s %s -o \"%s\" --no-obsolete \"%s\"' %\n+                (wrap, location, pofile, pofile))\n+            if errors:\n+                if status != STATUS_OK:\n+                    raise CommandError(\n+                        \"errors happened while running msgattrib\\n%s\" % errors)\n+                elif self.verbosity > 0:\n+                    self.stdout.write(errors)\n+\n+    def copy_plural_forms(self, msgs, locale):\n+        \"\"\"\n+        Copies plural forms header contents from a Django catalog of locale to\n+        the msgs string, inserting it at the right place. msgs should be the\n+        contents of a newly created .po file.\n+        \"\"\"\n+        django_dir = os.path.normpath(os.path.join(os.path.dirname(django.__file__)))\n+        if self.domain == 'djangojs':\n+            domains = ('djangojs', 'django')\n+        else:\n+            domains = ('django',)\n+        for domain in domains:\n+            django_po = os.path.join(django_dir, 'conf', 'locale', locale, 'LC_MESSAGES', '%s.po' % domain)\n+            if os.path.exists(django_po):\n+                with open(django_po, 'rU') as fp:\n+                    m = plural_forms_re.search(fp.read())\n+                if m:\n+                    if self.verbosity > 1:\n+                        self.stdout.write(\"copying plural forms: %s\\n\" % m.group('value'))\n+                    lines = []\n+                    seen = False\n+                    for line in msgs.split('\\n'):\n+                        if not line and not seen:\n+                            line = '%s\\n' % m.group('value')\n+                            seen = True\n+                        lines.append(line)\n+                    msgs = '\\n'.join(lines)\n+                    break\n+        return msgs"
        }
    ],
    "stats": {
        "total": 626,
        "additions": 313,
        "deletions": 313
    }
}