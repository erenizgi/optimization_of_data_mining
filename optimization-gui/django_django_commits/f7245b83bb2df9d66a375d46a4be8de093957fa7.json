{
    "author": "aaugustin",
    "message": "Implemented atomic_if_autocommit.\n\nIt disables transaction management entirely when AUTOCOMMIT is False.",
    "sha": "f7245b83bb2df9d66a375d46a4be8de093957fa7",
    "files": [
        {
            "sha": "0799d23bb676ba46f297b3b0d0b53098ddd36d14",
            "filename": "django/db/transaction.py",
            "status": "modified",
            "additions": 22,
            "deletions": 4,
            "changes": 26,
            "blob_url": "https://github.com/django/django/blob/f7245b83bb2df9d66a375d46a4be8de093957fa7/django%2Fdb%2Ftransaction.py",
            "raw_url": "https://github.com/django/django/raw/f7245b83bb2df9d66a375d46a4be8de093957fa7/django%2Fdb%2Ftransaction.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Ftransaction.py?ref=f7245b83bb2df9d66a375d46a4be8de093957fa7",
            "patch": "@@ -308,6 +308,24 @@ def atomic(using=None):\n         return Atomic(using)\n \n \n+def atomic_if_autocommit(using=None):\n+    # This variant only exists to support the ability to disable transaction\n+    # management entirely in the DATABASES setting. It doesn't care about the\n+    # autocommit state at run time.\n+    db = DEFAULT_DB_ALIAS if callable(using) else using\n+    autocommit = get_connection(db).settings_dict['AUTOCOMMIT']\n+\n+    if autocommit:\n+        return atomic(using)\n+    else:\n+        # Bare decorator: @atomic_if_autocommit\n+        if callable(using):\n+            return using\n+        # Decorator: @atomic_if_autocommit(...)\n+        else:\n+            return lambda func: func\n+\n+\n ############################################\n # Deprecated decorators / context managers #\n ############################################\n@@ -431,13 +449,13 @@ def commit_on_success_unless_managed(using=None):\n     Transitory API to preserve backwards-compatibility while refactoring.\n \n     Once the legacy transaction management is fully deprecated, this should\n-    simply be replaced by atomic. Until then, it's necessary to avoid making a\n-    commit where Django didn't use to, since entering atomic in managed mode\n-    triggers a commmit.\n+    simply be replaced by atomic_if_autocommit. Until then, it's necessary to\n+    avoid making a commit where Django didn't use to, since entering atomic in\n+    managed mode triggers a commmit.\n     \"\"\"\n     connection = get_connection(using)\n     if connection.autocommit or connection.in_atomic_block:\n-        return atomic(using)\n+        return atomic_if_autocommit(using)\n     else:\n         def entering(using):\n             pass"
        }
    ],
    "stats": {
        "total": 26,
        "additions": 22,
        "deletions": 4
    }
}