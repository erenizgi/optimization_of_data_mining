{
    "author": "aaugustin",
    "message": "Enabled database-level autocommit for all backends.\n\nThis is mostly a documentation change.\n\nIt has the same backwards-incompatibility consequences as those\ndescribed for PostgreSQL in a previous commit.",
    "sha": "5e27debc5cba30c84f99151a84c5fd846a65b091",
    "files": [
        {
            "sha": "4031e8f668719993e4c95e1f2156221a0ff67eb8",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/5e27debc5cba30c84f99151a84c5fd846a65b091/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/5e27debc5cba30c84f99151a84c5fd846a65b091/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=5e27debc5cba30c84f99151a84c5fd846a65b091",
            "patch": "@@ -98,6 +98,8 @@ def connect(self):\n         conn_params = self.get_connection_params()\n         self.connection = self.get_new_connection(conn_params)\n         self.init_connection_state()\n+        if not settings.TRANSACTIONS_MANAGED:\n+            self.set_autocommit()\n         connection_created.send(sender=self.__class__, connection=self)\n \n     def ensure_connection(self):"
        },
        {
            "sha": "5c5f5e185a07c002b13d13fafec6b0d46728c141",
            "filename": "django/db/backends/postgresql_psycopg2/base.py",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/5e27debc5cba30c84f99151a84c5fd846a65b091/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/5e27debc5cba30c84f99151a84c5fd846a65b091/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py?ref=5e27debc5cba30c84f99151a84c5fd846a65b091",
            "patch": "@@ -136,7 +136,6 @@ def init_connection_state(self):\n                 self.connection.cursor().execute(\n                         self.ops.set_time_zone_sql(), [tz])\n         self.connection.set_isolation_level(self.isolation_level)\n-        self.set_autocommit(not settings.TRANSACTIONS_MANAGED)\n \n     def create_cursor(self):\n         cursor = self.connection.cursor()"
        },
        {
            "sha": "4dafb3774f6c7c507bc0b11c3c238480d35b2c7d",
            "filename": "docs/ref/databases.txt",
            "status": "modified",
            "additions": 13,
            "deletions": 45,
            "changes": 58,
            "blob_url": "https://github.com/django/django/blob/5e27debc5cba30c84f99151a84c5fd846a65b091/docs%2Fref%2Fdatabases.txt",
            "raw_url": "https://github.com/django/django/raw/5e27debc5cba30c84f99151a84c5fd846a65b091/docs%2Fref%2Fdatabases.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fdatabases.txt?ref=5e27debc5cba30c84f99151a84c5fd846a65b091",
            "patch": "@@ -69,7 +69,6 @@ even ``0``, because it doesn't make sense to maintain a connection that's\n unlikely to be reused. This will help keep the number of simultaneous\n connections to this database small.\n \n-\n The development server creates a new thread for each request it handles,\n negating the effect of persistent connections.\n \n@@ -104,7 +103,8 @@ Optimizing PostgreSQL's configuration\n Django needs the following parameters for its database connections:\n \n - ``client_encoding``: ``'UTF8'``,\n-- ``default_transaction_isolation``: ``'read committed'``,\n+- ``default_transaction_isolation``: ``'read committed'`` by default,\n+  or the value set in the connection options (see below),\n - ``timezone``: ``'UTC'`` when :setting:`USE_TZ` is ``True``, value of\n   :setting:`TIME_ZONE` otherwise.\n \n@@ -118,30 +118,16 @@ will do some additional queries to set these parameters.\n \n .. _ALTER ROLE: http://www.postgresql.org/docs/current/interactive/sql-alterrole.html\n \n-Transaction handling\n----------------------\n-\n-:doc:`By default </topics/db/transactions>`, Django runs with an open\n-transaction which it commits automatically when any built-in, data-altering\n-model function is called. The PostgreSQL backends normally operate the same as\n-any other Django backend in this respect.\n-\n .. _postgresql-autocommit-mode:\n \n Autocommit mode\n-~~~~~~~~~~~~~~~\n+---------------\n \n-If your application is particularly read-heavy and doesn't make many\n-database writes, the overhead of a constantly open transaction can\n-sometimes be noticeable. For those situations, you can configure Django\n-to use *\"autocommit\"* behavior for the connection, meaning that each database\n-operation will normally be in its own transaction, rather than having\n-the transaction extend over multiple operations. In this case, you can\n-still manually start a transaction if you're doing something that\n-requires consistency across multiple database operations. The\n-autocommit behavior is enabled by setting the ``autocommit`` key in\n-the :setting:`OPTIONS` part of your database configuration in\n-:setting:`DATABASES`::\n+.. versionchanged:: 1.6\n+\n+In previous versions of Django, database-level autocommit could be enabled by\n+setting the ``autocommit`` key in the :setting:`OPTIONS` part of your database\n+configuration in :setting:`DATABASES`::\n \n     DATABASES = {\n         # ...\n@@ -150,29 +136,11 @@ the :setting:`OPTIONS` part of your database configuration in\n         },\n     }\n \n-In this configuration, Django still ensures that :ref:`delete()\n-<topics-db-queries-delete>` and :ref:`update() <topics-db-queries-update>`\n-queries run inside a single transaction, so that either all the affected\n-objects are changed or none of them are.\n-\n-.. admonition:: This is database-level autocommit\n-\n-    This functionality is not the same as the :ref:`autocommit\n-    <topics-db-transactions-autocommit>` decorator. That decorator is\n-    a Django-level implementation that commits automatically after\n-    data changing operations. The feature enabled using the\n-    :setting:`OPTIONS` option provides autocommit behavior at the\n-    database adapter level. It commits after *every* operation.\n-\n-If you are using this feature and performing an operation akin to delete or\n-updating that requires multiple operations, you are strongly recommended to\n-wrap you operations in manual transaction handling to ensure data consistency.\n-You should also audit your existing code for any instances of this behavior\n-before enabling this feature. It's faster, but it provides less automatic\n-protection for multi-call operations.\n+Since Django 1.6, autocommit is turned on by default. This configuration is\n+ignored and can be safely removed.\n \n Isolation level\n-~~~~~~~~~~~~~~~\n+---------------\n \n .. versionadded:: 1.6\n \n@@ -200,7 +168,7 @@ such as ``REPEATABLE READ`` or ``SERIALIZABLE``, set it in the\n .. _postgresql-isolation-levels: http://www.postgresql.org/docs/devel/static/transaction-iso.html\n \n Indexes for ``varchar`` and ``text`` columns\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+--------------------------------------------\n \n When specifying ``db_index=True`` on your model fields, Django typically\n outputs a single ``CREATE INDEX`` statement.  However, if the database type\n@@ -457,7 +425,7 @@ Savepoints\n Both the Django ORM and MySQL (when using the InnoDB :ref:`storage engine\n <mysql-storage-engines>`) support database :ref:`savepoints\n <topics-db-transactions-savepoints>`, but this feature wasn't available in\n-Django until version 1.4 when such supports was added.\n+Django until version 1.4 when such support was added.\n \n If you use the MyISAM storage engine please be aware of the fact that you will\n receive database-generated errors if you try to use the :ref:`savepoint-related"
        },
        {
            "sha": "6f620e17e2f2510d040f6aa9171c87dd4e01cedf",
            "filename": "docs/ref/request-response.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/5e27debc5cba30c84f99151a84c5fd846a65b091/docs%2Fref%2Frequest-response.txt",
            "raw_url": "https://github.com/django/django/raw/5e27debc5cba30c84f99151a84c5fd846a65b091/docs%2Fref%2Frequest-response.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Frequest-response.txt?ref=5e27debc5cba30c84f99151a84c5fd846a65b091",
            "patch": "@@ -814,8 +814,8 @@ generating large CSV files.\n .. admonition:: Performance considerations\n \n     Django is designed for short-lived requests. Streaming responses will tie\n-    a worker process and keep a database connection idle in transaction for\n-    the entire duration of the response. This may result in poor performance.\n+    a worker process for the entire duration of the response. This may result\n+    in poor performance.\n \n     Generally speaking, you should perform expensive tasks outside of the\n     request-response cycle, rather than resorting to a streamed response."
        },
        {
            "sha": "c55ef0ef3806f4372d708596bf2cb617f28c31ba",
            "filename": "docs/releases/1.6.txt",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/django/django/blob/5e27debc5cba30c84f99151a84c5fd846a65b091/docs%2Freleases%2F1.6.txt",
            "raw_url": "https://github.com/django/django/raw/5e27debc5cba30c84f99151a84c5fd846a65b091/docs%2Freleases%2F1.6.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.6.txt?ref=5e27debc5cba30c84f99151a84c5fd846a65b091",
            "patch": "@@ -30,6 +30,18 @@ prevention <clickjacking-prevention>` are turned on.\n If the default templates don't suit your tastes, you can use :ref:`custom\n project and app templates <custom-app-and-project-templates>`.\n \n+Improved transaction management\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Django's transaction management was overhauled. Database-level autocommit is\n+now turned on by default. This makes transaction handling more explicit and\n+should improve performance. The existing APIs were deprecated, and new APIs\n+were introduced, as described in :doc:`/topics/db/transactions`.\n+\n+Please review carefully the list of :ref:`known backwards-incompatibilities\n+<transactions-changes-from-1.5>` to determine if you need to make changes in\n+your code.\n+\n Persistent database connections\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n@@ -148,6 +160,16 @@ Backwards incompatible changes in 1.6\n     deprecation timeline for a given feature, its removal may appear as a\n     backwards incompatible change.\n \n+* Database-level autocommit is enabled by default in Django 1.6. While this\n+  doesn't change the general spirit of Django's transaction management, there\n+  are a few known backwards-incompatibities, described in the :ref:`transaction\n+  management docs <transactions-changes-from-1.5>`. You should review your code\n+  to determine if you're affected.\n+\n+* In previous versions, database-level autocommit was only an option for\n+  PostgreSQL, and it was disabled by default. This option is now\n+  :ref:`ignored <postgresql-autocommit-mode>`.\n+\n * The ``django.db.models.query.EmptyQuerySet`` can't be instantiated any more -\n   it is only usable as a marker class for checking if\n   :meth:`~django.db.models.query.QuerySet.none` has been called:"
        },
        {
            "sha": "b2161fe65b89790f8ba7f9399405ed2367dfe3e9",
            "filename": "docs/topics/db/sql.txt",
            "status": "modified",
            "additions": 26,
            "deletions": 35,
            "changes": 61,
            "blob_url": "https://github.com/django/django/blob/5e27debc5cba30c84f99151a84c5fd846a65b091/docs%2Ftopics%2Fdb%2Fsql.txt",
            "raw_url": "https://github.com/django/django/raw/5e27debc5cba30c84f99151a84c5fd846a65b091/docs%2Ftopics%2Fdb%2Fsql.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Fsql.txt?ref=5e27debc5cba30c84f99151a84c5fd846a65b091",
            "patch": "@@ -201,31 +201,32 @@ perform queries that don't map cleanly to models, or directly execute\n In these cases, you can always access the database directly, routing around\n the model layer entirely.\n \n-The object ``django.db.connection`` represents the\n-default database connection, and ``django.db.transaction`` represents the\n-default database transaction. To use the database connection, call\n-``connection.cursor()`` to get a cursor object. Then, call\n-``cursor.execute(sql, [params])`` to execute the SQL and ``cursor.fetchone()``\n-or ``cursor.fetchall()`` to return the resulting rows. After performing a data\n-changing operation, you should then call\n-``transaction.commit_unless_managed()`` to ensure your changes are committed\n-to the database. If your query is purely a data retrieval operation, no commit\n-is required. For example::\n+The object ``django.db.connection`` represents the default database\n+connection. To use the database connection, call ``connection.cursor()`` to\n+get a cursor object. Then, call ``cursor.execute(sql, [params])`` to execute\n+the SQL and ``cursor.fetchone()`` or ``cursor.fetchall()`` to return the\n+resulting rows.\n+\n+For example::\n+\n+    from django.db import connection\n \n     def my_custom_sql():\n-        from django.db import connection, transaction\n         cursor = connection.cursor()\n \n-        # Data modifying operation - commit required\n         cursor.execute(\"UPDATE bar SET foo = 1 WHERE baz = %s\", [self.baz])\n-        transaction.commit_unless_managed()\n \n-        # Data retrieval operation - no commit required\n         cursor.execute(\"SELECT foo FROM bar WHERE baz = %s\", [self.baz])\n         row = cursor.fetchone()\n \n         return row\n \n+.. versionchanged:: 1.6\n+    In Django 1.5 and earlier, after performing a data changing operation, you\n+    had to call ``transaction.commit_unless_managed()`` to ensure your changes\n+    were committed to the database. Since Django now defaults to database-level\n+    autocommit, this isn't necessary any longer.\n+\n If you are using :doc:`more than one database </topics/db/multi-db>`, you can\n use ``django.db.connections`` to obtain the connection (and cursor) for a\n specific database. ``django.db.connections`` is a dictionary-like\n@@ -235,7 +236,6 @@ alias::\n     from django.db import connections\n     cursor = connections['my_db_alias'].cursor()\n     # Your code here...\n-    transaction.commit_unless_managed(using='my_db_alias')\n \n By default, the Python DB API will return results without their field\n names, which means you end up with a ``list`` of values, rather than a\n@@ -260,27 +260,18 @@ Here is an example of the difference between the two::\n     >>> dictfetchall(cursor)\n     [{'parent_id': None, 'id': 54360982L}, {'parent_id': None, 'id': 54360880L}]\n \n-\n-.. _transactions-and-raw-sql:\n-\n-Transactions and raw SQL\n-------------------------\n-\n-When you make a raw SQL call, Django will automatically mark the\n-current transaction as dirty. You must then ensure that the\n-transaction containing those calls is closed correctly. See :ref:`the\n-notes on the requirements of Django's transaction handling\n-<topics-db-transactions-requirements>` for more details.\n-\n Connections and cursors\n -----------------------\n \n ``connection`` and ``cursor`` mostly implement the standard Python DB-API\n-described in :pep:`249` (except when it comes to :doc:`transaction handling\n-</topics/db/transactions>`). If you're not familiar with the Python DB-API, note\n-that the SQL statement in ``cursor.execute()`` uses placeholders, ``\"%s\"``,\n-rather than adding parameters directly within the SQL. If you use this\n-technique, the underlying database library will automatically add quotes and\n-escaping to your parameter(s) as necessary. (Also note that Django expects the\n-``\"%s\"`` placeholder, *not* the ``\"?\"`` placeholder, which is used by the SQLite\n-Python bindings. This is for the sake of consistency and sanity.)\n+described in :pep:`249` — except when it comes to :doc:`transaction handling\n+</topics/db/transactions>`.\n+\n+If you're not familiar with the Python DB-API, note that the SQL statement in\n+``cursor.execute()`` uses placeholders, ``\"%s\"``, rather than adding\n+parameters directly within the SQL. If you use this technique, the underlying\n+database library will automatically escape your parameters as necessary.\n+\n+Also note that Django expects the ``\"%s\"`` placeholder, *not* the ``\"?\"``\n+placeholder, which is used by the SQLite Python bindings. This is for the sake\n+of consistency and sanity."
        },
        {
            "sha": "93c4a3b11ddab47d6a9d0137f2e5fac83c2c5210",
            "filename": "docs/topics/db/transactions.txt",
            "status": "modified",
            "additions": 173,
            "deletions": 57,
            "changes": 230,
            "blob_url": "https://github.com/django/django/blob/5e27debc5cba30c84f99151a84c5fd846a65b091/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "raw_url": "https://github.com/django/django/raw/5e27debc5cba30c84f99151a84c5fd846a65b091/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Ftransactions.txt?ref=5e27debc5cba30c84f99151a84c5fd846a65b091",
            "patch": "@@ -4,29 +4,32 @@ Managing database transactions\n \n .. module:: django.db.transaction\n \n-Django gives you a few ways to control how database transactions are managed,\n-if you're using a database that supports transactions.\n+Django gives you a few ways to control how database transactions are managed.\n \n Django's default transaction behavior\n =====================================\n \n-Django's default behavior is to run with an open transaction which it\n-commits automatically when any built-in, data-altering model function is\n-called. For example, if you call ``model.save()`` or ``model.delete()``, the\n-change will be committed immediately.\n+Django's default behavior is to run in autocommit mode. Each query is\n+immediately committed to the database. :ref:`See below for details\n+<autocommit-details>`.\n \n-This is much like the auto-commit setting for most databases. As soon as you\n-perform an action that needs to write to the database, Django produces the\n-``INSERT``/``UPDATE``/``DELETE`` statements and then does the ``COMMIT``.\n-There's no implicit ``ROLLBACK``.\n+..\n+   Django uses transactions or savepoints automatically to guarantee the\n+   integrity of ORM operations that require multiple queries, especially\n+   :ref:`delete() <topics-db-queries-delete>` and :ref:`update()\n+   <topics-db-queries-update>` queries.\n+\n+.. versionchanged:: 1.6\n+    Previous version of Django featured :ref:`a more complicated default\n+    behavior <transactions-changes-from-1.5>`.\n \n Tying transactions to HTTP requests\n ===================================\n \n The recommended way to handle transactions in Web requests is to tie them to\n the request and response phases via Django's ``TransactionMiddleware``.\n \n-It works like this: When a request starts, Django starts a transaction. If the\n+It works like this. When a request starts, Django starts a transaction. If the\n response is produced without problems, Django commits any pending transactions.\n If the view function produces an exception, Django rolls back any pending\n transactions.\n@@ -47,11 +50,11 @@ view functions, but also for all middleware modules that come after it. So if\n you use the session middleware after the transaction middleware, session\n creation will be part of the transaction.\n \n-The various cache middlewares are an exception:\n-``CacheMiddleware``, :class:`~django.middleware.cache.UpdateCacheMiddleware`,\n-and :class:`~django.middleware.cache.FetchFromCacheMiddleware` are never\n-affected. Even when using database caching, Django's cache backend uses its own\n-database cursor (which is mapped to its own database connection internally).\n+The various cache middlewares are an exception: ``CacheMiddleware``,\n+:class:`~django.middleware.cache.UpdateCacheMiddleware`, and\n+:class:`~django.middleware.cache.FetchFromCacheMiddleware` are never affected.\n+Even when using database caching, Django's cache backend uses its own database\n+connection internally.\n \n .. note::\n \n@@ -116,7 +119,7 @@ managers, too.\n .. function:: autocommit\n \n     Use the ``autocommit`` decorator to switch a view function to Django's\n-    default commit behavior, regardless of the global transaction setting.\n+    default commit behavior.\n \n     Example::\n \n@@ -195,14 +198,14 @@ managers, too.\n Requirements for transaction handling\n =====================================\n \n-Django requires that every transaction that is opened is closed before\n-the completion of a request. If you are using :func:`autocommit` (the\n-default commit mode) or :func:`commit_on_success`, this will be done\n-for you automatically (with the exception of :ref:`executing custom SQL\n-<executing-custom-sql>`). However, if you are manually managing\n-transactions (using the :func:`commit_manually` decorator), you must\n-ensure that the transaction is either committed or rolled back before\n-a request is completed.\n+Django requires that every transaction that is opened is closed before the\n+completion of a request.\n+\n+If you are using :func:`autocommit` (the default commit mode) or\n+:func:`commit_on_success`, this will be done for you automatically. However,\n+if you are manually managing transactions (using the :func:`commit_manually`\n+decorator), you must ensure that the transaction is either committed or rolled\n+back before a request is completed.\n \n This applies to all database operations, not just write operations. Even\n if your transaction only reads from the database, the transaction must\n@@ -231,17 +234,17 @@ How to globally deactivate transaction management\n =================================================\n \n Control freaks can totally disable all transaction management by setting\n-:setting:`TRANSACTIONS_MANAGED` to ``True`` in the Django settings file.\n+:setting:`TRANSACTIONS_MANAGED` to ``True`` in the Django settings file. If\n+you do this, Django won't enable autocommit. You'll get the regular behavior\n+of the underlying database library.\n \n-If you do this, Django won't provide any automatic transaction management\n-whatsoever. Middleware will no longer implicitly commit transactions, and\n-you'll need to roll management yourself. This even requires you to commit\n-changes done by middleware somewhere else.\n+This requires you to commit explicitly every transaction, even those started\n+by Django or by third-party libraries. Thus, this is best used in situations\n+where you want to run your own transaction-controlling middleware or do\n+something really strange.\n \n-Thus, this is best used in situations where you want to run your own\n-transaction-controlling middleware or do something really strange. In almost\n-all situations, you'll be better off using the default behavior, or the\n-transaction middleware, and only modify selected functions as needed.\n+In almost all situations, you'll be better off using the default behavior, or\n+the transaction middleware, and only modify selected functions as needed.\n \n .. _topics-db-transactions-savepoints:\n \n@@ -308,8 +311,11 @@ The following example demonstrates the use of savepoints::\n \n       transaction.commit()\n \n+Database-specific notes\n+=======================\n+\n Transactions in MySQL\n-=====================\n+---------------------\n \n If you're using MySQL, your tables may or may not support transactions; it\n depends on your MySQL version and the table types you're using. (By\n@@ -318,14 +324,14 @@ peculiarities are outside the scope of this article, but the MySQL site has\n `information on MySQL transactions`_.\n \n If your MySQL setup does *not* support transactions, then Django will function\n-in auto-commit mode: Statements will be executed and committed as soon as\n+in autocommit mode: Statements will be executed and committed as soon as\n they're called. If your MySQL setup *does* support transactions, Django will\n handle transactions as explained in this document.\n \n .. _information on MySQL transactions: http://dev.mysql.com/doc/refman/5.0/en/sql-syntax-transactions.html\n \n Handling exceptions within PostgreSQL transactions\n-==================================================\n+--------------------------------------------------\n \n When a call to a PostgreSQL cursor raises an exception (typically\n ``IntegrityError``), all subsequent SQL in the same transaction will fail with\n@@ -338,7 +344,7 @@ force_insert/force_update flag, or invoking custom SQL.\n There are several ways to recover from this sort of error.\n \n Transaction rollback\n---------------------\n+~~~~~~~~~~~~~~~~~~~~\n \n The first option is to roll back the entire transaction. For example::\n \n@@ -355,7 +361,7 @@ made by ``a.save()`` would be lost, even though that operation raised no error\n itself.\n \n Savepoint rollback\n-------------------\n+~~~~~~~~~~~~~~~~~~\n \n If you are using PostgreSQL 8 or later, you can use :ref:`savepoints\n <topics-db-transactions-savepoints>` to control the extent of a rollback.\n@@ -375,25 +381,135 @@ offending operation, rather than the entire transaction. For example::\n In this example, ``a.save()`` will not be undone in the case where\n ``b.save()`` raises an exception.\n \n-Database-level autocommit\n--------------------------\n+Under the hood\n+==============\n \n-With PostgreSQL 8.2 or later, there is an advanced option to run PostgreSQL\n-with :doc:`database-level autocommit </ref/databases>`. If you use this option,\n-there is no constantly open transaction, so it is always possible to continue\n-after catching an exception. For example::\n+.. _autocommit-details:\n \n-    a.save() # succeeds\n-    try:\n-        b.save() # Could throw exception\n-    except IntegrityError:\n-        pass\n-    c.save() # succeeds\n+Details on autocommit\n+---------------------\n \n-.. note::\n+In the SQL standards, each SQL query starts a transaction, unless one is\n+already in progress. Such transactions must then be committed or rolled back.\n+\n+This isn't always convenient for application developers. To alleviate this\n+problem, most databases provide an autocommit mode. When autocommit is turned\n+on, each SQL query is wrapped in its own transaction. In other words, the\n+transaction is not only automatically started, but also automatically\n+committed.\n+\n+:pep:`249`, the Python Database API Specification v2.0, requires autocommit to\n+be initially turned off. Django overrides this default and turns autocommit\n+on.\n+\n+To avoid this, you can :ref:`deactivate the transaction management\n+<deactivate-transaction-management>`, but it isn't recommended.\n+\n+.. versionchanged:: 1.6\n+    Before Django 1.6, autocommit was turned off, and it was emulated by\n+    forcing a commit after write operations in the ORM.\n+\n+.. warning::\n+\n+    If you're using the database API directly — for instance, you're running\n+    SQL queries with ``cursor.execute()`` — be aware that autocommit is on,\n+    and consider wrapping your operations in a transaction to ensure\n+    consistency.\n+\n+.. _transaction-states:\n+\n+Transaction management states\n+-----------------------------\n+\n+At any time, each database connection is in one of these two states:\n+\n+- **auto mode**: autocommit is enabled;\n+- **managed mode**: autocommit is disabled.\n+\n+Django starts in auto mode. ``TransactionMiddleware``,\n+:func:`commit_on_success` and :func:`commit_manually` activate managed mode;\n+:func:`autocommit` activates auto mode.\n+\n+Internally, Django keeps a stack of states. Activations and deactivations must\n+be balanced.\n+\n+For example, at the beginning of each HTTP request, ``TransactionMiddleware``\n+switches to managed mode; at the end of the request, it commits or rollbacks,\n+and switches back to auto mode.\n+\n+.. admonition:: Nesting decorators / context managers\n+\n+    :func:`commit_on_success` has two effects: it changes the transaction\n+    state, and defines an atomic transaction block.\n+\n+    Nesting with :func:`autocommit` and :func:`commit_manually` will give the\n+    expected results in terms of transaction state, but not in terms of\n+    transaction semantics. Most often, the inner block will commit, breaking\n+    the atomicity of the outer block.\n+\n+Django currently doesn't provide any APIs to create transactions in auto mode.\n+\n+.. _transactions-changes-from-1.5:\n+\n+Changes from Django 1.5 and earlier\n+===================================\n+\n+Since version 1.6, Django uses database-level autocommit in auto mode.\n+\n+Previously, it implemented application-level autocommit by triggering a commit\n+after each ORM write.\n+\n+As a consequence, each database query (for instance, an\n+ORM read) started a transaction that lasted until the next ORM write. Such\n+\"automatic transactions\" no longer exist in Django 1.6.\n+\n+There are four known scenarios where this is backwards-incompatible.\n+\n+Note that managed mode isn't affected at all. This section assumes auto mode.\n+See the :ref:`description of modes <transaction-states>` above.\n+\n+Sequences of custom SQL queries\n+-------------------------------\n+\n+If you're executing several :ref:`custom SQL queries <executing-custom-sql>`\n+in a row, each one now runs in its own transaction, instead of sharing the\n+same \"automatic transaction\". If you need to enforce atomicity, you must wrap\n+the sequence of queries in :func:`commit_on_success`.\n+\n+To check for this problem, look for calls to ``cursor.execute()``. They're\n+usually followed by a call to ``transaction.commit_unless_managed``, which\n+isn't necessary any more and should be removed.\n+\n+Select for update\n+-----------------\n+\n+If you were relying on \"automatic transactions\" to provide locking between\n+:meth:`~django.db.models.query.QuerySet.select_for_update` and a subsequent\n+write operation — an extremely fragile design, but nonetheless possible — you\n+must wrap the relevant code in :func:`commit_on_success`.\n+\n+Using a high isolation level\n+----------------------------\n+\n+If you were using the \"repeatable read\" isolation level or higher, and if you\n+relied on \"automatic transactions\" to guarantee consistency between successive\n+reads, the new behavior is backwards-incompatible. To maintain consistency,\n+you must wrap such sequences in :func:`commit_on_success`.\n+\n+MySQL defaults to \"repeatable read\" and SQLite to \"serializable\"; they may be\n+affected by this problem.\n+\n+At the \"read committed\" isolation level or lower, \"automatic transactions\"\n+have no effect on the semantics of any sequence of ORM operations.\n+\n+PostgreSQL and Oracle default to \"read committed\" and aren't affected, unless\n+you changed the isolation level.\n+\n+Using unsupported database features\n+-----------------------------------\n \n-    This is not the same as the :ref:`autocommit decorator\n-    <topics-db-transactions-autocommit>`. When using database level autocommit\n-    there is no database transaction at all. The ``autocommit`` decorator\n-    still uses transactions, automatically committing each transaction when\n-    a database modifying operation occurs.\n+With triggers, views, or functions, it's possible to make ORM reads result in\n+database modifications. Django 1.5 and earlier doesn't deal with this case and\n+it's theoretically possible to observe a different behavior after upgrading to\n+Django 1.6 or later. In doubt, use :func:`commit_on_success` to enforce\n+integrity."
        }
    ],
    "stats": {
        "total": 378,
        "additions": 238,
        "deletions": 140
    }
}