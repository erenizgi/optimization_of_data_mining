{
    "author": "aaugustin",
    "message": "Made atomic usable when autocommit is off.\n\nThanks Anssi for haggling until I implemented this.\n\nThis change alleviates the need for atomic_if_autocommit. When\nautocommit is disabled for a database, atomic will simply create and\nrelease savepoints, and not commit anything. This honors the contract of\nnot doing any transaction management.\n\nThis change also makes the hack to allow using atomic within the legacy\ntransaction management redundant.\n\nNone of the above will work with SQLite, because of a flaw in the design\nof the sqlite3 library. This is a known limitation that cannot be lifted\nwithout unacceptable side effects eg. triggering arbitrary commits.",
    "sha": "83a416f5e764705ed553f3513bdf9587270554c6",
    "files": [
        {
            "sha": "77492841228f73048dde63c67146520f7239eec1",
            "filename": "django/core/cache/backends/db.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/83a416f5e764705ed553f3513bdf9587270554c6/django%2Fcore%2Fcache%2Fbackends%2Fdb.py",
            "raw_url": "https://github.com/django/django/raw/83a416f5e764705ed553f3513bdf9587270554c6/django%2Fcore%2Fcache%2Fbackends%2Fdb.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Fdb.py?ref=83a416f5e764705ed553f3513bdf9587270554c6",
            "patch": "@@ -109,7 +109,7 @@ def _base_set(self, mode, key, value, timeout=None):\n         if six.PY3:\n             b64encoded = b64encoded.decode('latin1')\n         try:\n-            with transaction.atomic_if_autocommit(using=db):\n+            with transaction.atomic(using=db):\n                 cursor.execute(\"SELECT cache_key, expires FROM %s \"\n                                \"WHERE cache_key = %%s\" % table, [key])\n                 result = cursor.fetchone()"
        },
        {
            "sha": "27b39a3d1febdd8033933b92a4226abbfea19769",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/django/django/blob/83a416f5e764705ed553f3513bdf9587270554c6/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/83a416f5e764705ed553f3513bdf9587270554c6/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=83a416f5e764705ed553f3513bdf9587270554c6",
            "patch": "@@ -50,15 +50,16 @@ def __init__(self, settings_dict, alias=DEFAULT_DB_ALIAS,\n         # set somewhat aggressively, as the DBAPI doesn't make it easy to\n         # deduce if the connection is in transaction or not.\n         self._dirty = False\n-        # Tracks if the connection is in a transaction managed by 'atomic'\n+        # Tracks if the connection is in a transaction managed by 'atomic'.\n         self.in_atomic_block = False\n+        # Tracks if the outermost 'atomic' block should commit on exit,\n+        # ie. if autocommit was active on entry.\n+        self.commit_on_exit = True\n         # Tracks if the transaction should be rolled back to the next\n         # available savepoint because of an exception in an inner block.\n         self.needs_rollback = False\n         # List of savepoints created by 'atomic'\n         self.savepoint_ids = []\n-        # Hack to provide compatibility with legacy transaction management\n-        self._atomic_forced_unmanaged = False\n \n         # Connection termination related attributes\n         self.close_at = None"
        },
        {
            "sha": "0aed0aa4f4900caaa0f513cece1d3a4b4017b518",
            "filename": "django/db/transaction.py",
            "status": "modified",
            "additions": 69,
            "deletions": 86,
            "changes": 155,
            "blob_url": "https://github.com/django/django/blob/83a416f5e764705ed553f3513bdf9587270554c6/django%2Fdb%2Ftransaction.py",
            "raw_url": "https://github.com/django/django/raw/83a416f5e764705ed553f3513bdf9587270554c6/django%2Fdb%2Ftransaction.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Ftransaction.py?ref=83a416f5e764705ed553f3513bdf9587270554c6",
            "patch": "@@ -206,31 +206,38 @@ def __init__(self, using, savepoint):\n         self.using = using\n         self.savepoint = savepoint\n \n-    def _legacy_enter_transaction_management(self, connection):\n-        if not connection.in_atomic_block:\n-            if connection.transaction_state and connection.transaction_state[-1]:\n-                connection._atomic_forced_unmanaged = True\n-                connection.enter_transaction_management(managed=False)\n-            else:\n-                connection._atomic_forced_unmanaged = False\n-\n-    def _legacy_leave_transaction_management(self, connection):\n-        if not connection.in_atomic_block and connection._atomic_forced_unmanaged:\n-            connection.leave_transaction_management()\n-\n     def __enter__(self):\n         connection = get_connection(self.using)\n \n         # Ensure we have a connection to the database before testing\n         # autocommit status.\n         connection.ensure_connection()\n \n-        # Remove this when the legacy transaction management goes away.\n-        self._legacy_enter_transaction_management(connection)\n-\n-        if not connection.in_atomic_block and not connection.autocommit:\n-            raise TransactionManagementError(\n-                \"'atomic' cannot be used when autocommit is disabled.\")\n+        if not connection.in_atomic_block:\n+            # Reset state when entering an outermost atomic block.\n+            connection.commit_on_exit = True\n+            connection.needs_rollback = False\n+            if not connection.autocommit:\n+                # Some database adapters (namely sqlite3) don't handle\n+                # transactions and savepoints properly when autocommit is off.\n+                # Turning autocommit back on isn't an option; it would trigger\n+                # a premature commit. Give up if that happens.\n+                if connection.features.autocommits_when_autocommit_is_off:\n+                    raise TransactionManagementError(\n+                        \"Your database backend doesn't behave properly when \"\n+                        \"autocommit is off. Turn it on before using 'atomic'.\")\n+                # When entering an atomic block with autocommit turned off,\n+                # Django should only use savepoints and shouldn't commit.\n+                # This requires at least a savepoint for the outermost block.\n+                if not self.savepoint:\n+                    raise TransactionManagementError(\n+                        \"The outermost 'atomic' block cannot use \"\n+                        \"savepoint = False when autocommit is off.\")\n+                # Pretend we're already in an atomic block to bypass the code\n+                # that disables autocommit to enter a transaction, and make a\n+                # note to deal with this case in __exit__.\n+                connection.in_atomic_block = True\n+                connection.commit_on_exit = False\n \n         if connection.in_atomic_block:\n             # We're already in a transaction; create a savepoint, unless we\n@@ -255,63 +262,58 @@ def __enter__(self):\n             else:\n                 connection.set_autocommit(False)\n             connection.in_atomic_block = True\n-            connection.needs_rollback = False\n \n     def __exit__(self, exc_type, exc_value, traceback):\n         connection = get_connection(self.using)\n-        if exc_value is None and not connection.needs_rollback:\n-            if connection.savepoint_ids:\n-                # Release savepoint if there is one\n-                sid = connection.savepoint_ids.pop()\n-                if sid is not None:\n+\n+        if connection.savepoint_ids:\n+            sid = connection.savepoint_ids.pop()\n+        else:\n+            # Prematurely unset this flag to allow using commit or rollback.\n+            connection.in_atomic_block = False\n+\n+        try:\n+            if exc_value is None and not connection.needs_rollback:\n+                if connection.in_atomic_block:\n+                    # Release savepoint if there is one\n+                    if sid is not None:\n+                        try:\n+                            connection.savepoint_commit(sid)\n+                        except DatabaseError:\n+                            connection.savepoint_rollback(sid)\n+                            raise\n+                else:\n+                    # Commit transaction\n                     try:\n-                        connection.savepoint_commit(sid)\n+                        connection.commit()\n                     except DatabaseError:\n-                        connection.savepoint_rollback(sid)\n-                        # Remove this when the legacy transaction management goes away.\n-                        self._legacy_leave_transaction_management(connection)\n+                        connection.rollback()\n                         raise\n             else:\n-                # Commit transaction\n-                connection.in_atomic_block = False\n-                try:\n-                    connection.commit()\n-                except DatabaseError:\n-                    connection.rollback()\n-                    # Remove this when the legacy transaction management goes away.\n-                    self._legacy_leave_transaction_management(connection)\n-                    raise\n-                finally:\n-                    if connection.features.autocommits_when_autocommit_is_off:\n-                        connection.autocommit = True\n+                # This flag will be set to True again if there isn't a savepoint\n+                # allowing to perform the rollback at this level.\n+                connection.needs_rollback = False\n+                if connection.in_atomic_block:\n+                    # Roll back to savepoint if there is one, mark for rollback\n+                    # otherwise.\n+                    if sid is None:\n+                        connection.needs_rollback = True\n                     else:\n-                        connection.set_autocommit(True)\n-        else:\n-            # This flag will be set to True again if there isn't a savepoint\n-            # allowing to perform the rollback at this level.\n-            connection.needs_rollback = False\n-            if connection.savepoint_ids:\n-                # Roll back to savepoint if there is one, mark for rollback\n-                # otherwise.\n-                sid = connection.savepoint_ids.pop()\n-                if sid is None:\n-                    connection.needs_rollback = True\n+                        connection.savepoint_rollback(sid)\n                 else:\n-                    connection.savepoint_rollback(sid)\n-            else:\n-                # Roll back transaction\n-                connection.in_atomic_block = False\n-                try:\n+                    # Roll back transaction\n                     connection.rollback()\n-                finally:\n-                    if connection.features.autocommits_when_autocommit_is_off:\n-                        connection.autocommit = True\n-                    else:\n-                        connection.set_autocommit(True)\n-\n-        # Remove this when the legacy transaction management goes away.\n-        self._legacy_leave_transaction_management(connection)\n \n+        finally:\n+            # Outermost block exit when autocommit was enabled.\n+            if not connection.in_atomic_block:\n+                if connection.features.autocommits_when_autocommit_is_off:\n+                    connection.autocommit = True\n+                else:\n+                    connection.set_autocommit(True)\n+            # Outermost block exit when autocommit was disabled.\n+            elif not connection.savepoint_ids and not connection.commit_on_exit:\n+                connection.in_atomic_block = False\n \n     def __call__(self, func):\n         @wraps(func, assigned=available_attrs(func))\n@@ -331,24 +333,6 @@ def atomic(using=None, savepoint=True):\n         return Atomic(using, savepoint)\n \n \n-def atomic_if_autocommit(using=None, savepoint=True):\n-    # This variant only exists to support the ability to disable transaction\n-    # management entirely in the DATABASES setting. It doesn't care about the\n-    # autocommit state at run time.\n-    db = DEFAULT_DB_ALIAS if callable(using) else using\n-    autocommit = get_connection(db).settings_dict['AUTOCOMMIT']\n-\n-    if autocommit:\n-        return atomic(using, savepoint)\n-    else:\n-        # Bare decorator: @atomic_if_autocommit\n-        if callable(using):\n-            return using\n-        # Decorator: @atomic_if_autocommit(...)\n-        else:\n-            return lambda func: func\n-\n-\n ############################################\n # Deprecated decorators / context managers #\n ############################################\n@@ -472,16 +456,15 @@ def commit_on_success_unless_managed(using=None, savepoint=False):\n     Transitory API to preserve backwards-compatibility while refactoring.\n \n     Once the legacy transaction management is fully deprecated, this should\n-    simply be replaced by atomic_if_autocommit. Until then, it's necessary to\n-    avoid making a commit where Django didn't use to, since entering atomic in\n-    managed mode triggers a commmit.\n+    simply be replaced by atomic. Until then, it's necessary to guarantee that\n+    a commit occurs on exit, which atomic doesn't do when it's nested.\n \n     Unlike atomic, savepoint defaults to False because that's closer to the\n     legacy behavior.\n     \"\"\"\n     connection = get_connection(using)\n     if connection.autocommit or connection.in_atomic_block:\n-        return atomic_if_autocommit(using, savepoint)\n+        return atomic(using, savepoint)\n     else:\n         def entering(using):\n             pass"
        },
        {
            "sha": "122af1435976f5f24453b936504c736739ee59d2",
            "filename": "docs/topics/db/transactions.txt",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/django/django/blob/83a416f5e764705ed553f3513bdf9587270554c6/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "raw_url": "https://github.com/django/django/raw/83a416f5e764705ed553f3513bdf9587270554c6/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Ftransactions.txt?ref=83a416f5e764705ed553f3513bdf9587270554c6",
            "patch": "@@ -153,9 +153,6 @@ Django provides a single API to control database transactions.\n     to commit, roll back, or change the autocommit state of the database\n     connection within an ``atomic`` block will raise an exception.\n \n-    ``atomic`` can only be used in autocommit mode. It will raise an exception\n-    if autocommit is turned off.\n-\n     Under the hood, Django's transaction management code:\n \n     - opens a transaction when entering the outermost ``atomic`` block;\n@@ -171,6 +168,10 @@ Django provides a single API to control database transactions.\n     the overhead of savepoints is noticeable. It has the drawback of breaking\n     the error handling described above.\n \n+    You may use ``atomic`` when autocommit is turned off. It will only use\n+    savepoints, even for the outermost block, and it will raise an exception\n+    if the outermost block is declared with ``savepoint=False``.\n+\n .. admonition:: Performance considerations\n \n     Open transactions have a performance cost for your database server. To\n@@ -271,9 +272,8 @@ another. Review the documentation of the adapter you're using carefully.\n You must ensure that no transaction is active, usually by issuing a\n :func:`commit` or a :func:`rollback`, before turning autocommit back on.\n \n-:func:`atomic` requires autocommit to be turned on; it will raise an exception\n-if autocommit is off. Django will also refuse to turn autocommit off when an\n-:func:`atomic` block is active, because that would break atomicity.\n+Django will refuse to turn autocommit off when an :func:`atomic` block is\n+active, because that would break atomicity.\n \n Transactions\n ------------\n@@ -392,8 +392,11 @@ When autocommit is enabled, savepoints don't make sense. When it's disabled,\n commits before any statement other than ``SELECT``, ``INSERT``, ``UPDATE``,\n ``DELETE`` and ``REPLACE``.)\n \n-As a consequence, savepoints are only usable inside a transaction ie. inside\n-an :func:`atomic` block.\n+This has two consequences:\n+\n+- The low level APIs for savepoints are only usable inside a transaction ie.\n+  inside an :func:`atomic` block.\n+- It's impossible to use :func:`atomic` when autocommit is turned off.\n \n Transactions in MySQL\n ---------------------\n@@ -584,9 +587,6 @@ During the deprecation period, it's possible to use :func:`atomic` within\n However, the reverse is forbidden, because nesting the old decorators /\n context managers breaks atomicity.\n \n-If you enter :func:`atomic` while you're in managed mode, it will trigger a\n-commit to start from a clean slate.\n-\n Managing autocommit\n ~~~~~~~~~~~~~~~~~~~\n \n@@ -623,8 +623,8 @@ Disabling transaction management\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n Instead of setting ``TRANSACTIONS_MANAGED = True``, set the ``AUTOCOMMIT`` key\n-to ``False`` in the configuration of each database, as explained in :ref\n-:`deactivate-transaction-management`.\n+to ``False`` in the configuration of each database, as explained in\n+:ref:`deactivate-transaction-management`.\n \n Backwards incompatibilities\n ---------------------------"
        },
        {
            "sha": "aeb9bc3d2c11082764663f4e2a82fd60ebd06a36",
            "filename": "tests/transactions/tests.py",
            "status": "modified",
            "additions": 19,
            "deletions": 11,
            "changes": 30,
            "blob_url": "https://github.com/django/django/blob/83a416f5e764705ed553f3513bdf9587270554c6/tests%2Ftransactions%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/83a416f5e764705ed553f3513bdf9587270554c6/tests%2Ftransactions%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions%2Ftests.py?ref=83a416f5e764705ed553f3513bdf9587270554c6",
            "patch": "@@ -6,7 +6,7 @@\n from django.db import connection, transaction, IntegrityError\n from django.test import TransactionTestCase, skipUnlessDBFeature\n from django.utils import six\n-from django.utils.unittest import skipUnless\n+from django.utils.unittest import skipIf, skipUnless\n \n from .models import Reporter\n \n@@ -197,6 +197,23 @@ def tearDown(self):\n         self.atomic.__exit__(*sys.exc_info())\n \n \n+@skipIf(connection.features.autocommits_when_autocommit_is_off,\n+        \"This test requires a non-autocommit mode that doesn't autocommit.\")\n+class AtomicWithoutAutocommitTests(AtomicTests):\n+    \"\"\"All basic tests for atomic should also pass when autocommit is turned off.\"\"\"\n+\n+    def setUp(self):\n+        transaction.set_autocommit(False)\n+\n+    def tearDown(self):\n+        # The tests access the database after exercising 'atomic', initiating\n+        # a transaction ; a rollback is required before restoring autocommit.\n+        transaction.rollback()\n+        transaction.set_autocommit(True)\n+\n+\n+@skipIf(connection.features.autocommits_when_autocommit_is_off,\n+        \"This test requires a non-autocommit mode that doesn't autocommit.\")\n class AtomicInsideLegacyTransactionManagementTests(AtomicTests):\n \n     def setUp(self):\n@@ -268,16 +285,7 @@ def test_merged_outer_rollback_after_inner_failure_and_inner_success(self):\n         \"'atomic' requires transactions and savepoints.\")\n class AtomicErrorsTests(TransactionTestCase):\n \n-    def test_atomic_requires_autocommit(self):\n-        transaction.set_autocommit(False)\n-        try:\n-            with self.assertRaises(transaction.TransactionManagementError):\n-                with transaction.atomic():\n-                    pass\n-        finally:\n-            transaction.set_autocommit(True)\n-\n-    def test_atomic_prevents_disabling_autocommit(self):\n+    def test_atomic_prevents_setting_autocommit(self):\n         autocommit = transaction.get_autocommit()\n         with transaction.atomic():\n             with self.assertRaises(transaction.TransactionManagementError):"
        }
    ],
    "stats": {
        "total": 220,
        "additions": 106,
        "deletions": 114
    }
}