{
    "author": "ramiro",
    "message": "Refactor loaddata for readability.\n\nThanks Claude Paroz and Daniel Moisset for review and feedback.",
    "sha": "9e7723f851dc6e4d5eea96ab808e1a4cdd4eabd7",
    "files": [
        {
            "sha": "f6f1b1039ae78b7168d56889384c6e8fc66fe711",
            "filename": "django/core/management/commands/loaddata.py",
            "status": "modified",
            "additions": 140,
            "deletions": 133,
            "changes": 273,
            "blob_url": "https://github.com/django/django/blob/9e7723f851dc6e4d5eea96ab808e1a4cdd4eabd7/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py",
            "raw_url": "https://github.com/django/django/raw/9e7723f851dc6e4d5eea96ab808e1a4cdd4eabd7/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py?ref=9e7723f851dc6e4d5eea96ab808e1a4cdd4eabd7",
            "patch": "@@ -1,11 +1,9 @@\n from __future__ import unicode_literals\n \n-import sys\n import os\n import gzip\n import zipfile\n from optparse import make_option\n-import traceback\n \n from django.conf import settings\n from django.core import serializers\n@@ -39,19 +37,18 @@ class Command(BaseCommand):\n \n     def handle(self, *fixture_labels, **options):\n \n-        ignore = options.get('ignore')\n-        using = options.get('database')\n+        self.ignore = options.get('ignore')\n+        self.using = options.get('database')\n \n-        connection = connections[using]\n+        connection = connections[self.using]\n \n         if not len(fixture_labels):\n             raise CommandError(\n                 \"No database fixture specified. Please provide the path of at \"\n                 \"least one fixture in the command line.\"\n             )\n \n-        verbosity = int(options.get('verbosity'))\n-        show_traceback = options.get('traceback')\n+        self.verbosity = int(options.get('verbosity'))\n \n         # commit is a stealth option - it isn't really useful as\n         # a command line option, but it can be useful when invoking\n@@ -62,12 +59,10 @@ def handle(self, *fixture_labels, **options):\n         commit = options.get('commit', True)\n \n         # Keep a count of the installed objects and fixtures\n-        fixture_count = 0\n-        loaded_object_count = 0\n-        fixture_object_count = 0\n-        models = set()\n-\n-        humanize = lambda dirname: \"'%s'\" % dirname if dirname else 'absolute path'\n+        self.fixture_count = 0\n+        self.loaded_object_count = 0\n+        self.fixture_object_count = 0\n+        self.models = set()\n \n         # Get a cursor (even though we don't need one yet). This has\n         # the side effect of initializing the test database (if\n@@ -77,9 +72,9 @@ def handle(self, *fixture_labels, **options):\n         # Start transaction management. All fixtures are installed in a\n         # single transaction to ensure that all references are resolved.\n         if commit:\n-            transaction.commit_unless_managed(using=using)\n-            transaction.enter_transaction_management(using=using)\n-            transaction.managed(True, using=using)\n+            transaction.commit_unless_managed(using=self.using)\n+            transaction.enter_transaction_management(using=self.using)\n+            transaction.managed(True, using=self.using)\n \n         class SingleZipReader(zipfile.ZipFile):\n             def __init__(self, *args, **kwargs):\n@@ -89,13 +84,13 @@ def __init__(self, *args, **kwargs):\n             def read(self):\n                 return zipfile.ZipFile.read(self, self.namelist()[0])\n \n-        compression_types = {\n+        self.compression_types = {\n             None:   open,\n             'gz':   gzip.GzipFile,\n             'zip':  SingleZipReader\n         }\n         if has_bz2:\n-            compression_types['bz2'] = bz2.BZ2File\n+            self.compression_types['bz2'] = bz2.BZ2File\n \n         app_module_paths = []\n         for app in get_apps():\n@@ -112,113 +107,11 @@ def read(self):\n         try:\n             with connection.constraint_checks_disabled():\n                 for fixture_label in fixture_labels:\n-                    parts = fixture_label.split('.')\n-\n-                    if len(parts) > 1 and parts[-1] in compression_types:\n-                        compression_formats = [parts[-1]]\n-                        parts = parts[:-1]\n-                    else:\n-                        compression_formats = compression_types.keys()\n-\n-                    if len(parts) == 1:\n-                        fixture_name = parts[0]\n-                        formats = serializers.get_public_serializer_formats()\n-                    else:\n-                        fixture_name, format = '.'.join(parts[:-1]), parts[-1]\n-                        if format in serializers.get_public_serializer_formats():\n-                            formats = [format]\n-                        else:\n-                            formats = []\n-\n-                    if formats:\n-                        if verbosity >= 2:\n-                            self.stdout.write(\"Loading '%s' fixtures...\" % fixture_name)\n-                    else:\n-                        raise CommandError(\n-                            \"Problem installing fixture '%s': %s is not a known serialization format.\" %\n-                                (fixture_name, format))\n-\n-                    if os.path.isabs(fixture_name):\n-                        fixture_dirs = [fixture_name]\n-                    else:\n-                        fixture_dirs = app_fixtures + list(settings.FIXTURE_DIRS) + ['']\n-\n-                    for fixture_dir in fixture_dirs:\n-                        if verbosity >= 2:\n-                            self.stdout.write(\"Checking %s for fixtures...\" % humanize(fixture_dir))\n-\n-                        label_found = False\n-                        for combo in product([using, None], formats, compression_formats):\n-                            database, format, compression_format = combo\n-                            file_name = '.'.join(\n-                                p for p in [\n-                                    fixture_name, database, format, compression_format\n-                                ]\n-                                if p\n-                            )\n-\n-                            if verbosity >= 3:\n-                                self.stdout.write(\"Trying %s for %s fixture '%s'...\" % \\\n-                                    (humanize(fixture_dir), file_name, fixture_name))\n-                            full_path = os.path.join(fixture_dir, file_name)\n-                            open_method = compression_types[compression_format]\n-                            try:\n-                                fixture = open_method(full_path, 'r')\n-                            except IOError:\n-                                if verbosity >= 2:\n-                                    self.stdout.write(\"No %s fixture '%s' in %s.\" % \\\n-                                        (format, fixture_name, humanize(fixture_dir)))\n-                            else:\n-                                try:\n-                                    if label_found:\n-                                        raise CommandError(\"Multiple fixtures named '%s' in %s. Aborting.\" %\n-                                            (fixture_name, humanize(fixture_dir)))\n-\n-                                    fixture_count += 1\n-                                    objects_in_fixture = 0\n-                                    loaded_objects_in_fixture = 0\n-                                    if verbosity >= 2:\n-                                        self.stdout.write(\"Installing %s fixture '%s' from %s.\" % \\\n-                                            (format, fixture_name, humanize(fixture_dir)))\n-\n-                                    objects = serializers.deserialize(format, fixture, using=using, ignorenonexistent=ignore)\n-\n-                                    for obj in objects:\n-                                        objects_in_fixture += 1\n-                                        if router.allow_syncdb(using, obj.object.__class__):\n-                                            loaded_objects_in_fixture += 1\n-                                            models.add(obj.object.__class__)\n-                                            try:\n-                                                obj.save(using=using)\n-                                            except (DatabaseError, IntegrityError) as e:\n-                                                e.args = (\"Could not load %(app_label)s.%(object_name)s(pk=%(pk)s): %(error_msg)s\" % {\n-                                                        'app_label': obj.object._meta.app_label,\n-                                                        'object_name': obj.object._meta.object_name,\n-                                                        'pk': obj.object.pk,\n-                                                        'error_msg': force_text(e)\n-                                                    },)\n-                                                raise\n-\n-                                    loaded_object_count += loaded_objects_in_fixture\n-                                    fixture_object_count += objects_in_fixture\n-                                    label_found = True\n-                                except Exception as e:\n-                                    if not isinstance(e, CommandError):\n-                                        e.args = (\"Problem installing fixture '%s': %s\" % (full_path, e),)\n-                                    raise\n-                                finally:\n-                                    fixture.close()\n-\n-                                # If the fixture we loaded contains 0 objects, assume that an\n-                                # error was encountered during fixture loading.\n-                                if objects_in_fixture == 0:\n-                                    raise CommandError(\n-                                        \"No fixture data found for '%s'. (File format may be invalid.)\" %\n-                                            (fixture_name))\n+                    self.load_label(fixture_label, app_fixtures)\n \n             # Since we disabled constraint checks, we must manually check for\n             # any invalid keys that might have been added\n-            table_names = [model._meta.db_table for model in models]\n+            table_names = [model._meta.db_table for model in self.models]\n             try:\n                 connection.check_constraints(table_names=table_names)\n             except Exception as e:\n@@ -229,35 +122,149 @@ def read(self):\n             raise\n         except Exception as e:\n             if commit:\n-                transaction.rollback(using=using)\n-                transaction.leave_transaction_management(using=using)\n+                transaction.rollback(using=self.using)\n+                transaction.leave_transaction_management(using=self.using)\n             raise\n \n         # If we found even one object in a fixture, we need to reset the\n         # database sequences.\n-        if loaded_object_count > 0:\n-            sequence_sql = connection.ops.sequence_reset_sql(no_style(), models)\n+        if self.loaded_object_count > 0:\n+            sequence_sql = connection.ops.sequence_reset_sql(no_style(), self.models)\n             if sequence_sql:\n-                if verbosity >= 2:\n+                if self.verbosity >= 2:\n                     self.stdout.write(\"Resetting sequences\\n\")\n                 for line in sequence_sql:\n                     cursor.execute(line)\n \n         if commit:\n-            transaction.commit(using=using)\n-            transaction.leave_transaction_management(using=using)\n+            transaction.commit(using=self.using)\n+            transaction.leave_transaction_management(using=self.using)\n \n-        if verbosity >= 1:\n-            if fixture_object_count == loaded_object_count:\n+        if self.verbosity >= 1:\n+            if self.fixture_object_count == self.loaded_object_count:\n                 self.stdout.write(\"Installed %d object(s) from %d fixture(s)\" % (\n-                    loaded_object_count, fixture_count))\n+                    self.loaded_object_count, self.fixture_count))\n             else:\n                 self.stdout.write(\"Installed %d object(s) (of %d) from %d fixture(s)\" % (\n-                    loaded_object_count, fixture_object_count, fixture_count))\n+                    self.loaded_object_count, self.fixture_object_count, self.fixture_count))\n \n         # Close the DB connection. This is required as a workaround for an\n         # edge case in MySQL: if the same connection is used to\n         # create tables, load data, and query, the query can return\n         # incorrect results. See Django #7572, MySQL #37735.\n         if commit:\n             connection.close()\n+\n+    def load_label(self, fixture_label, app_fixtures):\n+\n+        parts = fixture_label.split('.')\n+\n+        if len(parts) > 1 and parts[-1] in self.compression_types:\n+            compression_formats = [parts[-1]]\n+            parts = parts[:-1]\n+        else:\n+            compression_formats = self.compression_types.keys()\n+\n+        if len(parts) == 1:\n+            fixture_name = parts[0]\n+            formats = serializers.get_public_serializer_formats()\n+        else:\n+            fixture_name, format = '.'.join(parts[:-1]), parts[-1]\n+            if format in serializers.get_public_serializer_formats():\n+                formats = [format]\n+            else:\n+                formats = []\n+\n+        if formats:\n+            if self.verbosity >= 2:\n+                self.stdout.write(\"Loading '%s' fixtures...\" % fixture_name)\n+        else:\n+            raise CommandError(\n+                \"Problem installing fixture '%s': %s is not a known serialization format.\" %\n+                    (fixture_name, format))\n+\n+        if os.path.isabs(fixture_name):\n+            fixture_dirs = [fixture_name]\n+        else:\n+            fixture_dirs = app_fixtures + list(settings.FIXTURE_DIRS) + ['']\n+\n+        for fixture_dir in fixture_dirs:\n+            self.process_dir(fixture_dir, fixture_name, compression_formats,\n+                             formats)\n+\n+    def process_dir(self, fixture_dir, fixture_name, compression_formats,\n+                    serialization_formats):\n+\n+        humanize = lambda dirname: \"'%s'\" % dirname if dirname else 'absolute path'\n+\n+        if self.verbosity >= 2:\n+            self.stdout.write(\"Checking %s for fixtures...\" % humanize(fixture_dir))\n+\n+        label_found = False\n+        for combo in product([self.using, None], serialization_formats, compression_formats):\n+            database, format, compression_format = combo\n+            file_name = '.'.join(\n+                p for p in [\n+                    fixture_name, database, format, compression_format\n+                ]\n+                if p\n+            )\n+\n+            if self.verbosity >= 3:\n+                self.stdout.write(\"Trying %s for %s fixture '%s'...\" % \\\n+                    (humanize(fixture_dir), file_name, fixture_name))\n+            full_path = os.path.join(fixture_dir, file_name)\n+            open_method = self.compression_types[compression_format]\n+            try:\n+                fixture = open_method(full_path, 'r')\n+            except IOError:\n+                if self.verbosity >= 2:\n+                    self.stdout.write(\"No %s fixture '%s' in %s.\" % \\\n+                        (format, fixture_name, humanize(fixture_dir)))\n+            else:\n+                try:\n+                    if label_found:\n+                        raise CommandError(\"Multiple fixtures named '%s' in %s. Aborting.\" %\n+                            (fixture_name, humanize(fixture_dir)))\n+\n+                    self.fixture_count += 1\n+                    objects_in_fixture = 0\n+                    loaded_objects_in_fixture = 0\n+                    if self.verbosity >= 2:\n+                        self.stdout.write(\"Installing %s fixture '%s' from %s.\" % \\\n+                            (format, fixture_name, humanize(fixture_dir)))\n+\n+                    objects = serializers.deserialize(format, fixture, using=self.using, ignorenonexistent=self.ignore)\n+\n+                    for obj in objects:\n+                        objects_in_fixture += 1\n+                        if router.allow_syncdb(self.using, obj.object.__class__):\n+                            loaded_objects_in_fixture += 1\n+                            self.models.add(obj.object.__class__)\n+                            try:\n+                                obj.save(using=self.using)\n+                            except (DatabaseError, IntegrityError) as e:\n+                                e.args = (\"Could not load %(app_label)s.%(object_name)s(pk=%(pk)s): %(error_msg)s\" % {\n+                                        'app_label': obj.object._meta.app_label,\n+                                        'object_name': obj.object._meta.object_name,\n+                                        'pk': obj.object.pk,\n+                                        'error_msg': force_text(e)\n+                                    },)\n+                                raise\n+\n+                    self.loaded_object_count += loaded_objects_in_fixture\n+                    self.fixture_object_count += objects_in_fixture\n+                    label_found = True\n+                except Exception as e:\n+                    if not isinstance(e, CommandError):\n+                        e.args = (\"Problem installing fixture '%s': %s\" % (full_path, e),)\n+                    raise\n+                finally:\n+                    fixture.close()\n+\n+                # If the fixture we loaded contains 0 objects, assume that an\n+                # error was encountered during fixture loading.\n+                if objects_in_fixture == 0:\n+                    raise CommandError(\n+                        \"No fixture data found for '%s'. (File format may be invalid.)\" %\n+                            (fixture_name))"
        }
    ],
    "stats": {
        "total": 273,
        "additions": 140,
        "deletions": 133
    }
}