{
    "author": "alex",
    "message": "Fixed a suite of errors in the ORM -- a) fixed calling values_list().values_list() and changing whether the results are flat, b) fixed an issue with fields on the left-hand side of what becomes the HAVING clause not being included in the GROUP BY clause, and c) fixed a bug with fields from values() calls not being included in the GROUP BY clause.  This fixed the recent test failures under postgresql.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@14715 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "678f626c24f389b03d4bfe2c552c33e9bdcc9379",
    "files": [
        {
            "sha": "deb138119c54458521ada617bcde4b89df05951a",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/django/django/blob/678f626c24f389b03d4bfe2c552c33e9bdcc9379/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/678f626c24f389b03d4bfe2c552c33e9bdcc9379/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=678f626c24f389b03d4bfe2c552c33e9bdcc9379",
            "patch": "@@ -965,8 +965,7 @@ def iterator(self):\n             # If a field list has been specified, use it. Otherwise, use the\n             # full list of fields, including extras and aggregates.\n             if self._fields:\n-                fields = list(self._fields) + filter(lambda f: f not in self._fields,\n-                                                     aggregate_names)\n+                fields = list(self._fields) + filter(lambda f: f not in self._fields, aggregate_names)\n             else:\n                 fields = names\n \n@@ -976,7 +975,9 @@ def iterator(self):\n \n     def _clone(self, *args, **kwargs):\n         clone = super(ValuesListQuerySet, self)._clone(*args, **kwargs)\n-        clone.flat = self.flat\n+        if not hasattr(clone, \"flat\"):\n+            # Only assign flat if the clone didn't already get it from kwargs\n+            clone.flat = self.flat\n         return clone\n \n "
        },
        {
            "sha": "ba707d4140cbcc273d13781f1935ffbf2fc95cc6",
            "filename": "django/db/models/sql/compiler.py",
            "status": "modified",
            "additions": 9,
            "deletions": 5,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/678f626c24f389b03d4bfe2c552c33e9bdcc9379/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/678f626c24f389b03d4bfe2c552c33e9bdcc9379/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py?ref=678f626c24f389b03d4bfe2c552c33e9bdcc9379",
            "patch": "@@ -469,21 +469,25 @@ def get_grouping(self):\n         qn = self.quote_name_unless_alias\n         result, params = [], []\n         if self.query.group_by is not None:\n-            if len(self.query.model._meta.fields) == len(self.query.select) and \\\n-                self.connection.features.allows_group_by_pk:\n-                self.query.group_by = [(self.query.model._meta.db_table, self.query.model._meta.pk.column)]\n+            if (len(self.query.model._meta.fields) == len(self.query.select) and\n+                self.connection.features.allows_group_by_pk):\n+                self.query.group_by = [\n+                    (self.query.model._meta.db_table, self.query.model._meta.pk.column)\n+                ]\n \n             group_by = self.query.group_by or []\n \n             extra_selects = []\n             for extra_select, extra_params in self.query.extra_select.itervalues():\n                 extra_selects.append(extra_select)\n                 params.extend(extra_params)\n-            for col in group_by + self.query.related_select_cols + extra_selects:\n+            cols = (group_by + self.query.select +\n+                self.query.related_select_cols + extra_selects)\n+            for col in cols:\n                 if isinstance(col, (list, tuple)):\n                     result.append('%s.%s' % (qn(col[0]), qn(col[1])))\n                 elif hasattr(col, 'as_sql'):\n-                    result.append(col.as_sql(qn))\n+                    result.append(col.as_sql(qn, self.connection))\n                 else:\n                     result.append('(%s)' % str(col))\n         return result, params"
        },
        {
            "sha": "eae7a87ac76eb0aa93cd426b27eaf129924b7470",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/678f626c24f389b03d4bfe2c552c33e9bdcc9379/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/678f626c24f389b03d4bfe2c552c33e9bdcc9379/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=678f626c24f389b03d4bfe2c552c33e9bdcc9379",
            "patch": "@@ -195,8 +195,9 @@ def __setstate__(self, obj_dict):\n         Unpickling support.\n         \"\"\"\n         # Rebuild list of field instances\n+        opts = obj_dict['model']._meta\n         obj_dict['select_fields'] = [\n-            name is not None and obj_dict['model']._meta.get_field(name) or None\n+            name is not None and opts.get_field(name) or None\n             for name in obj_dict['select_fields']\n         ]\n \n@@ -707,13 +708,20 @@ def change_aliases(self, change_map):\n         # \"group by\", \"where\" and \"having\".\n         self.where.relabel_aliases(change_map)\n         self.having.relabel_aliases(change_map)\n-        for columns in (self.select, self.aggregates.values(), self.group_by or []):\n+        for columns in [self.select, self.group_by or []]:\n             for pos, col in enumerate(columns):\n                 if isinstance(col, (list, tuple)):\n                     old_alias = col[0]\n                     columns[pos] = (change_map.get(old_alias, old_alias), col[1])\n                 else:\n                     col.relabel_aliases(change_map)\n+        for mapping in [self.aggregates]:\n+            for key, col in mapping.items():\n+                if isinstance(col, (list, tuple)):\n+                    old_alias = col[0]\n+                    mapping[key] = (change_map.get(old_alias, old_alias), col[1])\n+                else:\n+                    col.relabel_aliases(change_map)\n \n         # 2. Rename the alias in the internal table/alias datastructures.\n         for old_alias, new_alias in change_map.iteritems():\n@@ -1075,6 +1083,8 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n \n \n         if having_clause:\n+            if (alias, col) not in self.group_by:\n+                self.group_by.append((alias, col))\n             self.having.add((Constraint(alias, col, field), lookup_type, value),\n                 connector)\n         else:"
        },
        {
            "sha": "bb4b838b822b7338364df326a3f906462ad544ca",
            "filename": "django/db/models/sql/subqueries.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/678f626c24f389b03d4bfe2c552c33e9bdcc9379/django%2Fdb%2Fmodels%2Fsql%2Fsubqueries.py",
            "raw_url": "https://github.com/django/django/raw/678f626c24f389b03d4bfe2c552c33e9bdcc9379/django%2Fdb%2Fmodels%2Fsql%2Fsubqueries.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fsubqueries.py?ref=678f626c24f389b03d4bfe2c552c33e9bdcc9379",
            "patch": "@@ -202,7 +202,7 @@ def add_date_select(self, field_name, lookup_type, order='ASC'):\n         alias = result[3][-1]\n         select = Date((alias, field.column), lookup_type)\n         self.select = [select]\n-        self.select_fields = [None]\n+        self.select_fields = []\n         self.select_related = False # See #7097.\n         self.set_extra_mask([])\n         self.distinct = True"
        },
        {
            "sha": "33e37d6a9affdee8242dfed9fcb0b009035dbce6",
            "filename": "tests/regressiontests/aggregation_regress/tests.py",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/678f626c24f389b03d4bfe2c552c33e9bdcc9379/tests%2Fregressiontests%2Faggregation_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/678f626c24f389b03d4bfe2c552c33e9bdcc9379/tests%2Fregressiontests%2Faggregation_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Faggregation_regress%2Ftests.py?ref=678f626c24f389b03d4bfe2c552c33e9bdcc9379",
            "patch": "@@ -654,6 +654,25 @@ def test_f_expression_annotation(self):\n             attrgetter(\"name\")\n         )\n \n+    def test_values_annotate_values(self):\n+        qs = Book.objects.values(\"name\").annotate(\n+            n_authors=Count(\"authors\")\n+        ).values_list(\"pk\", flat=True)\n+        self.assertEqual(list(qs), list(Book.objects.values_list(\"pk\", flat=True)))\n+\n+    def test_having_group_by(self):\n+        # Test that when a field occurs on the LHS of a HAVING clause that it\n+        # appears correctly in the GROUP BY clause\n+        qs = Book.objects.values_list(\"name\").annotate(\n+            n_authors=Count(\"authors\")\n+        ).filter(\n+            pages__gt=F(\"n_authors\")\n+        ).values_list(\"name\", flat=True)\n+        # Results should be the same, all Books have more pages than authors\n+        self.assertEqual(\n+            list(qs), list(Book.objects.values_list(\"name\", flat=True))\n+        )\n+\n     @skipUnlessDBFeature('supports_stddev')\n     def test_stddev(self):\n         self.assertEqual("
        },
        {
            "sha": "ab75eb62ca9d00333f74328a8edd52d3f3d72b2d",
            "filename": "tests/regressiontests/queries/tests.py",
            "status": "modified",
            "additions": 21,
            "deletions": 10,
            "changes": 31,
            "blob_url": "https://github.com/django/django/blob/678f626c24f389b03d4bfe2c552c33e9bdcc9379/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/678f626c24f389b03d4bfe2c552c33e9bdcc9379/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Ftests.py?ref=678f626c24f389b03d4bfe2c552c33e9bdcc9379",
            "patch": "@@ -1093,11 +1093,12 @@ def test_ticket7045(self):\n         # Extra tables used to crash SQL construction on the second use.\n         qs = Ranking.objects.extra(tables=['django_site'])\n         qs.query.get_compiler(qs.db).as_sql()\n-        qs.query.get_compiler(qs.db).as_sql()   # test passes if this doesn't raise an exception.\n+        # test passes if this doesn't raise an exception.\n+        qs.query.get_compiler(qs.db).as_sql()\n \n     def test_ticket9848(self):\n-        # Make sure that updates which only filter on sub-tables don't inadvertently\n-        # update the wrong records (bug #9848).\n+        # Make sure that updates which only filter on sub-tables don't\n+        # inadvertently update the wrong records (bug #9848).\n \n         # Make sure that the IDs from different tables don't happen to match.\n         self.assertQuerysetEqual(\n@@ -1283,15 +1284,15 @@ def test_tickets_8921_9188(self):\n         )\n \n         # The annotation->tag link is single values and tag->children links is\n-        # multi-valued. So we have to split the exclude filter in the middle and then\n-        # optimise the inner query without losing results.\n+        # multi-valued. So we have to split the exclude filter in the middle\n+        # and then optimise the inner query without losing results.\n         self.assertQuerysetEqual(\n             Annotation.objects.exclude(tag__children__name=\"t2\"),\n             ['<Annotation: a2>']\n         )\n \n-        # Nested queries are possible (although should be used with care, since they have\n-        # performance problems on backends like MySQL.\n+        # Nested queries are possible (although should be used with care, since\n+        # they have performance problems on backends like MySQL.\n \n         self.assertQuerysetEqual(\n             Annotation.objects.filter(notes__in=Note.objects.filter(note=\"n1\")),\n@@ -1301,7 +1302,7 @@ def test_tickets_8921_9188(self):\n     def test_ticket3739(self):\n         # The all() method on querysets returns a copy of the queryset.\n         q1 = Tag.objects.order_by('name')\n-        self.assertNotEqual(id(q1), id(q1.all()))\n+        self.assertIsNot(q1, q1.all())\n \n \n class GeneratorExpressionTests(TestCase):\n@@ -1452,6 +1453,16 @@ def test_values_subquery(self):\n         )\n \n \n+class ValuesQuerysetTests(BaseQuerysetTest):\n+    def test_flat_values_lits(self):\n+        Number.objects.create(num=72)\n+        qs = Number.objects.values_list(\"num\")\n+        qs = qs.values_list(\"num\", flat=True)\n+        self.assertValueQuerysetEqual(\n+            qs, [72]\n+        )\n+\n+\n class WeirdQuerysetSlicingTests(BaseQuerysetTest):\n     def setUp(self):\n         Number.objects.create(num=1)\n@@ -1481,8 +1492,8 @@ def test_empty_resultset_sql(self):\n class EscapingTests(TestCase):\n     def test_ticket_7302(self):\n         # Reserved names are appropriately escaped\n-        _ = ReservedName.objects.create(name='a',order=42)\n-        ReservedName.objects.create(name='b',order=37)\n+        _ = ReservedName.objects.create(name='a', order=42)\n+        ReservedName.objects.create(name='b', order=37)\n         self.assertQuerysetEqual(\n             ReservedName.objects.all().order_by('order'),\n             ['<ReservedName: b>', '<ReservedName: a>']"
        }
    ],
    "stats": {
        "total": 87,
        "additions": 66,
        "deletions": 21
    }
}