{
    "author": "unknown",
    "message": "Fixed #15558 -- Improved QuerySet reference docs and cleaned up numerous reST/sphinx problems.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15776 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "409435440a8f8d453fa88aae9afb7799972b4422",
    "files": [
        {
            "sha": "badcf38f530752473c71e545f0c3786a60f4c10f",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 41,
            "deletions": 15,
            "changes": 56,
            "blob_url": "https://github.com/django/django/blob/409435440a8f8d453fa88aae9afb7799972b4422/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/409435440a8f8d453fa88aae9afb7799972b4422/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=409435440a8f8d453fa88aae9afb7799972b4422",
            "patch": "@@ -2,7 +2,7 @@\n QuerySet API reference\n ======================\n \n-.. currentmodule:: django.db.models.QuerySet\n+.. currentmodule:: django.db.models.query\n \n This document describes the details of the ``QuerySet`` API. It builds on the\n material presented in the :doc:`model </topics/db/models>` and :doc:`database\n@@ -120,12 +120,38 @@ QuerySet API\n ============\n \n Though you usually won't create one manually -- you'll go through a\n-:class:`Manager` -- here's the formal declaration of a ``QuerySet``:\n+:class:`~django.db.models.Manager` -- here's the formal declaration of a\n+``QuerySet``:\n \n-.. class:: QuerySet([model=None])\n+.. class:: QuerySet([model=None, query=None, using=None])\n \n-Usually when you'll interact with a ``QuerySet`` you'll use it by :ref:`chaining\n-filters <chaining-filters>`. To make this work, most ``QuerySet`` methods return new querysets.\n+    Usually when you'll interact with a ``QuerySet`` you'll use it by\n+    :ref:`chaining filters <chaining-filters>`. To make this work, most\n+    ``QuerySet`` methods return new querysets. These methods are covered in\n+    detail later in this section.\n+\n+    The ``QuerySet`` class has two public attributes you can use for\n+    introspection:\n+\n+    .. attribute:: ordered\n+\n+        ``True`` if the ``QuerySet`` is ordered -- i.e. has an order_by()\n+        clause or a default ordering on the model. ``False`` otherwise.\n+\n+    .. attribute:: db\n+    \n+        The database that will be used if this query is executed now.\n+\n+    .. note::\n+\n+        The ``query`` parameter to :class:`QuerySet` exists so that specialized\n+        query subclasses such as\n+        :class:`~django.contrib.gis.db.models.GeoQuerySet` can reconstruct\n+        internal query state. The value of the parameter is an opaque\n+        representation of that query state and is not part of a public API.\n+        To put it simply: if you need to ask, you don't need to use it.\n+\n+.. currentmodule:: django.db.models.query.QuerySet\n \n Methods that return new QuerySets\n ---------------------------------\n@@ -285,7 +311,7 @@ If you don't want any ordering to be applied to a query, not even the default\n ordering, call ``order_by()`` with no parameters.\n \n You can tell if a query is ordered or not by checking the\n-:attr:`QuerySet.ordered` attribute, which will be ``True`` if the\n+:attr:`.QuerySet.ordered` attribute, which will be ``True`` if the\n ``QuerySet`` has been ordered in any way.\n \n reverse\n@@ -999,9 +1025,9 @@ The :ref:`force_insert <ref-models-force-insert>` parameter is documented\n elsewhere, but all it means is that a new object will always be created.\n Normally you won't need to worry about this. However, if your model contains a\n manual primary key value that you set and if that value already exists in the\n-database, a call to ``create()`` will fail with an :exc:`IntegrityError` since\n-primary keys must be unique. So remember to be prepared to handle the exception\n-if you are using manual primary keys.\n+database, a call to ``create()`` will fail with an\n+:exc:`~django.db.IntegrityError` since primary keys must be unique. So remember\n+to be prepared to handle the exception if you are using manual primary keys.\n \n get_or_create\n ~~~~~~~~~~~~~\n@@ -1197,10 +1223,10 @@ exists\n \n .. versionadded:: 1.2\n \n-Returns ``True`` if the :class:`QuerySet` contains any results, and ``False``\n+Returns ``True`` if the :class:`.QuerySet` contains any results, and ``False``\n if not. This tries to perform the query in the simplest and fastest way\n possible, but it *does* execute nearly the same query. This means that calling\n-:meth:`QuerySet.exists()` is faster than ``bool(some_query_set)``, but not by\n+:meth:`.QuerySet.exists` is faster than ``bool(some_query_set)``, but not by\n a large degree.  If ``some_query_set`` has not yet been evaluated, but you know\n that it will be at some point, then using ``some_query_set.exists()`` will do\n more overall work (an additional query) than simply using\n@@ -1213,10 +1239,10 @@ update\n \n Performs an SQL update query for the specified fields, and returns\n the number of rows affected. The ``update()`` method is applied instantly and\n-the only restriction on the :class:`QuerySet` that is updated is that it can\n+the only restriction on the :class:`.QuerySet` that is updated is that it can\n only update columns in the model's main table. Filtering based on related\n fields is still possible. You cannot call ``update()`` on a\n-:class:`QuerySet` that has had a slice taken or can otherwise no longer be\n+:class:`.QuerySet` that has had a slice taken or can otherwise no longer be\n filtered.\n \n For example, if you wanted to update all the entries in a particular blog\n@@ -1236,9 +1262,9 @@ delete\n \n .. method:: delete()\n \n-Performs an SQL delete query on all rows in the :class:`QuerySet`. The\n+Performs an SQL delete query on all rows in the :class:`.QuerySet`. The\n ``delete()`` is applied instantly. You cannot call ``delete()`` on a\n-:class:`QuerySet` that has had a slice taken or can otherwise no longer be\n+:class:`.QuerySet` that has had a slice taken or can otherwise no longer be\n filtered.\n \n For example, to delete all the entries in a particular blog::"
        },
        {
            "sha": "cc24560295a05260fd4e826095df19c47a6e7b58",
            "filename": "docs/topics/http/shortcuts.txt",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/409435440a8f8d453fa88aae9afb7799972b4422/docs%2Ftopics%2Fhttp%2Fshortcuts.txt",
            "raw_url": "https://github.com/django/django/raw/409435440a8f8d453fa88aae9afb7799972b4422/docs%2Ftopics%2Fhttp%2Fshortcuts.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fhttp%2Fshortcuts.txt?ref=409435440a8f8d453fa88aae9afb7799972b4422",
            "patch": "@@ -24,7 +24,7 @@ introduce controlled coupling for convenience's sake.\n \n    :func:`render()` is the same as a call to\n    :func:`render_to_response()` with a `context_instance` argument that\n-   that forces the use of a :class:`RequestContext`.\n+   that forces the use of a :class:`~django.template.RequestContext`.\n \n Required arguments\n ------------------\n@@ -220,7 +220,7 @@ will be returned::\n \n .. function:: get_object_or_404(klass, *args, **kwargs)\n \n-   Calls :meth:`~django.db.models.QuerySet.get()` on a given model manager,\n+   Calls :meth:`~django.db.models.query.QuerySet.get()` on a given model manager,\n    but it raises :class:`~django.http.Http404` instead of the model's\n    :class:`~django.core.exceptions.DoesNotExist` exception.\n \n@@ -229,7 +229,8 @@ Required arguments\n \n ``klass``\n     A :class:`~django.db.models.Model`, :class:`~django.db.models.Manager` or\n-    :class:`~django.db.models.QuerySet` instance from which to get the object.\n+    :class:`~django.db.models.query.QuerySet` instance from which to get the\n+    object.\n \n ``**kwargs``\n     Lookup parameters, which should be in the format accepted by ``get()`` and\n@@ -265,7 +266,7 @@ will be raised if more than one object is found.\n \n .. function:: get_list_or_404(klass, *args, **kwargs)\n \n-   Returns the result of :meth:`~django.db.models.QuerySet.filter()` on a\n+   Returns the result of :meth:`~django.db.models.query.QuerySet.filter()` on a\n    given model manager, raising :class:`~django.http.Http404` if the resulting\n    list is empty.\n "
        }
    ],
    "stats": {
        "total": 65,
        "additions": 46,
        "deletions": 19
    }
}