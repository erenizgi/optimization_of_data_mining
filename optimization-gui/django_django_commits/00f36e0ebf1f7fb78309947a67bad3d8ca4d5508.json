{
    "author": "timgraham",
    "message": "Fixed #9033 - Add bullets to QuerySet extra() arguments. thanks julien for the suggestion and dwillis for the patch.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@14816 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "00f36e0ebf1f7fb78309947a67bad3d8ca4d5508",
    "files": [
        {
            "sha": "c951bc4b5585290b52598df6dbec4f9e63cb1882",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 108,
            "deletions": 108,
            "changes": 216,
            "blob_url": "https://github.com/django/django/blob/00f36e0ebf1f7fb78309947a67bad3d8ca4d5508/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/00f36e0ebf1f7fb78309947a67bad3d8ca4d5508/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=00f36e0ebf1f7fb78309947a67bad3d8ca4d5508",
            "patch": "@@ -709,151 +709,151 @@ principle, so you should avoid them if possible.\n Specify one or more of ``params``, ``select``, ``where`` or ``tables``. None\n of the arguments is required, but you should use at least one of them.\n \n-``select``\n-    The ``select`` argument lets you put extra fields in the ``SELECT`` clause.\n-    It should be a dictionary mapping attribute names to SQL clauses to use to\n-    calculate that attribute.\n+    * ``select``\n+        The ``select`` argument lets you put extra fields in the ``SELECT`` clause.\n+        It should be a dictionary mapping attribute names to SQL clauses to use to\n+        calculate that attribute.\n \n-    Example::\n+        Example::\n \n-        Entry.objects.extra(select={'is_recent': \"pub_date > '2006-01-01'\"})\n-\n-    As a result, each ``Entry`` object will have an extra attribute,\n-    ``is_recent``, a boolean representing whether the entry's ``pub_date`` is\n-    greater than Jan. 1, 2006.\n+            Entry.objects.extra(select={'is_recent': \"pub_date > '2006-01-01'\"})\n+\n+        As a result, each ``Entry`` object will have an extra attribute,\n+        ``is_recent``, a boolean representing whether the entry's ``pub_date`` is\n+        greater than Jan. 1, 2006.\n \n-    Django inserts the given SQL snippet directly into the ``SELECT``\n-    statement, so the resulting SQL of the above example would be something\n-    like::\n+        Django inserts the given SQL snippet directly into the ``SELECT``\n+        statement, so the resulting SQL of the above example would be something\n+        like::\n \n-        SELECT blog_entry.*, (pub_date > '2006-01-01') AS is_recent\n-        FROM blog_entry;\n+            SELECT blog_entry.*, (pub_date > '2006-01-01') AS is_recent\n+            FROM blog_entry;\n \n \n-    The next example is more advanced; it does a subquery to give each\n-    resulting ``Blog`` object an ``entry_count`` attribute, an integer count\n-    of associated ``Entry`` objects::\n+        The next example is more advanced; it does a subquery to give each\n+        resulting ``Blog`` object an ``entry_count`` attribute, an integer count\n+        of associated ``Entry`` objects::\n \n-        Blog.objects.extra(\n-            select={\n-                'entry_count': 'SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id'\n-            },\n-        )\n+            Blog.objects.extra(\n+                select={\n+                    'entry_count': 'SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id'\n+                },\n+            )\n \n-    (In this particular case, we're exploiting the fact that the query will\n-    already contain the ``blog_blog`` table in its ``FROM`` clause.)\n+        (In this particular case, we're exploiting the fact that the query will\n+        already contain the ``blog_blog`` table in its ``FROM`` clause.)\n \n-    The resulting SQL of the above example would be::\n+        The resulting SQL of the above example would be::\n \n-        SELECT blog_blog.*, (SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id) AS entry_count\n-        FROM blog_blog;\n+            SELECT blog_blog.*, (SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id) AS entry_count\n+            FROM blog_blog;\n \n-    Note that the parenthesis required by most database engines around\n-    subqueries are not required in Django's ``select`` clauses. Also note that\n-    some database backends, such as some MySQL versions, don't support\n-    subqueries.\n+        Note that the parenthesis required by most database engines around\n+        subqueries are not required in Django's ``select`` clauses. Also note that\n+        some database backends, such as some MySQL versions, don't support\n+        subqueries.\n \n-    .. versionadded:: 1.0\n+        .. versionadded:: 1.0\n \n-    In some rare cases, you might wish to pass parameters to the SQL fragments\n-    in ``extra(select=...)``. For this purpose, use the ``select_params``\n-    parameter. Since ``select_params`` is a sequence and the ``select``\n-    attribute is a dictionary, some care is required so that the parameters\n-    are matched up correctly with the extra select pieces.  In this situation,\n-    you should use a ``django.utils.datastructures.SortedDict`` for the\n-    ``select`` value, not just a normal Python dictionary.\n+        In some rare cases, you might wish to pass parameters to the SQL fragments\n+        in ``extra(select=...)``. For this purpose, use the ``select_params``\n+        parameter. Since ``select_params`` is a sequence and the ``select``\n+        attribute is a dictionary, some care is required so that the parameters\n+        are matched up correctly with the extra select pieces.  In this situation,\n+        you should use a ``django.utils.datastructures.SortedDict`` for the\n+        ``select`` value, not just a normal Python dictionary.\n \n-    This will work, for example::\n+        This will work, for example::\n \n-        Blog.objects.extra(\n-            select=SortedDict([('a', '%s'), ('b', '%s')]),\n-            select_params=('one', 'two'))\n+            Blog.objects.extra(\n+                select=SortedDict([('a', '%s'), ('b', '%s')]),\n+                select_params=('one', 'two'))\n \n-    The only thing to be careful about when using select parameters in\n-    ``extra()`` is to avoid using the substring ``\"%%s\"`` (that's *two*\n-    percent characters before the ``s``) in the select strings. Django's\n-    tracking of parameters looks for ``%s`` and an escaped ``%`` character\n-    like this isn't detected. That will lead to incorrect results.\n+        The only thing to be careful about when using select parameters in\n+        ``extra()`` is to avoid using the substring ``\"%%s\"`` (that's *two*\n+        percent characters before the ``s``) in the select strings. Django's\n+        tracking of parameters looks for ``%s`` and an escaped ``%`` character\n+        like this isn't detected. That will lead to incorrect results.\n \n-``where`` / ``tables``\n-    You can define explicit SQL ``WHERE`` clauses -- perhaps to perform\n-    non-explicit joins -- by using ``where``. You can manually add tables to\n-    the SQL ``FROM`` clause by using ``tables``.\n+    * ``where`` / ``tables``\n+        You can define explicit SQL ``WHERE`` clauses -- perhaps to perform\n+        non-explicit joins -- by using ``where``. You can manually add tables to\n+        the SQL ``FROM`` clause by using ``tables``.\n \n-    ``where`` and ``tables`` both take a list of strings. All ``where``\n-    parameters are \"AND\"ed to any other search criteria.\n+        ``where`` and ``tables`` both take a list of strings. All ``where``\n+        parameters are \"AND\"ed to any other search criteria.\n \n-    Example::\n+        Example::\n \n-        Entry.objects.extra(where=['id IN (3, 4, 5, 20)'])\n+            Entry.objects.extra(where=['id IN (3, 4, 5, 20)'])\n \n-    ...translates (roughly) into the following SQL::\n+        ...translates (roughly) into the following SQL::\n \n-        SELECT * FROM blog_entry WHERE id IN (3, 4, 5, 20);\n+            SELECT * FROM blog_entry WHERE id IN (3, 4, 5, 20);\n \n-    Be careful when using the ``tables`` parameter if you're specifying\n-    tables that are already used in the query. When you add extra tables\n-    via the ``tables`` parameter, Django assumes you want that table included\n-    an extra time, if it is already included. That creates a problem,\n-    since the table name will then be given an alias. If a table appears\n-    multiple times in an SQL statement, the second and subsequent occurrences\n-    must use aliases so the database can tell them apart. If you're\n-    referring to the extra table you added in the extra ``where`` parameter\n-    this is going to cause errors.\n+        Be careful when using the ``tables`` parameter if you're specifying\n+        tables that are already used in the query. When you add extra tables\n+        via the ``tables`` parameter, Django assumes you want that table included\n+        an extra time, if it is already included. That creates a problem,\n+        since the table name will then be given an alias. If a table appears\n+        multiple times in an SQL statement, the second and subsequent occurrences\n+        must use aliases so the database can tell them apart. If you're\n+        referring to the extra table you added in the extra ``where`` parameter\n+        this is going to cause errors.\n \n-    Normally you'll only be adding extra tables that don't already appear in\n-    the query. However, if the case outlined above does occur, there are a few\n-    solutions. First, see if you can get by without including the extra table\n-    and use the one already in the query. If that isn't possible, put your\n-    ``extra()`` call at the front of the queryset construction so that your\n-    table is the first use of that table. Finally, if all else fails, look at\n-    the query produced and rewrite your ``where`` addition to use the alias\n-    given to your extra table. The alias will be the same each time you\n-    construct the queryset in the same way, so you can rely upon the alias\n-    name to not change.\n+        Normally you'll only be adding extra tables that don't already appear in\n+        the query. However, if the case outlined above does occur, there are a few\n+        solutions. First, see if you can get by without including the extra table\n+        and use the one already in the query. If that isn't possible, put your\n+        ``extra()`` call at the front of the queryset construction so that your\n+        table is the first use of that table. Finally, if all else fails, look at\n+        the query produced and rewrite your ``where`` addition to use the alias\n+        given to your extra table. The alias will be the same each time you\n+        construct the queryset in the same way, so you can rely upon the alias\n+        name to not change.\n \n-``order_by``\n-    If you need to order the resulting queryset using some of the new fields\n-    or tables you have included via ``extra()`` use the ``order_by`` parameter\n-    to ``extra()`` and pass in a sequence of strings. These strings should\n-    either be model fields (as in the normal ``order_by()`` method on\n-    querysets), of the form ``table_name.column_name`` or an alias for a column\n-    that you specified in the ``select`` parameter to ``extra()``.\n+    * ``order_by``\n+        If you need to order the resulting queryset using some of the new fields\n+        or tables you have included via ``extra()`` use the ``order_by`` parameter\n+        to ``extra()`` and pass in a sequence of strings. These strings should\n+        either be model fields (as in the normal ``order_by()`` method on\n+        querysets), of the form ``table_name.column_name`` or an alias for a column\n+        that you specified in the ``select`` parameter to ``extra()``.\n \n-    For example::\n+        For example::\n \n-        q = Entry.objects.extra(select={'is_recent': \"pub_date > '2006-01-01'\"})\n-        q = q.extra(order_by = ['-is_recent'])\n+            q = Entry.objects.extra(select={'is_recent': \"pub_date > '2006-01-01'\"})\n+            q = q.extra(order_by = ['-is_recent'])\n \n-    This would sort all the items for which ``is_recent`` is true to the front\n-    of the result set (``True`` sorts before ``False`` in a descending\n-    ordering).\n+        This would sort all the items for which ``is_recent`` is true to the front\n+        of the result set (``True`` sorts before ``False`` in a descending\n+        ordering).\n \n-    This shows, by the way, that you can make multiple calls to\n-    ``extra()`` and it will behave as you expect (adding new constraints each\n-    time).\n+        This shows, by the way, that you can make multiple calls to\n+        ``extra()`` and it will behave as you expect (adding new constraints each\n+        time).\n \n-``params``\n-    The ``where`` parameter described above may use standard Python database\n-    string placeholders -- ``'%s'`` to indicate parameters the database engine\n-    should automatically quote. The ``params`` argument is a list of any extra\n-    parameters to be substituted.\n+    * ``params``\n+        The ``where`` parameter described above may use standard Python database\n+        string placeholders -- ``'%s'`` to indicate parameters the database engine\n+        should automatically quote. The ``params`` argument is a list of any extra\n+        parameters to be substituted.\n \n-    Example::\n+        Example::\n \n-        Entry.objects.extra(where=['headline=%s'], params=['Lennon'])\n+            Entry.objects.extra(where=['headline=%s'], params=['Lennon'])\n \n-    Always use ``params`` instead of embedding values directly into ``where``\n-    because ``params`` will ensure values are quoted correctly according to\n-    your particular backend. (For example, quotes will be escaped correctly.)\n+        Always use ``params`` instead of embedding values directly into ``where``\n+        because ``params`` will ensure values are quoted correctly according to\n+        your particular backend. (For example, quotes will be escaped correctly.)\n \n-    Bad::\n+        Bad::\n \n-        Entry.objects.extra(where=[\"headline='Lennon'\"])\n+            Entry.objects.extra(where=[\"headline='Lennon'\"])\n \n-    Good::\n+        Good::\n \n-        Entry.objects.extra(where=['headline=%s'], params=['Lennon'])\n+            Entry.objects.extra(where=['headline=%s'], params=['Lennon'])\n \n defer\n ~~~~~"
        }
    ],
    "stats": {
        "total": 216,
        "additions": 108,
        "deletions": 108
    }
}