{
    "author": "jezdez",
    "message": "Fixed #5535 -- Allow using an explicit foreign key in get() calls. Thanks, Michal Petrucha.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16473 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "dbffffa7dc95fc62cbecfd00284bde62ee796f48",
    "files": [
        {
            "sha": "110e3179d5929f78677121186008b8545373b34c",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/dbffffa7dc95fc62cbecfd00284bde62ee796f48/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/dbffffa7dc95fc62cbecfd00284bde62ee796f48/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=dbffffa7dc95fc62cbecfd00284bde62ee796f48",
            "patch": "@@ -1068,8 +1068,9 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n \n         try:\n             field, target, opts, join_list, last, extra_filters = self.setup_joins(\n-                    parts, opts, alias, True, allow_many, can_reuse=can_reuse,\n-                    negate=negate, process_extras=process_extras)\n+                    parts, opts, alias, True, allow_many, allow_explicit_fk=True,\n+                    can_reuse=can_reuse, negate=negate,\n+                    process_extras=process_extras)\n         except MultiJoin, e:\n             self.split_exclude(filter_expr, LOOKUP_SEP.join(parts[:e.level]),\n                     can_reuse)"
        },
        {
            "sha": "a4267489b932125f817ae1a6ab2cb64d31e51241",
            "filename": "docs/topics/db/queries.txt",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/dbffffa7dc95fc62cbecfd00284bde62ee796f48/docs%2Ftopics%2Fdb%2Fqueries.txt",
            "raw_url": "https://github.com/django/django/raw/dbffffa7dc95fc62cbecfd00284bde62ee796f48/docs%2Ftopics%2Fdb%2Fqueries.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Fqueries.txt?ref=dbffffa7dc95fc62cbecfd00284bde62ee796f48",
            "patch": "@@ -365,6 +365,16 @@ translates (roughly) into the following SQL::\n \n    .. _`Keyword Arguments`: http://docs.python.org/tutorial/controlflow.html#keyword-arguments\n \n+.. versionchanged:: 1.4\n+\n+    The field specified in a lookup has to be the name of a model field.\n+    There's one exception though, in case of a\n+    :class:`~django.db.models.fields.ForeignKey` you can specify the field\n+    name suffixed with ``_id``. In this case, the value parameter is expected\n+    to contain the raw value of the foreign model's primary key. For example::\n+\n+        >>> Entry.objects.filter(blog_id__exact=4)\n+\n If you pass an invalid keyword argument, a lookup function will raise\n ``TypeError``.\n "
        },
        {
            "sha": "83e984dc6d8d3392c68c20681b6517aa45cc6772",
            "filename": "tests/modeltests/many_to_one/tests.py",
            "status": "modified",
            "additions": 32,
            "deletions": 5,
            "changes": 37,
            "blob_url": "https://github.com/django/django/blob/dbffffa7dc95fc62cbecfd00284bde62ee796f48/tests%2Fmodeltests%2Fmany_to_one%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/dbffffa7dc95fc62cbecfd00284bde62ee796f48/tests%2Fmodeltests%2Fmany_to_one%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fmany_to_one%2Ftests.py?ref=dbffffa7dc95fc62cbecfd00284bde62ee796f48",
            "patch": "@@ -2,7 +2,7 @@\n from datetime import datetime\n \n from django.test import TestCase\n-from django.core.exceptions import FieldError\n+from django.core.exceptions import FieldError, MultipleObjectsReturned\n \n from models import Article, Reporter\n \n@@ -229,10 +229,6 @@ def test_selects(self):\n                 \"<Article: John's second story>\",\n                 \"<Article: This is a test>\",\n             ])\n-        # You need two underscores between \"reporter\" and \"id\" -- not one.\n-        self.assertRaises(FieldError, Article.objects.filter, reporter_id__exact=self.r.id)\n-        # You need to specify a comparison clause\n-        self.assertRaises(FieldError, Article.objects.filter, reporter_id=self.r.id)\n \n     def test_reverse_selects(self):\n         a3 = Article.objects.create(id=None, headline=\"Third article\",\n@@ -372,3 +368,34 @@ def test_regression_12876(self):\n         # recursive don't cause recursion depth problems under deepcopy.\n         self.r.cached_query = Article.objects.filter(reporter=self.r)\n         self.assertEqual(repr(deepcopy(self.r)), \"<Reporter: John Smith>\")\n+\n+    def test_explicit_fk(self):\n+        # Create a new Article with get_or_create using an explicit value\n+        # for a ForeignKey.\n+        a2, created = Article.objects.get_or_create(id=None,\n+                                                    headline=\"John's second test\",\n+                                                    pub_date=datetime(2011, 5, 7),\n+                                                    reporter_id=self.r.id)\n+        self.assertTrue(created)\n+        self.assertEqual(a2.reporter.id, self.r.id)\n+\n+        # You can specify filters containing the explicit FK value.\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(reporter_id__exact=self.r.id),\n+            [\n+                \"<Article: John's second test>\",\n+                \"<Article: This is a test>\",\n+            ])\n+\n+        # Create an Article by Paul for the same date.\n+        a3 = Article.objects.create(id=None, headline=\"Paul's commentary\",\n+                                    pub_date=datetime(2011, 5, 7),\n+                                    reporter_id=self.r2.id)\n+        self.assertEqual(a3.reporter.id, self.r2.id)\n+\n+        # Get should respect explicit foreign keys as well.\n+        self.assertRaises(MultipleObjectsReturned,\n+                          Article.objects.get, reporter_id=self.r.id)\n+        self.assertEqual(repr(a3),\n+                         repr(Article.objects.get(reporter_id=self.r2.id,\n+                                             pub_date=datetime(2011, 5, 7))))"
        }
    ],
    "stats": {
        "total": 52,
        "additions": 45,
        "deletions": 7
    }
}