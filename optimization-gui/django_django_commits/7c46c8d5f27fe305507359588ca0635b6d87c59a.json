{
    "author": "aaugustin",
    "message": "Added some assertions to enforce the atomicity of atomic.",
    "sha": "7c46c8d5f27fe305507359588ca0635b6d87c59a",
    "files": [
        {
            "sha": "08c901ab7b234ce51937ee786cd9631ba1ca5d1b",
            "filename": "django/db/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/django%2Fdb%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/django%2Fdb%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2F__init__.py?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -70,6 +70,7 @@ def reset_queries(**kwargs):\n # their lifetime. NB: abort() doesn't do anything outside of a transaction.\n def close_old_connections(**kwargs):\n     for conn in connections.all():\n+        # Remove this when the legacy transaction management goes away.\n         try:\n             conn.abort()\n         except DatabaseError:"
        },
        {
            "sha": "346d10198d37d65a3dbd08ae6942fa25dfc2c8b2",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -157,6 +157,7 @@ def commit(self):\n         Commits a transaction and resets the dirty flag.\n         \"\"\"\n         self.validate_thread_sharing()\n+        self.validate_no_atomic_block()\n         self._commit()\n         self.set_clean()\n \n@@ -165,6 +166,7 @@ def rollback(self):\n         Rolls back a transaction and resets the dirty flag.\n         \"\"\"\n         self.validate_thread_sharing()\n+        self.validate_no_atomic_block()\n         self._rollback()\n         self.set_clean()\n \n@@ -265,6 +267,8 @@ def enter_transaction_management(self, managed=True, forced=False):\n         If you switch off transaction management and there is a pending\n         commit/rollback, the data will be commited, unless \"forced\" is True.\n         \"\"\"\n+        self.validate_no_atomic_block()\n+\n         self.transaction_state.append(managed)\n \n         if not managed and self.is_dirty() and not forced:\n@@ -280,6 +284,8 @@ def leave_transaction_management(self):\n         over to the surrounding block, as a commit will commit all changes, even\n         those from outside. (Commits are on connection level.)\n         \"\"\"\n+        self.validate_no_atomic_block()\n+\n         if self.transaction_state:\n             del self.transaction_state[-1]\n         else:\n@@ -305,10 +311,19 @@ def set_autocommit(self, autocommit=True):\n         \"\"\"\n         Enable or disable autocommit.\n         \"\"\"\n+        self.validate_no_atomic_block()\n         self.ensure_connection()\n         self._set_autocommit(autocommit)\n         self.autocommit = autocommit\n \n+    def validate_no_atomic_block(self):\n+        \"\"\"\n+        Raise an error if an atomic block is active.\n+        \"\"\"\n+        if self.in_atomic_block:\n+            raise TransactionManagementError(\n+                \"This is forbidden when an 'atomic' block is active.\")\n+\n     def abort(self):\n         \"\"\"\n         Roll back any ongoing transaction and clean the transaction state"
        },
        {
            "sha": "eb9d85e27474020ce69dcb56437a42141c5238ff",
            "filename": "django/db/transaction.py",
            "status": "modified",
            "additions": 16,
            "deletions": 2,
            "changes": 18,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/django%2Fdb%2Ftransaction.py",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/django%2Fdb%2Ftransaction.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Ftransaction.py?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -367,6 +367,9 @@ def autocommit(using=None):\n     this decorator is useful if you globally activated transaction management in\n     your settings file and want the default behavior in some view functions.\n     \"\"\"\n+    warnings.warn(\"autocommit is deprecated in favor of set_autocommit.\",\n+        PendingDeprecationWarning, stacklevel=2)\n+\n     def entering(using):\n         enter_transaction_management(managed=False, using=using)\n \n@@ -382,6 +385,9 @@ def commit_on_success(using=None):\n     a rollback is made. This is one of the most common ways to do transaction\n     control in Web apps.\n     \"\"\"\n+    warnings.warn(\"commit_on_success is deprecated in favor of atomic.\",\n+        PendingDeprecationWarning, stacklevel=2)\n+\n     def entering(using):\n         enter_transaction_management(using=using)\n \n@@ -409,6 +415,9 @@ def commit_manually(using=None):\n     own -- it's up to the user to call the commit and rollback functions\n     themselves.\n     \"\"\"\n+    warnings.warn(\"commit_manually is deprecated in favor of set_autocommit.\",\n+        PendingDeprecationWarning, stacklevel=2)\n+\n     def entering(using):\n         enter_transaction_management(using=using)\n \n@@ -420,10 +429,15 @@ def exiting(exc_value, using):\n def commit_on_success_unless_managed(using=None):\n     \"\"\"\n     Transitory API to preserve backwards-compatibility while refactoring.\n+\n+    Once the legacy transaction management is fully deprecated, this should\n+    simply be replaced by atomic. Until then, it's necessary to avoid making a\n+    commit where Django didn't use to, since entering atomic in managed mode\n+    triggers a commmit.\n     \"\"\"\n     connection = get_connection(using)\n-    if connection.autocommit and not connection.in_atomic_block:\n-        return commit_on_success(using)\n+    if connection.autocommit or connection.in_atomic_block:\n+        return atomic(using)\n     else:\n         def entering(using):\n             pass"
        },
        {
            "sha": "6c13af7ae41f7d1f00cac79164b75435585f82d5",
            "filename": "docs/internals/deprecation.txt",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/docs%2Finternals%2Fdeprecation.txt",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/docs%2Finternals%2Fdeprecation.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Finternals%2Fdeprecation.txt?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -329,6 +329,10 @@ these changes.\n 1.8\n ---\n \n+* The decorators and context managers ``django.db.transaction.autocommit``,\n+  ``commit_on_success`` and ``commit_manually`` will be removed. See\n+  :ref:`transactions-upgrading-from-1.5`.\n+\n * The :ttag:`cycle` and :ttag:`firstof` template tags will auto-escape their\n   arguments. In 1.6 and 1.7, this behavior is provided by the version of these\n   tags in the ``future`` template tag library."
        },
        {
            "sha": "53d38a006b9bc6225802937239eb67d6aebef1ca",
            "filename": "docs/releases/1.3-alpha-1.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/docs%2Freleases%2F1.3-alpha-1.txt",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/docs%2Freleases%2F1.3-alpha-1.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.3-alpha-1.txt?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -105,16 +105,14 @@ you just won't get any of the nice new unittest2 features.\n Transaction context managers\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-Users of Python 2.5 and above may now use :ref:`transaction management functions\n-<transaction-management-functions>` as `context managers`_. For example::\n+Users of Python 2.5 and above may now use transaction management functions as\n+`context managers`_. For example::\n \n     with transaction.autocommit():\n         # ...\n \n .. _context managers: http://docs.python.org/glossary.html#term-context-manager\n \n-For more information, see :ref:`transaction-management-functions`.\n-\n Configurable delete-cascade\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "582bceffca4924e918bcafad4e26d7a27558cb03",
            "filename": "docs/releases/1.3.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/docs%2Freleases%2F1.3.txt",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/docs%2Freleases%2F1.3.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.3.txt?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -148,16 +148,14 @@ you just won't get any of the nice new unittest2 features.\n Transaction context managers\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-Users of Python 2.5 and above may now use :ref:`transaction management functions\n-<transaction-management-functions>` as `context managers`_. For example::\n+Users of Python 2.5 and above may now use transaction management functions as\n+`context managers`_. For example::\n \n     with transaction.autocommit():\n         # ...\n \n .. _context managers: http://docs.python.org/glossary.html#term-context-manager\n \n-For more information, see :ref:`transaction-management-functions`.\n-\n Configurable delete-cascade\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "cc3bf94ef54ddd74c472d0b2439ab9369a7afe74",
            "filename": "docs/releases/1.6.txt",
            "status": "modified",
            "additions": 15,
            "deletions": 2,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/docs%2Freleases%2F1.6.txt",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/docs%2Freleases%2F1.6.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.6.txt?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -39,7 +39,7 @@ should improve performance. The existing APIs were deprecated, and new APIs\n were introduced, as described in :doc:`/topics/db/transactions`.\n \n Please review carefully the list of :ref:`known backwards-incompatibilities\n-<transactions-changes-from-1.5>` to determine if you need to make changes in\n+<transactions-upgrading-from-1.5>` to determine if you need to make changes in\n your code.\n \n Persistent database connections\n@@ -163,7 +163,7 @@ Backwards incompatible changes in 1.6\n * Database-level autocommit is enabled by default in Django 1.6. While this\n   doesn't change the general spirit of Django's transaction management, there\n   are a few known backwards-incompatibities, described in the :ref:`transaction\n-  management docs <transactions-changes-from-1.5>`. You should review your code\n+  management docs <transactions-upgrading-from-1.5>`. You should review your code\n   to determine if you're affected.\n \n * In previous versions, database-level autocommit was only an option for\n@@ -256,6 +256,19 @@ Backwards incompatible changes in 1.6\n Features deprecated in 1.6\n ==========================\n \n+Transaction management APIs\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Transaction management was completely overhauled in Django 1.6, and the\n+current APIs are deprecated:\n+\n+- :func:`django.db.transaction.autocommit`\n+- :func:`django.db.transaction.commit_on_success`\n+- :func:`django.db.transaction.commit_manually`\n+\n+The reasons for this change and the upgrade path are described in the\n+:ref:`transactions documentation <transactions-upgrading-from-1.5>`.\n+\n Changes to :ttag:`cycle` and :ttag:`firstof`\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "91b2cf41b32b2ca38859dcc26879ca46b1021919",
            "filename": "docs/topics/db/transactions.txt",
            "status": "modified",
            "additions": 199,
            "deletions": 240,
            "changes": 439,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Ftransactions.txt?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -24,7 +24,7 @@ immediately committed to the database. :ref:`See below for details\n \n .. versionchanged:: 1.6\n     Previous version of Django featured :ref:`a more complicated default\n-    behavior <transactions-changes-from-1.5>`.\n+    behavior <transactions-upgrading-from-1.5>`.\n \n Tying transactions to HTTP requests\n -----------------------------------\n@@ -89,7 +89,7 @@ Django provides a single API to control database transactions.\n     database. If this argument isn't provided, Django uses the ``\"default\"``\n     database.\n \n-    ``atomic`` is usable both as a decorator::\n+    ``atomic`` is usable both as a `decorator`_::\n \n         from django.db import transaction\n \n@@ -98,7 +98,7 @@ Django provides a single API to control database transactions.\n             # This code executes inside a transaction.\n             do_stuff()\n \n-    and as a context manager::\n+    and as a `context manager`_::\n \n         from django.db import transaction\n \n@@ -110,6 +110,9 @@ Django provides a single API to control database transactions.\n                 # This code executes inside a transaction.\n                 do_more_stuff()\n \n+    .. _decorator: http://docs.python.org/glossary.html#term-decorator\n+    .. _context manager: http://docs.python.org/glossary.html#term-context-manager\n+\n     Wrapping ``atomic`` in a try/except block allows for natural handling of\n     integrity errors::\n \n@@ -145,158 +148,116 @@ Django provides a single API to control database transactions.\n     - releases or rolls back to the savepoint when exiting an inner block;\n     - commits or rolls back the transaction when exiting the outermost block.\n \n-.. _transaction-management-functions:\n-\n-Controlling transaction management in views\n-===========================================\n-\n-For most people, implicit request-based transactions work wonderfully. However,\n-if you need more fine-grained control over how transactions are managed, you can\n-use a set of functions in ``django.db.transaction`` to control transactions on a\n-per-function or per-code-block basis.\n-\n-These functions, described in detail below, can be used in two different ways:\n-\n-* As a decorator_ on a particular function. For example::\n-\n-    from django.db import transaction\n-\n-    @transaction.commit_on_success\n-    def viewfunc(request):\n-        # ...\n-        # this code executes inside a transaction\n-        # ...\n-\n-* As a `context manager`_ around a particular block of code::\n-\n-    from django.db import transaction\n-\n-    def viewfunc(request):\n-        # ...\n-        # this code executes using default transaction management\n-        # ...\n-\n-        with transaction.commit_on_success():\n-            # ...\n-            # this code executes inside a transaction\n-            # ...\n-\n-Both techniques work with all supported version of Python.\n+.. _topics-db-transactions-savepoints:\n \n-.. _decorator: http://docs.python.org/glossary.html#term-decorator\n-.. _context manager: http://docs.python.org/glossary.html#term-context-manager\n+Savepoints\n+==========\n \n-For maximum compatibility, all of the examples below show transactions using the\n-decorator syntax, but all of the follow functions may be used as context\n-managers, too.\n+A savepoint is a marker within a transaction that enables you to roll back\n+part of a transaction, rather than the full transaction. Savepoints are\n+available with the SQLite (≥ 3.6.8), PostgreSQL, Oracle and MySQL (when using\n+the InnoDB storage engine) backends. Other backends provide the savepoint\n+functions, but they're empty operations -- they don't actually do anything.\n \n-.. note::\n+Savepoints aren't especially useful if you are using autocommit, the default\n+behavior of Django. However, once you open a transaction with :func:`atomic`,\n+you build up a series of database operations awaiting a commit or rollback. If\n+you issue a rollback, the entire transaction is rolled back. Savepoints\n+provide the ability to perform a fine-grained rollback, rather than the full\n+rollback that would be performed by ``transaction.rollback()``.\n \n-    Although the examples below use view functions as examples, these\n-    decorators and context managers can be used anywhere in your code\n-    that you need to deal with transactions.\n+.. versionchanged:: 1.6\n \n-.. _topics-db-transactions-autocommit:\n+When the :func:`atomic` decorator is nested, it creates a savepoint to allow\n+partial commit or rollback. You're strongly encouraged to use :func:`atomic`\n+rather than the functions described below, but they're still part of the\n+public API, and there's no plan to deprecate them.\n \n-.. function:: autocommit\n+Each of these functions takes a ``using`` argument which should be the name of\n+a database for which the behavior applies.  If no ``using`` argument is\n+provided then the ``\"default\"`` database is used.\n \n-    Use the ``autocommit`` decorator to switch a view function to Django's\n-    default commit behavior.\n+Savepoints are controlled by three methods on the transaction object:\n \n-    Example::\n+.. method:: transaction.savepoint(using=None)\n \n-        from django.db import transaction\n+    Creates a new savepoint. This marks a point in the transaction that\n+    is known to be in a \"good\" state.\n \n-        @transaction.autocommit\n-        def viewfunc(request):\n-            ....\n+    Returns the savepoint ID (sid).\n \n-        @transaction.autocommit(using=\"my_other_database\")\n-        def viewfunc2(request):\n-            ....\n+.. method:: transaction.savepoint_commit(sid, using=None)\n \n-    Within ``viewfunc()``, transactions will be committed as soon as you call\n-    ``model.save()``, ``model.delete()``, or any other function that writes to\n-    the database.  ``viewfunc2()`` will have this same behavior, but for the\n-    ``\"my_other_database\"`` connection.\n+    Updates the savepoint to include any operations that have been performed\n+    since the savepoint was created, or since the last commit.\n \n-.. function:: commit_on_success\n+.. method:: transaction.savepoint_rollback(sid, using=None)\n \n-    Use the ``commit_on_success`` decorator to use a single transaction for all\n-    the work done in a function::\n+    Rolls the transaction back to the last point at which the savepoint was\n+    committed.\n \n-        from django.db import transaction\n+The following example demonstrates the use of savepoints::\n \n-        @transaction.commit_on_success\n-        def viewfunc(request):\n-            ....\n+    from django.db import transaction\n \n-        @transaction.commit_on_success(using=\"my_other_database\")\n-        def viewfunc2(request):\n-            ....\n+    # open a transaction\n+    @transaction.atomic\n+    def viewfunc(request):\n \n-    If the function returns successfully, then Django will commit all work done\n-    within the function at that point. If the function raises an exception,\n-    though, Django will roll back the transaction.\n+      a.save()\n+      # transaction now contains a.save()\n \n-.. function:: commit_manually\n+      sid = transaction.savepoint()\n \n-    Use the ``commit_manually`` decorator if you need full control over\n-    transactions. It tells Django you'll be managing the transaction on your\n-    own.\n+      b.save()\n+      # transaction now contains a.save() and b.save()\n \n-    Whether you are writing or simply reading from the database, you must\n-    ``commit()`` or ``rollback()`` explicitly or Django will raise a\n-    :exc:`TransactionManagementError` exception. This is required when reading\n-    from the database because ``SELECT`` statements may call functions which\n-    modify tables, and thus it is impossible to know if any data has been\n-    modified.\n+      if want_to_keep_b:\n+          transaction.savepoint_commit(sid)\n+          # open transaction still contains a.save() and b.save()\n+      else:\n+          transaction.savepoint_rollback(sid)\n+          # open transaction now contains only a.save()\n \n-    Manual transaction management looks like this::\n+Autocommit\n+==========\n \n-        from django.db import transaction\n+.. _autocommit-details:\n \n-        @transaction.commit_manually\n-        def viewfunc(request):\n-            ...\n-            # You can commit/rollback however and whenever you want\n-            transaction.commit()\n-            ...\n+Why Django uses autocommit\n+--------------------------\n \n-            # But you've got to remember to do it yourself!\n-            try:\n-                ...\n-            except:\n-                transaction.rollback()\n-            else:\n-                transaction.commit()\n+In the SQL standards, each SQL query starts a transaction, unless one is\n+already in progress. Such transactions must then be committed or rolled back.\n \n-        @transaction.commit_manually(using=\"my_other_database\")\n-        def viewfunc2(request):\n-            ....\n+This isn't always convenient for application developers. To alleviate this\n+problem, most databases provide an autocommit mode. When autocommit is turned\n+on, each SQL query is wrapped in its own transaction. In other words, the\n+transaction is not only automatically started, but also automatically\n+committed.\n \n-.. _topics-db-transactions-requirements:\n+:pep:`249`, the Python Database API Specification v2.0, requires autocommit to\n+be initially turned off. Django overrides this default and turns autocommit\n+on.\n \n-Requirements for transaction handling\n-=====================================\n+To avoid this, you can :ref:`deactivate the transaction management\n+<deactivate-transaction-management>`, but it isn't recommended.\n \n-Django requires that every transaction that is opened is closed before the\n-completion of a request.\n+.. versionchanged:: 1.6\n+    Before Django 1.6, autocommit was turned off, and it was emulated by\n+    forcing a commit after write operations in the ORM.\n \n-If you are using :func:`autocommit` (the default commit mode) or\n-:func:`commit_on_success`, this will be done for you automatically. However,\n-if you are manually managing transactions (using the :func:`commit_manually`\n-decorator), you must ensure that the transaction is either committed or rolled\n-back before a request is completed.\n+.. warning::\n \n-This applies to all database operations, not just write operations. Even\n-if your transaction only reads from the database, the transaction must\n-be committed or rolled back before you complete a request.\n+    If you're using the database API directly — for instance, you're running\n+    SQL queries with ``cursor.execute()`` — be aware that autocommit is on,\n+    and consider wrapping your operations in a transaction, with\n+    :func:`atomic`, to ensure consistency.\n \n .. _managing-autocommit:\n \n Managing autocommit\n-===================\n+-------------------\n \n .. versionadded:: 1.6\n \n@@ -310,10 +271,17 @@ database connection, if you need to.\n These functions take a ``using`` argument which should be the name of a\n database. If it isn't provided, Django uses the ``\"default\"`` database.\n \n+Autocommit is initially turned on. If you turn it off, it's your\n+responsibility to restore it.\n+\n+:func:`atomic` requires autocommit to be turned on; it will raise an exception\n+if autocommit is off. Django will also refuse to turn autocommit off when an\n+:func:`atomic` block is active, because that would break atomicity.\n+\n .. _deactivate-transaction-management:\n \n-How to globally deactivate transaction management\n-=================================================\n+Deactivating transaction management\n+-----------------------------------\n \n Control freaks can totally disable all transaction management by setting\n :setting:`TRANSACTIONS_MANAGED` to ``True`` in the Django settings file. If\n@@ -328,71 +296,6 @@ something really strange.\n In almost all situations, you'll be better off using the default behavior, or\n the transaction middleware, and only modify selected functions as needed.\n \n-.. _topics-db-transactions-savepoints:\n-\n-Savepoints\n-==========\n-\n-A savepoint is a marker within a transaction that enables you to roll back\n-part of a transaction, rather than the full transaction. Savepoints are\n-available with the SQLite (≥ 3.6.8), PostgreSQL, Oracle and MySQL (when using\n-the InnoDB storage engine) backends. Other backends provide the savepoint\n-functions, but they're empty operations -- they don't actually do anything.\n-\n-Savepoints aren't especially useful if you are using the default\n-``autocommit`` behavior of Django. However, if you are using\n-``commit_on_success`` or ``commit_manually``, each open transaction will build\n-up a series of database operations, awaiting a commit or rollback. If you\n-issue a rollback, the entire transaction is rolled back. Savepoints provide\n-the ability to perform a fine-grained rollback, rather than the full rollback\n-that would be performed by ``transaction.rollback()``.\n-\n-Each of these functions takes a ``using`` argument which should be the name of\n-a database for which the behavior applies.  If no ``using`` argument is\n-provided then the ``\"default\"`` database is used.\n-\n-Savepoints are controlled by three methods on the transaction object:\n-\n-.. method:: transaction.savepoint(using=None)\n-\n-    Creates a new savepoint. This marks a point in the transaction that\n-    is known to be in a \"good\" state.\n-\n-    Returns the savepoint ID (sid).\n-\n-.. method:: transaction.savepoint_commit(sid, using=None)\n-\n-    Updates the savepoint to include any operations that have been performed\n-    since the savepoint was created, or since the last commit.\n-\n-.. method:: transaction.savepoint_rollback(sid, using=None)\n-\n-    Rolls the transaction back to the last point at which the savepoint was\n-    committed.\n-\n-The following example demonstrates the use of savepoints::\n-\n-    from django.db import transaction\n-\n-    @transaction.commit_manually\n-    def viewfunc(request):\n-\n-      a.save()\n-      # open transaction now contains a.save()\n-      sid = transaction.savepoint()\n-\n-      b.save()\n-      # open transaction now contains a.save() and b.save()\n-\n-      if want_to_keep_b:\n-          transaction.savepoint_commit(sid)\n-          # open transaction still contains a.save() and b.save()\n-      else:\n-          transaction.savepoint_rollback(sid)\n-          # open transaction now contains only a.save()\n-\n-      transaction.commit()\n-\n Database-specific notes\n =======================\n \n@@ -477,45 +380,57 @@ transaction. For example::\n In this example, ``a.save()`` will not be undone in the case where\n ``b.save()`` raises an exception.\n \n-Under the hood\n-==============\n+.. _transactions-upgrading-from-1.5:\n \n-.. _autocommit-details:\n+Changes from Django 1.5 and earlier\n+===================================\n \n-Details on autocommit\n----------------------\n+The features described below were deprecated in Django 1.6 and will be removed\n+in Django 1.8. They're documented in order to ease the migration to the new\n+transaction management APIs.\n \n-In the SQL standards, each SQL query starts a transaction, unless one is\n-already in progress. Such transactions must then be committed or rolled back.\n+Legacy APIs\n+-----------\n \n-This isn't always convenient for application developers. To alleviate this\n-problem, most databases provide an autocommit mode. When autocommit is turned\n-on, each SQL query is wrapped in its own transaction. In other words, the\n-transaction is not only automatically started, but also automatically\n-committed.\n+The following functions, defined in ``django.db.transaction``, provided a way\n+to control transactions on a per-function or per-code-block basis. They could\n+be used as decorators or as context managers, and they accepted a ``using``\n+argument, exactly like :func:`atomic`.\n \n-:pep:`249`, the Python Database API Specification v2.0, requires autocommit to\n-be initially turned off. Django overrides this default and turns autocommit\n-on.\n+.. function:: autocommit\n \n-To avoid this, you can :ref:`deactivate the transaction management\n-<deactivate-transaction-management>`, but it isn't recommended.\n+    Enable Django's default autocommit behavior.\n \n-.. versionchanged:: 1.6\n-    Before Django 1.6, autocommit was turned off, and it was emulated by\n-    forcing a commit after write operations in the ORM.\n+    Transactions will be committed as soon as you call ``model.save()``,\n+    ``model.delete()``, or any other function that writes to the database.\n \n-.. warning::\n+.. function:: commit_on_success\n \n-    If you're using the database API directly — for instance, you're running\n-    SQL queries with ``cursor.execute()`` — be aware that autocommit is on,\n-    and consider wrapping your operations in a transaction to ensure\n-    consistency.\n+    Use a single transaction for all the work done in a function.\n+\n+    If the function returns successfully, then Django will commit all work done\n+    within the function at that point. If the function raises an exception,\n+    though, Django will roll back the transaction.\n+\n+.. function:: commit_manually\n+\n+    Tells Django you'll be managing the transaction on your own.\n+\n+    Whether you are writing or simply reading from the database, you must\n+    ``commit()`` or ``rollback()`` explicitly or Django will raise a\n+    :exc:`TransactionManagementError` exception. This is required when reading\n+    from the database because ``SELECT`` statements may call functions which\n+    modify tables, and thus it is impossible to know if any data has been\n+    modified.\n \n .. _transaction-states:\n \n-Transaction management states\n------------------------------\n+Transaction states\n+------------------\n+\n+The three functions described above relied on a concept called \"transaction\n+states\". This mechanisme was deprecated in Django 1.6, but it's still\n+available until Django 1.8..\n \n At any time, each database connection is in one of these two states:\n \n@@ -529,43 +444,88 @@ Django starts in auto mode. ``TransactionMiddleware``,\n Internally, Django keeps a stack of states. Activations and deactivations must\n be balanced.\n \n-For example, at the beginning of each HTTP request, ``TransactionMiddleware``\n-switches to managed mode; at the end of the request, it commits or rollbacks,\n+For example, ``commit_on_success`` switches to managed mode when entering the\n+block of code it controls; when exiting the block, it commits or rollbacks,\n and switches back to auto mode.\n \n-.. admonition:: Nesting decorators / context managers\n+So :func:`commit_on_success` really has two effects: it changes the\n+transaction state and it defines an transaction block. Nesting will give the\n+expected results in terms of transaction state, but not in terms of\n+transaction semantics. Most often, the inner block will commit, breaking the\n+atomicity of the outer block.\n \n-    :func:`commit_on_success` has two effects: it changes the transaction\n-    state, and defines an atomic transaction block.\n+:func:`autocommit` and :func:`commit_manually` have similar limitations.\n \n-    Nesting with :func:`autocommit` and :func:`commit_manually` will give the\n-    expected results in terms of transaction state, but not in terms of\n-    transaction semantics. Most often, the inner block will commit, breaking\n-    the atomicity of the outer block.\n+API changes\n+-----------\n \n-Django currently doesn't provide any APIs to create transactions in auto mode.\n+Managing transactions\n+~~~~~~~~~~~~~~~~~~~~~\n \n-.. _transactions-changes-from-1.5:\n+Starting with Django 1.6, :func:`atomic` is the only supported API for\n+defining a transaction. Unlike the deprecated APIs, it's nestable and always\n+guarantees atomicity.\n \n-Changes from Django 1.5 and earlier\n-===================================\n+In most cases, it will be a drop-in replacement for :func:`commit_on_success`.\n \n-Since version 1.6, Django uses database-level autocommit in auto mode.\n+During the deprecation period, it's possible to use :func:`atomic` within\n+:func:`autocommit`, :func:`commit_on_success` or :func:`commit_manually`.\n+However, the reverse is forbidden, because nesting the old decorators /\n+context managers breaks atomicity.\n+\n+If you enter :func:`atomic` while you're in managed mode, it will trigger a\n+commit to start from a clean slate.\n+\n+Managing autocommit\n+~~~~~~~~~~~~~~~~~~~\n+\n+Django 1.6 introduces an explicit :ref:`API for mananging autocommit\n+<managing-autocommit>`.\n+\n+To disable autocommit temporarily, instead of::\n \n+    with transaction.commit_manually():\n+        # do stuff\n+\n+you should now use::\n+\n+    transaction.set_autocommit(autocommit=False)\n+    try:\n+        # do stuff\n+    finally:\n+        transaction.set_autocommit(autocommit=True)\n+\n+To enable autocommit temporarily, instead of::\n+\n+    with transaction.autocommit():\n+        # do stuff\n+\n+you should now use::\n+\n+    transaction.set_autocommit(autocommit=True)\n+    try:\n+        # do stuff\n+    finally:\n+        transaction.set_autocommit(autocommit=False)\n+\n+Backwards incompatibilities\n+---------------------------\n+\n+Since version 1.6, Django uses database-level autocommit in auto mode.\n Previously, it implemented application-level autocommit by triggering a commit\n after each ORM write.\n \n-As a consequence, each database query (for instance, an\n-ORM read) started a transaction that lasted until the next ORM write. Such\n-\"automatic transactions\" no longer exist in Django 1.6.\n+As a consequence, each database query (for instance, an ORM read) started a\n+transaction that lasted until the next ORM write. Such \"automatic\n+transactions\" no longer exist in Django 1.6.\n \n There are four known scenarios where this is backwards-incompatible.\n \n Note that managed mode isn't affected at all. This section assumes auto mode.\n See the :ref:`description of modes <transaction-states>` above.\n \n Sequences of custom SQL queries\n--------------------------------\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n If you're executing several :ref:`custom SQL queries <executing-custom-sql>`\n in a row, each one now runs in its own transaction, instead of sharing the\n@@ -577,20 +537,20 @@ usually followed by a call to ``transaction.commit_unless_managed``, which\n isn't necessary any more and should be removed.\n \n Select for update\n------------------\n+~~~~~~~~~~~~~~~~~\n \n If you were relying on \"automatic transactions\" to provide locking between\n :meth:`~django.db.models.query.QuerySet.select_for_update` and a subsequent\n write operation — an extremely fragile design, but nonetheless possible — you\n-must wrap the relevant code in :func:`commit_on_success`.\n+must wrap the relevant code in :func:`atomic`.\n \n Using a high isolation level\n-----------------------------\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n If you were using the \"repeatable read\" isolation level or higher, and if you\n relied on \"automatic transactions\" to guarantee consistency between successive\n-reads, the new behavior is backwards-incompatible. To maintain consistency,\n-you must wrap such sequences in :func:`commit_on_success`.\n+reads, the new behavior might be backwards-incompatible. To enforce\n+consistency, you must wrap such sequences in :func:`atomic`.\n \n MySQL defaults to \"repeatable read\" and SQLite to \"serializable\"; they may be\n affected by this problem.\n@@ -602,10 +562,9 @@ PostgreSQL and Oracle default to \"read committed\" and aren't affected, unless\n you changed the isolation level.\n \n Using unsupported database features\n------------------------------------\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n With triggers, views, or functions, it's possible to make ORM reads result in\n database modifications. Django 1.5 and earlier doesn't deal with this case and\n it's theoretically possible to observe a different behavior after upgrading to\n-Django 1.6 or later. In doubt, use :func:`commit_on_success` to enforce\n-integrity.\n+Django 1.6 or later. In doubt, use :func:`atomic` to enforce integrity."
        },
        {
            "sha": "51acbcb07fc6a13b625226590aa76e8dc5dcab54",
            "filename": "tests/backends/tests.py",
            "status": "modified",
            "additions": 12,
            "deletions": 3,
            "changes": 15,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/tests%2Fbackends%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/tests%2Fbackends%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fbackends%2Ftests.py?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -522,7 +522,8 @@ def test_disable_constraint_checks_manually(self):\n         \"\"\"\n         When constraint checks are disabled, should be able to write bad data without IntegrityErrors.\n         \"\"\"\n-        with transaction.commit_manually():\n+        transaction.set_autocommit(autocommit=False)\n+        try:\n             # Create an Article.\n             models.Article.objects.create(headline=\"Test article\", pub_date=datetime.datetime(2010, 9, 4), reporter=self.r)\n             # Retrive it from the DB\n@@ -536,12 +537,15 @@ def test_disable_constraint_checks_manually(self):\n                 self.fail(\"IntegrityError should not have occurred.\")\n             finally:\n                 transaction.rollback()\n+        finally:\n+            transaction.set_autocommit(autocommit=True)\n \n     def test_disable_constraint_checks_context_manager(self):\n         \"\"\"\n         When constraint checks are disabled (using context manager), should be able to write bad data without IntegrityErrors.\n         \"\"\"\n-        with transaction.commit_manually():\n+        transaction.set_autocommit(autocommit=False)\n+        try:\n             # Create an Article.\n             models.Article.objects.create(headline=\"Test article\", pub_date=datetime.datetime(2010, 9, 4), reporter=self.r)\n             # Retrive it from the DB\n@@ -554,12 +558,15 @@ def test_disable_constraint_checks_context_manager(self):\n                 self.fail(\"IntegrityError should not have occurred.\")\n             finally:\n                 transaction.rollback()\n+        finally:\n+            transaction.set_autocommit(autocommit=True)\n \n     def test_check_constraints(self):\n         \"\"\"\n         Constraint checks should raise an IntegrityError when bad data is in the DB.\n         \"\"\"\n-        with transaction.commit_manually():\n+        try:\n+            transaction.set_autocommit(autocommit=False)\n             # Create an Article.\n             models.Article.objects.create(headline=\"Test article\", pub_date=datetime.datetime(2010, 9, 4), reporter=self.r)\n             # Retrive it from the DB\n@@ -572,6 +579,8 @@ def test_check_constraints(self):\n                         connection.check_constraints()\n             finally:\n                 transaction.rollback()\n+        finally:\n+            transaction.set_autocommit(autocommit=True)\n \n \n class ThreadTests(TestCase):"
        },
        {
            "sha": "894a6c7fde9c737e60aa9cfa908d1ab86e9e92de",
            "filename": "tests/fixtures_model_package/tests.py",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/tests%2Ffixtures_model_package%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/tests%2Ffixtures_model_package%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ffixtures_model_package%2Ftests.py?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -25,7 +25,8 @@ def testClassFixtures(self):\n \n class TestNoInitialDataLoading(TransactionTestCase):\n     def test_syncdb(self):\n-        with transaction.commit_manually():\n+        transaction.set_autocommit(autocommit=False)\n+        try:\n             Book.objects.all().delete()\n \n             management.call_command(\n@@ -35,6 +36,9 @@ def test_syncdb(self):\n             )\n             self.assertQuerysetEqual(Book.objects.all(), [])\n             transaction.rollback()\n+        finally:\n+            transaction.set_autocommit(autocommit=True)\n+\n \n     def test_flush(self):\n         # Test presence of fixture (flush called by TransactionTestCase)\n@@ -45,7 +49,8 @@ def test_flush(self):\n             lambda a: a.name\n         )\n \n-        with transaction.commit_manually():\n+        transaction.set_autocommit(autocommit=False)\n+        try:\n             management.call_command(\n                 'flush',\n                 verbosity=0,\n@@ -55,6 +60,8 @@ def test_flush(self):\n             )\n             self.assertQuerysetEqual(Book.objects.all(), [])\n             transaction.rollback()\n+        finally:\n+            transaction.set_autocommit(autocommit=True)\n \n \n class FixtureTestCase(TestCase):"
        },
        {
            "sha": "f965dd81ac7d190b40bbfd805f88994ae744ab37",
            "filename": "tests/fixtures_regress/tests.py",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/tests%2Ffixtures_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/tests%2Ffixtures_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ffixtures_regress%2Ftests.py?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -684,5 +684,8 @@ def ticket_11101(self):\n     @skipUnlessDBFeature('supports_transactions')\n     def test_ticket_11101(self):\n         \"\"\"Test that fixtures can be rolled back (ticket #11101).\"\"\"\n-        ticket_11101 = transaction.commit_manually(self.ticket_11101)\n-        ticket_11101()\n+        transaction.set_autocommit(autocommit=False)\n+        try:\n+            self.ticket_11101()\n+        finally:\n+            transaction.set_autocommit(autocommit=True)"
        },
        {
            "sha": "7e26037967d5e2b0e7cd0596d3f9f4ce15ea3314",
            "filename": "tests/middleware/tests.py",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/tests%2Fmiddleware%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/tests%2Fmiddleware%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmiddleware%2Ftests.py?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -24,6 +24,8 @@\n from django.utils.six.moves import xrange\n from django.utils.unittest import expectedFailure\n \n+from transactions.tests import IgnorePendingDeprecationWarningsMixin\n+\n from .models import Band\n \n \n@@ -670,11 +672,12 @@ def test_compress_response(self):\n \n         self.assertNotEqual(gzip_etag, nogzip_etag)\n \n-class TransactionMiddlewareTest(TransactionTestCase):\n+class TransactionMiddlewareTest(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     \"\"\"\n     Test the transaction middleware.\n     \"\"\"\n     def setUp(self):\n+        super(TransactionMiddlewareTest, self).setUp()\n         self.request = HttpRequest()\n         self.request.META = {\n             'SERVER_NAME': 'testserver',\n@@ -686,6 +689,7 @@ def setUp(self):\n \n     def tearDown(self):\n         transaction.abort()\n+        super(TransactionMiddlewareTest, self).tearDown()\n \n     def test_request(self):\n         TransactionMiddleware().process_request(self.request)"
        },
        {
            "sha": "d6cfd8ae959e3c2183738679056eed4948e15a63",
            "filename": "tests/transactions/tests.py",
            "status": "modified",
            "additions": 67,
            "deletions": 4,
            "changes": 71,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/tests%2Ftransactions%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/tests%2Ftransactions%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions%2Ftests.py?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -1,9 +1,10 @@\n from __future__ import absolute_import\n \n import sys\n+import warnings\n \n from django.db import connection, transaction, IntegrityError\n-from django.test import TestCase, TransactionTestCase, skipUnlessDBFeature\n+from django.test import TransactionTestCase, skipUnlessDBFeature\n from django.utils import six\n from django.utils.unittest import skipUnless\n \n@@ -158,7 +159,69 @@ def tearDown(self):\n         self.atomic.__exit__(*sys.exc_info())\n \n \n-class TransactionTests(TransactionTestCase):\n+class AtomicInsideLegacyTransactionManagementTests(AtomicTests):\n+\n+    def setUp(self):\n+        transaction.enter_transaction_management()\n+\n+    def tearDown(self):\n+        # The tests access the database after exercising 'atomic', making the\n+        # connection dirty; a rollback is required to make it clean.\n+        transaction.rollback()\n+        transaction.leave_transaction_management()\n+\n+\n+@skipUnless(connection.features.uses_savepoints,\n+        \"'atomic' requires transactions and savepoints.\")\n+class AtomicErrorsTests(TransactionTestCase):\n+\n+    def test_atomic_requires_autocommit(self):\n+        transaction.set_autocommit(autocommit=False)\n+        try:\n+            with self.assertRaises(transaction.TransactionManagementError):\n+                with transaction.atomic():\n+                    pass\n+        finally:\n+            transaction.set_autocommit(autocommit=True)\n+\n+    def test_atomic_prevents_disabling_autocommit(self):\n+        autocommit = transaction.get_autocommit()\n+        with transaction.atomic():\n+            with self.assertRaises(transaction.TransactionManagementError):\n+                transaction.set_autocommit(autocommit=not autocommit)\n+        # Make sure autocommit wasn't changed.\n+        self.assertEqual(connection.autocommit, autocommit)\n+\n+    def test_atomic_prevents_calling_transaction_methods(self):\n+        with transaction.atomic():\n+            with self.assertRaises(transaction.TransactionManagementError):\n+                transaction.commit()\n+            with self.assertRaises(transaction.TransactionManagementError):\n+                transaction.rollback()\n+\n+    def test_atomic_prevents_calling_transaction_management_methods(self):\n+        with transaction.atomic():\n+            with self.assertRaises(transaction.TransactionManagementError):\n+                transaction.enter_transaction_management()\n+            with self.assertRaises(transaction.TransactionManagementError):\n+                transaction.leave_transaction_management()\n+\n+\n+class IgnorePendingDeprecationWarningsMixin(object):\n+\n+    def setUp(self):\n+        super(IgnorePendingDeprecationWarningsMixin, self).setUp()\n+        self.catch_warnings = warnings.catch_warnings()\n+        self.catch_warnings.__enter__()\n+        warnings.filterwarnings(\"ignore\", category=PendingDeprecationWarning)\n+\n+    def tearDown(self):\n+        self.catch_warnings.__exit__(*sys.exc_info())\n+        super(IgnorePendingDeprecationWarningsMixin, self).tearDown()\n+\n+\n+class TransactionTests(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n+\n     def create_a_reporter_then_fail(self, first, last):\n         a = Reporter(first_name=first, last_name=last)\n         a.save()\n@@ -313,7 +376,7 @@ def test_manually_managed_with_using(self):\n         )\n \n \n-class TransactionRollbackTests(TransactionTestCase):\n+class TransactionRollbackTests(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     def execute_bad_sql(self):\n         cursor = connection.cursor()\n         cursor.execute(\"INSERT INTO transactions_reporter (first_name, last_name) VALUES ('Douglas', 'Adams');\")\n@@ -330,7 +393,7 @@ def test_bad_sql(self):\n         self.assertRaises(IntegrityError, execute_bad_sql)\n         transaction.rollback()\n \n-class TransactionContextManagerTests(TransactionTestCase):\n+class TransactionContextManagerTests(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     def create_reporter_and_fail(self):\n         Reporter.objects.create(first_name=\"Bob\", last_name=\"Holtzman\")\n         raise Exception"
        },
        {
            "sha": "d5ee62da5edc49ca1ceedbed701d0e0a3311fae6",
            "filename": "tests/transactions_regress/tests.py",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/7c46c8d5f27fe305507359588ca0635b6d87c59a/tests%2Ftransactions_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/7c46c8d5f27fe305507359588ca0635b6d87c59a/tests%2Ftransactions_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions_regress%2Ftests.py?ref=7c46c8d5f27fe305507359588ca0635b6d87c59a",
            "patch": "@@ -6,10 +6,12 @@\n from django.test.utils import override_settings\n from django.utils.unittest import skipIf, skipUnless, expectedFailure\n \n+from transactions.tests import IgnorePendingDeprecationWarningsMixin\n+\n from .models import Mod, M2mA, M2mB\n \n \n-class TestTransactionClosing(TransactionTestCase):\n+class TestTransactionClosing(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     \"\"\"\n     Tests to make sure that transactions are properly closed\n     when they should be, and aren't left pending after operations\n@@ -166,7 +168,7 @@ def test_failing_query_transaction_closed_debug(self):\n         (connection.settings_dict['NAME'] == ':memory:' or\n          not connection.settings_dict['NAME']),\n         'Test uses multiple connections, but in-memory sqlite does not support this')\n-class TestNewConnection(TransactionTestCase):\n+class TestNewConnection(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     \"\"\"\n     Check that new connections don't have special behaviour.\n     \"\"\"\n@@ -211,7 +213,7 @@ def test_enter_exit_management(self):\n \n @skipUnless(connection.vendor == 'postgresql',\n             \"This test only valid for PostgreSQL\")\n-class TestPostgresAutocommitAndIsolation(TransactionTestCase):\n+class TestPostgresAutocommitAndIsolation(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     \"\"\"\n     Tests to make sure psycopg2's autocommit mode and isolation level\n     is restored after entering and leaving transaction management.\n@@ -292,7 +294,7 @@ def test_enter_autocommit(self):\n         self.assertTrue(connection.autocommit)\n \n \n-class TestManyToManyAddTransaction(TransactionTestCase):\n+class TestManyToManyAddTransaction(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     def test_manyrelated_add_commit(self):\n         \"Test for https://code.djangoproject.com/ticket/16818\"\n         a = M2mA.objects.create()\n@@ -307,7 +309,7 @@ def test_manyrelated_add_commit(self):\n         self.assertEqual(a.others.count(), 1)\n \n \n-class SavepointTest(TransactionTestCase):\n+class SavepointTest(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n \n     @skipIf(connection.vendor == 'sqlite',\n             \"SQLite doesn't support savepoints in managed mode\")"
        }
    ],
    "stats": {
        "total": 628,
        "additions": 359,
        "deletions": 269
    }
}