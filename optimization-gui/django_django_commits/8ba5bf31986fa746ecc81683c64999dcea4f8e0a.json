{
    "author": "andrewgodwin",
    "message": "Very start of schema alteration port. Create/delete model and some tests.",
    "sha": "8ba5bf31986fa746ecc81683c64999dcea4f8e0a",
    "files": [
        {
            "sha": "ed2a54277fb3521033556fe924c62bf07592ecad",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=8ba5bf31986fa746ecc81683c64999dcea4f8e0a",
            "patch": "@@ -312,6 +312,11 @@ def cursor(self):\n     def make_debug_cursor(self, cursor):\n         return util.CursorDebugWrapper(cursor, self)\n \n+    def schema_editor(self):\n+        \"Returns a new instance of this backend's SchemaEditor\"\n+        raise NotImplementedError()\n+\n+\n class BaseDatabaseFeatures(object):\n     allows_group_by_pk = False\n     # True if django.db.backend.utils.typecast_timestamp is used on values\n@@ -411,6 +416,9 @@ class BaseDatabaseFeatures(object):\n     # Support for the DISTINCT ON clause\n     can_distinct_on_fields = False\n \n+    # Can we roll back DDL in a transaction?\n+    can_rollback_ddl = False\n+\n     def __init__(self, connection):\n         self.connection = connection\n "
        },
        {
            "sha": "6c56bb9c9191d24ad0143cf13bc3b053c6c80eda",
            "filename": "django/db/backends/postgresql_psycopg2/base.py",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py?ref=8ba5bf31986fa746ecc81683c64999dcea4f8e0a",
            "patch": "@@ -13,6 +13,7 @@\n from django.db.backends.postgresql_psycopg2.creation import DatabaseCreation\n from django.db.backends.postgresql_psycopg2.version import get_version\n from django.db.backends.postgresql_psycopg2.introspection import DatabaseIntrospection\n+from django.db.backends.postgresql_psycopg2.schema import DatabaseSchemaEditor\n from django.utils.log import getLogger\n from django.utils.safestring import SafeUnicode, SafeString\n from django.utils.timezone import utc\n@@ -83,6 +84,7 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     has_bulk_insert = True\n     supports_tablespaces = True\n     can_distinct_on_fields = True\n+    can_rollback_ddl = True\n \n class DatabaseWrapper(BaseDatabaseWrapper):\n     vendor = 'postgresql'\n@@ -235,3 +237,7 @@ def _commit(self):\n                 return self.connection.commit()\n             except Database.IntegrityError as e:\n                 raise utils.IntegrityError, utils.IntegrityError(*tuple(e)), sys.exc_info()[2]\n+\n+    def schema_editor(self):\n+        \"Returns a new instance of this backend's SchemaEditor\"\n+        return DatabaseSchemaEditor(self)"
        },
        {
            "sha": "b86e0857bbb97f0c5dfadaaa8f6fb5f996cedc7a",
            "filename": "django/db/backends/postgresql_psycopg2/schema.py",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fschema.py",
            "raw_url": "https://github.com/django/django/raw/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fschema.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fschema.py?ref=8ba5bf31986fa746ecc81683c64999dcea4f8e0a",
            "patch": "@@ -0,0 +1,5 @@\n+from django.db.backends.schema import BaseDatabaseSchemaEditor\n+\n+\n+class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n+    pass"
        },
        {
            "sha": "73a9b99b5014b9dca9df5ed0f1ace2a6a159b03d",
            "filename": "django/db/backends/schema.py",
            "status": "added",
            "additions": 178,
            "deletions": 0,
            "changes": 178,
            "blob_url": "https://github.com/django/django/blob/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/django%2Fdb%2Fbackends%2Fschema.py",
            "raw_url": "https://github.com/django/django/raw/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/django%2Fdb%2Fbackends%2Fschema.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fschema.py?ref=8ba5bf31986fa746ecc81683c64999dcea4f8e0a",
            "patch": "@@ -0,0 +1,178 @@\n+import sys\n+import time\n+\n+from django.conf import settings\n+from django.db import transaction\n+from django.db.utils import load_backend\n+from django.utils.log import getLogger\n+\n+logger = getLogger('django.db.backends.schema')\n+\n+\n+class BaseDatabaseSchemaEditor(object):\n+    \"\"\"\n+    This class (and its subclasses) are responsible for emitting schema-changing\n+    statements to the databases - model creation/removal/alteration, field\n+    renaming, index fiddling, and so on.\n+\n+    It is intended to eventually completely replace DatabaseCreation.\n+\n+    This class should be used by creating an instance for each set of schema\n+    changes (e.g. a syncdb run, a migration file), and by first calling start(),\n+    then the relevant actions, and then commit(). This is necessary to allow\n+    things like circular foreign key references - FKs will only be created once\n+    commit() is called.\n+    \"\"\"\n+\n+    # Overrideable SQL templates\n+    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n+    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n+    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n+\n+    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(definition)s\"\n+    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n+    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n+    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n+    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE;\"\n+\n+    sql_create_check = \"ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n+    sql_delete_check = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n+\n+    sql_create_unique = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s UNIQUE (%(columns)s)\"\n+    sql_delete_unique = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n+\n+    sql_create_fk = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n+    sql_delete_fk = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n+\n+    sql_create_index = \"CREATE %(unique)s INDEX %(name)s ON %(table)s (%(columns)s)%s;\"\n+    sql_delete_index = \"DROP INDEX %(name)s\"\n+\n+    sql_create_pk = \"ALTER TABLE %(table)s ADD CONSTRAINT %(constraint)s PRIMARY KEY (%(columns)s)\"\n+    sql_delete_pk = \"ALTER TABLE %(table)s DROP CONSTRAINT %(constraint)s\"\n+\n+    def __init__(self, connection):\n+        self.connection = connection\n+\n+    # State-managing methods\n+\n+    def start(self):\n+        \"Marks the start of a schema-altering run\"\n+        self.deferred_sql = []\n+        self.connection.commit_unless_managed()\n+        self.connection.enter_transaction_management()\n+        self.connection.managed(True)\n+\n+    def commit(self):\n+        \"Finishes a schema-altering run\"\n+        for sql in self.deferred_sql:\n+            self.execute(sql)\n+        self.connection.commit()\n+        self.connection.leave_transaction_management()\n+\n+    def rollback(self):\n+        \"Tries to roll back a schema-altering run. Call instead of commit()\"\n+        if not self.connection.features.can_rollback_ddl:\n+            raise RuntimeError(\"Cannot rollback schema changes on this backend\")\n+        self.connection.rollback()\n+        self.connection.leave_transaction_management()\n+\n+    # Core utility functions\n+\n+    def execute(self, sql, params=[], fetch_results=False):\n+        \"\"\"\n+        Executes the given SQL statement, with optional parameters.\n+        \"\"\"\n+        # Get the cursor\n+        cursor = self.connection.cursor()\n+        # Log the command we're running, then run it\n+        logger.info(\"%s; (params %r)\" % (sql, params))\n+        cursor.execute(sql, params)\n+\n+    def quote_name(self, name):\n+        return self.connection.ops.quote_name(name)\n+\n+    # Actions\n+\n+    def create_model(self, model):\n+        \"\"\"\n+        Takes a model and creates a table for it in the database.\n+        Will also create any accompanying indexes or unique constraints.\n+        \"\"\"\n+        # Do nothing if this is an unmanaged or proxy model\n+        if not model._meta.managed or model._meta.proxy:\n+            return [], {}\n+        # Create column SQL, add FK deferreds if needed\n+        column_sqls = []\n+        for field in model._meta.local_fields:\n+            # SQL\n+            definition = self.column_sql(model, field)\n+            if definition is None:\n+                continue\n+            column_sqls.append(\"%s %s\" % (\n+                self.quote_name(field.column),\n+                definition,\n+            ))\n+            # FK\n+            if field.rel:\n+                to_table = field.rel.to._meta.db_table\n+                to_column = field.rel.to._meta.get_field(field.rel.field_name).column\n+                self.deferred_sql.append(\n+                    self.sql_create_fk % {\n+                        \"name\": '%s_refs_%s_%x' % (\n+                            field.column,\n+                            to_column,\n+                            abs(hash((model._meta.db_table, to_table)))\n+                        ),\n+                        \"table\": self.quote_name(model._meta.db_table),\n+                        \"column\": self.quote_name(field.column),\n+                        \"to_table\": self.quote_name(to_table),\n+                        \"to_column\": self.quote_name(to_column),\n+                    }\n+                )\n+        # Make the table\n+        sql = self.sql_create_table % {\n+            \"table\": model._meta.db_table,\n+            \"definition\": \", \".join(column_sqls)\n+        }\n+        self.execute(sql)\n+\n+    def column_sql(self, model, field, include_default=False):\n+        \"\"\"\n+        Takes a field and returns its column definition.\n+        The field must already have had set_attributes_from_name called.\n+        \"\"\"\n+        # Get the column's type and use that as the basis of the SQL\n+        sql = field.db_type(connection=self.connection)\n+        # Check for fields that aren't actually columns (e.g. M2M)\n+        if sql is None:\n+            return None\n+        # Optionally add the tablespace if it's an implicitly indexed column\n+        tablespace = field.db_tablespace or model._meta.db_tablespace\n+        if tablespace and self.connection.features.supports_tablespaces and field.unique:\n+            sql += \" %s\" % self.connection.ops.tablespace_sql(tablespace, inline=True)\n+        # Work out nullability\n+        null = field.null\n+        # Oracle treats the empty string ('') as null, so coerce the null\n+        # option whenever '' is a possible value.\n+        if (field.empty_strings_allowed and not field.primary_key and\n+                self.connection.features.interprets_empty_strings_as_nulls):\n+            null = True\n+        if null:\n+            sql += \" NULL\"\n+        else:\n+            sql += \" NOT NULL\"\n+        # Primary key/unique outputs\n+        if field.primary_key:\n+            sql += \" PRIMARY KEY\"\n+        elif field.unique:\n+            sql += \" UNIQUE\"\n+        # If we were told to include a default value, do so\n+        if include_default:\n+            raise NotImplementedError()\n+        # Return the sql\n+        return sql\n+\n+    def delete_model(self, model):\n+        self.execute(self.sql_delete_table % {\n+            \"table\": self.quote_name(model._meta.db_table),\n+        })"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/modeltests/schema/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/django/django/blob/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/tests%2Fmodeltests%2Fschema%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/tests%2Fmodeltests%2Fschema%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fschema%2F__init__.py?ref=8ba5bf31986fa746ecc81683c64999dcea4f8e0a"
        },
        {
            "sha": "2c5dc829c6d939fc9e6ba3bae1c940a19772f39b",
            "filename": "tests/modeltests/schema/models.py",
            "status": "added",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/tests%2Fmodeltests%2Fschema%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/tests%2Fmodeltests%2Fschema%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fschema%2Fmodels.py?ref=8ba5bf31986fa746ecc81683c64999dcea4f8e0a",
            "patch": "@@ -0,0 +1,21 @@\n+from django.db import models\n+\n+# Because we want to test creation and deletion of these as separate things,\n+# these models are all marked as unmanaged and only marked as managed while\n+# a schema test is running.\n+\n+\n+class Author(models.Model):\n+    name = models.CharField(max_length=255)\n+\n+    class Meta:\n+        managed = False\n+\n+\n+class Book(models.Model):\n+    author = models.ForeignKey(Author)\n+    title = models.CharField(max_length=100)\n+    pub_date = models.DateTimeField()\n+\n+    class Meta:\n+        managed = False"
        },
        {
            "sha": "6d5d27cdf1cf1780d07aeb27c076437097838a0d",
            "filename": "tests/modeltests/schema/tests.py",
            "status": "added",
            "additions": 102,
            "deletions": 0,
            "changes": 102,
            "blob_url": "https://github.com/django/django/blob/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/8ba5bf31986fa746ecc81683c64999dcea4f8e0a/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fschema%2Ftests.py?ref=8ba5bf31986fa746ecc81683c64999dcea4f8e0a",
            "patch": "@@ -0,0 +1,102 @@\n+from __future__ import absolute_import\n+import copy\n+import datetime\n+from django.test import TestCase\n+from django.db.models.loading import cache\n+from django.db import connection, DatabaseError, IntegrityError\n+from .models import Author, Book\n+\n+\n+class SchemaTests(TestCase):\n+    \"\"\"\n+    Tests that the schema-alteration code works correctly.\n+\n+    Be aware that these tests are more liable than most to false results,\n+    as sometimes the code to check if a test has worked is almost as complex\n+    as the code it is testing.\n+    \"\"\"\n+\n+    models = [Author, Book]\n+\n+    def setUp(self):\n+        # Make sure we're in manual transaction mode\n+        connection.commit_unless_managed()\n+        connection.enter_transaction_management()\n+        connection.managed(True)\n+        # The unmanaged models need to be removed after the test in order to\n+        # prevent bad interactions with the flush operation in other tests.\n+        self.old_app_models = copy.deepcopy(cache.app_models)\n+        self.old_app_store = copy.deepcopy(cache.app_store)\n+        for model in self.models:\n+            model._meta.managed = True\n+\n+    def tearDown(self):\n+        # Rollback anything that may have happened\n+        connection.rollback()\n+        # Delete any tables made for our models\n+        cursor = connection.cursor()\n+        for model in self.models:\n+            try:\n+                cursor.execute(\"DROP TABLE %s CASCADE\" % (\n+                    connection.ops.quote_name(model._meta.db_table),\n+                ))\n+            except DatabaseError:\n+                connection.rollback()\n+            else:\n+                connection.commit()\n+        # Unhook our models\n+        for model in self.models:\n+            model._meta.managed = False\n+        cache.app_models = self.old_app_models\n+        cache.app_store = self.old_app_store\n+        cache._get_models_cache = {}\n+\n+    def test_creation_deletion(self):\n+        \"\"\"\n+        Tries creating a model's table, and then deleting it.\n+        \"\"\"\n+        # Create the table\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.create_model(Author)\n+        editor.commit()\n+        # Check that it's there\n+        try:\n+            list(Author.objects.all())\n+        except DatabaseError, e:\n+            self.fail(\"Table not created: %s\" % e)\n+        # Clean up that table\n+        editor.start()\n+        editor.delete_model(Author)\n+        editor.commit()\n+        # Check that it's gone\n+        self.assertRaises(\n+            DatabaseError,\n+            lambda: list(Author.objects.all()),\n+        )\n+\n+    def test_creation_fk(self):\n+        \"Tests that creating tables out of FK order works\"\n+        # Create the table\n+        editor = connection.schema_editor()\n+        editor.start()\n+        editor.create_model(Book)\n+        editor.create_model(Author)\n+        editor.commit()\n+        # Check that both tables are there\n+        try:\n+            list(Author.objects.all())\n+        except DatabaseError, e:\n+            self.fail(\"Author table not created: %s\" % e)\n+        try:\n+            list(Book.objects.all())\n+        except DatabaseError, e:\n+            self.fail(\"Book table not created: %s\" % e)\n+        # Make sure the FK constraint is present\n+        with self.assertRaises(IntegrityError):\n+            Book.objects.create(\n+                author_id = 1,\n+                title = \"Much Ado About Foreign Keys\",\n+                pub_date = datetime.datetime.now(),\n+            )\n+            connection.commit()"
        }
    ],
    "stats": {
        "total": 320,
        "additions": 320,
        "deletions": 0
    }
}