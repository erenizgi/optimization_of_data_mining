{
    "author": "aaugustin",
    "message": "Fixed #18323 -- Refactored date arithmetic\n\nin date based generic views, in order to deal properly with both\nDateFields and DateTimeFields.",
    "sha": "20e697368219603599649bc67aea5e087caedeae",
    "files": [
        {
            "sha": "a634d170c2f384de28d95aca7b6a0843b5d320f2",
            "filename": "django/views/generic/dates.py",
            "status": "modified",
            "additions": 139,
            "deletions": 63,
            "changes": 202,
            "blob_url": "https://github.com/django/django/blob/20e697368219603599649bc67aea5e087caedeae/django%2Fviews%2Fgeneric%2Fdates.py",
            "raw_url": "https://github.com/django/django/raw/20e697368219603599649bc67aea5e087caedeae/django%2Fviews%2Fgeneric%2Fdates.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fviews%2Fgeneric%2Fdates.py?ref=20e697368219603599649bc67aea5e087caedeae",
            "patch": "@@ -23,7 +23,9 @@ def get_year_format(self):\n         return self.year_format\n \n     def get_year(self):\n-        \"Return the year for which this view should display data\"\n+        \"\"\"\n+        Return the year for which this view should display data.\n+        \"\"\"\n         year = self.year\n         if year is None:\n             try:\n@@ -35,6 +37,20 @@ def get_year(self):\n                     raise Http404(_(u\"No year specified\"))\n         return year\n \n+    def _get_next_year(self, date):\n+        \"\"\"\n+        Return the start date of the next interval.\n+\n+        The interval is defined by start date <= item date < next start date.\n+        \"\"\"\n+        return date.replace(year=date.year + 1, month=1, day=1)\n+\n+    def _get_current_year(self, date):\n+        \"\"\"\n+        Return the start date of the current interval.\n+        \"\"\"\n+        return date.replace(month=1, day=1)\n+\n \n class MonthMixin(object):\n     month_format = '%b'\n@@ -48,7 +64,9 @@ def get_month_format(self):\n         return self.month_format\n \n     def get_month(self):\n-        \"Return the month for which this view should display data\"\n+        \"\"\"\n+        Return the month for which this view should display data.\n+        \"\"\"\n         month = self.month\n         if month is None:\n             try:\n@@ -64,20 +82,30 @@ def get_next_month(self, date):\n         \"\"\"\n         Get the next valid month.\n         \"\"\"\n-        # next must be the first day of the next month.\n-        if date.month == 12:\n-            next = date.replace(year=date.year + 1, month=1, day=1)\n-        else:\n-            next = date.replace(month=date.month + 1, day=1)\n-        return _get_next_prev(self, next, is_previous=False, period='month')\n+        return _get_next_prev(self, date, is_previous=False, period='month')\n \n     def get_previous_month(self, date):\n         \"\"\"\n         Get the previous valid month.\n         \"\"\"\n-        # prev must be the last day of the previous month.\n-        prev = date.replace(day=1) - datetime.timedelta(days=1)\n-        return _get_next_prev(self, prev, is_previous=True, period='month')\n+        return _get_next_prev(self, date, is_previous=True, period='month')\n+\n+    def _get_next_month(self, date):\n+        \"\"\"\n+        Return the start date of the next interval.\n+\n+        The interval is defined by start date <= item date < next start date.\n+        \"\"\"\n+        if date.month == 12:\n+            return date.replace(year=date.year + 1, month=1, day=1)\n+        else:\n+            return date.replace(month=date.month + 1, day=1)\n+\n+    def _get_current_month(self, date):\n+        \"\"\"\n+        Return the start date of the previous interval.\n+        \"\"\"\n+        return date.replace(day=1)\n \n \n class DayMixin(object):\n@@ -92,7 +120,9 @@ def get_day_format(self):\n         return self.day_format\n \n     def get_day(self):\n-        \"Return the day for which this view should display data\"\n+        \"\"\"\n+        Return the day for which this view should display data.\n+        \"\"\"\n         day = self.day\n         if day is None:\n             try:\n@@ -108,15 +138,27 @@ def get_next_day(self, date):\n         \"\"\"\n         Get the next valid day.\n         \"\"\"\n-        next = date + datetime.timedelta(days=1)\n-        return _get_next_prev(self, next, is_previous=False, period='day')\n+        return _get_next_prev(self, date, is_previous=False, period='day')\n \n     def get_previous_day(self, date):\n         \"\"\"\n         Get the previous valid day.\n         \"\"\"\n-        prev = date - datetime.timedelta(days=1)\n-        return _get_next_prev(self, prev, is_previous=True, period='day')\n+        return _get_next_prev(self, date, is_previous=True, period='day')\n+\n+    def _get_next_day(self, date):\n+        \"\"\"\n+        Return the start date of the next interval.\n+\n+        The interval is defined by start date <= item date < next start date.\n+        \"\"\"\n+        return date + datetime.timedelta(days=1)\n+\n+    def _get_current_day(self, date):\n+        \"\"\"\n+        Return the start date of the current interval.\n+        \"\"\"\n+        return date\n \n \n class WeekMixin(object):\n@@ -131,7 +173,9 @@ def get_week_format(self):\n         return self.week_format\n \n     def get_week(self):\n-        \"Return the week for which this view should display data\"\n+        \"\"\"\n+        Return the week for which this view should display data\n+        \"\"\"\n         week = self.week\n         if week is None:\n             try:\n@@ -147,19 +191,34 @@ def get_next_week(self, date):\n         \"\"\"\n         Get the next valid week.\n         \"\"\"\n-        # next must be the first day of the next week.\n-        next = date + datetime.timedelta(days=7 - self._get_weekday(date))\n-        return _get_next_prev(self, next, is_previous=False, period='week')\n+        return _get_next_prev(self, date, is_previous=False, period='week')\n \n     def get_previous_week(self, date):\n         \"\"\"\n         Get the previous valid week.\n         \"\"\"\n-        # prev must be the last day of the previous week.\n-        prev = date - datetime.timedelta(days=self._get_weekday(date) + 1)\n-        return _get_next_prev(self, prev, is_previous=True, period='week')\n+        return _get_next_prev(self, date, is_previous=True, period='week')\n+\n+    def _get_next_week(self, date):\n+        \"\"\"\n+        Return the start date of the next interval.\n+\n+        The interval is defined by start date <= item date < next start date.\n+        \"\"\"\n+        return date + datetime.timedelta(days=7 - self._get_weekday(date))\n+\n+    def _get_current_week(self, date):\n+        \"\"\"\n+        Return the start date of the current interval.\n+        \"\"\"\n+        return date - datetime.timedelta(self._get_weekday(date))\n \n     def _get_weekday(self, date):\n+        \"\"\"\n+        Return the weekday for a given date.\n+\n+        The first day according to the week format is 0 and the last day is 6.\n+        \"\"\"\n         week_format = self.get_week_format()\n         if week_format == '%W':                 # week starts on Monday\n             return date.weekday()\n@@ -168,6 +227,7 @@ def _get_weekday(self, date):\n         else:\n             raise ValueError(\"unknown week format: %s\" % week_format)\n \n+\n class DateMixin(object):\n     \"\"\"\n     Mixin class for views manipulating date-based data.\n@@ -267,7 +327,7 @@ def get_dated_queryset(self, **lookup):\n         paginate_by = self.get_paginate_by(qs)\n \n         if not allow_future:\n-            now = timezone.now() if self.uses_datetime_field else datetime.date.today()\n+            now = timezone.now() if self.uses_datetime_field else timezone_today()\n             qs = qs.filter(**{'%s__lte' % date_field: now})\n \n         if not allow_empty:\n@@ -344,7 +404,7 @@ def get_dated_items(self):\n         date = _date_from_string(year, self.get_year_format())\n \n         since = self._make_date_lookup_arg(date)\n-        until = self._make_date_lookup_arg(datetime.date(date.year + 1, 1, 1))\n+        until = self._make_date_lookup_arg(self._get_next_year(date))\n         lookup_kwargs = {\n             '%s__gte' % date_field: since,\n             '%s__lt' % date_field: until,\n@@ -392,12 +452,8 @@ def get_dated_items(self):\n         date = _date_from_string(year, self.get_year_format(),\n                                  month, self.get_month_format())\n \n-        # Construct a date-range lookup.\n         since = self._make_date_lookup_arg(date)\n-        if date.month == 12:\n-            until = self._make_date_lookup_arg(datetime.date(date.year + 1, 1, 1))\n-        else:\n-            until = self._make_date_lookup_arg(datetime.date(date.year, date.month + 1, 1))\n+        until = self._make_date_lookup_arg(self._get_next_month(date))\n         lookup_kwargs = {\n             '%s__gte' % date_field: since,\n             '%s__lt' % date_field: until,\n@@ -442,9 +498,8 @@ def get_dated_items(self):\n                                  week_start, '%w',\n                                  week, week_format)\n \n-        # Construct a date-range lookup.\n         since = self._make_date_lookup_arg(date)\n-        until = self._make_date_lookup_arg(date + datetime.timedelta(days=7))\n+        until = self._make_date_lookup_arg(self._get_next_week(date))\n         lookup_kwargs = {\n             '%s__gte' % date_field: since,\n             '%s__lt' % date_field: until,\n@@ -585,22 +640,22 @@ def _date_from_string(year, year_format, month='', month_format='', day='', day_\n         })\n \n \n-def _get_next_prev(generic_view, naive_result, is_previous, period):\n+def _get_next_prev(generic_view, date, is_previous, period):\n     \"\"\"\n     Helper: Get the next or the previous valid date. The idea is to allow\n     links on month/day views to never be 404s by never providing a date\n     that'll be invalid for the given view.\n \n-    This is a bit complicated since it handles both next and previous months\n-    and days (for MonthArchiveView and DayArchiveView); hence the coupling to generic_view.\n+    This is a bit complicated since it handles different intervals of time,\n+    hence the coupling to generic_view.\n \n     However in essence the logic comes down to:\n \n         * If allow_empty and allow_future are both true, this is easy: just\n-          return the naive result (just the next/previous day or month,\n+          return the naive result (just the next/previous day/week/month,\n           reguardless of object existence.)\n \n-        * If allow_empty is true, allow_future is false, and the naive month\n+        * If allow_empty is true, allow_future is false, and the naive result\n           isn't in the future, then return it; otherwise return None.\n \n         * If allow_empty is false and allow_future is true, return the next\n@@ -616,9 +671,23 @@ def _get_next_prev(generic_view, naive_result, is_previous, period):\n     allow_empty = generic_view.get_allow_empty()\n     allow_future = generic_view.get_allow_future()\n \n-    # If allow_empty is True the naive value will be valid\n+    get_current = getattr(generic_view, '_get_current_%s' % period)\n+    get_next = getattr(generic_view, '_get_next_%s' % period)\n+\n+    # Bounds of the current interval\n+    start, end = get_current(date), get_next(date)\n+\n+    # If allow_empty is True, the naive result will be valid\n     if allow_empty:\n-        result = naive_result\n+        if is_previous:\n+            result = get_current(start - datetime.timedelta(days=1))\n+        else:\n+            result = end\n+\n+        if allow_future or result <= timezone_today():\n+            return result\n+        else:\n+            return None\n \n     # Otherwise, we'll need to go to the database to look for an object\n     # whose date_field is at least (greater than/less than) the given\n@@ -627,39 +696,46 @@ def _get_next_prev(generic_view, naive_result, is_previous, period):\n         # Construct a lookup and an ordering depending on whether we're doing\n         # a previous date or a next date lookup.\n         if is_previous:\n-            lookup = {'%s__lte' % date_field: generic_view._make_date_lookup_arg(naive_result)}\n+            lookup = {'%s__lt' % date_field: generic_view._make_date_lookup_arg(start)}\n             ordering = '-%s' % date_field\n         else:\n-            lookup = {'%s__gte' % date_field: generic_view._make_date_lookup_arg(naive_result)}\n+            lookup = {'%s__gte' % date_field: generic_view._make_date_lookup_arg(end)}\n             ordering = date_field\n \n+        # Filter out objects in the future if appropriate.\n+        if not allow_future:\n+            # Fortunately, to match the implementation of allow_future,\n+            # we need __lte, which doesn't conflict with __lt above.\n+            if generic_view.uses_datetime_field:\n+                now = timezone.now()\n+            else:\n+                now = timezone_today()\n+            lookup['%s__lte' % date_field] = now\n+\n         qs = generic_view.get_queryset().filter(**lookup).order_by(ordering)\n \n         # Snag the first object from the queryset; if it doesn't exist that\n         # means there's no next/previous link available.\n         try:\n             result = getattr(qs[0], date_field)\n         except IndexError:\n-            result = None\n-\n-    # Convert datetimes to a dates\n-    if result and generic_view.uses_datetime_field:\n-        if settings.USE_TZ:\n-            result = timezone.localtime(result)\n-        result = result.date()\n-\n-    if result:\n-        if period == 'month':\n-            # first day of the month\n-            result = result.replace(day=1)\n-        elif period == 'week':\n-            # monday of the week\n-            result = result - datetime.timedelta(days=generic_view._get_weekday(result))\n-        elif period != 'day':\n-            raise ValueError('invalid period: %s' % period)\n-\n-    # Check against future dates.\n-    if result and (allow_future or result < datetime.date.today()):\n-        return result\n+            return None\n+\n+        # Convert datetimes to dates in the current time zone.\n+        if generic_view.uses_datetime_field:\n+            if settings.USE_TZ:\n+                result = timezone.localtime(result)\n+            result = result.date()\n+\n+        # Return the first day of the period.\n+        return get_current(result)\n+\n+\n+def timezone_today():\n+    \"\"\"\n+    Return the current date in the current time zone.\n+    \"\"\"\n+    if settings.USE_TZ:\n+        return timezone.localtime(timezone.now()).date()\n     else:\n-        return None\n+        return datetime.date.today()"
        }
    ],
    "stats": {
        "total": 202,
        "additions": 139,
        "deletions": 63
    }
}