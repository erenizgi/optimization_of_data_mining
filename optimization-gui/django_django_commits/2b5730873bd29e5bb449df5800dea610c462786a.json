{
    "author": "ramiro",
    "message": "Added ability to describe grouping of form fields in the same row to the `fields` ModelAdmin attribute.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16225 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "2b5730873bd29e5bb449df5800dea610c462786a",
    "files": [
        {
            "sha": "b4f2b9d0dc94b81905c805fbabfc75a8b5d092a7",
            "filename": "django/contrib/admin/validation.py",
            "status": "modified",
            "additions": 36,
            "deletions": 41,
            "changes": 77,
            "blob_url": "https://github.com/django/django/blob/2b5730873bd29e5bb449df5800dea610c462786a/django%2Fcontrib%2Fadmin%2Fvalidation.py",
            "raw_url": "https://github.com/django/django/raw/2b5730873bd29e5bb449df5800dea610c462786a/django%2Fcontrib%2Fadmin%2Fvalidation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fadmin%2Fvalidation.py?ref=2b5730873bd29e5bb449df5800dea610c462786a",
            "patch": "@@ -222,6 +222,40 @@ def validate_inline(cls, parent, parent_model):\n     if hasattr(cls, \"readonly_fields\"):\n         check_readonly_fields(cls, cls.model, cls.model._meta)\n \n+def validate_fields_spec(cls, model, opts, flds, label):\n+    \"\"\"\n+    Validate the fields specification in `flds` from a ModelAdmin subclass\n+    `cls` for the `model` model. `opts` is `model`'s Meta inner class.\n+    Use `label` for reporting problems to the user.\n+\n+    The fields specification can be a ``fields`` option or a ``fields``\n+    sub-option from a ``fieldsets`` option component.\n+    \"\"\"\n+    for fields in flds:\n+        # The entry in fields might be a tuple. If it is a standalone\n+        # field, make it into a tuple to make processing easier.\n+        if type(fields) != tuple:\n+            fields = (fields,)\n+        for field in fields:\n+            if field in cls.readonly_fields:\n+                # Stuff can be put in fields that isn't actually a\n+                # model field if it's in readonly_fields,\n+                # readonly_fields will handle the validation of such\n+                # things.\n+                continue\n+            check_formfield(cls, model, opts, label, field)\n+            try:\n+                f = opts.get_field(field)\n+            except models.FieldDoesNotExist:\n+                # If we can't find a field on the model that matches,\n+                # it could be an extra field on the form.\n+                pass\n+            if isinstance(f, models.ManyToManyField) and not f.rel.through._meta.auto_created:\n+                raise ImproperlyConfigured(\"'%s.%s' \"\n+                    \"can't include the ManyToManyField field '%s' because \"\n+                    \"'%s' manually specifies a 'through' model.\" % (\n+                        cls.__name__, label, field, field))\n+\n def validate_base(cls, model):\n     opts = model._meta\n \n@@ -238,23 +272,7 @@ def validate_base(cls, model):\n     # fields\n     if cls.fields: # default value is None\n         check_isseq(cls, 'fields', cls.fields)\n-        for field in cls.fields:\n-            if field in cls.readonly_fields:\n-                # Stuff can be put in fields that isn't actually a model field\n-                # if it's in readonly_fields, readonly_fields will handle the\n-                # validation of such things.\n-                continue\n-            check_formfield(cls, model, opts, 'fields', field)\n-            try:\n-                f = opts.get_field(field)\n-            except models.FieldDoesNotExist:\n-                # If we can't find a field on the model that matches,\n-                # it could be an extra field on the form.\n-                continue\n-            if isinstance(f, models.ManyToManyField) and not f.rel.through._meta.auto_created:\n-                raise ImproperlyConfigured(\"'%s.fields' can't include the ManyToManyField \"\n-                    \"field '%s' because '%s' manually specifies \"\n-                    \"a 'through' model.\" % (cls.__name__, field, field))\n+        validate_fields_spec(cls, model, opts, cls.fields, 'fields')\n         if cls.fieldsets:\n             raise ImproperlyConfigured('Both fieldsets and fields are specified in %s.' % cls.__name__)\n         if len(cls.fields) > len(set(cls.fields)):\n@@ -273,30 +291,7 @@ def validate_base(cls, model):\n                 raise ImproperlyConfigured(\"'fields' key is required in \"\n                         \"%s.fieldsets[%d][1] field options dict.\"\n                         % (cls.__name__, idx))\n-            for fields in fieldset[1]['fields']:\n-                # The entry in fields might be a tuple. If it is a standalone\n-                # field, make it into a tuple to make processing easier.\n-                if type(fields) != tuple:\n-                    fields = (fields,)\n-                for field in fields:\n-                    if field in cls.readonly_fields:\n-                        # Stuff can be put in fields that isn't actually a\n-                        # model field if it's in readonly_fields,\n-                        # readonly_fields will handle the validation of such\n-                        # things.\n-                        continue\n-                    check_formfield(cls, model, opts, \"fieldsets[%d][1]['fields']\" % idx, field)\n-                    try:\n-                        f = opts.get_field(field)\n-                        if isinstance(f, models.ManyToManyField) and not f.rel.through._meta.auto_created:\n-                            raise ImproperlyConfigured(\"'%s.fieldsets[%d][1]['fields']' \"\n-                                \"can't include the ManyToManyField field '%s' because \"\n-                                \"'%s' manually specifies a 'through' model.\" % (\n-                                    cls.__name__, idx, field, field))\n-                    except models.FieldDoesNotExist:\n-                        # If we can't find a field on the model that matches,\n-                        # it could be an extra field on the form.\n-                        pass\n+            validate_fields_spec(cls, model, opts, fieldset[1]['fields'], \"fieldsets[%d][1]['fields']\" % idx)\n         flattened_fieldsets = flatten_fieldsets(cls.fieldsets)\n         if len(flattened_fieldsets) > len(set(flattened_fieldsets)):\n             raise ImproperlyConfigured('There are duplicate field(s) in %s.fieldsets' % cls.__name__)"
        },
        {
            "sha": "8c7a69ceaf5b6f523fdfd03bef4b9fc1c79a2fc6",
            "filename": "docs/ref/contrib/admin/index.txt",
            "status": "modified",
            "additions": 34,
            "deletions": 14,
            "changes": 48,
            "blob_url": "https://github.com/django/django/blob/2b5730873bd29e5bb449df5800dea610c462786a/docs%2Fref%2Fcontrib%2Fadmin%2Findex.txt",
            "raw_url": "https://github.com/django/django/raw/2b5730873bd29e5bb449df5800dea610c462786a/docs%2Fref%2Fcontrib%2Fadmin%2Findex.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fcontrib%2Fadmin%2Findex.txt?ref=2b5730873bd29e5bb449df5800dea610c462786a",
            "patch": "@@ -160,27 +160,45 @@ subclass::\n \n .. attribute:: ModelAdmin.fields\n \n-    Use this option as an alternative to ``fieldsets`` if the layout does not\n-    matter and if you want to only show a subset of the available fields in the\n-    form. For example, you could define a simpler version of the admin form for\n-    the ``django.contrib.flatpages.FlatPage`` model as follows::\n+    If you need to achieve simple changes in the layout of fields in the forms\n+    of the \"add\" and \"change\" pages like only showing a subset of the available\n+    fields, modifying their order or grouping them in rows you can use the\n+    ``fields`` option (for more complex layout needs see the\n+    :attr:`~ModelAdmin.fieldsets` option described in the next section). For\n+    example, you could define a simpler version of the admin form for the\n+    ``django.contrib.flatpages.FlatPage`` model as follows::\n \n         class FlatPageAdmin(admin.ModelAdmin):\n             fields = ('url', 'title', 'content')\n \n-    In the above example, only the fields 'url', 'title' and 'content' will be\n-    displayed, sequentially, in the form.\n+    In the above example, only the fields ``url``, ``title`` and ``content``\n+    will be displayed, sequentially, in the form.\n \n     .. versionadded:: 1.2\n \n     ``fields`` can contain values defined in :attr:`ModelAdmin.readonly_fields`\n     to be displayed as read-only.\n \n+    .. versionadded:: 1.4\n+\n+    To display multiple fields on the same line, wrap those fields in their own\n+    tuple. In this example, the ``url`` and ``title`` fields will display on the\n+    same line and the ``content`` field will be displayed below them in its\n+    own line::\n+\n+        class FlatPageAdmin(admin.ModelAdmin):\n+            fields = (('url', 'title'), 'content')\n+\n     .. admonition:: Note\n \n         This ``fields`` option should not be confused with the ``fields``\n-        dictionary key that is within the ``fieldsets`` option, as described in\n-        the previous section.\n+        dictionary key that is within the :attr:`~ModelAdmin.fieldsets` option,\n+        as described in the next section.\n+\n+    If neither ``fields`` nor :attr:`~ModelAdmin.fieldsets` options are present,\n+    Django will default to displaying each field that isn't an ``AutoField`` and\n+    has ``editable=True``, in a single fieldset, in the same order as the fields\n+    are defined in the model.\n \n .. attribute:: ModelAdmin.fieldsets\n \n@@ -213,9 +231,10 @@ subclass::\n \n         .. image:: _images/flatfiles_admin.png\n \n-    If ``fieldsets`` isn't given, Django will default to displaying each field\n-    that isn't an ``AutoField`` and has ``editable=True``, in a single\n-    fieldset, in the same order as the fields are defined in the model.\n+    If neither ``fieldsets`` nor :attr:`~ModelAdmin.fields` options are present,\n+    Django will default to displaying each field that isn't an ``AutoField`` and\n+    has ``editable=True``, in a single fieldset, in the same order as the fields\n+    are defined in the model.\n \n     The ``field_options`` dictionary can have the following keys:\n \n@@ -229,9 +248,10 @@ subclass::\n                 'fields': ('first_name', 'last_name', 'address', 'city', 'state'),\n                 }\n \n-            To display multiple fields on the same line, wrap those fields in\n-            their own tuple. In this example, the ``first_name`` and\n-            ``last_name`` fields will display on the same line::\n+            Just like with the :attr:`~ModelAdmin.fields` option, to display\n+            multiple fields on the same line, wrap those fields in their own\n+            tuple. In this example, the ``first_name`` and ``last_name`` fields\n+            will display on the same line::\n \n                 {\n                 'fields': (('first_name', 'last_name'), 'address', 'city', 'state'),"
        },
        {
            "sha": "a80820cb6750d44d2148eab75e881dd27a5013a4",
            "filename": "tests/regressiontests/admin_validation/tests.py",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/django/django/blob/2b5730873bd29e5bb449df5800dea610c462786a/tests%2Fregressiontests%2Fadmin_validation%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/2b5730873bd29e5bb449df5800dea610c462786a/tests%2Fregressiontests%2Fadmin_validation%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fadmin_validation%2Ftests.py?ref=2b5730873bd29e5bb449df5800dea610c462786a",
            "patch": "@@ -201,7 +201,7 @@ class BookAdmin(admin.ModelAdmin):\n             validate,\n             BookAdmin, Book)\n \n-    def test_cannon_include_through(self):\n+    def test_cannot_include_through(self):\n         class FieldsetBookAdmin(admin.ModelAdmin):\n             fieldsets = (\n                 ('Header 1', {'fields': ('name',)}),\n@@ -212,6 +212,11 @@ class FieldsetBookAdmin(admin.ModelAdmin):\n             validate,\n             FieldsetBookAdmin, Book)\n \n+    def test_nested_fields(self):\n+        class NestedFieldsAdmin(admin.ModelAdmin):\n+           fields = ('price', ('name', 'subtitle'))\n+        validate(NestedFieldsAdmin, Book)\n+\n     def test_nested_fieldsets(self):\n         class NestedFieldsetAdmin(admin.ModelAdmin):\n            fieldsets = ("
        }
    ],
    "stats": {
        "total": 132,
        "additions": 76,
        "deletions": 56
    }
}