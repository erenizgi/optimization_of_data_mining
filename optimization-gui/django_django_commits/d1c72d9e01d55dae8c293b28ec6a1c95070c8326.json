{
    "author": "aaugustin",
    "message": "Removed django.core.management.setup_environ and execute_manager.",
    "sha": "d1c72d9e01d55dae8c293b28ec6a1c95070c8326",
    "files": [
        {
            "sha": "7638937c94bf9b867baf05865d85487460dcbc91",
            "filename": "django/core/management/__init__.py",
            "status": "modified",
            "additions": 0,
            "deletions": 70,
            "changes": 70,
            "blob_url": "https://github.com/django/django/blob/d1c72d9e01d55dae8c293b28ec6a1c95070c8326/django%2Fcore%2Fmanagement%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/d1c72d9e01d55dae8c293b28ec6a1c95070c8326/django%2Fcore%2Fmanagement%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2F__init__.py?ref=d1c72d9e01d55dae8c293b28ec6a1c95070c8326",
            "patch": "@@ -391,79 +391,9 @@ def execute(self):\n         else:\n             self.fetch_command(subcommand).run_from_argv(self.argv)\n \n-def setup_environ(settings_mod, original_settings_path=None):\n-    \"\"\"\n-    Configures the runtime environment. This can also be used by external\n-    scripts wanting to set up a similar environment to manage.py.\n-    Returns the project directory (assuming the passed settings module is\n-    directly in the project directory).\n-\n-    The \"original_settings_path\" parameter is optional, but recommended, since\n-    trying to work out the original path from the module can be problematic.\n-    \"\"\"\n-    warnings.warn(\n-        \"The 'setup_environ' function is deprecated, \"\n-        \"you likely need to update your 'manage.py'; \"\n-        \"please see the Django 1.4 release notes \"\n-        \"(https://docs.djangoproject.com/en/dev/releases/1.4/).\",\n-        DeprecationWarning)\n-\n-    # Add this project to sys.path so that it's importable in the conventional\n-    # way. For example, if this file (manage.py) lives in a directory\n-    # \"myproject\", this code would add \"/path/to/myproject\" to sys.path.\n-    if '__init__.py' in upath(settings_mod.__file__):\n-        p = os.path.dirname(upath(settings_mod.__file__))\n-    else:\n-        p = upath(settings_mod.__file__)\n-    project_directory, settings_filename = os.path.split(p)\n-    if project_directory == os.curdir or not project_directory:\n-        project_directory = os.getcwd()\n-    project_name = os.path.basename(project_directory)\n-\n-    # Strip filename suffix to get the module name.\n-    settings_name = os.path.splitext(settings_filename)[0]\n-\n-    # Strip $py for Jython compiled files (like settings$py.class)\n-    if settings_name.endswith(\"$py\"):\n-        settings_name = settings_name[:-3]\n-\n-    # Set DJANGO_SETTINGS_MODULE appropriately.\n-    if original_settings_path:\n-        os.environ['DJANGO_SETTINGS_MODULE'] = original_settings_path\n-    else:\n-        # If DJANGO_SETTINGS_MODULE is already set, use it.\n-        os.environ['DJANGO_SETTINGS_MODULE'] = os.environ.get(\n-            'DJANGO_SETTINGS_MODULE',\n-            '%s.%s' % (project_name, settings_name)\n-        )\n-\n-    # Import the project module. We add the parent directory to PYTHONPATH to\n-    # avoid some of the path errors new users can have.\n-    sys.path.append(os.path.join(project_directory, os.pardir))\n-    import_module(project_name)\n-    sys.path.pop()\n-\n-    return project_directory\n-\n def execute_from_command_line(argv=None):\n     \"\"\"\n     A simple method that runs a ManagementUtility.\n     \"\"\"\n     utility = ManagementUtility(argv)\n     utility.execute()\n-\n-def execute_manager(settings_mod, argv=None):\n-    \"\"\"\n-    Like execute_from_command_line(), but for use by manage.py, a\n-    project-specific django-admin.py utility.\n-    \"\"\"\n-    warnings.warn(\n-        \"The 'execute_manager' function is deprecated, \"\n-        \"you likely need to update your 'manage.py'; \"\n-        \"please see the Django 1.4 release notes \"\n-        \"(https://docs.djangoproject.com/en/dev/releases/1.4/).\",\n-        DeprecationWarning)\n-\n-    setup_environ(settings_mod)\n-    utility = ManagementUtility(argv)\n-    utility.execute()"
        },
        {
            "sha": "97e43ff0eb1176ec971629a7c00547033ef86f11",
            "filename": "tests/regressiontests/settings_tests/tests.py",
            "status": "modified",
            "additions": 0,
            "deletions": 64,
            "changes": 64,
            "blob_url": "https://github.com/django/django/blob/d1c72d9e01d55dae8c293b28ec6a1c95070c8326/tests%2Fregressiontests%2Fsettings_tests%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/d1c72d9e01d55dae8c293b28ec6a1c95070c8326/tests%2Fregressiontests%2Fsettings_tests%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fsettings_tests%2Ftests.py?ref=d1c72d9e01d55dae8c293b28ec6a1c95070c8326",
            "patch": "@@ -287,67 +287,3 @@ def test_set_with_xheader_right(self):\n         req = HttpRequest()\n         req.META['HTTP_X_FORWARDED_PROTOCOL'] = 'https'\n         self.assertEqual(req.is_secure(), True)\n-\n-class EnvironmentVariableTest(TestCase):\n-    \"\"\"\n-    Ensures proper settings file is used in setup_environ if\n-    DJANGO_SETTINGS_MODULE is set in the environment.\n-    \"\"\"\n-    # Decide what to do with these tests when setup_environ() gets removed in Django 1.6\n-    def setUp(self):\n-        self.original_value = os.environ.get('DJANGO_SETTINGS_MODULE')\n-        self.save_warnings_state()\n-        warnings.filterwarnings('ignore', category=DeprecationWarning, module='django.core.management')\n-\n-    def tearDown(self):\n-        self.restore_warnings_state()\n-        if self.original_value:\n-            os.environ['DJANGO_SETTINGS_MODULE'] = self.original_value\n-        elif 'DJANGO_SETTINGS_MODULE' in os.environ:\n-            del(os.environ['DJANGO_SETTINGS_MODULE'])\n-\n-    def test_env_var_used(self):\n-        \"\"\"\n-        If the environment variable is set, do not ignore it. However, the\n-        kwarg original_settings_path takes precedence.\n-\n-        This tests both plus the default (neither set).\n-        \"\"\"\n-        from django.core.management import setup_environ\n-\n-        # whatever was already there\n-        original_module =  os.environ.get(\n-            'DJANGO_SETTINGS_MODULE',\n-            'the default'\n-        )\n-\n-        # environment variable set by user\n-        user_override = 'custom.settings'\n-\n-        # optional argument to setup_environ\n-        orig_path = 'original.path'\n-\n-        # expect default\n-        setup_environ(global_settings)\n-        self.assertEqual(\n-            os.environ.get('DJANGO_SETTINGS_MODULE'),\n-            original_module\n-        )\n-\n-        # override with environment variable\n-        os.environ['DJANGO_SETTINGS_MODULE'] = user_override\n-        setup_environ(global_settings)\n-\n-        self.assertEqual(\n-            os.environ.get('DJANGO_SETTINGS_MODULE'),\n-            user_override\n-        )\n-\n-        # pass in original_settings_path (should take precedence)\n-        os.environ['DJANGO_SETTINGS_MODULE'] = user_override\n-        setup_environ(global_settings, original_settings_path = orig_path)\n-\n-        self.assertEqual(\n-            os.environ.get('DJANGO_SETTINGS_MODULE'),\n-            orig_path\n-        )"
        }
    ],
    "stats": {
        "total": 134,
        "additions": 0,
        "deletions": 134
    }
}