{
    "author": "aaugustin",
    "message": "Implemented an 'atomic' decorator and context manager.\n\nCurrently it only works in autocommit mode.\n\nBased on @xact by Christophe Pettus.",
    "sha": "d7bc4fbc94df6c231d71dffa45cf337ff13512ee",
    "files": [
        {
            "sha": "3c1cd81639e8cc234bc49632e20ea099b75a3455",
            "filename": "AUTHORS",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/AUTHORS",
            "raw_url": "https://github.com/django/django/raw/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/AUTHORS",
            "contents_url": "https://api.github.com/repos/django/django/contents/AUTHORS?ref=d7bc4fbc94df6c231d71dffa45cf337ff13512ee",
            "patch": "@@ -434,6 +434,7 @@ answer newbie questions, and generally made Django that much better:\n     Andreas Pelme <andreas@pelme.se>\n     permonik@mesias.brnonet.cz\n     peter@mymart.com\n+    Christophe Pettus <xof@thebuild.com>\n     pgross@thoughtworks.com\n     phaedo <http://phaedo.cx/>\n     phil@produxion.net"
        },
        {
            "sha": "818850bf4309b549b304a44c324d8af52282235f",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 21,
            "deletions": 2,
            "changes": 23,
            "blob_url": "https://github.com/django/django/blob/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=d7bc4fbc94df6c231d71dffa45cf337ff13512ee",
            "patch": "@@ -50,6 +50,12 @@ def __init__(self, settings_dict, alias=DEFAULT_DB_ALIAS,\n         # set somewhat aggressively, as the DBAPI doesn't make it easy to\n         # deduce if the connection is in transaction or not.\n         self._dirty = False\n+        # Tracks if the connection is in a transaction managed by 'atomic'\n+        self.in_atomic_block = False\n+        # List of savepoints created by 'atomic'\n+        self.savepoint_ids = []\n+        # Hack to provide compatibility with legacy transaction management\n+        self._atomic_forced_unmanaged = False\n \n         # Connection termination related attributes\n         self.close_at = None\n@@ -148,15 +154,15 @@ def cursor(self):\n \n     def commit(self):\n         \"\"\"\n-        Does the commit itself and resets the dirty flag.\n+        Commits a transaction and resets the dirty flag.\n         \"\"\"\n         self.validate_thread_sharing()\n         self._commit()\n         self.set_clean()\n \n     def rollback(self):\n         \"\"\"\n-        Does the rollback itself and resets the dirty flag.\n+        Rolls back a transaction and resets the dirty flag.\n         \"\"\"\n         self.validate_thread_sharing()\n         self._rollback()\n@@ -447,6 +453,12 @@ def temporary_connection(self):\n             if must_close:\n                 self.close()\n \n+    def _start_transaction_under_autocommit(self):\n+        \"\"\"\n+        Only required when autocommits_when_autocommit_is_off = True.\n+        \"\"\"\n+        raise NotImplementedError\n+\n \n class BaseDatabaseFeatures(object):\n     allows_group_by_pk = False\n@@ -549,6 +561,10 @@ class BaseDatabaseFeatures(object):\n     # Support for the DISTINCT ON clause\n     can_distinct_on_fields = False\n \n+    # Does the backend decide to commit before SAVEPOINT statements\n+    # when autocommit is disabled? http://bugs.python.org/issue8145#msg109965\n+    autocommits_when_autocommit_is_off = False\n+\n     def __init__(self, connection):\n         self.connection = connection\n \n@@ -931,6 +947,9 @@ def start_transaction_sql(self):\n         return \"BEGIN;\"\n \n     def end_transaction_sql(self, success=True):\n+        \"\"\"\n+        Returns the SQL statement required to end a transaction.\n+        \"\"\"\n         if not success:\n             return \"ROLLBACK;\"\n         return \"COMMIT;\""
        },
        {
            "sha": "f70c3872a89eb986046522f1dedbedb36f6db349",
            "filename": "django/db/backends/sqlite3/base.py",
            "status": "modified",
            "additions": 15,
            "deletions": 4,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py?ref=d7bc4fbc94df6c231d71dffa45cf337ff13512ee",
            "patch": "@@ -99,6 +99,7 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     supports_mixed_date_datetime_comparisons = False\n     has_bulk_insert = True\n     can_combine_inserts_with_and_without_auto_increment_pk = False\n+    autocommits_when_autocommit_is_off = True\n \n     @cached_property\n     def uses_savepoints(self):\n@@ -360,10 +361,12 @@ def close(self):\n             BaseDatabaseWrapper.close(self)\n \n     def _savepoint_allowed(self):\n-        # When 'isolation_level' is None, Django doesn't provide a way to\n-        # create a transaction (yet) so savepoints can't be created. When it\n-        # isn't, sqlite3 commits before each savepoint -- it's a bug.\n-        return False\n+        # When 'isolation_level' is not None, sqlite3 commits before each\n+        # savepoint; it's a bug. When it is None, savepoints don't make sense\n+        # because autocommit is enabled. The only exception is inside atomic\n+        # blocks. To work around that bug, on SQLite, atomic starts a\n+        # transaction explicitly rather than simply disable autocommit.\n+        return self.in_atomic_block\n \n     def _set_autocommit(self, autocommit):\n         if autocommit:\n@@ -413,6 +416,14 @@ def check_constraints(self, table_names=None):\n     def is_usable(self):\n         return True\n \n+    def _start_transaction_under_autocommit(self):\n+        \"\"\"\n+        Start a transaction explicitly in autocommit mode.\n+\n+        Staying in autocommit mode works around a bug of sqlite3 that breaks\n+        savepoints when autocommit is disabled.\n+        \"\"\"\n+        self.cursor().execute(\"BEGIN\")\n \n FORMAT_QMARK_REGEX = re.compile(r'(?<!%)%s')\n "
        },
        {
            "sha": "8126c18a7010e92f3d6c28c0a2ec74c4327ae3ca",
            "filename": "django/db/transaction.py",
            "status": "modified",
            "additions": 150,
            "deletions": 7,
            "changes": 157,
            "blob_url": "https://github.com/django/django/blob/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/django%2Fdb%2Ftransaction.py",
            "raw_url": "https://github.com/django/django/raw/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/django%2Fdb%2Ftransaction.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Ftransaction.py?ref=d7bc4fbc94df6c231d71dffa45cf337ff13512ee",
            "patch": "@@ -16,7 +16,7 @@\n \n from functools import wraps\n \n-from django.db import connections, DEFAULT_DB_ALIAS\n+from django.db import connections, DatabaseError, DEFAULT_DB_ALIAS\n \n \n class TransactionManagementError(Exception):\n@@ -134,13 +134,13 @@ def rollback_unless_managed(using=None):\n \n def commit(using=None):\n     \"\"\"\n-    Does the commit itself and resets the dirty flag.\n+    Commits a transaction and resets the dirty flag.\n     \"\"\"\n     get_connection(using).commit()\n \n def rollback(using=None):\n     \"\"\"\n-    This function does the rollback itself and resets the dirty flag.\n+    Rolls back a transaction and resets the dirty flag.\n     \"\"\"\n     get_connection(using).rollback()\n \n@@ -166,9 +166,151 @@ def savepoint_commit(sid, using=None):\n     \"\"\"\n     get_connection(using).savepoint_commit(sid)\n \n-##############\n-# DECORATORS #\n-##############\n+\n+#################################\n+# Decorators / context managers #\n+#################################\n+\n+class Atomic(object):\n+    \"\"\"\n+    This class guarantees the atomic execution of a given block.\n+\n+    An instance can be used either as a decorator or as a context manager.\n+\n+    When it's used as a decorator, __call__ wraps the execution of the\n+    decorated function in the instance itself, used as a context manager.\n+\n+    When it's used as a context manager, __enter__ creates a transaction or a\n+    savepoint, depending on whether a transaction is already in progress, and\n+    __exit__ commits the transaction or releases the savepoint on normal exit,\n+    and rolls back the transaction or to the savepoint on exceptions.\n+\n+    A stack of savepoints identifiers is maintained as an attribute of the\n+    connection. None denotes a plain transaction.\n+\n+    This allows reentrancy even if the same AtomicWrapper is reused. For\n+    example, it's possible to define `oa = @atomic('other')` and use `@ao` or\n+    `with oa:` multiple times.\n+\n+    Since database connections are thread-local, this is thread-safe.\n+    \"\"\"\n+\n+    def __init__(self, using):\n+        self.using = using\n+\n+    def _legacy_enter_transaction_management(self, connection):\n+        if not connection.in_atomic_block:\n+            if connection.transaction_state and connection.transaction_state[-1]:\n+                connection._atomic_forced_unmanaged = True\n+                connection.enter_transaction_management(managed=False)\n+            else:\n+                connection._atomic_forced_unmanaged = False\n+\n+    def _legacy_leave_transaction_management(self, connection):\n+        if not connection.in_atomic_block and connection._atomic_forced_unmanaged:\n+            connection.leave_transaction_management()\n+\n+    def __enter__(self):\n+        connection = get_connection(self.using)\n+\n+        # Ensure we have a connection to the database before testing\n+        # autocommit status.\n+        connection.ensure_connection()\n+\n+        # Remove this when the legacy transaction management goes away.\n+        self._legacy_enter_transaction_management(connection)\n+\n+        if not connection.in_atomic_block and not connection.autocommit:\n+            raise TransactionManagementError(\n+                \"'atomic' cannot be used when autocommit is disabled.\")\n+\n+        if connection.in_atomic_block:\n+            # We're already in a transaction; create a savepoint.\n+            sid = connection.savepoint()\n+            connection.savepoint_ids.append(sid)\n+        else:\n+            # We aren't in a transaction yet; create one.\n+            # The usual way to start a transaction is to turn autocommit off.\n+            # However, some database adapters (namely sqlite3) don't handle\n+            # transactions and savepoints properly when autocommit is off.\n+            # In such cases, start an explicit transaction instead, which has\n+            # the side-effect of disabling autocommit.\n+            if connection.features.autocommits_when_autocommit_is_off:\n+                connection._start_transaction_under_autocommit()\n+                connection.autocommit = False\n+            else:\n+                connection.set_autocommit(False)\n+            connection.in_atomic_block = True\n+            connection.savepoint_ids.append(None)\n+\n+    def __exit__(self, exc_type, exc_value, traceback):\n+        connection = get_connection(self.using)\n+        sid = connection.savepoint_ids.pop()\n+        if exc_value is None:\n+            if sid is None:\n+                # Commit transaction\n+                connection.in_atomic_block = False\n+                try:\n+                    connection.commit()\n+                except DatabaseError:\n+                    connection.rollback()\n+                    # Remove this when the legacy transaction management goes away.\n+                    self._legacy_leave_transaction_management(connection)\n+                    raise\n+                finally:\n+                    if connection.features.autocommits_when_autocommit_is_off:\n+                        connection.autocommit = True\n+                    else:\n+                        connection.set_autocommit(True)\n+            else:\n+                # Release savepoint\n+                try:\n+                    connection.savepoint_commit(sid)\n+                except DatabaseError:\n+                    connection.savepoint_rollback(sid)\n+                    # Remove this when the legacy transaction management goes away.\n+                    self._legacy_leave_transaction_management(connection)\n+                    raise\n+        else:\n+            if sid is None:\n+                # Roll back transaction\n+                connection.in_atomic_block = False\n+                try:\n+                    connection.rollback()\n+                finally:\n+                    if connection.features.autocommits_when_autocommit_is_off:\n+                        connection.autocommit = True\n+                    else:\n+                        connection.set_autocommit(True)\n+            else:\n+                # Roll back to savepoint\n+                connection.savepoint_rollback(sid)\n+\n+        # Remove this when the legacy transaction management goes away.\n+        self._legacy_leave_transaction_management(connection)\n+\n+\n+    def __call__(self, func):\n+        @wraps(func)\n+        def inner(*args, **kwargs):\n+            with self:\n+                return func(*args, **kwargs)\n+        return inner\n+\n+\n+def atomic(using=None):\n+    # Bare decorator: @atomic -- although the first argument is called\n+    # `using`, it's actually the function being decorated.\n+    if callable(using):\n+        return Atomic(DEFAULT_DB_ALIAS)(using)\n+    # Decorator: @atomic(...) or context manager: with atomic(...): ...\n+    else:\n+        return Atomic(using)\n+\n+\n+############################################\n+# Deprecated decorators / context managers #\n+############################################\n \n class Transaction(object):\n     \"\"\"\n@@ -279,7 +421,8 @@ def commit_on_success_unless_managed(using=None):\n     \"\"\"\n     Transitory API to preserve backwards-compatibility while refactoring.\n     \"\"\"\n-    if get_autocommit(using):\n+    connection = get_connection(using)\n+    if connection.autocommit and not connection.in_atomic_block:\n         return commit_on_success(using)\n     else:\n         def entering(using):"
        },
        {
            "sha": "2a4cd306c6d6a17569120040478e6c3d89df30a2",
            "filename": "docs/topics/db/transactions.txt",
            "status": "modified",
            "additions": 89,
            "deletions": 8,
            "changes": 97,
            "blob_url": "https://github.com/django/django/blob/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "raw_url": "https://github.com/django/django/raw/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Ftransactions.txt?ref=d7bc4fbc94df6c231d71dffa45cf337ff13512ee",
            "patch": "@@ -1,13 +1,16 @@\n-==============================\n-Managing database transactions\n-==============================\n+=====================\n+Database transactions\n+=====================\n \n .. module:: django.db.transaction\n \n Django gives you a few ways to control how database transactions are managed.\n \n+Managing database transactions\n+==============================\n+\n Django's default transaction behavior\n-=====================================\n+-------------------------------------\n \n Django's default behavior is to run in autocommit mode. Each query is\n immediately committed to the database. :ref:`See below for details\n@@ -24,7 +27,7 @@ immediately committed to the database. :ref:`See below for details\n     behavior <transactions-changes-from-1.5>`.\n \n Tying transactions to HTTP requests\n-===================================\n+-----------------------------------\n \n The recommended way to handle transactions in Web requests is to tie them to\n the request and response phases via Django's ``TransactionMiddleware``.\n@@ -63,6 +66,85 @@ connection internally.\n     multiple databases and want transaction control over databases other than\n     \"default\", you will need to write your own transaction middleware.\n \n+Controlling transactions explicitly\n+-----------------------------------\n+\n+.. versionadded:: 1.6\n+\n+Django provides a single API to control database transactions.\n+\n+.. function:: atomic(using=None)\n+\n+    This function creates an atomic block for writes to the database.\n+    (Atomicity is the defining property of database transactions.)\n+\n+    When the block completes successfully, the changes are committed to the\n+    database. When it raises an exception, the changes are rolled back.\n+\n+    ``atomic`` can be nested. In this case, when an inner block completes\n+    successfully, its effects can still be rolled back if an exception is\n+    raised in the outer block at a later point.\n+\n+    ``atomic`` takes a ``using`` argument which should be the name of a\n+    database. If this argument isn't provided, Django uses the ``\"default\"``\n+    database.\n+\n+    ``atomic`` is usable both as a decorator::\n+\n+        from django.db import transaction\n+\n+        @transaction.atomic\n+        def viewfunc(request):\n+            # This code executes inside a transaction.\n+            do_stuff()\n+\n+    and as a context manager::\n+\n+        from django.db import transaction\n+\n+        def viewfunc(request):\n+            # This code executes in autocommit mode (Django's default).\n+            do_stuff()\n+\n+            with transaction.atomic():\n+                # This code executes inside a transaction.\n+                do_more_stuff()\n+\n+    Wrapping ``atomic`` in a try/except block allows for natural handling of\n+    integrity errors::\n+\n+        from django.db import IntegrityError, transaction\n+\n+        @transaction.atomic\n+        def viewfunc(request):\n+            do_stuff()\n+\n+            try:\n+                with transaction.atomic():\n+                    do_stuff_that_could_fail()\n+            except IntegrityError:\n+                handle_exception()\n+\n+            do_more_stuff()\n+\n+    In this example, even if ``do_stuff_that_could_fail()`` causes a database\n+    error by breaking an integrity constraint, you can execute queries in\n+    ``do_more_stuff()``, and the changes from ``do_stuff()`` are still there.\n+\n+    In order to guarantee atomicity, ``atomic`` disables some APIs. Attempting\n+    to commit, roll back, or change the autocommit state of the database\n+    connection within an ``atomic`` block will raise an exception.\n+\n+    ``atomic`` can only be used in autocommit mode. It will raise an exception\n+    if autocommit is turned off.\n+\n+    Under the hood, Django's transaction management code:\n+\n+    - opens a transaction when entering the outermost ``atomic`` block;\n+    - creates a savepoint when entering an inner ``atomic`` block;\n+    - releases or rolls back to the savepoint when exiting an inner block;\n+    - commits or rolls back the transaction when exiting the outermost block.\n+\n .. _transaction-management-functions:\n \n Controlling transaction management in views\n@@ -325,9 +407,8 @@ When autocommit is enabled, savepoints don't make sense. When it's disabled,\n commits before any statement other than ``SELECT``, ``INSERT``, ``UPDATE``,\n ``DELETE`` and ``REPLACE``.)\n \n-As a consequence, savepoints are only usable if you start a transaction\n-manually while in autocommit mode, and Django doesn't provide an API to\n-achieve that.\n+As a consequence, savepoints are only usable inside a transaction ie. inside\n+an :func:`atomic` block.\n \n Transactions in MySQL\n ---------------------"
        },
        {
            "sha": "6c2bcfd23f3f5e892a85dfe8114a0fc6cd3f22a0",
            "filename": "tests/transactions/models.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/tests%2Ftransactions%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/tests%2Ftransactions%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions%2Fmodels.py?ref=d7bc4fbc94df6c231d71dffa45cf337ff13512ee",
            "patch": "@@ -22,4 +22,4 @@ class Meta:\n         ordering = ('first_name', 'last_name')\n \n     def __str__(self):\n-        return \"%s %s\" % (self.first_name, self.last_name)\n+        return (\"%s %s\" % (self.first_name, self.last_name)).strip()"
        },
        {
            "sha": "14252dd6dc3cf6491ada6dd2a9a143278fb59ef2",
            "filename": "tests/transactions/tests.py",
            "status": "modified",
            "additions": 153,
            "deletions": 1,
            "changes": 154,
            "blob_url": "https://github.com/django/django/blob/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/tests%2Ftransactions%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/d7bc4fbc94df6c231d71dffa45cf337ff13512ee/tests%2Ftransactions%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions%2Ftests.py?ref=d7bc4fbc94df6c231d71dffa45cf337ff13512ee",
            "patch": "@@ -1,11 +1,163 @@\n from __future__ import absolute_import\n \n+import sys\n+\n from django.db import connection, transaction, IntegrityError\n-from django.test import TransactionTestCase, skipUnlessDBFeature\n+from django.test import TestCase, TransactionTestCase, skipUnlessDBFeature\n+from django.utils import six\n+from django.utils.unittest import skipUnless\n \n from .models import Reporter\n \n \n+@skipUnless(connection.features.uses_savepoints,\n+        \"'atomic' requires transactions and savepoints.\")\n+class AtomicTests(TransactionTestCase):\n+    \"\"\"\n+    Tests for the atomic decorator and context manager.\n+\n+    The tests make assertions on internal attributes because there isn't a\n+    robust way to ask the database for its current transaction state.\n+\n+    Since the decorator syntax is converted into a context manager (see the\n+    implementation), there are only a few basic tests with the decorator\n+    syntax and the bulk of the tests use the context manager syntax.\n+    \"\"\"\n+\n+    def test_decorator_syntax_commit(self):\n+        @transaction.atomic\n+        def make_reporter():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+        make_reporter()\n+        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])\n+\n+    def test_decorator_syntax_rollback(self):\n+        @transaction.atomic\n+        def make_reporter():\n+            Reporter.objects.create(first_name=\"Haddock\")\n+            raise Exception(\"Oops, that's his last name\")\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            make_reporter()\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_alternate_decorator_syntax_commit(self):\n+        @transaction.atomic()\n+        def make_reporter():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+        make_reporter()\n+        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])\n+\n+    def test_alternate_decorator_syntax_rollback(self):\n+        @transaction.atomic()\n+        def make_reporter():\n+            Reporter.objects.create(first_name=\"Haddock\")\n+            raise Exception(\"Oops, that's his last name\")\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            make_reporter()\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_commit(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])\n+\n+    def test_rollback(self):\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with transaction.atomic():\n+                Reporter.objects.create(first_name=\"Haddock\")\n+                raise Exception(\"Oops, that's his last name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_nested_commit_commit(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with transaction.atomic():\n+                Reporter.objects.create(first_name=\"Archibald\", last_name=\"Haddock\")\n+        self.assertQuerysetEqual(Reporter.objects.all(),\n+                ['<Reporter: Archibald Haddock>', '<Reporter: Tintin>'])\n+\n+    def test_nested_commit_rollback(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                with transaction.atomic():\n+                    Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])\n+\n+    def test_nested_rollback_commit(self):\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with transaction.atomic():\n+                Reporter.objects.create(last_name=\"Tintin\")\n+                with transaction.atomic():\n+                    Reporter.objects.create(last_name=\"Haddock\")\n+                raise Exception(\"Oops, that's his first name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_nested_rollback_rollback(self):\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with transaction.atomic():\n+                Reporter.objects.create(last_name=\"Tintin\")\n+                with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                    with transaction.atomic():\n+                        Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+                raise Exception(\"Oops, that's his first name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_reuse_commit_commit(self):\n+        atomic = transaction.atomic()\n+        with atomic:\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with atomic:\n+                Reporter.objects.create(first_name=\"Archibald\", last_name=\"Haddock\")\n+        self.assertQuerysetEqual(Reporter.objects.all(),\n+                ['<Reporter: Archibald Haddock>', '<Reporter: Tintin>'])\n+\n+    def test_reuse_commit_rollback(self):\n+        atomic = transaction.atomic()\n+        with atomic:\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                with atomic:\n+                    Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])\n+\n+    def test_reuse_rollback_commit(self):\n+        atomic = transaction.atomic()\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with atomic:\n+                Reporter.objects.create(last_name=\"Tintin\")\n+                with atomic:\n+                    Reporter.objects.create(last_name=\"Haddock\")\n+                raise Exception(\"Oops, that's his first name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_reuse_rollback_rollback(self):\n+        atomic = transaction.atomic()\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with atomic:\n+                Reporter.objects.create(last_name=\"Tintin\")\n+                with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                    with atomic:\n+                        Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+                raise Exception(\"Oops, that's his first name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+\n+class AtomicInsideTransactionTests(AtomicTests):\n+    \"\"\"All basic tests for atomic should also pass within an existing transaction.\"\"\"\n+\n+    def setUp(self):\n+        self.atomic = transaction.atomic()\n+        self.atomic.__enter__()\n+\n+    def tearDown(self):\n+        self.atomic.__exit__(*sys.exc_info())\n+\n+\n class TransactionTests(TransactionTestCase):\n     def create_a_reporter_then_fail(self, first, last):\n         a = Reporter(first_name=first, last_name=last)"
        }
    ],
    "stats": {
        "total": 453,
        "additions": 430,
        "deletions": 23
    }
}