{
    "author": "timgraham",
    "message": "Fixed #13997 - Added an example of constructing a MultiWidget and documented the value_from_datadict method.",
    "sha": "04775b4598d1a9c5bcc0c1da431e368f28dcd13e",
    "files": [
        {
            "sha": "a0ef0731add55f0844af3d6a47c2c091e056d1ef",
            "filename": "docs/ref/forms/widgets.txt",
            "status": "modified",
            "additions": 129,
            "deletions": 63,
            "changes": 192,
            "blob_url": "https://github.com/django/django/blob/04775b4598d1a9c5bcc0c1da431e368f28dcd13e/docs%2Fref%2Fforms%2Fwidgets.txt",
            "raw_url": "https://github.com/django/django/raw/04775b4598d1a9c5bcc0c1da431e368f28dcd13e/docs%2Fref%2Fforms%2Fwidgets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fforms%2Fwidgets.txt?ref=04775b4598d1a9c5bcc0c1da431e368f28dcd13e",
            "patch": "@@ -214,38 +214,49 @@ foundation for custom widgets.\n         The 'value' given is not guaranteed to be valid input, therefore\n         subclass implementations should program defensively.\n \n+    .. method:: value_from_datadict(self, data, files, name)\n+\n+        Given a dictionary of data and this widget's name, returns the value\n+        of this widget. Returns ``None`` if a value wasn't provided.\n+\n .. class:: MultiWidget(widgets, attrs=None)\n \n     A widget that is composed of multiple widgets.\n     :class:`~django.forms.widgets.MultiWidget` works hand in hand with the\n     :class:`~django.forms.MultiValueField`.\n \n-    .. method:: render(name, value, attrs=None)\n+    :class:`MultiWidget` has one required argument:\n \n-        Argument `value` is handled differently in this method from the\n-        subclasses of :class:`~Widget`.\n+    .. attribute:: MultiWidget.widgets\n \n-        If `value` is a list, output of :meth:`~MultiWidget.render` will be a\n-        concatenation of rendered child widgets. If `value` is not a list, it\n-        will be first processed by the method :meth:`~MultiWidget.decompress()`\n-        to create the list and then processed as above.\n+        An iterable containing the widgets needed.\n \n-        Unlike in the single value widgets, method :meth:`~MultiWidget.render`\n-        need not be implemented in the subclasses.\n+    And one required method:\n \n     .. method:: decompress(value)\n \n-        Returns a list of \"decompressed\" values for the given value of the\n-        multi-value field that makes use of the widget. The input value can be\n-        assumed as valid, but not necessarily non-empty.\n+        This method takes a single \"compressed\" value from the field and\n+        returns a list of \"decompressed\" values. The input value can be\n+        assumed valid, but not necessarily non-empty.\n \n         This method **must be implemented** by the subclass, and since the\n         value may be empty, the implementation must be defensive.\n \n         The rationale behind \"decompression\" is that it is necessary to \"split\"\n-        the combined value of the form field into the values of the individual\n-        field encapsulated within the multi-value field (e.g. when displaying\n-        the partially or fully filled-out form).\n+        the combined value of the form field into the values for each widget.\n+\n+        An example of this is how :class:`SplitDateTimeWidget` turns a\n+        :class:`datetime` value into a list with date and time split into two\n+        separate values::\n+\n+            class SplitDateTimeWidget(MultiWidget):\n+\n+                # ...\n+\n+                def decompress(self, value):\n+                    if value:\n+                        return [value.date(), value.time().replace(microsecond=0)]\n+                    return [None, None]\n \n         .. tip::\n \n@@ -254,6 +265,109 @@ foundation for custom widgets.\n             with the opposite responsibility - to combine cleaned values of\n             all member fields into one.\n \n+    Other methods that may be useful to override include:\n+\n+    .. method:: render(name, value, attrs=None)\n+\n+        Argument ``value`` is handled differently in this method from the\n+        subclasses of :class:`~Widget` because it has to figure out how to\n+        split a single value for display in multiple widgets.\n+\n+        The ``value`` argument used when rendering can be one of two things:\n+\n+        * A ``list``.\n+        * A single value (e.g., a string) that is the \"compressed\" representation\n+          of a ``list`` of values.\n+\n+        If `value` is a list, output of :meth:`~MultiWidget.render` will be a\n+        concatenation of rendered child widgets. If `value` is not a list, it\n+        will be first processed by the method :meth:`~MultiWidget.decompress()`\n+        to create the list and then processed as above.\n+\n+        In the second case -- i.e., if the value is *not* a list --\n+        ``render()`` will first decompress the value into a ``list`` before\n+        rendering it. It does so by calling the ``decompress()`` method, which\n+        :class:`MultiWidget`'s subclasses must implement (see above).\n+\n+        When ``render()`` executes its HTML rendering, each value in the list\n+        is rendered with the corresponding widget -- the first value is\n+        rendered in the first widget, the second value is rendered in the\n+        second widget, etc.\n+\n+        Unlike in the single value widgets, method :meth:`~MultiWidget.render`\n+        need not be implemented in the subclasses.\n+\n+    .. method:: format_output(rendered_widgets)\n+\n+        Given a list of rendered widgets (as strings), returns a Unicode string\n+        representing the HTML for the whole lot.\n+\n+        This hook allows you to format the HTML design of the widgets any way\n+        you'd like.\n+\n+    Here's an example widget which subclasses :class:`MultiWidget` to display\n+    a date with the day, month, and year in different select boxes. This widget\n+    is intended to be used with a :class:`~django.forms.DateField` rather than\n+    a :class:`~django.forms.MultiValueField`, thus we have implemented\n+    :meth:`~Widget.value_from_datadict`::\n+\n+        from datetime import date\n+        from django.forms import widgets\n+\n+        class DateSelectorWidget(widgets.MultiWidget):\n+            def __init__(self, attrs=None):\n+                # create choices for days, months, years\n+                # example below, the rest snipped for brevity.\n+                years = [(year, year) for year in (2011, 2012, 2013)]\n+                _widgets = (\n+                    widgets.Select(attrs=attrs, choices=days),\n+                    widgets.Select(attrs=attrs, choices=months),\n+                    widgets.Select(attrs=attrs, choices=years),\n+                )\n+                super(DateSelectorWidget, self).__init__(_widgets, attrs)\n+\n+            def decompress(self, value):\n+                if value:\n+                    return [value.day, value.month, value.year]\n+                return [None, None, None]\n+\n+            def format_output(self, rendered_widgets):\n+                return u''.join(rendered_widgets)\n+\n+            def value_from_datadict(self, data, files, name):\n+                datelist = [\n+                    widget.value_from_datadict(data, files, name + '_%s' % i)\n+                    for i, widget in enumerate(self.widgets)]\n+                try:\n+                    D = date(day=int(datelist[0]), month=int(datelist[1]),\n+                            year=int(datelist[2]))\n+                except ValueError:\n+                    return ''\n+                else:\n+                    return str(D)\n+\n+    The constructor creates several :class:`Select` widgets in a tuple. The\n+    ``super`` class uses this tuple to setup the widget.\n+\n+    The :meth:`~MultiWidget.format_output` method is fairly vanilla here (in\n+    fact, it's the same as what's been implemented as the default for\n+    ``MultiWidget``), but the idea is that you could add custom HTML between\n+    the widgets should you wish.\n+\n+    The required method :meth:`~MultiWidget.decompress` breaks up a\n+    ``datetime.date`` value into the day, month, and year values corresponding\n+    to each widget. Note how the method handles the case where ``value`` is\n+    ``None``.\n+\n+    The default implementation of :meth:`~Widget.value_from_datadict` returns\n+    a list of values corresponding to each ``Widget``.  This is appropriate\n+    when using a ``MultiWidget`` with a :class:`~django.forms.MultiValueField`,\n+    but since we want to use this widget with a :class:`~django.forms.DateField`\n+    which takes a single value, we have overridden this method to combine the\n+    data of all the subwidgets into a ``datetime.date``. The method extracts\n+    data from the ``POST`` dictionary and constructs and validates the date.\n+    If it is valid, we return the string, otherwise, we return an empty string\n+    which will cause ``form.is_valid`` to return ``False``.\n \n .. _built-in widgets:\n \n@@ -552,54 +666,6 @@ Composite widgets\n         :attr:`~Field.choices` attribute. If it does, it will override anything\n         you set here when the attribute is updated on the :class:`Field`.\n \n-``MultiWidget``\n-~~~~~~~~~~~~~~~\n-\n-.. class:: MultiWidget\n-\n-    Wrapper around multiple other widgets. You'll probably want to use this\n-    class with :class:`MultiValueField`.\n-\n-    Its ``render()`` method is different than other widgets', because it has to\n-    figure out how to split a single value for display in multiple widgets.\n-\n-    Subclasses may implement ``format_output``, which takes the list of\n-    rendered widgets and returns a string of HTML that formats them any way\n-    you'd like.\n-\n-    The ``value`` argument used when rendering can be one of two things:\n-\n-    * A ``list``.\n-    * A single value (e.g., a string) that is the \"compressed\" representation\n-      of a ``list`` of values.\n-\n-    In the second case -- i.e., if the value is *not* a list -- ``render()``\n-    will first decompress the value into a ``list`` before rendering it. It\n-    does so by calling the ``decompress()`` method, which\n-    :class:`MultiWidget`'s subclasses must implement. This method takes a\n-    single \"compressed\" value and returns a ``list``. An example of this is how\n-    :class:`SplitDateTimeWidget` turns a :class:`datetime` value into a list\n-    with date and time split into two seperate values::\n-\n-        class SplitDateTimeWidget(MultiWidget):\n-\n-            # ...\n-\n-            def decompress(self, value):\n-                if value:\n-                    return [value.date(), value.time().replace(microsecond=0)]\n-                return [None, None]\n-\n-    When ``render()`` executes its HTML rendering, each value in the list is\n-    rendered with the corresponding widget -- the first value is rendered in\n-    the first widget, the second value is rendered in the second widget, etc.\n-\n-    :class:`MultiWidget` has one required argument:\n-\n-    .. attribute:: MultiWidget.widgets\n-\n-        An iterable containing the widgets needed.\n-\n ``SplitDateTimeWidget``\n ~~~~~~~~~~~~~~~~~~~~~~~\n "
        }
    ],
    "stats": {
        "total": 192,
        "additions": 129,
        "deletions": 63
    }
}