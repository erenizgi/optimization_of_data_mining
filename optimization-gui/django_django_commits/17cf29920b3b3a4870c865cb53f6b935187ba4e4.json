{
    "author": "aaugustin",
    "message": "Added an explanation of transactions and grouped low-level APIs.",
    "sha": "17cf29920b3b3a4870c865cb53f6b935187ba4e4",
    "files": [
        {
            "sha": "4cecf896a4029d1a1ef425b193a1a7be364c32f0",
            "filename": "docs/topics/db/transactions.txt",
            "status": "modified",
            "additions": 122,
            "deletions": 80,
            "changes": 202,
            "blob_url": "https://github.com/django/django/blob/17cf29920b3b3a4870c865cb53f6b935187ba4e4/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "raw_url": "https://github.com/django/django/raw/17cf29920b3b3a4870c865cb53f6b935187ba4e4/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Ftransactions.txt?ref=17cf29920b3b3a4870c865cb53f6b935187ba4e4",
            "patch": "@@ -164,10 +164,131 @@ Django provides a single API to control database transactions.\n     - releases or rolls back to the savepoint when exiting an inner block;\n     - commits or rolls back the transaction when exiting the outermost block.\n \n+Autocommit\n+==========\n+\n+.. _autocommit-details:\n+\n+Why Django uses autocommit\n+--------------------------\n+\n+In the SQL standards, each SQL query starts a transaction, unless one is\n+already in progress. Such transactions must then be committed or rolled back.\n+\n+This isn't always convenient for application developers. To alleviate this\n+problem, most databases provide an autocommit mode. When autocommit is turned\n+on, each SQL query is wrapped in its own transaction. In other words, the\n+transaction is not only automatically started, but also automatically\n+committed.\n+\n+:pep:`249`, the Python Database API Specification v2.0, requires autocommit to\n+be initially turned off. Django overrides this default and turns autocommit\n+on.\n+\n+To avoid this, you can :ref:`deactivate the transaction management\n+<deactivate-transaction-management>`, but it isn't recommended.\n+\n+.. versionchanged:: 1.6\n+    Before Django 1.6, autocommit was turned off, and it was emulated by\n+    forcing a commit after write operations in the ORM.\n+\n+.. warning::\n+\n+    If you're using the database API directly — for instance, you're running\n+    SQL queries with ``cursor.execute()`` — be aware that autocommit is on,\n+    and consider wrapping your operations in a transaction, with\n+    :func:`atomic`, to ensure consistency.\n+\n+.. _deactivate-transaction-management:\n+\n+Deactivating transaction management\n+-----------------------------------\n+\n+You can totally disable Django's transaction management for a given database\n+by setting :setting:`AUTOCOMMIT <DATABASE-AUTOCOMMIT>` to ``False`` in its\n+configuration. If you do this, Django won't enable autocommit, and won't\n+perform any commits. You'll get the regular behavior of the underlying\n+database library.\n+\n+This requires you to commit explicitly every transaction, even those started\n+by Django or by third-party libraries. Thus, this is best used in situations\n+where you want to run your own transaction-controlling middleware or do\n+something really strange.\n+\n+.. versionchanged:: 1.6\n+    This used to be controlled by the ``TRANSACTIONS_MANAGED`` setting.\n+\n+Low-level APIs\n+==============\n+\n+.. warning::\n+\n+    Always prefer :func:`atomic` if possible at all. It accounts for the\n+    idiosyncrasies of each database and prevents invalid operations.\n+\n+    The low level APIs are only useful if you're implementing your own\n+    transaction management.\n+\n+.. _managing-autocommit:\n+\n+Autocommit\n+----------\n+\n+.. versionadded:: 1.6\n+\n+Django provides a straightforward API to manage the autocommit state of each\n+database connection, if you need to.\n+\n+.. function:: get_autocommit(using=None)\n+\n+.. function:: set_autocommit(using=None, autocommit=True)\n+\n+These functions take a ``using`` argument which should be the name of a\n+database. If it isn't provided, Django uses the ``\"default\"`` database.\n+\n+Autocommit is initially turned on. If you turn it off, it's your\n+responsibility to restore it.\n+\n+Once you turn autocommit off, you get the default behavior of your database\n+adapter, and Django won't help you. Although that behavior is specified in\n+:pep:`249`, implementations of adapters aren't always consistent with one\n+another. Review the documentation of the adapter you're using carefully.\n+\n+You must ensure that no transaction is active, usually by issuing a\n+:func:`commit` or a :func:`rollback`, before turning autocommit back on.\n+\n+:func:`atomic` requires autocommit to be turned on; it will raise an exception\n+if autocommit is off. Django will also refuse to turn autocommit off when an\n+:func:`atomic` block is active, because that would break atomicity.\n+\n+Transactions\n+------------\n+\n+A transaction is an atomic set of database queries. Even if your program\n+crashes, the database guarantees that either all the changes will be applied,\n+or none of them.\n+\n+Django doesn't provide an API to start a transaction. The expected way to\n+start a transaction is to disable autocommit with :func:`set_autocommit`.\n+\n+Once you're in a transaction, you can choose either to apply the changes\n+you've performed until this point with :func:`commit`, or to cancel them with\n+:func:`rollback`.\n+\n+.. function:: commit(using=None)\n+\n+.. function:: rollback(using=None)\n+\n+These functions take a ``using`` argument which should be the name of a\n+database. If it isn't provided, Django uses the ``\"default\"`` database.\n+\n+Django will refuse to commit or to rollback when an :func:`atomic` block is\n+active, because that would break atomicity.\n+\n .. _topics-db-transactions-savepoints:\n \n Savepoints\n-==========\n+----------\n \n A savepoint is a marker within a transaction that enables you to roll back\n part of a transaction, rather than the full transaction. Savepoints are\n@@ -243,85 +364,6 @@ The following example demonstrates the use of savepoints::\n           transaction.savepoint_rollback(sid)\n           # open transaction now contains only a.save()\n \n-Autocommit\n-==========\n-\n-.. _autocommit-details:\n-\n-Why Django uses autocommit\n---------------------------\n-\n-In the SQL standards, each SQL query starts a transaction, unless one is\n-already in progress. Such transactions must then be committed or rolled back.\n-\n-This isn't always convenient for application developers. To alleviate this\n-problem, most databases provide an autocommit mode. When autocommit is turned\n-on, each SQL query is wrapped in its own transaction. In other words, the\n-transaction is not only automatically started, but also automatically\n-committed.\n-\n-:pep:`249`, the Python Database API Specification v2.0, requires autocommit to\n-be initially turned off. Django overrides this default and turns autocommit\n-on.\n-\n-To avoid this, you can :ref:`deactivate the transaction management\n-<deactivate-transaction-management>`, but it isn't recommended.\n-\n-.. versionchanged:: 1.6\n-    Before Django 1.6, autocommit was turned off, and it was emulated by\n-    forcing a commit after write operations in the ORM.\n-\n-.. warning::\n-\n-    If you're using the database API directly — for instance, you're running\n-    SQL queries with ``cursor.execute()`` — be aware that autocommit is on,\n-    and consider wrapping your operations in a transaction, with\n-    :func:`atomic`, to ensure consistency.\n-\n-.. _managing-autocommit:\n-\n-Managing autocommit\n--------------------\n-\n-.. versionadded:: 1.6\n-\n-Django provides a straightforward API to manage the autocommit state of each\n-database connection, if you need to.\n-\n-.. function:: get_autocommit(using=None)\n-\n-.. function:: set_autocommit(using=None, autocommit=True)\n-\n-These functions take a ``using`` argument which should be the name of a\n-database. If it isn't provided, Django uses the ``\"default\"`` database.\n-\n-Autocommit is initially turned on. If you turn it off, it's your\n-responsibility to restore it.\n-\n-:func:`atomic` requires autocommit to be turned on; it will raise an exception\n-if autocommit is off. Django will also refuse to turn autocommit off when an\n-:func:`atomic` block is active, because that would break atomicity.\n-\n-.. _deactivate-transaction-management:\n-\n-Deactivating transaction management\n------------------------------------\n-\n-You can totally disable Django's transaction management for a given database\n-by setting :setting:`AUTOCOMMIT <DATABASE-AUTOCOMMIT>` to ``False`` in its\n-configuration. If you do this, Django won't enable autocommit, and won't\n-perform any commits. You'll get the regular behavior of the underlying\n-database library.\n-\n-This requires you to commit explicitly every transaction, even those started\n-by Django or by third-party libraries. Thus, this is best used in situations\n-where you want to run your own transaction-controlling middleware or do\n-something really strange.\n-\n-.. versionchanged:: 1.6\n-    This used to be controlled by the ``TRANSACTIONS_MANAGED`` setting.\n-\n-\n Database-specific notes\n =======================\n "
        }
    ],
    "stats": {
        "total": 202,
        "additions": 122,
        "deletions": 80
    }
}