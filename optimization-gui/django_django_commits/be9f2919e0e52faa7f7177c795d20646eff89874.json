{
    "author": "aaugustin",
    "message": "Edited the middleware doc for completeness, clarity, and consistency.",
    "sha": "be9f2919e0e52faa7f7177c795d20646eff89874",
    "files": [
        {
            "sha": "0caf6b29fa0912ad8aec9625ef1366ec547fe11b",
            "filename": "django/core/handlers/base.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/be9f2919e0e52faa7f7177c795d20646eff89874/django%2Fcore%2Fhandlers%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/be9f2919e0e52faa7f7177c795d20646eff89874/django%2Fcore%2Fhandlers%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fhandlers%2Fbase.py?ref=be9f2919e0e52faa7f7177c795d20646eff89874",
            "patch": "@@ -134,7 +134,7 @@ def get_response(self, request):\n                     raise ValueError(\"The view %s.%s didn't return an HttpResponse object.\" % (callback.__module__, view_name))\n \n                 # If the response supports deferred rendering, apply template\n-                # response middleware and the render the response\n+                # response middleware and then render the response\n                 if hasattr(response, 'render') and callable(response.render):\n                     for middleware_method in self._template_response_middleware:\n                         response = middleware_method(request, response)"
        },
        {
            "sha": "0c6858e2cf7df149010da625e262c6b89d5aee5c",
            "filename": "docs/topics/http/middleware.txt",
            "status": "modified",
            "additions": 112,
            "deletions": 68,
            "changes": 180,
            "blob_url": "https://github.com/django/django/blob/be9f2919e0e52faa7f7177c795d20646eff89874/docs%2Ftopics%2Fhttp%2Fmiddleware.txt",
            "raw_url": "https://github.com/django/django/raw/be9f2919e0e52faa7f7177c795d20646eff89874/docs%2Ftopics%2Fhttp%2Fmiddleware.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fhttp%2Fmiddleware.txt?ref=be9f2919e0e52faa7f7177c795d20646eff89874",
            "patch": "@@ -4,25 +4,28 @@ Middleware\n \n Middleware is a framework of hooks into Django's request/response processing.\n It's a light, low-level \"plugin\" system for globally altering Django's input\n-and/or output.\n+or output.\n \n Each middleware component is responsible for doing some specific function. For\n-example, Django includes a middleware component, ``XViewMiddleware``, that adds\n-an ``\"X-View\"`` HTTP header to every response to a ``HEAD`` request.\n+example, Django includes a middleware component,\n+:class:`~django.middleware.transaction.TransactionMiddleware`, that wraps the\n+processing of each HTTP request in a database transaction.\n \n This document explains how middleware works, how you activate middleware, and\n how to write your own middleware. Django ships with some built-in middleware\n-you can use right out of the box; they're documented in the :doc:`built-in\n+you can use right out of the box. They're documented in the :doc:`built-in\n middleware reference </ref/middleware>`.\n \n Activating middleware\n =====================\n \n-To activate a middleware component, add it to the :setting:`MIDDLEWARE_CLASSES`\n-list in your Django settings. In :setting:`MIDDLEWARE_CLASSES`, each middleware\n-component is represented by a string: the full Python path to the middleware's\n-class name. For example, here's the default :setting:`MIDDLEWARE_CLASSES`\n-created by :djadmin:`django-admin.py startproject <startproject>`::\n+To activate a middleware component, add it to the\n+:setting:`MIDDLEWARE_CLASSES` tuple in your Django settings.\n+\n+In :setting:`MIDDLEWARE_CLASSES`, each middleware component is represented by\n+a string: the full Python path to the middleware's class name. For example,\n+here's the default value created by :djadmin:`django-admin.py startproject\n+<startproject>`::\n \n     MIDDLEWARE_CLASSES = (\n         'django.middleware.common.CommonMiddleware',\n@@ -32,12 +35,33 @@ created by :djadmin:`django-admin.py startproject <startproject>`::\n         'django.contrib.messages.middleware.MessageMiddleware',\n     )\n \n-During the request phases (:meth:`process_request` and :meth:`process_view`),\n-Django applies middleware in the order it's defined in\n-:setting:`MIDDLEWARE_CLASSES`, top-down. During the response phases\n-(:meth:`process_template_response`, :meth:`process_response`, and\n-:meth:`process_exception`), the classes are applied in reverse order, from the\n-bottom up.\n+A Django installation doesn't require any middleware —\n+:setting:`MIDDLEWARE_CLASSES` can be empty, if you'd like — but it's strongly\n+suggested that you at least use\n+:class:`~django.middleware.common.CommonMiddleware`.\n+\n+The order in :setting:`MIDDLEWARE_CLASSES` matters because a middleware can\n+depend on other middleware. For instance,\n+:class:`~django.contrib.auth.middleware.AuthenticationMiddleware` stores the\n+authenticated user in the session; therefore, it must run after\n+:class:`~django.contrib.sessions.middleware.SessionMiddleware`.\n+\n+Hooks and application order\n+===========================\n+\n+During the request phase, before calling the view, Django applies middleware\n+in the order it's defined in :setting:`MIDDLEWARE_CLASSES`, top-down. Two\n+hooks are available:\n+\n+* :meth:`process_request`\n+* :meth:`process_view`\n+\n+During the response phase, after calling the view, middleware are applied in\n+reverse order, from the bottom up. Three hooks are available:\n+\n+* :meth:`process_exception` (only if the view raised an exception)\n+* :meth:`process_template_response` (only for template responses)\n+* :meth:`process_response`\n \n .. image:: _images/middleware.svg\n    :alt: middleware application order\n@@ -47,10 +71,7 @@ bottom up.\n If you prefer, you can also think of it like an onion: each middleware class\n is a \"layer\" that wraps the view.\n \n-A Django installation doesn't require any middleware -- e.g.,\n-:setting:`MIDDLEWARE_CLASSES` can be empty, if you'd like -- but it's strongly\n-suggested that you at least use\n-:class:`~django.middleware.common.CommonMiddleware`.\n+The behavior of each hook is described below.\n \n Writing your own middleware\n ===========================\n@@ -65,16 +86,19 @@ Python class that defines one or more of the following methods:\n \n .. method:: process_request(self, request)\n \n-``request`` is an :class:`~django.http.HttpRequest` object. This method is\n-called on each request, before Django decides which view to execute.\n+``request`` is an :class:`~django.http.HttpRequest` object.\n+\n+``process_request()`` is called on each request, before Django decides which\n+view to execute.\n \n-``process_request()`` should return either ``None`` or an\n-:class:`~django.http.HttpResponse` object. If it returns ``None``, Django will\n-continue processing this request, executing any other middleware and, then, the\n-appropriate view. If it returns an :class:`~django.http.HttpResponse` object,\n-Django won't bother calling ANY other request, view or exception middleware, or\n-the appropriate view; it'll return that :class:`~django.http.HttpResponse`.\n-Response middleware is always called on every response.\n+It should return either ``None`` or an :class:`~django.http.HttpResponse`\n+object. If it returns ``None``, Django will continue processing this request,\n+executing any other ``process_request()`` middleware, then, ``process_view()``\n+middleware, and finally, the appropriate view. If it returns an\n+:class:`~django.http.HttpResponse` object, Django won't bother calling any\n+other request, view or exception middleware, or the appropriate view; it'll\n+apply response middleware to that :class:`~django.http.HttpResponse`, and\n+return the result.\n \n .. _view-middleware:\n \n@@ -91,14 +115,15 @@ dictionary of keyword arguments that will be passed to the view. Neither\n ``view_args`` nor ``view_kwargs`` include the first view argument\n (``request``).\n \n-``process_view()`` is called just before Django calls the view. It should\n-return either ``None`` or an :class:`~django.http.HttpResponse` object. If it\n-returns ``None``, Django will continue processing this request, executing any\n-other ``process_view()`` middleware and, then, the appropriate view. If it\n-returns an :class:`~django.http.HttpResponse` object, Django won't bother\n-calling ANY other request, view or exception middleware, or the appropriate\n-view; it'll return that :class:`~django.http.HttpResponse`. Response\n-middleware is always called on every response.\n+``process_view()`` is called just before Django calls the view.\n+\n+It should return either ``None`` or an :class:`~django.http.HttpResponse`\n+object. If it returns ``None``, Django will continue processing this request,\n+executing any other ``process_view()`` middleware and, then, the appropriate\n+view. If it returns an :class:`~django.http.HttpResponse` object, Django won't\n+bother calling any other view or exception middleware, or the appropriate\n+view; it'll apply response middleware to that\n+:class:`~django.http.HttpResponse`, and return the result.\n \n .. note::\n \n@@ -122,27 +147,25 @@ middleware is always called on every response.\n \n .. method:: process_template_response(self, request, response)\n \n-``request`` is an :class:`~django.http.HttpRequest` object. ``response`` is a\n-subclass of :class:`~django.template.response.SimpleTemplateResponse` (e.g.\n-:class:`~django.template.response.TemplateResponse`) or any response object\n-that implements a ``render`` method.\n+``request`` is an :class:`~django.http.HttpRequest` object. ``response`` is\n+the :class:`~django.template.response.TemplateResponse` object (or equivalent)\n+returned by a Django view or by a middleware.\n \n-``process_template_response()`` must return a response object that implements a\n-``render`` method. It could alter the given ``response`` by changing\n-``response.template_name`` and ``response.context_data``, or it could create\n-and return a brand-new\n-:class:`~django.template.response.SimpleTemplateResponse` or equivalent.\n+``process_template_response()`` is called just after the view has finished\n+executing, if the response instance has a ``render()`` method, indicating that\n+it is a :class:`~django.template.response.TemplateResponse` or equivalent.\n \n-``process_template_response()`` will only be called if the response\n-instance has a ``render()`` method, indicating that it is a\n+It must return a response object that implements a ``render`` method. It could\n+alter the given ``response`` by changing ``response.template_name`` and\n+``response.context_data``, or it could create and return a brand-new\n :class:`~django.template.response.TemplateResponse` or equivalent.\n \n You don't need to explicitly render responses -- responses will be\n automatically rendered once all template response middleware has been\n called.\n \n Middleware are run in reverse order during the response phase, which\n-includes process_template_response.\n+includes ``process_template_response()``.\n \n .. _response-middleware:\n \n@@ -151,21 +174,34 @@ includes process_template_response.\n \n .. method:: process_response(self, request, response)\n \n-``request`` is an :class:`~django.http.HttpRequest` object. ``response`` is the\n-:class:`~django.http.HttpResponse` object returned by a Django view.\n+``request`` is an :class:`~django.http.HttpRequest` object. ``response`` is\n+the :class:`~django.http.HttpResponse` or\n+:class:`~django.http.StreamingHttpResponse` object returned by a Django view\n+or by a middleware.\n+\n+``process_response()`` is called on all responses before they're returned to\n+the browser.\n \n-``process_response()`` must return an :class:`~django.http.HttpResponse`\n-object. It could alter the given ``response``, or it could create and return a\n-brand-new :class:`~django.http.HttpResponse`.\n+It must return an :class:`~django.http.HttpResponse` or\n+:class:`~django.http.StreamingHttpResponse` object. It could alter the given\n+``response``, or it could create and return a brand-new\n+:class:`~django.http.HttpResponse` or\n+:class:`~django.http.StreamingHttpResponse`.\n \n Unlike the ``process_request()`` and ``process_view()`` methods, the\n-``process_response()`` method is always called, even if the ``process_request()``\n-and ``process_view()`` methods of the same middleware class were skipped because\n-an earlier middleware method returned an :class:`~django.http.HttpResponse`\n-(this means that your ``process_response()`` method cannot rely on setup done in\n-``process_request()``, for example). In addition, during the response phase the\n-classes are applied in reverse order, from the bottom up. This means classes\n-defined at the end of :setting:`MIDDLEWARE_CLASSES` will be run first.\n+``process_response()`` method is always called, even if the\n+``process_request()`` and ``process_view()`` methods of the same middleware\n+class were skipped (because an earlier middleware method returned an\n+:class:`~django.http.HttpResponse`). In particular, this means that your\n+``process_response()`` method cannot rely on setup done in\n+``process_request()``.\n+\n+Finally, remember that during the response phase, middleware are applied in\n+reverse order, from the bottom up. This means classes defined at the end of\n+:setting:`MIDDLEWARE_CLASSES` will be run first.\n+\n+Dealing with streaming responses\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n .. versionchanged:: 1.5\n     ``response`` may also be an :class:`~django.http.StreamingHttpResponse`\n@@ -180,10 +216,17 @@ must test for streaming responses and adjust their behavior accordingly::\n     if response.streaming:\n         response.streaming_content = wrap_streaming_content(response.streaming_content)\n     else:\n-        response.content = wrap_content(response.content)\n+        response.content = alter_content(response.content)\n+\n+.. note::\n+\n+    ``streaming_content`` should be assumed to be too large to hold in memory.\n+    Response middleware may wrap it in a new generator, but must not consume\n+    it. Wrapping is typically implemented as follows::\n \n-``streaming_content`` should be assumed to be too large to hold in memory.\n-Middleware may wrap it in a new generator, but must not consume it.\n+        def wrap_streaming_content(content)\n+            for chunk in content:\n+                yield alter_content(chunk)\n \n .. _exception-middleware:\n \n@@ -198,8 +241,9 @@ Middleware may wrap it in a new generator, but must not consume it.\n Django calls ``process_exception()`` when a view raises an exception.\n ``process_exception()`` should return either ``None`` or an\n :class:`~django.http.HttpResponse` object. If it returns an\n-:class:`~django.http.HttpResponse` object, the response will be returned to\n-the browser. Otherwise, default exception handling kicks in.\n+:class:`~django.http.HttpResponse` object, the template response and response\n+middleware will be applied, and the resulting response returned to the\n+browser. Otherwise, default exception handling kicks in.\n \n Again, middleware are run in reverse order during the response phase, which\n includes ``process_exception``. If an exception middleware returns a response,\n@@ -224,9 +268,9 @@ Marking middleware as unused\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n It's sometimes useful to determine at run-time whether a piece of middleware\n-should be used. In these cases, your middleware's ``__init__`` method may raise\n-``django.core.exceptions.MiddlewareNotUsed``. Django will then remove that\n-piece of middleware from the middleware process.\n+should be used. In these cases, your middleware's ``__init__`` method may\n+raise :exc:`django.core.exceptions.MiddlewareNotUsed`. Django will then remove\n+that piece of middleware from the middleware process.\n \n Guidelines\n ----------"
        }
    ],
    "stats": {
        "total": 182,
        "additions": 113,
        "deletions": 69
    }
}