{
    "author": "akaariai",
    "message": "Fixed #13781 -- Improved select_related in inheritance situations\n\nThe select_related code got confused when it needed to travel a\nreverse relation to a model which had different parent than the\noriginally travelled relation.\n\nThanks to Trac aliases shauncutts for report and ungenio for original\npatch (committed patch is somewhat modified version of that).",
    "sha": "f51e409a5fb34020e170494320a421503689aea0",
    "files": [
        {
            "sha": "ab2f44e2f7504fa80d248057d6eea2eb1acf2c53",
            "filename": "django/db/models/options.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/f51e409a5fb34020e170494320a421503689aea0/django%2Fdb%2Fmodels%2Foptions.py",
            "raw_url": "https://github.com/django/django/raw/f51e409a5fb34020e170494320a421503689aea0/django%2Fdb%2Fmodels%2Foptions.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Foptions.py?ref=f51e409a5fb34020e170494320a421503689aea0",
            "patch": "@@ -75,6 +75,7 @@ def contribute_to_class(self, cls, name):\n         from django.db.backends.util import truncate_name\n \n         cls._meta = self\n+        self.model = cls\n         self.installed = re.sub('\\.models$', '', cls.__module__) in settings.INSTALLED_APPS\n         # First, construct the default values for these options.\n         self.object_name = cls.__name__\n@@ -464,16 +465,15 @@ def get_base_chain(self, model):\n         a granparent or even more distant relation.\n         \"\"\"\n         if not self.parents:\n-            return\n+            return None\n         if model in self.parents:\n             return [model]\n         for parent in self.parents:\n             res = parent._meta.get_base_chain(model)\n             if res:\n                 res.insert(0, parent)\n                 return res\n-        raise TypeError('%r is not an ancestor of this model'\n-                % model._meta.module_name)\n+        return None\n \n     def get_parent_list(self):\n         \"\"\""
        },
        {
            "sha": "d5379a5f6a47807829dd91a5b7834f2e01c11207",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 49,
            "deletions": 34,
            "changes": 83,
            "blob_url": "https://github.com/django/django/blob/f51e409a5fb34020e170494320a421503689aea0/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/f51e409a5fb34020e170494320a421503689aea0/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=f51e409a5fb34020e170494320a421503689aea0",
            "patch": "@@ -1300,7 +1300,7 @@ def values_list(self, *fields, **kwargs):\n     value_annotation = False\n \n def get_klass_info(klass, max_depth=0, cur_depth=0, requested=None,\n-                   only_load=None, local_only=False):\n+                   only_load=None, from_parent=None):\n     \"\"\"\n     Helper function that recursively returns an information for a klass, to be\n     used in get_cached_row.  It exists just to compute this information only\n@@ -1320,8 +1320,10 @@ def get_klass_info(klass, max_depth=0, cur_depth=0, requested=None,\n      * only_load - if the query has had only() or defer() applied,\n        this is the list of field names that will be returned. If None,\n        the full field list for `klass` can be assumed.\n-     * local_only - Only populate local fields. This is used when\n-       following reverse select-related relations\n+     * from_parent - the parent model used to get to this model\n+\n+    Note that when travelling from parent to child, we will only load child\n+    fields which aren't in the parent.\n     \"\"\"\n     if max_depth and requested is None and cur_depth > max_depth:\n         # We've recursed deeply enough; stop now.\n@@ -1347,7 +1349,9 @@ def get_klass_info(klass, max_depth=0, cur_depth=0, requested=None,\n         for field, model in klass._meta.get_fields_with_model():\n             if field.name not in load_fields:\n                 skip.add(field.attname)\n-            elif local_only and model is not None:\n+            elif from_parent and issubclass(from_parent, model.__class__):\n+                # Avoid loading fields already loaded for parent model for\n+                # child models.\n                 continue\n             else:\n                 init_list.append(field.attname)\n@@ -1361,16 +1365,22 @@ def get_klass_info(klass, max_depth=0, cur_depth=0, requested=None,\n     else:\n         # Load all fields on klass\n \n-        # We trying to not populate field_names variable for perfomance reason.\n-        # If field_names variable is set, it is used to instantiate desired fields,\n-        # by passing **dict(zip(field_names, fields)) as kwargs to Model.__init__ method.\n-        # But kwargs version of Model.__init__ is slower, so we should avoid using\n-        # it when it is not really neccesary.\n-        if local_only and len(klass._meta.local_fields) != len(klass._meta.fields):\n-            field_count = len(klass._meta.local_fields)\n-            field_names = [f.attname for f in klass._meta.local_fields]\n-        else:\n-            field_count = len(klass._meta.fields)\n+        field_count = len(klass._meta.fields)\n+        # Check if we need to skip some parent fields.\n+        if from_parent and len(klass._meta.local_fields) != len(klass._meta.fields):\n+            # Only load those fields which haven't been already loaded into\n+            # 'from_parent'.\n+            non_seen_models = [p for p in klass._meta.get_parent_list()\n+                               if not issubclass(from_parent, p)]\n+            # Load local fields, too...\n+            non_seen_models.append(klass)\n+            field_names = [f.attname for f in klass._meta.fields\n+                           if f.model in non_seen_models]\n+            field_count = len(field_names)\n+        # Try to avoid populating field_names variable for perfomance reasons.\n+        # If field_names variable is set, we use **kwargs based model init\n+        # which is slower than normal init.\n+        if field_count == len(klass._meta.fields):\n             field_names = ()\n \n     restricted = requested is not None\n@@ -1392,8 +1402,9 @@ def get_klass_info(klass, max_depth=0, cur_depth=0, requested=None,\n             if o.field.unique and select_related_descend(o.field, restricted, requested,\n                                                          only_load.get(o.model), reverse=True):\n                 next = requested[o.field.related_query_name()]\n+                parent = klass if issubclass(o.model, klass) else None\n                 klass_info = get_klass_info(o.model, max_depth=max_depth, cur_depth=cur_depth+1,\n-                                            requested=next, only_load=only_load, local_only=True)\n+                                            requested=next, only_load=only_load, from_parent=parent)\n                 reverse_related_fields.append((o.field, klass_info))\n     if field_names:\n         pk_idx = field_names.index(klass._meta.pk.attname)\n@@ -1403,7 +1414,8 @@ def get_klass_info(klass, max_depth=0, cur_depth=0, requested=None,\n     return klass, field_names, field_count, related_fields, reverse_related_fields, pk_idx\n \n \n-def get_cached_row(row, index_start, using,  klass_info, offset=0):\n+def get_cached_row(row, index_start, using,  klass_info, offset=0,\n+                   parent_data=()):\n     \"\"\"\n     Helper function that recursively returns an object with the specified\n     related attributes already populated.\n@@ -1418,13 +1430,16 @@ def get_cached_row(row, index_start, using,  klass_info, offset=0):\n          * offset - the number of additional fields that are known to\n            exist in row for `klass`. This usually means the number of\n            annotated results on `klass`.\n-        * using - the database alias on which the query is being executed.\n+         * using - the database alias on which the query is being executed.\n          * klass_info - result of the get_klass_info function\n+         * parent_data - parent model data in format (field, value). Used\n+           to populate the non-local fields of child models.\n     \"\"\"\n     if klass_info is None:\n         return None\n     klass, field_names, field_count, related_fields, reverse_related_fields, pk_idx = klass_info\n \n+\n     fields = row[index_start : index_start + field_count]\n     # If the pk column is None (or the Oracle equivalent ''), then the related\n     # object must be non-existent - set the relation to None.\n@@ -1434,7 +1449,6 @@ def get_cached_row(row, index_start, using,  klass_info, offset=0):\n         obj = klass(**dict(zip(field_names, fields)))\n     else:\n         obj = klass(*fields)\n-\n     # If an object was retrieved, set the database state.\n     if obj:\n         obj._state.db = using\n@@ -1464,34 +1478,35 @@ def get_cached_row(row, index_start, using,  klass_info, offset=0):\n     # Only handle the restricted case - i.e., don't do a depth\n     # descent into reverse relations unless explicitly requested\n     for f, klass_info in reverse_related_fields:\n+        # Transfer data from this object to childs.\n+        parent_data = []\n+        for rel_field, rel_model in klass_info[0]._meta.get_fields_with_model():\n+            if rel_model is not None and isinstance(obj, rel_model):\n+                parent_data.append((rel_field, getattr(obj, rel_field.attname)))\n         # Recursively retrieve the data for the related object\n-        cached_row = get_cached_row(row, index_end, using, klass_info)\n+        cached_row = get_cached_row(row, index_end, using, klass_info,\n+                                   parent_data=parent_data)\n         # If the recursive descent found an object, populate the\n         # descriptor caches relevant to the object\n         if cached_row:\n             rel_obj, index_end = cached_row\n             if obj is not None:\n-                # If the field is unique, populate the\n-                # reverse descriptor cache\n+                # populate the reverse descriptor cache\n                 setattr(obj, f.related.get_cache_name(), rel_obj)\n             if rel_obj is not None:\n                 # If the related object exists, populate\n                 # the descriptor cache.\n                 setattr(rel_obj, f.get_cache_name(), obj)\n-                # Now populate all the non-local field values\n-                # on the related object\n-                for rel_field, rel_model in rel_obj._meta.get_fields_with_model():\n-                    if rel_model is not None:\n+                # Populate related object caches using parent data.\n+                for rel_field, _ in parent_data:\n+                    if rel_field.rel:\n                         setattr(rel_obj, rel_field.attname, getattr(obj, rel_field.attname))\n-                        # populate the field cache for any related object\n-                        # that has already been retrieved\n-                        if rel_field.rel:\n-                            try:\n-                                cached_obj = getattr(obj, rel_field.get_cache_name())\n-                                setattr(rel_obj, rel_field.get_cache_name(), cached_obj)\n-                            except AttributeError:\n-                                # Related object hasn't been cached yet\n-                                pass\n+                        try:\n+                            cached_obj = getattr(obj, rel_field.get_cache_name())\n+                            setattr(rel_obj, rel_field.get_cache_name(), cached_obj)\n+                        except AttributeError:\n+                            # Related object hasn't been cached yet\n+                            pass\n     return obj, index_end\n \n "
        },
        {
            "sha": "8cfb12a8e36b18a361392456a88a9da3661f295b",
            "filename": "django/db/models/sql/compiler.py",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/f51e409a5fb34020e170494320a421503689aea0/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/f51e409a5fb34020e170494320a421503689aea0/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py?ref=f51e409a5fb34020e170494320a421503689aea0",
            "patch": "@@ -240,7 +240,7 @@ def get_columns(self, with_aliases=False):\n         return result\n \n     def get_default_columns(self, with_aliases=False, col_aliases=None,\n-            start_alias=None, opts=None, as_pairs=False, local_only=False):\n+            start_alias=None, opts=None, as_pairs=False, from_parent=None):\n         \"\"\"\n         Computes the default columns for selecting every field in the base\n         model. Will sometimes be called to pull in related models (e.g. via\n@@ -265,7 +265,8 @@ def get_default_columns(self, with_aliases=False, col_aliases=None,\n         if start_alias:\n             seen = {None: start_alias}\n         for field, model in opts.get_fields_with_model():\n-            if local_only and model is not None:\n+            if from_parent and model is not None and issubclass(from_parent, model):\n+                # Avoid loading data for already loaded parents.\n                 continue\n             if start_alias:\n                 try:\n@@ -686,11 +687,13 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n                     (alias, table, f.rel.get_related_field().column, f.column),\n                     promote=True\n                 )\n+                from_parent = (opts.model if issubclass(model, opts.model)\n+                               else None)\n                 columns, aliases = self.get_default_columns(start_alias=alias,\n-                    opts=model._meta, as_pairs=True, local_only=True)\n+                    opts=model._meta, as_pairs=True, from_parent=from_parent)\n                 self.query.related_select_cols.extend(\n-                    SelectInfo(col, field) for col, field in zip(columns, model._meta.fields))\n-\n+                    SelectInfo(col, field) for col, field\n+                    in zip(columns, model._meta.fields))\n                 next = requested.get(f.related_query_name(), {})\n                 # Use True here because we are looking at the _reverse_ side of\n                 # the relation, which is always nullable."
        },
        {
            "sha": "d32faafbb9d6c4e0b1fb01ae4046b0c4a5a8a9f9",
            "filename": "tests/regressiontests/select_related_onetoone/models.py",
            "status": "modified",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/django/django/blob/f51e409a5fb34020e170494320a421503689aea0/tests%2Fregressiontests%2Fselect_related_onetoone%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/f51e409a5fb34020e170494320a421503689aea0/tests%2Fregressiontests%2Fselect_related_onetoone%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fselect_related_onetoone%2Fmodels.py?ref=f51e409a5fb34020e170494320a421503689aea0",
            "patch": "@@ -51,10 +51,52 @@ def __str__(self):\n class AdvancedUserStat(UserStat):\n     karma = models.IntegerField()\n \n+\n class Image(models.Model):\n     name = models.CharField(max_length=100)\n \n \n class Product(models.Model):\n     name = models.CharField(max_length=100)\n     image = models.OneToOneField(Image, null=True)\n+\n+\n+@python_2_unicode_compatible\n+class Parent1(models.Model):\n+    name1 = models.CharField(max_length=50)\n+\n+    def __str__(self):\n+        return self.name1\n+\n+\n+@python_2_unicode_compatible\n+class Parent2(models.Model):\n+    # Avoid having two \"id\" fields in the Child1 subclass\n+    id2 = models.AutoField(primary_key=True)\n+    name2 = models.CharField(max_length=50)\n+\n+    def __str__(self):\n+        return self.name2\n+\n+\n+@python_2_unicode_compatible\n+class Child1(Parent1, Parent2):\n+    value = models.IntegerField()\n+\n+    def __str__(self):\n+        return self.name1\n+\n+\n+@python_2_unicode_compatible\n+class Child2(Parent1):\n+    parent2 = models.OneToOneField(Parent2)\n+    value = models.IntegerField()\n+\n+    def __str__(self):\n+        return self.name1\n+\n+class Child3(Child2):\n+    value3 = models.IntegerField()\n+\n+class Child4(Child1):\n+    value4 = models.IntegerField()"
        },
        {
            "sha": "d4a1275e49bbc97aa096172b0ffb87070a8e43c0",
            "filename": "tests/regressiontests/select_related_onetoone/tests.py",
            "status": "modified",
            "additions": 101,
            "deletions": 1,
            "changes": 102,
            "blob_url": "https://github.com/django/django/blob/f51e409a5fb34020e170494320a421503689aea0/tests%2Fregressiontests%2Fselect_related_onetoone%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/f51e409a5fb34020e170494320a421503689aea0/tests%2Fregressiontests%2Fselect_related_onetoone%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fselect_related_onetoone%2Ftests.py?ref=f51e409a5fb34020e170494320a421503689aea0",
            "patch": "@@ -1,9 +1,11 @@\n from __future__ import absolute_import\n \n from django.test import TestCase\n+from django.utils import unittest\n \n from .models import (User, UserProfile, UserStat, UserStatResult, StatDetails,\n-    AdvancedUserStat, Image, Product)\n+    AdvancedUserStat, Image, Product, Parent1, Parent2, Child1, Child2, Child3,\n+    Child4)\n \n \n class ReverseSelectRelatedTestCase(TestCase):\n@@ -21,6 +23,14 @@ def setUp(self):\n         advstat = AdvancedUserStat.objects.create(user=user2, posts=200, karma=5,\n                                                   results=results2)\n         StatDetails.objects.create(base_stats=advstat, comments=250)\n+        p1 = Parent1(name1=\"Only Parent1\")\n+        p1.save()\n+        c1 = Child1(name1=\"Child1 Parent1\", name2=\"Child1 Parent2\", value=1)\n+        c1.save()\n+        p2 = Parent2(name2=\"Child2 Parent2\")\n+        p2.save()\n+        c2 = Child2(name1=\"Child2 Parent1\", parent2=p2, value=2)\n+        c2.save()\n \n     def test_basic(self):\n         with self.assertNumQueries(1):\n@@ -108,3 +118,93 @@ def test_nullable_missing_reverse(self):\n             image = Image.objects.select_related('product').get()\n             with self.assertRaises(Product.DoesNotExist):\n                 image.product\n+\n+    def test_parent_only(self):\n+        with self.assertNumQueries(1):\n+            p = Parent1.objects.select_related('child1').get(name1=\"Only Parent1\")\n+        with self.assertNumQueries(0):\n+            with self.assertRaises(Child1.DoesNotExist):\n+                p.child1\n+\n+    def test_multiple_subclass(self):\n+        with self.assertNumQueries(1):\n+            p = Parent1.objects.select_related('child1').get(name1=\"Child1 Parent1\")\n+            self.assertEqual(p.child1.name2, 'Child1 Parent2')\n+\n+    def test_onetoone_with_subclass(self):\n+        with self.assertNumQueries(1):\n+            p = Parent2.objects.select_related('child2').get(name2=\"Child2 Parent2\")\n+            self.assertEqual(p.child2.name1, 'Child2 Parent1')\n+\n+    def test_onetoone_with_two_subclasses(self):\n+        with self.assertNumQueries(1):\n+            p = Parent2.objects.select_related('child2', \"child2__child3\").get(name2=\"Child2 Parent2\")\n+            self.assertEqual(p.child2.name1, 'Child2 Parent1')\n+            with self.assertRaises(Child3.DoesNotExist):\n+                p.child2.child3\n+        p3 = Parent2(name2=\"Child3 Parent2\")\n+        p3.save()\n+        c2 = Child3(name1=\"Child3 Parent1\", parent2=p3, value=2, value3=3)\n+        c2.save()\n+        with self.assertNumQueries(1):\n+            p = Parent2.objects.select_related('child2', \"child2__child3\").get(name2=\"Child3 Parent2\")\n+            self.assertEqual(p.child2.name1, 'Child3 Parent1')\n+            self.assertEqual(p.child2.child3.value3, 3)\n+            self.assertEqual(p.child2.child3.value, p.child2.value)\n+            self.assertEqual(p.child2.name1, p.child2.child3.name1)\n+\n+    def test_multiinheritance_two_subclasses(self):\n+        with self.assertNumQueries(1):\n+            p = Parent1.objects.select_related('child1', 'child1__child4').get(name1=\"Child1 Parent1\")\n+            self.assertEqual(p.child1.name2, 'Child1 Parent2')\n+            self.assertEqual(p.child1.name1, p.name1)\n+            with self.assertRaises(Child4.DoesNotExist):\n+                p.child1.child4\n+        Child4(name1='n1', name2='n2', value=1, value4=4).save()\n+        with self.assertNumQueries(1):\n+            p = Parent2.objects.select_related('child1', 'child1__child4').get(name2=\"n2\")\n+            self.assertEqual(p.name2, 'n2')\n+            self.assertEqual(p.child1.name1, 'n1')\n+            self.assertEqual(p.child1.name2, p.name2)\n+            self.assertEqual(p.child1.value, 1)\n+            self.assertEqual(p.child1.child4.name1, p.child1.name1)\n+            self.assertEqual(p.child1.child4.name2, p.child1.name2)\n+            self.assertEqual(p.child1.child4.value, p.child1.value)\n+            self.assertEqual(p.child1.child4.value4, 4)\n+\n+    @unittest.expectedFailure\n+    def test_inheritance_deferred(self):\n+        c = Child4.objects.create(name1='n1', name2='n2', value=1, value4=4)\n+        with self.assertNumQueries(1):\n+            p = Parent2.objects.select_related('child1').only(\n+                'id2',  'child1__value').get(name2=\"n2\")\n+            self.assertEqual(p.id2, c.id2)\n+            self.assertEqual(p.child1.value, 1)\n+        p = Parent2.objects.select_related('child1').only(\n+            'id2',  'child1__value').get(name2=\"n2\")\n+        with self.assertNumQueries(1):\n+            self.assertEquals(p.name2, 'n2')\n+        p = Parent2.objects.select_related('child1').only(\n+            'id2',  'child1__value').get(name2=\"n2\")\n+        with self.assertNumQueries(1):\n+            self.assertEquals(p.child1.name2, 'n2')\n+\n+    @unittest.expectedFailure\n+    def test_inheritance_deferred2(self):\n+        c = Child4.objects.create(name1='n1', name2='n2', value=1, value4=4)\n+        qs = Parent2.objects.select_related('child1', 'child4').only(\n+            'id2',  'child1__value', 'child1__child4__value4')\n+        with self.assertNumQueries(1):\n+            p = qs.get(name2=\"n2\")\n+            self.assertEqual(p.id2, c.id2)\n+            self.assertEqual(p.child1.value, 1)\n+            self.assertEqual(p.child1.child4.value4, 4)\n+            self.assertEqual(p.child1.child4.id2, c.id2)\n+        p = qs.get(name2=\"n2\")\n+        with self.assertNumQueries(1):\n+            self.assertEquals(p.child1.name2, 'n2')\n+        p = qs.get(name2=\"n2\")\n+        with self.assertNumQueries(1):\n+            self.assertEquals(p.child1.name1, 'n1')\n+        with self.assertNumQueries(1):\n+            self.assertEquals(p.child1.child4.name1, 'n1')"
        }
    ],
    "stats": {
        "total": 246,
        "additions": 203,
        "deletions": 43
    }
}