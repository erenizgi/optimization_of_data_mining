{
    "author": "akaariai",
    "message": "Fixed #18823 -- Ensured m2m.clear() works when using through+to_field\n\nThere was a potential data-loss issue involved -- when clearing\ninstance's m2m assignments it was possible some other instance's\nm2m data was deleted instead.\n\nThis commit also improved None handling for to_field cases.",
    "sha": "611c4d6f1c24763e5e6e331a5dcf9b610288aaa8",
    "files": [
        {
            "sha": "80c62f85c476c61432722311e23c5fb49ac5915e",
            "filename": "django/db/models/fields/related.py",
            "status": "modified",
            "additions": 36,
            "deletions": 9,
            "changes": 45,
            "blob_url": "https://github.com/django/django/blob/611c4d6f1c24763e5e6e331a5dcf9b610288aaa8/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "raw_url": "https://github.com/django/django/raw/611c4d6f1c24763e5e6e331a5dcf9b610288aaa8/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2Frelated.py?ref=611c4d6f1c24763e5e6e331a5dcf9b610288aaa8",
            "patch": "@@ -573,9 +573,31 @@ def __init__(self, model=None, query_field_name=None, instance=None, symmetrical\n             self.reverse = reverse\n             self.through = through\n             self.prefetch_cache_name = prefetch_cache_name\n-            self._pk_val = self.instance.pk\n-            if self._pk_val is None:\n-                raise ValueError(\"%r instance needs to have a primary key value before a many-to-many relationship can be used.\" % instance.__class__.__name__)\n+            self._fk_val = self._get_fk_val(instance, source_field_name)\n+            if self._fk_val is None:\n+                raise ValueError('\"%r\" needs to have a value for field \"%s\" before '\n+                                 'this many-to-many relationship can be used.' %\n+                                 (instance, source_field_name))\n+            # Even if this relation is not to pk, we require still pk value.\n+            # The wish is that the instance has been already saved to DB,\n+            # although having a pk value isn't a guarantee of that.\n+            if instance.pk is None:\n+                raise ValueError(\"%r instance needs to have a primary key value before \"\n+                                 \"a many-to-many relationship can be used.\" %\n+                                 instance.__class__.__name__)\n+\n+\n+        def _get_fk_val(self, obj, field_name):\n+            \"\"\"\n+            Returns the correct value for this relationship's foreign key. This\n+            might be something else than pk value when to_field is used.\n+            \"\"\"\n+            fk = self.through._meta.get_field(field_name)\n+            if fk.rel.field_name and fk.rel.field_name != fk.rel.to._meta.pk.attname:\n+                attname = fk.rel.get_related_field().get_attname()\n+                return fk.get_prep_lookup('exact', getattr(obj, attname))\n+            else:\n+                return obj.pk\n \n         def get_query_set(self):\n             try:\n@@ -677,15 +699,19 @@ def _add_items(self, source_field_name, target_field_name, *objs):\n                         if not router.allow_relation(obj, self.instance):\n                             raise ValueError('Cannot add \"%r\": instance is on database \"%s\", value is on database \"%s\"' %\n                                                (obj, self.instance._state.db, obj._state.db))\n-                        new_ids.add(obj.pk)\n+                        fk_val = self._get_fk_val(obj, target_field_name)\n+                        if fk_val is None:\n+                            raise ValueError('Cannot add \"%r\": the value for field \"%s\" is None' %\n+                                             (obj, target_field_name))\n+                        new_ids.add(self._get_fk_val(obj, target_field_name))\n                     elif isinstance(obj, Model):\n                         raise TypeError(\"'%s' instance expected, got %r\" % (self.model._meta.object_name, obj))\n                     else:\n                         new_ids.add(obj)\n                 db = router.db_for_write(self.through, instance=self.instance)\n                 vals = self.through._default_manager.using(db).values_list(target_field_name, flat=True)\n                 vals = vals.filter(**{\n-                    source_field_name: self._pk_val,\n+                    source_field_name: self._fk_val,\n                     '%s__in' % target_field_name: new_ids,\n                 })\n                 new_ids = new_ids - set(vals)\n@@ -699,11 +725,12 @@ def _add_items(self, source_field_name, target_field_name, *objs):\n                 # Add the ones that aren't there already\n                 self.through._default_manager.using(db).bulk_create([\n                     self.through(**{\n-                        '%s_id' % source_field_name: self._pk_val,\n+                        '%s_id' % source_field_name: self._fk_val,\n                         '%s_id' % target_field_name: obj_id,\n                     })\n                     for obj_id in new_ids\n                 ])\n+\n                 if self.reverse or source_field_name == self.source_field_name:\n                     # Don't send the signal when we are inserting the\n                     # duplicate data row for symmetrical reverse entries.\n@@ -722,7 +749,7 @@ def _remove_items(self, source_field_name, target_field_name, *objs):\n                 old_ids = set()\n                 for obj in objs:\n                     if isinstance(obj, self.model):\n-                        old_ids.add(obj.pk)\n+                        old_ids.add(self._get_fk_val(obj, target_field_name))\n                     else:\n                         old_ids.add(obj)\n                 # Work out what DB we're operating on\n@@ -736,7 +763,7 @@ def _remove_items(self, source_field_name, target_field_name, *objs):\n                         model=self.model, pk_set=old_ids, using=db)\n                 # Remove the specified objects from the join table\n                 self.through._default_manager.using(db).filter(**{\n-                    source_field_name: self._pk_val,\n+                    source_field_name: self._fk_val,\n                     '%s__in' % target_field_name: old_ids\n                 }).delete()\n                 if self.reverse or source_field_name == self.source_field_name:\n@@ -756,7 +783,7 @@ def _clear_items(self, source_field_name):\n                     instance=self.instance, reverse=self.reverse,\n                     model=self.model, pk_set=None, using=db)\n             self.through._default_manager.using(db).filter(**{\n-                source_field_name: self._pk_val\n+                source_field_name: self._fk_val\n             }).delete()\n             if self.reverse or source_field_name == self.source_field_name:\n                 # Don't send the signal when we are clearing the"
        },
        {
            "sha": "23d3366f228200e476c639b2efd484cf0138ec29",
            "filename": "tests/regressiontests/m2m_through_regress/models.py",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/611c4d6f1c24763e5e6e331a5dcf9b610288aaa8/tests%2Fregressiontests%2Fm2m_through_regress%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/611c4d6f1c24763e5e6e331a5dcf9b610288aaa8/tests%2Fregressiontests%2Fm2m_through_regress%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fm2m_through_regress%2Fmodels.py?ref=611c4d6f1c24763e5e6e331a5dcf9b610288aaa8",
            "patch": "@@ -62,18 +62,18 @@ class B(models.Model):\n # Using to_field on the through model\n @python_2_unicode_compatible\n class Car(models.Model):\n-    make = models.CharField(max_length=20, unique=True)\n+    make = models.CharField(max_length=20, unique=True, null=True)\n     drivers = models.ManyToManyField('Driver', through='CarDriver')\n \n     def __str__(self):\n-        return self.make\n+        return \"%s\" % self.make\n \n @python_2_unicode_compatible\n class Driver(models.Model):\n-    name = models.CharField(max_length=20, unique=True)\n+    name = models.CharField(max_length=20, unique=True, null=True)\n \n     def __str__(self):\n-        return self.name\n+        return \"%s\" % self.name\n \n @python_2_unicode_compatible\n class CarDriver(models.Model):"
        },
        {
            "sha": "828ec3618c80a4cd822e9114cdf94e1fe4e343ba",
            "filename": "tests/regressiontests/m2m_through_regress/tests.py",
            "status": "modified",
            "additions": 88,
            "deletions": 2,
            "changes": 90,
            "blob_url": "https://github.com/django/django/blob/611c4d6f1c24763e5e6e331a5dcf9b610288aaa8/tests%2Fregressiontests%2Fm2m_through_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/611c4d6f1c24763e5e6e331a5dcf9b610288aaa8/tests%2Fregressiontests%2Fm2m_through_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fm2m_through_regress%2Ftests.py?ref=611c4d6f1c24763e5e6e331a5dcf9b610288aaa8",
            "patch": "@@ -123,18 +123,104 @@ def setUp(self):\n         self.car = Car.objects.create(make=\"Toyota\")\n         self.driver = Driver.objects.create(name=\"Ryan Briscoe\")\n         CarDriver.objects.create(car=self.car, driver=self.driver)\n+        # We are testing if wrong objects get deleted due to using wrong\n+        # field value in m2m queries. So, it is essential that the pk\n+        # numberings do not match.\n+        # Create one intentionally unused driver to mix up the autonumbering\n+        self.unused_driver = Driver.objects.create(name=\"Barney Gumble\")\n+        # And two intentionally unused cars.\n+        self.unused_car1 = Car.objects.create(make=\"Trabant\")\n+        self.unused_car2 = Car.objects.create(make=\"Wartburg\")\n \n     def test_to_field(self):\n         self.assertQuerysetEqual(\n             self.car.drivers.all(),\n             [\"<Driver: Ryan Briscoe>\"]\n-            )\n+        )\n \n     def test_to_field_reverse(self):\n         self.assertQuerysetEqual(\n             self.driver.car_set.all(),\n             [\"<Car: Toyota>\"]\n-            )\n+        )\n+\n+    def test_to_field_clear_reverse(self):\n+        self.driver.car_set.clear()\n+        self.assertQuerysetEqual(\n+            self.driver.car_set.all(),[])\n+\n+    def test_to_field_clear(self):\n+        self.car.drivers.clear()\n+        self.assertQuerysetEqual(\n+            self.car.drivers.all(),[])\n+\n+    # Low level tests for _add_items and _remove_items. We test these methods\n+    # because .add/.remove aren't available for m2m fields with through, but\n+    # through is the only way to set to_field currently. We do want to make\n+    # sure these methods are ready if the ability to use .add or .remove with\n+    # to_field relations is added some day.\n+    def test_add(self):\n+        self.assertQuerysetEqual(\n+            self.car.drivers.all(),\n+            [\"<Driver: Ryan Briscoe>\"]\n+        )\n+        # Yikes - barney is going to drive...\n+        self.car.drivers._add_items('car', 'driver', self.unused_driver)\n+        self.assertQuerysetEqual(\n+            self.car.drivers.all(),\n+            [\"<Driver: Ryan Briscoe>\", \"<Driver: Barney Gumble>\"]\n+        )\n+\n+    def test_add_null(self):\n+        nullcar = Car.objects.create(make=None)\n+        with self.assertRaises(ValueError):\n+            nullcar.drivers._add_items('car', 'driver', self.unused_driver)\n+\n+    def test_add_related_null(self):\n+        nulldriver = Driver.objects.create(name=None)\n+        with self.assertRaises(ValueError):\n+            self.car.drivers._add_items('car', 'driver', nulldriver)\n+\n+    def test_add_reverse(self):\n+        car2 = Car.objects.create(make=\"Honda\")\n+        self.assertQuerysetEqual(\n+            self.driver.car_set.all(),\n+            [\"<Car: Toyota>\"]\n+        )\n+        self.driver.car_set._add_items('driver', 'car', car2)\n+        self.assertQuerysetEqual(\n+            self.driver.car_set.all(),\n+            [\"<Car: Toyota>\", \"<Car: Honda>\"]\n+        )\n+\n+    def test_add_null_reverse(self):\n+        nullcar = Car.objects.create(make=None)\n+        with self.assertRaises(ValueError):\n+            self.driver.car_set._add_items('driver', 'car', nullcar)\n+\n+    def test_add_null_reverse_related(self):\n+        nulldriver = Driver.objects.create(name=None)\n+        with self.assertRaises(ValueError):\n+            nulldriver.car_set._add_items('driver', 'car', self.car)\n+\n+    def test_remove(self):\n+        self.assertQuerysetEqual(\n+            self.car.drivers.all(),\n+            [\"<Driver: Ryan Briscoe>\"]\n+        )\n+        self.car.drivers._remove_items('car', 'driver', self.driver)\n+        self.assertQuerysetEqual(\n+            self.car.drivers.all(),[])\n+\n+    def test_remove_reverse(self):\n+        self.assertQuerysetEqual(\n+            self.driver.car_set.all(),\n+            [\"<Car: Toyota>\"]\n+        )\n+        self.driver.car_set._remove_items('driver', 'car', self.car)\n+        self.assertQuerysetEqual(\n+            self.driver.car_set.all(),[])\n+\n \n class ThroughLoadDataTestCase(TestCase):\n     fixtures = [\"m2m_through\"]"
        }
    ],
    "stats": {
        "total": 143,
        "additions": 128,
        "deletions": 15
    }
}