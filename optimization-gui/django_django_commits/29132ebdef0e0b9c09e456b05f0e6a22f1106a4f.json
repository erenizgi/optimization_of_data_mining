{
    "author": "akaariai",
    "message": "Fixed #17788 -- Added batch_size argument to qs.bulk_create()\n\nThe qs.bulk_create() method did not work with large batches together\nwith SQLite3. This commit adds a way to split the bulk into smaller\nbatches. The default batch size is unlimited except for SQLite3 where\nthe batch size is limited to 999 SQL parameters per batch.\n\nThanks to everybody who participated in the discussions at Trac.",
    "sha": "29132ebdef0e0b9c09e456b05f0e6a22f1106a4f",
    "files": [
        {
            "sha": "3075bdb3e4c345875ff05e0e231833b18baac6c0",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 19,
            "deletions": 11,
            "changes": 30,
            "blob_url": "https://github.com/django/django/blob/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=29132ebdef0e0b9c09e456b05f0e6a22f1106a4f",
            "patch": "@@ -475,6 +475,14 @@ def autoinc_sql(self, table, column):\n         \"\"\"\n         return None\n \n+    def bulk_batch_size(self, fields, objs):\n+        \"\"\"\n+        Returns the maximum allowed batch size for the backend. The fields\n+        are the fields going to be inserted in the batch, the objs contains\n+        all the objects to be inserted.\n+        \"\"\"\n+        return len(objs)\n+\n     def cache_key_culling_sql(self):\n         \"\"\"\n         Returns a SQL query that retrieves the first cache key greater than the\n@@ -522,6 +530,17 @@ def deferrable_sql(self):\n         \"\"\"\n         return ''\n \n+    def distinct_sql(self, fields):\n+        \"\"\"\n+        Returns an SQL DISTINCT clause which removes duplicate rows from the\n+        result set. If any fields are given, only the given fields are being\n+        checked for duplicates.\n+        \"\"\"\n+        if fields:\n+            raise NotImplementedError('DISTINCT ON fields is not supported by this database backend')\n+        else:\n+            return 'DISTINCT'\n+\n     def drop_foreignkey_sql(self):\n         \"\"\"\n         Returns the SQL command that drops a foreign key.\n@@ -577,17 +596,6 @@ def fulltext_search_sql(self, field_name):\n         \"\"\"\n         raise NotImplementedError('Full-text search is not implemented for this database backend')\n \n-    def distinct_sql(self, fields):\n-        \"\"\"\n-        Returns an SQL DISTINCT clause which removes duplicate rows from the\n-        result set. If any fields are given, only the given fields are being\n-        checked for duplicates.\n-        \"\"\"\n-        if fields:\n-            raise NotImplementedError('DISTINCT ON fields is not supported by this database backend')\n-        else:\n-            return 'DISTINCT'\n-\n     def last_executed_query(self, cursor, sql, params):\n         \"\"\"\n         Returns a string of the query last executed by the given cursor, with"
        },
        {
            "sha": "60723124c1b1420da70944f9c7590d037ebcc568",
            "filename": "django/db/backends/sqlite3/base.py",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py?ref=29132ebdef0e0b9c09e456b05f0e6a22f1106a4f",
            "patch": "@@ -85,7 +85,7 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     supports_1000_query_parameters = False\n     supports_mixed_date_datetime_comparisons = False\n     has_bulk_insert = True\n-    can_combine_inserts_with_and_without_auto_increment_pk = True\n+    can_combine_inserts_with_and_without_auto_increment_pk = False\n \n     @cached_property\n     def supports_stddev(self):\n@@ -107,6 +107,13 @@ def supports_stddev(self):\n         return has_support\n \n class DatabaseOperations(BaseDatabaseOperations):\n+    def bulk_batch_size(self, fields, objs):\n+        \"\"\"\n+        SQLite has a compile-time default (SQLITE_LIMIT_VARIABLE_NUMBER) of\n+        999 variables per query.\n+        \"\"\"\n+        return (999 // len(fields)) if len(fields) > 0 else len(objs)\n+\n     def date_extract_sql(self, lookup_type, field_name):\n         # sqlite doesn't support extract, so we fake it with the user-defined\n         # function django_extract that's registered in connect(). Note that"
        },
        {
            "sha": "ebe61a12266548f0958ac21e4a8d038353f70daf",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 23,
            "deletions": 6,
            "changes": 29,
            "blob_url": "https://github.com/django/django/blob/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=29132ebdef0e0b9c09e456b05f0e6a22f1106a4f",
            "patch": "@@ -388,7 +388,7 @@ def create(self, **kwargs):\n         obj.save(force_insert=True, using=self.db)\n         return obj\n \n-    def bulk_create(self, objs):\n+    def bulk_create(self, objs, batch_size=None):\n         \"\"\"\n         Inserts each of the instances into the database. This does *not* call\n         save() on each of the instances, does not send any pre/post save\n@@ -401,8 +401,10 @@ def bulk_create(self, objs):\n         # this could be implemented if you didn't have an autoincrement pk,\n         # and 2) you could do it by doing O(n) normal inserts into the parent\n         # tables to get the primary keys back, and then doing a single bulk\n-        # insert into the childmost table. We're punting on these for now\n-        # because they are relatively rare cases.\n+        # insert into the childmost table. Some databases might allow doing\n+        # this by using RETURNING clause for the insert query. We're punting\n+        # on these for now because they are relatively rare cases.\n+        assert batch_size is None or batch_size > 0\n         if self.model._meta.parents:\n             raise ValueError(\"Can't bulk create an inherited model\")\n         if not objs:\n@@ -418,13 +420,14 @@ def bulk_create(self, objs):\n         try:\n             if (connection.features.can_combine_inserts_with_and_without_auto_increment_pk\n                 and self.model._meta.has_auto_field):\n-                self.model._base_manager._insert(objs, fields=fields, using=self.db)\n+                self._batched_insert(objs, fields, batch_size)\n             else:\n                 objs_with_pk, objs_without_pk = partition(lambda o: o.pk is None, objs)\n                 if objs_with_pk:\n-                    self.model._base_manager._insert(objs_with_pk, fields=fields, using=self.db)\n+                    self._batched_insert(objs_with_pk, fields, batch_size)\n                 if objs_without_pk:\n-                    self.model._base_manager._insert(objs_without_pk, fields=[f for f in fields if not isinstance(f, AutoField)], using=self.db)\n+                    fields= [f for f in fields if not isinstance(f, AutoField)]\n+                    self._batched_insert(objs_without_pk, fields, batch_size)\n             if forced_managed:\n                 transaction.commit(using=self.db)\n             else:\n@@ -860,6 +863,20 @@ def db(self):\n     ###################\n     # PRIVATE METHODS #\n     ###################\n+    def _batched_insert(self, objs, fields, batch_size):\n+        \"\"\"\n+        A little helper method for bulk_insert to insert the bulk one batch\n+        at a time. Inserts recursively a batch from the front of the bulk and\n+        then _batched_insert() the remaining objects again.\n+        \"\"\"\n+        if not objs:\n+            return\n+        ops = connections[self.db].ops\n+        batch_size = (batch_size or max(ops.bulk_batch_size(fields, objs), 1))\n+        for batch in [objs[i:i+batch_size]\n+                      for i in range(0, len(objs), batch_size)]:\n+            self.model._base_manager._insert(batch, fields=fields,\n+                                             using=self.db)\n \n     def _clone(self, klass=None, setup=False, **kwargs):\n         if klass is None:"
        },
        {
            "sha": "8c188c67c3998ba8e04b347b7806804eb5fa2db1",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 6,
            "deletions": 14,
            "changes": 20,
            "blob_url": "https://github.com/django/django/blob/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=29132ebdef0e0b9c09e456b05f0e6a22f1106a4f",
            "patch": "@@ -1350,7 +1350,7 @@ has a side effect on your data. For more, see `Safe methods`_ in the HTTP spec.\n bulk_create\n ~~~~~~~~~~~\n \n-.. method:: bulk_create(objs)\n+.. method:: bulk_create(objs, batch_size=None)\n \n .. versionadded:: 1.4\n \n@@ -1372,20 +1372,12 @@ This has a number of caveats though:\n * If the model's primary key is an :class:`~django.db.models.AutoField` it\n   does not retrieve and set the primary key attribute, as ``save()`` does.\n \n-.. admonition:: Limits of SQLite\n+The ``batch_size`` parameter controls how many objects are created in single\n+query. The default is to create all objects in one batch, except for SQLite\n+where the default is such that at maximum 999 variables per query is used.\n \n-    SQLite sets a limit on the number of parameters per SQL statement. The\n-    maximum is defined by the SQLITE_MAX_VARIABLE_NUMBER_ compilation option,\n-    which defaults to 999. For instance, if your model has 8 fields (including\n-    the primary key), you cannot create more than 999 // 8 = 124 instances at\n-    a time. If you exceed this limit, you'll get an exception::\n-\n-        django.db.utils.DatabaseError: too many SQL variables\n-\n-    If your application's performance requirements exceed SQLite's limits, you\n-    should switch to another database engine, such as PostgreSQL.\n-\n-.. _SQLITE_MAX_VARIABLE_NUMBER: http://sqlite.org/limits.html#max_variable_number\n+.. versionadded:: 1.5\n+    The ``batch_size`` parameter was added in version 1.5.\n \n count\n ~~~~~"
        },
        {
            "sha": "fd9ae4f0389d839d91d1803b5df7caa900581db5",
            "filename": "docs/releases/1.5.txt",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/docs%2Freleases%2F1.5.txt",
            "raw_url": "https://github.com/django/django/raw/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/docs%2Freleases%2F1.5.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.5.txt?ref=29132ebdef0e0b9c09e456b05f0e6a22f1106a4f",
            "patch": "@@ -106,6 +106,11 @@ Django 1.5 also includes several smaller improvements worth noting:\n * The :ref:`receiver <connecting-receiver-functions>` decorator is now able to\n   connect to more than one signal by supplying a list of signals.\n \n+* :meth:`QuerySet.bulk_create()\n+  <django.db.models.query.QuerySet.bulk_create>` has now a batch_size\n+  argument. By default the batch_size is unlimited except for SQLite where\n+  single batch is limited so that 999 parameters per query isn't exceeded.\n+\n Backwards incompatible changes in 1.5\n =====================================\n "
        },
        {
            "sha": "bc685bbbe42d0f4e8d55dbd471317c56f95679e8",
            "filename": "tests/regressiontests/bulk_create/models.py",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/tests%2Fregressiontests%2Fbulk_create%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/tests%2Fregressiontests%2Fbulk_create%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fbulk_create%2Fmodels.py?ref=29132ebdef0e0b9c09e456b05f0e6a22f1106a4f",
            "patch": "@@ -18,4 +18,8 @@ class Pizzeria(Restaurant):\n     pass\n \n class State(models.Model):\n-    two_letter_code = models.CharField(max_length=2, primary_key=True)\n\\ No newline at end of file\n+    two_letter_code = models.CharField(max_length=2, primary_key=True)\n+\n+class TwoFields(models.Model):\n+    f1 = models.IntegerField(unique=True)\n+    f2 = models.IntegerField(unique=True)"
        },
        {
            "sha": "33108ea9b0ecfd1c9884b7fda28c30d28aa7510e",
            "filename": "tests/regressiontests/bulk_create/tests.py",
            "status": "modified",
            "additions": 43,
            "deletions": 3,
            "changes": 46,
            "blob_url": "https://github.com/django/django/blob/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/tests%2Fregressiontests%2Fbulk_create%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/tests%2Fregressiontests%2Fbulk_create%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fbulk_create%2Ftests.py?ref=29132ebdef0e0b9c09e456b05f0e6a22f1106a4f",
            "patch": "@@ -2,9 +2,11 @@\n \n from operator import attrgetter\n \n-from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n+from django.db import connection\n+from django.test import TestCase, skipIfDBFeature\n+from django.test.utils import override_settings\n \n-from .models import Country, Restaurant, Pizzeria, State\n+from .models import Country, Restaurant, Pizzeria, State, TwoFields\n \n \n class BulkCreateTests(TestCase):\n@@ -27,7 +29,6 @@ def test_simple(self):\n         self.assertEqual(created, [])\n         self.assertEqual(Country.objects.count(), 4)\n \n-    @skipUnlessDBFeature(\"has_bulk_insert\")\n     def test_efficiency(self):\n         with self.assertNumQueries(1):\n             Country.objects.bulk_create(self.data)\n@@ -69,3 +70,42 @@ def test_zero_as_autoval(self):\n         invalid_country = Country(id=0, name='Poland', iso_two_letter='PL')\n         with self.assertRaises(ValueError):\n             Country.objects.bulk_create([valid_country, invalid_country])\n+\n+    def test_large_batch(self):\n+        with override_settings(DEBUG=True):\n+            connection.queries = []\n+            TwoFields.objects.bulk_create([\n+                   TwoFields(f1=i, f2=i+1) for i in range(0, 1001)\n+                ])\n+            self.assertTrue(len(connection.queries) < 10)\n+        self.assertEqual(TwoFields.objects.count(), 1001)\n+        self.assertEqual(\n+            TwoFields.objects.filter(f1__gte=450, f1__lte=550).count(),\n+            101)\n+        self.assertEqual(TwoFields.objects.filter(f2__gte=901).count(), 101)\n+\n+    def test_large_batch_mixed(self):\n+        \"\"\"\n+        Test inserting a large batch with objects having primary key set\n+        mixed together with objects without PK set.\n+        \"\"\"\n+        with override_settings(DEBUG=True):\n+            connection.queries = []\n+            TwoFields.objects.bulk_create([\n+                TwoFields(id=i if i % 2 == 0 else None, f1=i, f2=i+1)\n+                for i in range(100000, 101000)])\n+            self.assertTrue(len(connection.queries) < 10)\n+        self.assertEqual(TwoFields.objects.count(), 1000)\n+        # We can't assume much about the ID's created, except that the above\n+        # created IDs must exist.\n+        id_range = range(100000, 101000, 2)\n+        self.assertEqual(TwoFields.objects.filter(id__in=id_range).count(), 500)\n+        self.assertEqual(TwoFields.objects.exclude(id__in=id_range).count(), 500)\n+\n+    def test_explicit_batch_size(self):\n+        objs = [TwoFields(f1=i, f2=i) for i in range(0, 100)]\n+        with self.assertNumQueries(2):\n+            TwoFields.objects.bulk_create(objs, 50)\n+        TwoFields.objects.all().delete()\n+        with self.assertNumQueries(1):\n+            TwoFields.objects.bulk_create(objs, len(objs))"
        },
        {
            "sha": "1582993dfc3fcc5fc2550d32b3efe3d9706f220a",
            "filename": "tests/regressiontests/queries/tests.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/29132ebdef0e0b9c09e456b05f0e6a22f1106a4f/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Ftests.py?ref=29132ebdef0e0b9c09e456b05f0e6a22f1106a4f",
            "patch": "@@ -1879,8 +1879,7 @@ def test_ticket14244(self):\n         # Test that the \"in\" lookup works with lists of 1000 items or more.\n         Number.objects.all().delete()\n         numbers = range(2500)\n-        for num in numbers:\n-            _ = Number.objects.create(num=num)\n+        Number.objects.bulk_create(Number(num=num) for num in numbers)\n         self.assertEqual(\n             Number.objects.filter(num__in=numbers[:1000]).count(),\n             1000"
        }
    ],
    "stats": {
        "total": 148,
        "additions": 110,
        "deletions": 38
    }
}