{
    "author": "claudep",
    "message": "Fixed #5524 -- Do not remove cleaned_data when a form fails validation\n\ncleaned_data is no longer deleted when form validation fails but only\ncontains the data that did validate.\nThanks to the various contributors to this patch (see ticket).",
    "sha": "121fd109de09ece4e263e508f9034df9b583da46",
    "files": [
        {
            "sha": "ee93479cbd73c0cf8413b5bc7f76e1e644359c34",
            "filename": "django/contrib/formtools/tests/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/121fd109de09ece4e263e508f9034df9b583da46/django%2Fcontrib%2Fformtools%2Ftests%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/121fd109de09ece4e263e508f9034df9b583da46/django%2Fcontrib%2Fformtools%2Ftests%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fformtools%2Ftests%2F__init__.py?ref=121fd109de09ece4e263e508f9034df9b583da46",
            "patch": "@@ -317,7 +317,7 @@ def test_14498(self):\n \n         class WizardWithProcessStep(TestWizardClass):\n             def process_step(self, request, form, step):\n-                that.assertTrue(hasattr(form, 'cleaned_data'))\n+                that.assertTrue(form.is_valid())\n                 reached[0] = True\n \n         wizard = WizardWithProcessStep([WizardPageOneForm,"
        },
        {
            "sha": "4d4cdbe3db5a7d95a6cb09bb259d503181f73bb3",
            "filename": "django/forms/forms.py",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/121fd109de09ece4e263e508f9034df9b583da46/django%2Fforms%2Fforms.py",
            "raw_url": "https://github.com/django/django/raw/121fd109de09ece4e263e508f9034df9b583da46/django%2Fforms%2Fforms.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fforms%2Fforms.py?ref=121fd109de09ece4e263e508f9034df9b583da46",
            "patch": "@@ -271,8 +271,6 @@ def full_clean(self):\n         self._clean_fields()\n         self._clean_form()\n         self._post_clean()\n-        if self._errors:\n-            del self.cleaned_data\n \n     def _clean_fields(self):\n         for name, field in self.fields.items():"
        },
        {
            "sha": "e6ae357d19218ba7ef779487d63ff6532ffbb469",
            "filename": "django/forms/models.py",
            "status": "modified",
            "additions": 12,
            "deletions": 13,
            "changes": 25,
            "blob_url": "https://github.com/django/django/blob/121fd109de09ece4e263e508f9034df9b583da46/django%2Fforms%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/121fd109de09ece4e263e508f9034df9b583da46/django%2Fforms%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fforms%2Fmodels.py?ref=121fd109de09ece4e263e508f9034df9b583da46",
            "patch": "@@ -506,7 +506,7 @@ def validate_unique(self):\n         all_unique_checks = set()\n         all_date_checks = set()\n         for form in self.forms:\n-            if not hasattr(form, 'cleaned_data'):\n+            if not form.is_valid():\n                 continue\n             exclude = form._get_validation_exclusions()\n             unique_checks, date_checks = form.instance._get_unique_checks(exclude=exclude)\n@@ -518,31 +518,29 @@ def validate_unique(self):\n         for uclass, unique_check in all_unique_checks:\n             seen_data = set()\n             for form in self.forms:\n-                # if the form doesn't have cleaned_data then we ignore it,\n-                # it's already invalid\n-                if not hasattr(form, \"cleaned_data\"):\n+                if not form.is_valid():\n                     continue\n                 # get data for each field of each of unique_check\n                 row_data = tuple([form.cleaned_data[field] for field in unique_check if field in form.cleaned_data])\n                 if row_data and not None in row_data:\n-                    # if we've aready seen it then we have a uniqueness failure\n+                    # if we've already seen it then we have a uniqueness failure\n                     if row_data in seen_data:\n                         # poke error messages into the right places and mark\n                         # the form as invalid\n                         errors.append(self.get_unique_error_message(unique_check))\n                         form._errors[NON_FIELD_ERRORS] = self.error_class([self.get_form_error()])\n-                        del form.cleaned_data\n-                        break\n+                        # remove the data from the cleaned_data dict since it was invalid\n+                        for field in unique_check:\n+                            if field in form.cleaned_data:\n+                                del form.cleaned_data[field]\n                     # mark the data as seen\n                     seen_data.add(row_data)\n         # iterate over each of the date checks now\n         for date_check in all_date_checks:\n             seen_data = set()\n             uclass, lookup, field, unique_for = date_check\n             for form in self.forms:\n-                # if the form doesn't have cleaned_data then we ignore it,\n-                # it's already invalid\n-                if not hasattr(self, 'cleaned_data'):\n+                if not form.is_valid():\n                     continue\n                 # see if we have data for both fields\n                 if (form.cleaned_data and form.cleaned_data[field] is not None\n@@ -556,14 +554,15 @@ def validate_unique(self):\n                     else:\n                         date_data = (getattr(form.cleaned_data[unique_for], lookup),)\n                     data = (form.cleaned_data[field],) + date_data\n-                    # if we've aready seen it then we have a uniqueness failure\n+                    # if we've already seen it then we have a uniqueness failure\n                     if data in seen_data:\n                         # poke error messages into the right places and mark\n                         # the form as invalid\n                         errors.append(self.get_date_error_message(date_check))\n                         form._errors[NON_FIELD_ERRORS] = self.error_class([self.get_form_error()])\n-                        del form.cleaned_data\n-                        break\n+                        # remove the data from the cleaned_data dict since it was invalid\n+                        del form.cleaned_data[field]\n+                    # mark the data as seen\n                     seen_data.add(data)\n         if errors:\n             raise ValidationError(errors)"
        },
        {
            "sha": "777d73e0150de7ff64c436138b281f8e558bb95b",
            "filename": "docs/ref/forms/api.txt",
            "status": "modified",
            "additions": 12,
            "deletions": 9,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/121fd109de09ece4e263e508f9034df9b583da46/docs%2Fref%2Fforms%2Fapi.txt",
            "raw_url": "https://github.com/django/django/raw/121fd109de09ece4e263e508f9034df9b583da46/docs%2Fref%2Fforms%2Fapi.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fforms%2Fapi.txt?ref=121fd109de09ece4e263e508f9034df9b583da46",
            "patch": "@@ -199,8 +199,8 @@ Note that any text-based field -- such as ``CharField`` or ``EmailField`` --\n always cleans the input into a Unicode string. We'll cover the encoding\n implications later in this document.\n \n-If your data does *not* validate, your ``Form`` instance will not have a\n-``cleaned_data`` attribute::\n+If your data does *not* validate, the ``cleaned_data`` dictionary contains\n+only the valid fields::\n \n     >>> data = {'subject': '',\n     ...         'message': 'Hi there',\n@@ -210,9 +210,12 @@ If your data does *not* validate, your ``Form`` instance will not have a\n     >>> f.is_valid()\n     False\n     >>> f.cleaned_data\n-    Traceback (most recent call last):\n-    ...\n-    AttributeError: 'ContactForm' object has no attribute 'cleaned_data'\n+    {'cc_myself': True, 'message': u'Hi there'}\n+\n+.. versionchanged:: 1.5\n+\n+Until Django 1.5, the ``cleaned_data`` attribute wasn't defined at all when\n+the ``Form`` didn't validate.\n \n ``cleaned_data`` will always *only* contain a key for fields defined in the\n ``Form``, even if you pass extra data when you define the ``Form``. In this\n@@ -232,9 +235,9 @@ but ``cleaned_data`` contains only the form's fields::\n     >>> f.cleaned_data # Doesn't contain extra_field_1, etc.\n     {'cc_myself': True, 'message': u'Hi there', 'sender': u'foo@example.com', 'subject': u'hello'}\n \n-``cleaned_data`` will include a key and value for *all* fields defined in the\n-``Form``, even if the data didn't include a value for fields that are not\n-required. In this example, the data dictionary doesn't include a value for the\n+When the ``Form`` is valid, ``cleaned_data`` will include a key and value for\n+*all* its fields, even if the data didn't include a value for some optional\n+fields. In this example, the data dictionary doesn't include a value for the\n ``nick_name`` field, but ``cleaned_data`` includes it, with an empty value::\n \n     >>> class OptionalPersonForm(Form):\n@@ -583,7 +586,7 @@ lazy developers -- they're not the only way a form object can be displayed.\n \n    Used to display HTML or access attributes for a single field of a\n    :class:`Form` instance.\n-   \n+\n    The :meth:`__unicode__` and :meth:`__str__` methods of this object displays\n    the HTML for this field.\n "
        },
        {
            "sha": "95424d0cd0deaa08b70fb7c154eac631277d3070",
            "filename": "docs/ref/forms/validation.txt",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/121fd109de09ece4e263e508f9034df9b583da46/docs%2Fref%2Fforms%2Fvalidation.txt",
            "raw_url": "https://github.com/django/django/raw/121fd109de09ece4e263e508f9034df9b583da46/docs%2Fref%2Fforms%2Fvalidation.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fforms%2Fvalidation.txt?ref=121fd109de09ece4e263e508f9034df9b583da46",
            "patch": "@@ -362,7 +362,9 @@ Secondly, once we have decided that the combined data in the two fields we are\n considering aren't valid, we must remember to remove them from the\n ``cleaned_data``.\n \n-In fact, Django will currently completely wipe out the ``cleaned_data``\n-dictionary if there are any errors in the form. However, this behavior may\n-change in the future, so it's not a bad idea to clean up after yourself in the\n-first place.\n+.. versionchanged:: 1.5\n+\n+Django used to remove the ``cleaned_data`` attribute entirely if there were\n+any errors in the form. Since version 1.5, ``cleaned_data`` is present even if\n+the form doesn't validate, but it contains only field values that did\n+validate."
        },
        {
            "sha": "3a9b2d859ae6341149489dd3ba58bbca2e99ed80",
            "filename": "docs/releases/1.5.txt",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/121fd109de09ece4e263e508f9034df9b583da46/docs%2Freleases%2F1.5.txt",
            "raw_url": "https://github.com/django/django/raw/121fd109de09ece4e263e508f9034df9b583da46/docs%2Freleases%2F1.5.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.5.txt?ref=121fd109de09ece4e263e508f9034df9b583da46",
            "patch": "@@ -239,6 +239,16 @@ database state behind or unit tests that rely on some form of state being\n preserved after the execution of other tests. Such tests are already very\n fragile, and must now be changed to be able to run independently.\n \n+`cleaned_data` dictionary kept for invalid forms\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The :attr:`~django.forms.Form.cleaned_data` dictionary is now always present\n+after form validation. When the form doesn't validate, it contains only the\n+fields that passed validation. You should test the success of the validation\n+with the :meth:`~django.forms.Form.is_valid()` method and not with the\n+presence or absence of the :attr:`~django.forms.Form.cleaned_data` attribute\n+on the form.\n+\n Miscellaneous\n ~~~~~~~~~~~~~\n "
        },
        {
            "sha": "1da7f583be4df3e7990f5bebbc444767ec8e44c6",
            "filename": "tests/modeltests/model_forms/tests.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/121fd109de09ece4e263e508f9034df9b583da46/tests%2Fmodeltests%2Fmodel_forms%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/121fd109de09ece4e263e508f9034df9b583da46/tests%2Fmodeltests%2Fmodel_forms%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fmodel_forms%2Ftests.py?ref=121fd109de09ece4e263e508f9034df9b583da46",
            "patch": "@@ -638,8 +638,7 @@ def test_with_data(self):\n         f = BaseCategoryForm({'name': '', 'slug': 'not a slug!', 'url': 'foo'})\n         self.assertEqual(f.errors['name'], ['This field is required.'])\n         self.assertEqual(f.errors['slug'], [\"Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens.\"])\n-        with self.assertRaises(AttributeError):\n-            f.cleaned_data\n+        self.assertEqual(f.cleaned_data, {'url': 'foo'})\n         with self.assertRaises(ValueError):\n             f.save()\n         f = BaseCategoryForm({'name': '', 'slug': '', 'url': 'foo'})"
        },
        {
            "sha": "a8a28ba8060e834bcf28875f12afabe607986b12",
            "filename": "tests/regressiontests/forms/tests/forms.py",
            "status": "modified",
            "additions": 4,
            "deletions": 20,
            "changes": 24,
            "blob_url": "https://github.com/django/django/blob/121fd109de09ece4e263e508f9034df9b583da46/tests%2Fregressiontests%2Fforms%2Ftests%2Fforms.py",
            "raw_url": "https://github.com/django/django/raw/121fd109de09ece4e263e508f9034df9b583da46/tests%2Fregressiontests%2Fforms%2Ftests%2Fforms.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fforms%2Ftests%2Fforms.py?ref=121fd109de09ece4e263e508f9034df9b583da46",
            "patch": "@@ -82,11 +82,7 @@ def test_empty_dict(self):\n         self.assertEqual(p.errors['last_name'], ['This field is required.'])\n         self.assertEqual(p.errors['birthday'], ['This field is required.'])\n         self.assertFalse(p.is_valid())\n-        try:\n-            p.cleaned_data\n-            self.fail('Attempts to access cleaned_data when validation fails should fail.')\n-        except AttributeError:\n-            pass\n+        self.assertEqual(p.cleaned_data, {})\n         self.assertHTMLEqual(str(p), \"\"\"<tr><th><label for=\"id_first_name\">First name:</label></th><td><ul class=\"errorlist\"><li>This field is required.</li></ul><input type=\"text\" name=\"first_name\" id=\"id_first_name\" /></td></tr>\n <tr><th><label for=\"id_last_name\">Last name:</label></th><td><ul class=\"errorlist\"><li>This field is required.</li></ul><input type=\"text\" name=\"last_name\" id=\"id_last_name\" /></td></tr>\n <tr><th><label for=\"id_birthday\">Birthday:</label></th><td><ul class=\"errorlist\"><li>This field is required.</li></ul><input type=\"text\" name=\"birthday\" id=\"id_birthday\" /></td></tr>\"\"\")\n@@ -145,11 +141,7 @@ def test_unicode_values(self):\n   * This field is required.\n * birthday\n   * This field is required.\"\"\")\n-        try:\n-            p.cleaned_data\n-            self.fail('Attempts to access cleaned_data when validation fails should fail.')\n-        except AttributeError:\n-            pass\n+        self.assertEqual(p.cleaned_data, {'last_name': 'Lennon'})\n         self.assertEqual(p['first_name'].errors, ['This field is required.'])\n         self.assertHTMLEqual(p['first_name'].errors.as_ul(), '<ul class=\"errorlist\"><li>This field is required.</li></ul>')\n         self.assertEqual(p['first_name'].errors.as_text(), '* This field is required.')\n@@ -1678,11 +1670,7 @@ class SongForm(Form):\n         form = SongForm(data, empty_permitted=False)\n         self.assertFalse(form.is_valid())\n         self.assertEqual(form.errors, {'name': ['This field is required.'], 'artist': ['This field is required.']})\n-        try:\n-            form.cleaned_data\n-            self.fail('Attempts to access cleaned_data when validation fails should fail.')\n-        except AttributeError:\n-            pass\n+        self.assertEqual(form.cleaned_data, {})\n \n         # Now let's show what happens when empty_permitted=True and the form is empty.\n         form = SongForm(data, empty_permitted=True)\n@@ -1696,11 +1684,7 @@ class SongForm(Form):\n         form = SongForm(data, empty_permitted=False)\n         self.assertFalse(form.is_valid())\n         self.assertEqual(form.errors, {'name': ['This field is required.']})\n-        try:\n-            form.cleaned_data\n-            self.fail('Attempts to access cleaned_data when validation fails should fail.')\n-        except AttributeError:\n-            pass\n+        self.assertEqual(form.cleaned_data, {'artist': 'The Doors'})\n \n         # If a field is not given in the data then None is returned for its data. Lets\n         # make sure that when checking for empty_permitted that None is treated"
        }
    ],
    "stats": {
        "total": 97,
        "additions": 46,
        "deletions": 51
    }
}