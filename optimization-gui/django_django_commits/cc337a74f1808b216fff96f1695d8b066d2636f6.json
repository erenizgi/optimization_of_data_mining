{
    "author": "freakboy3742",
    "message": "Fixed #19069 -- Improved the error message when trying to query a swapped model.\n\nThanks to Preston Holmes for the suggestion.",
    "sha": "cc337a74f1808b216fff96f1695d8b066d2636f6",
    "files": [
        {
            "sha": "8da8af487c845d4c2e3831f47aec97d22b39b4ed",
            "filename": "django/db/models/manager.py",
            "status": "modified",
            "additions": 35,
            "deletions": 2,
            "changes": 37,
            "blob_url": "https://github.com/django/django/blob/cc337a74f1808b216fff96f1695d8b066d2636f6/django%2Fdb%2Fmodels%2Fmanager.py",
            "raw_url": "https://github.com/django/django/raw/cc337a74f1808b216fff96f1695d8b066d2636f6/django%2Fdb%2Fmodels%2Fmanager.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fmanager.py?ref=cc337a74f1808b216fff96f1695d8b066d2636f6",
            "patch": "@@ -13,7 +13,11 @@ def ensure_default_manager(sender, **kwargs):\n     _default_manager if it's not a subclass of Manager).\n     \"\"\"\n     cls = sender\n-    if cls._meta.abstract or cls._meta.swapped:\n+    if cls._meta.abstract:\n+        setattr(cls, 'objects', AbstractManagerDescriptor(cls))\n+        return\n+    elif cls._meta.swapped:\n+        setattr(cls, 'objects', SwappedManagerDescriptor(cls))\n         return\n     if not getattr(cls, '_default_manager', None):\n         # Create the default manager, if needed.\n@@ -58,7 +62,12 @@ def contribute_to_class(self, model, name):\n         # TODO: Use weakref because of possible memory leak / circular reference.\n         self.model = model\n         # Only contribute the manager if the model is concrete\n-        if not model._meta.abstract and not model._meta.swapped:\n+        if model._meta.abstract:\n+            setattr(model, name, AbstractManagerDescriptor(model))\n+        elif model._meta.swapped:\n+            setattr(model, name, SwappedManagerDescriptor(model))\n+        else:\n+        # if not model._meta.abstract and not model._meta.swapped:\n             setattr(model, name, ManagerDescriptor(self))\n         if not getattr(model, '_default_manager', None) or self.creation_counter < model._default_manager.creation_counter:\n             model._default_manager = self\n@@ -224,6 +233,30 @@ def __get__(self, instance, type=None):\n         return self.manager\n \n \n+class AbstractManagerDescriptor(object):\n+    # This class provides a better error message when you try to access a\n+    # manager on an abstract model.\n+    def __init__(self, model):\n+        self.model = model\n+\n+    def __get__(self, instance, type=None):\n+        raise AttributeError(\"Manager isn't available; %s is abstract\" % (\n+            self.model._meta.object_name,\n+        ))\n+\n+\n+class SwappedManagerDescriptor(object):\n+    # This class provides a better error message when you try to access a\n+    # manager on a swapped model.\n+    def __init__(self, model):\n+        self.model = model\n+\n+    def __get__(self, instance, type=None):\n+        raise AttributeError(\"Manager isn't available; %s has been swapped for '%s'\" % (\n+            self.model._meta.object_name, self.model._meta.swapped\n+        ))\n+\n+\n class EmptyManager(Manager):\n     def get_query_set(self):\n         return self.get_empty_query_set()"
        },
        {
            "sha": "d72970d86e93142518162a02504ee2565f4bf451",
            "filename": "tests/regressiontests/managers_regress/models.py",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/cc337a74f1808b216fff96f1695d8b066d2636f6/tests%2Fregressiontests%2Fmanagers_regress%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/cc337a74f1808b216fff96f1695d8b066d2636f6/tests%2Fregressiontests%2Fmanagers_regress%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fmanagers_regress%2Fmodels.py?ref=cc337a74f1808b216fff96f1695d8b066d2636f6",
            "patch": "@@ -10,14 +10,17 @@ class OnlyFred(models.Manager):\n     def get_query_set(self):\n         return super(OnlyFred, self).get_query_set().filter(name='fred')\n \n+\n class OnlyBarney(models.Manager):\n     def get_query_set(self):\n         return super(OnlyBarney, self).get_query_set().filter(name='barney')\n \n+\n class Value42(models.Manager):\n     def get_query_set(self):\n         return super(Value42, self).get_query_set().filter(value=42)\n \n+\n class AbstractBase1(models.Model):\n     name = models.CharField(max_length=50)\n \n@@ -29,6 +32,7 @@ class Meta:\n     manager2 = OnlyBarney()\n     objects = models.Manager()\n \n+\n class AbstractBase2(models.Model):\n     value = models.IntegerField()\n \n@@ -38,13 +42,15 @@ class Meta:\n     # Custom manager\n     restricted = Value42()\n \n+\n # No custom manager on this class to make sure the default case doesn't break.\n class AbstractBase3(models.Model):\n     comment = models.CharField(max_length=50)\n \n     class Meta:\n         abstract = True\n \n+\n @python_2_unicode_compatible\n class Parent(models.Model):\n     name = models.CharField(max_length=50)\n@@ -54,6 +60,7 @@ class Parent(models.Model):\n     def __str__(self):\n         return self.name\n \n+\n # Managers from base classes are inherited and, if no manager is specified\n # *and* the parent has a manager specified, the first one (in the MRO) will\n # become the default.\n@@ -64,20 +71,23 @@ class Child1(AbstractBase1):\n     def __str__(self):\n         return self.data\n \n+\n @python_2_unicode_compatible\n class Child2(AbstractBase1, AbstractBase2):\n     data = models.CharField(max_length=25)\n \n     def __str__(self):\n         return self.data\n \n+\n @python_2_unicode_compatible\n class Child3(AbstractBase1, AbstractBase3):\n     data = models.CharField(max_length=25)\n \n     def __str__(self):\n         return self.data\n \n+\n @python_2_unicode_compatible\n class Child4(AbstractBase1):\n     data = models.CharField(max_length=25)\n@@ -89,6 +99,7 @@ class Child4(AbstractBase1):\n     def __str__(self):\n         return self.data\n \n+\n @python_2_unicode_compatible\n class Child5(AbstractBase3):\n     name = models.CharField(max_length=25)\n@@ -99,10 +110,12 @@ class Child5(AbstractBase3):\n     def __str__(self):\n         return self.name\n \n+\n # Will inherit managers from AbstractBase1, but not Child4.\n class Child6(Child4):\n     value = models.IntegerField()\n \n+\n # Will not inherit default manager from parent.\n class Child7(Parent):\n     pass"
        },
        {
            "sha": "f3721a4c01ab0151df1c558034202fc49a620ddc",
            "filename": "tests/regressiontests/managers_regress/tests.py",
            "status": "modified",
            "additions": 153,
            "deletions": 15,
            "changes": 168,
            "blob_url": "https://github.com/django/django/blob/cc337a74f1808b216fff96f1695d8b066d2636f6/tests%2Fregressiontests%2Fmanagers_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/cc337a74f1808b216fff96f1695d8b066d2636f6/tests%2Fregressiontests%2Fmanagers_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fmanagers_regress%2Ftests.py?ref=cc337a74f1808b216fff96f1695d8b066d2636f6",
            "patch": "@@ -1,26 +1,42 @@\n from __future__ import absolute_import\n+import copy\n \n+from django.conf import settings\n+from django.db import models\n+from django.db.models.loading import cache\n from django.test import TestCase\n+from django.test.utils import override_settings\n \n-from .models import Child1, Child2, Child3, Child4, Child5, Child6, Child7\n+from .models import (\n+    Child1,\n+    Child2,\n+    Child3,\n+    Child4,\n+    Child5,\n+    Child6,\n+    Child7,\n+    AbstractBase1,\n+    AbstractBase2,\n+    AbstractBase3,\n+)\n \n \n class ManagersRegressionTests(TestCase):\n     def test_managers(self):\n-        a1 = Child1.objects.create(name='fred', data='a1')\n-        a2 = Child1.objects.create(name='barney', data='a2')\n-        b1 = Child2.objects.create(name='fred', data='b1', value=1)\n-        b2 = Child2.objects.create(name='barney', data='b2', value=42)\n-        c1 = Child3.objects.create(name='fred', data='c1', comment='yes')\n-        c2 = Child3.objects.create(name='barney', data='c2', comment='no')\n-        d1 = Child4.objects.create(name='fred', data='d1')\n-        d2 = Child4.objects.create(name='barney', data='d2')\n-        e1 = Child5.objects.create(name='fred', comment='yes')\n-        e2 = Child5.objects.create(name='barney', comment='no')\n-        f1 = Child6.objects.create(name='fred', data='f1', value=42)\n-        f2 = Child6.objects.create(name='barney', data='f2', value=42)\n-        g1 = Child7.objects.create(name='fred')\n-        g2 = Child7.objects.create(name='barney')\n+        Child1.objects.create(name='fred', data='a1')\n+        Child1.objects.create(name='barney', data='a2')\n+        Child2.objects.create(name='fred', data='b1', value=1)\n+        Child2.objects.create(name='barney', data='b2', value=42)\n+        Child3.objects.create(name='fred', data='c1', comment='yes')\n+        Child3.objects.create(name='barney', data='c2', comment='no')\n+        Child4.objects.create(name='fred', data='d1')\n+        Child4.objects.create(name='barney', data='d2')\n+        Child5.objects.create(name='fred', comment='yes')\n+        Child5.objects.create(name='barney', comment='no')\n+        Child6.objects.create(name='fred', data='f1', value=42)\n+        Child6.objects.create(name='barney', data='f2', value=42)\n+        Child7.objects.create(name='fred')\n+        Child7.objects.create(name='barney')\n \n         self.assertQuerysetEqual(Child1.manager1.all(), [\"<Child1: a1>\"])\n         self.assertQuerysetEqual(Child1.manager2.all(), [\"<Child1: a2>\"])\n@@ -54,3 +70,125 @@ def test_managers(self):\n                 \"<Child7: fred>\"\n             ]\n         )\n+\n+    def test_abstract_manager(self):\n+        # Accessing the manager on an abstract model should\n+        # raise an attribute error with an appropriate message.\n+        try:\n+            AbstractBase3.objects.all()\n+            self.fail('Should raise an AttributeError')\n+        except AttributeError as e:\n+            # This error message isn't ideal, but if the model is abstract and\n+            # a lot of the class instantiation logic isn't invoked; if the\n+            # manager is implied, then we don't get a hook to install the\n+            # error-raising manager.\n+            self.assertEqual(str(e), \"type object 'AbstractBase3' has no attribute 'objects'\")\n+\n+    def test_custom_abstract_manager(self):\n+        # Accessing the manager on an abstract model with an custom\n+        # manager should raise an attribute error with an appropriate\n+        # message.\n+        try:\n+            AbstractBase2.restricted.all()\n+            self.fail('Should raise an AttributeError')\n+        except AttributeError as e:\n+            self.assertEqual(str(e), \"Manager isn't available; AbstractBase2 is abstract\")\n+\n+    def test_explicit_abstract_manager(self):\n+        # Accessing the manager on an abstract model with an explicit\n+        # manager should raise an attribute error with an appropriate\n+        # message.\n+        try:\n+            AbstractBase1.objects.all()\n+            self.fail('Should raise an AttributeError')\n+        except AttributeError as e:\n+            self.assertEqual(str(e), \"Manager isn't available; AbstractBase1 is abstract\")\n+\n+    def test_swappable_manager(self):\n+        try:\n+            # This test adds dummy models to the app cache. These\n+            # need to be removed in order to prevent bad interactions\n+            # with the flush operation in other tests.\n+            old_app_models = copy.deepcopy(cache.app_models)\n+            old_app_store = copy.deepcopy(cache.app_store)\n+\n+            settings.TEST_SWAPPABLE_MODEL = 'managers_regress.Parent'\n+\n+            class SwappableModel(models.Model):\n+                class Meta:\n+                    swappable = 'TEST_SWAPPABLE_MODEL'\n+\n+            # Accessing the manager on a swappable model should\n+            # raise an attribute error with a helpful message\n+            try:\n+                SwappableModel.objects.all()\n+                self.fail('Should raise an AttributeError')\n+            except AttributeError as e:\n+                self.assertEqual(str(e), \"Manager isn't available; SwappableModel has been swapped for 'managers_regress.Parent'\")\n+\n+        finally:\n+            del settings.TEST_SWAPPABLE_MODEL\n+            cache.app_models = old_app_models\n+            cache.app_store = old_app_store\n+\n+    def test_custom_swappable_manager(self):\n+        try:\n+            # This test adds dummy models to the app cache. These\n+            # need to be removed in order to prevent bad interactions\n+            # with the flush operation in other tests.\n+            old_app_models = copy.deepcopy(cache.app_models)\n+            old_app_store = copy.deepcopy(cache.app_store)\n+\n+            settings.TEST_SWAPPABLE_MODEL = 'managers_regress.Parent'\n+\n+            class SwappableModel(models.Model):\n+\n+                stuff = models.Manager()\n+\n+                class Meta:\n+                    swappable = 'TEST_SWAPPABLE_MODEL'\n+\n+            # Accessing the manager on a swappable model with an\n+            # explicit manager should raise an attribute error with a\n+            # helpful message\n+            try:\n+                SwappableModel.stuff.all()\n+                self.fail('Should raise an AttributeError')\n+            except AttributeError as e:\n+                self.assertEqual(str(e), \"Manager isn't available; SwappableModel has been swapped for 'managers_regress.Parent'\")\n+\n+        finally:\n+            del settings.TEST_SWAPPABLE_MODEL\n+            cache.app_models = old_app_models\n+            cache.app_store = old_app_store\n+\n+    def test_explicit_swappable_manager(self):\n+        try:\n+            # This test adds dummy models to the app cache. These\n+            # need to be removed in order to prevent bad interactions\n+            # with the flush operation in other tests.\n+            old_app_models = copy.deepcopy(cache.app_models)\n+            old_app_store = copy.deepcopy(cache.app_store)\n+\n+            settings.TEST_SWAPPABLE_MODEL = 'managers_regress.Parent'\n+\n+            class SwappableModel(models.Model):\n+\n+                objects = models.Manager()\n+\n+                class Meta:\n+                    swappable = 'TEST_SWAPPABLE_MODEL'\n+\n+            # Accessing the manager on a swappable model with an\n+            # explicit manager should raise an attribute error with a\n+            # helpful message\n+            try:\n+                SwappableModel.objects.all()\n+                self.fail('Should raise an AttributeError')\n+            except AttributeError as e:\n+                self.assertEqual(str(e), \"Manager isn't available; SwappableModel has been swapped for 'managers_regress.Parent'\")\n+\n+        finally:\n+            del settings.TEST_SWAPPABLE_MODEL\n+            cache.app_models = old_app_models\n+            cache.app_store = old_app_store"
        }
    ],
    "stats": {
        "total": 218,
        "additions": 201,
        "deletions": 17
    }
}