{
    "author": "PaulMcMillan",
    "message": "Fixes #16827. Adds a length check to CSRF tokens before applying the santizing regex. Thanks to jedie for the report and zsiciarz for the initial patch.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17500 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "a77679dfaa963361b6daad6de0d7de1b53d4f104",
    "files": [
        {
            "sha": "1a4e06bbecb4b621822e15547e387ce8ae01223b",
            "filename": "django/middleware/csrf.py",
            "status": "modified",
            "additions": 27,
            "deletions": 25,
            "changes": 52,
            "blob_url": "https://github.com/django/django/blob/a77679dfaa963361b6daad6de0d7de1b53d4f104/django%2Fmiddleware%2Fcsrf.py",
            "raw_url": "https://github.com/django/django/raw/a77679dfaa963361b6daad6de0d7de1b53d4f104/django%2Fmiddleware%2Fcsrf.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fmiddleware%2Fcsrf.py?ref=a77679dfaa963361b6daad6de0d7de1b53d4f104",
            "patch": "@@ -14,22 +14,16 @@\n from django.utils.cache import patch_vary_headers\n from django.utils.http import same_origin\n from django.utils.log import getLogger\n-from django.utils.crypto import constant_time_compare\n+from django.utils.crypto import constant_time_compare, get_random_string\n \n logger = getLogger('django.request')\n \n-# Use the system (hardware-based) random number generator if it exists.\n-if hasattr(random, 'SystemRandom'):\n-    randrange = random.SystemRandom().randrange\n-else:\n-    randrange = random.randrange\n-_MAX_CSRF_KEY = 18446744073709551616L     # 2 << 63\n-\n REASON_NO_REFERER = \"Referer checking failed - no Referer.\"\n REASON_BAD_REFERER = \"Referer checking failed - %s does not match %s.\"\n REASON_NO_CSRF_COOKIE = \"CSRF cookie not set.\"\n REASON_BAD_TOKEN = \"CSRF token missing or incorrect.\"\n \n+CSRF_KEY_LENGTH = 32\n \n def _get_failure_view():\n     \"\"\"\n@@ -39,7 +33,7 @@ def _get_failure_view():\n \n \n def _get_new_csrf_key():\n-    return hashlib.md5(\"%s%s\" % (randrange(0, _MAX_CSRF_KEY), settings.SECRET_KEY)).hexdigest()\n+    return get_random_string(CSRF_KEY_LENGTH)\n \n \n def get_token(request):\n@@ -57,14 +51,15 @@ def get_token(request):\n \n \n def _sanitize_token(token):\n-    # Allow only alphanum, and ensure we return a 'str' for the sake of the post\n-    # processing middleware.\n-    token = re.sub('[^a-zA-Z0-9]', '', str(token.decode('ascii', 'ignore')))\n+    # Allow only alphanum, and ensure we return a 'str' for the sake\n+    # of the post processing middleware.\n+    if len(token) > CSRF_KEY_LENGTH:\n+        return _get_new_csrf_key()\n+    token = re.sub('[^a-zA-Z0-9]+', '', str(token.decode('ascii', 'ignore')))\n     if token == \"\":\n         # In case the cookie has been truncated to nothing at some point.\n         return _get_new_csrf_key()\n-    else:\n-        return token\n+    return token\n \n \n class CsrfViewMiddleware(object):\n@@ -94,26 +89,29 @@ def process_view(self, request, callback, callback_args, callback_kwargs):\n             return None\n \n         try:\n-            csrf_token = _sanitize_token(request.COOKIES[settings.CSRF_COOKIE_NAME])\n+            csrf_token = _sanitize_token(\n+                request.COOKIES[settings.CSRF_COOKIE_NAME])\n             # Use same token next time\n             request.META['CSRF_COOKIE'] = csrf_token\n         except KeyError:\n             csrf_token = None\n-            # Generate token and store it in the request, so it's available to the view.\n+            # Generate token and store it in the request, so it's\n+            # available to the view.\n             request.META[\"CSRF_COOKIE\"] = _get_new_csrf_key()\n \n         # Wait until request.META[\"CSRF_COOKIE\"] has been manipulated before\n         # bailing out, so that get_token still works\n         if getattr(callback, 'csrf_exempt', False):\n             return None\n \n-        # Assume that anything not defined as 'safe' by RC2616 needs protection.\n+        # Assume that anything not defined as 'safe' by RC2616 needs protection\n         if request.method not in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):\n             if getattr(request, '_dont_enforce_csrf_checks', False):\n-                # Mechanism to turn off CSRF checks for test suite.  It comes after\n-                # the creation of CSRF cookies, so that everything else continues to\n-                # work exactly the same (e.g. cookies are sent etc), but before the\n-                # any branches that call reject()\n+                # Mechanism to turn off CSRF checks for test suite.\n+                # It comes after the creation of CSRF cookies, so that\n+                # everything else continues to work exactly the same\n+                # (e.g. cookies are sent etc), but before the any\n+                # branches that call reject()\n                 return self._accept(request)\n \n             if request.is_secure():\n@@ -134,7 +132,8 @@ def process_view(self, request, callback, callback_args, callback_kwargs):\n                 # we can use strict Referer checking.\n                 referer = request.META.get('HTTP_REFERER')\n                 if referer is None:\n-                    logger.warning('Forbidden (%s): %s', REASON_NO_REFERER, request.path,\n+                    logger.warning('Forbidden (%s): %s',\n+                                   REASON_NO_REFERER, request.path,\n                         extra={\n                             'status_code': 403,\n                             'request': request,\n@@ -158,7 +157,8 @@ def process_view(self, request, callback, callback_args, callback_kwargs):\n                 # No CSRF cookie. For POST requests, we insist on a CSRF cookie,\n                 # and in this way we can avoid all CSRF attacks, including login\n                 # CSRF.\n-                logger.warning('Forbidden (%s): %s', REASON_NO_CSRF_COOKIE, request.path,\n+                logger.warning('Forbidden (%s): %s',\n+                               REASON_NO_CSRF_COOKIE, request.path,\n                     extra={\n                         'status_code': 403,\n                         'request': request,\n@@ -177,7 +177,8 @@ def process_view(self, request, callback, callback_args, callback_kwargs):\n                 request_csrf_token = request.META.get('HTTP_X_CSRFTOKEN', '')\n \n             if not constant_time_compare(request_csrf_token, csrf_token):\n-                logger.warning('Forbidden (%s): %s', REASON_BAD_TOKEN, request.path,\n+                logger.warning('Forbidden (%s): %s',\n+                               REASON_BAD_TOKEN, request.path,\n                     extra={\n                         'status_code': 403,\n                         'request': request,\n@@ -200,7 +201,8 @@ def process_response(self, request, response):\n         if not request.META.get(\"CSRF_COOKIE_USED\", False):\n             return response\n \n-        # Set the CSRF cookie even if it's already set, so we renew the expiry timer.\n+        # Set the CSRF cookie even if it's already set, so we renew\n+        # the expiry timer.\n         response.set_cookie(settings.CSRF_COOKIE_NAME,\n                             request.META[\"CSRF_COOKIE\"],\n                             max_age = 60 * 60 * 24 * 7 * 52,"
        },
        {
            "sha": "4fe11f428c15c0f4c4b364927a7e31cd35f0aa0d",
            "filename": "django/utils/crypto.py",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/django/django/blob/a77679dfaa963361b6daad6de0d7de1b53d4f104/django%2Futils%2Fcrypto.py",
            "raw_url": "https://github.com/django/django/raw/a77679dfaa963361b6daad6de0d7de1b53d4f104/django%2Futils%2Fcrypto.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fcrypto.py?ref=a77679dfaa963361b6daad6de0d7de1b53d4f104",
            "patch": "@@ -36,10 +36,11 @@ def salted_hmac(key_salt, value, secret=None):\n     return hmac.new(key, msg=value, digestmod=hashlib.sha1)\n \n \n-def get_random_string(length=12, allowed_chars='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):\n+def get_random_string(length=12,\n+                      allowed_chars='abcdefghijklmnopqrstuvwxyz'\n+                                    'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):\n     \"\"\"\n-    Returns a random string of length characters from the set of a-z, A-Z, 0-9\n-    for use as a salt.\n+    Returns a random string of length characters from the set of a-z, A-Z, 0-9.\n \n     The default length of 12 with the a-z, A-Z, 0-9 character set returns\n     a 71-bit salt. log_2((26+26+10)^12) =~ 71 bits"
        },
        {
            "sha": "71400ead8933f6e44ce040ea1c5b0648b91cb103",
            "filename": "tests/regressiontests/csrf_tests/tests.py",
            "status": "modified",
            "additions": 14,
            "deletions": 1,
            "changes": 15,
            "blob_url": "https://github.com/django/django/blob/a77679dfaa963361b6daad6de0d7de1b53d4f104/tests%2Fregressiontests%2Fcsrf_tests%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/a77679dfaa963361b6daad6de0d7de1b53d4f104/tests%2Fregressiontests%2Fcsrf_tests%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fcsrf_tests%2Ftests.py?ref=a77679dfaa963361b6daad6de0d7de1b53d4f104",
            "patch": "@@ -4,7 +4,7 @@\n from django.conf import settings\n from django.core.context_processors import csrf\n from django.http import HttpRequest, HttpResponse\n-from django.middleware.csrf import CsrfViewMiddleware\n+from django.middleware.csrf import CsrfViewMiddleware, CSRF_KEY_LENGTH\n from django.template import RequestContext, Template\n from django.test import TestCase\n from django.views.decorators.csrf import csrf_exempt, requires_csrf_token, ensure_csrf_cookie\n@@ -77,6 +77,19 @@ def _get_POST_request_with_token(self):\n     def _check_token_present(self, response, csrf_id=None):\n         self.assertContains(response, \"name='csrfmiddlewaretoken' value='%s'\" % (csrf_id or self._csrf_id))\n \n+    def test_process_view_token_too_long(self): \n+        \"\"\" \n+        Check that if the token is longer than expected, it is ignored and \n+        a new token is created. \n+        \"\"\" \n+        req = self._get_GET_no_csrf_cookie_request() \n+        req.COOKIES[settings.CSRF_COOKIE_NAME] = 'x' * 10000000 \n+        CsrfViewMiddleware().process_view(req, token_view, (), {}) \n+        resp = token_view(req) \n+        resp2 = CsrfViewMiddleware().process_response(req, resp) \n+        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, False) \n+        self.assertEqual(len(csrf_cookie.value), CSRF_KEY_LENGTH) \n+\n     def test_process_response_get_token_used(self):\n         \"\"\"\n         When get_token is used, check that the cookie is created and headers"
        }
    ],
    "stats": {
        "total": 74,
        "additions": 45,
        "deletions": 29
    }
}