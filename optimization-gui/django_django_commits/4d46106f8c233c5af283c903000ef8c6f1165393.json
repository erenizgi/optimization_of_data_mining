{
    "author": "claudep",
    "message": "Fixed #17754 -- Refactored gis.measure\n\nThis refactoring does allow much easier MeasureBase subclassing.\nMany thanks to Ricardo di Virgilio for the initial patch.",
    "sha": "4d46106f8c233c5af283c903000ef8c6f1165393",
    "files": [
        {
            "sha": "ea0b01926cc4eb9dbdd8a94653a0ae46fab79102",
            "filename": "AUTHORS",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/4d46106f8c233c5af283c903000ef8c6f1165393/AUTHORS",
            "raw_url": "https://github.com/django/django/raw/4d46106f8c233c5af283c903000ef8c6f1165393/AUTHORS",
            "contents_url": "https://api.github.com/repos/django/django/contents/AUTHORS?ref=4d46106f8c233c5af283c903000ef8c6f1165393",
            "patch": "@@ -161,6 +161,7 @@ answer newbie questions, and generally made Django that much better:\n     Rajesh Dhawan <rajesh.dhawan@gmail.com>\n     Sander Dijkhuis <sander.dijkhuis@gmail.com>\n     Jordan Dimov <s3x3y1@gmail.com>\n+    Riccardo Di Virgilio\n     Nebojša Dorđević\n     dne@mayonnaise.net\n     dready <wil@mojipage.com>"
        },
        {
            "sha": "9efea504c7b7f939da94812bdf5a101481b49f37",
            "filename": "django/contrib/gis/measure.py",
            "status": "modified",
            "additions": 139,
            "deletions": 174,
            "changes": 313,
            "blob_url": "https://github.com/django/django/blob/4d46106f8c233c5af283c903000ef8c6f1165393/django%2Fcontrib%2Fgis%2Fmeasure.py",
            "raw_url": "https://github.com/django/django/raw/4d46106f8c233c5af283c903000ef8c6f1165393/django%2Fcontrib%2Fgis%2Fmeasure.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fmeasure.py?ref=4d46106f8c233c5af283c903000ef8c6f1165393",
            "patch": "@@ -30,7 +30,7 @@\n Distance and Area objects to allow for sensible and convienient calculation\n and conversions.\n \n-Authors: Robert Coup, Justin Bronn\n+Authors: Robert Coup, Justin Bronn, Riccardo Di Virgilio\n \n Inspired by GeoPy (http://exogen.case.edu/projects/geopy/)\n and Geoff Biggs' PhD work on dimensioned units for robotics.\n@@ -40,13 +40,134 @@\n \n from django.utils.functional import total_ordering\n \n+NUMERIC_TYPES = (int, float, long, Decimal)\n+AREA_PREFIX = \"sq_\"\n+\n+def pretty_name(obj):\n+    return obj.__name__ if obj.__class__ == type else obj.__class__.__name__\n+\n+\n+@total_ordering\n class MeasureBase(object):\n+    STANDARD_UNIT = None\n+    ALIAS  = {}\n+    UNITS  = {}\n+    LALIAS = {}\n+\n+    def __init__(self, default_unit=None, **kwargs):\n+        value, self._default_unit = self.default_units(kwargs)\n+        setattr(self, self.STANDARD_UNIT, value)\n+        if default_unit and isinstance(default_unit, basestring):\n+            self._default_unit = default_unit\n+\n+    def _get_standard(self):\n+        return getattr(self, self.STANDARD_UNIT)\n+\n+    def _set_standard(self, value):\n+        setattr(self, self.STANDARD_UNIT, value)\n+\n+    standard = property(_get_standard, _set_standard)\n+\n+    def __getattr__(self, name):\n+        if name in self.UNITS:\n+            return self.standard / self.UNITS[name]\n+        else:\n+            raise AttributeError('Unknown unit type: %s' % name)\n+\n+    def __repr__(self):\n+        return '%s(%s=%s)' % (pretty_name(self), self._default_unit,\n+            getattr(self, self._default_unit))\n+\n+    def __str__(self):\n+        return '%s %s' % (getattr(self, self._default_unit), self._default_unit)\n+\n+    # **** Comparison methods ****\n+\n+    def __eq__(self, other):\n+        if isinstance(other, self.__class__):\n+            return self.standard == other.standard\n+        else:\n+            return NotImplemented\n+\n+    def __lt__(self, other):\n+        if isinstance(other, self.__class__):\n+            return self.standard < other.standard\n+        else:\n+            return NotImplemented\n+\n+    # **** Operators methods ****\n+\n+    def __add__(self, other):\n+        if isinstance(other, self.__class__):\n+            return self.__class__(default_unit=self._default_unit,\n+                **{self.STANDARD_UNIT: (self.standard + other.standard)})\n+        else:\n+            raise TypeError('%(class)s must be added with %(class)s' % {\"class\":pretty_name(self)})\n+\n+    def __iadd__(self, other):\n+        if isinstance(other, self.__class__):\n+            self.standard += other.standard\n+            return self\n+        else:\n+            raise TypeError('%(class)s must be added with %(class)s' % {\"class\":pretty_name(self)})\n+\n+    def __sub__(self, other):\n+        if isinstance(other, self.__class__):\n+            return self.__class__(default_unit=self._default_unit,\n+                **{self.STANDARD_UNIT: (self.standard - other.standard)})\n+        else:\n+            raise TypeError('%(class)s must be subtracted from %(class)s' % {\"class\":pretty_name(self)})\n+\n+    def __isub__(self, other):\n+        if isinstance(other, self.__class__):\n+            self.standard -= other.standard\n+            return self\n+        else:\n+            raise TypeError('%(class)s must be subtracted from %(class)s' % {\"class\":pretty_name(self)})\n+\n+    def __mul__(self, other):\n+        if isinstance(other, NUMERIC_TYPES):\n+            return self.__class__(default_unit=self._default_unit,\n+                **{self.STANDARD_UNIT: (self.standard * other)})\n+        else:\n+            raise TypeError('%(class)s must be multiplied with number' % {\"class\":pretty_name(self)})\n+\n+    def __imul__(self, other):\n+        if isinstance(other, NUMERIC_TYPES):\n+            self.standard *= float(other)\n+            return self\n+        else:\n+            raise TypeError('%(class)s must be multiplied with number' % {\"class\":pretty_name(self)})\n+\n+    def __rmul__(self, other):\n+        return self * other\n+\n+    def __div__(self, other):\n+        if isinstance(other, self.__class__):\n+            return self.standard / other.standard\n+        if isinstance(other, NUMERIC_TYPES):\n+            return self.__class__(default_unit=self._default_unit,\n+                **{self.STANDARD_UNIT: (self.standard / other)})\n+        else:\n+            raise TypeError('%(class)s must be divided with number or %(class)s' % {\"class\":pretty_name(self)})\n+\n+    def __idiv__(self, other):\n+        if isinstance(other, NUMERIC_TYPES):\n+            self.standard /= float(other)\n+            return self\n+        else:\n+            raise TypeError('%(class)s must be divided with number' % {\"class\":pretty_name(self)})\n+\n+    def __nonzero__(self):\n+        return bool(self.standard)\n+\n     def default_units(self, kwargs):\n         \"\"\"\n         Return the unit value and the default units specified\n         from the given keyword arguments dictionary.\n         \"\"\"\n         val = 0.0\n+        default_unit = self.STANDARD_UNIT\n         for unit, value in kwargs.iteritems():\n             if not isinstance(value, float): value = float(value)\n             if unit in self.UNITS:\n@@ -86,8 +207,8 @@ def unit_attname(cls, unit_str):\n         else:\n             raise Exception('Could not find a unit keyword associated with \"%s\"' % unit_str)\n \n-@total_ordering\n class Distance(MeasureBase):\n+    STANDARD_UNIT = \"m\"\n     UNITS = {\n         'chain' : 20.1168,\n         'chain_benoit' : 20.116782,\n@@ -163,189 +284,33 @@ class Distance(MeasureBase):\n         }\n     LALIAS = dict([(k.lower(), v) for k, v in ALIAS.items()])\n \n-    def __init__(self, default_unit=None, **kwargs):\n-        # The base unit is in meters.\n-        self.m, self._default_unit = self.default_units(kwargs)\n-        if default_unit and isinstance(default_unit, str):\n-            self._default_unit = default_unit\n-\n-    def __getattr__(self, name):\n-        if name in self.UNITS:\n-            return self.m / self.UNITS[name]\n-        else:\n-            raise AttributeError('Unknown unit type: %s' % name)\n-\n-    def __repr__(self):\n-        return 'Distance(%s=%s)' % (self._default_unit, getattr(self, self._default_unit))\n-\n-    def __str__(self):\n-        return '%s %s' % (getattr(self, self._default_unit), self._default_unit)\n-\n-    def __eq__(self, other):\n-        if isinstance(other, Distance):\n-            return self.m == other.m\n-        else:\n-            return NotImplemented\n-\n-    def __lt__(self, other):\n-        if isinstance(other, Distance):\n-            return self.m < other.m\n-        else:\n-            return NotImplemented\n-\n-    def __add__(self, other):\n-        if isinstance(other, Distance):\n-            return Distance(default_unit=self._default_unit, m=(self.m + other.m))\n-        else:\n-            raise TypeError('Distance must be added with Distance')\n-\n-    def __iadd__(self, other):\n-        if isinstance(other, Distance):\n-            self.m += other.m\n-            return self\n-        else:\n-            raise TypeError('Distance must be added with Distance')\n-\n-    def __sub__(self, other):\n-        if isinstance(other, Distance):\n-            return Distance(default_unit=self._default_unit, m=(self.m - other.m))\n-        else:\n-            raise TypeError('Distance must be subtracted from Distance')\n-\n-    def __isub__(self, other):\n-        if isinstance(other, Distance):\n-            self.m -= other.m\n-            return self\n-        else:\n-            raise TypeError('Distance must be subtracted from Distance')\n-\n     def __mul__(self, other):\n-        if isinstance(other, (int, float, long, Decimal)):\n-            return Distance(default_unit=self._default_unit, m=(self.m * float(other)))\n-        elif isinstance(other, Distance):\n-            return Area(default_unit='sq_' + self._default_unit, sq_m=(self.m * other.m))\n+        if isinstance(other, self.__class__):\n+            return Area(default_unit=AREA_PREFIX + self._default_unit,\n+                **{AREA_PREFIX + self.STANDARD_UNIT: (self.standard * other.standard)})\n+        elif isinstance(other, NUMERIC_TYPES):\n+            return self.__class__(default_unit=self._default_unit,\n+                **{self.STANDARD_UNIT: (self.standard * other)})\n         else:\n-            raise TypeError('Distance must be multiplied with number or Distance')\n+            raise TypeError('%(distance)s must be multiplied with number or %(distance)s' % {\n+                \"distance\" : pretty_name(self.__class__),\n+                })\n \n-    def __imul__(self, other):\n-        if isinstance(other, (int, float, long, Decimal)):\n-            self.m *= float(other)\n-            return self\n-        else:\n-            raise TypeError('Distance must be multiplied with number')\n \n-    def __rmul__(self, other):\n-        return self * other\n-\n-    def __div__(self, other):\n-        if isinstance(other, (int, float, long, Decimal)):\n-            return Distance(default_unit=self._default_unit, m=(self.m / float(other)))\n-        else:\n-            raise TypeError('Distance must be divided with number')\n-\n-    def __idiv__(self, other):\n-        if isinstance(other, (int, float, long, Decimal)):\n-            self.m /= float(other)\n-            return self\n-        else:\n-            raise TypeError('Distance must be divided with number')\n-\n-    def __nonzero__(self):\n-        return bool(self.m)\n-\n-@total_ordering\n class Area(MeasureBase):\n+    STANDARD_UNIT = AREA_PREFIX + Distance.STANDARD_UNIT\n     # Getting the square units values and the alias dictionary.\n-    UNITS = dict([('sq_%s' % k, v ** 2) for k, v in Distance.UNITS.items()])\n-    ALIAS = dict([(k, 'sq_%s' % v) for k, v in Distance.ALIAS.items()])\n+    UNITS = dict([('%s%s' % (AREA_PREFIX, k), v ** 2) for k, v in Distance.UNITS.items()])\n+    ALIAS = dict([(k, '%s%s' % (AREA_PREFIX, v)) for k, v in Distance.ALIAS.items()])\n     LALIAS = dict([(k.lower(), v) for k, v in ALIAS.items()])\n \n-    def __init__(self, default_unit=None, **kwargs):\n-        self.sq_m, self._default_unit = self.default_units(kwargs)\n-        if default_unit and isinstance(default_unit, str):\n-            self._default_unit = default_unit\n-\n-    def __getattr__(self, name):\n-        if name in self.UNITS:\n-            return self.sq_m / self.UNITS[name]\n-        else:\n-            raise AttributeError('Unknown unit type: ' + name)\n-\n-    def __repr__(self):\n-        return 'Area(%s=%s)' % (self._default_unit, getattr(self, self._default_unit))\n-\n-    def __str__(self):\n-        return '%s %s' % (getattr(self, self._default_unit), self._default_unit)\n-\n-    def __eq__(self, other):\n-        if isinstance(other, Area):\n-            return self.sq_m == other.sq_m\n-        else:\n-            return NotImplemented\n-\n-    def __lt__(self, other):\n-        if isinstance(other, Area):\n-            return self.sq_m < other.sq_m\n-        else:\n-            return NotImplemented\n-\n-    def __add__(self, other):\n-        if isinstance(other, Area):\n-            return Area(default_unit=self._default_unit, sq_m=(self.sq_m + other.sq_m))\n-        else:\n-            raise TypeError('Area must be added with Area')\n-\n-    def __iadd__(self, other):\n-        if isinstance(other, Area):\n-            self.sq_m += other.sq_m\n-            return self\n-        else:\n-            raise TypeError('Area must be added with Area')\n-\n-    def __sub__(self, other):\n-        if isinstance(other, Area):\n-            return Area(default_unit=self._default_unit, sq_m=(self.sq_m - other.sq_m))\n-        else:\n-            raise TypeError('Area must be subtracted from Area')\n-\n-    def __isub__(self, other):\n-        if isinstance(other, Area):\n-            self.sq_m -= other.sq_m\n-            return self\n-        else:\n-            raise TypeError('Area must be subtracted from Area')\n-\n-    def __mul__(self, other):\n-        if isinstance(other, (int, float, long, Decimal)):\n-            return Area(default_unit=self._default_unit, sq_m=(self.sq_m * float(other)))\n-        else:\n-            raise TypeError('Area must be multiplied with number')\n-\n-    def __imul__(self, other):\n-        if isinstance(other, (int, float, long, Decimal)):\n-            self.sq_m *= float(other)\n-            return self\n-        else:\n-            raise TypeError('Area must be multiplied with number')\n-\n-    def __rmul__(self, other):\n-        return self * other\n-\n     def __div__(self, other):\n-        if isinstance(other, (int, float, long, Decimal)):\n-            return Area(default_unit=self._default_unit, sq_m=(self.sq_m / float(other)))\n+        if isinstance(other, NUMERIC_TYPES):\n+            return self.__class__(default_unit=self._default_unit,\n+                **{self.STANDARD_UNIT: (self.standard / other)})\n         else:\n-            raise TypeError('Area must be divided with number')\n+            raise TypeError('%(class)s must be divided by a number' % {\"class\":pretty_name(self)})\n \n-    def __idiv__(self, other):\n-        if isinstance(other, (int, float, long, Decimal)):\n-            self.sq_m /= float(other)\n-            return self\n-        else:\n-            raise TypeError('Area must be divided with number')\n-\n-    def __nonzero__(self):\n-        return bool(self.sq_m)\n \n # Shortcuts\n D = Distance"
        },
        {
            "sha": "0428704d6c79259992b906c004c840500ab014f0",
            "filename": "django/contrib/gis/tests/test_measure.py",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/4d46106f8c233c5af283c903000ef8c6f1165393/django%2Fcontrib%2Fgis%2Ftests%2Ftest_measure.py",
            "raw_url": "https://github.com/django/django/raw/4d46106f8c233c5af283c903000ef8c6f1165393/django%2Fcontrib%2Fgis%2Ftests%2Ftest_measure.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Ftests%2Ftest_measure.py?ref=4d46106f8c233c5af283c903000ef8c6f1165393",
            "patch": "@@ -93,6 +93,8 @@ def testMultiplication(self):\n         self.assertEqual(d4.m, 50)\n         d4 /= 5\n         self.assertEqual(d4.m, 10)\n+        d5 = d1 / D(m=2)\n+        self.assertEqual(d5, 50)\n \n         a5 = d1 * D(m=10)\n         self.assertTrue(isinstance(a5, Area))\n@@ -102,10 +104,6 @@ def testMultiplication(self):\n             d1 *= D(m=1)\n             self.fail('Distance *= Distance should raise TypeError')\n \n-        with self.assertRaises(TypeError):\n-            d5 = d1 / D(m=1)\n-            self.fail('Distance / Distance should raise TypeError')\n-\n         with self.assertRaises(TypeError):\n             d1 /= D(m=1)\n             self.fail('Distance /= Distance should raise TypeError')"
        }
    ],
    "stats": {
        "total": 320,
        "additions": 142,
        "deletions": 178
    }
}