{
    "author": "alex",
    "message": "Fixed a security issue in the CSRF component.  Disclosure and new release forthcoming.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15464 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "208630aa4b6460cb31cd81be2cc83d4075f1f27b",
    "files": [
        {
            "sha": "624dc7955d1ff1f2789bb353b991de54b54ccaa9",
            "filename": "django/middleware/csrf.py",
            "status": "modified",
            "additions": 5,
            "deletions": 25,
            "changes": 30,
            "blob_url": "https://github.com/django/django/blob/208630aa4b6460cb31cd81be2cc83d4075f1f27b/django%2Fmiddleware%2Fcsrf.py",
            "raw_url": "https://github.com/django/django/raw/208630aa4b6460cb31cd81be2cc83d4075f1f27b/django%2Fmiddleware%2Fcsrf.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fmiddleware%2Fcsrf.py?ref=208630aa4b6460cb31cd81be2cc83d4075f1f27b",
            "patch": "@@ -101,6 +101,7 @@ def _reject(self, request, reason):\n         return _get_failure_view()(request, reason=reason)\n \n     def process_view(self, request, callback, callback_args, callback_kwargs):\n+\n         if getattr(request, 'csrf_processing_done', False):\n             return None\n \n@@ -134,31 +135,6 @@ def process_view(self, request, callback, callback_args, callback_kwargs):\n                 # any branches that call reject()\n                 return self._accept(request)\n \n-            if request.is_ajax():\n-                # .is_ajax() is based on the presence of X-Requested-With.  In\n-                # the context of a browser, this can only be sent if using\n-                # XmlHttpRequest.  Browsers implement careful policies for\n-                # XmlHttpRequest:\n-                #\n-                #  * Normally, only same-domain requests are allowed.\n-                #\n-                #  * Some browsers (e.g. Firefox 3.5 and later) relax this\n-                #    carefully:\n-                #\n-                #    * if it is a 'simple' GET or POST request (which can\n-                #      include no custom headers), it is allowed to be cross\n-                #      domain.  These requests will not be recognized as AJAX.\n-                #\n-                #    * if a 'preflight' check with the server confirms that the\n-                #      server is expecting and allows the request, cross domain\n-                #      requests even with custom headers are allowed. These\n-                #      requests will be recognized as AJAX, but can only get\n-                #      through when the developer has specifically opted in to\n-                #      allowing the cross-domain POST request.\n-                #\n-                # So in all cases, it is safe to allow these requests through.\n-                return self._accept(request)\n-\n             if request.is_secure():\n                 # Suppose user visits http://example.com/\n                 # An active network attacker,(man-in-the-middle, MITM) sends a\n@@ -222,6 +198,10 @@ def process_view(self, request, callback, callback_args, callback_kwargs):\n \n             # check incoming token\n             request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')\n+            if request_csrf_token == \"\":\n+                # Fall back to X-CSRFToken, to make things easier for AJAX\n+                request_csrf_token = request.META.get('HTTP_X_CSRFTOKEN', '')\n+\n             if not constant_time_compare(request_csrf_token, csrf_token):\n                 if cookie_is_new:\n                     # probably a problem setting the CSRF cookie"
        },
        {
            "sha": "34d15db04a6bc3e3fddb35d97584cdfc506fc307",
            "filename": "docs/ref/contrib/csrf.txt",
            "status": "modified",
            "additions": 41,
            "deletions": 22,
            "changes": 63,
            "blob_url": "https://github.com/django/django/blob/208630aa4b6460cb31cd81be2cc83d4075f1f27b/docs%2Fref%2Fcontrib%2Fcsrf.txt",
            "raw_url": "https://github.com/django/django/raw/208630aa4b6460cb31cd81be2cc83d4075f1f27b/docs%2Fref%2Fcontrib%2Fcsrf.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fcontrib%2Fcsrf.txt?ref=208630aa4b6460cb31cd81be2cc83d4075f1f27b",
            "patch": "@@ -81,6 +81,47 @@ The utility script ``extras/csrf_migration_helper.py`` can help to automate the\n finding of code and templates that may need to be upgraded.  It contains full\n help on how to use it.\n \n+AJAX\n+----\n+\n+While the above method can be used for AJAX POST requests, it has some\n+inconveniences: you have to remember to pass the CSRF token in as POST data with\n+every POST request. For this reason, there is an alternative method: on each\n+XMLHttpRequest, set a custom `X-CSRFToken` header to the value of the CSRF\n+token. This is often easier, because many javascript frameworks provide hooks\n+that allow headers to be set on every request. In jQuery, you can use the\n+``beforeSend`` hook as follows:\n+\n+.. code-block:: javascript\n+\n+    $.ajaxSetup({\n+        beforeSend: function(xhr, settings) {\n+            function getCookie(name) {\n+                var cookieValue = null;\n+                if (document.cookie && document.cookie != '') {\n+                    var cookies = document.cookie.split(';');\n+                    for (var i = 0; i < cookies.length; i++) {\n+                        var cookie = jQuery.trim(cookies[i]);\n+                        // Does this cookie string begin with the name we want?\n+                        if (cookie.substring(0, name.length + 1) == (name + '=')) {\n+                            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n+                            break;\n+                        }\n+                    }\n+                }\n+                return cookieValue;\n+            }\n+            if (!(/^http:.*/.test(settings.url) || /^https:.*/.test(settings.url))) {\n+                // Only send the token to relative URLs i.e. locally.\n+                xhr.setRequestHeader(\"X-CSRFToken\", getCookie('csrftoken'));\n+            }\n+        }\n+    });\n+\n+Adding this to a javascript file that is included on your site will ensure that\n+AJAX POST requests that are made via jQuery will not be caught by the CSRF\n+protection.\n+\n The decorator method\n --------------------\n \n@@ -261,10 +302,6 @@ in the same module.  These disable the view protection mechanism\n (``CsrfResponseMiddleware``) respectively.  They can be used individually if\n required.\n \n-You don't have to worry about doing this for most AJAX views. Any request sent\n-with \"X-Requested-With: XMLHttpRequest\" is automatically exempt. (See the `How\n-it works`_ section.)\n-\n Subdomains\n ----------\n \n@@ -342,24 +379,6 @@ request ought to be harmless.\n response, and only pages that are served as 'text/html' or\n 'application/xml+xhtml' are modified.\n \n-AJAX\n-----\n-\n-The middleware tries to be smart about requests that come in via AJAX. Most\n-modern JavaScript toolkits send an \"X-Requested-With: XMLHttpRequest\" HTTP\n-header; these requests are detected and automatically *not* handled by this\n-middleware.  We can do this safely because, in the context of a browser, the\n-header can only be added by using ``XMLHttpRequest``, and browsers already\n-implement a same-domain policy for ``XMLHttpRequest``.\n-\n-For the more recent browsers that relax this same-domain policy, custom headers\n-like \"X-Requested-With\" are only allowed after the browser has done a\n-'preflight' check to the server to see if the cross-domain request is allowed,\n-using a strictly 'opt in' mechanism, so the exception for AJAX is still safeâ€”if\n-the developer has specifically opted in to allowing cross-site AJAX POST\n-requests on a specific URL, they obviously don't want the middleware to disallow\n-exactly that.\n-\n .. _9.1.1 Safe Methods, HTTP 1.1, RFC 2616: http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\n \n Caching"
        },
        {
            "sha": "7e14d0a5658f785ac628bb24c478a561bc9ac2a6",
            "filename": "tests/regressiontests/csrf_tests/tests.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/208630aa4b6460cb31cd81be2cc83d4075f1f27b/tests%2Fregressiontests%2Fcsrf_tests%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/208630aa4b6460cb31cd81be2cc83d4075f1f27b/tests%2Fregressiontests%2Fcsrf_tests%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fcsrf_tests%2Ftests.py?ref=208630aa4b6460cb31cd81be2cc83d4075f1f27b",
            "patch": "@@ -284,12 +284,12 @@ def test_process_request_csrf_cookie_no_token_exempt_view(self):\n         req2 = CsrfMiddleware().process_view(req, csrf_exempt(post_form_view), (), {})\n         self.assertEquals(None, req2)\n \n-    def test_ajax_exemption(self):\n+    def test_csrf_token_in_header(self):\n         \"\"\"\n-        Check that AJAX requests are automatically exempted.\n+        Check that we can pass in the token in a header instead of in the form\n         \"\"\"\n         req = self._get_POST_csrf_cookie_request()\n-        req.META['HTTP_X_REQUESTED_WITH'] = 'XMLHttpRequest'\n+        req.META['HTTP_X_CSRFTOKEN'] = self._csrf_id\n         req2 = CsrfMiddleware().process_view(req, post_form_view, (), {})\n         self.assertEquals(None, req2)\n "
        }
    ],
    "stats": {
        "total": 99,
        "additions": 49,
        "deletions": 50
    }
}