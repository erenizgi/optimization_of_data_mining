{
    "author": "unknown",
    "message": "Fixed #15309 -- reST/Sphinx cleanup on the ContentTypes Framework docs.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15544 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "e9d99c43711087c8840b725726efc7237e125477",
    "files": [
        {
            "sha": "18db29eefc83a9a166c2546f7b539a659085da74",
            "filename": "docs/ref/contrib/contenttypes.txt",
            "status": "modified",
            "additions": 108,
            "deletions": 89,
            "changes": 197,
            "blob_url": "https://github.com/django/django/blob/e9d99c43711087c8840b725726efc7237e125477/docs%2Fref%2Fcontrib%2Fcontenttypes.txt",
            "raw_url": "https://github.com/django/django/raw/e9d99c43711087c8840b725726efc7237e125477/docs%2Fref%2Fcontrib%2Fcontenttypes.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fcontrib%2Fcontenttypes.txt?ref=e9d99c43711087c8840b725726efc7237e125477",
            "patch": "@@ -5,8 +5,8 @@ The contenttypes framework\n .. module:: django.contrib.contenttypes\n    :synopsis: Provides generic interface to installed models.\n \n-Django includes a :mod:`contenttypes` application that can track all of\n-the models installed in your Django-powered project, providing a\n+Django includes a :mod:`~django.contrib.contenttypes` application that can\n+track all of the models installed in your Django-powered project, providing a\n high-level, generic interface for working with your models.\n \n Overview\n@@ -54,68 +54,72 @@ installed; several of Django's other bundled applications require it:\n     * Django's comments system (:mod:`django.contrib.comments`) uses it to\n       \"attach\" comments to any installed model.\n \n+.. currentmodule:: django.contrib.contenttypes.models\n+\n The ``ContentType`` model\n =========================\n \n-.. class:: models.ContentType\n+.. class:: ContentType\n \n     Each instance of :class:`~django.contrib.contenttypes.models.ContentType`\n-    has three fields which, taken together, uniquely describe an installed model:\n+    has three fields which, taken together, uniquely describe an installed\n+    model:\n \n-    .. attribute:: models.ContentType.app_label\n+    .. attribute:: app_label\n \n         The name of the application the model is part of. This is taken from\n-        the :attr:`app_label` attribute of the model, and includes only the *last*\n-        part of the application's Python import path;\n-        \"django.contrib.contenttypes\", for example, becomes an :attr:`app_label`\n-        of \"contenttypes\".\n+        the :attr:`app_label` attribute of the model, and includes only the\n+        *last* part of the application's Python import path;\n+        \"django.contrib.contenttypes\", for example, becomes an\n+        :attr:`app_label` of \"contenttypes\".\n \n-    .. attribute:: models.ContentType.model\n+    .. attribute:: model\n \n         The name of the model class.\n \n-    .. attribute:: models.ContentType.name\n+    .. attribute:: name\n \n         The human-readable name of the model. This is taken from the\n-        :attr:`verbose_name <django.db.models.fields.Field.verbose_name>`\n+        :attr:`verbose_name <django.db.models.Field.verbose_name>`\n         attribute of the model.\n \n Let's look at an example to see how this works. If you already have\n-the contenttypes application installed, and then add\n+the :mod:`~django.contrib.contenttypes` application installed, and then add\n :mod:`the sites application <django.contrib.sites>` to your\n :setting:`INSTALLED_APPS` setting and run ``manage.py syncdb`` to install it,\n the model :class:`django.contrib.sites.models.Site` will be installed into\n your database. Along with it a new instance of\n :class:`~django.contrib.contenttypes.models.ContentType` will be\n created with the following values:\n \n-    * :attr:`app_label` will be set to ``'sites'`` (the last part of the Python\n+    * :attr:`~django.contrib.contenttypes.models.ContentType.app_label`\n+      will be set to ``'sites'`` (the last part of the Python\n       path \"django.contrib.sites\").\n \n-    * :attr:`model` will be set to ``'site'``.\n+    * :attr:`~django.contrib.contenttypes.models.ContentType.model`\n+      will be set to ``'site'``.\n \n-    * :attr:`name` will be set to ``'site'``.\n+    * :attr:`~django.contrib.contenttypes.models.ContentType.name`\n+      will be set to ``'site'``.\n \n .. _the verbose_name attribute: ../model-api/#verbose_name\n \n Methods on ``ContentType`` instances\n ====================================\n \n-.. class:: models.ContentType\n-\n-    Each :class:`~django.contrib.contenttypes.models.ContentType` instance has\n-    methods that allow you to get from a\n-    :class:`~django.contrib.contenttypes.models.ContentType` instance to the model\n-    it represents, or to retrieve objects from that model:\n+Each :class:`~django.contrib.contenttypes.models.ContentType` instance has\n+methods that allow you to get from a\n+:class:`~django.contrib.contenttypes.models.ContentType` instance to the\n+model it represents, or to retrieve objects from that model:\n \n-.. method:: models.ContentType.get_object_for_this_type(**kwargs)\n+.. method:: ContentType.get_object_for_this_type(**kwargs)\n \n     Takes a set of valid :ref:`lookup arguments <field-lookups-intro>` for the\n     model the :class:`~django.contrib.contenttypes.models.ContentType`\n-    represents, and does :lookup:`a get() lookup <get>` on that model,\n-    returning the corresponding object.\n+    represents, and does :meth:`a get() lookup <django.db.models.QuerySet.get>`\n+    on that model, returning the corresponding object.\n \n-.. method:: models.ContentType.model_class()\n+.. method:: ContentType.model_class()\n \n     Returns the model class represented by this\n     :class:`~django.contrib.contenttypes.models.ContentType` instance.\n@@ -129,7 +133,8 @@ For example, we could look up the\n     >>> user_type\n     <ContentType: user>\n \n-And then use it to query for a particular ``User``, or to get access\n+And then use it to query for a particular\n+:class:`~django.contrib.auth.models.User`, or to get access\n to the ``User`` model class::\n \n     >>> user_type.model_class()\n@@ -139,15 +144,15 @@ to the ``User`` model class::\n \n Together,\n :meth:`~django.contrib.contenttypes.models.ContentType.get_object_for_this_type`\n-and :meth:`~django.contrib.contenttypes.models.ContentType.model_class`\n-enable two extremely important use cases:\n+and :meth:`~django.contrib.contenttypes.models.ContentType.model_class` enable\n+two extremely important use cases:\n \n     1. Using these methods, you can write high-level generic code that\n-       performs queries on any installed model -- instead of importing and using\n-       a single specific model class, you can pass an ``app_label`` and\n-       ``model`` into a :class:`~django.contrib.contenttypes.models.ContentType`\n-       lookup at runtime, and then work with the model class or retrieve objects\n-       from it.\n+       performs queries on any installed model -- instead of importing and\n+       using a single specific model class, you can pass an ``app_label`` and\n+       ``model`` into a\n+       :class:`~django.contrib.contenttypes.models.ContentType` lookup at\n+       runtime, and then work with the model class or retrieve objects from it.\n \n     2. You can relate another model to\n        :class:`~django.contrib.contenttypes.models.ContentType` as a way of\n@@ -156,7 +161,7 @@ enable two extremely important use cases:\n \n Several of Django's bundled applications make use of the latter technique.\n For example,\n-:class:`the permissions system <django.contrib.auth.models.Permission` in\n+:class:`the permissions system <django.contrib.auth.models.Permission>` in\n Django's authentication framework uses a\n :class:`~django.contrib.auth.models.Permission` model with a foreign\n key to :class:`~django.contrib.contenttypes.models.ContentType`; this lets\n@@ -166,36 +171,40 @@ key to :class:`~django.contrib.contenttypes.models.ContentType`; this lets\n The ``ContentTypeManager``\n --------------------------\n \n-.. class:: models.ContentTypeManager\n+.. class:: ContentTypeManager\n \n     :class:`~django.contrib.contenttypes.models.ContentType` also has a custom\n     manager, :class:`~django.contrib.contenttypes.models.ContentTypeManager`,\n     which adds the following methods:\n \n-    .. method:: models.ContentTypeManager.clear_cache()\n+    .. method:: clear_cache()\n \n         Clears an internal cache used by\n         :class:`~django.contrib.contenttypes.models.ContentType` to keep track\n         of which models for which it has created\n-        :class:`django.contrib.contenttypes.models.ContentType` instances. You\n+        :class:`~django.contrib.contenttypes.models.ContentType` instances. You\n         probably won't ever need to call this method yourself; Django will call\n         it automatically when it's needed.\n \n-    .. method:: models.ContentTypeManager.get_for_model(model)\n+    .. method:: get_for_model(model)\n \n         Takes either a model class or an instance of a model, and returns the\n         :class:`~django.contrib.contenttypes.models.ContentType` instance\n         representing that model.\n \n-The :meth:`~models.ContentTypeManager.get_for_model()` method is especially useful when you know you\n-need to work with a :class:`ContentType <django.contrib.contenttypes.models.ContentType>` but don't want to go to the\n-trouble of obtaining the model's metadata to perform a manual lookup::\n+The :meth:`~ContentTypeManager.get_for_model()` method is especially\n+useful when you know you need to work with a\n+:class:`ContentType <django.contrib.contenttypes.models.ContentType>` but don't\n+want to go to the trouble of obtaining the model's metadata to perform a manual\n+lookup::\n \n     >>> from django.contrib.auth.models import User\n     >>> user_type = ContentType.objects.get_for_model(User)\n     >>> user_type\n     <ContentType: user>\n \n+.. module:: django.contrib.contenttypes.generic\n+\n .. _generic-relations:\n \n Generic relations\n@@ -224,40 +233,42 @@ A simple example is a tagging system, which might look like this::\n         def __unicode__(self):\n             return self.tag\n \n-A normal :class:`~django.db.models.fields.related.ForeignKey` can only \"point\n+A normal :class:`~django.db.models.ForeignKey` can only \"point\n to\" one other model, which means that if the ``TaggedItem`` model used a\n-:class:`~django.db.models.fields.related.ForeignKey` it would have to\n+:class:`~django.db.models.ForeignKey` it would have to\n choose one and only one model to store tags for. The contenttypes\n-application provides a special field type --\n-:class:`django.contrib.contenttypes.generic.GenericForeignKey` -- which\n+application provides a special field type which\n works around this and allows the relationship to be with any\n-model. There are three parts to setting up a\n-:class:`~django.contrib.contenttypes.generic.GenericForeignKey`:\n-\n-    1. Give your model a :class:`~django.db.models.fields.related.ForeignKey`\n-       to :class:`~django.contrib.contenttypes.models.ContentType`.\n-\n-    2. Give your model a field that can store a primary-key value from the\n-       models you'll be relating to. (For most models, this means an\n-       :class:`~django.db.models.fields.IntegerField` or\n-       :class:`~django.db.models.fields.PositiveIntegerField`.)\n-\n-       This field must be of the same type as the primary key of the models\n-       that will be involved in the generic relation. For example, if you use\n-       :class:`~django.db.models.fields.IntegerField`, you won't be able to\n-       form a generic relation with a model that uses a\n-       :class:`~django.db.models.fields.CharField` as a primary key.\n-\n-    3. Give your model a\n-       :class:`~django.contrib.contenttypes.generic.GenericForeignKey`, and\n-       pass it the names of the two fields described above. If these fields\n-       are named \"content_type\" and \"object_id\", you can omit this -- those\n-       are the default field names\n-       :class:`~django.contrib.contenttypes.generic.GenericForeignKey` will\n-       look for.\n+model:\n+\n+.. class:: GenericForeignKey\n+\n+    There are three parts to setting up a\n+    :class:`~django.contrib.contenttypes.generic.GenericForeignKey`:\n+\n+        1. Give your model a :class:`~django.db.models.ForeignKey`\n+           to :class:`~django.contrib.contenttypes.models.ContentType`.\n+\n+        2. Give your model a field that can store primary key values from the\n+           models you'll be relating to. For most models, this means a\n+           :class:`~django.db.models.PositiveIntegerField`.\n+           \n+           This field must be of the same type as the primary key of the models\n+           that will be involved in the generic relation. For example, if you use\n+           :class:`~django.db.models.fields.IntegerField`, you won't be able to\n+           form a generic relation with a model that uses a\n+           :class:`~django.db.models.fields.CharField` as a primary key.\n+\n+        3. Give your model a\n+           :class:`~django.contrib.contenttypes.generic.GenericForeignKey`, and\n+           pass it the names of the two fields described above. If these fields\n+           are named \"content_type\" and \"object_id\", you can omit this -- those\n+           are the default field names\n+           :class:`~django.contrib.contenttypes.generic.GenericForeignKey` will\n+           look for.\n \n This will enable an API similar to the one used for a normal\n-:class:`~django.db.models.fields.related.ForeignKey`;\n+:class:`~django.db.models.ForeignKey`;\n each ``TaggedItem`` will have a ``content_object`` field that returns the\n object it's related to, and you can also assign to that field or use it when\n creating a ``TaggedItem``::\n@@ -271,8 +282,9 @@ creating a ``TaggedItem``::\n \n Due to the way :class:`~django.contrib.contenttypes.generic.GenericForeignKey`\n is implemented, you cannot use such fields directly with filters (``filter()``\n-and ``exclude()``, for example) via the database API. They aren't normal field\n-objects. These examples will *not* work::\n+and ``exclude()``, for example) via the database API. Because a \n+:class:`~django.contrib.contenttypes.generic.GenericForeignKey` isn't a \n+normal field objects, these examples will *not* work::\n \n     # This will fail\n     >>> TaggedItem.objects.filter(content_object=guido)\n@@ -282,6 +294,8 @@ objects. These examples will *not* work::\n Reverse generic relations\n -------------------------\n \n+.. class:: GenericRelation\n+\n If you know which models you'll be using most often, you can also add\n a \"reverse\" generic relationship to enable an additional API. For example::\n \n@@ -301,17 +315,20 @@ be used to retrieve their associated ``TaggedItems``::\n     >>> b.tags.all()\n     [<TaggedItem: django>, <TaggedItem: python>]\n \n-Just as :class:`django.contrib.contenttypes.generic.GenericForeignKey`\n+Just as :class:`~django.contrib.contenttypes.generic.GenericForeignKey`\n accepts the names of the content-type and object-ID fields as\n-arguments, so too does ``GenericRelation``; if the model which has the\n-generic foreign key is using non-default names for those fields, you\n-must pass the names of the fields when setting up a\n-``GenericRelation`` to it. For example, if the ``TaggedItem`` model\n+arguments, so too does\n+:class:`~django.contrib.contenttypes.generic.GenericRelation`;\n+if the model which has the generic foreign key is using non-default names\n+for those fields, you must pass the names of the fields when setting up a\n+:class:`.GenericRelation` to it. For example, if the ``TaggedItem`` model\n referred to above used fields named ``content_type_fk`` and\n ``object_primary_key`` to create its generic foreign key, then a\n-``GenericRelation`` back to it would need to be defined like so::\n+:class:`.GenericRelation` back to it would need to be defined like so::\n \n-    tags = generic.GenericRelation(TaggedItem, content_type_field='content_type_fk', object_id_field='object_primary_key')\n+    tags = generic.GenericRelation(TaggedItem,\n+                                   content_type_field='content_type_fk',\n+                                   object_id_field='object_primary_key')\n \n Of course, if you don't add the reverse relationship, you can do the\n same types of lookups manually::\n@@ -332,7 +349,7 @@ the :class:`~django.contrib.contenttypes.generic.GenericRelation` to\n match the ``ct_field`` and ``fk_field``, respectively, in the\n :class:`~django.contrib.contenttypes.generic.GenericForeignKey`::\n \n-\tcomments = generic.GenericRelation(Comment, object_id_field=\"object_pk\")\n+    comments = generic.GenericRelation(Comment, object_id_field=\"object_pk\")\n \n Note also, that if you delete an object that has a\n :class:`~django.contrib.contenttypes.generic.GenericRelation`, any objects\n@@ -362,37 +379,39 @@ might be tempted to try something like::\n     Bookmark.objects.aggregate(Count('tags'))\n \n This will not work correctly, however. The generic relation adds extra filters\n-to the queryset to ensure the correct content type, but the ``aggregate`` method\n-doesn't take them into account. For now, if you need aggregates on generic\n-relations, you'll need to calculate them without using the aggregation API.\n+to the queryset to ensure the correct content type, but the\n+:meth:`~django.db.models.QuerySet.aggregate` method doesn't take them into\n+account. For now, if you need aggregates on generic relations, you'll need\n+to calculate them without using the aggregation API.\n \n Generic relations in forms and admin\n ------------------------------------\n \n-:mod:`django.contrib.contenttypes.generic` provides\n+The :mod:`django.contrib.contenttypes.generic` module provides\n :class:`~django.contrib.contenttypes.generic.GenericInlineFormSet`,\n :class:`~django.contrib.contenttypes.generic.GenericTabularInline`\n and :class:`~django.contrib.contenttypes.generic.GenericStackedInline`\n-(the last two subclasses of :class:`~django.contrib.contenttypes.generic.GenericInlineModelAdmin`).\n+(the last two are subclasses of\n+:class:`~django.contrib.contenttypes.generic.GenericInlineModelAdmin`).\n This enables the use of generic relations in forms and the admin. See the\n :doc:`model formset </topics/forms/modelforms>` and\n :ref:`admin <using-generic-relations-as-an-inline>` documentation for more\n information.\n \n-.. class:: generic.GenericInlineModelAdmin\n+.. class:: GenericInlineModelAdmin\n \n     The :class:`~django.contrib.contenttypes.generic.GenericInlineModelAdmin`\n     class inherits all properties from an\n     :class:`~django.contrib.admin.InlineModelAdmin` class. However,\n     it adds a couple of its own for working with the generic relation:\n \n-    .. attribute:: generic.GenericInlineModelAdmin.ct_field\n+    .. attribute:: ct_field\n \n         The name of the\n         :class:`~django.contrib.contenttypes.models.ContentType` foreign key\n         field on the model. Defaults to ``content_type``.\n \n-    .. attribute:: generic.GenericInlineModelAdmin.ct_fk_field\n+    .. attribute:: ct_fk_field\n \n         The name of the integer field that represents the ID of the related\n         object. Defaults to ``object_id``."
        }
    ],
    "stats": {
        "total": 197,
        "additions": 108,
        "deletions": 89
    }
}