{
    "author": "freakboy3742",
    "message": "Fixed #14512 -- Added documentation on how to apply decorators to class-based generic views. Thanks to ≈Åukasz Rekucki for his work on the issue.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@14642 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "591ad8afbf7a2b32825e81866f387d4eb1938a4e",
    "files": [
        {
            "sha": "17f2ea30b337f624c0f984698e31aebbb19f6d37",
            "filename": "django/utils/decorators.py",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/591ad8afbf7a2b32825e81866f387d4eb1938a4e/django%2Futils%2Fdecorators.py",
            "raw_url": "https://github.com/django/django/raw/591ad8afbf7a2b32825e81866f387d4eb1938a4e/django%2Futils%2Fdecorators.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fdecorators.py?ref=591ad8afbf7a2b32825e81866f387d4eb1938a4e",
            "patch": "@@ -1,11 +1,15 @@\n \"Functions that help with dynamically creating decorators for views.\"\n \n-import types\n try:\n     from functools import wraps, update_wrapper, WRAPPER_ASSIGNMENTS\n except ImportError:\n     from django.utils.functional import wraps, update_wrapper, WRAPPER_ASSIGNMENTS  # Python 2.4 fallback.\n \n+class classonlymethod(classmethod):\n+    def __get__(self, instance, owner):\n+        if instance is not None:\n+            raise AttributeError(\"This method is available only on the view class.\")\n+        return super(classonlymethod, self).__get__(instance, owner)\n \n def method_decorator(decorator):\n     \"\"\""
        },
        {
            "sha": "0c9cd7971f44936d0120624178fe610fc9dbf11a",
            "filename": "django/views/generic/base.py",
            "status": "modified",
            "additions": 1,
            "deletions": 8,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/591ad8afbf7a2b32825e81866f387d4eb1938a4e/django%2Fviews%2Fgeneric%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/591ad8afbf7a2b32825e81866f387d4eb1938a4e/django%2Fviews%2Fgeneric%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fviews%2Fgeneric%2Fbase.py?ref=591ad8afbf7a2b32825e81866f387d4eb1938a4e",
            "patch": "@@ -1,19 +1,12 @@\n-import copy\n from django import http\n from django.core.exceptions import ImproperlyConfigured\n from django.template import RequestContext, loader\n-from django.utils.translation import ugettext_lazy as _\n from django.utils.functional import update_wrapper\n from django.utils.log import getLogger\n+from django.utils.decorators import classonlymethod\n \n logger = getLogger('django.request')\n \n-class classonlymethod(classmethod):\n-    def __get__(self, instance, owner):\n-        if instance is not None:\n-            raise AttributeError(\"This method is available only on the view class.\")\n-        return super(classonlymethod, self).__get__(instance, owner)\n-\n class View(object):\n     \"\"\"\n     Intentionally simple parent class for all views. Only implements"
        },
        {
            "sha": "5b848e811502bc06e439f9b296e6353ccc9ddc99",
            "filename": "docs/topics/class-based-views.txt",
            "status": "modified",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/django/django/blob/591ad8afbf7a2b32825e81866f387d4eb1938a4e/docs%2Ftopics%2Fclass-based-views.txt",
            "raw_url": "https://github.com/django/django/raw/591ad8afbf7a2b32825e81866f387d4eb1938a4e/docs%2Ftopics%2Fclass-based-views.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fclass-based-views.txt?ref=591ad8afbf7a2b32825e81866f387d4eb1938a4e",
            "patch": "@@ -537,3 +537,60 @@ Because of the way that Python resolves method overloading, the local\n :func:`render_to_response()` implementation will override the\n versions provided by :class:`JSONResponseMixin` and\n :class:`~django.views.generic.detail.SingleObjectTemplateResponseMixin`.\n+\n+Decorating class-based views\n+============================\n+\n+.. highlightlang:: python\n+\n+The extension of class-based views isn't limited to using mixins. You\n+can use also use decorators.\n+\n+Decorating in URLconf\n+---------------------\n+\n+The simplest way of decorating class-based views is to decorate the\n+result of the :meth:`~django.views.generic.base.View.as_view` method.\n+The easiest place to do this is in the URLconf where you deploy your\n+view::\n+\n+    from django.contrib.auth.decorators import login_required\n+    from django.views.generic import TemplateView\n+\n+    urlpatterns = patterns('',\n+        (r'^about/',login_required(TemplateView.as_view(template_name=\"secret.html\"))),\n+    )\n+\n+This approach applies the decorator on a per-instance basis. If you\n+want every instance of a view to be decorated, you need to take a\n+different approach.\n+\n+Decorating the class\n+--------------------\n+\n+To decorate every instance of a class-based view, you need to decorate\n+the class definition itself. To do this you apply the decorator to one\n+of the view-like methods on the class; that is,\n+:meth:`~django.views.generic.base.View.dispatch`, or one of the HTTP\n+methods (:meth:`~django.views.generic.base.View.get`,\n+:meth:`~django.views.generic.base.View.post` etc).\n+\n+A method on a class isn't quite the same as a standalone function, so\n+you can't just apply a function decorator to the method -- you need to\n+transform it into a method decorator first. The ``method_decorator``\n+decorator transforms a function decorator into a method decorator so\n+that it can be used on an instance method.\n+\n+    from django.contrib.auth.decorators import login_required\n+    from django.utils.decorators import method_decorator\n+    from django.views.generic import TemplateView\n+\n+    class ProtectedView(TemplateView):\n+        template_name = 'secret.html'\n+\n+        @method_decorator(login_required)\n+        def dispatch(self, **kwargs):\n+            return super(ProtectedView, self).dispatch(**kwargs)\n+\n+In this example, every instance of :class:`ProtectedView` will have\n+login protection."
        }
    ],
    "stats": {
        "total": 72,
        "additions": 63,
        "deletions": 9
    }
}