{
    "author": "jphalip",
    "message": "Fixed #16990 -- Fixed a couple of small docstring typos in the `django/test/testcases.py` module and did some minor cleanup while I was in the area.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16928 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "03d4a8d1b633ad918c9f85e765208bed00a1ad3a",
    "files": [
        {
            "sha": "010850d42ae975b776e1b95222482f9a45b33236",
            "filename": "django/test/testcases.py",
            "status": "modified",
            "additions": 50,
            "deletions": 26,
            "changes": 76,
            "blob_url": "https://github.com/django/django/blob/03d4a8d1b633ad918c9f85e765208bed00a1ad3a/django%2Ftest%2Ftestcases.py",
            "raw_url": "https://github.com/django/django/raw/03d4a8d1b633ad918c9f85e765208bed00a1ad3a/django%2Ftest%2Ftestcases.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Ftestcases.py?ref=03d4a8d1b633ad918c9f85e765208bed00a1ad3a",
            "patch": "@@ -19,15 +19,17 @@\n from django.http import QueryDict\n from django.test import _doctest as doctest\n from django.test.client import Client\n-from django.test.utils import get_warnings_state, restore_warnings_state, override_settings\n+from django.test.utils import (get_warnings_state, restore_warnings_state,\n+    override_settings)\n from django.utils import simplejson, unittest as ut2\n from django.utils.encoding import smart_str\n \n __all__ = ('DocTestRunner', 'OutputChecker', 'TestCase', 'TransactionTestCase',\n            'SimpleTestCase', 'skipIfDBFeature', 'skipUnlessDBFeature')\n \n normalize_long_ints = lambda s: re.sub(r'(?<![\\w])(\\d+)L(?![\\w])', '\\\\1', s)\n-normalize_decimals = lambda s: re.sub(r\"Decimal\\('(\\d+(\\.\\d*)?)'\\)\", lambda m: \"Decimal(\\\"%s\\\")\" % m.groups()[0], s)\n+normalize_decimals = lambda s: re.sub(r\"Decimal\\('(\\d+(\\.\\d*)?)'\\)\",\n+                                lambda m: \"Decimal(\\\"%s\\\")\" % m.groups()[0], s)\n \n def to_list(value):\n     \"\"\"\n@@ -65,7 +67,9 @@ def restore_transaction_methods():\n \n class OutputChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n-        \"The entry method for doctest output checking. Defers to a sequence of child checkers\"\n+        \"\"\"\n+        The entry method for doctest output checking. Defers to a sequence of child checkers\n+        \"\"\"\n         checks = (self.check_output_default,\n                   self.check_output_numeric,\n                   self.check_output_xml,\n@@ -76,7 +80,10 @@ def check_output(self, want, got, optionflags):\n         return False\n \n     def check_output_default(self, want, got, optionflags):\n-        \"The default comparator provided by doctest - not perfect, but good for most purposes\"\n+        \"\"\"\n+        The default comparator provided by doctest - not perfect, but good for\n+        most purposes\n+        \"\"\"\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n     def check_output_numeric(self, want, got, optionflags):\n@@ -147,17 +154,19 @@ def check_element(want_element, got_element):\n         try:\n             want_root = parseString(want).firstChild\n             got_root = parseString(got).firstChild\n-        except:\n+        except Exception:\n             return False\n         return check_element(want_root, got_root)\n \n     def check_output_json(self, want, got, optionsflags):\n-        \"Tries to compare want and got as if they were JSON-encoded data\"\n+        \"\"\"\n+        Tries to compare want and got as if they were JSON-encoded data\n+        \"\"\"\n         want, got = self._strip_quotes(want, got)\n         try:\n             want_json = simplejson.loads(want)\n             got_json = simplejson.loads(got)\n-        except:\n+        except Exception:\n             return False\n         return want_json == got_json\n \n@@ -248,7 +257,7 @@ def save_warnings_state(self):\n \n     def restore_warnings_state(self):\n         \"\"\"\n-        Restores the sate of the warnings module to the state\n+        Restores the state of the warnings module to the state\n         saved by save_warnings_state()\n         \"\"\"\n         restore_warnings_state(self._warnings_state)\n@@ -262,7 +271,9 @@ def settings(self, **kwargs):\n \n     def assertRaisesMessage(self, expected_exception, expected_message,\n                            callable_obj=None, *args, **kwargs):\n-        \"\"\"Asserts that the message in a raised exception matches the passe value.\n+        \"\"\"\n+        Asserts that the message in a raised exception matches the passed\n+        value.\n \n         Args:\n             expected_exception: Exception class expected to be raised.\n@@ -295,7 +306,8 @@ def assertFieldOutput(self, fieldclass, valid, invalid, field_args=None,\n         if field_kwargs is None:\n             field_kwargs = {}\n         required = fieldclass(*field_args, **field_kwargs)\n-        optional = fieldclass(*field_args, **dict(field_kwargs, required=False))\n+        optional = fieldclass(*field_args,\n+                              **dict(field_kwargs, required=False))\n         # test valid inputs\n         for input, output in valid.items():\n             self.assertEqual(required.clean(input), output)\n@@ -314,12 +326,14 @@ def assertFieldOutput(self, fieldclass, valid, invalid, field_args=None,\n         for e in EMPTY_VALUES:\n             with self.assertRaises(ValidationError) as context_manager:\n                 required.clean(e)\n-            self.assertEqual(context_manager.exception.messages, error_required)\n+            self.assertEqual(context_manager.exception.messages,\n+                             error_required)\n             self.assertEqual(optional.clean(e), empty_value)\n         # test that max_length and min_length are always accepted\n         if issubclass(fieldclass, CharField):\n             field_kwargs.update({'min_length':2, 'max_length':20})\n-            self.assertTrue(isinstance(fieldclass(*field_args, **field_kwargs), fieldclass))\n+            self.assertTrue(isinstance(fieldclass(*field_args, **field_kwargs),\n+                                       fieldclass))\n \n class TransactionTestCase(SimpleTestCase):\n     # The class we'll use for the test client self.client.\n@@ -353,7 +367,8 @@ def _fixture_setup(self):\n             if hasattr(self, 'fixtures'):\n                 # We have to use this slightly awkward syntax due to the fact\n                 # that we're using *args and **kwargs together.\n-                call_command('loaddata', *self.fixtures, **{'verbosity': 0, 'database': db})\n+                call_command('loaddata', *self.fixtures,\n+                             **{'verbosity': 0, 'database': db})\n \n     def _urlconf_setup(self):\n         if hasattr(self, 'urls'):\n@@ -466,7 +481,8 @@ def assertRedirects(self, response, expected_url, status_code=302,\n                 \" response code was %d (expected %d)\" %\n                     (path, redirect_response.status_code, target_status_code))\n \n-        e_scheme, e_netloc, e_path, e_query, e_fragment = urlsplit(expected_url)\n+        e_scheme, e_netloc, e_path, e_query, e_fragment = urlsplit(\n+                                                              expected_url)\n         if not (e_scheme or e_netloc):\n             expected_url = urlunsplit(('http', host or 'testserver', e_path,\n                 e_query, e_fragment))\n@@ -617,14 +633,16 @@ def connections_support_transactions():\n     \"\"\"\n     Returns True if all connections support transactions.\n     \"\"\"\n-    return all(conn.features.supports_transactions for conn in connections.all())\n+    return all(conn.features.supports_transactions\n+               for conn in connections.all())\n \n class TestCase(TransactionTestCase):\n     \"\"\"\n     Does basically the same as TransactionTestCase, but surrounds every test\n-    with a transaction, monkey-patches the real transaction management routines to\n-    do nothing, and rollsback the test transaction at the end of the test. You have\n-    to use TransactionTestCase, if you need transaction management inside a test.\n+    with a transaction, monkey-patches the real transaction management routines\n+    to do nothing, and rollsback the test transaction at the end of the test.\n+    You have to use TransactionTestCase, if you need transaction management\n+    inside a test.\n     \"\"\"\n \n     def _fixture_setup(self):\n@@ -648,11 +666,12 @@ def _fixture_setup(self):\n \n         for db in databases:\n             if hasattr(self, 'fixtures'):\n-                call_command('loaddata', *self.fixtures, **{\n-                                                            'verbosity': 0,\n-                                                            'commit': False,\n-                                                            'database': db\n-                                                            })\n+                call_command('loaddata', *self.fixtures,\n+                             **{\n+                                'verbosity': 0,\n+                                'commit': False,\n+                                'database': db\n+                             })\n \n     def _fixture_teardown(self):\n         if not connections_support_transactions():\n@@ -672,7 +691,8 @@ def _fixture_teardown(self):\n \n def _deferredSkip(condition, reason):\n     def decorator(test_func):\n-        if not (isinstance(test_func, type) and issubclass(test_func, TestCase)):\n+        if not (isinstance(test_func, type) and\n+                issubclass(test_func, TestCase)):\n             @wraps(test_func)\n             def skip_wrapper(*args, **kwargs):\n                 if condition():\n@@ -686,11 +706,15 @@ def skip_wrapper(*args, **kwargs):\n     return decorator\n \n def skipIfDBFeature(feature):\n-    \"Skip a test if a database has the named feature\"\n+    \"\"\"\n+    Skip a test if a database has the named feature\n+    \"\"\"\n     return _deferredSkip(lambda: getattr(connection.features, feature),\n                          \"Database has feature %s\" % feature)\n \n def skipUnlessDBFeature(feature):\n-    \"Skip a test unless a database has the named feature\"\n+    \"\"\"\n+    Skip a test unless a database has the named feature\n+    \"\"\"\n     return _deferredSkip(lambda: not getattr(connection.features, feature),\n                          \"Database doesn't support feature %s\" % feature)"
        }
    ],
    "stats": {
        "total": 76,
        "additions": 50,
        "deletions": 26
    }
}