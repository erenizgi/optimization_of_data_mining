{
    "author": "aaugustin",
    "message": "Merged branch 'database-level-autocommit'.\n\nFixed #2227: `atomic` supports nesting.\nFixed #6623: `commit_manually` is deprecated and `atomic` doesn't suffer from this defect.\nFixed #8320: the problem wasn't identified, but the legacy transaction management is deprecated.\nFixed #10744: the problem wasn't identified, but the legacy transaction management is deprecated.\nFixed #10813: since autocommit is enabled, it isn't necessary to rollback after errors any more.\nFixed #13742: savepoints are now implemented for SQLite.\nFixed #13870: transaction management in long running processes isn't a problem any more, and it's documented.\nFixed #14970: while it digresses on transaction management, this ticket essentially asks for autocommit on PostgreSQL.\nFixed #15694: `atomic` supports nesting.\nFixed #17887: autocommit makes it impossible for a connection to stay \"idle of transaction\".",
    "sha": "14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
    "files": [
        {
            "sha": "3c1cd81639e8cc234bc49632e20ea099b75a3455",
            "filename": "AUTHORS",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/AUTHORS",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/AUTHORS",
            "contents_url": "https://api.github.com/repos/django/django/contents/AUTHORS?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -434,6 +434,7 @@ answer newbie questions, and generally made Django that much better:\n     Andreas Pelme <andreas@pelme.se>\n     permonik@mesias.brnonet.cz\n     peter@mymart.com\n+    Christophe Pettus <xof@thebuild.com>\n     pgross@thoughtworks.com\n     phaedo <http://phaedo.cx/>\n     phil@produxion.net"
        },
        {
            "sha": "51f70f53500fef4482bdad7e103e5b833c8b492f",
            "filename": "django/contrib/gis/utils/layermapping.py",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcontrib%2Fgis%2Futils%2Flayermapping.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcontrib%2Fgis%2Futils%2Flayermapping.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Futils%2Flayermapping.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -555,10 +555,6 @@ def _save(feat_range=default_range, num_feat=0, num_saved=0):\n                     except SystemExit:\n                         raise\n                     except Exception as msg:\n-                        if self.transaction_mode == 'autocommit':\n-                            # Rolling back the transaction so that other model saves\n-                            # will work.\n-                            transaction.rollback_unless_managed()\n                         if strict:\n                             # Bailing out if the `strict` keyword is set.\n                             if not silent:"
        },
        {
            "sha": "30da0b7a10a06d744b5aeb4492428fa89d2db6c1",
            "filename": "django/contrib/sessions/backends/db.py",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcontrib%2Fsessions%2Fbackends%2Fdb.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcontrib%2Fsessions%2Fbackends%2Fdb.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fsessions%2Fbackends%2Fdb.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -74,7 +74,6 @@ def delete(self, session_key=None):\n     @classmethod\n     def clear_expired(cls):\n         Session.objects.filter(expire_date__lt=timezone.now()).delete()\n-        transaction.commit_unless_managed()\n \n \n # At bottom to avoid circular import"
        },
        {
            "sha": "53d7f4d22a87b378df206f40b5fbb5033a0e6c75",
            "filename": "django/core/cache/backends/db.py",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcore%2Fcache%2Fbackends%2Fdb.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcore%2Fcache%2Fbackends%2Fdb.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Fdb.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -10,7 +10,7 @@\n \n from django.conf import settings\n from django.core.cache.backends.base import BaseCache\n-from django.db import connections, router, transaction, DatabaseError\n+from django.db import connections, router, DatabaseError\n from django.utils import timezone, six\n from django.utils.encoding import force_bytes\n \n@@ -70,7 +70,6 @@ def get(self, key, default=None, version=None):\n             cursor = connections[db].cursor()\n             cursor.execute(\"DELETE FROM %s \"\n                            \"WHERE cache_key = %%s\" % table, [key])\n-            transaction.commit_unless_managed(using=db)\n             return default\n         value = connections[db].ops.process_clob(row[1])\n         return pickle.loads(base64.b64decode(force_bytes(value)))\n@@ -124,10 +123,8 @@ def _base_set(self, mode, key, value, timeout=None):\n                                [key, b64encoded, connections[db].ops.value_to_db_datetime(exp)])\n         except DatabaseError:\n             # To be threadsafe, updates/inserts are allowed to fail silently\n-            transaction.rollback_unless_managed(using=db)\n             return False\n         else:\n-            transaction.commit_unless_managed(using=db)\n             return True\n \n     def delete(self, key, version=None):\n@@ -139,7 +136,6 @@ def delete(self, key, version=None):\n         cursor = connections[db].cursor()\n \n         cursor.execute(\"DELETE FROM %s WHERE cache_key = %%s\" % table, [key])\n-        transaction.commit_unless_managed(using=db)\n \n     def has_key(self, key, version=None):\n         key = self.make_key(key, version=version)\n@@ -184,7 +180,6 @@ def clear(self):\n         table = connections[db].ops.quote_name(self._table)\n         cursor = connections[db].cursor()\n         cursor.execute('DELETE FROM %s' % table)\n-        transaction.commit_unless_managed(using=db)\n \n # For backwards compatibility\n class CacheClass(DatabaseCache):"
        },
        {
            "sha": "5327ce58911c9369f561be19c16e3e7f82d805df",
            "filename": "django/core/handlers/base.py",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcore%2Fhandlers%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcore%2Fhandlers%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fhandlers%2Fbase.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -6,10 +6,10 @@\n \n from django import http\n from django.conf import settings\n-from django.core import exceptions\n from django.core import urlresolvers\n from django.core import signals\n from django.core.exceptions import MiddlewareNotUsed, PermissionDenied\n+from django.db import connections, transaction\n from django.utils.encoding import force_text\n from django.utils.module_loading import import_by_path\n from django.utils import six\n@@ -65,6 +65,13 @@ def load_middleware(self):\n         # as a flag for initialization being complete.\n         self._request_middleware = request_middleware\n \n+    def make_view_atomic(self, view):\n+        if getattr(view, 'transactions_per_request', True):\n+            for db in connections.all():\n+                if db.settings_dict['ATOMIC_REQUESTS']:\n+                    view = transaction.atomic(using=db.alias)(view)\n+        return view\n+\n     def get_response(self, request):\n         \"Returns an HttpResponse object for the given HttpRequest\"\n         try:\n@@ -101,8 +108,9 @@ def get_response(self, request):\n                             break\n \n                 if response is None:\n+                    wrapped_callback = self.make_view_atomic(callback)\n                     try:\n-                        response = callback(request, *callback_args, **callback_kwargs)\n+                        response = wrapped_callback(request, *callback_args, **callback_kwargs)\n                     except Exception as e:\n                         # If the view raised an exception, run it through exception\n                         # middleware, and if the exception middleware returns a"
        },
        {
            "sha": "94b6b09400a953b70d0bfe27f7eaf910ec196027",
            "filename": "django/core/management/commands/createcachetable.py",
            "status": "modified",
            "additions": 10,
            "deletions": 11,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcore%2Fmanagement%2Fcommands%2Fcreatecachetable.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcore%2Fmanagement%2Fcommands%2Fcreatecachetable.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Fcreatecachetable.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -53,14 +53,13 @@ def handle_label(self, tablename, **options):\n         for i, line in enumerate(table_output):\n             full_statement.append('    %s%s' % (line, i < len(table_output)-1 and ',' or ''))\n         full_statement.append(');')\n-        curs = connection.cursor()\n-        try:\n-            curs.execute(\"\\n\".join(full_statement))\n-        except DatabaseError as e:\n-            transaction.rollback_unless_managed(using=db)\n-            raise CommandError(\n-                \"Cache table '%s' could not be created.\\nThe error was: %s.\" %\n-                    (tablename, force_text(e)))\n-        for statement in index_output:\n-            curs.execute(statement)\n-        transaction.commit_unless_managed(using=db)\n+        with transaction.commit_on_success_unless_managed():\n+            curs = connection.cursor()\n+            try:\n+                curs.execute(\"\\n\".join(full_statement))\n+            except DatabaseError as e:\n+                raise CommandError(\n+                    \"Cache table '%s' could not be created.\\nThe error was: %s.\" %\n+                        (tablename, force_text(e)))\n+            for statement in index_output:\n+                curs.execute(statement)"
        },
        {
            "sha": "9bd65e735c3ec9ba8e84ddf4e0f9ee19d51b5901",
            "filename": "django/core/management/commands/flush.py",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcore%2Fmanagement%2Fcommands%2Fflush.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcore%2Fmanagement%2Fcommands%2Fflush.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Fflush.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -57,18 +57,17 @@ def handle_noargs(self, **options):\n \n         if confirm == 'yes':\n             try:\n-                cursor = connection.cursor()\n-                for sql in sql_list:\n-                    cursor.execute(sql)\n+                with transaction.commit_on_success_unless_managed():\n+                    cursor = connection.cursor()\n+                    for sql in sql_list:\n+                        cursor.execute(sql)\n             except Exception as e:\n-                transaction.rollback_unless_managed(using=db)\n                 raise CommandError(\"\"\"Database %s couldn't be flushed. Possible reasons:\n   * The database isn't running or isn't configured correctly.\n   * At least one of the expected database tables doesn't exist.\n   * The SQL was invalid.\n Hint: Look at the output of 'django-admin.py sqlflush'. That's the SQL this command wasn't able to run.\n The full error: %s\"\"\" % (connection.settings_dict['NAME'], e))\n-            transaction.commit_unless_managed(using=db)\n \n             # Emit the post sync signal. This allows individual\n             # applications to respond as if the database had been"
        },
        {
            "sha": "8aa40cf021e2bea6bc3fab13ce1eaf93594cc547",
            "filename": "django/core/management/commands/loaddata.py",
            "status": "modified",
            "additions": 21,
            "deletions": 50,
            "changes": 71,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -41,8 +41,6 @@ def handle(self, *fixture_labels, **options):\n         self.ignore = options.get('ignore')\n         self.using = options.get('database')\n \n-        connection = connections[self.using]\n-\n         if not len(fixture_labels):\n             raise CommandError(\n                 \"No database fixture specified. Please provide the path of at \"\n@@ -51,32 +49,25 @@ def handle(self, *fixture_labels, **options):\n \n         self.verbosity = int(options.get('verbosity'))\n \n-        # commit is a stealth option - it isn't really useful as\n-        # a command line option, but it can be useful when invoking\n-        # loaddata from within another script.\n-        # If commit=True, loaddata will use its own transaction;\n-        # if commit=False, the data load SQL will become part of\n-        # the transaction in place when loaddata was invoked.\n-        commit = options.get('commit', True)\n+        with transaction.commit_on_success_unless_managed(using=self.using):\n+            self.loaddata(fixture_labels)\n+\n+        # Close the DB connection -- unless we're still in a transaction. This\n+        # is required as a workaround for an  edge case in MySQL: if the same\n+        # connection is used to create tables, load data, and query, the query\n+        # can return incorrect results. See Django #7572, MySQL #37735.\n+        if transaction.get_autocommit(self.using):\n+            connections[self.using].close()\n+\n+    def loaddata(self, fixture_labels):\n+        connection = connections[self.using]\n \n         # Keep a count of the installed objects and fixtures\n         self.fixture_count = 0\n         self.loaded_object_count = 0\n         self.fixture_object_count = 0\n         self.models = set()\n \n-        # Get a cursor (even though we don't need one yet). This has\n-        # the side effect of initializing the test database (if\n-        # it isn't already initialized).\n-        cursor = connection.cursor()\n-\n-        # Start transaction management. All fixtures are installed in a\n-        # single transaction to ensure that all references are resolved.\n-        if commit:\n-            transaction.commit_unless_managed(using=self.using)\n-            transaction.enter_transaction_management(using=self.using)\n-            transaction.managed(True, using=self.using)\n-\n         class SingleZipReader(zipfile.ZipFile):\n             def __init__(self, *args, **kwargs):\n                 zipfile.ZipFile.__init__(self, *args, **kwargs)\n@@ -105,26 +96,17 @@ def read(self):\n \n         app_fixtures = [os.path.join(os.path.dirname(path), 'fixtures') for path in app_module_paths]\n \n-        try:\n-            with connection.constraint_checks_disabled():\n-                for fixture_label in fixture_labels:\n-                    self.load_label(fixture_label, app_fixtures)\n-\n-            # Since we disabled constraint checks, we must manually check for\n-            # any invalid keys that might have been added\n-            table_names = [model._meta.db_table for model in self.models]\n-            try:\n-                connection.check_constraints(table_names=table_names)\n-            except Exception as e:\n-                e.args = (\"Problem installing fixtures: %s\" % e,)\n-                raise\n+        with connection.constraint_checks_disabled():\n+            for fixture_label in fixture_labels:\n+                self.load_label(fixture_label, app_fixtures)\n \n-        except (SystemExit, KeyboardInterrupt):\n-            raise\n+        # Since we disabled constraint checks, we must manually check for\n+        # any invalid keys that might have been added\n+        table_names = [model._meta.db_table for model in self.models]\n+        try:\n+            connection.check_constraints(table_names=table_names)\n         except Exception as e:\n-            if commit:\n-                transaction.rollback(using=self.using)\n-                transaction.leave_transaction_management(using=self.using)\n+            e.args = (\"Problem installing fixtures: %s\" % e,)\n             raise\n \n         # If we found even one object in a fixture, we need to reset the\n@@ -137,10 +119,6 @@ def read(self):\n                 for line in sequence_sql:\n                     cursor.execute(line)\n \n-        if commit:\n-            transaction.commit(using=self.using)\n-            transaction.leave_transaction_management(using=self.using)\n-\n         if self.verbosity >= 1:\n             if self.fixture_object_count == self.loaded_object_count:\n                 self.stdout.write(\"Installed %d object(s) from %d fixture(s)\" % (\n@@ -149,13 +127,6 @@ def read(self):\n                 self.stdout.write(\"Installed %d object(s) (of %d) from %d fixture(s)\" % (\n                     self.loaded_object_count, self.fixture_object_count, self.fixture_count))\n \n-        # Close the DB connection. This is required as a workaround for an\n-        # edge case in MySQL: if the same connection is used to\n-        # create tables, load data, and query, the query can return\n-        # incorrect results. See Django #7572, MySQL #37735.\n-        if commit:\n-            connection.close()\n-\n     def load_label(self, fixture_label, app_fixtures):\n \n         parts = fixture_label.split('.')"
        },
        {
            "sha": "e7e11a8c90e403334054930b1f2990a1d3a6c045",
            "filename": "django/core/management/commands/syncdb.py",
            "status": "modified",
            "additions": 37,
            "deletions": 40,
            "changes": 77,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcore%2Fmanagement%2Fcommands%2Fsyncdb.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fcore%2Fmanagement%2Fcommands%2Fsyncdb.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Fsyncdb.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -83,26 +83,25 @@ def model_installed(model):\n         # Create the tables for each model\n         if verbosity >= 1:\n             self.stdout.write(\"Creating tables ...\\n\")\n-        for app_name, model_list in manifest.items():\n-            for model in model_list:\n-                # Create the model's database table, if it doesn't already exist.\n-                if verbosity >= 3:\n-                    self.stdout.write(\"Processing %s.%s model\\n\" % (app_name, model._meta.object_name))\n-                sql, references = connection.creation.sql_create_model(model, self.style, seen_models)\n-                seen_models.add(model)\n-                created_models.add(model)\n-                for refto, refs in references.items():\n-                    pending_references.setdefault(refto, []).extend(refs)\n-                    if refto in seen_models:\n-                        sql.extend(connection.creation.sql_for_pending_references(refto, self.style, pending_references))\n-                sql.extend(connection.creation.sql_for_pending_references(model, self.style, pending_references))\n-                if verbosity >= 1 and sql:\n-                    self.stdout.write(\"Creating table %s\\n\" % model._meta.db_table)\n-                for statement in sql:\n-                    cursor.execute(statement)\n-                tables.append(connection.introspection.table_name_converter(model._meta.db_table))\n-\n-        transaction.commit_unless_managed(using=db)\n+        with transaction.commit_on_success_unless_managed(using=db):\n+            for app_name, model_list in manifest.items():\n+                for model in model_list:\n+                    # Create the model's database table, if it doesn't already exist.\n+                    if verbosity >= 3:\n+                        self.stdout.write(\"Processing %s.%s model\\n\" % (app_name, model._meta.object_name))\n+                    sql, references = connection.creation.sql_create_model(model, self.style, seen_models)\n+                    seen_models.add(model)\n+                    created_models.add(model)\n+                    for refto, refs in references.items():\n+                        pending_references.setdefault(refto, []).extend(refs)\n+                        if refto in seen_models:\n+                            sql.extend(connection.creation.sql_for_pending_references(refto, self.style, pending_references))\n+                    sql.extend(connection.creation.sql_for_pending_references(model, self.style, pending_references))\n+                    if verbosity >= 1 and sql:\n+                        self.stdout.write(\"Creating table %s\\n\" % model._meta.db_table)\n+                    for statement in sql:\n+                        cursor.execute(statement)\n+                    tables.append(connection.introspection.table_name_converter(model._meta.db_table))\n \n         # Send the post_syncdb signal, so individual apps can do whatever they need\n         # to do at this point.\n@@ -122,17 +121,16 @@ def model_installed(model):\n                     if custom_sql:\n                         if verbosity >= 2:\n                             self.stdout.write(\"Installing custom SQL for %s.%s model\\n\" % (app_name, model._meta.object_name))\n-                        try:\n-                            for sql in custom_sql:\n-                                cursor.execute(sql)\n-                        except Exception as e:\n-                            self.stderr.write(\"Failed to install custom SQL for %s.%s model: %s\\n\" % \\\n-                                                (app_name, model._meta.object_name, e))\n-                            if show_traceback:\n-                                traceback.print_exc()\n-                            transaction.rollback_unless_managed(using=db)\n-                        else:\n-                            transaction.commit_unless_managed(using=db)\n+                        with transaction.commit_on_success_unless_managed(using=db):\n+                            try:\n+                                for sql in custom_sql:\n+                                    cursor.execute(sql)\n+                            except Exception as e:\n+                                self.stderr.write(\"Failed to install custom SQL for %s.%s model: %s\\n\" % \\\n+                                                    (app_name, model._meta.object_name, e))\n+                                if show_traceback:\n+                                    traceback.print_exc()\n+                                raise\n                     else:\n                         if verbosity >= 3:\n                             self.stdout.write(\"No custom SQL for %s.%s model\\n\" % (app_name, model._meta.object_name))\n@@ -147,15 +145,14 @@ def model_installed(model):\n                     if index_sql:\n                         if verbosity >= 2:\n                             self.stdout.write(\"Installing index for %s.%s model\\n\" % (app_name, model._meta.object_name))\n-                        try:\n-                            for sql in index_sql:\n-                                cursor.execute(sql)\n-                        except Exception as e:\n-                            self.stderr.write(\"Failed to install index for %s.%s model: %s\\n\" % \\\n-                                                (app_name, model._meta.object_name, e))\n-                            transaction.rollback_unless_managed(using=db)\n-                        else:\n-                            transaction.commit_unless_managed(using=db)\n+                        with transaction.commit_on_success_unless_managed(using=db):\n+                            try:\n+                                for sql in index_sql:\n+                                    cursor.execute(sql)\n+                            except Exception as e:\n+                                self.stderr.write(\"Failed to install index for %s.%s model: %s\\n\" % \\\n+                                                    (app_name, model._meta.object_name, e))\n+                                raise\n \n         # Load initial_data fixtures (unless that has been disabled)\n         if load_initial_data:"
        },
        {
            "sha": "08c901ab7b234ce51937ee786cd9631ba1ca5d1b",
            "filename": "django/db/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 11,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2F__init__.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -70,21 +70,11 @@ def reset_queries(**kwargs):\n # their lifetime. NB: abort() doesn't do anything outside of a transaction.\n def close_old_connections(**kwargs):\n     for conn in connections.all():\n+        # Remove this when the legacy transaction management goes away.\n         try:\n             conn.abort()\n         except DatabaseError:\n             pass\n         conn.close_if_unusable_or_obsolete()\n signals.request_started.connect(close_old_connections)\n signals.request_finished.connect(close_old_connections)\n-\n-# Register an event that rolls back the connections\n-# when a Django request has an exception.\n-def _rollback_on_exception(**kwargs):\n-    from django.db import transaction\n-    for conn in connections:\n-        try:\n-            transaction.rollback_unless_managed(using=conn)\n-        except DatabaseError:\n-            pass\n-signals.got_request_exception.connect(_rollback_on_exception)"
        },
        {
            "sha": "09a33eebae905f67c9f426add2adfcfc1a2a8a2c",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 140,
            "deletions": 107,
            "changes": 247,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -44,11 +44,21 @@ def __init__(self, settings_dict, alias=DEFAULT_DB_ALIAS,\n         self.savepoint_state = 0\n \n         # Transaction management related attributes\n+        self.autocommit = False\n         self.transaction_state = []\n         # Tracks if the connection is believed to be in transaction. This is\n         # set somewhat aggressively, as the DBAPI doesn't make it easy to\n         # deduce if the connection is in transaction or not.\n         self._dirty = False\n+        # Tracks if the connection is in a transaction managed by 'atomic'\n+        self.in_atomic_block = False\n+        # Tracks if the transaction should be rolled back to the next\n+        # available savepoint because of an exception in an inner block.\n+        self.needs_rollback = False\n+        # List of savepoints created by 'atomic'\n+        self.savepoint_ids = []\n+        # Hack to provide compatibility with legacy transaction management\n+        self._atomic_forced_unmanaged = False\n \n         # Connection termination related attributes\n         self.close_at = None\n@@ -85,20 +95,35 @@ def create_cursor(self):\n         \"\"\"Creates a cursor. Assumes that a connection is established.\"\"\"\n         raise NotImplementedError\n \n+    ##### Backend-specific methods for creating connections #####\n+\n+    def connect(self):\n+        \"\"\"Connects to the database. Assumes that the connection is closed.\"\"\"\n+        # Reset parameters defining when to close the connection\n+        max_age = self.settings_dict['CONN_MAX_AGE']\n+        self.close_at = None if max_age is None else time.time() + max_age\n+        self.errors_occurred = False\n+        # Establish the connection\n+        conn_params = self.get_connection_params()\n+        self.connection = self.get_new_connection(conn_params)\n+        self.init_connection_state()\n+        if self.settings_dict['AUTOCOMMIT']:\n+            self.set_autocommit(True)\n+        connection_created.send(sender=self.__class__, connection=self)\n+\n+    def ensure_connection(self):\n+        \"\"\"\n+        Guarantees that a connection to the database is established.\n+        \"\"\"\n+        if self.connection is None:\n+            with self.wrap_database_errors():\n+                self.connect()\n+\n     ##### Backend-specific wrappers for PEP-249 connection methods #####\n \n     def _cursor(self):\n+        self.ensure_connection()\n         with self.wrap_database_errors():\n-            if self.connection is None:\n-                # Reset parameters defining when to close the connection\n-                max_age = self.settings_dict['CONN_MAX_AGE']\n-                self.close_at = None if max_age is None else time.time() + max_age\n-                self.errors_occurred = False\n-                # Establish the connection\n-                conn_params = self.get_connection_params()\n-                self.connection = self.get_new_connection(conn_params)\n-                self.init_connection_state()\n-                connection_created.send(sender=self.__class__, connection=self)\n             return self.create_cursor()\n \n     def _commit(self):\n@@ -132,17 +157,19 @@ def cursor(self):\n \n     def commit(self):\n         \"\"\"\n-        Does the commit itself and resets the dirty flag.\n+        Commits a transaction and resets the dirty flag.\n         \"\"\"\n         self.validate_thread_sharing()\n+        self.validate_no_atomic_block()\n         self._commit()\n         self.set_clean()\n \n     def rollback(self):\n         \"\"\"\n-        Does the rollback itself and resets the dirty flag.\n+        Rolls back a transaction and resets the dirty flag.\n         \"\"\"\n         self.validate_thread_sharing()\n+        self.validate_no_atomic_block()\n         self._rollback()\n         self.set_clean()\n \n@@ -160,54 +187,59 @@ def close(self):\n     ##### Backend-specific savepoint management methods #####\n \n     def _savepoint(self, sid):\n-        if not self.features.uses_savepoints:\n-            return\n         self.cursor().execute(self.ops.savepoint_create_sql(sid))\n \n     def _savepoint_rollback(self, sid):\n-        if not self.features.uses_savepoints:\n-            return\n         self.cursor().execute(self.ops.savepoint_rollback_sql(sid))\n \n     def _savepoint_commit(self, sid):\n-        if not self.features.uses_savepoints:\n-            return\n         self.cursor().execute(self.ops.savepoint_commit_sql(sid))\n \n+    def _savepoint_allowed(self):\n+        # Savepoints cannot be created outside a transaction\n+        return self.features.uses_savepoints and not self.autocommit\n+\n     ##### Generic savepoint management methods #####\n \n     def savepoint(self):\n         \"\"\"\n-        Creates a savepoint (if supported and required by the backend) inside the\n-        current transaction. Returns an identifier for the savepoint that will be\n-        used for the subsequent rollback or commit.\n+        Creates a savepoint inside the current transaction. Returns an\n+        identifier for the savepoint that will be used for the subsequent\n+        rollback or commit. Does nothing if savepoints are not supported.\n         \"\"\"\n+        if not self._savepoint_allowed():\n+            return\n+\n         thread_ident = thread.get_ident()\n+        tid = str(thread_ident).replace('-', '')\n \n         self.savepoint_state += 1\n-\n-        tid = str(thread_ident).replace('-', '')\n         sid = \"s%s_x%d\" % (tid, self.savepoint_state)\n+\n+        self.validate_thread_sharing()\n         self._savepoint(sid)\n+\n         return sid\n \n     def savepoint_rollback(self, sid):\n         \"\"\"\n-        Rolls back the most recent savepoint (if one exists). Does nothing if\n-        savepoints are not supported.\n+        Rolls back to a savepoint. Does nothing if savepoints are not supported.\n         \"\"\"\n+        if not self._savepoint_allowed():\n+            return\n+\n         self.validate_thread_sharing()\n-        if self.savepoint_state:\n-            self._savepoint_rollback(sid)\n+        self._savepoint_rollback(sid)\n \n     def savepoint_commit(self, sid):\n         \"\"\"\n-        Commits the most recent savepoint (if one exists). Does nothing if\n-        savepoints are not supported.\n+        Releases a savepoint. Does nothing if savepoints are not supported.\n         \"\"\"\n+        if not self._savepoint_allowed():\n+            return\n+\n         self.validate_thread_sharing()\n-        if self.savepoint_state:\n-            self._savepoint_commit(sid)\n+        self._savepoint_commit(sid)\n \n     def clean_savepoints(self):\n         \"\"\"\n@@ -217,24 +249,15 @@ def clean_savepoints(self):\n \n     ##### Backend-specific transaction management methods #####\n \n-    def _enter_transaction_management(self, managed):\n-        \"\"\"\n-        A hook for backend-specific changes required when entering manual\n-        transaction handling.\n-        \"\"\"\n-        pass\n-\n-    def _leave_transaction_management(self, managed):\n+    def _set_autocommit(self, autocommit):\n         \"\"\"\n-        A hook for backend-specific changes required when leaving manual\n-        transaction handling. Will usually be implemented only when\n-        _enter_transaction_management() is also required.\n+        Backend-specific implementation to enable or disable autocommit.\n         \"\"\"\n-        pass\n+        raise NotImplementedError\n \n     ##### Generic transaction management methods #####\n \n-    def enter_transaction_management(self, managed=True):\n+    def enter_transaction_management(self, managed=True, forced=False):\n         \"\"\"\n         Enters transaction management for a running thread. It must be balanced with\n         the appropriate leave_transaction_management call, since the actual state is\n@@ -243,35 +266,71 @@ def enter_transaction_management(self, managed=True):\n         The state and dirty flag are carried over from the surrounding block or\n         from the settings, if there is no surrounding block (dirty is always false\n         when no current block is running).\n+\n+        If you switch off transaction management and there is a pending\n+        commit/rollback, the data will be commited, unless \"forced\" is True.\n         \"\"\"\n-        if self.transaction_state:\n-            self.transaction_state.append(self.transaction_state[-1])\n-        else:\n-            self.transaction_state.append(settings.TRANSACTIONS_MANAGED)\n-        self._enter_transaction_management(managed)\n+        self.validate_no_atomic_block()\n+\n+        self.ensure_connection()\n+\n+        self.transaction_state.append(managed)\n+\n+        if not managed and self.is_dirty() and not forced:\n+            self.commit()\n+            self.set_clean()\n+\n+        if managed == self.autocommit:\n+            self.set_autocommit(not managed)\n \n     def leave_transaction_management(self):\n         \"\"\"\n         Leaves transaction management for a running thread. A dirty flag is carried\n         over to the surrounding block, as a commit will commit all changes, even\n         those from outside. (Commits are on connection level.)\n         \"\"\"\n+        self.validate_no_atomic_block()\n+\n+        self.ensure_connection()\n+\n         if self.transaction_state:\n             del self.transaction_state[-1]\n         else:\n             raise TransactionManagementError(\n                 \"This code isn't under transaction management\")\n-        # The _leave_transaction_management hook can change the dirty flag,\n-        # so memoize it.\n-        dirty = self._dirty\n-        # We will pass the next status (after leaving the previous state\n-        # behind) to subclass hook.\n-        self._leave_transaction_management(self.is_managed())\n-        if dirty:\n+\n+        if self.transaction_state:\n+            managed = self.transaction_state[-1]\n+        else:\n+            managed = not self.settings_dict['AUTOCOMMIT']\n+\n+        if self._dirty:\n             self.rollback()\n+            if managed == self.autocommit:\n+                self.set_autocommit(not managed)\n             raise TransactionManagementError(\n                 \"Transaction managed block ended with pending COMMIT/ROLLBACK\")\n \n+        if managed == self.autocommit:\n+            self.set_autocommit(not managed)\n+\n+    def set_autocommit(self, autocommit):\n+        \"\"\"\n+        Enable or disable autocommit.\n+        \"\"\"\n+        self.validate_no_atomic_block()\n+        self.ensure_connection()\n+        self._set_autocommit(autocommit)\n+        self.autocommit = autocommit\n+\n+    def validate_no_atomic_block(self):\n+        \"\"\"\n+        Raise an error if an atomic block is active.\n+        \"\"\"\n+        if self.in_atomic_block:\n+            raise TransactionManagementError(\n+                \"This is forbidden when an 'atomic' block is active.\")\n+\n     def abort(self):\n         \"\"\"\n         Roll back any ongoing transaction and clean the transaction state\n@@ -295,7 +354,8 @@ def set_dirty(self):\n         to decide in a managed block of code to decide whether there are open\n         changes waiting for commit.\n         \"\"\"\n-        self._dirty = True\n+        if not self.autocommit:\n+            self._dirty = True\n \n     def set_clean(self):\n         \"\"\"\n@@ -306,51 +366,6 @@ def set_clean(self):\n         self._dirty = False\n         self.clean_savepoints()\n \n-    def is_managed(self):\n-        \"\"\"\n-        Checks whether the transaction manager is in manual or in auto state.\n-        \"\"\"\n-        if self.transaction_state:\n-            return self.transaction_state[-1]\n-        return settings.TRANSACTIONS_MANAGED\n-\n-    def managed(self, flag=True):\n-        \"\"\"\n-        Puts the transaction manager into a manual state: managed transactions have\n-        to be committed explicitly by the user. If you switch off transaction\n-        management and there is a pending commit/rollback, the data will be\n-        commited.\n-        \"\"\"\n-        top = self.transaction_state\n-        if top:\n-            top[-1] = flag\n-            if not flag and self.is_dirty():\n-                self.commit()\n-        else:\n-            raise TransactionManagementError(\"This code isn't under transaction \"\n-                \"management\")\n-\n-    def commit_unless_managed(self):\n-        \"\"\"\n-        Commits changes if the system is not in managed transaction mode.\n-        \"\"\"\n-        self.validate_thread_sharing()\n-        if not self.is_managed():\n-            self.commit()\n-            self.clean_savepoints()\n-        else:\n-            self.set_dirty()\n-\n-    def rollback_unless_managed(self):\n-        \"\"\"\n-        Rolls back changes if the system is not in managed transaction mode.\n-        \"\"\"\n-        self.validate_thread_sharing()\n-        if not self.is_managed():\n-            self.rollback()\n-        else:\n-            self.set_dirty()\n-\n     ##### Foreign key constraints checks handling #####\n \n     @contextmanager\n@@ -402,12 +417,19 @@ def close_if_unusable_or_obsolete(self):\n         or if it outlived its maximum age.\n         \"\"\"\n         if self.connection is not None:\n+            # If the application didn't restore the original autocommit setting,\n+            # don't take chances, drop the connection.\n+            if self.autocommit != self.settings_dict['AUTOCOMMIT']:\n+                self.close()\n+                return\n+\n             if self.errors_occurred:\n                 if self.is_usable():\n                     self.errors_occurred = False\n                 else:\n                     self.close()\n                     return\n+\n             if self.close_at is not None and time.time() >= self.close_at:\n                 self.close()\n                 return\n@@ -460,6 +482,12 @@ def temporary_connection(self):\n             if must_close:\n                 self.close()\n \n+    def _start_transaction_under_autocommit(self):\n+        \"\"\"\n+        Only required when autocommits_when_autocommit_is_off = True.\n+        \"\"\"\n+        raise NotImplementedError\n+\n \n class BaseDatabaseFeatures(object):\n     allows_group_by_pk = False\n@@ -479,7 +507,6 @@ class BaseDatabaseFeatures(object):\n     can_use_chunked_reads = True\n     can_return_id_from_insert = False\n     has_bulk_insert = False\n-    uses_autocommit = False\n     uses_savepoints = False\n     can_combine_inserts_with_and_without_auto_increment_pk = False\n \n@@ -563,6 +590,10 @@ class BaseDatabaseFeatures(object):\n     # Support for the DISTINCT ON clause\n     can_distinct_on_fields = False\n \n+    # Does the backend decide to commit before SAVEPOINT statements\n+    # when autocommit is disabled? http://bugs.python.org/issue8145#msg109965\n+    autocommits_when_autocommit_is_off = False\n+\n     def __init__(self, connection):\n         self.connection = connection\n \n@@ -574,7 +605,6 @@ def supports_transactions(self):\n             # otherwise autocommit will cause the confimation to\n             # fail.\n             self.connection.enter_transaction_management()\n-            self.connection.managed(True)\n             cursor = self.connection.cursor()\n             cursor.execute('CREATE TABLE ROLLBACK_TEST (X INT)')\n             self.connection.commit()\n@@ -883,19 +913,19 @@ def savepoint_create_sql(self, sid):\n         \"uses_savepoints\" feature is True. The \"sid\" parameter is a string\n         for the savepoint id.\n         \"\"\"\n-        raise NotImplementedError\n+        return \"SAVEPOINT %s\" % self.quote_name(sid)\n \n     def savepoint_commit_sql(self, sid):\n         \"\"\"\n         Returns the SQL for committing the given savepoint.\n         \"\"\"\n-        raise NotImplementedError\n+        return \"RELEASE SAVEPOINT %s\" % self.quote_name(sid)\n \n     def savepoint_rollback_sql(self, sid):\n         \"\"\"\n         Returns the SQL for rolling back the given savepoint.\n         \"\"\"\n-        raise NotImplementedError\n+        return \"ROLLBACK TO SAVEPOINT %s\" % self.quote_name(sid)\n \n     def set_time_zone_sql(self):\n         \"\"\"\n@@ -946,6 +976,9 @@ def start_transaction_sql(self):\n         return \"BEGIN;\"\n \n     def end_transaction_sql(self, success=True):\n+        \"\"\"\n+        Returns the SQL statement required to end a transaction.\n+        \"\"\"\n         if not success:\n             return \"ROLLBACK;\"\n         return \"COMMIT;\""
        },
        {
            "sha": "38c284d6d3cd1533b5826f008d14fba9c923a08f",
            "filename": "django/db/backends/creation.py",
            "status": "modified",
            "additions": 6,
            "deletions": 15,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fcreation.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -1,6 +1,7 @@\n import hashlib\n import sys\n import time\n+import warnings\n \n from django.conf import settings\n from django.db.utils import load_backend\n@@ -382,10 +383,7 @@ def _create_test_db(self, verbosity, autoclobber):\n \n         qn = self.connection.ops.quote_name\n \n-        # Create the test database and connect to it. We need to autocommit\n-        # if the database supports it because PostgreSQL doesn't allow\n-        # CREATE/DROP DATABASE statements within transactions.\n-        self._prepare_for_test_db_ddl()\n+        # Create the test database and connect to it.\n         cursor = self.connection.cursor()\n         try:\n             cursor.execute(\n@@ -453,7 +451,6 @@ def _destroy_test_db(self, test_database_name, verbosity):\n         # to do so, because it's not allowed to delete a database while being\n         # connected to it.\n         cursor = self.connection.cursor()\n-        self._prepare_for_test_db_ddl()\n         # Wait to avoid \"database is being accessed by other users\" errors.\n         time.sleep(1)\n         cursor.execute(\"DROP DATABASE %s\"\n@@ -466,16 +463,10 @@ def set_autocommit(self):\n         anymore by Django code. Kept for compatibility with user code that\n         might use it.\n         \"\"\"\n-        pass\n-\n-    def _prepare_for_test_db_ddl(self):\n-        \"\"\"\n-        Internal implementation - Hook for tasks that should be performed\n-        before the ``CREATE DATABASE``/``DROP DATABASE`` clauses used by\n-        testing code to create/ destroy test databases. Needed e.g. in\n-        PostgreSQL to rollback and close any active transaction.\n-        \"\"\"\n-        pass\n+        warnings.warn(\n+            \"set_autocommit was moved from BaseDatabaseCreation to \"\n+            \"BaseDatabaseWrapper.\", PendingDeprecationWarning, stacklevel=2)\n+        return self.connection.set_autocommit(True)\n \n     def sql_table_creation_suffix(self):\n         \"\"\""
        },
        {
            "sha": "9a220ffd8b5ca233f8a3e4b37e41d6e351d7b8fd",
            "filename": "django/db/backends/dummy/base.py",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fdummy%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fdummy%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fdummy%2Fbase.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -55,12 +55,9 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     _savepoint = ignore\n     _savepoint_commit = complain\n     _savepoint_rollback = ignore\n-    _enter_transaction_management = complain\n-    _leave_transaction_management = ignore\n+    _set_autocommit = complain\n     set_dirty = complain\n     set_clean = complain\n-    commit_unless_managed = complain\n-    rollback_unless_managed = ignore\n \n     def __init__(self, *args, **kwargs):\n         super(DatabaseWrapper, self).__init__(*args, **kwargs)"
        },
        {
            "sha": "f7d07cf4b76136738521729a87418ef4e2af158a",
            "filename": "django/db/backends/mysql/base.py",
            "status": "modified",
            "additions": 3,
            "deletions": 9,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -355,15 +355,6 @@ def bulk_insert_sql(self, fields, num_values):\n         items_sql = \"(%s)\" % \", \".join([\"%s\"] * len(fields))\n         return \"VALUES \" + \", \".join([items_sql] * num_values)\n \n-    def savepoint_create_sql(self, sid):\n-        return \"SAVEPOINT %s\" % sid\n-\n-    def savepoint_commit_sql(self, sid):\n-        return \"RELEASE SAVEPOINT %s\" % sid\n-\n-    def savepoint_rollback_sql(self, sid):\n-        return \"ROLLBACK TO SAVEPOINT %s\" % sid\n-\n class DatabaseWrapper(BaseDatabaseWrapper):\n     vendor = 'mysql'\n     operators = {\n@@ -445,6 +436,9 @@ def _rollback(self):\n         except Database.NotSupportedError:\n             pass\n \n+    def _set_autocommit(self, autocommit):\n+        self.connection.autocommit(autocommit)\n+\n     def disable_constraint_checking(self):\n         \"\"\"\n         Disables foreign key checks, primarily for use in adding rows with forward references. Always returns True,"
        },
        {
            "sha": "d895c1583ab4ff0a8140bad5e9909c53777386a7",
            "filename": "django/db/backends/oracle/base.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Foracle%2Fbase.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -612,6 +612,9 @@ def _commit(self):\n     def _savepoint_commit(self, sid):\n         pass\n \n+    def _set_autocommit(self, autocommit):\n+        self.connection.autocommit = autocommit\n+\n     def check_constraints(self, table_names=None):\n         \"\"\"\n         To check constraints, we set constraints to immediate. Then, when, we're done we must ensure they"
        },
        {
            "sha": "5485830bf56d7e3e298c2e3ed1cf35eed3564339",
            "filename": "django/db/backends/oracle/creation.py",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Foracle%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Foracle%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Foracle%2Fcreation.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -273,6 +273,3 @@ def test_db_signature(self):\n             settings_dict['NAME'],\n             self._test_database_user(),\n         )\n-\n-    def set_autocommit(self):\n-        self.connection.connection.autocommit = True"
        },
        {
            "sha": "5c5f5e185a07c002b13d13fafec6b0d46728c141",
            "filename": "django/db/backends/postgresql_psycopg2/base.py",
            "status": "modified",
            "additions": 26,
            "deletions": 47,
            "changes": 73,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -49,6 +49,7 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     has_select_for_update = True\n     has_select_for_update_nowait = True\n     has_bulk_insert = True\n+    uses_savepoints = True\n     supports_tablespaces = True\n     supports_transactions = True\n     can_distinct_on_fields = True\n@@ -77,15 +78,11 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def __init__(self, *args, **kwargs):\n         super(DatabaseWrapper, self).__init__(*args, **kwargs)\n \n+        opts = self.settings_dict[\"OPTIONS\"]\n+        RC = psycopg2.extensions.ISOLATION_LEVEL_READ_COMMITTED\n+        self.isolation_level = opts.get('isolation_level', RC)\n+\n         self.features = DatabaseFeatures(self)\n-        autocommit = self.settings_dict[\"OPTIONS\"].get('autocommit', False)\n-        self.features.uses_autocommit = autocommit\n-        if autocommit:\n-            level = psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT\n-        else:\n-            level = self.settings_dict[\"OPTIONS\"].get('isolation_level',\n-                psycopg2.extensions.ISOLATION_LEVEL_READ_COMMITTED)\n-        self._set_isolation_level(level)\n         self.ops = DatabaseOperations(self)\n         self.client = DatabaseClient(self)\n         self.creation = DatabaseCreation(self)\n@@ -135,8 +132,7 @@ def init_connection_state(self):\n \n             if conn_tz != tz:\n                 # Set the time zone in autocommit mode (see #17062)\n-                self.connection.set_isolation_level(\n-                        psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)\n+                self.set_autocommit(True)\n                 self.connection.cursor().execute(\n                         self.ops.set_time_zone_sql(), [tz])\n         self.connection.set_isolation_level(self.isolation_level)\n@@ -167,44 +163,22 @@ def close(self):\n         finally:\n             self.set_clean()\n \n-    def _enter_transaction_management(self, managed):\n-        \"\"\"\n-        Switch the isolation level when needing transaction support, so that\n-        the same transaction is visible across all the queries.\n-        \"\"\"\n-        if self.features.uses_autocommit and managed and not self.isolation_level:\n-            level = self.settings_dict[\"OPTIONS\"].get('isolation_level',\n-                psycopg2.extensions.ISOLATION_LEVEL_READ_COMMITTED)\n-            self._set_isolation_level(level)\n-\n-    def _leave_transaction_management(self, managed):\n-        \"\"\"\n-        If the normal operating mode is \"autocommit\", switch back to that when\n-        leaving transaction management.\n-        \"\"\"\n-        if self.features.uses_autocommit and not managed and self.isolation_level:\n-            self._set_isolation_level(psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)\n-\n-    def _set_isolation_level(self, level):\n-        \"\"\"\n-        Do all the related feature configurations for changing isolation\n-        levels. This doesn't touch the uses_autocommit feature, since that\n-        controls the movement *between* isolation levels.\n-        \"\"\"\n-        assert level in range(5)\n-        try:\n-            if self.connection is not None:\n-                self.connection.set_isolation_level(level)\n-            if level == psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT:\n-                self.set_clean()\n-        finally:\n-            self.isolation_level = level\n-            self.features.uses_savepoints = bool(level)\n+    def _set_isolation_level(self, isolation_level):\n+        assert isolation_level in range(1, 5)     # Use set_autocommit for level = 0\n+        if self.psycopg2_version >= (2, 4, 2):\n+            self.connection.set_session(isolation_level=isolation_level)\n+        else:\n+            self.connection.set_isolation_level(isolation_level)\n \n-    def set_dirty(self):\n-        if ((self.transaction_state and self.transaction_state[-1]) or\n-                not self.features.uses_autocommit):\n-            super(DatabaseWrapper, self).set_dirty()\n+    def _set_autocommit(self, autocommit):\n+        if self.psycopg2_version >= (2, 4, 2):\n+            self.connection.autocommit = autocommit\n+        else:\n+            if autocommit:\n+                level = psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT\n+            else:\n+                level = self.isolation_level\n+            self.connection.set_isolation_level(level)\n \n     def check_constraints(self, table_names=None):\n         \"\"\"\n@@ -223,6 +197,11 @@ def is_usable(self):\n         else:\n             return True\n \n+    @cached_property\n+    def psycopg2_version(self):\n+        version = psycopg2.__version__.split(' ', 1)[0]\n+        return tuple(int(v) for v in version.split('.'))\n+\n     @cached_property\n     def pg_version(self):\n         with self.temporary_connection():"
        },
        {
            "sha": "3ba21581032e8b6bc485cbffedf3e99d2aa2078a",
            "filename": "django/db/backends/postgresql_psycopg2/creation.py",
            "status": "modified",
            "additions": 0,
            "deletions": 11,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fcreation.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -77,14 +77,3 @@ def get_index_sql(index_name, opclass=''):\n                 output.append(get_index_sql('%s_%s_like' % (db_table, f.column),\n                                             ' text_pattern_ops'))\n         return output\n-\n-    def set_autocommit(self):\n-        self._prepare_for_test_db_ddl()\n-\n-    def _prepare_for_test_db_ddl(self):\n-        \"\"\"Rollback and close the active transaction.\"\"\"\n-        # Make sure there is an open connection.\n-        self.connection.cursor()\n-        self.connection.connection.rollback()\n-        self.connection.connection.set_isolation_level(\n-                psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)"
        },
        {
            "sha": "a210f87ccd114687cd768cd787a0fd6e68b7703c",
            "filename": "django/db/backends/postgresql_psycopg2/operations.py",
            "status": "modified",
            "additions": 0,
            "deletions": 9,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Foperations.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Foperations.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Foperations.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -175,15 +175,6 @@ def sequence_reset_sql(self, style, model_list):\n                         style.SQL_TABLE(qn(f.m2m_db_table()))))\n         return output\n \n-    def savepoint_create_sql(self, sid):\n-        return \"SAVEPOINT %s\" % sid\n-\n-    def savepoint_commit_sql(self, sid):\n-        return \"RELEASE SAVEPOINT %s\" % sid\n-\n-    def savepoint_rollback_sql(self, sid):\n-        return \"ROLLBACK TO SAVEPOINT %s\" % sid\n-\n     def prep_for_iexact_query(self, x):\n         return x\n "
        },
        {
            "sha": "f70c3872a89eb986046522f1dedbedb36f6db349",
            "filename": "django/db/backends/sqlite3/base.py",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -99,6 +99,11 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     supports_mixed_date_datetime_comparisons = False\n     has_bulk_insert = True\n     can_combine_inserts_with_and_without_auto_increment_pk = False\n+    autocommits_when_autocommit_is_off = True\n+\n+    @cached_property\n+    def uses_savepoints(self):\n+        return Database.sqlite_version_info >= (3, 6, 8)\n \n     @cached_property\n     def supports_stddev(self):\n@@ -355,6 +360,25 @@ def close(self):\n         if self.settings_dict['NAME'] != \":memory:\":\n             BaseDatabaseWrapper.close(self)\n \n+    def _savepoint_allowed(self):\n+        # When 'isolation_level' is not None, sqlite3 commits before each\n+        # savepoint; it's a bug. When it is None, savepoints don't make sense\n+        # because autocommit is enabled. The only exception is inside atomic\n+        # blocks. To work around that bug, on SQLite, atomic starts a\n+        # transaction explicitly rather than simply disable autocommit.\n+        return self.in_atomic_block\n+\n+    def _set_autocommit(self, autocommit):\n+        if autocommit:\n+            level = None\n+        else:\n+            # sqlite3's internal default is ''. It's different from None.\n+            # See Modules/_sqlite/connection.c.\n+            level = ''\n+        # 'isolation_level' is a misleading API.\n+        # SQLite always runs at the SERIALIZABLE isolation level.\n+        self.connection.isolation_level = level\n+\n     def check_constraints(self, table_names=None):\n         \"\"\"\n         Checks each table name in `table_names` for rows with invalid foreign key references. This method is\n@@ -392,6 +416,14 @@ def check_constraints(self, table_names=None):\n     def is_usable(self):\n         return True\n \n+    def _start_transaction_under_autocommit(self):\n+        \"\"\"\n+        Start a transaction explicitly in autocommit mode.\n+\n+        Staying in autocommit mode works around a bug of sqlite3 that breaks\n+        savepoints when autocommit is disabled.\n+        \"\"\"\n+        self.cursor().execute(\"BEGIN\")\n \n FORMAT_QMARK_REGEX = re.compile(r'(?<!%)%s')\n "
        },
        {
            "sha": "a9fb273f7ad22eaccb2f0d407f7b71752368ff5a",
            "filename": "django/db/backends/sqlite3/creation.py",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fsqlite3%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fbackends%2Fsqlite3%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fcreation.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -72,9 +72,6 @@ def _destroy_test_db(self, test_database_name, verbosity):\n             # Remove the SQLite database file\n             os.remove(test_database_name)\n \n-    def set_autocommit(self):\n-        self.connection.connection.isolation_level = None\n-\n     def test_db_signature(self):\n         \"\"\"\n         Returns a tuple that uniquely identifies a test database."
        },
        {
            "sha": "ab0e42d4619fc0546da9d7ff06b5114cea245e6a",
            "filename": "django/db/models/base.py",
            "status": "modified",
            "additions": 42,
            "deletions": 42,
            "changes": 84,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fmodels%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fmodels%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fbase.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -609,48 +609,48 @@ def save_base(self, raw=False, cls=None, origin=None, force_insert=False,\n             if update_fields:\n                 non_pks = [f for f in non_pks if f.name in update_fields or f.attname in update_fields]\n \n-            # First, try an UPDATE. If that doesn't update anything, do an INSERT.\n-            pk_val = self._get_pk_val(meta)\n-            pk_set = pk_val is not None\n-            record_exists = True\n-            manager = cls._base_manager\n-            if pk_set:\n-                # Determine if we should do an update (pk already exists, forced update,\n-                # no force_insert)\n-                if ((force_update or update_fields) or (not force_insert and\n-                        manager.using(using).filter(pk=pk_val).exists())):\n-                    if force_update or non_pks:\n-                        values = [(f, None, (raw and getattr(self, f.attname) or f.pre_save(self, False))) for f in non_pks]\n-                        if values:\n-                            rows = manager.using(using).filter(pk=pk_val)._update(values)\n-                            if force_update and not rows:\n-                                raise DatabaseError(\"Forced update did not affect any rows.\")\n-                            if update_fields and not rows:\n-                                raise DatabaseError(\"Save with update_fields did not affect any rows.\")\n-                else:\n-                    record_exists = False\n-            if not pk_set or not record_exists:\n-                if meta.order_with_respect_to:\n-                    # If this is a model with an order_with_respect_to\n-                    # autopopulate the _order field\n-                    field = meta.order_with_respect_to\n-                    order_value = manager.using(using).filter(**{field.name: getattr(self, field.attname)}).count()\n-                    self._order = order_value\n-\n-                fields = meta.local_fields\n-                if not pk_set:\n-                    if force_update or update_fields:\n-                        raise ValueError(\"Cannot force an update in save() with no primary key.\")\n-                    fields = [f for f in fields if not isinstance(f, AutoField)]\n+            with transaction.commit_on_success_unless_managed(using=using):\n+                # First, try an UPDATE. If that doesn't update anything, do an INSERT.\n+                pk_val = self._get_pk_val(meta)\n+                pk_set = pk_val is not None\n+                record_exists = True\n+                manager = cls._base_manager\n+                if pk_set:\n+                    # Determine if we should do an update (pk already exists, forced update,\n+                    # no force_insert)\n+                    if ((force_update or update_fields) or (not force_insert and\n+                            manager.using(using).filter(pk=pk_val).exists())):\n+                        if force_update or non_pks:\n+                            values = [(f, None, (raw and getattr(self, f.attname) or f.pre_save(self, False))) for f in non_pks]\n+                            if values:\n+                                rows = manager.using(using).filter(pk=pk_val)._update(values)\n+                                if force_update and not rows:\n+                                    raise DatabaseError(\"Forced update did not affect any rows.\")\n+                                if update_fields and not rows:\n+                                    raise DatabaseError(\"Save with update_fields did not affect any rows.\")\n+                    else:\n+                        record_exists = False\n+                if not pk_set or not record_exists:\n+                    if meta.order_with_respect_to:\n+                        # If this is a model with an order_with_respect_to\n+                        # autopopulate the _order field\n+                        field = meta.order_with_respect_to\n+                        order_value = manager.using(using).filter(**{field.name: getattr(self, field.attname)}).count()\n+                        self._order = order_value\n+\n+                    fields = meta.local_fields\n+                    if not pk_set:\n+                        if force_update or update_fields:\n+                            raise ValueError(\"Cannot force an update in save() with no primary key.\")\n+                        fields = [f for f in fields if not isinstance(f, AutoField)]\n \n-                record_exists = False\n+                    record_exists = False\n \n-                update_pk = bool(meta.has_auto_field and not pk_set)\n-                result = manager._insert([self], fields=fields, return_id=update_pk, using=using, raw=raw)\n+                    update_pk = bool(meta.has_auto_field and not pk_set)\n+                    result = manager._insert([self], fields=fields, return_id=update_pk, using=using, raw=raw)\n \n-                if update_pk:\n-                    setattr(self, meta.pk.attname, result)\n-            transaction.commit_unless_managed(using=using)\n+                    if update_pk:\n+                        setattr(self, meta.pk.attname, result)\n \n         # Store the database on which the object was saved\n         self._state.db = using\n@@ -963,9 +963,9 @@ def method_set_order(ordered_obj, self, id_list, using=None):\n     order_name = ordered_obj._meta.order_with_respect_to.name\n     # FIXME: It would be nice if there was an \"update many\" version of update\n     # for situations like this.\n-    for i, j in enumerate(id_list):\n-        ordered_obj.objects.filter(**{'pk': j, order_name: rel_val}).update(_order=i)\n-    transaction.commit_unless_managed(using=using)\n+    with transaction.commit_on_success_unless_managed(using=using):\n+        for i, j in enumerate(id_list):\n+            ordered_obj.objects.filter(**{'pk': j, order_name: rel_val}).update(_order=i)\n \n \n def method_get_order(ordered_obj, self):"
        },
        {
            "sha": "a04f05c73bf26466d9abe3400371a41b6c81fe06",
            "filename": "django/db/models/deletion.py",
            "status": "modified",
            "additions": 32,
            "deletions": 52,
            "changes": 84,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fmodels%2Fdeletion.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fmodels%2Fdeletion.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fdeletion.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -50,26 +50,6 @@ def DO_NOTHING(collector, field, sub_objs, using):\n     pass\n \n \n-def force_managed(func):\n-    @wraps(func)\n-    def decorated(self, *args, **kwargs):\n-        if not transaction.is_managed(using=self.using):\n-            transaction.enter_transaction_management(using=self.using)\n-            forced_managed = True\n-        else:\n-            forced_managed = False\n-        try:\n-            func(self, *args, **kwargs)\n-            if forced_managed:\n-                transaction.commit(using=self.using)\n-            else:\n-                transaction.commit_unless_managed(using=self.using)\n-        finally:\n-            if forced_managed:\n-                transaction.leave_transaction_management(using=self.using)\n-    return decorated\n-\n-\n class Collector(object):\n     def __init__(self, using):\n         self.using = using\n@@ -262,7 +242,6 @@ def sort(self):\n         self.data = SortedDict([(model, self.data[model])\n                                 for model in sorted_models])\n \n-    @force_managed\n     def delete(self):\n         # sort instance collections\n         for model, instances in self.data.items():\n@@ -273,40 +252,41 @@ def delete(self):\n         # end of a transaction.\n         self.sort()\n \n-        # send pre_delete signals\n-        for model, obj in self.instances_with_model():\n-            if not model._meta.auto_created:\n-                signals.pre_delete.send(\n-                    sender=model, instance=obj, using=self.using\n-                )\n-\n-        # fast deletes\n-        for qs in self.fast_deletes:\n-            qs._raw_delete(using=self.using)\n-\n-        # update fields\n-        for model, instances_for_fieldvalues in six.iteritems(self.field_updates):\n-            query = sql.UpdateQuery(model)\n-            for (field, value), instances in six.iteritems(instances_for_fieldvalues):\n-                query.update_batch([obj.pk for obj in instances],\n-                                   {field.name: value}, self.using)\n-\n-        # reverse instance collections\n-        for instances in six.itervalues(self.data):\n-            instances.reverse()\n-\n-        # delete instances\n-        for model, instances in six.iteritems(self.data):\n-            query = sql.DeleteQuery(model)\n-            pk_list = [obj.pk for obj in instances]\n-            query.delete_batch(pk_list, self.using)\n-\n-            if not model._meta.auto_created:\n-                for obj in instances:\n-                    signals.post_delete.send(\n+        with transaction.commit_on_success_unless_managed(using=self.using):\n+            # send pre_delete signals\n+            for model, obj in self.instances_with_model():\n+                if not model._meta.auto_created:\n+                    signals.pre_delete.send(\n                         sender=model, instance=obj, using=self.using\n                     )\n \n+            # fast deletes\n+            for qs in self.fast_deletes:\n+                qs._raw_delete(using=self.using)\n+\n+            # update fields\n+            for model, instances_for_fieldvalues in six.iteritems(self.field_updates):\n+                query = sql.UpdateQuery(model)\n+                for (field, value), instances in six.iteritems(instances_for_fieldvalues):\n+                    query.update_batch([obj.pk for obj in instances],\n+                                       {field.name: value}, self.using)\n+\n+            # reverse instance collections\n+            for instances in six.itervalues(self.data):\n+                instances.reverse()\n+\n+            # delete instances\n+            for model, instances in six.iteritems(self.data):\n+                query = sql.DeleteQuery(model)\n+                pk_list = [obj.pk for obj in instances]\n+                query.delete_batch(pk_list, self.using)\n+\n+                if not model._meta.auto_created:\n+                    for obj in instances:\n+                        signals.post_delete.send(\n+                            sender=model, instance=obj, using=self.using\n+                        )\n+\n         # update collected instances\n         for model, instances_for_fieldvalues in six.iteritems(self.field_updates):\n             for (field, value), instances in six.iteritems(instances_for_fieldvalues):"
        },
        {
            "sha": "22c7cfba323723fb0b011356e5d0b5a250b5f809",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 2,
            "deletions": 26,
            "changes": 28,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -442,12 +442,7 @@ def bulk_create(self, objs, batch_size=None):\n         self._for_write = True\n         connection = connections[self.db]\n         fields = self.model._meta.local_fields\n-        if not transaction.is_managed(using=self.db):\n-            transaction.enter_transaction_management(using=self.db)\n-            forced_managed = True\n-        else:\n-            forced_managed = False\n-        try:\n+        with transaction.commit_on_success_unless_managed(using=self.db):\n             if (connection.features.can_combine_inserts_with_and_without_auto_increment_pk\n                 and self.model._meta.has_auto_field):\n                 self._batched_insert(objs, fields, batch_size)\n@@ -458,13 +453,6 @@ def bulk_create(self, objs, batch_size=None):\n                 if objs_without_pk:\n                     fields= [f for f in fields if not isinstance(f, AutoField)]\n                     self._batched_insert(objs_without_pk, fields, batch_size)\n-            if forced_managed:\n-                transaction.commit(using=self.db)\n-            else:\n-                transaction.commit_unless_managed(using=self.db)\n-        finally:\n-            if forced_managed:\n-                transaction.leave_transaction_management(using=self.db)\n \n         return objs\n \n@@ -581,20 +569,8 @@ def update(self, **kwargs):\n         self._for_write = True\n         query = self.query.clone(sql.UpdateQuery)\n         query.add_update_values(kwargs)\n-        if not transaction.is_managed(using=self.db):\n-            transaction.enter_transaction_management(using=self.db)\n-            forced_managed = True\n-        else:\n-            forced_managed = False\n-        try:\n+        with transaction.commit_on_success_unless_managed(using=self.db):\n             rows = query.get_compiler(self.db).execute_sql(None)\n-            if forced_managed:\n-                transaction.commit(using=self.db)\n-            else:\n-                transaction.commit_unless_managed(using=self.db)\n-        finally:\n-            if forced_managed:\n-                transaction.leave_transaction_management(using=self.db)\n         self._result_cache = None\n         return rows\n     update.alters_data = True"
        },
        {
            "sha": "3a4c3f2b8dd1317cfd84841bd5c2aa1ed06cd019",
            "filename": "django/db/transaction.py",
            "status": "modified",
            "additions": 251,
            "deletions": 36,
            "changes": 287,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Ftransaction.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Ftransaction.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Ftransaction.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -12,9 +12,11 @@\n or implicit commits or rollbacks.\n \"\"\"\n \n+import warnings\n+\n from functools import wraps\n \n-from django.db import connections, DEFAULT_DB_ALIAS\n+from django.db import connections, DatabaseError, DEFAULT_DB_ALIAS\n \n \n class TransactionManagementError(Exception):\n@@ -37,6 +39,10 @@ def get_connection(using=None):\n         using = DEFAULT_DB_ALIAS\n     return connections[using]\n \n+###########################\n+# Deprecated private APIs #\n+###########################\n+\n def abort(using=None):\n     \"\"\"\n     Roll back any ongoing transactions and clean the transaction management\n@@ -49,7 +55,7 @@ def abort(using=None):\n     \"\"\"\n     get_connection(using).abort()\n \n-def enter_transaction_management(managed=True, using=None):\n+def enter_transaction_management(managed=True, using=None, forced=False):\n     \"\"\"\n     Enters transaction management for a running thread. It must be balanced with\n     the appropriate leave_transaction_management call, since the actual state is\n@@ -59,7 +65,7 @@ def enter_transaction_management(managed=True, using=None):\n     from the settings, if there is no surrounding block (dirty is always false\n     when no current block is running).\n     \"\"\"\n-    get_connection(using).enter_transaction_management(managed)\n+    get_connection(using).enter_transaction_management(managed, forced)\n \n def leave_transaction_management(using=None):\n     \"\"\"\n@@ -92,52 +98,47 @@ def set_clean(using=None):\n     \"\"\"\n     get_connection(using).set_clean()\n \n-def clean_savepoints(using=None):\n-    \"\"\"\n-    Resets the counter used to generate unique savepoint ids in this thread.\n-    \"\"\"\n-    get_connection(using).clean_savepoints()\n-\n def is_managed(using=None):\n-    \"\"\"\n-    Checks whether the transaction manager is in manual or in auto state.\n-    \"\"\"\n-    return get_connection(using).is_managed()\n+    warnings.warn(\"'is_managed' is deprecated.\",\n+        PendingDeprecationWarning, stacklevel=2)\n \n def managed(flag=True, using=None):\n-    \"\"\"\n-    Puts the transaction manager into a manual state: managed transactions have\n-    to be committed explicitly by the user. If you switch off transaction\n-    management and there is a pending commit/rollback, the data will be\n-    commited.\n-    \"\"\"\n-    get_connection(using).managed(flag)\n+    warnings.warn(\"'managed' no longer serves a purpose.\",\n+        PendingDeprecationWarning, stacklevel=2)\n \n def commit_unless_managed(using=None):\n-    \"\"\"\n-    Commits changes if the system is not in managed transaction mode.\n-    \"\"\"\n-    get_connection(using).commit_unless_managed()\n+    warnings.warn(\"'commit_unless_managed' is now a no-op.\",\n+        PendingDeprecationWarning, stacklevel=2)\n \n def rollback_unless_managed(using=None):\n-    \"\"\"\n-    Rolls back changes if the system is not in managed transaction mode.\n-    \"\"\"\n-    get_connection(using).rollback_unless_managed()\n+    warnings.warn(\"'rollback_unless_managed' is now a no-op.\",\n+        PendingDeprecationWarning, stacklevel=2)\n \n ###############\n # Public APIs #\n ###############\n \n+def get_autocommit(using=None):\n+    \"\"\"\n+    Get the autocommit status of the connection.\n+    \"\"\"\n+    return get_connection(using).autocommit\n+\n+def set_autocommit(autocommit, using=None):\n+    \"\"\"\n+    Set the autocommit status of the connection.\n+    \"\"\"\n+    return get_connection(using).set_autocommit(autocommit)\n+\n def commit(using=None):\n     \"\"\"\n-    Does the commit itself and resets the dirty flag.\n+    Commits a transaction and resets the dirty flag.\n     \"\"\"\n     get_connection(using).commit()\n \n def rollback(using=None):\n     \"\"\"\n-    This function does the rollback itself and resets the dirty flag.\n+    Rolls back a transaction and resets the dirty flag.\n     \"\"\"\n     get_connection(using).rollback()\n \n@@ -163,9 +164,193 @@ def savepoint_commit(sid, using=None):\n     \"\"\"\n     get_connection(using).savepoint_commit(sid)\n \n-##############\n-# DECORATORS #\n-##############\n+def clean_savepoints(using=None):\n+    \"\"\"\n+    Resets the counter used to generate unique savepoint ids in this thread.\n+    \"\"\"\n+    get_connection(using).clean_savepoints()\n+\n+#################################\n+# Decorators / context managers #\n+#################################\n+\n+class Atomic(object):\n+    \"\"\"\n+    This class guarantees the atomic execution of a given block.\n+\n+    An instance can be used either as a decorator or as a context manager.\n+\n+    When it's used as a decorator, __call__ wraps the execution of the\n+    decorated function in the instance itself, used as a context manager.\n+\n+    When it's used as a context manager, __enter__ creates a transaction or a\n+    savepoint, depending on whether a transaction is already in progress, and\n+    __exit__ commits the transaction or releases the savepoint on normal exit,\n+    and rolls back the transaction or to the savepoint on exceptions.\n+\n+    It's possible to disable the creation of savepoints if the goal is to\n+    ensure that some code runs within a transaction without creating overhead.\n+\n+    A stack of savepoints identifiers is maintained as an attribute of the\n+    connection. None denotes the absence of a savepoint.\n+\n+    This allows reentrancy even if the same AtomicWrapper is reused. For\n+    example, it's possible to define `oa = @atomic('other')` and use `@ao` or\n+    `with oa:` multiple times.\n+\n+    Since database connections are thread-local, this is thread-safe.\n+    \"\"\"\n+\n+    def __init__(self, using, savepoint):\n+        self.using = using\n+        self.savepoint = savepoint\n+\n+    def _legacy_enter_transaction_management(self, connection):\n+        if not connection.in_atomic_block:\n+            if connection.transaction_state and connection.transaction_state[-1]:\n+                connection._atomic_forced_unmanaged = True\n+                connection.enter_transaction_management(managed=False)\n+            else:\n+                connection._atomic_forced_unmanaged = False\n+\n+    def _legacy_leave_transaction_management(self, connection):\n+        if not connection.in_atomic_block and connection._atomic_forced_unmanaged:\n+            connection.leave_transaction_management()\n+\n+    def __enter__(self):\n+        connection = get_connection(self.using)\n+\n+        # Ensure we have a connection to the database before testing\n+        # autocommit status.\n+        connection.ensure_connection()\n+\n+        # Remove this when the legacy transaction management goes away.\n+        self._legacy_enter_transaction_management(connection)\n+\n+        if not connection.in_atomic_block and not connection.autocommit:\n+            raise TransactionManagementError(\n+                \"'atomic' cannot be used when autocommit is disabled.\")\n+\n+        if connection.in_atomic_block:\n+            # We're already in a transaction; create a savepoint, unless we\n+            # were told not to or we're already waiting for a rollback. The\n+            # second condition avoids creating useless savepoints and prevents\n+            # overwriting needs_rollback until the rollback is performed.\n+            if self.savepoint and not connection.needs_rollback:\n+                sid = connection.savepoint()\n+                connection.savepoint_ids.append(sid)\n+            else:\n+                connection.savepoint_ids.append(None)\n+        else:\n+            # We aren't in a transaction yet; create one.\n+            # The usual way to start a transaction is to turn autocommit off.\n+            # However, some database adapters (namely sqlite3) don't handle\n+            # transactions and savepoints properly when autocommit is off.\n+            # In such cases, start an explicit transaction instead, which has\n+            # the side-effect of disabling autocommit.\n+            if connection.features.autocommits_when_autocommit_is_off:\n+                connection._start_transaction_under_autocommit()\n+                connection.autocommit = False\n+            else:\n+                connection.set_autocommit(False)\n+            connection.in_atomic_block = True\n+            connection.needs_rollback = False\n+\n+    def __exit__(self, exc_type, exc_value, traceback):\n+        connection = get_connection(self.using)\n+        if exc_value is None and not connection.needs_rollback:\n+            if connection.savepoint_ids:\n+                # Release savepoint if there is one\n+                sid = connection.savepoint_ids.pop()\n+                if sid is not None:\n+                    try:\n+                        connection.savepoint_commit(sid)\n+                    except DatabaseError:\n+                        connection.savepoint_rollback(sid)\n+                        # Remove this when the legacy transaction management goes away.\n+                        self._legacy_leave_transaction_management(connection)\n+                        raise\n+            else:\n+                # Commit transaction\n+                connection.in_atomic_block = False\n+                try:\n+                    connection.commit()\n+                except DatabaseError:\n+                    connection.rollback()\n+                    # Remove this when the legacy transaction management goes away.\n+                    self._legacy_leave_transaction_management(connection)\n+                    raise\n+                finally:\n+                    if connection.features.autocommits_when_autocommit_is_off:\n+                        connection.autocommit = True\n+                    else:\n+                        connection.set_autocommit(True)\n+        else:\n+            # This flag will be set to True again if there isn't a savepoint\n+            # allowing to perform the rollback at this level.\n+            connection.needs_rollback = False\n+            if connection.savepoint_ids:\n+                # Roll back to savepoint if there is one, mark for rollback\n+                # otherwise.\n+                sid = connection.savepoint_ids.pop()\n+                if sid is None:\n+                    connection.needs_rollback = True\n+                else:\n+                    connection.savepoint_rollback(sid)\n+            else:\n+                # Roll back transaction\n+                connection.in_atomic_block = False\n+                try:\n+                    connection.rollback()\n+                finally:\n+                    if connection.features.autocommits_when_autocommit_is_off:\n+                        connection.autocommit = True\n+                    else:\n+                        connection.set_autocommit(True)\n+\n+        # Remove this when the legacy transaction management goes away.\n+        self._legacy_leave_transaction_management(connection)\n+\n+\n+    def __call__(self, func):\n+        @wraps(func)\n+        def inner(*args, **kwargs):\n+            with self:\n+                return func(*args, **kwargs)\n+        return inner\n+\n+\n+def atomic(using=None, savepoint=True):\n+    # Bare decorator: @atomic -- although the first argument is called\n+    # `using`, it's actually the function being decorated.\n+    if callable(using):\n+        return Atomic(DEFAULT_DB_ALIAS, savepoint)(using)\n+    # Decorator: @atomic(...) or context manager: with atomic(...): ...\n+    else:\n+        return Atomic(using, savepoint)\n+\n+\n+def atomic_if_autocommit(using=None, savepoint=True):\n+    # This variant only exists to support the ability to disable transaction\n+    # management entirely in the DATABASES setting. It doesn't care about the\n+    # autocommit state at run time.\n+    db = DEFAULT_DB_ALIAS if callable(using) else using\n+    autocommit = get_connection(db).settings_dict['AUTOCOMMIT']\n+\n+    if autocommit:\n+        return atomic(using, savepoint)\n+    else:\n+        # Bare decorator: @atomic_if_autocommit\n+        if callable(using):\n+            return using\n+        # Decorator: @atomic_if_autocommit(...)\n+        else:\n+            return lambda func: func\n+\n+\n+############################################\n+# Deprecated decorators / context managers #\n+############################################\n \n class Transaction(object):\n     \"\"\"\n@@ -222,9 +407,11 @@ def autocommit(using=None):\n     this decorator is useful if you globally activated transaction management in\n     your settings file and want the default behavior in some view functions.\n     \"\"\"\n+    warnings.warn(\"autocommit is deprecated in favor of set_autocommit.\",\n+        PendingDeprecationWarning, stacklevel=2)\n+\n     def entering(using):\n         enter_transaction_management(managed=False, using=using)\n-        managed(False, using=using)\n \n     def exiting(exc_value, using):\n         leave_transaction_management(using=using)\n@@ -238,9 +425,11 @@ def commit_on_success(using=None):\n     a rollback is made. This is one of the most common ways to do transaction\n     control in Web apps.\n     \"\"\"\n+    warnings.warn(\"commit_on_success is deprecated in favor of atomic.\",\n+        PendingDeprecationWarning, stacklevel=2)\n+\n     def entering(using):\n         enter_transaction_management(using=using)\n-        managed(True, using=using)\n \n     def exiting(exc_value, using):\n         try:\n@@ -266,11 +455,37 @@ def commit_manually(using=None):\n     own -- it's up to the user to call the commit and rollback functions\n     themselves.\n     \"\"\"\n+    warnings.warn(\"commit_manually is deprecated in favor of set_autocommit.\",\n+        PendingDeprecationWarning, stacklevel=2)\n+\n     def entering(using):\n         enter_transaction_management(using=using)\n-        managed(True, using=using)\n \n     def exiting(exc_value, using):\n         leave_transaction_management(using=using)\n \n     return _transaction_func(entering, exiting, using)\n+\n+def commit_on_success_unless_managed(using=None, savepoint=False):\n+    \"\"\"\n+    Transitory API to preserve backwards-compatibility while refactoring.\n+\n+    Once the legacy transaction management is fully deprecated, this should\n+    simply be replaced by atomic_if_autocommit. Until then, it's necessary to\n+    avoid making a commit where Django didn't use to, since entering atomic in\n+    managed mode triggers a commmit.\n+\n+    Unlike atomic, savepoint defaults to False because that's closer to the\n+    legacy behavior.\n+    \"\"\"\n+    connection = get_connection(using)\n+    if connection.autocommit or connection.in_atomic_block:\n+        return atomic_if_autocommit(using, savepoint)\n+    else:\n+        def entering(using):\n+            pass\n+\n+        def exiting(exc_value, using):\n+            set_dirty(using=using)\n+\n+        return _transaction_func(entering, exiting, using)"
        },
        {
            "sha": "936b42039d5079bc3e6a5f54f9247fa5aeaba66e",
            "filename": "django/db/utils.py",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Futils.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fdb%2Futils.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Futils.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -2,6 +2,7 @@\n import os\n import pkgutil\n from threading import local\n+import warnings\n \n from django.conf import settings\n from django.core.exceptions import ImproperlyConfigured\n@@ -158,6 +159,13 @@ def ensure_defaults(self, alias):\n         except KeyError:\n             raise ConnectionDoesNotExist(\"The connection %s doesn't exist\" % alias)\n \n+        conn.setdefault('ATOMIC_REQUESTS', False)\n+        if settings.TRANSACTIONS_MANAGED:\n+            warnings.warn(\n+                \"TRANSACTIONS_MANAGED is deprecated. Use AUTOCOMMIT instead.\",\n+                PendingDeprecationWarning, stacklevel=2)\n+            conn.setdefault('AUTOCOMMIT', False)\n+        conn.setdefault('AUTOCOMMIT', True)\n         conn.setdefault('ENGINE', 'django.db.backends.dummy')\n         if conn['ENGINE'] == 'django.db.backends.' or not conn['ENGINE']:\n             conn['ENGINE'] = 'django.db.backends.dummy'"
        },
        {
            "sha": "95cc9a21f3bcc71bec6d110804437596cc7a4d00",
            "filename": "django/middleware/transaction.py",
            "status": "modified",
            "additions": 13,
            "deletions": 3,
            "changes": 16,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fmiddleware%2Ftransaction.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Fmiddleware%2Ftransaction.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fmiddleware%2Ftransaction.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -1,4 +1,7 @@\n-from django.db import transaction\n+import warnings\n+\n+from django.core.exceptions import MiddlewareNotUsed\n+from django.db import connection, transaction\n \n class TransactionMiddleware(object):\n     \"\"\"\n@@ -7,10 +10,17 @@ class TransactionMiddleware(object):\n     commit, the commit is done when a successful response is created. If an\n     exception happens, the database is rolled back.\n     \"\"\"\n+\n+    def __init__(self):\n+        warnings.warn(\n+            \"TransactionMiddleware is deprecated in favor of ATOMIC_REQUESTS.\",\n+            PendingDeprecationWarning, stacklevel=2)\n+        if connection.settings_dict['ATOMIC_REQUESTS']:\n+            raise MiddlewareNotUsed\n+\n     def process_request(self, request):\n         \"\"\"Enters transaction management\"\"\"\n         transaction.enter_transaction_management()\n-        transaction.managed(True)\n \n     def process_exception(self, request, exception):\n         \"\"\"Rolls back the database and leaves transaction management\"\"\"\n@@ -24,7 +34,7 @@ def process_exception(self, request, exception):\n \n     def process_response(self, request, response):\n         \"\"\"Commits and leaves transaction management.\"\"\"\n-        if transaction.is_managed():\n+        if not transaction.get_autocommit():\n             if transaction.is_dirty():\n                 # Note: it is possible that the commit fails. If the reason is\n                 # closed connection or some similar reason, then there is"
        },
        {
            "sha": "83762ddee45cd2f5a257ef419493dbd795ad13b6",
            "filename": "django/test/testcases.py",
            "status": "modified",
            "additions": 10,
            "deletions": 26,
            "changes": 36,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Ftest%2Ftestcases.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/django%2Ftest%2Ftestcases.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Ftestcases.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -67,7 +67,6 @@ def to_list(value):\n real_rollback = transaction.rollback\n real_enter_transaction_management = transaction.enter_transaction_management\n real_leave_transaction_management = transaction.leave_transaction_management\n-real_managed = transaction.managed\n real_abort = transaction.abort\n \n def nop(*args, **kwargs):\n@@ -78,15 +77,13 @@ def disable_transaction_methods():\n     transaction.rollback = nop\n     transaction.enter_transaction_management = nop\n     transaction.leave_transaction_management = nop\n-    transaction.managed = nop\n     transaction.abort = nop\n \n def restore_transaction_methods():\n     transaction.commit = real_commit\n     transaction.rollback = real_rollback\n     transaction.enter_transaction_management = real_enter_transaction_management\n     transaction.leave_transaction_management = real_leave_transaction_management\n-    transaction.managed = real_managed\n     transaction.abort = real_abort\n \n \n@@ -157,14 +154,6 @@ def __init__(self, *args, **kwargs):\n         doctest.DocTestRunner.__init__(self, *args, **kwargs)\n         self.optionflags = doctest.ELLIPSIS\n \n-    def report_unexpected_exception(self, out, test, example, exc_info):\n-        doctest.DocTestRunner.report_unexpected_exception(self, out, test,\n-                                                          example, exc_info)\n-        # Rollback, in case of database errors. Otherwise they'd have\n-        # side effects on other tests.\n-        for conn in connections:\n-            transaction.rollback_unless_managed(using=conn)\n-\n \n class _AssertNumQueriesContext(CaptureQueriesContext):\n     def __init__(self, test_case, num, connection):\n@@ -490,14 +479,10 @@ def _reset_sequences(self, db_name):\n                 conn.ops.sequence_reset_by_name_sql(no_style(),\n                                                     conn.introspection.sequence_list())\n             if sql_list:\n-                try:\n+                with transaction.commit_on_success_unless_managed(using=db_name):\n                     cursor = conn.cursor()\n                     for sql in sql_list:\n                         cursor.execute(sql)\n-                except Exception:\n-                    transaction.rollback_unless_managed(using=db_name)\n-                    raise\n-                transaction.commit_unless_managed(using=db_name)\n \n     def _fixture_setup(self):\n         for db_name in self._databases_names(include_mirrors=False):\n@@ -537,11 +522,6 @@ def _post_teardown(self):\n             conn.close()\n \n     def _fixture_teardown(self):\n-        # Roll back any pending transactions in order to avoid a deadlock\n-        # during flush when TEST_MIRROR is used (#18984).\n-        for conn in connections.all():\n-            conn.rollback_unless_managed()\n-\n         for db in self._databases_names(include_mirrors=False):\n             call_command('flush', verbosity=0, interactive=False, database=db,\n                          skip_validation=True, reset_sequences=False)\n@@ -831,9 +811,11 @@ def _fixture_setup(self):\n \n         assert not self.reset_sequences, 'reset_sequences cannot be used on TestCase instances'\n \n+        self.atomics = {}\n         for db_name in self._databases_names():\n-            transaction.enter_transaction_management(using=db_name)\n-            transaction.managed(True, using=db_name)\n+            self.atomics[db_name] = transaction.atomic(using=db_name)\n+            self.atomics[db_name].__enter__()\n+        # Remove this when the legacy transaction management goes away.\n         disable_transaction_methods()\n \n         from django.contrib.sites.models import Site\n@@ -853,10 +835,12 @@ def _fixture_teardown(self):\n         if not connections_support_transactions():\n             return super(TestCase, self)._fixture_teardown()\n \n+        # Remove this when the legacy transaction management goes away.\n         restore_transaction_methods()\n-        for db in self._databases_names():\n-            transaction.rollback(using=db)\n-            transaction.leave_transaction_management(using=db)\n+        for db_name in reversed(self._databases_names()):\n+            # Hack to force a rollback\n+            connections[db_name].needs_rollback = True\n+            self.atomics[db_name].__exit__(None, None, None)\n \n \n def _deferredSkip(condition, reason):"
        },
        {
            "sha": "19675801e43c6b6486bd37e5c197fab15b08f845",
            "filename": "docs/internals/deprecation.txt",
            "status": "modified",
            "additions": 17,
            "deletions": 2,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Finternals%2Fdeprecation.txt",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Finternals%2Fdeprecation.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Finternals%2Fdeprecation.txt?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -329,6 +329,15 @@ these changes.\n 1.8\n ---\n \n+* The following transaction management APIs will be removed:\n+\n+  - ``TransactionMiddleware``,\n+  - the decorators and context managers ``autocommit``, ``commit_on_success``,\n+    and ``commit_manually``,\n+  - the ``TRANSACTIONS_MANAGED`` setting.\n+\n+  Upgrade paths are described in :ref:`transactions-upgrading-from-1.5`.\n+\n * The :ttag:`cycle` and :ttag:`firstof` template tags will auto-escape their\n   arguments. In 1.6 and 1.7, this behavior is provided by the version of these\n   tags in the ``future`` template tag library.\n@@ -339,8 +348,6 @@ these changes.\n \n * ``Model._meta.module_name`` was renamed to ``model_name``.\n \n-* The private API ``django.db.close_connection`` will be removed.\n-\n * Remove the backward compatible shims introduced to rename ``get_query_set``\n   and similar queryset methods. This affects the following classes:\n   ``BaseModelAdmin``, ``ChangeList``, ``BaseCommentNode``,\n@@ -350,6 +357,14 @@ these changes.\n * Remove the backward compatible shims introduced to rename the attributes\n   ``ChangeList.root_query_set`` and ``ChangeList.query_set``.\n \n+* The following private APIs will be removed:\n+  - ``django.db.close_connection()``\n+  - ``django.db.backends.creation.BaseDatabaseCreation.set_autocommit()``\n+  - ``django.db.transaction.is_managed()``\n+  - ``django.db.transaction.managed()``\n+  - ``django.db.transaction.commit_unless_managed()``\n+  - ``django.db.transaction.rollback_unless_managed()``\n+\n 2.0\n ---\n "
        },
        {
            "sha": "78c1bb3dda168186800f55f86f82fa74f06af840",
            "filename": "docs/ref/databases.txt",
            "status": "modified",
            "additions": 13,
            "deletions": 46,
            "changes": 59,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Fref%2Fdatabases.txt",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Fref%2Fdatabases.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fdatabases.txt?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -69,7 +69,6 @@ even ``0``, because it doesn't make sense to maintain a connection that's\n unlikely to be reused. This will help keep the number of simultaneous\n connections to this database small.\n \n-\n The development server creates a new thread for each request it handles,\n negating the effect of persistent connections.\n \n@@ -104,7 +103,8 @@ Optimizing PostgreSQL's configuration\n Django needs the following parameters for its database connections:\n \n - ``client_encoding``: ``'UTF8'``,\n-- ``default_transaction_isolation``: ``'read committed'``,\n+- ``default_transaction_isolation``: ``'read committed'`` by default,\n+  or the value set in the connection options (see below),\n - ``timezone``: ``'UTC'`` when :setting:`USE_TZ` is ``True``, value of\n   :setting:`TIME_ZONE` otherwise.\n \n@@ -118,30 +118,16 @@ will do some additional queries to set these parameters.\n \n .. _ALTER ROLE: http://www.postgresql.org/docs/current/interactive/sql-alterrole.html\n \n-Transaction handling\n----------------------\n-\n-:doc:`By default </topics/db/transactions>`, Django runs with an open\n-transaction which it commits automatically when any built-in, data-altering\n-model function is called. The PostgreSQL backends normally operate the same as\n-any other Django backend in this respect.\n-\n .. _postgresql-autocommit-mode:\n \n Autocommit mode\n-~~~~~~~~~~~~~~~\n+---------------\n \n-If your application is particularly read-heavy and doesn't make many\n-database writes, the overhead of a constantly open transaction can\n-sometimes be noticeable. For those situations, you can configure Django\n-to use *\"autocommit\"* behavior for the connection, meaning that each database\n-operation will normally be in its own transaction, rather than having\n-the transaction extend over multiple operations. In this case, you can\n-still manually start a transaction if you're doing something that\n-requires consistency across multiple database operations. The\n-autocommit behavior is enabled by setting the ``autocommit`` key in\n-the :setting:`OPTIONS` part of your database configuration in\n-:setting:`DATABASES`::\n+.. versionchanged:: 1.6\n+\n+In previous versions of Django, database-level autocommit could be enabled by\n+setting the ``autocommit`` key in the :setting:`OPTIONS` part of your database\n+configuration in :setting:`DATABASES`::\n \n     DATABASES = {\n         # ...\n@@ -150,29 +136,11 @@ the :setting:`OPTIONS` part of your database configuration in\n         },\n     }\n \n-In this configuration, Django still ensures that :ref:`delete()\n-<topics-db-queries-delete>` and :ref:`update() <topics-db-queries-update>`\n-queries run inside a single transaction, so that either all the affected\n-objects are changed or none of them are.\n-\n-.. admonition:: This is database-level autocommit\n-\n-    This functionality is not the same as the :ref:`autocommit\n-    <topics-db-transactions-autocommit>` decorator. That decorator is\n-    a Django-level implementation that commits automatically after\n-    data changing operations. The feature enabled using the\n-    :setting:`OPTIONS` option provides autocommit behavior at the\n-    database adapter level. It commits after *every* operation.\n-\n-If you are using this feature and performing an operation akin to delete or\n-updating that requires multiple operations, you are strongly recommended to\n-wrap you operations in manual transaction handling to ensure data consistency.\n-You should also audit your existing code for any instances of this behavior\n-before enabling this feature. It's faster, but it provides less automatic\n-protection for multi-call operations.\n+Since Django 1.6, autocommit is turned on by default. This configuration is\n+ignored and can be safely removed.\n \n Isolation level\n-~~~~~~~~~~~~~~~\n+---------------\n \n .. versionadded:: 1.6\n \n@@ -200,7 +168,7 @@ such as ``REPEATABLE READ`` or ``SERIALIZABLE``, set it in the\n .. _postgresql-isolation-levels: http://www.postgresql.org/docs/devel/static/transaction-iso.html\n \n Indexes for ``varchar`` and ``text`` columns\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+--------------------------------------------\n \n When specifying ``db_index=True`` on your model fields, Django typically\n outputs a single ``CREATE INDEX`` statement.  However, if the database type\n@@ -456,8 +424,7 @@ Savepoints\n \n Both the Django ORM and MySQL (when using the InnoDB :ref:`storage engine\n <mysql-storage-engines>`) support database :ref:`savepoints\n-<topics-db-transactions-savepoints>`, but this feature wasn't available in\n-Django until version 1.4 when such supports was added.\n+<topics-db-transactions-savepoints>`.\n \n If you use the MyISAM storage engine please be aware of the fact that you will\n receive database-generated errors if you try to use the :ref:`savepoint-related"
        },
        {
            "sha": "20bb2fb751bc8440ffd1bebd7956c87e447c2d79",
            "filename": "docs/ref/middleware.txt",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Fref%2Fmiddleware.txt",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Fref%2Fmiddleware.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmiddleware.txt?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -205,6 +205,10 @@ Transaction middleware\n \n .. class:: TransactionMiddleware\n \n+.. versionchanged:: 1.6\n+    ``TransactionMiddleware`` is deprecated. The documentation of transactions\n+    contains :ref:`upgrade instructions <transactions-upgrading-from-1.5>`.\n+\n Binds commit and rollback of the default database to the request/response\n phase. If a view function runs successfully, a commit is done. If it fails with\n an exception, a rollback is done."
        },
        {
            "sha": "6f620e17e2f2510d040f6aa9171c87dd4e01cedf",
            "filename": "docs/ref/request-response.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Fref%2Frequest-response.txt",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Fref%2Frequest-response.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Frequest-response.txt?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -814,8 +814,8 @@ generating large CSV files.\n .. admonition:: Performance considerations\n \n     Django is designed for short-lived requests. Streaming responses will tie\n-    a worker process and keep a database connection idle in transaction for\n-    the entire duration of the response. This may result in poor performance.\n+    a worker process for the entire duration of the response. This may result\n+    in poor performance.\n \n     Generally speaking, you should perform expensive tasks outside of the\n     request-response cycle, rather than resorting to a streamed response."
        },
        {
            "sha": "2b80527d8b0eb11203433b46bc4462dfe5302bca",
            "filename": "docs/ref/settings.txt",
            "status": "modified",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Fref%2Fsettings.txt",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Fref%2Fsettings.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fsettings.txt?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -408,6 +408,30 @@ SQLite. This can be configured using the following::\n For other database backends, or more complex SQLite configurations, other options\n will be required. The following inner options are available.\n \n+.. setting:: DATABASE-ATOMIC_REQUESTS\n+\n+ATOMIC_REQUESTS\n+~~~~~~~~~~~~~~~\n+\n+.. versionadded:: 1.6\n+\n+Default: ``False``\n+\n+Set this to ``True`` to wrap each HTTP request in a transaction on this\n+database. See :ref:`tying-transactions-to-http-requests`.\n+\n+.. setting:: DATABASE-AUTOCOMMIT\n+\n+AUTOCOMMIT\n+~~~~~~~~~~\n+\n+.. versionadded:: 1.6\n+\n+Default: ``True``\n+\n+Set this to ``False`` if you want to :ref:`disable Django's transaction\n+management <deactivate-transaction-management>` and implement your own.\n+\n .. setting:: DATABASE-ENGINE\n \n ENGINE\n@@ -1807,6 +1831,12 @@ to ensure your processes are running in the correct environment.\n TRANSACTIONS_MANAGED\n --------------------\n \n+.. deprecated:: 1.6\n+\n+    This setting was deprecated because its name is very misleading. Use the\n+    :setting:`AUTOCOMMIT <DATABASE-AUTOCOMMIT>` key in :setting:`DATABASES`\n+    entries instead.\n+\n Default: ``False``\n \n Set this to ``True`` if you want to :ref:`disable Django's transaction"
        },
        {
            "sha": "53d38a006b9bc6225802937239eb67d6aebef1ca",
            "filename": "docs/releases/1.3-alpha-1.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Freleases%2F1.3-alpha-1.txt",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Freleases%2F1.3-alpha-1.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.3-alpha-1.txt?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -105,16 +105,14 @@ you just won't get any of the nice new unittest2 features.\n Transaction context managers\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-Users of Python 2.5 and above may now use :ref:`transaction management functions\n-<transaction-management-functions>` as `context managers`_. For example::\n+Users of Python 2.5 and above may now use transaction management functions as\n+`context managers`_. For example::\n \n     with transaction.autocommit():\n         # ...\n \n .. _context managers: http://docs.python.org/glossary.html#term-context-manager\n \n-For more information, see :ref:`transaction-management-functions`.\n-\n Configurable delete-cascade\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "582bceffca4924e918bcafad4e26d7a27558cb03",
            "filename": "docs/releases/1.3.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Freleases%2F1.3.txt",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Freleases%2F1.3.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.3.txt?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -148,16 +148,14 @@ you just won't get any of the nice new unittest2 features.\n Transaction context managers\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-Users of Python 2.5 and above may now use :ref:`transaction management functions\n-<transaction-management-functions>` as `context managers`_. For example::\n+Users of Python 2.5 and above may now use transaction management functions as\n+`context managers`_. For example::\n \n     with transaction.autocommit():\n         # ...\n \n .. _context managers: http://docs.python.org/glossary.html#term-context-manager\n \n-For more information, see :ref:`transaction-management-functions`.\n-\n Configurable delete-cascade\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "a1fe69229c0712772bb0463dfe6f92d51aea0e20",
            "filename": "docs/releases/1.6.txt",
            "status": "modified",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Freleases%2F1.6.txt",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Freleases%2F1.6.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.6.txt?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -30,6 +30,18 @@ prevention <clickjacking-prevention>` are turned on.\n If the default templates don't suit your tastes, you can use :ref:`custom\n project and app templates <custom-app-and-project-templates>`.\n \n+Improved transaction management\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Django's transaction management was overhauled. Database-level autocommit is\n+now turned on by default. This makes transaction handling more explicit and\n+should improve performance. The existing APIs were deprecated, and new APIs\n+were introduced, as described in :doc:`/topics/db/transactions`.\n+\n+Please review carefully the list of :ref:`known backwards-incompatibilities\n+<transactions-upgrading-from-1.5>` to determine if you need to make changes in\n+your code.\n+\n Persistent database connections\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n@@ -148,6 +160,16 @@ Backwards incompatible changes in 1.6\n     deprecation timeline for a given feature, its removal may appear as a\n     backwards incompatible change.\n \n+* Database-level autocommit is enabled by default in Django 1.6. While this\n+  doesn't change the general spirit of Django's transaction management, there\n+  are a few known backwards-incompatibities, described in the :ref:`transaction\n+  management docs <transactions-upgrading-from-1.5>`. You should review your code\n+  to determine if you're affected.\n+\n+* In previous versions, database-level autocommit was only an option for\n+  PostgreSQL, and it was disabled by default. This option is now\n+  :ref:`ignored <postgresql-autocommit-mode>`.\n+\n * The ``django.db.models.query.EmptyQuerySet`` can't be instantiated any more -\n   it is only usable as a marker class for checking if\n   :meth:`~django.db.models.query.QuerySet.none` has been called:\n@@ -234,6 +256,21 @@ Backwards incompatible changes in 1.6\n Features deprecated in 1.6\n ==========================\n \n+Transaction management APIs\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Transaction management was completely overhauled in Django 1.6, and the\n+current APIs are deprecated:\n+\n+- ``django.middleware.transaction.TransactionMiddleware``\n+- ``django.db.transaction.autocommit``\n+- ``django.db.transaction.commit_on_success``\n+- ``django.db.transaction.commit_manually``\n+- the ``TRANSACTIONS_MANAGED`` setting\n+\n+The reasons for this change and the upgrade path are described in the\n+:ref:`transactions documentation <transactions-upgrading-from-1.5>`.\n+\n Changes to :ttag:`cycle` and :ttag:`firstof`\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "b2161fe65b89790f8ba7f9399405ed2367dfe3e9",
            "filename": "docs/topics/db/sql.txt",
            "status": "modified",
            "additions": 26,
            "deletions": 35,
            "changes": 61,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Ftopics%2Fdb%2Fsql.txt",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Ftopics%2Fdb%2Fsql.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Fsql.txt?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -201,31 +201,32 @@ perform queries that don't map cleanly to models, or directly execute\n In these cases, you can always access the database directly, routing around\n the model layer entirely.\n \n-The object ``django.db.connection`` represents the\n-default database connection, and ``django.db.transaction`` represents the\n-default database transaction. To use the database connection, call\n-``connection.cursor()`` to get a cursor object. Then, call\n-``cursor.execute(sql, [params])`` to execute the SQL and ``cursor.fetchone()``\n-or ``cursor.fetchall()`` to return the resulting rows. After performing a data\n-changing operation, you should then call\n-``transaction.commit_unless_managed()`` to ensure your changes are committed\n-to the database. If your query is purely a data retrieval operation, no commit\n-is required. For example::\n+The object ``django.db.connection`` represents the default database\n+connection. To use the database connection, call ``connection.cursor()`` to\n+get a cursor object. Then, call ``cursor.execute(sql, [params])`` to execute\n+the SQL and ``cursor.fetchone()`` or ``cursor.fetchall()`` to return the\n+resulting rows.\n+\n+For example::\n+\n+    from django.db import connection\n \n     def my_custom_sql():\n-        from django.db import connection, transaction\n         cursor = connection.cursor()\n \n-        # Data modifying operation - commit required\n         cursor.execute(\"UPDATE bar SET foo = 1 WHERE baz = %s\", [self.baz])\n-        transaction.commit_unless_managed()\n \n-        # Data retrieval operation - no commit required\n         cursor.execute(\"SELECT foo FROM bar WHERE baz = %s\", [self.baz])\n         row = cursor.fetchone()\n \n         return row\n \n+.. versionchanged:: 1.6\n+    In Django 1.5 and earlier, after performing a data changing operation, you\n+    had to call ``transaction.commit_unless_managed()`` to ensure your changes\n+    were committed to the database. Since Django now defaults to database-level\n+    autocommit, this isn't necessary any longer.\n+\n If you are using :doc:`more than one database </topics/db/multi-db>`, you can\n use ``django.db.connections`` to obtain the connection (and cursor) for a\n specific database. ``django.db.connections`` is a dictionary-like\n@@ -235,7 +236,6 @@ alias::\n     from django.db import connections\n     cursor = connections['my_db_alias'].cursor()\n     # Your code here...\n-    transaction.commit_unless_managed(using='my_db_alias')\n \n By default, the Python DB API will return results without their field\n names, which means you end up with a ``list`` of values, rather than a\n@@ -260,27 +260,18 @@ Here is an example of the difference between the two::\n     >>> dictfetchall(cursor)\n     [{'parent_id': None, 'id': 54360982L}, {'parent_id': None, 'id': 54360880L}]\n \n-\n-.. _transactions-and-raw-sql:\n-\n-Transactions and raw SQL\n-------------------------\n-\n-When you make a raw SQL call, Django will automatically mark the\n-current transaction as dirty. You must then ensure that the\n-transaction containing those calls is closed correctly. See :ref:`the\n-notes on the requirements of Django's transaction handling\n-<topics-db-transactions-requirements>` for more details.\n-\n Connections and cursors\n -----------------------\n \n ``connection`` and ``cursor`` mostly implement the standard Python DB-API\n-described in :pep:`249` (except when it comes to :doc:`transaction handling\n-</topics/db/transactions>`). If you're not familiar with the Python DB-API, note\n-that the SQL statement in ``cursor.execute()`` uses placeholders, ``\"%s\"``,\n-rather than adding parameters directly within the SQL. If you use this\n-technique, the underlying database library will automatically add quotes and\n-escaping to your parameter(s) as necessary. (Also note that Django expects the\n-``\"%s\"`` placeholder, *not* the ``\"?\"`` placeholder, which is used by the SQLite\n-Python bindings. This is for the sake of consistency and sanity.)\n+described in :pep:`249`  except when it comes to :doc:`transaction handling\n+</topics/db/transactions>`.\n+\n+If you're not familiar with the Python DB-API, note that the SQL statement in\n+``cursor.execute()`` uses placeholders, ``\"%s\"``, rather than adding\n+parameters directly within the SQL. If you use this technique, the underlying\n+database library will automatically escape your parameters as necessary.\n+\n+Also note that Django expects the ``\"%s\"`` placeholder, *not* the ``\"?\"``\n+placeholder, which is used by the SQLite Python bindings. This is for the sake\n+of consistency and sanity."
        },
        {
            "sha": "b8017e8bfab725610ab4e563bc4f4cc653f25dde",
            "filename": "docs/topics/db/transactions.txt",
            "status": "modified",
            "additions": 525,
            "deletions": 219,
            "changes": 744,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/docs%2Ftopics%2Fdb%2Ftransactions.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Ftransactions.txt?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -1,286 +1,375 @@\n-==============================\n-Managing database transactions\n-==============================\n+=====================\n+Database transactions\n+=====================\n \n .. module:: django.db.transaction\n \n-Django gives you a few ways to control how database transactions are managed,\n-if you're using a database that supports transactions.\n+Django gives you a few ways to control how database transactions are managed.\n+\n+Managing database transactions\n+==============================\n \n Django's default transaction behavior\n-=====================================\n+-------------------------------------\n+\n+Django's default behavior is to run in autocommit mode. Each query is\n+immediately committed to the database. :ref:`See below for details\n+<autocommit-details>`.\n \n-Django's default behavior is to run with an open transaction which it\n-commits automatically when any built-in, data-altering model function is\n-called. For example, if you call ``model.save()`` or ``model.delete()``, the\n-change will be committed immediately.\n+Django uses transactions or savepoints automatically to guarantee the\n+integrity of ORM operations that require multiple queries, especially\n+:ref:`delete() <topics-db-queries-delete>` and :ref:`update()\n+<topics-db-queries-update>` queries.\n \n-This is much like the auto-commit setting for most databases. As soon as you\n-perform an action that needs to write to the database, Django produces the\n-``INSERT``/``UPDATE``/``DELETE`` statements and then does the ``COMMIT``.\n-There's no implicit ``ROLLBACK``.\n+.. versionchanged:: 1.6\n+    Previous version of Django featured :ref:`a more complicated default\n+    behavior <transactions-upgrading-from-1.5>`.\n+\n+.. _tying-transactions-to-http-requests:\n \n Tying transactions to HTTP requests\n-===================================\n+-----------------------------------\n \n-The recommended way to handle transactions in Web requests is to tie them to\n-the request and response phases via Django's ``TransactionMiddleware``.\n+A common way to handle transactions on the web is to wrap each request in a\n+transaction. Set :setting:`ATOMIC_REQUESTS <DATABASE-ATOMIC_REQUESTS>` to\n+``True`` in the configuration of each database for which you want to enable\n+this behavior.\n \n-It works like this: When a request starts, Django starts a transaction. If the\n-response is produced without problems, Django commits any pending transactions.\n-If the view function produces an exception, Django rolls back any pending\n-transactions.\n+It works like this. When a request starts, Django starts a transaction. If the\n+response is produced without problems, Django commits the transaction. If the\n+view function produces an exception, Django rolls back the transaction.\n+Middleware always runs outside of this transaction.\n \n-To activate this feature, just add the ``TransactionMiddleware`` middleware to\n-your :setting:`MIDDLEWARE_CLASSES` setting::\n+You may perfom partial commits and rollbacks in your view code, typically with\n+the :func:`atomic` context manager. However, at the end of the view, either\n+all the changes will be committed, or none of them.\n \n-    MIDDLEWARE_CLASSES = (\n-        'django.middleware.cache.UpdateCacheMiddleware',\n-        'django.contrib.sessions.middleware.SessionMiddleware',\n-        'django.middleware.common.CommonMiddleware',\n-        'django.middleware.transaction.TransactionMiddleware',\n-        'django.middleware.cache.FetchFromCacheMiddleware',\n-    )\n+To disable this behavior for a specific view, you must set the\n+``transactions_per_request`` attribute of the view function itself to\n+``False``, like this::\n \n-The order is quite important. The transaction middleware applies not only to\n-view functions, but also for all middleware modules that come after it. So if\n-you use the session middleware after the transaction middleware, session\n-creation will be part of the transaction.\n+    def my_view(request):\n+        do_stuff()\n+    my_view.transactions_per_request = False\n \n-The various cache middlewares are an exception:\n-``CacheMiddleware``, :class:`~django.middleware.cache.UpdateCacheMiddleware`,\n-and :class:`~django.middleware.cache.FetchFromCacheMiddleware` are never\n-affected. Even when using database caching, Django's cache backend uses its own\n-database cursor (which is mapped to its own database connection internally).\n+.. warning::\n \n-.. note::\n+    While the simplicity of this transaction model is appealing, it also makes it\n+    inefficient when traffic increases. Opening a transaction for every view has\n+    some overhead. The impact on performance depends on the query patterns of your\n+    application and on how well your database handles locking.\n \n-    The ``TransactionMiddleware`` only affects the database aliased\n-    as \"default\" within your :setting:`DATABASES` setting.  If you are using\n-    multiple databases and want transaction control over databases other than\n-    \"default\", you will need to write your own transaction middleware.\n+.. admonition:: Per-request transactions and streaming responses\n \n-.. _transaction-management-functions:\n+    When a view returns a :class:`~django.http.StreamingHttpResponse`, reading\n+    the contents of the response will often execute code to generate the\n+    content. Since the view has already returned, such code runs outside of\n+    the transaction.\n \n-Controlling transaction management in views\n-===========================================\n+    Generally speaking, it isn't advisable to write to the database while\n+    generating a streaming response, since there's no sensible way to handle\n+    errors after starting to send the response.\n \n-For most people, implicit request-based transactions work wonderfully. However,\n-if you need more fine-grained control over how transactions are managed, you can\n-use a set of functions in ``django.db.transaction`` to control transactions on a\n-per-function or per-code-block basis.\n+In practice, this feature simply wraps every view function in the :func:`atomic`\n+decorator described below.\n \n-These functions, described in detail below, can be used in two different ways:\n+Note that only the execution of your view in enclosed in the transactions.\n+Middleware run outside of the transaction, and so does the rendering of\n+template responses.\n \n-* As a decorator_ on a particular function. For example::\n+.. versionchanged:: 1.6\n+    Django used to provide this feature via ``TransactionMiddleware``, which is\n+    now deprecated.\n \n-    from django.db import transaction\n+Controlling transactions explicitly\n+-----------------------------------\n \n-    @transaction.commit_on_success\n-    def viewfunc(request):\n-        # ...\n-        # this code executes inside a transaction\n-        # ...\n+.. versionadded:: 1.6\n \n-* As a `context manager`_ around a particular block of code::\n+Django provides a single API to control database transactions.\n \n-    from django.db import transaction\n+.. function:: atomic(using=None, savepoint=True)\n \n-    def viewfunc(request):\n-        # ...\n-        # this code executes using default transaction management\n-        # ...\n+    This function creates an atomic block for writes to the database.\n+    (Atomicity is the defining property of database transactions.)\n \n-        with transaction.commit_on_success():\n-            # ...\n-            # this code executes inside a transaction\n-            # ...\n+    When the block completes successfully, the changes are committed to the\n+    database. When it raises an exception, the changes are rolled back.\n \n-Both techniques work with all supported version of Python.\n+    ``atomic`` can be nested. In this case, when an inner block completes\n+    successfully, its effects can still be rolled back if an exception is\n+    raised in the outer block at a later point.\n \n-.. _decorator: http://docs.python.org/glossary.html#term-decorator\n-.. _context manager: http://docs.python.org/glossary.html#term-context-manager\n+    ``atomic`` takes a ``using`` argument which should be the name of a\n+    database. If this argument isn't provided, Django uses the ``\"default\"``\n+    database.\n \n-For maximum compatibility, all of the examples below show transactions using the\n-decorator syntax, but all of the follow functions may be used as context\n-managers, too.\n+    ``atomic`` is usable both as a `decorator`_::\n \n-.. note::\n+        from django.db import transaction\n \n-    Although the examples below use view functions as examples, these\n-    decorators and context managers can be used anywhere in your code\n-    that you need to deal with transactions.\n+        @transaction.atomic\n+        def viewfunc(request):\n+            # This code executes inside a transaction.\n+            do_stuff()\n \n-.. _topics-db-transactions-autocommit:\n+    and as a `context manager`_::\n \n-.. function:: autocommit\n+        from django.db import transaction\n \n-    Use the ``autocommit`` decorator to switch a view function to Django's\n-    default commit behavior, regardless of the global transaction setting.\n+        def viewfunc(request):\n+            # This code executes in autocommit mode (Django's default).\n+            do_stuff()\n \n-    Example::\n+            with transaction.atomic():\n+                # This code executes inside a transaction.\n+                do_more_stuff()\n \n-        from django.db import transaction\n+    .. _decorator: http://docs.python.org/glossary.html#term-decorator\n+    .. _context manager: http://docs.python.org/glossary.html#term-context-manager\n \n-        @transaction.autocommit\n+    Wrapping ``atomic`` in a try/except block allows for natural handling of\n+    integrity errors::\n+\n+        from django.db import IntegrityError, transaction\n+\n+        @transaction.atomic\n         def viewfunc(request):\n-            ....\n+            do_stuff()\n \n-        @transaction.autocommit(using=\"my_other_database\")\n-        def viewfunc2(request):\n-            ....\n+            try:\n+                with transaction.atomic():\n+                    do_stuff_that_could_fail()\n+            except IntegrityError:\n+                handle_exception()\n \n-    Within ``viewfunc()``, transactions will be committed as soon as you call\n-    ``model.save()``, ``model.delete()``, or any other function that writes to\n-    the database.  ``viewfunc2()`` will have this same behavior, but for the\n-    ``\"my_other_database\"`` connection.\n+            do_more_stuff()\n \n-.. function:: commit_on_success\n+    In this example, even if ``do_stuff_that_could_fail()`` causes a database\n+    error by breaking an integrity constraint, you can execute queries in\n+    ``do_more_stuff()``, and the changes from ``do_stuff()`` are still there.\n \n-    Use the ``commit_on_success`` decorator to use a single transaction for all\n-    the work done in a function::\n+    In order to guarantee atomicity, ``atomic`` disables some APIs. Attempting\n+    to commit, roll back, or change the autocommit state of the database\n+    connection within an ``atomic`` block will raise an exception.\n \n-        from django.db import transaction\n+    ``atomic`` can only be used in autocommit mode. It will raise an exception\n+    if autocommit is turned off.\n \n-        @transaction.commit_on_success\n-        def viewfunc(request):\n-            ....\n+    Under the hood, Django's transaction management code:\n \n-        @transaction.commit_on_success(using=\"my_other_database\")\n-        def viewfunc2(request):\n-            ....\n+    - opens a transaction when entering the outermost ``atomic`` block;\n+    - creates a savepoint when entering an inner ``atomic`` block;\n+    - releases or rolls back to the savepoint when exiting an inner block;\n+    - commits or rolls back the transaction when exiting the outermost block.\n \n-    If the function returns successfully, then Django will commit all work done\n-    within the function at that point. If the function raises an exception,\n-    though, Django will roll back the transaction.\n+    You can disable the creation of savepoints for inner blocks by setting the\n+    ``savepoint`` argument to ``False``. If an exception occurs, Django will\n+    perform the rollback when exiting the first parent block with a savepoint\n+    if there is one, and the outermost block otherwise. Atomicity is still\n+    guaranteed by the outer transaction. This option should only be used if\n+    the overhead of savepoints is noticeable. It has the drawback of breaking\n+    the error handling described above.\n \n-.. function:: commit_manually\n+.. admonition:: Performance considerations\n \n-    Use the ``commit_manually`` decorator if you need full control over\n-    transactions. It tells Django you'll be managing the transaction on your\n-    own.\n+    Open transactions have a performance cost for your database server. To\n+    minimize this overhead, keep your transactions as short as possible. This\n+    is especially important of you're using :func:`atomic` in long-running\n+    processes, outside of Django's request / response cycle.\n \n-    Whether you are writing or simply reading from the database, you must\n-    ``commit()`` or ``rollback()`` explicitly or Django will raise a\n-    :exc:`TransactionManagementError` exception. This is required when reading\n-    from the database because ``SELECT`` statements may call functions which\n-    modify tables, and thus it is impossible to know if any data has been\n-    modified.\n+Autocommit\n+==========\n \n-    Manual transaction management looks like this::\n+.. _autocommit-details:\n \n-        from django.db import transaction\n+Why Django uses autocommit\n+--------------------------\n \n-        @transaction.commit_manually\n-        def viewfunc(request):\n-            ...\n-            # You can commit/rollback however and whenever you want\n-            transaction.commit()\n-            ...\n+In the SQL standards, each SQL query starts a transaction, unless one is\n+already in progress. Such transactions must then be committed or rolled back.\n \n-            # But you've got to remember to do it yourself!\n-            try:\n-                ...\n-            except:\n-                transaction.rollback()\n-            else:\n-                transaction.commit()\n-\n-        @transaction.commit_manually(using=\"my_other_database\")\n-        def viewfunc2(request):\n-            ....\n-\n-.. _topics-db-transactions-requirements:\n-\n-Requirements for transaction handling\n-=====================================\n-\n-Django requires that every transaction that is opened is closed before\n-the completion of a request. If you are using :func:`autocommit` (the\n-default commit mode) or :func:`commit_on_success`, this will be done\n-for you automatically (with the exception of :ref:`executing custom SQL\n-<executing-custom-sql>`). However, if you are manually managing\n-transactions (using the :func:`commit_manually` decorator), you must\n-ensure that the transaction is either committed or rolled back before\n-a request is completed.\n-\n-This applies to all database operations, not just write operations. Even\n-if your transaction only reads from the database, the transaction must\n-be committed or rolled back before you complete a request.\n+This isn't always convenient for application developers. To alleviate this\n+problem, most databases provide an autocommit mode. When autocommit is turned\n+on, each SQL query is wrapped in its own transaction. In other words, the\n+transaction is not only automatically started, but also automatically\n+committed.\n+\n+:pep:`249`, the Python Database API Specification v2.0, requires autocommit to\n+be initially turned off. Django overrides this default and turns autocommit\n+on.\n+\n+To avoid this, you can :ref:`deactivate the transaction management\n+<deactivate-transaction-management>`, but it isn't recommended.\n+\n+.. versionchanged:: 1.6\n+    Before Django 1.6, autocommit was turned off, and it was emulated by\n+    forcing a commit after write operations in the ORM.\n+\n+.. warning::\n+\n+    If you're using the database API directly  for instance, you're running\n+    SQL queries with ``cursor.execute()``  be aware that autocommit is on,\n+    and consider wrapping your operations in a transaction, with\n+    :func:`atomic`, to ensure consistency.\n \n .. _deactivate-transaction-management:\n \n-How to globally deactivate transaction management\n-=================================================\n+Deactivating transaction management\n+-----------------------------------\n+\n+You can totally disable Django's transaction management for a given database\n+by setting :setting:`AUTOCOMMIT <DATABASE-AUTOCOMMIT>` to ``False`` in its\n+configuration. If you do this, Django won't enable autocommit, and won't\n+perform any commits. You'll get the regular behavior of the underlying\n+database library.\n+\n+This requires you to commit explicitly every transaction, even those started\n+by Django or by third-party libraries. Thus, this is best used in situations\n+where you want to run your own transaction-controlling middleware or do\n+something really strange.\n+\n+.. versionchanged:: 1.6\n+    This used to be controlled by the ``TRANSACTIONS_MANAGED`` setting.\n+\n+Low-level APIs\n+==============\n+\n+.. warning::\n+\n+    Always prefer :func:`atomic` if possible at all. It accounts for the\n+    idiosyncrasies of each database and prevents invalid operations.\n+\n+    The low level APIs are only useful if you're implementing your own\n+    transaction management.\n+\n+.. _managing-autocommit:\n+\n+Autocommit\n+----------\n+\n+.. versionadded:: 1.6\n+\n+Django provides a straightforward API to manage the autocommit state of each\n+database connection, if you need to.\n+\n+.. function:: get_autocommit(using=None)\n+\n+.. function:: set_autocommit(autocommit, using=None)\n+\n+These functions take a ``using`` argument which should be the name of a\n+database. If it isn't provided, Django uses the ``\"default\"`` database.\n+\n+Autocommit is initially turned on. If you turn it off, it's your\n+responsibility to restore it.\n+\n+Once you turn autocommit off, you get the default behavior of your database\n+adapter, and Django won't help you. Although that behavior is specified in\n+:pep:`249`, implementations of adapters aren't always consistent with one\n+another. Review the documentation of the adapter you're using carefully.\n \n-Control freaks can totally disable all transaction management by setting\n-:setting:`TRANSACTIONS_MANAGED` to ``True`` in the Django settings file.\n+You must ensure that no transaction is active, usually by issuing a\n+:func:`commit` or a :func:`rollback`, before turning autocommit back on.\n \n-If you do this, Django won't provide any automatic transaction management\n-whatsoever. Middleware will no longer implicitly commit transactions, and\n-you'll need to roll management yourself. This even requires you to commit\n-changes done by middleware somewhere else.\n+:func:`atomic` requires autocommit to be turned on; it will raise an exception\n+if autocommit is off. Django will also refuse to turn autocommit off when an\n+:func:`atomic` block is active, because that would break atomicity.\n \n-Thus, this is best used in situations where you want to run your own\n-transaction-controlling middleware or do something really strange. In almost\n-all situations, you'll be better off using the default behavior, or the\n-transaction middleware, and only modify selected functions as needed.\n+Transactions\n+------------\n+\n+A transaction is an atomic set of database queries. Even if your program\n+crashes, the database guarantees that either all the changes will be applied,\n+or none of them.\n+\n+Django doesn't provide an API to start a transaction. The expected way to\n+start a transaction is to disable autocommit with :func:`set_autocommit`.\n+\n+Once you're in a transaction, you can choose either to apply the changes\n+you've performed until this point with :func:`commit`, or to cancel them with\n+:func:`rollback`.\n+\n+.. function:: commit(using=None)\n+\n+.. function:: rollback(using=None)\n+\n+These functions take a ``using`` argument which should be the name of a\n+database. If it isn't provided, Django uses the ``\"default\"`` database.\n+\n+Django will refuse to commit or to rollback when an :func:`atomic` block is\n+active, because that would break atomicity.\n \n .. _topics-db-transactions-savepoints:\n \n Savepoints\n-==========\n+----------\n+\n+A savepoint is a marker within a transaction that enables you to roll back\n+part of a transaction, rather than the full transaction. Savepoints are\n+available with the SQLite ( 3.6.8), PostgreSQL, Oracle and MySQL (when using\n+the InnoDB storage engine) backends. Other backends provide the savepoint\n+functions, but they're empty operations -- they don't actually do anything.\n+\n+Savepoints aren't especially useful if you are using autocommit, the default\n+behavior of Django. However, once you open a transaction with :func:`atomic`,\n+you build up a series of database operations awaiting a commit or rollback. If\n+you issue a rollback, the entire transaction is rolled back. Savepoints\n+provide the ability to perform a fine-grained rollback, rather than the full\n+rollback that would be performed by ``transaction.rollback()``.\n \n-A savepoint is a marker within a transaction that enables you to roll back part\n-of a transaction, rather than the full transaction. Savepoints are available\n-with the PostgreSQL 8, Oracle and MySQL (when using the InnoDB storage engine)\n-backends. Other backends provide the savepoint functions, but they're empty\n-operations -- they don't actually do anything.\n+.. versionchanged:: 1.6\n \n-Savepoints aren't especially useful if you are using the default\n-``autocommit`` behavior of Django. However, if you are using\n-``commit_on_success`` or ``commit_manually``, each open transaction will build\n-up a series of database operations, awaiting a commit or rollback. If you\n-issue a rollback, the entire transaction is rolled back. Savepoints provide\n-the ability to perform a fine-grained rollback, rather than the full rollback\n-that would be performed by ``transaction.rollback()``.\n+When the :func:`atomic` decorator is nested, it creates a savepoint to allow\n+partial commit or rollback. You're strongly encouraged to use :func:`atomic`\n+rather than the functions described below, but they're still part of the\n+public API, and there's no plan to deprecate them.\n \n Each of these functions takes a ``using`` argument which should be the name of\n a database for which the behavior applies.  If no ``using`` argument is\n provided then the ``\"default\"`` database is used.\n \n-Savepoints are controlled by three methods on the transaction object:\n+Savepoints are controlled by three functions in :mod:`django.db.transaction`:\n \n-.. method:: transaction.savepoint(using=None)\n+.. function:: savepoint(using=None)\n \n     Creates a new savepoint. This marks a point in the transaction that\n     is known to be in a \"good\" state.\n \n-    Returns the savepoint ID (sid).\n+    Returns the savepoint ID (``sid``).\n \n-.. method:: transaction.savepoint_commit(sid, using=None)\n+.. function:: savepoint_commit(sid, using=None)\n \n-    Updates the savepoint to include any operations that have been performed\n-    since the savepoint was created, or since the last commit.\n+    Releases savepoint ``sid``. The changes performed since the savepoint was\n+    created become part of the transaction.\n \n-.. method:: transaction.savepoint_rollback(sid, using=None)\n+.. function:: savepoint_rollback(sid, using=None)\n \n-    Rolls the transaction back to the last point at which the savepoint was\n-    committed.\n+    Rolls back the transaction to savepoint ``sid``.\n+\n+These functions do nothing if savepoints aren't supported or if the database\n+is in autocommit mode.\n+\n+In addition, there's a utility function:\n+\n+.. function:: clean_savepoints(using=None)\n+\n+    Resets the counter used to generate unique savepoint IDs.\n \n The following example demonstrates the use of savepoints::\n \n     from django.db import transaction\n \n-    @transaction.commit_manually\n+    # open a transaction\n+    @transaction.atomic\n     def viewfunc(request):\n \n       a.save()\n-      # open transaction now contains a.save()\n+      # transaction now contains a.save()\n+\n       sid = transaction.savepoint()\n \n       b.save()\n-      # open transaction now contains a.save() and b.save()\n+      # transaction now contains a.save() and b.save()\n \n       if want_to_keep_b:\n           transaction.savepoint_commit(sid)\n@@ -289,10 +378,25 @@ The following example demonstrates the use of savepoints::\n           transaction.savepoint_rollback(sid)\n           # open transaction now contains only a.save()\n \n-      transaction.commit()\n+Database-specific notes\n+=======================\n+\n+Savepoints in SQLite\n+--------------------\n+\n+While SQLite  3.6.8 supports savepoints, a flaw in the design of the\n+:mod:`sqlite3` makes them hardly usable.\n+\n+When autocommit is enabled, savepoints don't make sense. When it's disabled,\n+:mod:`sqlite3` commits implicitly before savepoint-related statement. (It\n+commits before any statement other than ``SELECT``, ``INSERT``, ``UPDATE``,\n+``DELETE`` and ``REPLACE``.)\n+\n+As a consequence, savepoints are only usable inside a transaction ie. inside\n+an :func:`atomic` block.\n \n Transactions in MySQL\n-=====================\n+---------------------\n \n If you're using MySQL, your tables may or may not support transactions; it\n depends on your MySQL version and the table types you're using. (By\n@@ -301,14 +405,14 @@ peculiarities are outside the scope of this article, but the MySQL site has\n `information on MySQL transactions`_.\n \n If your MySQL setup does *not* support transactions, then Django will function\n-in auto-commit mode: Statements will be executed and committed as soon as\n+in autocommit mode: Statements will be executed and committed as soon as\n they're called. If your MySQL setup *does* support transactions, Django will\n handle transactions as explained in this document.\n \n .. _information on MySQL transactions: http://dev.mysql.com/doc/refman/5.0/en/sql-syntax-transactions.html\n \n Handling exceptions within PostgreSQL transactions\n-==================================================\n+--------------------------------------------------\n \n When a call to a PostgreSQL cursor raises an exception (typically\n ``IntegrityError``), all subsequent SQL in the same transaction will fail with\n@@ -321,7 +425,7 @@ force_insert/force_update flag, or invoking custom SQL.\n There are several ways to recover from this sort of error.\n \n Transaction rollback\n---------------------\n+~~~~~~~~~~~~~~~~~~~~\n \n The first option is to roll back the entire transaction. For example::\n \n@@ -338,13 +442,13 @@ made by ``a.save()`` would be lost, even though that operation raised no error\n itself.\n \n Savepoint rollback\n-------------------\n+~~~~~~~~~~~~~~~~~~\n \n-If you are using PostgreSQL 8 or later, you can use :ref:`savepoints\n-<topics-db-transactions-savepoints>` to control the extent of a rollback.\n-Before performing a database operation that could fail, you can set or update\n-the savepoint; that way, if the operation fails, you can roll back the single\n-offending operation, rather than the entire transaction. For example::\n+You can use :ref:`savepoints <topics-db-transactions-savepoints>` to control\n+the extent of a rollback. Before performing a database operation that could\n+fail, you can set or update the savepoint; that way, if the operation fails,\n+you can roll back the single offending operation, rather than the entire\n+transaction. For example::\n \n     a.save() # Succeeds, and never undone by savepoint rollback\n     try:\n@@ -358,25 +462,227 @@ offending operation, rather than the entire transaction. For example::\n In this example, ``a.save()`` will not be undone in the case where\n ``b.save()`` raises an exception.\n \n-Database-level autocommit\n--------------------------\n+.. _transactions-upgrading-from-1.5:\n+\n+Changes from Django 1.5 and earlier\n+===================================\n+\n+The features described below were deprecated in Django 1.6 and will be removed\n+in Django 1.8. They're documented in order to ease the migration to the new\n+transaction management APIs.\n+\n+Legacy APIs\n+-----------\n+\n+The following functions, defined in ``django.db.transaction``, provided a way\n+to control transactions on a per-function or per-code-block basis. They could\n+be used as decorators or as context managers, and they accepted a ``using``\n+argument, exactly like :func:`atomic`.\n+\n+.. function:: autocommit\n+\n+    Enable Django's default autocommit behavior.\n+\n+    Transactions will be committed as soon as you call ``model.save()``,\n+    ``model.delete()``, or any other function that writes to the database.\n+\n+.. function:: commit_on_success\n+\n+    Use a single transaction for all the work done in a function.\n+\n+    If the function returns successfully, then Django will commit all work done\n+    within the function at that point. If the function raises an exception,\n+    though, Django will roll back the transaction.\n+\n+.. function:: commit_manually\n+\n+    Tells Django you'll be managing the transaction on your own.\n+\n+    Whether you are writing or simply reading from the database, you must\n+    ``commit()`` or ``rollback()`` explicitly or Django will raise a\n+    :exc:`TransactionManagementError` exception. This is required when reading\n+    from the database because ``SELECT`` statements may call functions which\n+    modify tables, and thus it is impossible to know if any data has been\n+    modified.\n+\n+.. _transaction-states:\n+\n+Transaction states\n+------------------\n+\n+The three functions described above relied on a concept called \"transaction\n+states\". This mechanisme was deprecated in Django 1.6, but it's still\n+available until Django 1.8..\n+\n+At any time, each database connection is in one of these two states:\n+\n+- **auto mode**: autocommit is enabled;\n+- **managed mode**: autocommit is disabled.\n+\n+Django starts in auto mode. ``TransactionMiddleware``,\n+:func:`commit_on_success` and :func:`commit_manually` activate managed mode;\n+:func:`autocommit` activates auto mode.\n+\n+Internally, Django keeps a stack of states. Activations and deactivations must\n+be balanced.\n+\n+For example, ``commit_on_success`` switches to managed mode when entering the\n+block of code it controls; when exiting the block, it commits or rollbacks,\n+and switches back to auto mode.\n+\n+So :func:`commit_on_success` really has two effects: it changes the\n+transaction state and it defines an transaction block. Nesting will give the\n+expected results in terms of transaction state, but not in terms of\n+transaction semantics. Most often, the inner block will commit, breaking the\n+atomicity of the outer block.\n+\n+:func:`autocommit` and :func:`commit_manually` have similar limitations.\n+\n+API changes\n+-----------\n \n-With PostgreSQL 8.2 or later, there is an advanced option to run PostgreSQL\n-with :doc:`database-level autocommit </ref/databases>`. If you use this option,\n-there is no constantly open transaction, so it is always possible to continue\n-after catching an exception. For example::\n+Transaction middleware\n+~~~~~~~~~~~~~~~~~~~~~~\n \n-    a.save() # succeeds\n+In Django 1.6, ``TransactionMiddleware`` is deprecated and replaced\n+:setting:`ATOMIC_REQUESTS <DATABASE-ATOMIC_REQUESTS>`. While the general\n+behavior is the same, there are a few differences.\n+\n+With the transaction middleware, it was still possible to switch to autocommit\n+or to commit explicitly in a view. Since :func:`atomic` guarantees atomicity,\n+this isn't allowed any longer.\n+\n+To avoid wrapping a particular view in a transaction, instead of::\n+\n+    @transaction.autocommit\n+    def my_view(request):\n+        do_stuff()\n+\n+you must now use this pattern::\n+\n+    def my_view(request):\n+        do_stuff()\n+    my_view.transactions_per_request = False\n+\n+The transaction middleware applied not only to view functions, but also to\n+middleware modules that come after it. For instance, if you used the session\n+middleware after the transaction middleware, session creation was part of the\n+transaction. :setting:`ATOMIC_REQUESTS <DATABASE-ATOMIC_REQUESTS>` only\n+applies to the view itself.\n+\n+Managing transactions\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+Starting with Django 1.6, :func:`atomic` is the only supported API for\n+defining a transaction. Unlike the deprecated APIs, it's nestable and always\n+guarantees atomicity.\n+\n+In most cases, it will be a drop-in replacement for :func:`commit_on_success`.\n+\n+During the deprecation period, it's possible to use :func:`atomic` within\n+:func:`autocommit`, :func:`commit_on_success` or :func:`commit_manually`.\n+However, the reverse is forbidden, because nesting the old decorators /\n+context managers breaks atomicity.\n+\n+If you enter :func:`atomic` while you're in managed mode, it will trigger a\n+commit to start from a clean slate.\n+\n+Managing autocommit\n+~~~~~~~~~~~~~~~~~~~\n+\n+Django 1.6 introduces an explicit :ref:`API for mananging autocommit\n+<managing-autocommit>`.\n+\n+To disable autocommit temporarily, instead of::\n+\n+    with transaction.commit_manually():\n+        # do stuff\n+\n+you should now use::\n+\n+    transaction.set_autocommit(False)\n     try:\n-        b.save() # Could throw exception\n-    except IntegrityError:\n-        pass\n-    c.save() # succeeds\n+        # do stuff\n+    finally:\n+        transaction.set_autocommit(True)\n+\n+To enable autocommit temporarily, instead of::\n+\n+    with transaction.autocommit():\n+        # do stuff\n+\n+you should now use::\n+\n+    transaction.set_autocommit(True)\n+    try:\n+        # do stuff\n+    finally:\n+        transaction.set_autocommit(False)\n+\n+Disabling transaction management\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Instead of setting ``TRANSACTIONS_MANAGED = True``, set the ``AUTOCOMMIT`` key\n+to ``False`` in the configuration of each database, as explained in :ref\n+:`deactivate-transaction-management`.\n+\n+Backwards incompatibilities\n+---------------------------\n+\n+Since version 1.6, Django uses database-level autocommit in auto mode.\n+Previously, it implemented application-level autocommit by triggering a commit\n+after each ORM write.\n+\n+As a consequence, each database query (for instance, an ORM read) started a\n+transaction that lasted until the next ORM write. Such \"automatic\n+transactions\" no longer exist in Django 1.6.\n+\n+There are four known scenarios where this is backwards-incompatible.\n+\n+Note that managed mode isn't affected at all. This section assumes auto mode.\n+See the :ref:`description of modes <transaction-states>` above.\n+\n+Sequences of custom SQL queries\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+If you're executing several :ref:`custom SQL queries <executing-custom-sql>`\n+in a row, each one now runs in its own transaction, instead of sharing the\n+same \"automatic transaction\". If you need to enforce atomicity, you must wrap\n+the sequence of queries in :func:`commit_on_success`.\n+\n+To check for this problem, look for calls to ``cursor.execute()``. They're\n+usually followed by a call to ``transaction.commit_unless_managed``, which\n+isn't necessary any more and should be removed.\n+\n+Select for update\n+~~~~~~~~~~~~~~~~~\n+\n+If you were relying on \"automatic transactions\" to provide locking between\n+:meth:`~django.db.models.query.QuerySet.select_for_update` and a subsequent\n+write operation  an extremely fragile design, but nonetheless possible  you\n+must wrap the relevant code in :func:`atomic`.\n+\n+Using a high isolation level\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+If you were using the \"repeatable read\" isolation level or higher, and if you\n+relied on \"automatic transactions\" to guarantee consistency between successive\n+reads, the new behavior might be backwards-incompatible. To enforce\n+consistency, you must wrap such sequences in :func:`atomic`.\n+\n+MySQL defaults to \"repeatable read\" and SQLite to \"serializable\"; they may be\n+affected by this problem.\n+\n+At the \"read committed\" isolation level or lower, \"automatic transactions\"\n+have no effect on the semantics of any sequence of ORM operations.\n+\n+PostgreSQL and Oracle default to \"read committed\" and aren't affected, unless\n+you changed the isolation level.\n \n-.. note::\n+Using unsupported database features\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-    This is not the same as the :ref:`autocommit decorator\n-    <topics-db-transactions-autocommit>`. When using database level autocommit\n-    there is no database transaction at all. The ``autocommit`` decorator\n-    still uses transactions, automatically committing each transaction when\n-    a database modifying operation occurs.\n+With triggers, views, or functions, it's possible to make ORM reads result in\n+database modifications. Django 1.5 and earlier doesn't deal with this case and\n+it's theoretically possible to observe a different behavior after upgrading to\n+Django 1.6 or later. In doubt, use :func:`atomic` to enforce integrity."
        },
        {
            "sha": "c7f09013d4c4c462e548294be76f8a87837d96bb",
            "filename": "tests/backends/tests.py",
            "status": "modified",
            "additions": 14,
            "deletions": 5,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fbackends%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fbackends%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fbackends%2Ftests.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -302,8 +302,8 @@ class PostgresNewConnectionTest(TestCase):\n     transaction is rolled back.\n     \"\"\"\n     @unittest.skipUnless(\n-        connection.vendor == 'postgresql' and connection.isolation_level > 0,\n-        \"This test applies only to PostgreSQL without autocommit\")\n+        connection.vendor == 'postgresql',\n+        \"This test applies only to PostgreSQL\")\n     def test_connect_and_rollback(self):\n         new_connections = ConnectionHandler(settings.DATABASES)\n         new_connection = new_connections[DEFAULT_DB_ALIAS]\n@@ -522,7 +522,8 @@ def test_disable_constraint_checks_manually(self):\n         \"\"\"\n         When constraint checks are disabled, should be able to write bad data without IntegrityErrors.\n         \"\"\"\n-        with transaction.commit_manually():\n+        transaction.set_autocommit(False)\n+        try:\n             # Create an Article.\n             models.Article.objects.create(headline=\"Test article\", pub_date=datetime.datetime(2010, 9, 4), reporter=self.r)\n             # Retrive it from the DB\n@@ -536,12 +537,15 @@ def test_disable_constraint_checks_manually(self):\n                 self.fail(\"IntegrityError should not have occurred.\")\n             finally:\n                 transaction.rollback()\n+        finally:\n+            transaction.set_autocommit(True)\n \n     def test_disable_constraint_checks_context_manager(self):\n         \"\"\"\n         When constraint checks are disabled (using context manager), should be able to write bad data without IntegrityErrors.\n         \"\"\"\n-        with transaction.commit_manually():\n+        transaction.set_autocommit(False)\n+        try:\n             # Create an Article.\n             models.Article.objects.create(headline=\"Test article\", pub_date=datetime.datetime(2010, 9, 4), reporter=self.r)\n             # Retrive it from the DB\n@@ -554,12 +558,15 @@ def test_disable_constraint_checks_context_manager(self):\n                 self.fail(\"IntegrityError should not have occurred.\")\n             finally:\n                 transaction.rollback()\n+        finally:\n+            transaction.set_autocommit(True)\n \n     def test_check_constraints(self):\n         \"\"\"\n         Constraint checks should raise an IntegrityError when bad data is in the DB.\n         \"\"\"\n-        with transaction.commit_manually():\n+        try:\n+            transaction.set_autocommit(False)\n             # Create an Article.\n             models.Article.objects.create(headline=\"Test article\", pub_date=datetime.datetime(2010, 9, 4), reporter=self.r)\n             # Retrive it from the DB\n@@ -572,6 +579,8 @@ def test_check_constraints(self):\n                         connection.check_constraints()\n             finally:\n                 transaction.rollback()\n+        finally:\n+            transaction.set_autocommit(True)\n \n \n class ThreadTests(TestCase):"
        },
        {
            "sha": "e88c95e22963dadd66e9caa267679539151f0648",
            "filename": "tests/delete_regress/tests.py",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fdelete_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fdelete_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fdelete_regress%2Ftests.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -22,9 +22,7 @@ def setUp(self):\n         self.conn2 = new_connections[DEFAULT_DB_ALIAS]\n         # Put both DB connections into managed transaction mode\n         transaction.enter_transaction_management()\n-        transaction.managed(True)\n         self.conn2.enter_transaction_management()\n-        self.conn2.managed(True)\n \n     def tearDown(self):\n         # Close down the second connection.\n@@ -335,7 +333,7 @@ def test_ticket_19102_select_related(self):\n             ).select_related('orgunit').delete()\n         self.assertFalse(Login.objects.filter(pk=self.l1.pk).exists())\n         self.assertTrue(Login.objects.filter(pk=self.l2.pk).exists())\n-    \n+\n     @skipUnlessDBFeature(\"update_can_self_select\")\n     def test_ticket_19102_defer(self):\n         with self.assertNumQueries(1):"
        },
        {
            "sha": "c250f647ce8a43f293a94e7d8ed232730945d5db",
            "filename": "tests/fixtures_model_package/tests.py",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Ffixtures_model_package%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Ffixtures_model_package%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ffixtures_model_package%2Ftests.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -25,7 +25,8 @@ def testClassFixtures(self):\n \n class TestNoInitialDataLoading(TransactionTestCase):\n     def test_syncdb(self):\n-        with transaction.commit_manually():\n+        transaction.set_autocommit(False)\n+        try:\n             Book.objects.all().delete()\n \n             management.call_command(\n@@ -35,6 +36,9 @@ def test_syncdb(self):\n             )\n             self.assertQuerysetEqual(Book.objects.all(), [])\n             transaction.rollback()\n+        finally:\n+            transaction.set_autocommit(True)\n+\n \n     def test_flush(self):\n         # Test presence of fixture (flush called by TransactionTestCase)\n@@ -45,7 +49,8 @@ def test_flush(self):\n             lambda a: a.name\n         )\n \n-        with transaction.commit_manually():\n+        transaction.set_autocommit(False)\n+        try:\n             management.call_command(\n                 'flush',\n                 verbosity=0,\n@@ -55,6 +60,8 @@ def test_flush(self):\n             )\n             self.assertQuerysetEqual(Book.objects.all(), [])\n             transaction.rollback()\n+        finally:\n+            transaction.set_autocommit(True)\n \n \n class FixtureTestCase(TestCase):"
        },
        {
            "sha": "c76056b93a19870e7dbd7f6d9acfe0f5cd794110",
            "filename": "tests/fixtures_regress/tests.py",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Ffixtures_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Ffixtures_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ffixtures_regress%2Ftests.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -684,5 +684,8 @@ def ticket_11101(self):\n     @skipUnlessDBFeature('supports_transactions')\n     def test_ticket_11101(self):\n         \"\"\"Test that fixtures can be rolled back (ticket #11101).\"\"\"\n-        ticket_11101 = transaction.commit_manually(self.ticket_11101)\n-        ticket_11101()\n+        transaction.set_autocommit(False)\n+        try:\n+            self.ticket_11101()\n+        finally:\n+            transaction.set_autocommit(True)"
        },
        {
            "sha": "3680eecdd2f599fe4c7c1a7ac36a46feda5d1e84",
            "filename": "tests/handlers/tests.py",
            "status": "modified",
            "additions": 27,
            "deletions": 3,
            "changes": 30,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fhandlers%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fhandlers%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fhandlers%2Ftests.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -1,9 +1,8 @@\n from django.core.handlers.wsgi import WSGIHandler\n from django.core.signals import request_started, request_finished\n-from django.db import close_old_connections\n-from django.test import RequestFactory, TestCase\n+from django.db import close_old_connections, connection\n+from django.test import RequestFactory, TestCase, TransactionTestCase\n from django.test.utils import override_settings\n-from django.utils import six\n \n \n class HandlerTests(TestCase):\n@@ -37,6 +36,31 @@ def test_bad_path_info(self):\n         self.assertEqual(response.status_code, 400)\n \n \n+class TransactionsPerRequestTests(TransactionTestCase):\n+    urls = 'handlers.urls'\n+\n+    def test_no_transaction(self):\n+        response = self.client.get('/in_transaction/')\n+        self.assertContains(response, 'False')\n+\n+    def test_auto_transaction(self):\n+        old_atomic_requests = connection.settings_dict['ATOMIC_REQUESTS']\n+        try:\n+            connection.settings_dict['ATOMIC_REQUESTS'] = True\n+            response = self.client.get('/in_transaction/')\n+        finally:\n+            connection.settings_dict['ATOMIC_REQUESTS'] = old_atomic_requests\n+        self.assertContains(response, 'True')\n+\n+    def test_no_auto_transaction(self):\n+        old_atomic_requests = connection.settings_dict['ATOMIC_REQUESTS']\n+        try:\n+            connection.settings_dict['ATOMIC_REQUESTS'] = True\n+            response = self.client.get('/not_in_transaction/')\n+        finally:\n+            connection.settings_dict['ATOMIC_REQUESTS'] = old_atomic_requests\n+        self.assertContains(response, 'False')\n+\n class SignalsTests(TestCase):\n     urls = 'handlers.urls'\n "
        },
        {
            "sha": "29858055abd4a82e0033a428e81a380d7e99a4cd",
            "filename": "tests/handlers/urls.py",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fhandlers%2Furls.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fhandlers%2Furls.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fhandlers%2Furls.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -1,9 +1,12 @@\n from __future__ import unicode_literals\n \n from django.conf.urls import patterns, url\n-from django.http import HttpResponse, StreamingHttpResponse\n+\n+from . import views\n \n urlpatterns = patterns('',\n-    url(r'^regular/$', lambda request: HttpResponse(b\"regular content\")),\n-    url(r'^streaming/$', lambda request: StreamingHttpResponse([b\"streaming\", b\" \", b\"content\"])),\n+    url(r'^regular/$', views.regular),\n+    url(r'^streaming/$', views.streaming),\n+    url(r'^in_transaction/$', views.in_transaction),\n+    url(r'^not_in_transaction/$', views.not_in_transaction),\n )"
        },
        {
            "sha": "22d9ea4c7d8207b449f1e506af248d6ee33484ac",
            "filename": "tests/handlers/views.py",
            "status": "added",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fhandlers%2Fviews.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fhandlers%2Fviews.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fhandlers%2Fviews.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -0,0 +1,17 @@\n+from __future__ import unicode_literals\n+\n+from django.db import connection\n+from django.http import HttpResponse, StreamingHttpResponse\n+\n+def regular(request):\n+    return HttpResponse(b\"regular content\")\n+\n+def streaming(request):\n+    return StreamingHttpResponse([b\"streaming\", b\" \", b\"content\"])\n+\n+def in_transaction(request):\n+    return HttpResponse(str(connection.in_atomic_block))\n+\n+def not_in_transaction(request):\n+    return HttpResponse(str(connection.in_atomic_block))\n+not_in_transaction.transactions_per_request = False"
        },
        {
            "sha": "74b8ab960165d12c2c97f172b46027caaea3ef9b",
            "filename": "tests/middleware/tests.py",
            "status": "modified",
            "additions": 7,
            "deletions": 15,
            "changes": 22,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fmiddleware%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fmiddleware%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmiddleware%2Ftests.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -22,6 +22,9 @@\n from django.utils import six\n from django.utils.encoding import force_str\n from django.utils.six.moves import xrange\n+from django.utils.unittest import expectedFailure\n+\n+from transactions.tests import IgnorePendingDeprecationWarningsMixin\n \n from .models import Band\n \n@@ -669,11 +672,12 @@ def test_compress_response(self):\n \n         self.assertNotEqual(gzip_etag, nogzip_etag)\n \n-class TransactionMiddlewareTest(TransactionTestCase):\n+class TransactionMiddlewareTest(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     \"\"\"\n     Test the transaction middleware.\n     \"\"\"\n     def setUp(self):\n+        super(TransactionMiddlewareTest, self).setUp()\n         self.request = HttpRequest()\n         self.request.META = {\n             'SERVER_NAME': 'testserver',\n@@ -685,33 +689,22 @@ def setUp(self):\n \n     def tearDown(self):\n         transaction.abort()\n+        super(TransactionMiddlewareTest, self).tearDown()\n \n     def test_request(self):\n         TransactionMiddleware().process_request(self.request)\n-        self.assertTrue(transaction.is_managed())\n+        self.assertFalse(transaction.get_autocommit())\n \n     def test_managed_response(self):\n         transaction.enter_transaction_management()\n-        transaction.managed(True)\n         Band.objects.create(name='The Beatles')\n         self.assertTrue(transaction.is_dirty())\n         TransactionMiddleware().process_response(self.request, self.response)\n         self.assertFalse(transaction.is_dirty())\n         self.assertEqual(Band.objects.count(), 1)\n \n-    def test_unmanaged_response(self):\n-        transaction.enter_transaction_management()\n-        transaction.managed(False)\n-        self.assertEqual(Band.objects.count(), 0)\n-        TransactionMiddleware().process_response(self.request, self.response)\n-        self.assertFalse(transaction.is_managed())\n-        # The transaction middleware doesn't commit/rollback if management\n-        # has been disabled.\n-        self.assertTrue(transaction.is_dirty())\n-\n     def test_exception(self):\n         transaction.enter_transaction_management()\n-        transaction.managed(True)\n         Band.objects.create(name='The Beatles')\n         self.assertTrue(transaction.is_dirty())\n         TransactionMiddleware().process_exception(self.request, None)\n@@ -726,7 +719,6 @@ def raise_exception():\n                 raise IntegrityError()\n             connections[DEFAULT_DB_ALIAS].commit = raise_exception\n             transaction.enter_transaction_management()\n-            transaction.managed(True)\n             Band.objects.create(name='The Beatles')\n             self.assertTrue(transaction.is_dirty())\n             with self.assertRaises(IntegrityError):"
        },
        {
            "sha": "2803d7995b6710017e0e23e6205079eeb2c79579",
            "filename": "tests/requests/tests.py",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Frequests%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Frequests%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Frequests%2Ftests.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -576,7 +576,6 @@ def test_request_finished_db_state(self):\n         # Make sure there is an open connection\n         connection.cursor()\n         connection.enter_transaction_management()\n-        connection.managed(True)\n         signals.request_finished.send(sender=response._handler_class)\n         self.assertEqual(len(connection.transaction_state), 0)\n \n@@ -585,7 +584,6 @@ def test_request_finished_failed_connection(self):\n         connection.settings_dict['CONN_MAX_AGE'] = 0\n \n         connection.enter_transaction_management()\n-        connection.managed(True)\n         connection.set_dirty()\n         # Test that the rollback doesn't succeed (for example network failure\n         # could cause this)."
        },
        {
            "sha": "c2fa22705aa8dec834fc1dce16a6ed791d8893e4",
            "filename": "tests/select_for_update/tests.py",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fselect_for_update%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fselect_for_update%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fselect_for_update%2Ftests.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -25,7 +25,6 @@ class SelectForUpdateTests(TransactionTestCase):\n \n     def setUp(self):\n         transaction.enter_transaction_management()\n-        transaction.managed(True)\n         self.person = Person.objects.create(name='Reinhardt')\n \n         # We have to commit here so that code in run_select_for_update can\n@@ -37,7 +36,6 @@ def setUp(self):\n         new_connections = ConnectionHandler(settings.DATABASES)\n         self.new_connection = new_connections[DEFAULT_DB_ALIAS]\n         self.new_connection.enter_transaction_management()\n-        self.new_connection.managed(True)\n \n         # We need to set settings.DEBUG to True so we can capture\n         # the output SQL to examine.\n@@ -162,7 +160,6 @@ def run_select_for_update(self, status, nowait=False):\n             # We need to enter transaction management again, as this is done on\n             # per-thread basis\n             transaction.enter_transaction_management()\n-            transaction.managed(True)\n             people = list(\n                 Person.objects.all().select_for_update(nowait=nowait)\n             )"
        },
        {
            "sha": "a96a1af748b4be70d73ac810a32f25c49ff971e8",
            "filename": "tests/serializers/tests.py",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fserializers%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Fserializers%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fserializers%2Ftests.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -268,7 +268,6 @@ def test_forward_refs(self):\n         # within a transaction in order to test forward reference\n         # handling.\n         transaction.enter_transaction_management()\n-        transaction.managed(True)\n         objs = serializers.deserialize(self.serializer_name, self.fwd_ref_str)\n         with connection.constraint_checks_disabled():\n             for obj in objs:"
        },
        {
            "sha": "6c2bcfd23f3f5e892a85dfe8114a0fc6cd3f22a0",
            "filename": "tests/transactions/models.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Ftransactions%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Ftransactions%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions%2Fmodels.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -22,4 +22,4 @@ class Meta:\n         ordering = ('first_name', 'last_name')\n \n     def __str__(self):\n-        return \"%s %s\" % (self.first_name, self.last_name)\n+        return (\"%s %s\" % (self.first_name, self.last_name)).strip()"
        },
        {
            "sha": "e5a608e5834104365b6848f28fda245cc344915b",
            "filename": "tests/transactions/tests.py",
            "status": "modified",
            "additions": 311,
            "deletions": 3,
            "changes": 314,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Ftransactions%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Ftransactions%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions%2Ftests.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -1,12 +1,320 @@\n from __future__ import absolute_import\n \n+import sys\n+import warnings\n+\n from django.db import connection, transaction, IntegrityError\n from django.test import TransactionTestCase, skipUnlessDBFeature\n+from django.utils import six\n+from django.utils.unittest import skipUnless\n \n from .models import Reporter\n \n \n-class TransactionTests(TransactionTestCase):\n+@skipUnless(connection.features.uses_savepoints,\n+        \"'atomic' requires transactions and savepoints.\")\n+class AtomicTests(TransactionTestCase):\n+    \"\"\"\n+    Tests for the atomic decorator and context manager.\n+\n+    The tests make assertions on internal attributes because there isn't a\n+    robust way to ask the database for its current transaction state.\n+\n+    Since the decorator syntax is converted into a context manager (see the\n+    implementation), there are only a few basic tests with the decorator\n+    syntax and the bulk of the tests use the context manager syntax.\n+    \"\"\"\n+\n+    def test_decorator_syntax_commit(self):\n+        @transaction.atomic\n+        def make_reporter():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+        make_reporter()\n+        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])\n+\n+    def test_decorator_syntax_rollback(self):\n+        @transaction.atomic\n+        def make_reporter():\n+            Reporter.objects.create(first_name=\"Haddock\")\n+            raise Exception(\"Oops, that's his last name\")\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            make_reporter()\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_alternate_decorator_syntax_commit(self):\n+        @transaction.atomic()\n+        def make_reporter():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+        make_reporter()\n+        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])\n+\n+    def test_alternate_decorator_syntax_rollback(self):\n+        @transaction.atomic()\n+        def make_reporter():\n+            Reporter.objects.create(first_name=\"Haddock\")\n+            raise Exception(\"Oops, that's his last name\")\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            make_reporter()\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_commit(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])\n+\n+    def test_rollback(self):\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with transaction.atomic():\n+                Reporter.objects.create(first_name=\"Haddock\")\n+                raise Exception(\"Oops, that's his last name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_nested_commit_commit(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with transaction.atomic():\n+                Reporter.objects.create(first_name=\"Archibald\", last_name=\"Haddock\")\n+        self.assertQuerysetEqual(Reporter.objects.all(),\n+                ['<Reporter: Archibald Haddock>', '<Reporter: Tintin>'])\n+\n+    def test_nested_commit_rollback(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                with transaction.atomic():\n+                    Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])\n+\n+    def test_nested_rollback_commit(self):\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with transaction.atomic():\n+                Reporter.objects.create(last_name=\"Tintin\")\n+                with transaction.atomic():\n+                    Reporter.objects.create(last_name=\"Haddock\")\n+                raise Exception(\"Oops, that's his first name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_nested_rollback_rollback(self):\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with transaction.atomic():\n+                Reporter.objects.create(last_name=\"Tintin\")\n+                with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                    with transaction.atomic():\n+                        Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+                raise Exception(\"Oops, that's his first name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_merged_commit_commit(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with transaction.atomic(savepoint=False):\n+                Reporter.objects.create(first_name=\"Archibald\", last_name=\"Haddock\")\n+        self.assertQuerysetEqual(Reporter.objects.all(),\n+                ['<Reporter: Archibald Haddock>', '<Reporter: Tintin>'])\n+\n+    def test_merged_commit_rollback(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                with transaction.atomic(savepoint=False):\n+                    Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+        # Writes in the outer block are rolled back too.\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_merged_rollback_commit(self):\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with transaction.atomic():\n+                Reporter.objects.create(last_name=\"Tintin\")\n+                with transaction.atomic(savepoint=False):\n+                    Reporter.objects.create(last_name=\"Haddock\")\n+                raise Exception(\"Oops, that's his first name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_merged_rollback_rollback(self):\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with transaction.atomic():\n+                Reporter.objects.create(last_name=\"Tintin\")\n+                with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                    with transaction.atomic(savepoint=False):\n+                        Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+                raise Exception(\"Oops, that's his first name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_reuse_commit_commit(self):\n+        atomic = transaction.atomic()\n+        with atomic:\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with atomic:\n+                Reporter.objects.create(first_name=\"Archibald\", last_name=\"Haddock\")\n+        self.assertQuerysetEqual(Reporter.objects.all(),\n+                ['<Reporter: Archibald Haddock>', '<Reporter: Tintin>'])\n+\n+    def test_reuse_commit_rollback(self):\n+        atomic = transaction.atomic()\n+        with atomic:\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                with atomic:\n+                    Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])\n+\n+    def test_reuse_rollback_commit(self):\n+        atomic = transaction.atomic()\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with atomic:\n+                Reporter.objects.create(last_name=\"Tintin\")\n+                with atomic:\n+                    Reporter.objects.create(last_name=\"Haddock\")\n+                raise Exception(\"Oops, that's his first name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_reuse_rollback_rollback(self):\n+        atomic = transaction.atomic()\n+        with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+            with atomic:\n+                Reporter.objects.create(last_name=\"Tintin\")\n+                with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                    with atomic:\n+                        Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+                raise Exception(\"Oops, that's his first name\")\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+\n+class AtomicInsideTransactionTests(AtomicTests):\n+    \"\"\"All basic tests for atomic should also pass within an existing transaction.\"\"\"\n+\n+    def setUp(self):\n+        self.atomic = transaction.atomic()\n+        self.atomic.__enter__()\n+\n+    def tearDown(self):\n+        self.atomic.__exit__(*sys.exc_info())\n+\n+\n+class AtomicInsideLegacyTransactionManagementTests(AtomicTests):\n+\n+    def setUp(self):\n+        transaction.enter_transaction_management()\n+\n+    def tearDown(self):\n+        # The tests access the database after exercising 'atomic', making the\n+        # connection dirty; a rollback is required to make it clean.\n+        transaction.rollback()\n+        transaction.leave_transaction_management()\n+\n+\n+@skipUnless(connection.features.uses_savepoints,\n+        \"'atomic' requires transactions and savepoints.\")\n+class AtomicMergeTests(TransactionTestCase):\n+    \"\"\"Test merging transactions with savepoint=False.\"\"\"\n+\n+    def test_merged_outer_rollback(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with transaction.atomic(savepoint=False):\n+                Reporter.objects.create(first_name=\"Archibald\", last_name=\"Haddock\")\n+                with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                    with transaction.atomic(savepoint=False):\n+                        Reporter.objects.create(first_name=\"Tournesol\")\n+                        raise Exception(\"Oops, that's his last name\")\n+                # It wasn't possible to roll back\n+                self.assertEqual(Reporter.objects.count(), 3)\n+            # It wasn't possible to roll back\n+            self.assertEqual(Reporter.objects.count(), 3)\n+        # The outer block must roll back\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+    def test_merged_inner_savepoint_rollback(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            with transaction.atomic():\n+                Reporter.objects.create(first_name=\"Archibald\", last_name=\"Haddock\")\n+                with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                    with transaction.atomic(savepoint=False):\n+                        Reporter.objects.create(first_name=\"Tournesol\")\n+                        raise Exception(\"Oops, that's his last name\")\n+                # It wasn't possible to roll back\n+                self.assertEqual(Reporter.objects.count(), 3)\n+            # The first block with a savepoint must roll back\n+            self.assertEqual(Reporter.objects.count(), 1)\n+        self.assertQuerysetEqual(Reporter.objects.all(), ['<Reporter: Tintin>'])\n+\n+    def test_merged_outer_rollback_after_inner_failure_and_inner_success(self):\n+        with transaction.atomic():\n+            Reporter.objects.create(first_name=\"Tintin\")\n+            # Inner block without a savepoint fails\n+            with six.assertRaisesRegex(self, Exception, \"Oops\"):\n+                with transaction.atomic(savepoint=False):\n+                    Reporter.objects.create(first_name=\"Haddock\")\n+                    raise Exception(\"Oops, that's his last name\")\n+            # It wasn't possible to roll back\n+            self.assertEqual(Reporter.objects.count(), 2)\n+            # Inner block with a savepoint succeeds\n+            with transaction.atomic(savepoint=False):\n+                Reporter.objects.create(first_name=\"Archibald\", last_name=\"Haddock\")\n+            # It still wasn't possible to roll back\n+            self.assertEqual(Reporter.objects.count(), 3)\n+        # The outer block must rollback\n+        self.assertQuerysetEqual(Reporter.objects.all(), [])\n+\n+\n+@skipUnless(connection.features.uses_savepoints,\n+        \"'atomic' requires transactions and savepoints.\")\n+class AtomicErrorsTests(TransactionTestCase):\n+\n+    def test_atomic_requires_autocommit(self):\n+        transaction.set_autocommit(False)\n+        try:\n+            with self.assertRaises(transaction.TransactionManagementError):\n+                with transaction.atomic():\n+                    pass\n+        finally:\n+            transaction.set_autocommit(True)\n+\n+    def test_atomic_prevents_disabling_autocommit(self):\n+        autocommit = transaction.get_autocommit()\n+        with transaction.atomic():\n+            with self.assertRaises(transaction.TransactionManagementError):\n+                transaction.set_autocommit(not autocommit)\n+        # Make sure autocommit wasn't changed.\n+        self.assertEqual(connection.autocommit, autocommit)\n+\n+    def test_atomic_prevents_calling_transaction_methods(self):\n+        with transaction.atomic():\n+            with self.assertRaises(transaction.TransactionManagementError):\n+                transaction.commit()\n+            with self.assertRaises(transaction.TransactionManagementError):\n+                transaction.rollback()\n+\n+    def test_atomic_prevents_calling_transaction_management_methods(self):\n+        with transaction.atomic():\n+            with self.assertRaises(transaction.TransactionManagementError):\n+                transaction.enter_transaction_management()\n+            with self.assertRaises(transaction.TransactionManagementError):\n+                transaction.leave_transaction_management()\n+\n+\n+class IgnorePendingDeprecationWarningsMixin(object):\n+\n+    def setUp(self):\n+        super(IgnorePendingDeprecationWarningsMixin, self).setUp()\n+        self.catch_warnings = warnings.catch_warnings()\n+        self.catch_warnings.__enter__()\n+        warnings.filterwarnings(\"ignore\", category=PendingDeprecationWarning)\n+\n+    def tearDown(self):\n+        self.catch_warnings.__exit__(*sys.exc_info())\n+        super(IgnorePendingDeprecationWarningsMixin, self).tearDown()\n+\n+\n+class TransactionTests(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n+\n     def create_a_reporter_then_fail(self, first, last):\n         a = Reporter(first_name=first, last_name=last)\n         a.save()\n@@ -161,7 +469,7 @@ def test_manually_managed_with_using(self):\n         )\n \n \n-class TransactionRollbackTests(TransactionTestCase):\n+class TransactionRollbackTests(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     def execute_bad_sql(self):\n         cursor = connection.cursor()\n         cursor.execute(\"INSERT INTO transactions_reporter (first_name, last_name) VALUES ('Douglas', 'Adams');\")\n@@ -178,7 +486,7 @@ def test_bad_sql(self):\n         self.assertRaises(IntegrityError, execute_bad_sql)\n         transaction.rollback()\n \n-class TransactionContextManagerTests(TransactionTestCase):\n+class TransactionContextManagerTests(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     def create_reporter_and_fail(self):\n         Reporter.objects.create(first_name=\"Bob\", last_name=\"Holtzman\")\n         raise Exception"
        },
        {
            "sha": "142c09d3cf9e9367a93a42e48e764230e08be5e8",
            "filename": "tests/transactions_regress/tests.py",
            "status": "modified",
            "additions": 37,
            "deletions": 58,
            "changes": 95,
            "blob_url": "https://github.com/django/django/blob/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Ftransactions_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9/tests%2Ftransactions_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions_regress%2Ftests.py?ref=14cddf51c5f001bb426ce7f7a83fdc52c8d8aee9",
            "patch": "@@ -6,10 +6,12 @@\n from django.test.utils import override_settings\n from django.utils.unittest import skipIf, skipUnless\n \n+from transactions.tests import IgnorePendingDeprecationWarningsMixin\n+\n from .models import Mod, M2mA, M2mB\n \n \n-class TestTransactionClosing(TransactionTestCase):\n+class TestTransactionClosing(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     \"\"\"\n     Tests to make sure that transactions are properly closed\n     when they should be, and aren't left pending after operations\n@@ -166,17 +168,13 @@ def test_failing_query_transaction_closed_debug(self):\n         (connection.settings_dict['NAME'] == ':memory:' or\n          not connection.settings_dict['NAME']),\n         'Test uses multiple connections, but in-memory sqlite does not support this')\n-class TestNewConnection(TransactionTestCase):\n+class TestNewConnection(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     \"\"\"\n     Check that new connections don't have special behaviour.\n     \"\"\"\n     def setUp(self):\n         self._old_backend = connections[DEFAULT_DB_ALIAS]\n         settings = self._old_backend.settings_dict.copy()\n-        opts = settings['OPTIONS'].copy()\n-        if 'autocommit' in opts:\n-            opts['autocommit'] = False\n-        settings['OPTIONS'] = opts\n         new_backend = self._old_backend.__class__(settings, DEFAULT_DB_ALIAS)\n         connections[DEFAULT_DB_ALIAS] = new_backend\n \n@@ -193,56 +191,31 @@ def test_commit(self):\n         \"\"\"\n         Users are allowed to commit and rollback connections.\n         \"\"\"\n-        # The starting value is False, not None.\n-        self.assertIs(connection._dirty, False)\n-        list(Mod.objects.all())\n-        self.assertTrue(connection.is_dirty())\n-        connection.commit()\n-        self.assertFalse(connection.is_dirty())\n-        list(Mod.objects.all())\n-        self.assertTrue(connection.is_dirty())\n-        connection.rollback()\n-        self.assertFalse(connection.is_dirty())\n+        connection.set_autocommit(False)\n+        try:\n+            # The starting value is False, not None.\n+            self.assertIs(connection._dirty, False)\n+            list(Mod.objects.all())\n+            self.assertTrue(connection.is_dirty())\n+            connection.commit()\n+            self.assertFalse(connection.is_dirty())\n+            list(Mod.objects.all())\n+            self.assertTrue(connection.is_dirty())\n+            connection.rollback()\n+            self.assertFalse(connection.is_dirty())\n+        finally:\n+            connection.set_autocommit(True)\n \n     def test_enter_exit_management(self):\n         orig_dirty = connection._dirty\n         connection.enter_transaction_management()\n         connection.leave_transaction_management()\n         self.assertEqual(orig_dirty, connection._dirty)\n \n-    def test_commit_unless_managed(self):\n-        cursor = connection.cursor()\n-        cursor.execute(\"INSERT into transactions_regress_mod (fld) values (2)\")\n-        connection.commit_unless_managed()\n-        self.assertFalse(connection.is_dirty())\n-        self.assertEqual(len(Mod.objects.all()), 1)\n-        self.assertTrue(connection.is_dirty())\n-        connection.commit_unless_managed()\n-        self.assertFalse(connection.is_dirty())\n-\n-    def test_commit_unless_managed_in_managed(self):\n-        cursor = connection.cursor()\n-        connection.enter_transaction_management()\n-        transaction.managed(True)\n-        cursor.execute(\"INSERT into transactions_regress_mod (fld) values (2)\")\n-        connection.commit_unless_managed()\n-        self.assertTrue(connection.is_dirty())\n-        connection.rollback()\n-        self.assertFalse(connection.is_dirty())\n-        self.assertEqual(len(Mod.objects.all()), 0)\n-        connection.commit()\n-        connection.leave_transaction_management()\n-        self.assertFalse(connection.is_dirty())\n-        self.assertEqual(len(Mod.objects.all()), 0)\n-        self.assertTrue(connection.is_dirty())\n-        connection.commit_unless_managed()\n-        self.assertFalse(connection.is_dirty())\n-        self.assertEqual(len(Mod.objects.all()), 0)\n-\n \n @skipUnless(connection.vendor == 'postgresql',\n             \"This test only valid for PostgreSQL\")\n-class TestPostgresAutocommitAndIsolation(TransactionTestCase):\n+class TestPostgresAutocommitAndIsolation(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     \"\"\"\n     Tests to make sure psycopg2's autocommit mode and isolation level\n     is restored after entering and leaving transaction management.\n@@ -261,7 +234,6 @@ def setUp(self):\n         self._old_backend = connections[DEFAULT_DB_ALIAS]\n         settings = self._old_backend.settings_dict.copy()\n         opts = settings['OPTIONS'].copy()\n-        opts['autocommit'] = True\n         opts['isolation_level'] = ISOLATION_LEVEL_SERIALIZABLE\n         settings['OPTIONS'] = opts\n         new_backend = self._old_backend.__class__(settings, DEFAULT_DB_ALIAS)\n@@ -275,53 +247,56 @@ def tearDown(self):\n             connections[DEFAULT_DB_ALIAS] = self._old_backend\n \n     def test_initial_autocommit_state(self):\n-        self.assertTrue(connection.features.uses_autocommit)\n-        self.assertEqual(connection.isolation_level, self._autocommit)\n+        # Autocommit is activated when the connection is created.\n+        connection.cursor().close()\n+        self.assertTrue(connection.autocommit)\n \n     def test_transaction_management(self):\n         transaction.enter_transaction_management()\n-        transaction.managed(True)\n+        self.assertFalse(connection.autocommit)\n         self.assertEqual(connection.isolation_level, self._serializable)\n \n         transaction.leave_transaction_management()\n-        self.assertEqual(connection.isolation_level, self._autocommit)\n+        self.assertTrue(connection.autocommit)\n \n     def test_transaction_stacking(self):\n         transaction.enter_transaction_management()\n-        transaction.managed(True)\n+        self.assertFalse(connection.autocommit)\n         self.assertEqual(connection.isolation_level, self._serializable)\n \n         transaction.enter_transaction_management()\n+        self.assertFalse(connection.autocommit)\n         self.assertEqual(connection.isolation_level, self._serializable)\n \n         transaction.leave_transaction_management()\n+        self.assertFalse(connection.autocommit)\n         self.assertEqual(connection.isolation_level, self._serializable)\n \n         transaction.leave_transaction_management()\n-        self.assertEqual(connection.isolation_level, self._autocommit)\n+        self.assertTrue(connection.autocommit)\n \n     def test_enter_autocommit(self):\n         transaction.enter_transaction_management()\n-        transaction.managed(True)\n+        self.assertFalse(connection.autocommit)\n         self.assertEqual(connection.isolation_level, self._serializable)\n         list(Mod.objects.all())\n         self.assertTrue(transaction.is_dirty())\n         # Enter autocommit mode again.\n         transaction.enter_transaction_management(False)\n-        transaction.managed(False)\n         self.assertFalse(transaction.is_dirty())\n         self.assertEqual(\n             connection.connection.get_transaction_status(),\n             self._idle)\n         list(Mod.objects.all())\n         self.assertFalse(transaction.is_dirty())\n         transaction.leave_transaction_management()\n+        self.assertFalse(connection.autocommit)\n         self.assertEqual(connection.isolation_level, self._serializable)\n         transaction.leave_transaction_management()\n-        self.assertEqual(connection.isolation_level, self._autocommit)\n+        self.assertTrue(connection.autocommit)\n \n \n-class TestManyToManyAddTransaction(TransactionTestCase):\n+class TestManyToManyAddTransaction(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     def test_manyrelated_add_commit(self):\n         \"Test for https://code.djangoproject.com/ticket/16818\"\n         a = M2mA.objects.create()\n@@ -336,8 +311,10 @@ def test_manyrelated_add_commit(self):\n         self.assertEqual(a.others.count(), 1)\n \n \n-class SavepointTest(TransactionTestCase):\n+class SavepointTest(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n \n+    @skipIf(connection.vendor == 'sqlite',\n+            \"SQLite doesn't support savepoints in managed mode\")\n     @skipUnlessDBFeature('uses_savepoints')\n     def test_savepoint_commit(self):\n         @commit_manually\n@@ -353,6 +330,8 @@ def work():\n \n         work()\n \n+    @skipIf(connection.vendor == 'sqlite',\n+            \"SQLite doesn't support savepoints in managed mode\")\n     @skipIf(connection.vendor == 'mysql' and\n             connection.features._mysql_storage_engine == 'MyISAM',\n             \"MyISAM MySQL storage engine doesn't support savepoints\")"
        }
    ],
    "stats": {
        "total": 2683,
        "additions": 1747,
        "deletions": 936
    }
}