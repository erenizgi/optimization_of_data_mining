{
    "author": "freakboy3742",
    "message": "Fixed #12248 -- Refactored django.template to get code out of __init__.py, to help with avoiding circular import dependencies. Thanks to Tom Tobin for the patch.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@14722 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "0be14b0b9647b1662c41e7e408072ebe19f28929",
    "files": [
        {
            "sha": "ca1bd49b4f03a0e0f3032a87b8b78af938a21238",
            "filename": "django/template/__init__.py",
            "status": "modified",
            "additions": 27,
            "deletions": 1003,
            "changes": 1030,
            "blob_url": "https://github.com/django/django/blob/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2F__init__.py?ref=0be14b0b9647b1662c41e7e408072ebe19f28929",
            "patch": "@@ -48,1009 +48,33 @@\n >>> t.render(c)\n u'<html></html>'\n \"\"\"\n-import imp\n-import re\n-from inspect import getargspec\n \n-from django.conf import settings\n-from django.template.context import Context, RequestContext, ContextPopException\n-from django.utils.importlib import import_module\n-from django.utils.itercompat import is_iterable\n-from django.utils.functional import curry, Promise\n-from django.utils.text import smart_split, unescape_string_literal, get_text_list\n-from django.utils.encoding import smart_unicode, force_unicode, smart_str\n-from django.utils.translation import ugettext as _\n-from django.utils.safestring import SafeData, EscapeData, mark_safe, mark_for_escaping\n-from django.utils.formats import localize\n-from django.utils.html import escape\n-from django.utils.module_loading import module_has_submodule\n+# Template lexing symbols\n+from django.template.base import (ALLOWED_VARIABLE_CHARS, BLOCK_TAG_END,\n+    BLOCK_TAG_START, COMMENT_TAG_END, COMMENT_TAG_START,\n+    FILTER_ARGUMENT_SEPARATOR, FILTER_SEPARATOR, SINGLE_BRACE_END,\n+    SINGLE_BRACE_START, TOKEN_BLOCK, TOKEN_COMMENT, TOKEN_TEXT, TOKEN_VAR,\n+    TRANSLATOR_COMMENT_MARK, UNKNOWN_SOURCE, VARIABLE_ATTRIBUTE_SEPARATOR,\n+    VARIABLE_TAG_END, VARIABLE_TAG_START, filter_re, tag_re)\n+\n+# Exceptions\n+from django.template.base import (ContextPopException, InvalidTemplateLibrary,\n+    TemplateDoesNotExist, TemplateEncodingError, TemplateSyntaxError,\n+    VariableDoesNotExist)\n+\n+# Template parts\n+from django.template.base import (Context, FilterExpression, Lexer, Node,\n+    NodeList, Parser, RequestContext, Origin, StringOrigin, Template,\n+    TextNode, Token, TokenParser, Variable, VariableNode, constant_string,\n+    filter_raw_string)\n+\n+# Compiling templates\n+from django.template.base import (compile_string, resolve_variable,\n+    unescape_string_literal, generic_tag_compiler)\n+\n+# Library management\n+from django.template.base import (Library, add_to_builtins, builtins,\n+    get_library, get_templatetags_modules, get_text_list, import_library,\n+    libraries)\n \n __all__ = ('Template', 'Context', 'RequestContext', 'compile_string')\n-\n-TOKEN_TEXT = 0\n-TOKEN_VAR = 1\n-TOKEN_BLOCK = 2\n-TOKEN_COMMENT = 3\n-\n-# template syntax constants\n-FILTER_SEPARATOR = '|'\n-FILTER_ARGUMENT_SEPARATOR = ':'\n-VARIABLE_ATTRIBUTE_SEPARATOR = '.'\n-BLOCK_TAG_START = '{%'\n-BLOCK_TAG_END = '%}'\n-VARIABLE_TAG_START = '{{'\n-VARIABLE_TAG_END = '}}'\n-COMMENT_TAG_START = '{#'\n-COMMENT_TAG_END = '#}'\n-TRANSLATOR_COMMENT_MARK = 'Translators'\n-SINGLE_BRACE_START = '{'\n-SINGLE_BRACE_END = '}'\n-\n-ALLOWED_VARIABLE_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.'\n-\n-# what to report as the origin for templates that come from non-loader sources\n-# (e.g. strings)\n-UNKNOWN_SOURCE = '<unknown source>'\n-\n-# match a variable or block tag and capture the entire tag, including start/end delimiters\n-tag_re = re.compile('(%s.*?%s|%s.*?%s|%s.*?%s)' % (re.escape(BLOCK_TAG_START), re.escape(BLOCK_TAG_END),\n-                                          re.escape(VARIABLE_TAG_START), re.escape(VARIABLE_TAG_END),\n-                                          re.escape(COMMENT_TAG_START), re.escape(COMMENT_TAG_END)))\n-\n-# global dictionary of libraries that have been loaded using get_library\n-libraries = {}\n-# global list of libraries to load by default for a new parser\n-builtins = []\n-\n-# True if TEMPLATE_STRING_IF_INVALID contains a format string (%s). None means\n-# uninitialised.\n-invalid_var_format_string = None\n-\n-class TemplateSyntaxError(Exception):\n-    pass\n-\n-class TemplateDoesNotExist(Exception):\n-    pass\n-\n-class TemplateEncodingError(Exception):\n-    pass\n-\n-class VariableDoesNotExist(Exception):\n-\n-    def __init__(self, msg, params=()):\n-        self.msg = msg\n-        self.params = params\n-\n-    def __str__(self):\n-        return unicode(self).encode('utf-8')\n-\n-    def __unicode__(self):\n-        return self.msg % tuple([force_unicode(p, errors='replace') for p in self.params])\n-\n-class InvalidTemplateLibrary(Exception):\n-    pass\n-\n-class Origin(object):\n-    def __init__(self, name):\n-        self.name = name\n-\n-    def reload(self):\n-        raise NotImplementedError\n-\n-    def __str__(self):\n-        return self.name\n-\n-class StringOrigin(Origin):\n-    def __init__(self, source):\n-        super(StringOrigin, self).__init__(UNKNOWN_SOURCE)\n-        self.source = source\n-\n-    def reload(self):\n-        return self.source\n-\n-class Template(object):\n-    def __init__(self, template_string, origin=None, name='<Unknown Template>'):\n-        try:\n-            template_string = smart_unicode(template_string)\n-        except UnicodeDecodeError:\n-            raise TemplateEncodingError(\"Templates can only be constructed from unicode or UTF-8 strings.\")\n-        if settings.TEMPLATE_DEBUG and origin is None:\n-            origin = StringOrigin(template_string)\n-        self.nodelist = compile_string(template_string, origin)\n-        self.name = name\n-\n-    def __iter__(self):\n-        for node in self.nodelist:\n-            for subnode in node:\n-                yield subnode\n-\n-    def _render(self, context):\n-        return self.nodelist.render(context)\n-\n-    def render(self, context):\n-        \"Display stage -- can be called many times\"\n-        context.render_context.push()\n-        try:\n-            return self._render(context)\n-        finally:\n-            context.render_context.pop()\n-\n-def compile_string(template_string, origin):\n-    \"Compiles template_string into NodeList ready for rendering\"\n-    if settings.TEMPLATE_DEBUG:\n-        from debug import DebugLexer, DebugParser\n-        lexer_class, parser_class = DebugLexer, DebugParser\n-    else:\n-        lexer_class, parser_class = Lexer, Parser\n-    lexer = lexer_class(template_string, origin)\n-    parser = parser_class(lexer.tokenize())\n-    return parser.parse()\n-\n-class Token(object):\n-    def __init__(self, token_type, contents):\n-        # token_type must be TOKEN_TEXT, TOKEN_VAR, TOKEN_BLOCK or TOKEN_COMMENT.\n-        self.token_type, self.contents = token_type, contents\n-\n-    def __str__(self):\n-        return '<%s token: \"%s...\">' % \\\n-            ({TOKEN_TEXT: 'Text', TOKEN_VAR: 'Var', TOKEN_BLOCK: 'Block', TOKEN_COMMENT: 'Comment'}[self.token_type],\n-            self.contents[:20].replace('\\n', ''))\n-\n-    def split_contents(self):\n-        split = []\n-        bits = iter(smart_split(self.contents))\n-        for bit in bits:\n-            # Handle translation-marked template pieces\n-            if bit.startswith('_(\"') or bit.startswith(\"_('\"):\n-                sentinal = bit[2] + ')'\n-                trans_bit = [bit]\n-                while not bit.endswith(sentinal):\n-                    bit = bits.next()\n-                    trans_bit.append(bit)\n-                bit = ' '.join(trans_bit)\n-            split.append(bit)\n-        return split\n-\n-class Lexer(object):\n-    def __init__(self, template_string, origin):\n-        self.template_string = template_string\n-        self.origin = origin\n-\n-    def tokenize(self):\n-        \"Return a list of tokens from a given template_string.\"\n-        in_tag = False\n-        result = []\n-        for bit in tag_re.split(self.template_string):\n-            if bit:\n-                result.append(self.create_token(bit, in_tag))\n-            in_tag = not in_tag\n-        return result\n-\n-    def create_token(self, token_string, in_tag):\n-        \"\"\"\n-        Convert the given token string into a new Token object and return it.\n-        If in_tag is True, we are processing something that matched a tag,\n-        otherwise it should be treated as a literal string.\n-        \"\"\"\n-        if in_tag:\n-            if token_string.startswith(VARIABLE_TAG_START):\n-                token = Token(TOKEN_VAR, token_string[len(VARIABLE_TAG_START):-len(VARIABLE_TAG_END)].strip())\n-            elif token_string.startswith(BLOCK_TAG_START):\n-                token = Token(TOKEN_BLOCK, token_string[len(BLOCK_TAG_START):-len(BLOCK_TAG_END)].strip())\n-            elif token_string.startswith(COMMENT_TAG_START):\n-                content = ''\n-                if token_string.find(TRANSLATOR_COMMENT_MARK):\n-                    content = token_string[len(COMMENT_TAG_START):-len(COMMENT_TAG_END)].strip()\n-                token = Token(TOKEN_COMMENT, content)\n-        else:\n-            token = Token(TOKEN_TEXT, token_string)\n-        return token\n-\n-class Parser(object):\n-    def __init__(self, tokens):\n-        self.tokens = tokens\n-        self.tags = {}\n-        self.filters = {}\n-        for lib in builtins:\n-            self.add_library(lib)\n-\n-    def parse(self, parse_until=None):\n-        if parse_until is None: parse_until = []\n-        nodelist = self.create_nodelist()\n-        while self.tokens:\n-            token = self.next_token()\n-            if token.token_type == TOKEN_TEXT:\n-                self.extend_nodelist(nodelist, TextNode(token.contents), token)\n-            elif token.token_type == TOKEN_VAR:\n-                if not token.contents:\n-                    self.empty_variable(token)\n-                filter_expression = self.compile_filter(token.contents)\n-                var_node = self.create_variable_node(filter_expression)\n-                self.extend_nodelist(nodelist, var_node,token)\n-            elif token.token_type == TOKEN_BLOCK:\n-                if token.contents in parse_until:\n-                    # put token back on token list so calling code knows why it terminated\n-                    self.prepend_token(token)\n-                    return nodelist\n-                try:\n-                    command = token.contents.split()[0]\n-                except IndexError:\n-                    self.empty_block_tag(token)\n-                # execute callback function for this tag and append resulting node\n-                self.enter_command(command, token)\n-                try:\n-                    compile_func = self.tags[command]\n-                except KeyError:\n-                    self.invalid_block_tag(token, command, parse_until)\n-                try:\n-                    compiled_result = compile_func(self, token)\n-                except TemplateSyntaxError, e:\n-                    if not self.compile_function_error(token, e):\n-                        raise\n-                self.extend_nodelist(nodelist, compiled_result, token)\n-                self.exit_command()\n-        if parse_until:\n-            self.unclosed_block_tag(parse_until)\n-        return nodelist\n-\n-    def skip_past(self, endtag):\n-        while self.tokens:\n-            token = self.next_token()\n-            if token.token_type == TOKEN_BLOCK and token.contents == endtag:\n-                return\n-        self.unclosed_block_tag([endtag])\n-\n-    def create_variable_node(self, filter_expression):\n-        return VariableNode(filter_expression)\n-\n-    def create_nodelist(self):\n-        return NodeList()\n-\n-    def extend_nodelist(self, nodelist, node, token):\n-        if node.must_be_first and nodelist:\n-            try:\n-                if nodelist.contains_nontext:\n-                    raise AttributeError\n-            except AttributeError:\n-                raise TemplateSyntaxError(\"%r must be the first tag in the template.\" % node)\n-        if isinstance(nodelist, NodeList) and not isinstance(node, TextNode):\n-            nodelist.contains_nontext = True\n-        nodelist.append(node)\n-\n-    def enter_command(self, command, token):\n-        pass\n-\n-    def exit_command(self):\n-        pass\n-\n-    def error(self, token, msg):\n-        return TemplateSyntaxError(msg)\n-\n-    def empty_variable(self, token):\n-        raise self.error(token, \"Empty variable tag\")\n-\n-    def empty_block_tag(self, token):\n-        raise self.error(token, \"Empty block tag\")\n-\n-    def invalid_block_tag(self, token, command, parse_until=None):\n-        if parse_until:\n-            raise self.error(token, \"Invalid block tag: '%s', expected %s\" % (command, get_text_list([\"'%s'\" % p for p in parse_until])))\n-        raise self.error(token, \"Invalid block tag: '%s'\" % command)\n-\n-    def unclosed_block_tag(self, parse_until):\n-        raise self.error(None, \"Unclosed tags: %s \" %  ', '.join(parse_until))\n-\n-    def compile_function_error(self, token, e):\n-        pass\n-\n-    def next_token(self):\n-        return self.tokens.pop(0)\n-\n-    def prepend_token(self, token):\n-        self.tokens.insert(0, token)\n-\n-    def delete_first_token(self):\n-        del self.tokens[0]\n-\n-    def add_library(self, lib):\n-        self.tags.update(lib.tags)\n-        self.filters.update(lib.filters)\n-\n-    def compile_filter(self, token):\n-        \"Convenient wrapper for FilterExpression\"\n-        return FilterExpression(token, self)\n-\n-    def find_filter(self, filter_name):\n-        if filter_name in self.filters:\n-            return self.filters[filter_name]\n-        else:\n-            raise TemplateSyntaxError(\"Invalid filter: '%s'\" % filter_name)\n-\n-class TokenParser(object):\n-    \"\"\"\n-    Subclass this and implement the top() method to parse a template line. When\n-    instantiating the parser, pass in the line from the Django template parser.\n-\n-    The parser's \"tagname\" instance-variable stores the name of the tag that\n-    the filter was called with.\n-    \"\"\"\n-    def __init__(self, subject):\n-        self.subject = subject\n-        self.pointer = 0\n-        self.backout = []\n-        self.tagname = self.tag()\n-\n-    def top(self):\n-        \"Overload this method to do the actual parsing and return the result.\"\n-        raise NotImplementedError()\n-\n-    def more(self):\n-        \"Returns True if there is more stuff in the tag.\"\n-        return self.pointer < len(self.subject)\n-\n-    def back(self):\n-        \"Undoes the last microparser. Use this for lookahead and backtracking.\"\n-        if not len(self.backout):\n-            raise TemplateSyntaxError(\"back called without some previous parsing\")\n-        self.pointer = self.backout.pop()\n-\n-    def tag(self):\n-        \"A microparser that just returns the next tag from the line.\"\n-        subject = self.subject\n-        i = self.pointer\n-        if i >= len(subject):\n-            raise TemplateSyntaxError(\"expected another tag, found end of string: %s\" % subject)\n-        p = i\n-        while i < len(subject) and subject[i] not in (' ', '\\t'):\n-            i += 1\n-        s = subject[p:i]\n-        while i < len(subject) and subject[i] in (' ', '\\t'):\n-            i += 1\n-        self.backout.append(self.pointer)\n-        self.pointer = i\n-        return s\n-\n-    def value(self):\n-        \"A microparser that parses for a value: some string constant or variable name.\"\n-        subject = self.subject\n-        i = self.pointer\n-\n-        def next_space_index(subject, i):\n-            \"Increment pointer until a real space (i.e. a space not within quotes) is encountered\"\n-            while i < len(subject) and subject[i] not in (' ', '\\t'):\n-                if subject[i] in ('\"', \"'\"):\n-                    c = subject[i]\n-                    i += 1\n-                    while i < len(subject) and subject[i] != c:\n-                        i += 1\n-                    if i >= len(subject):\n-                        raise TemplateSyntaxError(\"Searching for value. Unexpected end of string in column %d: %s\" % (i, subject))\n-                i += 1\n-            return i\n-\n-        if i >= len(subject):\n-            raise TemplateSyntaxError(\"Searching for value. Expected another value but found end of string: %s\" % subject)\n-        if subject[i] in ('\"', \"'\"):\n-            p = i\n-            i += 1\n-            while i < len(subject) and subject[i] != subject[p]:\n-                i += 1\n-            if i >= len(subject):\n-                raise TemplateSyntaxError(\"Searching for value. Unexpected end of string in column %d: %s\" % (i, subject))\n-            i += 1\n-\n-            # Continue parsing until next \"real\" space, so that filters are also included\n-            i = next_space_index(subject, i)\n-\n-            res = subject[p:i]\n-            while i < len(subject) and subject[i] in (' ', '\\t'):\n-                i += 1\n-            self.backout.append(self.pointer)\n-            self.pointer = i\n-            return res\n-        else:\n-            p = i\n-            i = next_space_index(subject, i)\n-            s = subject[p:i]\n-            while i < len(subject) and subject[i] in (' ', '\\t'):\n-                i += 1\n-            self.backout.append(self.pointer)\n-            self.pointer = i\n-            return s\n-\n-# This only matches constant *strings* (things in quotes or marked for\n-# translation). Numbers are treated as variables for implementation reasons\n-# (so that they retain their type when passed to filters).\n-constant_string = r\"\"\"\n-(?:%(i18n_open)s%(strdq)s%(i18n_close)s|\n-%(i18n_open)s%(strsq)s%(i18n_close)s|\n-%(strdq)s|\n-%(strsq)s)\n-\"\"\" % {\n-    'strdq': r'\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"', # double-quoted string\n-    'strsq': r\"'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\", # single-quoted string\n-    'i18n_open' : re.escape(\"_(\"),\n-    'i18n_close' : re.escape(\")\"),\n-    }\n-constant_string = constant_string.replace(\"\\n\", \"\")\n-\n-filter_raw_string = r\"\"\"\n-^(?P<constant>%(constant)s)|\n-^(?P<var>[%(var_chars)s]+|%(num)s)|\n- (?:%(filter_sep)s\n-     (?P<filter_name>\\w+)\n-         (?:%(arg_sep)s\n-             (?:\n-              (?P<constant_arg>%(constant)s)|\n-              (?P<var_arg>[%(var_chars)s]+|%(num)s)\n-             )\n-         )?\n- )\"\"\" % {\n-    'constant': constant_string,\n-    'num': r'[-+\\.]?\\d[\\d\\.e]*',\n-    'var_chars': \"\\w\\.\" ,\n-    'filter_sep': re.escape(FILTER_SEPARATOR),\n-    'arg_sep': re.escape(FILTER_ARGUMENT_SEPARATOR),\n-  }\n-\n-filter_re = re.compile(filter_raw_string, re.UNICODE|re.VERBOSE)\n-\n-class FilterExpression(object):\n-    r\"\"\"\n-    Parses a variable token and its optional filters (all as a single string),\n-    and return a list of tuples of the filter name and arguments.\n-    Sample:\n-        >>> token = 'variable|default:\"Default value\"|date:\"Y-m-d\"'\n-        >>> p = Parser('')\n-        >>> fe = FilterExpression(token, p)\n-        >>> len(fe.filters)\n-        2\n-        >>> fe.var\n-        <Variable: 'variable'>\n-\n-    This class should never be instantiated outside of the\n-    get_filters_from_token helper function.\n-    \"\"\"\n-    def __init__(self, token, parser):\n-        self.token = token\n-        matches = filter_re.finditer(token)\n-        var_obj = None\n-        filters = []\n-        upto = 0\n-        for match in matches:\n-            start = match.start()\n-            if upto != start:\n-                raise TemplateSyntaxError(\"Could not parse some characters: %s|%s|%s\"  % \\\n-                        (token[:upto], token[upto:start], token[start:]))\n-            if var_obj is None:\n-                var, constant = match.group(\"var\", \"constant\")\n-                if constant:\n-                    try:\n-                        var_obj = Variable(constant).resolve({})\n-                    except VariableDoesNotExist:\n-                        var_obj = None\n-                elif var is None:\n-                    raise TemplateSyntaxError(\"Could not find variable at start of %s.\" % token)\n-                else:\n-                    var_obj = Variable(var)\n-            else:\n-                filter_name = match.group(\"filter_name\")\n-                args = []\n-                constant_arg, var_arg = match.group(\"constant_arg\", \"var_arg\")\n-                if constant_arg:\n-                    args.append((False, Variable(constant_arg).resolve({})))\n-                elif var_arg:\n-                    args.append((True, Variable(var_arg)))\n-                filter_func = parser.find_filter(filter_name)\n-                self.args_check(filter_name, filter_func, args)\n-                filters.append((filter_func, args))\n-            upto = match.end()\n-        if upto != len(token):\n-            raise TemplateSyntaxError(\"Could not parse the remainder: '%s' from '%s'\" % (token[upto:], token))\n-\n-        self.filters = filters\n-        self.var = var_obj\n-\n-    def resolve(self, context, ignore_failures=False):\n-        if isinstance(self.var, Variable):\n-            try:\n-                obj = self.var.resolve(context)\n-            except VariableDoesNotExist:\n-                if ignore_failures:\n-                    obj = None\n-                else:\n-                    if settings.TEMPLATE_STRING_IF_INVALID:\n-                        global invalid_var_format_string\n-                        if invalid_var_format_string is None:\n-                            invalid_var_format_string = '%s' in settings.TEMPLATE_STRING_IF_INVALID\n-                        if invalid_var_format_string:\n-                            return settings.TEMPLATE_STRING_IF_INVALID % self.var\n-                        return settings.TEMPLATE_STRING_IF_INVALID\n-                    else:\n-                        obj = settings.TEMPLATE_STRING_IF_INVALID\n-        else:\n-            obj = self.var\n-        for func, args in self.filters:\n-            arg_vals = []\n-            for lookup, arg in args:\n-                if not lookup:\n-                    arg_vals.append(mark_safe(arg))\n-                else:\n-                    arg_vals.append(arg.resolve(context))\n-            if getattr(func, 'needs_autoescape', False):\n-                new_obj = func(obj, autoescape=context.autoescape, *arg_vals)\n-            else:\n-                new_obj = func(obj, *arg_vals)\n-            if getattr(func, 'is_safe', False) and isinstance(obj, SafeData):\n-                obj = mark_safe(new_obj)\n-            elif isinstance(obj, EscapeData):\n-                obj = mark_for_escaping(new_obj)\n-            else:\n-                obj = new_obj\n-        return obj\n-\n-    def args_check(name, func, provided):\n-        provided = list(provided)\n-        plen = len(provided)\n-        # Check to see if a decorator is providing the real function.\n-        func = getattr(func, '_decorated_function', func)\n-        args, varargs, varkw, defaults = getargspec(func)\n-        # First argument is filter input.\n-        args.pop(0)\n-        if defaults:\n-            nondefs = args[:-len(defaults)]\n-        else:\n-            nondefs = args\n-        # Args without defaults must be provided.\n-        try:\n-            for arg in nondefs:\n-                provided.pop(0)\n-        except IndexError:\n-            # Not enough\n-            raise TemplateSyntaxError(\"%s requires %d arguments, %d provided\" % (name, len(nondefs), plen))\n-\n-        # Defaults can be overridden.\n-        defaults = defaults and list(defaults) or []\n-        try:\n-            for parg in provided:\n-                defaults.pop(0)\n-        except IndexError:\n-            # Too many.\n-            raise TemplateSyntaxError(\"%s requires %d arguments, %d provided\" % (name, len(nondefs), plen))\n-\n-        return True\n-    args_check = staticmethod(args_check)\n-\n-    def __str__(self):\n-        return self.token\n-\n-def resolve_variable(path, context):\n-    \"\"\"\n-    Returns the resolved variable, which may contain attribute syntax, within\n-    the given context.\n-\n-    Deprecated; use the Variable class instead.\n-    \"\"\"\n-    return Variable(path).resolve(context)\n-\n-class Variable(object):\n-    r\"\"\"\n-    A template variable, resolvable against a given context. The variable may be\n-    a hard-coded string (if it begins and ends with single or double quote\n-    marks)::\n-\n-        >>> c = {'article': {'section':u'News'}}\n-        >>> Variable('article.section').resolve(c)\n-        u'News'\n-        >>> Variable('article').resolve(c)\n-        {'section': u'News'}\n-        >>> class AClass: pass\n-        >>> c = AClass()\n-        >>> c.article = AClass()\n-        >>> c.article.section = u'News'\n-\n-    (The example assumes VARIABLE_ATTRIBUTE_SEPARATOR is '.')\n-    \"\"\"\n-\n-    def __init__(self, var):\n-        self.var = var\n-        self.literal = None\n-        self.lookups = None\n-        self.translate = False\n-\n-        try:\n-            # First try to treat this variable as a number.\n-            #\n-            # Note that this could cause an OverflowError here that we're not\n-            # catching. Since this should only happen at compile time, that's\n-            # probably OK.\n-            self.literal = float(var)\n-\n-            # So it's a float... is it an int? If the original value contained a\n-            # dot or an \"e\" then it was a float, not an int.\n-            if '.' not in var and 'e' not in var.lower():\n-                self.literal = int(self.literal)\n-\n-            # \"2.\" is invalid\n-            if var.endswith('.'):\n-                raise ValueError\n-\n-        except ValueError:\n-            # A ValueError means that the variable isn't a number.\n-            if var.startswith('_(') and var.endswith(')'):\n-                # The result of the lookup should be translated at rendering\n-                # time.\n-                self.translate = True\n-                var = var[2:-1]\n-            # If it's wrapped with quotes (single or double), then\n-            # we're also dealing with a literal.\n-            try:\n-                self.literal = mark_safe(unescape_string_literal(var))\n-            except ValueError:\n-                # Otherwise we'll set self.lookups so that resolve() knows we're\n-                # dealing with a bonafide variable\n-                if var.find(VARIABLE_ATTRIBUTE_SEPARATOR + '_') > -1 or var[0] == '_':\n-                    raise TemplateSyntaxError(\"Variables and attributes may not begin with underscores: '%s'\" % var)\n-                self.lookups = tuple(var.split(VARIABLE_ATTRIBUTE_SEPARATOR))\n-\n-    def resolve(self, context):\n-        \"\"\"Resolve this variable against a given context.\"\"\"\n-        if self.lookups is not None:\n-            # We're dealing with a variable that needs to be resolved\n-            value = self._resolve_lookup(context)\n-        else:\n-            # We're dealing with a literal, so it's already been \"resolved\"\n-            value = self.literal\n-        if self.translate:\n-            return _(value)\n-        return value\n-\n-    def __repr__(self):\n-        return \"<%s: %r>\" % (self.__class__.__name__, self.var)\n-\n-    def __str__(self):\n-        return self.var\n-\n-    def _resolve_lookup(self, context):\n-        \"\"\"\n-        Performs resolution of a real variable (i.e. not a literal) against the\n-        given context.\n-\n-        As indicated by the method's name, this method is an implementation\n-        detail and shouldn't be called by external code. Use Variable.resolve()\n-        instead.\n-        \"\"\"\n-        current = context\n-        for bit in self.lookups:\n-            try: # dictionary lookup\n-                current = current[bit]\n-            except (TypeError, AttributeError, KeyError):\n-                try: # attribute lookup\n-                    current = getattr(current, bit)\n-                    if callable(current):\n-                        if getattr(current, 'alters_data', False):\n-                            current = settings.TEMPLATE_STRING_IF_INVALID\n-                        else:\n-                            try: # method call (assuming no args required)\n-                                current = current()\n-                            except TypeError: # arguments *were* required\n-                                # GOTCHA: This will also catch any TypeError\n-                                # raised in the function itself.\n-                                current = settings.TEMPLATE_STRING_IF_INVALID # invalid method call\n-                            except Exception, e:\n-                                if getattr(e, 'silent_variable_failure', False):\n-                                    current = settings.TEMPLATE_STRING_IF_INVALID\n-                                else:\n-                                    raise\n-                except (TypeError, AttributeError):\n-                    try: # list-index lookup\n-                        current = current[int(bit)]\n-                    except (IndexError, # list index out of range\n-                            ValueError, # invalid literal for int()\n-                            KeyError,   # current is a dict without `int(bit)` key\n-                            TypeError,  # unsubscriptable object\n-                            ):\n-                        raise VariableDoesNotExist(\"Failed lookup for key [%s] in %r\", (bit, current)) # missing attribute\n-                except Exception, e:\n-                    if getattr(e, 'silent_variable_failure', False):\n-                        current = settings.TEMPLATE_STRING_IF_INVALID\n-                    else:\n-                        raise\n-            except Exception, e:\n-                if getattr(e, 'silent_variable_failure', False):\n-                    current = settings.TEMPLATE_STRING_IF_INVALID\n-                else:\n-                    raise\n-\n-        return current\n-\n-class Node(object):\n-    # Set this to True for nodes that must be first in the template (although\n-    # they can be preceded by text nodes.\n-    must_be_first = False\n-    child_nodelists = ('nodelist',)\n-\n-    def render(self, context):\n-        \"Return the node rendered as a string\"\n-        pass\n-\n-    def __iter__(self):\n-        yield self\n-\n-    def get_nodes_by_type(self, nodetype):\n-        \"Return a list of all nodes (within this node and its nodelist) of the given type\"\n-        nodes = []\n-        if isinstance(self, nodetype):\n-            nodes.append(self)\n-        for attr in self.child_nodelists:\n-            nodelist = getattr(self, attr, None)\n-            if nodelist:\n-                nodes.extend(nodelist.get_nodes_by_type(nodetype))\n-        return nodes\n-\n-class NodeList(list):\n-    # Set to True the first time a non-TextNode is inserted by\n-    # extend_nodelist().\n-    contains_nontext = False\n-\n-    def render(self, context):\n-        bits = []\n-        for node in self:\n-            if isinstance(node, Node):\n-                bits.append(self.render_node(node, context))\n-            else:\n-                bits.append(node)\n-        return mark_safe(''.join([force_unicode(b) for b in bits]))\n-\n-    def get_nodes_by_type(self, nodetype):\n-        \"Return a list of all nodes of the given type\"\n-        nodes = []\n-        for node in self:\n-            nodes.extend(node.get_nodes_by_type(nodetype))\n-        return nodes\n-\n-    def render_node(self, node, context):\n-        return node.render(context)\n-\n-class TextNode(Node):\n-    def __init__(self, s):\n-        self.s = s\n-\n-    def __repr__(self):\n-        return \"<Text Node: '%s'>\" % smart_str(self.s[:25], 'ascii',\n-                errors='replace')\n-\n-    def render(self, context):\n-        return self.s\n-\n-def _render_value_in_context(value, context):\n-    \"\"\"\n-    Converts any value to a string to become part of a rendered template. This\n-    means escaping, if required, and conversion to a unicode object. If value\n-    is a string, it is expected to have already been translated.\n-    \"\"\"\n-    value = localize(value, use_l10n=context.use_l10n)\n-    value = force_unicode(value)\n-    if (context.autoescape and not isinstance(value, SafeData)) or isinstance(value, EscapeData):\n-        return escape(value)\n-    else:\n-        return value\n-\n-class VariableNode(Node):\n-    def __init__(self, filter_expression):\n-        self.filter_expression = filter_expression\n-\n-    def __repr__(self):\n-        return \"<Variable Node: %s>\" % self.filter_expression\n-\n-    def render(self, context):\n-        try:\n-            output = self.filter_expression.resolve(context)\n-        except UnicodeDecodeError:\n-            # Unicode conversion can fail sometimes for reasons out of our\n-            # control (e.g. exception rendering). In that case, we fail quietly.\n-            return ''\n-        return _render_value_in_context(output, context)\n-\n-def generic_tag_compiler(params, defaults, name, node_class, parser, token):\n-    \"Returns a template.Node subclass.\"\n-    bits = token.split_contents()[1:]\n-    bmax = len(params)\n-    def_len = defaults and len(defaults) or 0\n-    bmin = bmax - def_len\n-    if(len(bits) < bmin or len(bits) > bmax):\n-        if bmin == bmax:\n-            message = \"%s takes %s arguments\" % (name, bmin)\n-        else:\n-            message = \"%s takes between %s and %s arguments\" % (name, bmin, bmax)\n-        raise TemplateSyntaxError(message)\n-    return node_class(bits)\n-\n-class Library(object):\n-    def __init__(self):\n-        self.filters = {}\n-        self.tags = {}\n-\n-    def tag(self, name=None, compile_function=None):\n-        if name == None and compile_function == None:\n-            # @register.tag()\n-            return self.tag_function\n-        elif name != None and compile_function == None:\n-            if(callable(name)):\n-                # @register.tag\n-                return self.tag_function(name)\n-            else:\n-                # @register.tag('somename') or @register.tag(name='somename')\n-                def dec(func):\n-                    return self.tag(name, func)\n-                return dec\n-        elif name != None and compile_function != None:\n-            # register.tag('somename', somefunc)\n-            self.tags[name] = compile_function\n-            return compile_function\n-        else:\n-            raise InvalidTemplateLibrary(\"Unsupported arguments to Library.tag: (%r, %r)\", (name, compile_function))\n-\n-    def tag_function(self,func):\n-        self.tags[getattr(func, \"_decorated_function\", func).__name__] = func\n-        return func\n-\n-    def filter(self, name=None, filter_func=None):\n-        if name == None and filter_func == None:\n-            # @register.filter()\n-            return self.filter_function\n-        elif filter_func == None:\n-            if(callable(name)):\n-                # @register.filter\n-                return self.filter_function(name)\n-            else:\n-                # @register.filter('somename') or @register.filter(name='somename')\n-                def dec(func):\n-                    return self.filter(name, func)\n-                return dec\n-        elif name != None and filter_func != None:\n-            # register.filter('somename', somefunc)\n-            self.filters[name] = filter_func\n-            return filter_func\n-        else:\n-            raise InvalidTemplateLibrary(\"Unsupported arguments to Library.filter: (%r, %r)\", (name, filter_func))\n-\n-    def filter_function(self, func):\n-        self.filters[getattr(func, \"_decorated_function\", func).__name__] = func\n-        return func\n-\n-    def simple_tag(self,func):\n-        params, xx, xxx, defaults = getargspec(func)\n-\n-        class SimpleNode(Node):\n-            def __init__(self, vars_to_resolve):\n-                self.vars_to_resolve = map(Variable, vars_to_resolve)\n-\n-            def render(self, context):\n-                resolved_vars = [var.resolve(context) for var in self.vars_to_resolve]\n-                return func(*resolved_vars)\n-\n-        compile_func = curry(generic_tag_compiler, params, defaults, getattr(func, \"_decorated_function\", func).__name__, SimpleNode)\n-        compile_func.__doc__ = func.__doc__\n-        self.tag(getattr(func, \"_decorated_function\", func).__name__, compile_func)\n-        return func\n-\n-    def inclusion_tag(self, file_name, context_class=Context, takes_context=False):\n-        def dec(func):\n-            params, xx, xxx, defaults = getargspec(func)\n-            if takes_context:\n-                if params[0] == 'context':\n-                    params = params[1:]\n-                else:\n-                    raise TemplateSyntaxError(\"Any tag function decorated with takes_context=True must have a first argument of 'context'\")\n-\n-            class InclusionNode(Node):\n-                def __init__(self, vars_to_resolve):\n-                    self.vars_to_resolve = map(Variable, vars_to_resolve)\n-\n-                def render(self, context):\n-                    resolved_vars = [var.resolve(context) for var in self.vars_to_resolve]\n-                    if takes_context:\n-                        args = [context] + resolved_vars\n-                    else:\n-                        args = resolved_vars\n-\n-                    dict = func(*args)\n-\n-                    if not getattr(self, 'nodelist', False):\n-                        from django.template.loader import get_template, select_template\n-                        if not isinstance(file_name, basestring) and is_iterable(file_name):\n-                            t = select_template(file_name)\n-                        else:\n-                            t = get_template(file_name)\n-                        self.nodelist = t.nodelist\n-                    new_context = context_class(dict, autoescape=context.autoescape)\n-                    # Copy across the CSRF token, if present, because inclusion\n-                    # tags are often used for forms, and we need instructions\n-                    # for using CSRF protection to be as simple as possible.\n-                    csrf_token = context.get('csrf_token', None)\n-                    if csrf_token is not None:\n-                        new_context['csrf_token'] = csrf_token\n-                    return self.nodelist.render(new_context)\n-\n-            compile_func = curry(generic_tag_compiler, params, defaults, getattr(func, \"_decorated_function\", func).__name__, InclusionNode)\n-            compile_func.__doc__ = func.__doc__\n-            self.tag(getattr(func, \"_decorated_function\", func).__name__, compile_func)\n-            return func\n-        return dec\n-\n-def import_library(taglib_module):\n-    \"\"\"Load a template tag library module.\n-\n-    Verifies that the library contains a 'register' attribute, and\n-    returns that attribute as the representation of the library\n-    \"\"\"\n-    app_path, taglib = taglib_module.rsplit('.',1)\n-    app_module = import_module(app_path)\n-    try:\n-        mod = import_module(taglib_module)\n-    except ImportError, e:\n-        # If the ImportError is because the taglib submodule does not exist, that's not\n-        # an error that should be raised. If the submodule exists and raised an ImportError\n-        # on the attempt to load it, that we want to raise.\n-        if not module_has_submodule(app_module, taglib):\n-            return None\n-        else:\n-            raise InvalidTemplateLibrary(\"ImportError raised loading %s: %s\" % (taglib_module, e))\n-    try:\n-        return mod.register\n-    except AttributeError:\n-        raise InvalidTemplateLibrary(\"Template library %s does not have a variable named 'register'\" % taglib_module)\n-\n-templatetags_modules = []\n-\n-def get_templatetags_modules():\n-    \"\"\"Return the list of all available template tag modules.\n-\n-    Caches the result for faster access.\n-    \"\"\"\n-    global templatetags_modules\n-    if not templatetags_modules:\n-        _templatetags_modules = []\n-        # Populate list once per thread.\n-        for app_module in ['django'] + list(settings.INSTALLED_APPS):\n-            try:\n-                templatetag_module = '%s.templatetags' % app_module\n-                import_module(templatetag_module)\n-                _templatetags_modules.append(templatetag_module)\n-            except ImportError:\n-                continue\n-        templatetags_modules = _templatetags_modules\n-    return templatetags_modules\n-\n-def get_library(library_name):\n-    \"\"\"\n-    Load the template library module with the given name.\n-\n-    If library is not already loaded loop over all templatetags modules to locate it.\n-\n-    {% load somelib %} and {% load someotherlib %} loops twice.\n-\n-    Subsequent loads eg. {% load somelib %} in the same process will grab the cached\n-    module from libraries.\n-    \"\"\"\n-    lib = libraries.get(library_name, None)\n-    if not lib:\n-        templatetags_modules = get_templatetags_modules()\n-        tried_modules = []\n-        for module in templatetags_modules:\n-            taglib_module = '%s.%s' % (module, library_name)\n-            tried_modules.append(taglib_module)\n-            lib = import_library(taglib_module)\n-            if lib:\n-                libraries[library_name] = lib\n-                break\n-        if not lib:\n-            raise InvalidTemplateLibrary(\"Template library %s not found, tried %s\" % (library_name, ','.join(tried_modules)))\n-    return lib\n-\n-def add_to_builtins(module):\n-    builtins.append(import_library(module))\n-\n-add_to_builtins('django.template.defaulttags')\n-add_to_builtins('django.template.defaultfilters')"
        },
        {
            "sha": "c6d646eebf4d59ab5977730fc7729c7339e9c97f",
            "filename": "django/template/base.py",
            "status": "added",
            "additions": 1005,
            "deletions": 0,
            "changes": 1005,
            "blob_url": "https://github.com/django/django/blob/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2Fbase.py?ref=0be14b0b9647b1662c41e7e408072ebe19f28929",
            "patch": "@@ -0,0 +1,1005 @@\n+import imp\n+import re\n+from inspect import getargspec\n+\n+from django.conf import settings\n+from django.template.context import Context, RequestContext, ContextPopException\n+from django.utils.importlib import import_module\n+from django.utils.itercompat import is_iterable\n+from django.utils.functional import curry, Promise\n+from django.utils.text import smart_split, unescape_string_literal, get_text_list\n+from django.utils.encoding import smart_unicode, force_unicode, smart_str\n+from django.utils.translation import ugettext as _\n+from django.utils.safestring import SafeData, EscapeData, mark_safe, mark_for_escaping\n+from django.utils.formats import localize\n+from django.utils.html import escape\n+from django.utils.module_loading import module_has_submodule\n+\n+\n+TOKEN_TEXT = 0\n+TOKEN_VAR = 1\n+TOKEN_BLOCK = 2\n+TOKEN_COMMENT = 3\n+\n+# template syntax constants\n+FILTER_SEPARATOR = '|'\n+FILTER_ARGUMENT_SEPARATOR = ':'\n+VARIABLE_ATTRIBUTE_SEPARATOR = '.'\n+BLOCK_TAG_START = '{%'\n+BLOCK_TAG_END = '%}'\n+VARIABLE_TAG_START = '{{'\n+VARIABLE_TAG_END = '}}'\n+COMMENT_TAG_START = '{#'\n+COMMENT_TAG_END = '#}'\n+TRANSLATOR_COMMENT_MARK = 'Translators'\n+SINGLE_BRACE_START = '{'\n+SINGLE_BRACE_END = '}'\n+\n+ALLOWED_VARIABLE_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.'\n+\n+# what to report as the origin for templates that come from non-loader sources\n+# (e.g. strings)\n+UNKNOWN_SOURCE = '<unknown source>'\n+\n+# match a variable or block tag and capture the entire tag, including start/end delimiters\n+tag_re = re.compile('(%s.*?%s|%s.*?%s|%s.*?%s)' % (re.escape(BLOCK_TAG_START), re.escape(BLOCK_TAG_END),\n+                                          re.escape(VARIABLE_TAG_START), re.escape(VARIABLE_TAG_END),\n+                                          re.escape(COMMENT_TAG_START), re.escape(COMMENT_TAG_END)))\n+\n+# global dictionary of libraries that have been loaded using get_library\n+libraries = {}\n+# global list of libraries to load by default for a new parser\n+builtins = []\n+\n+# True if TEMPLATE_STRING_IF_INVALID contains a format string (%s). None means\n+# uninitialised.\n+invalid_var_format_string = None\n+\n+class TemplateSyntaxError(Exception):\n+    pass\n+\n+class TemplateDoesNotExist(Exception):\n+    pass\n+\n+class TemplateEncodingError(Exception):\n+    pass\n+\n+class VariableDoesNotExist(Exception):\n+\n+    def __init__(self, msg, params=()):\n+        self.msg = msg\n+        self.params = params\n+\n+    def __str__(self):\n+        return unicode(self).encode('utf-8')\n+\n+    def __unicode__(self):\n+        return self.msg % tuple([force_unicode(p, errors='replace') for p in self.params])\n+\n+class InvalidTemplateLibrary(Exception):\n+    pass\n+\n+class Origin(object):\n+    def __init__(self, name):\n+        self.name = name\n+\n+    def reload(self):\n+        raise NotImplementedError\n+\n+    def __str__(self):\n+        return self.name\n+\n+class StringOrigin(Origin):\n+    def __init__(self, source):\n+        super(StringOrigin, self).__init__(UNKNOWN_SOURCE)\n+        self.source = source\n+\n+    def reload(self):\n+        return self.source\n+\n+class Template(object):\n+    def __init__(self, template_string, origin=None, name='<Unknown Template>'):\n+        try:\n+            template_string = smart_unicode(template_string)\n+        except UnicodeDecodeError:\n+            raise TemplateEncodingError(\"Templates can only be constructed from unicode or UTF-8 strings.\")\n+        if settings.TEMPLATE_DEBUG and origin is None:\n+            origin = StringOrigin(template_string)\n+        self.nodelist = compile_string(template_string, origin)\n+        self.name = name\n+\n+    def __iter__(self):\n+        for node in self.nodelist:\n+            for subnode in node:\n+                yield subnode\n+\n+    def _render(self, context):\n+        return self.nodelist.render(context)\n+\n+    def render(self, context):\n+        \"Display stage -- can be called many times\"\n+        context.render_context.push()\n+        try:\n+            return self._render(context)\n+        finally:\n+            context.render_context.pop()\n+\n+def compile_string(template_string, origin):\n+    \"Compiles template_string into NodeList ready for rendering\"\n+    if settings.TEMPLATE_DEBUG:\n+        from debug import DebugLexer, DebugParser\n+        lexer_class, parser_class = DebugLexer, DebugParser\n+    else:\n+        lexer_class, parser_class = Lexer, Parser\n+    lexer = lexer_class(template_string, origin)\n+    parser = parser_class(lexer.tokenize())\n+    return parser.parse()\n+\n+class Token(object):\n+    def __init__(self, token_type, contents):\n+        # token_type must be TOKEN_TEXT, TOKEN_VAR, TOKEN_BLOCK or TOKEN_COMMENT.\n+        self.token_type, self.contents = token_type, contents\n+\n+    def __str__(self):\n+        return '<%s token: \"%s...\">' % \\\n+            ({TOKEN_TEXT: 'Text', TOKEN_VAR: 'Var', TOKEN_BLOCK: 'Block', TOKEN_COMMENT: 'Comment'}[self.token_type],\n+            self.contents[:20].replace('\\n', ''))\n+\n+    def split_contents(self):\n+        split = []\n+        bits = iter(smart_split(self.contents))\n+        for bit in bits:\n+            # Handle translation-marked template pieces\n+            if bit.startswith('_(\"') or bit.startswith(\"_('\"):\n+                sentinal = bit[2] + ')'\n+                trans_bit = [bit]\n+                while not bit.endswith(sentinal):\n+                    bit = bits.next()\n+                    trans_bit.append(bit)\n+                bit = ' '.join(trans_bit)\n+            split.append(bit)\n+        return split\n+\n+class Lexer(object):\n+    def __init__(self, template_string, origin):\n+        self.template_string = template_string\n+        self.origin = origin\n+\n+    def tokenize(self):\n+        \"Return a list of tokens from a given template_string.\"\n+        in_tag = False\n+        result = []\n+        for bit in tag_re.split(self.template_string):\n+            if bit:\n+                result.append(self.create_token(bit, in_tag))\n+            in_tag = not in_tag\n+        return result\n+\n+    def create_token(self, token_string, in_tag):\n+        \"\"\"\n+        Convert the given token string into a new Token object and return it.\n+        If in_tag is True, we are processing something that matched a tag,\n+        otherwise it should be treated as a literal string.\n+        \"\"\"\n+        if in_tag:\n+            if token_string.startswith(VARIABLE_TAG_START):\n+                token = Token(TOKEN_VAR, token_string[len(VARIABLE_TAG_START):-len(VARIABLE_TAG_END)].strip())\n+            elif token_string.startswith(BLOCK_TAG_START):\n+                token = Token(TOKEN_BLOCK, token_string[len(BLOCK_TAG_START):-len(BLOCK_TAG_END)].strip())\n+            elif token_string.startswith(COMMENT_TAG_START):\n+                content = ''\n+                if token_string.find(TRANSLATOR_COMMENT_MARK):\n+                    content = token_string[len(COMMENT_TAG_START):-len(COMMENT_TAG_END)].strip()\n+                token = Token(TOKEN_COMMENT, content)\n+        else:\n+            token = Token(TOKEN_TEXT, token_string)\n+        return token\n+\n+class Parser(object):\n+    def __init__(self, tokens):\n+        self.tokens = tokens\n+        self.tags = {}\n+        self.filters = {}\n+        for lib in builtins:\n+            self.add_library(lib)\n+\n+    def parse(self, parse_until=None):\n+        if parse_until is None: parse_until = []\n+        nodelist = self.create_nodelist()\n+        while self.tokens:\n+            token = self.next_token()\n+            if token.token_type == TOKEN_TEXT:\n+                self.extend_nodelist(nodelist, TextNode(token.contents), token)\n+            elif token.token_type == TOKEN_VAR:\n+                if not token.contents:\n+                    self.empty_variable(token)\n+                filter_expression = self.compile_filter(token.contents)\n+                var_node = self.create_variable_node(filter_expression)\n+                self.extend_nodelist(nodelist, var_node,token)\n+            elif token.token_type == TOKEN_BLOCK:\n+                if token.contents in parse_until:\n+                    # put token back on token list so calling code knows why it terminated\n+                    self.prepend_token(token)\n+                    return nodelist\n+                try:\n+                    command = token.contents.split()[0]\n+                except IndexError:\n+                    self.empty_block_tag(token)\n+                # execute callback function for this tag and append resulting node\n+                self.enter_command(command, token)\n+                try:\n+                    compile_func = self.tags[command]\n+                except KeyError:\n+                    self.invalid_block_tag(token, command, parse_until)\n+                try:\n+                    compiled_result = compile_func(self, token)\n+                except TemplateSyntaxError, e:\n+                    if not self.compile_function_error(token, e):\n+                        raise\n+                self.extend_nodelist(nodelist, compiled_result, token)\n+                self.exit_command()\n+        if parse_until:\n+            self.unclosed_block_tag(parse_until)\n+        return nodelist\n+\n+    def skip_past(self, endtag):\n+        while self.tokens:\n+            token = self.next_token()\n+            if token.token_type == TOKEN_BLOCK and token.contents == endtag:\n+                return\n+        self.unclosed_block_tag([endtag])\n+\n+    def create_variable_node(self, filter_expression):\n+        return VariableNode(filter_expression)\n+\n+    def create_nodelist(self):\n+        return NodeList()\n+\n+    def extend_nodelist(self, nodelist, node, token):\n+        if node.must_be_first and nodelist:\n+            try:\n+                if nodelist.contains_nontext:\n+                    raise AttributeError\n+            except AttributeError:\n+                raise TemplateSyntaxError(\"%r must be the first tag in the template.\" % node)\n+        if isinstance(nodelist, NodeList) and not isinstance(node, TextNode):\n+            nodelist.contains_nontext = True\n+        nodelist.append(node)\n+\n+    def enter_command(self, command, token):\n+        pass\n+\n+    def exit_command(self):\n+        pass\n+\n+    def error(self, token, msg):\n+        return TemplateSyntaxError(msg)\n+\n+    def empty_variable(self, token):\n+        raise self.error(token, \"Empty variable tag\")\n+\n+    def empty_block_tag(self, token):\n+        raise self.error(token, \"Empty block tag\")\n+\n+    def invalid_block_tag(self, token, command, parse_until=None):\n+        if parse_until:\n+            raise self.error(token, \"Invalid block tag: '%s', expected %s\" % (command, get_text_list([\"'%s'\" % p for p in parse_until])))\n+        raise self.error(token, \"Invalid block tag: '%s'\" % command)\n+\n+    def unclosed_block_tag(self, parse_until):\n+        raise self.error(None, \"Unclosed tags: %s \" %  ', '.join(parse_until))\n+\n+    def compile_function_error(self, token, e):\n+        pass\n+\n+    def next_token(self):\n+        return self.tokens.pop(0)\n+\n+    def prepend_token(self, token):\n+        self.tokens.insert(0, token)\n+\n+    def delete_first_token(self):\n+        del self.tokens[0]\n+\n+    def add_library(self, lib):\n+        self.tags.update(lib.tags)\n+        self.filters.update(lib.filters)\n+\n+    def compile_filter(self, token):\n+        \"Convenient wrapper for FilterExpression\"\n+        return FilterExpression(token, self)\n+\n+    def find_filter(self, filter_name):\n+        if filter_name in self.filters:\n+            return self.filters[filter_name]\n+        else:\n+            raise TemplateSyntaxError(\"Invalid filter: '%s'\" % filter_name)\n+\n+class TokenParser(object):\n+    \"\"\"\n+    Subclass this and implement the top() method to parse a template line. When\n+    instantiating the parser, pass in the line from the Django template parser.\n+\n+    The parser's \"tagname\" instance-variable stores the name of the tag that\n+    the filter was called with.\n+    \"\"\"\n+    def __init__(self, subject):\n+        self.subject = subject\n+        self.pointer = 0\n+        self.backout = []\n+        self.tagname = self.tag()\n+\n+    def top(self):\n+        \"Overload this method to do the actual parsing and return the result.\"\n+        raise NotImplementedError()\n+\n+    def more(self):\n+        \"Returns True if there is more stuff in the tag.\"\n+        return self.pointer < len(self.subject)\n+\n+    def back(self):\n+        \"Undoes the last microparser. Use this for lookahead and backtracking.\"\n+        if not len(self.backout):\n+            raise TemplateSyntaxError(\"back called without some previous parsing\")\n+        self.pointer = self.backout.pop()\n+\n+    def tag(self):\n+        \"A microparser that just returns the next tag from the line.\"\n+        subject = self.subject\n+        i = self.pointer\n+        if i >= len(subject):\n+            raise TemplateSyntaxError(\"expected another tag, found end of string: %s\" % subject)\n+        p = i\n+        while i < len(subject) and subject[i] not in (' ', '\\t'):\n+            i += 1\n+        s = subject[p:i]\n+        while i < len(subject) and subject[i] in (' ', '\\t'):\n+            i += 1\n+        self.backout.append(self.pointer)\n+        self.pointer = i\n+        return s\n+\n+    def value(self):\n+        \"A microparser that parses for a value: some string constant or variable name.\"\n+        subject = self.subject\n+        i = self.pointer\n+\n+        def next_space_index(subject, i):\n+            \"Increment pointer until a real space (i.e. a space not within quotes) is encountered\"\n+            while i < len(subject) and subject[i] not in (' ', '\\t'):\n+                if subject[i] in ('\"', \"'\"):\n+                    c = subject[i]\n+                    i += 1\n+                    while i < len(subject) and subject[i] != c:\n+                        i += 1\n+                    if i >= len(subject):\n+                        raise TemplateSyntaxError(\"Searching for value. Unexpected end of string in column %d: %s\" % (i, subject))\n+                i += 1\n+            return i\n+\n+        if i >= len(subject):\n+            raise TemplateSyntaxError(\"Searching for value. Expected another value but found end of string: %s\" % subject)\n+        if subject[i] in ('\"', \"'\"):\n+            p = i\n+            i += 1\n+            while i < len(subject) and subject[i] != subject[p]:\n+                i += 1\n+            if i >= len(subject):\n+                raise TemplateSyntaxError(\"Searching for value. Unexpected end of string in column %d: %s\" % (i, subject))\n+            i += 1\n+\n+            # Continue parsing until next \"real\" space, so that filters are also included\n+            i = next_space_index(subject, i)\n+\n+            res = subject[p:i]\n+            while i < len(subject) and subject[i] in (' ', '\\t'):\n+                i += 1\n+            self.backout.append(self.pointer)\n+            self.pointer = i\n+            return res\n+        else:\n+            p = i\n+            i = next_space_index(subject, i)\n+            s = subject[p:i]\n+            while i < len(subject) and subject[i] in (' ', '\\t'):\n+                i += 1\n+            self.backout.append(self.pointer)\n+            self.pointer = i\n+            return s\n+\n+# This only matches constant *strings* (things in quotes or marked for\n+# translation). Numbers are treated as variables for implementation reasons\n+# (so that they retain their type when passed to filters).\n+constant_string = r\"\"\"\n+(?:%(i18n_open)s%(strdq)s%(i18n_close)s|\n+%(i18n_open)s%(strsq)s%(i18n_close)s|\n+%(strdq)s|\n+%(strsq)s)\n+\"\"\" % {\n+    'strdq': r'\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"', # double-quoted string\n+    'strsq': r\"'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\", # single-quoted string\n+    'i18n_open' : re.escape(\"_(\"),\n+    'i18n_close' : re.escape(\")\"),\n+    }\n+constant_string = constant_string.replace(\"\\n\", \"\")\n+\n+filter_raw_string = r\"\"\"\n+^(?P<constant>%(constant)s)|\n+^(?P<var>[%(var_chars)s]+|%(num)s)|\n+ (?:%(filter_sep)s\n+     (?P<filter_name>\\w+)\n+         (?:%(arg_sep)s\n+             (?:\n+              (?P<constant_arg>%(constant)s)|\n+              (?P<var_arg>[%(var_chars)s]+|%(num)s)\n+             )\n+         )?\n+ )\"\"\" % {\n+    'constant': constant_string,\n+    'num': r'[-+\\.]?\\d[\\d\\.e]*',\n+    'var_chars': \"\\w\\.\" ,\n+    'filter_sep': re.escape(FILTER_SEPARATOR),\n+    'arg_sep': re.escape(FILTER_ARGUMENT_SEPARATOR),\n+  }\n+\n+filter_re = re.compile(filter_raw_string, re.UNICODE|re.VERBOSE)\n+\n+class FilterExpression(object):\n+    r\"\"\"\n+    Parses a variable token and its optional filters (all as a single string),\n+    and return a list of tuples of the filter name and arguments.\n+    Sample:\n+        >>> token = 'variable|default:\"Default value\"|date:\"Y-m-d\"'\n+        >>> p = Parser('')\n+        >>> fe = FilterExpression(token, p)\n+        >>> len(fe.filters)\n+        2\n+        >>> fe.var\n+        <Variable: 'variable'>\n+\n+    This class should never be instantiated outside of the\n+    get_filters_from_token helper function.\n+    \"\"\"\n+    def __init__(self, token, parser):\n+        self.token = token\n+        matches = filter_re.finditer(token)\n+        var_obj = None\n+        filters = []\n+        upto = 0\n+        for match in matches:\n+            start = match.start()\n+            if upto != start:\n+                raise TemplateSyntaxError(\"Could not parse some characters: %s|%s|%s\"  % \\\n+                        (token[:upto], token[upto:start], token[start:]))\n+            if var_obj is None:\n+                var, constant = match.group(\"var\", \"constant\")\n+                if constant:\n+                    try:\n+                        var_obj = Variable(constant).resolve({})\n+                    except VariableDoesNotExist:\n+                        var_obj = None\n+                elif var is None:\n+                    raise TemplateSyntaxError(\"Could not find variable at start of %s.\" % token)\n+                else:\n+                    var_obj = Variable(var)\n+            else:\n+                filter_name = match.group(\"filter_name\")\n+                args = []\n+                constant_arg, var_arg = match.group(\"constant_arg\", \"var_arg\")\n+                if constant_arg:\n+                    args.append((False, Variable(constant_arg).resolve({})))\n+                elif var_arg:\n+                    args.append((True, Variable(var_arg)))\n+                filter_func = parser.find_filter(filter_name)\n+                self.args_check(filter_name, filter_func, args)\n+                filters.append((filter_func, args))\n+            upto = match.end()\n+        if upto != len(token):\n+            raise TemplateSyntaxError(\"Could not parse the remainder: '%s' from '%s'\" % (token[upto:], token))\n+\n+        self.filters = filters\n+        self.var = var_obj\n+\n+    def resolve(self, context, ignore_failures=False):\n+        if isinstance(self.var, Variable):\n+            try:\n+                obj = self.var.resolve(context)\n+            except VariableDoesNotExist:\n+                if ignore_failures:\n+                    obj = None\n+                else:\n+                    if settings.TEMPLATE_STRING_IF_INVALID:\n+                        global invalid_var_format_string\n+                        if invalid_var_format_string is None:\n+                            invalid_var_format_string = '%s' in settings.TEMPLATE_STRING_IF_INVALID\n+                        if invalid_var_format_string:\n+                            return settings.TEMPLATE_STRING_IF_INVALID % self.var\n+                        return settings.TEMPLATE_STRING_IF_INVALID\n+                    else:\n+                        obj = settings.TEMPLATE_STRING_IF_INVALID\n+        else:\n+            obj = self.var\n+        for func, args in self.filters:\n+            arg_vals = []\n+            for lookup, arg in args:\n+                if not lookup:\n+                    arg_vals.append(mark_safe(arg))\n+                else:\n+                    arg_vals.append(arg.resolve(context))\n+            if getattr(func, 'needs_autoescape', False):\n+                new_obj = func(obj, autoescape=context.autoescape, *arg_vals)\n+            else:\n+                new_obj = func(obj, *arg_vals)\n+            if getattr(func, 'is_safe', False) and isinstance(obj, SafeData):\n+                obj = mark_safe(new_obj)\n+            elif isinstance(obj, EscapeData):\n+                obj = mark_for_escaping(new_obj)\n+            else:\n+                obj = new_obj\n+        return obj\n+\n+    def args_check(name, func, provided):\n+        provided = list(provided)\n+        plen = len(provided)\n+        # Check to see if a decorator is providing the real function.\n+        func = getattr(func, '_decorated_function', func)\n+        args, varargs, varkw, defaults = getargspec(func)\n+        # First argument is filter input.\n+        args.pop(0)\n+        if defaults:\n+            nondefs = args[:-len(defaults)]\n+        else:\n+            nondefs = args\n+        # Args without defaults must be provided.\n+        try:\n+            for arg in nondefs:\n+                provided.pop(0)\n+        except IndexError:\n+            # Not enough\n+            raise TemplateSyntaxError(\"%s requires %d arguments, %d provided\" % (name, len(nondefs), plen))\n+\n+        # Defaults can be overridden.\n+        defaults = defaults and list(defaults) or []\n+        try:\n+            for parg in provided:\n+                defaults.pop(0)\n+        except IndexError:\n+            # Too many.\n+            raise TemplateSyntaxError(\"%s requires %d arguments, %d provided\" % (name, len(nondefs), plen))\n+\n+        return True\n+    args_check = staticmethod(args_check)\n+\n+    def __str__(self):\n+        return self.token\n+\n+def resolve_variable(path, context):\n+    \"\"\"\n+    Returns the resolved variable, which may contain attribute syntax, within\n+    the given context.\n+\n+    Deprecated; use the Variable class instead.\n+    \"\"\"\n+    return Variable(path).resolve(context)\n+\n+class Variable(object):\n+    r\"\"\"\n+    A template variable, resolvable against a given context. The variable may be\n+    a hard-coded string (if it begins and ends with single or double quote\n+    marks)::\n+\n+        >>> c = {'article': {'section':u'News'}}\n+        >>> Variable('article.section').resolve(c)\n+        u'News'\n+        >>> Variable('article').resolve(c)\n+        {'section': u'News'}\n+        >>> class AClass: pass\n+        >>> c = AClass()\n+        >>> c.article = AClass()\n+        >>> c.article.section = u'News'\n+\n+    (The example assumes VARIABLE_ATTRIBUTE_SEPARATOR is '.')\n+    \"\"\"\n+\n+    def __init__(self, var):\n+        self.var = var\n+        self.literal = None\n+        self.lookups = None\n+        self.translate = False\n+\n+        try:\n+            # First try to treat this variable as a number.\n+            #\n+            # Note that this could cause an OverflowError here that we're not\n+            # catching. Since this should only happen at compile time, that's\n+            # probably OK.\n+            self.literal = float(var)\n+\n+            # So it's a float... is it an int? If the original value contained a\n+            # dot or an \"e\" then it was a float, not an int.\n+            if '.' not in var and 'e' not in var.lower():\n+                self.literal = int(self.literal)\n+\n+            # \"2.\" is invalid\n+            if var.endswith('.'):\n+                raise ValueError\n+\n+        except ValueError:\n+            # A ValueError means that the variable isn't a number.\n+            if var.startswith('_(') and var.endswith(')'):\n+                # The result of the lookup should be translated at rendering\n+                # time.\n+                self.translate = True\n+                var = var[2:-1]\n+            # If it's wrapped with quotes (single or double), then\n+            # we're also dealing with a literal.\n+            try:\n+                self.literal = mark_safe(unescape_string_literal(var))\n+            except ValueError:\n+                # Otherwise we'll set self.lookups so that resolve() knows we're\n+                # dealing with a bonafide variable\n+                if var.find(VARIABLE_ATTRIBUTE_SEPARATOR + '_') > -1 or var[0] == '_':\n+                    raise TemplateSyntaxError(\"Variables and attributes may not begin with underscores: '%s'\" % var)\n+                self.lookups = tuple(var.split(VARIABLE_ATTRIBUTE_SEPARATOR))\n+\n+    def resolve(self, context):\n+        \"\"\"Resolve this variable against a given context.\"\"\"\n+        if self.lookups is not None:\n+            # We're dealing with a variable that needs to be resolved\n+            value = self._resolve_lookup(context)\n+        else:\n+            # We're dealing with a literal, so it's already been \"resolved\"\n+            value = self.literal\n+        if self.translate:\n+            return _(value)\n+        return value\n+\n+    def __repr__(self):\n+        return \"<%s: %r>\" % (self.__class__.__name__, self.var)\n+\n+    def __str__(self):\n+        return self.var\n+\n+    def _resolve_lookup(self, context):\n+        \"\"\"\n+        Performs resolution of a real variable (i.e. not a literal) against the\n+        given context.\n+\n+        As indicated by the method's name, this method is an implementation\n+        detail and shouldn't be called by external code. Use Variable.resolve()\n+        instead.\n+        \"\"\"\n+        current = context\n+        for bit in self.lookups:\n+            try: # dictionary lookup\n+                current = current[bit]\n+            except (TypeError, AttributeError, KeyError):\n+                try: # attribute lookup\n+                    current = getattr(current, bit)\n+                    if callable(current):\n+                        if getattr(current, 'alters_data', False):\n+                            current = settings.TEMPLATE_STRING_IF_INVALID\n+                        else:\n+                            try: # method call (assuming no args required)\n+                                current = current()\n+                            except TypeError: # arguments *were* required\n+                                # GOTCHA: This will also catch any TypeError\n+                                # raised in the function itself.\n+                                current = settings.TEMPLATE_STRING_IF_INVALID # invalid method call\n+                            except Exception, e:\n+                                if getattr(e, 'silent_variable_failure', False):\n+                                    current = settings.TEMPLATE_STRING_IF_INVALID\n+                                else:\n+                                    raise\n+                except (TypeError, AttributeError):\n+                    try: # list-index lookup\n+                        current = current[int(bit)]\n+                    except (IndexError, # list index out of range\n+                            ValueError, # invalid literal for int()\n+                            KeyError,   # current is a dict without `int(bit)` key\n+                            TypeError,  # unsubscriptable object\n+                            ):\n+                        raise VariableDoesNotExist(\"Failed lookup for key [%s] in %r\", (bit, current)) # missing attribute\n+                except Exception, e:\n+                    if getattr(e, 'silent_variable_failure', False):\n+                        current = settings.TEMPLATE_STRING_IF_INVALID\n+                    else:\n+                        raise\n+            except Exception, e:\n+                if getattr(e, 'silent_variable_failure', False):\n+                    current = settings.TEMPLATE_STRING_IF_INVALID\n+                else:\n+                    raise\n+\n+        return current\n+\n+class Node(object):\n+    # Set this to True for nodes that must be first in the template (although\n+    # they can be preceded by text nodes.\n+    must_be_first = False\n+    child_nodelists = ('nodelist',)\n+\n+    def render(self, context):\n+        \"Return the node rendered as a string\"\n+        pass\n+\n+    def __iter__(self):\n+        yield self\n+\n+    def get_nodes_by_type(self, nodetype):\n+        \"Return a list of all nodes (within this node and its nodelist) of the given type\"\n+        nodes = []\n+        if isinstance(self, nodetype):\n+            nodes.append(self)\n+        for attr in self.child_nodelists:\n+            nodelist = getattr(self, attr, None)\n+            if nodelist:\n+                nodes.extend(nodelist.get_nodes_by_type(nodetype))\n+        return nodes\n+\n+class NodeList(list):\n+    # Set to True the first time a non-TextNode is inserted by\n+    # extend_nodelist().\n+    contains_nontext = False\n+\n+    def render(self, context):\n+        bits = []\n+        for node in self:\n+            if isinstance(node, Node):\n+                bits.append(self.render_node(node, context))\n+            else:\n+                bits.append(node)\n+        return mark_safe(''.join([force_unicode(b) for b in bits]))\n+\n+    def get_nodes_by_type(self, nodetype):\n+        \"Return a list of all nodes of the given type\"\n+        nodes = []\n+        for node in self:\n+            nodes.extend(node.get_nodes_by_type(nodetype))\n+        return nodes\n+\n+    def render_node(self, node, context):\n+        return node.render(context)\n+\n+class TextNode(Node):\n+    def __init__(self, s):\n+        self.s = s\n+\n+    def __repr__(self):\n+        return \"<Text Node: '%s'>\" % smart_str(self.s[:25], 'ascii',\n+                errors='replace')\n+\n+    def render(self, context):\n+        return self.s\n+\n+def _render_value_in_context(value, context):\n+    \"\"\"\n+    Converts any value to a string to become part of a rendered template. This\n+    means escaping, if required, and conversion to a unicode object. If value\n+    is a string, it is expected to have already been translated.\n+    \"\"\"\n+    value = localize(value, use_l10n=context.use_l10n)\n+    value = force_unicode(value)\n+    if (context.autoescape and not isinstance(value, SafeData)) or isinstance(value, EscapeData):\n+        return escape(value)\n+    else:\n+        return value\n+\n+class VariableNode(Node):\n+    def __init__(self, filter_expression):\n+        self.filter_expression = filter_expression\n+\n+    def __repr__(self):\n+        return \"<Variable Node: %s>\" % self.filter_expression\n+\n+    def render(self, context):\n+        try:\n+            output = self.filter_expression.resolve(context)\n+        except UnicodeDecodeError:\n+            # Unicode conversion can fail sometimes for reasons out of our\n+            # control (e.g. exception rendering). In that case, we fail quietly.\n+            return ''\n+        return _render_value_in_context(output, context)\n+\n+def generic_tag_compiler(params, defaults, name, node_class, parser, token):\n+    \"Returns a template.Node subclass.\"\n+    bits = token.split_contents()[1:]\n+    bmax = len(params)\n+    def_len = defaults and len(defaults) or 0\n+    bmin = bmax - def_len\n+    if(len(bits) < bmin or len(bits) > bmax):\n+        if bmin == bmax:\n+            message = \"%s takes %s arguments\" % (name, bmin)\n+        else:\n+            message = \"%s takes between %s and %s arguments\" % (name, bmin, bmax)\n+        raise TemplateSyntaxError(message)\n+    return node_class(bits)\n+\n+class Library(object):\n+    def __init__(self):\n+        self.filters = {}\n+        self.tags = {}\n+\n+    def tag(self, name=None, compile_function=None):\n+        if name == None and compile_function == None:\n+            # @register.tag()\n+            return self.tag_function\n+        elif name != None and compile_function == None:\n+            if(callable(name)):\n+                # @register.tag\n+                return self.tag_function(name)\n+            else:\n+                # @register.tag('somename') or @register.tag(name='somename')\n+                def dec(func):\n+                    return self.tag(name, func)\n+                return dec\n+        elif name != None and compile_function != None:\n+            # register.tag('somename', somefunc)\n+            self.tags[name] = compile_function\n+            return compile_function\n+        else:\n+            raise InvalidTemplateLibrary(\"Unsupported arguments to Library.tag: (%r, %r)\", (name, compile_function))\n+\n+    def tag_function(self,func):\n+        self.tags[getattr(func, \"_decorated_function\", func).__name__] = func\n+        return func\n+\n+    def filter(self, name=None, filter_func=None):\n+        if name == None and filter_func == None:\n+            # @register.filter()\n+            return self.filter_function\n+        elif filter_func == None:\n+            if(callable(name)):\n+                # @register.filter\n+                return self.filter_function(name)\n+            else:\n+                # @register.filter('somename') or @register.filter(name='somename')\n+                def dec(func):\n+                    return self.filter(name, func)\n+                return dec\n+        elif name != None and filter_func != None:\n+            # register.filter('somename', somefunc)\n+            self.filters[name] = filter_func\n+            return filter_func\n+        else:\n+            raise InvalidTemplateLibrary(\"Unsupported arguments to Library.filter: (%r, %r)\", (name, filter_func))\n+\n+    def filter_function(self, func):\n+        self.filters[getattr(func, \"_decorated_function\", func).__name__] = func\n+        return func\n+\n+    def simple_tag(self,func):\n+        params, xx, xxx, defaults = getargspec(func)\n+\n+        class SimpleNode(Node):\n+            def __init__(self, vars_to_resolve):\n+                self.vars_to_resolve = map(Variable, vars_to_resolve)\n+\n+            def render(self, context):\n+                resolved_vars = [var.resolve(context) for var in self.vars_to_resolve]\n+                return func(*resolved_vars)\n+\n+        compile_func = curry(generic_tag_compiler, params, defaults, getattr(func, \"_decorated_function\", func).__name__, SimpleNode)\n+        compile_func.__doc__ = func.__doc__\n+        self.tag(getattr(func, \"_decorated_function\", func).__name__, compile_func)\n+        return func\n+\n+    def inclusion_tag(self, file_name, context_class=Context, takes_context=False):\n+        def dec(func):\n+            params, xx, xxx, defaults = getargspec(func)\n+            if takes_context:\n+                if params[0] == 'context':\n+                    params = params[1:]\n+                else:\n+                    raise TemplateSyntaxError(\"Any tag function decorated with takes_context=True must have a first argument of 'context'\")\n+\n+            class InclusionNode(Node):\n+                def __init__(self, vars_to_resolve):\n+                    self.vars_to_resolve = map(Variable, vars_to_resolve)\n+\n+                def render(self, context):\n+                    resolved_vars = [var.resolve(context) for var in self.vars_to_resolve]\n+                    if takes_context:\n+                        args = [context] + resolved_vars\n+                    else:\n+                        args = resolved_vars\n+\n+                    dict = func(*args)\n+\n+                    if not getattr(self, 'nodelist', False):\n+                        from django.template.loader import get_template, select_template\n+                        if not isinstance(file_name, basestring) and is_iterable(file_name):\n+                            t = select_template(file_name)\n+                        else:\n+                            t = get_template(file_name)\n+                        self.nodelist = t.nodelist\n+                    new_context = context_class(dict, autoescape=context.autoescape)\n+                    # Copy across the CSRF token, if present, because inclusion\n+                    # tags are often used for forms, and we need instructions\n+                    # for using CSRF protection to be as simple as possible.\n+                    csrf_token = context.get('csrf_token', None)\n+                    if csrf_token is not None:\n+                        new_context['csrf_token'] = csrf_token\n+                    return self.nodelist.render(new_context)\n+\n+            compile_func = curry(generic_tag_compiler, params, defaults, getattr(func, \"_decorated_function\", func).__name__, InclusionNode)\n+            compile_func.__doc__ = func.__doc__\n+            self.tag(getattr(func, \"_decorated_function\", func).__name__, compile_func)\n+            return func\n+        return dec\n+\n+def import_library(taglib_module):\n+    \"\"\"Load a template tag library module.\n+\n+    Verifies that the library contains a 'register' attribute, and\n+    returns that attribute as the representation of the library\n+    \"\"\"\n+    app_path, taglib = taglib_module.rsplit('.',1)\n+    app_module = import_module(app_path)\n+    try:\n+        mod = import_module(taglib_module)\n+    except ImportError, e:\n+        # If the ImportError is because the taglib submodule does not exist, that's not\n+        # an error that should be raised. If the submodule exists and raised an ImportError\n+        # on the attempt to load it, that we want to raise.\n+        if not module_has_submodule(app_module, taglib):\n+            return None\n+        else:\n+            raise InvalidTemplateLibrary(\"ImportError raised loading %s: %s\" % (taglib_module, e))\n+    try:\n+        return mod.register\n+    except AttributeError:\n+        raise InvalidTemplateLibrary(\"Template library %s does not have a variable named 'register'\" % taglib_module)\n+\n+templatetags_modules = []\n+\n+def get_templatetags_modules():\n+    \"\"\"Return the list of all available template tag modules.\n+\n+    Caches the result for faster access.\n+    \"\"\"\n+    global templatetags_modules\n+    if not templatetags_modules:\n+        _templatetags_modules = []\n+        # Populate list once per thread.\n+        for app_module in ['django'] + list(settings.INSTALLED_APPS):\n+            try:\n+                templatetag_module = '%s.templatetags' % app_module\n+                import_module(templatetag_module)\n+                _templatetags_modules.append(templatetag_module)\n+            except ImportError:\n+                continue\n+        templatetags_modules = _templatetags_modules\n+    return templatetags_modules\n+\n+def get_library(library_name):\n+    \"\"\"\n+    Load the template library module with the given name.\n+\n+    If library is not already loaded loop over all templatetags modules to locate it.\n+\n+    {% load somelib %} and {% load someotherlib %} loops twice.\n+\n+    Subsequent loads eg. {% load somelib %} in the same process will grab the cached\n+    module from libraries.\n+    \"\"\"\n+    lib = libraries.get(library_name, None)\n+    if not lib:\n+        templatetags_modules = get_templatetags_modules()\n+        tried_modules = []\n+        for module in templatetags_modules:\n+            taglib_module = '%s.%s' % (module, library_name)\n+            tried_modules.append(taglib_module)\n+            lib = import_library(taglib_module)\n+            if lib:\n+                libraries[library_name] = lib\n+                break\n+        if not lib:\n+            raise InvalidTemplateLibrary(\"Template library %s not found, tried %s\" % (library_name, ','.join(tried_modules)))\n+    return lib\n+\n+def add_to_builtins(module):\n+    builtins.append(import_library(module))\n+\n+add_to_builtins('django.template.defaulttags')\n+add_to_builtins('django.template.defaultfilters')"
        },
        {
            "sha": "a9e3c4f49761818dd3e14102a73acedc4e13bd43",
            "filename": "django/template/debug.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Fdebug.py",
            "raw_url": "https://github.com/django/django/raw/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Fdebug.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2Fdebug.py?ref=0be14b0b9647b1662c41e7e408072ebe19f28929",
            "patch": "@@ -1,5 +1,5 @@\n from django.conf import settings\n-from django.template import Lexer, Parser, tag_re, NodeList, VariableNode, TemplateSyntaxError\n+from django.template.base import Lexer, Parser, tag_re, NodeList, VariableNode, TemplateSyntaxError\n from django.utils.encoding import force_unicode\n from django.utils.html import escape\n from django.utils.safestring import SafeData, EscapeData"
        },
        {
            "sha": "d59ad2d461c1280f1b2ec29ff7ff698c9702ae91",
            "filename": "django/template/defaultfilters.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Fdefaultfilters.py",
            "raw_url": "https://github.com/django/django/raw/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Fdefaultfilters.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2Fdefaultfilters.py?ref=0be14b0b9647b1662c41e7e408072ebe19f28929",
            "patch": "@@ -8,7 +8,7 @@\n except ImportError:\n     from django.utils.functional import wraps  # Python 2.4 fallback.\n \n-from django.template import Variable, Library\n+from django.template.base import Variable, Library\n from django.conf import settings\n from django.utils import formats\n from django.utils.encoding import force_unicode, iri_to_uri"
        },
        {
            "sha": "5beab49d0a50749d40e532df41c95f46568bf932",
            "filename": "django/template/defaulttags.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Fdefaulttags.py",
            "raw_url": "https://github.com/django/django/raw/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Fdefaulttags.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2Fdefaulttags.py?ref=0be14b0b9647b1662c41e7e408072ebe19f28929",
            "patch": "@@ -4,9 +4,9 @@\n import re\n from itertools import groupby, cycle as itertools_cycle\n \n-from django.template import Node, NodeList, Template, Context, Variable\n-from django.template import TemplateSyntaxError, VariableDoesNotExist, BLOCK_TAG_START, BLOCK_TAG_END, VARIABLE_TAG_START, VARIABLE_TAG_END, SINGLE_BRACE_START, SINGLE_BRACE_END, COMMENT_TAG_START, COMMENT_TAG_END\n-from django.template import get_library, Library, InvalidTemplateLibrary\n+from django.template.base import Node, NodeList, Template, Context, Variable\n+from django.template.base import TemplateSyntaxError, VariableDoesNotExist, BLOCK_TAG_START, BLOCK_TAG_END, VARIABLE_TAG_START, VARIABLE_TAG_END, SINGLE_BRACE_START, SINGLE_BRACE_END, COMMENT_TAG_START, COMMENT_TAG_END\n+from django.template.base import get_library, Library, InvalidTemplateLibrary\n from django.template.smartif import IfParser, Literal\n from django.conf import settings\n from django.utils.encoding import smart_str, smart_unicode"
        },
        {
            "sha": "279d8e86fe8cb7329f34c36888e75da88597dce9",
            "filename": "django/template/loader.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Floader.py",
            "raw_url": "https://github.com/django/django/raw/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Floader.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2Floader.py?ref=0be14b0b9647b1662c41e7e408072ebe19f28929",
            "patch": "@@ -26,7 +26,7 @@\n # installed, because pkg_resources is necessary to read eggs.\n \n from django.core.exceptions import ImproperlyConfigured\n-from django.template import Origin, Template, Context, TemplateDoesNotExist, add_to_builtins\n+from django.template.base import Origin, Template, Context, TemplateDoesNotExist, add_to_builtins\n from django.utils.importlib import import_module\n from django.conf import settings\n "
        },
        {
            "sha": "cc4773927c5745cdb20f5b3788b9b6512acfdf85",
            "filename": "django/template/loader_tags.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Floader_tags.py",
            "raw_url": "https://github.com/django/django/raw/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Floader_tags.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2Floader_tags.py?ref=0be14b0b9647b1662c41e7e408072ebe19f28929",
            "patch": "@@ -1,5 +1,5 @@\n-from django.template import TemplateSyntaxError, TemplateDoesNotExist, Variable\n-from django.template import Library, Node, TextNode\n+from django.template.base import TemplateSyntaxError, TemplateDoesNotExist, Variable\n+from django.template.base import Library, Node, TextNode\n from django.template.loader import get_template\n from django.conf import settings\n from django.utils.safestring import mark_safe"
        },
        {
            "sha": "475ece812f70906a4731375b3016b2e40b6034f7",
            "filename": "django/template/loaders/app_directories.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Floaders%2Fapp_directories.py",
            "raw_url": "https://github.com/django/django/raw/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Floaders%2Fapp_directories.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2Floaders%2Fapp_directories.py?ref=0be14b0b9647b1662c41e7e408072ebe19f28929",
            "patch": "@@ -8,7 +8,7 @@\n \n from django.conf import settings\n from django.core.exceptions import ImproperlyConfigured\n-from django.template import TemplateDoesNotExist\n+from django.template.base import TemplateDoesNotExist\n from django.template.loader import BaseLoader\n from django.utils._os import safe_join\n from django.utils.importlib import import_module"
        },
        {
            "sha": "715542adf765ecf509248a19f9be162a23f824bd",
            "filename": "django/template/loaders/cached.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Floaders%2Fcached.py",
            "raw_url": "https://github.com/django/django/raw/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Floaders%2Fcached.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2Floaders%2Fcached.py?ref=0be14b0b9647b1662c41e7e408072ebe19f28929",
            "patch": "@@ -4,7 +4,7 @@\n \"\"\"\n \n from django.core.exceptions import ImproperlyConfigured\n-from django.template import TemplateDoesNotExist\n+from django.template.base import TemplateDoesNotExist\n from django.template.loader import BaseLoader, get_template_from_string, find_template_loader, make_origin\n from django.utils.hashcompat import sha_constructor\n from django.utils.importlib import import_module"
        },
        {
            "sha": "df54a41fe8a820a901fe0e63ec676d22302bbd03",
            "filename": "django/template/loaders/eggs.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Floaders%2Feggs.py",
            "raw_url": "https://github.com/django/django/raw/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Floaders%2Feggs.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2Floaders%2Feggs.py?ref=0be14b0b9647b1662c41e7e408072ebe19f28929",
            "patch": "@@ -5,7 +5,7 @@\n except ImportError:\n     resource_string = None\n \n-from django.template import TemplateDoesNotExist\n+from django.template.base import TemplateDoesNotExist\n from django.template.loader import BaseLoader\n from django.conf import settings\n "
        },
        {
            "sha": "b12dcf8fba7301802d481b3196090b500db0852b",
            "filename": "django/template/loaders/filesystem.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Floaders%2Ffilesystem.py",
            "raw_url": "https://github.com/django/django/raw/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplate%2Floaders%2Ffilesystem.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2Floaders%2Ffilesystem.py?ref=0be14b0b9647b1662c41e7e408072ebe19f28929",
            "patch": "@@ -3,7 +3,7 @@\n \"\"\"\n \n from django.conf import settings\n-from django.template import TemplateDoesNotExist\n+from django.template.base import TemplateDoesNotExist\n from django.template.loader import BaseLoader\n from django.utils._os import safe_join\n "
        },
        {
            "sha": "192943728b1295bed556c0c23abc561b1b2abbfa",
            "filename": "django/templatetags/i18n.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplatetags%2Fi18n.py",
            "raw_url": "https://github.com/django/django/raw/0be14b0b9647b1662c41e7e408072ebe19f28929/django%2Ftemplatetags%2Fi18n.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplatetags%2Fi18n.py?ref=0be14b0b9647b1662c41e7e408072ebe19f28929",
            "patch": "@@ -1,8 +1,9 @@\n import re\n \n-from django.template import Node, Variable, VariableNode, _render_value_in_context\n+from django.template import Node, Variable, VariableNode\n from django.template import TemplateSyntaxError, TokenParser, Library\n from django.template import TOKEN_TEXT, TOKEN_VAR\n+from django.template.base import _render_value_in_context\n from django.utils import translation\n from django.utils.encoding import force_unicode\n "
        },
        {
            "sha": "326eb0a471606eb348278dd23e96516a62544444",
            "filename": "tests/regressiontests/templates/tests.py",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/0be14b0b9647b1662c41e7e408072ebe19f28929/tests%2Fregressiontests%2Ftemplates%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/0be14b0b9647b1662c41e7e408072ebe19f28929/tests%2Fregressiontests%2Ftemplates%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftemplates%2Ftests.py?ref=0be14b0b9647b1662c41e7e408072ebe19f28929",
            "patch": "@@ -13,6 +13,7 @@\n import traceback\n \n from django import template\n+from django.template import base as template_base\n from django.core import urlresolvers\n from django.template import loader\n from django.template.loaders import app_directories, filesystem, cached\n@@ -375,7 +376,7 @@ def test_template_loader(template_name, template_dirs=None):\n                 if isinstance(invalid_string_result, basestring) and '%s' in invalid_string_result:\n                     expected_invalid_str = 'INVALID %s'\n                     invalid_string_result = invalid_string_result % vals[2][2]\n-                    template.invalid_var_format_string = True\n+                    template_base.invalid_var_format_string = True\n             else:\n                 normal_string_result = vals[2]\n                 invalid_string_result = vals[2]\n@@ -417,9 +418,9 @@ def test_template_loader(template_name, template_dirs=None):\n             if 'LANGUAGE_CODE' in vals[1]:\n                 deactivate()\n \n-            if template.invalid_var_format_string:\n+            if template_base.invalid_var_format_string:\n                 expected_invalid_str = 'INVALID'\n-                template.invalid_var_format_string = False\n+                template_base.invalid_var_format_string = False\n \n         loader.template_source_loaders = old_template_loaders\n         deactivate()\n@@ -1463,13 +1464,13 @@ def setUp(self):\n         self.old_path = sys.path[:]\n         self.old_apps = settings.INSTALLED_APPS\n         self.egg_dir = '%s/eggs' % os.path.dirname(__file__)\n-        self.old_tag_modules = template.templatetags_modules\n-        template.templatetags_modules = []\n+        self.old_tag_modules = template_base.templatetags_modules\n+        template_base.templatetags_modules = []\n \n     def tearDown(self):\n         settings.INSTALLED_APPS = self.old_apps\n         sys.path = self.old_path\n-        template.templatetags_modules = self.old_tag_modules\n+        template_base.templatetags_modules = self.old_tag_modules\n \n     def test_load_error(self):\n         ttext = \"{% load broken_tag %}\""
        }
    ],
    "stats": {
        "total": 2075,
        "additions": 1053,
        "deletions": 1022
    }
}