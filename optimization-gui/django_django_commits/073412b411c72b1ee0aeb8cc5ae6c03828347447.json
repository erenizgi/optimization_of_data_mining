{
    "author": "spookylukey",
    "message": "Fixed #14700 - speed up RawQuerySet iterator.\n\nThis moves constant work out of the loop, and uses the much faster *args\nbased model instantiation where possible, to produce very large speed ups.\n\nThanks to akaariai for the report and patch.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@14692 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "073412b411c72b1ee0aeb8cc5ae6c03828347447",
    "files": [
        {
            "sha": "104c000325e419a439a7159114eb7553f3a3d594",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 61,
            "deletions": 46,
            "changes": 107,
            "blob_url": "https://github.com/django/django/blob/073412b411c72b1ee0aeb8cc5ae6c03828347447/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/073412b411c72b1ee0aeb8cc5ae6c03828347447/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=073412b411c72b1ee0aeb8cc5ae6c03828347447",
            "patch": "@@ -1299,8 +1299,67 @@ def __init__(self, raw_query, model=None, query=None, params=None,\n         self.translations = translations or {}\n \n     def __iter__(self):\n-        for row in self.query:\n-            yield self.transform_results(row)\n+        # Mapping of attrnames to row column positions. Used for constructing\n+        # the model using kwargs, needed when not all model's fields are present\n+        # in the query.\n+        model_init_field_names = {}\n+        # A list of tuples of (column name, column position). Used for\n+        # annotation fields.\n+        annotation_fields = []\n+\n+        # Cache some things for performance reasons outside the loop.\n+        db = self.db\n+        compiler = connections[db].ops.compiler('SQLCompiler')(self.query, connections[db], db)\n+        need_resolv_columns = hasattr(compiler, 'resolve_columns')\n+\n+        # Find out which columns are model's fields, and which ones should be\n+        # annotated to the model.\n+        for pos, column in enumerate(self.columns):\n+            if column in self.model_fields:\n+                model_init_field_names[self.model_fields[column].attname] = pos\n+            else:\n+                annotation_fields.append((column, pos))\n+\n+        # Find out which model's fields are not present in the query.\n+        skip = set()\n+        for field in self.model._meta.fields:\n+            if field.attname not in model_init_field_names:\n+                skip.add(field.attname)\n+        if skip:\n+            if self.model._meta.pk.attname in skip:\n+                raise InvalidQuery('Raw query must include the primary key')\n+            model_cls = deferred_class_factory(self.model, skip)\n+        else:\n+            model_cls = self.model\n+            # All model's fields are present in the query. So, it is possible\n+            # to use *args based model instantation. For each field of the model,\n+            # record the query column position matching that field.\n+            model_init_field_pos = []\n+            for field in self.model._meta.fields:\n+                model_init_field_pos.append(model_init_field_names[field.attname])\n+        if need_resolv_columns:\n+            fields = [self.model_fields.get(c, None) for c in self.columns]\n+        # Begin looping through the query values.\n+        for values in self.query:\n+            if need_resolv_columns:\n+                values = compiler.resolve_columns(values, fields)\n+            # Associate fields to values\n+            if skip:\n+                model_init_kwargs = {}\n+                for attname, pos in model_init_field_names.iteritems():\n+                    model_init_kwargs[attname] = values[pos]\n+                instance = model_cls(**model_init_kwargs)\n+            else:\n+                model_init_args = [values[pos] for pos in model_init_field_pos]\n+                instance = model_cls(*model_init_args)\n+            if annotation_fields:\n+                for column, pos in annotation_fields:\n+                    setattr(instance, column, values[pos])\n+\n+            instance._state.db = db\n+            instance._state.adding = False\n+\n+            yield instance\n \n     def __repr__(self):\n         return \"<RawQuerySet: %r>\" % (self.raw_query % self.params)\n@@ -1355,50 +1414,6 @@ def model_fields(self):\n                 self._model_fields[converter(column)] = field\n         return self._model_fields\n \n-    def transform_results(self, values):\n-        model_init_kwargs = {}\n-        annotations = ()\n-\n-        # Perform database backend type resolution\n-        connection = connections[self.db]\n-        compiler = connection.ops.compiler('SQLCompiler')(self.query, connection, self.db)\n-        if hasattr(compiler, 'resolve_columns'):\n-            fields = [self.model_fields.get(c,None) for c in self.columns]\n-            values = compiler.resolve_columns(values, fields)\n-\n-        # Associate fields to values\n-        for pos, value in enumerate(values):\n-            column = self.columns[pos]\n-\n-            # Separate properties from annotations\n-            if column in self.model_fields.keys():\n-                model_init_kwargs[self.model_fields[column].attname] = value\n-            else:\n-                annotations += (column, value),\n-\n-        # Construct model instance and apply annotations\n-        skip = set()\n-        for field in self.model._meta.fields:\n-            if field.attname not in model_init_kwargs.keys():\n-                skip.add(field.attname)\n-\n-        if skip:\n-            if self.model._meta.pk.attname in skip:\n-                raise InvalidQuery('Raw query must include the primary key')\n-            model_cls = deferred_class_factory(self.model, skip)\n-        else:\n-            model_cls = self.model\n-\n-        instance = model_cls(**model_init_kwargs)\n-\n-        for field, value in annotations:\n-            setattr(instance, field, value)\n-\n-        instance._state.db = self.query.using\n-        instance._state.adding = False\n-\n-        return instance\n-\n def insert_query(model, values, return_id=False, raw_values=False, using=None):\n     \"\"\"\n     Inserts a new record for the given model. This provides an interface to"
        }
    ],
    "stats": {
        "total": 107,
        "additions": 61,
        "deletions": 46
    }
}