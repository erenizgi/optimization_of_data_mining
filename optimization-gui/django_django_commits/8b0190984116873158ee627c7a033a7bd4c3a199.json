{
    "author": "aaugustin",
    "message": "[py3] Bundled six for Python 3 compatibility.\n\nRefs #18363.",
    "sha": "8b0190984116873158ee627c7a033a7bd4c3a199",
    "files": [
        {
            "sha": "8a5c37e97662fed5545db0d6d108da90a944b84c",
            "filename": "django/utils/py3.py",
            "status": "removed",
            "additions": 0,
            "deletions": 109,
            "changes": 109,
            "blob_url": "https://github.com/django/django/blob/01c392623d988d7486bdaa870886df0ea3da5fa7/django%2Futils%2Fpy3.py",
            "raw_url": "https://github.com/django/django/raw/01c392623d988d7486bdaa870886df0ea3da5fa7/django%2Futils%2Fpy3.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fpy3.py?ref=01c392623d988d7486bdaa870886df0ea3da5fa7",
            "patch": "@@ -1,109 +0,0 @@\n-# Compatibility layer for running Django both in 2.x and 3.x\n-\n-import sys\n-\n-if sys.version_info[0] < 3:\n-    PY3 = False\n-    # Changed module locations\n-    from urlparse import (urlparse, urlunparse, urljoin, urlsplit, urlunsplit,\n-                          urldefrag, parse_qsl)\n-    from urllib import (quote, unquote, quote_plus, urlopen, urlencode,\n-                        url2pathname, urlretrieve, unquote_plus)\n-    from urllib2 import (Request, OpenerDirector, UnknownHandler, HTTPHandler,\n-                         HTTPSHandler, HTTPDefaultErrorHandler, FTPHandler,\n-                         HTTPError, HTTPErrorProcessor)\n-    import urllib2\n-    import Cookie as cookies\n-    try:\n-        import cPickle as pickle\n-    except ImportError:\n-        import pickle\n-    try:\n-        import thread\n-    except ImportError:\n-        import dummy_thread as thread\n-    from htmlentitydefs import name2codepoint\n-    import HTMLParser\n-    from os import getcwdu\n-    from itertools import izip as zip\n-    unichr = unichr\n-    xrange = xrange\n-    maxsize = sys.maxint\n-\n-    # Type aliases\n-    string_types = basestring,\n-    text_type = unicode\n-    integer_types = int, long\n-    long_type = long\n-\n-    from io import BytesIO as OutputIO\n-\n-    # Glue code for syntax differences\n-    def reraise(tp, value, tb=None):\n-        exec(\"raise tp, value, tb\")\n-\n-    def with_metaclass(meta, base=object):\n-        class _DjangoBase(base):\n-            __metaclass__ = meta\n-        return _DjangoBase\n-\n-    iteritems = lambda o: o.iteritems()\n-    itervalues = lambda o: o.itervalues()\n-    iterkeys = lambda o: o.iterkeys()\n-\n-    # n() is useful when python3 needs a str (unicode), and python2 str (bytes)\n-    n = lambda s: s.encode('utf-8')\n-\n-else:\n-    PY3 = True\n-    import builtins\n-\n-    # Changed module locations\n-    from urllib.parse import (urlparse, urlunparse, urlencode, urljoin,\n-                              urlsplit, urlunsplit, quote, unquote,\n-                              quote_plus, unquote_plus, parse_qsl,\n-                              urldefrag)\n-    from urllib.request import (urlopen, url2pathname, Request, OpenerDirector,\n-                                UnknownHandler, HTTPHandler, HTTPSHandler,\n-                                HTTPDefaultErrorHandler, FTPHandler,\n-                                HTTPError, HTTPErrorProcessor, urlretrieve)\n-    import urllib.request as urllib2\n-    import http.cookies as cookies\n-    import pickle\n-    try:\n-        import _thread as thread\n-    except ImportError:\n-        import _dummy_thread as thread\n-    from html.entities import name2codepoint\n-    import html.parser as HTMLParser\n-    from os import getcwd as getcwdu\n-    zip = zip\n-    unichr = chr\n-    xrange = range\n-    maxsize = sys.maxsize\n-\n-    # Type aliases\n-    string_types = str,\n-    text_type = str\n-    integer_types = int,\n-    long_type = int\n-\n-    from io import StringIO as OutputIO\n-\n-    # Glue code for syntax differences\n-    def reraise(tp, value, tb=None):\n-        if value.__traceback__ is not tb:\n-            raise value.with_traceback(tb)\n-        raise value\n-\n-    def with_metaclass(meta, base=object):\n-        ns = dict(base=base, meta=meta)\n-        exec(\"\"\"class _DjangoBase(base, metaclass=meta):\n-    pass\"\"\", ns)\n-        return ns[\"_DjangoBase\"]\n-\n-    iteritems = lambda o: o.items()\n-    itervalues = lambda o: o.values()\n-    iterkeys = lambda o: o.keys()\n-\n-    n = lambda s: s"
        },
        {
            "sha": "6526d76cb14826fc31e5bd80f0cbc06449943da1",
            "filename": "django/utils/six.py",
            "status": "added",
            "additions": 353,
            "deletions": 0,
            "changes": 353,
            "blob_url": "https://github.com/django/django/blob/8b0190984116873158ee627c7a033a7bd4c3a199/django%2Futils%2Fsix.py",
            "raw_url": "https://github.com/django/django/raw/8b0190984116873158ee627c7a033a7bd4c3a199/django%2Futils%2Fsix.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fsix.py?ref=8b0190984116873158ee627c7a033a7bd4c3a199",
            "patch": "@@ -0,0 +1,353 @@\n+\"\"\"Utilities for writing code that runs on Python 2 and 3\"\"\"\n+\n+import operator\n+import sys\n+import types\n+\n+__author__ = \"Benjamin Peterson <benjamin@python.org>\"\n+__version__ = \"1.1.0\"\n+\n+\n+# True if we are running on Python 3.\n+PY3 = sys.version_info[0] == 3\n+\n+if PY3:\n+    string_types = str,\n+    integer_types = int,\n+    class_types = type,\n+    text_type = str\n+    binary_type = bytes\n+\n+    MAXSIZE = sys.maxsize\n+else:\n+    string_types = basestring,\n+    integer_types = (int, long)\n+    class_types = (type, types.ClassType)\n+    text_type = unicode\n+    binary_type = str\n+\n+    # It's possible to have sizeof(long) != sizeof(Py_ssize_t).\n+    class X(object):\n+        def __len__(self):\n+            return 1 << 31\n+    try:\n+        len(X())\n+    except OverflowError:\n+        # 32-bit\n+        MAXSIZE = int((1 << 31) - 1)\n+    else:\n+        # 64-bit\n+        MAXSIZE = int((1 << 63) - 1)\n+    del X\n+\n+\n+def _add_doc(func, doc):\n+    \"\"\"Add documentation to a function.\"\"\"\n+    func.__doc__ = doc\n+\n+\n+def _import_module(name):\n+    \"\"\"Import module, returning the module after the last dot.\"\"\"\n+    __import__(name)\n+    return sys.modules[name]\n+\n+\n+class _LazyDescr(object):\n+\n+    def __init__(self, name):\n+        self.name = name\n+\n+    def __get__(self, obj, tp):\n+        result = self._resolve()\n+        setattr(obj, self.name, result)\n+        # This is a bit ugly, but it avoids running this again.\n+        delattr(tp, self.name)\n+        return result\n+\n+\n+class MovedModule(_LazyDescr):\n+\n+    def __init__(self, name, old, new=None):\n+        super(MovedModule, self).__init__(name)\n+        if PY3:\n+            if new is None:\n+                new = name\n+            self.mod = new\n+        else:\n+            self.mod = old\n+\n+    def _resolve(self):\n+        return _import_module(self.mod)\n+\n+\n+class MovedAttribute(_LazyDescr):\n+\n+    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):\n+        super(MovedAttribute, self).__init__(name)\n+        if PY3:\n+            if new_mod is None:\n+                new_mod = name\n+            self.mod = new_mod\n+            if new_attr is None:\n+                if old_attr is None:\n+                    new_attr = name\n+                else:\n+                    new_attr = old_attr\n+            self.attr = new_attr\n+        else:\n+            self.mod = old_mod\n+            if old_attr is None:\n+                old_attr = name\n+            self.attr = old_attr\n+\n+    def _resolve(self):\n+        module = _import_module(self.mod)\n+        return getattr(module, self.attr)\n+\n+\n+\n+class _MovedItems(types.ModuleType):\n+    \"\"\"Lazy loading of moved objects\"\"\"\n+\n+\n+_moved_attributes = [\n+    MovedAttribute(\"cStringIO\", \"cStringIO\", \"io\", \"StringIO\"),\n+    MovedAttribute(\"filter\", \"itertools\", \"builtins\", \"ifilter\", \"filter\"),\n+    MovedAttribute(\"map\", \"itertools\", \"builtins\", \"imap\", \"map\"),\n+    MovedAttribute(\"reload_module\", \"__builtin__\", \"imp\", \"reload\"),\n+    MovedAttribute(\"reduce\", \"__builtin__\", \"functools\"),\n+    MovedAttribute(\"StringIO\", \"StringIO\", \"io\"),\n+    MovedAttribute(\"xrange\", \"__builtin__\", \"builtins\", \"xrange\", \"range\"),\n+    MovedAttribute(\"zip\", \"itertools\", \"builtins\", \"izip\", \"zip\"),\n+\n+    MovedModule(\"builtins\", \"__builtin__\"),\n+    MovedModule(\"configparser\", \"ConfigParser\"),\n+    MovedModule(\"copyreg\", \"copy_reg\"),\n+    MovedModule(\"http_cookiejar\", \"cookielib\", \"http.cookiejar\"),\n+    MovedModule(\"http_cookies\", \"Cookie\", \"http.cookies\"),\n+    MovedModule(\"html_entities\", \"htmlentitydefs\", \"html.entities\"),\n+    MovedModule(\"html_parser\", \"HTMLParser\", \"html.parser\"),\n+    MovedModule(\"http_client\", \"httplib\", \"http.client\"),\n+    MovedModule(\"BaseHTTPServer\", \"BaseHTTPServer\", \"http.server\"),\n+    MovedModule(\"CGIHTTPServer\", \"CGIHTTPServer\", \"http.server\"),\n+    MovedModule(\"SimpleHTTPServer\", \"SimpleHTTPServer\", \"http.server\"),\n+    MovedModule(\"cPickle\", \"cPickle\", \"pickle\"),\n+    MovedModule(\"queue\", \"Queue\"),\n+    MovedModule(\"reprlib\", \"repr\"),\n+    MovedModule(\"socketserver\", \"SocketServer\"),\n+    MovedModule(\"tkinter\", \"Tkinter\"),\n+    MovedModule(\"tkinter_dialog\", \"Dialog\", \"tkinter.dialog\"),\n+    MovedModule(\"tkinter_filedialog\", \"FileDialog\", \"tkinter.filedialog\"),\n+    MovedModule(\"tkinter_scrolledtext\", \"ScrolledText\", \"tkinter.scrolledtext\"),\n+    MovedModule(\"tkinter_simpledialog\", \"SimpleDialog\", \"tkinter.simpledialog\"),\n+    MovedModule(\"tkinter_tix\", \"Tix\", \"tkinter.tix\"),\n+    MovedModule(\"tkinter_constants\", \"Tkconstants\", \"tkinter.constants\"),\n+    MovedModule(\"tkinter_dnd\", \"Tkdnd\", \"tkinter.dnd\"),\n+    MovedModule(\"tkinter_colorchooser\", \"tkColorChooser\",\n+                \"tkinter.colorchooser\"),\n+    MovedModule(\"tkinter_commondialog\", \"tkCommonDialog\",\n+                \"tkinter.commondialog\"),\n+    MovedModule(\"tkinter_tkfiledialog\", \"tkFileDialog\", \"tkinter.filedialog\"),\n+    MovedModule(\"tkinter_font\", \"tkFont\", \"tkinter.font\"),\n+    MovedModule(\"tkinter_messagebox\", \"tkMessageBox\", \"tkinter.messagebox\"),\n+    MovedModule(\"tkinter_tksimpledialog\", \"tkSimpleDialog\",\n+                \"tkinter.simpledialog\"),\n+    MovedModule(\"urllib_robotparser\", \"robotparser\", \"urllib.robotparser\"),\n+    MovedModule(\"winreg\", \"_winreg\"),\n+]\n+for attr in _moved_attributes:\n+    setattr(_MovedItems, attr.name, attr)\n+del attr\n+\n+moves = sys.modules[\"six.moves\"] = _MovedItems(\"moves\")\n+\n+\n+def add_move(move):\n+    \"\"\"Add an item to six.moves.\"\"\"\n+    setattr(_MovedItems, move.name, move)\n+\n+\n+def remove_move(name):\n+    \"\"\"Remove item from six.moves.\"\"\"\n+    try:\n+        delattr(_MovedItems, name)\n+    except AttributeError:\n+        try:\n+            del moves.__dict__[name]\n+        except KeyError:\n+            raise AttributeError(\"no such move, %r\" % (name,))\n+\n+\n+if PY3:\n+    _meth_func = \"__func__\"\n+    _meth_self = \"__self__\"\n+\n+    _func_code = \"__code__\"\n+    _func_defaults = \"__defaults__\"\n+\n+    _iterkeys = \"keys\"\n+    _itervalues = \"values\"\n+    _iteritems = \"items\"\n+else:\n+    _meth_func = \"im_func\"\n+    _meth_self = \"im_self\"\n+\n+    _func_code = \"func_code\"\n+    _func_defaults = \"func_defaults\"\n+\n+    _iterkeys = \"iterkeys\"\n+    _itervalues = \"itervalues\"\n+    _iteritems = \"iteritems\"\n+\n+\n+if PY3:\n+    def get_unbound_function(unbound):\n+        return unbound\n+\n+\n+    advance_iterator = next\n+\n+    def callable(obj):\n+        return any(\"__call__\" in klass.__dict__ for klass in type(obj).__mro__)\n+else:\n+    def get_unbound_function(unbound):\n+        return unbound.im_func\n+\n+\n+    def advance_iterator(it):\n+        return it.next()\n+\n+    callable = callable\n+_add_doc(get_unbound_function,\n+         \"\"\"Get the function out of a possibly unbound function\"\"\")\n+\n+\n+get_method_function = operator.attrgetter(_meth_func)\n+get_method_self = operator.attrgetter(_meth_self)\n+get_function_code = operator.attrgetter(_func_code)\n+get_function_defaults = operator.attrgetter(_func_defaults)\n+\n+\n+def iterkeys(d):\n+    \"\"\"Return an iterator over the keys of a dictionary.\"\"\"\n+    return getattr(d, _iterkeys)()\n+\n+def itervalues(d):\n+    \"\"\"Return an iterator over the values of a dictionary.\"\"\"\n+    return getattr(d, _itervalues)()\n+\n+def iteritems(d):\n+    \"\"\"Return an iterator over the (key, value) pairs of a dictionary.\"\"\"\n+    return getattr(d, _iteritems)()\n+\n+\n+if PY3:\n+    def b(s):\n+        return s.encode(\"latin-1\")\n+    def u(s):\n+        return s\n+    if sys.version_info[1] <= 1:\n+        def int2byte(i):\n+            return bytes((i,))\n+    else:\n+        # This is about 2x faster than the implementation above on 3.2+\n+        int2byte = operator.methodcaller(\"to_bytes\", 1, \"big\")\n+    import io\n+    StringIO = io.StringIO\n+    BytesIO = io.BytesIO\n+else:\n+    def b(s):\n+        return s\n+    def u(s):\n+        return unicode(s, \"unicode_escape\")\n+    int2byte = chr\n+    import StringIO\n+    StringIO = BytesIO = StringIO.StringIO\n+_add_doc(b, \"\"\"Byte literal\"\"\")\n+_add_doc(u, \"\"\"Text literal\"\"\")\n+\n+\n+if PY3:\n+    import builtins\n+    exec_ = getattr(builtins, \"exec\")\n+\n+\n+    def reraise(tp, value, tb=None):\n+        if value.__traceback__ is not tb:\n+            raise value.with_traceback(tb)\n+        raise value\n+\n+\n+    print_ = getattr(builtins, \"print\")\n+    del builtins\n+\n+else:\n+    def exec_(code, globs=None, locs=None):\n+        \"\"\"Execute code in a namespace.\"\"\"\n+        if globs is None:\n+            frame = sys._getframe(1)\n+            globs = frame.f_globals\n+            if locs is None:\n+                locs = frame.f_locals\n+            del frame\n+        elif locs is None:\n+            locs = globs\n+        exec(\"\"\"exec code in globs, locs\"\"\")\n+\n+\n+    exec_(\"\"\"def reraise(tp, value, tb=None):\n+    raise tp, value, tb\n+\"\"\")\n+\n+\n+    def print_(*args, **kwargs):\n+        \"\"\"The new-style print function.\"\"\"\n+        fp = kwargs.pop(\"file\", sys.stdout)\n+        if fp is None:\n+            return\n+        def write(data):\n+            if not isinstance(data, basestring):\n+                data = str(data)\n+            fp.write(data)\n+        want_unicode = False\n+        sep = kwargs.pop(\"sep\", None)\n+        if sep is not None:\n+            if isinstance(sep, unicode):\n+                want_unicode = True\n+            elif not isinstance(sep, str):\n+                raise TypeError(\"sep must be None or a string\")\n+        end = kwargs.pop(\"end\", None)\n+        if end is not None:\n+            if isinstance(end, unicode):\n+                want_unicode = True\n+            elif not isinstance(end, str):\n+                raise TypeError(\"end must be None or a string\")\n+        if kwargs:\n+            raise TypeError(\"invalid keyword arguments to print()\")\n+        if not want_unicode:\n+            for arg in args:\n+                if isinstance(arg, unicode):\n+                    want_unicode = True\n+                    break\n+        if want_unicode:\n+            newline = unicode(\"\\n\")\n+            space = unicode(\" \")\n+        else:\n+            newline = \"\\n\"\n+            space = \" \"\n+        if sep is None:\n+            sep = space\n+        if end is None:\n+            end = newline\n+        for i, arg in enumerate(args):\n+            if i:\n+                write(sep)\n+            write(arg)\n+        write(end)\n+\n+_add_doc(reraise, \"\"\"Reraise an exception.\"\"\")\n+\n+\n+def with_metaclass(meta, base=object):\n+    \"\"\"Create a base class with a metaclass.\"\"\"\n+    return meta(\"NewBase\", (base,), {})"
        },
        {
            "sha": "e4bfc1bd9ccc64c6ab937fd75a9c179da5871a0a",
            "filename": "docs/topics/python3.txt",
            "status": "modified",
            "additions": 25,
            "deletions": 228,
            "changes": 253,
            "blob_url": "https://github.com/django/django/blob/8b0190984116873158ee627c7a033a7bd4c3a199/docs%2Ftopics%2Fpython3.txt",
            "raw_url": "https://github.com/django/django/raw/8b0190984116873158ee627c7a033a7bd4c3a199/docs%2Ftopics%2Fpython3.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fpython3.txt?ref=8b0190984116873158ee627c7a033a7bd4c3a199",
            "patch": "@@ -2,251 +2,48 @@\n Python 3 compatibility\n ======================\n \n-Django 1.5 introduces a compatibility layer that allows the code to be run both\n-in Python 2 (2.6/2.7) and Python 3 (>= 3.2) (*work in progress*).\n+Django 1.5 is the first version of Django to support Python 3.\n \n-This document is not meant as a complete Python 2 to Python 3 migration guide.\n-There are many existing resources you can read. But we describe some utilities\n-and guidelines that we recommend you should use when you want to ensure your\n-code can be run with both Python 2 and 3.\n+The same code runs both on Python 2 (≥2.6.5) and Python 3 (≥3.2). To\n+achieve this:\n \n-* http://docs.python.org/py3k/howto/pyporting.html\n-* http://python3porting.com/\n+- wherever possible, Django uses the six_ compatibility layer,\n+- all modules declare ``from __future__ import unicode_literals``.\n \n-django.utils.py3\n-================\n+.. _six: http://packages.python.org/six/\n+\n+This document is not meant as a Python 2 to Python 3 migration guide. There\n+are many existing resources, including `Python's official porting guide`_. But\n+it describes guidelines that apply to Django's code and are recommended for\n+pluggable apps that run with both Python 2 and 3.\n \n-Whenever a symbol or module has different semantics or different locations on\n-Python 2 and Python 3, you can import it from ``django.utils.py3`` where it\n-will be automatically converted depending on your current Python version.\n+.. _Python's official porting guide: http://docs.python.org/py3k/howto/pyporting.html\n \n-PY3\n----\n+.. module: django.utils.six\n \n-If you need to know anywhere in your code if you are running Python 3 or a\n-previous Python 2 version, you can check the ``PY3`` boolean variable::\n+django.utils.six\n+================\n \n-    from django.utils.py3 import PY3\n+Read the documentation of six_. It's the canonical compatibility library for\n+supporting Python 2 and 3 in a single codebase.\n \n-    if PY3:\n-        # Do stuff Python 3-wise\n-    else:\n-        # Do stuff Python 2-wise\n+``six`` is bundled with Django: you can import it as :mod:`django.utils.six`.\n \n-This should be considered as a last resort solution when it is not possible\n-to import a compatible name from django.utils.py3, as described in the sections\n-below.\n+.. _string-handling:\n \n String handling\n ===============\n \n-In Python 3, all strings are considered Unicode strings by default. Byte strings\n-have to be prefixed with the letter 'b'. To mimic the same behaviour in Python 2,\n-we recommend you import ``unicode_literals`` from the ``__future__`` library::\n+In Python 3, all strings are considered Unicode strings by default. Byte\n+strings must be prefixed with the letter ``b``. In order to enable the same\n+behavior in Python 2, every module must import ``unicode_literals`` from\n+``__future__``::\n \n     from __future__ import unicode_literals\n \n     my_string = \"This is an unicode literal\"\n     my_bytestring = b\"This is a bytestring\"\n \n-Be cautious if you have to slice bytestrings.\n-See http://docs.python.org/py3k/howto/pyporting.html#bytes-literals\n-\n-Different expected strings\n---------------------------\n-\n-Some method parameters have changed the expected string type of a parameter.\n-For example, ``strftime`` format parameter expects a bytestring on Python 2 but\n-a normal (Unicode) string on Python 3. For these cases, ``django.utils.py3``\n-provides a ``n()`` function which encodes the string parameter only with\n-Python 2.\n-\n-    >>> from __future__ import unicode_literals\n-    >>> from datetime import datetime\n-\n-    >>> print(datetime.date(2012, 5, 21).strftime(n(\"%m → %Y\")))\n-    05 → 2012\n-\n-Renamed types\n-=============\n-\n-Several types are named differently in Python 2 and Python 3. In order to keep\n-compatibility while using those types, import their corresponding aliases from\n-``django.utils.py3``.\n-\n-===========  =========  =====================\n-Python 2     Python 3   django.utils.py3\n-===========  =========  =====================\n-basestring,  str,       string_types (tuple)\n-unicode      str        text_type\n-int, long    int,       integer_types (tuple)\n-long         int        long_type\n-===========  =========  =====================\n-\n-String aliases\n---------------\n-\n-Code sample::\n-\n-    if isinstance(foo, basestring):\n-        print(\"foo is a string\")\n-\n-    # I want to convert a number to a Unicode string\n-    bar = 45\n-    bar_string = unicode(bar)\n-\n-Should be replaced by::\n-\n-    from django.utils.py3 import string_types, text_type\n-\n-    if isinstance(foo, string_types):\n-        print(\"foo is a string\")\n-\n-    # I want to convert a number to a Unicode string\n-    bar = 45\n-    bar_string = text_type(bar)\n-\n-No more long type\n------------------\n-\n-``long`` and ``int`` types have been unified in Python 3, meaning that  ``long``\n-is no longer available. ``django.utils.py3`` provides both ``long_type`` and\n-``integer_types`` aliases. For example:\n-\n-.. code-block:: python\n-\n-    # Old Python 2 code\n-    my_var = long(333463247234623)\n-    if isinstance(my_var, (int, long)):\n-        # ...\n-\n-Should be replaced by:\n-\n-.. code-block:: python\n-\n-    from django.utils.py3 import long_type, integer_types\n-\n-    my_var = long_type(333463247234623)\n-    if isinstance(my_var, integer_types):\n-        # ...\n-\n-\n-Changed module locations\n-========================\n-\n-The following modules have changed their location in Python 3. Therefore, it is\n-recommended to import them from the ``django.utils.py3`` compatibility layer:\n-\n-=============================== ======================================  ======================\n-Python 2                        Python3                                 django.utils.py3\n-=============================== ======================================  ======================\n-Cookie                          http.cookies                            cookies\n-\n-urlparse.urlparse               urllib.parse.urlparse                   urlparse\n-urlparse.urlunparse             urllib.parse.urlunparse                 urlunparse\n-urlparse.urljoin                urllib.parse.urljoin                    urljoin\n-urlparse.urlsplit               urllib.parse.urlsplit                   urlsplit\n-urlparse.urlunsplit             urllib.parse.urlunsplit                 urlunsplit\n-urlparse.urldefrag              urllib.parse.urldefrag                  urldefrag\n-urlparse.parse_qsl              urllib.parse.parse_qsl                  parse_qsl\n-urllib.quote                    urllib.parse.quote                      quote\n-urllib.unquote                  urllib.parse.unquote                    unquote\n-urllib.quote_plus               urllib.parse.quote_plus                 quote_plus\n-urllib.unquote_plus             urllib.parse.unquote_plus               unquote_plus\n-urllib.urlencode                urllib.parse.urlencode                  urlencode\n-urllib.urlopen                  urllib.request.urlopen                  urlopen\n-urllib.url2pathname             urllib.request.url2pathname             url2pathname\n-urllib.urlretrieve              urllib.request.urlretrieve              urlretrieve\n-urllib2                         urllib.request                          urllib2\n-urllib2.Request                 urllib.request.Request                  Request\n-urllib2.OpenerDirector          urllib.request.OpenerDirector           OpenerDirector\n-urllib2.UnknownHandler          urllib.request.UnknownHandler           UnknownHandler\n-urllib2.HTTPHandler             urllib.request.HTTPHandler              HTTPHandler\n-urllib2.HTTPSHandler            urllib.request.HTTPSHandler             HTTPSHandler\n-urllib2.HTTPDefaultErrorHandler urllib.request.HTTPDefaultErrorHandler  HTTPDefaultErrorHandler\n-urllib2.FTPHandler              urllib.request.FTPHandler               FTPHandler\n-urllib2.HTTPError               urllib.request.HTTPError                HTTPError\n-urllib2.HTTPErrorProcessor      urllib.request.HTTPErrorProcessor       HTTPErrorProcessor\n-\n-htmlentitydefs.name2codepoint   html.entities.name2codepoint            name2codepoint\n-HTMLParser                      html.parser                             HTMLParser\n-cPickle/pickle                  pickle                                  pickle\n-thread/dummy_thread             _thread/_dummy_thread                   thread\n-\n-os.getcwdu                      os.getcwd                               getcwdu\n-itertools.izip                  zip                                     zip\n-sys.maxint                      sys.maxsize                             maxsize\n-unichr                          chr                                     unichr\n-xrange                          range                                   xrange\n-=============================== ======================================  ======================\n-\n-\n-Output encoding now Unicode\n-===========================\n-\n-If you want to catch stdout/stderr output, the output content is UTF-8 encoded\n-in Python 2, while it is Unicode strings in Python 3. You can use the OutputIO\n-stream to capture this output::\n-\n-    from django.utils.py3 import OutputIO\n-\n-    try:\n-        old_stdout = sys.stdout\n-        out = OutputIO()\n-        sys.stdout = out\n-        # Do stuff which produces standard output\n-        result = out.getvalue()\n-    finally:\n-        sys.stdout = old_stdout\n-\n-Dict iteritems/itervalues/iterkeys\n-==================================\n-\n-The iteritems(), itervalues() and iterkeys() methods of dictionaries do not\n-exist any more in Python 3, simply because they represent the default items()\n-values() and keys() behavior in Python 3. Therefore, to keep compatibility,\n-use similar functions from ``django.utils.py3``::\n-\n-    from django.utils.py3 import iteritems, itervalues, iterkeys\n-\n-    my_dict = {'a': 21, 'b': 42}\n-    for key, value in iteritems(my_dict):\n-        # ...\n-    for value in itervalues(my_dict):\n-        # ...\n-    for key in iterkeys(my_dict):\n-        # ...\n-\n-Note that in Python 3, dict.keys(), dict.items() and dict.values() return\n-\"views\" instead of lists. Wrap them into list() if you really need their return\n-values to be in a list.\n-\n-http://docs.python.org/release/3.0.1/whatsnew/3.0.html#views-and-iterators-instead-of-lists\n-\n-Metaclass\n-=========\n-\n-The syntax for declaring metaclasses has changed in Python 3.\n-``django.utils.py3`` offers a compatible way to declare metaclasses::\n-\n-    from django.utils.py3 import with_metaclass\n-\n-    class MyClass(with_metaclass(SubClass1, SubClass2,...)):\n-        # ...\n-\n-Re-raising exceptions\n-=====================\n-\n-One of the syntaxes to raise exceptions (raise E, V, T) is gone in Python 3.\n-This is especially used in very specific cases where you want to re-raise a\n-different exception that the initial one, while keeping the original traceback.\n-So, instead of::\n-\n-    raise Exception, Exception(msg), traceback\n-\n-Use::\n-\n-    from django.utils.py3 import reraise\n-\n-    reraise(Exception, Exception(msg), traceback)\n+Be cautious if you have to `slice bytestrings`_.\n \n+.. _slice bytestrings: http://docs.python.org/py3k/howto/pyporting.html#bytes-literals"
        }
    ],
    "stats": {
        "total": 715,
        "additions": 378,
        "deletions": 337
    }
}