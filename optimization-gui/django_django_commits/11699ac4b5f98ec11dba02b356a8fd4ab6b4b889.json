{
    "author": "akaariai",
    "message": "Fixed #19190 -- Refactored Query select clause attributes\n\nThe Query.select and Query.select_fields were collapsed into one list\nbecause the attributes had to be always in sync. Now that they are in\none attribute it is impossible to edit them out of sync.\n\nSimilar collapse was done for Query.related_select_cols and\nQuery.related_select_fields.",
    "sha": "11699ac4b5f98ec11dba02b356a8fd4ab6b4b889",
    "files": [
        {
            "sha": "0dcf50d32a9e5538fea458336820fc4ca1fea7f5",
            "filename": "django/contrib/gis/db/models/sql/compiler.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/11699ac4b5f98ec11dba02b356a8fd4ab6b4b889/django%2Fcontrib%2Fgis%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/11699ac4b5f98ec11dba02b356a8fd4ab6b4b889/django%2Fcontrib%2Fgis%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fdb%2Fmodels%2Fsql%2Fcompiler.py?ref=11699ac4b5f98ec11dba02b356a8fd4ab6b4b889",
            "patch": "@@ -39,7 +39,7 @@ def get_columns(self, with_aliases=False):\n         if self.query.select:\n             only_load = self.deferred_to_columns()\n             # This loop customized for GeoQuery.\n-            for col, field in zip(self.query.select, self.query.select_fields):\n+            for col, field in self.query.select:\n                 if isinstance(col, (list, tuple)):\n                     alias, column = col\n                     table = self.query.alias_map[alias].table_name\n@@ -85,7 +85,7 @@ def get_columns(self, with_aliases=False):\n         ])\n \n         # This loop customized for GeoQuery.\n-        for (table, col), field in zip(self.query.related_select_cols, self.query.related_select_fields):\n+        for (table, col), field in self.query.related_select_cols:\n             r = self.get_field_select(field, table, col)\n             if with_aliases and col in col_aliases:\n                 c_alias = 'Col%d' % len(col_aliases)"
        },
        {
            "sha": "7461f5f31d27f857e2f1260e60ee48405bd5cc52",
            "filename": "django/db/models/sql/compiler.py",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/django/django/blob/11699ac4b5f98ec11dba02b356a8fd4ab6b4b889/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/11699ac4b5f98ec11dba02b356a8fd4ab6b4b889/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py?ref=11699ac4b5f98ec11dba02b356a8fd4ab6b4b889",
            "patch": "@@ -6,7 +6,7 @@\n from django.db.models.constants import LOOKUP_SEP\n from django.db.models.query_utils import select_related_descend\n from django.db.models.sql.constants import (SINGLE, MULTI, ORDER_DIR,\n-        GET_ITERATOR_CHUNK_SIZE)\n+        GET_ITERATOR_CHUNK_SIZE, SelectInfo)\n from django.db.models.sql.datastructures import EmptyResultSet\n from django.db.models.sql.expressions import SQLEvaluator\n from django.db.models.sql.query import get_order_dir, Query\n@@ -188,7 +188,7 @@ def get_columns(self, with_aliases=False):\n             col_aliases = set()\n         if self.query.select:\n             only_load = self.deferred_to_columns()\n-            for col in self.query.select:\n+            for col, _ in self.query.select:\n                 if isinstance(col, (list, tuple)):\n                     alias, column = col\n                     table = self.query.alias_map[alias].table_name\n@@ -233,7 +233,7 @@ def get_columns(self, with_aliases=False):\n             for alias, aggregate in self.query.aggregate_select.items()\n         ])\n \n-        for table, col in self.query.related_select_cols:\n+        for (table, col), _ in self.query.related_select_cols:\n             r = '%s.%s' % (qn(table), qn(col))\n             if with_aliases and col in col_aliases:\n                 c_alias = 'Col%d' % len(col_aliases)\n@@ -557,8 +557,9 @@ def get_grouping(self):\n             for extra_select, extra_params in six.itervalues(self.query.extra_select):\n                 extra_selects.append(extra_select)\n                 params.extend(extra_params)\n-            cols = (group_by + self.query.select +\n-                self.query.related_select_cols + extra_selects)\n+            select_cols = [s.col for s in self.query.select]\n+            related_select_cols = [s.col for s in self.query.related_select_cols]\n+            cols = (group_by + select_cols + related_select_cols + extra_selects)\n             seen = set()\n             for col in cols:\n                 if col in seen:\n@@ -589,7 +590,6 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n             opts = self.query.get_meta()\n             root_alias = self.query.get_initial_alias()\n             self.query.related_select_cols = []\n-            self.query.related_select_fields = []\n         if not used:\n             used = set()\n         if dupe_set is None:\n@@ -664,8 +664,8 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n             used.add(alias)\n             columns, aliases = self.get_default_columns(start_alias=alias,\n                     opts=f.rel.to._meta, as_pairs=True)\n-            self.query.related_select_cols.extend(columns)\n-            self.query.related_select_fields.extend(f.rel.to._meta.fields)\n+            self.query.related_select_cols.extend(\n+                SelectInfo(col, field) for col, field in zip(columns, f.rel.to._meta.fields))\n             if restricted:\n                 next = requested.get(f.name, {})\n             else:\n@@ -734,8 +734,8 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n                 used.add(alias)\n                 columns, aliases = self.get_default_columns(start_alias=alias,\n                     opts=model._meta, as_pairs=True, local_only=True)\n-                self.query.related_select_cols.extend(columns)\n-                self.query.related_select_fields.extend(model._meta.fields)\n+                self.query.related_select_cols.extend(\n+                    SelectInfo(col, field) for col, field in zip(columns, model._meta.fields))\n \n                 next = requested.get(f.related_query_name(), {})\n                 # Use True here because we are looking at the _reverse_ side of\n@@ -772,7 +772,7 @@ def results_iter(self):\n                 if resolve_columns:\n                     if fields is None:\n                         # We only set this up here because\n-                        # related_select_fields isn't populated until\n+                        # related_select_cols isn't populated until\n                         # execute_sql() has been called.\n \n                         # We also include types of fields of related models that\n@@ -782,11 +782,11 @@ def results_iter(self):\n \n                         # This code duplicates the logic for the order of fields\n                         # found in get_columns(). It would be nice to clean this up.\n-                        if self.query.select_fields:\n-                            fields = self.query.select_fields\n+                        if self.query.select:\n+                            fields = [f.field for f in self.query.select]\n                         else:\n                             fields = self.query.model._meta.fields\n-                        fields = fields + self.query.related_select_fields\n+                        fields = fields + [f.field for f in self.query.related_select_cols]\n \n                         # If the field was deferred, exclude it from being passed\n                         # into `resolve_columns` because it wasn't selected."
        },
        {
            "sha": "7e34047e1d63c803081650fe99b48f1104ac9d44",
            "filename": "django/db/models/sql/constants.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/11699ac4b5f98ec11dba02b356a8fd4ab6b4b889/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py",
            "raw_url": "https://github.com/django/django/raw/11699ac4b5f98ec11dba02b356a8fd4ab6b4b889/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py?ref=11699ac4b5f98ec11dba02b356a8fd4ab6b4b889",
            "patch": "@@ -25,6 +25,9 @@\n                       'table_name rhs_alias join_type lhs_alias '\n                       'lhs_join_col rhs_join_col nullable')\n \n+# Pairs of column clauses to select, and (possibly None) field for the clause.\n+SelectInfo = namedtuple('SelectInfo', 'col field')\n+\n # How many results to expect from a cursor.execute call\n MULTI = 'multi'\n SINGLE = 'single'"
        },
        {
            "sha": "de7e5904a397c1f8a0f41a471386afc7c56f1b32",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 40,
            "deletions": 47,
            "changes": 87,
            "blob_url": "https://github.com/django/django/blob/11699ac4b5f98ec11dba02b356a8fd4ab6b4b889/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/11699ac4b5f98ec11dba02b356a8fd4ab6b4b889/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=11699ac4b5f98ec11dba02b356a8fd4ab6b4b889",
            "patch": "@@ -20,7 +20,7 @@\n from django.db.models.fields import FieldDoesNotExist\n from django.db.models.sql import aggregates as base_aggregates_module\n from django.db.models.sql.constants import (QUERY_TERMS, ORDER_DIR, SINGLE,\n-        ORDER_PATTERN, JoinInfo)\n+        ORDER_PATTERN, JoinInfo, SelectInfo)\n from django.db.models.sql.datastructures import EmptyResultSet, Empty, MultiJoin\n from django.db.models.sql.expressions import SQLEvaluator\n from django.db.models.sql.where import (WhereNode, Constraint, EverythingNode,\n@@ -115,17 +115,20 @@ def __init__(self, model, where=WhereNode):\n         self.default_ordering = True\n         self.standard_ordering = True\n         self.ordering_aliases = []\n-        self.related_select_fields = []\n         self.dupe_avoidance = {}\n         self.used_aliases = set()\n         self.filter_is_sticky = False\n         self.included_inherited_models = {}\n \n-        # SQL-related attributes\n+        # SQL-related attributes  \n+        # Select and related select clauses as SelectInfo instances.\n+        # The select is used for cases where we want to set up the select\n+        # clause to contain other than default fields (values(), annotate(),\n+        # subqueries...)\n         self.select = []\n-        # For each to-be-selected field in self.select there must be a\n-        # corresponding entry in self.select - git seems to need this.\n-        self.select_fields = []\n+        # The related_select_cols is used for columns needed for\n+        # select_related - this is populated in compile stage.\n+        self.related_select_cols = []\n         self.tables = []    # Aliases in the order they are created.\n         self.where = where()\n         self.where_class = where\n@@ -138,7 +141,6 @@ def __init__(self, model, where=WhereNode):\n         self.select_for_update = False\n         self.select_for_update_nowait = False\n         self.select_related = False\n-        self.related_select_cols = []\n \n         # SQL aggregate-related attributes\n         self.aggregates = SortedDict() # Maps alias -> SQL aggregate function\n@@ -191,15 +193,14 @@ def __getstate__(self):\n         Pickling support.\n         \"\"\"\n         obj_dict = self.__dict__.copy()\n-        obj_dict['related_select_fields'] = []\n         obj_dict['related_select_cols'] = []\n \n         # Fields can't be pickled, so if a field list has been\n         # specified, we pickle the list of field names instead.\n         # None is also a possible value; that can pass as-is\n-        obj_dict['select_fields'] = [\n-            f is not None and f.name or None\n-            for f in obj_dict['select_fields']\n+        obj_dict['select'] = [\n+            (s.col, s.field is not None and s.field.name or None)\n+            for s in obj_dict['select']\n         ]\n         return obj_dict\n \n@@ -209,9 +210,9 @@ def __setstate__(self, obj_dict):\n         \"\"\"\n         # Rebuild list of field instances\n         opts = obj_dict['model']._meta\n-        obj_dict['select_fields'] = [\n-            name is not None and opts.get_field(name) or None\n-            for name in obj_dict['select_fields']\n+        obj_dict['select'] = [\n+            SelectInfo(tpl[0], tpl[1] is not None and opts.get_field(tpl[1]) or None)\n+            for tpl in obj_dict['select']\n         ]\n \n         self.__dict__.update(obj_dict)\n@@ -256,10 +257,9 @@ def clone(self, klass=None, memo=None, **kwargs):\n         obj.standard_ordering = self.standard_ordering\n         obj.included_inherited_models = self.included_inherited_models.copy()\n         obj.ordering_aliases = []\n-        obj.select_fields = self.select_fields[:]\n-        obj.related_select_fields = self.related_select_fields[:]\n         obj.dupe_avoidance = self.dupe_avoidance.copy()\n         obj.select = self.select[:]\n+        obj.related_select_cols = []\n         obj.tables = self.tables[:]\n         obj.where = copy.deepcopy(self.where, memo=memo)\n         obj.where_class = self.where_class\n@@ -275,7 +275,6 @@ def clone(self, klass=None, memo=None, **kwargs):\n         obj.select_for_update = self.select_for_update\n         obj.select_for_update_nowait = self.select_for_update_nowait\n         obj.select_related = self.select_related\n-        obj.related_select_cols = []\n         obj.aggregates = copy.deepcopy(self.aggregates, memo=memo)\n         if self.aggregate_select_mask is None:\n             obj.aggregate_select_mask = None\n@@ -384,7 +383,6 @@ def get_aggregation(self, using):\n         query.select_for_update = False\n         query.select_related = False\n         query.related_select_cols = []\n-        query.related_select_fields = []\n \n         result = query.get_compiler(using).execute_sql(SINGLE)\n         if result is None:\n@@ -527,14 +525,14 @@ def combine(self, rhs, connector):\n \n         # Selection columns and extra extensions are those provided by 'rhs'.\n         self.select = []\n-        for col in rhs.select:\n+        for col, field in rhs.select:\n             if isinstance(col, (list, tuple)):\n-                self.select.append((change_map.get(col[0], col[0]), col[1]))\n+                new_col = change_map.get(col[0], col[0]), col[1]\n+                self.select.append(SelectInfo(new_col, field))\n             else:\n                 item = copy.deepcopy(col)\n                 item.relabel_aliases(change_map)\n-                self.select.append(item)\n-        self.select_fields = rhs.select_fields[:]\n+                self.select.append(SelectInfo(item, field))\n \n         if connector == OR:\n             # It would be nice to be able to handle this, but the queries don't\n@@ -750,24 +748,23 @@ def change_aliases(self, change_map):\n         \"\"\"\n         assert set(change_map.keys()).intersection(set(change_map.values())) == set()\n \n+        def relabel_column(col):\n+            if isinstance(col, (list, tuple)):\n+                old_alias = col[0]\n+                return (change_map.get(old_alias, old_alias), col[1])\n+            else:\n+                col.relabel_aliases(change_map)\n+                return col\n         # 1. Update references in \"select\" (normal columns plus aliases),\n         # \"group by\", \"where\" and \"having\".\n         self.where.relabel_aliases(change_map)\n         self.having.relabel_aliases(change_map)\n-        for columns in [self.select, self.group_by or []]:\n-            for pos, col in enumerate(columns):\n-                if isinstance(col, (list, tuple)):\n-                    old_alias = col[0]\n-                    columns[pos] = (change_map.get(old_alias, old_alias), col[1])\n-                else:\n-                    col.relabel_aliases(change_map)\n-        for mapping in [self.aggregates]:\n-            for key, col in mapping.items():\n-                if isinstance(col, (list, tuple)):\n-                    old_alias = col[0]\n-                    mapping[key] = (change_map.get(old_alias, old_alias), col[1])\n-                else:\n-                    col.relabel_aliases(change_map)\n+        if self.group_by:\n+            self.group_by = [relabel_column(col) for col in self.group_by]\n+        self.select = [SelectInfo(relabel_column(s.col), s.field)\n+                       for s in self.select]\n+        self.aggregates = SortedDict(\n+            (key, relabel_column(col)) for key, col in self.aggregates.items())\n \n         # 2. Rename the alias in the internal table/alias datastructures.\n         for k, aliases in self.join_map.items():\n@@ -1570,7 +1567,7 @@ def split_exclude(self, filter_expr, prefix, can_reuse):\n         # since we are adding a IN <subquery> clause. This prevents the\n         # database from tripping over IN (...,NULL,...) selects and returning\n         # nothing\n-        alias, col = query.select[0]\n+        alias, col = query.select[0].col\n         query.where.add((Constraint(alias, col, None), 'isnull', False), AND)\n \n         self.add_filter(('%s__in' % prefix, query), negate=True, trim=True,\n@@ -1629,7 +1626,6 @@ def clear_select_clause(self):\n         Removes all fields from SELECT clause.\n         \"\"\"\n         self.select = []\n-        self.select_fields = []\n         self.default_cols = False\n         self.select_related = False\n         self.set_extra_mask(())\n@@ -1642,7 +1638,6 @@ def clear_select_fields(self):\n         columns.\n         \"\"\"\n         self.select = []\n-        self.select_fields = []\n \n     def add_distinct_fields(self, *field_names):\n         \"\"\"\n@@ -1674,8 +1669,7 @@ def add_fields(self, field_names, allow_m2m=True):\n                         col = join.lhs_join_col\n                         joins = joins[:-1]\n                 self.promote_joins(joins[1:])\n-                self.select.append((final_alias, col))\n-                self.select_fields.append(field)\n+                self.select.append(SelectInfo((final_alias, col), field))\n         except MultiJoin:\n             raise FieldError(\"Invalid field name: '%s'\" % name)\n         except FieldError:\n@@ -1731,8 +1725,8 @@ def set_group_by(self):\n         \"\"\"\n         self.group_by = []\n \n-        for sel in self.select:\n-            self.group_by.append(sel)\n+        for col, _ in self.select:\n+            self.group_by.append(col)\n \n     def add_count_column(self):\n         \"\"\"\n@@ -1745,7 +1739,7 @@ def add_count_column(self):\n             else:\n                 assert len(self.select) == 1, \\\n                         \"Cannot add count col with multiple cols in 'select': %r\" % self.select\n-                count = self.aggregates_module.Count(self.select[0])\n+                count = self.aggregates_module.Count(self.select[0].col)\n         else:\n             opts = self.model._meta\n             if not self.select:\n@@ -1757,7 +1751,7 @@ def add_count_column(self):\n                 assert len(self.select) == 1, \\\n                         \"Cannot add count col with multiple cols in 'select'.\"\n \n-                count = self.aggregates_module.Count(self.select[0], distinct=True)\n+                count = self.aggregates_module.Count(self.select[0].col, distinct=True)\n             # Distinct handling is done in Count(), so don't do it at this\n             # level.\n             self.distinct = False\n@@ -1781,7 +1775,6 @@ def add_select_related(self, fields):\n                 d = d.setdefault(part, {})\n         self.select_related = field_dict\n         self.related_select_cols = []\n-        self.related_select_fields = []\n \n     def add_extra(self, select, select_params, where, params, tables, order_by):\n         \"\"\"\n@@ -1975,7 +1968,7 @@ def set_start(self, start):\n             self.unref_alias(select_alias)\n             select_alias = join_info.rhs_alias\n             select_col = join_info.rhs_join_col\n-        self.select = [(select_alias, select_col)]\n+        self.select = [SelectInfo((select_alias, select_col), None)]\n         self.remove_inherited_models()\n \n     def is_nullable(self, field):"
        },
        {
            "sha": "39d1ee01163587104d80cb3bfd451546919576a6",
            "filename": "django/db/models/sql/subqueries.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/11699ac4b5f98ec11dba02b356a8fd4ab6b4b889/django%2Fdb%2Fmodels%2Fsql%2Fsubqueries.py",
            "raw_url": "https://github.com/django/django/raw/11699ac4b5f98ec11dba02b356a8fd4ab6b4b889/django%2Fdb%2Fmodels%2Fsql%2Fsubqueries.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fsubqueries.py?ref=11699ac4b5f98ec11dba02b356a8fd4ab6b4b889",
            "patch": "@@ -76,7 +76,7 @@ def delete_qs(self, query, using):\n                 return\n             else:\n                 innerq.clear_select_clause()\n-                innerq.select, innerq.select_fields = [(self.get_initial_alias(), pk.column)], [None]\n+                innerq.select = [SelectInfo((self.get_initial_alias(), pk.column), None)]\n                 values = innerq\n             where = self.where_class()\n             where.add((Constraint(None, pk.column, pk), 'in', values), AND)\n@@ -244,7 +244,7 @@ def add_date_select(self, field_name, lookup_type, order='ASC'):\n         alias = result[3][-1]\n         select = Date((alias, field.column), lookup_type)\n         self.clear_select_clause()\n-        self.select, self.select_fields = [select], [None]\n+        self.select = [SelectInfo(select, None)]\n         self.distinct = True\n         self.order_by = order == 'ASC' and [1] or [-1]\n "
        }
    ],
    "stats": {
        "total": 126,
        "additions": 61,
        "deletions": 65
    }
}