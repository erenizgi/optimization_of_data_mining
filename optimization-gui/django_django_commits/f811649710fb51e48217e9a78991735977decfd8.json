{
    "author": "akaariai",
    "message": "Fixed #18816 -- Removed \"trim\" argument from add_filter()\n\nThe trim argument was used by split_exclude() only to trim the last\njoin from the given lookup. It is cleaner to just trim the last part\nfrom the lookup in split_exclude() directly so that there is no need\nto burden add_filter() with the logic needed for only split_exclude().",
    "sha": "f811649710fb51e48217e9a78991735977decfd8",
    "files": [
        {
            "sha": "0e7bd92aa2eba71d9d4fcdaafcec34d6b1f92dbb",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 32,
            "deletions": 24,
            "changes": 56,
            "blob_url": "https://github.com/django/django/blob/f811649710fb51e48217e9a78991735977decfd8/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/f811649710fb51e48217e9a78991735977decfd8/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=f811649710fb51e48217e9a78991735977decfd8",
            "patch": "@@ -1029,7 +1029,7 @@ def add_aggregate(self, aggregate, model, alias, is_summary):\n         # Add the aggregate to the query\n         aggregate.add_to_query(self, alias, col=col, source=source, is_summary=is_summary)\n \n-    def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n+    def add_filter(self, filter_expr, connector=AND, negate=False,\n             can_reuse=None, process_extras=True, force_having=False):\n         \"\"\"\n         Add a single filter to the query. The 'filter_expr' is a pair:\n@@ -1042,9 +1042,6 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n         should only happen once. So the caller is responsible for this (the\n         caller will normally be add_q(), so that as an example).\n \n-        If 'trim' is True, we automatically trim the final join group (used\n-        internally when constructing nested queries).\n-\n         If 'can_reuse' is a set, we are processing a component of a\n         multi-component filter (e.g. filter(Q1, Q2)). In this case, 'can_reuse'\n         will be a set of table aliases that can be reused in this filter, even\n@@ -1115,7 +1112,7 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n \n         opts = self.get_meta()\n         alias = self.get_initial_alias()\n-        allow_many = trim or not negate\n+        allow_many = not negate\n \n         try:\n             field, target, opts, join_list, last, extra_filters = self.setup_joins(\n@@ -1141,7 +1138,7 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n         # Process the join list to see if we can remove any inner joins from\n         # the far end (fewer tables in a query is better).\n         nonnull_comparison = (lookup_type == 'isnull' and value is False)\n-        col, alias, join_list = self.trim_joins(target, join_list, last, trim,\n+        col, alias, join_list = self.trim_joins(target, join_list, last,\n                 nonnull_comparison)\n \n         if connector == OR:\n@@ -1456,7 +1453,7 @@ def setup_joins(self, names, opts, alias, can_reuse, allow_many=True,\n \n         return field, target, opts, joins, last, extra_filters\n \n-    def trim_joins(self, target, join_list, last, trim, nonnull_check=False):\n+    def trim_joins(self, target, join_list, last, nonnull_check=False):\n         \"\"\"\n         Sometimes joins at the end of a multi-table sequence can be trimmed. If\n         the final join is against the same column as we are comparing against,\n@@ -1473,10 +1470,6 @@ def trim_joins(self, target, join_list, last, trim, nonnull_check=False):\n         same way, so 'last' has an entry for the first of the two tables and\n         then the table immediately after the second table, in that case.\n \n-        The 'trim' parameter forces the final piece of the join list to be\n-        trimmed before anything. See the documentation of add_filter() for\n-        details about this.\n-\n         The 'nonnull_check' parameter is True when we are using inner joins\n         between tables explicitly to exclude NULL entries. In that case, the\n         tables shouldn't be trimmed, because the very action of joining to them\n@@ -1489,16 +1482,7 @@ def trim_joins(self, target, join_list, last, trim, nonnull_check=False):\n         penultimate = last.pop()\n         if penultimate == final:\n             penultimate = last.pop()\n-        if trim and final > 1:\n-            extra = join_list[penultimate:]\n-            join_list = join_list[:penultimate]\n-            final = penultimate\n-            penultimate = last.pop()\n-            col = self.alias_map[extra[0]].lhs_join_col\n-            for alias in extra:\n-                self.unref_alias(alias)\n-        else:\n-            col = target.column\n+        col = target.column\n         alias = join_list[-1]\n         while final > 1:\n             join = self.alias_map[alias]\n@@ -1520,6 +1504,19 @@ def split_exclude(self, filter_expr, prefix, can_reuse):\n         to use a subquery. This method constructs the nested query, given the\n         original exclude filter (filter_expr) and the portion up to the first\n         N-to-many relation field.\n+\n+        As an example we could have original filter ~Q(child__name='foo').\n+        We would get here with filter_expr = child_name, prefix = child and\n+        can_reuse is a set of joins we can reuse for filtering in the original\n+        query.\n+\n+        We will turn this into\n+            WHERE pk NOT IN (SELECT parent_id FROM thetable\n+                             WHERE name = 'foo' AND parent_id IS NOT NULL)\n+\n+        It might be worth it to consider using WHERE NOT EXISTS as that has\n+        saner null handling, and is easier for the backend's optimizer to\n+        handle.\n         \"\"\"\n         query = Query(self.model)\n         query.add_filter(filter_expr)\n@@ -1532,8 +1529,19 @@ def split_exclude(self, filter_expr, prefix, can_reuse):\n         # nothing\n         alias, col = query.select[0].col\n         query.where.add((Constraint(alias, col, None), 'isnull', False), AND)\n+        # We need to trim the last part from the prefix.\n+        trimmed_prefix = '__'.join(prefix.split(LOOKUP_SEP)[0:-1])\n+        if not trimmed_prefix:\n+            rel, _, direct, m2m = self.model._meta.get_field_by_name(prefix)\n+            if not m2m:\n+                trimmed_prefix = rel.field.rel.field_name\n+            else:\n+                if direct:\n+                    trimmed_prefix = rel.m2m_target_field_name()\n+                else:\n+                    trimmed_prefix = rel.field.m2m_reverse_target_field_name()\n \n-        self.add_filter(('%s__in' % prefix, query), negate=True, trim=True,\n+        self.add_filter(('%s__in' % trimmed_prefix, query), negate=True,\n                 can_reuse=can_reuse)\n \n         # If there's more than one join in the inner query (before any initial\n@@ -1546,8 +1554,8 @@ def split_exclude(self, filter_expr, prefix, can_reuse):\n         active_positions = len([count for count\n                                 in query.alias_refcount.items() if count])\n         if active_positions > 1:\n-            self.add_filter(('%s__isnull' % prefix, False), negate=True,\n-                    trim=True, can_reuse=can_reuse)\n+            self.add_filter(('%s__isnull' % trimmed_prefix, False), negate=True,\n+                    can_reuse=can_reuse)\n \n     def set_limits(self, low=None, high=None):\n         \"\"\""
        }
    ],
    "stats": {
        "total": 56,
        "additions": 32,
        "deletions": 24
    }
}