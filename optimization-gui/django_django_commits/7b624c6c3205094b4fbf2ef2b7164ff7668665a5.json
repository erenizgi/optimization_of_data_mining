{
    "author": "carljm",
    "message": "Fixed #17794 - Added a bunch of cross-reference links to the DB queries topic documentation. Thanks guettli for the initial patch.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17624 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "7b624c6c3205094b4fbf2ef2b7164ff7668665a5",
    "files": [
        {
            "sha": "4dc458d4affd83210797d38a496f0f4359156806",
            "filename": "docs/topics/db/queries.txt",
            "status": "modified",
            "additions": 294,
            "deletions": 221,
            "changes": 515,
            "blob_url": "https://github.com/django/django/blob/7b624c6c3205094b4fbf2ef2b7164ff7668665a5/docs%2Ftopics%2Fdb%2Fqueries.txt",
            "raw_url": "https://github.com/django/django/raw/7b624c6c3205094b4fbf2ef2b7164ff7668665a5/docs%2Ftopics%2Fdb%2Fqueries.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Fqueries.txt?ref=7b624c6c3205094b4fbf2ef2b7164ff7668665a5",
            "patch": "@@ -53,7 +53,7 @@ system: A model class represents a database table, and an instance of that\n class represents a particular record in the database table.\n \n To create an object, instantiate it using keyword arguments to the model class,\n-then call ``save()`` to save it to the database.\n+then call :meth:`~django.db.models.Model.save` to save it to the database.\n \n You import the model class from wherever it lives on the Python path, as you\n may expect. (We point this out here because previous Django versions required\n@@ -66,22 +66,24 @@ Assuming models live in a file ``mysite/blog/models.py``, here's an example::\n     >>> b.save()\n \n This performs an ``INSERT`` SQL statement behind the scenes. Django doesn't hit\n-the database until you explicitly call ``save()``.\n+the database until you explicitly call :meth:`~django.db.models.Model.save`.\n \n-The ``save()`` method has no return value.\n+The :meth:`~django.db.models.Model.save` method has no return value.\n \n .. seealso::\n \n-    ``save()`` takes a number of advanced options not described here.\n-    See the documentation for ``save()`` for complete details.\n+    :meth:`~django.db.models.Model.save` takes a number of advanced options not\n+    described here.  See the documentation for\n+    :meth:`~django.db.models.Model.save` for complete details.\n \n-    To create an object and save it all in one step see the ``create()``\n-    method.\n+    To create an object and save it all in one step see the\n+    :meth:`~django.db.models.query.QuerySet.create()` method.\n \n Saving changes to objects\n =========================\n \n-To save changes to an object that's already in the database, use ``save()``.\n+To save changes to an object that's already in the database, use\n+:meth:`~django.db.models.Model.save`.\n \n Given a ``Blog`` instance ``b5`` that has already been saved to the database,\n this example changes its name and updates its record in the database::\n@@ -90,31 +92,35 @@ this example changes its name and updates its record in the database::\n     >> b5.save()\n \n This performs an ``UPDATE`` SQL statement behind the scenes. Django doesn't hit\n-the database until you explicitly call ``save()``.\n+the database until you explicitly call :meth:`~django.db.models.Model.save`.\n \n Saving ``ForeignKey`` and ``ManyToManyField`` fields\n ----------------------------------------------------\n \n-Updating a ``ForeignKey`` field works exactly the same way as saving a normal\n-field; simply assign an object of the right type to the field in question.\n-This example updates the ``blog`` attribute of an ``Entry`` instance ``entry``::\n+Updating a :class:`~django.db.models.ForeignKey` field works exactly the same\n+way as saving a normal field; simply assign an object of the right type to the\n+field in question.  This example updates the ``blog`` attribute of an ``Entry``\n+instance ``entry``::\n \n     >>> from blog.models import Entry\n     >>> entry = Entry.objects.get(pk=1)\n     >>> cheese_blog = Blog.objects.get(name=\"Cheddar Talk\")\n     >>> entry.blog = cheese_blog\n     >>> entry.save()\n \n-Updating a ``ManyToManyField`` works a little differently; use the ``add()``\n-method on the field to add a record to the relation. This example adds the\n-``Author`` instance ``joe`` to the ``entry`` object::\n+Updating a :class:`~django.db.models.ManyToManyField` works a little\n+differently; use the\n+:meth:`~django.db.models.fields.related.RelatedManager.add` method on the field\n+to add a record to the relation. This example adds the ``Author`` instance\n+``joe`` to the ``entry`` object::\n \n     >>> from blog.models import Author\n     >>> joe = Author.objects.create(name=\"Joe\")\n     >>> entry.authors.add(joe)\n \n-To add multiple records to a ``ManyToManyField`` in one go, include multiple\n-arguments in the call to ``add()``, like this::\n+To add multiple records to a :class:`~django.db.models.ManyToManyField` in one\n+go, include multiple arguments in the call to\n+:meth:`~django.db.models.fields.related.RelatedManager.add`, like this::\n \n     >>> john = Author.objects.create(name=\"John\")\n     >>> paul = Author.objects.create(name=\"Paul\")\n@@ -127,17 +133,20 @@ Django will complain if you try to assign or add an object of the wrong type.\n Retrieving objects\n ==================\n \n-To retrieve objects from your database, you construct a ``QuerySet`` via a\n-``Manager`` on your model class.\n+To retrieve objects from your database, you construct a\n+:class:`~django.db.models.query.QuerySet` via a\n+:class:`~django.db.models.Manager` on your model class.\n \n-A ``QuerySet`` represents a collection of objects from your database. It can\n-have zero, one or many *filters* -- criteria that narrow down the collection\n-based on given parameters. In SQL terms, a ``QuerySet`` equates to a ``SELECT``\n-statement, and a filter is a limiting clause such as ``WHERE`` or ``LIMIT``.\n+A :class:`~django.db.models.query.QuerySet` represents a collection of objects\n+from your database. It can have zero, one or many *filters* -- criteria that\n+narrow down the collection based on given parameters. In SQL terms, a\n+:class:`~django.db.models.query.QuerySet` equates to a ``SELECT`` statement,\n+and a filter is a limiting clause such as ``WHERE`` or ``LIMIT``.\n \n-You get a ``QuerySet`` by using your model's ``Manager``. Each model has at\n-least one ``Manager``, and it's called ``objects`` by default. Access it\n-directly via the model class, like so::\n+You get a :class:`~django.db.models.query.QuerySet` by using your model's\n+:class:`~django.db.models.Manager`. Each model has at least one\n+:class:`~django.db.models.Manager`, and it's called ``objects`` by\n+default. Access it directly via the model class, like so::\n \n     >>> Blog.objects\n     <django.db.models.manager.Manager object at ...>\n@@ -153,64 +162,73 @@ directly via the model class, like so::\n     instances, to enforce a separation between \"table-level\" operations and\n     \"record-level\" operations.\n \n-The ``Manager`` is the main source of ``QuerySets`` for a model. It acts as a\n-\"root\" ``QuerySet`` that describes all objects in the model's database table.\n-For example, ``Blog.objects`` is the initial ``QuerySet`` that contains all\n-``Blog`` objects in the database.\n+The :class:`~django.db.models.Manager` is the main source of ``QuerySets`` for\n+a model. It acts as a \"root\" :class:`~django.db.models.query.QuerySet` that\n+describes all objects in the model's database table.  For example,\n+``Blog.objects`` is the initial :class:`~django.db.models.query.QuerySet` that\n+contains all ``Blog`` objects in the database.\n \n Retrieving all objects\n ----------------------\n \n-The simplest way to retrieve objects from a table is to get all of them.\n-To do this, use the ``all()`` method on a ``Manager``::\n+The simplest way to retrieve objects from a table is to get all of them.  To do\n+this, use the :meth:`~django.db.models.query.QuerySet.all` method on a\n+:class:`~django.db.models.Manager`::\n \n     >>> all_entries = Entry.objects.all()\n \n-The ``all()`` method returns a ``QuerySet`` of all the objects in the database.\n+The :meth:`~django.db.models.query.QuerySet.all` method returns a\n+:class:`~django.db.models.query.QuerySet` of all the objects in the database.\n \n-(If ``Entry.objects`` is a ``QuerySet``, why can't we just do ``Entry.objects``?\n-That's because ``Entry.objects``, the root ``QuerySet``, is a special case\n-that cannot be evaluated. The ``all()`` method returns a ``QuerySet`` that\n-*can* be evaluated.)\n+(If ``Entry.objects`` is a :class:`~django.db.models.query.QuerySet`, why can't\n+we just do ``Entry.objects``?  That's because ``Entry.objects``, the root\n+:class:`~django.db.models.query.QuerySet`, is a special case that cannot be\n+evaluated. The :meth:`~django.db.models.query.QuerySet.all` method returns a\n+:class:`~django.db.models.query.QuerySet` that *can* be evaluated.)\n \n \n Retrieving specific objects with filters\n ----------------------------------------\n \n-The root ``QuerySet`` provided by the ``Manager`` describes all objects in the\n-database table. Usually, though, you'll need to select only a subset of the\n-complete set of objects.\n+The root :class:`~django.db.models.query.QuerySet` provided by the\n+:class:`~django.db.models.Manager` describes all objects in the database\n+table. Usually, though, you'll need to select only a subset of the complete set\n+of objects.\n \n-To create such a subset, you refine the initial ``QuerySet``, adding filter\n-conditions. The two most common ways to refine a ``QuerySet`` are:\n+To create such a subset, you refine the initial\n+:class:`~django.db.models.query.QuerySet`, adding filter conditions. The two\n+most common ways to refine a :class:`~django.db.models.query.QuerySet` are:\n \n ``filter(**kwargs)``\n-    Returns a new ``QuerySet`` containing objects that match the given\n-    lookup parameters.\n+    Returns a new :class:`~django.db.models.query.QuerySet` containing objects\n+    that match the given lookup parameters.\n \n ``exclude(**kwargs)``\n-    Returns a new ``QuerySet`` containing objects that do *not* match the\n-    given lookup parameters.\n+    Returns a new :class:`~django.db.models.query.QuerySet` containing objects\n+    that do *not* match the given lookup parameters.\n \n The lookup parameters (``**kwargs`` in the above function definitions) should\n be in the format described in `Field lookups`_ below.\n \n-For example, to get a ``QuerySet`` of blog entries from the year 2006, use\n-``filter()`` like so::\n+For example, to get a :class:`~django.db.models.query.QuerySet` of blog entries\n+from the year 2006, use :meth:`~django.db.models.query.QuerySet.filter` like\n+so::\n \n     Entry.objects.filter(pub_date__year=2006)\n \n-We don't have to add an ``all()`` -- ``Entry.objects.all().filter(...)``. That\n-would still work, but you only need ``all()`` when you want all objects from the\n-root ``QuerySet``.\n+We don't have to add an :meth:`~django.db.models.query.QuerySet.all` --\n+``Entry.objects.all().filter(...)``. That would still work, but you only need\n+:meth:`~django.db.models.query.QuerySet.all` when you want all objects from the\n+root :class:`~django.db.models.query.QuerySet`.\n \n .. _chaining-filters:\n \n Chaining filters\n ~~~~~~~~~~~~~~~~\n \n-The result of refining a ``QuerySet`` is itself a ``QuerySet``, so it's\n-possible to chain refinements together. For example::\n+The result of refining a :class:`~django.db.models.query.QuerySet` is itself a\n+:class:`~django.db.models.query.QuerySet`, so it's possible to chain\n+refinements together. For example::\n \n     >>> Entry.objects.filter(\n     ...     headline__startswith='What'\n@@ -220,101 +238,118 @@ possible to chain refinements together. For example::\n     ...     pub_date__gte=datetime(2005, 1, 1)\n     ... )\n \n-This takes the initial ``QuerySet`` of all entries in the database, adds a\n-filter, then an exclusion, then another filter. The final result is a\n-``QuerySet`` containing all entries with a headline that starts with \"What\",\n-that were published between January 1, 2005, and the current day.\n+This takes the initial :class:`~django.db.models.query.QuerySet` of all entries\n+in the database, adds a filter, then an exclusion, then another filter. The\n+final result is a :class:`~django.db.models.query.QuerySet` containing all\n+entries with a headline that starts with \"What\", that were published between\n+January 1, 2005, and the current day.\n \n .. _filtered-querysets-are-unique:\n \n Filtered QuerySets are unique\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-Each time you refine a ``QuerySet``, you get a brand-new ``QuerySet`` that is\n-in no way bound to the previous ``QuerySet``. Each refinement creates a\n-separate and distinct ``QuerySet`` that can be stored, used and reused.\n+Each time you refine a :class:`~django.db.models.query.QuerySet`, you get a\n+brand-new :class:`~django.db.models.query.QuerySet` that is in no way bound to\n+the previous :class:`~django.db.models.query.QuerySet`. Each refinement creates\n+a separate and distinct :class:`~django.db.models.query.QuerySet` that can be\n+stored, used and reused.\n \n Example::\n \n     >> q1 = Entry.objects.filter(headline__startswith=\"What\")\n     >> q2 = q1.exclude(pub_date__gte=datetime.now())\n     >> q3 = q1.filter(pub_date__gte=datetime.now())\n \n-These three ``QuerySets`` are separate. The first is a base ``QuerySet``\n-containing all entries that contain a headline starting with \"What\". The second\n-is a subset of the first, with an additional criteria that excludes records\n-whose ``pub_date`` is greater than now. The third is a subset of the first,\n-with an additional criteria that selects only the records whose ``pub_date`` is\n-greater than now. The initial ``QuerySet`` (``q1``) is unaffected by the\n+These three ``QuerySets`` are separate. The first is a base\n+:class:`~django.db.models.query.QuerySet` containing all entries that contain a\n+headline starting with \"What\". The second is a subset of the first, with an\n+additional criteria that excludes records whose ``pub_date`` is greater than\n+now. The third is a subset of the first, with an additional criteria that\n+selects only the records whose ``pub_date`` is greater than now. The initial\n+:class:`~django.db.models.query.QuerySet` (``q1``) is unaffected by the\n refinement process.\n \n .. _querysets-are-lazy:\n \n QuerySets are lazy\n ~~~~~~~~~~~~~~~~~~\n \n-``QuerySets`` are lazy -- the act of creating a ``QuerySet`` doesn't involve any\n-database activity. You can stack filters together all day long, and Django won't\n-actually run the query until the ``QuerySet`` is *evaluated*. Take a look at\n-this example::\n+``QuerySets`` are lazy -- the act of creating a\n+:class:`~django.db.models.query.QuerySet` doesn't involve any database\n+activity. You can stack filters together all day long, and Django won't\n+actually run the query until the :class:`~django.db.models.query.QuerySet` is\n+*evaluated*. Take a look at this example::\n \n     >>> q = Entry.objects.filter(headline__startswith=\"What\")\n     >>> q = q.filter(pub_date__lte=datetime.now())\n     >>> q = q.exclude(body_text__icontains=\"food\")\n     >>> print q\n \n Though this looks like three database hits, in fact it hits the database only\n-once, at the last line (``print q``). In general, the results of a ``QuerySet``\n-aren't fetched from the database until you \"ask\" for them. When you do, the\n-``QuerySet`` is *evaluated* by accessing the database. For more details on\n-exactly when evaluation takes place, see :ref:`when-querysets-are-evaluated`.\n+once, at the last line (``print q``). In general, the results of a\n+:class:`~django.db.models.query.QuerySet` aren't fetched from the database\n+until you \"ask\" for them. When you do, the\n+:class:`~django.db.models.query.QuerySet` is *evaluated* by accessing the\n+database. For more details on exactly when evaluation takes place, see\n+:ref:`when-querysets-are-evaluated`.\n \n \n .. _retrieving-single-object-with-get:\n \n Retrieving a single object with get\n -----------------------------------\n \n-``.filter()`` will always give you a ``QuerySet``, even if only a single\n-object matches the query - in this case, it will be a ``QuerySet`` containing\n-a single element.\n+:meth:`~django.db.models.query.QuerySet.filter` will always give you a\n+:class:`~django.db.models.query.QuerySet`, even if only a single object matches\n+the query - in this case, it will be a\n+:class:`~django.db.models.query.QuerySet` containing a single element.\n \n-If you know there is only one object that matches your query, you can use\n-the ``get()`` method on a `Manager` which returns the object directly::\n+If you know there is only one object that matches your query, you can use the\n+:meth:`~django.db.models.query.QuerySet.get` method on a `Manager` which\n+returns the object directly::\n \n     >>> one_entry = Entry.objects.get(pk=1)\n \n-You can use any query expression with ``get()``, just like with ``filter()`` -\n-again, see `Field lookups`_ below.\n+You can use any query expression with\n+:meth:`~django.db.models.query.QuerySet.get`, just like with\n+:meth:`~django.db.models.query.QuerySet.filter` - again, see `Field lookups`_\n+below.\n \n-Note that there is a difference between using ``.get()``, and using\n-``.filter()`` with a slice of ``[0]``. If there are no results that match the\n-query, ``.get()`` will raise a ``DoesNotExist`` exception. This exception is an\n-attribute of the model class that the query is being performed on - so in the\n-code above, if there is no ``Entry`` object with a primary key of 1, Django will\n-raise ``Entry.DoesNotExist``.\n+Note that there is a difference between using\n+:meth:`~django.db.models.query.QuerySet.get`, and using\n+:meth:`~django.db.models.query.QuerySet.filter` with a slice of ``[0]``. If\n+there are no results that match the query,\n+:meth:`~django.db.models.query.QuerySet.get` will raise a ``DoesNotExist``\n+exception. This exception is an attribute of the model class that the query is\n+being performed on - so in the code above, if there is no ``Entry`` object with\n+a primary key of 1, Django will raise ``Entry.DoesNotExist``.\n \n-Similarly, Django will complain if more than one item matches the ``get()``\n-query. In this case, it will raise ``MultipleObjectsReturned``, which again is\n-an attribute of the model class itself.\n+Similarly, Django will complain if more than one item matches the\n+:meth:`~django.db.models.query.QuerySet.get` query. In this case, it will raise\n+``MultipleObjectsReturned``, which again is an attribute of the model class\n+itself.\n \n \n Other QuerySet methods\n ----------------------\n \n-Most of the time you'll use ``all()``, ``get()``, ``filter()`` and ``exclude()``\n-when you need to look up objects from the database. However, that's far from all\n-there is; see the :ref:`QuerySet API Reference <queryset-api>` for a complete\n-list of all the various ``QuerySet`` methods.\n+Most of the time you'll use :meth:`~django.db.models.query.QuerySet.all`,\n+:meth:`~django.db.models.query.QuerySet.get`,\n+:meth:`~django.db.models.query.QuerySet.filter` and\n+:meth:`~django.db.models.query.QuerySet.exclude` when you need to look up\n+objects from the database. However, that's far from all there is; see the\n+:ref:`QuerySet API Reference <queryset-api>` for a complete list of all the\n+various :class:`~django.db.models.query.QuerySet` methods.\n \n .. _limiting-querysets:\n \n Limiting QuerySets\n ------------------\n \n-Use a subset of Python's array-slicing syntax to limit your ``QuerySet`` to a\n-certain number of results. This is the equivalent of SQL's ``LIMIT`` and\n-``OFFSET`` clauses.\n+Use a subset of Python's array-slicing syntax to limit your\n+:class:`~django.db.models.query.QuerySet` to a certain number of results. This\n+is the equivalent of SQL's ``LIMIT`` and ``OFFSET`` clauses.\n \n For example, this returns the first 5 objects (``LIMIT 5``)::\n \n@@ -326,10 +361,11 @@ This returns the sixth through tenth objects (``OFFSET 5 LIMIT 5``)::\n \n Negative indexing (i.e. ``Entry.objects.all()[-1]``) is not supported.\n \n-Generally, slicing a ``QuerySet`` returns a new ``QuerySet`` -- it doesn't\n-evaluate the query. An exception is if you use the \"step\" parameter of Python\n-slice syntax. For example, this would actually execute the query in order to\n-return a list of every *second* object of the first 10::\n+Generally, slicing a :class:`~django.db.models.query.QuerySet` returns a new\n+:class:`~django.db.models.query.QuerySet` -- it doesn't evaluate the query. An\n+exception is if you use the \"step\" parameter of Python slice syntax. For\n+example, this would actually execute the query in order to return a list of\n+every *second* object of the first 10::\n \n     >>> Entry.objects.all()[:10:2]\n \n@@ -354,8 +390,10 @@ Field lookups\n -------------\n \n Field lookups are how you specify the meat of an SQL ``WHERE`` clause. They're\n-specified as keyword arguments to the ``QuerySet`` methods ``filter()``,\n-``exclude()`` and ``get()``.\n+specified as keyword arguments to the :class:`~django.db.models.query.QuerySet`\n+methods :meth:`~django.db.models.query.QuerySet.filter`,\n+:meth:`~django.db.models.query.QuerySet.exclude` and\n+:meth:`~django.db.models.query.QuerySet.get`.\n \n Basic lookups keyword arguments take the form ``field__lookuptype=value``.\n (That's a double-underscore). For example::\n@@ -377,7 +415,7 @@ translates (roughly) into the following SQL::\n .. versionchanged:: 1.4\n     The field specified in a lookup has to be the name of a model field.\n     There's one exception though, in case of a\n-    :class:`~django.db.models.fields.ForeignKey` you can specify the field\n+    :class:`~django.db.models.ForeignKey` you can specify the field\n     name suffixed with ``_id``. In this case, the value parameter is expected\n     to contain the raw value of the foreign model's primary key. For example::\n \n@@ -387,8 +425,9 @@ If you pass an invalid keyword argument, a lookup function will raise\n ``TypeError``.\n \n The database API supports about two dozen lookup types; a complete reference\n-can be found in the :ref:`field lookup reference <field-lookups>`. To give you a taste of what's available, here's some of the more common lookups\n-you'll probably use:\n+can be found in the :ref:`field lookup reference <field-lookups>`. To give you\n+a taste of what's available, here's some of the more common lookups you'll\n+probably use:\n \n :lookup:`exact`\n     An \"exact\" match. For example::\n@@ -479,7 +518,7 @@ All this means is that no error will be raised. For example, in this filter::\n associated with an entry, it would be treated as if there was also no ``name``\n attached, rather than raising an error because of the missing ``author``.\n Usually this is exactly what you want to have happen. The only case where it\n-might be confusing is if you are using ``isnull``. Thus::\n+might be confusing is if you are using :lookup:`isnull`. Thus::\n \n     Blog.objects.filter(entry__authors__name__isnull=True)\n \n@@ -493,28 +532,32 @@ those latter objects, you could write::\n Spanning multi-valued relationships\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-When you are filtering an object based on a ``ManyToManyField`` or a reverse\n-``ForeignKey``, there are two different sorts of filter you may be\n-interested in. Consider the ``Blog``/``Entry`` relationship (``Blog`` to\n-``Entry`` is a one-to-many relation). We might be interested in finding blogs\n-that have an entry which has both *\"Lennon\"* in the headline and was published\n-in 2008. Or we might want to find blogs that have an entry with *\"Lennon\"* in\n-the headline as well as an entry that was published in 2008. Since there are\n-multiple entries associated with a single ``Blog``, both of these queries are\n-possible and make sense in some situations.\n-\n-The same type of situation arises with a ``ManyToManyField``. For example, if\n-an ``Entry`` has a ``ManyToManyField`` called ``tags``, we might want to find\n-entries linked to tags called *\"music\"* and *\"bands\"* or we might want an\n+When you are filtering an object based on a\n+:class:`~django.db.models.ManyToManyField` or a reverse\n+:class:`~django.db.models.ForeignKey`, there are two different sorts of filter\n+you may be interested in. Consider the ``Blog``/``Entry`` relationship\n+(``Blog`` to ``Entry`` is a one-to-many relation). We might be interested in\n+finding blogs that have an entry which has both *\"Lennon\"* in the headline and\n+was published in 2008. Or we might want to find blogs that have an entry with\n+*\"Lennon\"* in the headline as well as an entry that was published\n+in 2008. Since there are multiple entries associated with a single ``Blog``,\n+both of these queries are possible and make sense in some situations.\n+\n+The same type of situation arises with a\n+:class:`~django.db.models.ManyToManyField`. For example, if an ``Entry`` has a\n+:class:`~django.db.models.ManyToManyField` called ``tags``, we might want to\n+find entries linked to tags called *\"music\"* and *\"bands\"* or we might want an\n entry that contains a tag with a name of *\"music\"* and a status of *\"public\"*.\n \n To handle both of these situations, Django has a consistent way of processing\n-``filter()`` and ``exclude()`` calls. Everything inside a single ``filter()``\n-call is applied simultaneously to filter out items matching all those\n-requirements. Successive ``filter()`` calls further restrict the set of\n-objects, but for multi-valued relations, they apply to any object linked to\n+:meth:`~django.db.models.query.QuerySet.filter` and\n+:meth:`~django.db.models.query.QuerySet.exclude` calls.  Everything inside a\n+single :meth:`~django.db.models.query.QuerySet.filter` call is applied\n+simultaneously to filter out items matching all those requirements. Successive\n+:meth:`~django.db.models.query.QuerySet.filter` calls further restrict the set\n+of objects, but for multi-valued relations, they apply to any object linked to\n the primary model, not necessarily those objects that were selected by an\n-earlier ``filter()`` call.\n+earlier :meth:`~django.db.models.query.QuerySet.filter` call.\n \n That may sound a bit confusing, so hopefully an example will clarify. To\n select all blogs that contain entries with both *\"Lennon\"* in the headline\n@@ -537,11 +580,14 @@ entry. The entries select by the second filter may or may not be the same as\n the entries in the first filter. We are filtering the ``Blog`` items with each\n filter statement, not the ``Entry`` items.\n \n-All of this behavior also applies to ``exclude()``: all the conditions in a\n-single ``exclude()`` statement apply to a single instance (if those conditions\n-are talking about the same multi-valued relation). Conditions in subsequent\n-``filter()`` or ``exclude()`` calls that refer to the same relation may end up\n-filtering on different linked objects.\n+All of this behavior also applies to\n+:meth:`~django.db.models.query.QuerySet.exclude`: all the conditions in a\n+single :meth:`~django.db.models.query.QuerySet.exclude` statement apply to a\n+single instance (if those conditions are talking about the same multi-valued\n+relation). Conditions in subsequent\n+:meth:`~django.db.models.query.QuerySet.filter` or\n+:meth:`~django.db.models.query.QuerySet.exclude` calls that refer to the same\n+relation may end up filtering on different linked objects.\n \n .. _query-expressions:\n \n@@ -552,10 +598,10 @@ In the examples given so far, we have constructed filters that compare\n the value of a model field with a constant. But what if you want to compare\n the value of a model field with another field on the same model?\n \n-Django provides the ``F()`` object to allow such comparisons. Instances\n-of ``F()`` act as a reference to a model field within a query. These\n-references can then be used in query filters to compare the values of two\n-different fields on the same model instance.\n+Django provides the :ref:`F() expressions <query-expressions>` to allow such\n+comparisons. Instances of ``F()`` act as a reference to a model field within a\n+query. These references can then be used in query filters to compare the values\n+of two different fields on the same model instance.\n \n For example, to find a list of all blog entries that have had more comments\n than pingbacks, we construct an ``F()`` object to reference the pingback count,\n@@ -587,9 +633,9 @@ issue the query::\n \n .. versionadded:: 1.3\n \n-For date and date/time fields, you can add or subtract a ``datetime.timedelta``\n-object.  The following would return all entries that were modified more than 3 days\n-after they were published::\n+For date and date/time fields, you can add or subtract a\n+:class:`~datetime.timedelta` object.  The following would return all entries\n+that were modified more than 3 days after they were published::\n \n     >>> from datetime import timedelta\n     >>> Entry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3))\n@@ -654,19 +700,23 @@ for you transparently.\n Caching and QuerySets\n ---------------------\n \n-Each ``QuerySet`` contains a cache, to minimize database access. It's important\n-to understand how it works, in order to write the most efficient code.\n+Each :class:`~django.db.models.query.QuerySet` contains a cache, to minimize\n+database access. It's important to understand how it works, in order to write\n+the most efficient code.\n \n-In a newly created ``QuerySet``, the cache is empty. The first time a\n-``QuerySet`` is evaluated -- and, hence, a database query happens -- Django\n-saves the query results in the ``QuerySet``'s cache and returns the results\n+In a newly created :class:`~django.db.models.query.QuerySet`, the cache is\n+empty. The first time a :class:`~django.db.models.query.QuerySet` is evaluated\n+-- and, hence, a database query happens -- Django saves the query results in\n+the :class:`~django.db.models.query.QuerySet`\\'s cache and returns the results\n that have been explicitly requested (e.g., the next element, if the\n-``QuerySet`` is being iterated over). Subsequent evaluations of the\n-``QuerySet`` reuse the cached results.\n+:class:`~django.db.models.query.QuerySet` is being iterated over). Subsequent\n+evaluations of the :class:`~django.db.models.query.QuerySet` reuse the cached\n+results.\n \n Keep this caching behavior in mind, because it may bite you if you don't use\n-your ``QuerySet``\\s correctly. For example, the following will create two\n-``QuerySet``\\s, evaluate them, and throw them away::\n+your :class:`~django.db.models.query.QuerySet`\\s correctly. For example, the\n+following will create two :class:`~django.db.models.query.QuerySet`\\s, evaluate\n+them, and throw them away::\n \n     >>> print [e.headline for e in Entry.objects.all()]\n     >>> print [e.pub_date for e in Entry.objects.all()]\n@@ -676,7 +726,8 @@ your database load. Also, there's a possibility the two lists may not include\n the same database records, because an ``Entry`` may have been added or deleted\n in the split second between the two requests.\n \n-To avoid this problem, simply save the ``QuerySet`` and reuse it::\n+To avoid this problem, simply save the\n+:class:`~django.db.models.query.QuerySet` and reuse it::\n \n     >>> queryset = Entry.objects.all()\n     >>> print [p.headline for p in queryset] # Evaluate the query set.\n@@ -687,13 +738,15 @@ To avoid this problem, simply save the ``QuerySet`` and reuse it::\n Complex lookups with Q objects\n ==============================\n \n-Keyword argument queries -- in ``filter()``, etc. -- are \"AND\"ed together. If\n-you need to execute more complex queries (for example, queries with ``OR``\n-statements), you can use ``Q`` objects.\n+Keyword argument queries -- in :meth:`~django.db.models.query.QuerySet.filter`,\n+etc. -- are \"AND\"ed together. If you need to execute more complex queries (for\n+example, queries with ``OR`` statements), you can use ``Q`` objects.\n \n-A ``Q`` object (``django.db.models.Q``) is an object used to encapsulate a\n-collection of keyword arguments. These keyword arguments are specified as in\n-\"Field lookups\" above.\n+.. comment: Link to Q does not work, since this documentation does not exist yet.\n+\n+A :class:`~django.db.models.Q` object (``django.db.models.Q``) is an object\n+used to encapsulate a collection of keyword arguments. These keyword arguments\n+are specified as in \"Field lookups\" above.\n \n For example, this ``Q`` object encapsulates a single ``LIKE`` query::\n \n@@ -719,11 +772,13 @@ that combine both a normal query and a negated (``NOT``) query::\n \n     Q(question__startswith='Who') | ~Q(pub_date__year=2005)\n \n-Each lookup function that takes keyword-arguments (e.g. ``filter()``,\n-``exclude()``, ``get()``) can also be passed one or more ``Q`` objects as\n-positional (not-named) arguments. If you provide multiple ``Q`` object\n-arguments to a lookup function, the arguments will be \"AND\"ed together. For\n-example::\n+Each lookup function that takes keyword-arguments\n+(e.g. :meth:`~django.db.models.query.QuerySet.filter`,\n+:meth:`~django.db.models.query.QuerySet.exclude`,\n+:meth:`~django.db.models.query.QuerySet.get`) can also be passed one or more\n+``Q`` objects as positional (not-named) arguments. If you provide multiple\n+``Q`` object arguments to a lookup function, the arguments will be \"AND\"ed\n+together. For example::\n \n     Poll.objects.get(\n         Q(question__startswith='Who'),\n@@ -784,27 +839,31 @@ primary key field is called ``name``, these two statements are equivalent::\n Deleting objects\n ================\n \n-The delete method, conveniently, is named ``delete()``. This method immediately\n-deletes the object and has no return value. Example::\n+The delete method, conveniently, is named\n+:meth:`~django.db.models.Model.delete`. This method immediately deletes the\n+object and has no return value. Example::\n \n     e.delete()\n \n-You can also delete objects in bulk. Every ``QuerySet`` has a ``delete()``\n-method, which deletes all members of that ``QuerySet``.\n+You can also delete objects in bulk. Every\n+:class:`~django.db.models.query.QuerySet` has a\n+:meth:`~django.db.models.query.QuerySet.delete` method, which deletes all\n+members of that :class:`~django.db.models.query.QuerySet`.\n \n For example, this deletes all ``Entry`` objects with a ``pub_date`` year of\n 2005::\n \n     Entry.objects.filter(pub_date__year=2005).delete()\n \n-Keep in mind that this will, whenever possible, be executed purely in\n-SQL, and so the ``delete()`` methods of individual object instances\n-will not necessarily be called during the process. If you've provided\n-a custom ``delete()`` method on a model class and want to ensure that\n-it is called, you will need to \"manually\" delete instances of that\n-model (e.g., by iterating over a ``QuerySet`` and calling ``delete()``\n-on each object individually) rather than using the bulk ``delete()``\n-method of a ``QuerySet``.\n+Keep in mind that this will, whenever possible, be executed purely in SQL, and\n+so the ``delete()`` methods of individual object instances will not necessarily\n+be called during the process. If you've provided a custom ``delete()`` method\n+on a model class and want to ensure that it is called, you will need to\n+\"manually\" delete instances of that model (e.g., by iterating over a\n+:class:`~django.db.models.query.QuerySet` and calling ``delete()`` on each\n+object individually) rather than using the bulk\n+:meth:`~django.db.models.query.QuerySet.delete` method of a\n+:class:`~django.db.models.query.QuerySet`.\n \n When Django deletes an object, by default it emulates the behavior of the SQL\n constraint ``ON DELETE CASCADE`` -- in other words, any objects which had\n@@ -820,11 +879,12 @@ it. For example::\n     :attr:`~django.db.models.ForeignKey.on_delete` argument to the\n     :class:`~django.db.models.ForeignKey`.\n \n-Note that ``delete()`` is the only ``QuerySet`` method that is not exposed on a\n-``Manager`` itself. This is a safety mechanism to prevent you from accidentally\n-requesting ``Entry.objects.delete()``, and deleting *all* the entries. If you\n-*do* want to delete all the objects, then you have to explicitly request a\n-complete query set::\n+Note that :meth:`~django.db.models.query.QuerySet.delete` is the only\n+:class:`~django.db.models.query.QuerySet` method that is not exposed on a\n+:class:`~django.db.models.Manager` itself. This is a safety mechanism to\n+prevent you from accidentally requesting ``Entry.objects.delete()``, and\n+deleting *all* the entries. If you *do* want to delete all the objects, then\n+you have to explicitly request a complete query set::\n \n     Entry.objects.all().delete()\n \n@@ -874,26 +934,28 @@ Updating multiple objects at once\n =================================\n \n Sometimes you want to set a field to a particular value for all the objects in\n-a ``QuerySet``. You can do this with the ``update()`` method. For example::\n+a :class:`~django.db.models.query.QuerySet`. You can do this with the\n+:meth:`~django.db.models.query.QuerySet.update` method. For example::\n \n     # Update all the headlines with pub_date in 2007.\n     Entry.objects.filter(pub_date__year=2007).update(headline='Everything is the same')\n \n-You can only set non-relation fields and ``ForeignKey`` fields using this\n-method. To update a non-relation field, provide the new value as a constant.\n-To update ``ForeignKey`` fields, set the new value to be the new model\n-instance you want to point to. For example::\n+You can only set non-relation fields and :class:`~django.db.models.ForeignKey`\n+fields using this method. To update a non-relation field, provide the new value\n+as a constant.  To update :class:`~django.db.models.ForeignKey` fields, set the\n+new value to be the new model instance you want to point to. For example::\n \n     >>> b = Blog.objects.get(pk=1)\n \n     # Change every Entry so that it belongs to this Blog.\n     >>> Entry.objects.all().update(blog=b)\n \n The ``update()`` method is applied instantly and returns the number of rows\n-affected by the query. The only restriction on the ``QuerySet`` that is\n-updated is that it can only access one database table, the model's main\n-table. You can filter based on related fields, but you can only update columns\n-in the model's main table. Example::\n+affected by the query. The only restriction on the\n+:class:`~django.db.models.query.QuerySet` that is updated is that it can only\n+access one database table, the model's main table. You can filter based on\n+related fields, but you can only update columns in the model's main\n+table. Example::\n \n     >>> b = Blog.objects.get(pk=1)\n \n@@ -902,11 +964,13 @@ in the model's main table. Example::\n \n Be aware that the ``update()`` method is converted directly to an SQL\n statement. It is a bulk operation for direct updates. It doesn't run any\n-``save()`` methods on your models, or emit the ``pre_save`` or ``post_save``\n-signals (which are a consequence of calling ``save()``). If you want to save\n-every item in a ``QuerySet`` and make sure that the ``save()`` method is\n-called on each instance, you don't need any special function to handle that.\n-Just loop over them and call ``save()``::\n+:meth:`~django.db.models.Model.save` methods on your models, or emit the\n+``pre_save`` or ``post_save`` signals (which are a consequence of calling\n+:meth:`~django.db.models.Model.save`). If you want to save every item in a\n+:class:`~django.db.models.query.QuerySet` and make sure that the\n+:meth:`~django.db.models.Model.save` method is called on each instance, you\n+don't need any special function to handle that.  Just loop over them and call\n+:meth:`~django.db.models.Model.save`::\n \n     for item in my_queryset:\n         item.save()\n@@ -931,8 +995,10 @@ a join with an ``F()`` object, a ``FieldError`` will be raised::\n Related objects\n ===============\n \n-When you define a relationship in a model (i.e., a ``ForeignKey``,\n-``OneToOneField``, or ``ManyToManyField``), instances of that model will have\n+When you define a relationship in a model (i.e., a\n+:class:`~django.db.models.ForeignKey`,\n+:class:`~django.db.models.OneToOneField`, or\n+:class:`~django.db.models.ManyToManyField`), instances of that model will have\n a convenient API to access the related object(s).\n \n Using the models at the top of this page, for example, an ``Entry`` object ``e``\n@@ -958,23 +1024,24 @@ One-to-many relationships\n Forward\n ~~~~~~~\n \n-If a model has a ``ForeignKey``, instances of that model will have access to\n-the related (foreign) object via a simple attribute of the model.\n+If a model has a :class:`~django.db.models.ForeignKey`, instances of that model\n+will have access to the related (foreign) object via a simple attribute of the\n+model.\n \n Example::\n \n     >>> e = Entry.objects.get(id=2)\n     >>> e.blog # Returns the related Blog object.\n \n You can get and set via a foreign-key attribute. As you may expect, changes to\n-the foreign key aren't saved to the database until you call ``save()``.\n-Example::\n+the foreign key aren't saved to the database until you call\n+:meth:`~django.db.models.Model.save`.  Example::\n \n     >>> e = Entry.objects.get(id=2)\n     >>> e.blog = some_blog\n     >>> e.save()\n \n-If a ``ForeignKey`` field has ``null=True`` set (i.e., it allows ``NULL``\n+If a :class:`~django.db.models.ForeignKey` field has ``null=True`` set (i.e., it allows ``NULL``\n values), you can assign ``None`` to it. Example::\n \n     >>> e = Entry.objects.get(id=2)\n@@ -989,8 +1056,9 @@ object instance are cached. Example::\n     >>> print e.blog  # Hits the database to retrieve the associated Blog.\n     >>> print e.blog  # Doesn't hit the database; uses cached version.\n \n-Note that the ``select_related()`` ``QuerySet`` method recursively prepopulates\n-the cache of all one-to-many relationships ahead of time. Example::\n+Note that the :meth:`~django.db.models.query.QuerySet.select_related`\n+:class:`~django.db.models.query.QuerySet` method recursively prepopulates the\n+cache of all one-to-many relationships ahead of time. Example::\n \n     >>> e = Entry.objects.select_related().get(id=2)\n     >>> print e.blog  # Doesn't hit the database; uses cached version.\n@@ -1001,12 +1069,13 @@ the cache of all one-to-many relationships ahead of time. Example::\n Following relationships \"backward\"\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-If a model has a ``ForeignKey``, instances of the foreign-key model will have\n-access to a ``Manager`` that returns all instances of the first model. By\n-default, this ``Manager`` is named ``FOO_set``, where ``FOO`` is the source\n-model name, lowercased. This ``Manager`` returns ``QuerySets``, which can be\n-filtered and manipulated as described in the \"Retrieving objects\" section\n-above.\n+If a model has a :class:`~django.db.models.ForeignKey`, instances of the\n+foreign-key model will have access to a :class:`~django.db.models.Manager` that\n+returns all instances of the first model. By default, this\n+:class:`~django.db.models.Manager` is named ``FOO_set``, where ``FOO`` is the\n+source model name, lowercased. This :class:`~django.db.models.Manager` returns\n+``QuerySets``, which can be filtered and manipulated as described in the\n+\"Retrieving objects\" section above.\n \n Example::\n \n@@ -1029,18 +1098,20 @@ above example code would look like this::\n     >>> b.entries.filter(headline__contains='Lennon')\n     >>> b.entries.count()\n \n-You cannot access a reverse ``ForeignKey`` ``Manager`` from the class; it must\n-be accessed from an instance::\n+You cannot access a reverse :class:`~django.db.models.ForeignKey`\n+:class:`~django.db.models.Manager` from the class; it must be accessed from an\n+instance::\n \n     >>> Blog.entry_set\n     Traceback:\n         ...\n     AttributeError: \"Manager must be accessed via instance\".\n \n-In addition to the ``QuerySet`` methods defined in \"Retrieving objects\" above,\n-the ``ForeignKey`` ``Manager`` has additional methods used to handle the set of\n-related objects. A synopsis of each is below, and complete details can be found\n-in the :doc:`related objects reference </ref/models/relations>`.\n+In addition to the :class:`~django.db.models.query.QuerySet` methods defined in\n+\"Retrieving objects\" above, the :class:`~django.db.models.ForeignKey`\n+:class:`~django.db.models.Manager` has additional methods used to handle the\n+set of related objects. A synopsis of each is below, and complete details can\n+be found in the :doc:`related objects reference </ref/models/relations>`.\n \n ``add(obj1, obj2, ...)``\n     Adds the specified model objects to the related object set.\n@@ -1084,9 +1155,9 @@ Both ends of a many-to-many relationship get automatic API access to the other\n end. The API works just as a \"backward\" one-to-many relationship, above.\n \n The only difference is in the attribute naming: The model that defines the\n-``ManyToManyField`` uses the attribute name of that field itself, whereas the\n-\"reverse\" model uses the lowercased model name of the original model, plus\n-``'_set'`` (just like reverse one-to-many relationships).\n+:class:`~django.db.models.ManyToManyField` uses the attribute name of that\n+field itself, whereas the \"reverse\" model uses the lowercased model name of the\n+original model, plus ``'_set'`` (just like reverse one-to-many relationships).\n \n An example makes this easier to understand::\n \n@@ -1098,10 +1169,11 @@ An example makes this easier to understand::\n     a = Author.objects.get(id=5)\n     a.entry_set.all() # Returns all Entry objects for this Author.\n \n-Like ``ForeignKey``, ``ManyToManyField`` can specify ``related_name``. In the\n-above example, if the ``ManyToManyField`` in ``Entry`` had specified\n-``related_name='entries'``, then each ``Author`` instance would have an\n-``entries`` attribute instead of ``entry_set``.\n+Like :class:`~django.db.models.ForeignKey`,\n+:class:`~django.db.models.ManyToManyField` can specify ``related_name``. In the\n+above example, if the :class:`~django.db.models.ManyToManyField` in ``Entry``\n+had specified ``related_name='entries'``, then each ``Author`` instance would\n+have an ``entries`` attribute instead of ``entry_set``.\n \n One-to-one relationships\n ------------------------\n@@ -1147,10 +1219,11 @@ relationship on one end.\n But how is this possible, given that a model class doesn't know which other\n model classes are related to it until those other model classes are loaded?\n \n-The answer lies in the :setting:`INSTALLED_APPS` setting. The first time any model is\n-loaded, Django iterates over every model in :setting:`INSTALLED_APPS` and creates the\n-backward relationships in memory as needed. Essentially, one of the functions\n-of :setting:`INSTALLED_APPS` is to tell Django the entire model domain.\n+The answer lies in the :setting:`INSTALLED_APPS` setting. The first time any\n+model is loaded, Django iterates over every model in :setting:`INSTALLED_APPS`\n+and creates the backward relationships in memory as needed. Essentially, one of\n+the functions of :setting:`INSTALLED_APPS` is to tell Django the entire model\n+domain.\n \n Queries over related objects\n ----------------------------"
        }
    ],
    "stats": {
        "total": 515,
        "additions": 294,
        "deletions": 221
    }
}