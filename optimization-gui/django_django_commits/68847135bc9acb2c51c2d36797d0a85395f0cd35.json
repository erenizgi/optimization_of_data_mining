{
    "author": "akaariai",
    "message": "Removed dupe_avoidance from sql/query and sql/compiler.py\n\nThe dupe avoidance logic was removed as it doesn't seem to do anything,\nit is complicated, and it has nearly zero documentation.\n\nThe removal of dupe_avoidance allowed for refactoring of both the\nimplementation and signature of Query.join(). This refactoring cascades\nagain to some other parts. The most significant of them is the changes\nin qs.combine(), and compiler.select_related_descent().",
    "sha": "68847135bc9acb2c51c2d36797d0a85395f0cd35",
    "files": [
        {
            "sha": "5c3f53801835b5af591b11796021a4f66096ddbf",
            "filename": "django/db/models/fields/related.py",
            "status": "modified",
            "additions": 0,
            "deletions": 11,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/68847135bc9acb2c51c2d36797d0a85395f0cd35/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "raw_url": "https://github.com/django/django/raw/68847135bc9acb2c51c2d36797d0a85395f0cd35/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2Frelated.py?ref=68847135bc9acb2c51c2d36797d0a85395f0cd35",
            "patch": "@@ -1053,11 +1053,6 @@ def value_to_string(self, obj):\n     def contribute_to_class(self, cls, name):\n         super(ForeignKey, self).contribute_to_class(cls, name)\n         setattr(cls, self.name, ReverseSingleRelatedObjectDescriptor(self))\n-        if isinstance(self.rel.to, six.string_types):\n-            target = self.rel.to\n-        else:\n-            target = self.rel.to._meta.db_table\n-        cls._meta.duplicate_targets[self.column] = (target, \"o2m\")\n \n     def contribute_to_related_class(self, cls, related):\n         # Internal FK's - i.e., those with a related name ending with '+' -\n@@ -1293,12 +1288,6 @@ def resolve_through_model(field, model, cls):\n                 field.rel.through = model\n             add_lazy_relation(cls, self, self.rel.through, resolve_through_model)\n \n-        if isinstance(self.rel.to, six.string_types):\n-            target = self.rel.to\n-        else:\n-            target = self.rel.to._meta.db_table\n-        cls._meta.duplicate_targets[self.column] = (target, \"m2m\")\n-\n     def contribute_to_related_class(self, cls, related):\n         # Internal M2Ms (i.e., those with a related name ending with '+')\n         # and swapped models don't get a related descriptor."
        },
        {
            "sha": "f430caceef7316f3762f7c5ba2c1fa3eb15318a7",
            "filename": "django/db/models/options.py",
            "status": "modified",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/68847135bc9acb2c51c2d36797d0a85395f0cd35/django%2Fdb%2Fmodels%2Foptions.py",
            "raw_url": "https://github.com/django/django/raw/68847135bc9acb2c51c2d36797d0a85395f0cd35/django%2Fdb%2Fmodels%2Foptions.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Foptions.py?ref=68847135bc9acb2c51c2d36797d0a85395f0cd35",
            "patch": "@@ -58,7 +58,6 @@ def __init__(self, meta, app_label=None):\n         self.concrete_model = None\n         self.swappable = None\n         self.parents = SortedDict()\n-        self.duplicate_targets = {}\n         self.auto_created = False\n \n         # To handle various inheritance situations, we need to track where\n@@ -147,24 +146,6 @@ def _prepare(self, model):\n                         auto_created=True)\n                 model.add_to_class('id', auto)\n \n-        # Determine any sets of fields that are pointing to the same targets\n-        # (e.g. two ForeignKeys to the same remote model). The query\n-        # construction code needs to know this. At the end of this,\n-        # self.duplicate_targets will map each duplicate field column to the\n-        # columns it duplicates.\n-        collections = {}\n-        for column, target in six.iteritems(self.duplicate_targets):\n-            try:\n-                collections[target].add(column)\n-            except KeyError:\n-                collections[target] = set([column])\n-        self.duplicate_targets = {}\n-        for elt in six.itervalues(collections):\n-            if len(elt) == 1:\n-                continue\n-            for column in elt:\n-                self.duplicate_targets[column] = elt.difference(set([column]))\n-\n     def add_field(self, field):\n         # Insert the given field in the order in which it was created, using\n         # the \"creation_counter\" attribute of the field."
        },
        {
            "sha": "db1e1131ad0d80218176163ee6f54e31958d9df6",
            "filename": "django/db/models/sql/compiler.py",
            "status": "modified",
            "additions": 9,
            "deletions": 59,
            "changes": 68,
            "blob_url": "https://github.com/django/django/blob/68847135bc9acb2c51c2d36797d0a85395f0cd35/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/68847135bc9acb2c51c2d36797d0a85395f0cd35/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py?ref=68847135bc9acb2c51c2d36797d0a85395f0cd35",
            "patch": "@@ -6,7 +6,7 @@\n from django.db.models.constants import LOOKUP_SEP\n from django.db.models.query_utils import select_related_descend\n from django.db.models.sql.constants import (SINGLE, MULTI, ORDER_DIR,\n-        GET_ITERATOR_CHUNK_SIZE, SelectInfo)\n+        GET_ITERATOR_CHUNK_SIZE, REUSE_ALL, SelectInfo)\n from django.db.models.sql.datastructures import EmptyResultSet\n from django.db.models.sql.expressions import SQLEvaluator\n from django.db.models.sql.query import get_order_dir, Query\n@@ -457,7 +457,7 @@ def _setup_joins(self, pieces, opts, alias):\n         if not alias:\n             alias = self.query.get_initial_alias()\n         field, target, opts, joins, _, _ = self.query.setup_joins(pieces,\n-                opts, alias, False)\n+                opts, alias, REUSE_ALL)\n         # We will later on need to promote those joins that were added to the\n         # query afresh above.\n         joins_to_promote = [j for j in joins if self.query.alias_refcount[j] < 2]\n@@ -574,8 +574,7 @@ def get_grouping(self):\n         return result, params\n \n     def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n-            used=None, requested=None, restricted=None, nullable=None,\n-            dupe_set=None, avoid_set=None):\n+            requested=None, restricted=None, nullable=None):\n         \"\"\"\n         Fill in the information needed for a select_related query. The current\n         depth is measured as the number of connections away from the root model\n@@ -590,13 +589,6 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n             opts = self.query.get_meta()\n             root_alias = self.query.get_initial_alias()\n             self.query.related_select_cols = []\n-        if not used:\n-            used = set()\n-        if dupe_set is None:\n-            dupe_set = set()\n-        if avoid_set is None:\n-            avoid_set = set()\n-        orig_dupe_set = dupe_set\n         only_load = self.query.get_loaded_field_names()\n \n         # Setup for the case when only particular related fields should be\n@@ -616,12 +608,6 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n             if not select_related_descend(f, restricted, requested,\n                                           only_load.get(field_model)):\n                 continue\n-            # The \"avoid\" set is aliases we want to avoid just for this\n-            # particular branch of the recursion. They aren't permanently\n-            # forbidden from reuse in the related selection tables (which is\n-            # what \"used\" specifies).\n-            avoid = avoid_set.copy()\n-            dupe_set = orig_dupe_set.copy()\n             table = f.rel.to._meta.db_table\n             promote = nullable or f.null\n             if model:\n@@ -637,31 +623,17 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n                         int_opts = int_model._meta\n                         continue\n                     lhs_col = int_opts.parents[int_model].column\n-                    dedupe = lhs_col in opts.duplicate_targets\n-                    if dedupe:\n-                        avoid.update(self.query.dupe_avoidance.get((id(opts), lhs_col),\n-                                ()))\n-                        dupe_set.add((opts, lhs_col))\n                     int_opts = int_model._meta\n                     alias = self.query.join((alias, int_opts.db_table, lhs_col,\n-                            int_opts.pk.column), exclusions=used,\n+                            int_opts.pk.column),\n                             promote=promote)\n                     alias_chain.append(alias)\n-                    for (dupe_opts, dupe_col) in dupe_set:\n-                        self.query.update_dupe_avoidance(dupe_opts, dupe_col, alias)\n             else:\n                 alias = root_alias\n \n-            dedupe = f.column in opts.duplicate_targets\n-            if dupe_set or dedupe:\n-                avoid.update(self.query.dupe_avoidance.get((id(opts), f.column), ()))\n-                if dedupe:\n-                    dupe_set.add((opts, f.column))\n-\n             alias = self.query.join((alias, table, f.column,\n                     f.rel.get_related_field().column),\n-                    exclusions=used.union(avoid), promote=promote)\n-            used.add(alias)\n+                    promote=promote)\n             columns, aliases = self.get_default_columns(start_alias=alias,\n                     opts=f.rel.to._meta, as_pairs=True)\n             self.query.related_select_cols.extend(\n@@ -671,10 +643,8 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n             else:\n                 next = False\n             new_nullable = f.null or promote\n-            for dupe_opts, dupe_col in dupe_set:\n-                self.query.update_dupe_avoidance(dupe_opts, dupe_col, alias)\n             self.fill_related_selections(f.rel.to._meta, alias, cur_depth + 1,\n-                    used, next, restricted, new_nullable, dupe_set, avoid)\n+                    next, restricted, new_nullable)\n \n         if restricted:\n             related_fields = [\n@@ -686,14 +656,8 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n                 if not select_related_descend(f, restricted, requested,\n                                               only_load.get(model), reverse=True):\n                     continue\n-                # The \"avoid\" set is aliases we want to avoid just for this\n-                # particular branch of the recursion. They aren't permanently\n-                # forbidden from reuse in the related selection tables (which is\n-                # what \"used\" specifies).\n-                avoid = avoid_set.copy()\n-                dupe_set = orig_dupe_set.copy()\n-                table = model._meta.db_table\n \n+                table = model._meta.db_table\n                 int_opts = opts\n                 alias = root_alias\n                 alias_chain = []\n@@ -708,30 +672,16 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n                             int_opts = int_model._meta\n                             continue\n                         lhs_col = int_opts.parents[int_model].column\n-                        dedupe = lhs_col in opts.duplicate_targets\n-                        if dedupe:\n-                            avoid.update((self.query.dupe_avoidance.get(id(opts), lhs_col),\n-                                ()))\n-                            dupe_set.add((opts, lhs_col))\n                         int_opts = int_model._meta\n                         alias = self.query.join(\n                             (alias, int_opts.db_table, lhs_col, int_opts.pk.column),\n-                            exclusions=used, promote=True, reuse=used\n+                            promote=True,\n                         )\n                         alias_chain.append(alias)\n-                        for dupe_opts, dupe_col in dupe_set:\n-                            self.query.update_dupe_avoidance(dupe_opts, dupe_col, alias)\n-                    dedupe = f.column in opts.duplicate_targets\n-                    if dupe_set or dedupe:\n-                        avoid.update(self.query.dupe_avoidance.get((id(opts), f.column), ()))\n-                        if dedupe:\n-                            dupe_set.add((opts, f.column))\n                 alias = self.query.join(\n                     (alias, table, f.rel.get_related_field().column, f.column),\n-                    exclusions=used.union(avoid),\n                     promote=True\n                 )\n-                used.add(alias)\n                 columns, aliases = self.get_default_columns(start_alias=alias,\n                     opts=model._meta, as_pairs=True, local_only=True)\n                 self.query.related_select_cols.extend(\n@@ -743,7 +693,7 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n                 new_nullable = True\n \n                 self.fill_related_selections(model._meta, table, cur_depth+1,\n-                    used, next, restricted, new_nullable)\n+                    next, restricted, new_nullable)\n \n     def deferred_to_columns(self):\n         \"\"\""
        },
        {
            "sha": "6e1d2dd87a5d48f34688ce25fe5bafcec6281b18",
            "filename": "django/db/models/sql/constants.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/68847135bc9acb2c51c2d36797d0a85395f0cd35/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py",
            "raw_url": "https://github.com/django/django/raw/68847135bc9acb2c51c2d36797d0a85395f0cd35/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py?ref=68847135bc9acb2c51c2d36797d0a85395f0cd35",
            "patch": "@@ -37,3 +37,6 @@\n     'ASC': ('ASC', 'DESC'),\n     'DESC': ('DESC', 'ASC'),\n }\n+\n+# A marker for join-reusability.\n+REUSE_ALL = object()"
        },
        {
            "sha": "ce45ec314a2a3aea4e582e1092a7c7ebcef1c429",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 74,
            "deletions": 122,
            "changes": 196,
            "blob_url": "https://github.com/django/django/blob/68847135bc9acb2c51c2d36797d0a85395f0cd35/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/68847135bc9acb2c51c2d36797d0a85395f0cd35/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=68847135bc9acb2c51c2d36797d0a85395f0cd35",
            "patch": "@@ -20,7 +20,7 @@\n from django.db.models.fields import FieldDoesNotExist\n from django.db.models.sql import aggregates as base_aggregates_module\n from django.db.models.sql.constants import (QUERY_TERMS, ORDER_DIR, SINGLE,\n-        ORDER_PATTERN, JoinInfo, SelectInfo)\n+        ORDER_PATTERN, REUSE_ALL, JoinInfo, SelectInfo)\n from django.db.models.sql.datastructures import EmptyResultSet, Empty, MultiJoin\n from django.db.models.sql.expressions import SQLEvaluator\n from django.db.models.sql.where import (WhereNode, Constraint, EverythingNode,\n@@ -115,7 +115,6 @@ def __init__(self, model, where=WhereNode):\n         self.default_ordering = True\n         self.standard_ordering = True\n         self.ordering_aliases = []\n-        self.dupe_avoidance = {}\n         self.used_aliases = set()\n         self.filter_is_sticky = False\n         self.included_inherited_models = {}\n@@ -257,7 +256,6 @@ def clone(self, klass=None, memo=None, **kwargs):\n         obj.standard_ordering = self.standard_ordering\n         obj.included_inherited_models = self.included_inherited_models.copy()\n         obj.ordering_aliases = []\n-        obj.dupe_avoidance = self.dupe_avoidance.copy()\n         obj.select = self.select[:]\n         obj.related_select_cols = []\n         obj.tables = self.tables[:]\n@@ -460,24 +458,42 @@ def combine(self, rhs, connector):\n         self.remove_inherited_models()\n         # Work out how to relabel the rhs aliases, if necessary.\n         change_map = {}\n-        used = set()\n         conjunction = (connector == AND)\n-        # Add the joins in the rhs query into the new query.\n-        first = True\n-        for alias in rhs.tables:\n+\n+        # Determine which existing joins can be reused. When combining the\n+        # query with AND we must recreate all joins for m2m filters. When\n+        # combining with OR we can reuse joins. The reason is that in AND\n+        # case a single row can't fulfill a condition like:\n+        #     revrel__col=1 & revrel__col=2\n+        # But, there might be two different related rows matching this\n+        # condition. In OR case a single True is enough, so single row is\n+        # enough, too.\n+        #\n+        # Note that we will be creating duplicate joins for non-m2m joins in\n+        # the AND case. The results will be correct but this creates too many\n+        # joins. This is something that could be fixed later on.\n+        reuse = set() if conjunction else set(self.tables)\n+        # Base table must be present in the query - this is the same\n+        # table on both sides.\n+        self.get_initial_alias()\n+        # Now, add the joins from rhs query into the new query (skipping base\n+        # table).\n+        for alias in rhs.tables[1:]:\n             if not rhs.alias_refcount[alias]:\n-                # An unused alias.\n                 continue\n-            table, _, join_type, lhs, lhs_col, col, _ = rhs.alias_map[alias]\n-            promote = join_type == self.LOUTER\n+            table, _, join_type, lhs, lhs_col, col, nullable = rhs.alias_map[alias]\n+            promote = (join_type == self.LOUTER)\n             # If the left side of the join was already relabeled, use the\n             # updated alias.\n             lhs = change_map.get(lhs, lhs)\n-            new_alias = self.join((lhs, table, lhs_col, col),\n-                    conjunction and not first, used, promote, not conjunction)\n-            used.add(new_alias)\n+            new_alias = self.join(\n+                (lhs, table, lhs_col, col), reuse=reuse, promote=promote,\n+                outer_if_first=not conjunction, nullable=nullable)\n+            # We can't reuse the same join again in the query. If we have two\n+            # distinct joins for the same connection in rhs query, then the\n+            # combined query must have two joins, too.\n+            reuse.discard(new_alias)\n             change_map[alias] = new_alias\n-            first = False\n \n         # So that we don't exclude valid results in an \"or\" query combination,\n         # all joins exclusive to either the lhs or the rhs must be converted\n@@ -767,9 +783,11 @@ def relabel_column(col):\n             (key, relabel_column(col)) for key, col in self.aggregates.items())\n \n         # 2. Rename the alias in the internal table/alias datastructures.\n-        for k, aliases in self.join_map.items():\n+        for ident, aliases in self.join_map.items():\n+            del self.join_map[ident]\n             aliases = tuple([change_map.get(a, a) for a in aliases])\n-            self.join_map[k] = aliases\n+            ident = (change_map.get(ident[0], ident[0]),) + ident[1:]\n+            self.join_map[ident] = aliases\n         for old_alias, new_alias in six.iteritems(change_map):\n             alias_data = self.alias_map[old_alias]\n             alias_data = alias_data._replace(rhs_alias=new_alias)\n@@ -844,8 +862,8 @@ def count_active_tables(self):\n         \"\"\"\n         return len([1 for count in six.itervalues(self.alias_refcount) if count])\n \n-    def join(self, connection, always_create=False, exclusions=(),\n-            promote=False, outer_if_first=False, nullable=False, reuse=None):\n+    def join(self, connection, reuse=REUSE_ALL, promote=False,\n+             outer_if_first=False, nullable=False):\n         \"\"\"\n         Returns an alias for the join in 'connection', either reusing an\n         existing alias for that join or creating a new one. 'connection' is a\n@@ -855,56 +873,40 @@ def join(self, connection, always_create=False, exclusions=(),\n \n             lhs.lhs_col = table.col\n \n-        If 'always_create' is True and 'reuse' is None, a new alias is always\n-        created, regardless of whether one already exists or not. If\n-        'always_create' is True and 'reuse' is a set, an alias in 'reuse' that\n-        matches the connection will be returned, if possible.  If\n-        'always_create' is False, the first existing alias that matches the\n-        'connection' is returned, if any. Otherwise a new join is created.\n-\n-        If 'exclusions' is specified, it is something satisfying the container\n-        protocol (\"foo in exclusions\" must work) and specifies a list of\n-        aliases that should not be returned, even if they satisfy the join.\n+        The 'reuse' parameter can be used in three ways: it can be REUSE_ALL\n+        which means all joins (matching the connection) are reusable, it can\n+        be a set containing the aliases that can be reused, or it can be None\n+        which means a new join is always created.\n \n         If 'promote' is True, the join type for the alias will be LOUTER (if\n         the alias previously existed, the join type will be promoted from INNER\n         to LOUTER, if necessary).\n \n         If 'outer_if_first' is True and a new join is created, it will have the\n-        LOUTER join type. This is used when joining certain types of querysets\n-        and Q-objects together.\n+        LOUTER join type. Used for example when adding ORed filters, where we\n+        want to use LOUTER joins except if some other join already restricts\n+        the join to INNER join.\n \n         A join is always created as LOUTER if the lhs alias is LOUTER to make\n-        sure we do not generate chains like a LOUTER b INNER c.\n+        sure we do not generate chains like t1 LOUTER t2 INNER t3.\n \n         If 'nullable' is True, the join can potentially involve NULL values and\n         is a candidate for promotion (to \"left outer\") when combining querysets.\n         \"\"\"\n         lhs, table, lhs_col, col = connection\n-        if lhs in self.alias_map:\n-            lhs_table = self.alias_map[lhs].table_name\n+        existing = self.join_map.get(connection, ())\n+        if reuse == REUSE_ALL:\n+            reuse = existing\n+        elif reuse is None:\n+            reuse = set()\n         else:\n-            lhs_table = lhs\n-\n-        if reuse and always_create and table in self.table_map:\n-            # Convert the 'reuse' to case to be \"exclude everything but the\n-            # reusable set, minus exclusions, for this table\".\n-            exclusions = set(self.table_map[table]).difference(reuse).union(set(exclusions))\n-            always_create = False\n-        t_ident = (lhs_table, table, lhs_col, col)\n-        if not always_create:\n-            for alias in self.join_map.get(t_ident, ()):\n-                if alias not in exclusions:\n-                    if lhs_table and not self.alias_refcount[self.alias_map[alias].lhs_alias]:\n-                        # The LHS of this join tuple is no longer part of the\n-                        # query, so skip this possibility.\n-                        continue\n-                    if self.alias_map[alias].lhs_alias != lhs:\n-                        continue\n-                    self.ref_alias(alias)\n-                    if promote or (lhs and self.alias_map[lhs].join_type == self.LOUTER):\n-                        self.promote_joins([alias])\n-                    return alias\n+            reuse = [a for a in existing if a in reuse]\n+        if reuse:\n+            alias = reuse[0]\n+            self.ref_alias(alias)\n+            if promote or (lhs and self.alias_map[lhs].join_type == self.LOUTER):\n+                self.promote_joins([alias])\n+            return alias\n \n         # No reuse is possible, so we need a new alias.\n         alias, _ = self.table_alias(table, True)\n@@ -915,18 +917,16 @@ def join(self, connection, always_create=False, exclusions=(),\n         elif (promote or outer_if_first\n               or self.alias_map[lhs].join_type == self.LOUTER):\n             # We need to use LOUTER join if asked by promote or outer_if_first,\n-            # or if the LHS table is left-joined in the query. Adding inner join\n-            # to an existing outer join effectively cancels the effect of the\n-            # outer join.\n+            # or if the LHS table is left-joined in the query.\n             join_type = self.LOUTER\n         else:\n             join_type = self.INNER\n         join = JoinInfo(table, alias, join_type, lhs, lhs_col, col, nullable)\n         self.alias_map[alias] = join\n-        if t_ident in self.join_map:\n-            self.join_map[t_ident] += (alias,)\n+        if connection in self.join_map:\n+            self.join_map[connection] += (alias,)\n         else:\n-            self.join_map[t_ident] = (alias,)\n+            self.join_map[connection] = (alias,)\n         return alias\n \n     def setup_inherited_models(self):\n@@ -1003,7 +1003,7 @@ def add_aggregate(self, aggregate, model, alias, is_summary):\n             # then we need to explore the joins that are required.\n \n             field, source, opts, join_list, last, _ = self.setup_joins(\n-                field_list, opts, self.get_initial_alias(), False)\n+                field_list, opts, self.get_initial_alias(), REUSE_ALL)\n \n             # Process the join chain to see if it can be trimmed\n             col, _, join_list = self.trim_joins(source, join_list, last, False)\n@@ -1114,8 +1114,8 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n \n         try:\n             field, target, opts, join_list, last, extra_filters = self.setup_joins(\n-                    parts, opts, alias, True, allow_many, allow_explicit_fk=True,\n-                    can_reuse=can_reuse, negate=negate,\n+                    parts, opts, alias, can_reuse, allow_many,\n+                    allow_explicit_fk=True, negate=negate,\n                     process_extras=process_extras)\n         except MultiJoin as e:\n             self.split_exclude(filter_expr, LOOKUP_SEP.join(parts[:e.level]),\n@@ -1268,9 +1268,8 @@ def add_q(self, q_object, used_aliases=None, force_having=False):\n         if self.filter_is_sticky:\n             self.used_aliases = used_aliases\n \n-    def setup_joins(self, names, opts, alias, dupe_multis, allow_many=True,\n-            allow_explicit_fk=False, can_reuse=None, negate=False,\n-            process_extras=True):\n+    def setup_joins(self, names, opts, alias, can_reuse, allow_many=True,\n+            allow_explicit_fk=False, negate=False, process_extras=True):\n         \"\"\"\n         Compute the necessary table joins for the passage through the fields\n         given in 'names'. 'opts' is the Options class for the current model\n@@ -1290,14 +1289,9 @@ def setup_joins(self, names, opts, alias, dupe_multis, allow_many=True,\n         \"\"\"\n         joins = [alias]\n         last = [0]\n-        dupe_set = set()\n-        exclusions = set()\n         extra_filters = []\n         int_alias = None\n         for pos, name in enumerate(names):\n-            if int_alias is not None:\n-                exclusions.add(int_alias)\n-            exclusions.add(alias)\n             last.append(len(joins))\n             if name == 'pk':\n                 name = opts.pk.name\n@@ -1330,28 +1324,12 @@ def setup_joins(self, names, opts, alias, dupe_multis, allow_many=True,\n                         opts = int_model._meta\n                     else:\n                         lhs_col = opts.parents[int_model].column\n-                        dedupe = lhs_col in opts.duplicate_targets\n-                        if dedupe:\n-                            exclusions.update(self.dupe_avoidance.get(\n-                                    (id(opts), lhs_col), ()))\n-                            dupe_set.add((opts, lhs_col))\n                         opts = int_model._meta\n                         alias = self.join((alias, opts.db_table, lhs_col,\n-                                opts.pk.column), exclusions=exclusions)\n+                                opts.pk.column))\n                         joins.append(alias)\n-                        exclusions.add(alias)\n-                        for (dupe_opts, dupe_col) in dupe_set:\n-                            self.update_dupe_avoidance(dupe_opts, dupe_col,\n-                                    alias)\n             cached_data = opts._join_cache.get(name)\n             orig_opts = opts\n-            dupe_col = direct and field.column or field.field.column\n-            dedupe = dupe_col in opts.duplicate_targets\n-            if dupe_set or dedupe:\n-                if dedupe:\n-                    dupe_set.add((opts, dupe_col))\n-                exclusions.update(self.dupe_avoidance.get((id(opts), dupe_col),\n-                        ()))\n \n             if process_extras and hasattr(field, 'extra_filters'):\n                 extra_filters.extend(field.extra_filters(names, pos, negate))\n@@ -1377,16 +1355,14 @@ def setup_joins(self, names, opts, alias, dupe_multis, allow_many=True,\n                                 target)\n \n                     int_alias = self.join((alias, table1, from_col1, to_col1),\n-                            dupe_multis, exclusions, nullable=True,\n-                            reuse=can_reuse)\n+                            reuse=can_reuse, nullable=True)\n                     if int_alias == table2 and from_col2 == to_col2:\n                         joins.append(int_alias)\n                         alias = int_alias\n                     else:\n                         alias = self.join(\n                                 (int_alias, table2, from_col2, to_col2),\n-                                dupe_multis, exclusions, nullable=True,\n-                                reuse=can_reuse)\n+                                reuse=can_reuse, nullable=True)\n                         joins.extend([int_alias, alias])\n                 elif field.rel:\n                     # One-to-one or many-to-one field\n@@ -1402,7 +1378,6 @@ def setup_joins(self, names, opts, alias, dupe_multis, allow_many=True,\n                                 opts, target)\n \n                     alias = self.join((alias, table, from_col, to_col),\n-                                      exclusions=exclusions,\n                                       nullable=self.is_nullable(field))\n                     joins.append(alias)\n                 else:\n@@ -1433,11 +1408,9 @@ def setup_joins(self, names, opts, alias, dupe_multis, allow_many=True,\n                                 target)\n \n                     int_alias = self.join((alias, table1, from_col1, to_col1),\n-                            dupe_multis, exclusions, nullable=True,\n-                            reuse=can_reuse)\n+                            reuse=can_reuse, nullable=True)\n                     alias = self.join((int_alias, table2, from_col2, to_col2),\n-                            dupe_multis, exclusions, nullable=True,\n-                            reuse=can_reuse)\n+                            reuse=can_reuse, nullable=True)\n                     joins.extend([int_alias, alias])\n                 else:\n                     # One-to-many field (ForeignKey defined on the target model)\n@@ -1461,17 +1434,9 @@ def setup_joins(self, names, opts, alias, dupe_multis, allow_many=True,\n                                 opts, target)\n \n                     alias = self.join((alias, table, from_col, to_col),\n-                            dupe_multis, exclusions, nullable=True,\n-                            reuse=can_reuse)\n+                            reuse=can_reuse, nullable=True)\n                     joins.append(alias)\n \n-            for (dupe_opts, dupe_col) in dupe_set:\n-                if int_alias is None:\n-                    to_avoid = alias\n-                else:\n-                    to_avoid = int_alias\n-                self.update_dupe_avoidance(dupe_opts, dupe_col, to_avoid)\n-\n         if pos != len(names) - 1:\n             if pos == len(names) - 2:\n                 raise FieldError(\"Join on field %r not permitted. Did you misspell %r for the lookup type?\" % (name, names[pos + 1]))\n@@ -1538,19 +1503,6 @@ def trim_joins(self, target, join_list, last, trim, nonnull_check=False):\n                 penultimate = last.pop()\n         return col, alias, join_list\n \n-    def update_dupe_avoidance(self, opts, col, alias):\n-        \"\"\"\n-        For a column that is one of multiple pointing to the same table, update\n-        the internal data structures to note that this alias shouldn't be used\n-        for those other columns.\n-        \"\"\"\n-        ident = id(opts)\n-        for name in opts.duplicate_targets[col]:\n-            try:\n-                self.dupe_avoidance[ident, name].add(alias)\n-            except KeyError:\n-                self.dupe_avoidance[ident, name] = set([alias])\n-\n     def split_exclude(self, filter_expr, prefix, can_reuse):\n         \"\"\"\n         When doing an exclude against any kind of N-to-many relation, we need\n@@ -1657,8 +1609,8 @@ def add_fields(self, field_names, allow_m2m=True):\n         try:\n             for name in field_names:\n                 field, target, u2, joins, u3, u4 = self.setup_joins(\n-                        name.split(LOOKUP_SEP), opts, alias, False, allow_m2m,\n-                        True)\n+                        name.split(LOOKUP_SEP), opts, alias, REUSE_ALL,\n+                        allow_m2m, True)\n                 final_alias = joins[-1]\n                 col = target.column\n                 if len(joins) > 1:\n@@ -1948,7 +1900,7 @@ def set_start(self, start):\n         opts = self.model._meta\n         alias = self.get_initial_alias()\n         field, col, opts, joins, last, extra = self.setup_joins(\n-                start.split(LOOKUP_SEP), opts, alias, False)\n+                start.split(LOOKUP_SEP), opts, alias, REUSE_ALL)\n         select_col = self.alias_map[joins[1]].lhs_join_col\n         select_alias = alias\n "
        },
        {
            "sha": "2dbe75fd241bf789011821d8d142fa62c1603ff1",
            "filename": "tests/regressiontests/queries/tests.py",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/68847135bc9acb2c51c2d36797d0a85395f0cd35/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/68847135bc9acb2c51c2d36797d0a85395f0cd35/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Ftests.py?ref=68847135bc9acb2c51c2d36797d0a85395f0cd35",
            "patch": "@@ -1046,6 +1046,18 @@ def test_ticket14876(self):\n         self.assertQuerysetEqual(q1, [\"<Item: i1>\"])\n         self.assertEqual(str(q1.query), str(q2.query))\n \n+    def test_combine_join_reuse(self):\n+        # Test that we correctly recreate joins having identical connections\n+        # in the rhs query, in case the query is ORed together. Related to\n+        # ticket #18748\n+        Report.objects.create(name='r4', creator=self.a1)\n+        q1 = Author.objects.filter(report__name='r5')\n+        q2 = Author.objects.filter(report__name='r4').filter(report__name='r1')\n+        combined = q1|q2\n+        self.assertEquals(str(combined.query).count('JOIN'), 2)\n+        self.assertEquals(len(combined), 1)\n+        self.assertEquals(combined[0].name, 'a1')\n+\n     def test_ticket7095(self):\n         # Updates that are filtered on the model being updated are somewhat\n         # tricky in MySQL. This exercises that case."
        }
    ],
    "stats": {
        "total": 309,
        "additions": 98,
        "deletions": 211
    }
}