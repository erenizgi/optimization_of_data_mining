{
    "author": "jphalip",
    "message": "Disentangled some parts of the admin ChangeList and ListFilter's internals. With this refactoring, the query string lookups are now processed once instead of twice and some bugs (in particular the SimpleListFilter parameter name being mistaken for a model field in some cases) are avoided.\n\nRefs #17091.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17145 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "a89b15628429da79dd47c04bd191de566ef7eee6",
    "files": [
        {
            "sha": "b2d74ce671f4e0de9fba8475c131ebc745a4ae20",
            "filename": "django/contrib/admin/filters.py",
            "status": "modified",
            "additions": 68,
            "deletions": 71,
            "changes": 139,
            "blob_url": "https://github.com/django/django/blob/a89b15628429da79dd47c04bd191de566ef7eee6/django%2Fcontrib%2Fadmin%2Ffilters.py",
            "raw_url": "https://github.com/django/django/raw/a89b15628429da79dd47c04bd191de566ef7eee6/django%2Fcontrib%2Fadmin%2Ffilters.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fadmin%2Ffilters.py?ref=a89b15628429da79dd47c04bd191de566ef7eee6",
            "patch": "@@ -13,21 +13,23 @@\n from django.utils.translation import ugettext_lazy as _\n \n from django.contrib.admin.util import (get_model_from_relation,\n-    reverse_field_path, get_limit_choices_to_from_path)\n+    reverse_field_path, get_limit_choices_to_from_path, prepare_lookup_value)\n \n class ListFilter(object):\n     title = None  # Human-readable title to appear in the right sidebar.\n \n     def __init__(self, request, params, model, model_admin):\n-        self.params = params\n+        # This dictionary will eventually contain the request's query string\n+        # parameters actually used by this filter.\n+        self.used_parameters = {}\n         if self.title is None:\n             raise ImproperlyConfigured(\n                 \"The list filter '%s' does not specify \"\n                 \"a 'title'.\" % self.__class__.__name__)\n \n     def has_output(self):\n         \"\"\"\n-        Returns True if some choices would be output for the filter.\n+        Returns True if some choices would be output for this filter.\n         \"\"\"\n         raise NotImplementedError\n \n@@ -43,15 +45,14 @@ def queryset(self, request, queryset):\n         \"\"\"\n         raise NotImplementedError\n \n-    def used_params(self):\n+    def expected_parameters(self):\n         \"\"\"\n-        Return a list of parameters to consume from the change list\n-        querystring.\n+        Returns the list of parameter names that are expected from the\n+        request's query string and that will be used by this filter.\n         \"\"\"\n         raise NotImplementedError\n \n \n-\n class SimpleListFilter(ListFilter):\n     # The parameter that should be used in the query string for that filter.\n     parameter_name = None\n@@ -67,24 +68,28 @@ def __init__(self, request, params, model, model_admin):\n         if lookup_choices is None:\n             lookup_choices = ()\n         self.lookup_choices = list(lookup_choices)\n+        if self.parameter_name in params:\n+            value = params.pop(self.parameter_name)\n+            self.used_parameters[self.parameter_name] = value\n \n     def has_output(self):\n         return len(self.lookup_choices) > 0\n \n     def value(self):\n         \"\"\"\n-        Returns the value given in the query string for this filter,\n-        if any. Returns None otherwise.\n+        Returns the value (in string format) provided in the request's\n+        query string for this filter, if any. If the value wasn't provided then\n+        returns None.\n         \"\"\"\n-        return self.params.get(self.parameter_name, None)\n+        return self.used_parameters.get(self.parameter_name, None)\n \n     def lookups(self, request, model_admin):\n         \"\"\"\n         Must be overriden to return a list of tuples (value, verbose value)\n         \"\"\"\n         raise NotImplementedError\n \n-    def used_params(self):\n+    def expected_parameters(self):\n         return [self.parameter_name]\n \n     def choices(self, cl):\n@@ -111,15 +116,18 @@ def __init__(self, field, request, params, model, model_admin, field_path):\n         self.field = field\n         self.field_path = field_path\n         self.title = getattr(field, 'verbose_name', field_path)\n-        super(FieldListFilter, self).__init__(request, params, model, model_admin)\n+        super(FieldListFilter, self).__init__(\n+            request, params, model, model_admin)\n+        for p in self.expected_parameters():\n+            if p in params:\n+                value = params.pop(p)\n+                self.used_parameters[p] = prepare_lookup_value(p, value)\n \n     def has_output(self):\n         return True\n \n     def queryset(self, request, queryset):\n-        for p in self.used_params():\n-            if p in self.params:\n-                return queryset.filter(**{p: self.params[p]})\n+        return queryset.filter(**self.used_parameters)\n \n     @classmethod\n     def register(cls, test, list_filter_class, take_priority=False):\n@@ -144,20 +152,20 @@ def create(cls, field, request, params, model, model_admin, field_path):\n \n class RelatedFieldListFilter(FieldListFilter):\n     def __init__(self, field, request, params, model, model_admin, field_path):\n-        super(RelatedFieldListFilter, self).__init__(\n-            field, request, params, model, model_admin, field_path)\n         other_model = get_model_from_relation(field)\n-        if hasattr(field, 'verbose_name'):\n-            self.lookup_title = field.verbose_name\n-        else:\n-            self.lookup_title = other_model._meta.verbose_name\n         rel_name = other_model._meta.pk.name\n-        self.lookup_kwarg = '%s__%s__exact' % (self.field_path, rel_name)\n-        self.lookup_kwarg_isnull = '%s__isnull' % (self.field_path)\n+        self.lookup_kwarg = '%s__%s__exact' % (field_path, rel_name)\n+        self.lookup_kwarg_isnull = '%s__isnull' % field_path\n         self.lookup_val = request.GET.get(self.lookup_kwarg, None)\n         self.lookup_val_isnull = request.GET.get(\n                                       self.lookup_kwarg_isnull, None)\n         self.lookup_choices = field.get_choices(include_blank=False)\n+        super(RelatedFieldListFilter, self).__init__(\n+            field, request, params, model, model_admin, field_path)\n+        if hasattr(field, 'verbose_name'):\n+            self.lookup_title = field.verbose_name\n+        else:\n+            self.lookup_title = other_model._meta.verbose_name\n         self.title = self.lookup_title\n \n     def has_output(self):\n@@ -169,7 +177,7 @@ def has_output(self):\n             extra = 0\n         return len(self.lookup_choices) + extra > 1\n \n-    def used_params(self):\n+    def expected_parameters(self):\n         return [self.lookup_kwarg, self.lookup_kwarg_isnull]\n \n     def choices(self, cl):\n@@ -206,14 +214,14 @@ def choices(self, cl):\n \n class BooleanFieldListFilter(FieldListFilter):\n     def __init__(self, field, request, params, model, model_admin, field_path):\n-        super(BooleanFieldListFilter, self).__init__(field,\n-            request, params, model, model_admin, field_path)\n-        self.lookup_kwarg = '%s__exact' % self.field_path\n-        self.lookup_kwarg2 = '%s__isnull' % self.field_path\n+        self.lookup_kwarg = '%s__exact' % field_path\n+        self.lookup_kwarg2 = '%s__isnull' % field_path\n         self.lookup_val = request.GET.get(self.lookup_kwarg, None)\n         self.lookup_val2 = request.GET.get(self.lookup_kwarg2, None)\n+        super(BooleanFieldListFilter, self).__init__(field,\n+            request, params, model, model_admin, field_path)\n \n-    def used_params(self):\n+    def expected_parameters(self):\n         return [self.lookup_kwarg, self.lookup_kwarg2]\n \n     def choices(self, cl):\n@@ -243,12 +251,12 @@ def choices(self, cl):\n \n class ChoicesFieldListFilter(FieldListFilter):\n     def __init__(self, field, request, params, model, model_admin, field_path):\n+        self.lookup_kwarg = '%s__exact' % field_path\n+        self.lookup_val = request.GET.get(self.lookup_kwarg)\n         super(ChoicesFieldListFilter, self).__init__(\n             field, request, params, model, model_admin, field_path)\n-        self.lookup_kwarg = '%s__exact' % self.field_path\n-        self.lookup_val = request.GET.get(self.lookup_kwarg)\n \n-    def used_params(self):\n+    def expected_parameters(self):\n         return [self.lookup_kwarg]\n \n     def choices(self, cl):\n@@ -260,7 +268,8 @@ def choices(self, cl):\n         for lookup, title in self.field.flatchoices:\n             yield {\n                 'selected': smart_unicode(lookup) == self.lookup_val,\n-                'query_string': cl.get_query_string({self.lookup_kwarg: lookup}),\n+                'query_string': cl.get_query_string({\n+                                    self.lookup_kwarg: lookup}),\n                 'display': title,\n             }\n \n@@ -269,25 +278,19 @@ def choices(self, cl):\n \n class DateFieldListFilter(FieldListFilter):\n     def __init__(self, field, request, params, model, model_admin, field_path):\n-        super(DateFieldListFilter, self).__init__(\n-            field, request, params, model, model_admin, field_path)\n-\n-        self.field_generic = '%s__' % self.field_path\n+        self.field_generic = '%s__' % field_path\n         self.date_params = dict([(k, v) for k, v in params.items()\n                                  if k.startswith(self.field_generic)])\n-\n         today = datetime.date.today()\n         one_week_ago = today - datetime.timedelta(days=7)\n         today_str = str(today)\n-        if isinstance(self.field, models.DateTimeField):\n+        if isinstance(field, models.DateTimeField):\n             today_str += ' 23:59:59'\n-\n-        self.lookup_kwarg_year = '%s__year' % self.field_path\n-        self.lookup_kwarg_month = '%s__month' % self.field_path\n-        self.lookup_kwarg_day = '%s__day' % self.field_path\n-        self.lookup_kwarg_past_7_days_gte = '%s__gte' % self.field_path\n-        self.lookup_kwarg_past_7_days_lte = '%s__lte' % self.field_path\n-\n+        self.lookup_kwarg_year = '%s__year' % field_path\n+        self.lookup_kwarg_month = '%s__month' % field_path\n+        self.lookup_kwarg_day = '%s__day' % field_path\n+        self.lookup_kwarg_past_7_days_gte = '%s__gte' % field_path\n+        self.lookup_kwarg_past_7_days_lte = '%s__lte' % field_path\n         self.links = (\n             (_('Any date'), {}),\n             (_('Today'), {\n@@ -307,31 +310,22 @@ def __init__(self, field, request, params, model, model_admin, field_path):\n                 self.lookup_kwarg_year: str(today.year),\n             }),\n         )\n+        super(DateFieldListFilter, self).__init__(\n+            field, request, params, model, model_admin, field_path)\n \n-    def used_params(self):\n+    def expected_parameters(self):\n         return [\n-            self.lookup_kwarg_year, self.lookup_kwarg_month, self.lookup_kwarg_day,\n-            self.lookup_kwarg_past_7_days_gte, self.lookup_kwarg_past_7_days_lte\n+            self.lookup_kwarg_year, self.lookup_kwarg_month,\n+            self.lookup_kwarg_day, self.lookup_kwarg_past_7_days_gte,\n+            self.lookup_kwarg_past_7_days_lte\n         ]\n \n-    def queryset(self, request, queryset):\n-        \"\"\"\n-        Override the default behaviour since there can be multiple query\n-        string parameters used for the same date filter (e.g. year + month).\n-        \"\"\"\n-        query_dict = {}\n-        for p in self.used_params():\n-            if p in self.params:\n-                query_dict[p] = self.params[p]\n-        if len(query_dict):\n-            return queryset.filter(**query_dict)\n-\n     def choices(self, cl):\n         for title, param_dict in self.links:\n             yield {\n                 'selected': self.date_params == param_dict,\n                 'query_string': cl.get_query_string(\n-                    param_dict, [self.field_generic]),\n+                                    param_dict, [self.field_generic]),\n                 'display': title,\n             }\n \n@@ -344,24 +338,27 @@ def choices(self, cl):\n # more appropriate, and the AllValuesFieldListFilter won't get used for it.\n class AllValuesFieldListFilter(FieldListFilter):\n     def __init__(self, field, request, params, model, model_admin, field_path):\n-        super(AllValuesFieldListFilter, self).__init__(\n-            field, request, params, model, model_admin, field_path)\n-        self.lookup_kwarg = self.field_path\n-        self.lookup_kwarg_isnull = '%s__isnull' % self.field_path\n+        self.lookup_kwarg = field_path\n+        self.lookup_kwarg_isnull = '%s__isnull' % field_path\n         self.lookup_val = request.GET.get(self.lookup_kwarg, None)\n-        self.lookup_val_isnull = request.GET.get(self.lookup_kwarg_isnull, None)\n-        parent_model, reverse_path = reverse_field_path(model, self.field_path)\n+        self.lookup_val_isnull = request.GET.get(self.lookup_kwarg_isnull,\n+                                                 None)\n+        parent_model, reverse_path = reverse_field_path(model, field_path)\n         queryset = parent_model._default_manager.all()\n         # optional feature: limit choices base on existing relationships\n         # queryset = queryset.complex_filter(\n         #    {'%s__isnull' % reverse_path: False})\n         limit_choices_to = get_limit_choices_to_from_path(model, field_path)\n         queryset = queryset.filter(limit_choices_to)\n \n-        self.lookup_choices = queryset.distinct(\n-            ).order_by(field.name).values_list(field.name, flat=True)\n+        self.lookup_choices = (queryset\n+                               .distinct()\n+                               .order_by(field.name)\n+                               .values_list(field.name, flat=True))\n+        super(AllValuesFieldListFilter, self).__init__(\n+            field, request, params, model, model_admin, field_path)\n \n-    def used_params(self):\n+    def expected_parameters(self):\n         return [self.lookup_kwarg, self.lookup_kwarg_isnull]\n \n     def choices(self, cl):"
        },
        {
            "sha": "61182a6d02bfdb0f5cea7c057f49655edf24f8f5",
            "filename": "django/contrib/admin/util.py",
            "status": "modified",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/django/django/blob/a89b15628429da79dd47c04bd191de566ef7eee6/django%2Fcontrib%2Fadmin%2Futil.py",
            "raw_url": "https://github.com/django/django/raw/a89b15628429da79dd47c04bd191de566ef7eee6/django%2Fcontrib%2Fadmin%2Futil.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fadmin%2Futil.py?ref=a89b15628429da79dd47c04bd191de566ef7eee6",
            "patch": "@@ -12,6 +12,33 @@\n from django.utils.translation import ungettext\n from django.core.urlresolvers import reverse\n \n+def lookup_needs_distinct(opts, lookup_path):\n+    \"\"\"\n+    Returns True if 'distinct()' should be used to query the given lookup path.\n+    \"\"\"\n+    field_name = lookup_path.split('__', 1)[0]\n+    field = opts.get_field_by_name(field_name)[0]\n+    if ((hasattr(field, 'rel') and\n+         isinstance(field.rel, models.ManyToManyRel)) or\n+        (isinstance(field, models.related.RelatedObject) and\n+         not field.field.unique)):\n+         return True\n+    return False\n+\n+def prepare_lookup_value(key, value):\n+    \"\"\"\n+    Returns a lookup value prepared to be used in queryset filtering.\n+    \"\"\"\n+    # if key ends with __in, split parameter into separate values\n+    if key.endswith('__in'):\n+        value = value.split(',')\n+    # if key ends with __isnull, special case '' and false\n+    if key.endswith('__isnull'):\n+        if value.lower() in ('', 'false'):\n+            value = False\n+        else:\n+            value = True\n+    return value\n \n def quote(s):\n     \"\"\""
        },
        {
            "sha": "32113f56eba4ea3b61b910c91f5c8743e5bf31a3",
            "filename": "django/contrib/admin/views/main.py",
            "status": "modified",
            "additions": 63,
            "deletions": 82,
            "changes": 145,
            "blob_url": "https://github.com/django/django/blob/a89b15628429da79dd47c04bd191de566ef7eee6/django%2Fcontrib%2Fadmin%2Fviews%2Fmain.py",
            "raw_url": "https://github.com/django/django/raw/a89b15628429da79dd47c04bd191de566ef7eee6/django%2Fcontrib%2Fadmin%2Fviews%2Fmain.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fadmin%2Fviews%2Fmain.py?ref=a89b15628429da79dd47c04bd191de566ef7eee6",
            "patch": "@@ -1,6 +1,6 @@\n import operator\n \n-from django.core.exceptions import SuspiciousOperation\n+from django.core.exceptions import SuspiciousOperation, ImproperlyConfigured\n from django.core.paginator import InvalidPage\n from django.db import models\n from django.utils.datastructures import SortedDict\n@@ -10,7 +10,8 @@\n \n from django.contrib.admin import FieldListFilter\n from django.contrib.admin.options import IncorrectLookupParameters\n-from django.contrib.admin.util import quote, get_fields_from_path\n+from django.contrib.admin.util import (quote, get_fields_from_path,\n+    lookup_needs_distinct, prepare_lookup_value)\n \n # Changelist settings\n ALL_VAR = 'all'\n@@ -28,14 +29,6 @@\n # Text to display within change-list table cells if the value is blank.\n EMPTY_CHANGELIST_VALUE = ugettext_lazy('(None)')\n \n-def field_needs_distinct(field):\n-    if ((hasattr(field, 'rel') and\n-         isinstance(field.rel, models.ManyToManyRel)) or\n-        (isinstance(field, models.related.RelatedObject) and\n-         not field.field.unique)):\n-         return True\n-    return False\n-\n \n class ChangeList(object):\n     def __init__(self, request, model, list_display, list_display_links,\n@@ -84,14 +77,33 @@ def __init__(self, request, model, list_display, list_display_links,\n         self.title = title % force_unicode(self.opts.verbose_name)\n         self.pk_attname = self.lookup_opts.pk.attname\n \n-    def get_filters(self, request, use_distinct=False):\n+    def get_filters(self, request):\n+        lookup_params = self.params.copy() # a dictionary of the query string\n+        use_distinct = False\n+\n+        # Remove all the parameters that are globally and systematically\n+        # ignored.\n+        for ignored in IGNORED_PARAMS:\n+            if ignored in lookup_params:\n+                del lookup_params[ignored]\n+\n+        # Normalize the types of keys\n+        for key, value in lookup_params.items():\n+            if not isinstance(key, str):\n+                # 'key' will be used as a keyword argument later, so Python\n+                # requires it to be a string.\n+                del lookup_params[key]\n+                lookup_params[smart_str(key)] = value\n+\n+            if not self.model_admin.lookup_allowed(key, value):\n+                raise SuspiciousOperation(\"Filtering by %s not allowed\" % key)\n+\n         filter_specs = []\n-        cleaned_params, use_distinct = self.get_lookup_params(use_distinct)\n         if self.list_filter:\n             for list_filter in self.list_filter:\n                 if callable(list_filter):\n                     # This is simply a custom list filter class.\n-                    spec = list_filter(request, cleaned_params,\n+                    spec = list_filter(request, lookup_params,\n                         self.model, self.model_admin)\n                 else:\n                     field_path = None\n@@ -106,11 +118,26 @@ def get_filters(self, request, use_distinct=False):\n                     if not isinstance(field, models.Field):\n                         field_path = field\n                         field = get_fields_from_path(self.model, field_path)[-1]\n-                    spec = field_list_filter_class(field, request, cleaned_params,\n+                    spec = field_list_filter_class(field, request, lookup_params,\n                         self.model, self.model_admin, field_path=field_path)\n+                    # Check if we need to use distinct()\n+                    use_distinct = (use_distinct or\n+                                    lookup_needs_distinct(self.lookup_opts,\n+                                                          field_path))\n                 if spec and spec.has_output():\n                     filter_specs.append(spec)\n-        return filter_specs, bool(filter_specs)\n+\n+        # At this point, all the parameters used by the various ListFilters\n+        # have been removed from lookup_params, which now only contains other\n+        # parameters passed via the query string. We now loop through the\n+        # remaining parameters both to ensure that all the parameters are valid\n+        # fields and to determine if at least one of them needs distinct().\n+        for key, value in lookup_params.items():\n+            lookup_params[key] = prepare_lookup_value(key, value)\n+            use_distinct = (use_distinct or\n+                            lookup_needs_distinct(self.lookup_opts, key))\n+\n+        return filter_specs, bool(filter_specs), lookup_params, use_distinct\n \n     def get_query_string(self, new_params=None, remove=None):\n         if new_params is None: new_params = {}\n@@ -247,78 +274,34 @@ def get_ordering_field_columns(self):\n                 ordering_fields[idx] = 'desc' if pfx == '-' else 'asc'\n         return ordering_fields\n \n-    def get_lookup_params(self, use_distinct=False):\n-        lookup_params = self.params.copy() # a dictionary of the query string\n-\n-        for ignored in IGNORED_PARAMS:\n-            if ignored in lookup_params:\n-                del lookup_params[ignored]\n-\n-        for key, value in lookup_params.items():\n-            if not isinstance(key, str):\n-                # 'key' will be used as a keyword argument later, so Python\n-                # requires it to be a string.\n-                del lookup_params[key]\n-                lookup_params[smart_str(key)] = value\n-\n-            field = None\n-            if not use_distinct:\n-                # Check if it's a relationship that might return more than one\n-                # instance\n-                field_name = key.split('__', 1)[0]\n-                try:\n-                    field = self.lookup_opts.get_field_by_name(field_name)[0]\n-                    use_distinct = field_needs_distinct(field)\n-                except models.FieldDoesNotExist:\n-                    # It might be a custom NonFieldFilter\n-                    pass\n-\n-            # if key ends with __in, split parameter into separate values\n-            if key.endswith('__in'):\n-                value = value.split(',')\n-                lookup_params[key] = value\n-\n-            # if key ends with __isnull, special case '' and false\n-            if key.endswith('__isnull'):\n-                if value.lower() in ('', 'false'):\n-                    value = False\n-                else:\n-                    value = True\n-                lookup_params[key] = value\n-\n-            if field and not self.model_admin.lookup_allowed(key, value):\n-                raise SuspiciousOperation(\"Filtering by %s not allowed\" % key)\n-\n-        return lookup_params, use_distinct\n-\n     def get_query_set(self, request):\n-        lookup_params, use_distinct = self.get_lookup_params(use_distinct=False)\n-        self.filter_specs, self.has_filters = self.get_filters(request, use_distinct)\n-\n         try:\n-            # First, let every list filter modify the qs and params to its\n-            # liking.\n+            # First, we collect all the declared list filters.\n+            (self.filter_specs, self.has_filters, remaining_lookup_params,\n+             use_distinct) = self.get_filters(request)\n+\n+            # Then, we let every list filter modify the qs to its liking.\n             qs = self.root_query_set\n             for filter_spec in self.filter_specs:\n                 new_qs = filter_spec.queryset(request, qs)\n                 if new_qs is not None:\n                     qs = new_qs\n-                    for param in filter_spec.used_params():\n-                        try:\n-                            del lookup_params[param]\n-                        except KeyError:\n-                            pass\n-\n-            # Then, apply the remaining lookup parameters from the query string\n-            # (i.e. those that haven't already been processed by the filters).\n-            qs = qs.filter(**lookup_params)\n+\n+            # Finally, we apply the remaining lookup parameters from the query\n+            # string (i.e. those that haven't already been processed by the\n+            # filters).\n+            qs = qs.filter(**remaining_lookup_params)\n+        except (SuspiciousOperation, ImproperlyConfigured):\n+            # Allow certain types of errors to be re-raised as-is so that the\n+            # caller can treat them in a special way.\n+            raise\n         except Exception, e:\n-            # Naked except! Because we don't have any other way of validating\n-            # \"lookup_params\". They might be invalid if the keyword arguments\n-            # are incorrect, or if the values are not in the correct type, so\n-            # we might get FieldError, ValueError, ValicationError, or ? from a\n-            # custom field that raises yet something else when handed\n-            # impossible data.\n+            # Every other error is caught with a naked except, because we don't\n+            # have any other way of validating lookup parameters. They might be\n+            # invalid if the keyword arguments are incorrect, or if the values\n+            # are not in the correct type, so we might get FieldError,\n+            # ValueError, ValidationError, or ? from a custom field that raises\n+            # yet something else when handed impossible data.\n             raise IncorrectLookupParameters(e)\n \n         # Use select_related() if one of the list_display options is a field\n@@ -362,9 +345,7 @@ def construct_search(field_name):\n                 qs = qs.filter(reduce(operator.or_, or_queries))\n             if not use_distinct:\n                 for search_spec in orm_lookups:\n-                    field_name = search_spec.split('__', 1)[0]\n-                    f = self.lookup_opts.get_field_by_name(field_name)[0]\n-                    if field_needs_distinct(f):\n+                    if lookup_needs_distinct(self.lookup_opts, search_spec):\n                         use_distinct = True\n                         break\n "
        },
        {
            "sha": "4988e57e617bdb6a1aacb5d3fecba41501b5e46c",
            "filename": "tests/regressiontests/admin_filters/tests.py",
            "status": "modified",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/django/django/blob/a89b15628429da79dd47c04bd191de566ef7eee6/tests%2Fregressiontests%2Fadmin_filters%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/a89b15628429da79dd47c04bd191de566ef7eee6/tests%2Fregressiontests%2Fadmin_filters%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fadmin_filters%2Ftests.py?ref=a89b15628429da79dd47c04bd191de566ef7eee6",
            "patch": "@@ -68,6 +68,14 @@ def lookups(self, request, model_admin):\n         if qs.filter(year__gte=2000, year__lte=2009).exists():\n             yield ('the 00s', \"the 2000's\")\n \n+class DecadeListFilterParameterEndsWith__In(DecadeListFilter):\n+    title = 'publication decade'\n+    parameter_name = 'decade__in' # Ends with '__in\"\n+\n+class DecadeListFilterParameterEndsWith__Isnull(DecadeListFilter):\n+    title = 'publication decade'\n+    parameter_name = 'decade__isnull' # Ends with '__isnull\"\n+\n class CustomUserAdmin(UserAdmin):\n     list_filter = ('books_authored', 'books_contributed')\n \n@@ -97,6 +105,12 @@ class DecadeFilterBookAdminWithFailingQueryset(ModelAdmin):\n class DecadeFilterBookAdminWithQuerysetBasedLookups(ModelAdmin):\n     list_filter = (DecadeListFilterWithQuerysetBasedLookups,)\n \n+class DecadeFilterBookAdminParameterEndsWith__In(ModelAdmin):\n+    list_filter = (DecadeListFilterParameterEndsWith__In,)\n+\n+class DecadeFilterBookAdminParameterEndsWith__Isnull(ModelAdmin):\n+    list_filter = (DecadeListFilterParameterEndsWith__Isnull,)\n+\n class ListFiltersTests(TestCase):\n \n     def setUp(self):\n@@ -570,3 +584,44 @@ def test_two_characters_long_field(self):\n         choices = list(filterspec.choices(changelist))\n         self.assertEqual(choices[2]['selected'], True)\n         self.assertEqual(choices[2]['query_string'], '?no=207')\n+\n+    def test_parameter_ends_with__in__or__isnull(self):\n+        \"\"\"\n+        Ensure that a SimpleListFilter's parameter name is not mistaken for a\n+        model field if it ends with '__isnull' or '__in'.\n+        Refs #17091.\n+        \"\"\"\n+\n+        # When it ends with '__in' -----------------------------------------\n+        modeladmin = DecadeFilterBookAdminParameterEndsWith__In(Book, site)\n+        request = self.request_factory.get('/', {'decade__in': 'the 90s'})\n+        changelist = self.get_changelist(request, Book, modeladmin)\n+\n+        # Make sure the correct queryset is returned\n+        queryset = changelist.get_query_set(request)\n+        self.assertEqual(list(queryset), [self.bio_book])\n+\n+        # Make sure the correct choice is selected\n+        filterspec = changelist.get_filters(request)[0][0]\n+        self.assertEqual(force_unicode(filterspec.title), u'publication decade')\n+        choices = list(filterspec.choices(changelist))\n+        self.assertEqual(choices[2]['display'], u'the 1990\\'s')\n+        self.assertEqual(choices[2]['selected'], True)\n+        self.assertEqual(choices[2]['query_string'], '?decade__in=the+90s')\n+\n+        # When it ends with '__isnull' ---------------------------------------\n+        modeladmin = DecadeFilterBookAdminParameterEndsWith__Isnull(Book, site)\n+        request = self.request_factory.get('/', {'decade__isnull': 'the 90s'})\n+        changelist = self.get_changelist(request, Book, modeladmin)\n+\n+        # Make sure the correct queryset is returned\n+        queryset = changelist.get_query_set(request)\n+        self.assertEqual(list(queryset), [self.bio_book])\n+\n+        # Make sure the correct choice is selected\n+        filterspec = changelist.get_filters(request)[0][0]\n+        self.assertEqual(force_unicode(filterspec.title), u'publication decade')\n+        choices = list(filterspec.choices(changelist))\n+        self.assertEqual(choices[2]['display'], u'the 1990\\'s')\n+        self.assertEqual(choices[2]['selected'], True)\n+        self.assertEqual(choices[2]['query_string'], '?decade__isnull=the+90s')\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 366,
        "additions": 213,
        "deletions": 153
    }
}