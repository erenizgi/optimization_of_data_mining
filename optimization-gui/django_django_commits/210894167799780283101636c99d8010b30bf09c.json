{
    "author": "timgraham",
    "message": "Fixed #16807 - Added a class-based views intro.\n\nThanks Preston Holmes for the text.",
    "sha": "210894167799780283101636c99d8010b30bf09c",
    "files": [
        {
            "sha": "b2fa93e05f27f21ab63e0e3f2d7d764c2c15d748",
            "filename": "docs/topics/class-based-views/index.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 65,
            "changes": 66,
            "blob_url": "https://github.com/django/django/blob/210894167799780283101636c99d8010b30bf09c/docs%2Ftopics%2Fclass-based-views%2Findex.txt",
            "raw_url": "https://github.com/django/django/raw/210894167799780283101636c99d8010b30bf09c/docs%2Ftopics%2Fclass-based-views%2Findex.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fclass-based-views%2Findex.txt?ref=210894167799780283101636c99d8010b30bf09c",
            "patch": "@@ -14,6 +14,7 @@ reusable views which suits your use case. For full details, see the\n .. toctree::\n    :maxdepth: 1\n \n+   intro\n    generic-display\n    generic-editing\n    mixins\n@@ -127,68 +128,3 @@ the client issues a ``HEAD`` request, the response has an empty body and\n the ``Last-Modified`` header indicates when the most recent book was published.\n Based on this information, the client may or may not download the full object\n list.\n-\n-Decorating class-based views\n-============================\n-\n-.. highlightlang:: python\n-\n-Since class-based views aren't functions, decorating them works differently\n-depending on if you're using ``as_view`` or creating a subclass.\n-\n-Decorating in URLconf\n----------------------\n-\n-The simplest way of decorating class-based views is to decorate the\n-result of the :meth:`~django.views.generic.base.View.as_view` method.\n-The easiest place to do this is in the URLconf where you deploy your view::\n-\n-    from django.contrib.auth.decorators import login_required, permission_required\n-    from django.views.generic import TemplateView\n-\n-    from .views import VoteView\n-\n-    urlpatterns = patterns('',\n-        (r'^about/', login_required(TemplateView.as_view(template_name=\"secret.html\"))),\n-        (r'^vote/', permission_required('polls.can_vote')(VoteView.as_view())),\n-    )\n-\n-This approach applies the decorator on a per-instance basis. If you\n-want every instance of a view to be decorated, you need to take a\n-different approach.\n-\n-.. _decorating-class-based-views:\n-\n-Decorating the class\n---------------------\n-\n-To decorate every instance of a class-based view, you need to decorate\n-the class definition itself. To do this you apply the decorator to the\n-:meth:`~django.views.generic.base.View.dispatch` method of the class.\n-\n-A method on a class isn't quite the same as a standalone function, so\n-you can't just apply a function decorator to the method -- you need to\n-transform it into a method decorator first. The ``method_decorator``\n-decorator transforms a function decorator into a method decorator so\n-that it can be used on an instance method. For example::\n-\n-    from django.contrib.auth.decorators import login_required\n-    from django.utils.decorators import method_decorator\n-    from django.views.generic import TemplateView\n-\n-    class ProtectedView(TemplateView):\n-        template_name = 'secret.html'\n-\n-        @method_decorator(login_required)\n-        def dispatch(self, *args, **kwargs):\n-            return super(ProtectedView, self).dispatch(*args, **kwargs)\n-\n-In this example, every instance of ``ProtectedView`` will have\n-login protection.\n-\n-.. note::\n-\n-    ``method_decorator`` passes ``*args`` and ``**kwargs``\n-    as parameters to the decorated method on the class. If your method\n-    does not accept a compatible set of parameters it will raise a\n-    ``TypeError`` exception."
        },
        {
            "sha": "5868b6be03abea232e980ab97b30195d71d08eaf",
            "filename": "docs/topics/class-based-views/intro.txt",
            "status": "added",
            "additions": 289,
            "deletions": 0,
            "changes": 289,
            "blob_url": "https://github.com/django/django/blob/210894167799780283101636c99d8010b30bf09c/docs%2Ftopics%2Fclass-based-views%2Fintro.txt",
            "raw_url": "https://github.com/django/django/raw/210894167799780283101636c99d8010b30bf09c/docs%2Ftopics%2Fclass-based-views%2Fintro.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fclass-based-views%2Fintro.txt?ref=210894167799780283101636c99d8010b30bf09c",
            "patch": "@@ -0,0 +1,289 @@\n+=================================\n+Introduction to Class-based views\n+=================================\n+\n+Class-based views provide an alternative way to implement views as Python\n+objects instead of functions. They do not replace function-based views, but\n+have certain differences and advantages when compared to function-based views:\n+\n+* Organization of code related to specific HTTP methods (``GET``, ``POST``,\n+  etc) can be addressed by separate methods instead of conditional branching.\n+\n+* Object oriented techniques such as mixins (multiple inheritance) can be\n+  used to factor code into reusable components.\n+\n+The relationship and history of generic views, class-based views, and class-based generic views\n+===============================================================================================\n+\n+In the beginning there was only the view function contract, Django passed your\n+function an :class:`~django.http.HttpRequest` and expected back an\n+:class:`~django.http.HttpResponse`. This was the extent of what Django provided.\n+\n+Early on it was recognized that there were common idioms and patterns found in\n+view development. Function-based generic views were introduced to abstract\n+these patterns and ease view development for the common cases.\n+\n+The problem with function-based generic views is that while they covered the\n+simple cases well, there was no way to extend or customize them beyond some\n+simple configuration options, limiting their usefulness in many real-world\n+applications.\n+\n+Class-based generic views were created with the same objective as\n+function-based generic views, to make view development easier. However, the way\n+the solution is implemented, through the use of mixins, provides a toolkit that\n+results in class-based generic views being more extensible and flexible than\n+their function-based counterparts.\n+\n+If you have tried function based generic views in the past and found them\n+lacking, you should not think of class-based generic views as simply a\n+class-based equivalent, but rather as a fresh approach to solving the original\n+problems that generic views were meant to solve.\n+\n+The toolkit of base classes and mixins that Django uses to build class-based\n+generic views are built for maximum flexibility, and as such have many hooks in\n+the form of default method implementations and attributes that you are unlikely\n+to be concerned with in the simplest use cases. For example, instead of\n+limiting you to a class based attribute for ``form_class``, the implementation\n+uses a ``get_form`` method, which calls a ``get_form_class`` method, which in\n+its default implementation just returns the ``form_class`` attribute of the\n+class. This gives you several options for specifying what form to use, from a\n+simple attribute, to a fully dynamic, callable hook. These options seem to add\n+hollow complexity for simple situations, but without them, more advanced\n+designs would be limited.\n+\n+Using class-based views\n+=======================\n+\n+At its core, a class-based view allows you to respond to different HTTP request\n+methods with different class instance methods, instead of with conditionally\n+branching code inside a single view function.\n+\n+So where the code to handle HTTP ``GET`` in a view function would look\n+something like::\n+\n+    from django.http import HttpResponse\n+\n+    def my_view(request):\n+        if request.method == 'GET':\n+            # <view logic>\n+            return HttpResponse('result')\n+\n+In a class-based view, this would become::\n+\n+    from django.http import HttpResponse\n+    from django.views.base import View\n+\n+    class MyView(View):\n+        def get(self, request):\n+            # <view logic>\n+            return HttpResponse('result')\n+\n+Because Django's URL resolver expects to send the request and associated\n+arguments to a callable function, not a class, class-based views have an\n+:meth:`~django.views.generic.base.View.as_view` class method which serves as\n+the callable entry point to your class. The ``as_view`` entry point creates an\n+instance of your class and calls its\n+:meth:`~django.views.generic.base.View.dispatch` method. ``dispatch`` looks at\n+the request to determine whether it is a ``GET``, ``POST``, etc, and relays the\n+request to a matching method if one is defined, or raises\n+:class:`~django.http.HttpResponseNotAllowed` if not::\n+\n+    # urls.py\n+    from django.conf.urls import patterns\n+    from myapp.views import MyView\n+\n+    urlpatterns = patterns('',\n+        (r'^about/', MyView.as_view()),\n+    )\n+\n+\n+It is worth noting that what your method returns is identical to what you\n+return from a function-based view, namely some form of\n+:class:`~django.http.HttpResponse`. This means that\n+:doc:`http shortcuts </topics/http/shortcuts>` or\n+:class:`~django.template.response.TemplateResponse` objects are valid to use\n+inside a class-based view.\n+\n+While a minimal class-based view does not require any class attributes to\n+perform its job, class attributes are useful in many class-based designs,\n+and there are two ways to configure or set class attributes.\n+\n+The first is the standard Python way of subclassing and overriding attributes\n+and methods in the subclass. So that if your parent class had an attribute\n+``greeting`` like this::\n+\n+    from django.http import HttpResponse\n+    from django.views.base import View\n+\n+    class GreetingView(View):\n+        greeting = \"Good Day\"\n+\n+        def get(self, request):\n+            return HttpResponse(self.greeting)\n+\n+You can override that in a subclass::\n+\n+    class MorningGreetingView(MyView):\n+        greeting = \"Morning to ya\"\n+\n+Another option is to configure class attributes as keyword arguments to the\n+:meth:`~django.views.generic.base.View.as_view` call in the URLconf::\n+\n+    urlpatterns = patterns('',\n+        (r'^about/', MyView.as_view(greeting=\"G'day\")),\n+    )\n+\n+.. note::\n+\n+    While your class is instantiated for each request dispatched to it, class\n+    attributes set through the\n+    :meth:`~django.views.generic.base.View.as_view` entry point are\n+    configured only once at the time your URLs are imported.\n+\n+Using mixins\n+============\n+\n+Mixins are a form of multiple inheritance where behaviors and attributes of\n+multiple parent classes can be combined.\n+\n+For example, in the generic class-based views there is a mixin called\n+:class:`~django.views.generic.base.TemplateResponseMixin` whose primary purpose\n+is to define the method\n+:meth:`~django.views.generic.base.TemplateResponseMixin.render_to_response`.\n+When combined with the behavior of the :class:`~django.views.generic.base.View`\n+base class, the result is a :class:`~django.views.generic.base.TemplateView`\n+class that will dispatch requests to the appropriate matching methods (a\n+behavior defined in the ``View`` base class), and that has a\n+:meth:`~django.views.generic.base.TemplateResponseMixin.render_to_response`\n+method that uses a\n+:attr:`~django.views.generic.base.TemplateResponseMixin.template_name`\n+attribute to return a :class:`~django.template.response.TemplateResponse`\n+object (a behavior defined in the ``TemplateResponseMixin``).\n+\n+Mixins are an excellent way of reusing code across multiple classes, but they\n+come with some cost. The more your code is scattered among mixins, the harder\n+it will be to read a child class and know what exactly it is doing, and the\n+harder it will be to know which methods from which mixins to override if you\n+are subclassing something that has a deep inheritance tree.\n+\n+Note also that you can only inherit from one generic view - that is, only one\n+parent class may inherit from :class:`~django.views.generic.base.View` and\n+the rest (if any) should be mixins. Trying to inherit from more than one class\n+that inherits from ``View`` - for example, trying to use a form at the top of a\n+list and combining :class:`~django.views.generic.edit.ProcessFormView` and\n+:class:`~django.views.generic.list.ListView` - won't work as expected.\n+\n+Handling forms with class-based views\n+=====================================\n+\n+A basic function-based view that handles forms may look something like this::\n+\n+    from django.http import HttpResponseRedirect\n+    from django.shortcuts import render\n+\n+    from .forms import MyForm\n+\n+    def myview(request):\n+        if request.method == \"POST\":\n+            form = MyForm(request.POST)\n+            if form.is_valid():\n+                # <process form cleaned data>\n+                return HttpResponseRedirect('/success/')\n+        else:\n+            form = MyForm(initial={'key': 'value'})\n+\n+        return render(request, 'form_template.html', {'form': form})\n+\n+A similar class-based view might look like::\n+\n+    from django.http import HttpResponseRedirect\n+    from django.shortcuts import render\n+\n+    from .forms import MyForm\n+\n+    class MyFormView(View):\n+        form_class = MyForm\n+        initial = {'key': 'value'}\n+        template_name = 'form_template.html'\n+\n+        def get(self, request, *args, **kwargs):\n+            form = self.form_class(initial=self.initial)\n+            return render(request,  self.template_name, {'form': form})\n+\n+        def post(self, request, *args, **kwargs):\n+            form = self.form_class(request.POST)\n+            if form.is_valid():\n+                # <process form cleaned data>\n+                return HttpResponseRedirect('/success/')\n+\n+            return render(request, self.template_name, {'form': form})\n+\n+This is a very simple case, but you can see that you would then have the option\n+of customizing this view by overriding any of the class attributes, e.g.\n+``form_class``, via URLconf configuration, or subclassing and overriding one or\n+more of the methods (or both!).\n+\n+Decorating class-based views\n+============================\n+\n+The extension of class-based views isn't limited to using mixins. You\n+can use also use decorators. Since class-based views aren't functions,\n+decorating them works differently depending on if you're using ``as_view`` or\n+creating a subclass.\n+\n+Decorating in URLconf\n+---------------------\n+\n+The simplest way of decorating class-based views is to decorate the\n+result of the :meth:`~django.views.generic.base.View.as_view` method.\n+The easiest place to do this is in the URLconf where you deploy your view::\n+\n+    from django.contrib.auth.decorators import login_required, permission_required\n+    from django.views.generic import TemplateView\n+\n+    from .views import VoteView\n+\n+    urlpatterns = patterns('',\n+        (r'^about/', login_required(TemplateView.as_view(template_name=\"secret.html\"))),\n+        (r'^vote/', permission_required('polls.can_vote')(VoteView.as_view())),\n+    )\n+\n+This approach applies the decorator on a per-instance basis. If you\n+want every instance of a view to be decorated, you need to take a\n+different approach.\n+\n+.. _decorating-class-based-views:\n+\n+Decorating the class\n+--------------------\n+\n+To decorate every instance of a class-based view, you need to decorate\n+the class definition itself. To do this you apply the decorator to the\n+:meth:`~django.views.generic.base.View.dispatch` method of the class.\n+\n+A method on a class isn't quite the same as a standalone function, so\n+you can't just apply a function decorator to the method -- you need to\n+transform it into a method decorator first. The ``method_decorator``\n+decorator transforms a function decorator into a method decorator so\n+that it can be used on an instance method. For example::\n+\n+    from django.contrib.auth.decorators import login_required\n+    from django.utils.decorators import method_decorator\n+    from django.views.generic import TemplateView\n+\n+    class ProtectedView(TemplateView):\n+        template_name = 'secret.html'\n+\n+        @method_decorator(login_required)\n+        def dispatch(self, *args, **kwargs):\n+            return super(ProtectedView, self).dispatch(*args, **kwargs)\n+\n+In this example, every instance of ``ProtectedView`` will have\n+login protection.\n+\n+.. note::\n+\n+    ``method_decorator`` passes ``*args`` and ``**kwargs``\n+    as parameters to the decorated method on the class. If your method\n+    does not accept a compatible set of parameters it will raise a\n+    ``TypeError`` exception."
        },
        {
            "sha": "2adbd406c79652af52702852f5b8137d8b8e6dd3",
            "filename": "docs/topics/class-based-views/mixins.txt",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/210894167799780283101636c99d8010b30bf09c/docs%2Ftopics%2Fclass-based-views%2Fmixins.txt",
            "raw_url": "https://github.com/django/django/raw/210894167799780283101636c99d8010b30bf09c/docs%2Ftopics%2Fclass-based-views%2Fmixins.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fclass-based-views%2Fmixins.txt?ref=210894167799780283101636c99d8010b30bf09c",
            "patch": "@@ -32,7 +32,6 @@ Two central mixins are provided that help in providing a consistent\n interface to working with templates in class-based views.\n \n :class:`~django.views.generic.base.TemplateResponseMixin`\n-\n     Every built in view which returns a\n     :class:`~django.template.response.TemplateResponse` will call the\n     :meth:`~django.views.generic.base.TemplateResponseMixin.render_to_response`"
        }
    ],
    "stats": {
        "total": 356,
        "additions": 290,
        "deletions": 66
    }
}