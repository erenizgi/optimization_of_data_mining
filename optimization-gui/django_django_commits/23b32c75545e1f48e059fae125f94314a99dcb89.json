{
    "author": "spookylukey",
    "message": "Fixed #15811 - lazy() doesn't take into account methods defined in parents\n\nThanks to abki for the report and patch.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16157 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "23b32c75545e1f48e059fae125f94314a99dcb89",
    "files": [
        {
            "sha": "21463bd5755a7004015072669ea9fa06125eace8",
            "filename": "django/utils/functional.py",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/23b32c75545e1f48e059fae125f94314a99dcb89/django%2Futils%2Ffunctional.py",
            "raw_url": "https://github.com/django/django/raw/23b32c75545e1f48e059fae125f94314a99dcb89/django%2Futils%2Ffunctional.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Ffunctional.py?ref=23b32c75545e1f48e059fae125f94314a99dcb89",
            "patch": "@@ -68,14 +68,15 @@ def __prepare_class__(cls):\n             cls.__dispatch = {}\n             for resultclass in resultclasses:\n                 cls.__dispatch[resultclass] = {}\n-                for (k, v) in resultclass.__dict__.items():\n-                    # All __promise__ return the same wrapper method, but they\n-                    # also do setup, inserting the method into the dispatch\n-                    # dict.\n-                    meth = cls.__promise__(resultclass, k, v)\n-                    if hasattr(cls, k):\n-                        continue\n-                    setattr(cls, k, meth)\n+                for type_ in reversed(resultclass.mro()):\n+                    for (k, v) in type_.__dict__.items():\n+                        # All __promise__ return the same wrapper method, but they\n+                        # also do setup, inserting the method into the dispatch\n+                        # dict.\n+                        meth = cls.__promise__(resultclass, k, v)\n+                        if hasattr(cls, k):\n+                            continue\n+                        setattr(cls, k, meth)\n             cls._delegate_str = str in resultclasses\n             cls._delegate_unicode = unicode in resultclasses\n             assert not (cls._delegate_str and cls._delegate_unicode), \"Cannot call lazy() with both str and unicode return types.\""
        },
        {
            "sha": "2784ddd7be50a059f4570b21785aeac0498d4bd3",
            "filename": "tests/regressiontests/utils/functional.py",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/23b32c75545e1f48e059fae125f94314a99dcb89/tests%2Fregressiontests%2Futils%2Ffunctional.py",
            "raw_url": "https://github.com/django/django/raw/23b32c75545e1f48e059fae125f94314a99dcb89/tests%2Fregressiontests%2Futils%2Ffunctional.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Futils%2Ffunctional.py?ref=23b32c75545e1f48e059fae125f94314a99dcb89",
            "patch": "@@ -7,3 +7,16 @@ def test_lazy(self):\n         t = lazy(lambda: tuple(range(3)), list, tuple)\n         for a, b in zip(t(), range(3)):\n             self.assertEqual(a, b)\n+\n+    def test_lazy_base_class(self):\n+        \"\"\"Test that lazy also finds base class methods in the proxy object\"\"\"\n+\n+        class Base(object):\n+            def base_method(self):\n+                pass\n+\n+        class Klazz(Base):\n+            pass\n+\n+        t = lazy(lambda: Klazz(), Klazz)()\n+        self.assertTrue('base_method' in dir(t))"
        }
    ],
    "stats": {
        "total": 30,
        "additions": 22,
        "deletions": 8
    }
}