{
    "author": "jezdez",
    "message": "Fixed #15785 -- Stopped HttpRequest.read() from reading beyond the end of a wsgi.input stream and removed some redundant code in the multipartparser. Thanks, tomchristie, grahamd and isagalaev.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16479 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "a6cd78662e72188555027a459cbff2564d72a221",
    "files": [
        {
            "sha": "14420fa7603d937b57c56b68228e3e5e6a4fe048",
            "filename": "django/core/handlers/wsgi.py",
            "status": "modified",
            "additions": 5,
            "deletions": 20,
            "changes": 25,
            "blob_url": "https://github.com/django/django/blob/a6cd78662e72188555027a459cbff2564d72a221/django%2Fcore%2Fhandlers%2Fwsgi.py",
            "raw_url": "https://github.com/django/django/raw/a6cd78662e72188555027a459cbff2564d72a221/django%2Fcore%2Fhandlers%2Fwsgi.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fhandlers%2Fwsgi.py?ref=a6cd78662e72188555027a459cbff2564d72a221",
            "patch": "@@ -135,26 +135,11 @@ def __init__(self, environ):\n         self.META['SCRIPT_NAME'] = script_name\n         self.method = environ['REQUEST_METHOD'].upper()\n         self._post_parse_error = False\n-        if type(socket._fileobject) is type and isinstance(self.environ['wsgi.input'], socket._fileobject):\n-            # Under development server 'wsgi.input' is an instance of\n-            # socket._fileobject which hangs indefinitely on reading bytes past\n-            # available count. To prevent this it's wrapped in LimitedStream\n-            # that doesn't read past Content-Length bytes.\n-            #\n-            # This is not done for other kinds of inputs (like flup's FastCGI\n-            # streams) beacuse they don't suffer from this problem and we can\n-            # avoid using another wrapper with its own .read and .readline\n-            # implementation.\n-            #\n-            # The type check is done because for some reason, AppEngine\n-            # implements _fileobject as a function, not a class.\n-            try:\n-                content_length = int(self.environ.get('CONTENT_LENGTH', 0))\n-            except (ValueError, TypeError):\n-                content_length = 0\n-            self._stream = LimitedStream(self.environ['wsgi.input'], content_length)\n-        else:\n-            self._stream = self.environ['wsgi.input']\n+        try:\n+            content_length = int(self.environ.get('CONTENT_LENGTH'))\n+        except (ValueError, TypeError):\n+            content_length = 0\n+        self._stream = LimitedStream(self.environ['wsgi.input'], content_length)\n         self._read_started = False\n \n     def get_full_path(self):"
        },
        {
            "sha": "e667f6a9fc35d18702c54a53bef0e2c06691b45e",
            "filename": "django/http/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 11,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/a6cd78662e72188555027a459cbff2564d72a221/django%2Fhttp%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/a6cd78662e72188555027a459cbff2564d72a221/django%2Fhttp%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2F__init__.py?ref=a6cd78662e72188555027a459cbff2564d72a221",
            "patch": "@@ -308,17 +308,7 @@ def _get_raw_post_data(self):\n         if not hasattr(self, '_raw_post_data'):\n             if self._read_started:\n                 raise Exception(\"You cannot access raw_post_data after reading from request's data stream\")\n-            try:\n-                content_length = int(self.META.get('CONTENT_LENGTH', 0))\n-            except (ValueError, TypeError):\n-                # If CONTENT_LENGTH was empty string or not an integer, don't\n-                # error out. We've also seen None passed in here (against all\n-                # specs, but see ticket #8259), so we handle TypeError as well.\n-                content_length = 0\n-            if content_length:\n-                self._raw_post_data = self.read(content_length)\n-            else:\n-                self._raw_post_data = self.read()\n+            self._raw_post_data = self.read()\n             self._stream = StringIO(self._raw_post_data)\n         return self._raw_post_data\n     raw_post_data = property(_get_raw_post_data)"
        },
        {
            "sha": "477a08c05a76dfb2c4ca007fdaba73700ceede2b",
            "filename": "django/http/multipartparser.py",
            "status": "modified",
            "additions": 5,
            "deletions": 31,
            "changes": 36,
            "blob_url": "https://github.com/django/django/blob/a6cd78662e72188555027a459cbff2564d72a221/django%2Fhttp%2Fmultipartparser.py",
            "raw_url": "https://github.com/django/django/raw/a6cd78662e72188555027a459cbff2564d72a221/django%2Fhttp%2Fmultipartparser.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2Fmultipartparser.py?ref=a6cd78662e72188555027a459cbff2564d72a221",
            "patch": "@@ -33,7 +33,7 @@ class MultiPartParser(object):\n     A rfc2388 multipart/form-data parser.\n \n     ``MultiValueDict.parse()`` reads the input stream in ``chunk_size`` chunks\n-    and returns a tuple of ``(MultiValueDict(POST), MultiValueDict(FILES))``. If\n+    and returns a tuple of ``(MultiValueDict(POST), MultiValueDict(FILES))``.\n     \"\"\"\n     def __init__(self, META, input_data, upload_handlers, encoding=None):\n         \"\"\"\n@@ -65,14 +65,11 @@ def __init__(self, META, input_data, upload_handlers, encoding=None):\n             raise MultiPartParserError('Invalid boundary in multipart: %s' % boundary)\n \n \n-        #\n         # Content-Length should contain the length of the body we are about\n         # to receive.\n-        #\n         try:\n             content_length = int(META.get('HTTP_CONTENT_LENGTH', META.get('CONTENT_LENGTH',0)))\n         except (ValueError, TypeError):\n-            # For now set it to 0; we'll try again later on down.\n             content_length = 0\n \n         if content_length < 0:\n@@ -110,12 +107,10 @@ def parse(self):\n         if self._content_length == 0:\n             return QueryDict(MultiValueDict(), encoding=self._encoding), MultiValueDict()\n \n-        limited_input_data = LimitBytes(self._input_data, self._content_length)\n-\n         # See if the handler will want to take care of the parsing.\n         # This allows overriding everything if somebody wants it.\n         for handler in handlers:\n-            result = handler.handle_raw_input(limited_input_data,\n+            result = handler.handle_raw_input(self._input_data,\n                                               self._meta,\n                                               self._content_length,\n                                               self._boundary,\n@@ -128,7 +123,7 @@ def parse(self):\n         self._files = MultiValueDict()\n \n         # Instantiate the parser and stream:\n-        stream = LazyStream(ChunkIter(limited_input_data, self._chunk_size))\n+        stream = LazyStream(ChunkIter(self._input_data, self._chunk_size))\n \n         # Whether or not to signal a file-completion at the beginning of the loop.\n         old_field_name = None\n@@ -225,10 +220,10 @@ def parse(self):\n                     exhaust(stream)\n         except StopUpload, e:\n             if not e.connection_reset:\n-                exhaust(limited_input_data)\n+                exhaust(self._input_data)\n         else:\n             # Make sure that the request data is all fed\n-            exhaust(limited_input_data)\n+            exhaust(self._input_data)\n \n         # Signal that the upload has completed.\n         for handler in handlers:\n@@ -390,27 +385,6 @@ def next(self):\n     def __iter__(self):\n         return self\n \n-class LimitBytes(object):\n-    \"\"\" Limit bytes for a file object. \"\"\"\n-    def __init__(self, fileobject, length):\n-        self._file = fileobject\n-        self.remaining = length\n-\n-    def read(self, num_bytes=None):\n-        \"\"\"\n-        Read data from the underlying file.\n-        If you ask for too much or there isn't anything left,\n-        this will raise an InputStreamExhausted error.\n-        \"\"\"\n-        if self.remaining <= 0:\n-            raise InputStreamExhausted()\n-        if num_bytes is None:\n-            num_bytes = self.remaining\n-        else:\n-            num_bytes = min(num_bytes, self.remaining)\n-        self.remaining -= num_bytes\n-        return self._file.read(num_bytes)\n-\n class InterBoundaryIter(object):\n     \"\"\"\n     A Producer that will iterate over boundaries."
        },
        {
            "sha": "6d79e2a451b7ee5572709b5a7f86b6ac92bf9f95",
            "filename": "tests/regressiontests/file_uploads/tests.py",
            "status": "modified",
            "additions": 42,
            "deletions": 1,
            "changes": 43,
            "blob_url": "https://github.com/django/django/blob/a6cd78662e72188555027a459cbff2564d72a221/tests%2Fregressiontests%2Ffile_uploads%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/a6cd78662e72188555027a459cbff2564d72a221/tests%2Fregressiontests%2Ffile_uploads%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ffile_uploads%2Ftests.py?ref=a6cd78662e72188555027a459cbff2564d72a221",
            "patch": "@@ -9,7 +9,7 @@\n \n from django.core.files import temp as tempfile\n from django.core.files.uploadedfile import SimpleUploadedFile\n-from django.http.multipartparser import MultiPartParser\n+from django.http.multipartparser import MultiPartParser, MultiPartParserError\n from django.test import TestCase, client\n from django.utils import simplejson\n from django.utils import unittest\n@@ -176,6 +176,47 @@ def test_filename_overflow(self):\n         got = simplejson.loads(self.client.request(**r).content)\n         self.assertTrue(len(got['file']) < 256, \"Got a long file name (%s characters).\" % len(got['file']))\n \n+    def test_truncated_multipart_handled_gracefully(self):\n+        \"\"\"\n+        If passed an incomplete multipart message, MultiPartParser does not\n+        attempt to read beyond the end of the stream, and simply will handle\n+        the part that can be parsed gracefully.\n+        \"\"\"\n+        payload = \"\\r\\n\".join([\n+            '--' + client.BOUNDARY,\n+            'Content-Disposition: form-data; name=\"file\"; filename=\"foo.txt\"',\n+            'Content-Type: application/octet-stream',\n+            '',\n+            'file contents'\n+            '--' + client.BOUNDARY + '--',\n+            '',\n+        ])\n+        payload = payload[:-10]\n+        r = {\n+            'CONTENT_LENGTH': len(payload),\n+            'CONTENT_TYPE': client.MULTIPART_CONTENT,\n+            'PATH_INFO': '/file_uploads/echo/',\n+            'REQUEST_METHOD': 'POST',\n+            'wsgi.input': client.FakePayload(payload),\n+        }\n+        got = simplejson.loads(self.client.request(**r).content)\n+        self.assertEquals(got, {})\n+\n+    def test_empty_multipart_handled_gracefully(self):\n+        \"\"\"\n+        If passed an empty multipart message, MultiPartParser will return\n+        an empty QueryDict.\n+        \"\"\"\n+        r = {\n+            'CONTENT_LENGTH': 0,\n+            'CONTENT_TYPE': client.MULTIPART_CONTENT,\n+            'PATH_INFO': '/file_uploads/echo/',\n+            'REQUEST_METHOD': 'POST',\n+            'wsgi.input': client.FakePayload(''),\n+        }\n+        got = simplejson.loads(self.client.request(**r).content)\n+        self.assertEquals(got, {})\n+\n     def test_custom_upload_handler(self):\n         # A small file (under the 5M quota)\n         smallfile = tempfile.NamedTemporaryFile()"
        },
        {
            "sha": "8bc81ffcf216b56a9ea55ed7e13310697af03bee",
            "filename": "tests/regressiontests/requests/tests.py",
            "status": "modified",
            "additions": 24,
            "deletions": 6,
            "changes": 30,
            "blob_url": "https://github.com/django/django/blob/a6cd78662e72188555027a459cbff2564d72a221/tests%2Fregressiontests%2Frequests%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/a6cd78662e72188555027a459cbff2564d72a221/tests%2Fregressiontests%2Frequests%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Frequests%2Ftests.py?ref=a6cd78662e72188555027a459cbff2564d72a221",
            "patch": "@@ -195,15 +195,21 @@ def test_limited_stream(self):\n         self.assertEqual(stream.read(), '')\n \n     def test_stream(self):\n-        request = WSGIRequest({'REQUEST_METHOD': 'POST', 'wsgi.input': StringIO('name=value')})\n+        payload = 'name=value'\n+        request = WSGIRequest({'REQUEST_METHOD': 'POST',\n+                               'CONTENT_LENGTH': len(payload),\n+                               'wsgi.input': StringIO(payload)})\n         self.assertEqual(request.read(), 'name=value')\n \n     def test_read_after_value(self):\n         \"\"\"\n         Reading from request is allowed after accessing request contents as\n         POST or raw_post_data.\n         \"\"\"\n-        request = WSGIRequest({'REQUEST_METHOD': 'POST', 'wsgi.input': StringIO('name=value')})\n+        payload = 'name=value'\n+        request = WSGIRequest({'REQUEST_METHOD': 'POST',\n+                               'CONTENT_LENGTH': len(payload),\n+                               'wsgi.input': StringIO(payload)})\n         self.assertEqual(request.POST, {u'name': [u'value']})\n         self.assertEqual(request.raw_post_data, 'name=value')\n         self.assertEqual(request.read(), 'name=value')\n@@ -213,7 +219,10 @@ def test_value_after_read(self):\n         Construction of POST or raw_post_data is not allowed after reading\n         from request.\n         \"\"\"\n-        request = WSGIRequest({'REQUEST_METHOD': 'POST', 'wsgi.input': StringIO('name=value')})\n+        payload = 'name=value'\n+        request = WSGIRequest({'REQUEST_METHOD': 'POST',\n+                               'CONTENT_LENGTH': len(payload),\n+                               'wsgi.input': StringIO(payload)})\n         self.assertEqual(request.read(2), 'na')\n         self.assertRaises(Exception, lambda: request.raw_post_data)\n         self.assertEqual(request.POST, {})\n@@ -261,14 +270,20 @@ def test_POST_multipart_with_content_length_zero(self):\n         self.assertEqual(request.POST, {})\n \n     def test_read_by_lines(self):\n-        request = WSGIRequest({'REQUEST_METHOD': 'POST', 'wsgi.input': StringIO('name=value')})\n+        payload = 'name=value'\n+        request = WSGIRequest({'REQUEST_METHOD': 'POST',\n+                               'CONTENT_LENGTH': len(payload),\n+                               'wsgi.input': StringIO(payload)})\n         self.assertEqual(list(request), ['name=value'])\n \n     def test_POST_after_raw_post_data_read(self):\n         \"\"\"\n         POST should be populated even if raw_post_data is read first\n         \"\"\"\n-        request = WSGIRequest({'REQUEST_METHOD': 'POST', 'wsgi.input': StringIO('name=value')})\n+        payload = 'name=value'\n+        request = WSGIRequest({'REQUEST_METHOD': 'POST',\n+                               'CONTENT_LENGTH': len(payload),\n+                               'wsgi.input': StringIO(payload)})\n         raw_data = request.raw_post_data\n         self.assertEqual(request.POST, {u'name': [u'value']})\n \n@@ -277,7 +292,10 @@ def test_POST_after_raw_post_data_read_and_stream_read(self):\n         POST should be populated even if raw_post_data is read first, and then\n         the stream is read second.\n         \"\"\"\n-        request = WSGIRequest({'REQUEST_METHOD': 'POST', 'wsgi.input': StringIO('name=value')})\n+        payload = 'name=value'\n+        request = WSGIRequest({'REQUEST_METHOD': 'POST',\n+                               'CONTENT_LENGTH': len(payload),\n+                               'wsgi.input': StringIO(payload)})\n         raw_data = request.raw_post_data\n         self.assertEqual(request.read(1), u'n')\n         self.assertEqual(request.POST, {u'name': [u'value']})"
        },
        {
            "sha": "8e840e49823e026350bcd98b5389b07116331e72",
            "filename": "tests/regressiontests/test_client_regress/models.py",
            "status": "modified",
            "additions": 38,
            "deletions": 8,
            "changes": 46,
            "blob_url": "https://github.com/django/django/blob/a6cd78662e72188555027a459cbff2564d72a221/tests%2Fregressiontests%2Ftest_client_regress%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/a6cd78662e72188555027a459cbff2564d72a221/tests%2Fregressiontests%2Ftest_client_regress%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftest_client_regress%2Fmodels.py?ref=a6cd78662e72188555027a459cbff2564d72a221",
            "patch": "@@ -913,14 +913,44 @@ def test_response_no_template(self):\n         response = self.client.get(\"/test_client_regress/request_methods/\")\n         self.assertEqual(response.template, None)\n \n-class RawPostDataTest(TestCase):\n-    \"Access to request.raw_post_data from the test client.\"\n-    def test_raw_post_data(self):\n-        # Refs #14753\n-        try:\n-            response = self.client.get(\"/test_client_regress/raw_post_data/\")\n-        except AssertionError:\n-            self.fail(\"Accessing request.raw_post_data from a view fetched with GET by the test client shouldn't fail.\")\n+\n+class ReadLimitedStreamTest(TestCase):\n+    \"\"\"\n+    Tests that ensure that HttpRequest.raw_post_data, HttpRequest.read() and\n+    HttpRequest.read(BUFFER) have proper LimitedStream behaviour.\n+\n+    Refs #14753, #15785\n+    \"\"\"\n+    def test_raw_post_data_from_empty_request(self):\n+        \"\"\"HttpRequest.raw_post_data on a test client GET request should return\n+        the empty string.\"\"\"\n+        self.assertEquals(self.client.get(\"/test_client_regress/raw_post_data/\").content, '')\n+\n+    def test_read_from_empty_request(self):\n+        \"\"\"HttpRequest.read() on a test client GET request should return the\n+        empty string.\"\"\"\n+        self.assertEquals(self.client.get(\"/test_client_regress/read_all/\").content, '')\n+\n+    def test_read_numbytes_from_empty_request(self):\n+        \"\"\"HttpRequest.read(LARGE_BUFFER) on a test client GET request should\n+        return the empty string.\"\"\"\n+        self.assertEquals(self.client.get(\"/test_client_regress/read_buffer/\").content, '')\n+\n+    def test_read_from_nonempty_request(self):\n+        \"\"\"HttpRequest.read() on a test client PUT request with some payload\n+        should return that payload.\"\"\"\n+        payload = 'foobar'\n+        self.assertEquals(self.client.put(\"/test_client_regress/read_all/\",\n+                                          data=payload,\n+                                          content_type='text/plain').content, payload)\n+\n+    def test_read_numbytes_from_nonempty_request(self):\n+        \"\"\"HttpRequest.read(LARGE_BUFFER) on a test client PUT request with\n+        some payload should return that payload.\"\"\"\n+        payload = 'foobar'\n+        self.assertEquals(self.client.put(\"/test_client_regress/read_buffer/\",\n+                                          data=payload,\n+                                          content_type='text/plain').content, payload)\n \n \n class RequestFactoryStateTest(TestCase):"
        },
        {
            "sha": "454f35b8240248ebd50b6895ca2ab440d147bb35",
            "filename": "tests/regressiontests/test_client_regress/urls.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/a6cd78662e72188555027a459cbff2564d72a221/tests%2Fregressiontests%2Ftest_client_regress%2Furls.py",
            "raw_url": "https://github.com/django/django/raw/a6cd78662e72188555027a459cbff2564d72a221/tests%2Fregressiontests%2Ftest_client_regress%2Furls.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftest_client_regress%2Furls.py?ref=a6cd78662e72188555027a459cbff2564d72a221",
            "patch": "@@ -27,5 +27,7 @@\n     (r'^check_headers/$', views.check_headers),\n     (r'^check_headers_redirect/$', RedirectView.as_view(url='/test_client_regress/check_headers/')),\n     (r'^raw_post_data/$', views.raw_post_data),\n+    (r'^read_all/$', views.read_all),\n+    (r'^read_buffer/$', views.read_buffer),\n     (r'^request_context_view/$', views.request_context_view),\n )"
        },
        {
            "sha": "b3982938b7794d437d992c160e9878deb19d58ed",
            "filename": "tests/regressiontests/test_client_regress/views.py",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/a6cd78662e72188555027a459cbff2564d72a221/tests%2Fregressiontests%2Ftest_client_regress%2Fviews.py",
            "raw_url": "https://github.com/django/django/raw/a6cd78662e72188555027a459cbff2564d72a221/tests%2Fregressiontests%2Ftest_client_regress%2Fviews.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftest_client_regress%2Fviews.py?ref=a6cd78662e72188555027a459cbff2564d72a221",
            "patch": "@@ -96,6 +96,14 @@ def raw_post_data(request):\n     \"A view that is requested with GET and accesses request.raw_post_data. Refs #14753.\"\n     return HttpResponse(request.raw_post_data)\n \n+def read_all(request):\n+    \"A view that is requested with accesses request.read().\"\n+    return HttpResponse(request.read())\n+\n+def read_buffer(request):\n+    \"A view that is requested with accesses request.read(LARGE_BUFFER).\"\n+    return HttpResponse(request.read(99999))\n+\n def request_context_view(request):\n     # Special attribute that won't be present on a plain HttpRequest\n     request.special_path = request.path"
        }
    ],
    "stats": {
        "total": 202,
        "additions": 125,
        "deletions": 77
    }
}