{
    "author": "aaugustin",
    "message": "[py3] Documented forwards-compatible aliases\n\nthat will be available as of version 1.4.2.",
    "sha": "e1a37d55374a399dee9c302419fbe9badd92abb0",
    "files": [
        {
            "sha": "d816db804681dbed4b988591bf05ef346542c3a2",
            "filename": "docs/topics/python3.txt",
            "status": "modified",
            "additions": 13,
            "deletions": 5,
            "changes": 18,
            "blob_url": "https://github.com/django/django/blob/e1a37d55374a399dee9c302419fbe9badd92abb0/docs%2Ftopics%2Fpython3.txt",
            "raw_url": "https://github.com/django/django/raw/e1a37d55374a399dee9c302419fbe9badd92abb0/docs%2Ftopics%2Fpython3.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fpython3.txt?ref=e1a37d55374a399dee9c302419fbe9badd92abb0",
            "patch": "@@ -25,10 +25,11 @@ free to chose another strategy for your own code, especially if you don't need\n to stay compatible with Python 2. But authors of pluggable applications are\n encouraged to use the same porting strategy as Django itself.\n \n-Writing compatible code is much easier if you target Python ≥ 2.6. You will\n-most likely take advantage of the compatibility functions introduced in Django\n-1.5, like :mod:`django.utils.six`, so your application will also require\n-Django ≥ 1.5.\n+Writing compatible code is much easier if you target Python ≥ 2.6. Django 1.5\n+introduces compatibility tools such as :mod:`django.utils.six`. For\n+convenience, forwards-compatible aliases were introduced in Django 1.4.2. If\n+your application takes advantage of these tools, it will require Django ≥\n+1.4.2.\n \n Obviously, writing compatible source code adds some overhead, and that can\n cause frustration. Django's developers have found that attempting to write\n@@ -102,6 +103,8 @@ Old name            New name\n For backwards compatibility, the old names still work on Python 2. Under\n Python 3, ``smart_str`` is an alias for ``smart_text``.\n \n+For forwards compatibility, the new names work as of Django 1.4.2.\n+\n .. note::\n \n     :mod:`django.utils.encoding` was deeply refactored in Django 1.5 to\n@@ -126,6 +129,8 @@ For backwards compatibility, the old names still work on Python 2. Under\n Python 3, ``EscapeString`` and ``SafeString`` are aliases for ``EscapeText``\n and ``SafeText`` respectively.\n \n+For forwards compatibility, the new names work as of Django 1.4.2.\n+\n :meth:`__str__` and :meth:`__unicode__` methods\n -----------------------------------------------\n \n@@ -166,6 +171,8 @@ On Python 3, the decorator is a no-op. On Python 2, it defines appropriate\n \n This technique is the best match for Django's porting philosophy.\n \n+For forwards compatibility, this decorator is available as of Django 1.4.2.\n+\n Finally, note that :meth:`__repr__` must return a :class:`str` on all versions\n of Python.\n \n@@ -317,7 +324,8 @@ Writing compatible code with six\n six_ is the canonical compatibility library for supporting Python 2 and 3 in\n a single codebase. Read its documentation!\n \n-:mod:`six` is bundled with Django: you can import it as :mod:`django.utils.six`.\n+:mod`six` is bundled with Django as of version 1.4.2. You can import it as\n+:mod`django.utils.six`.\n \n Here are the most common changes required to write compatible code.\n "
        }
    ],
    "stats": {
        "total": 18,
        "additions": 13,
        "deletions": 5
    }
}