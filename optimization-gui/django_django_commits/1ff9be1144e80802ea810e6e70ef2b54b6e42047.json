{
    "author": "jphalip",
    "message": "Fixed #17828 -- Ensured that when a list filter's `queryset()` method fails, it does so loudly instead of getting swallowed by a `IncorrectLookupParameters` exception. This also properly fixes #16705, which hadn't been addressed correctly in [16705].\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17763 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "1ff9be1144e80802ea810e6e70ef2b54b6e42047",
    "files": [
        {
            "sha": "73c2958103f989009c2b516660142c642d899774",
            "filename": "django/contrib/admin/options.py",
            "status": "modified",
            "additions": 9,
            "deletions": 11,
            "changes": 20,
            "blob_url": "https://github.com/django/django/blob/1ff9be1144e80802ea810e6e70ef2b54b6e42047/django%2Fcontrib%2Fadmin%2Foptions.py",
            "raw_url": "https://github.com/django/django/raw/1ff9be1144e80802ea810e6e70ef2b54b6e42047/django%2Fcontrib%2Fadmin%2Foptions.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fadmin%2Foptions.py?ref=1ff9be1144e80802ea810e6e70ef2b54b6e42047",
            "patch": "@@ -247,7 +247,12 @@ def lookup_allowed(self, lookup, value):\n         # the pk attribute name.\n         pk_attr_name = None\n         for part in parts[:-1]:\n-            field, _, _, _ = model._meta.get_field_by_name(part)\n+            try:\n+                field, _, _, _ = model._meta.get_field_by_name(part)\n+            except FieldDoesNotExist:\n+                # Lookups on non-existants fields are ok, since they're ignored\n+                # later.\n+                return True\n             if hasattr(field, 'rel'):\n                 model = field.rel.to\n                 pk_attr_name = model._meta.pk.name\n@@ -259,17 +264,10 @@ def lookup_allowed(self, lookup, value):\n         if pk_attr_name and len(parts) > 1 and parts[-1] == pk_attr_name:\n             parts.pop()\n \n-        try:\n-            self.model._meta.get_field_by_name(parts[0])\n-        except FieldDoesNotExist:\n-            # Lookups on non-existants fields are ok, since they're ignored\n-            # later.\n+        if len(parts) == 1:\n             return True\n-        else:\n-            if len(parts) == 1:\n-                return True\n-            clean_lookup = LOOKUP_SEP.join(parts)\n-            return clean_lookup in self.list_filter or clean_lookup == self.date_hierarchy\n+        clean_lookup = LOOKUP_SEP.join(parts)\n+        return clean_lookup in self.list_filter or clean_lookup == self.date_hierarchy\n \n     def has_add_permission(self, request):\n         \"\"\""
        },
        {
            "sha": "b11f9d566b935a4a683cb546067f2ca9285d9c08",
            "filename": "django/contrib/admin/views/main.py",
            "status": "modified",
            "additions": 22,
            "deletions": 19,
            "changes": 41,
            "blob_url": "https://github.com/django/django/blob/1ff9be1144e80802ea810e6e70ef2b54b6e42047/django%2Fcontrib%2Fadmin%2Fviews%2Fmain.py",
            "raw_url": "https://github.com/django/django/raw/1ff9be1144e80802ea810e6e70ef2b54b6e42047/django%2Fcontrib%2Fadmin%2Fviews%2Fmain.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fadmin%2Fviews%2Fmain.py?ref=1ff9be1144e80802ea810e6e70ef2b54b6e42047",
            "patch": "@@ -3,6 +3,7 @@\n from django.core.exceptions import SuspiciousOperation, ImproperlyConfigured\n from django.core.paginator import InvalidPage\n from django.db import models\n+from django.db.models.fields import FieldDoesNotExist\n from django.utils.datastructures import SortedDict\n from django.utils.encoding import force_unicode, smart_str\n from django.utils.translation import ugettext, ugettext_lazy\n@@ -130,13 +131,16 @@ def get_filters(self, request):\n         # have been removed from lookup_params, which now only contains other\n         # parameters passed via the query string. We now loop through the\n         # remaining parameters both to ensure that all the parameters are valid\n-        # fields and to determine if at least one of them needs distinct().\n-        for key, value in lookup_params.items():\n-            lookup_params[key] = prepare_lookup_value(key, value)\n-            use_distinct = (use_distinct or\n-                            lookup_needs_distinct(self.lookup_opts, key))\n-\n-        return filter_specs, bool(filter_specs), lookup_params, use_distinct\n+        # fields and to determine if at least one of them needs distinct(). If\n+        # the lookup parameters aren't real fields, then bail out.\n+        try:\n+            for key, value in lookup_params.items():\n+                lookup_params[key] = prepare_lookup_value(key, value)\n+                use_distinct = (use_distinct or\n+                                lookup_needs_distinct(self.lookup_opts, key))\n+            return filter_specs, bool(filter_specs), lookup_params, use_distinct\n+        except FieldDoesNotExist, e:\n+            raise IncorrectLookupParameters(e)\n \n     def get_query_string(self, new_params=None, remove=None):\n         if new_params is None: new_params = {}\n@@ -292,18 +296,18 @@ def get_ordering_field_columns(self):\n         return ordering_fields\n \n     def get_query_set(self, request):\n-        try:\n-            # First, we collect all the declared list filters.\n-            (self.filter_specs, self.has_filters, remaining_lookup_params,\n-             use_distinct) = self.get_filters(request)\n+        # First, we collect all the declared list filters.\n+        (self.filter_specs, self.has_filters, remaining_lookup_params,\n+         use_distinct) = self.get_filters(request)\n \n-            # Then, we let every list filter modify the qs to its liking.\n-            qs = self.root_query_set\n-            for filter_spec in self.filter_specs:\n-                new_qs = filter_spec.queryset(request, qs)\n-                if new_qs is not None:\n-                    qs = new_qs\n+        # Then, we let every list filter modify the queryset to its liking.\n+        qs = self.root_query_set\n+        for filter_spec in self.filter_specs:\n+            new_qs = filter_spec.queryset(request, qs)\n+            if new_qs is not None:\n+                qs = new_qs\n \n+        try:\n             # Finally, we apply the remaining lookup parameters from the query\n             # string (i.e. those that haven't already been processed by the\n             # filters).\n@@ -317,8 +321,7 @@ def get_query_set(self, request):\n             # have any other way of validating lookup parameters. They might be\n             # invalid if the keyword arguments are incorrect, or if the values\n             # are not in the correct type, so we might get FieldError,\n-            # ValueError, ValidationError, or ? from a custom field that raises\n-            # yet something else when handed impossible data.\n+            # ValueError, ValidationError, or ?.\n             raise IncorrectLookupParameters(e)\n \n         # Use select_related() if one of the list_display options is a field"
        },
        {
            "sha": "b42dfd700d7ecc8fcfeec0c86bf2ebe78b1e38e9",
            "filename": "tests/regressiontests/admin_filters/tests.py",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/1ff9be1144e80802ea810e6e70ef2b54b6e42047/tests%2Fregressiontests%2Fadmin_filters%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/1ff9be1144e80802ea810e6e70ef2b54b6e42047/tests%2Fregressiontests%2Fadmin_filters%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fadmin_filters%2Ftests.py?ref=1ff9be1144e80802ea810e6e70ef2b54b6e42047",
            "patch": "@@ -56,7 +56,7 @@ def lookups(self, request, model_admin):\n class DecadeListFilterWithFailingQueryset(DecadeListFilterWithTitleAndParameter):\n \n     def queryset(self, request, queryset):\n-        raise Exception\n+        raise 1/0\n \n class DecadeListFilterWithQuerysetBasedLookups(DecadeListFilterWithTitleAndParameter):\n \n@@ -77,6 +77,7 @@ class DecadeListFilterParameterEndsWith__Isnull(DecadeListFilter):\n     title = 'publication decade'\n     parameter_name = 'decade__isnull' # Ends with '__isnull\"\n \n+\n class CustomUserAdmin(UserAdmin):\n     list_filter = ('books_authored', 'books_contributed')\n \n@@ -112,6 +113,8 @@ class DecadeFilterBookAdminParameterEndsWith__In(ModelAdmin):\n class DecadeFilterBookAdminParameterEndsWith__Isnull(ModelAdmin):\n     list_filter = (DecadeListFilterParameterEndsWith__Isnull,)\n \n+\n+\n class ListFiltersTests(TestCase):\n \n     def setUp(self):\n@@ -542,14 +545,13 @@ def test_simplelistfilter_with_none_returning_lookups(self):\n \n     def test_filter_with_failing_queryset(self):\n         \"\"\"\n-        Ensure that a filter's failing queryset is interpreted as if incorrect\n-        lookup parameters were passed (therefore causing a 302 redirection to\n-        the changelist).\n-        Refs #16716, #16714.\n+        Ensure that when a filter's queryset method fails, it fails loudly and\n+        the corresponding exception doesn't get swallowed.\n+        Refs #17828.\n         \"\"\"\n         modeladmin = DecadeFilterBookAdminWithFailingQueryset(Book, site)\n         request = self.request_factory.get('/', {})\n-        self.assertRaises(IncorrectLookupParameters, self.get_changelist, request, Book, modeladmin)\n+        self.assertRaises(ZeroDivisionError, self.get_changelist, request, Book, modeladmin)\n \n     def test_simplelistfilter_with_queryset_based_lookups(self):\n         modeladmin = DecadeFilterBookAdminWithQuerysetBasedLookups(Book, site)"
        }
    ],
    "stats": {
        "total": 75,
        "additions": 39,
        "deletions": 36
    }
}