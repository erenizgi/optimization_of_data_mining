{
    "author": "akaariai",
    "message": "Fixed #10790 -- Refactored sql.Query.setup_joins()\n\nThis is a rather large refactoring. The \"lookup traversal\" code was\nsplitted out from the setup_joins. There is now names_to_path() method\nwhich does the lookup traveling, the actual work of setup_joins() is\ncalling names_to_path() and then adding the joins found into the query.\n\nAs a side effect it was possible to remove the \"process_extra\"\nfunctionality used by genric relations. This never worked for left\njoins. Now the extra restriction is appended directly to the join\ncondition instead of the where clause.\n\nTo generate the extra condition we need to have the join field\navailable in the compiler. This has the side-effect that we need more\nugly code in Query.__getstate__ and __setstate__ as Field objects\naren't pickleable.\n\nThe join trimming code got a big change - now we trim all direct joins\nand never trim reverse joins. This also fixes the problem in #10790\nwhich was join trimming in null filter cases.",
    "sha": "69597e5bcc89aadafd1b76abf7efab30ee0b8b1a",
    "files": [
        {
            "sha": "6aff07e5682ec4df775f510a78bf70a0a3c227d5",
            "filename": "django/contrib/contenttypes/generic.py",
            "status": "modified",
            "additions": 8,
            "deletions": 18,
            "changes": 26,
            "blob_url": "https://github.com/django/django/blob/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/django%2Fcontrib%2Fcontenttypes%2Fgeneric.py",
            "raw_url": "https://github.com/django/django/raw/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/django%2Fcontrib%2Fcontenttypes%2Fgeneric.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fcontenttypes%2Fgeneric.py?ref=69597e5bcc89aadafd1b76abf7efab30ee0b8b1a",
            "patch": "@@ -205,17 +205,16 @@ def db_type(self, connection):\n         # same db_type as well.\n         return None\n \n-    def extra_filters(self, pieces, pos, negate):\n+    def get_content_type(self):\n         \"\"\"\n-        Return an extra filter to the queryset so that the results are filtered\n-        on the appropriate content type.\n+        Returns the content type associated with this field's model.\n         \"\"\"\n-        if negate:\n-            return []\n-        content_type = ContentType.objects.get_for_model(self.model)\n-        prefix = \"__\".join(pieces[:pos + 1])\n-        return [(\"%s__%s\" % (prefix, self.content_type_field_name),\n-            content_type)]\n+        return ContentType.objects.get_for_model(self.model)\n+\n+    def get_extra_join_sql(self, connection, qn, lhs_alias, rhs_alias):\n+        extra_col = self.rel.to._meta.get_field_by_name(self.content_type_field_name)[0].column\n+        contenttype = self.get_content_type().pk\n+        return \" AND %s.%s = %%s\" % (qn(rhs_alias), qn(extra_col)), [contenttype]\n \n     def bulk_related_objects(self, objs, using=DEFAULT_DB_ALIAS):\n         \"\"\"\n@@ -246,9 +245,6 @@ def __get__(self, instance, instance_type=None):\n         if instance is None:\n             return self\n \n-        # This import is done here to avoid circular import importing this module\n-        from django.contrib.contenttypes.models import ContentType\n-\n         # Dynamically create a class that subclasses the related model's\n         # default manager.\n         rel_model = self.field.rel.to\n@@ -379,8 +375,6 @@ class BaseGenericInlineFormSet(BaseModelFormSet):\n \n     def __init__(self, data=None, files=None, instance=None, save_as_new=None,\n                  prefix=None, queryset=None):\n-        # Avoid a circular import.\n-        from django.contrib.contenttypes.models import ContentType\n         opts = self.model._meta\n         self.instance = instance\n         self.rel_name = '-'.join((\n@@ -409,8 +403,6 @@ def get_default_prefix(cls):\n         ))\n \n     def save_new(self, form, commit=True):\n-        # Avoid a circular import.\n-        from django.contrib.contenttypes.models import ContentType\n         kwargs = {\n             self.ct_field.get_attname(): ContentType.objects.get_for_model(self.instance).pk,\n             self.ct_fk_field.get_attname(): self.instance.pk,\n@@ -432,8 +424,6 @@ def generic_inlineformset_factory(model, form=ModelForm,\n     defaults ``content_type`` and ``object_id`` respectively.\n     \"\"\"\n     opts = model._meta\n-    # Avoid a circular import.\n-    from django.contrib.contenttypes.models import ContentType\n     # if there is no field called `ct_field` let the exception propagate\n     ct_field = opts.get_field(ct_field)\n     if not isinstance(ct_field, models.ForeignKey) or ct_field.rel.to != ContentType:"
        },
        {
            "sha": "4d846fb438fe5700066feefff8476541a4d53e20",
            "filename": "django/db/models/sql/compiler.py",
            "status": "modified",
            "additions": 18,
            "deletions": 10,
            "changes": 28,
            "blob_url": "https://github.com/django/django/blob/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py?ref=69597e5bcc89aadafd1b76abf7efab30ee0b8b1a",
            "patch": "@@ -274,7 +274,8 @@ def get_default_columns(self, with_aliases=False, col_aliases=None,\n                 except KeyError:\n                     link_field = opts.get_ancestor_link(model)\n                     alias = self.query.join((start_alias, model._meta.db_table,\n-                            link_field.column, model._meta.pk.column))\n+                            link_field.column, model._meta.pk.column),\n+                            join_field=link_field)\n                     seen[model] = alias\n             else:\n                 # If we're starting from the base model of the queryset, the\n@@ -448,8 +449,8 @@ def _setup_joins(self, pieces, opts, alias):\n         \"\"\"\n         if not alias:\n             alias = self.query.get_initial_alias()\n-        field, target, opts, joins, _, _ = self.query.setup_joins(pieces,\n-                opts, alias, REUSE_ALL)\n+        field, target, opts, joins, _ = self.query.setup_joins(\n+            pieces, opts, alias, REUSE_ALL)\n         # We will later on need to promote those joins that were added to the\n         # query afresh above.\n         joins_to_promote = [j for j in joins if self.query.alias_refcount[j] < 2]\n@@ -501,20 +502,27 @@ def get_from_clause(self):\n         qn = self.quote_name_unless_alias\n         qn2 = self.connection.ops.quote_name\n         first = True\n+        from_params = []\n         for alias in self.query.tables:\n             if not self.query.alias_refcount[alias]:\n                 continue\n             try:\n-                name, alias, join_type, lhs, lhs_col, col, nullable = self.query.alias_map[alias]\n+                name, alias, join_type, lhs, lhs_col, col, _, join_field = self.query.alias_map[alias]\n             except KeyError:\n                 # Extra tables can end up in self.tables, but not in the\n                 # alias_map if they aren't in a join. That's OK. We skip them.\n                 continue\n             alias_str = (alias != name and ' %s' % alias or '')\n             if join_type and not first:\n-                result.append('%s %s%s ON (%s.%s = %s.%s)'\n-                        % (join_type, qn(name), alias_str, qn(lhs),\n-                           qn2(lhs_col), qn(alias), qn2(col)))\n+                if join_field and hasattr(join_field, 'get_extra_join_sql'):\n+                    extra_cond, extra_params = join_field.get_extra_join_sql(\n+                        self.connection, qn, lhs, alias)\n+                    from_params.extend(extra_params)\n+                else:\n+                    extra_cond = \"\"\n+                result.append('%s %s%s ON (%s.%s = %s.%s%s)' %\n+                              (join_type, qn(name), alias_str, qn(lhs),\n+                               qn2(lhs_col), qn(alias), qn2(col), extra_cond))\n             else:\n                 connector = not first and ', ' or ''\n                 result.append('%s%s%s' % (connector, qn(name), alias_str))\n@@ -528,7 +536,7 @@ def get_from_clause(self):\n                 connector = not first and ', ' or ''\n                 result.append('%s%s' % (connector, qn(alias)))\n                 first = False\n-        return result, []\n+        return result, from_params\n \n     def get_grouping(self, ordering_group_by):\n         \"\"\"\n@@ -638,7 +646,7 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n \n             alias = self.query.join((alias, table, f.column,\n                     f.rel.get_related_field().column),\n-                    promote=promote)\n+                    promote=promote, join_field=f)\n             columns, aliases = self.get_default_columns(start_alias=alias,\n                     opts=f.rel.to._meta, as_pairs=True)\n             self.query.related_select_cols.extend(\n@@ -685,7 +693,7 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n                         alias_chain.append(alias)\n                 alias = self.query.join(\n                     (alias, table, f.rel.get_related_field().column, f.column),\n-                    promote=True\n+                    promote=True, join_field=f\n                 )\n                 from_parent = (opts.model if issubclass(model, opts.model)\n                                else None)"
        },
        {
            "sha": "1c34f7016915a03c8f95224b20ffd4cd20d5b85a",
            "filename": "django/db/models/sql/constants.py",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py",
            "raw_url": "https://github.com/django/django/raw/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py?ref=69597e5bcc89aadafd1b76abf7efab30ee0b8b1a",
            "patch": "@@ -18,12 +18,19 @@\n # Larger values are slightly faster at the expense of more storage space.\n GET_ITERATOR_CHUNK_SIZE = 100\n \n-# Constants to make looking up tuple values clearer.\n+# Namedtuples for sql.* internal use.\n+\n # Join lists (indexes into the tuples that are values in the alias_map\n # dictionary in the Query class).\n JoinInfo = namedtuple('JoinInfo',\n                       'table_name rhs_alias join_type lhs_alias '\n-                      'lhs_join_col rhs_join_col nullable')\n+                      'lhs_join_col rhs_join_col nullable join_field')\n+\n+# PathInfo is used when converting lookups (fk__somecol). The contents\n+# describe the join in Model terms (model Options and Fields for both\n+# sides of the join. The rel_field is the field we are joining along.\n+PathInfo = namedtuple('PathInfo',\n+                      'from_field to_field from_opts to_opts join_field')\n \n # Pairs of column clauses to select, and (possibly None) field for the clause.\n SelectInfo = namedtuple('SelectInfo', 'col field')"
        },
        {
            "sha": "af7e45e74e26eb1983aca42ec9093ba264fa296e",
            "filename": "django/db/models/sql/expressions.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py",
            "raw_url": "https://github.com/django/django/raw/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py?ref=69597e5bcc89aadafd1b76abf7efab30ee0b8b1a",
            "patch": "@@ -50,10 +50,10 @@ def prepare_leaf(self, node, query, allow_joins):\n             self.cols.append((node, query.aggregate_select[node.name]))\n         else:\n             try:\n-                field, source, opts, join_list, last, _ = query.setup_joins(\n+                field, source, opts, join_list, path = query.setup_joins(\n                     field_list, query.get_meta(),\n                     query.get_initial_alias(), self.reuse)\n-                col, _, join_list = query.trim_joins(source, join_list, last, False)\n+                col, _, join_list = query.trim_joins(source, join_list, path)\n                 if self.reuse is not None and self.reuse != REUSE_ALL:\n                     self.reuse.update(join_list)\n                 self.cols.append((node, (join_list[-1], col)))"
        },
        {
            "sha": "f6b812c54d94329aea79c7b46ed99200513f2df7",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 233,
            "deletions": 230,
            "changes": 463,
            "blob_url": "https://github.com/django/django/blob/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=69597e5bcc89aadafd1b76abf7efab30ee0b8b1a",
            "patch": "@@ -14,13 +14,13 @@\n from django.utils.tree import Node\n from django.utils import six\n from django.db import connections, DEFAULT_DB_ALIAS\n-from django.db.models import signals\n from django.db.models.constants import LOOKUP_SEP\n from django.db.models.expressions import ExpressionNode\n from django.db.models.fields import FieldDoesNotExist\n+from django.db.models.loading import get_model\n from django.db.models.sql import aggregates as base_aggregates_module\n from django.db.models.sql.constants import (QUERY_TERMS, ORDER_DIR, SINGLE,\n-        ORDER_PATTERN, REUSE_ALL, JoinInfo, SelectInfo)\n+        ORDER_PATTERN, REUSE_ALL, JoinInfo, SelectInfo, PathInfo)\n from django.db.models.sql.datastructures import EmptyResultSet, Empty, MultiJoin\n from django.db.models.sql.expressions import SQLEvaluator\n from django.db.models.sql.where import (WhereNode, Constraint, EverythingNode,\n@@ -119,7 +119,7 @@ def __init__(self, model, where=WhereNode):\n         self.filter_is_sticky = False\n         self.included_inherited_models = {}\n \n-        # SQL-related attributes  \n+        # SQL-related attributes\n         # Select and related select clauses as SelectInfo instances.\n         # The select is used for cases where we want to set up the select\n         # clause to contain other than default fields (values(), annotate(),\n@@ -201,6 +201,16 @@ def __getstate__(self):\n             (s.col, s.field is not None and s.field.name or None)\n             for s in obj_dict['select']\n         ]\n+        # alias_map can also contain references to fields.\n+        new_alias_map = {}\n+        for alias, join_info in obj_dict['alias_map'].items():\n+            if join_info.join_field is None:\n+                new_alias_map[alias] = join_info\n+            else:\n+                model = join_info.join_field.model._meta\n+                field_id = (model.app_label, model.object_name, join_info.join_field.name)\n+                new_alias_map[alias] = join_info._replace(join_field=field_id)\n+        obj_dict['alias_map'] = new_alias_map\n         return obj_dict\n \n     def __setstate__(self, obj_dict):\n@@ -213,6 +223,15 @@ def __setstate__(self, obj_dict):\n             SelectInfo(tpl[0], tpl[1] is not None and opts.get_field(tpl[1]) or None)\n             for tpl in obj_dict['select']\n         ]\n+        new_alias_map = {}\n+        for alias, join_info in obj_dict['alias_map'].items():\n+            if join_info.join_field is None:\n+                new_alias_map[alias] = join_info\n+            else:\n+                field_id = join_info.join_field\n+                new_alias_map[alias] = join_info._replace(\n+                    join_field=get_model(field_id[0], field_id[1])._meta.get_field(field_id[2]))\n+        obj_dict['alias_map'] = new_alias_map\n \n         self.__dict__.update(obj_dict)\n \n@@ -479,21 +498,26 @@ def combine(self, rhs, connector):\n         # Now, add the joins from rhs query into the new query (skipping base\n         # table).\n         for alias in rhs.tables[1:]:\n-            if not rhs.alias_refcount[alias]:\n-                continue\n-            table, _, join_type, lhs, lhs_col, col, nullable = rhs.alias_map[alias]\n+            table, _, join_type, lhs, lhs_col, col, nullable, join_field = rhs.alias_map[alias]\n             promote = (join_type == self.LOUTER)\n             # If the left side of the join was already relabeled, use the\n             # updated alias.\n             lhs = change_map.get(lhs, lhs)\n             new_alias = self.join(\n                 (lhs, table, lhs_col, col), reuse=reuse, promote=promote,\n-                outer_if_first=not conjunction, nullable=nullable)\n+                outer_if_first=not conjunction, nullable=nullable,\n+                join_field=join_field)\n             # We can't reuse the same join again in the query. If we have two\n             # distinct joins for the same connection in rhs query, then the\n             # combined query must have two joins, too.\n             reuse.discard(new_alias)\n             change_map[alias] = new_alias\n+            if not rhs.alias_refcount[alias]:\n+                # The alias was unused in the rhs query. Unref it so that it\n+                # will be unused in the new query, too. We have to add and\n+                # unref the alias so that join promotion has information of\n+                # the join type for the unused alias.\n+                self.unref_alias(new_alias)\n \n         # So that we don't exclude valid results in an \"or\" query combination,\n         # all joins exclusive to either the lhs or the rhs must be converted\n@@ -868,7 +892,7 @@ def count_active_tables(self):\n         return len([1 for count in self.alias_refcount.values() if count])\n \n     def join(self, connection, reuse=REUSE_ALL, promote=False,\n-             outer_if_first=False, nullable=False):\n+             outer_if_first=False, nullable=False, join_field=None):\n         \"\"\"\n         Returns an alias for the join in 'connection', either reusing an\n         existing alias for that join or creating a new one. 'connection' is a\n@@ -897,6 +921,8 @@ def join(self, connection, reuse=REUSE_ALL, promote=False,\n \n         If 'nullable' is True, the join can potentially involve NULL values and\n         is a candidate for promotion (to \"left outer\") when combining querysets.\n+\n+        The 'join_field' is the field we are joining along (if any).\n         \"\"\"\n         lhs, table, lhs_col, col = connection\n         existing = self.join_map.get(connection, ())\n@@ -906,8 +932,13 @@ def join(self, connection, reuse=REUSE_ALL, promote=False,\n             reuse = set()\n         else:\n             reuse = [a for a in existing if a in reuse]\n-        if reuse:\n-            alias = reuse[0]\n+        for alias in reuse:\n+            if join_field and self.alias_map[alias].join_field != join_field:\n+                # The join_map doesn't contain join_field (mainly because\n+                # fields in Query structs are problematic in pickling), so\n+                # check that the existing join is created using the same\n+                # join_field used for the under work join.\n+                continue\n             self.ref_alias(alias)\n             if promote or (lhs and self.alias_map[lhs].join_type == self.LOUTER):\n                 self.promote_joins([alias])\n@@ -926,7 +957,8 @@ def join(self, connection, reuse=REUSE_ALL, promote=False,\n             join_type = self.LOUTER\n         else:\n             join_type = self.INNER\n-        join = JoinInfo(table, alias, join_type, lhs, lhs_col, col, nullable)\n+        join = JoinInfo(table, alias, join_type, lhs, lhs_col, col, nullable,\n+                        join_field)\n         self.alias_map[alias] = join\n         if connection in self.join_map:\n             self.join_map[connection] += (alias,)\n@@ -1007,11 +1039,11 @@ def add_aggregate(self, aggregate, model, alias, is_summary):\n             #   - this is an annotation over a model field\n             # then we need to explore the joins that are required.\n \n-            field, source, opts, join_list, last, _ = self.setup_joins(\n+            field, source, opts, join_list, path = self.setup_joins(\n                 field_list, opts, self.get_initial_alias(), REUSE_ALL)\n \n             # Process the join chain to see if it can be trimmed\n-            col, _, join_list = self.trim_joins(source, join_list, last, False)\n+            col, _, join_list = self.trim_joins(source, join_list, path)\n \n             # If the aggregate references a model or field that requires a join,\n             # those joins must be LEFT OUTER - empty join rows must be returned\n@@ -1030,7 +1062,7 @@ def add_aggregate(self, aggregate, model, alias, is_summary):\n         aggregate.add_to_query(self, alias, col=col, source=source, is_summary=is_summary)\n \n     def add_filter(self, filter_expr, connector=AND, negate=False,\n-            can_reuse=None, process_extras=True, force_having=False):\n+            can_reuse=None, force_having=False):\n         \"\"\"\n         Add a single filter to the query. The 'filter_expr' is a pair:\n         (filter_string, value). E.g. ('name__contains', 'fred')\n@@ -1047,10 +1079,6 @@ def add_filter(self, filter_expr, connector=AND, negate=False,\n         will be a set of table aliases that can be reused in this filter, even\n         if we would otherwise force the creation of new aliases for a join\n         (needed for nested Q-filters). The set is updated by this method.\n-\n-        If 'process_extras' is set, any extra filters returned from the table\n-        joining process will be processed. This parameter is set to False\n-        during the processing of extra filters to avoid infinite recursion.\n         \"\"\"\n         arg, value = filter_expr\n         parts = arg.split(LOOKUP_SEP)\n@@ -1115,10 +1143,11 @@ def add_filter(self, filter_expr, connector=AND, negate=False,\n         allow_many = not negate\n \n         try:\n-            field, target, opts, join_list, last, extra_filters = self.setup_joins(\n+            field, target, opts, join_list, path = self.setup_joins(\n                     parts, opts, alias, can_reuse, allow_many,\n-                    allow_explicit_fk=True, negate=negate,\n-                    process_extras=process_extras)\n+                    allow_explicit_fk=True)\n+            if can_reuse is not None:\n+                can_reuse.update(join_list)\n         except MultiJoin as e:\n             self.split_exclude(filter_expr, LOOKUP_SEP.join(parts[:e.level]),\n                     can_reuse)\n@@ -1136,10 +1165,10 @@ def add_filter(self, filter_expr, connector=AND, negate=False,\n             join_promote = True\n \n         # Process the join list to see if we can remove any inner joins from\n-        # the far end (fewer tables in a query is better).\n-        nonnull_comparison = (lookup_type == 'isnull' and value is False)\n-        col, alias, join_list = self.trim_joins(target, join_list, last,\n-                nonnull_comparison)\n+        # the far end (fewer tables in a query is better). Note that join\n+        # promotion must happen before join trimming to have the join type\n+        # information available when reusing joins.\n+        col, alias, join_list = self.trim_joins(target, join_list, path)\n \n         if connector == OR:\n             # Some joins may need to be promoted when adding a new filter to a\n@@ -1212,12 +1241,6 @@ def add_filter(self, filter_expr, connector=AND, negate=False,\n                     # is added in upper layers of the code.\n                     self.where.add((Constraint(alias, col, None), 'isnull', False), AND)\n \n-        if can_reuse is not None:\n-            can_reuse.update(join_list)\n-        if process_extras:\n-            for filter in extra_filters:\n-                self.add_filter(filter, negate=negate, can_reuse=can_reuse,\n-                        process_extras=False)\n \n     def add_q(self, q_object, used_aliases=None, force_having=False):\n         \"\"\"\n@@ -1270,37 +1293,24 @@ def add_q(self, q_object, used_aliases=None, force_having=False):\n         if self.filter_is_sticky:\n             self.used_aliases = used_aliases\n \n-    def setup_joins(self, names, opts, alias, can_reuse, allow_many=True,\n-            allow_explicit_fk=False, negate=False, process_extras=True):\n+    def names_to_path(self, names, opts, allow_many=False,\n+                      allow_explicit_fk=True):\n         \"\"\"\n-        Compute the necessary table joins for the passage through the fields\n-        given in 'names'. 'opts' is the Options class for the current model\n-        (which gives the table we are joining to), 'alias' is the alias for the\n-        table we are joining to.\n+        Walks the names path and turns them PathInfo tuples. Note that a\n+        single name in 'names' can generate multiple PathInfos (m2m for\n+        example).\n \n-        The 'can_reuse' defines the reverse foreign key joins we can reuse. It\n-        can be either sql.constants.REUSE_ALL in which case all joins are\n-        reusable or a set of aliases that can be reused. Non-reverse foreign\n-        keys are always reusable.\n+        'names' is the path of names to travle, 'opts' is the model Options we\n+        start the name resolving from, 'allow_many' and 'allow_explicit_fk'\n+        are as for setup_joins().\n \n-        The 'allow_explicit_fk' controls if field.attname is allowed in the\n-        lookups.\n-\n-        Finally, 'negate' is used in the same sense as for add_filter()\n-        -- it indicates an exclude() filter, or something similar. It is only\n-        passed in here so that it can be passed to a field's extra_filter() for\n-        customized behavior.\n-\n-        Returns the final field involved in the join, the target database\n-        column (used for any 'where' constraint), the final 'opts' value and the\n-        list of tables joined.\n+        Returns a list of PathInfo tuples. In addition returns the final field\n+        (the last used join field), and target (which is a field guaranteed to\n+        contain the same value as the final field).\n         \"\"\"\n-        joins = [alias]\n-        last = [0]\n-        extra_filters = []\n-        int_alias = None\n+        path = []\n+        multijoin_pos = None\n         for pos, name in enumerate(names):\n-            last.append(len(joins))\n             if name == 'pk':\n                 name = opts.pk.name\n             try:\n@@ -1314,14 +1324,12 @@ def setup_joins(self, names, opts, alias, can_reuse, allow_many=True,\n                         field, model, direct, m2m = opts.get_field_by_name(f.name)\n                         break\n                 else:\n-                    names = opts.get_all_field_names() + list(self.aggregate_select)\n+                    available = opts.get_all_field_names() + list(self.aggregate_select)\n                     raise FieldError(\"Cannot resolve keyword %r into field. \"\n-                            \"Choices are: %s\" % (name, \", \".join(names)))\n-\n-            if not allow_many and (m2m or not direct):\n-                for alias in joins:\n-                    self.unref_alias(alias)\n-                raise MultiJoin(pos + 1)\n+                                     \"Choices are: %s\" % (name, \", \".join(available)))\n+            # Check if we need any joins for concrete inheritance cases (the\n+            # field lives in parent, but we are currently in one of its\n+            # children)\n             if model:\n                 # The field lives on a base class of the current model.\n                 # Skip the chain of proxy to the concrete proxied model\n@@ -1331,172 +1339,179 @@ def setup_joins(self, names, opts, alias, can_reuse, allow_many=True,\n                     if int_model is proxied_model:\n                         opts = int_model._meta\n                     else:\n-                        lhs_col = opts.parents[int_model].column\n+                        final_field = opts.parents[int_model]\n+                        target = final_field.rel.get_related_field()\n                         opts = int_model._meta\n-                        alias = self.join((alias, opts.db_table, lhs_col,\n-                                opts.pk.column))\n-                        joins.append(alias)\n-            cached_data = opts._join_cache.get(name)\n-            orig_opts = opts\n-\n-            if process_extras and hasattr(field, 'extra_filters'):\n-                extra_filters.extend(field.extra_filters(names, pos, negate))\n-            if direct:\n-                if m2m:\n-                    # Many-to-many field defined on the current model.\n-                    if cached_data:\n-                        (table1, from_col1, to_col1, table2, from_col2,\n-                                to_col2, opts, target) = cached_data\n-                    else:\n-                        table1 = field.m2m_db_table()\n-                        from_col1 = opts.get_field_by_name(\n-                            field.m2m_target_field_name())[0].column\n-                        to_col1 = field.m2m_column_name()\n-                        opts = field.rel.to._meta\n-                        table2 = opts.db_table\n-                        from_col2 = field.m2m_reverse_name()\n-                        to_col2 = opts.get_field_by_name(\n-                            field.m2m_reverse_target_field_name())[0].column\n-                        target = opts.pk\n-                        orig_opts._join_cache[name] = (table1, from_col1,\n-                                to_col1, table2, from_col2, to_col2, opts,\n-                                target)\n-\n-                    int_alias = self.join((alias, table1, from_col1, to_col1),\n-                            reuse=can_reuse, nullable=True)\n-                    if int_alias == table2 and from_col2 == to_col2:\n-                        joins.append(int_alias)\n-                        alias = int_alias\n-                    else:\n-                        alias = self.join(\n-                                (int_alias, table2, from_col2, to_col2),\n-                                reuse=can_reuse, nullable=True)\n-                        joins.extend([int_alias, alias])\n-                elif field.rel:\n-                    # One-to-one or many-to-one field\n-                    if cached_data:\n-                        (table, from_col, to_col, opts, target) = cached_data\n-                    else:\n-                        opts = field.rel.to._meta\n-                        target = field.rel.get_related_field()\n-                        table = opts.db_table\n-                        from_col = field.column\n-                        to_col = target.column\n-                        orig_opts._join_cache[name] = (table, from_col, to_col,\n-                                opts, target)\n-\n-                    alias = self.join((alias, table, from_col, to_col),\n-                                      nullable=self.is_nullable(field))\n-                    joins.append(alias)\n+                        path.append(PathInfo(final_field, target, final_field.model._meta,\n+                                             opts, final_field))\n+            # We have five different cases to solve: foreign keys, reverse\n+            # foreign keys, m2m fields (also reverse) and non-relational\n+            # fields. We are mostly just using the related field API to\n+            # fetch the from and to fields. The m2m fields are handled as\n+            # two foreign keys, first one reverse, the second one direct.\n+            if direct and not field.rel and not m2m:\n+                # Local non-relational field.\n+                final_field = target = field\n+                break\n+            elif direct and not m2m:\n+                # Foreign Key\n+                opts = field.rel.to._meta\n+                target = field.rel.get_related_field()\n+                final_field = field\n+                from_opts = field.model._meta\n+                path.append(PathInfo(field, target, from_opts, opts, field))\n+            elif not direct and not m2m:\n+                # Revere foreign key\n+                final_field = to_field = field.field\n+                opts = to_field.model._meta\n+                from_field = to_field.rel.get_related_field()\n+                from_opts = from_field.model._meta\n+                path.append(\n+                    PathInfo(from_field, to_field, from_opts, opts, to_field))\n+                if from_field.model is to_field.model:\n+                    # Recursive foreign key to self.\n+                    target = opts.get_field_by_name(\n+                        field.field.rel.field_name)[0]\n                 else:\n-                    # Non-relation fields.\n-                    target = field\n-                    break\n-            else:\n-                orig_field = field\n-                field = field.field\n-                if m2m:\n-                    # Many-to-many field defined on the target model.\n-                    if cached_data:\n-                        (table1, from_col1, to_col1, table2, from_col2,\n-                                to_col2, opts, target) = cached_data\n-                    else:\n-                        table1 = field.m2m_db_table()\n-                        from_col1 = opts.get_field_by_name(\n-                            field.m2m_reverse_target_field_name())[0].column\n-                        to_col1 = field.m2m_reverse_name()\n-                        opts = orig_field.opts\n-                        table2 = opts.db_table\n-                        from_col2 = field.m2m_column_name()\n-                        to_col2 = opts.get_field_by_name(\n-                            field.m2m_target_field_name())[0].column\n-                        target = opts.pk\n-                        orig_opts._join_cache[name] = (table1, from_col1,\n-                                to_col1, table2, from_col2, to_col2, opts,\n-                                target)\n-\n-                    int_alias = self.join((alias, table1, from_col1, to_col1),\n-                            reuse=can_reuse, nullable=True)\n-                    alias = self.join((int_alias, table2, from_col2, to_col2),\n-                            reuse=can_reuse, nullable=True)\n-                    joins.extend([int_alias, alias])\n+                    target = opts.pk\n+            elif direct and m2m:\n+                if not field.rel.through:\n+                    # Gotcha! This is just a fake m2m field - a generic relation\n+                    # field).\n+                    from_field = opts.pk\n+                    opts = field.rel.to._meta\n+                    target = opts.get_field_by_name(field.object_id_field_name)[0]\n+                    final_field = field\n+                    # Note that we are using different field for the join_field\n+                    # than from_field or to_field. This is a hack, but we need the\n+                    # GenericRelation to generate the extra SQL.\n+                    path.append(PathInfo(from_field, target, field.model._meta, opts,\n+                                         field))\n                 else:\n-                    # One-to-many field (ForeignKey defined on the target model)\n-                    if cached_data:\n-                        (table, from_col, to_col, opts, target) = cached_data\n-                    else:\n-                        local_field = opts.get_field_by_name(\n-                                field.rel.field_name)[0]\n-                        opts = orig_field.opts\n-                        table = opts.db_table\n-                        from_col = local_field.column\n-                        to_col = field.column\n-                        # In case of a recursive FK, use the to_field for\n-                        # reverse lookups as well\n-                        if orig_field.model is local_field.model:\n-                            target = opts.get_field_by_name(\n-                                field.rel.field_name)[0]\n-                        else:\n-                            target = opts.pk\n-                        orig_opts._join_cache[name] = (table, from_col, to_col,\n-                                opts, target)\n-\n-                    alias = self.join((alias, table, from_col, to_col),\n-                            reuse=can_reuse, nullable=True)\n-                    joins.append(alias)\n+                    # m2m field. We are travelling first to the m2m table along a\n+                    # reverse relation, then from m2m table to the target table.\n+                    from_field1 = opts.get_field_by_name(\n+                        field.m2m_target_field_name())[0]\n+                    opts = field.rel.through._meta\n+                    to_field1 = opts.get_field_by_name(field.m2m_field_name())[0]\n+                    path.append(\n+                        PathInfo(from_field1, to_field1, from_field1.model._meta,\n+                                 opts, to_field1))\n+                    final_field = from_field2 = opts.get_field_by_name(\n+                        field.m2m_reverse_field_name())[0]\n+                    opts = field.rel.to._meta\n+                    target = to_field2 = opts.get_field_by_name(\n+                        field.m2m_reverse_target_field_name())[0]\n+                    path.append(\n+                        PathInfo(from_field2, to_field2, from_field2.model._meta,\n+                                 opts, from_field2))\n+            elif not direct and m2m:\n+                # This one is just like above, except we are travelling the\n+                # fields in opposite direction.\n+                field = field.field\n+                from_field1 = opts.get_field_by_name(\n+                    field.m2m_reverse_target_field_name())[0]\n+                int_opts = field.rel.through._meta\n+                to_field1 = int_opts.get_field_by_name(\n+                    field.m2m_reverse_field_name())[0]\n+                path.append(\n+                    PathInfo(from_field1, to_field1, from_field1.model._meta,\n+                             int_opts, to_field1))\n+                final_field = from_field2 = int_opts.get_field_by_name(\n+                    field.m2m_field_name())[0]\n+                opts = field.opts\n+                target = to_field2 = opts.get_field_by_name(\n+                    field.m2m_target_field_name())[0]\n+                path.append(PathInfo(from_field2, to_field2, from_field2.model._meta,\n+                                     opts, from_field2))\n+\n+            if m2m and multijoin_pos is None:\n+                multijoin_pos = pos\n+            if not direct and not path[-1].to_field.unique and multijoin_pos is None:\n+                multijoin_pos = pos\n \n         if pos != len(names) - 1:\n             if pos == len(names) - 2:\n-                raise FieldError(\"Join on field %r not permitted. Did you misspell %r for the lookup type?\" % (name, names[pos + 1]))\n+                raise FieldError(\n+                    \"Join on field %r not permitted. Did you misspell %r for \"\n+                    \"the lookup type?\" % (name, names[pos + 1]))\n             else:\n                 raise FieldError(\"Join on field %r not permitted.\" % name)\n+        if multijoin_pos is not None and len(path) >= multijoin_pos and not allow_many:\n+            raise MultiJoin(multijoin_pos + 1)\n+        return path, final_field, target\n \n-        return field, target, opts, joins, last, extra_filters\n-\n-    def trim_joins(self, target, join_list, last, nonnull_check=False):\n+    def setup_joins(self, names, opts, alias, can_reuse, allow_many=True,\n+                    allow_explicit_fk=False):\n         \"\"\"\n-        Sometimes joins at the end of a multi-table sequence can be trimmed. If\n-        the final join is against the same column as we are comparing against,\n-        and is an inner join, we can go back one step in a join chain and\n-        compare against the LHS of the join instead (and then repeat the\n-        optimization). The result, potentially, involves fewer table joins.\n+        Compute the necessary table joins for the passage through the fields\n+        given in 'names'. 'opts' is the Options class for the current model\n+        (which gives the table we are starting from), 'alias' is the alias for\n+        the table to start the joining from.\n+\n+        The 'can_reuse' defines the reverse foreign key joins we can reuse. It\n+        can be sql.constants.REUSE_ALL in which case all joins are reusable\n+        or a set of aliases that can be reused. Note that Non-reverse foreign\n+        keys are always reusable.\n+\n+        If 'allow_many' is False, then any reverse foreign key seen will\n+        generate a MultiJoin exception.\n+\n+        The 'allow_explicit_fk' controls if field.attname is allowed in the\n+        lookups.\n \n-        The 'target' parameter is the final field being joined to, 'join_list'\n-        is the full list of join aliases.\n+        Returns the final field involved in the joins, the target field (used\n+        for any 'where' constraint), the final 'opts' value, the joins and the\n+        field path travelled to generate the joins.\n \n-        The 'last' list contains offsets into 'join_list', corresponding to\n-        each component of the filter. Many-to-many relations, for example, add\n-        two tables to the join list and we want to deal with both tables the\n-        same way, so 'last' has an entry for the first of the two tables and\n-        then the table immediately after the second table, in that case.\n+        The target field is the field containing the concrete value. Final\n+        field can be something different, for example foreign key pointing to\n+        that value. Final field is needed for example in some value\n+        conversions (convert 'obj' in fk__id=obj to pk val using the foreign\n+        key field for example).\n+        \"\"\"\n+        joins = [alias]\n+        # First, generate the path for the names\n+        path, final_field, target = self.names_to_path(\n+            names, opts, allow_many, allow_explicit_fk)\n+        # Then, add the path to the query's joins. Note that we can't trim\n+        # joins at this stage - we will need the information about join type\n+        # of the trimmed joins.\n+        for pos, join in enumerate(path):\n+            from_field, to_field, from_opts, opts, join_field = join\n+            direct = join_field == from_field\n+            if direct:\n+                nullable = self.is_nullable(from_field)\n+            else:\n+                nullable = True\n+            connection = alias, opts.db_table, from_field.column, to_field.column\n+            alias = self.join(connection, reuse=can_reuse, nullable=nullable,\n+                              join_field=join_field)\n+            joins.append(alias)\n+        return final_field, target, opts, joins, path\n \n-        The 'nonnull_check' parameter is True when we are using inner joins\n-        between tables explicitly to exclude NULL entries. In that case, the\n-        tables shouldn't be trimmed, because the very action of joining to them\n-        alters the result set.\n+    def trim_joins(self, target, joins, path):\n+        \"\"\"\n+        The 'target' parameter is the final field being joined to, 'joins'\n+        is the full list of join aliases. The 'path' contain the PathInfos\n+        used to create the joins.\n \n         Returns the final active column and table alias and the new active\n-        join_list.\n-        \"\"\"\n-        final = len(join_list)\n-        penultimate = last.pop()\n-        if penultimate == final:\n-            penultimate = last.pop()\n-        col = target.column\n-        alias = join_list[-1]\n-        while final > 1:\n-            join = self.alias_map[alias]\n-            if (col != join.rhs_join_col or join.join_type != self.INNER or\n-                    nonnull_check):\n+        joins.\n+\n+        We will always trim any direct join if we have the target column\n+        available already in the previous table. Reverse joins can't be\n+        trimmed as we don't know if there is anything on the other side of\n+        the join.\n+        \"\"\"\n+        for info in reversed(path):\n+            direct = info.join_field == info.from_field\n+            if info.to_field == target and direct:\n+                target = info.from_field\n+                self.unref_alias(joins.pop())\n+            else:\n                 break\n-            self.unref_alias(alias)\n-            alias = join.lhs_alias\n-            col = join.lhs_join_col\n-            join_list.pop()\n-            final -= 1\n-            if final == penultimate:\n-                penultimate = last.pop()\n-        return col, alias, join_list\n+        return target.column, joins[-1], joins\n \n     def split_exclude(self, filter_expr, prefix, can_reuse):\n         \"\"\"\n@@ -1627,9 +1642,9 @@ def add_fields(self, field_names, allow_m2m=True):\n \n         try:\n             for name in field_names:\n-                field, target, u2, joins, u3, u4 = self.setup_joins(\n-                        name.split(LOOKUP_SEP), opts, alias, REUSE_ALL,\n-                        allow_m2m, True)\n+                field, target, u2, joins, u3 = self.setup_joins(\n+                        name.split(LOOKUP_SEP), opts, alias, REUSE_ALL, allow_m2m,\n+                        True)\n                 final_alias = joins[-1]\n                 col = target.column\n                 if len(joins) > 1:\n@@ -1918,7 +1933,7 @@ def set_start(self, start):\n         \"\"\"\n         opts = self.model._meta\n         alias = self.get_initial_alias()\n-        field, col, opts, joins, last, extra = self.setup_joins(\n+        field, col, opts, joins, extra = self.setup_joins(\n                 start.split(LOOKUP_SEP), opts, alias, REUSE_ALL)\n         select_col = self.alias_map[joins[1]].lhs_join_col\n         select_alias = alias\n@@ -1975,18 +1990,6 @@ def get_order_dir(field, default='ASC'):\n     return field, dirn[0]\n \n \n-def setup_join_cache(sender, **kwargs):\n-    \"\"\"\n-    The information needed to join between model fields is something that is\n-    invariant over the life of the model, so we cache it in the model's Options\n-    class, rather than recomputing it all the time.\n-\n-    This method initialises the (empty) cache when the model is created.\n-    \"\"\"\n-    sender._meta._join_cache = {}\n-\n-signals.class_prepared.connect(setup_join_cache)\n-\n def add_to_dict(data, key, value):\n     \"\"\"\n     A helper function to add \"value\" to the set of values for \"key\", whether or"
        },
        {
            "sha": "596ebbfaec3be5be1c675b035f1d97d3a1fa353c",
            "filename": "tests/regressiontests/aggregation_regress/tests.py",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/tests%2Fregressiontests%2Faggregation_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/tests%2Fregressiontests%2Faggregation_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Faggregation_regress%2Ftests.py?ref=69597e5bcc89aadafd1b76abf7efab30ee0b8b1a",
            "patch": "@@ -978,3 +978,7 @@ def test_aggregate_duplicate_columns_select_related(self):\n                 ('The Definitive Guide to Django: Web Development Done Right', 2)\n             ]\n         )\n+\n+    def test_reverse_join_trimming(self):\n+        qs = Author.objects.annotate(Count('book_contact_set__contact'))\n+        self.assertIn(' JOIN ', str(qs.query))"
        },
        {
            "sha": "73b97621500a4483e102a1782d428e51bf0686d6",
            "filename": "tests/regressiontests/queries/models.py",
            "status": "modified",
            "additions": 22,
            "deletions": 1,
            "changes": 23,
            "blob_url": "https://github.com/django/django/blob/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/tests%2Fregressiontests%2Fqueries%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/tests%2Fregressiontests%2Fqueries%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Fmodels.py?ref=69597e5bcc89aadafd1b76abf7efab30ee0b8b1a",
            "patch": "@@ -283,6 +283,7 @@ def __str__(self):\n \n class RelatedObject(models.Model):\n     single = models.ForeignKey(SingleObject, null=True)\n+    f = models.IntegerField(null=True)\n \n     class Meta:\n         ordering = ['single']\n@@ -311,7 +312,7 @@ def __str__(self):\n \n @python_2_unicode_compatible\n class Eaten(models.Model):\n-    food = models.ForeignKey(Food, to_field=\"name\")\n+    food = models.ForeignKey(Food, to_field=\"name\", null=True)\n     meal = models.CharField(max_length=20)\n \n     def __str__(self):\n@@ -400,3 +401,23 @@ class ModelA(models.Model):\n     name = models.TextField()\n     b = models.ForeignKey(ModelB, null=True)\n     d = models.ForeignKey(ModelD)\n+\n+@python_2_unicode_compatible\n+class Job(models.Model):\n+    name = models.CharField(max_length=20, unique=True)\n+\n+    def __str__(self):\n+        return self.name\n+\n+class JobResponsibilities(models.Model):\n+    job = models.ForeignKey(Job, to_field='name')\n+    responsibility = models.ForeignKey('Responsibility', to_field='description')\n+\n+@python_2_unicode_compatible\n+class Responsibility(models.Model):\n+    description = models.CharField(max_length=20, unique=True)\n+    jobs = models.ManyToManyField(Job, through=JobResponsibilities,\n+                                  related_name='responsibilities')\n+\n+    def __str__(self):\n+        return self.description"
        },
        {
            "sha": "75e27769b4a9838fea6c1602d450c6d390ee728b",
            "filename": "tests/regressiontests/queries/tests.py",
            "status": "modified",
            "additions": 268,
            "deletions": 5,
            "changes": 273,
            "blob_url": "https://github.com/django/django/blob/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/69597e5bcc89aadafd1b76abf7efab30ee0b8b1a/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Ftests.py?ref=69597e5bcc89aadafd1b76abf7efab30ee0b8b1a",
            "patch": "@@ -23,7 +23,8 @@\n     Ranking, Related, Report, ReservedName, Tag, TvChef, Valid, X, Food, Eaten,\n     Node, ObjectA, ObjectB, ObjectC, CategoryItem, SimpleCategory,\n     SpecialCategory, OneToOneCategory, NullableName, ProxyCategory,\n-    SingleObject, RelatedObject, ModelA, ModelD)\n+    SingleObject, RelatedObject, ModelA, ModelD, Responsibility, Job,\n+    JobResponsibilities)\n \n \n class BaseQuerysetTest(TestCase):\n@@ -243,7 +244,10 @@ def test_order_by_tables(self):\n         q1 = Item.objects.order_by('name')\n         q2 = Item.objects.filter(id=self.i1.id)\n         list(q2)\n-        self.assertEqual(len((q1 & q2).order_by('name').query.tables), 1)\n+        combined_query = (q1 & q2).order_by('name').query\n+        self.assertEqual(len([\n+            t for t in combined_query.tables if combined_query.alias_refcount[t]\n+        ]), 1)\n \n     def test_order_by_join_unref(self):\n         \"\"\"\n@@ -883,6 +887,225 @@ def test_exclude_in(self):\n             Item.objects.filter(Q(tags__name__in=['t4', 't3'])),\n             [repr(i) for i in Item.objects.filter(~~Q(tags__name__in=['t4', 't3']))])\n \n+    def test_ticket_10790_1(self):\n+        # Querying direct fields with isnull should trim the left outer join.\n+        # It also should not create INNER JOIN.\n+        q = Tag.objects.filter(parent__isnull=True)\n+\n+        self.assertQuerysetEqual(q, ['<Tag: t1>'])\n+        self.assertTrue('JOIN' not in str(q.query))\n+\n+        q = Tag.objects.filter(parent__isnull=False)\n+\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Tag: t2>', '<Tag: t3>', '<Tag: t4>', '<Tag: t5>'],\n+        )\n+        self.assertTrue('JOIN' not in str(q.query))\n+\n+        q = Tag.objects.exclude(parent__isnull=True)\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Tag: t2>', '<Tag: t3>', '<Tag: t4>', '<Tag: t5>'],\n+        )\n+        self.assertTrue('JOIN' not in str(q.query))\n+\n+        q = Tag.objects.exclude(parent__isnull=False)\n+        self.assertQuerysetEqual(q, ['<Tag: t1>'])\n+        self.assertTrue('JOIN' not in str(q.query))\n+\n+        q = Tag.objects.exclude(parent__parent__isnull=False)\n+\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Tag: t1>', '<Tag: t2>', '<Tag: t3>'],\n+        )\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 1)\n+        self.assertTrue('INNER JOIN' not in str(q.query))\n+\n+    def test_ticket_10790_2(self):\n+        # Querying across several tables should strip only the last outer join,\n+        # while preserving the preceeding inner joins.\n+        q = Tag.objects.filter(parent__parent__isnull=False)\n+\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Tag: t4>', '<Tag: t5>'],\n+        )\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 0)\n+        self.assertTrue(str(q.query).count('INNER JOIN') == 1)\n+\n+        # Querying without isnull should not convert anything to left outer join.\n+        q = Tag.objects.filter(parent__parent=self.t1)\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Tag: t4>', '<Tag: t5>'],\n+        )\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 0)\n+        self.assertTrue(str(q.query).count('INNER JOIN') == 1)\n+\n+    def test_ticket_10790_3(self):\n+        # Querying via indirect fields should populate the left outer join\n+        q = NamedCategory.objects.filter(tag__isnull=True)\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 1)\n+        # join to dumbcategory ptr_id\n+        self.assertTrue(str(q.query).count('INNER JOIN') == 1)\n+        self.assertQuerysetEqual(q, [])\n+\n+        # Querying across several tables should strip only the last join, while\n+        # preserving the preceding left outer joins.\n+        q = NamedCategory.objects.filter(tag__parent__isnull=True)\n+        self.assertTrue(str(q.query).count('INNER JOIN') == 1)\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 1)\n+        self.assertQuerysetEqual( q, ['<NamedCategory: NamedCategory object>'])\n+\n+    def test_ticket_10790_4(self):\n+        # Querying across m2m field should not strip the m2m table from join.\n+        q = Author.objects.filter(item__tags__isnull=True)\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Author: a2>', '<Author: a3>'],\n+        )\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 2)\n+        self.assertTrue('INNER JOIN' not in str(q.query))\n+\n+        q = Author.objects.filter(item__tags__parent__isnull=True)\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Author: a1>', '<Author: a2>', '<Author: a2>', '<Author: a3>'],\n+        )\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 3)\n+        self.assertTrue('INNER JOIN' not in str(q.query))\n+\n+    def test_ticket_10790_5(self):\n+        # Querying with isnull=False across m2m field should not create outer joins\n+        q = Author.objects.filter(item__tags__isnull=False)\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Author: a1>', '<Author: a1>', '<Author: a2>', '<Author: a2>', '<Author: a4>']\n+        )\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 0)\n+        self.assertTrue(str(q.query).count('INNER JOIN') == 2)\n+\n+        q = Author.objects.filter(item__tags__parent__isnull=False)\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Author: a1>', '<Author: a2>', '<Author: a4>']\n+        )\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 0)\n+        self.assertTrue(str(q.query).count('INNER JOIN') == 3)\n+\n+        q = Author.objects.filter(item__tags__parent__parent__isnull=False)\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Author: a4>']\n+        )\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 0)\n+        self.assertTrue(str(q.query).count('INNER JOIN') == 4)\n+\n+    def test_ticket_10790_6(self):\n+        # Querying with isnull=True across m2m field should not create inner joins\n+        # and strip last outer join\n+        q = Author.objects.filter(item__tags__parent__parent__isnull=True)\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Author: a1>', '<Author: a1>', '<Author: a2>', '<Author: a2>',\n+             '<Author: a2>', '<Author: a3>']\n+        )\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 4)\n+        self.assertTrue(str(q.query).count('INNER JOIN') == 0)\n+\n+        q = Author.objects.filter(item__tags__parent__isnull=True)\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Author: a1>', '<Author: a2>', '<Author: a2>', '<Author: a3>']\n+        )\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 3)\n+        self.assertTrue(str(q.query).count('INNER JOIN') == 0)\n+\n+    def test_ticket_10790_7(self):\n+        # Reverse querying with isnull should not strip the join\n+        q = Author.objects.filter(item__isnull=True)\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Author: a3>']\n+        )\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 1)\n+        self.assertTrue(str(q.query).count('INNER JOIN') == 0)\n+\n+        q = Author.objects.filter(item__isnull=False)\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Author: a1>', '<Author: a2>', '<Author: a2>', '<Author: a4>']\n+        )\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 0)\n+        self.assertTrue(str(q.query).count('INNER JOIN') == 1)\n+\n+    def test_ticket_10790_8(self):\n+        # Querying with combined q-objects should also strip the left outer join\n+        q = Tag.objects.filter(Q(parent__isnull=True) | Q(parent=self.t1))\n+        self.assertQuerysetEqual(\n+            q,\n+            ['<Tag: t1>', '<Tag: t2>', '<Tag: t3>']\n+        )\n+        self.assertTrue(str(q.query).count('LEFT OUTER JOIN') == 0)\n+        self.assertTrue(str(q.query).count('INNER JOIN') == 0)\n+\n+    def test_ticket_10790_combine(self):\n+        # Combining queries should not re-populate the left outer join\n+        q1 = Tag.objects.filter(parent__isnull=True)\n+        q2 = Tag.objects.filter(parent__isnull=False)\n+\n+        q3 = q1 | q2\n+        self.assertQuerysetEqual(\n+            q3,\n+            ['<Tag: t1>', '<Tag: t2>', '<Tag: t3>', '<Tag: t4>', '<Tag: t5>'],\n+        )\n+        self.assertTrue(str(q3.query).count('LEFT OUTER JOIN') == 0)\n+        self.assertTrue(str(q3.query).count('INNER JOIN') == 0)\n+\n+        q3 = q1 & q2\n+        self.assertQuerysetEqual(q3, [])\n+        self.assertTrue(str(q3.query).count('LEFT OUTER JOIN') == 0)\n+        self.assertTrue(str(q3.query).count('INNER JOIN') == 0)\n+\n+        q2 = Tag.objects.filter(parent=self.t1)\n+        q3 = q1 | q2\n+        self.assertQuerysetEqual(\n+            q3,\n+            ['<Tag: t1>', '<Tag: t2>', '<Tag: t3>']\n+        )\n+        self.assertTrue(str(q3.query).count('LEFT OUTER JOIN') == 0)\n+        self.assertTrue(str(q3.query).count('INNER JOIN') == 0)\n+\n+        q3 = q2 | q1\n+        self.assertQuerysetEqual(\n+            q3,\n+            ['<Tag: t1>', '<Tag: t2>', '<Tag: t3>']\n+        )\n+        self.assertTrue(str(q3.query).count('LEFT OUTER JOIN') == 0)\n+        self.assertTrue(str(q3.query).count('INNER JOIN') == 0)\n+\n+        q1 = Tag.objects.filter(parent__isnull=True)\n+        q2 = Tag.objects.filter(parent__parent__isnull=True)\n+\n+        q3 = q1 | q2\n+        self.assertQuerysetEqual(\n+            q3,\n+            ['<Tag: t1>', '<Tag: t2>', '<Tag: t3>']\n+        )\n+        self.assertTrue(str(q3.query).count('LEFT OUTER JOIN') == 1)\n+        self.assertTrue(str(q3.query).count('INNER JOIN') == 0)\n+\n+        q3 = q2 | q1\n+        self.assertQuerysetEqual(\n+            q3,\n+            ['<Tag: t1>', '<Tag: t2>', '<Tag: t3>']\n+        )\n+        self.assertTrue(str(q3.query).count('LEFT OUTER JOIN') == 1)\n+        self.assertTrue(str(q3.query).count('INNER JOIN') == 0)\n+\n+\n class Queries2Tests(TestCase):\n     def setUp(self):\n         Number.objects.create(num=4)\n@@ -1037,6 +1260,10 @@ def setUp(self):\n         Item.objects.create(name='i2', created=datetime.datetime.now(), note=n1, creator=self.a3)\n \n     def test_ticket14876(self):\n+        # Note: when combining the query we need to have information available\n+        # about the join type of the trimmed \"creator__isnull\" join. If we\n+        # don't have that information, then the join is created as INNER JOIN\n+        # and results will be incorrect.\n         q1 = Report.objects.filter(Q(creator__isnull=True) | Q(creator__extra__info='e1'))\n         q2 = Report.objects.filter(Q(creator__isnull=True)) | Report.objects.filter(Q(creator__extra__info='e1'))\n         self.assertQuerysetEqual(q1, [\"<Report: r1>\", \"<Report: r3>\"], ordered=False)\n@@ -1405,17 +1632,19 @@ def test_join_already_in_query(self):\n         # the join type of already existing joins.\n         Plaything.objects.create(name=\"p1\")\n         s = SingleObject.objects.create(name='s')\n-        r = RelatedObject.objects.create(single=s)\n+        r = RelatedObject.objects.create(single=s, f=1)\n         Plaything.objects.create(name=\"p2\", others=r)\n         qs = Plaything.objects.all().filter(others__isnull=False).order_by('pk')\n+        self.assertTrue('JOIN' not in str(qs.query))\n+        qs = Plaything.objects.all().filter(others__f__isnull=False).order_by('pk')\n         self.assertTrue('INNER' in str(qs.query))\n         qs = qs.order_by('others__single__name')\n         # The ordering by others__single__pk will add one new join (to single)\n         # and that join must be LEFT join. The already existing join to related\n         # objects must be kept INNER. So, we have both a INNER and a LEFT join\n         # in the query.\n-        self.assertTrue('LEFT' in str(qs.query))\n-        self.assertTrue('INNER' in str(qs.query))\n+        self.assertEquals(str(qs.query).count('LEFT'), 1)\n+        self.assertEquals(str(qs.query).count('INNER'), 1)\n         self.assertQuerysetEqual(\n             qs,\n             ['<Plaything: p2>']\n@@ -1466,6 +1695,7 @@ def setUp(self):\n \n     # This next test used to cause really weird PostgreSQL behavior, but it was\n     # only apparent much later when the full test suite ran.\n+    #  - Yeah, it leaves global ITER_CHUNK_SIZE to 2 instead of 100...\n     #@unittest.expectedFailure\n     def test_slicing_and_cache_interaction(self):\n         # We can do slicing beyond what is currently in the result cache,\n@@ -1993,6 +2223,29 @@ def test_no_extra_params(self):\n         except TypeError:\n             self.fail(\"Creation of an instance of a model with only the PK field shouldn't error out after bulk insert refactoring (#17056)\")\n \n+class ExcludeTest(TestCase):\n+    def setUp(self):\n+        f1 = Food.objects.create(name='apples')\n+        Food.objects.create(name='oranges')\n+        Eaten.objects.create(food=f1, meal='dinner')\n+        j1 = Job.objects.create(name='Manager')\n+        r1 = Responsibility.objects.create(description='Playing golf')\n+        j2 = Job.objects.create(name='Programmer')\n+        r2 = Responsibility.objects.create(description='Programming')\n+        JobResponsibilities.objects.create(job=j1, responsibility=r1)\n+        JobResponsibilities.objects.create(job=j2, responsibility=r2)\n+\n+    def test_to_field(self):\n+        self.assertQuerysetEqual(\n+            Food.objects.exclude(eaten__meal='dinner'),\n+            ['<Food: oranges>'])\n+        self.assertQuerysetEqual(\n+            Job.objects.exclude(responsibilities__description='Playing golf'),\n+            ['<Job: Programmer>'])\n+        self.assertQuerysetEqual(\n+            Responsibility.objects.exclude(jobs__name='Manager'),\n+            ['<Responsibility: Programming>'])\n+\n class NullInExcludeTest(TestCase):\n     def setUp(self):\n         NullableName.objects.create(name='i1')\n@@ -2155,3 +2408,13 @@ def test_ticket_17886(self):\n         # so we can use INNER JOIN for it. However, we can NOT use INNER JOIN\n         # for the b->c join, as a->b is nullable.\n         self.assertEqual(str(qset.query).count('INNER JOIN'), 1)\n+\n+class ReverseJoinTrimmingTest(TestCase):\n+    def test_reverse_trimming(self):\n+        # Check that we don't accidentally trim reverse joins - we can't know\n+        # if there is anything on the other side of the join, so trimming\n+        # reverse joins can't be done, ever.\n+        t = Tag.objects.create()\n+        qs = Tag.objects.filter(annotation__tag=t.pk)\n+        self.assertIn('INNER JOIN', str(qs.query))\n+        self.assertEquals(list(qs), [])"
        }
    ],
    "stats": {
        "total": 832,
        "additions": 564,
        "deletions": 268
    }
}