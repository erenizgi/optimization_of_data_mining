{
    "author": "andrewgodwin",
    "message": "Clean up unique validation tests to not use bare excepts and use assertRaises. Refs [16345].\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16348 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "da0c7cd7778ee99a31587276faee30e94a8255ae",
    "files": [
        {
            "sha": "ef890490c153d6e4e5f73a6680aceee504ca3edb",
            "filename": "tests/modeltests/validation/test_unique.py",
            "status": "modified",
            "additions": 12,
            "deletions": 36,
            "changes": 48,
            "blob_url": "https://github.com/django/django/blob/da0c7cd7778ee99a31587276faee30e94a8255ae/tests%2Fmodeltests%2Fvalidation%2Ftest_unique.py",
            "raw_url": "https://github.com/django/django/raw/da0c7cd7778ee99a31587276faee30e94a8255ae/tests%2Fmodeltests%2Fvalidation%2Ftest_unique.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fvalidation%2Ftest_unique.py?ref=da0c7cd7778ee99a31587276faee30e94a8255ae",
            "patch": "@@ -83,12 +83,9 @@ def test_unique_for_date(self):\n             slug=\"Django 1.0\", subtitle=\"Finally\", posted=datetime.date(2008, 9, 3))\n \n         p = Post(title=\"Django 1.0 is released\", posted=datetime.date(2008, 9, 3))\n-        try:\n+        with self.assertRaises(ValidationError) as cm:\n             p.full_clean()\n-        except ValidationError, e:\n-            self.assertEqual(e.message_dict, {'title': [u'Title must be unique for Posted date.']})\n-        else:\n-            self.fail('unique_for_date checks should catch this.')\n+        self.assertEqual(cm.exception.message_dict, {'title': [u'Title must be unique for Posted date.']})\n \n         # Should work without errors\n         p = Post(title=\"Work on Django 1.1 begins\", posted=datetime.date(2008, 9, 3))\n@@ -99,28 +96,19 @@ def test_unique_for_date(self):\n         p.full_clean()\n \n         p = Post(slug=\"Django 1.0\", posted=datetime.datetime(2008, 1, 1))\n-        try:\n+        with self.assertRaises(ValidationError) as cm:\n             p.full_clean()\n-        except ValidationError, e:\n-            self.assertEqual(e.message_dict, {'slug': [u'Slug must be unique for Posted year.']})\n-        else:\n-            self.fail('unique_for_year checks should catch this.')\n+        self.assertEqual(cm.exception.message_dict, {'slug': [u'Slug must be unique for Posted year.']})\n \n         p = Post(subtitle=\"Finally\", posted=datetime.datetime(2008, 9, 30))\n-        try:\n+        with self.assertRaises(ValidationError) as cm:\n             p.full_clean()\n-        except ValidationError, e:\n-            self.assertEqual(e.message_dict, {'subtitle': [u'Subtitle must be unique for Posted month.']})\n-        else:\n-            self.fail('unique_for_month checks should catch this.')\n+        self.assertEqual(cm.exception.message_dict, {'subtitle': [u'Subtitle must be unique for Posted month.']})\n \n         p = Post(title=\"Django 1.0 is released\")\n-        try:\n+        with self.assertRaises(ValidationError) as cm:\n             p.full_clean()\n-        except ValidationError, e:\n-            self.assertEqual(e.message_dict, {'posted': [u'This field cannot be null.']})\n-        else:\n-            self.fail(\"Model validation shouldn't allow an absent value for a DateField without null=True.\")\n+        self.assertEqual(cm.exception.message_dict, {'posted': [u'This field cannot be null.']})\n \n     def test_unique_for_date_with_nullable_date(self):\n         p1 = FlexibleDatePost.objects.create(title=\"Django 1.0 is released\",\n@@ -131,40 +119,28 @@ def test_unique_for_date_with_nullable_date(self):\n             p.full_clean()\n         except ValidationError, e:\n             self.fail(\"unique_for_date checks shouldn't trigger when the associated DateField is None.\")\n-        except:\n-            self.fail(\"unique_for_date checks shouldn't explode when the associated DateField is None.\")\n \n         p = FlexibleDatePost(slug=\"Django 1.0\")\n         try:\n             p.full_clean()\n         except ValidationError, e:\n             self.fail(\"unique_for_year checks shouldn't trigger when the associated DateField is None.\")\n-        except:\n-            self.fail(\"unique_for_year checks shouldn't explode when the associated DateField is None.\")\n \n         p = FlexibleDatePost(subtitle=\"Finally\")\n         try:\n             p.full_clean()\n         except ValidationError, e:\n             self.fail(\"unique_for_month checks shouldn't trigger when the associated DateField is None.\")\n-        except:\n-            self.fail(\"unique_for_month checks shouldn't explode when the associated DateField is None.\")\n \n     def test_unique_errors(self):\n         m1 = UniqueErrorsModel.objects.create(name='Some Name', number=10)\n         m = UniqueErrorsModel(name='Some Name', number=11)\n-        try:\n+        with self.assertRaises(ValidationError) as cm:\n             m.full_clean()\n-        except ValidationError, e:\n-            self.assertEqual(e.message_dict, {'name': [u'Custom unique name message.']})\n-        except:\n-            self.fail('unique checks should catch this.')\n+        self.assertEqual(cm.exception.message_dict, {'name': [u'Custom unique name message.']})\n \n         m = UniqueErrorsModel(name='Some Other Name', number=10)\n-        try:\n+        with self.assertRaises(ValidationError) as cm:\n             m.full_clean()\n-        except ValidationError, e:\n-            self.assertEqual(e.message_dict, {'number': [u'Custom unique number message.']})\n-        except:\n-            self.fail('unique checks should catch this.')\n+        self.assertEqual(cm.exception.message_dict, {'number': [u'Custom unique number message.']})\n             \n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 48,
        "additions": 12,
        "deletions": 36
    }
}