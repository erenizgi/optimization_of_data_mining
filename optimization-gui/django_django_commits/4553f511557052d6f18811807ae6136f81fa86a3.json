{
    "author": "claudep",
    "message": "Moved test_client_regress tests from models.py to tests.py",
    "sha": "4553f511557052d6f18811807ae6136f81fa86a3",
    "files": [
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/regressiontests/test_client_regress/models.py",
            "status": "modified",
            "additions": 0,
            "deletions": 1021,
            "changes": 1021,
            "blob_url": "https://github.com/django/django/blob/4553f511557052d6f18811807ae6136f81fa86a3/tests%2Fregressiontests%2Ftest_client_regress%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/4553f511557052d6f18811807ae6136f81fa86a3/tests%2Fregressiontests%2Ftest_client_regress%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftest_client_regress%2Fmodels.py?ref=4553f511557052d6f18811807ae6136f81fa86a3",
            "patch": "@@ -1,1021 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\"\"\"\n-Regression tests for the Test Client, especially the customized assertions.\n-\"\"\"\n-import os\n-\n-from django.conf import settings\n-from django.core.exceptions import SuspiciousOperation\n-from django.core.urlresolvers import reverse\n-from django.template import (TemplateDoesNotExist, TemplateSyntaxError,\n-    Context, Template, loader)\n-import django.template.context\n-from django.test import Client, TestCase\n-from django.test.client import encode_file, RequestFactory\n-from django.test.utils import ContextList, override_settings\n-from django.template.response import SimpleTemplateResponse\n-from django.http import HttpResponse\n-\n-\n-class AssertContainsTests(TestCase):\n-    def setUp(self):\n-        self.old_templates = settings.TEMPLATE_DIRS\n-        settings.TEMPLATE_DIRS = (os.path.join(os.path.dirname(__file__), 'templates'),)\n-\n-    def tearDown(self):\n-        settings.TEMPLATE_DIRS = self.old_templates\n-\n-    def test_contains(self):\n-        \"Responses can be inspected for content, including counting repeated substrings\"\n-        response = self.client.get('/test_client_regress/no_template_view/')\n-\n-        self.assertNotContains(response, 'never')\n-        self.assertContains(response, 'never', 0)\n-        self.assertContains(response, 'once')\n-        self.assertContains(response, 'once', 1)\n-        self.assertContains(response, 'twice')\n-        self.assertContains(response, 'twice', 2)\n-\n-        try:\n-            self.assertContains(response, 'text', status_code=999)\n-        except AssertionError as e:\n-            self.assertIn(\"Couldn't retrieve content: Response code was 200 (expected 999)\", str(e))\n-        try:\n-            self.assertContains(response, 'text', status_code=999, msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Couldn't retrieve content: Response code was 200 (expected 999)\", str(e))\n-\n-        try:\n-            self.assertNotContains(response, 'text', status_code=999)\n-        except AssertionError as e:\n-            self.assertIn(\"Couldn't retrieve content: Response code was 200 (expected 999)\", str(e))\n-        try:\n-            self.assertNotContains(response, 'text', status_code=999, msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Couldn't retrieve content: Response code was 200 (expected 999)\", str(e))\n-\n-        try:\n-            self.assertNotContains(response, 'once')\n-        except AssertionError as e:\n-            self.assertIn(\"Response should not contain 'once'\", str(e))\n-        try:\n-            self.assertNotContains(response, 'once', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Response should not contain 'once'\", str(e))\n-\n-        try:\n-            self.assertContains(response, 'never', 1)\n-        except AssertionError as e:\n-            self.assertIn(\"Found 0 instances of 'never' in response (expected 1)\", str(e))\n-        try:\n-            self.assertContains(response, 'never', 1, msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Found 0 instances of 'never' in response (expected 1)\", str(e))\n-\n-        try:\n-            self.assertContains(response, 'once', 0)\n-        except AssertionError as e:\n-            self.assertIn(\"Found 1 instances of 'once' in response (expected 0)\", str(e))\n-        try:\n-            self.assertContains(response, 'once', 0, msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Found 1 instances of 'once' in response (expected 0)\", str(e))\n-\n-        try:\n-            self.assertContains(response, 'once', 2)\n-        except AssertionError as e:\n-            self.assertIn(\"Found 1 instances of 'once' in response (expected 2)\", str(e))\n-        try:\n-            self.assertContains(response, 'once', 2, msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Found 1 instances of 'once' in response (expected 2)\", str(e))\n-\n-        try:\n-            self.assertContains(response, 'twice', 1)\n-        except AssertionError as e:\n-            self.assertIn(\"Found 2 instances of 'twice' in response (expected 1)\", str(e))\n-        try:\n-            self.assertContains(response, 'twice', 1, msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Found 2 instances of 'twice' in response (expected 1)\", str(e))\n-\n-        try:\n-            self.assertContains(response, 'thrice')\n-        except AssertionError as e:\n-            self.assertIn(\"Couldn't find 'thrice' in response\", str(e))\n-        try:\n-            self.assertContains(response, 'thrice', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Couldn't find 'thrice' in response\", str(e))\n-\n-        try:\n-            self.assertContains(response, 'thrice', 3)\n-        except AssertionError as e:\n-            self.assertIn(\"Found 0 instances of 'thrice' in response (expected 3)\", str(e))\n-        try:\n-            self.assertContains(response, 'thrice', 3, msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Found 0 instances of 'thrice' in response (expected 3)\", str(e))\n-\n-    def test_unicode_contains(self):\n-        \"Unicode characters can be found in template context\"\n-        #Regression test for #10183\n-        r = self.client.get('/test_client_regress/check_unicode/')\n-        self.assertContains(r, u'さかき')\n-        self.assertContains(r, b'\\xe5\\xb3\\xa0'.decode('utf-8'))\n-\n-    def test_unicode_not_contains(self):\n-        \"Unicode characters can be searched for, and not found in template context\"\n-        #Regression test for #10183\n-        r = self.client.get('/test_client_regress/check_unicode/')\n-        self.assertNotContains(r, u'はたけ')\n-        self.assertNotContains(r, b'\\xe3\\x81\\xaf\\xe3\\x81\\x9f\\xe3\\x81\\x91'.decode('utf-8'))\n-\n-    def test_assert_contains_renders_template_response(self):\n-        \"\"\" Test that we can pass in an unrendered SimpleTemplateReponse\n-            without throwing an error.\n-            Refs #15826.\n-        \"\"\"\n-        response = SimpleTemplateResponse(Template('Hello'), status=200)\n-        self.assertContains(response, 'Hello')\n-\n-    def test_assert_contains_using_non_template_response(self):\n-        \"\"\" Test that auto-rendering does not affect responses that aren't\n-            instances (or subclasses) of SimpleTemplateResponse.\n-            Refs #15826.\n-        \"\"\"\n-        response = HttpResponse('Hello')\n-        self.assertContains(response, 'Hello')\n-\n-    def test_assert_not_contains_renders_template_response(self):\n-        \"\"\" Test that we can pass in an unrendered SimpleTemplateReponse\n-            without throwing an error.\n-            Refs #15826.\n-        \"\"\"\n-        response = SimpleTemplateResponse(Template('Hello'), status=200)\n-        self.assertNotContains(response, 'Bye')\n-\n-    def test_assert_not_contains_using_non_template_response(self):\n-        \"\"\" Test that auto-rendering does not affect responses that aren't\n-            instances (or subclasses) of SimpleTemplateResponse.\n-            Refs #15826.\n-        \"\"\"\n-        response = HttpResponse('Hello')\n-        self.assertNotContains(response, 'Bye')\n-\n-@override_settings(PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',))\n-class AssertTemplateUsedTests(TestCase):\n-    fixtures = ['testdata.json']\n-\n-    def test_no_context(self):\n-        \"Template usage assertions work then templates aren't in use\"\n-        response = self.client.get('/test_client_regress/no_template_view/')\n-\n-        # Check that the no template case doesn't mess with the template assertions\n-        self.assertTemplateNotUsed(response, 'GET Template')\n-\n-        try:\n-            self.assertTemplateUsed(response, 'GET Template')\n-        except AssertionError as e:\n-            self.assertIn(\"No templates used to render the response\", str(e))\n-\n-        try:\n-            self.assertTemplateUsed(response, 'GET Template', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: No templates used to render the response\", str(e))\n-\n-    def test_single_context(self):\n-        \"Template assertions work when there is a single context\"\n-        response = self.client.get('/test_client/post_view/', {})\n-\n-        try:\n-            self.assertTemplateNotUsed(response, 'Empty GET Template')\n-        except AssertionError as e:\n-            self.assertIn(\"Template 'Empty GET Template' was used unexpectedly in rendering the response\", str(e))\n-\n-        try:\n-            self.assertTemplateNotUsed(response, 'Empty GET Template', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Template 'Empty GET Template' was used unexpectedly in rendering the response\", str(e))\n-\n-        try:\n-            self.assertTemplateUsed(response, 'Empty POST Template')\n-        except AssertionError as e:\n-            self.assertIn(\"Template 'Empty POST Template' was not a template used to render the response. Actual template(s) used: Empty GET Template\", str(e))\n-\n-        try:\n-            self.assertTemplateUsed(response, 'Empty POST Template', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Template 'Empty POST Template' was not a template used to render the response. Actual template(s) used: Empty GET Template\", str(e))\n-\n-    def test_multiple_context(self):\n-        \"Template assertions work when there are multiple contexts\"\n-        post_data = {\n-            'text': 'Hello World',\n-            'email': 'foo@example.com',\n-            'value': 37,\n-            'single': 'b',\n-            'multi': ('b','c','e')\n-        }\n-        response = self.client.post('/test_client/form_view_with_template/', post_data)\n-        self.assertContains(response, 'POST data OK')\n-        try:\n-            self.assertTemplateNotUsed(response, \"form_view.html\")\n-        except AssertionError as e:\n-            self.assertIn(\"Template 'form_view.html' was used unexpectedly in rendering the response\", str(e))\n-\n-        try:\n-            self.assertTemplateNotUsed(response, 'base.html')\n-        except AssertionError as e:\n-            self.assertIn(\"Template 'base.html' was used unexpectedly in rendering the response\", str(e))\n-\n-        try:\n-            self.assertTemplateUsed(response, \"Valid POST Template\")\n-        except AssertionError as e:\n-            self.assertIn(\"Template 'Valid POST Template' was not a template used to render the response. Actual template(s) used: form_view.html, base.html\", str(e))\n-\n-class AssertRedirectsTests(TestCase):\n-    def test_redirect_page(self):\n-        \"An assertion is raised if the original page couldn't be retrieved as expected\"\n-        # This page will redirect with code 301, not 302\n-        response = self.client.get('/test_client/permanent_redirect_view/')\n-        try:\n-            self.assertRedirects(response, '/test_client/get_view/')\n-        except AssertionError as e:\n-            self.assertIn(\"Response didn't redirect as expected: Response code was 301 (expected 302)\", str(e))\n-\n-        try:\n-            self.assertRedirects(response, '/test_client/get_view/', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Response didn't redirect as expected: Response code was 301 (expected 302)\", str(e))\n-\n-    def test_lost_query(self):\n-        \"An assertion is raised if the redirect location doesn't preserve GET parameters\"\n-        response = self.client.get('/test_client/redirect_view/', {'var': 'value'})\n-        try:\n-            self.assertRedirects(response, '/test_client/get_view/')\n-        except AssertionError as e:\n-            self.assertIn(\"Response redirected to 'http://testserver/test_client/get_view/?var=value', expected 'http://testserver/test_client/get_view/'\", str(e))\n-\n-        try:\n-            self.assertRedirects(response, '/test_client/get_view/', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Response redirected to 'http://testserver/test_client/get_view/?var=value', expected 'http://testserver/test_client/get_view/'\", str(e))\n-\n-    def test_incorrect_target(self):\n-        \"An assertion is raised if the response redirects to another target\"\n-        response = self.client.get('/test_client/permanent_redirect_view/')\n-        try:\n-            # Should redirect to get_view\n-            self.assertRedirects(response, '/test_client/some_view/')\n-        except AssertionError as e:\n-            self.assertIn(\"Response didn't redirect as expected: Response code was 301 (expected 302)\", str(e))\n-\n-    def test_target_page(self):\n-        \"An assertion is raised if the response redirect target cannot be retrieved as expected\"\n-        response = self.client.get('/test_client/double_redirect_view/')\n-        try:\n-            # The redirect target responds with a 301 code, not 200\n-            self.assertRedirects(response, 'http://testserver/test_client/permanent_redirect_view/')\n-        except AssertionError as e:\n-            self.assertIn(\"Couldn't retrieve redirection page '/test_client/permanent_redirect_view/': response code was 301 (expected 200)\", str(e))\n-\n-        try:\n-            # The redirect target responds with a 301 code, not 200\n-            self.assertRedirects(response, 'http://testserver/test_client/permanent_redirect_view/', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Couldn't retrieve redirection page '/test_client/permanent_redirect_view/': response code was 301 (expected 200)\", str(e))\n-\n-    def test_redirect_chain(self):\n-        \"You can follow a redirect chain of multiple redirects\"\n-        response = self.client.get('/test_client_regress/redirects/further/more/', {}, follow=True)\n-        self.assertRedirects(response, '/test_client_regress/no_template_view/',\n-            status_code=301, target_status_code=200)\n-\n-        self.assertEqual(len(response.redirect_chain), 1)\n-        self.assertEqual(response.redirect_chain[0], ('http://testserver/test_client_regress/no_template_view/', 301))\n-\n-    def test_multiple_redirect_chain(self):\n-        \"You can follow a redirect chain of multiple redirects\"\n-        response = self.client.get('/test_client_regress/redirects/', {}, follow=True)\n-        self.assertRedirects(response, '/test_client_regress/no_template_view/',\n-            status_code=301, target_status_code=200)\n-\n-        self.assertEqual(len(response.redirect_chain), 3)\n-        self.assertEqual(response.redirect_chain[0], ('http://testserver/test_client_regress/redirects/further/', 301))\n-        self.assertEqual(response.redirect_chain[1], ('http://testserver/test_client_regress/redirects/further/more/', 301))\n-        self.assertEqual(response.redirect_chain[2], ('http://testserver/test_client_regress/no_template_view/', 301))\n-\n-    def test_redirect_chain_to_non_existent(self):\n-        \"You can follow a chain to a non-existent view\"\n-        response = self.client.get('/test_client_regress/redirect_to_non_existent_view2/', {}, follow=True)\n-        self.assertRedirects(response, '/test_client_regress/non_existent_view/',\n-            status_code=301, target_status_code=404)\n-\n-    def test_redirect_chain_to_self(self):\n-        \"Redirections to self are caught and escaped\"\n-        response = self.client.get('/test_client_regress/redirect_to_self/', {}, follow=True)\n-        # The chain of redirects stops once the cycle is detected.\n-        self.assertRedirects(response, '/test_client_regress/redirect_to_self/',\n-            status_code=301, target_status_code=301)\n-        self.assertEqual(len(response.redirect_chain), 2)\n-\n-    def test_circular_redirect(self):\n-        \"Circular redirect chains are caught and escaped\"\n-        response = self.client.get('/test_client_regress/circular_redirect_1/', {}, follow=True)\n-        # The chain of redirects will get back to the starting point, but stop there.\n-        self.assertRedirects(response, '/test_client_regress/circular_redirect_2/',\n-            status_code=301, target_status_code=301)\n-        self.assertEqual(len(response.redirect_chain), 4)\n-\n-    def test_redirect_chain_post(self):\n-        \"A redirect chain will be followed from an initial POST post\"\n-        response = self.client.post('/test_client_regress/redirects/',\n-            {'nothing': 'to_send'}, follow=True)\n-        self.assertRedirects(response,\n-            '/test_client_regress/no_template_view/', 301, 200)\n-        self.assertEqual(len(response.redirect_chain), 3)\n-\n-    def test_redirect_chain_head(self):\n-        \"A redirect chain will be followed from an initial HEAD request\"\n-        response = self.client.head('/test_client_regress/redirects/',\n-            {'nothing': 'to_send'}, follow=True)\n-        self.assertRedirects(response,\n-            '/test_client_regress/no_template_view/', 301, 200)\n-        self.assertEqual(len(response.redirect_chain), 3)\n-\n-    def test_redirect_chain_options(self):\n-        \"A redirect chain will be followed from an initial OPTIONS request\"\n-        response = self.client.options('/test_client_regress/redirects/',\n-            follow=True)\n-        self.assertRedirects(response,\n-            '/test_client_regress/no_template_view/', 301, 200)\n-        self.assertEqual(len(response.redirect_chain), 3)\n-\n-    def test_redirect_chain_put(self):\n-        \"A redirect chain will be followed from an initial PUT request\"\n-        response = self.client.put('/test_client_regress/redirects/',\n-            follow=True)\n-        self.assertRedirects(response,\n-            '/test_client_regress/no_template_view/', 301, 200)\n-        self.assertEqual(len(response.redirect_chain), 3)\n-\n-    def test_redirect_chain_delete(self):\n-        \"A redirect chain will be followed from an initial DELETE request\"\n-        response = self.client.delete('/test_client_regress/redirects/',\n-            follow=True)\n-        self.assertRedirects(response,\n-            '/test_client_regress/no_template_view/', 301, 200)\n-        self.assertEqual(len(response.redirect_chain), 3)\n-\n-    def test_redirect_to_different_host(self):\n-        \"The test client will preserve scheme, host and port changes\"\n-        response = self.client.get('/test_client_regress/redirect_other_host/', follow=True)\n-        self.assertRedirects(response,\n-            'https://otherserver:8443/test_client_regress/no_template_view/',\n-            status_code=301, target_status_code=200)\n-        # We can't use is_secure() or get_host()\n-        # because response.request is a dictionary, not an HttpRequest\n-        self.assertEqual(response.request.get('wsgi.url_scheme'), 'https')\n-        self.assertEqual(response.request.get('SERVER_NAME'), 'otherserver')\n-        self.assertEqual(response.request.get('SERVER_PORT'), '8443')\n-\n-    def test_redirect_chain_on_non_redirect_page(self):\n-        \"An assertion is raised if the original page couldn't be retrieved as expected\"\n-        # This page will redirect with code 301, not 302\n-        response = self.client.get('/test_client/get_view/', follow=True)\n-        try:\n-            self.assertRedirects(response, '/test_client/get_view/')\n-        except AssertionError as e:\n-            self.assertIn(\"Response didn't redirect as expected: Response code was 200 (expected 302)\", str(e))\n-\n-        try:\n-            self.assertRedirects(response, '/test_client/get_view/', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Response didn't redirect as expected: Response code was 200 (expected 302)\", str(e))\n-\n-    def test_redirect_on_non_redirect_page(self):\n-        \"An assertion is raised if the original page couldn't be retrieved as expected\"\n-        # This page will redirect with code 301, not 302\n-        response = self.client.get('/test_client/get_view/')\n-        try:\n-            self.assertRedirects(response, '/test_client/get_view/')\n-        except AssertionError as e:\n-            self.assertIn(\"Response didn't redirect as expected: Response code was 200 (expected 302)\", str(e))\n-\n-        try:\n-            self.assertRedirects(response, '/test_client/get_view/', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: Response didn't redirect as expected: Response code was 200 (expected 302)\", str(e))\n-\n-\n-class AssertFormErrorTests(TestCase):\n-    def test_unknown_form(self):\n-        \"An assertion is raised if the form name is unknown\"\n-        post_data = {\n-            'text': 'Hello World',\n-            'email': 'not an email address',\n-            'value': 37,\n-            'single': 'b',\n-            'multi': ('b','c','e')\n-        }\n-        response = self.client.post('/test_client/form_view/', post_data)\n-        self.assertEqual(response.status_code, 200)\n-        self.assertTemplateUsed(response, \"Invalid POST Template\")\n-\n-        try:\n-            self.assertFormError(response, 'wrong_form', 'some_field', 'Some error.')\n-        except AssertionError as e:\n-            self.assertIn(\"The form 'wrong_form' was not used to render the response\", str(e))\n-        try:\n-            self.assertFormError(response, 'wrong_form', 'some_field', 'Some error.', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: The form 'wrong_form' was not used to render the response\", str(e))\n-\n-    def test_unknown_field(self):\n-        \"An assertion is raised if the field name is unknown\"\n-        post_data = {\n-            'text': 'Hello World',\n-            'email': 'not an email address',\n-            'value': 37,\n-            'single': 'b',\n-            'multi': ('b','c','e')\n-        }\n-        response = self.client.post('/test_client/form_view/', post_data)\n-        self.assertEqual(response.status_code, 200)\n-        self.assertTemplateUsed(response, \"Invalid POST Template\")\n-\n-        try:\n-            self.assertFormError(response, 'form', 'some_field', 'Some error.')\n-        except AssertionError as e:\n-            self.assertIn(\"The form 'form' in context 0 does not contain the field 'some_field'\", str(e))\n-        try:\n-            self.assertFormError(response, 'form', 'some_field', 'Some error.', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: The form 'form' in context 0 does not contain the field 'some_field'\", str(e))\n-\n-    def test_noerror_field(self):\n-        \"An assertion is raised if the field doesn't have any errors\"\n-        post_data = {\n-            'text': 'Hello World',\n-            'email': 'not an email address',\n-            'value': 37,\n-            'single': 'b',\n-            'multi': ('b','c','e')\n-        }\n-        response = self.client.post('/test_client/form_view/', post_data)\n-        self.assertEqual(response.status_code, 200)\n-        self.assertTemplateUsed(response, \"Invalid POST Template\")\n-\n-        try:\n-            self.assertFormError(response, 'form', 'value', 'Some error.')\n-        except AssertionError as e:\n-            self.assertIn(\"The field 'value' on form 'form' in context 0 contains no errors\", str(e))\n-        try:\n-            self.assertFormError(response, 'form', 'value', 'Some error.', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: The field 'value' on form 'form' in context 0 contains no errors\", str(e))\n-\n-    def test_unknown_error(self):\n-        \"An assertion is raised if the field doesn't contain the provided error\"\n-        post_data = {\n-            'text': 'Hello World',\n-            'email': 'not an email address',\n-            'value': 37,\n-            'single': 'b',\n-            'multi': ('b','c','e')\n-        }\n-        response = self.client.post('/test_client/form_view/', post_data)\n-        self.assertEqual(response.status_code, 200)\n-        self.assertTemplateUsed(response, \"Invalid POST Template\")\n-\n-        try:\n-            self.assertFormError(response, 'form', 'email', 'Some error.')\n-        except AssertionError as e:\n-            self.assertIn(\"The field 'email' on form 'form' in context 0 does not contain the error 'Some error.' (actual errors: [u'Enter a valid e-mail address.'])\", str(e))\n-        try:\n-            self.assertFormError(response, 'form', 'email', 'Some error.', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: The field 'email' on form 'form' in context 0 does not contain the error 'Some error.' (actual errors: [u'Enter a valid e-mail address.'])\", str(e))\n-\n-    def test_unknown_nonfield_error(self):\n-        \"\"\"\n-        Checks that an assertion is raised if the form's non field errors\n-        doesn't contain the provided error.\n-        \"\"\"\n-        post_data = {\n-            'text': 'Hello World',\n-            'email': 'not an email address',\n-            'value': 37,\n-            'single': 'b',\n-            'multi': ('b','c','e')\n-        }\n-        response = self.client.post('/test_client/form_view/', post_data)\n-        self.assertEqual(response.status_code, 200)\n-        self.assertTemplateUsed(response, \"Invalid POST Template\")\n-\n-        try:\n-            self.assertFormError(response, 'form', None, 'Some error.')\n-        except AssertionError as e:\n-            self.assertIn(\"The form 'form' in context 0 does not contain the non-field error 'Some error.' (actual errors: )\", str(e))\n-        try:\n-            self.assertFormError(response, 'form', None, 'Some error.', msg_prefix='abc')\n-        except AssertionError as e:\n-            self.assertIn(\"abc: The form 'form' in context 0 does not contain the non-field error 'Some error.' (actual errors: )\", str(e))\n-\n-@override_settings(PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',))\n-class LoginTests(TestCase):\n-    fixtures = ['testdata']\n-\n-    def test_login_different_client(self):\n-        \"Check that using a different test client doesn't violate authentication\"\n-\n-        # Create a second client, and log in.\n-        c = Client()\n-        login = c.login(username='testclient', password='password')\n-        self.assertTrue(login, 'Could not log in')\n-\n-        # Get a redirection page with the second client.\n-        response = c.get(\"/test_client_regress/login_protected_redirect_view/\")\n-\n-        # At this points, the self.client isn't logged in.\n-        # Check that assertRedirects uses the original client, not the\n-        # default client.\n-        self.assertRedirects(response, \"http://testserver/test_client_regress/get_view/\")\n-\n-\n-@override_settings(PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',))\n-class SessionEngineTests(TestCase):\n-    fixtures = ['testdata']\n-\n-    def setUp(self):\n-        self.old_SESSION_ENGINE = settings.SESSION_ENGINE\n-        settings.SESSION_ENGINE = 'regressiontests.test_client_regress.session'\n-\n-    def tearDown(self):\n-        settings.SESSION_ENGINE = self.old_SESSION_ENGINE\n-\n-    def test_login(self):\n-        \"A session engine that modifies the session key can be used to log in\"\n-        login = self.client.login(username='testclient', password='password')\n-        self.assertTrue(login, 'Could not log in')\n-\n-        # Try to access a login protected page.\n-        response = self.client.get(\"/test_client/login_protected_view/\")\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.context['user'].username, 'testclient')\n-\n-\n-class URLEscapingTests(TestCase):\n-    def test_simple_argument_get(self):\n-        \"Get a view that has a simple string argument\"\n-        response = self.client.get(reverse('arg_view', args=['Slartibartfast']))\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'Howdy, Slartibartfast')\n-\n-    def test_argument_with_space_get(self):\n-        \"Get a view that has a string argument that requires escaping\"\n-        response = self.client.get(reverse('arg_view', args=['Arthur Dent']))\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'Hi, Arthur')\n-\n-    def test_simple_argument_post(self):\n-        \"Post for a view that has a simple string argument\"\n-        response = self.client.post(reverse('arg_view', args=['Slartibartfast']))\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'Howdy, Slartibartfast')\n-\n-    def test_argument_with_space_post(self):\n-        \"Post for a view that has a string argument that requires escaping\"\n-        response = self.client.post(reverse('arg_view', args=['Arthur Dent']))\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'Hi, Arthur')\n-\n-@override_settings(PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',))\n-class ExceptionTests(TestCase):\n-    fixtures = ['testdata.json']\n-\n-    def test_exception_cleared(self):\n-        \"#5836 - A stale user exception isn't re-raised by the test client.\"\n-\n-        login = self.client.login(username='testclient',password='password')\n-        self.assertTrue(login, 'Could not log in')\n-        try:\n-            response = self.client.get(\"/test_client_regress/staff_only/\")\n-            self.fail(\"General users should not be able to visit this page\")\n-        except SuspiciousOperation:\n-            pass\n-\n-        # At this point, an exception has been raised, and should be cleared.\n-\n-        # This next operation should be successful; if it isn't we have a problem.\n-        login = self.client.login(username='staff', password='password')\n-        self.assertTrue(login, 'Could not log in')\n-        try:\n-            self.client.get(\"/test_client_regress/staff_only/\")\n-        except SuspiciousOperation:\n-            self.fail(\"Staff should be able to visit this page\")\n-\n-class TemplateExceptionTests(TestCase):\n-    def setUp(self):\n-        # Reset the loaders so they don't try to render cached templates.\n-        if loader.template_source_loaders is not None:\n-            for template_loader in loader.template_source_loaders:\n-                if hasattr(template_loader, 'reset'):\n-                    template_loader.reset()\n-        self.old_templates = settings.TEMPLATE_DIRS\n-        settings.TEMPLATE_DIRS = ()\n-\n-    def tearDown(self):\n-        settings.TEMPLATE_DIRS = self.old_templates\n-\n-    def test_no_404_template(self):\n-        \"Missing templates are correctly reported by test client\"\n-        try:\n-            response = self.client.get(\"/no_such_view/\")\n-            self.fail(\"Should get error about missing template\")\n-        except TemplateDoesNotExist:\n-            pass\n-\n-    def test_bad_404_template(self):\n-        \"Errors found when rendering 404 error templates are re-raised\"\n-        settings.TEMPLATE_DIRS = (os.path.join(os.path.dirname(__file__), 'bad_templates'),)\n-        try:\n-            response = self.client.get(\"/no_such_view/\")\n-            self.fail(\"Should get error about syntax error in template\")\n-        except TemplateSyntaxError:\n-            pass\n-\n-# We need two different tests to check URLconf substitution -  one to check\n-# it was changed, and another one (without self.urls) to check it was reverted on\n-# teardown. This pair of tests relies upon the alphabetical ordering of test execution.\n-class UrlconfSubstitutionTests(TestCase):\n-    urls = 'regressiontests.test_client_regress.urls'\n-\n-    def test_urlconf_was_changed(self):\n-        \"TestCase can enforce a custom URLconf on a per-test basis\"\n-        url = reverse('arg_view', args=['somename'])\n-        self.assertEqual(url, '/arg_view/somename/')\n-\n-# This test needs to run *after* UrlconfSubstitutionTests; the zz prefix in the\n-# name is to ensure alphabetical ordering.\n-class zzUrlconfSubstitutionTests(TestCase):\n-    def test_urlconf_was_reverted(self):\n-        \"URLconf is reverted to original value after modification in a TestCase\"\n-        url = reverse('arg_view', args=['somename'])\n-        self.assertEqual(url, '/test_client_regress/arg_view/somename/')\n-\n-@override_settings(PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',))\n-class ContextTests(TestCase):\n-    fixtures = ['testdata']\n-\n-    def test_single_context(self):\n-        \"Context variables can be retrieved from a single context\"\n-        response = self.client.get(\"/test_client_regress/request_data/\", data={'foo':'whiz'})\n-        self.assertEqual(response.context.__class__, Context)\n-        self.assertTrue('get-foo' in response.context)\n-        self.assertEqual(response.context['get-foo'], 'whiz')\n-        self.assertEqual(response.context['request-foo'], 'whiz')\n-        self.assertEqual(response.context['data'], 'sausage')\n-\n-        try:\n-            response.context['does-not-exist']\n-            self.fail('Should not be able to retrieve non-existent key')\n-        except KeyError as e:\n-            self.assertEqual(e.args[0], 'does-not-exist')\n-\n-    def test_inherited_context(self):\n-        \"Context variables can be retrieved from a list of contexts\"\n-        response = self.client.get(\"/test_client_regress/request_data_extended/\", data={'foo':'whiz'})\n-        self.assertEqual(response.context.__class__, ContextList)\n-        self.assertEqual(len(response.context), 2)\n-        self.assertTrue('get-foo' in response.context)\n-        self.assertEqual(response.context['get-foo'], 'whiz')\n-        self.assertEqual(response.context['request-foo'], 'whiz')\n-        self.assertEqual(response.context['data'], 'bacon')\n-\n-        try:\n-            response.context['does-not-exist']\n-            self.fail('Should not be able to retrieve non-existent key')\n-        except KeyError as e:\n-            self.assertEqual(e.args[0], 'does-not-exist')\n-\n-    def test_15368(self):\n-        # Need to insert a context processor that assumes certain things about\n-        # the request instance. This triggers a bug caused by some ways of\n-        # copying RequestContext.\n-        try:\n-            django.template.context._standard_context_processors = (lambda request: {'path': request.special_path},)\n-            response = self.client.get(\"/test_client_regress/request_context_view/\")\n-            self.assertContains(response, 'Path: /test_client_regress/request_context_view/')\n-        finally:\n-            django.template.context._standard_context_processors = None\n-\n-\n-@override_settings(PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',))\n-class SessionTests(TestCase):\n-    fixtures = ['testdata.json']\n-\n-    def test_session(self):\n-        \"The session isn't lost if a user logs in\"\n-        # The session doesn't exist to start.\n-        response = self.client.get('/test_client_regress/check_session/')\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'NO')\n-\n-        # This request sets a session variable.\n-        response = self.client.get('/test_client_regress/set_session/')\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'set_session')\n-\n-        # Check that the session has been modified\n-        response = self.client.get('/test_client_regress/check_session/')\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'YES')\n-\n-        # Log in\n-        login = self.client.login(username='testclient',password='password')\n-        self.assertTrue(login, 'Could not log in')\n-\n-        # Session should still contain the modified value\n-        response = self.client.get('/test_client_regress/check_session/')\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'YES')\n-\n-    def test_logout(self):\n-        \"\"\"Logout should work whether the user is logged in or not (#9978).\"\"\"\n-        self.client.logout()\n-        login = self.client.login(username='testclient',password='password')\n-        self.assertTrue(login, 'Could not log in')\n-        self.client.logout()\n-        self.client.logout()\n-\n-class RequestMethodTests(TestCase):\n-    def test_get(self):\n-        \"Request a view via request method GET\"\n-        response = self.client.get('/test_client_regress/request_methods/')\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'request method: GET')\n-\n-    def test_post(self):\n-        \"Request a view via request method POST\"\n-        response = self.client.post('/test_client_regress/request_methods/')\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'request method: POST')\n-\n-    def test_head(self):\n-        \"Request a view via request method HEAD\"\n-        response = self.client.head('/test_client_regress/request_methods/')\n-        self.assertEqual(response.status_code, 200)\n-        # A HEAD request doesn't return any content.\n-        self.assertNotEqual(response.content, b'request method: HEAD')\n-        self.assertEqual(response.content, b'')\n-\n-    def test_options(self):\n-        \"Request a view via request method OPTIONS\"\n-        response = self.client.options('/test_client_regress/request_methods/')\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'request method: OPTIONS')\n-\n-    def test_put(self):\n-        \"Request a view via request method PUT\"\n-        response = self.client.put('/test_client_regress/request_methods/')\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'request method: PUT')\n-\n-    def test_delete(self):\n-        \"Request a view via request method DELETE\"\n-        response = self.client.delete('/test_client_regress/request_methods/')\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'request method: DELETE')\n-\n-class RequestMethodStringDataTests(TestCase):\n-    def test_post(self):\n-        \"Request a view with string data via request method POST\"\n-        # Regression test for #11371\n-        data = u'{\"test\": \"json\"}'\n-        response = self.client.post('/test_client_regress/request_methods/', data=data, content_type='application/json')\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'request method: POST')\n-\n-    def test_put(self):\n-        \"Request a view with string data via request method PUT\"\n-        # Regression test for #11371\n-        data = u'{\"test\": \"json\"}'\n-        response = self.client.put('/test_client_regress/request_methods/', data=data, content_type='application/json')\n-        self.assertEqual(response.status_code, 200)\n-        self.assertEqual(response.content, b'request method: PUT')\n-\n-class QueryStringTests(TestCase):\n-    def test_get_like_requests(self):\n-        # See: https://code.djangoproject.com/ticket/10571.\n-        for method_name in ('get', 'head'):\n-            # A GET-like request can pass a query string as data\n-            method = getattr(self.client, method_name)\n-            response = method(\"/test_client_regress/request_data/\", data={'foo':'whiz'})\n-            self.assertEqual(response.context['get-foo'], 'whiz')\n-            self.assertEqual(response.context['request-foo'], 'whiz')\n-\n-            # A GET-like request can pass a query string as part of the URL\n-            response = method(\"/test_client_regress/request_data/?foo=whiz\")\n-            self.assertEqual(response.context['get-foo'], 'whiz')\n-            self.assertEqual(response.context['request-foo'], 'whiz')\n-\n-            # Data provided in the URL to a GET-like request is overridden by actual form data\n-            response = method(\"/test_client_regress/request_data/?foo=whiz\", data={'foo':'bang'})\n-            self.assertEqual(response.context['get-foo'], 'bang')\n-            self.assertEqual(response.context['request-foo'], 'bang')\n-\n-            response = method(\"/test_client_regress/request_data/?foo=whiz\", data={'bar':'bang'})\n-            self.assertEqual(response.context['get-foo'], None)\n-            self.assertEqual(response.context['get-bar'], 'bang')\n-            self.assertEqual(response.context['request-foo'], None)\n-            self.assertEqual(response.context['request-bar'], 'bang')\n-\n-    def test_post_like_requests(self):\n-        # A POST-like request can pass a query string as data\n-        response = self.client.post(\"/test_client_regress/request_data/\", data={'foo':'whiz'})\n-        self.assertEqual(response.context['get-foo'], None)\n-        self.assertEqual(response.context['post-foo'], 'whiz')\n-\n-        # A POST-like request can pass a query string as part of the URL\n-        response = self.client.post(\"/test_client_regress/request_data/?foo=whiz\")\n-        self.assertEqual(response.context['get-foo'], 'whiz')\n-        self.assertEqual(response.context['post-foo'], None)\n-        self.assertEqual(response.context['request-foo'], 'whiz')\n-\n-        # POST data provided in the URL augments actual form data\n-        response = self.client.post(\"/test_client_regress/request_data/?foo=whiz\", data={'foo':'bang'})\n-        self.assertEqual(response.context['get-foo'], 'whiz')\n-        self.assertEqual(response.context['post-foo'], 'bang')\n-        self.assertEqual(response.context['request-foo'], 'bang')\n-\n-        response = self.client.post(\"/test_client_regress/request_data/?foo=whiz\", data={'bar':'bang'})\n-        self.assertEqual(response.context['get-foo'], 'whiz')\n-        self.assertEqual(response.context['get-bar'], None)\n-        self.assertEqual(response.context['post-foo'], None)\n-        self.assertEqual(response.context['post-bar'], 'bang')\n-        self.assertEqual(response.context['request-foo'], 'whiz')\n-        self.assertEqual(response.context['request-bar'], 'bang')\n-\n-class UnicodePayloadTests(TestCase):\n-    def test_simple_unicode_payload(self):\n-        \"A simple ASCII-only unicode JSON document can be POSTed\"\n-        # Regression test for #10571\n-        json = u'{\"english\": \"mountain pass\"}'\n-        response = self.client.post(\"/test_client_regress/parse_unicode_json/\", json,\n-                                    content_type=\"application/json\")\n-        self.assertEqual(response.content, json)\n-\n-    def test_unicode_payload_utf8(self):\n-        \"A non-ASCII unicode data encoded as UTF-8 can be POSTed\"\n-        # Regression test for #10571\n-        json = u'{\"dog\": \"собака\"}'\n-        response = self.client.post(\"/test_client_regress/parse_unicode_json/\", json,\n-                                    content_type=\"application/json; charset=utf-8\")\n-        self.assertEqual(response.content, json.encode('utf-8'))\n-\n-    def test_unicode_payload_utf16(self):\n-        \"A non-ASCII unicode data encoded as UTF-16 can be POSTed\"\n-        # Regression test for #10571\n-        json = u'{\"dog\": \"собака\"}'\n-        response = self.client.post(\"/test_client_regress/parse_unicode_json/\", json,\n-                                    content_type=\"application/json; charset=utf-16\")\n-        self.assertEqual(response.content, json.encode('utf-16'))\n-\n-    def test_unicode_payload_non_utf(self):\n-        \"A non-ASCII unicode data as a non-UTF based encoding can be POSTed\"\n-        #Regression test for #10571\n-        json = u'{\"dog\": \"собака\"}'\n-        response = self.client.post(\"/test_client_regress/parse_unicode_json/\", json,\n-                                    content_type=\"application/json; charset=koi8-r\")\n-        self.assertEqual(response.content, json.encode('koi8-r'))\n-\n-class DummyFile(object):\n-    def __init__(self, filename):\n-        self.name = filename\n-    def read(self):\n-        return 'TEST_FILE_CONTENT'\n-\n-class UploadedFileEncodingTest(TestCase):\n-    def test_file_encoding(self):\n-        encoded_file = encode_file('TEST_BOUNDARY', 'TEST_KEY', DummyFile('test_name.bin'))\n-        self.assertEqual(b'--TEST_BOUNDARY', encoded_file[0])\n-        self.assertEqual(b'Content-Disposition: form-data; name=\"TEST_KEY\"; filename=\"test_name.bin\"', encoded_file[1])\n-        self.assertEqual(b'TEST_FILE_CONTENT', encoded_file[-1])\n-\n-    def test_guesses_content_type_on_file_encoding(self):\n-        self.assertEqual(b'Content-Type: application/octet-stream',\n-                         encode_file('IGNORE', 'IGNORE', DummyFile(\"file.bin\"))[2])\n-        self.assertEqual(b'Content-Type: text/plain',\n-                         encode_file('IGNORE', 'IGNORE', DummyFile(\"file.txt\"))[2])\n-        self.assertIn(encode_file('IGNORE', 'IGNORE', DummyFile(\"file.zip\"))[2], (\n-                        b'Content-Type: application/x-compress',\n-                        b'Content-Type: application/x-zip',\n-                        b'Content-Type: application/x-zip-compressed',\n-                        b'Content-Type: application/zip',))\n-        self.assertEqual(b'Content-Type: application/octet-stream',\n-                         encode_file('IGNORE', 'IGNORE', DummyFile(\"file.unknown\"))[2])\n-\n-class RequestHeadersTest(TestCase):\n-    def test_client_headers(self):\n-        \"A test client can receive custom headers\"\n-        response = self.client.get(\"/test_client_regress/check_headers/\", HTTP_X_ARG_CHECK='Testing 123')\n-        self.assertEqual(response.content, b\"HTTP_X_ARG_CHECK: Testing 123\")\n-        self.assertEqual(response.status_code, 200)\n-\n-    def test_client_headers_redirect(self):\n-        \"Test client headers are preserved through redirects\"\n-        response = self.client.get(\"/test_client_regress/check_headers_redirect/\", follow=True, HTTP_X_ARG_CHECK='Testing 123')\n-        self.assertEqual(response.content, b\"HTTP_X_ARG_CHECK: Testing 123\")\n-        self.assertRedirects(response, '/test_client_regress/check_headers/',\n-            status_code=301, target_status_code=200)\n-\n-\n-class ReadLimitedStreamTest(TestCase):\n-    \"\"\"\n-    Tests that ensure that HttpRequest.body, HttpRequest.read() and\n-    HttpRequest.read(BUFFER) have proper LimitedStream behavior.\n-\n-    Refs #14753, #15785\n-    \"\"\"\n-\n-    def test_body_from_empty_request(self):\n-        \"\"\"HttpRequest.body on a test client GET request should return\n-        the empty string.\"\"\"\n-        self.assertEqual(self.client.get(\"/test_client_regress/body/\").content, b'')\n-\n-    def test_read_from_empty_request(self):\n-        \"\"\"HttpRequest.read() on a test client GET request should return the\n-        empty string.\"\"\"\n-        self.assertEqual(self.client.get(\"/test_client_regress/read_all/\").content, b'')\n-\n-    def test_read_numbytes_from_empty_request(self):\n-        \"\"\"HttpRequest.read(LARGE_BUFFER) on a test client GET request should\n-        return the empty string.\"\"\"\n-        self.assertEqual(self.client.get(\"/test_client_regress/read_buffer/\").content, b'')\n-\n-    def test_read_from_nonempty_request(self):\n-        \"\"\"HttpRequest.read() on a test client PUT request with some payload\n-        should return that payload.\"\"\"\n-        payload = b'foobar'\n-        self.assertEqual(self.client.put(\"/test_client_regress/read_all/\",\n-                                          data=payload,\n-                                          content_type='text/plain').content, payload)\n-\n-    def test_read_numbytes_from_nonempty_request(self):\n-        \"\"\"HttpRequest.read(LARGE_BUFFER) on a test client PUT request with\n-        some payload should return that payload.\"\"\"\n-        payload = b'foobar'\n-        self.assertEqual(self.client.put(\"/test_client_regress/read_buffer/\",\n-                                          data=payload,\n-                                          content_type='text/plain').content, payload)\n-\n-\n-class RequestFactoryStateTest(TestCase):\n-    \"\"\"Regression tests for #15929.\"\"\"\n-    # These tests are checking that certain middleware don't change certain\n-    # global state. Alternatively, from the point of view of a test, they are\n-    # ensuring test isolation behavior. So, unusually, it doesn't make sense to\n-    # run the tests individually, and if any are failing it is confusing to run\n-    # them with any other set of tests.\n-\n-    def setUp(self):\n-        self.factory = RequestFactory()\n-\n-    def common_test_that_should_always_pass(self):\n-        request = self.factory.get('/')\n-        request.session = {}\n-        self.assertFalse(hasattr(request, 'user'))\n-\n-    def test_request(self):\n-        self.common_test_that_should_always_pass()\n-\n-    def test_request_after_client(self):\n-        # apart from the next line the three tests are identical\n-        self.client.get('/')\n-        self.common_test_that_should_always_pass()\n-\n-    def test_request_after_client_2(self):\n-        # This test is executed after the previous one\n-        self.common_test_that_should_always_pass()\n-\n-\n-class RequestFactoryEnvironmentTests(TestCase):\n-    \"\"\"\n-    Regression tests for #8551 and #17067: ensure that environment variables\n-    are set correctly in RequestFactory.\n-    \"\"\"\n-\n-    def setUp(self):\n-        self.factory = RequestFactory()\n-\n-    def test_should_set_correct_env_variables(self):\n-        request = self.factory.get('/path/')\n-\n-        self.assertEqual(request.META.get('REMOTE_ADDR'), '127.0.0.1')\n-        self.assertEqual(request.META.get('SERVER_NAME'), 'testserver')\n-        self.assertEqual(request.META.get('SERVER_PORT'), '80')\n-        self.assertEqual(request.META.get('SERVER_PROTOCOL'), 'HTTP/1.1')\n-        self.assertEqual(request.META.get('SCRIPT_NAME') +\n-                         request.META.get('PATH_INFO'), '/path/')"
        },
        {
            "sha": "ca55bd156b143c5b335f52f83496e4fe828a13b7",
            "filename": "tests/regressiontests/test_client_regress/tests.py",
            "status": "added",
            "additions": 1021,
            "deletions": 0,
            "changes": 1021,
            "blob_url": "https://github.com/django/django/blob/4553f511557052d6f18811807ae6136f81fa86a3/tests%2Fregressiontests%2Ftest_client_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/4553f511557052d6f18811807ae6136f81fa86a3/tests%2Fregressiontests%2Ftest_client_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftest_client_regress%2Ftests.py?ref=4553f511557052d6f18811807ae6136f81fa86a3",
            "patch": "@@ -0,0 +1,1021 @@\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+Regression tests for the Test Client, especially the customized assertions.\n+\"\"\"\n+import os\n+\n+from django.conf import settings\n+from django.core.exceptions import SuspiciousOperation\n+from django.core.urlresolvers import reverse\n+from django.template import (TemplateDoesNotExist, TemplateSyntaxError,\n+    Context, Template, loader)\n+import django.template.context\n+from django.test import Client, TestCase\n+from django.test.client import encode_file, RequestFactory\n+from django.test.utils import ContextList, override_settings\n+from django.template.response import SimpleTemplateResponse\n+from django.http import HttpResponse\n+\n+\n+class AssertContainsTests(TestCase):\n+    def setUp(self):\n+        self.old_templates = settings.TEMPLATE_DIRS\n+        settings.TEMPLATE_DIRS = (os.path.join(os.path.dirname(__file__), 'templates'),)\n+\n+    def tearDown(self):\n+        settings.TEMPLATE_DIRS = self.old_templates\n+\n+    def test_contains(self):\n+        \"Responses can be inspected for content, including counting repeated substrings\"\n+        response = self.client.get('/test_client_regress/no_template_view/')\n+\n+        self.assertNotContains(response, 'never')\n+        self.assertContains(response, 'never', 0)\n+        self.assertContains(response, 'once')\n+        self.assertContains(response, 'once', 1)\n+        self.assertContains(response, 'twice')\n+        self.assertContains(response, 'twice', 2)\n+\n+        try:\n+            self.assertContains(response, 'text', status_code=999)\n+        except AssertionError as e:\n+            self.assertIn(\"Couldn't retrieve content: Response code was 200 (expected 999)\", str(e))\n+        try:\n+            self.assertContains(response, 'text', status_code=999, msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Couldn't retrieve content: Response code was 200 (expected 999)\", str(e))\n+\n+        try:\n+            self.assertNotContains(response, 'text', status_code=999)\n+        except AssertionError as e:\n+            self.assertIn(\"Couldn't retrieve content: Response code was 200 (expected 999)\", str(e))\n+        try:\n+            self.assertNotContains(response, 'text', status_code=999, msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Couldn't retrieve content: Response code was 200 (expected 999)\", str(e))\n+\n+        try:\n+            self.assertNotContains(response, 'once')\n+        except AssertionError as e:\n+            self.assertIn(\"Response should not contain 'once'\", str(e))\n+        try:\n+            self.assertNotContains(response, 'once', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Response should not contain 'once'\", str(e))\n+\n+        try:\n+            self.assertContains(response, 'never', 1)\n+        except AssertionError as e:\n+            self.assertIn(\"Found 0 instances of 'never' in response (expected 1)\", str(e))\n+        try:\n+            self.assertContains(response, 'never', 1, msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Found 0 instances of 'never' in response (expected 1)\", str(e))\n+\n+        try:\n+            self.assertContains(response, 'once', 0)\n+        except AssertionError as e:\n+            self.assertIn(\"Found 1 instances of 'once' in response (expected 0)\", str(e))\n+        try:\n+            self.assertContains(response, 'once', 0, msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Found 1 instances of 'once' in response (expected 0)\", str(e))\n+\n+        try:\n+            self.assertContains(response, 'once', 2)\n+        except AssertionError as e:\n+            self.assertIn(\"Found 1 instances of 'once' in response (expected 2)\", str(e))\n+        try:\n+            self.assertContains(response, 'once', 2, msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Found 1 instances of 'once' in response (expected 2)\", str(e))\n+\n+        try:\n+            self.assertContains(response, 'twice', 1)\n+        except AssertionError as e:\n+            self.assertIn(\"Found 2 instances of 'twice' in response (expected 1)\", str(e))\n+        try:\n+            self.assertContains(response, 'twice', 1, msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Found 2 instances of 'twice' in response (expected 1)\", str(e))\n+\n+        try:\n+            self.assertContains(response, 'thrice')\n+        except AssertionError as e:\n+            self.assertIn(\"Couldn't find 'thrice' in response\", str(e))\n+        try:\n+            self.assertContains(response, 'thrice', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Couldn't find 'thrice' in response\", str(e))\n+\n+        try:\n+            self.assertContains(response, 'thrice', 3)\n+        except AssertionError as e:\n+            self.assertIn(\"Found 0 instances of 'thrice' in response (expected 3)\", str(e))\n+        try:\n+            self.assertContains(response, 'thrice', 3, msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Found 0 instances of 'thrice' in response (expected 3)\", str(e))\n+\n+    def test_unicode_contains(self):\n+        \"Unicode characters can be found in template context\"\n+        #Regression test for #10183\n+        r = self.client.get('/test_client_regress/check_unicode/')\n+        self.assertContains(r, u'さかき')\n+        self.assertContains(r, b'\\xe5\\xb3\\xa0'.decode('utf-8'))\n+\n+    def test_unicode_not_contains(self):\n+        \"Unicode characters can be searched for, and not found in template context\"\n+        #Regression test for #10183\n+        r = self.client.get('/test_client_regress/check_unicode/')\n+        self.assertNotContains(r, u'はたけ')\n+        self.assertNotContains(r, b'\\xe3\\x81\\xaf\\xe3\\x81\\x9f\\xe3\\x81\\x91'.decode('utf-8'))\n+\n+    def test_assert_contains_renders_template_response(self):\n+        \"\"\" Test that we can pass in an unrendered SimpleTemplateReponse\n+            without throwing an error.\n+            Refs #15826.\n+        \"\"\"\n+        response = SimpleTemplateResponse(Template('Hello'), status=200)\n+        self.assertContains(response, 'Hello')\n+\n+    def test_assert_contains_using_non_template_response(self):\n+        \"\"\" Test that auto-rendering does not affect responses that aren't\n+            instances (or subclasses) of SimpleTemplateResponse.\n+            Refs #15826.\n+        \"\"\"\n+        response = HttpResponse('Hello')\n+        self.assertContains(response, 'Hello')\n+\n+    def test_assert_not_contains_renders_template_response(self):\n+        \"\"\" Test that we can pass in an unrendered SimpleTemplateReponse\n+            without throwing an error.\n+            Refs #15826.\n+        \"\"\"\n+        response = SimpleTemplateResponse(Template('Hello'), status=200)\n+        self.assertNotContains(response, 'Bye')\n+\n+    def test_assert_not_contains_using_non_template_response(self):\n+        \"\"\" Test that auto-rendering does not affect responses that aren't\n+            instances (or subclasses) of SimpleTemplateResponse.\n+            Refs #15826.\n+        \"\"\"\n+        response = HttpResponse('Hello')\n+        self.assertNotContains(response, 'Bye')\n+\n+@override_settings(PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',))\n+class AssertTemplateUsedTests(TestCase):\n+    fixtures = ['testdata.json']\n+\n+    def test_no_context(self):\n+        \"Template usage assertions work then templates aren't in use\"\n+        response = self.client.get('/test_client_regress/no_template_view/')\n+\n+        # Check that the no template case doesn't mess with the template assertions\n+        self.assertTemplateNotUsed(response, 'GET Template')\n+\n+        try:\n+            self.assertTemplateUsed(response, 'GET Template')\n+        except AssertionError as e:\n+            self.assertIn(\"No templates used to render the response\", str(e))\n+\n+        try:\n+            self.assertTemplateUsed(response, 'GET Template', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: No templates used to render the response\", str(e))\n+\n+    def test_single_context(self):\n+        \"Template assertions work when there is a single context\"\n+        response = self.client.get('/test_client/post_view/', {})\n+\n+        try:\n+            self.assertTemplateNotUsed(response, 'Empty GET Template')\n+        except AssertionError as e:\n+            self.assertIn(\"Template 'Empty GET Template' was used unexpectedly in rendering the response\", str(e))\n+\n+        try:\n+            self.assertTemplateNotUsed(response, 'Empty GET Template', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Template 'Empty GET Template' was used unexpectedly in rendering the response\", str(e))\n+\n+        try:\n+            self.assertTemplateUsed(response, 'Empty POST Template')\n+        except AssertionError as e:\n+            self.assertIn(\"Template 'Empty POST Template' was not a template used to render the response. Actual template(s) used: Empty GET Template\", str(e))\n+\n+        try:\n+            self.assertTemplateUsed(response, 'Empty POST Template', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Template 'Empty POST Template' was not a template used to render the response. Actual template(s) used: Empty GET Template\", str(e))\n+\n+    def test_multiple_context(self):\n+        \"Template assertions work when there are multiple contexts\"\n+        post_data = {\n+            'text': 'Hello World',\n+            'email': 'foo@example.com',\n+            'value': 37,\n+            'single': 'b',\n+            'multi': ('b','c','e')\n+        }\n+        response = self.client.post('/test_client/form_view_with_template/', post_data)\n+        self.assertContains(response, 'POST data OK')\n+        try:\n+            self.assertTemplateNotUsed(response, \"form_view.html\")\n+        except AssertionError as e:\n+            self.assertIn(\"Template 'form_view.html' was used unexpectedly in rendering the response\", str(e))\n+\n+        try:\n+            self.assertTemplateNotUsed(response, 'base.html')\n+        except AssertionError as e:\n+            self.assertIn(\"Template 'base.html' was used unexpectedly in rendering the response\", str(e))\n+\n+        try:\n+            self.assertTemplateUsed(response, \"Valid POST Template\")\n+        except AssertionError as e:\n+            self.assertIn(\"Template 'Valid POST Template' was not a template used to render the response. Actual template(s) used: form_view.html, base.html\", str(e))\n+\n+class AssertRedirectsTests(TestCase):\n+    def test_redirect_page(self):\n+        \"An assertion is raised if the original page couldn't be retrieved as expected\"\n+        # This page will redirect with code 301, not 302\n+        response = self.client.get('/test_client/permanent_redirect_view/')\n+        try:\n+            self.assertRedirects(response, '/test_client/get_view/')\n+        except AssertionError as e:\n+            self.assertIn(\"Response didn't redirect as expected: Response code was 301 (expected 302)\", str(e))\n+\n+        try:\n+            self.assertRedirects(response, '/test_client/get_view/', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Response didn't redirect as expected: Response code was 301 (expected 302)\", str(e))\n+\n+    def test_lost_query(self):\n+        \"An assertion is raised if the redirect location doesn't preserve GET parameters\"\n+        response = self.client.get('/test_client/redirect_view/', {'var': 'value'})\n+        try:\n+            self.assertRedirects(response, '/test_client/get_view/')\n+        except AssertionError as e:\n+            self.assertIn(\"Response redirected to 'http://testserver/test_client/get_view/?var=value', expected 'http://testserver/test_client/get_view/'\", str(e))\n+\n+        try:\n+            self.assertRedirects(response, '/test_client/get_view/', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Response redirected to 'http://testserver/test_client/get_view/?var=value', expected 'http://testserver/test_client/get_view/'\", str(e))\n+\n+    def test_incorrect_target(self):\n+        \"An assertion is raised if the response redirects to another target\"\n+        response = self.client.get('/test_client/permanent_redirect_view/')\n+        try:\n+            # Should redirect to get_view\n+            self.assertRedirects(response, '/test_client/some_view/')\n+        except AssertionError as e:\n+            self.assertIn(\"Response didn't redirect as expected: Response code was 301 (expected 302)\", str(e))\n+\n+    def test_target_page(self):\n+        \"An assertion is raised if the response redirect target cannot be retrieved as expected\"\n+        response = self.client.get('/test_client/double_redirect_view/')\n+        try:\n+            # The redirect target responds with a 301 code, not 200\n+            self.assertRedirects(response, 'http://testserver/test_client/permanent_redirect_view/')\n+        except AssertionError as e:\n+            self.assertIn(\"Couldn't retrieve redirection page '/test_client/permanent_redirect_view/': response code was 301 (expected 200)\", str(e))\n+\n+        try:\n+            # The redirect target responds with a 301 code, not 200\n+            self.assertRedirects(response, 'http://testserver/test_client/permanent_redirect_view/', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Couldn't retrieve redirection page '/test_client/permanent_redirect_view/': response code was 301 (expected 200)\", str(e))\n+\n+    def test_redirect_chain(self):\n+        \"You can follow a redirect chain of multiple redirects\"\n+        response = self.client.get('/test_client_regress/redirects/further/more/', {}, follow=True)\n+        self.assertRedirects(response, '/test_client_regress/no_template_view/',\n+            status_code=301, target_status_code=200)\n+\n+        self.assertEqual(len(response.redirect_chain), 1)\n+        self.assertEqual(response.redirect_chain[0], ('http://testserver/test_client_regress/no_template_view/', 301))\n+\n+    def test_multiple_redirect_chain(self):\n+        \"You can follow a redirect chain of multiple redirects\"\n+        response = self.client.get('/test_client_regress/redirects/', {}, follow=True)\n+        self.assertRedirects(response, '/test_client_regress/no_template_view/',\n+            status_code=301, target_status_code=200)\n+\n+        self.assertEqual(len(response.redirect_chain), 3)\n+        self.assertEqual(response.redirect_chain[0], ('http://testserver/test_client_regress/redirects/further/', 301))\n+        self.assertEqual(response.redirect_chain[1], ('http://testserver/test_client_regress/redirects/further/more/', 301))\n+        self.assertEqual(response.redirect_chain[2], ('http://testserver/test_client_regress/no_template_view/', 301))\n+\n+    def test_redirect_chain_to_non_existent(self):\n+        \"You can follow a chain to a non-existent view\"\n+        response = self.client.get('/test_client_regress/redirect_to_non_existent_view2/', {}, follow=True)\n+        self.assertRedirects(response, '/test_client_regress/non_existent_view/',\n+            status_code=301, target_status_code=404)\n+\n+    def test_redirect_chain_to_self(self):\n+        \"Redirections to self are caught and escaped\"\n+        response = self.client.get('/test_client_regress/redirect_to_self/', {}, follow=True)\n+        # The chain of redirects stops once the cycle is detected.\n+        self.assertRedirects(response, '/test_client_regress/redirect_to_self/',\n+            status_code=301, target_status_code=301)\n+        self.assertEqual(len(response.redirect_chain), 2)\n+\n+    def test_circular_redirect(self):\n+        \"Circular redirect chains are caught and escaped\"\n+        response = self.client.get('/test_client_regress/circular_redirect_1/', {}, follow=True)\n+        # The chain of redirects will get back to the starting point, but stop there.\n+        self.assertRedirects(response, '/test_client_regress/circular_redirect_2/',\n+            status_code=301, target_status_code=301)\n+        self.assertEqual(len(response.redirect_chain), 4)\n+\n+    def test_redirect_chain_post(self):\n+        \"A redirect chain will be followed from an initial POST post\"\n+        response = self.client.post('/test_client_regress/redirects/',\n+            {'nothing': 'to_send'}, follow=True)\n+        self.assertRedirects(response,\n+            '/test_client_regress/no_template_view/', 301, 200)\n+        self.assertEqual(len(response.redirect_chain), 3)\n+\n+    def test_redirect_chain_head(self):\n+        \"A redirect chain will be followed from an initial HEAD request\"\n+        response = self.client.head('/test_client_regress/redirects/',\n+            {'nothing': 'to_send'}, follow=True)\n+        self.assertRedirects(response,\n+            '/test_client_regress/no_template_view/', 301, 200)\n+        self.assertEqual(len(response.redirect_chain), 3)\n+\n+    def test_redirect_chain_options(self):\n+        \"A redirect chain will be followed from an initial OPTIONS request\"\n+        response = self.client.options('/test_client_regress/redirects/',\n+            follow=True)\n+        self.assertRedirects(response,\n+            '/test_client_regress/no_template_view/', 301, 200)\n+        self.assertEqual(len(response.redirect_chain), 3)\n+\n+    def test_redirect_chain_put(self):\n+        \"A redirect chain will be followed from an initial PUT request\"\n+        response = self.client.put('/test_client_regress/redirects/',\n+            follow=True)\n+        self.assertRedirects(response,\n+            '/test_client_regress/no_template_view/', 301, 200)\n+        self.assertEqual(len(response.redirect_chain), 3)\n+\n+    def test_redirect_chain_delete(self):\n+        \"A redirect chain will be followed from an initial DELETE request\"\n+        response = self.client.delete('/test_client_regress/redirects/',\n+            follow=True)\n+        self.assertRedirects(response,\n+            '/test_client_regress/no_template_view/', 301, 200)\n+        self.assertEqual(len(response.redirect_chain), 3)\n+\n+    def test_redirect_to_different_host(self):\n+        \"The test client will preserve scheme, host and port changes\"\n+        response = self.client.get('/test_client_regress/redirect_other_host/', follow=True)\n+        self.assertRedirects(response,\n+            'https://otherserver:8443/test_client_regress/no_template_view/',\n+            status_code=301, target_status_code=200)\n+        # We can't use is_secure() or get_host()\n+        # because response.request is a dictionary, not an HttpRequest\n+        self.assertEqual(response.request.get('wsgi.url_scheme'), 'https')\n+        self.assertEqual(response.request.get('SERVER_NAME'), 'otherserver')\n+        self.assertEqual(response.request.get('SERVER_PORT'), '8443')\n+\n+    def test_redirect_chain_on_non_redirect_page(self):\n+        \"An assertion is raised if the original page couldn't be retrieved as expected\"\n+        # This page will redirect with code 301, not 302\n+        response = self.client.get('/test_client/get_view/', follow=True)\n+        try:\n+            self.assertRedirects(response, '/test_client/get_view/')\n+        except AssertionError as e:\n+            self.assertIn(\"Response didn't redirect as expected: Response code was 200 (expected 302)\", str(e))\n+\n+        try:\n+            self.assertRedirects(response, '/test_client/get_view/', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Response didn't redirect as expected: Response code was 200 (expected 302)\", str(e))\n+\n+    def test_redirect_on_non_redirect_page(self):\n+        \"An assertion is raised if the original page couldn't be retrieved as expected\"\n+        # This page will redirect with code 301, not 302\n+        response = self.client.get('/test_client/get_view/')\n+        try:\n+            self.assertRedirects(response, '/test_client/get_view/')\n+        except AssertionError as e:\n+            self.assertIn(\"Response didn't redirect as expected: Response code was 200 (expected 302)\", str(e))\n+\n+        try:\n+            self.assertRedirects(response, '/test_client/get_view/', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: Response didn't redirect as expected: Response code was 200 (expected 302)\", str(e))\n+\n+\n+class AssertFormErrorTests(TestCase):\n+    def test_unknown_form(self):\n+        \"An assertion is raised if the form name is unknown\"\n+        post_data = {\n+            'text': 'Hello World',\n+            'email': 'not an email address',\n+            'value': 37,\n+            'single': 'b',\n+            'multi': ('b','c','e')\n+        }\n+        response = self.client.post('/test_client/form_view/', post_data)\n+        self.assertEqual(response.status_code, 200)\n+        self.assertTemplateUsed(response, \"Invalid POST Template\")\n+\n+        try:\n+            self.assertFormError(response, 'wrong_form', 'some_field', 'Some error.')\n+        except AssertionError as e:\n+            self.assertIn(\"The form 'wrong_form' was not used to render the response\", str(e))\n+        try:\n+            self.assertFormError(response, 'wrong_form', 'some_field', 'Some error.', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: The form 'wrong_form' was not used to render the response\", str(e))\n+\n+    def test_unknown_field(self):\n+        \"An assertion is raised if the field name is unknown\"\n+        post_data = {\n+            'text': 'Hello World',\n+            'email': 'not an email address',\n+            'value': 37,\n+            'single': 'b',\n+            'multi': ('b','c','e')\n+        }\n+        response = self.client.post('/test_client/form_view/', post_data)\n+        self.assertEqual(response.status_code, 200)\n+        self.assertTemplateUsed(response, \"Invalid POST Template\")\n+\n+        try:\n+            self.assertFormError(response, 'form', 'some_field', 'Some error.')\n+        except AssertionError as e:\n+            self.assertIn(\"The form 'form' in context 0 does not contain the field 'some_field'\", str(e))\n+        try:\n+            self.assertFormError(response, 'form', 'some_field', 'Some error.', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: The form 'form' in context 0 does not contain the field 'some_field'\", str(e))\n+\n+    def test_noerror_field(self):\n+        \"An assertion is raised if the field doesn't have any errors\"\n+        post_data = {\n+            'text': 'Hello World',\n+            'email': 'not an email address',\n+            'value': 37,\n+            'single': 'b',\n+            'multi': ('b','c','e')\n+        }\n+        response = self.client.post('/test_client/form_view/', post_data)\n+        self.assertEqual(response.status_code, 200)\n+        self.assertTemplateUsed(response, \"Invalid POST Template\")\n+\n+        try:\n+            self.assertFormError(response, 'form', 'value', 'Some error.')\n+        except AssertionError as e:\n+            self.assertIn(\"The field 'value' on form 'form' in context 0 contains no errors\", str(e))\n+        try:\n+            self.assertFormError(response, 'form', 'value', 'Some error.', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: The field 'value' on form 'form' in context 0 contains no errors\", str(e))\n+\n+    def test_unknown_error(self):\n+        \"An assertion is raised if the field doesn't contain the provided error\"\n+        post_data = {\n+            'text': 'Hello World',\n+            'email': 'not an email address',\n+            'value': 37,\n+            'single': 'b',\n+            'multi': ('b','c','e')\n+        }\n+        response = self.client.post('/test_client/form_view/', post_data)\n+        self.assertEqual(response.status_code, 200)\n+        self.assertTemplateUsed(response, \"Invalid POST Template\")\n+\n+        try:\n+            self.assertFormError(response, 'form', 'email', 'Some error.')\n+        except AssertionError as e:\n+            self.assertIn(\"The field 'email' on form 'form' in context 0 does not contain the error 'Some error.' (actual errors: [u'Enter a valid e-mail address.'])\", str(e))\n+        try:\n+            self.assertFormError(response, 'form', 'email', 'Some error.', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: The field 'email' on form 'form' in context 0 does not contain the error 'Some error.' (actual errors: [u'Enter a valid e-mail address.'])\", str(e))\n+\n+    def test_unknown_nonfield_error(self):\n+        \"\"\"\n+        Checks that an assertion is raised if the form's non field errors\n+        doesn't contain the provided error.\n+        \"\"\"\n+        post_data = {\n+            'text': 'Hello World',\n+            'email': 'not an email address',\n+            'value': 37,\n+            'single': 'b',\n+            'multi': ('b','c','e')\n+        }\n+        response = self.client.post('/test_client/form_view/', post_data)\n+        self.assertEqual(response.status_code, 200)\n+        self.assertTemplateUsed(response, \"Invalid POST Template\")\n+\n+        try:\n+            self.assertFormError(response, 'form', None, 'Some error.')\n+        except AssertionError as e:\n+            self.assertIn(\"The form 'form' in context 0 does not contain the non-field error 'Some error.' (actual errors: )\", str(e))\n+        try:\n+            self.assertFormError(response, 'form', None, 'Some error.', msg_prefix='abc')\n+        except AssertionError as e:\n+            self.assertIn(\"abc: The form 'form' in context 0 does not contain the non-field error 'Some error.' (actual errors: )\", str(e))\n+\n+@override_settings(PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',))\n+class LoginTests(TestCase):\n+    fixtures = ['testdata']\n+\n+    def test_login_different_client(self):\n+        \"Check that using a different test client doesn't violate authentication\"\n+\n+        # Create a second client, and log in.\n+        c = Client()\n+        login = c.login(username='testclient', password='password')\n+        self.assertTrue(login, 'Could not log in')\n+\n+        # Get a redirection page with the second client.\n+        response = c.get(\"/test_client_regress/login_protected_redirect_view/\")\n+\n+        # At this points, the self.client isn't logged in.\n+        # Check that assertRedirects uses the original client, not the\n+        # default client.\n+        self.assertRedirects(response, \"http://testserver/test_client_regress/get_view/\")\n+\n+\n+@override_settings(PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',))\n+class SessionEngineTests(TestCase):\n+    fixtures = ['testdata']\n+\n+    def setUp(self):\n+        self.old_SESSION_ENGINE = settings.SESSION_ENGINE\n+        settings.SESSION_ENGINE = 'regressiontests.test_client_regress.session'\n+\n+    def tearDown(self):\n+        settings.SESSION_ENGINE = self.old_SESSION_ENGINE\n+\n+    def test_login(self):\n+        \"A session engine that modifies the session key can be used to log in\"\n+        login = self.client.login(username='testclient', password='password')\n+        self.assertTrue(login, 'Could not log in')\n+\n+        # Try to access a login protected page.\n+        response = self.client.get(\"/test_client/login_protected_view/\")\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.context['user'].username, 'testclient')\n+\n+\n+class URLEscapingTests(TestCase):\n+    def test_simple_argument_get(self):\n+        \"Get a view that has a simple string argument\"\n+        response = self.client.get(reverse('arg_view', args=['Slartibartfast']))\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'Howdy, Slartibartfast')\n+\n+    def test_argument_with_space_get(self):\n+        \"Get a view that has a string argument that requires escaping\"\n+        response = self.client.get(reverse('arg_view', args=['Arthur Dent']))\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'Hi, Arthur')\n+\n+    def test_simple_argument_post(self):\n+        \"Post for a view that has a simple string argument\"\n+        response = self.client.post(reverse('arg_view', args=['Slartibartfast']))\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'Howdy, Slartibartfast')\n+\n+    def test_argument_with_space_post(self):\n+        \"Post for a view that has a string argument that requires escaping\"\n+        response = self.client.post(reverse('arg_view', args=['Arthur Dent']))\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'Hi, Arthur')\n+\n+@override_settings(PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',))\n+class ExceptionTests(TestCase):\n+    fixtures = ['testdata.json']\n+\n+    def test_exception_cleared(self):\n+        \"#5836 - A stale user exception isn't re-raised by the test client.\"\n+\n+        login = self.client.login(username='testclient',password='password')\n+        self.assertTrue(login, 'Could not log in')\n+        try:\n+            response = self.client.get(\"/test_client_regress/staff_only/\")\n+            self.fail(\"General users should not be able to visit this page\")\n+        except SuspiciousOperation:\n+            pass\n+\n+        # At this point, an exception has been raised, and should be cleared.\n+\n+        # This next operation should be successful; if it isn't we have a problem.\n+        login = self.client.login(username='staff', password='password')\n+        self.assertTrue(login, 'Could not log in')\n+        try:\n+            self.client.get(\"/test_client_regress/staff_only/\")\n+        except SuspiciousOperation:\n+            self.fail(\"Staff should be able to visit this page\")\n+\n+class TemplateExceptionTests(TestCase):\n+    def setUp(self):\n+        # Reset the loaders so they don't try to render cached templates.\n+        if loader.template_source_loaders is not None:\n+            for template_loader in loader.template_source_loaders:\n+                if hasattr(template_loader, 'reset'):\n+                    template_loader.reset()\n+        self.old_templates = settings.TEMPLATE_DIRS\n+        settings.TEMPLATE_DIRS = ()\n+\n+    def tearDown(self):\n+        settings.TEMPLATE_DIRS = self.old_templates\n+\n+    def test_no_404_template(self):\n+        \"Missing templates are correctly reported by test client\"\n+        try:\n+            response = self.client.get(\"/no_such_view/\")\n+            self.fail(\"Should get error about missing template\")\n+        except TemplateDoesNotExist:\n+            pass\n+\n+    def test_bad_404_template(self):\n+        \"Errors found when rendering 404 error templates are re-raised\"\n+        settings.TEMPLATE_DIRS = (os.path.join(os.path.dirname(__file__), 'bad_templates'),)\n+        try:\n+            response = self.client.get(\"/no_such_view/\")\n+            self.fail(\"Should get error about syntax error in template\")\n+        except TemplateSyntaxError:\n+            pass\n+\n+# We need two different tests to check URLconf substitution -  one to check\n+# it was changed, and another one (without self.urls) to check it was reverted on\n+# teardown. This pair of tests relies upon the alphabetical ordering of test execution.\n+class UrlconfSubstitutionTests(TestCase):\n+    urls = 'regressiontests.test_client_regress.urls'\n+\n+    def test_urlconf_was_changed(self):\n+        \"TestCase can enforce a custom URLconf on a per-test basis\"\n+        url = reverse('arg_view', args=['somename'])\n+        self.assertEqual(url, '/arg_view/somename/')\n+\n+# This test needs to run *after* UrlconfSubstitutionTests; the zz prefix in the\n+# name is to ensure alphabetical ordering.\n+class zzUrlconfSubstitutionTests(TestCase):\n+    def test_urlconf_was_reverted(self):\n+        \"URLconf is reverted to original value after modification in a TestCase\"\n+        url = reverse('arg_view', args=['somename'])\n+        self.assertEqual(url, '/test_client_regress/arg_view/somename/')\n+\n+@override_settings(PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',))\n+class ContextTests(TestCase):\n+    fixtures = ['testdata']\n+\n+    def test_single_context(self):\n+        \"Context variables can be retrieved from a single context\"\n+        response = self.client.get(\"/test_client_regress/request_data/\", data={'foo':'whiz'})\n+        self.assertEqual(response.context.__class__, Context)\n+        self.assertTrue('get-foo' in response.context)\n+        self.assertEqual(response.context['get-foo'], 'whiz')\n+        self.assertEqual(response.context['request-foo'], 'whiz')\n+        self.assertEqual(response.context['data'], 'sausage')\n+\n+        try:\n+            response.context['does-not-exist']\n+            self.fail('Should not be able to retrieve non-existent key')\n+        except KeyError as e:\n+            self.assertEqual(e.args[0], 'does-not-exist')\n+\n+    def test_inherited_context(self):\n+        \"Context variables can be retrieved from a list of contexts\"\n+        response = self.client.get(\"/test_client_regress/request_data_extended/\", data={'foo':'whiz'})\n+        self.assertEqual(response.context.__class__, ContextList)\n+        self.assertEqual(len(response.context), 2)\n+        self.assertTrue('get-foo' in response.context)\n+        self.assertEqual(response.context['get-foo'], 'whiz')\n+        self.assertEqual(response.context['request-foo'], 'whiz')\n+        self.assertEqual(response.context['data'], 'bacon')\n+\n+        try:\n+            response.context['does-not-exist']\n+            self.fail('Should not be able to retrieve non-existent key')\n+        except KeyError as e:\n+            self.assertEqual(e.args[0], 'does-not-exist')\n+\n+    def test_15368(self):\n+        # Need to insert a context processor that assumes certain things about\n+        # the request instance. This triggers a bug caused by some ways of\n+        # copying RequestContext.\n+        try:\n+            django.template.context._standard_context_processors = (lambda request: {'path': request.special_path},)\n+            response = self.client.get(\"/test_client_regress/request_context_view/\")\n+            self.assertContains(response, 'Path: /test_client_regress/request_context_view/')\n+        finally:\n+            django.template.context._standard_context_processors = None\n+\n+\n+@override_settings(PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',))\n+class SessionTests(TestCase):\n+    fixtures = ['testdata.json']\n+\n+    def test_session(self):\n+        \"The session isn't lost if a user logs in\"\n+        # The session doesn't exist to start.\n+        response = self.client.get('/test_client_regress/check_session/')\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'NO')\n+\n+        # This request sets a session variable.\n+        response = self.client.get('/test_client_regress/set_session/')\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'set_session')\n+\n+        # Check that the session has been modified\n+        response = self.client.get('/test_client_regress/check_session/')\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'YES')\n+\n+        # Log in\n+        login = self.client.login(username='testclient',password='password')\n+        self.assertTrue(login, 'Could not log in')\n+\n+        # Session should still contain the modified value\n+        response = self.client.get('/test_client_regress/check_session/')\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'YES')\n+\n+    def test_logout(self):\n+        \"\"\"Logout should work whether the user is logged in or not (#9978).\"\"\"\n+        self.client.logout()\n+        login = self.client.login(username='testclient',password='password')\n+        self.assertTrue(login, 'Could not log in')\n+        self.client.logout()\n+        self.client.logout()\n+\n+class RequestMethodTests(TestCase):\n+    def test_get(self):\n+        \"Request a view via request method GET\"\n+        response = self.client.get('/test_client_regress/request_methods/')\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'request method: GET')\n+\n+    def test_post(self):\n+        \"Request a view via request method POST\"\n+        response = self.client.post('/test_client_regress/request_methods/')\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'request method: POST')\n+\n+    def test_head(self):\n+        \"Request a view via request method HEAD\"\n+        response = self.client.head('/test_client_regress/request_methods/')\n+        self.assertEqual(response.status_code, 200)\n+        # A HEAD request doesn't return any content.\n+        self.assertNotEqual(response.content, b'request method: HEAD')\n+        self.assertEqual(response.content, b'')\n+\n+    def test_options(self):\n+        \"Request a view via request method OPTIONS\"\n+        response = self.client.options('/test_client_regress/request_methods/')\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'request method: OPTIONS')\n+\n+    def test_put(self):\n+        \"Request a view via request method PUT\"\n+        response = self.client.put('/test_client_regress/request_methods/')\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'request method: PUT')\n+\n+    def test_delete(self):\n+        \"Request a view via request method DELETE\"\n+        response = self.client.delete('/test_client_regress/request_methods/')\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'request method: DELETE')\n+\n+class RequestMethodStringDataTests(TestCase):\n+    def test_post(self):\n+        \"Request a view with string data via request method POST\"\n+        # Regression test for #11371\n+        data = u'{\"test\": \"json\"}'\n+        response = self.client.post('/test_client_regress/request_methods/', data=data, content_type='application/json')\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'request method: POST')\n+\n+    def test_put(self):\n+        \"Request a view with string data via request method PUT\"\n+        # Regression test for #11371\n+        data = u'{\"test\": \"json\"}'\n+        response = self.client.put('/test_client_regress/request_methods/', data=data, content_type='application/json')\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.content, b'request method: PUT')\n+\n+class QueryStringTests(TestCase):\n+    def test_get_like_requests(self):\n+        # See: https://code.djangoproject.com/ticket/10571.\n+        for method_name in ('get', 'head'):\n+            # A GET-like request can pass a query string as data\n+            method = getattr(self.client, method_name)\n+            response = method(\"/test_client_regress/request_data/\", data={'foo':'whiz'})\n+            self.assertEqual(response.context['get-foo'], 'whiz')\n+            self.assertEqual(response.context['request-foo'], 'whiz')\n+\n+            # A GET-like request can pass a query string as part of the URL\n+            response = method(\"/test_client_regress/request_data/?foo=whiz\")\n+            self.assertEqual(response.context['get-foo'], 'whiz')\n+            self.assertEqual(response.context['request-foo'], 'whiz')\n+\n+            # Data provided in the URL to a GET-like request is overridden by actual form data\n+            response = method(\"/test_client_regress/request_data/?foo=whiz\", data={'foo':'bang'})\n+            self.assertEqual(response.context['get-foo'], 'bang')\n+            self.assertEqual(response.context['request-foo'], 'bang')\n+\n+            response = method(\"/test_client_regress/request_data/?foo=whiz\", data={'bar':'bang'})\n+            self.assertEqual(response.context['get-foo'], None)\n+            self.assertEqual(response.context['get-bar'], 'bang')\n+            self.assertEqual(response.context['request-foo'], None)\n+            self.assertEqual(response.context['request-bar'], 'bang')\n+\n+    def test_post_like_requests(self):\n+        # A POST-like request can pass a query string as data\n+        response = self.client.post(\"/test_client_regress/request_data/\", data={'foo':'whiz'})\n+        self.assertEqual(response.context['get-foo'], None)\n+        self.assertEqual(response.context['post-foo'], 'whiz')\n+\n+        # A POST-like request can pass a query string as part of the URL\n+        response = self.client.post(\"/test_client_regress/request_data/?foo=whiz\")\n+        self.assertEqual(response.context['get-foo'], 'whiz')\n+        self.assertEqual(response.context['post-foo'], None)\n+        self.assertEqual(response.context['request-foo'], 'whiz')\n+\n+        # POST data provided in the URL augments actual form data\n+        response = self.client.post(\"/test_client_regress/request_data/?foo=whiz\", data={'foo':'bang'})\n+        self.assertEqual(response.context['get-foo'], 'whiz')\n+        self.assertEqual(response.context['post-foo'], 'bang')\n+        self.assertEqual(response.context['request-foo'], 'bang')\n+\n+        response = self.client.post(\"/test_client_regress/request_data/?foo=whiz\", data={'bar':'bang'})\n+        self.assertEqual(response.context['get-foo'], 'whiz')\n+        self.assertEqual(response.context['get-bar'], None)\n+        self.assertEqual(response.context['post-foo'], None)\n+        self.assertEqual(response.context['post-bar'], 'bang')\n+        self.assertEqual(response.context['request-foo'], 'whiz')\n+        self.assertEqual(response.context['request-bar'], 'bang')\n+\n+class UnicodePayloadTests(TestCase):\n+    def test_simple_unicode_payload(self):\n+        \"A simple ASCII-only unicode JSON document can be POSTed\"\n+        # Regression test for #10571\n+        json = u'{\"english\": \"mountain pass\"}'\n+        response = self.client.post(\"/test_client_regress/parse_unicode_json/\", json,\n+                                    content_type=\"application/json\")\n+        self.assertEqual(response.content, json)\n+\n+    def test_unicode_payload_utf8(self):\n+        \"A non-ASCII unicode data encoded as UTF-8 can be POSTed\"\n+        # Regression test for #10571\n+        json = u'{\"dog\": \"собака\"}'\n+        response = self.client.post(\"/test_client_regress/parse_unicode_json/\", json,\n+                                    content_type=\"application/json; charset=utf-8\")\n+        self.assertEqual(response.content, json.encode('utf-8'))\n+\n+    def test_unicode_payload_utf16(self):\n+        \"A non-ASCII unicode data encoded as UTF-16 can be POSTed\"\n+        # Regression test for #10571\n+        json = u'{\"dog\": \"собака\"}'\n+        response = self.client.post(\"/test_client_regress/parse_unicode_json/\", json,\n+                                    content_type=\"application/json; charset=utf-16\")\n+        self.assertEqual(response.content, json.encode('utf-16'))\n+\n+    def test_unicode_payload_non_utf(self):\n+        \"A non-ASCII unicode data as a non-UTF based encoding can be POSTed\"\n+        #Regression test for #10571\n+        json = u'{\"dog\": \"собака\"}'\n+        response = self.client.post(\"/test_client_regress/parse_unicode_json/\", json,\n+                                    content_type=\"application/json; charset=koi8-r\")\n+        self.assertEqual(response.content, json.encode('koi8-r'))\n+\n+class DummyFile(object):\n+    def __init__(self, filename):\n+        self.name = filename\n+    def read(self):\n+        return 'TEST_FILE_CONTENT'\n+\n+class UploadedFileEncodingTest(TestCase):\n+    def test_file_encoding(self):\n+        encoded_file = encode_file('TEST_BOUNDARY', 'TEST_KEY', DummyFile('test_name.bin'))\n+        self.assertEqual(b'--TEST_BOUNDARY', encoded_file[0])\n+        self.assertEqual(b'Content-Disposition: form-data; name=\"TEST_KEY\"; filename=\"test_name.bin\"', encoded_file[1])\n+        self.assertEqual(b'TEST_FILE_CONTENT', encoded_file[-1])\n+\n+    def test_guesses_content_type_on_file_encoding(self):\n+        self.assertEqual(b'Content-Type: application/octet-stream',\n+                         encode_file('IGNORE', 'IGNORE', DummyFile(\"file.bin\"))[2])\n+        self.assertEqual(b'Content-Type: text/plain',\n+                         encode_file('IGNORE', 'IGNORE', DummyFile(\"file.txt\"))[2])\n+        self.assertIn(encode_file('IGNORE', 'IGNORE', DummyFile(\"file.zip\"))[2], (\n+                        b'Content-Type: application/x-compress',\n+                        b'Content-Type: application/x-zip',\n+                        b'Content-Type: application/x-zip-compressed',\n+                        b'Content-Type: application/zip',))\n+        self.assertEqual(b'Content-Type: application/octet-stream',\n+                         encode_file('IGNORE', 'IGNORE', DummyFile(\"file.unknown\"))[2])\n+\n+class RequestHeadersTest(TestCase):\n+    def test_client_headers(self):\n+        \"A test client can receive custom headers\"\n+        response = self.client.get(\"/test_client_regress/check_headers/\", HTTP_X_ARG_CHECK='Testing 123')\n+        self.assertEqual(response.content, b\"HTTP_X_ARG_CHECK: Testing 123\")\n+        self.assertEqual(response.status_code, 200)\n+\n+    def test_client_headers_redirect(self):\n+        \"Test client headers are preserved through redirects\"\n+        response = self.client.get(\"/test_client_regress/check_headers_redirect/\", follow=True, HTTP_X_ARG_CHECK='Testing 123')\n+        self.assertEqual(response.content, b\"HTTP_X_ARG_CHECK: Testing 123\")\n+        self.assertRedirects(response, '/test_client_regress/check_headers/',\n+            status_code=301, target_status_code=200)\n+\n+\n+class ReadLimitedStreamTest(TestCase):\n+    \"\"\"\n+    Tests that ensure that HttpRequest.body, HttpRequest.read() and\n+    HttpRequest.read(BUFFER) have proper LimitedStream behavior.\n+\n+    Refs #14753, #15785\n+    \"\"\"\n+\n+    def test_body_from_empty_request(self):\n+        \"\"\"HttpRequest.body on a test client GET request should return\n+        the empty string.\"\"\"\n+        self.assertEqual(self.client.get(\"/test_client_regress/body/\").content, b'')\n+\n+    def test_read_from_empty_request(self):\n+        \"\"\"HttpRequest.read() on a test client GET request should return the\n+        empty string.\"\"\"\n+        self.assertEqual(self.client.get(\"/test_client_regress/read_all/\").content, b'')\n+\n+    def test_read_numbytes_from_empty_request(self):\n+        \"\"\"HttpRequest.read(LARGE_BUFFER) on a test client GET request should\n+        return the empty string.\"\"\"\n+        self.assertEqual(self.client.get(\"/test_client_regress/read_buffer/\").content, b'')\n+\n+    def test_read_from_nonempty_request(self):\n+        \"\"\"HttpRequest.read() on a test client PUT request with some payload\n+        should return that payload.\"\"\"\n+        payload = b'foobar'\n+        self.assertEqual(self.client.put(\"/test_client_regress/read_all/\",\n+                                          data=payload,\n+                                          content_type='text/plain').content, payload)\n+\n+    def test_read_numbytes_from_nonempty_request(self):\n+        \"\"\"HttpRequest.read(LARGE_BUFFER) on a test client PUT request with\n+        some payload should return that payload.\"\"\"\n+        payload = b'foobar'\n+        self.assertEqual(self.client.put(\"/test_client_regress/read_buffer/\",\n+                                          data=payload,\n+                                          content_type='text/plain').content, payload)\n+\n+\n+class RequestFactoryStateTest(TestCase):\n+    \"\"\"Regression tests for #15929.\"\"\"\n+    # These tests are checking that certain middleware don't change certain\n+    # global state. Alternatively, from the point of view of a test, they are\n+    # ensuring test isolation behavior. So, unusually, it doesn't make sense to\n+    # run the tests individually, and if any are failing it is confusing to run\n+    # them with any other set of tests.\n+\n+    def setUp(self):\n+        self.factory = RequestFactory()\n+\n+    def common_test_that_should_always_pass(self):\n+        request = self.factory.get('/')\n+        request.session = {}\n+        self.assertFalse(hasattr(request, 'user'))\n+\n+    def test_request(self):\n+        self.common_test_that_should_always_pass()\n+\n+    def test_request_after_client(self):\n+        # apart from the next line the three tests are identical\n+        self.client.get('/')\n+        self.common_test_that_should_always_pass()\n+\n+    def test_request_after_client_2(self):\n+        # This test is executed after the previous one\n+        self.common_test_that_should_always_pass()\n+\n+\n+class RequestFactoryEnvironmentTests(TestCase):\n+    \"\"\"\n+    Regression tests for #8551 and #17067: ensure that environment variables\n+    are set correctly in RequestFactory.\n+    \"\"\"\n+\n+    def setUp(self):\n+        self.factory = RequestFactory()\n+\n+    def test_should_set_correct_env_variables(self):\n+        request = self.factory.get('/path/')\n+\n+        self.assertEqual(request.META.get('REMOTE_ADDR'), '127.0.0.1')\n+        self.assertEqual(request.META.get('SERVER_NAME'), 'testserver')\n+        self.assertEqual(request.META.get('SERVER_PORT'), '80')\n+        self.assertEqual(request.META.get('SERVER_PROTOCOL'), 'HTTP/1.1')\n+        self.assertEqual(request.META.get('SCRIPT_NAME') +\n+                         request.META.get('PATH_INFO'), '/path/')"
        }
    ],
    "stats": {
        "total": 2042,
        "additions": 1021,
        "deletions": 1021
    }
}