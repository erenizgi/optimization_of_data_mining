{
    "author": "freakboy3742",
    "message": "Fixed #19806 -- Ensure that content types and permissions aren't created for swapped models.\n\nThanks to rizumu for the report.",
    "sha": "c8985a8a7317042a641e870cb75b3005cc5d67b1",
    "files": [
        {
            "sha": "8329ab65d9d1e527cc7e23944476dc3f0c7b4f06",
            "filename": "django/contrib/contenttypes/management.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/c8985a8a7317042a641e870cb75b3005cc5d67b1/django%2Fcontrib%2Fcontenttypes%2Fmanagement.py",
            "raw_url": "https://github.com/django/django/raw/c8985a8a7317042a641e870cb75b3005cc5d67b1/django%2Fcontrib%2Fcontenttypes%2Fmanagement.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fcontenttypes%2Fmanagement.py?ref=c8985a8a7317042a641e870cb75b3005cc5d67b1",
            "patch": "@@ -5,6 +5,7 @@\n from django.utils import six\n from django.utils.six.moves import input\n \n+\n def update_contenttypes(app, created_models, verbosity=2, db=DEFAULT_DB_ALIAS, **kwargs):\n     \"\"\"\n     Creates content types for models in the given app, removing any model\n@@ -77,6 +78,7 @@ def update_contenttypes(app, created_models, verbosity=2, db=DEFAULT_DB_ALIAS, *\n             if verbosity >= 2:\n                 print(\"Stale content types remain.\")\n \n+\n def update_all_contenttypes(verbosity=2, **kwargs):\n     for app in get_apps():\n         update_contenttypes(app, None, verbosity, **kwargs)"
        },
        {
            "sha": "af15752f0fb69ae3253d16966a940d60c52a9d58",
            "filename": "django/core/management/validation.py",
            "status": "modified",
            "additions": 17,
            "deletions": 11,
            "changes": 28,
            "blob_url": "https://github.com/django/django/blob/c8985a8a7317042a641e870cb75b3005cc5d67b1/django%2Fcore%2Fmanagement%2Fvalidation.py",
            "raw_url": "https://github.com/django/django/raw/c8985a8a7317042a641e870cb75b3005cc5d67b1/django%2Fcore%2Fmanagement%2Fvalidation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fvalidation.py?ref=c8985a8a7317042a641e870cb75b3005cc5d67b1",
            "patch": "@@ -35,7 +35,10 @@ def get_validation_errors(outfile, app=None):\n     for (app_name, error) in get_app_errors().items():\n         e.add(app_name, error)\n \n-    for cls in models.get_models(app):\n+    inc = set(models.get_models(app, include_swapped=True))\n+    no_inc = set(models.get_models(app))\n+\n+    for cls in models.get_models(app, include_swapped=True):\n         opts = cls._meta\n \n         # Check swappable attribute.\n@@ -138,16 +141,17 @@ def get_validation_errors(outfile, app=None):\n             # fields, m2m fields, m2m related objects or related objects\n             if f.rel:\n                 if f.rel.to not in models.get_models():\n-                    e.add(opts, \"'%s' has a relation with model %s, which has either not been installed or is abstract.\" % (f.name, f.rel.to))\n+                    # If the related model is swapped, provide a hint;\n+                    # otherwise, the model just hasn't been installed.\n+                    if not isinstance(f.rel.to, six.string_types) and f.rel.to._meta.swapped:\n+                        e.add(opts, \"'%s' defines a relation with the model '%s.%s', which has been swapped out. Update the relation to point at settings.%s.\" % (f.name, f.rel.to._meta.app_label, f.rel.to._meta.object_name, f.rel.to._meta.swappable))\n+                    else:\n+                        e.add(opts, \"'%s' has a relation with model %s, which has either not been installed or is abstract.\" % (f.name, f.rel.to))\n                 # it is a string and we could not find the model it refers to\n                 # so skip the next section\n                 if isinstance(f.rel.to, six.string_types):\n                     continue\n \n-                # Make sure the model we're related hasn't been swapped out\n-                if f.rel.to._meta.swapped:\n-                    e.add(opts, \"'%s' defines a relation with the model '%s.%s', which has been swapped out. Update the relation to point at settings.%s.\" % (f.name, f.rel.to._meta.app_label, f.rel.to._meta.object_name, f.rel.to._meta.swappable))\n-\n                 # Make sure the related field specified by a ForeignKey is unique\n                 if not f.rel.to._meta.get_field(f.rel.field_name).unique:\n                     e.add(opts, \"Field '%s' under model '%s' must have a unique=True constraint.\" % (f.rel.field_name, f.rel.to.__name__))\n@@ -184,16 +188,18 @@ def get_validation_errors(outfile, app=None):\n             # existing fields, m2m fields, m2m related objects or related\n             # objects\n             if f.rel.to not in models.get_models():\n-                e.add(opts, \"'%s' has an m2m relation with model %s, which has either not been installed or is abstract.\" % (f.name, f.rel.to))\n+                # If the related model is swapped, provide a hint;\n+                # otherwise, the model just hasn't been installed.\n+                if not isinstance(f.rel.to, six.string_types) and f.rel.to._meta.swapped:\n+                    e.add(opts, \"'%s' defines a relation with the model '%s.%s', which has been swapped out. Update the relation to point at settings.%s.\" % (f.name, f.rel.to._meta.app_label, f.rel.to._meta.object_name, f.rel.to._meta.swappable))\n+                else:\n+                    e.add(opts, \"'%s' has an m2m relation with model %s, which has either not been installed or is abstract.\" % (f.name, f.rel.to))\n+\n                 # it is a string and we could not find the model it refers to\n                 # so skip the next section\n                 if isinstance(f.rel.to, six.string_types):\n                     continue\n \n-            # Make sure the model we're related hasn't been swapped out\n-            if f.rel.to._meta.swapped:\n-                e.add(opts, \"'%s' defines a relation with the model '%s.%s', which has been swapped out. Update the relation to point at settings.%s.\" % (f.name, f.rel.to._meta.app_label, f.rel.to._meta.object_name, f.rel.to._meta.swappable))\n-\n             # Check that the field is not set to unique.  ManyToManyFields do not support unique.\n             if f.unique:\n                 e.add(opts, \"ManyToManyFields cannot be unique.  Remove the unique argument on '%s'.\" % f.name)"
        },
        {
            "sha": "a0510acc6ddee30983b97195e3275ff4832ae5c6",
            "filename": "django/db/models/loading.py",
            "status": "modified",
            "additions": 21,
            "deletions": 12,
            "changes": 33,
            "blob_url": "https://github.com/django/django/blob/c8985a8a7317042a641e870cb75b3005cc5d67b1/django%2Fdb%2Fmodels%2Floading.py",
            "raw_url": "https://github.com/django/django/raw/c8985a8a7317042a641e870cb75b3005cc5d67b1/django%2Fdb%2Fmodels%2Floading.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Floading.py?ref=c8985a8a7317042a641e870cb75b3005cc5d67b1",
            "patch": "@@ -24,24 +24,24 @@ class AppCache(object):\n     # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66531.\n     __shared_state = dict(\n         # Keys of app_store are the model modules for each application.\n-        app_store = SortedDict(),\n+        app_store=SortedDict(),\n \n         # Mapping of installed app_labels to model modules for that app.\n-        app_labels = {},\n+        app_labels={},\n \n         # Mapping of app_labels to a dictionary of model names to model code.\n         # May contain apps that are not installed.\n-        app_models = SortedDict(),\n+        app_models=SortedDict(),\n \n         # Mapping of app_labels to errors raised when trying to import the app.\n-        app_errors = {},\n+        app_errors={},\n \n         # -- Everything below here is only used when populating the cache --\n-        loaded = False,\n-        handled = {},\n-        postponed = [],\n-        nesting_level = 0,\n-        _get_models_cache = {},\n+        loaded=False,\n+        handled={},\n+        postponed=[],\n+        nesting_level=0,\n+        _get_models_cache={},\n     )\n \n     def __init__(self):\n@@ -167,7 +167,7 @@ def get_app_errors(self):\n \n     def get_models(self, app_mod=None,\n                    include_auto_created=False, include_deferred=False,\n-                   only_installed=True):\n+                   only_installed=True, include_swapped=False):\n         \"\"\"\n         Given a module containing models, returns a list of the models.\n         Otherwise returns a list of all installed models.\n@@ -179,8 +179,16 @@ def get_models(self, app_mod=None,\n         By default, models created to satisfy deferred attribute\n         queries are *not* included in the list of models. However, if\n         you specify include_deferred, they will be.\n+\n+        By default, models that aren't part of installed apps will *not*\n+        be included in the list of models. However, if you specify\n+        only_installed=False, they will be.\n+\n+        By default, models that have been swapped out will *not* be\n+        included in the list of models. However, if you specify\n+        include_swapped, they will be.\n         \"\"\"\n-        cache_key = (app_mod, include_auto_created, include_deferred, only_installed)\n+        cache_key = (app_mod, include_auto_created, include_deferred, only_installed, include_swapped)\n         try:\n             return self._get_models_cache[cache_key]\n         except KeyError:\n@@ -203,7 +211,8 @@ def get_models(self, app_mod=None,\n             model_list.extend(\n                 model for model in app.values()\n                 if ((not model._deferred or include_deferred) and\n-                    (not model._meta.auto_created or include_auto_created))\n+                    (not model._meta.auto_created or include_auto_created) and\n+                    (not model._meta.swapped or include_swapped))\n             )\n         self._get_models_cache[cache_key] = model_list\n         return model_list"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/regressiontests/swappable_models/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/django/django/blob/c8985a8a7317042a641e870cb75b3005cc5d67b1/tests%2Fregressiontests%2Fswappable_models%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/c8985a8a7317042a641e870cb75b3005cc5d67b1/tests%2Fregressiontests%2Fswappable_models%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fswappable_models%2F__init__.py?ref=c8985a8a7317042a641e870cb75b3005cc5d67b1"
        },
        {
            "sha": "92692d439694256fd24d48420d0cb45643cd8464",
            "filename": "tests/regressiontests/swappable_models/models.py",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/django/django/blob/c8985a8a7317042a641e870cb75b3005cc5d67b1/tests%2Fregressiontests%2Fswappable_models%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/c8985a8a7317042a641e870cb75b3005cc5d67b1/tests%2Fregressiontests%2Fswappable_models%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fswappable_models%2Fmodels.py?ref=c8985a8a7317042a641e870cb75b3005cc5d67b1",
            "patch": "@@ -0,0 +1,15 @@\n+from django.db import models\n+\n+\n+class Article(models.Model):\n+    title =  models.CharField(max_length=100)\n+    publication_date = models.DateField()\n+\n+    class Meta:\n+        swappable = 'TEST_ARTICLE_MODEL'\n+\n+\n+class AlternateArticle(models.Model):\n+    title =  models.CharField(max_length=100)\n+    publication_date = models.DateField()\n+    byline = models.CharField(max_length=100)"
        },
        {
            "sha": "d9a01f9e26f2afb87b833a1c38a96c6de1e9be11",
            "filename": "tests/regressiontests/swappable_models/tests.py",
            "status": "added",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/django/django/blob/c8985a8a7317042a641e870cb75b3005cc5d67b1/tests%2Fregressiontests%2Fswappable_models%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/c8985a8a7317042a641e870cb75b3005cc5d67b1/tests%2Fregressiontests%2Fswappable_models%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fswappable_models%2Ftests.py?ref=c8985a8a7317042a641e870cb75b3005cc5d67b1",
            "patch": "@@ -0,0 +1,46 @@\n+from __future__ import absolute_import, unicode_literals\n+\n+from django.utils.six import StringIO\n+\n+from django.contrib.auth.models import Permission\n+from django.contrib.contenttypes.models import ContentType\n+from django.core import management\n+from django.db.models.loading import cache\n+from django.test import TestCase\n+from django.test.utils import override_settings\n+\n+\n+class SwappableModelTests(TestCase):\n+    def setUp(self):\n+        # This test modifies the installed apps, so we need to make sure\n+        # we're not dealing with a cached app list.\n+        cache._get_models_cache.clear()\n+\n+    def tearDown(self):\n+        # By fiddling with swappable models, we alter the installed models\n+        # cache, so flush it to make sure there are no side effects.\n+        cache._get_models_cache.clear()\n+\n+    @override_settings(TEST_ARTICLE_MODEL='swappable_models.AlternateArticle')\n+    def test_generated_data(self):\n+        \"Permissions and content types are not created for a swapped model\"\n+\n+        # Delete all permissions and content_types\n+        Permission.objects.all().delete()\n+        ContentType.objects.all().delete()\n+\n+        # Re-run syncdb. This will re-build the permissions and content types.\n+        new_io = StringIO()\n+        management.call_command('syncdb', load_initial_data=False, interactive=False, stdout=new_io)\n+\n+        # Check that content types and permissions exist for the swapped model,\n+        # but not for the swappable model.\n+        apps_models = [(p.content_type.app_label, p.content_type.model)\n+                       for p in Permission.objects.all()]\n+        self.assertIn(('swappable_models', 'alternatearticle'), apps_models)\n+        self.assertNotIn(('swappable_models', 'article'), apps_models)\n+\n+        apps_models = [(ct.app_label, ct.model)\n+                       for ct in ContentType.objects.all()]\n+        self.assertIn(('swappable_models', 'alternatearticle'), apps_models)\n+        self.assertNotIn(('swappable_models', 'article'), apps_models)"
        }
    ],
    "stats": {
        "total": 124,
        "additions": 101,
        "deletions": 23
    }
}