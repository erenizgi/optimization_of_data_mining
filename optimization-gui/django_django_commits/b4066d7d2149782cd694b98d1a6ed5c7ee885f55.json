{
    "author": "unknown",
    "message": "Cleaned up the the http module. Moved all of the code from __init__.py to request.py, response.py and utils.py",
    "sha": "b4066d7d2149782cd694b98d1a6ed5c7ee885f55",
    "files": [
        {
            "sha": "46afa34ee7376c78d66dd3c1934a6e642f7ab69c",
            "filename": "django/http/__init__.py",
            "status": "modified",
            "additions": 10,
            "deletions": 933,
            "changes": 943,
            "blob_url": "https://github.com/django/django/blob/b4066d7d2149782cd694b98d1a6ed5c7ee885f55/django%2Fhttp%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/b4066d7d2149782cd694b98d1a6ed5c7ee885f55/django%2Fhttp%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2F__init__.py?ref=b4066d7d2149782cd694b98d1a6ed5c7ee885f55",
            "patch": "@@ -1,933 +1,10 @@\n-from __future__ import absolute_import, unicode_literals\n-\n-import copy\n-import datetime\n-from email.header import Header\n-import os\n-import re\n-import sys\n-import time\n-import warnings\n-\n-from io import BytesIO\n-from pprint import pformat\n-try:\n-    from urllib.parse import quote, parse_qsl, urlencode, urljoin, urlparse\n-except ImportError:     # Python 2\n-    from urllib import quote, urlencode\n-    from urlparse import parse_qsl, urljoin, urlparse\n-\n-from django.utils.six.moves import http_cookies\n-# Some versions of Python 2.7 and later won't need this encoding bug fix:\n-_cookie_encodes_correctly = http_cookies.SimpleCookie().value_encode(';') == (';', '\"\\\\073\"')\n-# See ticket #13007, http://bugs.python.org/issue2193 and http://trac.edgewall.org/ticket/2256\n-_tc = http_cookies.SimpleCookie()\n-try:\n-    _tc.load(str('foo:bar=1'))\n-    _cookie_allows_colon_in_names = True\n-except http_cookies.CookieError:\n-    _cookie_allows_colon_in_names = False\n-\n-if _cookie_encodes_correctly and _cookie_allows_colon_in_names:\n-    SimpleCookie = http_cookies.SimpleCookie\n-else:\n-    Morsel = http_cookies.Morsel\n-\n-    class SimpleCookie(http_cookies.SimpleCookie):\n-        if not _cookie_encodes_correctly:\n-            def value_encode(self, val):\n-                # Some browsers do not support quoted-string from RFC 2109,\n-                # including some versions of Safari and Internet Explorer.\n-                # These browsers split on ';', and some versions of Safari\n-                # are known to split on ', '. Therefore, we encode ';' and ','\n-\n-                # SimpleCookie already does the hard work of encoding and decoding.\n-                # It uses octal sequences like '\\\\012' for newline etc.\n-                # and non-ASCII chars. We just make use of this mechanism, to\n-                # avoid introducing two encoding schemes which would be confusing\n-                # and especially awkward for javascript.\n-\n-                # NB, contrary to Python docs, value_encode returns a tuple containing\n-                # (real val, encoded_val)\n-                val, encoded = super(SimpleCookie, self).value_encode(val)\n-\n-                encoded = encoded.replace(\";\", \"\\\\073\").replace(\",\",\"\\\\054\")\n-                # If encoded now contains any quoted chars, we need double quotes\n-                # around the whole string.\n-                if \"\\\\\" in encoded and not encoded.startswith('\"'):\n-                    encoded = '\"' + encoded + '\"'\n-\n-                return val, encoded\n-\n-        if not _cookie_allows_colon_in_names:\n-            def load(self, rawdata):\n-                self.bad_cookies = set()\n-                super(SimpleCookie, self).load(force_str(rawdata))\n-                for key in self.bad_cookies:\n-                    del self[key]\n-\n-            # override private __set() method:\n-            # (needed for using our Morsel, and for laxness with CookieError\n-            def _BaseCookie__set(self, key, real_value, coded_value):\n-                key = force_str(key)\n-                try:\n-                    M = self.get(key, Morsel())\n-                    M.set(key, real_value, coded_value)\n-                    dict.__setitem__(self, key, M)\n-                except http_cookies.CookieError:\n-                    self.bad_cookies.add(key)\n-                    dict.__setitem__(self, key, http_cookies.Morsel())\n-\n-\n-from django.conf import settings\n-from django.core import signing\n-from django.core.exceptions import ImproperlyConfigured, SuspiciousOperation\n-from django.core.files import uploadhandler\n-from django.http.multipartparser import MultiPartParser\n-from django.http.utils import *\n-from django.utils.datastructures import MultiValueDict, ImmutableList\n-from django.utils.encoding import force_bytes, force_str, force_text, iri_to_uri\n-from django.utils.http import cookie_date\n-from django.utils import six\n-from django.utils import timezone\n-\n-RESERVED_CHARS=\"!*'();:@&=+$,/?%#[]\"\n-\n-absolute_http_url_re = re.compile(r\"^https?://\", re.I)\n-\n-class Http404(Exception):\n-    pass\n-\n-RAISE_ERROR = object()\n-\n-\n-def build_request_repr(request, path_override=None, GET_override=None,\n-                       POST_override=None, COOKIES_override=None,\n-                       META_override=None):\n-    \"\"\"\n-    Builds and returns the request's representation string. The request's\n-    attributes may be overridden by pre-processed values.\n-    \"\"\"\n-    # Since this is called as part of error handling, we need to be very\n-    # robust against potentially malformed input.\n-    try:\n-        get = (pformat(GET_override)\n-               if GET_override is not None\n-               else pformat(request.GET))\n-    except Exception:\n-        get = '<could not parse>'\n-    if request._post_parse_error:\n-        post = '<could not parse>'\n-    else:\n-        try:\n-            post = (pformat(POST_override)\n-                    if POST_override is not None\n-                    else pformat(request.POST))\n-        except Exception:\n-            post = '<could not parse>'\n-    try:\n-        cookies = (pformat(COOKIES_override)\n-                   if COOKIES_override is not None\n-                   else pformat(request.COOKIES))\n-    except Exception:\n-        cookies = '<could not parse>'\n-    try:\n-        meta = (pformat(META_override)\n-                if META_override is not None\n-                else pformat(request.META))\n-    except Exception:\n-        meta = '<could not parse>'\n-    path = path_override if path_override is not None else request.path\n-    return force_str('<%s\\npath:%s,\\nGET:%s,\\nPOST:%s,\\nCOOKIES:%s,\\nMETA:%s>' %\n-                     (request.__class__.__name__,\n-                      path,\n-                      six.text_type(get),\n-                      six.text_type(post),\n-                      six.text_type(cookies),\n-                      six.text_type(meta)))\n-\n-class UnreadablePostError(IOError):\n-    pass\n-\n-class HttpRequest(object):\n-    \"\"\"A basic HTTP request.\"\"\"\n-\n-    # The encoding used in GET/POST dicts. None means use default setting.\n-    _encoding = None\n-    _upload_handlers = []\n-\n-    def __init__(self):\n-        self.GET, self.POST, self.COOKIES, self.META, self.FILES = {}, {}, {}, {}, {}\n-        self.path = ''\n-        self.path_info = ''\n-        self.method = None\n-        self._post_parse_error = False\n-\n-    def __repr__(self):\n-        return build_request_repr(self)\n-\n-    def get_host(self):\n-        \"\"\"Returns the HTTP host using the environment or request headers.\"\"\"\n-        # We try three options, in order of decreasing preference.\n-        if settings.USE_X_FORWARDED_HOST and (\n-            'HTTP_X_FORWARDED_HOST' in self.META):\n-            host = self.META['HTTP_X_FORWARDED_HOST']\n-        elif 'HTTP_HOST' in self.META:\n-            host = self.META['HTTP_HOST']\n-        else:\n-            # Reconstruct the host using the algorithm from PEP 333.\n-            host = self.META['SERVER_NAME']\n-            server_port = str(self.META['SERVER_PORT'])\n-            if server_port != ('443' if self.is_secure() else '80'):\n-                host = '%s:%s' % (host, server_port)\n-\n-        # Disallow potentially poisoned hostnames.\n-        if set(';/?@&=+$,').intersection(host):\n-            raise SuspiciousOperation('Invalid HTTP_HOST header: %s' % host)\n-\n-        return host\n-\n-    def get_full_path(self):\n-        # RFC 3986 requires query string arguments to be in the ASCII range.\n-        # Rather than crash if this doesn't happen, we encode defensively.\n-        return '%s%s' % (self.path, ('?' + iri_to_uri(self.META.get('QUERY_STRING', ''))) if self.META.get('QUERY_STRING', '') else '')\n-\n-    def get_signed_cookie(self, key, default=RAISE_ERROR, salt='', max_age=None):\n-        \"\"\"\n-        Attempts to return a signed cookie. If the signature fails or the\n-        cookie has expired, raises an exception... unless you provide the\n-        default argument in which case that value will be returned instead.\n-        \"\"\"\n-        try:\n-            cookie_value = self.COOKIES[key]\n-        except KeyError:\n-            if default is not RAISE_ERROR:\n-                return default\n-            else:\n-                raise\n-        try:\n-            value = signing.get_cookie_signer(salt=key + salt).unsign(\n-                cookie_value, max_age=max_age)\n-        except signing.BadSignature:\n-            if default is not RAISE_ERROR:\n-                return default\n-            else:\n-                raise\n-        return value\n-\n-    def build_absolute_uri(self, location=None):\n-        \"\"\"\n-        Builds an absolute URI from the location and the variables available in\n-        this request. If no location is specified, the absolute URI is built on\n-        ``request.get_full_path()``.\n-        \"\"\"\n-        if not location:\n-            location = self.get_full_path()\n-        if not absolute_http_url_re.match(location):\n-            current_uri = '%s://%s%s' % ('https' if self.is_secure() else 'http',\n-                                         self.get_host(), self.path)\n-            location = urljoin(current_uri, location)\n-        return iri_to_uri(location)\n-\n-    def _is_secure(self):\n-        return os.environ.get(\"HTTPS\") == \"on\"\n-\n-    def is_secure(self):\n-        # First, check the SECURE_PROXY_SSL_HEADER setting.\n-        if settings.SECURE_PROXY_SSL_HEADER:\n-            try:\n-                header, value = settings.SECURE_PROXY_SSL_HEADER\n-            except ValueError:\n-                raise ImproperlyConfigured('The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.')\n-            if self.META.get(header, None) == value:\n-                return True\n-\n-        # Failing that, fall back to _is_secure(), which is a hook for\n-        # subclasses to implement.\n-        return self._is_secure()\n-\n-    def is_ajax(self):\n-        return self.META.get('HTTP_X_REQUESTED_WITH') == 'XMLHttpRequest'\n-\n-    @property\n-    def encoding(self):\n-        return self._encoding\n-\n-    @encoding.setter\n-    def encoding(self, val):\n-        \"\"\"\n-        Sets the encoding used for GET/POST accesses. If the GET or POST\n-        dictionary has already been created, it is removed and recreated on the\n-        next access (so that it is decoded correctly).\n-        \"\"\"\n-        self._encoding = val\n-        if hasattr(self, '_get'):\n-            del self._get\n-        if hasattr(self, '_post'):\n-            del self._post\n-\n-    def _initialize_handlers(self):\n-        self._upload_handlers = [uploadhandler.load_handler(handler, self)\n-                                 for handler in settings.FILE_UPLOAD_HANDLERS]\n-\n-    @property\n-    def upload_handlers(self):\n-        if not self._upload_handlers:\n-            # If there are no upload handlers defined, initialize them from settings.\n-            self._initialize_handlers()\n-        return self._upload_handlers\n-\n-    @upload_handlers.setter\n-    def upload_handlers(self, upload_handlers):\n-        if hasattr(self, '_files'):\n-            raise AttributeError(\"You cannot set the upload handlers after the upload has been processed.\")\n-        self._upload_handlers = upload_handlers\n-\n-    def parse_file_upload(self, META, post_data):\n-        \"\"\"Returns a tuple of (POST QueryDict, FILES MultiValueDict).\"\"\"\n-        self.upload_handlers = ImmutableList(\n-            self.upload_handlers,\n-            warning=\"You cannot alter upload handlers after the upload has been processed.\"\n-        )\n-        parser = MultiPartParser(META, post_data, self.upload_handlers, self.encoding)\n-        return parser.parse()\n-\n-    @property\n-    def body(self):\n-        if not hasattr(self, '_body'):\n-            if self._read_started:\n-                raise Exception(\"You cannot access body after reading from request's data stream\")\n-            try:\n-                self._body = self.read()\n-            except IOError as e:\n-                six.reraise(UnreadablePostError, UnreadablePostError(*e.args), sys.exc_info()[2])\n-            self._stream = BytesIO(self._body)\n-        return self._body\n-\n-    @property\n-    def raw_post_data(self):\n-        warnings.warn('HttpRequest.raw_post_data has been deprecated. Use HttpRequest.body instead.', DeprecationWarning)\n-        return self.body\n-\n-    def _mark_post_parse_error(self):\n-        self._post = QueryDict('')\n-        self._files = MultiValueDict()\n-        self._post_parse_error = True\n-\n-    def _load_post_and_files(self):\n-        \"\"\"Populate self._post and self._files if the content-type is a form type\"\"\"\n-        if self.method != 'POST':\n-            self._post, self._files = QueryDict('', encoding=self._encoding), MultiValueDict()\n-            return\n-        if self._read_started and not hasattr(self, '_body'):\n-            self._mark_post_parse_error()\n-            return\n-\n-        if self.META.get('CONTENT_TYPE', '').startswith('multipart/form-data'):\n-            if hasattr(self, '_body'):\n-                # Use already read data\n-                data = BytesIO(self._body)\n-            else:\n-                data = self\n-            try:\n-                self._post, self._files = self.parse_file_upload(self.META, data)\n-            except:\n-                # An error occured while parsing POST data. Since when\n-                # formatting the error the request handler might access\n-                # self.POST, set self._post and self._file to prevent\n-                # attempts to parse POST data again.\n-                # Mark that an error occured. This allows self.__repr__ to\n-                # be explicit about it instead of simply representing an\n-                # empty POST\n-                self._mark_post_parse_error()\n-                raise\n-        elif self.META.get('CONTENT_TYPE', '').startswith('application/x-www-form-urlencoded'):\n-            self._post, self._files = QueryDict(self.body, encoding=self._encoding), MultiValueDict()\n-        else:\n-            self._post, self._files = QueryDict('', encoding=self._encoding), MultiValueDict()\n-\n-    ## File-like and iterator interface.\n-    ##\n-    ## Expects self._stream to be set to an appropriate source of bytes by\n-    ## a corresponding request subclass (e.g. WSGIRequest).\n-    ## Also when request data has already been read by request.POST or\n-    ## request.body, self._stream points to a BytesIO instance\n-    ## containing that data.\n-\n-    def read(self, *args, **kwargs):\n-        self._read_started = True\n-        return self._stream.read(*args, **kwargs)\n-\n-    def readline(self, *args, **kwargs):\n-        self._read_started = True\n-        return self._stream.readline(*args, **kwargs)\n-\n-    def xreadlines(self):\n-        while True:\n-            buf = self.readline()\n-            if not buf:\n-                break\n-            yield buf\n-\n-    __iter__ = xreadlines\n-\n-    def readlines(self):\n-        return list(iter(self))\n-\n-\n-class QueryDict(MultiValueDict):\n-    \"\"\"\n-    A specialized MultiValueDict that takes a query string when initialized.\n-    This is immutable unless you create a copy of it.\n-\n-    Values retrieved from this class are converted from the given encoding\n-    (DEFAULT_CHARSET by default) to unicode.\n-    \"\"\"\n-    # These are both reset in __init__, but is specified here at the class\n-    # level so that unpickling will have valid values\n-    _mutable = True\n-    _encoding = None\n-\n-    def __init__(self, query_string, mutable=False, encoding=None):\n-        super(QueryDict, self).__init__()\n-        if not encoding:\n-            encoding = settings.DEFAULT_CHARSET\n-        self.encoding = encoding\n-        if six.PY3:\n-            for key, value in parse_qsl(query_string or '',\n-                                        keep_blank_values=True,\n-                                        encoding=encoding):\n-                self.appendlist(key, value)\n-        else:\n-            for key, value in parse_qsl(query_string or '',\n-                                        keep_blank_values=True):\n-                self.appendlist(force_text(key, encoding, errors='replace'),\n-                                force_text(value, encoding, errors='replace'))\n-        self._mutable = mutable\n-\n-    @property\n-    def encoding(self):\n-        if self._encoding is None:\n-            self._encoding = settings.DEFAULT_CHARSET\n-        return self._encoding\n-\n-    @encoding.setter\n-    def encoding(self, value):\n-        self._encoding = value\n-\n-    def _assert_mutable(self):\n-        if not self._mutable:\n-            raise AttributeError(\"This QueryDict instance is immutable\")\n-\n-    def __setitem__(self, key, value):\n-        self._assert_mutable()\n-        key = bytes_to_text(key, self.encoding)\n-        value = bytes_to_text(value, self.encoding)\n-        super(QueryDict, self).__setitem__(key, value)\n-\n-    def __delitem__(self, key):\n-        self._assert_mutable()\n-        super(QueryDict, self).__delitem__(key)\n-\n-    def __copy__(self):\n-        result = self.__class__('', mutable=True, encoding=self.encoding)\n-        for key, value in six.iterlists(self):\n-            result.setlist(key, value)\n-        return result\n-\n-    def __deepcopy__(self, memo):\n-        result = self.__class__('', mutable=True, encoding=self.encoding)\n-        memo[id(self)] = result\n-        for key, value in six.iterlists(self):\n-            result.setlist(copy.deepcopy(key, memo), copy.deepcopy(value, memo))\n-        return result\n-\n-    def setlist(self, key, list_):\n-        self._assert_mutable()\n-        key = bytes_to_text(key, self.encoding)\n-        list_ = [bytes_to_text(elt, self.encoding) for elt in list_]\n-        super(QueryDict, self).setlist(key, list_)\n-\n-    def setlistdefault(self, key, default_list=None):\n-        self._assert_mutable()\n-        return super(QueryDict, self).setlistdefault(key, default_list)\n-\n-    def appendlist(self, key, value):\n-        self._assert_mutable()\n-        key = bytes_to_text(key, self.encoding)\n-        value = bytes_to_text(value, self.encoding)\n-        super(QueryDict, self).appendlist(key, value)\n-\n-    def pop(self, key, *args):\n-        self._assert_mutable()\n-        return super(QueryDict, self).pop(key, *args)\n-\n-    def popitem(self):\n-        self._assert_mutable()\n-        return super(QueryDict, self).popitem()\n-\n-    def clear(self):\n-        self._assert_mutable()\n-        super(QueryDict, self).clear()\n-\n-    def setdefault(self, key, default=None):\n-        self._assert_mutable()\n-        key = bytes_to_text(key, self.encoding)\n-        default = bytes_to_text(default, self.encoding)\n-        return super(QueryDict, self).setdefault(key, default)\n-\n-    def copy(self):\n-        \"\"\"Returns a mutable copy of this object.\"\"\"\n-        return self.__deepcopy__({})\n-\n-    def urlencode(self, safe=None):\n-        \"\"\"\n-        Returns an encoded string of all query string arguments.\n-\n-        :arg safe: Used to specify characters which do not require quoting, for\n-            example::\n-\n-                >>> q = QueryDict('', mutable=True)\n-                >>> q['next'] = '/a&b/'\n-                >>> q.urlencode()\n-                'next=%2Fa%26b%2F'\n-                >>> q.urlencode(safe='/')\n-                'next=/a%26b/'\n-\n-        \"\"\"\n-        output = []\n-        if safe:\n-            safe = force_bytes(safe, self.encoding)\n-            encode = lambda k, v: '%s=%s' % ((quote(k, safe), quote(v, safe)))\n-        else:\n-            encode = lambda k, v: urlencode({k: v})\n-        for k, list_ in self.lists():\n-            k = force_bytes(k, self.encoding)\n-            output.extend([encode(k, force_bytes(v, self.encoding))\n-                           for v in list_])\n-        return '&'.join(output)\n-\n-\n-def parse_cookie(cookie):\n-    if cookie == '':\n-        return {}\n-    if not isinstance(cookie, http_cookies.BaseCookie):\n-        try:\n-            c = SimpleCookie()\n-            c.load(cookie)\n-        except http_cookies.CookieError:\n-            # Invalid cookie\n-            return {}\n-    else:\n-        c = cookie\n-    cookiedict = {}\n-    for key in c.keys():\n-        cookiedict[key] = c.get(key).value\n-    return cookiedict\n-\n-class BadHeaderError(ValueError):\n-    pass\n-\n-class HttpResponseBase(object):\n-    \"\"\"\n-    An HTTP response base class with dictionary-accessed headers.\n-\n-    This class doesn't handle content. It should not be used directly.\n-    Use the HttpResponse and StreamingHttpResponse subclasses instead.\n-    \"\"\"\n-\n-    status_code = 200\n-\n-    def __init__(self, content_type=None, status=None, mimetype=None):\n-        # _headers is a mapping of the lower-case name to the original case of\n-        # the header (required for working with legacy systems) and the header\n-        # value. Both the name of the header and its value are ASCII strings.\n-        self._headers = {}\n-        self._charset = settings.DEFAULT_CHARSET\n-        self._closable_objects = []\n-        if mimetype:\n-            warnings.warn(\"Using mimetype keyword argument is deprecated, use\"\n-                          \" content_type instead\", PendingDeprecationWarning)\n-            content_type = mimetype\n-        if not content_type:\n-            content_type = \"%s; charset=%s\" % (settings.DEFAULT_CONTENT_TYPE,\n-                    self._charset)\n-        self.cookies = SimpleCookie()\n-        if status:\n-            self.status_code = status\n-\n-        self['Content-Type'] = content_type\n-\n-    def serialize_headers(self):\n-        \"\"\"HTTP headers as a bytestring.\"\"\"\n-        headers = [\n-            ('%s: %s' % (key, value)).encode('us-ascii')\n-            for key, value in self._headers.values()\n-        ]\n-        return b'\\r\\n'.join(headers)\n-\n-    if six.PY3:\n-        __bytes__ = serialize_headers\n-    else:\n-        __str__ = serialize_headers\n-\n-    def _convert_to_charset(self, value, charset, mime_encode=False):\n-        \"\"\"Converts headers key/value to ascii/latin1 native strings.\n-\n-        `charset` must be 'ascii' or 'latin-1'. If `mime_encode` is True and\n-        `value` value can't be represented in the given charset, MIME-encoding\n-        is applied.\n-        \"\"\"\n-        if not isinstance(value, (bytes, six.text_type)):\n-            value = str(value)\n-        try:\n-            if six.PY3:\n-                if isinstance(value, str):\n-                    # Ensure string is valid in given charset\n-                    value.encode(charset)\n-                else:\n-                    # Convert bytestring using given charset\n-                    value = value.decode(charset)\n-            else:\n-                if isinstance(value, str):\n-                    # Ensure string is valid in given charset\n-                    value.decode(charset)\n-                else:\n-                    # Convert unicode string to given charset\n-                    value = value.encode(charset)\n-        except UnicodeError as e:\n-            if mime_encode:\n-                # Wrapping in str() is a workaround for #12422 under Python 2.\n-                value = str(Header(value, 'utf-8').encode())\n-            else:\n-                e.reason += ', HTTP response headers must be in %s format' % charset\n-                raise\n-        if str('\\n') in value or str('\\r') in value:\n-            raise BadHeaderError(\"Header values can't contain newlines (got %r)\" % value)\n-        return value\n-\n-    def __setitem__(self, header, value):\n-        header = self._convert_to_charset(header, 'ascii')\n-        value = self._convert_to_charset(value, 'latin1', mime_encode=True)\n-        self._headers[header.lower()] = (header, value)\n-\n-    def __delitem__(self, header):\n-        try:\n-            del self._headers[header.lower()]\n-        except KeyError:\n-            pass\n-\n-    def __getitem__(self, header):\n-        return self._headers[header.lower()][1]\n-\n-    def __getstate__(self):\n-        # SimpleCookie is not pickeable with pickle.HIGHEST_PROTOCOL, so we\n-        # serialise to a string instead\n-        state = self.__dict__.copy()\n-        state['cookies'] = str(state['cookies'])\n-        return state\n-\n-    def __setstate__(self, state):\n-        self.__dict__.update(state)\n-        self.cookies = SimpleCookie(self.cookies)\n-\n-    def has_header(self, header):\n-        \"\"\"Case-insensitive check for a header.\"\"\"\n-        return header.lower() in self._headers\n-\n-    __contains__ = has_header\n-\n-    def items(self):\n-        return self._headers.values()\n-\n-    def get(self, header, alternate=None):\n-        return self._headers.get(header.lower(), (None, alternate))[1]\n-\n-    def set_cookie(self, key, value='', max_age=None, expires=None, path='/',\n-                   domain=None, secure=False, httponly=False):\n-        \"\"\"\n-        Sets a cookie.\n-\n-        ``expires`` can be:\n-        - a string in the correct format,\n-        - a naive ``datetime.datetime`` object in UTC,\n-        - an aware ``datetime.datetime`` object in any time zone.\n-        If it is a ``datetime.datetime`` object then ``max_age`` will be calculated.\n-\n-        \"\"\"\n-        self.cookies[key] = value\n-        if expires is not None:\n-            if isinstance(expires, datetime.datetime):\n-                if timezone.is_aware(expires):\n-                    expires = timezone.make_naive(expires, timezone.utc)\n-                delta = expires - expires.utcnow()\n-                # Add one second so the date matches exactly (a fraction of\n-                # time gets lost between converting to a timedelta and\n-                # then the date string).\n-                delta = delta + datetime.timedelta(seconds=1)\n-                # Just set max_age - the max_age logic will set expires.\n-                expires = None\n-                max_age = max(0, delta.days * 86400 + delta.seconds)\n-            else:\n-                self.cookies[key]['expires'] = expires\n-        if max_age is not None:\n-            self.cookies[key]['max-age'] = max_age\n-            # IE requires expires, so set it if hasn't been already.\n-            if not expires:\n-                self.cookies[key]['expires'] = cookie_date(time.time() +\n-                                                           max_age)\n-        if path is not None:\n-            self.cookies[key]['path'] = path\n-        if domain is not None:\n-            self.cookies[key]['domain'] = domain\n-        if secure:\n-            self.cookies[key]['secure'] = True\n-        if httponly:\n-            self.cookies[key]['httponly'] = True\n-\n-    def set_signed_cookie(self, key, value, salt='', **kwargs):\n-        value = signing.get_cookie_signer(salt=key + salt).sign(value)\n-        return self.set_cookie(key, value, **kwargs)\n-\n-    def delete_cookie(self, key, path='/', domain=None):\n-        self.set_cookie(key, max_age=0, path=path, domain=domain,\n-                        expires='Thu, 01-Jan-1970 00:00:00 GMT')\n-\n-    # Common methods used by subclasses\n-\n-    def make_bytes(self, value):\n-        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n-        # For backwards compatibility, this method supports values that are\n-        # unlikely to occur in real applications. It has grown complex and\n-        # should be refactored. It also overlaps __next__. See #18796.\n-        if self.has_header('Content-Encoding'):\n-            if isinstance(value, int):\n-                value = six.text_type(value)\n-            if isinstance(value, six.text_type):\n-                value = value.encode('ascii')\n-            # force conversion to bytes in case chunk is a subclass\n-            return bytes(value)\n-        else:\n-            return force_bytes(value, self._charset)\n-\n-    # These methods partially implement the file-like object interface.\n-    # See http://docs.python.org/lib/bltin-file-objects.html\n-\n-    # The WSGI server must call this method upon completion of the request.\n-    # See http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html\n-    def close(self):\n-        for closable in self._closable_objects:\n-            closable.close()\n-\n-    def write(self, content):\n-        raise Exception(\"This %s instance is not writable\" % self.__class__.__name__)\n-\n-    def flush(self):\n-        pass\n-\n-    def tell(self):\n-        raise Exception(\"This %s instance cannot tell its position\" % self.__class__.__name__)\n-\n-class HttpResponse(HttpResponseBase):\n-    \"\"\"\n-    An HTTP response class with a string as content.\n-\n-    This content that can be read, appended to or replaced.\n-    \"\"\"\n-\n-    streaming = False\n-\n-    def __init__(self, content='', *args, **kwargs):\n-        super(HttpResponse, self).__init__(*args, **kwargs)\n-        # Content is a bytestring. See the `content` property methods.\n-        self.content = content\n-\n-    def serialize(self):\n-        \"\"\"Full HTTP message, including headers, as a bytestring.\"\"\"\n-        return self.serialize_headers() + b'\\r\\n\\r\\n' + self.content\n-\n-    if six.PY3:\n-        __bytes__ = serialize\n-    else:\n-        __str__ = serialize\n-\n-    @property\n-    def content(self):\n-        return b''.join(self.make_bytes(e) for e in self._container)\n-\n-    @content.setter\n-    def content(self, value):\n-        if hasattr(value, '__iter__') and not isinstance(value, (bytes, six.string_types)):\n-            self._container = value\n-            self._base_content_is_iter = True\n-            if hasattr(value, 'close'):\n-                self._closable_objects.append(value)\n-        else:\n-            self._container = [value]\n-            self._base_content_is_iter = False\n-\n-    def __iter__(self):\n-        self._iterator = iter(self._container)\n-        return self\n-\n-    def __next__(self):\n-        chunk = next(self._iterator)\n-        if isinstance(chunk, int):\n-            chunk = six.text_type(chunk)\n-        if isinstance(chunk, six.text_type):\n-            chunk = chunk.encode(self._charset)\n-        # force conversion to bytes in case chunk is a subclass\n-        return bytes(chunk)\n-\n-    next = __next__             # Python 2 compatibility\n-\n-    def write(self, content):\n-        if self._base_content_is_iter:\n-            raise Exception(\"This %s instance is not writable\" % self.__class__.__name__)\n-        self._container.append(content)\n-\n-    def tell(self):\n-        if self._base_content_is_iter:\n-            raise Exception(\"This %s instance cannot tell its position\" % self.__class__.__name__)\n-        return sum([len(chunk) for chunk in self])\n-\n-class StreamingHttpResponse(HttpResponseBase):\n-    \"\"\"\n-    A streaming HTTP response class with an iterator as content.\n-\n-    This should only be iterated once, when the response is streamed to the\n-    client. However, it can be appended to or replaced with a new iterator\n-    that wraps the original content (or yields entirely new content).\n-    \"\"\"\n-\n-    streaming = True\n-\n-    def __init__(self, streaming_content=(), *args, **kwargs):\n-        super(StreamingHttpResponse, self).__init__(*args, **kwargs)\n-        # `streaming_content` should be an iterable of bytestrings.\n-        # See the `streaming_content` property methods.\n-        self.streaming_content = streaming_content\n-\n-    @property\n-    def content(self):\n-        raise AttributeError(\"This %s instance has no `content` attribute. \"\n-            \"Use `streaming_content` instead.\" % self.__class__.__name__)\n-\n-    @property\n-    def streaming_content(self):\n-        return self._iterator\n-\n-    @streaming_content.setter\n-    def streaming_content(self, value):\n-        # Ensure we can never iterate on \"value\" more than once.\n-        self._iterator = iter(value)\n-        if hasattr(value, 'close'):\n-            self._closable_objects.append(value)\n-\n-    def __iter__(self):\n-        return self\n-\n-    def __next__(self):\n-        return self.make_bytes(next(self._iterator))\n-\n-    next = __next__             # Python 2 compatibility\n-\n-class CompatibleStreamingHttpResponse(StreamingHttpResponse):\n-    \"\"\"\n-    This class maintains compatibility with middleware that doesn't know how\n-    to handle the content of a streaming response by exposing a `content`\n-    attribute that will consume and cache the content iterator when accessed.\n-\n-    These responses will stream only if no middleware attempts to access the\n-    `content` attribute. Otherwise, they will behave like a regular response,\n-    and raise a `PendingDeprecationWarning`.\n-    \"\"\"\n-    @property\n-    def content(self):\n-        warnings.warn(\n-            'Accessing the `content` attribute on a streaming response is '\n-            'deprecated. Use the `streaming_content` attribute instead.',\n-            PendingDeprecationWarning)\n-        content = b''.join(self)\n-        self.streaming_content = [content]\n-        return content\n-\n-    @content.setter\n-    def content(self, content):\n-        warnings.warn(\n-            'Accessing the `content` attribute on a streaming response is '\n-            'deprecated. Use the `streaming_content` attribute instead.',\n-            PendingDeprecationWarning)\n-        self.streaming_content = [content]\n-\n-class HttpResponseRedirectBase(HttpResponse):\n-    allowed_schemes = ['http', 'https', 'ftp']\n-\n-    def __init__(self, redirect_to, *args, **kwargs):\n-        parsed = urlparse(redirect_to)\n-        if parsed.scheme and parsed.scheme not in self.allowed_schemes:\n-            raise SuspiciousOperation(\"Unsafe redirect to URL with protocol '%s'\" % parsed.scheme)\n-        super(HttpResponseRedirectBase, self).__init__(*args, **kwargs)\n-        self['Location'] = iri_to_uri(redirect_to)\n-\n-class HttpResponseRedirect(HttpResponseRedirectBase):\n-    status_code = 302\n-\n-class HttpResponsePermanentRedirect(HttpResponseRedirectBase):\n-    status_code = 301\n-\n-class HttpResponseNotModified(HttpResponse):\n-    status_code = 304\n-\n-    def __init__(self, *args, **kwargs):\n-        super(HttpResponseNotModified, self).__init__(*args, **kwargs)\n-        del self['content-type']\n-\n-    @HttpResponse.content.setter\n-    def content(self, value):\n-        if value:\n-            raise AttributeError(\"You cannot set content to a 304 (Not Modified) response\")\n-        self._container = []\n-\n-class HttpResponseBadRequest(HttpResponse):\n-    status_code = 400\n-\n-class HttpResponseNotFound(HttpResponse):\n-    status_code = 404\n-\n-class HttpResponseForbidden(HttpResponse):\n-    status_code = 403\n-\n-class HttpResponseNotAllowed(HttpResponse):\n-    status_code = 405\n-\n-    def __init__(self, permitted_methods, *args, **kwargs):\n-        super(HttpResponseNotAllowed, self).__init__(*args, **kwargs)\n-        self['Allow'] = ', '.join(permitted_methods)\n-\n-class HttpResponseGone(HttpResponse):\n-    status_code = 410\n-\n-class HttpResponseServerError(HttpResponse):\n-    status_code = 500\n-\n-# A backwards compatible alias for HttpRequest.get_host.\n-def get_host(request):\n-    return request.get_host()\n-\n-# It's neither necessary nor appropriate to use\n-# django.utils.encoding.smart_text for parsing URLs and form inputs. Thus,\n-# this slightly more restricted function, used by QueryDict.\n-def bytes_to_text(s, encoding):\n-    \"\"\"\n-    Converts basestring objects to unicode, using the given encoding. Illegally\n-    encoded input characters are replaced with Unicode \"unknown\" codepoint\n-    (\\ufffd).\n-\n-    Returns any non-basestring objects without change.\n-    \"\"\"\n-    if isinstance(s, bytes):\n-        return six.text_type(s, encoding, 'replace')\n-    else:\n-        return s\n-\n+from django.http.cookie import SimpleCookie, parse_cookie\n+from django.http.request import (HttpRequest, QueryDict, UnreadablePostError,\n+    build_request_repr)\n+from django.http.response import (HttpResponse, StreamingHttpResponse,\n+    CompatibleStreamingHttpResponse, HttpResponsePermanentRedirect,\n+    HttpResponseRedirect, HttpResponseNotModified, HttpResponseBadRequest,\n+    HttpResponseForbidden, HttpResponseNotFound, HttpResponseNotAllowed,\n+    HttpResponseGone, HttpResponseServerError, Http404, BadHeaderError)\n+from django.http.utils import (fix_location_header, conditional_content_removal,\n+    fix_IE_for_attach, fix_IE_for_vary)"
        },
        {
            "sha": "78adb09ce81a025f50a27fd30f0a2d5855e56046",
            "filename": "django/http/cookie.py",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/django/django/blob/b4066d7d2149782cd694b98d1a6ed5c7ee885f55/django%2Fhttp%2Fcookie.py",
            "raw_url": "https://github.com/django/django/raw/b4066d7d2149782cd694b98d1a6ed5c7ee885f55/django%2Fhttp%2Fcookie.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2Fcookie.py?ref=b4066d7d2149782cd694b98d1a6ed5c7ee885f55",
            "patch": "@@ -0,0 +1,83 @@\n+from __future__ import absolute_import, unicode_literals\n+\n+from django.utils.encoding import force_str\n+from django.utils.six.moves import http_cookies\n+\n+\n+# Some versions of Python 2.7 and later won't need this encoding bug fix:\n+_cookie_encodes_correctly = http_cookies.SimpleCookie().value_encode(';') == (';', '\"\\\\073\"')\n+# See ticket #13007, http://bugs.python.org/issue2193 and http://trac.edgewall.org/ticket/2256\n+_tc = http_cookies.SimpleCookie()\n+try:\n+    _tc.load(str('foo:bar=1'))\n+    _cookie_allows_colon_in_names = True\n+except http_cookies.CookieError:\n+    _cookie_allows_colon_in_names = False\n+\n+if _cookie_encodes_correctly and _cookie_allows_colon_in_names:\n+    SimpleCookie = http_cookies.SimpleCookie\n+else:\n+    Morsel = http_cookies.Morsel\n+\n+    class SimpleCookie(http_cookies.SimpleCookie):\n+        if not _cookie_encodes_correctly:\n+            def value_encode(self, val):\n+                # Some browsers do not support quoted-string from RFC 2109,\n+                # including some versions of Safari and Internet Explorer.\n+                # These browsers split on ';', and some versions of Safari\n+                # are known to split on ', '. Therefore, we encode ';' and ','\n+\n+                # SimpleCookie already does the hard work of encoding and decoding.\n+                # It uses octal sequences like '\\\\012' for newline etc.\n+                # and non-ASCII chars. We just make use of this mechanism, to\n+                # avoid introducing two encoding schemes which would be confusing\n+                # and especially awkward for javascript.\n+\n+                # NB, contrary to Python docs, value_encode returns a tuple containing\n+                # (real val, encoded_val)\n+                val, encoded = super(SimpleCookie, self).value_encode(val)\n+\n+                encoded = encoded.replace(\";\", \"\\\\073\").replace(\",\",\"\\\\054\")\n+                # If encoded now contains any quoted chars, we need double quotes\n+                # around the whole string.\n+                if \"\\\\\" in encoded and not encoded.startswith('\"'):\n+                    encoded = '\"' + encoded + '\"'\n+\n+                return val, encoded\n+\n+        if not _cookie_allows_colon_in_names:\n+            def load(self, rawdata):\n+                self.bad_cookies = set()\n+                super(SimpleCookie, self).load(force_str(rawdata))\n+                for key in self.bad_cookies:\n+                    del self[key]\n+\n+            # override private __set() method:\n+            # (needed for using our Morsel, and for laxness with CookieError\n+            def _BaseCookie__set(self, key, real_value, coded_value):\n+                key = force_str(key)\n+                try:\n+                    M = self.get(key, Morsel())\n+                    M.set(key, real_value, coded_value)\n+                    dict.__setitem__(self, key, M)\n+                except http_cookies.CookieError:\n+                    self.bad_cookies.add(key)\n+                    dict.__setitem__(self, key, http_cookies.Morsel())\n+\n+\n+def parse_cookie(cookie):\n+    if cookie == '':\n+        return {}\n+    if not isinstance(cookie, http_cookies.BaseCookie):\n+        try:\n+            c = SimpleCookie()\n+            c.load(cookie)\n+        except http_cookies.CookieError:\n+            # Invalid cookie\n+            return {}\n+    else:\n+        c = cookie\n+    cookiedict = {}\n+    for key in c.keys():\n+        cookiedict[key] = c.get(key).value\n+    return cookiedict"
        },
        {
            "sha": "96c7606c86d94b4ed3a1bf4299d1fd45770da20e",
            "filename": "django/http/request.py",
            "status": "added",
            "additions": 453,
            "deletions": 0,
            "changes": 453,
            "blob_url": "https://github.com/django/django/blob/b4066d7d2149782cd694b98d1a6ed5c7ee885f55/django%2Fhttp%2Frequest.py",
            "raw_url": "https://github.com/django/django/raw/b4066d7d2149782cd694b98d1a6ed5c7ee885f55/django%2Fhttp%2Frequest.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2Frequest.py?ref=b4066d7d2149782cd694b98d1a6ed5c7ee885f55",
            "patch": "@@ -0,0 +1,453 @@\n+from __future__ import absolute_import, unicode_literals\n+\n+import copy\n+import os\n+import re\n+import sys\n+import warnings\n+from io import BytesIO\n+from pprint import pformat\n+try:\n+    from urllib.parse import parse_qsl, urlencode, quote, urljoin\n+except ImportError:\n+    from urllib import urlencode, quote\n+    from urlparse import parse_qsl, urljoin\n+\n+from django.conf import settings\n+from django.core import signing\n+from django.core.exceptions import SuspiciousOperation, ImproperlyConfigured\n+from django.core.files import uploadhandler\n+from django.http.multipartparser import MultiPartParser\n+from django.utils import six\n+from django.utils.datastructures import MultiValueDict, ImmutableList\n+from django.utils.encoding import force_bytes, force_text, force_str, iri_to_uri\n+\n+\n+RAISE_ERROR = object()\n+absolute_http_url_re = re.compile(r\"^https?://\", re.I)\n+\n+\n+class UnreadablePostError(IOError):\n+    pass\n+\n+\n+class HttpRequest(object):\n+    \"\"\"A basic HTTP request.\"\"\"\n+\n+    # The encoding used in GET/POST dicts. None means use default setting.\n+    _encoding = None\n+    _upload_handlers = []\n+\n+    def __init__(self):\n+        self.GET, self.POST, self.COOKIES, self.META, self.FILES = {}, {}, {}, {}, {}\n+        self.path = ''\n+        self.path_info = ''\n+        self.method = None\n+        self._post_parse_error = False\n+\n+    def __repr__(self):\n+        return build_request_repr(self)\n+\n+    def get_host(self):\n+        \"\"\"Returns the HTTP host using the environment or request headers.\"\"\"\n+        # We try three options, in order of decreasing preference.\n+        if settings.USE_X_FORWARDED_HOST and (\n+            'HTTP_X_FORWARDED_HOST' in self.META):\n+            host = self.META['HTTP_X_FORWARDED_HOST']\n+        elif 'HTTP_HOST' in self.META:\n+            host = self.META['HTTP_HOST']\n+        else:\n+            # Reconstruct the host using the algorithm from PEP 333.\n+            host = self.META['SERVER_NAME']\n+            server_port = str(self.META['SERVER_PORT'])\n+            if server_port != ('443' if self.is_secure() else '80'):\n+                host = '%s:%s' % (host, server_port)\n+\n+        # Disallow potentially poisoned hostnames.\n+        if set(';/?@&=+$,').intersection(host):\n+            raise SuspiciousOperation('Invalid HTTP_HOST header: %s' % host)\n+\n+        return host\n+\n+    def get_full_path(self):\n+        # RFC 3986 requires query string arguments to be in the ASCII range.\n+        # Rather than crash if this doesn't happen, we encode defensively.\n+        return '%s%s' % (self.path, ('?' + iri_to_uri(self.META.get('QUERY_STRING', ''))) if self.META.get('QUERY_STRING', '') else '')\n+\n+    def get_signed_cookie(self, key, default=RAISE_ERROR, salt='', max_age=None):\n+        \"\"\"\n+        Attempts to return a signed cookie. If the signature fails or the\n+        cookie has expired, raises an exception... unless you provide the\n+        default argument in which case that value will be returned instead.\n+        \"\"\"\n+        try:\n+            cookie_value = self.COOKIES[key]\n+        except KeyError:\n+            if default is not RAISE_ERROR:\n+                return default\n+            else:\n+                raise\n+        try:\n+            value = signing.get_cookie_signer(salt=key + salt).unsign(\n+                cookie_value, max_age=max_age)\n+        except signing.BadSignature:\n+            if default is not RAISE_ERROR:\n+                return default\n+            else:\n+                raise\n+        return value\n+\n+    def build_absolute_uri(self, location=None):\n+        \"\"\"\n+        Builds an absolute URI from the location and the variables available in\n+        this request. If no location is specified, the absolute URI is built on\n+        ``request.get_full_path()``.\n+        \"\"\"\n+        if not location:\n+            location = self.get_full_path()\n+        if not absolute_http_url_re.match(location):\n+            current_uri = '%s://%s%s' % ('https' if self.is_secure() else 'http',\n+                                         self.get_host(), self.path)\n+            location = urljoin(current_uri, location)\n+        return iri_to_uri(location)\n+\n+    def _is_secure(self):\n+        return os.environ.get(\"HTTPS\") == \"on\"\n+\n+    def is_secure(self):\n+        # First, check the SECURE_PROXY_SSL_HEADER setting.\n+        if settings.SECURE_PROXY_SSL_HEADER:\n+            try:\n+                header, value = settings.SECURE_PROXY_SSL_HEADER\n+            except ValueError:\n+                raise ImproperlyConfigured('The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.')\n+            if self.META.get(header, None) == value:\n+                return True\n+\n+        # Failing that, fall back to _is_secure(), which is a hook for\n+        # subclasses to implement.\n+        return self._is_secure()\n+\n+    def is_ajax(self):\n+        return self.META.get('HTTP_X_REQUESTED_WITH') == 'XMLHttpRequest'\n+\n+    @property\n+    def encoding(self):\n+        return self._encoding\n+\n+    @encoding.setter\n+    def encoding(self, val):\n+        \"\"\"\n+        Sets the encoding used for GET/POST accesses. If the GET or POST\n+        dictionary has already been created, it is removed and recreated on the\n+        next access (so that it is decoded correctly).\n+        \"\"\"\n+        self._encoding = val\n+        if hasattr(self, '_get'):\n+            del self._get\n+        if hasattr(self, '_post'):\n+            del self._post\n+\n+    def _initialize_handlers(self):\n+        self._upload_handlers = [uploadhandler.load_handler(handler, self)\n+                                 for handler in settings.FILE_UPLOAD_HANDLERS]\n+\n+    @property\n+    def upload_handlers(self):\n+        if not self._upload_handlers:\n+            # If there are no upload handlers defined, initialize them from settings.\n+            self._initialize_handlers()\n+        return self._upload_handlers\n+\n+    @upload_handlers.setter\n+    def upload_handlers(self, upload_handlers):\n+        if hasattr(self, '_files'):\n+            raise AttributeError(\"You cannot set the upload handlers after the upload has been processed.\")\n+        self._upload_handlers = upload_handlers\n+\n+    def parse_file_upload(self, META, post_data):\n+        \"\"\"Returns a tuple of (POST QueryDict, FILES MultiValueDict).\"\"\"\n+        self.upload_handlers = ImmutableList(\n+            self.upload_handlers,\n+            warning=\"You cannot alter upload handlers after the upload has been processed.\"\n+        )\n+        parser = MultiPartParser(META, post_data, self.upload_handlers, self.encoding)\n+        return parser.parse()\n+\n+    @property\n+    def body(self):\n+        if not hasattr(self, '_body'):\n+            if self._read_started:\n+                raise Exception(\"You cannot access body after reading from request's data stream\")\n+            try:\n+                self._body = self.read()\n+            except IOError as e:\n+                six.reraise(UnreadablePostError, UnreadablePostError(*e.args), sys.exc_info()[2])\n+            self._stream = BytesIO(self._body)\n+        return self._body\n+\n+    @property\n+    def raw_post_data(self):\n+        warnings.warn('HttpRequest.raw_post_data has been deprecated. Use HttpRequest.body instead.', DeprecationWarning)\n+        return self.body\n+\n+    def _mark_post_parse_error(self):\n+        self._post = QueryDict('')\n+        self._files = MultiValueDict()\n+        self._post_parse_error = True\n+\n+    def _load_post_and_files(self):\n+        \"\"\"Populate self._post and self._files if the content-type is a form type\"\"\"\n+        if self.method != 'POST':\n+            self._post, self._files = QueryDict('', encoding=self._encoding), MultiValueDict()\n+            return\n+        if self._read_started and not hasattr(self, '_body'):\n+            self._mark_post_parse_error()\n+            return\n+\n+        if self.META.get('CONTENT_TYPE', '').startswith('multipart/form-data'):\n+            if hasattr(self, '_body'):\n+                # Use already read data\n+                data = BytesIO(self._body)\n+            else:\n+                data = self\n+            try:\n+                self._post, self._files = self.parse_file_upload(self.META, data)\n+            except:\n+                # An error occured while parsing POST data. Since when\n+                # formatting the error the request handler might access\n+                # self.POST, set self._post and self._file to prevent\n+                # attempts to parse POST data again.\n+                # Mark that an error occured. This allows self.__repr__ to\n+                # be explicit about it instead of simply representing an\n+                # empty POST\n+                self._mark_post_parse_error()\n+                raise\n+        elif self.META.get('CONTENT_TYPE', '').startswith('application/x-www-form-urlencoded'):\n+            self._post, self._files = QueryDict(self.body, encoding=self._encoding), MultiValueDict()\n+        else:\n+            self._post, self._files = QueryDict('', encoding=self._encoding), MultiValueDict()\n+\n+    ## File-like and iterator interface.\n+    ##\n+    ## Expects self._stream to be set to an appropriate source of bytes by\n+    ## a corresponding request subclass (e.g. WSGIRequest).\n+    ## Also when request data has already been read by request.POST or\n+    ## request.body, self._stream points to a BytesIO instance\n+    ## containing that data.\n+\n+    def read(self, *args, **kwargs):\n+        self._read_started = True\n+        return self._stream.read(*args, **kwargs)\n+\n+    def readline(self, *args, **kwargs):\n+        self._read_started = True\n+        return self._stream.readline(*args, **kwargs)\n+\n+    def xreadlines(self):\n+        while True:\n+            buf = self.readline()\n+            if not buf:\n+                break\n+            yield buf\n+\n+    __iter__ = xreadlines\n+\n+    def readlines(self):\n+        return list(iter(self))\n+\n+\n+class QueryDict(MultiValueDict):\n+    \"\"\"\n+    A specialized MultiValueDict that takes a query string when initialized.\n+    This is immutable unless you create a copy of it.\n+\n+    Values retrieved from this class are converted from the given encoding\n+    (DEFAULT_CHARSET by default) to unicode.\n+    \"\"\"\n+    # These are both reset in __init__, but is specified here at the class\n+    # level so that unpickling will have valid values\n+    _mutable = True\n+    _encoding = None\n+\n+    def __init__(self, query_string, mutable=False, encoding=None):\n+        super(QueryDict, self).__init__()\n+        if not encoding:\n+            encoding = settings.DEFAULT_CHARSET\n+        self.encoding = encoding\n+        if six.PY3:\n+            for key, value in parse_qsl(query_string or '',\n+                                        keep_blank_values=True,\n+                                        encoding=encoding):\n+                self.appendlist(key, value)\n+        else:\n+            for key, value in parse_qsl(query_string or '',\n+                                        keep_blank_values=True):\n+                self.appendlist(force_text(key, encoding, errors='replace'),\n+                                force_text(value, encoding, errors='replace'))\n+        self._mutable = mutable\n+\n+    @property\n+    def encoding(self):\n+        if self._encoding is None:\n+            self._encoding = settings.DEFAULT_CHARSET\n+        return self._encoding\n+\n+    @encoding.setter\n+    def encoding(self, value):\n+        self._encoding = value\n+\n+    def _assert_mutable(self):\n+        if not self._mutable:\n+            raise AttributeError(\"This QueryDict instance is immutable\")\n+\n+    def __setitem__(self, key, value):\n+        self._assert_mutable()\n+        key = bytes_to_text(key, self.encoding)\n+        value = bytes_to_text(value, self.encoding)\n+        super(QueryDict, self).__setitem__(key, value)\n+\n+    def __delitem__(self, key):\n+        self._assert_mutable()\n+        super(QueryDict, self).__delitem__(key)\n+\n+    def __copy__(self):\n+        result = self.__class__('', mutable=True, encoding=self.encoding)\n+        for key, value in six.iterlists(self):\n+            result.setlist(key, value)\n+        return result\n+\n+    def __deepcopy__(self, memo):\n+        result = self.__class__('', mutable=True, encoding=self.encoding)\n+        memo[id(self)] = result\n+        for key, value in six.iterlists(self):\n+            result.setlist(copy.deepcopy(key, memo), copy.deepcopy(value, memo))\n+        return result\n+\n+    def setlist(self, key, list_):\n+        self._assert_mutable()\n+        key = bytes_to_text(key, self.encoding)\n+        list_ = [bytes_to_text(elt, self.encoding) for elt in list_]\n+        super(QueryDict, self).setlist(key, list_)\n+\n+    def setlistdefault(self, key, default_list=None):\n+        self._assert_mutable()\n+        return super(QueryDict, self).setlistdefault(key, default_list)\n+\n+    def appendlist(self, key, value):\n+        self._assert_mutable()\n+        key = bytes_to_text(key, self.encoding)\n+        value = bytes_to_text(value, self.encoding)\n+        super(QueryDict, self).appendlist(key, value)\n+\n+    def pop(self, key, *args):\n+        self._assert_mutable()\n+        return super(QueryDict, self).pop(key, *args)\n+\n+    def popitem(self):\n+        self._assert_mutable()\n+        return super(QueryDict, self).popitem()\n+\n+    def clear(self):\n+        self._assert_mutable()\n+        super(QueryDict, self).clear()\n+\n+    def setdefault(self, key, default=None):\n+        self._assert_mutable()\n+        key = bytes_to_text(key, self.encoding)\n+        default = bytes_to_text(default, self.encoding)\n+        return super(QueryDict, self).setdefault(key, default)\n+\n+    def copy(self):\n+        \"\"\"Returns a mutable copy of this object.\"\"\"\n+        return self.__deepcopy__({})\n+\n+    def urlencode(self, safe=None):\n+        \"\"\"\n+        Returns an encoded string of all query string arguments.\n+\n+        :arg safe: Used to specify characters which do not require quoting, for\n+            example::\n+\n+                >>> q = QueryDict('', mutable=True)\n+                >>> q['next'] = '/a&b/'\n+                >>> q.urlencode()\n+                'next=%2Fa%26b%2F'\n+                >>> q.urlencode(safe='/')\n+                'next=/a%26b/'\n+\n+        \"\"\"\n+        output = []\n+        if safe:\n+            safe = force_bytes(safe, self.encoding)\n+            encode = lambda k, v: '%s=%s' % ((quote(k, safe), quote(v, safe)))\n+        else:\n+            encode = lambda k, v: urlencode({k: v})\n+        for k, list_ in self.lists():\n+            k = force_bytes(k, self.encoding)\n+            output.extend([encode(k, force_bytes(v, self.encoding))\n+                           for v in list_])\n+        return '&'.join(output)\n+\n+\n+def build_request_repr(request, path_override=None, GET_override=None,\n+                       POST_override=None, COOKIES_override=None,\n+                       META_override=None):\n+    \"\"\"\n+    Builds and returns the request's representation string. The request's\n+    attributes may be overridden by pre-processed values.\n+    \"\"\"\n+    # Since this is called as part of error handling, we need to be very\n+    # robust against potentially malformed input.\n+    try:\n+        get = (pformat(GET_override)\n+               if GET_override is not None\n+               else pformat(request.GET))\n+    except Exception:\n+        get = '<could not parse>'\n+    if request._post_parse_error:\n+        post = '<could not parse>'\n+    else:\n+        try:\n+            post = (pformat(POST_override)\n+                    if POST_override is not None\n+                    else pformat(request.POST))\n+        except Exception:\n+            post = '<could not parse>'\n+    try:\n+        cookies = (pformat(COOKIES_override)\n+                   if COOKIES_override is not None\n+                   else pformat(request.COOKIES))\n+    except Exception:\n+        cookies = '<could not parse>'\n+    try:\n+        meta = (pformat(META_override)\n+                if META_override is not None\n+                else pformat(request.META))\n+    except Exception:\n+        meta = '<could not parse>'\n+    path = path_override if path_override is not None else request.path\n+    return force_str('<%s\\npath:%s,\\nGET:%s,\\nPOST:%s,\\nCOOKIES:%s,\\nMETA:%s>' %\n+                     (request.__class__.__name__,\n+                      path,\n+                      six.text_type(get),\n+                      six.text_type(post),\n+                      six.text_type(cookies),\n+                      six.text_type(meta)))\n+\n+\n+# It's neither necessary nor appropriate to use\n+# django.utils.encoding.smart_text for parsing URLs and form inputs. Thus,\n+# this slightly more restricted function, used by QueryDict.\n+def bytes_to_text(s, encoding):\n+    \"\"\"\n+    Converts basestring objects to unicode, using the given encoding. Illegally\n+    encoded input characters are replaced with Unicode \"unknown\" codepoint\n+    (\\ufffd).\n+\n+    Returns any non-basestring objects without change.\n+    \"\"\"\n+    if isinstance(s, bytes):\n+        return six.text_type(s, encoding, 'replace')\n+    else:\n+        return s"
        },
        {
            "sha": "4a5c479419334d939e0d6202965e79b5b35ce318",
            "filename": "django/http/response.py",
            "status": "added",
            "additions": 423,
            "deletions": 0,
            "changes": 423,
            "blob_url": "https://github.com/django/django/blob/b4066d7d2149782cd694b98d1a6ed5c7ee885f55/django%2Fhttp%2Fresponse.py",
            "raw_url": "https://github.com/django/django/raw/b4066d7d2149782cd694b98d1a6ed5c7ee885f55/django%2Fhttp%2Fresponse.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2Fresponse.py?ref=b4066d7d2149782cd694b98d1a6ed5c7ee885f55",
            "patch": "@@ -0,0 +1,423 @@\n+from __future__ import absolute_import, unicode_literals\n+\n+import datetime\n+import time\n+import warnings\n+from email.header import Header\n+try:\n+    from urllib.parse import urlparse\n+except ImportError:\n+    from urlparse import urlparse\n+\n+from django.conf import settings\n+from django.core import signing\n+from django.core.exceptions import SuspiciousOperation\n+from django.http.cookie import SimpleCookie\n+from django.utils import six, timezone\n+from django.utils.encoding import force_bytes, iri_to_uri\n+from django.utils.http import cookie_date\n+\n+\n+class BadHeaderError(ValueError):\n+    pass\n+\n+\n+class HttpResponseBase(object):\n+    \"\"\"\n+    An HTTP response base class with dictionary-accessed headers.\n+\n+    This class doesn't handle content. It should not be used directly.\n+    Use the HttpResponse and StreamingHttpResponse subclasses instead.\n+    \"\"\"\n+\n+    status_code = 200\n+\n+    def __init__(self, content_type=None, status=None, mimetype=None):\n+        # _headers is a mapping of the lower-case name to the original case of\n+        # the header (required for working with legacy systems) and the header\n+        # value. Both the name of the header and its value are ASCII strings.\n+        self._headers = {}\n+        self._charset = settings.DEFAULT_CHARSET\n+        self._closable_objects = []\n+        if mimetype:\n+            warnings.warn(\"Using mimetype keyword argument is deprecated, use\"\n+                          \" content_type instead\", PendingDeprecationWarning)\n+            content_type = mimetype\n+        if not content_type:\n+            content_type = \"%s; charset=%s\" % (settings.DEFAULT_CONTENT_TYPE,\n+                    self._charset)\n+        self.cookies = SimpleCookie()\n+        if status:\n+            self.status_code = status\n+\n+        self['Content-Type'] = content_type\n+\n+    def serialize_headers(self):\n+        \"\"\"HTTP headers as a bytestring.\"\"\"\n+        headers = [\n+            ('%s: %s' % (key, value)).encode('us-ascii')\n+            for key, value in self._headers.values()\n+        ]\n+        return b'\\r\\n'.join(headers)\n+\n+    if six.PY3:\n+        __bytes__ = serialize_headers\n+    else:\n+        __str__ = serialize_headers\n+\n+    def _convert_to_charset(self, value, charset, mime_encode=False):\n+        \"\"\"Converts headers key/value to ascii/latin1 native strings.\n+\n+        `charset` must be 'ascii' or 'latin-1'. If `mime_encode` is True and\n+        `value` value can't be represented in the given charset, MIME-encoding\n+        is applied.\n+        \"\"\"\n+        if not isinstance(value, (bytes, six.text_type)):\n+            value = str(value)\n+        try:\n+            if six.PY3:\n+                if isinstance(value, str):\n+                    # Ensure string is valid in given charset\n+                    value.encode(charset)\n+                else:\n+                    # Convert bytestring using given charset\n+                    value = value.decode(charset)\n+            else:\n+                if isinstance(value, str):\n+                    # Ensure string is valid in given charset\n+                    value.decode(charset)\n+                else:\n+                    # Convert unicode string to given charset\n+                    value = value.encode(charset)\n+        except UnicodeError as e:\n+            if mime_encode:\n+                # Wrapping in str() is a workaround for #12422 under Python 2.\n+                value = str(Header(value, 'utf-8').encode())\n+            else:\n+                e.reason += ', HTTP response headers must be in %s format' % charset\n+                raise\n+        if str('\\n') in value or str('\\r') in value:\n+            raise BadHeaderError(\"Header values can't contain newlines (got %r)\" % value)\n+        return value\n+\n+    def __setitem__(self, header, value):\n+        header = self._convert_to_charset(header, 'ascii')\n+        value = self._convert_to_charset(value, 'latin1', mime_encode=True)\n+        self._headers[header.lower()] = (header, value)\n+\n+    def __delitem__(self, header):\n+        try:\n+            del self._headers[header.lower()]\n+        except KeyError:\n+            pass\n+\n+    def __getitem__(self, header):\n+        return self._headers[header.lower()][1]\n+\n+    def __getstate__(self):\n+        # SimpleCookie is not pickeable with pickle.HIGHEST_PROTOCOL, so we\n+        # serialise to a string instead\n+        state = self.__dict__.copy()\n+        state['cookies'] = str(state['cookies'])\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        self.cookies = SimpleCookie(self.cookies)\n+\n+    def has_header(self, header):\n+        \"\"\"Case-insensitive check for a header.\"\"\"\n+        return header.lower() in self._headers\n+\n+    __contains__ = has_header\n+\n+    def items(self):\n+        return self._headers.values()\n+\n+    def get(self, header, alternate=None):\n+        return self._headers.get(header.lower(), (None, alternate))[1]\n+\n+    def set_cookie(self, key, value='', max_age=None, expires=None, path='/',\n+                   domain=None, secure=False, httponly=False):\n+        \"\"\"\n+        Sets a cookie.\n+\n+        ``expires`` can be:\n+        - a string in the correct format,\n+        - a naive ``datetime.datetime`` object in UTC,\n+        - an aware ``datetime.datetime`` object in any time zone.\n+        If it is a ``datetime.datetime`` object then ``max_age`` will be calculated.\n+\n+        \"\"\"\n+        self.cookies[key] = value\n+        if expires is not None:\n+            if isinstance(expires, datetime.datetime):\n+                if timezone.is_aware(expires):\n+                    expires = timezone.make_naive(expires, timezone.utc)\n+                delta = expires - expires.utcnow()\n+                # Add one second so the date matches exactly (a fraction of\n+                # time gets lost between converting to a timedelta and\n+                # then the date string).\n+                delta = delta + datetime.timedelta(seconds=1)\n+                # Just set max_age - the max_age logic will set expires.\n+                expires = None\n+                max_age = max(0, delta.days * 86400 + delta.seconds)\n+            else:\n+                self.cookies[key]['expires'] = expires\n+        if max_age is not None:\n+            self.cookies[key]['max-age'] = max_age\n+            # IE requires expires, so set it if hasn't been already.\n+            if not expires:\n+                self.cookies[key]['expires'] = cookie_date(time.time() +\n+                                                           max_age)\n+        if path is not None:\n+            self.cookies[key]['path'] = path\n+        if domain is not None:\n+            self.cookies[key]['domain'] = domain\n+        if secure:\n+            self.cookies[key]['secure'] = True\n+        if httponly:\n+            self.cookies[key]['httponly'] = True\n+\n+    def set_signed_cookie(self, key, value, salt='', **kwargs):\n+        value = signing.get_cookie_signer(salt=key + salt).sign(value)\n+        return self.set_cookie(key, value, **kwargs)\n+\n+    def delete_cookie(self, key, path='/', domain=None):\n+        self.set_cookie(key, max_age=0, path=path, domain=domain,\n+                        expires='Thu, 01-Jan-1970 00:00:00 GMT')\n+\n+    # Common methods used by subclasses\n+\n+    def make_bytes(self, value):\n+        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n+        # For backwards compatibility, this method supports values that are\n+        # unlikely to occur in real applications. It has grown complex and\n+        # should be refactored. It also overlaps __next__. See #18796.\n+        if self.has_header('Content-Encoding'):\n+            if isinstance(value, int):\n+                value = six.text_type(value)\n+            if isinstance(value, six.text_type):\n+                value = value.encode('ascii')\n+            # force conversion to bytes in case chunk is a subclass\n+            return bytes(value)\n+        else:\n+            return force_bytes(value, self._charset)\n+\n+    # These methods partially implement the file-like object interface.\n+    # See http://docs.python.org/lib/bltin-file-objects.html\n+\n+    # The WSGI server must call this method upon completion of the request.\n+    # See http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html\n+    def close(self):\n+        for closable in self._closable_objects:\n+            closable.close()\n+\n+    def write(self, content):\n+        raise Exception(\"This %s instance is not writable\" % self.__class__.__name__)\n+\n+    def flush(self):\n+        pass\n+\n+    def tell(self):\n+        raise Exception(\"This %s instance cannot tell its position\" % self.__class__.__name__)\n+\n+\n+class HttpResponse(HttpResponseBase):\n+    \"\"\"\n+    An HTTP response class with a string as content.\n+\n+    This content that can be read, appended to or replaced.\n+    \"\"\"\n+\n+    streaming = False\n+\n+    def __init__(self, content='', *args, **kwargs):\n+        super(HttpResponse, self).__init__(*args, **kwargs)\n+        # Content is a bytestring. See the `content` property methods.\n+        self.content = content\n+\n+    def serialize(self):\n+        \"\"\"Full HTTP message, including headers, as a bytestring.\"\"\"\n+        return self.serialize_headers() + b'\\r\\n\\r\\n' + self.content\n+\n+    if six.PY3:\n+        __bytes__ = serialize\n+    else:\n+        __str__ = serialize\n+\n+    @property\n+    def content(self):\n+        return b''.join(self.make_bytes(e) for e in self._container)\n+\n+    @content.setter\n+    def content(self, value):\n+        if hasattr(value, '__iter__') and not isinstance(value, (bytes, six.string_types)):\n+            self._container = value\n+            self._base_content_is_iter = True\n+            if hasattr(value, 'close'):\n+                self._closable_objects.append(value)\n+        else:\n+            self._container = [value]\n+            self._base_content_is_iter = False\n+\n+    def __iter__(self):\n+        self._iterator = iter(self._container)\n+        return self\n+\n+    def __next__(self):\n+        chunk = next(self._iterator)\n+        if isinstance(chunk, int):\n+            chunk = six.text_type(chunk)\n+        if isinstance(chunk, six.text_type):\n+            chunk = chunk.encode(self._charset)\n+        # force conversion to bytes in case chunk is a subclass\n+        return bytes(chunk)\n+\n+    next = __next__             # Python 2 compatibility\n+\n+    def write(self, content):\n+        if self._base_content_is_iter:\n+            raise Exception(\"This %s instance is not writable\" % self.__class__.__name__)\n+        self._container.append(content)\n+\n+    def tell(self):\n+        if self._base_content_is_iter:\n+            raise Exception(\"This %s instance cannot tell its position\" % self.__class__.__name__)\n+        return sum([len(chunk) for chunk in self])\n+\n+\n+class StreamingHttpResponse(HttpResponseBase):\n+    \"\"\"\n+    A streaming HTTP response class with an iterator as content.\n+\n+    This should only be iterated once, when the response is streamed to the\n+    client. However, it can be appended to or replaced with a new iterator\n+    that wraps the original content (or yields entirely new content).\n+    \"\"\"\n+\n+    streaming = True\n+\n+    def __init__(self, streaming_content=(), *args, **kwargs):\n+        super(StreamingHttpResponse, self).__init__(*args, **kwargs)\n+        # `streaming_content` should be an iterable of bytestrings.\n+        # See the `streaming_content` property methods.\n+        self.streaming_content = streaming_content\n+\n+    @property\n+    def content(self):\n+        raise AttributeError(\"This %s instance has no `content` attribute. \"\n+            \"Use `streaming_content` instead.\" % self.__class__.__name__)\n+\n+    @property\n+    def streaming_content(self):\n+        return self._iterator\n+\n+    @streaming_content.setter\n+    def streaming_content(self, value):\n+        # Ensure we can never iterate on \"value\" more than once.\n+        self._iterator = iter(value)\n+        if hasattr(value, 'close'):\n+            self._closable_objects.append(value)\n+\n+    def __iter__(self):\n+        return self\n+\n+    def __next__(self):\n+        return self.make_bytes(next(self._iterator))\n+\n+    next = __next__             # Python 2 compatibility\n+\n+\n+class CompatibleStreamingHttpResponse(StreamingHttpResponse):\n+    \"\"\"\n+    This class maintains compatibility with middleware that doesn't know how\n+    to handle the content of a streaming response by exposing a `content`\n+    attribute that will consume and cache the content iterator when accessed.\n+\n+    These responses will stream only if no middleware attempts to access the\n+    `content` attribute. Otherwise, they will behave like a regular response,\n+    and raise a `PendingDeprecationWarning`.\n+    \"\"\"\n+    @property\n+    def content(self):\n+        warnings.warn(\n+            'Accessing the `content` attribute on a streaming response is '\n+            'deprecated. Use the `streaming_content` attribute instead.',\n+            PendingDeprecationWarning)\n+        content = b''.join(self)\n+        self.streaming_content = [content]\n+        return content\n+\n+    @content.setter\n+    def content(self, content):\n+        warnings.warn(\n+            'Accessing the `content` attribute on a streaming response is '\n+            'deprecated. Use the `streaming_content` attribute instead.',\n+            PendingDeprecationWarning)\n+        self.streaming_content = [content]\n+\n+\n+class HttpResponseRedirectBase(HttpResponse):\n+    allowed_schemes = ['http', 'https', 'ftp']\n+\n+    def __init__(self, redirect_to, *args, **kwargs):\n+        parsed = urlparse(redirect_to)\n+        if parsed.scheme and parsed.scheme not in self.allowed_schemes:\n+            raise SuspiciousOperation(\"Unsafe redirect to URL with protocol '%s'\" % parsed.scheme)\n+        super(HttpResponseRedirectBase, self).__init__(*args, **kwargs)\n+        self['Location'] = iri_to_uri(redirect_to)\n+\n+\n+class HttpResponseRedirect(HttpResponseRedirectBase):\n+    status_code = 302\n+\n+\n+class HttpResponsePermanentRedirect(HttpResponseRedirectBase):\n+    status_code = 301\n+\n+\n+class HttpResponseNotModified(HttpResponse):\n+    status_code = 304\n+\n+    def __init__(self, *args, **kwargs):\n+        super(HttpResponseNotModified, self).__init__(*args, **kwargs)\n+        del self['content-type']\n+\n+    @HttpResponse.content.setter\n+    def content(self, value):\n+        if value:\n+            raise AttributeError(\"You cannot set content to a 304 (Not Modified) response\")\n+        self._container = []\n+\n+\n+class HttpResponseBadRequest(HttpResponse):\n+    status_code = 400\n+\n+\n+class HttpResponseNotFound(HttpResponse):\n+    status_code = 404\n+\n+\n+class HttpResponseForbidden(HttpResponse):\n+    status_code = 403\n+\n+\n+class HttpResponseNotAllowed(HttpResponse):\n+    status_code = 405\n+\n+    def __init__(self, permitted_methods, *args, **kwargs):\n+        super(HttpResponseNotAllowed, self).__init__(*args, **kwargs)\n+        self['Allow'] = ', '.join(permitted_methods)\n+\n+\n+class HttpResponseGone(HttpResponse):\n+    status_code = 410\n+\n+\n+class HttpResponseServerError(HttpResponse):\n+    status_code = 500\n+\n+\n+class Http404(Exception):\n+    pass"
        },
        {
            "sha": "fcb3fecb6ca5fec7d72d94408d24e05815ff9d56",
            "filename": "django/http/utils.py",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/b4066d7d2149782cd694b98d1a6ed5c7ee885f55/django%2Fhttp%2Futils.py",
            "raw_url": "https://github.com/django/django/raw/b4066d7d2149782cd694b98d1a6ed5c7ee885f55/django%2Fhttp%2Futils.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2Futils.py?ref=b4066d7d2149782cd694b98d1a6ed5c7ee885f55",
            "patch": "@@ -8,6 +8,7 @@\n # it's a little fiddly to override this behavior, so they should be truly\n # universally applicable.\n \n+\n def fix_location_header(request, response):\n     \"\"\"\n     Ensures that we always use an absolute URI in any location header in the\n@@ -20,6 +21,7 @@ def fix_location_header(request, response):\n         response['Location'] = request.build_absolute_uri(response['Location'])\n     return response\n \n+\n def conditional_content_removal(request, response):\n     \"\"\"\n     Removes the content of responses for HEAD requests, 1xx, 204 and 304\n@@ -38,6 +40,7 @@ def conditional_content_removal(request, response):\n             response.content = ''\n     return response\n \n+\n def fix_IE_for_attach(request, response):\n     \"\"\"\n     This function will prevent Django from serving a Content-Disposition header\n@@ -66,6 +69,7 @@ def fix_IE_for_attach(request, response):\n \n     return response\n \n+\n def fix_IE_for_vary(request, response):\n     \"\"\"\n     This function will fix the bug reported at\n@@ -90,4 +94,3 @@ def fix_IE_for_vary(request, response):\n             pass\n \n     return response\n-"
        }
    ],
    "stats": {
        "total": 1907,
        "additions": 973,
        "deletions": 934
    }
}