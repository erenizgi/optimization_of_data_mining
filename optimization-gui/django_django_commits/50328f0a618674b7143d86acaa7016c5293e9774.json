{
    "author": "akaariai",
    "message": "Fixed #19861 -- Transaction ._dirty flag improvement\n\nThere were a couple of errors in ._dirty flag handling:\n  * It started as None, but was never reset to None.\n  * The _dirty flag was sometimes used to indicate if the connection\n    was inside transaction management, but this was not done\n    consistently. This also meant the flag had three separate values.\n  * The None value had a special meaning, causing for example inability\n    to commit() on new connection unless enter/leave tx management was\n    done.\n  * The _dirty was tracking \"connection in transaction\" state, but only\n    in managed transactions.\n  * Some tests never reset the transaction state of the used connection.\n  * And some additional less important changes.\n\nThis commit has some potential for regressions, but as the above list\nshows, the current situation isn't perfect either.",
    "sha": "50328f0a618674b7143d86acaa7016c5293e9774",
    "files": [
        {
            "sha": "46db1910f9ea1755951f78ef3b1d9bdb0461aa20",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 18,
            "deletions": 25,
            "changes": 43,
            "blob_url": "https://github.com/django/django/blob/50328f0a618674b7143d86acaa7016c5293e9774/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/50328f0a618674b7143d86acaa7016c5293e9774/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=50328f0a618674b7143d86acaa7016c5293e9774",
            "patch": "@@ -41,7 +41,10 @@ def __init__(self, settings_dict, alias=DEFAULT_DB_ALIAS,\n         # Transaction related attributes\n         self.transaction_state = []\n         self.savepoint_state = 0\n-        self._dirty = None\n+        # Tracks if the connection is believed to be in transaction. This is\n+        # set somewhat aggressively, as the DBAPI doesn't make it easy to\n+        # deduce if the connection is in transaction or not.\n+        self._dirty = False\n         self._thread_ident = thread.get_ident()\n         self.allow_thread_sharing = allow_thread_sharing\n \n@@ -118,8 +121,7 @@ def abort(self):\n         stack.\n         \"\"\"\n         if self._dirty:\n-            self._rollback()\n-            self._dirty = False\n+            self.rollback()\n         while self.transaction_state:\n             self.leave_transaction_management()\n \n@@ -137,9 +139,6 @@ def enter_transaction_management(self, managed=True):\n             self.transaction_state.append(self.transaction_state[-1])\n         else:\n             self.transaction_state.append(settings.TRANSACTIONS_MANAGED)\n-\n-        if self._dirty is None:\n-            self._dirty = False\n         self._enter_transaction_management(managed)\n \n     def leave_transaction_management(self):\n@@ -153,14 +152,16 @@ def leave_transaction_management(self):\n         else:\n             raise TransactionManagementError(\n                 \"This code isn't under transaction management\")\n+        # The _leave_transaction_management hook can change the dirty flag,\n+        # so memoize it.\n+        dirty = self._dirty\n         # We will pass the next status (after leaving the previous state\n         # behind) to subclass hook.\n         self._leave_transaction_management(self.is_managed())\n-        if self._dirty:\n+        if dirty:\n             self.rollback()\n             raise TransactionManagementError(\n                 \"Transaction managed block ended with pending COMMIT/ROLLBACK\")\n-        self._dirty = False\n \n     def validate_thread_sharing(self):\n         \"\"\"\n@@ -190,22 +191,15 @@ def set_dirty(self):\n         to decide in a managed block of code to decide whether there are open\n         changes waiting for commit.\n         \"\"\"\n-        if self._dirty is not None:\n-            self._dirty = True\n-        else:\n-            raise TransactionManagementError(\"This code isn't under transaction \"\n-                \"management\")\n+        self._dirty = True\n \n     def set_clean(self):\n         \"\"\"\n         Resets a dirty flag for the current thread and code streak. This can be used\n         to decide in a managed block of code to decide whether a commit or rollback\n         should happen.\n         \"\"\"\n-        if self._dirty is not None:\n-            self._dirty = False\n-        else:\n-            raise TransactionManagementError(\"This code isn't under transaction management\")\n+        self._dirty = False\n         self.clean_savepoints()\n \n     def clean_savepoints(self):\n@@ -233,8 +227,7 @@ def managed(self, flag=True):\n         if top:\n             top[-1] = flag\n             if not flag and self.is_dirty():\n-                self._commit()\n-                self.set_clean()\n+                self.commit()\n         else:\n             raise TransactionManagementError(\"This code isn't under transaction \"\n                 \"management\")\n@@ -245,7 +238,7 @@ def commit_unless_managed(self):\n         \"\"\"\n         self.validate_thread_sharing()\n         if not self.is_managed():\n-            self._commit()\n+            self.commit()\n             self.clean_savepoints()\n         else:\n             self.set_dirty()\n@@ -256,7 +249,7 @@ def rollback_unless_managed(self):\n         \"\"\"\n         self.validate_thread_sharing()\n         if not self.is_managed():\n-            self._rollback()\n+            self.rollback()\n         else:\n             self.set_dirty()\n \n@@ -343,6 +336,7 @@ def close(self):\n         if self.connection is not None:\n             self.connection.close()\n             self.connection = None\n+        self.set_clean()\n \n     def cursor(self):\n         self.validate_thread_sharing()\n@@ -485,14 +479,13 @@ def supports_transactions(self):\n             self.connection.managed(True)\n             cursor = self.connection.cursor()\n             cursor.execute('CREATE TABLE ROLLBACK_TEST (X INT)')\n-            self.connection._commit()\n+            self.connection.commit()\n             cursor.execute('INSERT INTO ROLLBACK_TEST (X) VALUES (8)')\n-            self.connection._rollback()\n+            self.connection.rollback()\n             cursor.execute('SELECT COUNT(X) FROM ROLLBACK_TEST')\n             count, = cursor.fetchone()\n             cursor.execute('DROP TABLE ROLLBACK_TEST')\n-            self.connection._commit()\n-            self.connection._dirty = False\n+            self.connection.commit()\n         finally:\n             self.connection.leave_transaction_management()\n         return count == 0"
        },
        {
            "sha": "70c24bc820a3327d1960ec8456b36a67c8bae2ca",
            "filename": "django/db/backends/creation.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/50328f0a618674b7143d86acaa7016c5293e9774/django%2Fdb%2Fbackends%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/50328f0a618674b7143d86acaa7016c5293e9774/django%2Fdb%2Fbackends%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fcreation.py?ref=50328f0a618674b7143d86acaa7016c5293e9774",
            "patch": "@@ -385,8 +385,8 @@ def _create_test_db(self, verbosity, autoclobber):\n         # Create the test database and connect to it. We need to autocommit\n         # if the database supports it because PostgreSQL doesn't allow\n         # CREATE/DROP DATABASE statements within transactions.\n-        cursor = self.connection.cursor()\n         self._prepare_for_test_db_ddl()\n+        cursor = self.connection.cursor()\n         try:\n             cursor.execute(\n                 \"CREATE DATABASE %s %s\" % (qn(test_database_name), suffix))"
        },
        {
            "sha": "bf129c07585869f05c9a6b9c27483ea8cfe2cac8",
            "filename": "django/db/backends/postgresql_psycopg2/base.py",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/50328f0a618674b7143d86acaa7016c5293e9774/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/50328f0a618674b7143d86acaa7016c5293e9774/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py?ref=50328f0a618674b7143d86acaa7016c5293e9774",
            "patch": "@@ -149,6 +149,8 @@ def close(self):\n                 exc_info=sys.exc_info()\n             )\n             raise\n+        finally:\n+            self.set_clean()\n \n     @cached_property\n     def pg_version(self):\n@@ -233,10 +235,17 @@ def _set_isolation_level(self, level):\n         try:\n             if self.connection is not None:\n                 self.connection.set_isolation_level(level)\n+            if level == psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT:\n+                self.set_clean()\n         finally:\n             self.isolation_level = level\n             self.features.uses_savepoints = bool(level)\n \n+    def set_dirty(self):\n+        if ((self.transaction_state and self.transaction_state[-1]) or\n+                not self.features.uses_autocommit):\n+            super(DatabaseWrapper, self).set_dirty()\n+\n     def _commit(self):\n         if self.connection is not None:\n             try:"
        },
        {
            "sha": "d977939f410ccb78fb52cf1d65e88824a68fca36",
            "filename": "django/db/backends/postgresql_psycopg2/creation.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/50328f0a618674b7143d86acaa7016c5293e9774/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/50328f0a618674b7143d86acaa7016c5293e9774/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fcreation.py?ref=50328f0a618674b7143d86acaa7016c5293e9774",
            "patch": "@@ -82,6 +82,8 @@ def set_autocommit(self):\n \n     def _prepare_for_test_db_ddl(self):\n         \"\"\"Rollback and close the active transaction.\"\"\"\n+        # Make sure there is an open connection.\n+        self.connection.cursor()\n         self.connection.connection.rollback()\n         self.connection.connection.set_isolation_level(\n                 psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)"
        },
        {
            "sha": "ebab982a049636b9f7af74eb978ec76458d9c0a3",
            "filename": "django/db/backends/util.py",
            "status": "modified",
            "additions": 3,
            "deletions": 7,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/50328f0a618674b7143d86acaa7016c5293e9774/django%2Fdb%2Fbackends%2Futil.py",
            "raw_url": "https://github.com/django/django/raw/50328f0a618674b7143d86acaa7016c5293e9774/django%2Fdb%2Fbackends%2Futil.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Futil.py?ref=50328f0a618674b7143d86acaa7016c5293e9774",
            "patch": "@@ -19,13 +19,9 @@ def __init__(self, cursor, db):\n         self.cursor = cursor\n         self.db = db\n \n-    def set_dirty(self):\n-        if self.db.is_managed():\n-            self.db.set_dirty()\n-\n     def __getattr__(self, attr):\n         if attr in ('execute', 'executemany', 'callproc'):\n-            self.set_dirty()\n+            self.db.set_dirty()\n         return getattr(self.cursor, attr)\n \n     def __iter__(self):\n@@ -35,7 +31,7 @@ def __iter__(self):\n class CursorDebugWrapper(CursorWrapper):\n \n     def execute(self, sql, params=()):\n-        self.set_dirty()\n+        self.db.set_dirty()\n         start = time()\n         try:\n             return self.cursor.execute(sql, params)\n@@ -52,7 +48,7 @@ def execute(self, sql, params=()):\n             )\n \n     def executemany(self, sql, param_list):\n-        self.set_dirty()\n+        self.db.set_dirty()\n         start = time()\n         try:\n             return self.cursor.executemany(sql, param_list)"
        },
        {
            "sha": "b9d25d98a17ff159bd90a14e926fce16f322669a",
            "filename": "django/db/models/sql/compiler.py",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/50328f0a618674b7143d86acaa7016c5293e9774/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/50328f0a618674b7143d86acaa7016c5293e9774/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py?ref=50328f0a618674b7143d86acaa7016c5293e9774",
            "patch": "@@ -687,11 +687,6 @@ def results_iter(self):\n         resolve_columns = hasattr(self, 'resolve_columns')\n         fields = None\n         has_aggregate_select = bool(self.query.aggregate_select)\n-        # Set transaction dirty if we're using SELECT FOR UPDATE to ensure\n-        # a subsequent commit/rollback is executed, so any database locks\n-        # are released.\n-        if self.query.select_for_update and transaction.is_managed(self.using):\n-            transaction.set_dirty(self.using)\n         for rows in self.execute_sql(MULTI):\n             for row in rows:\n                 if resolve_columns:"
        },
        {
            "sha": "0fa8b8e361b4b2e5d767ebbf1f19dcb56faaf966",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/50328f0a618674b7143d86acaa7016c5293e9774/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/50328f0a618674b7143d86acaa7016c5293e9774/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=50328f0a618674b7143d86acaa7016c5293e9774",
            "patch": "@@ -1249,11 +1249,6 @@ make the call non-blocking. If a conflicting lock is already acquired by\n another transaction, :exc:`~django.db.DatabaseError` will be raised when the\n queryset is evaluated.\n \n-Note that using ``select_for_update()`` will cause the current transaction to be\n-considered dirty, if under transaction management. This is to ensure that\n-Django issues a ``COMMIT`` or ``ROLLBACK``, releasing any locks held by the\n-``SELECT FOR UPDATE``.\n-\n Currently, the ``postgresql_psycopg2``, ``oracle``, and ``mysql`` database\n backends support ``select_for_update()``. However, MySQL has no support for the\n ``nowait`` argument. Obviously, users of external third-party backends should"
        },
        {
            "sha": "9fcc19ba715404de62fc145ef6bdd270e8eaca40",
            "filename": "tests/delete_regress/tests.py",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/50328f0a618674b7143d86acaa7016c5293e9774/tests%2Fdelete_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/50328f0a618674b7143d86acaa7016c5293e9774/tests%2Fdelete_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fdelete_regress%2Ftests.py?ref=50328f0a618674b7143d86acaa7016c5293e9774",
            "patch": "@@ -23,11 +23,13 @@ def setUp(self):\n         # Put both DB connections into managed transaction mode\n         transaction.enter_transaction_management()\n         transaction.managed(True)\n-        self.conn2._enter_transaction_management(True)\n+        self.conn2.enter_transaction_management()\n+        self.conn2.managed(True)\n \n     def tearDown(self):\n         # Close down the second connection.\n         transaction.leave_transaction_management()\n+        self.conn2.abort()\n         self.conn2.close()\n \n     @skipUnlessDBFeature('test_db_allows_multiple_connections')"
        },
        {
            "sha": "4e5fd8ea6b6851a1f4429a6d3946b0dc30a89f58",
            "filename": "tests/middleware/tests.py",
            "status": "modified",
            "additions": 10,
            "deletions": 3,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/50328f0a618674b7143d86acaa7016c5293e9774/tests%2Fmiddleware%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/50328f0a618674b7143d86acaa7016c5293e9774/tests%2Fmiddleware%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmiddleware%2Ftests.py?ref=50328f0a618674b7143d86acaa7016c5293e9774",
            "patch": "@@ -683,6 +683,9 @@ def setUp(self):\n         self.response = HttpResponse()\n         self.response.status_code = 200\n \n+    def tearDown(self):\n+        transaction.abort()\n+\n     def test_request(self):\n         TransactionMiddleware().process_request(self.request)\n         self.assertTrue(transaction.is_managed())\n@@ -697,19 +700,23 @@ def test_managed_response(self):\n         self.assertEqual(Band.objects.count(), 1)\n \n     def test_unmanaged_response(self):\n+        transaction.enter_transaction_management()\n         transaction.managed(False)\n+        self.assertEqual(Band.objects.count(), 0)\n         TransactionMiddleware().process_response(self.request, self.response)\n         self.assertFalse(transaction.is_managed())\n-        self.assertFalse(transaction.is_dirty())\n+        # The transaction middleware doesn't commit/rollback if management\n+        # has been disabled.\n+        self.assertTrue(transaction.is_dirty())\n \n     def test_exception(self):\n         transaction.enter_transaction_management()\n         transaction.managed(True)\n         Band.objects.create(name='The Beatles')\n         self.assertTrue(transaction.is_dirty())\n         TransactionMiddleware().process_exception(self.request, None)\n-        self.assertEqual(Band.objects.count(), 0)\n         self.assertFalse(transaction.is_dirty())\n+        self.assertEqual(Band.objects.count(), 0)\n \n     def test_failing_commit(self):\n         # It is possible that connection.commit() fails. Check that\n@@ -724,8 +731,8 @@ def raise_exception():\n             self.assertTrue(transaction.is_dirty())\n             with self.assertRaises(IntegrityError):\n                 TransactionMiddleware().process_response(self.request, None)\n-            self.assertEqual(Band.objects.count(), 0)\n             self.assertFalse(transaction.is_dirty())\n+            self.assertEqual(Band.objects.count(), 0)\n             self.assertFalse(transaction.is_managed())\n         finally:\n             del connections[DEFAULT_DB_ALIAS].commit"
        },
        {
            "sha": "c5a04881c911e682c34d77c9b698e4b8cc967e7b",
            "filename": "tests/select_for_update/tests.py",
            "status": "modified",
            "additions": 7,
            "deletions": 16,
            "changes": 23,
            "blob_url": "https://github.com/django/django/blob/50328f0a618674b7143d86acaa7016c5293e9774/tests%2Fselect_for_update%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/50328f0a618674b7143d86acaa7016c5293e9774/tests%2Fselect_for_update%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fselect_for_update%2Ftests.py?ref=50328f0a618674b7143d86acaa7016c5293e9774",
            "patch": "@@ -24,7 +24,7 @@\n class SelectForUpdateTests(TransactionTestCase):\n \n     def setUp(self):\n-        transaction.enter_transaction_management(True)\n+        transaction.enter_transaction_management()\n         transaction.managed(True)\n         self.person = Person.objects.create(name='Reinhardt')\n \n@@ -48,9 +48,8 @@ def tearDown(self):\n         try:\n             # We don't really care if this fails - some of the tests will set\n             # this in the course of their run.\n-            transaction.managed(False)\n-            transaction.leave_transaction_management()\n-            self.new_connection.leave_transaction_management()\n+            transaction.abort()\n+            self.new_connection.abort()\n         except transaction.TransactionManagementError:\n             pass\n         self.new_connection.close()\n@@ -73,7 +72,7 @@ def start_blocking_transaction(self):\n \n     def end_blocking_transaction(self):\n         # Roll back the blocking transaction.\n-        self.new_connection._rollback()\n+        self.new_connection.rollback()\n \n     def has_for_update_sql(self, tested_connection, nowait=False):\n         # Examine the SQL that was executed to determine whether it\n@@ -119,6 +118,7 @@ def test_nowait_raises_error_on_block(self):\n         \"\"\"\n         self.start_blocking_transaction()\n         status = []\n+\n         thread = threading.Thread(\n             target=self.run_select_for_update,\n             args=(status,),\n@@ -164,7 +164,7 @@ def run_select_for_update(self, status, nowait=False):\n         try:\n             # We need to enter transaction management again, as this is done on\n             # per-thread basis\n-            transaction.enter_transaction_management(True)\n+            transaction.enter_transaction_management()\n             transaction.managed(True)\n             people = list(\n                 Person.objects.all().select_for_update(nowait=nowait)\n@@ -177,6 +177,7 @@ def run_select_for_update(self, status, nowait=False):\n         finally:\n             # This method is run in a separate thread. It uses its own\n             # database connection. Close it without waiting for the GC.\n+            transaction.abort()\n             connection.close()\n \n     @requires_threading\n@@ -271,13 +272,3 @@ def test_transaction_dirty_managed(self):\n         \"\"\"\n         people = list(Person.objects.select_for_update())\n         self.assertTrue(transaction.is_dirty())\n-\n-    @skipUnlessDBFeature('has_select_for_update')\n-    def test_transaction_not_dirty_unmanaged(self):\n-        \"\"\" If we're not under txn management, the txn will never be\n-        marked as dirty.\n-        \"\"\"\n-        transaction.managed(False)\n-        transaction.leave_transaction_management()\n-        people = list(Person.objects.select_for_update())\n-        self.assertFalse(transaction.is_dirty())"
        },
        {
            "sha": "a1edf53fcb7fbfd4a48e0d70975f4ad9b32e921f",
            "filename": "tests/transactions/tests.py",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/50328f0a618674b7143d86acaa7016c5293e9774/tests%2Ftransactions%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/50328f0a618674b7143d86acaa7016c5293e9774/tests%2Ftransactions%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions%2Ftests.py?ref=50328f0a618674b7143d86acaa7016c5293e9774",
            "patch": "@@ -165,7 +165,6 @@ class TransactionRollbackTests(TransactionTestCase):\n     def execute_bad_sql(self):\n         cursor = connection.cursor()\n         cursor.execute(\"INSERT INTO transactions_reporter (first_name, last_name) VALUES ('Douglas', 'Adams');\")\n-        transaction.set_dirty()\n \n     @skipUnlessDBFeature('requires_rollback_on_dirty_transaction')\n     def test_bad_sql(self):\n@@ -306,5 +305,4 @@ def test_bad_sql(self):\n             with transaction.commit_on_success():\n                 cursor = connection.cursor()\n                 cursor.execute(\"INSERT INTO transactions_reporter (first_name, last_name) VALUES ('Douglas', 'Adams');\")\n-                transaction.set_dirty()\n         transaction.rollback()"
        },
        {
            "sha": "8cc68b7e0d6794b6ea8fc791afc0f7c23f6a4ad4",
            "filename": "tests/transactions_regress/tests.py",
            "status": "modified",
            "additions": 108,
            "deletions": 4,
            "changes": 112,
            "blob_url": "https://github.com/django/django/blob/50328f0a618674b7143d86acaa7016c5293e9774/tests%2Ftransactions_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/50328f0a618674b7143d86acaa7016c5293e9774/tests%2Ftransactions_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions_regress%2Ftests.py?ref=50328f0a618674b7143d86acaa7016c5293e9774",
            "patch": "@@ -138,7 +138,8 @@ def test_failing_query_transaction_closed(self):\n         @transaction.commit_on_success\n         def create_system_user():\n             \"Create a user in a transaction\"\n-            user = User.objects.create_user(username='system', password='iamr00t', email='root@SITENAME.com')\n+            user = User.objects.create_user(username='system', password='iamr00t',\n+                                            email='root@SITENAME.com')\n             # Redundant, just makes sure the user id was read back from DB\n             Mod.objects.create(fld=user.pk)\n \n@@ -161,6 +162,83 @@ def test_failing_query_transaction_closed_debug(self):\n         \"\"\"\n         self.test_failing_query_transaction_closed()\n \n+@skipIf(connection.vendor == 'sqlite' and\n+        (connection.settings_dict['NAME'] == ':memory:' or\n+         not connection.settings_dict['NAME']),\n+        'Test uses multiple connections, but in-memory sqlite does not support this')\n+class TestNewConnection(TransactionTestCase):\n+    \"\"\"\n+    Check that new connections don't have special behaviour.\n+    \"\"\"\n+    def setUp(self):\n+        self._old_backend = connections[DEFAULT_DB_ALIAS]\n+        settings = self._old_backend.settings_dict.copy()\n+        opts = settings['OPTIONS'].copy()\n+        if 'autocommit' in opts:\n+            opts['autocommit'] = False\n+        settings['OPTIONS'] = opts\n+        new_backend = self._old_backend.__class__(settings, DEFAULT_DB_ALIAS)\n+        connections[DEFAULT_DB_ALIAS] = new_backend\n+\n+    def tearDown(self):\n+        try:\n+            connections[DEFAULT_DB_ALIAS].abort()\n+        except Exception:\n+            import ipdb; ipdb.set_trace()\n+        finally:\n+            connections[DEFAULT_DB_ALIAS].close()\n+            connections[DEFAULT_DB_ALIAS] = self._old_backend\n+\n+    def test_commit(self):\n+        \"\"\"\n+        Users are allowed to commit and rollback connections.\n+        \"\"\"\n+        # The starting value is False, not None.\n+        self.assertIs(connection._dirty, False)\n+        list(Mod.objects.all())\n+        self.assertTrue(connection.is_dirty())\n+        connection.commit()\n+        self.assertFalse(connection.is_dirty())\n+        list(Mod.objects.all())\n+        self.assertTrue(connection.is_dirty())\n+        connection.rollback()\n+        self.assertFalse(connection.is_dirty())\n+\n+    def test_enter_exit_management(self):\n+        orig_dirty = connection._dirty\n+        connection.enter_transaction_management()\n+        connection.leave_transaction_management()\n+        self.assertEqual(orig_dirty, connection._dirty)\n+\n+    def test_commit_unless_managed(self):\n+        cursor = connection.cursor()\n+        cursor.execute(\"INSERT into transactions_regress_mod (fld) values (2)\")\n+        connection.commit_unless_managed()\n+        self.assertFalse(connection.is_dirty())\n+        self.assertEqual(len(Mod.objects.all()), 1)\n+        self.assertTrue(connection.is_dirty())\n+        connection.commit_unless_managed()\n+        self.assertFalse(connection.is_dirty())\n+\n+    def test_commit_unless_managed_in_managed(self):\n+        cursor = connection.cursor()\n+        connection.enter_transaction_management()\n+        transaction.managed(True)\n+        cursor.execute(\"INSERT into transactions_regress_mod (fld) values (2)\")\n+        connection.commit_unless_managed()\n+        self.assertTrue(connection.is_dirty())\n+        connection.rollback()\n+        self.assertFalse(connection.is_dirty())\n+        self.assertEqual(len(Mod.objects.all()), 0)\n+        connection.commit()\n+        connection.leave_transaction_management()\n+        self.assertFalse(connection.is_dirty())\n+        self.assertEqual(len(Mod.objects.all()), 0)\n+        self.assertTrue(connection.is_dirty())\n+        connection.commit_unless_managed()\n+        self.assertFalse(connection.is_dirty())\n+        self.assertEqual(len(Mod.objects.all()), 0)\n+\n \n @skipUnless(connection.vendor == 'postgresql',\n             \"This test only valid for PostgreSQL\")\n@@ -171,9 +249,11 @@ class TestPostgresAutocommit(TransactionTestCase):\n     \"\"\"\n     def setUp(self):\n         from psycopg2.extensions import (ISOLATION_LEVEL_AUTOCOMMIT,\n-                                         ISOLATION_LEVEL_READ_COMMITTED)\n+                                         ISOLATION_LEVEL_READ_COMMITTED,\n+                                         TRANSACTION_STATUS_IDLE)\n         self._autocommit = ISOLATION_LEVEL_AUTOCOMMIT\n         self._read_committed = ISOLATION_LEVEL_READ_COMMITTED\n+        self._idle = TRANSACTION_STATUS_IDLE\n \n         # We want a clean backend with autocommit = True, so\n         # first we need to do a bit of work to have that.\n@@ -186,7 +266,11 @@ def setUp(self):\n         connections[DEFAULT_DB_ALIAS] = new_backend\n \n     def tearDown(self):\n-        connections[DEFAULT_DB_ALIAS] = self._old_backend\n+        try:\n+            connections[DEFAULT_DB_ALIAS].abort()\n+        finally:\n+            connections[DEFAULT_DB_ALIAS].close()\n+            connections[DEFAULT_DB_ALIAS] = self._old_backend\n \n     def test_initial_autocommit_state(self):\n         self.assertTrue(connection.features.uses_autocommit)\n@@ -214,6 +298,26 @@ def test_transaction_stacking(self):\n         transaction.leave_transaction_management()\n         self.assertEqual(connection.isolation_level, self._autocommit)\n \n+    def test_enter_autocommit(self):\n+        transaction.enter_transaction_management()\n+        transaction.managed(True)\n+        self.assertEqual(connection.isolation_level, self._read_committed)\n+        list(Mod.objects.all())\n+        self.assertTrue(transaction.is_dirty())\n+        # Enter autocommit mode again.\n+        transaction.enter_transaction_management(False)\n+        transaction.managed(False)\n+        self.assertFalse(transaction.is_dirty())\n+        self.assertEqual(\n+            connection.connection.get_transaction_status(),\n+            self._idle)\n+        list(Mod.objects.all())\n+        self.assertFalse(transaction.is_dirty())\n+        transaction.leave_transaction_management()\n+        self.assertEqual(connection.isolation_level, self._read_committed)\n+        transaction.leave_transaction_management()\n+        self.assertEqual(connection.isolation_level, self._autocommit)\n+\n \n class TestManyToManyAddTransaction(TransactionTestCase):\n     def test_manyrelated_add_commit(self):\n@@ -247,7 +351,7 @@ def work():\n \n         work()\n \n-    @skipIf(connection.vendor == 'mysql' and \\\n+    @skipIf(connection.vendor == 'mysql' and\n             connection.features._mysql_storage_engine == 'MyISAM',\n             \"MyISAM MySQL storage engine doesn't support savepoints\")\n     @skipUnlessDBFeature('uses_savepoints')"
        }
    ],
    "stats": {
        "total": 230,
        "additions": 161,
        "deletions": 69
    }
}