{
    "author": "spookylukey",
    "message": "Fixed #15791 - method to signal that callable objects should not be called in templates\n\nThanks to ejucovy for the suggestion and patch!\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16045 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "1286d783110e8b4d1df8068ed0d9093b49cdcaec",
    "files": [
        {
            "sha": "08ff5c6d52137259f0b356bab7622e008ccccd56",
            "filename": "django/template/base.py",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/1286d783110e8b4d1df8068ed0d9093b49cdcaec/django%2Ftemplate%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/1286d783110e8b4d1df8068ed0d9093b49cdcaec/django%2Ftemplate%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2Fbase.py?ref=1286d783110e8b4d1df8068ed0d9093b49cdcaec",
            "patch": "@@ -692,7 +692,9 @@ def _resolve_lookup(self, context):\n                                 ):\n                             raise VariableDoesNotExist(\"Failed lookup for key [%s] in %r\", (bit, current)) # missing attribute\n                 if callable(current):\n-                    if getattr(current, 'alters_data', False):\n+                    if getattr(current, 'do_not_call_in_templates', False):\n+                        pass\n+                    elif getattr(current, 'alters_data', False):\n                         current = settings.TEMPLATE_STRING_IF_INVALID\n                     else:\n                         try: # method call (assuming no args required)"
        },
        {
            "sha": "c997a3c279cf6d2d0ddc67b4e7f68b0535a01ed1",
            "filename": "docs/ref/templates/api.txt",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/1286d783110e8b4d1df8068ed0d9093b49cdcaec/docs%2Fref%2Ftemplates%2Fapi.txt",
            "raw_url": "https://github.com/django/django/raw/1286d783110e8b4d1df8068ed0d9093b49cdcaec/docs%2Fref%2Ftemplates%2Fapi.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Ftemplates%2Fapi.txt?ref=1286d783110e8b4d1df8068ed0d9093b49cdcaec",
            "patch": "@@ -207,15 +207,25 @@ straight lookups. Here are some things to keep in mind:\n \n       To prevent this, set an ``alters_data`` attribute on the callable\n       variable. The template system won't call a variable if it has\n-      ``alters_data=True`` set. The dynamically-generated\n-      :meth:`~django.db.models.Model.delete` and\n+      ``alters_data=True`` set, and will instead replace the variable with\n+      :setting:`TEMPLATE_STRING_IF_INVALID`, unconditionally.  The\n+      dynamically-generated :meth:`~django.db.models.Model.delete` and\n       :meth:`~django.db.models.Model.save` methods on Django model objects get\n       ``alters_data=True`` automatically. Example::\n \n         def sensitive_function(self):\n             self.database_record.delete()\n         sensitive_function.alters_data = True\n \n+    * .. versionadded:: 1.4\n+         Occasionally you may want to turn off this feature for other reasons,\n+         and tell the template system to leave a variable un-called no matter\n+         what.  To do so, set a ``do_not_call_in_templates`` attribute on the\n+         callable with the value ``True``.  The template system then will act as\n+         if your variable is not callable (allowing you to access attributes of\n+         the callable, for example).\n+\n+\n .. _invalid-template-variables:\n \n How invalid variables are handled"
        },
        {
            "sha": "8afa703f63b442a6e51deda01e0ba020dd0bd013",
            "filename": "tests/regressiontests/templates/callables.py",
            "status": "added",
            "additions": 111,
            "deletions": 0,
            "changes": 111,
            "blob_url": "https://github.com/django/django/blob/1286d783110e8b4d1df8068ed0d9093b49cdcaec/tests%2Fregressiontests%2Ftemplates%2Fcallables.py",
            "raw_url": "https://github.com/django/django/raw/1286d783110e8b4d1df8068ed0d9093b49cdcaec/tests%2Fregressiontests%2Ftemplates%2Fcallables.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftemplates%2Fcallables.py?ref=1286d783110e8b4d1df8068ed0d9093b49cdcaec",
            "patch": "@@ -0,0 +1,111 @@\n+from django import template\n+from django.utils.unittest import TestCase\n+\n+class CallableVariablesTests(TestCase):\n+\n+    def test_callable(self):\n+\n+        class Doodad(object):\n+            def __init__(self, value):\n+                self.num_calls = 0\n+                self.value = value\n+            def __call__(self):\n+                self.num_calls += 1\n+                return {\"the_value\": self.value}\n+\n+        my_doodad = Doodad(42)\n+        c = template.Context({\"my_doodad\": my_doodad})\n+\n+        # We can't access ``my_doodad.value`` in the template, because\n+        # ``my_doodad.__call__`` will be invoked first, yielding a dictionary\n+        # without a key ``value``.\n+        t = template.Template('{{ my_doodad.value }}')\n+        self.assertEqual(t.render(c), u'')\n+\n+        # We can confirm that the doodad has been called\n+        self.assertEqual(my_doodad.num_calls, 1)\n+\n+        # But we can access keys on the dict that's returned\n+        # by ``__call__``, instead.\n+        t = template.Template('{{ my_doodad.the_value }}')\n+        self.assertEqual(t.render(c), u'42')\n+        self.assertEqual(my_doodad.num_calls, 2)\n+\n+    def test_alters_data(self):\n+\n+        class Doodad(object):\n+            alters_data = True\n+            def __init__(self, value):\n+                self.num_calls = 0\n+                self.value = value\n+            def __call__(self):\n+                self.num_calls += 1\n+                return {\"the_value\": self.value}\n+\n+        my_doodad = Doodad(42)\n+        c = template.Context({\"my_doodad\": my_doodad})\n+\n+        # Since ``my_doodad.alters_data`` is True, the template system will not\n+        # try to call our doodad but will use TEMPLATE_STRING_IF_INVALID\n+        t = template.Template('{{ my_doodad.value }}')\n+        self.assertEqual(t.render(c), u'')\n+        t = template.Template('{{ my_doodad.the_value }}')\n+        self.assertEqual(t.render(c), u'')\n+\n+        # Double-check that the object was really never called during the\n+        # template rendering.\n+        self.assertEqual(my_doodad.num_calls, 0)\n+\n+    def test_do_not_call(self):\n+\n+        class Doodad(object):\n+            do_not_call_in_templates = True\n+            def __init__(self, value):\n+                self.num_calls = 0\n+                self.value = value\n+            def __call__(self):\n+                self.num_calls += 1\n+                return {\"the_value\": self.value}\n+\n+        my_doodad = Doodad(42)\n+        c = template.Context({\"my_doodad\": my_doodad})\n+\n+        # Since ``my_doodad.do_not_call_in_templates`` is True, the template\n+        # system will not try to call our doodad.  We can access its attributes\n+        # as normal, and we don't have access to the dict that it returns when\n+        # called.\n+        t = template.Template('{{ my_doodad.value }}')\n+        self.assertEqual(t.render(c), u'42')\n+        t = template.Template('{{ my_doodad.the_value }}')\n+        self.assertEqual(t.render(c), u'')\n+\n+        # Double-check that the object was really never called during the\n+        # template rendering.\n+        self.assertEqual(my_doodad.num_calls, 0)\n+\n+    def test_do_not_call_and_alters_data(self):\n+        # If we combine ``alters_data`` and ``do_not_call_in_templates``, the\n+        # ``alters_data`` attribute will not make any difference in the\n+        # template system's behavior.\n+\n+        class Doodad(object):\n+            do_not_call_in_templates = True\n+            alters_data = True\n+            def __init__(self, value):\n+                self.num_calls = 0\n+                self.value = value\n+            def __call__(self):\n+                self.num_calls += 1\n+                return {\"the_value\": self.value}\n+\n+        my_doodad = Doodad(42)\n+        c = template.Context({\"my_doodad\": my_doodad})\n+\n+        t = template.Template('{{ my_doodad.value }}')\n+        self.assertEqual(t.render(c), u'42')\n+        t = template.Template('{{ my_doodad.the_value }}')\n+        self.assertEqual(t.render(c), u'')\n+\n+        # Double-check that the object was really never called during the\n+        # template rendering.\n+        self.assertEqual(my_doodad.num_calls, 0)"
        },
        {
            "sha": "75f3b4f412d93d2497ae759e8b6724ac0e15ba6f",
            "filename": "tests/regressiontests/templates/tests.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/1286d783110e8b4d1df8068ed0d9093b49cdcaec/tests%2Fregressiontests%2Ftemplates%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/1286d783110e8b4d1df8068ed0d9093b49cdcaec/tests%2Fregressiontests%2Ftemplates%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftemplates%2Ftests.py?ref=1286d783110e8b4d1df8068ed0d9093b49cdcaec",
            "patch": "@@ -25,6 +25,7 @@\n from django.utils.safestring import mark_safe\n from django.utils.tzinfo import LocalTimezone\n \n+from callables import *\n from context import ContextTests\n from custom import CustomTagTests, CustomFilterTests\n from parser import ParserTests"
        }
    ],
    "stats": {
        "total": 130,
        "additions": 127,
        "deletions": 3
    }
}