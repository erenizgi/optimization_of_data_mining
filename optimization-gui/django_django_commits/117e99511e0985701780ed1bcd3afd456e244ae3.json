{
    "author": "claudep",
    "message": "Added assertXML[Not]Equal assertions\n\nThis is especially needed to compare XML when hash randomization\nis on, as attribute order may vary. Refs #17758, #19038.\nThanks Taylor Mitchell for the initial patch, and Ian Clelland for\nreview and cleanup.",
    "sha": "117e99511e0985701780ed1bcd3afd456e244ae3",
    "files": [
        {
            "sha": "260b060c45a4c7fcc50e20704d73312ca116c2a3",
            "filename": "django/test/testcases.py",
            "status": "modified",
            "additions": 35,
            "deletions": 89,
            "changes": 124,
            "blob_url": "https://github.com/django/django/blob/117e99511e0985701780ed1bcd3afd456e244ae3/django%2Ftest%2Ftestcases.py",
            "raw_url": "https://github.com/django/django/raw/117e99511e0985701780ed1bcd3afd456e244ae3/django%2Ftest%2Ftestcases.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Ftestcases.py?ref=117e99511e0985701780ed1bcd3afd456e244ae3",
            "patch": "@@ -11,7 +11,6 @@\n     from urllib.parse import urlsplit, urlunsplit\n except ImportError:     # Python 2\n     from urlparse import urlsplit, urlunsplit\n-from xml.dom.minidom import parseString, Node\n import select\n import socket\n import threading\n@@ -38,7 +37,7 @@\n from django.test.html import HTMLParseError, parse_html\n from django.test.signals import template_rendered\n from django.test.utils import (get_warnings_state, restore_warnings_state,\n-    override_settings)\n+    override_settings, compare_xml, strip_quotes)\n from django.test.utils import ContextList\n from django.utils import unittest as ut2\n from django.utils.encoding import force_text\n@@ -134,108 +133,23 @@ def check_output_numeric(self, want, got, optionflags):\n             optionflags)\n \n     def check_output_xml(self, want, got, optionsflags):\n-        \"\"\"Tries to do a 'xml-comparision' of want and got.  Plain string\n-        comparision doesn't always work because, for example, attribute\n-        ordering should not be important.\n-\n-        Based on http://codespeak.net/svn/lxml/trunk/src/lxml/doctestcompare.py\n-        \"\"\"\n-        _norm_whitespace_re = re.compile(r'[ \\t\\n][ \\t\\n]+')\n-        def norm_whitespace(v):\n-            return _norm_whitespace_re.sub(' ', v)\n-\n-        def child_text(element):\n-            return ''.join([c.data for c in element.childNodes\n-                            if c.nodeType == Node.TEXT_NODE])\n-\n-        def children(element):\n-            return [c for c in element.childNodes\n-                    if c.nodeType == Node.ELEMENT_NODE]\n-\n-        def norm_child_text(element):\n-            return norm_whitespace(child_text(element))\n-\n-        def attrs_dict(element):\n-            return dict(element.attributes.items())\n-\n-        def check_element(want_element, got_element):\n-            if want_element.tagName != got_element.tagName:\n-                return False\n-            if norm_child_text(want_element) != norm_child_text(got_element):\n-                return False\n-            if attrs_dict(want_element) != attrs_dict(got_element):\n-                return False\n-            want_children = children(want_element)\n-            got_children = children(got_element)\n-            if len(want_children) != len(got_children):\n-                return False\n-            for want, got in zip(want_children, got_children):\n-                if not check_element(want, got):\n-                    return False\n-            return True\n-\n-        want, got = self._strip_quotes(want, got)\n-        want = want.replace('\\\\n','\\n')\n-        got = got.replace('\\\\n','\\n')\n-\n-        # If the string is not a complete xml document, we may need to add a\n-        # root element. This allow us to compare fragments, like \"<foo/><bar/>\"\n-        if not want.startswith('<?xml'):\n-            wrapper = '<root>%s</root>'\n-            want = wrapper % want\n-            got = wrapper % got\n-\n-        # Parse the want and got strings, and compare the parsings.\n         try:\n-            want_root = parseString(want).firstChild\n-            got_root = parseString(got).firstChild\n+            return compare_xml(want, got)\n         except Exception:\n             return False\n-        return check_element(want_root, got_root)\n \n     def check_output_json(self, want, got, optionsflags):\n         \"\"\"\n         Tries to compare want and got as if they were JSON-encoded data\n         \"\"\"\n-        want, got = self._strip_quotes(want, got)\n+        want, got = strip_quotes(want, got)\n         try:\n             want_json = json.loads(want)\n             got_json = json.loads(got)\n         except Exception:\n             return False\n         return want_json == got_json\n \n-    def _strip_quotes(self, want, got):\n-        \"\"\"\n-        Strip quotes of doctests output values:\n-\n-        >>> o = OutputChecker()\n-        >>> o._strip_quotes(\"'foo'\")\n-        \"foo\"\n-        >>> o._strip_quotes('\"foo\"')\n-        \"foo\"\n-        \"\"\"\n-        def is_quoted_string(s):\n-            s = s.strip()\n-            return (len(s) >= 2\n-                    and s[0] == s[-1]\n-                    and s[0] in ('\"', \"'\"))\n-\n-        def is_quoted_unicode(s):\n-            s = s.strip()\n-            return (len(s) >= 3\n-                    and s[0] == 'u'\n-                    and s[1] == s[-1]\n-                    and s[1] in ('\"', \"'\"))\n-\n-        if is_quoted_string(want) and is_quoted_string(got):\n-            want = want.strip()[1:-1]\n-            got = got.strip()[1:-1]\n-        elif is_quoted_unicode(want) and is_quoted_unicode(got):\n-            want = want.strip()[2:-1]\n-            got = got.strip()[2:-1]\n-        return want, got\n-\n \n class DocTestRunner(doctest.DocTestRunner):\n     def __init__(self, *args, **kwargs):\n@@ -445,6 +359,38 @@ def assertHTMLNotEqual(self, html1, html2, msg=None):\n                 safe_repr(dom1, True), safe_repr(dom2, True))\n             self.fail(self._formatMessage(msg, standardMsg))\n \n+    def assertXMLEqual(self, xml1, xml2, msg=None):\n+        \"\"\"\n+        Asserts that two XML snippets are semantically the same.\n+        Whitespace in most cases is ignored, and attribute ordering is not\n+        significant. The passed-in arguments must be valid XML.\n+        \"\"\"\n+        try:\n+            result = compare_xml(xml1, xml2)\n+        except Exception as e:\n+            standardMsg = 'First or second argument is not valid XML\\n%s' % e\n+            self.fail(self._formatMessage(msg, standardMsg))\n+        else:\n+            if not result:\n+                standardMsg = '%s != %s' % (safe_repr(xml1, True), safe_repr(xml2, True))\n+                self.fail(self._formatMessage(msg, standardMsg))\n+\n+    def assertXMLNotEqual(self, xml1, xml2, msg=None):\n+        \"\"\"\n+        Asserts that two XML snippets are not semantically equivalent.\n+        Whitespace in most cases is ignored, and attribute ordering is not\n+        significant. The passed-in arguments must be valid XML.\n+        \"\"\"\n+        try:\n+            result = compare_xml(xml1, xml2)\n+        except Exception as e:\n+            standardMsg = 'First or second argument is not valid XML\\n%s' % e\n+            self.fail(self._formatMessage(msg, standardMsg))\n+        else:\n+            if result:\n+                standardMsg = '%s == %s' % (safe_repr(xml1, True), safe_repr(xml2, True))\n+                self.fail(self._formatMessage(msg, standardMsg))\n+\n \n class TransactionTestCase(SimpleTestCase):\n "
        },
        {
            "sha": "71252eaac8c9f2eb77ec412407e0aef93cf57cec",
            "filename": "django/test/utils.py",
            "status": "modified",
            "additions": 92,
            "deletions": 0,
            "changes": 92,
            "blob_url": "https://github.com/django/django/blob/117e99511e0985701780ed1bcd3afd456e244ae3/django%2Ftest%2Futils.py",
            "raw_url": "https://github.com/django/django/raw/117e99511e0985701780ed1bcd3afd456e244ae3/django%2Ftest%2Futils.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Futils.py?ref=117e99511e0985701780ed1bcd3afd456e244ae3",
            "patch": "@@ -1,4 +1,7 @@\n+import re\n import warnings\n+from xml.dom.minidom import parseString, Node\n+\n from django.conf import settings, UserSettingsHolder\n from django.core import mail\n from django.test.signals import template_rendered, setting_changed\n@@ -223,5 +226,94 @@ def disable(self):\n                                  setting=key, value=new_value)\n \n \n+def compare_xml(want, got):\n+    \"\"\"Tries to do a 'xml-comparision' of want and got.  Plain string\n+    comparision doesn't always work because, for example, attribute\n+    ordering should not be important.\n+\n+    Based on http://codespeak.net/svn/lxml/trunk/src/lxml/doctestcompare.py\n+    \"\"\"\n+    _norm_whitespace_re = re.compile(r'[ \\t\\n][ \\t\\n]+')\n+    def norm_whitespace(v):\n+        return _norm_whitespace_re.sub(' ', v)\n+\n+    def child_text(element):\n+        return ''.join([c.data for c in element.childNodes\n+                        if c.nodeType == Node.TEXT_NODE])\n+\n+    def children(element):\n+        return [c for c in element.childNodes\n+                if c.nodeType == Node.ELEMENT_NODE]\n+\n+    def norm_child_text(element):\n+        return norm_whitespace(child_text(element))\n+\n+    def attrs_dict(element):\n+        return dict(element.attributes.items())\n+\n+    def check_element(want_element, got_element):\n+        if want_element.tagName != got_element.tagName:\n+            return False\n+        if norm_child_text(want_element) != norm_child_text(got_element):\n+            return False\n+        if attrs_dict(want_element) != attrs_dict(got_element):\n+            return False\n+        want_children = children(want_element)\n+        got_children = children(got_element)\n+        if len(want_children) != len(got_children):\n+            return False\n+        for want, got in zip(want_children, got_children):\n+            if not check_element(want, got):\n+                return False\n+        return True\n+\n+    want, got = strip_quotes(want, got)\n+    want = want.replace('\\\\n','\\n')\n+    got = got.replace('\\\\n','\\n')\n+\n+    # If the string is not a complete xml document, we may need to add a\n+    # root element. This allow us to compare fragments, like \"<foo/><bar/>\"\n+    if not want.startswith('<?xml'):\n+        wrapper = '<root>%s</root>'\n+        want = wrapper % want\n+        got = wrapper % got\n+\n+    # Parse the want and got strings, and compare the parsings.\n+    want_root = parseString(want).firstChild\n+    got_root = parseString(got).firstChild\n+\n+    return check_element(want_root, got_root)\n+\n+\n+def strip_quotes(want, got):\n+    \"\"\"\n+    Strip quotes of doctests output values:\n+\n+    >>> strip_quotes(\"'foo'\")\n+    \"foo\"\n+    >>> strip_quotes('\"foo\"')\n+    \"foo\"\n+    \"\"\"\n+    def is_quoted_string(s):\n+        s = s.strip()\n+        return (len(s) >= 2\n+                and s[0] == s[-1]\n+                and s[0] in ('\"', \"'\"))\n+\n+    def is_quoted_unicode(s):\n+        s = s.strip()\n+        return (len(s) >= 3\n+                and s[0] == 'u'\n+                and s[1] == s[-1]\n+                and s[1] in ('\"', \"'\"))\n+\n+    if is_quoted_string(want) and is_quoted_string(got):\n+        want = want.strip()[1:-1]\n+        got = got.strip()[1:-1]\n+    elif is_quoted_unicode(want) and is_quoted_unicode(got):\n+        want = want.strip()[2:-1]\n+        got = got.strip()[2:-1]\n+    return want, got\n+\n def str_prefix(s):\n     return s % {'_': '' if six.PY3 else 'u'}"
        },
        {
            "sha": "e99b2fd5789f36a8d3cc306b3028ec8c96fa25eb",
            "filename": "docs/releases/1.5.txt",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/117e99511e0985701780ed1bcd3afd456e244ae3/docs%2Freleases%2F1.5.txt",
            "raw_url": "https://github.com/django/django/raw/117e99511e0985701780ed1bcd3afd456e244ae3/docs%2Freleases%2F1.5.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.5.txt?ref=117e99511e0985701780ed1bcd3afd456e244ae3",
            "patch": "@@ -198,6 +198,11 @@ Django 1.5 also includes several smaller improvements worth noting:\n * The loaddata management command now supports an `ignorenonexistent` option to\n   ignore data for fields that no longer exist.\n \n+* :meth:`~django.test.SimpleTestCase.assertXMLEqual` and\n+  :meth:`~django.test.SimpleTestCase.assertXMLNotEqual` new assertions allow\n+  you to test equality for XML content at a semantic level, without caring for\n+  syntax differences (spaces, attribute order, etc.).\n+\n Backwards incompatible changes in 1.5\n =====================================\n "
        },
        {
            "sha": "895e721ef550e4bd843eaaa15af30d21597fb05d",
            "filename": "docs/topics/testing.txt",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/117e99511e0985701780ed1bcd3afd456e244ae3/docs%2Ftopics%2Ftesting.txt",
            "raw_url": "https://github.com/django/django/raw/117e99511e0985701780ed1bcd3afd456e244ae3/docs%2Ftopics%2Ftesting.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Ftesting.txt?ref=117e99511e0985701780ed1bcd3afd456e244ae3",
            "patch": "@@ -1783,6 +1783,25 @@ your test suite.\n     ``html1`` and ``html2`` must be valid HTML. An ``AssertionError`` will be\n     raised if one of them cannot be parsed.\n \n+.. method:: SimpleTestCase.assertXMLEqual(xml1, xml2, msg=None)\n+\n+    .. versionadded:: 1.5\n+\n+    Asserts that the strings ``xml1`` and ``xml2`` are equal. The\n+    comparison is based on XML semantics. Similarily to\n+    :meth:`~SimpleTestCase.assertHTMLEqual`, the comparison is\n+    made on parsed content, hence only semantic differences are considered, not\n+    syntax differences. When unvalid XML is passed in any parameter, an\n+    ``AssertionError`` is always raised, even if both string are identical.\n+\n+.. method:: SimpleTestCase.assertXMLNotEqual(xml1, xml2, msg=None)\n+\n+    .. versionadded:: 1.5\n+\n+    Asserts that the strings ``xml1`` and ``xml2`` are *not* equal. The\n+    comparison is based on XML semantics. See\n+    :meth:`~SimpleTestCase.assertXMLEqual` for details.\n+\n .. _topics-testing-email:\n \n Email services"
        },
        {
            "sha": "dec157eacbc0643118d711813e45e9a11230146d",
            "filename": "tests/regressiontests/test_utils/tests.py",
            "status": "modified",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/django/django/blob/117e99511e0985701780ed1bcd3afd456e244ae3/tests%2Fregressiontests%2Ftest_utils%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/117e99511e0985701780ed1bcd3afd456e244ae3/tests%2Fregressiontests%2Ftest_utils%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftest_utils%2Ftests.py?ref=117e99511e0985701780ed1bcd3afd456e244ae3",
            "patch": "@@ -450,6 +450,41 @@ def test_unicode_handling(self):\n         self.assertContains(response, '<p class=\"help\">Some help text for the title (with unicode ŠĐĆŽćžšđ)</p>', html=True)\n \n \n+class XMLEqualTests(TestCase):\n+    def test_simple_equal(self):\n+        xml1 = \"<elem attr1='a' attr2='b' />\"\n+        xml2 = \"<elem attr1='a' attr2='b' />\"\n+        self.assertXMLEqual(xml1, xml2)\n+\n+    def test_simple_equal_unordered(self):\n+        xml1 = \"<elem attr1='a' attr2='b' />\"\n+        xml2 = \"<elem attr2='b' attr1='a' />\"\n+        self.assertXMLEqual(xml1, xml2)\n+\n+    def test_simple_equal_raise(self):\n+        xml1 = \"<elem attr1='a' />\"\n+        xml2 = \"<elem attr2='b' attr1='a' />\"\n+        with self.assertRaises(AssertionError):\n+            self.assertXMLEqual(xml1, xml2)\n+\n+    def test_simple_not_equal(self):\n+        xml1 = \"<elem attr1='a' attr2='c' />\"\n+        xml2 = \"<elem attr1='a' attr2='b' />\"\n+        self.assertXMLNotEqual(xml1, xml2)\n+\n+    def test_simple_not_equal_raise(self):\n+        xml1 = \"<elem attr1='a' attr2='b' />\"\n+        xml2 = \"<elem attr2='b' attr1='a' />\"\n+        with self.assertRaises(AssertionError):\n+            self.assertXMLNotEqual(xml1, xml2)\n+\n+    def test_parsing_errors(self):\n+        xml_unvalid = \"<elem attr1='a attr2='b' />\"\n+        xml2 = \"<elem attr2='b' attr1='a' />\"\n+        with self.assertRaises(AssertionError):\n+            self.assertXMLNotEqual(xml_unvalid, xml2)\n+\n+\n class SkippingExtraTests(TestCase):\n     fixtures = ['should_not_be_loaded.json']\n "
        }
    ],
    "stats": {
        "total": 275,
        "additions": 186,
        "deletions": 89
    }
}