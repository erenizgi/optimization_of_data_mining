{
    "author": "nmfm",
    "message": "Fixed #18056 - Cleared aggregations on DateQuery.add_date_select\n\nCleared aggregations on add_date_select method so only distinct dates\nare returned when dealing with a QuerySet that contained aggregations.\nThat would cause the query set to return repeated dates because it\nwould look for distinct (date kind, aggregation) pairs.",
    "sha": "bebbbb7af096ecffc0d7585617fdfacb196bc7c2",
    "files": [
        {
            "sha": "7b92394e906abbb1711d8294bcc471f068a5b27c",
            "filename": "django/db/models/sql/subqueries.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/bebbbb7af096ecffc0d7585617fdfacb196bc7c2/django%2Fdb%2Fmodels%2Fsql%2Fsubqueries.py",
            "raw_url": "https://github.com/django/django/raw/bebbbb7af096ecffc0d7585617fdfacb196bc7c2/django%2Fdb%2Fmodels%2Fsql%2Fsubqueries.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fsubqueries.py?ref=bebbbb7af096ecffc0d7585617fdfacb196bc7c2",
            "patch": "@@ -8,6 +8,7 @@\n from django.db.models.sql.datastructures import Date\n from django.db.models.sql.query import Query\n from django.db.models.sql.where import AND, Constraint\n+from django.utils.datastructures import SortedDict\n from django.utils.functional import Promise\n from django.utils.encoding import force_unicode\n \n@@ -205,6 +206,7 @@ def add_date_select(self, field_name, lookup_type, order='ASC'):\n         self.select = [select]\n         self.select_fields = [None]\n         self.select_related = False # See #7097.\n+        self.aggregates = SortedDict() # See 18056.\n         self.set_extra_mask([])\n         self.distinct = True\n         self.order_by = order == 'ASC' and [1] or [-1]"
        },
        {
            "sha": "c23b32fc85ee80825c6f2ee84d8c0b4b1165ccb4",
            "filename": "tests/modeltests/aggregation/tests.py",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/django/django/blob/bebbbb7af096ecffc0d7585617fdfacb196bc7c2/tests%2Fmodeltests%2Faggregation%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/bebbbb7af096ecffc0d7585617fdfacb196bc7c2/tests%2Fmodeltests%2Faggregation%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Faggregation%2Ftests.py?ref=bebbbb7af096ecffc0d7585617fdfacb196bc7c2",
            "patch": "@@ -565,3 +565,23 @@ def test_annotate_values_list(self):\n                 (Decimal('82.8'), 1),\n             ]\n         )\n+\n+    def test_dates_with_aggregation(self):\n+        \"\"\"\n+        Test that .dates() returns a distinct set of dates when applied to a\n+        QuerySet with aggregation.\n+\n+        Refs #18056. Previously, .dates() would return distinct (date_kind,\n+        aggregation) sets, in this case (year, num_authors), so 2008 would be\n+        returned twice because there are books from 2008 with a different\n+        number of authors.\n+        \"\"\"\n+        dates = Book.objects.annotate(num_authors=Count(\"authors\")).dates('pubdate', 'year')\n+        self.assertQuerysetEqual(\n+            dates, [\n+                \"datetime.datetime(1991, 1, 1, 0, 0)\",\n+                \"datetime.datetime(1995, 1, 1, 0, 0)\",\n+                \"datetime.datetime(2007, 1, 1, 0, 0)\",\n+                \"datetime.datetime(2008, 1, 1, 0, 0)\"\n+            ]\n+        )"
        }
    ],
    "stats": {
        "total": 22,
        "additions": 22,
        "deletions": 0
    }
}