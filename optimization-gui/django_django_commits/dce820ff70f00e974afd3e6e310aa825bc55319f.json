{
    "author": "PaulMcMillan",
    "message": "Renovated password hashing. Many thanks to Justine Tunney for help with the initial patch.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17253 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "dce820ff70f00e974afd3e6e310aa825bc55319f",
    "files": [
        {
            "sha": "806892d3ca955cc6850007e1019ba5b872adaa19",
            "filename": "django/conf/global_settings.py",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Fconf%2Fglobal_settings.py",
            "raw_url": "https://github.com/django/django/raw/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Fconf%2Fglobal_settings.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fconf%2Fglobal_settings.py?ref=dce820ff70f00e974afd3e6e310aa825bc55319f",
            "patch": "@@ -498,6 +498,18 @@\n # The number of days a password reset link is valid for\n PASSWORD_RESET_TIMEOUT_DAYS = 3\n \n+# the first hasher in this list is the preferred algorithm.  any\n+# password using different algorithms will be converted automatically\n+# upon login\n+PASSWORD_HASHERS = (\n+    'django.contrib.auth.hashers.PBKDF2PasswordHasher',\n+    'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',\n+    'django.contrib.auth.hashers.BCryptPasswordHasher',\n+    'django.contrib.auth.hashers.SHA1PasswordHasher',\n+    'django.contrib.auth.hashers.MD5PasswordHasher',\n+    'django.contrib.auth.hashers.CryptPasswordHasher',\n+)\n+\n ###########\n # SIGNING #\n ###########"
        },
        {
            "sha": "50b2e2b757112815015e796348ef7a28bc682c18",
            "filename": "django/contrib/auth/forms.py",
            "status": "modified",
            "additions": 20,
            "deletions": 20,
            "changes": 40,
            "blob_url": "https://github.com/django/django/blob/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Fcontrib%2Fauth%2Fforms.py",
            "raw_url": "https://github.com/django/django/raw/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Fcontrib%2Fauth%2Fforms.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fauth%2Fforms.py?ref=dce820ff70f00e974afd3e6e310aa825bc55319f",
            "patch": "@@ -1,13 +1,14 @@\n from django import forms\n from django.forms.util import flatatt\n from django.template import loader\n+from django.utils.encoding import smart_str\n from django.utils.http import int_to_base36\n from django.utils.safestring import mark_safe\n from django.utils.translation import ugettext_lazy as _\n \n-from django.contrib.auth.models import User\n-from django.contrib.auth.utils import UNUSABLE_PASSWORD\n from django.contrib.auth import authenticate\n+from django.contrib.auth.models import User\n+from django.contrib.auth.hashers import UNUSABLE_PASSWORD, is_password_usable, get_hasher\n from django.contrib.auth.tokens import default_token_generator\n from django.contrib.sites.models import get_current_site\n \n@@ -18,27 +19,26 @@\n \n class ReadOnlyPasswordHashWidget(forms.Widget):\n     def render(self, name, value, attrs):\n-        if not value:\n+        encoded = value\n+\n+        if not is_password_usable(encoded):\n             return \"None\"\n+\n         final_attrs = self.build_attrs(attrs)\n-        parts = value.split(\"$\")\n-        if len(parts) != 3:\n-            # Legacy passwords didn't specify a hash type and were md5.\n-            hash_type = \"md5\"\n-            masked = mask_password(value)\n+\n+        encoded = smart_str(encoded)\n+\n+        if len(encoded) == 32 and '$' not in encoded:\n+            hasher = get_hasher('md5')\n         else:\n-            hash_type = parts[0]\n-            masked = mask_password(parts[2])\n-        return mark_safe(\"\"\"<div%(attrs)s>\n-                    <strong>%(hash_type_label)s</strong>: %(hash_type)s\n-                    <strong>%(masked_label)s</strong>: %(masked)s\n-                </div>\"\"\" % {\n-                    \"attrs\": flatatt(final_attrs),\n-                    \"hash_type_label\": _(\"Hash type\"),\n-                    \"hash_type\": hash_type,\n-                    \"masked_label\": _(\"Masked hash\"),\n-                    \"masked\": masked,\n-                })\n+            algorithm = encoded.split('$', 1)[0]\n+            hasher = get_hasher(algorithm)\n+\n+        summary = \"\"\n+        for key, value in hasher.safe_summary(encoded).iteritems():\n+            summary += \"<strong>%(key)s</strong>: %(value)s \" % {\"key\": key, \"value\": value}\n+\n+        return mark_safe(\"<div%(attrs)s>%(summary)s</div>\" % {\"attrs\": flatatt(final_attrs), \"summary\": summary})\n \n \n class ReadOnlyPasswordHashField(forms.Field):"
        },
        {
            "sha": "36ac6d8605bbedcbb647ed750c409a29aaffa9bb",
            "filename": "django/contrib/auth/models.py",
            "status": "modified",
            "additions": 9,
            "deletions": 16,
            "changes": 25,
            "blob_url": "https://github.com/django/django/blob/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Fcontrib%2Fauth%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Fcontrib%2Fauth%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fauth%2Fmodels.py?ref=dce820ff70f00e974afd3e6e310aa825bc55319f",
            "patch": "@@ -9,11 +9,10 @@\n from django.utils import timezone\n \n from django.contrib import auth\n-from django.contrib.auth.signals import user_logged_in\n # UNUSABLE_PASSWORD is still imported here for backwards compatibility\n-from django.contrib.auth.utils import (get_hexdigest, make_password,\n-        check_password, is_password_usable, get_random_string,\n-        UNUSABLE_PASSWORD)\n+from django.contrib.auth.hashers import (\n+    check_password, make_password, is_password_usable, UNUSABLE_PASSWORD)\n+from django.contrib.auth.signals import user_logged_in\n from django.contrib.contenttypes.models import ContentType\n \n def update_last_login(sender, user, **kwargs):\n@@ -220,27 +219,21 @@ def get_full_name(self):\n         return full_name.strip()\n \n     def set_password(self, raw_password):\n-        self.password = make_password('sha1', raw_password)\n+        self.password = make_password(raw_password)\n \n     def check_password(self, raw_password):\n         \"\"\"\n         Returns a boolean of whether the raw_password was correct. Handles\n         hashing formats behind the scenes.\n         \"\"\"\n-        # Backwards-compatibility check. Older passwords won't include the\n-        # algorithm or salt.\n-        if '$' not in self.password:\n-            is_correct = (self.password == get_hexdigest('md5', '', raw_password))\n-            if is_correct:\n-                # Convert the password to the new, more secure format.\n-                self.set_password(raw_password)\n-                self.save()\n-            return is_correct\n-        return check_password(raw_password, self.password)\n+        def setter(raw_password):\n+            self.set_password(raw_password)\n+            self.save()\n+        return check_password(raw_password, self.password, setter)\n \n     def set_unusable_password(self):\n         # Sets a value that will never be a valid hash\n-        self.password = make_password('sha1', None)\n+        self.password = make_password(None)\n \n     def has_usable_password(self):\n         return is_password_usable(self.password)"
        },
        {
            "sha": "883e4c944b57696a6dfd9b8bf307e0eb5eccd237",
            "filename": "django/contrib/auth/tests/__init__.py",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Fcontrib%2Fauth%2Ftests%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Fcontrib%2Fauth%2Ftests%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fauth%2Ftests%2F__init__.py?ref=dce820ff70f00e974afd3e6e310aa825bc55319f",
            "patch": "@@ -1,7 +1,7 @@\n from django.contrib.auth.tests.auth_backends import (BackendTest,\n     RowlevelBackendTest, AnonymousUserBackendTest, NoBackendsTest,\n     InActiveUserBackendTest, NoInActiveUserBackendTest)\n-from django.contrib.auth.tests.basic import BasicTestCase, PasswordUtilsTestCase\n+from django.contrib.auth.tests.basic import BasicTestCase\n from django.contrib.auth.tests.context_processors import AuthContextProcessorTests\n from django.contrib.auth.tests.decorators import LoginRequiredTestCase\n from django.contrib.auth.tests.forms import (UserCreationFormTest,\n@@ -11,9 +11,11 @@\n     RemoteUserNoCreateTest, RemoteUserCustomTest)\n from django.contrib.auth.tests.management import GetDefaultUsernameTestCase\n from django.contrib.auth.tests.models import ProfileTestCase\n+from django.contrib.auth.tests.hashers import TestUtilsHashPass\n from django.contrib.auth.tests.signals import SignalTestCase\n from django.contrib.auth.tests.tokens import TokenGeneratorTest\n-from django.contrib.auth.tests.views import (AuthViewNamedURLTests, PasswordResetTest,\n-    ChangePasswordTest, LoginTest, LogoutTest, LoginURLSettings)\n+from django.contrib.auth.tests.views import (AuthViewNamedURLTests, \n+    PasswordResetTest, ChangePasswordTest, LoginTest, LogoutTest, \n+    LoginURLSettings)\n \n # The password for the fixture data users is 'password'"
        },
        {
            "sha": "512de163d94b9cfbca36b1e28854e3bf4caac78a",
            "filename": "django/contrib/auth/tests/basic.py",
            "status": "modified",
            "additions": 0,
            "deletions": 28,
            "changes": 28,
            "blob_url": "https://github.com/django/django/blob/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Fcontrib%2Fauth%2Ftests%2Fbasic.py",
            "raw_url": "https://github.com/django/django/raw/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Fcontrib%2Fauth%2Ftests%2Fbasic.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fauth%2Ftests%2Fbasic.py?ref=dce820ff70f00e974afd3e6e310aa825bc55319f",
            "patch": "@@ -1,7 +1,6 @@\n from django.test import TestCase\n from django.utils.unittest import skipUnless\n from django.contrib.auth.models import User, AnonymousUser\n-from django.contrib.auth import utils\n from django.core.management import call_command\n from StringIO import StringIO\n \n@@ -111,30 +110,3 @@ def test_createsuperuser_management_command(self):\n         u = User.objects.get(username=\"joe+admin@somewhere.org\")\n         self.assertEqual(u.email, 'joe@somewhere.org')\n         self.assertFalse(u.has_usable_password())\n-\n-\n-class PasswordUtilsTestCase(TestCase):\n-\n-    def _test_make_password(self, algo):\n-        password = utils.make_password(algo, \"foobar\")\n-        self.assertTrue(utils.is_password_usable(password))\n-        self.assertTrue(utils.check_password(\"foobar\", password))\n-\n-    def test_make_unusable(self):\n-        \"Check that you can create an unusable password.\"\n-        password = utils.make_password(\"any\", None)\n-        self.assertFalse(utils.is_password_usable(password))\n-        self.assertFalse(utils.check_password(\"foobar\", password))\n-\n-    def test_make_password_sha1(self):\n-        \"Check creating passwords with SHA1 algorithm.\"\n-        self._test_make_password(\"sha1\")\n-\n-    def test_make_password_md5(self):\n-        \"Check creating passwords with MD5 algorithm.\"\n-        self._test_make_password(\"md5\")\n-\n-    @skipUnless(crypt_module, \"no crypt module to generate password.\")\n-    def test_make_password_crypt(self):\n-        \"Check creating passwords with CRYPT algorithm.\"\n-        self._test_make_password(\"crypt\")"
        },
        {
            "sha": "ff6096c6f946f9503df740419665ff1e3c35bbcf",
            "filename": "django/utils/crypto.py",
            "status": "modified",
            "additions": 95,
            "deletions": 1,
            "changes": 96,
            "blob_url": "https://github.com/django/django/blob/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Futils%2Fcrypto.py",
            "raw_url": "https://github.com/django/django/raw/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Futils%2Fcrypto.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fcrypto.py?ref=dce820ff70f00e974afd3e6e310aa825bc55319f",
            "patch": "@@ -2,10 +2,18 @@\n Django's standard crypto functions and utilities.\n \"\"\"\n \n-import hashlib\n import hmac\n+import struct\n+import hashlib\n+import binascii\n+import operator\n from django.conf import settings\n \n+\n+trans_5c = \"\".join([chr(x ^ 0x5C) for x in xrange(256)])\n+trans_36 = \"\".join([chr(x ^ 0x36) for x in xrange(256)])\n+\n+\n def salted_hmac(key_salt, value, secret=None):\n     \"\"\"\n     Returns the HMAC-SHA1 of 'value', using a key generated from key_salt and a\n@@ -27,6 +35,23 @@ def salted_hmac(key_salt, value, secret=None):\n     # However, we need to ensure that we *always* do this.\n     return hmac.new(key, msg=value, digestmod=hashlib.sha1)\n \n+\n+def get_random_string(length=12, allowed_chars='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):\n+    \"\"\"\n+    Returns a random string of length characters from the set of a-z, A-Z, 0-9\n+    for use as a salt.\n+\n+    The default length of 12 with the a-z, A-Z, 0-9 character set returns\n+    a 71-bit salt. log_2((26+26+10)^12) =~ 71 bits\n+    \"\"\"\n+    import random\n+    try:\n+        random = random.SystemRandom()\n+    except NotImplementedError:\n+        pass\n+    return ''.join([random.choice(allowed_chars) for i in range(length)])\n+\n+\n def constant_time_compare(val1, val2):\n     \"\"\"\n     Returns True if the two strings are equal, False otherwise.\n@@ -39,3 +64,72 @@ def constant_time_compare(val1, val2):\n     for x, y in zip(val1, val2):\n         result |= ord(x) ^ ord(y)\n     return result == 0\n+\n+\n+def bin_to_long(x):\n+    \"\"\"\n+    Convert a binary string into a long integer\n+\n+    This is a clever optimization for fast xor vector math\n+    \"\"\"\n+    return long(x.encode('hex'), 16)\n+\n+\n+def long_to_bin(x):\n+    \"\"\"\n+    Convert a long integer into a binary string\n+    \"\"\"\n+    hex = \"%x\" % (x)\n+    if len(hex) % 2 == 1:\n+        hex = '0' + hex\n+    return binascii.unhexlify(hex)\n+\n+\n+def fast_hmac(key, msg, digest):\n+    \"\"\"\n+    A trimmed down version of Python's HMAC implementation\n+    \"\"\"\n+    dig1, dig2 = digest(), digest()\n+    if len(key) > dig1.block_size:\n+        key = digest(key).digest()\n+    key += chr(0) * (dig1.block_size - len(key))\n+    dig1.update(key.translate(trans_36))\n+    dig1.update(msg)\n+    dig2.update(key.translate(trans_5c))\n+    dig2.update(dig1.digest())\n+    return dig2\n+\n+\n+def pbkdf2(password, salt, iterations, dklen=0, digest=None):\n+    \"\"\"\n+    Implements PBKDF2 as defined in RFC 2898, section 5.2\n+\n+    HMAC+SHA256 is used as the default pseudo random function.\n+\n+    Right now 10,000 iterations is the recommended default which takes\n+    100ms on a 2.2Ghz Core 2 Duo.  This is probably the bare minimum\n+    for security given 1000 iterations was recommended in 2001. This\n+    code is very well optimized for CPython and is only four times\n+    slower than openssl's implementation.\n+    \"\"\"\n+    assert iterations > 0\n+    if not digest:\n+        digest = hashlib.sha256\n+    hlen = digest().digest_size\n+    if not dklen:\n+        dklen = hlen\n+    if dklen > (2 ** 32 - 1) * hlen:\n+        raise OverflowError('dklen too big')\n+    l = -(-dklen // hlen)\n+    r = dklen - (l - 1) * hlen\n+\n+    def F(i):\n+        def U():\n+            u = salt + struct.pack('>I', i)\n+            for j in xrange(int(iterations)):\n+                u = fast_hmac(password, u, digest).digest()\n+                yield bin_to_long(u)\n+        return long_to_bin(reduce(operator.xor, U()))\n+\n+    T = [F(x) for x in range(1, l + 1)]\n+    return ''.join(T[:-1]) + T[-1][:r]"
        },
        {
            "sha": "255bdc68501a824fe1a79fb2ef4e846a98ca6897",
            "filename": "docs/releases/1.4.txt",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/django/django/blob/dce820ff70f00e974afd3e6e310aa825bc55319f/docs%2Freleases%2F1.4.txt",
            "raw_url": "https://github.com/django/django/raw/dce820ff70f00e974afd3e6e310aa825bc55319f/docs%2Freleases%2F1.4.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.4.txt?ref=dce820ff70f00e974afd3e6e310aa825bc55319f",
            "patch": "@@ -90,6 +90,22 @@ allows you to fix a very common performance problem in which your code ends up\n doing O(n) database queries (or worse) if objects on your primary ``QuerySet``\n each have many related objects that you also need.\n \n+Improved password hashing\n+~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Django's auth system (``django.contrib.auth``) stores passwords using a one-way\n+algorithm. Django 1.3 uses the SHA1_ algorithm, but increasing processor speeds\n+and theoretical attacks have revealed that SHA1 isn't as secure as we'd like.\n+Thus, Django 1.4 introduces a new password storage system: by default Django now\n+uses the PBKDF2_ algorithm (as recommended by NIST_). You can also easily choose\n+a different algorithm (including the popular bcrypt_ algorithm). For more\n+details, see :ref:`auth_password_storage`.\n+\n+.. _sha1: http://en.wikipedia.org/wiki/SHA1\n+.. _pbkdf2: http://en.wikipedia.org/wiki/PBKDF2\n+.. _nist: http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf\n+.. _bcrypt: http://en.wikipedia.org/wiki/Bcrypt\n+\n HTML5 Doctype\n ~~~~~~~~~~~~~\n "
        },
        {
            "sha": "1cfccfc5e0206784ca6299f80098308581b89c00",
            "filename": "docs/topics/auth.txt",
            "status": "modified",
            "additions": 147,
            "deletions": 20,
            "changes": 167,
            "blob_url": "https://github.com/django/django/blob/dce820ff70f00e974afd3e6e310aa825bc55319f/docs%2Ftopics%2Fauth.txt",
            "raw_url": "https://github.com/django/django/raw/dce820ff70f00e974afd3e6e310aa825bc55319f/docs%2Ftopics%2Fauth.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fauth.txt?ref=dce820ff70f00e974afd3e6e310aa825bc55319f",
            "patch": "@@ -371,35 +371,162 @@ Don't set the :attr:`~django.contrib.auth.models.User.password` attribute\n directly unless you know what you're doing. This is explained in the next\n section.\n \n-Passwords\n----------\n+.. _auth_password_storage:\n+\n+How Django stores passwords\n+---------------------------\n+\n+.. versionadded:: 1.4\n+   Django 1.4 introduces a new flexible password storage system and uses\n+   PBKDF2 by default. Previous versions of Django used SHA1, and other\n+   algorithms couldn't be chosen.\n \n The :attr:`~django.contrib.auth.models.User.password` attribute of a\n :class:`~django.contrib.auth.models.User` object is a string in this format::\n \n-    hashtype$salt$hash\n-\n-That's hashtype, salt and hash, separated by the dollar-sign character.\n+    algorithm$hash\n+\n+That's a storage algorithm, and hash, separated by the dollar-sign\n+character. The algorithm is one of a number of one way hashing or password\n+storage algorithms Django can use; see below. The hash is the result of the one-\n+way function.\n+\n+By default, Django uses the PBKDF2_ algorithm with a SHA256 hash, a\n+password stretching mechanism recommended by NIST_. This should be\n+sufficient for most users: it's quite secure, requiring massive\n+amounts of computing time to break.\n+\n+However, depending on your requirements, you may choose a different\n+algorithm, or even use a custom algorithm to match your specific\n+security situation. Again, most users shouldn't need to do this -- if\n+you're not sure, you probably don't.  If you do, please read on:\n+\n+Django chooses the an algorithm by consulting the :setting:`PASSWORD_HASHERS`\n+setting. This is a list of hashing algorithm classes that this Django\n+installation supports. The first entry in this list (that is,\n+``settings.PASSWORD_HASHERS[0]``) will be used to store passwords, and all the\n+other entries are valid hashers that can be used to check existing passwords.\n+This means that if you want to use a different algorithm, you'll need to modify\n+:setting:`PASSWORD_HASHERS` to list your prefered algorithm first in the list.\n+\n+The default for :setting:`PASSWORD_HASHERS` is::\n+\n+    PASSWORD_HASHERS = (\n+        'django.contrib.auth.hashers.PBKDF2PasswordHasher',\n+        'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',\n+        'django.contrib.auth.hashers.BCryptPasswordHasher',\n+        'django.contrib.auth.hashers.SHA1PasswordHasher',\n+        'django.contrib.auth.hashers.MD5PasswordHasher',\n+        'django.contrib.auth.hashers.CryptPasswordHasher',\n+    )\n+\n+This means that Django will use PBKDF2_ to store all passwords, but will support\n+checking passwords stored with PBKDF2SHA1, bcrypt_, SHA1_, etc. The next few\n+sections describe a couple of common ways advanced users may want to modify this\n+setting.\n+\n+Using bcrypt with Django\n+~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Bcrypt_ is a popular password storage algorithm that's specifically designed\n+for long-term password storage. It's not the default used by Django since it\n+requires the use of third-party libraries, but since many people may want to\n+use it Django supports bcrypt with minimal effort.\n+\n+To use Bcrypt as your default storage algorithm, do the following:\n+\n+    1. Install the `py-bcrypt`_ library (probably by running ``pip install py-bcrypt``,\n+       ``easy_install py-bcrypt``, or downloading the library and installing\n+       it with ``python setup.py install``).\n+\n+    2. Modify :setting:`PASSWORD_HASHERS` to list ``BCryptPasswordHasher``\n+       first. That is, in your settings file, you'd put::\n+\n+            PASSWORD_HASHERS = (\n+                'django.contrib.auth.hashers.BCryptPasswordHasher',\n+                'django.contrib.auth.hashers.PBKDF2PasswordHasher',\n+                'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',\n+                'django.contrib.auth.hashers.SHA1PasswordHasher',\n+                'django.contrib.auth.hashers.MD5PasswordHasher',\n+                'django.contrib.auth.hashers.CryptPasswordHasher',\n+            )\n \n-Hashtype is either ``sha1`` (default), ``md5`` or ``crypt`` -- the algorithm\n-used to perform a one-way hash of the password. Salt is a random string used\n-to salt the raw password to create the hash. Note that the ``crypt`` method is\n-only supported on platforms that have the standard Python ``crypt`` module\n-available.\n+       (You need to keep the other entries in this list, or else Django won't\n+       be able to upgrade passwords; see below).\n+\n+That's it -- now your Django install will use Bcrypt as the default storage\n+algorithm.\n+\n+.. admonition:: Other bcrypt implementations\n+\n+   There are several other implementations that allow bcrypt to be\n+   used with Django. Django's bcrypt support is NOT directly\n+   compatible with these. To upgrade, you will need to modify the\n+   hashes in your database to be in the form `bcrypt$(raw bcrypt\n+   output)`. For example:\n+   `bcrypt$$2a$12$NT0I31Sa7ihGEWpka9ASYrEFkhuTNeBQ2xfZskIiiJeyFXhRgS.Sy`.\n+\n+Increasing the work factor\n+~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The PDKDF2 and bcrypt algorithms use a number of iterations or rounds of\n+hashing. This deliberately slows down attackers, making attacks against hashed\n+passwords harder. However, as computing power increases, the number of\n+iterations needs to be increased. We've chosen a reasonable default (and will\n+increase it with each release of Django), but you may wish to tune it up or\n+down, depending on your security needs and available processing power. To do so,\n+you'll subclass the appropriate algorithm and override the ``iterations``\n+parameters. For example, to increase the number of iterations used by the\n+default PDKDF2 algorithm:\n+\n+    1. Create a subclass of ``django.contrib.auth.hashers.PBKDF2PasswordHasher``::\n+\n+            from django.contrib.auth.hashers import PBKDF2PasswordHasher\n+\n+            class MyPBKDF2PasswordHasher(PBKDF2PasswordHasher):\n+                \"\"\"\n+                A subclass of PBKDF2PasswordHasher that uses 100 times more iterations.\n+                \"\"\"\n+                iterations = PBKDF2PasswordHasher.iterations * 100\n+\n+       Save this somewhere in your project. For example, you might put this in\n+       a file like ``myproject/hashers.py``.\n+\n+    2. Add your new hasher as the first entry in :setting:`PASSWORD_HASHERS`::\n+\n+            PASSWORD_HASHERS = (\n+                'myproject.hashers.MyPBKDF2PasswordHasher',\n+                'django.contrib.auth.hashers.PBKDF2PasswordHasher',\n+                'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',\n+                'django.contrib.auth.hashers.BCryptPasswordHasher',\n+                'django.contrib.auth.hashers.SHA1PasswordHasher',\n+                'django.contrib.auth.hashers.MD5PasswordHasher',\n+                'django.contrib.auth.hashers.CryptPasswordHasher',\n+            )\n \n-For example::\n \n-    sha1$a1976$a36cc8cbf81742a8fb52e221aaeab48ed7f58ab4\n+That's it -- now your Django install will use more iterations when it\n+stores passwords using PBKDF2.\n \n-The :meth:`~django.contrib.auth.models.User.set_password` and\n-:meth:`~django.contrib.auth.models.User.check_password` functions handle the\n-setting and checking of these values behind the scenes.\n+Password upgrading\n+~~~~~~~~~~~~~~~~~~\n \n-Previous Django versions, such as 0.90, used simple MD5 hashes without password\n-salts. For backwards compatibility, those are still supported; they'll be\n-converted automatically to the new style the first time\n-:meth:`~django.contrib.auth.models.User.check_password()` works correctly for\n-a given user.\n+When users log in, if their passwords are stored with anything other than\n+the preferred algorithm, Django will automatically upgrade the algorithm\n+to the preferred one. This means that old installs of Django will get\n+automatically more secure as users log in, and it also means that you\n+can switch to new (and better) storage algorithms as they get invented.\n+\n+However, Django can only upgrade passwords that use algorithms mentioned in\n+:setting:`PASSWORD_HASHERS`, so as you upgrade to new systems you should make\n+sure never to *remove* entries from this list. If you do, users using un-\n+mentioned algorithms won't be able to upgrade.\n+\n+.. _sha1: http://en.wikipedia.org/wiki/SHA1\n+.. _pbkdf2: http://en.wikipedia.org/wiki/PBKDF2\n+.. _nist: http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf\n+.. _bcrypt: http://en.wikipedia.org/wiki/Bcrypt\n+.. _py-bcrypt: http://pypi.python.org/pypi/py-bcrypt/\n \n Anonymous users\n ---------------"
        },
        {
            "sha": "f48a4adfee3e17e6e01eb7959f83db4be86980a5",
            "filename": "tests/regressiontests/utils/tests.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/dce820ff70f00e974afd3e6e310aa825bc55319f/tests%2Fregressiontests%2Futils%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/dce820ff70f00e974afd3e6e310aa825bc55319f/tests%2Fregressiontests%2Futils%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Futils%2Ftests.py?ref=dce820ff70f00e974afd3e6e310aa825bc55319f",
            "patch": "@@ -1,7 +1,6 @@\n \"\"\"\n Tests for django.utils.\n \"\"\"\n-\n from __future__ import absolute_import\n \n from .dateformat import DateFormatTests\n@@ -24,4 +23,5 @@\n from .jslex import JsTokensTest, JsToCForGettextTest\n from .ipv6 import TestUtilsIPv6\n from .timezone import TimezoneTests\n+from .crypto import TestUtilsCryptoPBKDF2\n from .archive import TestZip, TestTar, TestGzipTar, TestBzip2Tar"
        }
    ],
    "stats": {
        "total": 394,
        "additions": 305,
        "deletions": 89
    }
}