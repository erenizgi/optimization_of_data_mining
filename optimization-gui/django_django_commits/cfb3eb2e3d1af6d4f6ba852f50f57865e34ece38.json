{
    "author": "claudep",
    "message": "Used FakePayload in requests tests",
    "sha": "cfb3eb2e3d1af6d4f6ba852f50f57865e34ece38",
    "files": [
        {
            "sha": "2ec478a20140a39a63d88b6b66e696177b54c346",
            "filename": "tests/regressiontests/requests/tests.py",
            "status": "modified",
            "additions": 24,
            "deletions": 23,
            "changes": 47,
            "blob_url": "https://github.com/django/django/blob/cfb3eb2e3d1af6d4f6ba852f50f57865e34ece38/tests%2Fregressiontests%2Frequests%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/cfb3eb2e3d1af6d4f6ba852f50f57865e34ece38/tests%2Fregressiontests%2Frequests%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Frequests%2Ftests.py?ref=cfb3eb2e3d1af6d4f6ba852f50f57865e34ece38",
            "patch": "@@ -9,6 +9,7 @@\n from django.core.exceptions import SuspiciousOperation\n from django.core.handlers.wsgi import WSGIRequest, LimitedStream\n from django.http import HttpRequest, HttpResponse, parse_cookie, build_request_repr, UnreadablePostError\n+from django.test.client import FakePayload\n from django.test.utils import str_prefix\n from django.utils import unittest\n from django.utils.http import cookie_date\n@@ -328,23 +329,23 @@ def test_limited_stream(self):\n         self.assertEqual(stream.read(), b'')\n \n     def test_stream(self):\n-        payload = b'name=value'\n+        payload = FakePayload('name=value')\n         request = WSGIRequest({'REQUEST_METHOD': 'POST',\n                                'CONTENT_TYPE': 'application/x-www-form-urlencoded',\n                                'CONTENT_LENGTH': len(payload),\n-                               'wsgi.input': BytesIO(payload)})\n+                               'wsgi.input': payload})\n         self.assertEqual(request.read(), b'name=value')\n \n     def test_read_after_value(self):\n         \"\"\"\n         Reading from request is allowed after accessing request contents as\n         POST or body.\n         \"\"\"\n-        payload = b'name=value'\n+        payload = FakePayload('name=value')\n         request = WSGIRequest({'REQUEST_METHOD': 'POST',\n                                'CONTENT_TYPE': 'application/x-www-form-urlencoded',\n                                'CONTENT_LENGTH': len(payload),\n-                               'wsgi.input': BytesIO(payload)})\n+                               'wsgi.input': payload})\n         self.assertEqual(request.POST, {'name': ['value']})\n         self.assertEqual(request.body, b'name=value')\n         self.assertEqual(request.read(), b'name=value')\n@@ -354,11 +355,11 @@ def test_value_after_read(self):\n         Construction of POST or body is not allowed after reading\n         from request.\n         \"\"\"\n-        payload = b'name=value'\n+        payload = FakePayload('name=value')\n         request = WSGIRequest({'REQUEST_METHOD': 'POST',\n                                'CONTENT_TYPE': 'application/x-www-form-urlencoded',\n                                'CONTENT_LENGTH': len(payload),\n-                               'wsgi.input': BytesIO(payload)})\n+                               'wsgi.input': payload})\n         self.assertEqual(request.read(2), b'na')\n         self.assertRaises(Exception, lambda: request.body)\n         self.assertEqual(request.POST, {})\n@@ -370,17 +371,17 @@ def test_body_after_POST_multipart(self):\n         # Because multipart is used for large amounts fo data i.e. file uploads,\n         # we don't want the data held in memory twice, and we don't want to\n         # silence the error by setting body = '' either.\n-        payload = \"\\r\\n\".join([\n+        payload = FakePayload(\"\\r\\n\".join([\n                 '--boundary',\n                 'Content-Disposition: form-data; name=\"name\"',\n                 '',\n                 'value',\n                 '--boundary--'\n-                '']).encode('utf-8')\n+                '']))\n         request = WSGIRequest({'REQUEST_METHOD': 'POST',\n                                'CONTENT_TYPE': 'multipart/form-data; boundary=boundary',\n                                'CONTENT_LENGTH': len(payload),\n-                               'wsgi.input': BytesIO(payload)})\n+                               'wsgi.input': payload})\n         self.assertEqual(request.POST, {'name': ['value']})\n         self.assertRaises(Exception, lambda: request.body)\n \n@@ -392,17 +393,17 @@ def test_POST_multipart_with_content_length_zero(self):\n         # http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13\n         # Every request.POST with Content-Length >= 0 is a valid request,\n         # this test ensures that we handle Content-Length == 0.\n-        payload = \"\\r\\n\".join([\n+        payload = FakePayload(\"\\r\\n\".join([\n                 '--boundary',\n                 'Content-Disposition: form-data; name=\"name\"',\n                 '',\n                 'value',\n                 '--boundary--'\n-                '']).encode('utf-8')\n+                '']))\n         request = WSGIRequest({'REQUEST_METHOD': 'POST',\n                                'CONTENT_TYPE': 'multipart/form-data; boundary=boundary',\n                                'CONTENT_LENGTH': 0,\n-                               'wsgi.input': BytesIO(payload)})\n+                               'wsgi.input': payload})\n         self.assertEqual(request.POST, {})\n \n     def test_POST_binary_only(self):\n@@ -424,22 +425,22 @@ def test_POST_binary_only(self):\n         self.assertEqual(request.body, payload)\n \n     def test_read_by_lines(self):\n-        payload = b'name=value'\n+        payload = FakePayload('name=value')\n         request = WSGIRequest({'REQUEST_METHOD': 'POST',\n                                'CONTENT_TYPE': 'application/x-www-form-urlencoded',\n                                'CONTENT_LENGTH': len(payload),\n-                               'wsgi.input': BytesIO(payload)})\n+                               'wsgi.input': payload})\n         self.assertEqual(list(request), [b'name=value'])\n \n     def test_POST_after_body_read(self):\n         \"\"\"\n         POST should be populated even if body is read first\n         \"\"\"\n-        payload = b'name=value'\n+        payload = FakePayload('name=value')\n         request = WSGIRequest({'REQUEST_METHOD': 'POST',\n                                'CONTENT_TYPE': 'application/x-www-form-urlencoded',\n                                'CONTENT_LENGTH': len(payload),\n-                               'wsgi.input': BytesIO(payload)})\n+                               'wsgi.input': payload})\n         raw_data = request.body\n         self.assertEqual(request.POST, {'name': ['value']})\n \n@@ -448,11 +449,11 @@ def test_POST_after_body_read_and_stream_read(self):\n         POST should be populated even if body is read first, and then\n         the stream is read second.\n         \"\"\"\n-        payload = b'name=value'\n+        payload = FakePayload('name=value')\n         request = WSGIRequest({'REQUEST_METHOD': 'POST',\n                                'CONTENT_TYPE': 'application/x-www-form-urlencoded',\n                                'CONTENT_LENGTH': len(payload),\n-                               'wsgi.input': BytesIO(payload)})\n+                               'wsgi.input': payload})\n         raw_data = request.body\n         self.assertEqual(request.read(1), b'n')\n         self.assertEqual(request.POST, {'name': ['value']})\n@@ -462,17 +463,17 @@ def test_POST_after_body_read_and_stream_read_multipart(self):\n         POST should be populated even if body is read first, and then\n         the stream is read second. Using multipart/form-data instead of urlencoded.\n         \"\"\"\n-        payload = \"\\r\\n\".join([\n+        payload = FakePayload(\"\\r\\n\".join([\n                 '--boundary',\n                 'Content-Disposition: form-data; name=\"name\"',\n                 '',\n                 'value',\n                 '--boundary--'\n-                '']).encode('utf-8')\n+                '']))\n         request = WSGIRequest({'REQUEST_METHOD': 'POST',\n                                'CONTENT_TYPE': 'multipart/form-data; boundary=boundary',\n                                'CONTENT_LENGTH': len(payload),\n-                               'wsgi.input': BytesIO(payload)})\n+                               'wsgi.input': payload})\n         raw_data = request.body\n         # Consume enough data to mess up the parsing:\n         self.assertEqual(request.read(13), b'--boundary\\r\\nC')\n@@ -482,11 +483,11 @@ def test_raw_post_data_returns_body(self):\n         \"\"\"\n         HttpRequest.raw_post_body should be the same as HttpRequest.body\n         \"\"\"\n-        payload = b'Hello There!'\n+        payload = FakePayload('Hello There!')\n         request = WSGIRequest({\n             'REQUEST_METHOD': 'POST',\n             'CONTENT_LENGTH': len(payload),\n-            'wsgi.input': BytesIO(payload)\n+            'wsgi.input': payload,\n         })\n \n         with warnings.catch_warnings(record=True):"
        }
    ],
    "stats": {
        "total": 47,
        "additions": 24,
        "deletions": 23
    }
}