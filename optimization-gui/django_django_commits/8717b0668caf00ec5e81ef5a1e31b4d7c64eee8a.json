{
    "author": "aaugustin",
    "message": "Separated autocommit and isolation level handling for PostgreSQL.\n\nAutocommit cannot be manipulated independently from an open connection.\nThis commit introduces a minor change in behavior: entering transaction\nmanagement forces opening a databasse connection. This shouldn't be\nbackwards incompatible in any practical use case.",
    "sha": "8717b0668caf00ec5e81ef5a1e31b4d7c64eee8a",
    "files": [
        {
            "sha": "6211adcbd70e321e3573c0b7cc0b0f22226dc288",
            "filename": "django/db/backends/postgresql_psycopg2/base.py",
            "status": "modified",
            "additions": 41,
            "deletions": 37,
            "changes": 78,
            "blob_url": "https://github.com/django/django/blob/8717b0668caf00ec5e81ef5a1e31b4d7c64eee8a/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/8717b0668caf00ec5e81ef5a1e31b4d7c64eee8a/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py?ref=8717b0668caf00ec5e81ef5a1e31b4d7c64eee8a",
            "patch": "@@ -77,21 +77,21 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def __init__(self, *args, **kwargs):\n         super(DatabaseWrapper, self).__init__(*args, **kwargs)\n \n+        opts = self.settings_dict[\"OPTIONS\"]\n+        RC = psycopg2.extensions.ISOLATION_LEVEL_READ_COMMITTED\n+        self.isolation_level = opts.get('isolation_level', RC)\n+\n         self.features = DatabaseFeatures(self)\n-        autocommit = self.settings_dict[\"OPTIONS\"].get('autocommit', False)\n-        self.features.uses_autocommit = autocommit\n-        if autocommit:\n-            level = psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT\n-        else:\n-            level = self.settings_dict[\"OPTIONS\"].get('isolation_level',\n-                psycopg2.extensions.ISOLATION_LEVEL_READ_COMMITTED)\n-        self._set_isolation_level(level)\n         self.ops = DatabaseOperations(self)\n         self.client = DatabaseClient(self)\n         self.creation = DatabaseCreation(self)\n         self.introspection = DatabaseIntrospection(self)\n         self.validation = BaseDatabaseValidation(self)\n \n+        autocommit = opts.get('autocommit', False)\n+        self.features.uses_autocommit = autocommit\n+        self.features.uses_savepoints = not autocommit\n+\n     def get_connection_params(self):\n         settings_dict = self.settings_dict\n         if not settings_dict['NAME']:\n@@ -135,11 +135,12 @@ def init_connection_state(self):\n \n             if conn_tz != tz:\n                 # Set the time zone in autocommit mode (see #17062)\n-                self.connection.set_isolation_level(\n-                        psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)\n+                self.set_autocommit(True)\n                 self.connection.cursor().execute(\n                         self.ops.set_time_zone_sql(), [tz])\n         self.connection.set_isolation_level(self.isolation_level)\n+        if self.features.uses_autocommit:\n+            self.set_autocommit(True)\n \n     def create_cursor(self):\n         cursor = self.connection.cursor()\n@@ -172,42 +173,40 @@ def _enter_transaction_management(self, managed):\n         Switch the isolation level when needing transaction support, so that\n         the same transaction is visible across all the queries.\n         \"\"\"\n-        if self.features.uses_autocommit and managed and not self.isolation_level:\n-            level = self.settings_dict[\"OPTIONS\"].get('isolation_level',\n-                psycopg2.extensions.ISOLATION_LEVEL_READ_COMMITTED)\n-            self._set_isolation_level(level)\n+        if self.connection is None:             # Force creating a connection.\n+            self.cursor().close()\n+        if self.features.uses_autocommit and managed and self.autocommit:\n+            self.set_autocommit(False)\n+            self.features.uses_savepoints = True\n \n     def _leave_transaction_management(self, managed):\n         \"\"\"\n         If the normal operating mode is \"autocommit\", switch back to that when\n         leaving transaction management.\n         \"\"\"\n-        if self.features.uses_autocommit and not managed and self.isolation_level:\n-            self._set_isolation_level(psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)\n-\n-    def _set_isolation_level(self, level):\n-        \"\"\"\n-        Do all the related feature configurations for changing isolation\n-        levels. This doesn't touch the uses_autocommit feature, since that\n-        controls the movement *between* isolation levels.\n-        \"\"\"\n-        assert level in range(5)\n-        try:\n-            if self.connection is not None:\n-                self.connection.set_isolation_level(level)\n-            if level == psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT:\n-                self.set_clean()\n-        finally:\n-            self.isolation_level = level\n-            self.features.uses_savepoints = bool(level)\n+        if self.connection is None:             # Force creating a connection.\n+            self.cursor().close()\n+        if self.features.uses_autocommit and not managed and not self.autocommit:\n+            self.rollback()                     # Must terminate transaction first.\n+            self.set_autocommit(True)\n+            self.features.uses_savepoints = False\n+\n+    def _set_isolation_level(self, isolation_level):\n+        assert isolation_level in range(1, 5)     # Use set_autocommit for level = 0\n+        if self.psycopg2_version >= (2, 4, 2):\n+            self.connection.set_session(isolation_level=isolation_level)\n+        else:\n+            self.connection.set_isolation_level(isolation_level)\n \n     def _set_autocommit(self, autocommit):\n-        if autocommit:\n-            level = psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT\n+        if self.psycopg2_version >= (2, 4, 2):\n+            self.connection.autocommit = autocommit\n         else:\n-            level = self.settings_dict[\"OPTIONS\"].get('isolation_level',\n-                psycopg2.extensions.ISOLATION_LEVEL_READ_COMMITTED)\n-        self._set_isolation_level(level)\n+            if autocommit:\n+                level = psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT\n+            else:\n+                level = self.isolation_level\n+            self.connection.set_isolation_level(level)\n \n     def set_dirty(self):\n         if ((self.transaction_state and self.transaction_state[-1]) or\n@@ -231,6 +230,11 @@ def is_usable(self):\n         else:\n             return True\n \n+    @cached_property\n+    def psycopg2_version(self):\n+        version = psycopg2.__version__.split(' ', 1)[0]\n+        return tuple(int(v) for v in version.split('.'))\n+\n     @cached_property\n     def pg_version(self):\n         with self.temporary_connection():"
        },
        {
            "sha": "1b50039965e4208793001abaead4bdfafc2c8184",
            "filename": "tests/transactions_regress/tests.py",
            "status": "modified",
            "additions": 13,
            "deletions": 4,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/8717b0668caf00ec5e81ef5a1e31b4d7c64eee8a/tests%2Ftransactions_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/8717b0668caf00ec5e81ef5a1e31b4d7c64eee8a/tests%2Ftransactions_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions_regress%2Ftests.py?ref=8717b0668caf00ec5e81ef5a1e31b4d7c64eee8a",
            "patch": "@@ -274,31 +274,39 @@ def tearDown(self):\n             connections[DEFAULT_DB_ALIAS] = self._old_backend\n \n     def test_initial_autocommit_state(self):\n+        # Autocommit is activated when the connection is created.\n+        connection.cursor().close()\n+\n         self.assertTrue(connection.features.uses_autocommit)\n-        self.assertEqual(connection.isolation_level, self._autocommit)\n+        self.assertTrue(connection.autocommit)\n \n     def test_transaction_management(self):\n         transaction.enter_transaction_management()\n+        self.assertFalse(connection.autocommit)\n         self.assertEqual(connection.isolation_level, self._serializable)\n \n         transaction.leave_transaction_management()\n-        self.assertEqual(connection.isolation_level, self._autocommit)\n+        self.assertTrue(connection.autocommit)\n \n     def test_transaction_stacking(self):\n         transaction.enter_transaction_management()\n+        self.assertFalse(connection.autocommit)\n         self.assertEqual(connection.isolation_level, self._serializable)\n \n         transaction.enter_transaction_management()\n+        self.assertFalse(connection.autocommit)\n         self.assertEqual(connection.isolation_level, self._serializable)\n \n         transaction.leave_transaction_management()\n+        self.assertFalse(connection.autocommit)\n         self.assertEqual(connection.isolation_level, self._serializable)\n \n         transaction.leave_transaction_management()\n-        self.assertEqual(connection.isolation_level, self._autocommit)\n+        self.assertTrue(connection.autocommit)\n \n     def test_enter_autocommit(self):\n         transaction.enter_transaction_management()\n+        self.assertFalse(connection.autocommit)\n         self.assertEqual(connection.isolation_level, self._serializable)\n         list(Mod.objects.all())\n         self.assertTrue(transaction.is_dirty())\n@@ -311,9 +319,10 @@ def test_enter_autocommit(self):\n         list(Mod.objects.all())\n         self.assertFalse(transaction.is_dirty())\n         transaction.leave_transaction_management()\n+        self.assertFalse(connection.autocommit)\n         self.assertEqual(connection.isolation_level, self._serializable)\n         transaction.leave_transaction_management()\n-        self.assertEqual(connection.isolation_level, self._autocommit)\n+        self.assertTrue(connection.autocommit)\n \n \n class TestManyToManyAddTransaction(TransactionTestCase):"
        }
    ],
    "stats": {
        "total": 95,
        "additions": 54,
        "deletions": 41
    }
}