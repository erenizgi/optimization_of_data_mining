{
    "author": "ptone",
    "message": "PEP8 cleanup of functional.py",
    "sha": "876fc3912881e15eda2b02c3b4933af313d0a498",
    "files": [
        {
            "sha": "d740acf8f2807c44bd671720704720fe232300a9",
            "filename": "django/utils/functional.py",
            "status": "modified",
            "additions": 24,
            "deletions": 12,
            "changes": 36,
            "blob_url": "https://github.com/django/django/blob/876fc3912881e15eda2b02c3b4933af313d0a498/django%2Futils%2Ffunctional.py",
            "raw_url": "https://github.com/django/django/raw/876fc3912881e15eda2b02c3b4933af313d0a498/django%2Futils%2Ffunctional.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Ffunctional.py?ref=876fc3912881e15eda2b02c3b4933af313d0a498",
            "patch": "@@ -1,18 +1,20 @@\n import copy\n import operator\n-from functools import wraps, update_wrapper\n+from functools import wraps\n import sys\n \n from django.utils import six\n \n+\n # You can't trivially replace this with `functools.partial` because this binds\n # to classes and returns bound instances, whereas functools.partial (on\n # CPython) is a type and its instances don't bind.\n def curry(_curried_func, *args, **kwargs):\n     def _curried(*moreargs, **morekwargs):\n-        return _curried_func(*(args+moreargs), **dict(kwargs, **morekwargs))\n+        return _curried_func(*(args + moreargs), **dict(kwargs, **morekwargs))\n     return _curried\n \n+\n def memoize(func, cache, num_args):\n     \"\"\"\n     Wrap a function so that results for any argument tuple are stored in\n@@ -31,6 +33,7 @@ def wrapper(*args):\n         return result\n     return wrapper\n \n+\n class cached_property(object):\n     \"\"\"\n     Decorator that converts a method with a single self argument into a\n@@ -45,6 +48,7 @@ def __get__(self, instance, type=None):\n         res = instance.__dict__[self.func.__name__] = self.func(instance)\n         return res\n \n+\n class Promise(object):\n     \"\"\"\n     This is just a base class for the proxy class created in\n@@ -53,6 +57,7 @@ class Promise(object):\n     \"\"\"\n     pass\n \n+\n def lazy(func, *resultclasses):\n     \"\"\"\n     Turns any callable into a lazy evaluated callable. You need to give result\n@@ -88,9 +93,9 @@ def __prepare_class__(cls):\n                 cls.__dispatch[resultclass] = {}\n                 for type_ in reversed(resultclass.mro()):\n                     for (k, v) in type_.__dict__.items():\n-                        # All __promise__ return the same wrapper method, but they\n-                        # also do setup, inserting the method into the dispatch\n-                        # dict.\n+                        # All __promise__ return the same wrapper method, but\n+                        # they also do setup, inserting the method into the\n+                        # dispatch dict.\n                         meth = cls.__promise__(resultclass, k, v)\n                         if hasattr(cls, k):\n                             continue\n@@ -111,8 +116,8 @@ def __prepare_class__(cls):\n         __prepare_class__ = classmethod(__prepare_class__)\n \n         def __promise__(cls, klass, funcname, method):\n-            # Builds a wrapper around some magic method and registers that magic\n-            # method for the given type and method name.\n+            # Builds a wrapper around some magic method and registers that\n+            # magic method for the given type and method name.\n             def __wrapper__(self, *args, **kw):\n                 # Automatically triggers the evaluation of a lazy value and\n                 # applies the given magic method of the result type.\n@@ -176,9 +181,11 @@ def __wrapper__(*args, **kw):\n \n     return __wrapper__\n \n+\n def _lazy_proxy_unpickle(func, args, kwargs, *resultclasses):\n     return lazy(func, *resultclasses)(*args, **kwargs)\n \n+\n def allow_lazy(func, *resultclasses):\n     \"\"\"\n     A decorator that allows a function to be called with one or more lazy\n@@ -197,13 +204,16 @@ def wrapper(*args, **kwargs):\n     return wrapper\n \n empty = object()\n+\n+\n def new_method_proxy(func):\n     def inner(self, *args):\n         if self._wrapped is empty:\n             self._setup()\n         return func(self._wrapped, *args)\n     return inner\n \n+\n class LazyObject(object):\n     \"\"\"\n     A wrapper for another class that can be used to delay instantiation of the\n@@ -246,6 +256,7 @@ def _setup(self):\n # Workaround for http://bugs.python.org/issue12370\n _super = super\n \n+\n class SimpleLazyObject(LazyObject):\n     \"\"\"\n     A lazy object initialised from any function.\n@@ -288,8 +299,8 @@ def __deepcopy__(self, memo):\n     # Because we have messed with __class__ below, we confuse pickle as to what\n     # class we are pickling. It also appears to stop __reduce__ from being\n     # called. So, we define __getstate__ in a way that cooperates with the way\n-    # that pickle interprets this class.  This fails when the wrapped class is a\n-    # builtin, but it is better than nothing.\n+    # that pickle interprets this class.  This fails when the wrapped class is\n+    # a builtin, but it is better than nothing.\n     def __getstate__(self):\n         if self._wrapped is empty:\n             self._setup()\n@@ -314,8 +325,8 @@ def __repr__(self):\n             repr_attr = self._wrapped\n         return '<SimpleLazyObject: %r>' % repr_attr\n \n-    # Need to pretend to be the wrapped class, for the sake of objects that care\n-    # about this (especially in equality tests)\n+    # Need to pretend to be the wrapped class, for the sake of objects that\n+    # care about this (especially in equality tests)\n     __class__ = property(new_method_proxy(operator.attrgetter(\"__class__\")))\n     __eq__ = new_method_proxy(operator.eq)\n     __hash__ = new_method_proxy(hash)\n@@ -343,6 +354,7 @@ def fdel(instance, name=fdel.__name__):\n                 return getattr(instance, name)()\n         return property(fget, fset, fdel, doc)\n \n+\n def partition(predicate, values):\n     \"\"\"\n     Splits the values into two sets, based on the return value of the function\n@@ -356,7 +368,7 @@ def partition(predicate, values):\n         results[predicate(item)].append(item)\n     return results\n \n-if sys.version_info >= (2,7,2):\n+if sys.version_info >= (2, 7, 2):\n     from functools import total_ordering\n else:\n     # For Python < 2.7.2. Python 2.6 does not have total_ordering, and"
        },
        {
            "sha": "2bc6799372ba1438434b44d784956b4375fd34b7",
            "filename": "tests/utils_tests/simplelazyobject.py",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/django/django/blob/876fc3912881e15eda2b02c3b4933af313d0a498/tests%2Futils_tests%2Fsimplelazyobject.py",
            "raw_url": "https://github.com/django/django/raw/876fc3912881e15eda2b02c3b4933af313d0a498/tests%2Futils_tests%2Fsimplelazyobject.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Futils_tests%2Fsimplelazyobject.py?ref=876fc3912881e15eda2b02c3b4933af313d0a498",
            "patch": "@@ -3,7 +3,6 @@\n import copy\n import pickle\n \n-from django.test.utils import str_prefix\n from django.utils import six\n from django.utils.unittest import TestCase\n from django.utils.functional import SimpleLazyObject, empty\n@@ -67,7 +66,7 @@ def test_repr(self):\n         self.assertEqual(empty, x._wrapped)\n \n         # Second, for an evaluated SimpleLazyObject\n-        name = x.name # evaluate\n+        name = x.name  # evaluate\n         self.assertTrue(isinstance(x._wrapped, _ComplexObject))\n         # __repr__ contains __repr__ of wrapped object\n         self.assertEqual(\"<SimpleLazyObject: %r>\" % x._wrapped, repr(x))\n@@ -97,14 +96,14 @@ def test_deepcopy(self):\n         self.assertEqual(s2, complex_object())\n \n         # Second, for an evaluated SimpleLazyObject\n-        name = s.name # evaluate\n+        name = s.name  # evaluate\n         self.assertIsNot(s._wrapped, empty)\n         s3 = copy.deepcopy(s)\n         self.assertEqual(s3, complex_object())\n \n-\n     def test_none(self):\n         i = [0]\n+\n         def f():\n             i[0] += 1\n             return None"
        }
    ],
    "stats": {
        "total": 43,
        "additions": 27,
        "deletions": 16
    }
}