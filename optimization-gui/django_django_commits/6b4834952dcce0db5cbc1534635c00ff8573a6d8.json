{
    "author": "akaariai",
    "message": "Fixed #16649 -- Refactored save_base logic\n\nModel.save() will use UPDATE - if not updated - INSERT instead of\nSELECT - if found UPDATE else INSERT. This should save a query when\nupdating, but will cost a little when inserting model with PK set.\n\nAlso fixed #17341 -- made sure .save() commits transactions only after\nthe whole model has been saved. This wasn't the case in model\ninheritance situations.\n\nThe save_base implementation was refactored into multiple methods.\nA typical chain for inherited save is:\nsave_base()\n    _save_parents(self)\n        for each parent:\n            _save_parents(parent)\n            _save_table(parent)\n    _save_table(self)",
    "sha": "6b4834952dcce0db5cbc1534635c00ff8573a6d8",
    "files": [
        {
            "sha": "f3e3b76dd7d711a8b3e3a92fd6317e1dd08ce3b1",
            "filename": "django/db/models/base.py",
            "status": "modified",
            "additions": 115,
            "deletions": 101,
            "changes": 216,
            "blob_url": "https://github.com/django/django/blob/6b4834952dcce0db5cbc1534635c00ff8573a6d8/django%2Fdb%2Fmodels%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/6b4834952dcce0db5cbc1534635c00ff8573a6d8/django%2Fdb%2Fmodels%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fbase.py?ref=6b4834952dcce0db5cbc1534635c00ff8573a6d8",
            "patch": "@@ -545,125 +545,139 @@ def save(self, force_insert=False, force_update=False, using=None,\n                        force_update=force_update, update_fields=update_fields)\n     save.alters_data = True\n \n-    def save_base(self, raw=False, cls=None, origin=None, force_insert=False,\n+    def save_base(self, raw=False, force_insert=False,\n                   force_update=False, using=None, update_fields=None):\n         \"\"\"\n-        Does the heavy-lifting involved in saving. Subclasses shouldn't need to\n-        override this method. It's separate from save() in order to hide the\n-        need for overrides of save() to pass around internal-only parameters\n-        ('raw', 'cls', and 'origin').\n+        Handles the parts of saving which should be done only once per save,\n+        yet need to be done in raw saves, too. This includes some sanity\n+        checks and signal sending.\n+\n+        The 'raw' argument is telling save_base not to save any parent\n+        models and not to do any changes to the values before save. This\n+        is used by fixture loading.\n         \"\"\"\n         using = using or router.db_for_write(self.__class__, instance=self)\n         assert not (force_insert and (force_update or update_fields))\n         assert update_fields is None or len(update_fields) > 0\n-        if cls is None:\n-            cls = self.__class__\n-            meta = cls._meta\n-            if not meta.proxy:\n-                origin = cls\n-        else:\n-            meta = cls._meta\n-\n-        if origin and not meta.auto_created:\n+        cls = origin = self.__class__\n+        # Skip proxies, but keep the origin as the proxy model.\n+        if cls._meta.proxy:\n+            cls = cls._meta.concrete_model\n+        meta = cls._meta\n+        if not meta.auto_created:\n             signals.pre_save.send(sender=origin, instance=self, raw=raw, using=using,\n                                   update_fields=update_fields)\n-\n-        # If we are in a raw save, save the object exactly as presented.\n-        # That means that we don't try to be smart about saving attributes\n-        # that might have come from the parent class - we just save the\n-        # attributes we have been given to the class we have been given.\n-        # We also go through this process to defer the save of proxy objects\n-        # to their actual underlying model.\n-        if not raw or meta.proxy:\n-            if meta.proxy:\n-                org = cls\n-            else:\n-                org = None\n-            for parent, field in meta.parents.items():\n-                # At this point, parent's primary key field may be unknown\n-                # (for example, from administration form which doesn't fill\n-                # this field). If so, fill it.\n-                if field and getattr(self, parent._meta.pk.attname) is None and getattr(self, field.attname) is not None:\n-                    setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n-\n-                self.save_base(cls=parent, origin=org, using=using,\n-                               update_fields=update_fields)\n-\n-                if field:\n-                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n-                    # Since we didn't have an instance of the parent handy, we\n-                    # set attname directly, bypassing the descriptor.\n-                    # Invalidate the related object cache, in case it's been\n-                    # accidentally populated. A fresh instance will be\n-                    # re-built from the database if necessary.\n-                    cache_name = field.get_cache_name()\n-                    if hasattr(self, cache_name):\n-                        delattr(self, cache_name)\n-\n-            if meta.proxy:\n-                return\n-\n-        if not meta.proxy:\n-            non_pks = [f for f in meta.local_fields if not f.primary_key]\n-\n-            if update_fields:\n-                non_pks = [f for f in non_pks if f.name in update_fields or f.attname in update_fields]\n-\n-            with transaction.commit_on_success_unless_managed(using=using):\n-                # First, try an UPDATE. If that doesn't update anything, do an INSERT.\n-                pk_val = self._get_pk_val(meta)\n-                pk_set = pk_val is not None\n-                record_exists = True\n-                manager = cls._base_manager\n-                if pk_set:\n-                    # Determine if we should do an update (pk already exists, forced update,\n-                    # no force_insert)\n-                    if ((force_update or update_fields) or (not force_insert and\n-                            manager.using(using).filter(pk=pk_val).exists())):\n-                        if force_update or non_pks:\n-                            values = [(f, None, (raw and getattr(self, f.attname) or f.pre_save(self, False))) for f in non_pks]\n-                            if values:\n-                                rows = manager.using(using).filter(pk=pk_val)._update(values)\n-                                if force_update and not rows:\n-                                    raise DatabaseError(\"Forced update did not affect any rows.\")\n-                                if update_fields and not rows:\n-                                    raise DatabaseError(\"Save with update_fields did not affect any rows.\")\n-                    else:\n-                        record_exists = False\n-                if not pk_set or not record_exists:\n-                    if meta.order_with_respect_to:\n-                        # If this is a model with an order_with_respect_to\n-                        # autopopulate the _order field\n-                        field = meta.order_with_respect_to\n-                        order_value = manager.using(using).filter(**{field.name: getattr(self, field.attname)}).count()\n-                        self._order = order_value\n-\n-                    fields = meta.local_fields\n-                    if not pk_set:\n-                        if force_update or update_fields:\n-                            raise ValueError(\"Cannot force an update in save() with no primary key.\")\n-                        fields = [f for f in fields if not isinstance(f, AutoField)]\n-\n-                    record_exists = False\n-\n-                    update_pk = bool(meta.has_auto_field and not pk_set)\n-                    result = manager._insert([self], fields=fields, return_id=update_pk, using=using, raw=raw)\n-\n-                    if update_pk:\n-                        setattr(self, meta.pk.attname, result)\n-\n+        with transaction.commit_on_success_unless_managed(using=using, savepoint=False):\n+            if not raw:\n+                self._save_parents(cls, using, update_fields)\n+            updated = self._save_table(raw, cls, force_insert, force_update, using, update_fields)\n         # Store the database on which the object was saved\n         self._state.db = using\n         # Once saved, this is no longer a to-be-added instance.\n         self._state.adding = False\n \n         # Signal that the save is complete\n-        if origin and not meta.auto_created:\n-            signals.post_save.send(sender=origin, instance=self, created=(not record_exists),\n+        if not meta.auto_created:\n+            signals.post_save.send(sender=origin, instance=self, created=(not updated),\n                                    update_fields=update_fields, raw=raw, using=using)\n \n     save_base.alters_data = True\n \n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"\n+        Saves all the parents of cls using values from self.\n+        \"\"\"\n+        meta = cls._meta\n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+            if (field and getattr(self, parent._meta.pk.attname) is None\n+                    and getattr(self, field.attname) is not None):\n+                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n+            self._save_parents(cls=parent, using=using, update_fields=update_fields)\n+            self._save_table(cls=parent, using=using, update_fields=update_fields)\n+            # Set the parent's PK value to self.\n+            if field:\n+                setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                # Since we didn't have an instance of the parent handy set\n+                # attname directly, bypassing the descriptor. Invalidate\n+                # the related object cache, in case it's been accidentally\n+                # populated. A fresh instance will be re-built from the\n+                # database if necessary.\n+                cache_name = field.get_cache_name()\n+                if hasattr(self, cache_name):\n+                    delattr(self, cache_name)\n+\n+    def _save_table(self, raw=False, cls=None, force_insert=False,\n+                    force_update=False, using=None, update_fields=None):\n+        \"\"\"\n+        Does the heavy-lifting involved in saving. Updates or inserts the data\n+        for a single table.\n+        \"\"\"\n+        meta = cls._meta\n+        non_pks = [f for f in meta.local_fields if not f.primary_key]\n+\n+        if update_fields:\n+            non_pks = [f for f in non_pks\n+                       if f.name in update_fields or f.attname in update_fields]\n+\n+        pk_val = self._get_pk_val(meta)\n+        pk_set = pk_val is not None\n+        if not pk_set and (force_update or update_fields):\n+            raise ValueError(\"Cannot force an update in save() with no primary key.\")\n+        updated = False\n+        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n+        if pk_set and not force_insert:\n+            base_qs = cls._base_manager.using(using)\n+            values = [(f, None, (raw and getattr(self, f.attname) or f.pre_save(self, False)))\n+                      for f in non_pks]\n+            if not values:\n+                # We can end up here when saving a model in inheritance chain where\n+                # update_fields doesn't target any field in current model. In that\n+                # case we just say the update succeeded. Another case ending up here\n+                # is a model with just PK - in that case check that the PK still\n+                # exists.\n+                updated = update_fields is not None or base_qs.filter(pk=pk_val).exists()\n+            else:\n+                updated = self._do_update(base_qs, using, pk_val, values)\n+            if force_update and not updated:\n+                raise DatabaseError(\"Forced update did not affect any rows.\")\n+            if update_fields and not updated:\n+                raise DatabaseError(\"Save with update_fields did not affect any rows.\")\n+        if not updated:\n+            if meta.order_with_respect_to:\n+                # If this is a model with an order_with_respect_to\n+                # autopopulate the _order field\n+                field = meta.order_with_respect_to\n+                order_value = cls._base_manager.using(using).filter(\n+                    **{field.name: getattr(self, field.attname)}).count()\n+                self._order = order_value\n+\n+            fields = meta.local_fields\n+            if not pk_set:\n+                fields = [f for f in fields if not isinstance(f, AutoField)]\n+\n+            update_pk = bool(meta.has_auto_field and not pk_set)\n+            result = self._do_insert(cls._base_manager, using, fields, update_pk, raw)\n+            if update_pk:\n+                setattr(self, meta.pk.attname, result)\n+        return updated\n+\n+    def _do_update(self, base_qs, using, pk_val, values):\n+        \"\"\"\n+        This method will try to update the model. If the model was updated (in\n+        the sense that an update query was done and a matching row was found\n+        from the DB) the method will return True.\n+        \"\"\"\n+        return base_qs.filter(pk=pk_val)._update(values) > 0\n+\n+    def _do_insert(self, manager, using, fields, update_pk, raw):\n+        \"\"\"\n+        Do an INSERT. If update_pk is defined then this method should return\n+        the new pk for the model.\n+        \"\"\"\n+        return manager._insert([self], fields=fields, return_id=update_pk,\n+                               using=using, raw=raw)\n+\n     def delete(self, using=None):\n         using = using or router.db_for_write(self.__class__, instance=self)\n         assert self._get_pk_val() is not None, \"%s object can't be deleted because its %s attribute is set to None.\" % (self._meta.object_name, self._meta.pk.attname)"
        },
        {
            "sha": "9f583c42ac393958adfc3137e7eb480cf4fbb277",
            "filename": "docs/ref/models/instances.txt",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/6b4834952dcce0db5cbc1534635c00ff8573a6d8/docs%2Fref%2Fmodels%2Finstances.txt",
            "raw_url": "https://github.com/django/django/raw/6b4834952dcce0db5cbc1534635c00ff8573a6d8/docs%2Fref%2Fmodels%2Finstances.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Finstances.txt?ref=6b4834952dcce0db5cbc1534635c00ff8573a6d8",
            "patch": "@@ -292,12 +292,13 @@ follows this algorithm:\n \n * If the object's primary key attribute is set to a value that evaluates to\n   ``True`` (i.e., a value other than ``None`` or the empty string), Django\n-  executes a ``SELECT`` query to determine whether a record with the given\n-  primary key already exists.\n-* If the record with the given primary key does already exist, Django\n-  executes an ``UPDATE`` query.\n-* If the object's primary key attribute is *not* set, or if it's set but a\n-  record doesn't exist, Django executes an ``INSERT``.\n+  executes an ``UPDATE``.\n+* If the object's primary key attribute is *not* set or if the ``UPDATE``\n+  didn't update anything, Django executes an ``INSERT``.\n+\n+.. versionchanged:: 1.6\n+  Previously Django used ``SELECT`` - if not found ``INSERT`` else ``UPDATE``\n+  algorithm. The old algorithm resulted in one more query in ``UPDATE`` case.\n \n The one gotcha here is that you should be careful not to specify a primary-key\n value explicitly when saving new objects, if you cannot guarantee the"
        },
        {
            "sha": "a44545ddf3ed2563c4709dff2088199afc8b03eb",
            "filename": "docs/releases/1.6.txt",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/6b4834952dcce0db5cbc1534635c00ff8573a6d8/docs%2Freleases%2F1.6.txt",
            "raw_url": "https://github.com/django/django/raw/6b4834952dcce0db5cbc1534635c00ff8573a6d8/docs%2Freleases%2F1.6.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.6.txt?ref=6b4834952dcce0db5cbc1534635c00ff8573a6d8",
            "patch": "@@ -150,6 +150,10 @@ Minor features\n * Generic :class:`~django.contrib.gis.db.models.GeometryField` is now editable\n   with the OpenLayers widget in the admin.\n \n+* The :meth:`Model.save() <django.db.models.Model.save()>` will do\n+  ``UPDATE`` - if not updated - ``INSERT`` instead of ``SELECT`` - if not\n+  found ``INSERT`` else ``UPDATE`` in case the model's primary key is set.\n+\n Backwards incompatible changes in 1.6\n =====================================\n "
        },
        {
            "sha": "a8005baca7b1f0cd28159719fcf3cc8eb08d75f0",
            "filename": "tests/basic/tests.py",
            "status": "modified",
            "additions": 29,
            "deletions": 2,
            "changes": 31,
            "blob_url": "https://github.com/django/django/blob/6b4834952dcce0db5cbc1534635c00ff8573a6d8/tests%2Fbasic%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/6b4834952dcce0db5cbc1534635c00ff8573a6d8/tests%2Fbasic%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fbasic%2Ftests.py?ref=6b4834952dcce0db5cbc1534635c00ff8573a6d8",
            "patch": "@@ -1,11 +1,13 @@\n from __future__ import absolute_import, unicode_literals\n \n from datetime import datetime\n+import threading\n \n from django.core.exceptions import ObjectDoesNotExist, MultipleObjectsReturned, FieldError\n+from django.db import connections, DEFAULT_DB_ALIAS\n from django.db.models.fields import Field, FieldDoesNotExist\n from django.db.models.query import QuerySet, EmptyQuerySet, ValuesListQuerySet\n-from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n+from django.test import TestCase, TransactionTestCase, skipIfDBFeature, skipUnlessDBFeature\n from django.utils import six\n from django.utils.translation import ugettext_lazy\n \n@@ -690,4 +692,29 @@ def test_emptyqs_distinct(self):\n     def test_invalid_qs_list(self):\n         qs = Article.objects.order_by('invalid_column')\n         self.assertRaises(FieldError, list, qs)\n-        self.assertRaises(FieldError, list, qs)\n\\ No newline at end of file\n+        self.assertRaises(FieldError, list, qs)\n+\n+class ConcurrentSaveTests(TransactionTestCase):\n+    @skipUnlessDBFeature('test_db_allows_multiple_connections')\n+    def test_concurrent_delete_with_save(self):\n+        \"\"\"\n+        Test fetching, deleting and finally saving an object - we should get\n+        an insert in this case.\n+        \"\"\"\n+        a = Article.objects.create(headline='foo', pub_date=datetime.now())\n+        exceptions = []\n+        def deleter():\n+            try:\n+                # Do not delete a directly - doing so alters its state.\n+                Article.objects.filter(pk=a.pk).delete()\n+                connections[DEFAULT_DB_ALIAS].commit_unless_managed()\n+            except Exception as e:\n+                exceptions.append(e)\n+            finally:\n+                connections[DEFAULT_DB_ALIAS].close()\n+        self.assertEqual(len(exceptions), 0)\n+        t = threading.Thread(target=deleter)\n+        t.start()\n+        t.join()\n+        a.save()\n+        self.assertEqual(Article.objects.get(pk=a.pk).headline, 'foo')"
        },
        {
            "sha": "dc40d2d2e0c60026115cb7ab0c739cad4ee21a15",
            "filename": "tests/model_inheritance/tests.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/6b4834952dcce0db5cbc1534635c00ff8573a6d8/tests%2Fmodel_inheritance%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/6b4834952dcce0db5cbc1534635c00ff8573a6d8/tests%2Fmodel_inheritance%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodel_inheritance%2Ftests.py?ref=6b4834952dcce0db5cbc1534635c00ff8573a6d8",
            "patch": "@@ -294,7 +294,7 @@ def test_update_query_counts(self):\n             rating=4,\n             chef=c\n         )\n-        with self.assertNumQueries(6):\n+        with self.assertNumQueries(3):\n             ir.save()\n \n     def test_update_parent_filtering(self):"
        },
        {
            "sha": "e09e81d93d037bbb67930312ef9a9c724fd08202",
            "filename": "tests/transactions_regress/models.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/6b4834952dcce0db5cbc1534635c00ff8573a6d8/tests%2Ftransactions_regress%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/6b4834952dcce0db5cbc1534635c00ff8573a6d8/tests%2Ftransactions_regress%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions_regress%2Fmodels.py?ref=6b4834952dcce0db5cbc1534635c00ff8573a6d8",
            "patch": "@@ -4,6 +4,8 @@\n class Mod(models.Model):\n     fld = models.IntegerField()\n \n+class SubMod(Mod):\n+    cnt = models.IntegerField(unique=True)\n \n class M2mA(models.Model):\n     others = models.ManyToManyField('M2mB')"
        },
        {
            "sha": "e320f761699c4d73b4bec6ebde25956d4aca0388",
            "filename": "tests/transactions_regress/tests.py",
            "status": "modified",
            "additions": 21,
            "deletions": 3,
            "changes": 24,
            "blob_url": "https://github.com/django/django/blob/6b4834952dcce0db5cbc1534635c00ff8573a6d8/tests%2Ftransactions_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/6b4834952dcce0db5cbc1534635c00ff8573a6d8/tests%2Ftransactions_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Ftransactions_regress%2Ftests.py?ref=6b4834952dcce0db5cbc1534635c00ff8573a6d8",
            "patch": "@@ -1,15 +1,33 @@\n from __future__ import absolute_import\n \n-from django.db import connection, connections, transaction, DEFAULT_DB_ALIAS, DatabaseError\n+from django.db import (connection, connections, transaction, DEFAULT_DB_ALIAS, DatabaseError,\n+                       IntegrityError)\n from django.db.transaction import commit_on_success, commit_manually, TransactionManagementError\n from django.test import TransactionTestCase, skipUnlessDBFeature\n from django.test.utils import override_settings\n from django.utils.unittest import skipIf, skipUnless\n \n from transactions.tests import IgnorePendingDeprecationWarningsMixin\n \n-from .models import Mod, M2mA, M2mB\n-\n+from .models import Mod, M2mA, M2mB, SubMod\n+\n+class ModelInheritanceTests(TransactionTestCase):\n+    def test_save(self):\n+        # First, create a SubMod, then try to save another with conflicting\n+        # cnt field. The problem was that transactions were committed after\n+        # every parent save when not in managed transaction. As the cnt\n+        # conflict is in the second model, we can check if the first save\n+        # was committed or not.\n+        SubMod(fld=1, cnt=1).save()\n+        # We should have committed the transaction for the above - assert this.\n+        connection.rollback()\n+        self.assertEqual(SubMod.objects.count(), 1)\n+        try:\n+            SubMod(fld=2, cnt=1).save()\n+        except IntegrityError:\n+            connection.rollback()\n+        self.assertEqual(SubMod.objects.count(), 1)\n+        self.assertEqual(Mod.objects.count(), 1)\n \n class TestTransactionClosing(IgnorePendingDeprecationWarningsMixin, TransactionTestCase):\n     \"\"\""
        }
    ],
    "stats": {
        "total": 292,
        "additions": 179,
        "deletions": 113
    }
}