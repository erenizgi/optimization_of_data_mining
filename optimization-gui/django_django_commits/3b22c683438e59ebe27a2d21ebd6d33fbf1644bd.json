{
    "author": "jphalip",
    "message": "Fixed #12467 -- Made the model data validation for `DateField` and `DateTimeField` more useful by actually telling what was the value that failed. Also did a bit of PEP8 cleanup in the area. Thanks to knutin for the report, to raulcd for the initial patch and to charettes for the review.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16966 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "3b22c683438e59ebe27a2d21ebd6d33fbf1644bd",
    "files": [
        {
            "sha": "7e119c2f868a6ab49bd0c1934db14b12cc773e08",
            "filename": "django/db/models/fields/__init__.py",
            "status": "modified",
            "additions": 141,
            "deletions": 71,
            "changes": 212,
            "blob_url": "https://github.com/django/django/blob/3b22c683438e59ebe27a2d21ebd6d33fbf1644bd/django%2Fdb%2Fmodels%2Ffields%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/3b22c683438e59ebe27a2d21ebd6d33fbf1644bd/django%2Fdb%2Fmodels%2Ffields%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2F__init__.py?ref=3b22c683438e59ebe27a2d21ebd6d33fbf1644bd",
            "patch": "@@ -22,7 +22,8 @@\n class NOT_PROVIDED:\n     pass\n \n-# The values to use for \"blank\" in SelectFields. Will be appended to the start of most \"choices\" lists.\n+# The values to use for \"blank\" in SelectFields. Will be appended to the start\n+# of most \"choices\" lists.\n BLANK_CHOICE_DASH = [(\"\", \"---------\")]\n BLANK_CHOICE_NONE = [(\"\", \"None\")]\n \n@@ -61,7 +62,8 @@ class Field(object):\n         'invalid_choice': _(u'Value %r is not a valid choice.'),\n         'null': _(u'This field cannot be null.'),\n         'blank': _(u'This field cannot be blank.'),\n-        'unique': _(u'%(model_name)s with this %(field_label)s already exists.'),\n+        'unique': _(u'%(model_name)s with this %(field_label)s '\n+                    u'already exists.'),\n     }\n \n     # Generic field type description, usually overriden by subclasses\n@@ -85,21 +87,24 @@ def __init__(self, verbose_name=None, name=None, primary_key=False,\n         self.blank, self.null = blank, null\n         # Oracle treats the empty string ('') as null, so coerce the null\n         # option whenever '' is a possible value.\n-        if self.empty_strings_allowed and connection.features.interprets_empty_strings_as_nulls:\n+        if (self.empty_strings_allowed and\n+            connection.features.interprets_empty_strings_as_nulls):\n             self.null = True\n         self.rel = rel\n         self.default = default\n         self.editable = editable\n         self.serialize = serialize\n-        self.unique_for_date, self.unique_for_month = unique_for_date, unique_for_month\n+        self.unique_for_date, self.unique_for_month = (unique_for_date,\n+                                                       unique_for_month)\n         self.unique_for_year = unique_for_year\n         self._choices = choices or []\n         self.help_text = help_text\n         self.db_column = db_column\n         self.db_tablespace = db_tablespace or settings.DEFAULT_INDEX_TABLESPACE\n         self.auto_created = auto_created\n \n-        # Set db_index to True if the field has a relationship and doesn't explicitly set db_index.\n+        # Set db_index to True if the field has a relationship and doesn't\n+        # explicitly set db_index.\n         self.db_index = db_index\n \n         # Adjust the appropriate creation counter, and save our local copy.\n@@ -169,13 +174,15 @@ def validate(self, value, model_instance):\n         if self._choices and value:\n             for option_key, option_value in self.choices:\n                 if isinstance(option_value, (list, tuple)):\n-                    # This is an optgroup, so look inside the group for options.\n+                    # This is an optgroup, so look inside the group for\n+                    # options.\n                     for optgroup_key, optgroup_value in option_value:\n                         if value == optgroup_key:\n                             return\n                 elif value == option_key:\n                     return\n-            raise exceptions.ValidationError(self.error_messages['invalid_choice'] % value)\n+            raise exceptions.ValidationError(\n+                self.error_messages['invalid_choice'] % value)\n \n         if value is None and not self.null:\n             raise exceptions.ValidationError(self.error_messages['null'])\n@@ -185,9 +192,9 @@ def validate(self, value, model_instance):\n \n     def clean(self, value, model_instance):\n         \"\"\"\n-        Convert the value's type and run validation. Validation errors from to_python\n-        and validate are propagated. The correct value is returned if no error is\n-        raised.\n+        Convert the value's type and run validation. Validation errors\n+        from to_python and validate are propagated. The correct value is\n+        returned if no error is raised.\n         \"\"\"\n         value = self.to_python(value)\n         self.validate(value, model_instance)\n@@ -205,9 +212,9 @@ def db_type(self, connection):\n         #\n         # A Field class can implement the get_internal_type() method to specify\n         # which *preexisting* Django Field class it's most similar to -- i.e.,\n-        # a custom field might be represented by a TEXT column type, which is the\n-        # same as the TextField Django field type, which means the custom field's\n-        # get_internal_type() returns 'TextField'.\n+        # a custom field might be represented by a TEXT column type, which is\n+        # the same as the TextField Django field type, which means the custom\n+        # field's get_internal_type() returns 'TextField'.\n         #\n         # But the limitation of the get_internal_type() / data_types approach\n         # is that it cannot handle database column types that aren't already\n@@ -216,7 +223,8 @@ def db_type(self, connection):\n         # exactly which wacky database column type you want to use.\n         data = DictWrapper(self.__dict__, connection.ops.quote_name, \"qn_\")\n         try:\n-            return connection.creation.data_types[self.get_internal_type()] % data\n+            return (connection.creation.data_types[self.get_internal_type()]\n+                    % data)\n         except KeyError:\n             return None\n \n@@ -236,7 +244,8 @@ def contribute_to_class(self, cls, name):\n         self.model = cls\n         cls._meta.add_field(self)\n         if self.choices:\n-            setattr(cls, 'get_%s_display' % self.name, curry(cls._get_FIELD_display, field=self))\n+            setattr(cls, 'get_%s_display' % self.name,\n+                    curry(cls._get_FIELD_display, field=self))\n \n     def get_attname(self):\n         return self.name\n@@ -253,11 +262,15 @@ def get_internal_type(self):\n         return self.__class__.__name__\n \n     def pre_save(self, model_instance, add):\n-        \"Returns field's value just before saving.\"\n+        \"\"\"\n+        Returns field's value just before saving.\n+        \"\"\"\n         return getattr(model_instance, self.attname)\n \n     def get_prep_value(self, value):\n-        \"Perform preliminary non-db specific value checks and conversions.\"\n+        \"\"\"\n+        Perform preliminary non-db specific value checks and conversions.\n+        \"\"\"\n         return value\n \n     def get_db_prep_value(self, value, connection, prepared=False):\n@@ -272,11 +285,16 @@ def get_db_prep_value(self, value, connection, prepared=False):\n         return value\n \n     def get_db_prep_save(self, value, connection):\n-        \"Returns field's value prepared for saving into a database.\"\n-        return self.get_db_prep_value(value, connection=connection, prepared=False)\n+        \"\"\"\n+        Returns field's value prepared for saving into a database.\n+        \"\"\"\n+        return self.get_db_prep_value(value, connection=connection,\n+                                      prepared=False)\n \n     def get_prep_lookup(self, lookup_type, value):\n-        \"Perform preliminary non-db specific lookup checks and conversions\"\n+        \"\"\"\n+        Perform preliminary non-db specific lookup checks and conversions\n+        \"\"\"\n         if hasattr(value, 'prepare'):\n             return value.prepare()\n         if hasattr(value, '_prepare'):\n@@ -296,12 +314,16 @@ def get_prep_lookup(self, lookup_type, value):\n             try:\n                 return int(value)\n             except ValueError:\n-                raise ValueError(\"The __year lookup type requires an integer argument\")\n+                raise ValueError(\"The __year lookup type requires an integer \"\n+                                 \"argument\")\n \n         raise TypeError(\"Field has invalid lookup: %s\" % lookup_type)\n \n-    def get_db_prep_lookup(self, lookup_type, value, connection, prepared=False):\n-        \"Returns field's value prepared for database lookup.\"\n+    def get_db_prep_lookup(self, lookup_type, value, connection,\n+                           prepared=False):\n+        \"\"\"\n+        Returns field's value prepared for database lookup.\n+        \"\"\"\n         if not prepared:\n             value = self.get_prep_lookup(lookup_type, value)\n         if hasattr(value, 'get_compiler'):\n@@ -317,12 +339,15 @@ def get_db_prep_lookup(self, lookup_type, value, connection, prepared=False):\n                 sql, params = value._as_sql(connection=connection)\n             return QueryWrapper(('(%s)' % sql), params)\n \n-        if lookup_type in ('regex', 'iregex', 'month', 'day', 'week_day', 'search'):\n+        if lookup_type in ('regex', 'iregex', 'month', 'day', 'week_day',\n+                           'search'):\n             return [value]\n         elif lookup_type in ('exact', 'gt', 'gte', 'lt', 'lte'):\n-            return [self.get_db_prep_value(value, connection=connection, prepared=prepared)]\n+            return [self.get_db_prep_value(value, connection=connection,\n+                                           prepared=prepared)]\n         elif lookup_type in ('range', 'in'):\n-            return [self.get_db_prep_value(v, connection=connection, prepared=prepared) for v in value]\n+            return [self.get_db_prep_value(v, connection=connection,\n+                                           prepared=prepared) for v in value]\n         elif lookup_type in ('contains', 'icontains'):\n             return [\"%%%s%%\" % connection.ops.prep_for_like_query(value)]\n         elif lookup_type == 'iexact':\n@@ -340,16 +365,21 @@ def get_db_prep_lookup(self, lookup_type, value, connection, prepared=False):\n                 return connection.ops.year_lookup_bounds(value)\n \n     def has_default(self):\n-        \"Returns a boolean of whether this field has a default value.\"\n+        \"\"\"\n+        Returns a boolean of whether this field has a default value.\n+        \"\"\"\n         return self.default is not NOT_PROVIDED\n \n     def get_default(self):\n-        \"Returns the default value for this field.\"\n+        \"\"\"\n+        Returns the default value for this field.\n+        \"\"\"\n         if self.has_default():\n             if callable(self.default):\n                 return self.default()\n             return force_unicode(self.default, strings_only=True)\n-        if not self.empty_strings_allowed or (self.null and not connection.features.interprets_empty_strings_as_nulls):\n+        if (not self.empty_strings_allowed or (self.null and\n+                   not connection.features.interprets_empty_strings_as_nulls)):\n             return None\n         return \"\"\n \n@@ -364,16 +394,24 @@ def get_choices(self, include_blank=True, blank_choice=BLANK_CHOICE_DASH):\n             return first_choice + list(self.choices)\n         rel_model = self.rel.to\n         if hasattr(self.rel, 'get_related_field'):\n-            lst = [(getattr(x, self.rel.get_related_field().attname), smart_unicode(x)) for x in rel_model._default_manager.complex_filter(self.rel.limit_choices_to)]\n+            lst = [(getattr(x, self.rel.get_related_field().attname),\n+                        smart_unicode(x))\n+                   for x in rel_model._default_manager.complex_filter(\n+                       self.rel.limit_choices_to)]\n         else:\n-            lst = [(x._get_pk_val(), smart_unicode(x)) for x in rel_model._default_manager.complex_filter(self.rel.limit_choices_to)]\n+            lst = [(x._get_pk_val(), smart_unicode(x))\n+                   for x in rel_model._default_manager.complex_filter(\n+                       self.rel.limit_choices_to)]\n         return first_choice + lst\n \n     def get_choices_default(self):\n         return self.get_choices()\n \n-    def get_flatchoices(self, include_blank=True, blank_choice=BLANK_CHOICE_DASH):\n-        \"Returns flattened choices with a default blank choice included.\"\n+    def get_flatchoices(self, include_blank=True,\n+                        blank_choice=BLANK_CHOICE_DASH):\n+        \"\"\"\n+        Returns flattened choices with a default blank choice included.\n+        \"\"\"\n         first_choice = include_blank and blank_choice or []\n         return first_choice + list(self.flatchoices)\n \n@@ -416,8 +454,12 @@ def save_form_data(self, instance, data):\n         setattr(instance, self.name, data)\n \n     def formfield(self, form_class=forms.CharField, **kwargs):\n-        \"Returns a django.forms.Field instance for this database Field.\"\n-        defaults = {'required': not self.blank, 'label': capfirst(self.verbose_name), 'help_text': self.help_text}\n+        \"\"\"\n+        Returns a django.forms.Field instance for this database Field.\n+        \"\"\"\n+        defaults = {'required': not self.blank,\n+                    'label': capfirst(self.verbose_name),\n+                    'help_text': self.help_text}\n         if self.has_default():\n             if callable(self.default):\n                 defaults['initial'] = self.default\n@@ -426,7 +468,8 @@ def formfield(self, form_class=forms.CharField, **kwargs):\n                 defaults['initial'] = self.get_default()\n         if self.choices:\n             # Fields with choices get special treatment.\n-            include_blank = self.blank or not (self.has_default() or 'initial' in kwargs)\n+            include_blank = (self.blank or\n+                             not (self.has_default() or 'initial' in kwargs))\n             defaults['choices'] = self.get_choices(include_blank=include_blank)\n             defaults['coerce'] = self.to_python\n             if self.null:\n@@ -444,7 +487,9 @@ def formfield(self, form_class=forms.CharField, **kwargs):\n         return form_class(**defaults)\n \n     def value_from_object(self, obj):\n-        \"Returns the value of this field in the given model instance.\"\n+        \"\"\"\n+        Returns the value of this field in the given model instance.\n+        \"\"\"\n         return getattr(obj, self.attname)\n \n     def __repr__(self):\n@@ -465,7 +510,8 @@ class AutoField(Field):\n         'invalid': _(u\"'%s' value must be an integer.\"),\n     }\n     def __init__(self, *args, **kwargs):\n-        assert kwargs.get('primary_key', False) is True, \"%ss must have primary_key=True.\" % self.__class__.__name__\n+        assert (kwargs.get('primary_key', False) is True,\n+                \"%ss must have primary_key=True.\" % self.__class__.__name__)\n         kwargs['blank'] = True\n         Field.__init__(self, *args, **kwargs)\n \n@@ -490,7 +536,8 @@ def get_prep_value(self, value):\n         return int(value)\n \n     def contribute_to_class(self, cls, name):\n-        assert not cls._meta.has_auto_field, \"A model can't have more than one AutoField.\"\n+        assert (not cls._meta.has_auto_field,\n+                \"A model can't have more than one AutoField.\")\n         super(AutoField, self).contribute_to_class(cls, name)\n         cls._meta.has_auto_field = True\n         cls._meta.auto_field = self\n@@ -543,8 +590,10 @@ def formfield(self, **kwargs):\n         # Unlike most fields, BooleanField figures out include_blank from\n         # self.null instead of self.blank.\n         if self.choices:\n-            include_blank = self.null or not (self.has_default() or 'initial' in kwargs)\n-            defaults = {'choices': self.get_choices(include_blank=include_blank)}\n+            include_blank = (self.null or\n+                             not (self.has_default() or 'initial' in kwargs))\n+            defaults = {'choices': self.get_choices(\n+                                       include_blank=include_blank)}\n         else:\n             defaults = {'form_class': forms.BooleanField}\n         defaults.update(kwargs)\n@@ -597,12 +646,16 @@ class DateField(Field):\n \n     empty_strings_allowed = False\n     default_error_messages = {\n-        'invalid': _('Enter a valid date in YYYY-MM-DD format.'),\n-        'invalid_date': _('Invalid date: %s'),\n+        'invalid': _(u\"'%s' value has an invalid date format. It must be \"\n+                     u\"in YYYY-MM-DD format.\"),\n+        'invalid_date': _(u\"'%s' value has the correct format (YYYY-MM-DD) \"\n+                          u\"but it is an invalid date.\"),\n     }\n-    def __init__(self, verbose_name=None, name=None, auto_now=False, auto_now_add=False, **kwargs):\n+    def __init__(self, verbose_name=None, name=None, auto_now=False,\n+                 auto_now_add=False, **kwargs):\n         self.auto_now, self.auto_now_add = auto_now, auto_now_add\n-        #HACKs : auto_now_add/auto_now should be done as a default or a pre_save.\n+        # HACKs : auto_now_add/auto_now should be done as a default or a\n+        # pre_save.\n         if auto_now or auto_now_add:\n             kwargs['editable'] = False\n             kwargs['blank'] = True\n@@ -620,7 +673,8 @@ def to_python(self, value):\n             return value\n \n         if not ansi_date_re.search(value):\n-            raise exceptions.ValidationError(self.error_messages['invalid'])\n+            msg = self.error_messages['invalid'] % str(value)\n+            raise exceptions.ValidationError(msg)\n         # Now that we have the date string in YYYY-MM-DD format, check to make\n         # sure it's a valid date.\n         # We could use time.strptime here and catch errors, but datetime.date\n@@ -629,7 +683,7 @@ def to_python(self, value):\n         try:\n             return datetime.date(year, month, day)\n         except ValueError, e:\n-            msg = self.error_messages['invalid_date'] % _(str(e))\n+            msg = self.error_messages['invalid_date'] % str(value)\n             raise exceptions.ValidationError(msg)\n \n     def pre_save(self, model_instance, add):\n@@ -644,9 +698,11 @@ def contribute_to_class(self, cls, name):\n         super(DateField,self).contribute_to_class(cls, name)\n         if not self.null:\n             setattr(cls, 'get_next_by_%s' % self.name,\n-                curry(cls._get_next_or_previous_by_FIELD, field=self, is_next=True))\n+                curry(cls._get_next_or_previous_by_FIELD, field=self,\n+                      is_next=True))\n             setattr(cls, 'get_previous_by_%s' % self.name,\n-                curry(cls._get_next_or_previous_by_FIELD, field=self, is_next=False))\n+                curry(cls._get_next_or_previous_by_FIELD, field=self,\n+                      is_next=False))\n \n     def get_prep_lookup(self, lookup_type, value):\n         # For \"__month\", \"__day\", and \"__week_day\" lookups, convert the value\n@@ -679,7 +735,9 @@ def formfield(self, **kwargs):\n \n class DateTimeField(DateField):\n     default_error_messages = {\n-        'invalid': _(u'Enter a valid date/time in YYYY-MM-DD HH:MM[:ss[.uuuuuu]] format.'),\n+        'invalid': _(u\"'%s' value either has an invalid valid format (The \"\n+                     u\"format must be YYYY-MM-DD HH:MM[:ss[.uuuuuu]]) or is \"\n+                     u\"an invalid date/time.\"),\n     }\n     description = _(\"Date (with time)\")\n \n@@ -702,24 +760,26 @@ def to_python(self, value):\n                 value, usecs = value.split('.')\n                 usecs = int(usecs)\n             except ValueError:\n-                raise exceptions.ValidationError(self.error_messages['invalid'])\n+                raise exceptions.ValidationError(\n+                    self.error_messages['invalid'] % str(value))\n         else:\n             usecs = 0\n         kwargs = {'microsecond': usecs}\n         try: # Seconds are optional, so try converting seconds first.\n-            return datetime.datetime(*time.strptime(value, '%Y-%m-%d %H:%M:%S')[:6],\n-                                     **kwargs)\n+            return datetime.datetime(\n+                *time.strptime(value, '%Y-%m-%d %H:%M:%S')[:6], **kwargs)\n \n         except ValueError:\n             try: # Try without seconds.\n-                return datetime.datetime(*time.strptime(value, '%Y-%m-%d %H:%M')[:5],\n-                                         **kwargs)\n+                return datetime.datetime(\n+                    *time.strptime(value, '%Y-%m-%d %H:%M')[:5], **kwargs)\n             except ValueError: # Try without hour/minutes/seconds.\n                 try:\n-                    return datetime.datetime(*time.strptime(value, '%Y-%m-%d')[:3],\n-                                             **kwargs)\n+                    return datetime.datetime(\n+                        *time.strptime(value, '%Y-%m-%d')[:3], **kwargs)\n                 except ValueError:\n-                    raise exceptions.ValidationError(self.error_messages['invalid'])\n+                    raise exceptions.ValidationError(\n+                        self.error_messages['invalid'] % str(value))\n \n     def pre_save(self, model_instance, add):\n         if self.auto_now or (self.auto_now_add and add):\n@@ -759,7 +819,8 @@ class DecimalField(Field):\n     }\n     description = _(\"Decimal number\")\n \n-    def __init__(self, verbose_name=None, name=None, max_digits=None, decimal_places=None, **kwargs):\n+    def __init__(self, verbose_name=None, name=None, max_digits=None,\n+                 decimal_places=None, **kwargs):\n         self.max_digits, self.decimal_places = max_digits, decimal_places\n         Field.__init__(self, verbose_name, name, **kwargs)\n \n@@ -820,7 +881,8 @@ def __init__(self, *args, **kwargs):\n         CharField.__init__(self, *args, **kwargs)\n \n     def formfield(self, **kwargs):\n-        # As with CharField, this will cause email validation to be performed twice\n+        # As with CharField, this will cause email validation to be performed\n+        # twice.\n         defaults = {\n             'form_class': forms.EmailField,\n         }\n@@ -830,7 +892,8 @@ def formfield(self, **kwargs):\n class FilePathField(Field):\n     description = _(\"File path\")\n \n-    def __init__(self, verbose_name=None, name=None, path='', match=None, recursive=False, **kwargs):\n+    def __init__(self, verbose_name=None, name=None, path='', match=None,\n+                 recursive=False, **kwargs):\n         self.path, self.match, self.recursive = path, match, recursive\n         kwargs['max_length'] = kwargs.get('max_length', 100)\n         Field.__init__(self, verbose_name, name, **kwargs)\n@@ -890,9 +953,9 @@ def get_prep_value(self, value):\n         return int(value)\n \n     def get_prep_lookup(self, lookup_type, value):\n-        if (lookup_type == 'gte' or lookup_type == 'lt') \\\n-           and isinstance(value, float):\n-                value = math.ceil(value)\n+        if ((lookup_type == 'gte' or lookup_type == 'lt')\n+            and isinstance(value, float)):\n+            value = math.ceil(value)\n         return super(IntegerField, self).get_prep_lookup(lookup_type, value)\n \n     def get_internal_type(self):\n@@ -1019,7 +1082,8 @@ def get_prep_lookup(self, lookup_type, value):\n         # constructing the list.\n         if value in ('1', '0'):\n             value = bool(int(value))\n-        return super(NullBooleanField, self).get_prep_lookup(lookup_type, value)\n+        return super(NullBooleanField, self).get_prep_lookup(lookup_type,\n+                                                             value)\n \n     def get_prep_value(self, value):\n         if value is None:\n@@ -1102,7 +1166,8 @@ class TimeField(Field):\n     default_error_messages = {\n         'invalid': _('Enter a valid time in HH:MM[:ss[.uuuuuu]] format.'),\n     }\n-    def __init__(self, verbose_name=None, name=None, auto_now=False, auto_now_add=False, **kwargs):\n+    def __init__(self, verbose_name=None, name=None, auto_now=False,\n+                 auto_now_add=False, **kwargs):\n         self.auto_now, self.auto_now_add = auto_now, auto_now_add\n         if auto_now or auto_now_add:\n             kwargs['editable'] = False\n@@ -1130,7 +1195,8 @@ def to_python(self, value):\n                 value, usecs = value.split('.')\n                 usecs = int(usecs)\n             except ValueError:\n-                raise exceptions.ValidationError(self.error_messages['invalid'])\n+                raise exceptions.ValidationError(\n+                    self.error_messages['invalid'])\n         else:\n             usecs = 0\n         kwargs = {'microsecond': usecs}\n@@ -1143,7 +1209,8 @@ def to_python(self, value):\n                 return datetime.time(*time.strptime(value, '%H:%M')[3:5],\n                                          **kwargs)\n             except ValueError:\n-                raise exceptions.ValidationError(self.error_messages['invalid'])\n+                raise exceptions.ValidationError(\n+                    self.error_messages['invalid'])\n \n     def pre_save(self, model_instance, add):\n         if self.auto_now or (self.auto_now_add and add):\n@@ -1178,13 +1245,16 @@ def formfield(self, **kwargs):\n class URLField(CharField):\n     description = _(\"URL\")\n \n-    def __init__(self, verbose_name=None, name=None, verify_exists=False, **kwargs):\n+    def __init__(self, verbose_name=None, name=None, verify_exists=False,\n+                 **kwargs):\n         kwargs['max_length'] = kwargs.get('max_length', 200)\n         CharField.__init__(self, verbose_name, name, **kwargs)\n-        self.validators.append(validators.URLValidator(verify_exists=verify_exists))\n+        self.validators.append(\n+            validators.URLValidator(verify_exists=verify_exists))\n \n     def formfield(self, **kwargs):\n-        # As with CharField, this will cause URL validation to be performed twice\n+        # As with CharField, this will cause URL validation to be performed\n+        # twice.\n         defaults = {\n             'form_class': forms.URLField,\n         }"
        },
        {
            "sha": "43b707e632d10fb33cdcfb44806d60ca68698ead",
            "filename": "tests/modeltests/validation/test_error_messages.py",
            "status": "modified",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/django/django/blob/3b22c683438e59ebe27a2d21ebd6d33fbf1644bd/tests%2Fmodeltests%2Fvalidation%2Ftest_error_messages.py",
            "raw_url": "https://github.com/django/django/raw/3b22c683438e59ebe27a2d21ebd6d33fbf1644bd/tests%2Fmodeltests%2Fvalidation%2Ftest_error_messages.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fvalidation%2Ftest_error_messages.py?ref=3b22c683438e59ebe27a2d21ebd6d33fbf1644bd",
            "patch": "@@ -55,3 +55,59 @@ def test_null_boolean_field_raises_error_message(self):\n         except ValidationError, e:\n             self.assertEqual(e.messages,\n                         [u\"'foo' value must be either None, True or False.\"])\n+\n+    def test_date_field_raises_error_message(self):\n+        f = models.DateField()\n+        self.assertRaises(ValidationError, f.clean, 'foo', None)\n+        try:\n+            f.clean('foo', None)\n+        except ValidationError, e:\n+            self.assertEqual(e.messages, [\n+                u\"'foo' value has an invalid date format. \"\n+                u\"It must be in YYYY-MM-DD format.\"])\n+\n+        self.assertRaises(ValidationError, f.clean, 'aaaa-10-10', None)\n+        try:\n+            f.clean('aaaa-10-10', None)\n+        except ValidationError, e:\n+            self.assertEqual(e.messages, [\n+                u\"'aaaa-10-10' value has an invalid date format. \"\n+                u\"It must be in YYYY-MM-DD format.\"])\n+\n+        self.assertRaises(ValidationError, f.clean, '2011-13-10', None)\n+        try:\n+            f.clean('2011-13-10', None)\n+        except ValidationError, e:\n+            self.assertEqual(e.messages, [\n+                u\"'2011-13-10' value has the correct format (YYYY-MM-DD) \"\n+                u\"but it is an invalid date.\"])\n+\n+        self.assertRaises(ValidationError, f.clean, '2011-10-32', None)\n+        try:\n+            f.clean('2011-10-32', None)\n+        except ValidationError, e:\n+            self.assertEqual(e.messages, [\n+                u\"'2011-10-32' value has the correct format (YYYY-MM-DD) \"\n+                u\"but it is an invalid date.\"])\n+\n+    def test_datetime_field_raises_error_message(self):\n+        f = models.DateTimeField()\n+        # Wrong format\n+        self.assertRaises(ValidationError, f.clean, 'foo', None)\n+        try:\n+            f.clean('foo', None)\n+        except ValidationError, e:\n+            self.assertEqual(e.messages, [\n+                u\"'foo' value either has an invalid valid format \"\n+                u\"(The format must be YYYY-MM-DD HH:MM[:ss[.uuuuuu]]) \"\n+                u\"or is an invalid date/time.\"])\n+        self.assertRaises(ValidationError, f.clean,\n+                          '2011-10-32 10:10', None)\n+        # Correct format but invalid date/time\n+        try:\n+            f.clean('2011-10-32 10:10', None)\n+        except ValidationError, e:\n+            self.assertEqual(e.messages, [\n+                u\"'2011-10-32 10:10' value either has an invalid valid format \"\n+                u\"(The format must be YYYY-MM-DD HH:MM[:ss[.uuuuuu]]) \"\n+                u\"or is an invalid date/time.\"])\n\\ No newline at end of file"
        },
        {
            "sha": "5b20df4ef317a960f6bf9059d3ebda9cb1198ce9",
            "filename": "tests/modeltests/validation/tests.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/3b22c683438e59ebe27a2d21ebd6d33fbf1644bd/tests%2Fmodeltests%2Fvalidation%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/3b22c683438e59ebe27a2d21ebd6d33fbf1644bd/tests%2Fmodeltests%2Fvalidation%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fvalidation%2Ftests.py?ref=3b22c683438e59ebe27a2d21ebd6d33fbf1644bd",
            "patch": "@@ -12,7 +12,7 @@\n from modeltests.validation.test_unique import (GetUniqueCheckTests,\n     PerformUniqueChecksTest)\n from modeltests.validation.test_custom_messages import CustomMessagesTest\n-\n+from modeltests.validation.test_error_messages import ValidationMessagesTest\n \n class BaseModelValidationTests(ValidationTestCase):\n "
        }
    ],
    "stats": {
        "total": 270,
        "additions": 198,
        "deletions": 72
    }
}