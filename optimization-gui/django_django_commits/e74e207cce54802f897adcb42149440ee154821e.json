{
    "author": "aaugustin",
    "message": "Fixed #17260 -- Added time zone aware aggregation and lookups.\n\nThanks Carl Meyer for the review.\n\nSquashed commit of the following:\n\ncommit 4f290bdb60b7d8534abf4ca901bd0844612dcbda\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Wed Feb 13 21:21:30 2013 +0100\n\n    Used '0:00' instead of 'UTC' which doesn't always exist in Oracle.\n\n    Thanks Ian Kelly for the suggestion.\n\ncommit 01b6366f3ce67d57a58ca8f25e5be77911748638\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Wed Feb 13 13:38:43 2013 +0100\n\n    Made tzname a parameter of datetime_extract/trunc_sql.\n\n    This is required to work around a bug in Oracle.\n\ncommit 924a144ef8a80ba4daeeafbe9efaa826566e9d02\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Wed Feb 13 14:47:44 2013 +0100\n\n    Added support for parameters in SELECT clauses.\n\ncommit b4351d2890cd1090d3ff2d203fe148937324c935\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Mon Feb 11 22:30:22 2013 +0100\n\n    Documented backwards incompatibilities in the two previous commits.\n\ncommit 91ef84713c81bd455f559dacf790e586d08cacb9\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Mon Feb 11 09:42:31 2013 +0100\n\n    Used QuerySet.datetimes for the admin's date_hierarchy.\n\ncommit 0d0de288a5210fa106cd4350961eb2006535cc5c\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Mon Feb 11 09:29:38 2013 +0100\n\n    Used QuerySet.datetimes in date-based generic views.\n\ncommit 9c0859ff7c0b00734afe7fc15609d43d83215072\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Sun Feb 10 21:43:25 2013 +0100\n\n    Implemented QuerySet.datetimes on Oracle.\n\ncommit 68ab511a4ffbd2b811bf5da174d47e4dd90f28fc\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Sun Feb 10 21:43:14 2013 +0100\n\n    Implemented QuerySet.datetimes on MySQL.\n\ncommit 22d52681d347a8cdf568dc31ed032cbc61d049ef\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Sun Feb 10 21:42:29 2013 +0100\n\n    Implemented QuerySet.datetimes on SQLite.\n\ncommit f6800fd04c93722b45f9236976389e0b2fe436f5\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Sun Feb 10 21:43:03 2013 +0100\n\n    Implemented QuerySet.datetimes on PostgreSQL.\n\ncommit 0c829c23f4cf4d6804cadcc93032dd4c26b8c65e\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Sun Feb 10 21:41:08 2013 +0100\n\n    Added datetime-handling infrastructure in the ORM layers.\n\ncommit 104d82a7778cf3f0f5d03dfa53709c26df45daad\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Mon Feb 11 10:05:55 2013 +0100\n\n    Updated null_queries tests to avoid clashing with the __second lookup.\n\ncommit c01bbb32358201b3ac8cb4291ef87b7612a2b8e6\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Sun Feb 10 23:07:41 2013 +0100\n\n    Updated tests of .dates().\n\n    Replaced .dates() by .datetimes() for DateTimeFields.\n    Replaced dates with datetimes in the expected output for DateFields.\n\ncommit 50fb7a52462fecf0127b38e7f3df322aeb287c43\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Sun Feb 10 21:40:09 2013 +0100\n\n    Updated and added tests for QuerySet.datetimes.\n\ncommit a8451a5004c437190e264667b1e6fb8acc3c1eeb\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Sun Feb 10 22:34:46 2013 +0100\n\n    Documented the new time lookups and updated the date lookups.\n\ncommit 29413eab2bd1d5e004598900c0dadc0521bbf4d3\nAuthor: Aymeric Augustin <aymeric.augustin@m4x.org>\nDate:   Sun Feb 10 16:15:49 2013 +0100\n\n    Documented QuerySet.datetimes and updated QuerySet.dates.",
    "sha": "e74e207cce54802f897adcb42149440ee154821e",
    "files": [
        {
            "sha": "c5bcad342bef1180a2ed1e2f82c41c0ef8f74e5b",
            "filename": "django/contrib/admin/templatetags/admin_list.py",
            "status": "modified",
            "additions": 9,
            "deletions": 5,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fadmin%2Ftemplatetags%2Fadmin_list.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fadmin%2Ftemplatetags%2Fadmin_list.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fadmin%2Ftemplatetags%2Fadmin_list.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -292,6 +292,8 @@ def date_hierarchy(cl):\n     \"\"\"\n     if cl.date_hierarchy:\n         field_name = cl.date_hierarchy\n+        field = cl.opts.get_field_by_name(field_name)[0]\n+        dates_or_datetimes = 'datetimes' if isinstance(field, models.DateTimeField) else 'dates'\n         year_field = '%s__year' % field_name\n         month_field = '%s__month' % field_name\n         day_field = '%s__day' % field_name\n@@ -323,7 +325,8 @@ def date_hierarchy(cl):\n                 'choices': [{'title': capfirst(formats.date_format(day, 'MONTH_DAY_FORMAT'))}]\n             }\n         elif year_lookup and month_lookup:\n-            days = cl.query_set.filter(**{year_field: year_lookup, month_field: month_lookup}).dates(field_name, 'day')\n+            days = cl.query_set.filter(**{year_field: year_lookup, month_field: month_lookup})\n+            days = getattr(days, dates_or_datetimes)(field_name, 'day')\n             return {\n                 'show': True,\n                 'back': {\n@@ -336,11 +339,12 @@ def date_hierarchy(cl):\n                 } for day in days]\n             }\n         elif year_lookup:\n-            months = cl.query_set.filter(**{year_field: year_lookup}).dates(field_name, 'month')\n+            months = cl.query_set.filter(**{year_field: year_lookup})\n+            months = getattr(months, dates_or_datetimes)(field_name, 'month')\n             return {\n-                'show' : True,\n+                'show': True,\n                 'back': {\n-                    'link' : link({}),\n+                    'link': link({}),\n                     'title': _('All dates')\n                 },\n                 'choices': [{\n@@ -349,7 +353,7 @@ def date_hierarchy(cl):\n                 } for month in months]\n             }\n         else:\n-            years = cl.query_set.dates(field_name, 'year')\n+            years = getattr(cl.query_set, dates_or_datetimes)(field_name, 'year')\n             return {\n                 'show': True,\n                 'choices': [{"
        },
        {
            "sha": "f4654eff840159456f606f272e9eb97499a5357a",
            "filename": "django/contrib/gis/db/backends/mysql/compiler.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fmysql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fmysql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fmysql%2Fcompiler.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -30,3 +30,6 @@ class SQLAggregateCompiler(compiler.SQLAggregateCompiler, GeoSQLCompiler):\n \n class SQLDateCompiler(compiler.SQLDateCompiler, GeoSQLCompiler):\n     pass\n+\n+class SQLDateTimeCompiler(compiler.SQLDateTimeCompiler, GeoSQLCompiler):\n+    pass"
        },
        {
            "sha": "14402ec0a319e2ec4df03f8bd194f37db8b36330",
            "filename": "django/contrib/gis/db/backends/mysql/operations.py",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fmysql%2Foperations.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fmysql%2Foperations.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fmysql%2Foperations.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -56,12 +56,13 @@ def spatial_lookup_sql(self, lvalue, lookup_type, value, field, qn):\n \n         lookup_info = self.geometry_functions.get(lookup_type, False)\n         if lookup_info:\n-            return \"%s(%s, %s)\" % (lookup_info, geo_col,\n-                                   self.get_geom_placeholder(value, field.srid))\n+            sql = \"%s(%s, %s)\" % (lookup_info, geo_col,\n+                                  self.get_geom_placeholder(value, field.srid))\n+            return sql, []\n \n         # TODO: Is this really necessary? MySQL can't handle NULL geometries\n         #  in its spatial indexes anyways.\n         if lookup_type == 'isnull':\n-            return \"%s IS %sNULL\" % (geo_col, (not value and 'NOT ' or ''))\n+            return \"%s IS %sNULL\" % (geo_col, ('' if value else 'NOT ')), []\n \n         raise TypeError(\"Got invalid lookup_type: %s\" % repr(lookup_type))"
        },
        {
            "sha": "d00af7fa7189f4958cccc69aa585a4ed69c75a69",
            "filename": "django/contrib/gis/db/backends/oracle/compiler.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Foracle%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Foracle%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Foracle%2Fcompiler.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -20,3 +20,6 @@ class SQLAggregateCompiler(compiler.SQLAggregateCompiler, GeoSQLCompiler):\n \n class SQLDateCompiler(compiler.SQLDateCompiler, GeoSQLCompiler):\n     pass\n+\n+class SQLDateTimeCompiler(compiler.SQLDateTimeCompiler, GeoSQLCompiler):\n+    pass"
        },
        {
            "sha": "18697ac8c0ef444131260915f9476e5bf50f27af",
            "filename": "django/contrib/gis/db/backends/oracle/operations.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Foracle%2Foperations.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Foracle%2Foperations.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Foracle%2Foperations.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -262,7 +262,7 @@ def spatial_lookup_sql(self, lvalue, lookup_type, value, field, qn):\n                 return lookup_info.as_sql(geo_col, self.get_geom_placeholder(field, value))\n         elif lookup_type == 'isnull':\n             # Handling 'isnull' lookup type\n-            return \"%s IS %sNULL\" % (geo_col, (not value and 'NOT ' or ''))\n+            return \"%s IS %sNULL\" % (geo_col, ('' if value else 'NOT ')), []\n \n         raise TypeError(\"Got invalid lookup_type: %s\" % repr(lookup_type))\n \n@@ -288,7 +288,7 @@ def geometry_columns(self):\n     def spatial_ref_sys(self):\n         from django.contrib.gis.db.backends.oracle.models import SpatialRefSys\n         return SpatialRefSys\n-    \n+\n     def modify_insert_params(self, placeholders, params):\n         \"\"\"Drop out insert parameters for NULL placeholder. Needed for Oracle Spatial\n         backend due to #10888"
        },
        {
            "sha": "fe903434116fb1e3f367589db964e24d528d968f",
            "filename": "django/contrib/gis/db/backends/postgis/operations.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fpostgis%2Foperations.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fpostgis%2Foperations.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fpostgis%2Foperations.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -560,7 +560,7 @@ def spatial_lookup_sql(self, lvalue, lookup_type, value, field, qn):\n \n         elif lookup_type == 'isnull':\n             # Handling 'isnull' lookup type\n-            return \"%s IS %sNULL\" % (geo_col, (not value and 'NOT ' or ''))\n+            return \"%s IS %sNULL\" % (geo_col, ('' if value else 'NOT ')), []\n \n         raise TypeError(\"Got invalid lookup_type: %s\" % repr(lookup_type))\n "
        },
        {
            "sha": "d2d75c1fff4a9972331674fe09edadde95e15eb0",
            "filename": "django/contrib/gis/db/backends/spatialite/operations.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fspatialite%2Foperations.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fspatialite%2Foperations.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fspatialite%2Foperations.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -358,7 +358,7 @@ def spatial_lookup_sql(self, lvalue, lookup_type, value, field, qn):\n             return op.as_sql(geo_col, self.get_geom_placeholder(field, geom))\n         elif lookup_type == 'isnull':\n             # Handling 'isnull' lookup type\n-            return \"%s IS %sNULL\" % (geo_col, (not value and 'NOT ' or ''))\n+            return \"%s IS %sNULL\" % (geo_col, ('' if value else 'NOT ')), []\n \n         raise TypeError(\"Got invalid lookup_type: %s\" % repr(lookup_type))\n "
        },
        {
            "sha": "2612810659255fa5344ceb6129f44c47da175607",
            "filename": "django/contrib/gis/db/backends/util.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Futil.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Futil.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Futil.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -16,7 +16,7 @@ def __init__(self, function='', operator='', result='', **kwargs):\n         self.extra = kwargs\n \n     def as_sql(self, geo_col, geometry='%s'):\n-        return self.sql_template % self.params(geo_col, geometry)\n+        return self.sql_template % self.params(geo_col, geometry), []\n \n     def params(self, geo_col, geometry):\n         params = {'function' : self.function,"
        },
        {
            "sha": "ae848c0894e19b7c83c22cea63533ae7dda454eb",
            "filename": "django/contrib/gis/db/models/sql/aggregates.py",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fmodels%2Fsql%2Faggregates.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fmodels%2Fsql%2Faggregates.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fdb%2Fmodels%2Fsql%2Faggregates.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -22,27 +22,29 @@ def __init__(self, col, source=None, is_summary=False, tolerance=0.05, **extra):\n             raise ValueError('Geospatial aggregates only allowed on geometry fields.')\n \n     def as_sql(self, qn, connection):\n-        \"Return the aggregate, rendered as SQL.\"\n+        \"Return the aggregate, rendered as SQL with parameters.\"\n \n         if connection.ops.oracle:\n             self.extra['tolerance'] = self.tolerance\n \n+        params = []\n+\n         if hasattr(self.col, 'as_sql'):\n-            field_name = self.col.as_sql(qn, connection)\n+            field_name, params = self.col.as_sql(qn, connection)\n         elif isinstance(self.col, (list, tuple)):\n             field_name = '.'.join([qn(c) for c in self.col])\n         else:\n             field_name = self.col\n \n         sql_template, sql_function = connection.ops.spatial_aggregate_sql(self)\n \n-        params = {\n+        substitutions = {\n             'function': sql_function,\n             'field': field_name\n         }\n-        params.update(self.extra)\n+        substitutions.update(self.extra)\n \n-        return sql_template % params\n+        return sql_template % substitutions, params\n \n class Collect(GeoAggregate):\n     pass"
        },
        {
            "sha": "b488f59362496faac81765142aafa805219b2508",
            "filename": "django/contrib/gis/db/models/sql/compiler.py",
            "status": "modified",
            "additions": 48,
            "deletions": 15,
            "changes": 63,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fdb%2Fmodels%2Fsql%2Fcompiler.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -1,14 +1,16 @@\n+import datetime\n try:\n     from itertools import zip_longest\n except ImportError:\n     from itertools import izip_longest as zip_longest\n \n-from django.utils.six.moves import zip\n-\n-from django.db.backends.util import truncate_name, typecast_timestamp\n+from django.conf import settings\n+from django.db.backends.util import truncate_name, typecast_date, typecast_timestamp\n from django.db.models.sql import compiler\n from django.db.models.sql.constants import MULTI\n from django.utils import six\n+from django.utils.six.moves import zip\n+from django.utils import timezone\n \n SQLCompiler = compiler.SQLCompiler\n \n@@ -31,6 +33,7 @@ def get_columns(self, with_aliases=False):\n         qn2 = self.connection.ops.quote_name\n         result = ['(%s) AS %s' % (self.get_extra_select_format(alias) % col[0], qn2(alias))\n                   for alias, col in six.iteritems(self.query.extra_select)]\n+        params = []\n         aliases = set(self.query.extra_select.keys())\n         if with_aliases:\n             col_aliases = aliases.copy()\n@@ -61,7 +64,9 @@ def get_columns(self, with_aliases=False):\n                         aliases.add(r)\n                         col_aliases.add(col[1])\n                 else:\n-                    result.append(col.as_sql(qn, self.connection))\n+                    col_sql, col_params = col.as_sql(qn, self.connection)\n+                    result.append(col_sql)\n+                    params.extend(col_params)\n \n                     if hasattr(col, 'alias'):\n                         aliases.add(col.alias)\n@@ -74,15 +79,13 @@ def get_columns(self, with_aliases=False):\n             aliases.update(new_aliases)\n \n         max_name_length = self.connection.ops.max_name_length()\n-        result.extend([\n-                '%s%s' % (\n-                    self.get_extra_select_format(alias) % aggregate.as_sql(qn, self.connection),\n-                    alias is not None\n-                        and ' AS %s' % qn(truncate_name(alias, max_name_length))\n-                        or ''\n-                    )\n-                for alias, aggregate in self.query.aggregate_select.items()\n-        ])\n+        for alias, aggregate in self.query.aggregate_select.items():\n+            agg_sql, agg_params = aggregate.as_sql(qn, self.connection)\n+            if alias is None:\n+                result.append(agg_sql)\n+            else:\n+                result.append('%s AS %s' % (agg_sql, qn(truncate_name(alias, max_name_length))))\n+            params.extend(agg_params)\n \n         # This loop customized for GeoQuery.\n         for (table, col), field in self.query.related_select_cols:\n@@ -98,7 +101,7 @@ def get_columns(self, with_aliases=False):\n                 col_aliases.add(col)\n \n         self._select_aliases = aliases\n-        return result\n+        return result, params\n \n     def get_default_columns(self, with_aliases=False, col_aliases=None,\n             start_alias=None, opts=None, as_pairs=False, from_parent=None):\n@@ -280,5 +283,35 @@ def results_iter(self):\n                 if self.connection.ops.oracle:\n                     date = self.resolve_columns(row, fields)[offset]\n                 elif needs_string_cast:\n-                    date = typecast_timestamp(str(date))\n+                    date = typecast_date(str(date))\n+                if isinstance(date, datetime.datetime):\n+                    date = date.date()\n                 yield date\n+\n+class SQLDateTimeCompiler(compiler.SQLDateTimeCompiler, GeoSQLCompiler):\n+    \"\"\"\n+    This is overridden for GeoDjango to properly cast date columns, since\n+    `GeoQuery.resolve_columns` is used for spatial values.\n+    See #14648, #16757.\n+    \"\"\"\n+    def results_iter(self):\n+        if self.connection.ops.oracle:\n+            from django.db.models.fields import DateTimeField\n+            fields = [DateTimeField()]\n+        else:\n+            needs_string_cast = self.connection.features.needs_datetime_string_cast\n+\n+        offset = len(self.query.extra_select)\n+        for rows in self.execute_sql(MULTI):\n+            for row in rows:\n+                datetime = row[offset]\n+                if self.connection.ops.oracle:\n+                    datetime = self.resolve_columns(row, fields)[offset]\n+                elif needs_string_cast:\n+                    datetime = typecast_timestamp(str(datetime))\n+                # Datetimes are artifically returned in UTC on databases that\n+                # don't support time zone. Restore the zone used in the query.\n+                if settings.USE_TZ:\n+                    datetime = datetime.replace(tzinfo=None)\n+                    datetime = timezone.make_aware(datetime, self.query.tzinfo)\n+                yield datetime"
        },
        {
            "sha": "6ef34db0a3d0844038fb27372163096337768821",
            "filename": "django/contrib/gis/db/models/sql/where.py",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fmodels%2Fsql%2Fwhere.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Fdb%2Fmodels%2Fsql%2Fwhere.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fdb%2Fmodels%2Fsql%2Fwhere.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -44,8 +44,9 @@ def make_atom(self, child, qn, connection):\n         lvalue, lookup_type, value_annot, params_or_value = child\n         if isinstance(lvalue, GeoConstraint):\n             data, params = lvalue.process(lookup_type, params_or_value, connection)\n-            spatial_sql = connection.ops.spatial_lookup_sql(data, lookup_type, params_or_value, lvalue.field, qn)\n-            return spatial_sql, params\n+            spatial_sql, spatial_params = connection.ops.spatial_lookup_sql(\n+                    data, lookup_type, params_or_value, lvalue.field, qn)\n+            return spatial_sql, spatial_params + params\n         else:\n             return super(GeoWhereNode, self).make_atom(child, qn, connection)\n "
        },
        {
            "sha": "a27b2d40f6d2d3240b0abddc35dce113de24c546",
            "filename": "django/contrib/gis/tests/geoapp/test_regress.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Ftests%2Fgeoapp%2Ftest_regress.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fcontrib%2Fgis%2Ftests%2Fgeoapp%2Ftest_regress.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Ftests%2Fgeoapp%2Ftest_regress.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -49,7 +49,7 @@ def test_unicode_date(self):\n         founded = datetime(1857, 5, 23)\n         mansfield = PennsylvaniaCity.objects.create(name='Mansfield', county='Tioga', point='POINT(-77.071445 41.823881)',\n                                                     founded=founded)\n-        self.assertEqual(founded, PennsylvaniaCity.objects.dates('founded', 'day')[0])\n+        self.assertEqual(founded, PennsylvaniaCity.objects.datetimes('founded', 'day')[0])\n         self.assertEqual(founded, PennsylvaniaCity.objects.aggregate(Min('founded'))['founded__min'])\n \n     def test_empty_count(self):"
        },
        {
            "sha": "03b62f64136f6b89b08b0838ac6443c18f560c50",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 41,
            "deletions": 15,
            "changes": 56,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -1,3 +1,5 @@\n+import datetime\n+\n from django.db.utils import DatabaseError\n \n try:\n@@ -14,7 +16,7 @@\n from django.utils.functional import cached_property\n from django.utils.importlib import import_module\n from django.utils import six\n-from django.utils.timezone import is_aware\n+from django.utils import timezone\n \n \n class BaseDatabaseWrapper(object):\n@@ -397,6 +399,9 @@ class BaseDatabaseFeatures(object):\n     # Can datetimes with timezones be used?\n     supports_timezones = True\n \n+    # Does the database have a copy of the zoneinfo database?\n+    has_zoneinfo_database = True\n+\n     # When performing a GROUP BY, is an ORDER BY NULL required\n     # to remove any ordering?\n     requires_explicit_null_ordering_when_grouping = False\n@@ -523,7 +528,7 @@ def date_interval_sql(self, sql, connector, timedelta):\n     def date_trunc_sql(self, lookup_type, field_name):\n         \"\"\"\n         Given a lookup_type of 'year', 'month' or 'day', returns the SQL that\n-        truncates the given date field field_name to a DATE object with only\n+        truncates the given date field field_name to a date object with only\n         the given specificity.\n         \"\"\"\n         raise NotImplementedError()\n@@ -537,6 +542,23 @@ def datetime_cast_sql(self):\n         \"\"\"\n         return \"%s\"\n \n+    def datetime_extract_sql(self, lookup_type, field_name, tzname):\n+        \"\"\"\n+        Given a lookup_type of 'year', 'month', 'day', 'hour', 'minute' or\n+        'second', returns the SQL that extracts a value from the given\n+        datetime field field_name, and a tuple of parameters.\n+        \"\"\"\n+        raise NotImplementedError()\n+\n+    def datetime_trunc_sql(self, lookup_type, field_name, tzname):\n+        \"\"\"\n+        Given a lookup_type of 'year', 'month', 'day', 'hour', 'minute' or\n+        'second', returns the SQL that truncates the given datetime field\n+        field_name to a datetime object with only the given specificity, and\n+        a tuple of parameters.\n+        \"\"\"\n+        raise NotImplementedError()\n+\n     def deferrable_sql(self):\n         \"\"\"\n         Returns the SQL necessary to make a constraint \"initially deferred\"\n@@ -853,7 +875,7 @@ def value_to_db_time(self, value):\n         \"\"\"\n         if value is None:\n             return None\n-        if is_aware(value):\n+        if timezone.is_aware(value):\n             raise ValueError(\"Django does not support timezone-aware times.\")\n         return six.text_type(value)\n \n@@ -866,29 +888,33 @@ def value_to_db_decimal(self, value, max_digits, decimal_places):\n             return None\n         return util.format_number(value, max_digits, decimal_places)\n \n-    def year_lookup_bounds(self, value):\n+    def year_lookup_bounds_for_date_field(self, value):\n         \"\"\"\n         Returns a two-elements list with the lower and upper bound to be used\n-        with a BETWEEN operator to query a field value using a year lookup\n+        with a BETWEEN operator to query a DateField value using a year\n+        lookup.\n \n         `value` is an int, containing the looked-up year.\n         \"\"\"\n-        first = '%s-01-01 00:00:00'\n-        second = '%s-12-31 23:59:59.999999'\n-        return [first % value, second % value]\n+        first = datetime.date(value, 1, 1)\n+        second = datetime.date(value, 12, 31)\n+        return [first, second]\n \n-    def year_lookup_bounds_for_date_field(self, value):\n+    def year_lookup_bounds_for_datetime_field(self, value):\n         \"\"\"\n         Returns a two-elements list with the lower and upper bound to be used\n-        with a BETWEEN operator to query a DateField value using a year lookup\n+        with a BETWEEN operator to query a DateTimeField value using a year\n+        lookup.\n \n         `value` is an int, containing the looked-up year.\n-\n-        By default, it just calls `self.year_lookup_bounds`. Some backends need\n-        this hook because on their DB date fields can't be compared to values\n-        which include a time part.\n         \"\"\"\n-        return self.year_lookup_bounds(value)\n+        first = datetime.datetime(value, 1, 1)\n+        second = datetime.datetime(value, 12, 31, 23, 59, 59, 999999)\n+        if settings.USE_TZ:\n+            tz = timezone.get_current_timezone()\n+            first = timezone.make_aware(first, tz)\n+            second = timezone.make_aware(second, tz)\n+        return [first, second]\n \n     def convert_values(self, value, field):\n         \"\"\""
        },
        {
            "sha": "9de2a4d62d17828a23a942a0ee1ee4eec99a0cb7",
            "filename": "django/db/backends/mysql/base.py",
            "status": "modified",
            "additions": 43,
            "deletions": 4,
            "changes": 47,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -30,6 +30,7 @@\n from MySQLdb.converters import conversions, Thing2Literal\n from MySQLdb.constants import FIELD_TYPE, CLIENT\n \n+from django.conf import settings\n from django.db import utils\n from django.db.backends import *\n from django.db.backends.signals import connection_created\n@@ -193,6 +194,12 @@ def can_introspect_foreign_keys(self):\n         \"Confirm support for introspected foreign keys\"\n         return self._mysql_storage_engine != 'MyISAM'\n \n+    @cached_property\n+    def has_zoneinfo_database(self):\n+        cursor = self.connection.cursor()\n+        cursor.execute(\"SELECT 1 FROM mysql.time_zone LIMIT 1\")\n+        return cursor.fetchone() is not None\n+\n class DatabaseOperations(BaseDatabaseOperations):\n     compiler_module = \"django.db.backends.mysql.compiler\"\n \n@@ -218,6 +225,39 @@ def date_trunc_sql(self, lookup_type, field_name):\n             sql = \"CAST(DATE_FORMAT(%s, '%s') AS DATETIME)\" % (field_name, format_str)\n         return sql\n \n+    def datetime_extract_sql(self, lookup_type, field_name, tzname):\n+        if settings.USE_TZ:\n+            field_name = \"CONVERT_TZ(%s, 'UTC', %%s)\" % field_name\n+            params = [tzname]\n+        else:\n+            params = []\n+        # http://dev.mysql.com/doc/mysql/en/date-and-time-functions.html\n+        if lookup_type == 'week_day':\n+            # DAYOFWEEK() returns an integer, 1-7, Sunday=1.\n+            # Note: WEEKDAY() returns 0-6, Monday=0.\n+            sql = \"DAYOFWEEK(%s)\" % field_name\n+        else:\n+            sql = \"EXTRACT(%s FROM %s)\" % (lookup_type.upper(), field_name)\n+        return sql, params\n+\n+    def datetime_trunc_sql(self, lookup_type, field_name, tzname):\n+        if settings.USE_TZ:\n+            field_name = \"CONVERT_TZ(%s, 'UTC', %%s)\" % field_name\n+            params = [tzname]\n+        else:\n+            params = []\n+        fields = ['year', 'month', 'day', 'hour', 'minute', 'second']\n+        format = ('%%Y-', '%%m', '-%%d', ' %%H:', '%%i', ':%%s') # Use double percents to escape.\n+        format_def = ('0000-', '01', '-01', ' 00:', '00', ':00')\n+        try:\n+            i = fields.index(lookup_type) + 1\n+        except ValueError:\n+            sql = field_name\n+        else:\n+            format_str = ''.join([f for f in format[:i]] + [f for f in format_def[i:]])\n+            sql = \"CAST(DATE_FORMAT(%s, '%s') AS DATETIME)\" % (field_name, format_str)\n+        return sql, params\n+\n     def date_interval_sql(self, sql, connector, timedelta):\n         return \"(%s %s INTERVAL '%d 0:0:%d:%d' DAY_MICROSECOND)\" % (sql, connector,\n                 timedelta.days, timedelta.seconds, timedelta.microseconds)\n@@ -314,11 +354,10 @@ def value_to_db_time(self, value):\n         # MySQL doesn't support microseconds\n         return six.text_type(value.replace(microsecond=0))\n \n-    def year_lookup_bounds(self, value):\n+    def year_lookup_bounds_for_datetime_field(self, value):\n         # Again, no microseconds\n-        first = '%s-01-01 00:00:00'\n-        second = '%s-12-31 23:59:59.99'\n-        return [first % value, second % value]\n+        first, second = super(DatabaseOperations, self).year_lookup_bounds_for_datetime_field(value)\n+        return [first.replace(microsecond=0), second.replace(microsecond=0)]\n \n     def max_name_length(self):\n         return 64"
        },
        {
            "sha": "f4c5563eb219a9bac87af46f4559a8fb697cd48f",
            "filename": "django/db/backends/mysql/compiler.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2Fmysql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2Fmysql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fcompiler.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -31,3 +31,6 @@ class SQLAggregateCompiler(compiler.SQLAggregateCompiler, SQLCompiler):\n \n class SQLDateCompiler(compiler.SQLDateCompiler, SQLCompiler):\n     pass\n+\n+class SQLDateTimeCompiler(compiler.SQLDateTimeCompiler, SQLCompiler):\n+    pass"
        },
        {
            "sha": "7bcfb46798319015b5beac522c15b91c37019972",
            "filename": "django/db/backends/oracle/base.py",
            "status": "modified",
            "additions": 54,
            "deletions": 8,
            "changes": 62,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Foracle%2Fbase.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -7,6 +7,7 @@\n \n import datetime\n import decimal\n+import re\n import sys\n import warnings\n \n@@ -128,12 +129,12 @@ def cache_key_culling_sql(self):\n         \"\"\"\n \n     def date_extract_sql(self, lookup_type, field_name):\n-        # http://download-east.oracle.com/docs/cd/B10501_01/server.920/a96540/functions42a.htm#1017163\n         if lookup_type == 'week_day':\n             # TO_CHAR(field, 'D') returns an integer from 1-7, where 1=Sunday.\n             return \"TO_CHAR(%s, 'D')\" % field_name\n         else:\n-            return \"EXTRACT(%s FROM %s)\" % (lookup_type, field_name)\n+            # http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions050.htm\n+            return \"EXTRACT(%s FROM %s)\" % (lookup_type.upper(), field_name)\n \n     def date_interval_sql(self, sql, connector, timedelta):\n         \"\"\"\n@@ -150,13 +151,58 @@ def date_interval_sql(self, sql, connector, timedelta):\n                 timedelta.microseconds, day_precision)\n \n     def date_trunc_sql(self, lookup_type, field_name):\n-        # Oracle uses TRUNC() for both dates and numbers.\n-        # http://download-east.oracle.com/docs/cd/B10501_01/server.920/a96540/functions155a.htm#SQLRF06151\n-        if lookup_type == 'day':\n-            sql = 'TRUNC(%s)' % field_name\n+        # http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions230.htm#i1002084\n+        if lookup_type in ('year', 'month'):\n+            return \"TRUNC(%s, '%s')\" % (field_name, lookup_type.upper())\n         else:\n-            sql = \"TRUNC(%s, '%s')\" % (field_name, lookup_type)\n-        return sql\n+            return \"TRUNC(%s)\" % field_name\n+\n+    # Oracle crashes with \"ORA-03113: end-of-file on communication channel\"\n+    # if the time zone name is passed in parameter. Use interpolation instead.\n+    # https://groups.google.com/forum/#!msg/django-developers/zwQju7hbG78/9l934yelwfsJ\n+    # This regexp matches all time zone names from the zoneinfo database.\n+    _tzname_re = re.compile(r'^[\\w/:+-]+$')\n+\n+    def _convert_field_to_tz(self, field_name, tzname):\n+        if not self._tzname_re.match(tzname):\n+            raise ValueError(\"Invalid time zone name: %s\" % tzname)\n+        # Convert from UTC to local time, returning TIMESTAMP WITH TIME ZONE.\n+        result = \"(FROM_TZ(%s, '0:00') AT TIME ZONE '%s')\" % (field_name, tzname)\n+        # Extracting from a TIMESTAMP WITH TIME ZONE ignore the time zone.\n+        # Convert to a DATETIME, which is called DATE by Oracle. There's no\n+        # built-in function to do that; the easiest is to go through a string.\n+        result = \"TO_CHAR(%s, 'YYYY-MM-DD HH24:MI:SS')\" % result\n+        result = \"TO_DATE(%s, 'YYYY-MM-DD HH24:MI:SS')\" % result\n+        # Re-convert to a TIMESTAMP because EXTRACT only handles the date part\n+        # on DATE values, even though they actually store the time part.\n+        return \"CAST(%s AS TIMESTAMP)\" % result\n+\n+    def datetime_extract_sql(self, lookup_type, field_name, tzname):\n+        if settings.USE_TZ:\n+            field_name = self._convert_field_to_tz(field_name, tzname)\n+        if lookup_type == 'week_day':\n+            # TO_CHAR(field, 'D') returns an integer from 1-7, where 1=Sunday.\n+            sql = \"TO_CHAR(%s, 'D')\" % field_name\n+        else:\n+            # http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions050.htm\n+            sql = \"EXTRACT(%s FROM %s)\" % (lookup_type.upper(), field_name)\n+        return sql, []\n+\n+    def datetime_trunc_sql(self, lookup_type, field_name, tzname):\n+        if settings.USE_TZ:\n+            field_name = self._convert_field_to_tz(field_name, tzname)\n+        # http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions230.htm#i1002084\n+        if lookup_type in ('year', 'month'):\n+            sql = \"TRUNC(%s, '%s')\" % (field_name, lookup_type.upper())\n+        elif lookup_type == 'day':\n+            sql = \"TRUNC(%s)\" % field_name\n+        elif lookup_type == 'hour':\n+            sql = \"TRUNC(%s, 'HH24')\" % field_name\n+        elif lookup_type == 'minute':\n+            sql = \"TRUNC(%s, 'MI')\" % field_name\n+        else:\n+            sql = field_name    # Cast to DATE removes sub-second precision.\n+        return sql, []\n \n     def convert_values(self, value, field):\n         if isinstance(value, Database.LOB):"
        },
        {
            "sha": "cbee27951c9b07faa59ce3f0c9196331057772a1",
            "filename": "django/db/backends/oracle/compiler.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2Foracle%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2Foracle%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Foracle%2Fcompiler.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -71,3 +71,6 @@ class SQLAggregateCompiler(compiler.SQLAggregateCompiler, SQLCompiler):\n \n class SQLDateCompiler(compiler.SQLDateCompiler, SQLCompiler):\n     pass\n+\n+class SQLDateTimeCompiler(compiler.SQLDateTimeCompiler, SQLCompiler):\n+    pass"
        },
        {
            "sha": "8e87ed539f1b985acd49afd10427497ae62281bb",
            "filename": "django/db/backends/postgresql_psycopg2/operations.py",
            "status": "modified",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Foperations.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Foperations.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Foperations.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -1,5 +1,6 @@\n from __future__ import unicode_literals\n \n+from django.conf import settings\n from django.db.backends import BaseDatabaseOperations\n \n \n@@ -36,6 +37,30 @@ def date_trunc_sql(self, lookup_type, field_name):\n         # http://www.postgresql.org/docs/8.0/static/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC\n         return \"DATE_TRUNC('%s', %s)\" % (lookup_type, field_name)\n \n+    def datetime_extract_sql(self, lookup_type, field_name, tzname):\n+        if settings.USE_TZ:\n+            field_name = \"%s AT TIME ZONE %%s\" % field_name\n+            params = [tzname]\n+        else:\n+            params = []\n+        # http://www.postgresql.org/docs/8.0/static/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT\n+        if lookup_type == 'week_day':\n+            # For consistency across backends, we return Sunday=1, Saturday=7.\n+            sql = \"EXTRACT('dow' FROM %s) + 1\" % field_name\n+        else:\n+            sql = \"EXTRACT('%s' FROM %s)\" % (lookup_type, field_name)\n+        return sql, params\n+\n+    def datetime_trunc_sql(self, lookup_type, field_name, tzname):\n+        if settings.USE_TZ:\n+            field_name = \"%s AT TIME ZONE %%s\" % field_name\n+            params = [tzname]\n+        else:\n+            params = []\n+        # http://www.postgresql.org/docs/8.0/static/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC\n+        sql = \"DATE_TRUNC('%s', %s)\" % (lookup_type, field_name)\n+        return sql, params\n+\n     def deferrable_sql(self):\n         return \" DEFERRABLE INITIALLY DEFERRED\"\n "
        },
        {
            "sha": "3b4ff4c5ddc24bcc0af2d9ce27fdac7fde731d74",
            "filename": "django/db/backends/sqlite3/base.py",
            "status": "modified",
            "additions": 69,
            "deletions": 11,
            "changes": 80,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -35,6 +35,10 @@\n     from django.core.exceptions import ImproperlyConfigured\n     raise ImproperlyConfigured(\"Error loading either pysqlite2 or sqlite3 modules (tried in that order): %s\" % exc)\n \n+try:\n+    import pytz\n+except ImportError:\n+    pytz = None\n \n DatabaseError = Database.DatabaseError\n IntegrityError = Database.IntegrityError\n@@ -117,6 +121,10 @@ def supports_stddev(self):\n         cursor.execute('DROP TABLE STDDEV_TEST')\n         return has_support\n \n+    @cached_property\n+    def has_zoneinfo_database(self):\n+        return pytz is not None\n+\n class DatabaseOperations(BaseDatabaseOperations):\n     def bulk_batch_size(self, fields, objs):\n         \"\"\"\n@@ -142,10 +150,10 @@ def check_aggregate_support(self, aggregate):\n \n     def date_extract_sql(self, lookup_type, field_name):\n         # sqlite doesn't support extract, so we fake it with the user-defined\n-        # function django_extract that's registered in connect(). Note that\n+        # function django_date_extract that's registered in connect(). Note that\n         # single quotes are used because this is a string (and could otherwise\n         # cause a collision with a field name).\n-        return \"django_extract('%s', %s)\" % (lookup_type.lower(), field_name)\n+        return \"django_date_extract('%s', %s)\" % (lookup_type.lower(), field_name)\n \n     def date_interval_sql(self, sql, connector, timedelta):\n         # It would be more straightforward if we could use the sqlite strftime\n@@ -154,7 +162,7 @@ def date_interval_sql(self, sql, connector, timedelta):\n         # values differently. So instead we register our own function that\n         # formats the datetime combined with the delta in a manner suitable\n         # for comparisons.\n-        return  'django_format_dtdelta(%s, \"%s\", \"%d\", \"%d\", \"%d\")' % (sql,\n+        return 'django_format_dtdelta(%s, \"%s\", \"%d\", \"%d\", \"%d\")' % (sql,\n             connector, timedelta.days, timedelta.seconds, timedelta.microseconds)\n \n     def date_trunc_sql(self, lookup_type, field_name):\n@@ -164,6 +172,26 @@ def date_trunc_sql(self, lookup_type, field_name):\n         # cause a collision with a field name).\n         return \"django_date_trunc('%s', %s)\" % (lookup_type.lower(), field_name)\n \n+    def datetime_extract_sql(self, lookup_type, field_name, tzname):\n+        # Same comment as in date_extract_sql.\n+        if settings.USE_TZ:\n+            if pytz is None:\n+                from django.core.exceptions import ImproperlyConfigured\n+                raise ImproperlyConfigured(\"This query requires pytz, \"\n+                                           \"but it isn't installed.\")\n+        return \"django_datetime_extract('%s', %s, %%s)\" % (\n+            lookup_type.lower(), field_name), [tzname]\n+\n+    def datetime_trunc_sql(self, lookup_type, field_name, tzname):\n+        # Same comment as in date_trunc_sql.\n+        if settings.USE_TZ:\n+            if pytz is None:\n+                from django.core.exceptions import ImproperlyConfigured\n+                raise ImproperlyConfigured(\"This query requires pytz, \"\n+                                           \"but it isn't installed.\")\n+        return \"django_datetime_trunc('%s', %s, %%s)\" % (\n+            lookup_type.lower(), field_name), [tzname]\n+\n     def drop_foreignkey_sql(self):\n         return \"\"\n \n@@ -214,11 +242,6 @@ def value_to_db_time(self, value):\n \n         return six.text_type(value)\n \n-    def year_lookup_bounds(self, value):\n-        first = '%s-01-01'\n-        second = '%s-12-31 23:59:59.999999'\n-        return [first % value, second % value]\n-\n     def convert_values(self, value, field):\n         \"\"\"SQLite returns floats when it should be returning decimals,\n         and gets dates and datetimes wrong.\n@@ -310,9 +333,10 @@ def get_connection_params(self):\n \n     def get_new_connection(self, conn_params):\n         conn = Database.connect(**conn_params)\n-        # Register extract, date_trunc, and regexp functions.\n-        conn.create_function(\"django_extract\", 2, _sqlite_extract)\n+        conn.create_function(\"django_date_extract\", 2, _sqlite_date_extract)\n         conn.create_function(\"django_date_trunc\", 2, _sqlite_date_trunc)\n+        conn.create_function(\"django_datetime_extract\", 3, _sqlite_datetime_extract)\n+        conn.create_function(\"django_datetime_trunc\", 3, _sqlite_datetime_trunc)\n         conn.create_function(\"regexp\", 2, _sqlite_regexp)\n         conn.create_function(\"django_format_dtdelta\", 5, _sqlite_format_dtdelta)\n         return conn\n@@ -402,7 +426,7 @@ def executemany(self, query, param_list):\n     def convert_query(self, query):\n         return FORMAT_QMARK_REGEX.sub('?', query).replace('%%','%')\n \n-def _sqlite_extract(lookup_type, dt):\n+def _sqlite_date_extract(lookup_type, dt):\n     if dt is None:\n         return None\n     try:\n@@ -419,12 +443,46 @@ def _sqlite_date_trunc(lookup_type, dt):\n         dt = util.typecast_timestamp(dt)\n     except (ValueError, TypeError):\n         return None\n+    if lookup_type == 'year':\n+        return \"%i-01-01\" % dt.year\n+    elif lookup_type == 'month':\n+        return \"%i-%02i-01\" % (dt.year, dt.month)\n+    elif lookup_type == 'day':\n+        return \"%i-%02i-%02i\" % (dt.year, dt.month, dt.day)\n+\n+def _sqlite_datetime_extract(lookup_type, dt, tzname):\n+    if dt is None:\n+        return None\n+    try:\n+        dt = util.typecast_timestamp(dt)\n+    except (ValueError, TypeError):\n+        return None\n+    if tzname is not None:\n+        dt = timezone.localtime(dt, pytz.timezone(tzname))\n+    if lookup_type == 'week_day':\n+        return (dt.isoweekday() % 7) + 1\n+    else:\n+        return getattr(dt, lookup_type)\n+\n+def _sqlite_datetime_trunc(lookup_type, dt, tzname):\n+    try:\n+        dt = util.typecast_timestamp(dt)\n+    except (ValueError, TypeError):\n+        return None\n+    if tzname is not None:\n+        dt = timezone.localtime(dt, pytz.timezone(tzname))\n     if lookup_type == 'year':\n         return \"%i-01-01 00:00:00\" % dt.year\n     elif lookup_type == 'month':\n         return \"%i-%02i-01 00:00:00\" % (dt.year, dt.month)\n     elif lookup_type == 'day':\n         return \"%i-%02i-%02i 00:00:00\" % (dt.year, dt.month, dt.day)\n+    elif lookup_type == 'hour':\n+        return \"%i-%02i-%02i %02i:00:00\" % (dt.year, dt.month, dt.day, dt.hour)\n+    elif lookup_type == 'minute':\n+        return \"%i-%02i-%02i %02i:%02i:00\" % (dt.year, dt.month, dt.day, dt.hour, dt.minute)\n+    elif lookup_type == 'second':\n+        return \"%i-%02i-%02i %02i:%02i:%02i\" % (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)\n \n def _sqlite_format_dtdelta(dt, conn, days, secs, usecs):\n     try:"
        },
        {
            "sha": "b70d235656ee6476664792c851927c11f48a0136",
            "filename": "django/db/models/fields/__init__.py",
            "status": "modified",
            "additions": 13,
            "deletions": 10,
            "changes": 23,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Ffields%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Ffields%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2F__init__.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -312,9 +312,10 @@ def get_prep_lookup(self, lookup_type, value):\n             return value._prepare()\n \n         if lookup_type in (\n-                'regex', 'iregex', 'month', 'day', 'week_day', 'search',\n-                'contains', 'icontains', 'iexact', 'startswith', 'istartswith',\n-                'endswith', 'iendswith', 'isnull'\n+                'iexact', 'contains', 'icontains',\n+                'startswith', 'istartswith', 'endswith', 'iendswith',\n+                'month', 'day', 'week_day', 'hour', 'minute', 'second',\n+                'isnull', 'search', 'regex', 'iregex',\n             ):\n             return value\n         elif lookup_type in ('exact', 'gt', 'gte', 'lt', 'lte'):\n@@ -350,8 +351,8 @@ def get_db_prep_lookup(self, lookup_type, value, connection,\n                 sql, params = value._as_sql(connection=connection)\n             return QueryWrapper(('(%s)' % sql), params)\n \n-        if lookup_type in ('regex', 'iregex', 'month', 'day', 'week_day',\n-                           'search'):\n+        if lookup_type in ('month', 'day', 'week_day', 'hour', 'minute',\n+                           'second', 'search', 'regex', 'iregex'):\n             return [value]\n         elif lookup_type in ('exact', 'gt', 'gte', 'lt', 'lte'):\n             return [self.get_db_prep_value(value, connection=connection,\n@@ -370,10 +371,12 @@ def get_db_prep_lookup(self, lookup_type, value, connection,\n         elif lookup_type == 'isnull':\n             return []\n         elif lookup_type == 'year':\n-            if self.get_internal_type() == 'DateField':\n+            if isinstance(self, DateTimeField):\n+                return connection.ops.year_lookup_bounds_for_datetime_field(value)\n+            elif isinstance(self, DateField):\n                 return connection.ops.year_lookup_bounds_for_date_field(value)\n             else:\n-                return connection.ops.year_lookup_bounds(value)\n+                return [value]          # this isn't supposed to happen\n \n     def has_default(self):\n         \"\"\"\n@@ -722,9 +725,9 @@ def contribute_to_class(self, cls, name):\n                       is_next=False))\n \n     def get_prep_lookup(self, lookup_type, value):\n-        # For \"__month\", \"__day\", and \"__week_day\" lookups, convert the value\n-        # to an int so the database backend always sees a consistent type.\n-        if lookup_type in ('month', 'day', 'week_day'):\n+        # For dates lookups, convert the value to an int\n+        # so the database backend always sees a consistent type.\n+        if lookup_type in ('month', 'day', 'week_day', 'hour', 'minute', 'second'):\n             return int(value)\n         return super(DateField, self).get_prep_lookup(lookup_type, value)\n "
        },
        {
            "sha": "b1f2e1073507174723687c61f65ba1857a38f990",
            "filename": "django/db/models/manager.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fmanager.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fmanager.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fmanager.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -130,6 +130,9 @@ def count(self):\n     def dates(self, *args, **kwargs):\n         return self.get_query_set().dates(*args, **kwargs)\n \n+    def datetimes(self, *args, **kwargs):\n+        return self.get_query_set().datetimes(*args, **kwargs)\n+\n     def distinct(self, *args, **kwargs):\n         return self.get_query_set().distinct(*args, **kwargs)\n "
        },
        {
            "sha": "0f3a79a25d439fa7041345704371c3f6f2034af4",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 48,
            "deletions": 3,
            "changes": 51,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -7,6 +7,7 @@\n import sys\n import warnings\n \n+from django.conf import settings\n from django.core import exceptions\n from django.db import connections, router, transaction, IntegrityError\n from django.db.models.constants import LOOKUP_SEP\n@@ -17,6 +18,7 @@\n from django.db.models import sql\n from django.utils.functional import partition\n from django.utils import six\n+from django.utils import timezone\n \n # Used to control how many objects are worked with at once in some cases (e.g.\n # when deleting objects).\n@@ -629,16 +631,33 @@ def values_list(self, *fields, **kwargs):\n \n     def dates(self, field_name, kind, order='ASC'):\n         \"\"\"\n-        Returns a list of datetime objects representing all available dates for\n+        Returns a list of date objects representing all available dates for\n         the given field_name, scoped to 'kind'.\n         \"\"\"\n-        assert kind in (\"month\", \"year\", \"day\"), \\\n+        assert kind in (\"year\", \"month\", \"day\"), \\\n                 \"'kind' must be one of 'year', 'month' or 'day'.\"\n         assert order in ('ASC', 'DESC'), \\\n                 \"'order' must be either 'ASC' or 'DESC'.\"\n         return self._clone(klass=DateQuerySet, setup=True,\n                 _field_name=field_name, _kind=kind, _order=order)\n \n+    def datetimes(self, field_name, kind, order='ASC', tzinfo=None):\n+        \"\"\"\n+        Returns a list of datetime objects representing all available\n+        datetimes for the given field_name, scoped to 'kind'.\n+        \"\"\"\n+        assert kind in (\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"), \\\n+                \"'kind' must be one of 'year', 'month', 'day', 'hour', 'minute' or 'second'.\"\n+        assert order in ('ASC', 'DESC'), \\\n+                \"'order' must be either 'ASC' or 'DESC'.\"\n+        if settings.USE_TZ:\n+            if tzinfo is None:\n+                tzinfo = timezone.get_current_timezone()\n+        else:\n+            tzinfo = None\n+        return self._clone(klass=DateTimeQuerySet, setup=True,\n+                _field_name=field_name, _kind=kind, _order=order, _tzinfo=tzinfo)\n+\n     def none(self):\n         \"\"\"\n         Returns an empty QuerySet.\n@@ -1187,7 +1206,7 @@ def _setup_query(self):\n         self.query.clear_deferred_loading()\n         self.query = self.query.clone(klass=sql.DateQuery, setup=True)\n         self.query.select = []\n-        self.query.add_date_select(self._field_name, self._kind, self._order)\n+        self.query.add_select(self._field_name, self._kind, self._order)\n \n     def _clone(self, klass=None, setup=False, **kwargs):\n         c = super(DateQuerySet, self)._clone(klass, False, **kwargs)\n@@ -1198,6 +1217,32 @@ def _clone(self, klass=None, setup=False, **kwargs):\n         return c\n \n \n+class DateTimeQuerySet(QuerySet):\n+    def iterator(self):\n+        return self.query.get_compiler(self.db).results_iter()\n+\n+    def _setup_query(self):\n+        \"\"\"\n+        Sets up any special features of the query attribute.\n+\n+        Called by the _clone() method after initializing the rest of the\n+        instance.\n+        \"\"\"\n+        self.query.clear_deferred_loading()\n+        self.query = self.query.clone(klass=sql.DateTimeQuery, setup=True, tzinfo=self._tzinfo)\n+        self.query.select = []\n+        self.query.add_select(self._field_name, self._kind, self._order)\n+\n+    def _clone(self, klass=None, setup=False, **kwargs):\n+        c = super(DateTimeQuerySet, self)._clone(klass, False, **kwargs)\n+        c._field_name = self._field_name\n+        c._kind = self._kind\n+        c._tzinfo = self._tzinfo\n+        if setup and hasattr(c, '_setup_query'):\n+            c._setup_query()\n+        return c\n+\n+\n def get_klass_info(klass, max_depth=0, cur_depth=0, requested=None,\n                    only_load=None, from_parent=None):\n     \"\"\""
        },
        {
            "sha": "c82cc456170f6511f9e87b5b475a4ef934ebb48b",
            "filename": "django/db/models/query_utils.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fquery_utils.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fquery_utils.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery_utils.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -25,7 +25,7 @@ class QueryWrapper(object):\n     parameters. Can be used to pass opaque data to a where-clause, for example.\n     \"\"\"\n     def __init__(self, sql, params):\n-        self.data = sql, params\n+        self.data = sql, list(params)\n \n     def as_sql(self, qn=None, connection=None):\n         return self.data"
        },
        {
            "sha": "3c8720210b5702f1cbcaddd3185e3fb2210425a1",
            "filename": "django/db/models/sql/aggregates.py",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Faggregates.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Faggregates.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Faggregates.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -73,22 +73,23 @@ def relabel_aliases(self, change_map):\n             self.col = (change_map.get(self.col[0], self.col[0]), self.col[1])\n \n     def as_sql(self, qn, connection):\n-        \"Return the aggregate, rendered as SQL.\"\n+        \"Return the aggregate, rendered as SQL with parameters.\"\n+        params = []\n \n         if hasattr(self.col, 'as_sql'):\n-            field_name = self.col.as_sql(qn, connection)\n+            field_name, params = self.col.as_sql(qn, connection)\n         elif isinstance(self.col, (list, tuple)):\n             field_name = '.'.join([qn(c) for c in self.col])\n         else:\n             field_name = self.col\n \n-        params = {\n+        substitutions = {\n             'function': self.sql_function,\n             'field': field_name\n         }\n-        params.update(self.extra)\n+        substitutions.update(self.extra)\n \n-        return self.sql_template % params\n+        return self.sql_template % substitutions, params\n \n \n class Avg(Aggregate):"
        },
        {
            "sha": "1b6654b6702f94c243f7fa377198f158ac8d0b64",
            "filename": "django/db/models/sql/compiler.py",
            "status": "modified",
            "additions": 69,
            "deletions": 30,
            "changes": 99,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -1,5 +1,6 @@\n-from django.utils.six.moves import zip\n+import datetime\n \n+from django.conf import settings\n from django.core.exceptions import FieldError\n from django.db import transaction\n from django.db.backends.util import truncate_name\n@@ -12,6 +13,8 @@\n from django.db.models.sql.query import get_order_dir, Query\n from django.db.utils import DatabaseError\n from django.utils import six\n+from django.utils.six.moves import zip\n+from django.utils import timezone\n \n \n class SQLCompiler(object):\n@@ -71,7 +74,7 @@ def as_sql(self, with_limits=True, with_col_aliases=False):\n         # as the pre_sql_setup will modify query state in a way that forbids\n         # another run of it.\n         self.refcounts_before = self.query.alias_refcount.copy()\n-        out_cols = self.get_columns(with_col_aliases)\n+        out_cols, s_params = self.get_columns(with_col_aliases)\n         ordering, ordering_group_by = self.get_ordering()\n \n         distinct_fields = self.get_distinct()\n@@ -94,6 +97,7 @@ def as_sql(self, with_limits=True, with_col_aliases=False):\n             result.append(self.connection.ops.distinct_sql(distinct_fields))\n \n         result.append(', '.join(out_cols + self.query.ordering_aliases))\n+        params.extend(s_params)\n \n         result.append('FROM')\n         result.extend(from_)\n@@ -161,9 +165,10 @@ def as_nested_sql(self):\n \n     def get_columns(self, with_aliases=False):\n         \"\"\"\n-        Returns the list of columns to use in the select statement. If no\n-        columns have been specified, returns all columns relating to fields in\n-        the model.\n+        Returns the list of columns to use in the select statement, as well as\n+        a list any extra parameters that need to be included. If no columns\n+        have been specified, returns all columns relating to fields in the\n+        model.\n \n         If 'with_aliases' is true, any column names that are duplicated\n         (without the table names) are given unique aliases. This is needed in\n@@ -172,6 +177,7 @@ def get_columns(self, with_aliases=False):\n         qn = self.quote_name_unless_alias\n         qn2 = self.connection.ops.quote_name\n         result = ['(%s) AS %s' % (col[0], qn2(alias)) for alias, col in six.iteritems(self.query.extra_select)]\n+        params = []\n         aliases = set(self.query.extra_select.keys())\n         if with_aliases:\n             col_aliases = aliases.copy()\n@@ -201,7 +207,9 @@ def get_columns(self, with_aliases=False):\n                         aliases.add(r)\n                         col_aliases.add(col[1])\n                 else:\n-                    result.append(col.as_sql(qn, self.connection))\n+                    col_sql, col_params = col.as_sql(qn, self.connection)\n+                    result.append(col_sql)\n+                    params.extend(col_params)\n \n                     if hasattr(col, 'alias'):\n                         aliases.add(col.alias)\n@@ -214,15 +222,13 @@ def get_columns(self, with_aliases=False):\n             aliases.update(new_aliases)\n \n         max_name_length = self.connection.ops.max_name_length()\n-        result.extend([\n-            '%s%s' % (\n-                aggregate.as_sql(qn, self.connection),\n-                alias is not None\n-                    and ' AS %s' % qn(truncate_name(alias, max_name_length))\n-                    or ''\n-            )\n-            for alias, aggregate in self.query.aggregate_select.items()\n-        ])\n+        for alias, aggregate in self.query.aggregate_select.items():\n+            agg_sql, agg_params = aggregate.as_sql(qn, self.connection)\n+            if alias is None:\n+                result.append(agg_sql)\n+            else:\n+                result.append('%s AS %s' % (agg_sql, qn(truncate_name(alias, max_name_length))))\n+            params.extend(agg_params)\n \n         for (table, col), _ in self.query.related_select_cols:\n             r = '%s.%s' % (qn(table), qn(col))\n@@ -237,7 +243,7 @@ def get_columns(self, with_aliases=False):\n                 col_aliases.add(col)\n \n         self._select_aliases = aliases\n-        return result\n+        return result, params\n \n     def get_default_columns(self, with_aliases=False, col_aliases=None,\n             start_alias=None, opts=None, as_pairs=False, from_parent=None):\n@@ -542,14 +548,16 @@ def get_grouping(self, ordering_group_by):\n             seen = set()\n             cols = self.query.group_by + select_cols\n             for col in cols:\n+                col_params = ()\n                 if isinstance(col, (list, tuple)):\n                     sql = '%s.%s' % (qn(col[0]), qn(col[1]))\n                 elif hasattr(col, 'as_sql'):\n-                    sql = col.as_sql(qn, self.connection)\n+                    sql, col_params = col.as_sql(qn, self.connection)\n                 else:\n                     sql = '(%s)' % str(col)\n                 if sql not in seen:\n                     result.append(sql)\n+                    params.extend(col_params)\n                     seen.add(sql)\n \n             # Still, we need to add all stuff in ordering (except if the backend can\n@@ -988,15 +996,17 @@ def as_sql(self, qn=None):\n         if qn is None:\n             qn = self.quote_name_unless_alias\n \n-        sql = ('SELECT %s FROM (%s) subquery' % (\n-            ', '.join([\n-                aggregate.as_sql(qn, self.connection)\n-                for aggregate in self.query.aggregate_select.values()\n-            ]),\n-            self.query.subquery)\n-        )\n-        params = self.query.sub_params\n-        return (sql, params)\n+        sql, params = [], []\n+        for aggregate in self.query.aggregate_select.values():\n+            agg_sql, agg_params = aggregate.as_sql(qn, self.connection)\n+            sql.append(agg_sql)\n+            params.extend(agg_params)\n+        sql = ', '.join(sql)\n+        params = tuple(params)\n+\n+        sql = 'SELECT %s FROM (%s) subquery' % (sql, self.query.subquery)\n+        params = params + self.query.sub_params\n+        return sql, params\n \n class SQLDateCompiler(SQLCompiler):\n     def results_iter(self):\n@@ -1005,10 +1015,10 @@ def results_iter(self):\n         \"\"\"\n         resolve_columns = hasattr(self, 'resolve_columns')\n         if resolve_columns:\n-            from django.db.models.fields import DateTimeField\n-            fields = [DateTimeField()]\n+            from django.db.models.fields import DateField\n+            fields = [DateField()]\n         else:\n-            from django.db.backends.util import typecast_timestamp\n+            from django.db.backends.util import typecast_date\n             needs_string_cast = self.connection.features.needs_datetime_string_cast\n \n         offset = len(self.query.extra_select)\n@@ -1018,9 +1028,38 @@ def results_iter(self):\n                 if resolve_columns:\n                     date = self.resolve_columns(row, fields)[offset]\n                 elif needs_string_cast:\n-                    date = typecast_timestamp(str(date))\n+                    date = typecast_date(str(date))\n+                if isinstance(date, datetime.datetime):\n+                    date = date.date()\n                 yield date\n \n+class SQLDateTimeCompiler(SQLCompiler):\n+    def results_iter(self):\n+        \"\"\"\n+        Returns an iterator over the results from executing this query.\n+        \"\"\"\n+        resolve_columns = hasattr(self, 'resolve_columns')\n+        if resolve_columns:\n+            from django.db.models.fields import DateTimeField\n+            fields = [DateTimeField()]\n+        else:\n+            from django.db.backends.util import typecast_timestamp\n+            needs_string_cast = self.connection.features.needs_datetime_string_cast\n+\n+        offset = len(self.query.extra_select)\n+        for rows in self.execute_sql(MULTI):\n+            for row in rows:\n+                datetime = row[offset]\n+                if resolve_columns:\n+                    datetime = self.resolve_columns(row, fields)[offset]\n+                elif needs_string_cast:\n+                    datetime = typecast_timestamp(str(datetime))\n+                # Datetimes are artifically returned in UTC on databases that\n+                # don't support time zone. Restore the zone used in the query.\n+                if settings.USE_TZ:\n+                    datetime = datetime.replace(tzinfo=None)\n+                    datetime = timezone.make_aware(datetime, self.query.tzinfo)\n+                yield datetime\n \n def order_modified_iter(cursor, trim, sentinel):\n     \"\"\""
        },
        {
            "sha": "81bd646d692e11df9fd85b049ff79a7e4c502e9a",
            "filename": "django/db/models/sql/constants.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fconstants.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -11,7 +11,8 @@\n QUERY_TERMS = set([\n     'exact', 'iexact', 'contains', 'icontains', 'gt', 'gte', 'lt', 'lte', 'in',\n     'startswith', 'istartswith', 'endswith', 'iendswith', 'range', 'year',\n-    'month', 'day', 'week_day', 'isnull', 'search', 'regex', 'iregex',\n+    'month', 'day', 'week_day', 'hour', 'minute', 'second', 'isnull', 'search',\n+    'regex', 'iregex',\n ])\n \n # Size of each \"chunk\" for get_iterator calls."
        },
        {
            "sha": "612eb8f2d9df0878c881f052dea998bc888164e2",
            "filename": "django/db/models/sql/datastructures.py",
            "status": "modified",
            "additions": 22,
            "deletions": 1,
            "changes": 23,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Fdatastructures.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Fdatastructures.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fdatastructures.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -40,4 +40,25 @@ def as_sql(self, qn, connection):\n             col = '%s.%s' % tuple([qn(c) for c in self.col])\n         else:\n             col = self.col\n-        return connection.ops.date_trunc_sql(self.lookup_type, col)\n+        return connection.ops.date_trunc_sql(self.lookup_type, col), []\n+\n+class DateTime(object):\n+    \"\"\"\n+    Add a datetime selection column.\n+    \"\"\"\n+    def __init__(self, col, lookup_type, tzname):\n+        self.col = col\n+        self.lookup_type = lookup_type\n+        self.tzname = tzname\n+\n+    def relabel_aliases(self, change_map):\n+        c = self.col\n+        if isinstance(c, (list, tuple)):\n+            self.col = (change_map.get(c[0], c[0]), c[1])\n+\n+    def as_sql(self, qn, connection):\n+        if isinstance(self.col, (list, tuple)):\n+            col = '%s.%s' % tuple([qn(c) for c in self.col])\n+        else:\n+            col = self.col\n+        return connection.ops.datetime_trunc_sql(self.lookup_type, col, self.tzname)"
        },
        {
            "sha": "2a5008f0672a705da3462ce832b057f9156c11de",
            "filename": "django/db/models/sql/expressions.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fexpressions.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -94,9 +94,9 @@ def evaluate_leaf(self, node, qn, connection):\n         if col is None:\n             raise ValueError(\"Given node not found\")\n         if hasattr(col, 'as_sql'):\n-            return col.as_sql(qn, connection), ()\n+            return col.as_sql(qn, connection)\n         else:\n-            return '%s.%s' % (qn(col[0]), qn(col[1])), ()\n+            return '%s.%s' % (qn(col[0]), qn(col[1])), []\n \n     def evaluate_date_modifier_node(self, node, qn, connection):\n         timedelta = node.children.pop()"
        },
        {
            "sha": "6aac5c898c89efe5081dc982347343bc01b52fb1",
            "filename": "django/db/models/sql/subqueries.py",
            "status": "modified",
            "additions": 39,
            "deletions": 9,
            "changes": 48,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Fsubqueries.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Fsubqueries.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fsubqueries.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -2,22 +2,23 @@\n Query subclasses which provide extra functionality beyond simple data retrieval.\n \"\"\"\n \n+from django.conf import settings\n from django.core.exceptions import FieldError\n from django.db import connections\n from django.db.models.constants import LOOKUP_SEP\n-from django.db.models.fields import DateField, FieldDoesNotExist\n+from django.db.models.fields import DateField, DateTimeField, FieldDoesNotExist\n from django.db.models.sql.constants import *\n-from django.db.models.sql.datastructures import Date\n+from django.db.models.sql.datastructures import Date, DateTime\n from django.db.models.sql.query import Query\n from django.db.models.sql.where import AND, Constraint\n-from django.utils.datastructures import SortedDict\n from django.utils.functional import Promise\n from django.utils.encoding import force_text\n from django.utils import six\n+from django.utils import timezone\n \n \n __all__ = ['DeleteQuery', 'UpdateQuery', 'InsertQuery', 'DateQuery',\n-        'AggregateQuery']\n+        'DateTimeQuery', 'AggregateQuery']\n \n class DeleteQuery(Query):\n     \"\"\"\n@@ -223,9 +224,9 @@ class DateQuery(Query):\n \n     compiler = 'SQLDateCompiler'\n \n-    def add_date_select(self, field_name, lookup_type, order='ASC'):\n+    def add_select(self, field_name, lookup_type, order='ASC'):\n         \"\"\"\n-        Converts the query into a date extraction query.\n+        Converts the query into an extraction query.\n         \"\"\"\n         try:\n             result = self.setup_joins(\n@@ -238,10 +239,9 @@ def add_date_select(self, field_name, lookup_type, order='ASC'):\n                 self.model._meta.object_name, field_name\n             ))\n         field = result[0]\n-        assert isinstance(field, DateField), \"%r isn't a DateField.\" \\\n-                % field.name\n+        self._check_field(field)                # overridden in DateTimeQuery\n         alias = result[3][-1]\n-        select = Date((alias, field.column), lookup_type)\n+        select = self._get_select((alias, field.column), lookup_type)\n         self.clear_select_clause()\n         self.select = [SelectInfo(select, None)]\n         self.distinct = True\n@@ -250,6 +250,36 @@ def add_date_select(self, field_name, lookup_type, order='ASC'):\n         if field.null:\n             self.add_filter((\"%s__isnull\" % field_name, False))\n \n+    def _check_field(self, field):\n+        assert isinstance(field, DateField), \\\n+            \"%r isn't a DateField.\" % field.name\n+        if settings.USE_TZ:\n+            assert not isinstance(field, DateTimeField), \\\n+                \"%r is a DateTimeField, not a DateField.\" % field.name\n+\n+    def _get_select(self, col, lookup_type):\n+        return Date(col, lookup_type)\n+\n+class DateTimeQuery(DateQuery):\n+    \"\"\"\n+    A DateTimeQuery is like a DateQuery but for a datetime field. If time zone\n+    support is active, the tzinfo attribute contains the time zone to use for\n+    converting the values before truncating them. Otherwise it's set to None.\n+    \"\"\"\n+\n+    compiler = 'SQLDateTimeCompiler'\n+\n+    def _check_field(self, field):\n+        assert isinstance(field, DateTimeField), \\\n+                \"%r isn't a DateTimeField.\" % field.name\n+\n+    def _get_select(self, col, lookup_type):\n+        if self.tzinfo is None:\n+            tzname = None\n+        else:\n+            tzname = timezone._get_timezone_name(self.tzinfo)\n+        return DateTime(col, lookup_type, tzname)\n+\n class AggregateQuery(Query):\n     \"\"\"\n     An AggregateQuery takes another query as a parameter to the FROM"
        },
        {
            "sha": "ef856893b531c19899ecba4af2ecdc846e51c689",
            "filename": "django/db/models/sql/where.py",
            "status": "modified",
            "additions": 21,
            "deletions": 13,
            "changes": 34,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Fwhere.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fdb%2Fmodels%2Fsql%2Fwhere.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fwhere.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -8,11 +8,13 @@\n import datetime\n from itertools import repeat\n \n-from django.utils import tree\n-from django.db.models.fields import Field\n+from django.conf import settings\n+from django.db.models.fields import DateTimeField, Field\n from django.db.models.sql.datastructures import EmptyResultSet, Empty\n from django.db.models.sql.aggregates import Aggregate\n from django.utils.six.moves import xrange\n+from django.utils import timezone\n+from django.utils import tree\n \n # Connection types\n AND = 'AND'\n@@ -60,7 +62,8 @@ def add(self, data, connector):\n         # about the value(s) to the query construction. Specifically, datetime\n         # and empty values need special handling. Other types could be used\n         # here in the future (using Python types is suggested for consistency).\n-        if isinstance(value, datetime.datetime):\n+        if (isinstance(value, datetime.datetime)\n+            or (isinstance(obj.field, DateTimeField) and lookup_type != 'isnull')):\n             value_annotation = datetime.datetime\n         elif hasattr(value, 'value_annotation'):\n             value_annotation = value.value_annotation\n@@ -169,22 +172,22 @@ def make_atom(self, child, qn, connection):\n \n         if isinstance(lvalue, tuple):\n             # A direct database column lookup.\n-            field_sql = self.sql_for_columns(lvalue, qn, connection)\n+            field_sql, field_params = self.sql_for_columns(lvalue, qn, connection), []\n         else:\n             # A smart object with an as_sql() method.\n-            field_sql = lvalue.as_sql(qn, connection)\n+            field_sql, field_params = lvalue.as_sql(qn, connection)\n \n-        if value_annotation is datetime.datetime:\n-            cast_sql = connection.ops.datetime_cast_sql()\n-        else:\n-            cast_sql = '%s'\n+        is_datetime_field = value_annotation is datetime.datetime\n+        cast_sql = connection.ops.datetime_cast_sql() if is_datetime_field else '%s'\n \n         if hasattr(params, 'as_sql'):\n             extra, params = params.as_sql(qn, connection)\n             cast_sql = ''\n         else:\n             extra = ''\n \n+        params = field_params + params\n+\n         if (len(params) == 1 and params[0] == '' and lookup_type == 'exact'\n             and connection.features.interprets_empty_strings_as_nulls):\n             lookup_type = 'isnull'\n@@ -221,9 +224,14 @@ def make_atom(self, child, qn, connection):\n                         params)\n         elif lookup_type in ('range', 'year'):\n             return ('%s BETWEEN %%s and %%s' % field_sql, params)\n+        elif is_datetime_field and lookup_type in ('month', 'day', 'week_day',\n+                                                   'hour', 'minute', 'second'):\n+            tzname = timezone.get_current_timezone_name() if settings.USE_TZ else None\n+            sql, tz_params = connection.ops.datetime_extract_sql(lookup_type, field_sql, tzname)\n+            return ('%s = %%s' % sql, tz_params + params)\n         elif lookup_type in ('month', 'day', 'week_day'):\n-            return ('%s = %%s' % connection.ops.date_extract_sql(lookup_type, field_sql),\n-                    params)\n+            return ('%s = %%s'\n+                    % connection.ops.date_extract_sql(lookup_type, field_sql), params)\n         elif lookup_type == 'isnull':\n             assert value_annotation in (True, False), \"Invalid value_annotation for isnull\"\n             return ('%s IS %sNULL' % (field_sql, ('' if value_annotation else 'NOT ')), ())\n@@ -238,7 +246,7 @@ def sql_for_columns(self, data, qn, connection):\n         \"\"\"\n         Returns the SQL fragment used for the left-hand side of a column\n         constraint (for example, the \"T1.foo\" portion in the clause\n-        \"WHERE ... T1.foo = 6\").\n+        \"WHERE ... T1.foo = 6\") and a list of parameters.\n         \"\"\"\n         table_alias, name, db_type = data\n         if table_alias:\n@@ -331,7 +339,7 @@ def __init__(self, sqls, params):\n \n     def as_sql(self, qn=None, connection=None):\n         sqls = [\"(%s)\" % sql for sql in self.sqls]\n-        return \" AND \".join(sqls), tuple(self.params or ())\n+        return \" AND \".join(sqls), list(self.params or ())\n \n     def clone(self):\n         return self"
        },
        {
            "sha": "29efc7dfac3f9eeafceff329726f6b9e7eddecae",
            "filename": "django/views/generic/dates.py",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/django%2Fviews%2Fgeneric%2Fdates.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/django%2Fviews%2Fgeneric%2Fdates.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fviews%2Fgeneric%2Fdates.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -379,15 +379,18 @@ def get_date_list_period(self):\n \n     def get_date_list(self, queryset, date_type=None, ordering='ASC'):\n         \"\"\"\n-        Get a date list by calling `queryset.dates()`, checking along the way\n-        for empty lists that aren't allowed.\n+        Get a date list by calling `queryset.dates/datetimes()`, checking\n+        along the way for empty lists that aren't allowed.\n         \"\"\"\n         date_field = self.get_date_field()\n         allow_empty = self.get_allow_empty()\n         if date_type is None:\n             date_type = self.get_date_list_period()\n \n-        date_list = queryset.dates(date_field, date_type, ordering)\n+        if self.uses_datetime_field:\n+            date_list = queryset.datetimes(date_field, date_type, ordering)\n+        else:\n+            date_list = queryset.dates(date_field, date_type, ordering)\n         if date_list is not None and not date_list and not allow_empty:\n             name = force_text(queryset.model._meta.verbose_name_plural)\n             raise Http404(_(\"No %(verbose_name_plural)s available\") %"
        },
        {
            "sha": "f77f87dd8e9fb280173015b049074cf109ec7d7d",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 136,
            "deletions": 21,
            "changes": 157,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -550,14 +550,19 @@ dates\n .. method:: dates(field, kind, order='ASC')\n \n Returns a ``DateQuerySet``  a ``QuerySet`` that evaluates to a list of\n-``datetime.datetime`` objects representing all available dates of a particular\n-kind within the contents of the ``QuerySet``.\n+:class:`datetime.date` objects representing all available dates of a\n+particular kind within the contents of the ``QuerySet``.\n \n-``field`` should be the name of a ``DateField`` or ``DateTimeField`` of your\n-model.\n+.. versionchanged:: 1.6\n+    ``dates`` used to return a list of :class:`datetime.datetime` objects.\n+\n+``field`` should be the name of a ``DateField`` of your model.\n+\n+.. versionchanged:: 1.6\n+    ``dates`` used to accept operating on a ``DateTimeField``.\n \n ``kind`` should be either ``\"year\"``, ``\"month\"`` or ``\"day\"``. Each\n-``datetime.datetime`` object in the result list is \"truncated\" to the given\n+``datetime.date`` object in the result list is \"truncated\" to the given\n ``type``.\n \n * ``\"year\"`` returns a list of all distinct year values for the field.\n@@ -572,21 +577,60 @@ model.\n Examples::\n \n     >>> Entry.objects.dates('pub_date', 'year')\n-    [datetime.datetime(2005, 1, 1)]\n+    [datetime.date(2005, 1, 1)]\n     >>> Entry.objects.dates('pub_date', 'month')\n-    [datetime.datetime(2005, 2, 1), datetime.datetime(2005, 3, 1)]\n+    [datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]\n     >>> Entry.objects.dates('pub_date', 'day')\n-    [datetime.datetime(2005, 2, 20), datetime.datetime(2005, 3, 20)]\n+    [datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]\n     >>> Entry.objects.dates('pub_date', 'day', order='DESC')\n-    [datetime.datetime(2005, 3, 20), datetime.datetime(2005, 2, 20)]\n+    [datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]\n     >>> Entry.objects.filter(headline__contains='Lennon').dates('pub_date', 'day')\n-    [datetime.datetime(2005, 3, 20)]\n+    [datetime.date(2005, 3, 20)]\n \n-.. warning::\n+datetimes\n+~~~~~~~~~\n+\n+.. versionadded:: 1.6\n+\n+.. method:: datetimes(field, kind, order='ASC', tzinfo=None)\n+\n+Returns a ``DateTimeQuerySet``  a ``QuerySet`` that evaluates to a list of\n+:class:`datetime.datetime` objects representing all available dates of a\n+particular kind within the contents of the ``QuerySet``.\n+\n+``field`` should be the name of a ``DateTimeField`` of your model.\n+\n+``kind`` should be either ``\"year\"``, ``\"month\"``, ``\"day\"``, ``\"hour\"``,\n+``\"minute\"`` or ``\"second\"``. Each ``datetime.datetime`` object in the result\n+list is \"truncated\" to the given ``type``.\n+\n+``order``, which defaults to ``'ASC'``, should be either ``'ASC'`` or\n+``'DESC'``. This specifies how to order the results.\n+\n+``tzinfo`` defines the time zone to which datetimes are converted prior to\n+truncation. Indeed, a given datetime has different representations depending\n+on the time zone in use. This parameter must be a :class:`datetime.tzinfo`\n+object. If it's ``None``, Django uses the :ref:`current time zone\n+<default-current-time-zone>`. It has no effect when :setting:`USE_TZ` is\n+``False``.\n+\n+.. _database-time-zone-definitions:\n+\n+.. note::\n \n-    When :doc:`time zone support </topics/i18n/timezones>` is enabled, Django\n-    uses UTC in the database connection, which means the aggregation is\n-    performed in UTC. This is a known limitation of the current implementation.\n+    This function performs time zone conversions directly in the database.\n+    As a consequence, your database must be able to interpret the value of\n+    ``tzinfo.tzname(None)``. This translates into the following requirements:\n+\n+    - SQLite: install pytz_  conversions are actually performed in Python.\n+    - PostgreSQL: no requirements (see `Time Zones`_).\n+    - Oracle: no requirements (see `Choosing a Time Zone File`_).\n+    - MySQL: load the time zone tables with `mysql_tzinfo_to_sql`_.\n+\n+    .. _pytz: http://pytz.sourceforge.net/\n+    .. _Time Zones: http://www.postgresql.org/docs/9.2/static/datatype-datetime.html#DATATYPE-TIMEZONES\n+    .. _Choosing a Time Zone File: http://docs.oracle.com/cd/B19306_01/server.102/b14225/ch4datetime.htm#i1006667\n+    .. _mysql_tzinfo_to_sql: http://dev.mysql.com/doc/refman/5.5/en/mysql-tzinfo-to-sql.html\n \n none\n ~~~~\n@@ -2020,7 +2064,7 @@ numbers and even characters.\n year\n ~~~~\n \n-For date/datetime fields, exact year match. Takes a four-digit year.\n+For date and datetime fields, an exact year match. Takes an integer year.\n \n Example::\n \n@@ -2032,6 +2076,9 @@ SQL equivalent::\n \n (The exact SQL syntax varies for each database engine.)\n \n+When :setting:`USE_TZ` is ``True``, datetime fields are converted to the\n+current time zone before filtering.\n+\n .. fieldlookup:: month\n \n month\n@@ -2050,12 +2097,15 @@ SQL equivalent::\n \n (The exact SQL syntax varies for each database engine.)\n \n+When :setting:`USE_TZ` is ``True``, datetime fields are converted to the\n+current time zone before filtering.\n+\n .. fieldlookup:: day\n \n day\n ~~~\n \n-For date and datetime fields, an exact day match.\n+For date and datetime fields, an exact day match. Takes an integer day.\n \n Example::\n \n@@ -2070,6 +2120,9 @@ SQL equivalent::\n Note this will match any record with a pub_date on the third day of the month,\n such as January 3, July 3, etc.\n \n+When :setting:`USE_TZ` is ``True``, datetime fields are converted to the\n+current time zone before filtering.\n+\n .. fieldlookup:: week_day\n \n week_day\n@@ -2091,12 +2144,74 @@ Note this will match any record with a ``pub_date`` that falls on a Monday (day\n 2 of the week), regardless of the month or year in which it occurs. Week days\n are indexed with day 1 being Sunday and day 7 being Saturday.\n \n-.. warning::\n+When :setting:`USE_TZ` is ``True``, datetime fields are converted to the\n+current time zone before filtering.\n+\n+.. fieldlookup:: hour\n+\n+hour\n+~~~~\n+\n+.. versionadded:: 1.6\n+\n+For datetime fields, an exact hour match. Takes an integer between 0 and 23.\n+\n+Example::\n+\n+    Event.objects.filter(timestamp__hour=23)\n+\n+SQL equivalent::\n+\n+    SELECT ... WHERE EXTRACT('hour' FROM timestamp) = '23';\n+\n+(The exact SQL syntax varies for each database engine.)\n+\n+When :setting:`USE_TZ` is ``True``, values are converted to the current time\n+zone before filtering.\n+\n+.. fieldlookup:: minute\n+\n+minute\n+~~~~~~\n+\n+.. versionadded:: 1.6\n+\n+For datetime fields, an exact minute match. Takes an integer between 0 and 59.\n+\n+Example::\n+\n+    Event.objects.filter(timestamp__minute=29)\n+\n+SQL equivalent::\n+\n+    SELECT ... WHERE EXTRACT('minute' FROM timestamp) = '29';\n+\n+(The exact SQL syntax varies for each database engine.)\n+\n+When :setting:`USE_TZ` is ``True``, values are converted to the current time\n+zone before filtering.\n+\n+.. fieldlookup:: second\n+\n+second\n+~~~~~~\n+\n+.. versionadded:: 1.6\n+\n+For datetime fields, an exact second match. Takes an integer between 0 and 59.\n+\n+Example::\n+\n+    Event.objects.filter(timestamp__second=31)\n+\n+SQL equivalent::\n+\n+    SELECT ... WHERE EXTRACT('second' FROM timestamp) = '31';\n+\n+(The exact SQL syntax varies for each database engine.)\n \n-    When :doc:`time zone support </topics/i18n/timezones>` is enabled, Django\n-    uses UTC in the database connection, which means the ``year``, ``month``,\n-    ``day`` and ``week_day`` lookups are performed in UTC. This is a known\n-    limitation of the current implementation.\n+When :setting:`USE_TZ` is ``True``, values are converted to the current time\n+zone before filtering.\n \n .. fieldlookup:: isnull\n "
        },
        {
            "sha": "9594481b9f4f017f14a95f4a7e731f087196cec5",
            "filename": "docs/releases/1.6.txt",
            "status": "modified",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/docs%2Freleases%2F1.6.txt",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/docs%2Freleases%2F1.6.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.6.txt?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -30,6 +30,16 @@ prevention <clickjacking-prevention>` are turned on.\n If the default templates don't suit your tastes, you can use :ref:`custom\n project and app templates <custom-app-and-project-templates>`.\n \n+Time zone aware aggregation\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The support for :doc:`time zones </topics/i18n/timezones>` introduced in\n+Django 1.4 didn't work well with :meth:`QuerySet.dates()\n+<django.db.models.query.QuerySet.dates>`: aggregation was always performed in\n+UTC. This limitation was lifted in Django 1.6. Use :meth:`QuerySet.datetimes()\n+<django.db.models.query.QuerySet.datetimes>` to perform time zone aware\n+aggregation on a :class:`~django.db.models.DateTimeField`.\n+\n Minor features\n ~~~~~~~~~~~~~~\n \n@@ -47,6 +57,9 @@ Minor features\n * Added :meth:`~django.db.models.query.QuerySet.earliest` for symmetry with\n   :meth:`~django.db.models.query.QuerySet.latest`.\n \n+* In addition to :lookup:`year`, :lookup:`month` and :lookup:`day`, the ORM\n+  now supports :lookup:`hour`, :lookup:`minute` and :lookup:`second` lookups.\n+\n * The default widgets for :class:`~django.forms.EmailField` and\n   :class:`~django.forms.URLField` use the new type attributes available in\n   HTML5 (type='email', type='url').\n@@ -80,6 +93,28 @@ Backwards incompatible changes in 1.6\n   :meth:`~django.db.models.query.QuerySet.none` has been called:\n   ``isinstance(qs.none(), EmptyQuerySet)``\n \n+* :meth:`QuerySet.dates() <django.db.models.query.QuerySet.dates>` raises an\n+  error if it's used on :class:`~django.db.models.DateTimeField` when time\n+  zone support is active. Use :meth:`QuerySet.datetimes()\n+  <django.db.models.query.QuerySet.datetimes>` instead.\n+\n+* :meth:`QuerySet.dates() <django.db.models.query.QuerySet.dates>` returns a\n+  list of :class:`~datetime.date`. It used to return a list of\n+  :class:`~datetime.datetime`.\n+\n+* The :attr:`~django.contrib.admin.ModelAdmin.date_hierarchy` feature of the\n+  admin on a :class:`~django.db.models.DateTimeField` requires time zone\n+  definitions in the database when :setting:`USE_TZ` is ``True``.\n+  :ref:`Learn more <database-time-zone-definitions>`.\n+\n+* Accessing ``date_list`` in the context of a date-based generic view requires\n+  time zone definitions in the database when the view is based on a\n+  :class:`~django.db.models.DateTimeField` and :setting:`USE_TZ` is ``True``.\n+  :ref:`Learn more <database-time-zone-definitions>`.\n+\n+* Model fields named ``hour``, ``minute`` or ``second`` may clash with the new\n+  lookups. Append an explicit :lookup:`exact` lookup if this is an issue.\n+\n * If your CSS/Javascript code used to access HTML input widgets by type, you\n   should review it as ``type='text'`` widgets might be now output as\n   ``type='email'`` or ``type='url'`` depending on their corresponding field type."
        },
        {
            "sha": "c635e6ebb6a13180135e163de54e5cee879561fe",
            "filename": "tests/modeltests/aggregation/tests.py",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fmodeltests%2Faggregation%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fmodeltests%2Faggregation%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Faggregation%2Ftests.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -579,9 +579,9 @@ def test_dates_with_aggregation(self):\n         dates = Book.objects.annotate(num_authors=Count(\"authors\")).dates('pubdate', 'year')\n         self.assertQuerysetEqual(\n             dates, [\n-                \"datetime.datetime(1991, 1, 1, 0, 0)\",\n-                \"datetime.datetime(1995, 1, 1, 0, 0)\",\n-                \"datetime.datetime(2007, 1, 1, 0, 0)\",\n-                \"datetime.datetime(2008, 1, 1, 0, 0)\"\n+                \"datetime.date(1991, 1, 1)\",\n+                \"datetime.date(1995, 1, 1)\",\n+                \"datetime.date(2007, 1, 1)\",\n+                \"datetime.date(2008, 1, 1)\"\n             ]\n         )"
        },
        {
            "sha": "e408df8d465a8b9056370d8c4e1d0a7c510367ee",
            "filename": "tests/modeltests/basic/tests.py",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fmodeltests%2Fbasic%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fmodeltests%2Fbasic%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fbasic%2Ftests.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -266,34 +266,34 @@ def test_object_creation(self):\n         # ... but there will often be more efficient ways if that is all you need:\n         self.assertTrue(Article.objects.filter(id=a8.id).exists())\n \n-        # dates() returns a list of available dates of the given scope for\n+        # datetimes() returns a list of available dates of the given scope for\n         # the given field.\n         self.assertQuerysetEqual(\n-            Article.objects.dates('pub_date', 'year'),\n+            Article.objects.datetimes('pub_date', 'year'),\n             [\"datetime.datetime(2005, 1, 1, 0, 0)\"])\n         self.assertQuerysetEqual(\n-            Article.objects.dates('pub_date', 'month'),\n+            Article.objects.datetimes('pub_date', 'month'),\n             [\"datetime.datetime(2005, 7, 1, 0, 0)\"])\n         self.assertQuerysetEqual(\n-            Article.objects.dates('pub_date', 'day'),\n+            Article.objects.datetimes('pub_date', 'day'),\n             [\"datetime.datetime(2005, 7, 28, 0, 0)\",\n              \"datetime.datetime(2005, 7, 29, 0, 0)\",\n              \"datetime.datetime(2005, 7, 30, 0, 0)\",\n              \"datetime.datetime(2005, 7, 31, 0, 0)\"])\n         self.assertQuerysetEqual(\n-            Article.objects.dates('pub_date', 'day', order='ASC'),\n+            Article.objects.datetimes('pub_date', 'day', order='ASC'),\n             [\"datetime.datetime(2005, 7, 28, 0, 0)\",\n              \"datetime.datetime(2005, 7, 29, 0, 0)\",\n              \"datetime.datetime(2005, 7, 30, 0, 0)\",\n              \"datetime.datetime(2005, 7, 31, 0, 0)\"])\n         self.assertQuerysetEqual(\n-            Article.objects.dates('pub_date', 'day', order='DESC'),\n+            Article.objects.datetimes('pub_date', 'day', order='DESC'),\n             [\"datetime.datetime(2005, 7, 31, 0, 0)\",\n              \"datetime.datetime(2005, 7, 30, 0, 0)\",\n              \"datetime.datetime(2005, 7, 29, 0, 0)\",\n              \"datetime.datetime(2005, 7, 28, 0, 0)\"])\n \n-        # dates() requires valid arguments.\n+        # datetimes() requires valid arguments.\n         self.assertRaises(\n             TypeError,\n             Article.objects.dates,\n@@ -324,10 +324,10 @@ def test_object_creation(self):\n             order=\"bad order\",\n         )\n \n-        # Use iterator() with dates() to return a generator that lazily\n+        # Use iterator() with datetimes() to return a generator that lazily\n         # requests each result one at a time, to save memory.\n         dates = []\n-        for article in Article.objects.dates('pub_date', 'day', order='DESC').iterator():\n+        for article in Article.objects.datetimes('pub_date', 'day', order='DESC').iterator():\n             dates.append(article)\n         self.assertEqual(dates, [\n             datetime(2005, 7, 31, 0, 0),"
        },
        {
            "sha": "a4f87a328334ed7e04919473a70a98d7941d27d2",
            "filename": "tests/modeltests/many_to_one/tests.py",
            "status": "modified",
            "additions": 28,
            "deletions": 28,
            "changes": 56,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fmodeltests%2Fmany_to_one%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fmodeltests%2Fmany_to_one%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fmany_to_one%2Ftests.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -1,7 +1,7 @@\n from __future__ import absolute_import\n \n from copy import deepcopy\n-from datetime import datetime\n+import datetime\n \n from django.core.exceptions import MultipleObjectsReturned, FieldError\n from django.test import TestCase\n@@ -20,7 +20,7 @@ def setUp(self):\n         self.r2.save()\n         # Create an Article.\n         self.a = Article(id=None, headline=\"This is a test\",\n-                         pub_date=datetime(2005, 7, 27), reporter=self.r)\n+                         pub_date=datetime.date(2005, 7, 27), reporter=self.r)\n         self.a.save()\n \n     def test_get(self):\n@@ -36,25 +36,25 @@ def test_create(self):\n         # You can also instantiate an Article by passing the Reporter's ID\n         # instead of a Reporter object.\n         a3 = Article(id=None, headline=\"Third article\",\n-                     pub_date=datetime(2005, 7, 27), reporter_id=self.r.id)\n+                     pub_date=datetime.date(2005, 7, 27), reporter_id=self.r.id)\n         a3.save()\n         self.assertEqual(a3.reporter.id, self.r.id)\n \n         # Similarly, the reporter ID can be a string.\n         a4 = Article(id=None, headline=\"Fourth article\",\n-                     pub_date=datetime(2005, 7, 27), reporter_id=str(self.r.id))\n+                     pub_date=datetime.date(2005, 7, 27), reporter_id=str(self.r.id))\n         a4.save()\n         self.assertEqual(repr(a4.reporter), \"<Reporter: John Smith>\")\n \n     def test_add(self):\n         # Create an Article via the Reporter object.\n         new_article = self.r.article_set.create(headline=\"John's second story\",\n-                                                pub_date=datetime(2005, 7, 29))\n+                                                pub_date=datetime.date(2005, 7, 29))\n         self.assertEqual(repr(new_article), \"<Article: John's second story>\")\n         self.assertEqual(new_article.reporter.id, self.r.id)\n \n         # Create a new article, and add it to the article set.\n-        new_article2 = Article(headline=\"Paul's story\", pub_date=datetime(2006, 1, 17))\n+        new_article2 = Article(headline=\"Paul's story\", pub_date=datetime.date(2006, 1, 17))\n         self.r.article_set.add(new_article2)\n         self.assertEqual(new_article2.reporter.id, self.r.id)\n         self.assertQuerysetEqual(self.r.article_set.all(),\n@@ -80,9 +80,9 @@ def test_add(self):\n \n     def test_assign(self):\n         new_article = self.r.article_set.create(headline=\"John's second story\",\n-                                                pub_date=datetime(2005, 7, 29))\n+                                                pub_date=datetime.date(2005, 7, 29))\n         new_article2 = self.r2.article_set.create(headline=\"Paul's story\",\n-                                                  pub_date=datetime(2006, 1, 17))\n+                                                  pub_date=datetime.date(2006, 1, 17))\n         # Assign the article to the reporter directly using the descriptor.\n         new_article2.reporter = self.r\n         new_article2.save()\n@@ -118,9 +118,9 @@ def test_assign(self):\n \n     def test_selects(self):\n         new_article = self.r.article_set.create(headline=\"John's second story\",\n-                                                pub_date=datetime(2005, 7, 29))\n+                                                pub_date=datetime.date(2005, 7, 29))\n         new_article2 = self.r2.article_set.create(headline=\"Paul's story\",\n-                                                  pub_date=datetime(2006, 1, 17))\n+                                                  pub_date=datetime.date(2006, 1, 17))\n         # Reporter objects have access to their related Article objects.\n         self.assertQuerysetEqual(self.r.article_set.all(), [\n             \"<Article: John's second story>\",\n@@ -237,9 +237,9 @@ def test_selects(self):\n \n     def test_reverse_selects(self):\n         a3 = Article.objects.create(id=None, headline=\"Third article\",\n-                                    pub_date=datetime(2005, 7, 27), reporter_id=self.r.id)\n+                                    pub_date=datetime.date(2005, 7, 27), reporter_id=self.r.id)\n         a4 = Article.objects.create(id=None, headline=\"Fourth article\",\n-                                    pub_date=datetime(2005, 7, 27), reporter_id=str(self.r.id))\n+                                    pub_date=datetime.date(2005, 7, 27), reporter_id=str(self.r.id))\n         # Reporters can be queried\n         self.assertQuerysetEqual(Reporter.objects.filter(id__exact=self.r.id),\n                                  [\"<Reporter: John Smith>\"])\n@@ -316,33 +316,33 @@ def test_select_related(self):\n         # objects (Reporters).\n         r1 = Reporter.objects.create(first_name='Mike', last_name='Royko', email='royko@suntimes.com')\n         r2 = Reporter.objects.create(first_name='John', last_name='Kass', email='jkass@tribune.com')\n-        a1 = Article.objects.create(headline='First', pub_date=datetime(1980, 4, 23), reporter=r1)\n-        a2 = Article.objects.create(headline='Second', pub_date=datetime(1980, 4, 23), reporter=r2)\n+        Article.objects.create(headline='First', pub_date=datetime.date(1980, 4, 23), reporter=r1)\n+        Article.objects.create(headline='Second', pub_date=datetime.date(1980, 4, 23), reporter=r2)\n         self.assertEqual(list(Article.objects.select_related().dates('pub_date', 'day')),\n             [\n-                datetime(1980, 4, 23, 0, 0),\n-                datetime(2005, 7, 27, 0, 0),\n+                datetime.date(1980, 4, 23),\n+                datetime.date(2005, 7, 27),\n             ])\n         self.assertEqual(list(Article.objects.select_related().dates('pub_date', 'month')),\n             [\n-                datetime(1980, 4, 1, 0, 0),\n-                datetime(2005, 7, 1, 0, 0),\n+                datetime.date(1980, 4, 1),\n+                datetime.date(2005, 7, 1),\n             ])\n         self.assertEqual(list(Article.objects.select_related().dates('pub_date', 'year')),\n             [\n-                datetime(1980, 1, 1, 0, 0),\n-                datetime(2005, 1, 1, 0, 0),\n+                datetime.date(1980, 1, 1),\n+                datetime.date(2005, 1, 1),\n             ])\n \n     def test_delete(self):\n         new_article = self.r.article_set.create(headline=\"John's second story\",\n-                                                pub_date=datetime(2005, 7, 29))\n+                                                pub_date=datetime.date(2005, 7, 29))\n         new_article2 = self.r2.article_set.create(headline=\"Paul's story\",\n-                                                  pub_date=datetime(2006, 1, 17))\n+                                                  pub_date=datetime.date(2006, 1, 17))\n         a3 = Article.objects.create(id=None, headline=\"Third article\",\n-                                    pub_date=datetime(2005, 7, 27), reporter_id=self.r.id)\n+                                    pub_date=datetime.date(2005, 7, 27), reporter_id=self.r.id)\n         a4 = Article.objects.create(id=None, headline=\"Fourth article\",\n-                                    pub_date=datetime(2005, 7, 27), reporter_id=str(self.r.id))\n+                                    pub_date=datetime.date(2005, 7, 27), reporter_id=str(self.r.id))\n         # If you delete a reporter, his articles will be deleted.\n         self.assertQuerysetEqual(Article.objects.all(),\n             [\n@@ -383,7 +383,7 @@ def test_explicit_fk(self):\n         # for a ForeignKey.\n         a2, created = Article.objects.get_or_create(id=None,\n                                                     headline=\"John's second test\",\n-                                                    pub_date=datetime(2011, 5, 7),\n+                                                    pub_date=datetime.date(2011, 5, 7),\n                                                     reporter_id=self.r.id)\n         self.assertTrue(created)\n         self.assertEqual(a2.reporter.id, self.r.id)\n@@ -398,7 +398,7 @@ def test_explicit_fk(self):\n \n         # Create an Article by Paul for the same date.\n         a3 = Article.objects.create(id=None, headline=\"Paul's commentary\",\n-                                    pub_date=datetime(2011, 5, 7),\n+                                    pub_date=datetime.date(2011, 5, 7),\n                                     reporter_id=self.r2.id)\n         self.assertEqual(a3.reporter.id, self.r2.id)\n \n@@ -407,7 +407,7 @@ def test_explicit_fk(self):\n                           Article.objects.get, reporter_id=self.r.id)\n         self.assertEqual(repr(a3),\n                          repr(Article.objects.get(reporter_id=self.r2.id,\n-                                             pub_date=datetime(2011, 5, 7))))\n+                                             pub_date=datetime.date(2011, 5, 7))))\n \n     def test_manager_class_caching(self):\n         r1 = Reporter.objects.create(first_name='Mike')\n@@ -425,7 +425,7 @@ def test_create_relation_with_ugettext_lazy(self):\n                                            email='john.smith@example.com')\n         lazy = ugettext_lazy('test')\n         reporter.article_set.create(headline=lazy,\n-                                    pub_date=datetime(2011, 6, 10))\n+                                    pub_date=datetime.date(2011, 6, 10))\n         notlazy = six.text_type(lazy)\n         article = reporter.article_set.get()\n         self.assertEqual(article.headline, notlazy)"
        },
        {
            "sha": "ddffe08d345082f99a902dfe03e7f6c55f43a35d",
            "filename": "tests/modeltests/reserved_names/tests.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fmodeltests%2Freserved_names%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fmodeltests%2Freserved_names%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Freserved_names%2Ftests.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -42,8 +42,8 @@ def test_dates(self):\n         self.generate()\n         resp = Thing.objects.dates('where', 'year')\n         self.assertEqual(list(resp), [\n-            datetime.datetime(2005, 1, 1, 0, 0),\n-            datetime.datetime(2006, 1, 1, 0, 0),\n+            datetime.date(2005, 1, 1),\n+            datetime.date(2006, 1, 1),\n         ])\n \n     def test_month_filter(self):"
        },
        {
            "sha": "8786c1912ff511854c342f7a6610044c532f0445",
            "filename": "tests/modeltests/timezones/tests.py",
            "status": "modified",
            "additions": 100,
            "deletions": 28,
            "changes": 128,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fmodeltests%2Ftimezones%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fmodeltests%2Ftimezones%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Ftimezones%2Ftests.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -189,13 +189,16 @@ def test_query_filter(self):\n         self.assertEqual(Event.objects.filter(dt__gte=dt2).count(), 1)\n         self.assertEqual(Event.objects.filter(dt__gt=dt2).count(), 0)\n \n-    def test_query_date_related_filters(self):\n+    def test_query_datetime_lookups(self):\n         Event.objects.create(dt=datetime.datetime(2011, 1, 1, 1, 30, 0))\n         Event.objects.create(dt=datetime.datetime(2011, 1, 1, 4, 30, 0))\n         self.assertEqual(Event.objects.filter(dt__year=2011).count(), 2)\n         self.assertEqual(Event.objects.filter(dt__month=1).count(), 2)\n         self.assertEqual(Event.objects.filter(dt__day=1).count(), 2)\n         self.assertEqual(Event.objects.filter(dt__week_day=7).count(), 2)\n+        self.assertEqual(Event.objects.filter(dt__hour=1).count(), 1)\n+        self.assertEqual(Event.objects.filter(dt__minute=30).count(), 2)\n+        self.assertEqual(Event.objects.filter(dt__second=0).count(), 2)\n \n     def test_query_aggregation(self):\n         # Only min and max make sense for datetimes.\n@@ -230,15 +233,30 @@ def test_query_annotation(self):\n                 [afternoon_min_dt],\n                 transform=lambda d: d.dt)\n \n-    def test_query_dates(self):\n+    def test_query_datetimes(self):\n         Event.objects.create(dt=datetime.datetime(2011, 1, 1, 1, 30, 0))\n         Event.objects.create(dt=datetime.datetime(2011, 1, 1, 4, 30, 0))\n-        self.assertQuerysetEqual(Event.objects.dates('dt', 'year'),\n-                [datetime.datetime(2011, 1, 1)], transform=lambda d: d)\n-        self.assertQuerysetEqual(Event.objects.dates('dt', 'month'),\n-                [datetime.datetime(2011, 1, 1)], transform=lambda d: d)\n-        self.assertQuerysetEqual(Event.objects.dates('dt', 'day'),\n-                [datetime.datetime(2011, 1, 1)], transform=lambda d: d)\n+        self.assertQuerysetEqual(Event.objects.datetimes('dt', 'year'),\n+                [datetime.datetime(2011, 1, 1, 0, 0, 0)],\n+                transform=lambda d: d)\n+        self.assertQuerysetEqual(Event.objects.datetimes('dt', 'month'),\n+                [datetime.datetime(2011, 1, 1, 0, 0, 0)],\n+                transform=lambda d: d)\n+        self.assertQuerysetEqual(Event.objects.datetimes('dt', 'day'),\n+                [datetime.datetime(2011, 1, 1, 0, 0, 0)],\n+                transform=lambda d: d)\n+        self.assertQuerysetEqual(Event.objects.datetimes('dt', 'hour'),\n+                [datetime.datetime(2011, 1, 1, 1, 0, 0),\n+                 datetime.datetime(2011, 1, 1, 4, 0, 0)],\n+                transform=lambda d: d)\n+        self.assertQuerysetEqual(Event.objects.datetimes('dt', 'minute'),\n+                [datetime.datetime(2011, 1, 1, 1, 30, 0),\n+                 datetime.datetime(2011, 1, 1, 4, 30, 0)],\n+                transform=lambda d: d)\n+        self.assertQuerysetEqual(Event.objects.datetimes('dt', 'second'),\n+                [datetime.datetime(2011, 1, 1, 1, 30, 0),\n+                 datetime.datetime(2011, 1, 1, 4, 30, 0)],\n+                transform=lambda d: d)\n \n     def test_raw_sql(self):\n         # Regression test for #17755\n@@ -398,17 +416,32 @@ def test_query_filter_with_naive_datetime(self):\n                 msg = str(warning.message)\n                 self.assertTrue(msg.startswith(\"DateTimeField received a naive datetime\"))\n \n-    def test_query_date_related_filters(self):\n-        # These two dates fall in the same day in EAT, but in different days,\n-        # years and months in UTC, and aggregation is performed in UTC when\n-        # time zone support is enabled. This test could be changed if the\n-        # implementation is changed to perform the aggregation is local time.\n+    @skipUnlessDBFeature('has_zoneinfo_database')\n+    def test_query_datetime_lookups(self):\n         Event.objects.create(dt=datetime.datetime(2011, 1, 1, 1, 30, 0, tzinfo=EAT))\n         Event.objects.create(dt=datetime.datetime(2011, 1, 1, 4, 30, 0, tzinfo=EAT))\n-        self.assertEqual(Event.objects.filter(dt__year=2011).count(), 1)\n-        self.assertEqual(Event.objects.filter(dt__month=1).count(), 1)\n-        self.assertEqual(Event.objects.filter(dt__day=1).count(), 1)\n-        self.assertEqual(Event.objects.filter(dt__week_day=7).count(), 1)\n+        self.assertEqual(Event.objects.filter(dt__year=2011).count(), 2)\n+        self.assertEqual(Event.objects.filter(dt__month=1).count(), 2)\n+        self.assertEqual(Event.objects.filter(dt__day=1).count(), 2)\n+        self.assertEqual(Event.objects.filter(dt__week_day=7).count(), 2)\n+        self.assertEqual(Event.objects.filter(dt__hour=1).count(), 1)\n+        self.assertEqual(Event.objects.filter(dt__minute=30).count(), 2)\n+        self.assertEqual(Event.objects.filter(dt__second=0).count(), 2)\n+\n+    @skipUnlessDBFeature('has_zoneinfo_database')\n+    def test_query_datetime_lookups_in_other_timezone(self):\n+        Event.objects.create(dt=datetime.datetime(2011, 1, 1, 1, 30, 0, tzinfo=EAT))\n+        Event.objects.create(dt=datetime.datetime(2011, 1, 1, 4, 30, 0, tzinfo=EAT))\n+        with timezone.override(UTC):\n+            # These two dates fall in the same day in EAT, but in different days,\n+            # years and months in UTC.\n+            self.assertEqual(Event.objects.filter(dt__year=2011).count(), 1)\n+            self.assertEqual(Event.objects.filter(dt__month=1).count(), 1)\n+            self.assertEqual(Event.objects.filter(dt__day=1).count(), 1)\n+            self.assertEqual(Event.objects.filter(dt__week_day=7).count(), 1)\n+            self.assertEqual(Event.objects.filter(dt__hour=22).count(), 1)\n+            self.assertEqual(Event.objects.filter(dt__minute=30).count(), 2)\n+            self.assertEqual(Event.objects.filter(dt__second=0).count(), 2)\n \n     def test_query_aggregation(self):\n         # Only min and max make sense for datetimes.\n@@ -443,22 +476,61 @@ def test_query_annotation(self):\n                 [afternoon_min_dt],\n                 transform=lambda d: d.dt)\n \n-    def test_query_dates(self):\n-        # Same comment as in test_query_date_related_filters.\n+    @skipUnlessDBFeature('has_zoneinfo_database')\n+    def test_query_datetimes(self):\n         Event.objects.create(dt=datetime.datetime(2011, 1, 1, 1, 30, 0, tzinfo=EAT))\n         Event.objects.create(dt=datetime.datetime(2011, 1, 1, 4, 30, 0, tzinfo=EAT))\n-        self.assertQuerysetEqual(Event.objects.dates('dt', 'year'),\n-                [datetime.datetime(2010, 1, 1, tzinfo=UTC),\n-                 datetime.datetime(2011, 1, 1, tzinfo=UTC)],\n+        self.assertQuerysetEqual(Event.objects.datetimes('dt', 'year'),\n+                [datetime.datetime(2011, 1, 1, 0, 0, 0, tzinfo=EAT)],\n+                transform=lambda d: d)\n+        self.assertQuerysetEqual(Event.objects.datetimes('dt', 'month'),\n+                [datetime.datetime(2011, 1, 1, 0, 0, 0, tzinfo=EAT)],\n+                transform=lambda d: d)\n+        self.assertQuerysetEqual(Event.objects.datetimes('dt', 'day'),\n+                [datetime.datetime(2011, 1, 1, 0, 0, 0, tzinfo=EAT)],\n                 transform=lambda d: d)\n-        self.assertQuerysetEqual(Event.objects.dates('dt', 'month'),\n-                [datetime.datetime(2010, 12, 1, tzinfo=UTC),\n-                 datetime.datetime(2011, 1, 1, tzinfo=UTC)],\n+        self.assertQuerysetEqual(Event.objects.datetimes('dt', 'hour'),\n+                [datetime.datetime(2011, 1, 1, 1, 0, 0, tzinfo=EAT),\n+                 datetime.datetime(2011, 1, 1, 4, 0, 0, tzinfo=EAT)],\n                 transform=lambda d: d)\n-        self.assertQuerysetEqual(Event.objects.dates('dt', 'day'),\n-                [datetime.datetime(2010, 12, 31, tzinfo=UTC),\n-                 datetime.datetime(2011, 1, 1, tzinfo=UTC)],\n+        self.assertQuerysetEqual(Event.objects.datetimes('dt', 'minute'),\n+                [datetime.datetime(2011, 1, 1, 1, 30, 0, tzinfo=EAT),\n+                 datetime.datetime(2011, 1, 1, 4, 30, 0, tzinfo=EAT)],\n                 transform=lambda d: d)\n+        self.assertQuerysetEqual(Event.objects.datetimes('dt', 'second'),\n+                [datetime.datetime(2011, 1, 1, 1, 30, 0, tzinfo=EAT),\n+                 datetime.datetime(2011, 1, 1, 4, 30, 0, tzinfo=EAT)],\n+                transform=lambda d: d)\n+\n+    @skipUnlessDBFeature('has_zoneinfo_database')\n+    def test_query_datetimes_in_other_timezone(self):\n+        Event.objects.create(dt=datetime.datetime(2011, 1, 1, 1, 30, 0, tzinfo=EAT))\n+        Event.objects.create(dt=datetime.datetime(2011, 1, 1, 4, 30, 0, tzinfo=EAT))\n+        with timezone.override(UTC):\n+            self.assertQuerysetEqual(Event.objects.datetimes('dt', 'year'),\n+                    [datetime.datetime(2010, 1, 1, 0, 0, 0, tzinfo=UTC),\n+                     datetime.datetime(2011, 1, 1, 0, 0, 0, tzinfo=UTC)],\n+                    transform=lambda d: d)\n+            self.assertQuerysetEqual(Event.objects.datetimes('dt', 'month'),\n+                    [datetime.datetime(2010, 12, 1, 0, 0, 0, tzinfo=UTC),\n+                     datetime.datetime(2011, 1, 1, 0, 0, 0, tzinfo=UTC)],\n+                    transform=lambda d: d)\n+            self.assertQuerysetEqual(Event.objects.datetimes('dt', 'day'),\n+                    [datetime.datetime(2010, 12, 31, 0, 0, 0, tzinfo=UTC),\n+                     datetime.datetime(2011, 1, 1, 0, 0, 0, tzinfo=UTC)],\n+                    transform=lambda d: d)\n+            self.assertQuerysetEqual(Event.objects.datetimes('dt', 'hour'),\n+                    [datetime.datetime(2010, 12, 31, 22, 0, 0, tzinfo=UTC),\n+                     datetime.datetime(2011, 1, 1, 1, 0, 0, tzinfo=UTC)],\n+                    transform=lambda d: d)\n+            self.assertQuerysetEqual(Event.objects.datetimes('dt', 'minute'),\n+                    [datetime.datetime(2010, 12, 31, 22, 30, 0, tzinfo=UTC),\n+                     datetime.datetime(2011, 1, 1, 1, 30, 0, tzinfo=UTC)],\n+                    transform=lambda d: d)\n+            self.assertQuerysetEqual(Event.objects.datetimes('dt', 'second'),\n+                    [datetime.datetime(2010, 12, 31, 22, 30, 0, tzinfo=UTC),\n+                     datetime.datetime(2011, 1, 1, 1, 30, 0, tzinfo=UTC)],\n+                    transform=lambda d: d)\n \n     def test_raw_sql(self):\n         # Regression test for #17755"
        },
        {
            "sha": "076567538b85d9b0c859dad43de16ba59ac16442",
            "filename": "tests/regressiontests/aggregation_regress/tests.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Faggregation_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Faggregation_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Faggregation_regress%2Ftests.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -546,8 +546,8 @@ def test_more_more_more(self):\n         qs = Book.objects.annotate(num_authors=Count('authors')).filter(num_authors=2).dates('pubdate', 'day')\n         self.assertQuerysetEqual(\n             qs, [\n-                datetime.datetime(1995, 1, 15, 0, 0),\n-                datetime.datetime(2007, 12, 6, 0, 0)\n+                datetime.date(1995, 1, 15),\n+                datetime.date(2007, 12, 6),\n             ],\n             lambda b: b\n         )"
        },
        {
            "sha": "fbe5026e12b766aad3fc6d07605f1e3fc92f93d8",
            "filename": "tests/regressiontests/backends/tests.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fbackends%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fbackends%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fbackends%2Ftests.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -144,11 +144,11 @@ def test_django_date_trunc(self):\n         updated = datetime.datetime(2010, 2, 20)\n         models.SchoolClass.objects.create(year=2009, last_updated=updated)\n         years = models.SchoolClass.objects.dates('last_updated', 'year')\n-        self.assertEqual(list(years), [datetime.datetime(2010, 1, 1, 0, 0)])\n+        self.assertEqual(list(years), [datetime.date(2010, 1, 1)])\n \n-    def test_django_extract(self):\n+    def test_django_date_extract(self):\n         \"\"\"\n-        Test the custom ``django_extract method``, in particular against fields\n+        Test the custom ``django_date_extract method``, in particular against fields\n         which clash with strings passed to it (e.g. 'day') - see #12818__.\n \n         __: http://code.djangoproject.com/ticket/12818"
        },
        {
            "sha": "23350755e71183633e0caf8162aa83e598450971",
            "filename": "tests/regressiontests/dates/models.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fdates%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fdates%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fdates%2Fmodels.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -1,3 +1,5 @@\n+from __future__ import unicode_literals\n+\n from django.db import models\n from django.utils.encoding import python_2_unicode_compatible\n "
        },
        {
            "sha": "6c02d597decf2f1ed064ba14f68dbe28a6439136",
            "filename": "tests/regressiontests/dates/tests.py",
            "status": "modified",
            "additions": 19,
            "deletions": 19,
            "changes": 38,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fdates%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fdates%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fdates%2Ftests.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -1,6 +1,6 @@\n from __future__ import absolute_import\n \n-from datetime import datetime\n+import datetime\n \n from django.test import TestCase\n \n@@ -11,64 +11,64 @@ class DatesTests(TestCase):\n     def test_related_model_traverse(self):\n         a1 = Article.objects.create(\n             title=\"First one\",\n-            pub_date=datetime(2005, 7, 28),\n+            pub_date=datetime.date(2005, 7, 28),\n         )\n         a2 = Article.objects.create(\n             title=\"Another one\",\n-            pub_date=datetime(2010, 7, 28),\n+            pub_date=datetime.date(2010, 7, 28),\n         )\n         a3 = Article.objects.create(\n             title=\"Third one, in the first day\",\n-            pub_date=datetime(2005, 7, 28),\n+            pub_date=datetime.date(2005, 7, 28),\n         )\n \n         a1.comments.create(\n             text=\"Im the HULK!\",\n-            pub_date=datetime(2005, 7, 28),\n+            pub_date=datetime.date(2005, 7, 28),\n         )\n         a1.comments.create(\n             text=\"HULK SMASH!\",\n-            pub_date=datetime(2005, 7, 29),\n+            pub_date=datetime.date(2005, 7, 29),\n         )\n         a2.comments.create(\n             text=\"LMAO\",\n-            pub_date=datetime(2010, 7, 28),\n+            pub_date=datetime.date(2010, 7, 28),\n         )\n         a3.comments.create(\n             text=\"+1\",\n-            pub_date=datetime(2005, 8, 29),\n+            pub_date=datetime.date(2005, 8, 29),\n         )\n \n         c = Category.objects.create(name=\"serious-news\")\n         c.articles.add(a1, a3)\n \n         self.assertQuerysetEqual(\n             Comment.objects.dates(\"article__pub_date\", \"year\"), [\n-                datetime(2005, 1, 1),\n-                datetime(2010, 1, 1),\n+                datetime.date(2005, 1, 1),\n+                datetime.date(2010, 1, 1),\n             ],\n             lambda d: d,\n         )\n         self.assertQuerysetEqual(\n             Comment.objects.dates(\"article__pub_date\", \"month\"), [\n-                datetime(2005, 7, 1),\n-                datetime(2010, 7, 1),\n+                datetime.date(2005, 7, 1),\n+                datetime.date(2010, 7, 1),\n             ],\n             lambda d: d\n         )\n         self.assertQuerysetEqual(\n             Comment.objects.dates(\"article__pub_date\", \"day\"), [\n-                datetime(2005, 7, 28),\n-                datetime(2010, 7, 28),\n+                datetime.date(2005, 7, 28),\n+                datetime.date(2010, 7, 28),\n             ],\n             lambda d: d\n         )\n         self.assertQuerysetEqual(\n             Article.objects.dates(\"comments__pub_date\", \"day\"), [\n-                datetime(2005, 7, 28),\n-                datetime(2005, 7, 29),\n-                datetime(2005, 8, 29),\n-                datetime(2010, 7, 28),\n+                datetime.date(2005, 7, 28),\n+                datetime.date(2005, 7, 29),\n+                datetime.date(2005, 8, 29),\n+                datetime.date(2010, 7, 28),\n             ],\n             lambda d: d\n         )\n@@ -77,7 +77,7 @@ def test_related_model_traverse(self):\n         )\n         self.assertQuerysetEqual(\n             Category.objects.dates(\"articles__pub_date\", \"day\"), [\n-                datetime(2005, 7, 28),\n+                datetime.date(2005, 7, 28),\n             ],\n             lambda d: d,\n         )"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/regressiontests/datetimes/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fdatetimes%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fdatetimes%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fdatetimes%2F__init__.py?ref=e74e207cce54802f897adcb42149440ee154821e"
        },
        {
            "sha": "f21376aa1c073887bbac89ebadc394e1758bb87f",
            "filename": "tests/regressiontests/datetimes/models.py",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fdatetimes%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fdatetimes%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fdatetimes%2Fmodels.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -0,0 +1,28 @@\n+from __future__ import unicode_literals\n+\n+from django.db import models\n+from django.utils.encoding import python_2_unicode_compatible\n+\n+\n+@python_2_unicode_compatible\n+class Article(models.Model):\n+    title = models.CharField(max_length=100)\n+    pub_date = models.DateTimeField()\n+\n+    categories = models.ManyToManyField(\"Category\", related_name=\"articles\")\n+\n+    def __str__(self):\n+        return self.title\n+\n+@python_2_unicode_compatible\n+class Comment(models.Model):\n+    article = models.ForeignKey(Article, related_name=\"comments\")\n+    text = models.TextField()\n+    pub_date = models.DateTimeField()\n+    approval_date = models.DateTimeField(null=True)\n+\n+    def __str__(self):\n+        return 'Comment to %s (%s)' % (self.article.title, self.pub_date)\n+\n+class Category(models.Model):\n+    name = models.CharField(max_length=255)"
        },
        {
            "sha": "58cb060f6ba897d2508e5f9259ff49e302d9eb6b",
            "filename": "tests/regressiontests/datetimes/tests.py",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fdatetimes%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fdatetimes%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fdatetimes%2Ftests.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -0,0 +1,83 @@\n+from __future__ import absolute_import\n+\n+import datetime\n+\n+from django.test import TestCase\n+\n+from .models import Article, Comment, Category\n+\n+\n+class DateTimesTests(TestCase):\n+    def test_related_model_traverse(self):\n+        a1 = Article.objects.create(\n+            title=\"First one\",\n+            pub_date=datetime.datetime(2005, 7, 28, 9, 0, 0),\n+        )\n+        a2 = Article.objects.create(\n+            title=\"Another one\",\n+            pub_date=datetime.datetime(2010, 7, 28, 10, 0, 0),\n+        )\n+        a3 = Article.objects.create(\n+            title=\"Third one, in the first day\",\n+            pub_date=datetime.datetime(2005, 7, 28, 17, 0, 0),\n+        )\n+\n+        a1.comments.create(\n+            text=\"Im the HULK!\",\n+            pub_date=datetime.datetime(2005, 7, 28, 9, 30, 0),\n+        )\n+        a1.comments.create(\n+            text=\"HULK SMASH!\",\n+            pub_date=datetime.datetime(2005, 7, 29, 1, 30, 0),\n+        )\n+        a2.comments.create(\n+            text=\"LMAO\",\n+            pub_date=datetime.datetime(2010, 7, 28, 10, 10, 10),\n+        )\n+        a3.comments.create(\n+            text=\"+1\",\n+            pub_date=datetime.datetime(2005, 8, 29, 10, 10, 10),\n+        )\n+\n+        c = Category.objects.create(name=\"serious-news\")\n+        c.articles.add(a1, a3)\n+\n+        self.assertQuerysetEqual(\n+            Comment.objects.datetimes(\"article__pub_date\", \"year\"), [\n+                datetime.datetime(2005, 1, 1),\n+                datetime.datetime(2010, 1, 1),\n+            ],\n+            lambda d: d,\n+        )\n+        self.assertQuerysetEqual(\n+            Comment.objects.datetimes(\"article__pub_date\", \"month\"), [\n+                datetime.datetime(2005, 7, 1),\n+                datetime.datetime(2010, 7, 1),\n+            ],\n+            lambda d: d\n+        )\n+        self.assertQuerysetEqual(\n+            Comment.objects.datetimes(\"article__pub_date\", \"day\"), [\n+                datetime.datetime(2005, 7, 28),\n+                datetime.datetime(2010, 7, 28),\n+            ],\n+            lambda d: d\n+        )\n+        self.assertQuerysetEqual(\n+            Article.objects.datetimes(\"comments__pub_date\", \"day\"), [\n+                datetime.datetime(2005, 7, 28),\n+                datetime.datetime(2005, 7, 29),\n+                datetime.datetime(2005, 8, 29),\n+                datetime.datetime(2010, 7, 28),\n+            ],\n+            lambda d: d\n+        )\n+        self.assertQuerysetEqual(\n+            Article.objects.datetimes(\"comments__approval_date\", \"day\"), []\n+        )\n+        self.assertQuerysetEqual(\n+            Category.objects.datetimes(\"articles__pub_date\", \"day\"), [\n+                datetime.datetime(2005, 7, 28),\n+            ],\n+            lambda d: d,\n+        )"
        },
        {
            "sha": "194b250c999951dfc6590f015719072f29dfb017",
            "filename": "tests/regressiontests/extra_regress/tests.py",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fextra_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fextra_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fextra_regress%2Ftests.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -166,8 +166,9 @@ def test_dates_query(self):\n         )\n \n         self.assertQuerysetEqual(\n-            RevisionableModel.objects.extra(select={\"the_answer\": 'id'}).dates('when', 'month'),\n-            ['datetime.datetime(2008, 9, 1, 0, 0)']\n+            RevisionableModel.objects.extra(select={\"the_answer\": 'id'}).datetimes('when', 'month'),\n+            [datetime.datetime(2008, 9, 1, 0, 0)],\n+            transform=lambda d: d,\n         )\n \n     def test_values_with_extra(self):"
        },
        {
            "sha": "844b10bbcc2ad6fa441639a1921c14bdd4011a37",
            "filename": "tests/regressiontests/generic_views/dates.py",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fgeneric_views%2Fdates.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fgeneric_views%2Fdates.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fgeneric_views%2Fdates.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -4,7 +4,7 @@\n import datetime\n \n from django.core.exceptions import ImproperlyConfigured\n-from django.test import TestCase\n+from django.test import TestCase, skipUnlessDBFeature\n from django.test.utils import override_settings\n from django.utils import timezone\n from django.utils.unittest import skipUnless\n@@ -119,6 +119,7 @@ def test_datetime_archive_view(self):\n         self.assertEqual(res.status_code, 200)\n \n     @requires_tz_support\n+    @skipUnlessDBFeature('has_zoneinfo_database')\n     @override_settings(USE_TZ=True, TIME_ZONE='Africa/Nairobi')\n     def test_aware_datetime_archive_view(self):\n         BookSigning.objects.create(event_date=datetime.datetime(2008, 4, 2, 12, 0, tzinfo=timezone.utc))\n@@ -140,7 +141,7 @@ class YearArchiveViewTests(TestCase):\n     def test_year_view(self):\n         res = self.client.get('/dates/books/2008/')\n         self.assertEqual(res.status_code, 200)\n-        self.assertEqual(list(res.context['date_list']), [datetime.datetime(2008, 10, 1)])\n+        self.assertEqual(list(res.context['date_list']), [datetime.date(2008, 10, 1)])\n         self.assertEqual(res.context['year'], datetime.date(2008, 1, 1))\n         self.assertTemplateUsed(res, 'generic_views/book_archive_year.html')\n \n@@ -151,7 +152,7 @@ def test_year_view(self):\n     def test_year_view_make_object_list(self):\n         res = self.client.get('/dates/books/2006/make_object_list/')\n         self.assertEqual(res.status_code, 200)\n-        self.assertEqual(list(res.context['date_list']), [datetime.datetime(2006, 5, 1)])\n+        self.assertEqual(list(res.context['date_list']), [datetime.date(2006, 5, 1)])\n         self.assertEqual(list(res.context['book_list']), list(Book.objects.filter(pubdate__year=2006)))\n         self.assertEqual(list(res.context['object_list']), list(Book.objects.filter(pubdate__year=2006)))\n         self.assertTemplateUsed(res, 'generic_views/book_archive_year.html')\n@@ -181,7 +182,7 @@ def test_year_view_allow_future(self):\n \n         res = self.client.get('/dates/books/%s/allow_future/' % year)\n         self.assertEqual(res.status_code, 200)\n-        self.assertEqual(list(res.context['date_list']), [datetime.datetime(year, 1, 1)])\n+        self.assertEqual(list(res.context['date_list']), [datetime.date(year, 1, 1)])\n \n     def test_year_view_paginated(self):\n         res = self.client.get('/dates/books/2006/paginated/')\n@@ -204,6 +205,7 @@ def test_datetime_year_view(self):\n         res = self.client.get('/dates/booksignings/2008/')\n         self.assertEqual(res.status_code, 200)\n \n+    @skipUnlessDBFeature('has_zoneinfo_database')\n     @override_settings(USE_TZ=True, TIME_ZONE='Africa/Nairobi')\n     def test_aware_datetime_year_view(self):\n         BookSigning.objects.create(event_date=datetime.datetime(2008, 4, 2, 12, 0, tzinfo=timezone.utc))\n@@ -225,7 +227,7 @@ def test_month_view(self):\n         res = self.client.get('/dates/books/2008/oct/')\n         self.assertEqual(res.status_code, 200)\n         self.assertTemplateUsed(res, 'generic_views/book_archive_month.html')\n-        self.assertEqual(list(res.context['date_list']), [datetime.datetime(2008, 10, 1)])\n+        self.assertEqual(list(res.context['date_list']), [datetime.date(2008, 10, 1)])\n         self.assertEqual(list(res.context['book_list']),\n                          list(Book.objects.filter(pubdate=datetime.date(2008, 10, 1))))\n         self.assertEqual(res.context['month'], datetime.date(2008, 10, 1))\n@@ -268,7 +270,7 @@ def test_month_view_allow_future(self):\n         # allow_future = True, valid future month\n         res = self.client.get('/dates/books/%s/allow_future/' % urlbit)\n         self.assertEqual(res.status_code, 200)\n-        self.assertEqual(res.context['date_list'][0].date(), b.pubdate)\n+        self.assertEqual(res.context['date_list'][0], b.pubdate)\n         self.assertEqual(list(res.context['book_list']), [b])\n         self.assertEqual(res.context['month'], future)\n \n@@ -328,6 +330,7 @@ def test_datetime_month_view(self):\n         res = self.client.get('/dates/booksignings/2008/apr/')\n         self.assertEqual(res.status_code, 200)\n \n+    @skipUnlessDBFeature('has_zoneinfo_database')\n     @override_settings(USE_TZ=True, TIME_ZONE='Africa/Nairobi')\n     def test_aware_datetime_month_view(self):\n         BookSigning.objects.create(event_date=datetime.datetime(2008, 2, 1, 12, 0, tzinfo=timezone.utc))"
        },
        {
            "sha": "8f741bbb7fdc51ba582804dcd80cc5269e6be67e",
            "filename": "tests/regressiontests/model_inheritance_regress/tests.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fmodel_inheritance_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fmodel_inheritance_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fmodel_inheritance_regress%2Ftests.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -134,8 +134,8 @@ def test_issue_7105(self):\n         obj = Child.objects.create(\n             name='child',\n             created=datetime.datetime(2008, 6, 26, 17, 0, 0))\n-        dates = list(Child.objects.dates('created', 'month'))\n-        self.assertEqual(dates, [datetime.datetime(2008, 6, 1, 0, 0)])\n+        datetimes = list(Child.objects.datetimes('created', 'month'))\n+        self.assertEqual(datetimes, [datetime.datetime(2008, 6, 1, 0, 0)])\n \n     def test_issue_7276(self):\n         # Regression test for #7276: calling delete() on a model with"
        },
        {
            "sha": "9070dd4873ade95696e756f080f785a143703912",
            "filename": "tests/regressiontests/null_queries/models.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fnull_queries%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fnull_queries%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fnull_queries%2Fmodels.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -28,4 +28,5 @@ class OuterB(models.Model):\n \n class Inner(models.Model):\n     first = models.ForeignKey(OuterA)\n-    second = models.ForeignKey(OuterB, null=True)\n+    # second would clash with the __second lookup.\n+    third = models.ForeignKey(OuterB, null=True)"
        },
        {
            "sha": "93e72d55d83c6e6bf071e19eb30caac7f8c0ae69",
            "filename": "tests/regressiontests/null_queries/tests.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fnull_queries%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fnull_queries%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fnull_queries%2Ftests.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -55,17 +55,17 @@ def test_reverse_relations(self):\n         \"\"\"\n         obj = OuterA.objects.create()\n         self.assertQuerysetEqual(\n-            OuterA.objects.filter(inner__second=None),\n+            OuterA.objects.filter(inner__third=None),\n             ['<OuterA: OuterA object>']\n         )\n         self.assertQuerysetEqual(\n-            OuterA.objects.filter(inner__second__data=None),\n+            OuterA.objects.filter(inner__third__data=None),\n             ['<OuterA: OuterA object>']\n         )\n \n         inner_obj = Inner.objects.create(first=obj)\n         self.assertQuerysetEqual(\n-            Inner.objects.filter(first__inner__second=None),\n+            Inner.objects.filter(first__inner__third=None),\n             ['<Inner: Inner object>']\n         )\n "
        },
        {
            "sha": "ea54d18451af59e0a921f118964781ef0d0810e7",
            "filename": "tests/regressiontests/queries/tests.py",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/django/django/blob/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e74e207cce54802f897adcb42149440ee154821e/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Ftests.py?ref=e74e207cce54802f897adcb42149440ee154821e",
            "patch": "@@ -550,37 +550,37 @@ def test_ticket9926(self):\n     def test_tickets_6180_6203(self):\n         # Dates with limits and/or counts\n         self.assertEqual(Item.objects.count(), 4)\n-        self.assertEqual(Item.objects.dates('created', 'month').count(), 1)\n-        self.assertEqual(Item.objects.dates('created', 'day').count(), 2)\n-        self.assertEqual(len(Item.objects.dates('created', 'day')), 2)\n-        self.assertEqual(Item.objects.dates('created', 'day')[0], datetime.datetime(2007, 12, 19, 0, 0))\n+        self.assertEqual(Item.objects.datetimes('created', 'month').count(), 1)\n+        self.assertEqual(Item.objects.datetimes('created', 'day').count(), 2)\n+        self.assertEqual(len(Item.objects.datetimes('created', 'day')), 2)\n+        self.assertEqual(Item.objects.datetimes('created', 'day')[0], datetime.datetime(2007, 12, 19, 0, 0))\n \n     def test_tickets_7087_12242(self):\n         # Dates with extra select columns\n         self.assertQuerysetEqual(\n-            Item.objects.dates('created', 'day').extra(select={'a': 1}),\n+            Item.objects.datetimes('created', 'day').extra(select={'a': 1}),\n             ['datetime.datetime(2007, 12, 19, 0, 0)', 'datetime.datetime(2007, 12, 20, 0, 0)']\n         )\n         self.assertQuerysetEqual(\n-            Item.objects.extra(select={'a': 1}).dates('created', 'day'),\n+            Item.objects.extra(select={'a': 1}).datetimes('created', 'day'),\n             ['datetime.datetime(2007, 12, 19, 0, 0)', 'datetime.datetime(2007, 12, 20, 0, 0)']\n         )\n \n         name=\"one\"\n         self.assertQuerysetEqual(\n-            Item.objects.dates('created', 'day').extra(where=['name=%s'], params=[name]),\n+            Item.objects.datetimes('created', 'day').extra(where=['name=%s'], params=[name]),\n             ['datetime.datetime(2007, 12, 19, 0, 0)']\n         )\n \n         self.assertQuerysetEqual(\n-            Item.objects.extra(where=['name=%s'], params=[name]).dates('created', 'day'),\n+            Item.objects.extra(where=['name=%s'], params=[name]).datetimes('created', 'day'),\n             ['datetime.datetime(2007, 12, 19, 0, 0)']\n         )\n \n     def test_ticket7155(self):\n         # Nullable dates\n         self.assertQuerysetEqual(\n-            Item.objects.dates('modified', 'day'),\n+            Item.objects.datetimes('modified', 'day'),\n             ['datetime.datetime(2007, 12, 19, 0, 0)']\n         )\n \n@@ -699,7 +699,7 @@ def test_ticket7791(self):\n         )\n \n         # Pickling of DateQuerySets used to fail\n-        qs = Item.objects.dates('created', 'month')\n+        qs = Item.objects.datetimes('created', 'month')\n         _ = pickle.loads(pickle.dumps(qs))\n \n     def test_ticket9997(self):\n@@ -1235,8 +1235,8 @@ def test_ticket8683(self):\n         # field\n         self.assertRaisesMessage(\n             AssertionError,\n-            \"'name' isn't a DateField.\",\n-            Item.objects.dates, 'name', 'month'\n+            \"'name' isn't a DateTimeField.\",\n+            Item.objects.datetimes, 'name', 'month'\n         )\n \n class Queries4Tests(BaseQuerysetTest):"
        }
    ],
    "stats": {
        "total": 1329,
        "additions": 1035,
        "deletions": 294
    }
}