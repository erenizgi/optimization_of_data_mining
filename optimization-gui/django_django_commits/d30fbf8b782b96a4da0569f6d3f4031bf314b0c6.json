{
    "author": "spookylukey",
    "message": "Fixed #16902 - select_related() results in a poor perfomance\n\nThanks to ivan_virabyan for the great patch!\n\n(For the record, some very small tweaks were made by me).\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16929 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "d30fbf8b782b96a4da0569f6d3f4031bf314b0c6",
    "files": [
        {
            "sha": "06d48f761bf78c91b1e7757b5b5763ea22c06896",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 116,
            "deletions": 89,
            "changes": 205,
            "blob_url": "https://github.com/django/django/blob/d30fbf8b782b96a4da0569f6d3f4031bf314b0c6/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/d30fbf8b782b96a4da0569f6d3f4031bf314b0c6/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=d30fbf8b782b96a4da0569f6d3f4031bf314b0c6",
            "patch": "@@ -265,12 +265,13 @@ def iterator(self):\n         db = self.db\n         model = self.model\n         compiler = self.query.get_compiler(using=db)\n+        if fill_cache:\n+            klass_info = get_klass_info(model, max_depth=max_depth,\n+                                        requested=requested, only_load=only_load)\n         for row in compiler.results_iter():\n             if fill_cache:\n-                obj, _ = get_cached_row(model, row,\n-                            index_start, using=db, max_depth=max_depth,\n-                            requested=requested, offset=len(aggregate_select),\n-                            only_load=only_load)\n+                obj, _ = get_cached_row(row, index_start, db, klass_info,\n+                                        offset=len(aggregate_select))\n             else:\n                 if skip:\n                     row_data = row[index_start:aggregate_start]\n@@ -1174,22 +1175,16 @@ def aggregate(self, *args, **kwargs):\n     # situations).\n     value_annotation = False\n \n-\n-def get_cached_row(klass, row, index_start, using, max_depth=0, cur_depth=0,\n-                   requested=None, offset=0, only_load=None, local_only=False):\n+def get_klass_info(klass, max_depth=0, cur_depth=0, requested=None,\n+                   only_load=None, local_only=False):\n     \"\"\"\n-    Helper function that recursively returns an object with the specified\n-    related attributes already populated.\n-\n-    This method may be called recursively to populate deep select_related()\n-    clauses.\n+    Helper function that recursively returns an information for a klass, to be\n+    used in get_cached_row.  It exists just to compute this information only\n+    once for entire queryset. Otherwise it would be computed for each row, which\n+    leads to poor perfomance on large querysets.\n \n     Arguments:\n      * klass - the class to retrieve (and instantiate)\n-     * row - the row of data returned by the database cursor\n-     * index_start - the index of the row at which data for this\n-       object is known to start\n-     * using - the database alias on which the query is being executed.\n      * max_depth - the maximum depth to which a select_related()\n        relationship should be explored.\n      * cur_depth - the current depth in the select_related() tree.\n@@ -1198,20 +1193,16 @@ def get_cached_row(klass, row, index_start, using, max_depth=0, cur_depth=0,\n        that is to be retrieved. keys are field names; values are\n        dictionaries describing the keys on that related object that\n        are themselves to be select_related().\n-     * offset - the number of additional fields that are known to\n-       exist in `row` for `klass`. This usually means the number of\n-       annotated results on `klass`.\n      * only_load - if the query has had only() or defer() applied,\n        this is the list of field names that will be returned. If None,\n        the full field list for `klass` can be assumed.\n-     * local_only - Only populate local fields. This is used when building\n+     * local_only - Only populate local fields. This is used when\n        following reverse select-related relations\n     \"\"\"\n     if max_depth and requested is None and cur_depth > max_depth:\n         # We've recursed deeply enough; stop now.\n         return None\n \n-    restricted = requested is not None\n     if only_load:\n         load_fields = only_load.get(klass)\n         # When we create the object, we will also be creating populating\n@@ -1223,6 +1214,7 @@ def get_cached_row(klass, row, index_start, using, max_depth=0, cur_depth=0,\n                 load_fields.update(fields)\n     else:\n         load_fields = None\n+\n     if load_fields:\n         # Handle deferred fields.\n         skip = set()\n@@ -1237,52 +1229,97 @@ def get_cached_row(klass, row, index_start, using, max_depth=0, cur_depth=0,\n                 init_list.append(field.attname)\n         # Retrieve all the requested fields\n         field_count = len(init_list)\n-        fields = row[index_start : index_start + field_count]\n-        # If all the select_related columns are None, then the related\n-        # object must be non-existent - set the relation to None.\n-        # Otherwise, construct the related object.\n-        if fields == (None,) * field_count:\n-            obj = None\n-        elif skip:\n+        if skip:\n             klass = deferred_class_factory(klass, skip)\n-            obj = klass(**dict(zip(init_list, fields)))\n+            field_names = init_list\n         else:\n-            obj = klass(*fields)\n-\n+            field_names = ()\n     else:\n         # Load all fields on klass\n-        if local_only:\n+\n+        # We trying to not populate field_names variable for perfomance reason.\n+        # If field_names variable is set, it is used to instantiate desired fields,\n+        # by passing **dict(zip(field_names, fields)) as kwargs to Model.__init__ method.\n+        # But kwargs version of Model.__init__ is slower, so we should avoid using\n+        # it when it is not really neccesary.\n+        if local_only and len(klass._meta.local_fields) != len(klass._meta.fields):\n+            field_count = len(klass._meta.local_fields)\n             field_names = [f.attname for f in klass._meta.local_fields]\n         else:\n-            field_names = [f.attname for f in klass._meta.fields]\n-        field_count = len(field_names)\n-        fields = row[index_start : index_start + field_count]\n-        # If all the select_related columns are None, then the related\n-        # object must be non-existent - set the relation to None.\n-        # Otherwise, construct the related object.\n-        if fields == (None,) * field_count:\n-            obj = None\n-        else:\n+            field_count = len(klass._meta.fields)\n+            field_names = ()\n+\n+    restricted = requested is not None\n+\n+    related_fields = []\n+    for f in klass._meta.fields:\n+        if select_related_descend(f, restricted, requested):\n+            if restricted:\n+                next = requested[f.name]\n+            else:\n+                next = None\n+            klass_info = get_klass_info(f.rel.to, max_depth=max_depth, cur_depth=cur_depth+1,\n+                                        requested=next, only_load=only_load)\n+            related_fields.append((f, klass_info))\n+\n+    reverse_related_fields = []\n+    if restricted:\n+        for o in klass._meta.get_all_related_objects():\n+            if o.field.unique and select_related_descend(o.field, restricted, requested, reverse=True):\n+                next = requested[o.field.related_query_name()]\n+                klass_info = get_klass_info(o.model, max_depth=max_depth, cur_depth=cur_depth+1,\n+                                            requested=next, only_load=only_load, local_only=True)\n+                reverse_related_fields.append((o.field, klass_info))\n+\n+    return klass, field_names, field_count, related_fields, reverse_related_fields\n+\n+\n+def get_cached_row(row, index_start, using,  klass_info, offset=0):\n+    \"\"\"\n+    Helper function that recursively returns an object with the specified\n+    related attributes already populated.\n+\n+    This method may be called recursively to populate deep select_related()\n+    clauses.\n+\n+    Arguments:\n+         * row - the row of data returned by the database cursor\n+         * index_start - the index of the row at which data for this\n+           object is known to start\n+         * offset - the number of additional fields that are known to\n+           exist in row for `klass`. This usually means the number of\n+           annotated results on `klass`.\n+        * using - the database alias on which the query is being executed.\n+         * klass_info - result of the get_klass_info function\n+    \"\"\"\n+    if klass_info is None:\n+        return None\n+    klass, field_names, field_count, related_fields, reverse_related_fields = klass_info\n+\n+    fields = row[index_start : index_start + field_count]\n+    # If all the select_related columns are None, then the related\n+    # object must be non-existent - set the relation to None.\n+    # Otherwise, construct the related object.\n+    if fields == (None,) * field_count:\n+        obj = None\n+    else:\n+        if field_names:\n             obj = klass(**dict(zip(field_names, fields)))\n+        else:\n+            obj = klass(*fields)\n \n     # If an object was retrieved, set the database state.\n     if obj:\n         obj._state.db = using\n         obj._state.adding = False\n \n+    # Instantiate related fields\n     index_end = index_start + field_count + offset\n     # Iterate over each related object, populating any\n     # select_related() fields\n-    for f in klass._meta.fields:\n-        if not select_related_descend(f, restricted, requested):\n-            continue\n-        if restricted:\n-            next = requested[f.name]\n-        else:\n-            next = None\n+    for f, klass_info in related_fields:\n         # Recursively retrieve the data for the related object\n-        cached_row = get_cached_row(f.rel.to, row, index_end, using,\n-                max_depth, cur_depth+1, next, only_load=only_load)\n+        cached_row = get_cached_row(row, index_end, using, klass_info)\n         # If the recursive descent found an object, populate the\n         # descriptor caches relevant to the object\n         if cached_row:\n@@ -1299,45 +1336,35 @@ def get_cached_row(klass, row, index_start, using, max_depth=0, cur_depth=0,\n     # Now do the same, but for reverse related objects.\n     # Only handle the restricted case - i.e., don't do a depth\n     # descent into reverse relations unless explicitly requested\n-    if restricted:\n-        related_fields = [\n-            (o.field, o.model)\n-            for o in klass._meta.get_all_related_objects()\n-            if o.field.unique\n-        ]\n-        for f, model in related_fields:\n-            if not select_related_descend(f, restricted, requested, reverse=True):\n-                continue\n-            next = requested[f.related_query_name()]\n-            # Recursively retrieve the data for the related object\n-            cached_row = get_cached_row(model, row, index_end, using,\n-                max_depth, cur_depth+1, next, only_load=only_load, local_only=True)\n-            # If the recursive descent found an object, populate the\n-            # descriptor caches relevant to the object\n-            if cached_row:\n-                rel_obj, index_end = cached_row\n-                if obj is not None:\n-                    # If the field is unique, populate the\n-                    # reverse descriptor cache\n-                    setattr(obj, f.related.get_cache_name(), rel_obj)\n-                if rel_obj is not None:\n-                    # If the related object exists, populate\n-                    # the descriptor cache.\n-                    setattr(rel_obj, f.get_cache_name(), obj)\n-                    # Now populate all the non-local field values\n-                    # on the related object\n-                    for rel_field,rel_model in rel_obj._meta.get_fields_with_model():\n-                        if rel_model is not None:\n-                            setattr(rel_obj, rel_field.attname, getattr(obj, rel_field.attname))\n-                            # populate the field cache for any related object\n-                            # that has already been retrieved\n-                            if rel_field.rel:\n-                                try:\n-                                    cached_obj = getattr(obj, rel_field.get_cache_name())\n-                                    setattr(rel_obj, rel_field.get_cache_name(), cached_obj)\n-                                except AttributeError:\n-                                    # Related object hasn't been cached yet\n-                                    pass\n+    for f, klass_info in reverse_related_fields:\n+        # Recursively retrieve the data for the related object\n+        cached_row = get_cached_row(row, index_end, using, klass_info)\n+        # If the recursive descent found an object, populate the\n+        # descriptor caches relevant to the object\n+        if cached_row:\n+            rel_obj, index_end = cached_row\n+            if obj is not None:\n+                # If the field is unique, populate the\n+                # reverse descriptor cache\n+                setattr(obj, f.related.get_cache_name(), rel_obj)\n+            if rel_obj is not None:\n+                # If the related object exists, populate\n+                # the descriptor cache.\n+                setattr(rel_obj, f.get_cache_name(), obj)\n+                # Now populate all the non-local field values\n+                # on the related object\n+                for rel_field, rel_model in rel_obj._meta.get_fields_with_model():\n+                    if rel_model is not None:\n+                        setattr(rel_obj, rel_field.attname, getattr(obj, rel_field.attname))\n+                        # populate the field cache for any related object\n+                        # that has already been retrieved\n+                        if rel_field.rel:\n+                            try:\n+                                cached_obj = getattr(obj, rel_field.get_cache_name())\n+                                setattr(rel_obj, rel_field.get_cache_name(), cached_obj)\n+                            except AttributeError:\n+                                # Related object hasn't been cached yet\n+                                pass\n     return obj, index_end\n \n "
        }
    ],
    "stats": {
        "total": 205,
        "additions": 116,
        "deletions": 89
    }
}