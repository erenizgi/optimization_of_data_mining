{
    "author": "spookylukey",
    "message": "Fixed #15679 - regression in HttpRequest.POST and raw_post_data access.\n\nThanks to vkryachko for the report.\n\nThis also fixes a slight inconsistency with raw_post_data after parsing of a\nmultipart request, and adds a test for that.  (Previously accessing\nraw_post_data would have returned the empty string rather than raising an\nException).\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15938 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "8bb46d8b7c808bb366c7e15c46e5476e2b2b51a1",
    "files": [
        {
            "sha": "b303f8bb6e83a74c1335af2e13a94b18a91a88a0",
            "filename": "django/http/__init__.py",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/8bb46d8b7c808bb366c7e15c46e5476e2b2b51a1/django%2Fhttp%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/8bb46d8b7c808bb366c7e15c46e5476e2b2b51a1/django%2Fhttp%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2F__init__.py?ref=8bb46d8b7c808bb366c7e15c46e5476e2b2b51a1",
            "patch": "@@ -262,14 +262,18 @@ def _load_post_and_files(self):\n         if self.method != 'POST':\n             self._post, self._files = QueryDict('', encoding=self._encoding), MultiValueDict()\n             return\n-        if self._read_started:\n+        if self._read_started and not hasattr(self, '_raw_post_data'):\n             self._mark_post_parse_error()\n             return\n \n         if self.META.get('CONTENT_TYPE', '').startswith('multipart'):\n-            self._raw_post_data = ''\n+            if hasattr(self, '_raw_post_data'):\n+                # Use already read data\n+                data = StringIO(self._raw_post_data)\n+            else:\n+                data = self\n             try:\n-                self._post, self._files = self.parse_file_upload(self.META, self)\n+                self._post, self._files = self.parse_file_upload(self.META, data)\n             except:\n                 # An error occured while parsing POST data.  Since when\n                 # formatting the error the request handler might access"
        },
        {
            "sha": "b68201494b46f18b99c578ca505b546c86de5b90",
            "filename": "tests/regressiontests/requests/tests.py",
            "status": "modified",
            "additions": 60,
            "deletions": 0,
            "changes": 60,
            "blob_url": "https://github.com/django/django/blob/8bb46d8b7c808bb366c7e15c46e5476e2b2b51a1/tests%2Fregressiontests%2Frequests%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/8bb46d8b7c808bb366c7e15c46e5476e2b2b51a1/tests%2Fregressiontests%2Frequests%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Frequests%2Ftests.py?ref=8bb46d8b7c808bb366c7e15c46e5476e2b2b51a1",
            "patch": "@@ -179,6 +179,66 @@ def test_value_after_read(self):\n         self.assertRaises(Exception, lambda: request.raw_post_data)\n         self.assertEqual(request.POST, {})\n \n+    def test_raw_post_data_after_POST_multipart(self):\n+        \"\"\"\n+        Reading raw_post_data after parsing multipart is not allowed\n+        \"\"\"\n+        # Because multipart is used for large amounts fo data i.e. file uploads,\n+        # we don't want the data held in memory twice, and we don't want to\n+        # silence the error by setting raw_post_data = '' either.\n+        payload = \"\\r\\n\".join([\n+                '--boundary',\n+                'Content-Disposition: form-data; name=\"name\"',\n+                '',\n+                'value',\n+                '--boundary--'\n+                ''])\n+        request = WSGIRequest({'REQUEST_METHOD': 'POST',\n+                               'CONTENT_TYPE': 'multipart/form-data; boundary=boundary',\n+                               'CONTENT_LENGTH': len(payload),\n+                               'wsgi.input': StringIO(payload)})\n+        self.assertEqual(request.POST, {u'name': [u'value']})\n+        self.assertRaises(Exception, lambda: request.raw_post_data)\n+\n     def test_read_by_lines(self):\n         request = WSGIRequest({'REQUEST_METHOD': 'POST', 'wsgi.input': StringIO('name=value')})\n         self.assertEqual(list(request), ['name=value'])\n+\n+    def test_POST_after_raw_post_data_read(self):\n+        \"\"\"\n+        POST should be populated even if raw_post_data is read first\n+        \"\"\"\n+        request = WSGIRequest({'REQUEST_METHOD': 'POST', 'wsgi.input': StringIO('name=value')})\n+        raw_data = request.raw_post_data\n+        self.assertEqual(request.POST, {u'name': [u'value']})\n+\n+    def test_POST_after_raw_post_data_read_and_stream_read(self):\n+        \"\"\"\n+        POST should be populated even if raw_post_data is read first, and then\n+        the stream is read second.\n+        \"\"\"\n+        request = WSGIRequest({'REQUEST_METHOD': 'POST', 'wsgi.input': StringIO('name=value')})\n+        raw_data = request.raw_post_data\n+        self.assertEqual(request.read(1), u'n')\n+        self.assertEqual(request.POST, {u'name': [u'value']})\n+\n+    def test_POST_after_raw_post_data_read_and_stream_read_multipart(self):\n+        \"\"\"\n+        POST should be populated even if raw_post_data is read first, and then\n+        the stream is read second. Using multipart/form-data instead of urlencoded.\n+        \"\"\"\n+        payload = \"\\r\\n\".join([\n+                '--boundary',\n+                'Content-Disposition: form-data; name=\"name\"',\n+                '',\n+                'value',\n+                '--boundary--'\n+                ''])\n+        request = WSGIRequest({'REQUEST_METHOD': 'POST',\n+                               'CONTENT_TYPE': 'multipart/form-data; boundary=boundary',\n+                               'CONTENT_LENGTH': len(payload),\n+                               'wsgi.input': StringIO(payload)})\n+        raw_data = request.raw_post_data\n+        # Consume enough data to mess up the parsing:\n+        self.assertEqual(request.read(13), u'--boundary\\r\\nC')\n+        self.assertEqual(request.POST, {u'name': [u'value']})"
        }
    ],
    "stats": {
        "total": 70,
        "additions": 67,
        "deletions": 3
    }
}