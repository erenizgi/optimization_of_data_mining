{
    "author": "unknown",
    "message": "Fixed #4102 -- Allow update of specific fields in model.save()\n\nAdded the ability to update only part of the model's fields in\nmodel.save() by introducing a new kwarg \"update_fields\". Thanks\nto all the numerous reviewers and commenters in the ticket",
    "sha": "365853da016f242937a657b488514e2f69fa6d82",
    "files": [
        {
            "sha": "a555ad9f13e0d2c85e994b0552b27197e66c4953",
            "filename": "django/db/models/base.py",
            "status": "modified",
            "additions": 41,
            "deletions": 14,
            "changes": 55,
            "blob_url": "https://github.com/django/django/blob/365853da016f242937a657b488514e2f69fa6d82/django%2Fdb%2Fmodels%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/365853da016f242937a657b488514e2f69fa6d82/django%2Fdb%2Fmodels%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fbase.py?ref=365853da016f242937a657b488514e2f69fa6d82",
            "patch": "@@ -11,7 +11,7 @@\n from django.db.models.fields import AutoField, FieldDoesNotExist\n from django.db.models.fields.related import (ManyToOneRel,\n     OneToOneField, add_lazy_relation)\n-from django.db import (connections, router, transaction, DatabaseError,\n+from django.db import (router, transaction, DatabaseError,\n     DEFAULT_DB_ALIAS)\n from django.db.models.query import Q\n from django.db.models.query_utils import DeferredAttribute\n@@ -449,7 +449,8 @@ def serializable_value(self, field_name):\n             return getattr(self, field_name)\n         return getattr(self, field.attname)\n \n-    def save(self, force_insert=False, force_update=False, using=None):\n+    def save(self, force_insert=False, force_update=False, using=None,\n+             update_fields=None):\n         \"\"\"\n         Saves the current instance. Override this in a subclass if you want to\n         control the saving process.\n@@ -458,22 +459,41 @@ def save(self, force_insert=False, force_update=False, using=None):\n         that the \"save\" must be an SQL insert or update (or equivalent for\n         non-SQL backends), respectively. Normally, they should not be set.\n         \"\"\"\n-        if force_insert and force_update:\n+        if force_insert and (force_update or update_fields):\n             raise ValueError(\"Cannot force both insert and updating in model saving.\")\n-        self.save_base(using=using, force_insert=force_insert, force_update=force_update)\n \n+        if update_fields is not None:\n+            # If update_fields is empty, skip the save. We do also check for\n+            # no-op saves later on for inheritance cases. This bailout is\n+            # still needed for skipping signal sending.\n+            if len(update_fields) == 0:\n+                return\n+\n+            update_fields = frozenset(update_fields)\n+            field_names = set([field.name for field in self._meta.fields\n+                               if not field.primary_key])\n+            non_model_fields = update_fields.difference(field_names)\n+\n+            if non_model_fields:\n+                raise ValueError(\"The following fields do not exist in this \"\n+                                 \"model or are m2m fields: %s\"\n+                                 % ', '.join(non_model_fields))\n+\n+        self.save_base(using=using, force_insert=force_insert,\n+                       force_update=force_update, update_fields=update_fields)\n     save.alters_data = True\n \n     def save_base(self, raw=False, cls=None, origin=None, force_insert=False,\n-            force_update=False, using=None):\n+                  force_update=False, using=None, update_fields=None):\n         \"\"\"\n         Does the heavy-lifting involved in saving. Subclasses shouldn't need to\n         override this method. It's separate from save() in order to hide the\n         need for overrides of save() to pass around internal-only parameters\n         ('raw', 'cls', and 'origin').\n         \"\"\"\n         using = using or router.db_for_write(self.__class__, instance=self)\n-        assert not (force_insert and force_update)\n+        assert not (force_insert and (force_update or update_fields))\n+        assert update_fields is None or len(update_fields) > 0\n         if cls is None:\n             cls = self.__class__\n             meta = cls._meta\n@@ -483,7 +503,8 @@ def save_base(self, raw=False, cls=None, origin=None, force_insert=False,\n             meta = cls._meta\n \n         if origin and not meta.auto_created:\n-            signals.pre_save.send(sender=origin, instance=self, raw=raw, using=using)\n+            signals.pre_save.send(sender=origin, instance=self, raw=raw, using=using,\n+                                  update_fields=update_fields)\n \n         # If we are in a raw save, save the object exactly as presented.\n         # That means that we don't try to be smart about saving attributes\n@@ -503,7 +524,8 @@ def save_base(self, raw=False, cls=None, origin=None, force_insert=False,\n                 if field and getattr(self, parent._meta.pk.attname) is None and getattr(self, field.attname) is not None:\n                     setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n \n-                self.save_base(cls=parent, origin=org, using=using)\n+                self.save_base(cls=parent, origin=org, using=using,\n+                               update_fields=update_fields)\n \n                 if field:\n                     setattr(self, field.attname, self._get_pk_val(parent._meta))\n@@ -513,22 +535,27 @@ def save_base(self, raw=False, cls=None, origin=None, force_insert=False,\n         if not meta.proxy:\n             non_pks = [f for f in meta.local_fields if not f.primary_key]\n \n+            if update_fields:\n+                non_pks = [f for f in non_pks if f.name in update_fields]\n+\n             # First, try an UPDATE. If that doesn't update anything, do an INSERT.\n             pk_val = self._get_pk_val(meta)\n             pk_set = pk_val is not None\n             record_exists = True\n             manager = cls._base_manager\n             if pk_set:\n-                # Determine whether a record with the primary key already exists.\n-                if (force_update or (not force_insert and\n+                # Determine if we should do an update (pk already exists, forced update,\n+                # no force_insert)\n+                if ((force_update or update_fields) or (not force_insert and\n                         manager.using(using).filter(pk=pk_val).exists())):\n-                    # It does already exist, so do an UPDATE.\n                     if force_update or non_pks:\n                         values = [(f, None, (raw and getattr(self, f.attname) or f.pre_save(self, False))) for f in non_pks]\n                         if values:\n                             rows = manager.using(using).filter(pk=pk_val)._update(values)\n                             if force_update and not rows:\n                                 raise DatabaseError(\"Forced update did not affect any rows.\")\n+                            if update_fields and not rows:\n+                                raise DatabaseError(\"Save with update_fields did not affect any rows.\")\n                 else:\n                     record_exists = False\n             if not pk_set or not record_exists:\n@@ -541,7 +568,7 @@ def save_base(self, raw=False, cls=None, origin=None, force_insert=False,\n \n                 fields = meta.local_fields\n                 if not pk_set:\n-                    if force_update:\n+                    if force_update or update_fields:\n                         raise ValueError(\"Cannot force an update in save() with no primary key.\")\n                     fields = [f for f in fields if not isinstance(f, AutoField)]\n \n@@ -561,8 +588,8 @@ def save_base(self, raw=False, cls=None, origin=None, force_insert=False,\n \n         # Signal that the save is complete\n         if origin and not meta.auto_created:\n-            signals.post_save.send(sender=origin, instance=self,\n-                created=(not record_exists), raw=raw, using=using)\n+            signals.post_save.send(sender=origin, instance=self, created=(not record_exists),\n+                                   update_fields=update_fields, raw=raw, using=using)\n \n \n     save_base.alters_data = True"
        },
        {
            "sha": "4666169bec602f04766fefa6a47cbdf75aa64ee1",
            "filename": "django/db/models/signals.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/365853da016f242937a657b488514e2f69fa6d82/django%2Fdb%2Fmodels%2Fsignals.py",
            "raw_url": "https://github.com/django/django/raw/365853da016f242937a657b488514e2f69fa6d82/django%2Fdb%2Fmodels%2Fsignals.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsignals.py?ref=365853da016f242937a657b488514e2f69fa6d82",
            "patch": "@@ -5,8 +5,8 @@\n pre_init = Signal(providing_args=[\"instance\", \"args\", \"kwargs\"])\n post_init = Signal(providing_args=[\"instance\"])\n \n-pre_save = Signal(providing_args=[\"instance\", \"raw\", \"using\"])\n-post_save = Signal(providing_args=[\"instance\", \"raw\", \"created\", \"using\"])\n+pre_save = Signal(providing_args=[\"instance\", \"raw\", \"using\", \"update_fields\"])\n+post_save = Signal(providing_args=[\"instance\", \"raw\", \"created\", \"using\", \"update_fields\"])\n \n pre_delete = Signal(providing_args=[\"instance\", \"using\"])\n post_delete = Signal(providing_args=[\"instance\", \"using\"])"
        },
        {
            "sha": "fb0fcc046dec8407ffae5741eaf9753838804c9c",
            "filename": "docs/ref/models/instances.txt",
            "status": "modified",
            "additions": 23,
            "deletions": 1,
            "changes": 24,
            "blob_url": "https://github.com/django/django/blob/365853da016f242937a657b488514e2f69fa6d82/docs%2Fref%2Fmodels%2Finstances.txt",
            "raw_url": "https://github.com/django/django/raw/365853da016f242937a657b488514e2f69fa6d82/docs%2Fref%2Fmodels%2Finstances.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Finstances.txt?ref=365853da016f242937a657b488514e2f69fa6d82",
            "patch": "@@ -135,7 +135,7 @@ Saving objects\n \n To save an object back to the database, call ``save()``:\n \n-.. method:: Model.save([force_insert=False, force_update=False, using=DEFAULT_DB_ALIAS])\n+.. method:: Model.save([force_insert=False, force_update=False, using=DEFAULT_DB_ALIAS, update_fields=None])\n \n .. versionadded:: 1.2\n    The ``using`` argument was added.\n@@ -289,6 +289,8 @@ almost always do the right thing and trying to override that will lead to\n errors that are difficult to track down. This feature is for advanced use\n only.\n \n+Using ``update_fields`` will force an update similarly to ``force_update``.\n+\n Updating attributes based on existing fields\n --------------------------------------------\n \n@@ -334,6 +336,26 @@ For more details, see the documentation on :ref:`F() expressions\n <query-expressions>` and their :ref:`use in update queries\n <topics-db-queries-update>`.\n \n+Specifying which fields to save\n+-------------------------------\n+\n+.. versionadded:: 1.5\n+\n+If ``save()`` is passed a list of field names in keyword argument\n+``update_fields``, only the fields named in that list will be updated.\n+This may be desirable if you want to update just one or a few fields on\n+an object. There will be a slight performance benefit from preventing\n+all of the model fields from being updated in the database. For example:\n+\n+    product.name = 'Name changed again'\n+    product.save(update_fields=['name'])\n+\n+The ``update_fields`` argument can be any iterable containing strings. An\n+empty ``update_fields`` iterable will skip the save. A value of None will\n+perform an update on all fields.\n+\n+Specifying ``update_fields`` will force an update.\n+\n Deleting objects\n ================\n "
        },
        {
            "sha": "136eee935c49ba1a61c91c8f698cace3ba0fe094",
            "filename": "docs/ref/signals.txt",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/365853da016f242937a657b488514e2f69fa6d82/docs%2Fref%2Fsignals.txt",
            "raw_url": "https://github.com/django/django/raw/365853da016f242937a657b488514e2f69fa6d82/docs%2Fref%2Fsignals.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fsignals.txt?ref=365853da016f242937a657b488514e2f69fa6d82",
            "patch": "@@ -123,6 +123,12 @@ Arguments sent with this signal:\n ``using``\n     The database alias being used.\n \n+.. versionadded:: 1.5\n+\n+``update_fields``\n+    The set of fields to update explicitly specified in the ``save()`` method.\n+    ``None`` if this argument was not used in the ``save()`` call.\n+\n post_save\n ---------\n \n@@ -154,6 +160,12 @@ Arguments sent with this signal:\n ``using``\n     The database alias being used.\n \n+.. versionadded:: 1.5\n+\n+``update_fields``\n+    The set of fields to update explicitly specified in the ``save()`` method.\n+    ``None`` if this argument was not used in the ``save()`` call.\n+\n pre_delete\n ----------\n "
        },
        {
            "sha": "be06fe58d8094a191e2ac056f9cf181bcadd49d2",
            "filename": "docs/releases/1.5.txt",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/365853da016f242937a657b488514e2f69fa6d82/docs%2Freleases%2F1.5.txt",
            "raw_url": "https://github.com/django/django/raw/365853da016f242937a657b488514e2f69fa6d82/docs%2Freleases%2F1.5.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.5.txt?ref=365853da016f242937a657b488514e2f69fa6d82",
            "patch": "@@ -33,6 +33,17 @@ version compatible with Python 2.6.\n What's new in Django 1.5\n ========================\n \n+Support for saving a subset of model's fields\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The method :meth:`Model.save() <django.db.models.Model.save()>` has a new\n+keyword argument ``update_fields``. By using this argument it is possible to\n+save only a select list of model's fields. This can be useful for performance\n+reasons or when trying to avoid overwriting concurrent changes.\n+\n+See the :meth:`Model.save() <django.db.models.Model.save()>` documentation for\n+more details.\n+\n Minor features\n ~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/modeltests/update_only_fields/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/django/django/blob/365853da016f242937a657b488514e2f69fa6d82/tests%2Fmodeltests%2Fupdate_only_fields%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/365853da016f242937a657b488514e2f69fa6d82/tests%2Fmodeltests%2Fupdate_only_fields%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fupdate_only_fields%2F__init__.py?ref=365853da016f242937a657b488514e2f69fa6d82"
        },
        {
            "sha": "968dba99160262fe584951508330d4e5f12ea093",
            "filename": "tests/modeltests/update_only_fields/models.py",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/django/django/blob/365853da016f242937a657b488514e2f69fa6d82/tests%2Fmodeltests%2Fupdate_only_fields%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/365853da016f242937a657b488514e2f69fa6d82/tests%2Fmodeltests%2Fupdate_only_fields%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fupdate_only_fields%2Fmodels.py?ref=365853da016f242937a657b488514e2f69fa6d82",
            "patch": "@@ -0,0 +1,37 @@\n+\n+from django.db import models\n+\n+GENDER_CHOICES = (\n+    ('M', 'Male'),\n+    ('F', 'Female'),\n+)\n+\n+class Account(models.Model):\n+    num = models.IntegerField()\n+\n+\n+class Person(models.Model):\n+    name = models.CharField(max_length=20)\n+    gender = models.CharField(max_length=1, choices=GENDER_CHOICES)\n+\n+    def __unicode__(self):\n+        return self.name\n+\n+\n+class Employee(Person):\n+    employee_num = models.IntegerField(default=0)\n+    profile = models.ForeignKey('Profile', related_name='profiles', null=True)\n+    accounts = models.ManyToManyField('Account', related_name='employees', blank=True, null=True)\n+\n+\n+class Profile(models.Model):\n+    name = models.CharField(max_length=200)\n+    salary = models.FloatField(default=1000.0)\n+\n+    def __unicode__(self):\n+        return self.name\n+\n+\n+class ProxyEmployee(Employee):\n+    class Meta:\n+        proxy = True"
        },
        {
            "sha": "e843bd7ab94dbfe07105b0984d1158fdeb74b888",
            "filename": "tests/modeltests/update_only_fields/tests.py",
            "status": "added",
            "additions": 146,
            "deletions": 0,
            "changes": 146,
            "blob_url": "https://github.com/django/django/blob/365853da016f242937a657b488514e2f69fa6d82/tests%2Fmodeltests%2Fupdate_only_fields%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/365853da016f242937a657b488514e2f69fa6d82/tests%2Fmodeltests%2Fupdate_only_fields%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fupdate_only_fields%2Ftests.py?ref=365853da016f242937a657b488514e2f69fa6d82",
            "patch": "@@ -0,0 +1,146 @@\n+from __future__ import absolute_import\n+\n+from django.test import TestCase\n+from django.db.models.signals import pre_save, post_save\n+from .models import Person, Employee, ProxyEmployee, Profile, Account\n+\n+\n+class UpdateOnlyFieldsTests(TestCase):\n+    def test_update_fields_basic(self):\n+        s = Person.objects.create(name='Sara', gender='F')\n+        self.assertEqual(s.gender, 'F')\n+\n+        s.gender = 'M'\n+        s.name = 'Ian'\n+        s.save(update_fields=['name'])\n+\n+        s = Person.objects.get(pk=s.pk)\n+        self.assertEqual(s.gender, 'F')\n+        self.assertEqual(s.name, 'Ian')\n+\n+    def test_update_fields_m2m(self):\n+        profile_boss = Profile.objects.create(name='Boss', salary=3000)\n+        e1 = Employee.objects.create(name='Sara', gender='F',\n+            employee_num=1, profile=profile_boss)\n+\n+        a1 = Account.objects.create(num=1)\n+        a2 = Account.objects.create(num=2)\n+\n+        e1.accounts = [a1,a2]\n+\n+        with self.assertRaises(ValueError):\n+            e1.save(update_fields=['accounts'])\n+\n+    def test_update_fields_inheritance(self):\n+        profile_boss = Profile.objects.create(name='Boss', salary=3000)\n+        profile_receptionist = Profile.objects.create(name='Receptionist', salary=1000)\n+\n+        e1 = Employee.objects.create(name='Sara', gender='F',\n+            employee_num=1, profile=profile_boss)\n+\n+        e1.name = 'Ian'\n+        e1.gender = 'M'\n+        e1.save(update_fields=['name'])\n+\n+        e2 = Employee.objects.get(pk=e1.pk)\n+        self.assertEqual(e2.name, 'Ian')\n+        self.assertEqual(e2.gender, 'F')\n+        self.assertEqual(e2.profile, profile_boss)\n+\n+        e2.profile = profile_receptionist\n+        e2.name = 'Sara'\n+        e2.save(update_fields=['profile'])\n+\n+        e3 = Employee.objects.get(pk=e1.pk)\n+        self.assertEqual(e3.name, 'Ian')\n+        self.assertEqual(e3.profile, profile_receptionist)\n+\n+    def test_update_fields_inheritance_with_proxy_model(self):\n+        profile_boss = Profile.objects.create(name='Boss', salary=3000)\n+        profile_receptionist = Profile.objects.create(name='Receptionist', salary=1000)\n+\n+        e1 = ProxyEmployee.objects.create(name='Sara', gender='F',\n+            employee_num=1, profile=profile_boss)\n+\n+        e1.name = 'Ian'\n+        e1.gender = 'M'\n+        e1.save(update_fields=['name'])\n+\n+        e2 = ProxyEmployee.objects.get(pk=e1.pk)\n+        self.assertEqual(e2.name, 'Ian')\n+        self.assertEqual(e2.gender, 'F')\n+        self.assertEqual(e2.profile, profile_boss)\n+\n+        e2.profile = profile_receptionist\n+        e2.name = 'Sara'\n+        e2.save(update_fields=['profile'])\n+\n+        e3 = ProxyEmployee.objects.get(pk=e1.pk)\n+        self.assertEqual(e3.name, 'Ian')\n+        self.assertEqual(e3.profile, profile_receptionist)\n+\n+    def test_update_fields_signals(self):\n+        p = Person.objects.create(name='Sara', gender='F')\n+        pre_save_data = []\n+        def pre_save_receiver(**kwargs):\n+            pre_save_data.append(kwargs['update_fields'])\n+        pre_save.connect(pre_save_receiver)\n+        post_save_data = []\n+        def post_save_receiver(**kwargs):\n+            post_save_data.append(kwargs['update_fields'])\n+        post_save.connect(post_save_receiver)\n+        p.save(update_fields=['name'])\n+        self.assertEqual(len(pre_save_data), 1)\n+        self.assertEqual(len(pre_save_data[0]), 1)\n+        self.assertTrue('name' in pre_save_data[0])\n+        self.assertEqual(len(post_save_data), 1)\n+        self.assertEqual(len(post_save_data[0]), 1)\n+        self.assertTrue('name' in post_save_data[0])\n+\n+    def test_update_fields_incorrect_params(self):\n+        s = Person.objects.create(name='Sara', gender='F')\n+\n+        with self.assertRaises(ValueError):\n+            s.save(update_fields=['first_name'])\n+\n+        with self.assertRaises(ValueError):\n+            s.save(update_fields=\"name\")\n+\n+    def test_empty_update_fields(self):\n+        s = Person.objects.create(name='Sara', gender='F')\n+        pre_save_data = []\n+        def pre_save_receiver(**kwargs):\n+            pre_save_data.append(kwargs['update_fields'])\n+        pre_save.connect(pre_save_receiver)\n+        post_save_data = []\n+        def post_save_receiver(**kwargs):\n+            post_save_data.append(kwargs['update_fields'])\n+        post_save.connect(post_save_receiver)\n+        # Save is skipped.\n+        with self.assertNumQueries(0):\n+            s.save(update_fields=[])\n+        # Signals were skipped, too...\n+        self.assertEqual(len(pre_save_data), 0)\n+        self.assertEqual(len(post_save_data), 0)\n+\n+    def test_num_queries_inheritance(self):\n+        s = Employee.objects.create(name='Sara', gender='F')\n+        s.employee_num = 1\n+        s.name = 'Emily'\n+        with self.assertNumQueries(1):\n+            s.save(update_fields=['employee_num'])\n+        s = Employee.objects.get(pk=s.pk)\n+        self.assertEqual(s.employee_num, 1)\n+        self.assertEqual(s.name, 'Sara')\n+        s.employee_num = 2\n+        s.name = 'Emily'\n+        with self.assertNumQueries(1):\n+            s.save(update_fields=['name'])\n+        s = Employee.objects.get(pk=s.pk)\n+        self.assertEqual(s.name, 'Emily')\n+        self.assertEqual(s.employee_num, 1)\n+        # A little sanity check that we actually did updates...\n+        self.assertEqual(Employee.objects.count(), 1)\n+        self.assertEqual(Person.objects.count(), 1)\n+        with self.assertNumQueries(2):\n+            s.save(update_fields=['name', 'employee_num'])"
        }
    ],
    "stats": {
        "total": 289,
        "additions": 272,
        "deletions": 17
    }
}