{
    "author": "claudep",
    "message": "[py3] Made signing infrastructure pass tests with Python 3",
    "sha": "92b2dec918d7b73456899ecb5726cc03b86bd068",
    "files": [
        {
            "sha": "6fc76bc201360e3ed8a9df4b05f4103f0e505d6d",
            "filename": "django/core/signing.py",
            "status": "modified",
            "additions": 9,
            "deletions": 10,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/92b2dec918d7b73456899ecb5726cc03b86bd068/django%2Fcore%2Fsigning.py",
            "raw_url": "https://github.com/django/django/raw/92b2dec918d7b73456899ecb5726cc03b86bd068/django%2Fcore%2Fsigning.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fsigning.py?ref=92b2dec918d7b73456899ecb5726cc03b86bd068",
            "patch": "@@ -32,6 +32,8 @@\n There are 65 url-safe characters: the 64 used by url-safe base64 and the ':'.\n These functions make use of all of them.\n \"\"\"\n+from __future__ import unicode_literals\n+\n import base64\n import json\n import time\n@@ -41,7 +43,7 @@\n from django.core.exceptions import ImproperlyConfigured\n from django.utils import baseconv\n from django.utils.crypto import constant_time_compare, salted_hmac\n-from django.utils.encoding import force_text, smart_bytes\n+from django.utils.encoding import smart_bytes\n from django.utils.importlib import import_module\n \n \n@@ -60,12 +62,12 @@ class SignatureExpired(BadSignature):\n \n \n def b64_encode(s):\n-    return base64.urlsafe_b64encode(s).strip('=')\n+    return base64.urlsafe_b64encode(smart_bytes(s)).decode('ascii').strip('=')\n \n \n def b64_decode(s):\n     pad = '=' * (-len(s) % 4)\n-    return base64.urlsafe_b64decode(s + pad)\n+    return base64.urlsafe_b64decode(smart_bytes(s + pad)).decode('ascii')\n \n \n def base64_hmac(salt, value, key):\n@@ -121,7 +123,7 @@ def dumps(obj, key=None, salt='django.core.signing', serializer=JSONSerializer,\n \n     if compress:\n         # Avoid zlib dependency unless compress is being used\n-        compressed = zlib.compress(data)\n+        compressed = zlib.compress(smart_bytes(data))\n         if len(compressed) < (len(data) - 1):\n             data = compressed\n             is_compressed = True\n@@ -135,8 +137,7 @@ def loads(s, key=None, salt='django.core.signing', serializer=JSONSerializer, ma\n     \"\"\"\n     Reverse of dumps(), raises BadSignature if signature fails\n     \"\"\"\n-    base64d = smart_bytes(\n-        TimestampSigner(key, salt=salt).unsign(s, max_age=max_age))\n+    base64d = TimestampSigner(key, salt=salt).unsign(s, max_age=max_age)\n     decompress = False\n     if base64d[0] == '.':\n         # It's compressed; uncompress it first\n@@ -159,16 +160,14 @@ def signature(self, value):\n         return base64_hmac(self.salt + 'signer', value, self.key)\n \n     def sign(self, value):\n-        value = smart_bytes(value)\n         return '%s%s%s' % (value, self.sep, self.signature(value))\n \n     def unsign(self, signed_value):\n-        signed_value = smart_bytes(signed_value)\n         if not self.sep in signed_value:\n             raise BadSignature('No \"%s\" found in value' % self.sep)\n         value, sig = signed_value.rsplit(self.sep, 1)\n         if constant_time_compare(sig, self.signature(value)):\n-            return force_text(value)\n+            return value\n         raise BadSignature('Signature \"%s\" does not match' % sig)\n \n \n@@ -178,7 +177,7 @@ def timestamp(self):\n         return baseconv.base62.encode(int(time.time()))\n \n     def sign(self, value):\n-        value = smart_bytes('%s%s%s' % (value, self.sep, self.timestamp()))\n+        value = '%s%s%s' % (value, self.sep, self.timestamp())\n         return '%s%s%s' % (value, self.sep, self.signature(value))\n \n     def unsign(self, value, max_age=None):"
        },
        {
            "sha": "7145ec8b1836068863c66f0d26ea4039a7da7bea",
            "filename": "tests/regressiontests/signing/tests.py",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/92b2dec918d7b73456899ecb5726cc03b86bd068/tests%2Fregressiontests%2Fsigning%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/92b2dec918d7b73456899ecb5726cc03b86bd068/tests%2Fregressiontests%2Fsigning%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fsigning%2Ftests.py?ref=92b2dec918d7b73456899ecb5726cc03b86bd068",
            "patch": "@@ -4,6 +4,7 @@\n \n from django.core import signing\n from django.test import TestCase\n+from django.utils import six\n from django.utils.encoding import force_text\n \n \n@@ -69,15 +70,18 @@ def unsign_detects_tampering(self):\n \n     def test_dumps_loads(self):\n         \"dumps and loads be reversible for any JSON serializable object\"\n-        objects = (\n+        objects = [\n             ['a', 'list'],\n-            b'a string',\n             'a unicode string \\u2019',\n             {'a': 'dictionary'},\n-        )\n+        ]\n+        if not six.PY3:\n+            objects.append(b'a byte string')\n         for o in objects:\n             self.assertNotEqual(o, signing.dumps(o))\n             self.assertEqual(o, signing.loads(signing.dumps(o)))\n+            self.assertNotEqual(o, signing.dumps(o, compress=True))\n+            self.assertEqual(o, signing.loads(signing.dumps(o, compress=True)))\n \n     def test_decode_detects_tampering(self):\n         \"loads should raise exception for tampered objects\""
        }
    ],
    "stats": {
        "total": 29,
        "additions": 16,
        "deletions": 13
    }
}