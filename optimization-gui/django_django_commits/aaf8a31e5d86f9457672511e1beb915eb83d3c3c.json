{
    "author": "jphalip",
    "message": "Brushed up the custom template tag 'howto' guide by moving the assignment_tag doc to a more appropriate place (i.e. under the \"Setting a variable in the context\" section), adding cross references, fixing a few minor inaccuracies and doing a little PEP8 cleanup.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16909 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "aaf8a31e5d86f9457672511e1beb915eb83d3c3c",
    "files": [
        {
            "sha": "58a9e06d76444eb47a5862ea45fb4c9a0f068e83",
            "filename": "docs/howto/custom-template-tags.txt",
            "status": "modified",
            "additions": 254,
            "deletions": 178,
            "changes": 432,
            "blob_url": "https://github.com/django/django/blob/aaf8a31e5d86f9457672511e1beb915eb83d3c3c/docs%2Fhowto%2Fcustom-template-tags.txt",
            "raw_url": "https://github.com/django/django/raw/aaf8a31e5d86f9457672511e1beb915eb83d3c3c/docs%2Fhowto%2Fcustom-template-tags.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fhowto%2Fcustom-template-tags.txt?ref=aaf8a31e5d86f9457672511e1beb915eb83d3c3c",
            "patch": "@@ -2,16 +2,13 @@\n Custom template tags and filters\n ================================\n \n-Introduction\n-============\n-\n Django's template system comes with a wide variety of :doc:`built-in\n tags and filters </ref/templates/builtins>` designed to address the\n presentation logic needs of your application. Nevertheless, you may\n find yourself needing functionality that is not covered by the core\n set of template primitives. You can extend the template engine by\n defining custom tags and filters using Python, and then make them\n-available to your templates using the ``{% load %}`` tag.\n+available to your templates using the :ttag:`{% load %}<load>` tag.\n \n Code layout\n -----------\n@@ -47,18 +44,20 @@ And in your template you would use the following:\n     {% load poll_extras %}\n \n The app that contains the custom tags must be in :setting:`INSTALLED_APPS` in\n-order for the ``{% load %}`` tag to work. This is a security feature: It allows\n-you to host Python code for many template libraries on a single host machine\n-without enabling access to all of them for every Django installation.\n+order for the :ttag:`{% load %}<load>` tag to work. This is a security feature:\n+It allows you to host Python code for many template libraries on a single host\n+machine without enabling access to all of them for every Django installation.\n \n There's no limit on how many modules you put in the ``templatetags`` package.\n-Just keep in mind that a ``{% load %}`` statement will load tags/filters for\n-the given Python module name, not the name of the app.\n+Just keep in mind that a :ttag:`{% load %}<load>` statement will load\n+tags/filters for the given Python module name, not the name of the app.\n \n To be a valid tag library, the module must contain a module-level variable\n named ``register`` that is a ``template.Library`` instance, in which all the\n tags and filters are registered. So, near the top of your module, put the\n-following::\n+following:\n+\n+.. code-block:: python\n \n     from django import template\n \n@@ -89,10 +88,12 @@ Filter functions should always return something. They shouldn't raise\n exceptions. They should fail silently. In case of error, they should return\n either the original input or an empty string -- whichever makes more sense.\n \n-Here's an example filter definition::\n+Here's an example filter definition:\n+\n+.. code-block:: python\n \n     def cut(value, arg):\n-        \"Removes all values of arg from the given string\"\n+        \"\"\"Removes all values of arg from the given string\"\"\"\n         return value.replace(arg, '')\n \n And here's an example of how that filter would be used:\n@@ -102,17 +103,21 @@ And here's an example of how that filter would be used:\n     {{ somevariable|cut:\"0\" }}\n \n Most filters don't take arguments. In this case, just leave the argument out of\n-your function. Example::\n+your function. Example:\n+\n+.. code-block:: python\n \n     def lower(value): # Only one argument.\n-        \"Converts a string into all lowercase\"\n+        \"\"\"Converts a string into all lowercase\"\"\"\n         return value.lower()\n \n Registering custom filters\n ~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n Once you've written your filter definition, you need to register it with\n-your ``Library`` instance, to make it available to Django's template language::\n+your ``Library`` instance, to make it available to Django's template language:\n+\n+.. code-block:: python\n \n     register.filter('cut', cut)\n     register.filter('lower', lower)\n@@ -123,7 +128,9 @@ The ``Library.filter()`` method takes two arguments:\n     2. The compilation function -- a Python function (not the name of the\n        function as a string).\n \n-You can use ``register.filter()`` as a decorator instead::\n+You can use ``register.filter()`` as a decorator instead:\n+\n+.. code-block:: python\n \n     @register.filter(name='cut')\n     def cut(value, arg):\n@@ -141,7 +148,9 @@ Template filters that expect strings\n \n If you're writing a template filter that only expects a string as the first\n argument, you should use the decorator ``stringfilter``. This will\n-convert an object to its string value before being passed to your function::\n+convert an object to its string value before being passed to your function:\n+\n+.. code-block:: python\n \n     from django import template\n     from django.template.defaultfilters import stringfilter\n@@ -175,14 +184,17 @@ passed around inside the template code:\n \n       Internally, these strings are of type ``SafeString`` or ``SafeUnicode``.\n       They share a common base class of ``SafeData``, so you can test\n-      for them using code like::\n+      for them using code like:\n+\n+      .. code-block:: python\n \n           if isinstance(value, SafeData):\n               # Do something with the \"safe\" string.\n+              ...\n \n     * **Strings marked as \"needing escaping\"** are *always* escaped on\n-      output, regardless of whether they are in an ``autoescape`` block or not.\n-      These strings are only escaped once, however, even if auto-escaping\n+      output, regardless of whether they are in an :ttag:`autoescape` block or\n+      not. These strings are only escaped once, however, even if auto-escaping\n       applies.\n \n       Internally, these strings are of type ``EscapeString`` or\n@@ -195,7 +207,9 @@ Template filter code falls into one of two situations:\n        ``'``, ``\"`` or ``&``) into the result that were not already present. In\n        this case, you can let Django take care of all the auto-escaping\n        handling for you. All you need to do is put the ``is_safe`` attribute on\n-       your filter function and set it to ``True``, like so::\n+       your filter function and set it to ``True``, like so:\n+\n+       .. code-block:: python\n \n            @register.filter\n            def myfilter(value):\n@@ -215,19 +229,21 @@ Template filter code falls into one of two situations:\n        them all, which would be very difficult, Django repairs the damage after\n        the filter has completed.\n \n-       For example, suppose you have a filter that adds the string ``xx`` to the\n-       end of any input. Since this introduces no dangerous HTML characters to\n-       the result (aside from any that were already present), you should mark\n-       your filter with ``is_safe``::\n+       For example, suppose you have a filter that adds the string ``xx`` to\n+       the end of any input. Since this introduces no dangerous HTML characters\n+       to the result (aside from any that were already present), you should\n+       mark your filter with ``is_safe``:\n+\n+       .. code-block:: python\n \n            @register.filter\n            def add_xx(value):\n                return '%sxx' % value\n            add_xx.is_safe = True\n \n        When this filter is used in a template where auto-escaping is enabled,\n-       Django will escape the output whenever the input is not already marked as\n-       \"safe\".\n+       Django will escape the output whenever the input is not already marked\n+       as \"safe\".\n \n        By default, ``is_safe`` defaults to ``False``, and you can omit it from\n        any filters where it isn't required.\n@@ -271,7 +287,9 @@ Template filter code falls into one of two situations:\n        auto-escaping is in effect and ``False`` otherwise.\n \n        For example, let's write a filter that emphasizes the first character of\n-       a string::\n+       a string:\n+\n+       .. code-block:: python\n \n            from django.utils.html import conditional_escape\n            from django.utils.safestring import mark_safe\n@@ -346,7 +364,9 @@ anything else. In our case, let's say the tag should be used like this:\n     <p>The time is {% current_time \"%Y-%m-%d %I:%M %p\" %}.</p>\n \n The parser for this function should grab the parameter and create a ``Node``\n-object::\n+object:\n+\n+.. code-block:: python\n \n     from django import template\n     def do_current_time(parser, token):\n@@ -399,7 +419,9 @@ Writing the renderer\n The second step in writing custom tags is to define a ``Node`` subclass that\n has a ``render()`` method.\n \n-Continuing the above example, we need to define ``CurrentTimeNode``::\n+Continuing the above example, we need to define ``CurrentTimeNode``:\n+\n+.. code-block:: python\n \n     from django import template\n     import datetime\n@@ -441,15 +463,19 @@ as such.\n Also, if your template tag creates a new context for performing some\n sub-rendering, set the auto-escape attribute to the current context's value.\n The ``__init__`` method for the ``Context`` class takes a parameter called\n-``autoescape`` that you can use for this purpose. For example::\n+``autoescape`` that you can use for this purpose. For example:\n+\n+.. code-block:: python\n \n     def render(self, context):\n         # ...\n         new_context = Context({'var': obj}, autoescape=context.autoescape)\n         # ... Do something with new_context ...\n \n This is not a very common situation, but it's useful if you're rendering a\n-template yourself. For example::\n+template yourself. For example:\n+\n+.. code-block:: python\n \n     def render(self, context):\n         t = template.loader.get_template('small_fragment.html')\n@@ -458,7 +484,7 @@ template yourself. For example::\n If we had neglected to pass in the current ``context.autoescape`` value to our\n new ``Context`` in this example, the results would have *always* been\n automatically escaped, which may not be the desired behavior if the template\n-tag is used inside a ``{% autoescape off %}`` block.\n+tag is used inside a :ttag:`{% autoescape off %}<autoescape>` block.\n \n .. _template_tag_thread_safety:\n \n@@ -474,16 +500,21 @@ requests. Therefore, it's important to make sure your template tags are thread\n safe.\n \n To make sure your template tags are thread safe, you should never store state\n-information on the node itself. For example, Django provides a builtin ``cycle``\n-template tag that cycles among a list of given strings each time it's rendered::\n+information on the node itself. For example, Django provides a builtin\n+``cycle`` template tag that cycles among a list of given strings each time it's\n+rendered:\n+\n+.. code-block:: html+django\n \n     {% for o in some_list %}\n         <tr class=\"{% cycle 'row1' 'row2' %}>\n             ...\n         </tr>\n     {% endfor %}\n \n-A naive implementation of ``CycleNode`` might look something like this::\n+A naive implementation of ``CycleNode`` might look something like this:\n+\n+.. code-block:: python\n \n     class CycleNode(Node):\n         def __init__(self, cyclevars):\n@@ -509,10 +540,12 @@ obviously not what we want!\n \n To address this problem, Django provides a ``render_context`` that's associated\n with the ``context`` of the template that is currently being rendered. The\n-``render_context`` behaves like a Python dictionary, and should be used to store\n-``Node`` state between invocations of the ``render`` method.\n+``render_context`` behaves like a Python dictionary, and should be used to\n+store ``Node`` state between invocations of the ``render`` method.\n \n-Let's refactor our ``CycleNode`` implementation to use the ``render_context``::\n+Let's refactor our ``CycleNode`` implementation to use the ``render_context``:\n+\n+.. code-block:: python\n \n     class CycleNode(Node):\n         def __init__(self, cyclevars):\n@@ -534,16 +567,18 @@ like the current iteration of the ``CycleNode``, should be stored in the\n .. note::\n     Notice how we used ``self`` to scope the ``CycleNode`` specific information\n     within the ``render_context``. There may be multiple ``CycleNodes`` in a\n-    given template, so we need to be careful not to clobber another node's state\n-    information. The easiest way to do this is to always use ``self`` as the key\n-    into ``render_context``. If you're keeping track of several state variables,\n-    make ``render_context[self]`` a dictionary.\n+    given template, so we need to be careful not to clobber another node's\n+    state information. The easiest way to do this is to always use ``self`` as\n+    the key into ``render_context``. If you're keeping track of several state\n+    variables, make ``render_context[self]`` a dictionary.\n \n Registering the tag\n ~~~~~~~~~~~~~~~~~~~\n \n Finally, register the tag with your module's ``Library`` instance, as explained\n-in \"Writing custom template filters\" above. Example::\n+in \"Writing custom template filters\" above. Example:\n+\n+.. code-block:: python\n \n     register.tag('current_time', do_current_time)\n \n@@ -554,15 +589,17 @@ The ``tag()`` method takes two arguments:\n     2. The compilation function -- a Python function (not the name of the\n        function as a string).\n \n-As with filter registration, it is also possible to use this as a decorator::\n+As with filter registration, it is also possible to use this as a decorator:\n+\n+.. code-block:: python\n \n     @register.tag(name=\"current_time\")\n     def do_current_time(parser, token):\n-        # ...\n+        ...\n \n     @register.tag\n     def shout(parser, token):\n-        # ...\n+        ...\n \n If you leave off the ``name`` argument, as in the second example above, Django\n will use the function's name as the tag name.\n@@ -576,8 +613,9 @@ string literals. A little more work is required in order to pass dynamic\n content (a template variable) to a template tag as an argument.\n \n While the previous examples have formatted the current time into a string and\n-returned the string, suppose you wanted to pass in a ``DateTimeField`` from an\n-object and have the template tag format that date-time:\n+returned the string, suppose you wanted to pass in a\n+:class:`~django.db.models.DateTimeField` from an object and have the template\n+tag format that date-time:\n \n .. code-block:: html+django\n \n@@ -586,12 +624,15 @@ object and have the template tag format that date-time:\n Initially, ``token.split_contents()`` will return three values:\n \n     1. The tag name ``format_time``.\n-    2. The string \"blog_entry.date_updated\" (without the surrounding quotes).\n-    3. The formatting string \"%Y-%m-%d %I:%M %p\". The return value from\n+    2. The string ``\"blog_entry.date_updated\"`` (without the surrounding\n+       quotes).\n+    3. The formatting string ``\"%Y-%m-%d %I:%M %p\"``. The return value from\n        ``split_contents()`` will include the leading and trailing quotes for\n        string literals like this.\n \n-Now your tag should begin to look like this::\n+Now your tag should begin to look like this:\n+\n+.. code-block:: python\n \n     from django import template\n     def do_format_time(parser, token):\n@@ -610,7 +651,9 @@ accomplished by using the ``Variable()`` class in ``django.template``.\n \n To use the ``Variable`` class, simply instantiate it with the name of the\n variable to be resolved, and then call ``variable.resolve(context)``. So,\n-for example::\n+for example:\n+\n+.. code-block:: python\n \n     class FormatTimeNode(template.Node):\n         def __init__(self, date_to_be_formatted, format_string):\n@@ -624,13 +667,13 @@ for example::\n             except template.VariableDoesNotExist:\n                 return ''\n \n-Variable resolution will throw a ``VariableDoesNotExist`` exception if it cannot\n-resolve the string passed to it in the current context of the page.\n+Variable resolution will throw a ``VariableDoesNotExist`` exception if it\n+cannot resolve the string passed to it in the current context of the page.\n \n .. _howto-custom-template-tags-simple-tags:\n \n-Shortcut for simple tags\n-~~~~~~~~~~~~~~~~~~~~~~~~\n+Simple tags\n+~~~~~~~~~~~\n \n Many template tags take a number of arguments -- strings or template variables\n -- and return a string after doing some processing based solely on\n@@ -644,20 +687,24 @@ To ease the creation of these types of tags, Django provides a helper function,\n arguments, wraps it in a ``render`` function and the other necessary bits\n mentioned above and registers it with the template system.\n \n-Our earlier ``current_time`` function could thus be written like this::\n+Our earlier ``current_time`` function could thus be written like this:\n+\n+.. code-block:: python\n \n     def current_time(format_string):\n         return datetime.datetime.now().strftime(format_string)\n \n     register.simple_tag(current_time)\n \n-The decorator syntax also works::\n+The decorator syntax also works:\n+\n+.. code-block:: python\n \n     @register.simple_tag\n     def current_time(format_string):\n         ...\n \n-A couple of things to note about the ``simple_tag`` helper function:\n+A few things to note about the ``simple_tag`` helper function:\n \n     * Checking for the required number of arguments, etc., has already been\n       done by the time our function is called, so we don't need to do that.\n@@ -669,7 +716,9 @@ A couple of things to note about the ``simple_tag`` helper function:\n .. versionadded:: 1.3\n \n If your template tag needs to access the current context, you can use the\n-``takes_context`` argument when registering your tag::\n+``takes_context`` argument when registering your tag:\n+\n+.. code-block:: python\n \n     # The first argument *must* be called \"context\" here.\n     def current_time(context, format_string):\n@@ -678,7 +727,9 @@ If your template tag needs to access the current context, you can use the\n \n     register.simple_tag(takes_context=True)(current_time)\n \n-Or, using decorator syntax::\n+Or, using decorator syntax:\n+\n+.. code-block:: python\n \n     @register.simple_tag(takes_context=True)\n     def current_time(context, format_string):\n@@ -690,13 +741,15 @@ on :ref:`inclusion tags<howto-custom-template-tags-inclusion-tags>`.\n \n .. versionadded:: 1.4\n \n-If you need to rename your tag, you can provide a custom name for it::\n+If you need to rename your tag, you can provide a custom name for it:\n+\n+.. code-block:: python\n \n     register.simple_tag(lambda x: x - 1, name='minusone')\n \n     @register.simple_tag(name='minustwo')\n     def some_function(value):\n-        return value - 1\n+        return value - 2\n \n .. versionadded:: 1.4\n \n@@ -714,97 +767,13 @@ arguments. For example:\n \n Then in the template any number of arguments, separated by spaces, may be\n passed to the template tag. Like in Python, the values for keyword arguments\n-are set using the equal sign (\"``=``\") and must be provided after the positional\n-arguments. For example:\n+are set using the equal sign (\"``=``\") and must be provided after the\n+positional arguments. For example:\n \n .. code-block:: html+django\n \n     {% my_tag 123 \"abcd\" book.title warning=message|lower profile=user.profile %}\n \n-.. _howto-custom-template-tags-assignment-tags:\n-\n-Assignment tags\n-~~~~~~~~~~~~~~~\n-\n-.. versionadded:: 1.4\n-\n-Another common type of template tag is the type that fetches some data and\n-stores it in a context variable. To ease the creation of this type of tags,\n-Django provides a helper function, ``assignment_tag``. This function works\n-the same way as :ref:`simple_tag<howto-custom-template-tags-simple-tags>`,\n-except that it stores the tag's result in a specified context variable instead\n-of directly outputting it.\n-\n-Our earlier ``current_time`` function could thus be written like this:\n-\n-.. code-block:: python\n-\n-    def get_current_time(format_string):\n-        return datetime.datetime.now().strftime(format_string)\n-\n-    register.assignment_tag(get_current_time)\n-\n-The decorator syntax also works:\n-\n-.. code-block:: python\n-\n-    @register.assignment_tag\n-    def get_current_time(format_string):\n-        ...\n-\n-You may then store the result in a template variable using the ``as`` argument\n-followed by the variable name, and output it yourself where you see fit:\n-\n-.. code-block:: html+django\n-\n-    {% get_current_time \"%Y-%m-%d %I:%M %p\" as the_time %}\n-    <p>The time is {{ the_time }}.</p>\n-\n-If your template tag needs to access the current context, you can use the\n-``takes_context`` argument when registering your tag:\n-\n-.. code-block:: python\n-\n-    # The first argument *must* be called \"context\" here.\n-    def get_current_time(context, format_string):\n-        timezone = context['timezone']\n-        return your_get_current_time_method(timezone, format_string)\n-\n-    register.assignment_tag(takes_context=True)(get_current_time)\n-\n-Or, using decorator syntax:\n-\n-.. code-block:: python\n-\n-    @register.assignment_tag(takes_context=True)\n-    def get_current_time(context, format_string):\n-        timezone = context['timezone']\n-        return your_get_current_time_method(timezone, format_string)\n-\n-For more information on how the ``takes_context`` option works, see the section\n-on :ref:`inclusion tags<howto-custom-template-tags-inclusion-tags>`.\n-\n-``assignment_tag`` functions may accept any number of positional or keyword\n-arguments. For example:\n-\n-.. code-block:: python\n-\n-    @register.assignment_tag\n-    def my_tag(a, b, *args, **kwargs):\n-        warning = kwargs['warning']\n-        profile = kwargs['profile']\n-        ...\n-        return ...\n-\n-Then in the template any number of arguments, separated by spaces, may be\n-passed to the template tag. Like in Python, the values for keyword arguments\n-are set using the equal sign (\"``=``\") and must be provided after the positional\n-arguments. For example:\n-\n-.. code-block:: html+django\n-\n-    {% my_tag 123 \"abcd\" book.title warning=message|lower profile=user.profile as the_result %}\n-\n .. _howto-custom-template-tags-inclusion-tags:\n \n Inclusion tags\n@@ -813,10 +782,10 @@ Inclusion tags\n Another common type of template tag is the type that displays some data by\n rendering *another* template. For example, Django's admin interface uses custom\n template tags to display the buttons along the bottom of the \"add/change\" form\n-pages. Those buttons always look the same, but the link targets change depending\n-on the object being edited -- so they're a perfect case for using a small\n-template that is filled with details from the current object. (In the admin's\n-case, this is the ``submit_row`` tag.)\n+pages. Those buttons always look the same, but the link targets change\n+depending on the object being edited -- so they're a perfect case for using a\n+small template that is filled with details from the current object. (In the\n+admin's case, this is the ``submit_row`` tag.)\n \n These sorts of tags are called \"inclusion tags\".\n \n@@ -841,7 +810,9 @@ created in the :ref:`tutorials <creating-models>`. We'll use the tag like this:\n First, define the function that takes the argument and produces a dictionary of\n data for the result. The important point here is we only need to return a\n dictionary, not anything more complex. This will be used as a template context\n-for the template fragment. Example::\n+for the template fragment. Example:\n+\n+.. code-block:: python\n \n     def show_results(poll):\n         choices = poll.choice_set.all()\n@@ -861,22 +832,28 @@ designer. Following our example, the template is very simple:\n \n Now, create and register the inclusion tag by calling the ``inclusion_tag()``\n method on a ``Library`` object. Following our example, if the above template is\n-in a file called ``results.html`` in a directory that's searched by the template\n-loader, we'd register the tag like this::\n+in a file called ``results.html`` in a directory that's searched by the\n+template loader, we'd register the tag like this:\n+\n+.. code-block:: python\n \n     # Here, register is a django.template.Library instance, as before\n     register.inclusion_tag('results.html')(show_results)\n \n .. versionchanged:: 1.4\n \n     Alternatively it is possible to register the inclusion tag using a\n-    :class:`django.template.Template` instance::\n+    :class:`django.template.Template` instance:\n+\n+    .. code-block:: python\n \n         from django.template.loader import get_template\n         t = get_template('results.html')\n         register.inclusion_tag(t)(show_results)\n \n-As always, decorator syntax works as well, so we could have written::\n+As always, decorator syntax works as well, so we could have written:\n+\n+.. code-block:: python\n \n     @register.inclusion_tag('results.html')\n     def show_results(poll):\n@@ -893,7 +870,9 @@ will have one argument -- the template context as of when the tag was called.\n \n For example, say you're writing an inclusion tag that will always be used in a\n context that contains ``home_link`` and ``home_title`` variables that point\n-back to the main page. Here's what the Python function would look like::\n+back to the main page. Here's what the Python function would look like:\n+\n+.. code-block:: python\n \n     # The first argument *must* be called \"context\" here.\n     def jump_link(context):\n@@ -924,9 +903,9 @@ without any arguments, like so:\n Note that when you're using ``takes_context=True``, there's no need to pass\n arguments to the template tag. It automatically gets access to the context.\n \n-The ``takes_context`` parameter defaults to ``False``. When it's set to *True*,\n-the tag is passed the context object, as in this example. That's the only\n-difference between this case and the previous ``inclusion_tag`` example.\n+The ``takes_context`` parameter defaults to ``False``. When it's set to\n+``True``, the tag is passed the context object, as in this example. That's the\n+only difference between this case and the previous ``inclusion_tag`` example.\n \n .. versionadded:: 1.4\n \n@@ -944,8 +923,8 @@ arguments. For example:\n \n Then in the template any number of arguments, separated by spaces, may be\n passed to the template tag. Like in Python, the values for keyword arguments\n-are set using the equal sign (\"``=``\") and must be provided after the positional\n-arguments. For example:\n+are set using the equal sign (\"``=``\") and must be provided after the\n+positional arguments. For example:\n \n .. code-block:: html+django\n \n@@ -961,7 +940,9 @@ template authors can reuse the values that your template tags create.\n To set a variable in the context, just use dictionary assignment on the context\n object in the ``render()`` method. Here's an updated version of\n ``CurrentTimeNode`` that sets a template variable ``current_time`` instead of\n-outputting it::\n+outputting it:\n+\n+.. code-block:: python\n \n     class CurrentTimeNode2(template.Node):\n         def __init__(self, format_string):\n@@ -982,10 +963,10 @@ Here's how you'd use this new version of the tag:\n \n .. admonition:: Variable scope in context\n \n-    Any variable set in the context will only be available in the same ``block``\n-    of the template in which it was assigned. This behavior is intentional;\n-    it provides a scope for variables so that they don't conflict with\n-    context in other blocks.\n+    Any variable set in the context will only be available in the same\n+    ``block`` of the template in which it was assigned. This behavior is\n+    intentional; it provides a scope for variables so that they don't conflict\n+    with context in other blocks.\n \n But, there's a problem with ``CurrentTimeNode2``: The variable name\n ``current_time`` is hard-coded. This means you'll need to make sure your\n@@ -1000,7 +981,9 @@ like so:\n     <p>The current time is {{ my_current_time }}.</p>\n \n To do that, you'll need to refactor both the compilation function and ``Node``\n-class, like so::\n+class, like so:\n+\n+.. code-block:: python\n \n     class CurrentTimeNode3(template.Node):\n         def __init__(self, format_string, var_name):\n@@ -1029,14 +1012,104 @@ class, like so::\n The difference here is that ``do_current_time()`` grabs the format string and\n the variable name, passing both to ``CurrentTimeNode3``.\n \n+Finally, if you only need to have a simple syntax for your custom\n+context-updating template tag, you might want to consider using an\n+:ref:`assignment tag <howto-custom-template-tags-assignment-tags>`.\n+\n+.. _howto-custom-template-tags-assignment-tags:\n+\n+Assignment tags\n+~~~~~~~~~~~~~~~\n+\n+.. versionadded:: 1.4\n+\n+To ease the creation of tags setting a variable in the context, Django provides\n+a helper function, ``assignment_tag``. This function works the same way as\n+:ref:`simple_tag<howto-custom-template-tags-simple-tags>`, except that it\n+stores the tag's result in a specified context variable instead of directly\n+outputting it.\n+\n+Our earlier ``current_time`` function could thus be written like this:\n+\n+.. code-block:: python\n+\n+    def get_current_time(format_string):\n+        return datetime.datetime.now().strftime(format_string)\n+\n+    register.assignment_tag(get_current_time)\n+\n+The decorator syntax also works:\n+\n+.. code-block:: python\n+\n+    @register.assignment_tag\n+    def get_current_time(format_string):\n+        ...\n+\n+You may then store the result in a template variable using the ``as`` argument\n+followed by the variable name, and output it yourself where you see fit:\n+\n+.. code-block:: html+django\n+\n+    {% get_current_time \"%Y-%m-%d %I:%M %p\" as the_time %}\n+    <p>The time is {{ the_time }}.</p>\n+\n+If your template tag needs to access the current context, you can use the\n+``takes_context`` argument when registering your tag:\n+\n+.. code-block:: python\n+\n+    # The first argument *must* be called \"context\" here.\n+    def get_current_time(context, format_string):\n+        timezone = context['timezone']\n+        return your_get_current_time_method(timezone, format_string)\n+\n+    register.assignment_tag(takes_context=True)(get_current_time)\n+\n+Or, using decorator syntax:\n+\n+.. code-block:: python\n+\n+    @register.assignment_tag(takes_context=True)\n+    def get_current_time(context, format_string):\n+        timezone = context['timezone']\n+        return your_get_current_time_method(timezone, format_string)\n+\n+For more information on how the ``takes_context`` option works, see the section\n+on :ref:`inclusion tags<howto-custom-template-tags-inclusion-tags>`.\n+\n+``assignment_tag`` functions may accept any number of positional or keyword\n+arguments. For example:\n+\n+.. code-block:: python\n+\n+    @register.assignment_tag\n+    def my_tag(a, b, *args, **kwargs):\n+        warning = kwargs['warning']\n+        profile = kwargs['profile']\n+        ...\n+        return ...\n+\n+Then in the template any number of arguments, separated by spaces, may be\n+passed to the template tag. Like in Python, the values for keyword arguments\n+are set using the equal sign (\"``=``\") and must be provided after the\n+positional arguments. For example:\n+\n+.. code-block:: html+django\n+\n+    {% my_tag 123 \"abcd\" book.title warning=message|lower profile=user.profile as the_result %}\n+\n Parsing until another block tag\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-Template tags can work in tandem. For instance, the standard ``{% comment %}``\n-tag hides everything until ``{% endcomment %}``. To create a template tag such\n-as this, use ``parser.parse()`` in your compilation function.\n+Template tags can work in tandem. For instance, the standard\n+:ttag:`{% comment %}<comment>` tag hides everything until ``{% endcomment %}``.\n+To create a template tag such as this, use ``parser.parse()`` in your\n+compilation function.\n \n-Here's how the standard ``{% comment %}`` tag is implemented::\n+Here's how the standard :ttag:`{% comment %}<comment>` tag is implemented:\n+\n+.. code-block:: python\n \n     def do_comment(parser, token):\n         nodelist = parser.parse(('endcomment',))\n@@ -1081,7 +1154,9 @@ Usage:\n     {% upper %}This will appear in uppercase, {{ your_name }}.{% endupper %}\n \n As in the previous example, we'll use ``parser.parse()``. But this time, we\n-pass the resulting ``nodelist`` to the ``Node``::\n+pass the resulting ``nodelist`` to the ``Node``:\n+\n+.. code-block:: python\n \n     def do_upper(parser, token):\n         nodelist = parser.parse(('endupper',))\n@@ -1098,6 +1173,7 @@ pass the resulting ``nodelist`` to the ``Node``::\n The only new concept here is the ``self.nodelist.render(context)`` in\n ``UpperNode.render()``.\n \n-For more examples of complex rendering, see the source code for ``{% if %}``,\n-``{% for %}``, ``{% ifequal %}`` and ``{% ifchanged %}``. They live in\n+For more examples of complex rendering, see the source code for\n+:ttag:`{% if %}<if>`, :ttag:`{% for %}<for>`, :ttag:`{% ifequal %}<ifequal>`\n+or :ttag:`{% ifchanged %}<ifchanged>`. They live in\n ``django/template/defaulttags.py``."
        }
    ],
    "stats": {
        "total": 432,
        "additions": 254,
        "deletions": 178
    }
}