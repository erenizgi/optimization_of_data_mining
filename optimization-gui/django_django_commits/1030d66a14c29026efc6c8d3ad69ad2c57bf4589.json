{
    "author": "PaulMcMillan",
    "message": "Fixed #17481. pbkdf2 hashes no longer ommit leading zeros. \n\nSome existing user passwords may need to be reset or converted \nafter this change. See the 1.4-beta release notes for more details.\n\nThanks bhuztez for the report and initial patch, claudep for the test.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17418 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "1030d66a14c29026efc6c8d3ad69ad2c57bf4589",
    "files": [
        {
            "sha": "f3a0675cc6f84ab5433aeac481d68303812c998c",
            "filename": "django/utils/crypto.py",
            "status": "modified",
            "additions": 15,
            "deletions": 15,
            "changes": 30,
            "blob_url": "https://github.com/django/django/blob/1030d66a14c29026efc6c8d3ad69ad2c57bf4589/django%2Futils%2Fcrypto.py",
            "raw_url": "https://github.com/django/django/raw/1030d66a14c29026efc6c8d3ad69ad2c57bf4589/django%2Futils%2Fcrypto.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fcrypto.py?ref=1030d66a14c29026efc6c8d3ad69ad2c57bf4589",
            "patch": "@@ -10,8 +10,8 @@\n from django.conf import settings\n \n \n-trans_5c = \"\".join([chr(x ^ 0x5C) for x in xrange(256)])\n-trans_36 = \"\".join([chr(x ^ 0x36) for x in xrange(256)])\n+_trans_5c = \"\".join([chr(x ^ 0x5C) for x in xrange(256)])\n+_trans_36 = \"\".join([chr(x ^ 0x36) for x in xrange(256)])\n \n \n def salted_hmac(key_salt, value, secret=None):\n@@ -66,7 +66,7 @@ def constant_time_compare(val1, val2):\n     return result == 0\n \n \n-def bin_to_long(x):\n+def _bin_to_long(x):\n     \"\"\"\n     Convert a binary string into a long integer\n \n@@ -75,27 +75,25 @@ def bin_to_long(x):\n     return long(x.encode('hex'), 16)\n \n \n-def long_to_bin(x):\n+def _long_to_bin(x, hex_format_string):\n     \"\"\"\n-    Convert a long integer into a binary string\n+    Convert a long integer into a binary string.\n+    hex_format_string is like \"%020x\" for padding 10 characters.\n     \"\"\"\n-    hex = \"%x\" % (x)\n-    if len(hex) % 2 == 1:\n-        hex = '0' + hex\n-    return binascii.unhexlify(hex)\n+    return binascii.unhexlify(hex_format_string % x)\n \n \n-def fast_hmac(key, msg, digest):\n+def _fast_hmac(key, msg, digest):\n     \"\"\"\n     A trimmed down version of Python's HMAC implementation\n     \"\"\"\n     dig1, dig2 = digest(), digest()\n     if len(key) > dig1.block_size:\n         key = digest(key).digest()\n     key += chr(0) * (dig1.block_size - len(key))\n-    dig1.update(key.translate(trans_36))\n+    dig1.update(key.translate(_trans_36))\n     dig1.update(msg)\n-    dig2.update(key.translate(trans_5c))\n+    dig2.update(key.translate(_trans_5c))\n     dig2.update(dig1.digest())\n     return dig2\n \n@@ -123,13 +121,15 @@ def pbkdf2(password, salt, iterations, dklen=0, digest=None):\n     l = -(-dklen // hlen)\n     r = dklen - (l - 1) * hlen\n \n+    hex_format_string = \"%%0%ix\" % (hlen * 2)\n+\n     def F(i):\n         def U():\n             u = salt + struct.pack('>I', i)\n             for j in xrange(int(iterations)):\n-                u = fast_hmac(password, u, digest).digest()\n-                yield bin_to_long(u)\n-        return long_to_bin(reduce(operator.xor, U()))\n+                u = _fast_hmac(password, u, digest).digest()\n+                yield _bin_to_long(u)\n+        return _long_to_bin(reduce(operator.xor, U()), hex_format_string)\n \n     T = [F(x) for x in range(1, l + 1)]\n     return ''.join(T[:-1]) + T[-1][:r]"
        },
        {
            "sha": "2bdc5ba53090777100d496a96ff0afe7ae07fbad",
            "filename": "tests/regressiontests/utils/crypto.py",
            "status": "modified",
            "additions": 19,
            "deletions": 4,
            "changes": 23,
            "blob_url": "https://github.com/django/django/blob/1030d66a14c29026efc6c8d3ad69ad2c57bf4589/tests%2Fregressiontests%2Futils%2Fcrypto.py",
            "raw_url": "https://github.com/django/django/raw/1030d66a14c29026efc6c8d3ad69ad2c57bf4589/tests%2Fregressiontests%2Futils%2Fcrypto.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Futils%2Fcrypto.py?ref=1030d66a14c29026efc6c8d3ad69ad2c57bf4589",
            "patch": "@@ -108,6 +108,17 @@ class TestUtilsCryptoPBKDF2(unittest.TestCase):\n                        \"c4007d5298f9033c0241d5ab69305e7b64eceeb8d\"\n                        \"834cfec\"),\n         },\n+        # Check leading zeros are not stripped (#17481) \n+        {\n+            \"args\": { \n+                \"password\": chr(186), \n+                \"salt\": \"salt\", \n+                \"iterations\": 1, \n+                \"dklen\": 20, \n+                \"digest\": hashlib.sha1, \n+            }, \n+            \"result\": '0053d3b91a7f1e54effebd6d68771e8a6e0b2c5b',\n+        },\n     ]\n \n     def test_public_vectors(self):\n@@ -125,11 +136,15 @@ def test_performance_scalability(self):\n         Theory: If you run with 100 iterations, it should take 100\n         times as long as running with 1 iteration.\n         \"\"\"\n-        n1, n2 = 1000, 100000\n-        elapsed = lambda f: timeit.Timer(f, 'from django.utils.crypto import pbkdf2').timeit(number=1)\n+        # These values are chosen as a reasonable tradeoff between time\n+        # to run the test suite and false positives caused by imprecise\n+        # measurement.\n+        n1, n2 = 200000, 800000\n+        elapsed = lambda f: timeit.Timer(f, \n+                    'from django.utils.crypto import pbkdf2').timeit(number=1)\n         t1 = elapsed('pbkdf2(\"password\", \"salt\", iterations=%d)' % n1)\n         t2 = elapsed('pbkdf2(\"password\", \"salt\", iterations=%d)' % n2)\n         measured_scale_exponent = math.log(t2 / t1, n2 / n1)\n-        # This should be less than 1. We allow up to 1.1 so that tests don't \n+        # This should be less than 1. We allow up to 1.2 so that tests don't \n         # fail nondeterministically too often.\n-        self.assertLess(measured_scale_exponent, 1.1)\n+        self.assertLess(measured_scale_exponent, 1.2)"
        }
    ],
    "stats": {
        "total": 53,
        "additions": 34,
        "deletions": 19
    }
}