{
    "author": "jacobian",
    "message": "Fixed #2705: added a `select_for_update()` clause to querysets.\n\nA number of people worked on this patch over the years -- Hawkeye, Colin Grady,\nKBS, sakyamuni, anih, jdemoor, and Issak Kelly. Thanks to them all, and\napologies if I missed anyone.\n\nSpecial thanks to Dan Fairs for picking it up again at the end and seeing this\nthrough to commit.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16058 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
    "files": [
        {
            "sha": "a6e4aa2eedbdf06fd0354f7a3c1ea04fc9628c23",
            "filename": "AUTHORS",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/AUTHORS",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/AUTHORS",
            "contents_url": "https://api.github.com/repos/django/django/contents/AUTHORS?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -168,6 +168,7 @@ answer newbie questions, and generally made Django that much better:\n     eriks@win.tue.nl\n     Tomáš Ehrlich <tomas.ehrlich@gmail.com>\n     Dirk Eschler <dirk.eschler@gmx.net>\n+    Dan Fairs <dan@fezconsulting.com>\n     Marc Fargas <telenieko@telenieko.com>\n     Szilveszter Farkas <szilveszter.farkas@gmail.com>\n     Grigory Fateyev <greg@dial.com.ru>"
        },
        {
            "sha": "b64fb01b0398b37911fd4c9380d75efc38ba912e",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -279,6 +279,8 @@ class BaseDatabaseFeatures(object):\n     # integer primary keys.\n     related_fields_match_type = False\n     allow_sliced_subqueries = True\n+    has_select_for_update = False\n+    has_select_for_update_nowait = False\n \n     # Does the default test database allow multiple connections?\n     # Usually an indication that the test database is in-memory\n@@ -476,6 +478,15 @@ def force_no_ordering(self):\n         \"\"\"\n         return []\n \n+    def for_update_sql(self, nowait=False):\n+        \"\"\"\n+        Returns the FOR UPDATE SQL clause to lock rows for an update operation.\n+        \"\"\"\n+        if nowait:\n+            return 'FOR UPDATE NOWAIT'\n+        else:\n+            return 'FOR UPDATE'\n+\n     def fulltext_search_sql(self, field_name):\n         \"\"\"\n         Returns the SQL WHERE clause to use in order to perform a full-text"
        },
        {
            "sha": "16067c68071f7b18285bdfa292da16216e20d7a6",
            "filename": "django/db/backends/mysql/base.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -124,6 +124,8 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     allows_group_by_pk = True\n     related_fields_match_type = True\n     allow_sliced_subqueries = False\n+    has_select_for_update = True\n+    has_select_for_update_nowait = False\n     supports_forward_references = False\n     supports_long_model_names = False\n     supports_microsecond_precision = False"
        },
        {
            "sha": "bcb906762b044aa3b586c06dfc97fd181b841753",
            "filename": "django/db/backends/oracle/base.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Foracle%2Fbase.py?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -70,6 +70,8 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     needs_datetime_string_cast = False\n     interprets_empty_strings_as_nulls = True\n     uses_savepoints = True\n+    has_select_for_update = True\n+    has_select_for_update_nowait = True\n     can_return_id_from_insert = True\n     allow_sliced_subqueries = False\n     supports_subqueries_in_group_by = False"
        },
        {
            "sha": "67e28774fe589b61a1e67fcb45670af6b5746be7",
            "filename": "django/db/backends/postgresql_psycopg2/base.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -70,6 +70,9 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     requires_rollback_on_dirty_transaction = True\n     has_real_datatype = True\n     can_defer_constraint_checks = True\n+    has_select_for_update = True\n+    has_select_for_update_nowait = True\n+\n \n class DatabaseWrapper(BaseDatabaseWrapper):\n     vendor = 'postgresql'"
        },
        {
            "sha": "4fa4c4a52df620e17a35b10f707202fd09482a2a",
            "filename": "django/db/models/manager.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fmodels%2Fmanager.py",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fmodels%2Fmanager.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fmanager.py?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -164,6 +164,9 @@ def latest(self, *args, **kwargs):\n     def order_by(self, *args, **kwargs):\n         return self.get_query_set().order_by(*args, **kwargs)\n \n+    def select_for_update(self, *args, **kwargs):\n+        return self.get_query_set().select_for_update(*args, **kwargs)\n+\n     def select_related(self, *args, **kwargs):\n         return self.get_query_set().select_related(*args, **kwargs)\n "
        },
        {
            "sha": "8e33765fdfc448bd4bf26f044b0d596c4e0a4b29",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -435,6 +435,7 @@ def delete(self):\n         del_query._for_write = True\n \n         # Disable non-supported fields.\n+        del_query.query.select_for_update = False\n         del_query.query.select_related = False\n         del_query.query.clear_ordering()\n \n@@ -583,6 +584,18 @@ def complex_filter(self, filter_obj):\n         else:\n             return self._filter_or_exclude(None, **filter_obj)\n \n+    def select_for_update(self, **kwargs):\n+        \"\"\"\n+        Returns a new QuerySet instance that will select objects with a\n+        FOR UPDATE lock.\n+        \"\"\"\n+        # Default to false for nowait\n+        nowait = kwargs.pop('nowait', False)\n+        obj = self._clone()\n+        obj.query.select_for_update = True\n+        obj.query.select_for_update_nowait = nowait\n+        return obj\n+\n     def select_related(self, *fields, **kwargs):\n         \"\"\"\n         Returns a new QuerySet instance that will select related objects."
        },
        {
            "sha": "ace9cf4c88346cc866dbdd369ea73427e8ba9924",
            "filename": "django/db/models/sql/compiler.py",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -1,11 +1,13 @@\n from django.core.exceptions import FieldError\n from django.db import connections\n+from django.db import transaction\n from django.db.backends.util import truncate_name\n from django.db.models.sql.constants import *\n from django.db.models.sql.datastructures import EmptyResultSet\n from django.db.models.sql.expressions import SQLEvaluator\n from django.db.models.sql.query import get_proxied_model, get_order_dir, \\\n      select_related_descend, Query\n+from django.db.utils import DatabaseError\n \n class SQLCompiler(object):\n     def __init__(self, query, connection, using):\n@@ -117,6 +119,14 @@ def as_sql(self, with_limits=True, with_col_aliases=False):\n                         result.append('LIMIT %d' % val)\n                 result.append('OFFSET %d' % self.query.low_mark)\n \n+        if self.query.select_for_update and self.connection.features.has_select_for_update:\n+            # If we've been asked for a NOWAIT query but the backend does not support it,\n+            # raise a DatabaseError otherwise we could get an unexpected deadlock.\n+            nowait = self.query.select_for_update_nowait\n+            if nowait and not self.connection.features.has_select_for_update_nowait:\n+                raise DatabaseError('NOWAIT is not supported on this database backend.')\n+            result.append(self.connection.ops.for_update_sql(nowait=nowait))\n+\n         return ' '.join(result), tuple(params)\n \n     def as_nested_sql(self):\n@@ -677,6 +687,11 @@ def results_iter(self):\n         resolve_columns = hasattr(self, 'resolve_columns')\n         fields = None\n         has_aggregate_select = bool(self.query.aggregate_select)\n+        # Set transaction dirty if we're using SELECT FOR UPDATE to ensure\n+        # a subsequent commit/rollback is executed, so any database locks\n+        # are released.\n+        if self.query.select_for_update and transaction.is_managed(self.using):\n+            transaction.set_dirty(self.using)\n         for rows in self.execute_sql(MULTI):\n             for row in rows:\n                 if resolve_columns:"
        },
        {
            "sha": "f41272cf0faa2025f1c03e3c3d5d68c819082e8f",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -125,6 +125,8 @@ def __init__(self, model, where=WhereNode):\n         self.order_by = []\n         self.low_mark, self.high_mark = 0, None  # Used for offset/limit\n         self.distinct = False\n+        self.select_for_update = False\n+        self.select_for_update_nowait = False\n         self.select_related = False\n         self.related_select_cols = []\n \n@@ -254,6 +256,8 @@ def clone(self, klass=None, memo=None, **kwargs):\n         obj.order_by = self.order_by[:]\n         obj.low_mark, obj.high_mark = self.low_mark, self.high_mark\n         obj.distinct = self.distinct\n+        obj.select_for_update = self.select_for_update\n+        obj.select_for_update_nowait = self.select_for_update_nowait\n         obj.select_related = self.select_related\n         obj.related_select_cols = []\n         obj.aggregates = copy.deepcopy(self.aggregates, memo=memo)\n@@ -360,6 +364,7 @@ def get_aggregation(self, using):\n \n         query.clear_ordering(True)\n         query.clear_limits()\n+        query.select_for_update = False\n         query.select_related = False\n         query.related_select_cols = []\n         query.related_select_fields = []"
        },
        {
            "sha": "fb97c9f0456737c1a583edf638db2711fea25979",
            "filename": "docs/ref/databases.txt",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/docs%2Fref%2Fdatabases.txt",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/docs%2Fref%2Fdatabases.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fdatabases.txt?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -359,6 +359,13 @@ store a timezone-aware ``time`` or ``datetime`` to a\n :class:`~django.db.models.TimeField` or :class:`~django.db.models.DateTimeField`\n respectively, a ``ValueError`` is raised rather than truncating data.\n \n+Row locking with ``QuerySet.select_for_update()``\n+-------------------------------------------------\n+\n+MySQL does not support the ``NOWAIT`` option to the ``SELECT ... FOR UPDATE``\n+statement. If ``select_for_update()`` is used with ``nowait=True`` then a\n+``DatabaseError`` will be raised.\n+\n .. _sqlite-notes:\n \n SQLite notes\n@@ -493,6 +500,12 @@ If you're getting this error, you can solve it by:\n       This will simply make SQLite wait a bit longer before throwing \"database\n       is locked\" errors; it won't really do anything to solve them.\n \n+``QuerySet.select_for_update()`` not supported\n+----------------------------------------------\n+\n+SQLite does not support the ``SELECT ... FOR UPDATE`` syntax. Calling it will\n+have no effect.\n+\n .. _oracle-notes:\n \n Oracle notes"
        },
        {
            "sha": "f05368bc0c57cfa980c00022223614c0434f1232",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -966,6 +966,46 @@ For example::\n     # queries the database with the 'backup' alias\n     >>> Entry.objects.using('backup')\n \n+select_for_update\n+~~~~~~~~~~~~~~~~~\n+\n+.. method:: select_for_update(nowait=False)\n+\n+.. versionadded:: 1.4\n+\n+Returns a queryset that will lock rows until the end of the transaction,\n+generating a ``SELECT ... FOR UPDATE`` SQL statement on supported databases.\n+\n+For example::\n+\n+    entries = Entry.objects.select_for_update().filter(author=request.user)\n+\n+All matched entries will be locked until the end of the transaction block,\n+meaning that other transactions will be prevented from changing or acquiring\n+locks on them.\n+\n+Usually, if another transaction has already acquired a lock on one of the\n+selected rows, the query will block until the lock is released. If this is\n+not the behaviour you want, call ``select_for_update(nowait=True)``. This will\n+make the call non-blocking. If a conflicting lock is already acquired by\n+another transaction, ``django.db.utils.DatabaseError`` will be raised when\n+the queryset is evaluated.\n+\n+Note that using ``select_for_update`` will cause the current transaction to be\n+set dirty, if under transaction management. This is to ensure that Django issues\n+a ``COMMIT`` or ``ROLLBACK``, releasing any locks held by the ``SELECT FOR\n+UPDATE``.\n+\n+Currently, the ``postgresql_psycopg2``, ``oracle``, and ``mysql``\n+database backends support ``select_for_update()``. However, MySQL has no\n+support for the ``nowait`` argument.\n+\n+Passing ``nowait=True`` to ``select_for_update`` using database backends that\n+do not support ``nowait``, such as MySQL, will cause a ``DatabaseError`` to be\n+raised. This is in order to prevent code unexpectedly blocking.\n+\n+Using ``select_for_update`` on backends which do not support\n+``SELECT ... FOR UPDATE`` (such as SQLite) will have no effect.\n \n Methods that do not return QuerySets\n ------------------------------------"
        },
        {
            "sha": "792d6005489ebee62cde02066f19c5521e620451",
            "filename": "tests/modeltests/select_for_update/__init__.py",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/tests%2Fmodeltests%2Fselect_for_update%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/tests%2Fmodeltests%2Fselect_for_update%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fselect_for_update%2F__init__.py?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -0,0 +1 @@\n+#"
        },
        {
            "sha": "a124d1f077a20772a762e1af004ea5f2e9195a7a",
            "filename": "tests/modeltests/select_for_update/models.py",
            "status": "added",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/tests%2Fmodeltests%2Fselect_for_update%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/tests%2Fmodeltests%2Fselect_for_update%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fselect_for_update%2Fmodels.py?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -0,0 +1,4 @@\n+from django.db import models\n+\n+class Person(models.Model):\n+    name = models.CharField(max_length=30)"
        },
        {
            "sha": "514b9e46fd8beb9cf12599fab46dd7b7f6f059ef",
            "filename": "tests/modeltests/select_for_update/tests.py",
            "status": "added",
            "additions": 262,
            "deletions": 0,
            "changes": 262,
            "blob_url": "https://github.com/django/django/blob/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/tests%2Fmodeltests%2Fselect_for_update%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/8f0f73c7b8b110489a1a127cc47e3cabb0eea646/tests%2Fmodeltests%2Fselect_for_update%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fselect_for_update%2Ftests.py?ref=8f0f73c7b8b110489a1a127cc47e3cabb0eea646",
            "patch": "@@ -0,0 +1,262 @@\n+import sys\n+import time\n+import unittest\n+from django.conf import settings\n+from django.db import transaction, connection\n+from django.db.utils import ConnectionHandler, DEFAULT_DB_ALIAS, DatabaseError\n+from django.test import (TransactionTestCase, skipIfDBFeature,\n+    skipUnlessDBFeature)\n+from django.utils.functional import wraps\n+from django.utils import unittest\n+\n+from models import Person\n+\n+try:\n+    import threading\n+    def requires_threading(func):\n+        return func\n+except ImportError:\n+    # Note we can't use dummy_threading here, as our tests will actually\n+    # block. We just have to skip the test completely.\n+    def requires_threading(func):\n+        @wraps(func)\n+        def wrapped(*args, **kw):\n+            raise unittest.SkipTest('threading required')\n+\n+class SelectForUpdateTests(TransactionTestCase):\n+\n+    def setUp(self):\n+        transaction.enter_transaction_management(True)\n+        transaction.managed(True)\n+        self.person = Person.objects.create(name='Reinhardt')\n+\n+        # We have to commit here so that code in run_select_for_update can\n+        # see this data.\n+        transaction.commit()\n+\n+        # We need another database connection to test that one connection\n+        # issuing a SELECT ... FOR UPDATE will block.\n+        new_connections = ConnectionHandler(settings.DATABASES)\n+        self.new_connection = new_connections[DEFAULT_DB_ALIAS]\n+\n+        # We need to set settings.DEBUG to True so we can capture\n+        # the output SQL to examine.\n+        self._old_debug = settings.DEBUG\n+        settings.DEBUG = True\n+\n+    def tearDown(self):\n+        try:\n+            # We don't really care if this fails - some of the tests will set\n+            # this in the course of their run.\n+            transaction.managed(False)\n+            transaction.leave_transaction_management()\n+        except transaction.TransactionManagementError:\n+            pass\n+        self.new_connection.close()\n+        settings.DEBUG = self._old_debug\n+        try:\n+            self.end_blocking_transaction()\n+        except (DatabaseError, AttributeError):\n+            pass\n+\n+    def start_blocking_transaction(self):\n+        # Start a blocking transaction. At some point,\n+        # end_blocking_transaction() should be called.\n+        self.cursor = self.new_connection.cursor()\n+        sql = 'SELECT * FROM %(db_table)s %(for_update)s;' % {\n+            'db_table': Person._meta.db_table,\n+            'for_update': self.new_connection.ops.for_update_sql(),\n+            }\n+        self.cursor.execute(sql, ())\n+        result = self.cursor.fetchone()\n+\n+    def end_blocking_transaction(self):\n+        # Roll back the blocking transaction.\n+        self.new_connection._rollback()\n+\n+    def has_for_update_sql(self, tested_connection, nowait=False):\n+        # Examine the SQL that was executed to determine whether it\n+        # contains the 'SELECT..FOR UPDATE' stanza.\n+        for_update_sql = tested_connection.ops.for_update_sql(nowait)\n+        sql = tested_connection.queries[-1]['sql']\n+        return bool(sql.find(for_update_sql) > -1)\n+\n+    def check_exc(self, exc):\n+        self.failUnless(isinstance(exc, DatabaseError))\n+\n+    @skipUnlessDBFeature('has_select_for_update')\n+    def test_for_update_sql_generated(self):\n+        \"\"\"\n+        Test that the backend's FOR UPDATE variant appears in\n+        generated SQL when select_for_update is invoked.\n+        \"\"\"\n+        list(Person.objects.all().select_for_update())\n+        self.assertTrue(self.has_for_update_sql(connection))\n+\n+    @skipUnlessDBFeature('has_select_for_update_nowait')\n+    def test_for_update_sql_generated_nowait(self):\n+        \"\"\"\n+        Test that the backend's FOR UPDATE NOWAIT variant appears in\n+        generated SQL when select_for_update is invoked.\n+        \"\"\"\n+        list(Person.objects.all().select_for_update(nowait=True))\n+        self.assertTrue(self.has_for_update_sql(connection, nowait=True))\n+\n+    # In Python 2.6 beta and some final releases, exceptions raised in __len__\n+    # are swallowed (Python issue 1242657), so these cases return an empty\n+    # list, rather than raising an exception. Not a lot we can do about that,\n+    # unfortunately, due to the way Python handles list() calls internally.\n+    # Thus, we skip this test for Python 2.6.\n+    @requires_threading\n+    @skipUnlessDBFeature('has_select_for_update_nowait')\n+    @unittest.skipIf(sys.version_info[:2] == (2, 6), \"Python version is 2.6\")\n+    def test_nowait_raises_error_on_block(self):\n+        \"\"\"\n+        If nowait is specified, we expect an error to be raised rather\n+        than blocking.\n+        \"\"\"\n+        self.start_blocking_transaction()\n+        status = []\n+        thread = threading.Thread(\n+            target=self.run_select_for_update,\n+            args=(status,),\n+            kwargs={'nowait': True},\n+        )\n+\n+        thread.start()\n+        time.sleep(1)\n+        thread.join()\n+        self.end_blocking_transaction()\n+        self.check_exc(status[-1])\n+\n+    @skipIfDBFeature('has_select_for_update_nowait')\n+    @skipUnlessDBFeature('has_select_for_update')\n+    def test_unsupported_nowait_raises_error(self):\n+        \"\"\"\n+        If a SELECT...FOR UPDATE NOWAIT is run on a database backend\n+        that supports FOR UPDATE but not NOWAIT, then we should find\n+        that a DatabaseError is raised.\n+        \"\"\"\n+        self.assertRaises(\n+            DatabaseError,\n+            list,\n+            Person.objects.all().select_for_update(nowait=True)\n+        )\n+\n+    def run_select_for_update(self, status, nowait=False):\n+        \"\"\"\n+        Utility method that runs a SELECT FOR UPDATE against all\n+        Person instances. After the select_for_update, it attempts\n+        to update the name of the only record, save, and commit.\n+\n+        In general, this will be run in a separate thread.\n+        \"\"\"\n+        status.append('started')\n+        try:\n+            # We need to enter transaction management again, as this is done on\n+            # per-thread basis\n+            transaction.enter_transaction_management(True)\n+            transaction.managed(True)\n+            people = list(\n+                Person.objects.all().select_for_update(nowait=nowait)\n+            )\n+            people[0].name = 'Fred'\n+            people[0].save()\n+            transaction.commit()\n+        except DatabaseError, e:\n+            status.append(e)\n+        except Exception, e:\n+            raise\n+\n+    @requires_threading\n+    @skipUnlessDBFeature('has_select_for_update')\n+    @skipUnlessDBFeature('supports_transactions')\n+    def test_block(self):\n+        \"\"\"\n+        Check that a thread running a select_for_update that\n+        accesses rows being touched by a similar operation\n+        on another connection blocks correctly.\n+        \"\"\"\n+        # First, let's start the transaction in our thread.\n+        self.start_blocking_transaction()\n+\n+        # Now, try it again using the ORM's select_for_update\n+        # facility. Do this in a separate thread.\n+        status = []\n+        thread = threading.Thread(\n+            target=self.run_select_for_update, args=(status,)\n+        )\n+\n+        # The thread should immediately block, but we'll sleep\n+        # for a bit to make sure.\n+        thread.start()\n+        sanity_count = 0\n+        while len(status) != 1 and sanity_count < 10:\n+            sanity_count += 1\n+            time.sleep(1)\n+        if sanity_count >= 10:\n+            raise ValueError, 'Thread did not run and block'\n+\n+        # Check the person hasn't been updated. Since this isn't\n+        # using FOR UPDATE, it won't block.\n+        p = Person.objects.get(pk=self.person.pk)\n+        self.assertEqual('Reinhardt', p.name)\n+\n+        # When we end our blocking transaction, our thread should\n+        # be able to continue.\n+        self.end_blocking_transaction()\n+        thread.join(5.0)\n+\n+        # Check the thread has finished. Assuming it has, we should\n+        # find that it has updated the person's name.\n+        self.failIf(thread.isAlive())\n+        p = Person.objects.get(pk=self.person.pk)\n+        self.assertEqual('Fred', p.name)\n+\n+    @requires_threading\n+    @skipUnlessDBFeature('has_select_for_update')\n+    def test_raw_lock_not_available(self):\n+        \"\"\"\n+        Check that running a raw query which can't obtain a FOR UPDATE lock\n+        raises the correct exception\n+        \"\"\"\n+        self.start_blocking_transaction()\n+        def raw(status):\n+            try:\n+                list(\n+                    Person.objects.raw(\n+                        'SELECT * FROM %s %s' % (\n+                            Person._meta.db_table,\n+                            connection.ops.for_update_sql(nowait=True)\n+                        )\n+                    )\n+                )\n+            except DatabaseError, e:\n+                status.append(e)\n+        status = []\n+        thread = threading.Thread(target=raw, kwargs={'status': status})\n+        thread.start()\n+        time.sleep(1)\n+        thread.join()\n+        self.end_blocking_transaction()\n+        self.check_exc(status[-1])\n+\n+    @skipUnlessDBFeature('has_select_for_update')\n+    def test_transaction_dirty_managed(self):\n+        \"\"\" Check that a select_for_update sets the transaction to be\n+        dirty when executed under txn management. Setting the txn dirty\n+        means that it will be either committed or rolled back by Django,\n+        which will release any locks held by the SELECT FOR UPDATE.\n+        \"\"\"\n+        people = list(Person.objects.select_for_update())\n+        self.assertTrue(transaction.is_dirty())\n+\n+    @skipUnlessDBFeature('has_select_for_update')\n+    def test_transaction_not_dirty_unmanaged(self):\n+        \"\"\" If we're not under txn management, the txn will never be\n+        marked as dirty.\n+        \"\"\"\n+        transaction.managed(False)\n+        transaction.leave_transaction_management()\n+        people = list(Person.objects.select_for_update())\n+        self.assertFalse(transaction.is_dirty())"
        }
    ],
    "stats": {
        "total": 375,
        "additions": 375,
        "deletions": 0
    }
}