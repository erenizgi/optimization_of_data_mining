{
    "author": "spookylukey",
    "message": "Removed deprecated CsrfResponseMiddleware, and corresponding tests and docs\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15949 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "8823021625785cbe8e9e2f4d6ff559fc4c8fa7c6",
    "files": [
        {
            "sha": "2f36f18e6c6809186769308f36eeb028129941d0",
            "filename": "django/middleware/csrf.py",
            "status": "modified",
            "additions": 0,
            "deletions": 91,
            "changes": 91,
            "blob_url": "https://github.com/django/django/blob/8823021625785cbe8e9e2f4d6ff559fc4c8fa7c6/django%2Fmiddleware%2Fcsrf.py",
            "raw_url": "https://github.com/django/django/raw/8823021625785cbe8e9e2f4d6ff559fc4c8fa7c6/django%2Fmiddleware%2Fcsrf.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fmiddleware%2Fcsrf.py?ref=8823021625785cbe8e9e2f4d6ff559fc4c8fa7c6",
            "patch": "@@ -6,7 +6,6 @@\n \"\"\"\n \n import hashlib\n-import itertools\n import re\n import random\n \n@@ -15,14 +14,8 @@\n from django.utils.cache import patch_vary_headers\n from django.utils.http import same_origin\n from django.utils.log import getLogger\n-from django.utils.safestring import mark_safe\n from django.utils.crypto import constant_time_compare\n \n-_POST_FORM_RE = \\\n-    re.compile(r'(<form\\W[^>]*\\bmethod\\s*=\\s*(\\'|\"|)POST(\\'|\"|)\\b[^>]*>)', re.IGNORECASE)\n-\n-_HTML_TYPES = ('text/html', 'application/xhtml+xml')\n-\n logger = getLogger('django.request')\n \n # Use the system (hardware-based) random number generator if it exists.\n@@ -49,10 +42,6 @@ def _get_new_csrf_key():\n     return hashlib.md5(\"%s%s\" % (randrange(0, _MAX_CSRF_KEY), settings.SECRET_KEY)).hexdigest()\n \n \n-def _make_legacy_session_token(session_id):\n-    return hashlib.md5(settings.SECRET_KEY + session_id).hexdigest()\n-\n-\n def get_token(request):\n     \"\"\"\n     Returns the the CSRF token required for a POST form. The token is an\n@@ -214,83 +203,3 @@ def process_response(self, request, response):\n         patch_vary_headers(response, ('Cookie',))\n         response.csrf_processing_done = True\n         return response\n-\n-\n-class CsrfResponseMiddleware(object):\n-    \"\"\"\n-    DEPRECATED\n-    Middleware that post-processes a response to add a csrfmiddlewaretoken.\n-\n-    This exists for backwards compatibility and as an interim measure until\n-    applications are converted to using use the csrf_token template tag\n-    instead. It will be removed in Django 1.4.\n-    \"\"\"\n-    def __init__(self):\n-        import warnings\n-        warnings.warn(\n-            \"CsrfResponseMiddleware and CsrfMiddleware are deprecated; use CsrfViewMiddleware and the template tag instead (see CSRF documentation).\",\n-            DeprecationWarning\n-        )\n-\n-    def process_response(self, request, response):\n-        if getattr(response, 'csrf_exempt', False):\n-            return response\n-\n-        if response['Content-Type'].split(';')[0] in _HTML_TYPES:\n-            csrf_token = get_token(request)\n-            # If csrf_token is None, we have no token for this request, which probably\n-            # means that this is a response from a request middleware.\n-            if csrf_token is None:\n-                return response\n-\n-            # ensure we don't add the 'id' attribute twice (HTML validity)\n-            idattributes = itertools.chain((\"id='csrfmiddlewaretoken'\",),\n-                                           itertools.repeat(''))\n-            def add_csrf_field(match):\n-                \"\"\"Returns the matched <form> tag plus the added <input> element\"\"\"\n-                return mark_safe(match.group() + \"<div style='display:none;'>\" + \\\n-                \"<input type='hidden' \" + idattributes.next() + \\\n-                \" name='csrfmiddlewaretoken' value='\" + csrf_token + \\\n-                \"' /></div>\")\n-\n-            # Modify any POST forms\n-            response.content, n = _POST_FORM_RE.subn(add_csrf_field, response.content)\n-            if n > 0:\n-                # Content varies with the CSRF cookie, so set the Vary header.\n-                patch_vary_headers(response, ('Cookie',))\n-\n-                # Since the content has been modified, any Etag will now be\n-                # incorrect.  We could recalculate, but only if we assume that\n-                # the Etag was set by CommonMiddleware. The safest thing is just\n-                # to delete. See bug #9163\n-                del response['ETag']\n-        return response\n-\n-\n-class CsrfMiddleware(object):\n-    \"\"\"\n-    Django middleware that adds protection against Cross Site\n-    Request Forgeries by adding hidden form fields to POST forms and\n-    checking requests for the correct value.\n-\n-    CsrfMiddleware uses two middleware, CsrfViewMiddleware and\n-    CsrfResponseMiddleware, which can be used independently.  It is recommended\n-    to use only CsrfViewMiddleware and use the csrf_token template tag in\n-    templates for inserting the token.\n-    \"\"\"\n-    # We can't just inherit from CsrfViewMiddleware and CsrfResponseMiddleware\n-    # because both have process_response methods.\n-    def __init__(self):\n-        self.response_middleware = CsrfResponseMiddleware()\n-        self.view_middleware = CsrfViewMiddleware()\n-\n-    def process_response(self, request, resp):\n-        # We must do the response post-processing first, because that calls\n-        # get_token(), which triggers a flag saying that the CSRF cookie needs\n-        # to be sent (done in CsrfViewMiddleware.process_response)\n-        resp2 = self.response_middleware.process_response(request, resp)\n-        return self.view_middleware.process_response(request, resp2)\n-\n-    def process_view(self, request, callback, callback_args, callback_kwargs):\n-        return self.view_middleware.process_view(request, callback, callback_args,\n-                                                 callback_kwargs)"
        },
        {
            "sha": "459a71ffe12d698993a0d5952d5d48830273af77",
            "filename": "docs/ref/contrib/csrf.txt",
            "status": "modified",
            "additions": 11,
            "deletions": 178,
            "changes": 189,
            "blob_url": "https://github.com/django/django/blob/8823021625785cbe8e9e2f4d6ff559fc4c8fa7c6/docs%2Fref%2Fcontrib%2Fcsrf.txt",
            "raw_url": "https://github.com/django/django/raw/8823021625785cbe8e9e2f4d6ff559fc4c8fa7c6/docs%2Fref%2Fcontrib%2Fcsrf.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fcontrib%2Fcsrf.txt?ref=8823021625785cbe8e9e2f4d6ff559fc4c8fa7c6",
            "patch": "@@ -17,28 +17,18 @@ The first defense against CSRF attacks is to ensure that GET requests are\n side-effect free.  POST requests can then be protected by following the steps\n below.\n \n-.. versionadded:: 1.2\n-    The 'contrib' apps, including the admin, use the functionality described\n-    here. Because it is security related, a few things have been added to core\n-    functionality to allow this to happen without any required upgrade steps.\n-\n .. _Cross Site Request Forgeries: http://www.squarefree.com/securitytips/web-developers.html#CSRF\n \n How to use it\n =============\n \n-.. versionchanged:: 1.2\n-    The template tag functionality (the recommended way to use this) was added\n-    in version 1.2. The previous method (still available) is described under\n-    `Legacy method`_.\n-\n To enable CSRF protection for your views, follow these steps:\n \n     1. Add the middleware\n        ``'django.middleware.csrf.CsrfViewMiddleware'`` to your list of\n        middleware classes, :setting:`MIDDLEWARE_CLASSES`.  (It should come\n-       before ``CsrfResponseMiddleware`` if that is being used, and before any\n-       view middleware that assume that CSRF attacks have been dealt with.)\n+       and before any view middleware that assume that CSRF attacks have\n+       been dealt with.)\n \n        Alternatively, you can use the decorator\n        ``django.views.decorators.csrf.csrf_protect`` on particular views you\n@@ -47,7 +37,7 @@ To enable CSRF protection for your views, follow these steps:\n     2. In any template that uses a POST form, use the :ttag:`csrf_token` tag inside\n        the ``<form>`` element if the form is for an internal URL, e.g.::\n \n-           <form action=\"\" method=\"post\">{% csrf_token %}\n+           <form action=\".\" method=\"post\">{% csrf_token %}\n \n        This should not be done for POST forms that target external URLs, since\n        that would cause the CSRF token to be leaked, leading to a vulnerability.\n@@ -78,8 +68,8 @@ To enable CSRF protection for your views, follow these steps:\n           takes care of this step for you.\n \n The utility script ``extras/csrf_migration_helper.py`` can help to automate the\n-finding of code and templates that may need to be upgraded.  It contains full\n-help on how to use it.\n+finding of code and templates that may need these steps. It contains full help\n+on how to use it.\n \n .. _csrf-ajax:\n \n@@ -146,145 +136,9 @@ Use of the decorator is **not recommended** by itself, since if you forget to\n use it, you will have a security hole.  The 'belt and braces' strategy of using\n both is fine, and will incur minimal overhead.\n \n-Legacy method\n--------------\n-\n-In Django 1.1, the template tag did not exist.  Instead, a post-processing\n-middleware that re-wrote POST forms to include the CSRF token was used.  If you\n-are upgrading a site from version 1.1 or earlier, please read this section and\n-the `Upgrading notes`_ below.  The post-processing middleware is still available\n-as ``CsrfResponseMiddleware``, and it can be used by following these steps:\n-\n-    1. Follow step 1 above to install ``CsrfViewMiddleware``.\n-\n-    2. Add ``'django.middleware.csrf.CsrfResponseMiddleware'`` to your\n-       :setting:`MIDDLEWARE_CLASSES` setting.\n-\n-       ``CsrfResponseMiddleware`` needs to process the response before things\n-       like compression or setting ofETags happen to the response, so it must\n-       come after ``GZipMiddleware``, ``CommonMiddleware`` and\n-       ``ConditionalGetMiddleware`` in the list. It also must come after\n-       ``CsrfViewMiddleware``.\n-\n-Use of the ``CsrfResponseMiddleware`` is not recommended because of the\n-performance hit it imposes, and because of a potential security problem (see\n-below).  It can be used as an interim measure until applications have been\n-updated to use the :ttag:`csrf_token` tag.  It is deprecated and will be\n-removed in Django 1.4.\n-\n-Django 1.1 and earlier provided a single ``CsrfMiddleware`` class.  This is also\n-still available for backwards compatibility.  It combines the functions of the\n-two middleware.\n-\n-Note also that previous versions of these classes depended on the sessions\n-framework, but this dependency has now been removed, with backward compatibility\n-support so that upgrading will not produce any issues.\n-\n-Security of legacy method\n-~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-The post-processing ``CsrfResponseMiddleware`` adds the CSRF token to all POST\n-forms (unless the view has been decorated with ``csrf_response_exempt``).  If\n-the POST form has an external untrusted site as its target, rather than an\n-internal page, that site will be sent the CSRF token when the form is submitted.\n-Armed with this leaked information, that site will then be able to successfully\n-launch a CSRF attack on your site against that user.  The\n-``@csrf_response_exempt`` decorator can be used to fix this, but only if the\n-page doesn't also contain internal forms that require the token.\n-\n-.. _ref-csrf-upgrading-notes:\n-\n-Upgrading notes\n----------------\n-\n-When upgrading to version 1.2 or later, you may have applications that rely on\n-the old post-processing functionality for CSRF protection, or you may not have\n-enabled any CSRF protection.  This section outlines the steps necessary for a\n-smooth upgrade, without having to fix all the applications to use the new\n-template tag method immediately.\n-\n-First of all, the location of the middleware and related functions have\n-changed.  There are backwards compatible stub files so that old imports will\n-continue to work for now, but they are deprecated and will be removed in Django\n-1.4.  The following changes have been made:\n-\n- * Middleware have been moved to ``django.middleware.csrf``\n- * Decorators have been moved to ``django.views.decorators.csrf``\n-\n-======================================================  ==============================================\n-   Old                                                       New\n-======================================================  ==============================================\n-django.contrib.csrf.middleware.CsrfMiddleware           django.middleware.csrf.CsrfMiddleware\n-django.contrib.csrf.middleware.CsrfViewMiddleware       django.middleware.csrf.CsrfViewMiddleware\n-django.contrib.csrf.middleware.CsrfResponseMiddleware   django.middleware.csrf.CsrfResponseMiddleware\n-django.contrib.csrf.middleware.csrf_exempt              django.views.decorators.csrf.csrf_exempt\n-django.contrib.csrf.middleware.csrf_view_exempt         django.views.decorators.csrf.csrf_view_exempt\n-django.contrib.csrf.middleware.csrf_response_exempt     django.views.decorators.csrf.csrf_response_exempt\n-======================================================  ==============================================\n-\n-You should update any imports, and also the paths in your\n-:setting:`MIDDLEWARE_CLASSES`.\n-\n-If you have ``CsrfMiddleware`` in your :setting:`MIDDLEWARE_CLASSES`, you will now\n-have a working installation with CSRF protection.  It is recommended at this\n-point that you replace ``CsrfMiddleware`` with its two components,\n-``CsrfViewMiddleware`` and ``CsrfResponseMiddleware`` (in that order).\n-\n-If you do not have any of the middleware in your :setting:`MIDDLEWARE_CLASSES`,\n-you will have a working installation but without any CSRF protection for your\n-views (just as you had before). It is strongly recommended to install\n-``CsrfViewMiddleware`` and ``CsrfResponseMiddleware``, as described above.\n-\n-Note that contrib apps, such as the admin, have been updated to use the\n-``csrf_protect`` decorator, so that they are secured even if you do not add the\n-``CsrfViewMiddleware`` to your settings.  However, if you have supplied\n-customised templates to any of the view functions of contrib apps (whether\n-explicitly via a keyword argument, or by overriding built-in templates), **you\n-MUST update them** to include the :ttag:`csrf_token` template tag as described\n-above, or they will stop working.  (If you cannot update these templates for\n-some reason, you will be forced to use ``CsrfResponseMiddleware`` for these\n-views to continue working).\n-\n-Note also, if you are using the comments app, and you are not going to add\n-``CsrfViewMiddleware`` to your settings (not recommended), you will need to add\n-the ``csrf_protect`` decorator to any views that include the comment forms and\n-target the comment views (usually using the :ttag:`comment_form_target` template\n-tag).\n-\n-Assuming you have followed the above, all views in your Django site will now be\n-protected by the ``CsrfViewMiddleware``.  Contrib apps meet the requirements\n-imposed by the ``CsrfViewMiddleware`` using the template tag, and other\n-applications in your project will meet its requirements by virtue of the\n-``CsrfResponseMiddleware``.\n-\n-The next step is to update all your applications to use the template tag, as\n-described in `How to use it`_, steps 2-3.  This can be done as soon as is\n-practical. Any applications that are updated will now require Django 1.1.2 or\n-later, since they will use the CSRF template tag which was not available in\n-earlier versions. (The template tag in 1.1.2 is actually a no-op that exists\n-solely to ease the transition to 1.2 â€” it allows apps to be created that have\n-CSRF protection under 1.2 without requiring users of the apps to upgrade to the\n-Django 1.2.X series).\n-\n-The utility script ``extras/csrf_migration_helper.py`` can help to automate the\n-finding of code and templates that may need to be upgraded.  It contains full\n-help on how to use it.\n-\n-Finally, once all applications are upgraded, ``CsrfResponseMiddleware`` can be\n-removed from your settings.\n-\n-While ``CsrfResponseMiddleware`` is still in use, the ``csrf_response_exempt``\n-decorator, described in `Exceptions`_, may be useful.  The post-processing\n-middleware imposes a performance hit and a potential vulnerability, and any\n-views that have been upgraded to use the new template tag method no longer need\n-it.\n-\n Exceptions\n ----------\n \n-.. versionchanged:: 1.2\n-    Import paths for the decorators below were changed.\n-\n To manually exclude a view function from being handled by either of the two CSRF\n middleware, you can use the ``csrf_exempt`` decorator, found in the\n ``django.views.decorators.csrf`` module. For example::\n@@ -295,13 +149,6 @@ middleware, you can use the ``csrf_exempt`` decorator, found in the\n     def my_view(request):\n         return HttpResponse('Hello world')\n \n-Like the middleware, the ``csrf_exempt`` decorator is composed of two parts: a\n-``csrf_view_exempt`` decorator and a ``csrf_response_exempt`` decorator, found\n-in the same module.  These disable the view protection mechanism\n-(``CsrfViewMiddleware``) and the response post-processing\n-(``CsrfResponseMiddleware``) respectively.  They can be used individually if\n-required.\n-\n Subdomains\n ----------\n \n@@ -350,8 +197,7 @@ The CSRF protection is based on the following things:\n    outgoing POST forms.  The value of this field is the value of the CSRF\n    cookie.\n \n-   This part is done by the template tag (and with the legacy method, it is done\n-   by ``CsrfResponseMiddleware``).\n+   This part is done by the template tag.\n \n 3. For all incoming POST requests, a CSRF cookie must be present, and the\n    'csrfmiddlewaretoken' field must be present and correct. If it isn't, the\n@@ -375,22 +221,16 @@ forms). GET requests ought never to have any potentially dangerous side effects\n (see `9.1.1 Safe Methods, HTTP 1.1, RFC 2616`_), and so a CSRF attack with a GET\n request ought to be harmless.\n \n-``CsrfResponseMiddleware`` checks the Content-Type before modifying the\n-response, and only pages that are served as 'text/html' or\n-'application/xml+xhtml' are modified.\n-\n .. _9.1.1 Safe Methods, HTTP 1.1, RFC 2616: http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\n \n Caching\n =======\n \n-If the :ttag:`csrf_token` template tag is used by a template (or the ``get_token``\n-function is called some other way), ``CsrfViewMiddleware`` will add a cookie and\n-a ``Vary: Cookie`` header to the response.  Similarly,\n-``CsrfResponseMiddleware`` will send the ``Vary: Cookie`` header if it inserted\n-a token.  This means that these middleware will play well with the cache\n-middleware if it is used as instructed (``UpdateCacheMiddleware`` goes before\n-all other middleware).\n+If the :ttag:`csrf_token` template tag is used by a template (or the\n+``get_token`` function is called some other way), ``CsrfViewMiddleware`` will\n+add a cookie and a ``Vary: Cookie`` header to the response. This means that the\n+middleware will play well with the cache middleware if it is used as instructed\n+(``UpdateCacheMiddleware`` goes before all other middleware).\n \n However, if you use cache decorators on individual views, the CSRF middleware\n will not yet have been able to set the Vary header.  In this case, on any views\n@@ -434,13 +274,6 @@ to set cookies).  Note that even without CSRF, there are other vulnerabilities,\n such as session fixation, that make giving subdomains to untrusted parties a bad\n idea, and these vulnerabilities cannot easily be fixed with current browsers.\n \n-If you are using ``CsrfResponseMiddleware`` and your app creates HTML pages and\n-forms in some unusual way, (e.g.  it sends fragments of HTML in JavaScript\n-document.write statements) you might bypass the filter that adds the hidden\n-field to the form, in which case form submission will always fail.  You should\n-use the template tag or :meth:`django.middleware.csrf.get_token` to get\n-the CSRF token and ensure it is included when your form is submitted.\n-\n Contrib and reusable apps\n =========================\n "
        },
        {
            "sha": "37a10044c4f2ae14866c064f0a1f729b09070c6d",
            "filename": "tests/regressiontests/csrf_tests/tests.py",
            "status": "modified",
            "additions": 11,
            "deletions": 100,
            "changes": 111,
            "blob_url": "https://github.com/django/django/blob/8823021625785cbe8e9e2f4d6ff559fc4c8fa7c6/tests%2Fregressiontests%2Fcsrf_tests%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/8823021625785cbe8e9e2f4d6ff559fc4c8fa7c6/tests%2Fregressiontests%2Fcsrf_tests%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fcsrf_tests%2Ftests.py?ref=8823021625785cbe8e9e2f4d6ff559fc4c8fa7c6",
            "patch": "@@ -3,7 +3,7 @@\n \n from django.test import TestCase\n from django.http import HttpRequest, HttpResponse\n-from django.middleware.csrf import CsrfMiddleware, CsrfViewMiddleware\n+from django.middleware.csrf import CsrfViewMiddleware\n from django.views.decorators.csrf import csrf_exempt, csrf_view_exempt, requires_csrf_token\n from django.core.context_processors import csrf\n from django.conf import settings\n@@ -16,11 +16,6 @@ def post_form_response():\n \"\"\", mimetype=\"text/html\")\n     return resp\n \n-def post_form_response_non_html():\n-    resp = post_form_response()\n-    resp[\"Content-Type\"] = \"application/xml\"\n-    return resp\n-\n def post_form_view(request):\n     \"\"\"A view that returns a POST form (without a token)\"\"\"\n     return post_form_response()\n@@ -54,7 +49,7 @@ class TestingHttpRequest(HttpRequest):\n     def is_secure(self):\n         return getattr(self, '_is_secure', False)\n \n-class CsrfMiddlewareTest(TestCase):\n+class CsrfViewMiddlewareTest(TestCase):\n     # The csrf token is potentially from an untrusted source, so could have\n     # characters that need dealing with.\n     _csrf_id_cookie = \"<1>\\xc2\\xa1\"\n@@ -94,58 +89,20 @@ def _get_POST_request_with_token(self):\n     def _check_token_present(self, response, csrf_id=None):\n         self.assertContains(response, \"name='csrfmiddlewaretoken' value='%s'\" % (csrf_id or self._csrf_id))\n \n-    # Check the post processing and outgoing cookie\n-    def test_process_response_no_csrf_cookie(self):\n-        \"\"\"\n-        When no prior CSRF cookie exists, check that the cookie is created and a\n-        token is inserted.\n-        \"\"\"\n-        req = self._get_GET_no_csrf_cookie_request()\n-        CsrfMiddleware().process_view(req, post_form_view, (), {})\n-\n-        resp = post_form_response()\n-        resp_content = resp.content # needed because process_response modifies resp\n-        resp2 = CsrfMiddleware().process_response(req, resp)\n-\n-        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, False)\n-        self.assertNotEqual(csrf_cookie, False)\n-        self.assertNotEqual(resp_content, resp2.content)\n-        self._check_token_present(resp2, csrf_cookie.value)\n-        # Check the Vary header got patched correctly\n-        self.assertTrue('Cookie' in resp2.get('Vary',''))\n-\n-    def test_process_response_for_exempt_view(self):\n+    def test_process_response_get_token_used(self):\n         \"\"\"\n-        Check that a view decorated with 'csrf_view_exempt' is still\n-        post-processed to add the CSRF token.\n+        When get_token is used, check that the cookie is created and headers\n+        patched.\n         \"\"\"\n         req = self._get_GET_no_csrf_cookie_request()\n-        CsrfMiddleware().process_view(req, csrf_view_exempt(post_form_view), (), {})\n-\n-        resp = post_form_response()\n-        resp_content = resp.content # needed because process_response modifies resp\n-        resp2 = CsrfMiddleware().process_response(req, resp)\n-\n-        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, False)\n-        self.assertNotEqual(csrf_cookie, False)\n-        self.assertNotEqual(resp_content, resp2.content)\n-        self._check_token_present(resp2, csrf_cookie.value)\n-\n-    def test_process_response_no_csrf_cookie_view_only_get_token_used(self):\n-        \"\"\"\n-        When no prior CSRF cookie exists, check that the cookie is created, even\n-        if only CsrfViewMiddleware is used.\n-        \"\"\"\n-        # This is checking that CsrfViewMiddleware has the cookie setting\n-        # code. Most of the other tests use CsrfMiddleware.\n-        req = self._get_GET_no_csrf_cookie_request()\n         # token_view calls get_token() indirectly\n         CsrfViewMiddleware().process_view(req, token_view, (), {})\n         resp = token_view(req)\n         resp2 = CsrfViewMiddleware().process_response(req, resp)\n \n         csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, False)\n         self.assertNotEqual(csrf_cookie, False)\n+        self.assertTrue('Cookie' in resp2.get('Vary',''))\n \n     def test_process_response_get_token_not_used(self):\n         \"\"\"\n@@ -167,51 +124,14 @@ def test_process_response_get_token_not_used(self):\n         csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, False)\n         self.assertEqual(csrf_cookie, False)\n \n-    def test_process_response_existing_csrf_cookie(self):\n-        \"\"\"\n-        Check that the token is inserted when a prior CSRF cookie exists\n-        \"\"\"\n-        req = self._get_GET_csrf_cookie_request()\n-        CsrfMiddleware().process_view(req, post_form_view, (), {})\n-\n-        resp = post_form_response()\n-        resp_content = resp.content # needed because process_response modifies resp\n-        resp2 = CsrfMiddleware().process_response(req, resp)\n-        self.assertNotEqual(resp_content, resp2.content)\n-        self._check_token_present(resp2)\n-\n-    def test_process_response_non_html(self):\n-        \"\"\"\n-        Check the the post-processor does nothing for content-types not in _HTML_TYPES.\n-        \"\"\"\n-        req = self._get_GET_no_csrf_cookie_request()\n-        CsrfMiddleware().process_view(req, post_form_view, (), {})\n-        resp = post_form_response_non_html()\n-        resp_content = resp.content # needed because process_response modifies resp\n-        resp2 = CsrfMiddleware().process_response(req, resp)\n-        self.assertEqual(resp_content, resp2.content)\n-\n-    def test_process_response_exempt_view(self):\n-        \"\"\"\n-        Check that no post processing is done for an exempt view\n-        \"\"\"\n-        req = self._get_GET_csrf_cookie_request()\n-        view = csrf_exempt(post_form_view)\n-        CsrfMiddleware().process_view(req, view, (), {})\n-\n-        resp = view(req)\n-        resp_content = resp.content\n-        resp2 = CsrfMiddleware().process_response(req, resp)\n-        self.assertEqual(resp_content, resp2.content)\n-\n     # Check the request processing\n     def test_process_request_no_csrf_cookie(self):\n         \"\"\"\n         Check that if no CSRF cookies is present, the middleware rejects the\n         incoming request.  This will stop login CSRF.\n         \"\"\"\n         req = self._get_POST_no_csrf_cookie_request()\n-        req2 = CsrfMiddleware().process_view(req, post_form_view, (), {})\n+        req2 = CsrfViewMiddleware().process_view(req, post_form_view, (), {})\n         self.assertEqual(403, req2.status_code)\n \n     def test_process_request_csrf_cookie_no_token(self):\n@@ -220,15 +140,15 @@ def test_process_request_csrf_cookie_no_token(self):\n         rejects the incoming request.\n         \"\"\"\n         req = self._get_POST_csrf_cookie_request()\n-        req2 = CsrfMiddleware().process_view(req, post_form_view, (), {})\n+        req2 = CsrfViewMiddleware().process_view(req, post_form_view, (), {})\n         self.assertEqual(403, req2.status_code)\n \n     def test_process_request_csrf_cookie_and_token(self):\n         \"\"\"\n         Check that if both a cookie and a token is present, the middleware lets it through.\n         \"\"\"\n         req = self._get_POST_request_with_token()\n-        req2 = CsrfMiddleware().process_view(req, post_form_view, (), {})\n+        req2 = CsrfViewMiddleware().process_view(req, post_form_view, (), {})\n         self.assertEqual(None, req2)\n \n     def test_process_request_csrf_cookie_no_token_exempt_view(self):\n@@ -237,7 +157,7 @@ def test_process_request_csrf_cookie_no_token_exempt_view(self):\n         decorator has been applied to the view, the middleware lets it through\n         \"\"\"\n         req = self._get_POST_csrf_cookie_request()\n-        req2 = CsrfMiddleware().process_view(req, csrf_exempt(post_form_view), (), {})\n+        req2 = CsrfViewMiddleware().process_view(req, csrf_exempt(post_form_view), (), {})\n         self.assertEqual(None, req2)\n \n     def test_csrf_token_in_header(self):\n@@ -246,7 +166,7 @@ def test_csrf_token_in_header(self):\n         \"\"\"\n         req = self._get_POST_csrf_cookie_request()\n         req.META['HTTP_X_CSRFTOKEN'] = self._csrf_id\n-        req2 = CsrfMiddleware().process_view(req, post_form_view, (), {})\n+        req2 = CsrfViewMiddleware().process_view(req, post_form_view, (), {})\n         self.assertEqual(None, req2)\n \n     # Tests for the template tag method\n@@ -307,15 +227,6 @@ def test_token_node_with_new_csrf_cookie(self):\n         csrf_cookie = resp2.cookies[settings.CSRF_COOKIE_NAME]\n         self._check_token_present(resp, csrf_id=csrf_cookie.value)\n \n-    def test_response_middleware_without_view_middleware(self):\n-        \"\"\"\n-        Check that CsrfResponseMiddleware finishes without error if the view middleware\n-        has not been called, as is the case if a request middleware returns a response.\n-        \"\"\"\n-        req = self._get_GET_no_csrf_cookie_request()\n-        resp = post_form_view(req)\n-        CsrfMiddleware().process_response(req, resp)\n-\n     def test_https_bad_referer(self):\n         \"\"\"\n         Test that a POST HTTPS request with a bad referer is rejected"
        }
    ],
    "stats": {
        "total": 391,
        "additions": 22,
        "deletions": 369
    }
}