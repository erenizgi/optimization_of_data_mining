{
    "author": "claudep",
    "message": "Fixed #18239 -- Subclassed HTMLParser only for selected Python versions\n\nOnly Python versions affected by http://bugs.python.org/issue670664\nshould patch HTMLParser.\nThanks RaphaÃ«l Hertzog for the initial patch (for 1.4).",
    "sha": "5c79dd586534bc88ce7dc81c2d781c772d28b121",
    "files": [
        {
            "sha": "d7311f253bbea4416f42f91da4fd947227310882",
            "filename": "django/utils/html_parser.py",
            "status": "modified",
            "additions": 100,
            "deletions": 88,
            "changes": 188,
            "blob_url": "https://github.com/django/django/blob/5c79dd586534bc88ce7dc81c2d781c772d28b121/django%2Futils%2Fhtml_parser.py",
            "raw_url": "https://github.com/django/django/raw/5c79dd586534bc88ce7dc81c2d781c772d28b121/django%2Futils%2Fhtml_parser.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fhtml_parser.py?ref=5c79dd586534bc88ce7dc81c2d781c772d28b121",
            "patch": "@@ -1,102 +1,114 @@\n from django.utils.six.moves import html_parser as _html_parser\n import re\n+import sys\n \n-tagfind = re.compile('([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\\s|/(?!>))*')\n+current_version = sys.version_info\n+\n+use_workaround = (\n+    (current_version < (2, 6, 8)) or\n+    (current_version >= (2, 7) and current_version < (2, 7, 3)) or\n+    (current_version >= (3, 0) and current_version < (3, 2, 3))\n+)\n \n HTMLParseError = _html_parser.HTMLParseError\n \n-class HTMLParser(_html_parser.HTMLParser):\n-    \"\"\"\n-    Patched version of stdlib's HTMLParser with patch from:\n-    http://bugs.python.org/issue670664\n-    \"\"\"\n-    def __init__(self):\n-        _html_parser.HTMLParser.__init__(self)\n-        self.cdata_tag = None\n+if not use_workaround:\n+    HTMLParser = _html_parser.HTMLParser\n+else:\n+    tagfind = re.compile('([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\\s|/(?!>))*')\n \n-    def set_cdata_mode(self, tag):\n-        try:\n-            self.interesting = _html_parser.interesting_cdata\n-        except AttributeError:\n-            self.interesting = re.compile(r'</\\s*%s\\s*>' % tag.lower(), re.I)\n-        self.cdata_tag = tag.lower()\n+    class HTMLParser(_html_parser.HTMLParser):\n+        \"\"\"\n+        Patched version of stdlib's HTMLParser with patch from:\n+        http://bugs.python.org/issue670664\n+        \"\"\"\n+        def __init__(self):\n+            _html_parser.HTMLParser.__init__(self)\n+            self.cdata_tag = None\n \n-    def clear_cdata_mode(self):\n-        self.interesting = _html_parser.interesting_normal\n-        self.cdata_tag = None\n+        def set_cdata_mode(self, tag):\n+            try:\n+                self.interesting = _html_parser.interesting_cdata\n+            except AttributeError:\n+                self.interesting = re.compile(r'</\\s*%s\\s*>' % tag.lower(), re.I)\n+            self.cdata_tag = tag.lower()\n \n-    # Internal -- handle starttag, return end or -1 if not terminated\n-    def parse_starttag(self, i):\n-        self.__starttag_text = None\n-        endpos = self.check_for_whole_start_tag(i)\n-        if endpos < 0:\n-            return endpos\n-        rawdata = self.rawdata\n-        self.__starttag_text = rawdata[i:endpos]\n+        def clear_cdata_mode(self):\n+            self.interesting = _html_parser.interesting_normal\n+            self.cdata_tag = None\n \n-        # Now parse the data between i+1 and j into a tag and attrs\n-        attrs = []\n-        match = tagfind.match(rawdata, i + 1)\n-        assert match, 'unexpected call to parse_starttag()'\n-        k = match.end()\n-        self.lasttag = tag = match.group(1).lower()\n+        # Internal -- handle starttag, return end or -1 if not terminated\n+        def parse_starttag(self, i):\n+            self.__starttag_text = None\n+            endpos = self.check_for_whole_start_tag(i)\n+            if endpos < 0:\n+                return endpos\n+            rawdata = self.rawdata\n+            self.__starttag_text = rawdata[i:endpos]\n \n-        while k < endpos:\n-            m = _html_parser.attrfind.match(rawdata, k)\n-            if not m:\n-                break\n-            attrname, rest, attrvalue = m.group(1, 2, 3)\n-            if not rest:\n-                attrvalue = None\n-            elif attrvalue[:1] == '\\'' == attrvalue[-1:] or \\\n-                 attrvalue[:1] == '\"' == attrvalue[-1:]:\n-                attrvalue = attrvalue[1:-1]\n-            if attrvalue:\n-                attrvalue = self.unescape(attrvalue)\n-            attrs.append((attrname.lower(), attrvalue))\n-            k = m.end()\n+            # Now parse the data between i+1 and j into a tag and attrs\n+            attrs = []\n+            match = tagfind.match(rawdata, i + 1)\n+            assert match, 'unexpected call to parse_starttag()'\n+            k = match.end()\n+            self.lasttag = tag = match.group(1).lower()\n \n-        end = rawdata[k:endpos].strip()\n-        if end not in (\">\", \"/>\"):\n-            lineno, offset = self.getpos()\n-            if \"\\n\" in self.__starttag_text:\n-                lineno = lineno + self.__starttag_text.count(\"\\n\")\n-                offset = len(self.__starttag_text) \\\n-                         - self.__starttag_text.rfind(\"\\n\")\n+            while k < endpos:\n+                m = _html_parser.attrfind.match(rawdata, k)\n+                if not m:\n+                    break\n+                attrname, rest, attrvalue = m.group(1, 2, 3)\n+                if not rest:\n+                    attrvalue = None\n+                elif attrvalue[:1] == '\\'' == attrvalue[-1:] or \\\n+                     attrvalue[:1] == '\"' == attrvalue[-1:]:\n+                    attrvalue = attrvalue[1:-1]\n+                if attrvalue:\n+                    attrvalue = self.unescape(attrvalue)\n+                attrs.append((attrname.lower(), attrvalue))\n+                k = m.end()\n+\n+            end = rawdata[k:endpos].strip()\n+            if end not in (\">\", \"/>\"):\n+                lineno, offset = self.getpos()\n+                if \"\\n\" in self.__starttag_text:\n+                    lineno = lineno + self.__starttag_text.count(\"\\n\")\n+                    offset = len(self.__starttag_text) \\\n+                             - self.__starttag_text.rfind(\"\\n\")\n+                else:\n+                    offset = offset + len(self.__starttag_text)\n+                self.error(\"junk characters in start tag: %r\"\n+                           % (rawdata[k:endpos][:20],))\n+            if end.endswith('/>'):\n+                # XHTML-style empty tag: <span attr=\"value\" />\n+                self.handle_startendtag(tag, attrs)\n             else:\n-                offset = offset + len(self.__starttag_text)\n-            self.error(\"junk characters in start tag: %r\"\n-                       % (rawdata[k:endpos][:20],))\n-        if end.endswith('/>'):\n-            # XHTML-style empty tag: <span attr=\"value\" />\n-            self.handle_startendtag(tag, attrs)\n-        else:\n-            self.handle_starttag(tag, attrs)\n-            if tag in self.CDATA_CONTENT_ELEMENTS:\n-                self.set_cdata_mode(tag) # <--------------------------- Changed\n-        return endpos\n+                self.handle_starttag(tag, attrs)\n+                if tag in self.CDATA_CONTENT_ELEMENTS:\n+                    self.set_cdata_mode(tag) # <--------------------------- Changed\n+            return endpos\n \n-    # Internal -- parse endtag, return end or -1 if incomplete\n-    def parse_endtag(self, i):\n-        rawdata = self.rawdata\n-        assert rawdata[i:i + 2] == \"</\", \"unexpected call to parse_endtag\"\n-        match = _html_parser.endendtag.search(rawdata, i + 1) # >\n-        if not match:\n-            return -1\n-        j = match.end()\n-        match = _html_parser.endtagfind.match(rawdata, i) # </ + tag + >\n-        if not match:\n-            if self.cdata_tag is not None: # *** add ***\n-                self.handle_data(rawdata[i:j]) # *** add ***\n-                return j # *** add ***\n-            self.error(\"bad end tag: %r\" % (rawdata[i:j],))\n-        # --- changed start ---------------------------------------------------\n-        tag = match.group(1).strip()\n-        if self.cdata_tag is not None:\n-            if tag.lower() != self.cdata_tag:\n-                self.handle_data(rawdata[i:j])\n-                return j\n-        # --- changed end -----------------------------------------------------\n-        self.handle_endtag(tag.lower())\n-        self.clear_cdata_mode()\n-        return j\n+        # Internal -- parse endtag, return end or -1 if incomplete\n+        def parse_endtag(self, i):\n+            rawdata = self.rawdata\n+            assert rawdata[i:i + 2] == \"</\", \"unexpected call to parse_endtag\"\n+            match = _html_parser.endendtag.search(rawdata, i + 1) # >\n+            if not match:\n+                return -1\n+            j = match.end()\n+            match = _html_parser.endtagfind.match(rawdata, i) # </ + tag + >\n+            if not match:\n+                if self.cdata_tag is not None: # *** add ***\n+                    self.handle_data(rawdata[i:j]) # *** add ***\n+                    return j # *** add ***\n+                self.error(\"bad end tag: %r\" % (rawdata[i:j],))\n+            # --- changed start ---------------------------------------------------\n+            tag = match.group(1).strip()\n+            if self.cdata_tag is not None:\n+                if tag.lower() != self.cdata_tag:\n+                    self.handle_data(rawdata[i:j])\n+                    return j\n+            # --- changed end -----------------------------------------------------\n+            self.handle_endtag(tag.lower())\n+            self.clear_cdata_mode()\n+            return j"
        }
    ],
    "stats": {
        "total": 188,
        "additions": 100,
        "deletions": 88
    }
}