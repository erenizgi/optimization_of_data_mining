{
    "author": "ramiro",
    "message": "Added support for modifying the effect of ``DISTINCT`` clauses so they\nonly consider some fields (PostgreSQL only).\n\nFor this, the ``distinct()`` QuerySet method now accepts an optional\nlist of model fields names and generates ``DISTINCT ON`` clauses on\nthese cases. Thanks Jeffrey Gelens and Anssi Kääriäinen for their work.\n\nFixes #6422.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17244 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "287565779d3ae4d3229ecbb2ff356c79b920e7d0",
    "files": [
        {
            "sha": "1320225e68b3f218d1db72ffe856a0501445407b",
            "filename": "AUTHORS",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/AUTHORS",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/AUTHORS",
            "contents_url": "https://api.github.com/repos/django/django/contents/AUTHORS?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -203,6 +203,7 @@ answer newbie questions, and generally made Django that much better:\n     Marc Garcia <marc.garcia@accopensys.com>\n     Andy Gayton <andy-django@thecablelounge.com>\n     geber@datacollect.com\n+    Jeffrey Gelens <jeffrey@gelens.org>\n     Baishampayan Ghose\n     Joshua Ginsberg <jag@flowtheory.net>\n     Dimitris Glezos <dimitris@glezos.com>\n@@ -269,6 +270,7 @@ answer newbie questions, and generally made Django that much better:\n     jpellerin@gmail.com\n     junzhang.jn@gmail.com\n     Xia Kai <http://blog.xiaket.org/>\n+    Anssi Kääriäinen\n     Antti Kaihola <http://djangopeople.net/akaihola/>\n     Peter van Kampen\n     Bahadır Kandemir <bahadir@pardus.org.tr>"
        },
        {
            "sha": "ebe8875e42eb916b192881d93ea064e5e9e092cf",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -406,6 +406,9 @@ class BaseDatabaseFeatures(object):\n     supports_stddev = None\n     can_introspect_foreign_keys = None\n \n+    # Support for the DISTINCT ON clause\n+    can_distinct_on_fields = False\n+\n     def __init__(self, connection):\n         self.connection = connection\n \n@@ -559,6 +562,17 @@ def fulltext_search_sql(self, field_name):\n         \"\"\"\n         raise NotImplementedError('Full-text search is not implemented for this database backend')\n \n+    def distinct_sql(self, fields):\n+        \"\"\"\n+        Returns an SQL DISTINCT clause which removes duplicate rows from the\n+        result set. If any fields are given, only the given fields are being\n+        checked for duplicates.\n+        \"\"\"\n+        if fields:\n+            raise NotImplementedError('DISTINCT ON fields is not supported by this database backend')\n+        else:\n+            return 'DISTINCT'\n+\n     def last_executed_query(self, cursor, sql, params):\n         \"\"\"\n         Returns a string of the query last executed by the given cursor, with"
        },
        {
            "sha": "802ebf2b80ff8cd7da469afa79d00727bf172637",
            "filename": "django/db/backends/postgresql_psycopg2/base.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -82,6 +82,7 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     has_select_for_update_nowait = True\n     has_bulk_insert = True\n     supports_tablespaces = True\n+    can_distinct_on_fields = True\n \n class DatabaseWrapper(BaseDatabaseWrapper):\n     vendor = 'postgresql'"
        },
        {
            "sha": "949a05c0b609a08a86ac374e2fa48091338475fa",
            "filename": "django/db/backends/postgresql_psycopg2/operations.py",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Foperations.py",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Foperations.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Foperations.py?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -179,6 +179,12 @@ def max_name_length(self):\n \n         return 63\n \n+    def distinct_sql(self, fields):\n+        if fields:\n+            return 'DISTINCT ON (%s)' % ', '.join(fields)\n+        else:\n+            return 'DISTINCT'\n+\n     def last_executed_query(self, cursor, sql, params):\n         # http://initd.org/psycopg/docs/cursor.html#cursor.query\n         # The query attribute is a Psycopg extension to the DB API 2.0."
        },
        {
            "sha": "fd531dd6d0fd5244588e0c2178b1e40f16c9066c",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -323,6 +323,8 @@ def aggregate(self, *args, **kwargs):\n         If args is present the expression is passed as a kwarg using\n         the Aggregate object's default alias.\n         \"\"\"\n+        if self.query.distinct_fields:\n+            raise NotImplementedError(\"aggregate() + distinct(fields) not implemented.\")\n         for arg in args:\n             kwargs[arg.default_alias] = arg\n \n@@ -751,12 +753,14 @@ def order_by(self, *field_names):\n         obj.query.add_ordering(*field_names)\n         return obj\n \n-    def distinct(self, true_or_false=True):\n+    def distinct(self, *field_names):\n         \"\"\"\n         Returns a new QuerySet instance that will select only distinct results.\n         \"\"\"\n+        assert self.query.can_filter(), \\\n+                \"Cannot create distinct fields once a slice has been taken.\"\n         obj = self._clone()\n-        obj.query.distinct = true_or_false\n+        obj.query.add_distinct_fields(*field_names)\n         return obj\n \n     def extra(self, select=None, where=None, params=None, tables=None,\n@@ -1179,7 +1183,7 @@ def order_by(self, *field_names):\n         \"\"\"\n         return self\n \n-    def distinct(self, true_or_false=True):\n+    def distinct(self, fields=None):\n         \"\"\"\n         Always returns EmptyQuerySet.\n         \"\"\""
        },
        {
            "sha": "b6047febae16c8fa6c1aedec8f0a2aec04b9b755",
            "filename": "django/db/models/sql/compiler.py",
            "status": "modified",
            "additions": 85,
            "deletions": 24,
            "changes": 109,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -23,6 +23,8 @@ def pre_sql_setup(self):\n         Does any necessary class setup immediately prior to producing SQL. This\n         is for things that can't necessarily be done in __init__ because we\n         might not have all the pieces in place at that time.\n+        # TODO: after the query has been executed, the altered state should be\n+        # cleaned. We are not using a clone() of the query here.\n         \"\"\"\n         if not self.query.tables:\n             self.query.join((None, self.query.model._meta.db_table, None, None))\n@@ -60,11 +62,19 @@ def as_sql(self, with_limits=True, with_col_aliases=False):\n             return '', ()\n \n         self.pre_sql_setup()\n+        # After executing the query, we must get rid of any joins the query\n+        # setup created. So, take note of alias counts before the query ran.\n+        # However we do not want to get rid of stuff done in pre_sql_setup(),\n+        # as the pre_sql_setup will modify query state in a way that forbids\n+        # another run of it.\n+        self.refcounts_before = self.query.alias_refcount.copy()\n         out_cols = self.get_columns(with_col_aliases)\n         ordering, ordering_group_by = self.get_ordering()\n \n-        # This must come after 'select' and 'ordering' -- see docstring of\n-        # get_from_clause() for details.\n+        distinct_fields = self.get_distinct()\n+\n+        # This must come after 'select', 'ordering' and 'distinct' -- see\n+        # docstring of get_from_clause() for details.\n         from_, f_params = self.get_from_clause()\n \n         qn = self.quote_name_unless_alias\n@@ -76,8 +86,10 @@ def as_sql(self, with_limits=True, with_col_aliases=False):\n             params.extend(val[1])\n \n         result = ['SELECT']\n+\n         if self.query.distinct:\n-            result.append('DISTINCT')\n+            result.append(self.connection.ops.distinct_sql(distinct_fields))\n+\n         result.append(', '.join(out_cols + self.query.ordering_aliases))\n \n         result.append('FROM')\n@@ -90,6 +102,9 @@ def as_sql(self, with_limits=True, with_col_aliases=False):\n \n         grouping, gb_params = self.get_grouping()\n         if grouping:\n+            if distinct_fields:\n+                raise NotImplementedError(\n+                    \"annotate() + distinct(fields) not implemented.\")\n             if ordering:\n                 # If the backend can't group by PK (i.e., any database\n                 # other than MySQL), then any fields mentioned in the\n@@ -129,6 +144,9 @@ def as_sql(self, with_limits=True, with_col_aliases=False):\n                 raise DatabaseError('NOWAIT is not supported on this database backend.')\n             result.append(self.connection.ops.for_update_sql(nowait=nowait))\n \n+        # Finally do cleanup - get rid of the joins we created above.\n+        self.query.reset_refcounts(self.refcounts_before)\n+\n         return ' '.join(result), tuple(params)\n \n     def as_nested_sql(self):\n@@ -292,6 +310,26 @@ def get_default_columns(self, with_aliases=False, col_aliases=None,\n                     col_aliases.add(field.column)\n         return result, aliases\n \n+    def get_distinct(self):\n+        \"\"\"\n+        Returns a quoted list of fields to use in DISTINCT ON part of the query.\n+\n+        Note that this method can alter the tables in the query, and thus it\n+        must be called before get_from_clause().\n+        \"\"\"\n+        qn = self.quote_name_unless_alias\n+        qn2 = self.connection.ops.quote_name\n+        result = []\n+        opts = self.query.model._meta\n+\n+        for name in self.query.distinct_fields:\n+            parts = name.split(LOOKUP_SEP)\n+            field, col, alias, _, _ = self._setup_joins(parts, opts, None)\n+            col, alias = self._final_join_removal(col, alias)\n+            result.append(\"%s.%s\" % (qn(alias), qn2(col)))\n+        return result\n+\n+\n     def get_ordering(self):\n         \"\"\"\n         Returns a tuple containing a list representing the SQL elements in the\n@@ -384,21 +422,7 @@ def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n         \"\"\"\n         name, order = get_order_dir(name, default_order)\n         pieces = name.split(LOOKUP_SEP)\n-        if not alias:\n-            alias = self.query.get_initial_alias()\n-        field, target, opts, joins, last, extra = self.query.setup_joins(pieces,\n-                opts, alias, False)\n-        alias = joins[-1]\n-        col = target.column\n-        if not field.rel:\n-            # To avoid inadvertent trimming of a necessary alias, use the\n-            # refcount to show that we are referencing a non-relation field on\n-            # the model.\n-            self.query.ref_alias(alias)\n-\n-        # Must use left outer joins for nullable fields and their relations.\n-        self.query.promote_alias_chain(joins,\n-            self.query.alias_map[joins[0]][JOIN_TYPE] == self.query.LOUTER)\n+        field, col, alias, joins, opts = self._setup_joins(pieces, opts, alias)\n \n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model.\n@@ -416,19 +440,55 @@ def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                 results.extend(self.find_ordering_name(item, opts, alias,\n                         order, already_seen))\n             return results\n+        col, alias = self._final_join_removal(col, alias)\n+        return [(alias, col, order)]\n+\n+    def _setup_joins(self, pieces, opts, alias):\n+        \"\"\"\n+        A helper method for get_ordering and get_distinct. This method will\n+        call query.setup_joins, handle refcounts and then promote the joins.\n+\n+        Note that get_ordering and get_distinct must produce same target\n+        columns on same input, as the prefixes of get_ordering and get_distinct\n+        must match. Executing SQL where this is not true is an error.\n+        \"\"\"\n+        if not alias:\n+            alias = self.query.get_initial_alias()\n+        field, target, opts, joins, _, _ = self.query.setup_joins(pieces,\n+                opts, alias, False)\n+        alias = joins[-1]\n+        col = target.column\n+        if not field.rel:\n+            # To avoid inadvertent trimming of a necessary alias, use the\n+            # refcount to show that we are referencing a non-relation field on\n+            # the model.\n+            self.query.ref_alias(alias)\n \n+        # Must use left outer joins for nullable fields and their relations.\n+        # Ordering or distinct must not affect the returned set, and INNER\n+        # JOINS for nullable fields could do this.\n+        self.query.promote_alias_chain(joins,\n+            self.query.alias_map[joins[0]][JOIN_TYPE] == self.query.LOUTER)\n+        return field, col, alias, joins, opts\n+\n+    def _final_join_removal(self, col, alias):\n+        \"\"\"\n+        A helper method for get_distinct and get_ordering. This method will\n+        trim extra not-needed joins from the tail of the join chain.\n+\n+        This is very similar to what is done in trim_joins, but we will\n+        trim LEFT JOINS here. It would be a good idea to consolidate this\n+        method and query.trim_joins().\n+        \"\"\"\n         if alias:\n-            # We have to do the same \"final join\" optimisation as in\n-            # add_filter, since the final column might not otherwise be part of\n-            # the select set (so we can't order on it).\n             while 1:\n                 join = self.query.alias_map[alias]\n                 if col != join[RHS_JOIN_COL]:\n                     break\n                 self.query.unref_alias(alias)\n                 alias = join[LHS_ALIAS]\n                 col = join[LHS_JOIN_COL]\n-        return [(alias, col, order)]\n+        return col, alias\n \n     def get_from_clause(self):\n         \"\"\"\n@@ -438,8 +498,8 @@ def get_from_clause(self):\n         from-clause via a \"select\".\n \n         This should only be called after any SQL construction methods that\n-        might change the tables we need. This means the select columns and\n-        ordering must be done first.\n+        might change the tables we need. This means the select columns,\n+        ordering and distinct must be done first.\n         \"\"\"\n         result = []\n         qn = self.quote_name_unless_alias\n@@ -984,6 +1044,7 @@ def as_sql(self, qn=None):\n         \"\"\"\n         if qn is None:\n             qn = self.quote_name_unless_alias\n+\n         sql = ('SELECT %s FROM (%s) subquery' % (\n             ', '.join([\n                 aggregate.as_sql(qn, self.connection)"
        },
        {
            "sha": "ed2bc06d4fb5a09a37a3bdc9b04e189f328b2fff",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 26,
            "deletions": 4,
            "changes": 30,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -127,6 +127,7 @@ def __init__(self, model, where=WhereNode):\n         self.order_by = []\n         self.low_mark, self.high_mark = 0, None  # Used for offset/limit\n         self.distinct = False\n+        self.distinct_fields = []\n         self.select_for_update = False\n         self.select_for_update_nowait = False\n         self.select_related = False\n@@ -265,6 +266,7 @@ def clone(self, klass=None, memo=None, **kwargs):\n         obj.order_by = self.order_by[:]\n         obj.low_mark, obj.high_mark = self.low_mark, self.high_mark\n         obj.distinct = self.distinct\n+        obj.distinct_fields = self.distinct_fields[:]\n         obj.select_for_update = self.select_for_update\n         obj.select_for_update_nowait = self.select_for_update_nowait\n         obj.select_related = self.select_related\n@@ -298,6 +300,7 @@ def clone(self, klass=None, memo=None, **kwargs):\n         else:\n             obj.used_aliases = set()\n         obj.filter_is_sticky = False\n+\n         obj.__dict__.update(kwargs)\n         if hasattr(obj, '_setup_query'):\n             obj._setup_query()\n@@ -393,7 +396,7 @@ def get_count(self, using):\n         Performs a COUNT() query using the current filter constraints.\n         \"\"\"\n         obj = self.clone()\n-        if len(self.select) > 1 or self.aggregate_select:\n+        if len(self.select) > 1 or self.aggregate_select or (self.distinct and self.distinct_fields):\n             # If a select clause exists, then the query has already started to\n             # specify the columns that are to be returned.\n             # In this case, we need to use a subquery to evaluate the count.\n@@ -452,6 +455,8 @@ def combine(self, rhs, connector):\n                 \"Cannot combine queries once a slice has been taken.\"\n         assert self.distinct == rhs.distinct, \\\n             \"Cannot combine a unique query with a non-unique query.\"\n+        assert self.distinct_fields == rhs.distinct_fields, \\\n+            \"Cannot combine queries with different distinct fields.\"\n \n         self.remove_inherited_models()\n         # Work out how to relabel the rhs aliases, if necessary.\n@@ -674,9 +679,9 @@ def ref_alias(self, alias):\n         \"\"\" Increases the reference count for this alias. \"\"\"\n         self.alias_refcount[alias] += 1\n \n-    def unref_alias(self, alias):\n+    def unref_alias(self, alias, amount=1):\n         \"\"\" Decreases the reference count for this alias. \"\"\"\n-        self.alias_refcount[alias] -= 1\n+        self.alias_refcount[alias] -= amount\n \n     def promote_alias(self, alias, unconditional=False):\n         \"\"\"\n@@ -705,6 +710,15 @@ def promote_alias_chain(self, chain, must_promote=False):\n             if self.promote_alias(alias, must_promote):\n                 must_promote = True\n \n+    def reset_refcounts(self, to_counts):\n+        \"\"\"\n+        This method will reset reference counts for aliases so that they match\n+        the value passed in :param to_counts:.\n+        \"\"\"\n+        for alias, cur_refcount in self.alias_refcount.copy().items():\n+            unref_amount = cur_refcount - to_counts.get(alias, 0)\n+            self.unref_alias(alias, unref_amount)\n+\n     def promote_unused_aliases(self, initial_refcounts, used_aliases):\n         \"\"\"\n         Given a \"before\" copy of the alias_refcounts dictionary (as\n@@ -832,7 +846,8 @@ def get_initial_alias(self):\n     def count_active_tables(self):\n         \"\"\"\n         Returns the number of tables in this query with a non-zero reference\n-        count.\n+        count. Note that after execution, the reference counts are zeroed, so\n+        tables added in compiler will not be seen by this method.\n         \"\"\"\n         return len([1 for count in self.alias_refcount.itervalues() if count])\n \n@@ -1596,6 +1611,13 @@ def clear_select_fields(self):\n         self.select = []\n         self.select_fields = []\n \n+    def add_distinct_fields(self, *field_names):\n+        \"\"\"\n+        Adds and resolves the given fields to the query's \"distinct on\" clause.\n+        \"\"\"\n+        self.distinct_fields = field_names\n+        self.distinct = True\n+\n     def add_fields(self, field_names, allow_m2m=True):\n         \"\"\"\n         Adds the given (model) fields to the select set. The field names are"
        },
        {
            "sha": "b7bc647981f0b78e41a8c875a25ee76f666b6bdc",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 38,
            "deletions": 1,
            "changes": 39,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -345,7 +345,7 @@ remain undefined afterward).\n distinct\n ~~~~~~~~\n \n-.. method:: distinct()\n+.. method:: distinct([*fields])\n \n Returns a new ``QuerySet`` that uses ``SELECT DISTINCT`` in its SQL query. This\n eliminates duplicate rows from the query results.\n@@ -374,6 +374,43 @@ query spans multiple tables, it's possible to get duplicate results when a\n     :meth:`values()` together, be careful when ordering by fields not in the\n     :meth:`values()` call.\n \n+.. versionadded:: 1.4\n+\n+The possibility to pass positional arguments (``*fields``) is new in Django 1.4.\n+They are names of fields to which the ``DISTINCT`` should be limited. This\n+translates to a ``SELECT DISTINCT ON`` SQL query. A ``DISTINCT ON`` query eliminates\n+duplicate rows not by comparing all fields in a row, but by comparing only the given\n+fields.\n+\n+.. note::\n+    Note that the ability to specify field names is only available in PostgreSQL.\n+\n+.. note::\n+    When using the ``DISTINCT ON`` functionality it is required that the columns given\n+    to :meth:`distinct` match the first :meth:`order_by` columns. For example ``SELECT\n+    DISTINCT ON (a)`` gives you the first row for each value in column ``a``. If you\n+    don't specify an order, then you'll get some arbitrary row.\n+\n+Examples::\n+\n+    >>> Author.objects.distinct()\n+    [...]\n+\n+    >>> Entry.objects.order_by('pub_date').distinct('pub_date')\n+    [...]\n+\n+    >>> Entry.objects.order_by('blog').distinct('blog')\n+    [...]\n+\n+    >>> Entry.objects.order_by('author', 'pub_date').distinct('author', 'pub_date')\n+    [...]\n+\n+    >>> Entry.objects.order_by('blog__name', 'mod_date').distinct('blog__name', 'mod_date')\n+    [...]\n+\n+    >>> Entry.objects.order_by('author', 'pub_date').distinct('author')\n+    [...]\n+\n values\n ~~~~~~\n "
        },
        {
            "sha": "8050ca91f6b90b0253f5caef8e439594072355b0",
            "filename": "docs/releases/1.4-alpha-1.txt",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/docs%2Freleases%2F1.4-alpha-1.txt",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/docs%2Freleases%2F1.4-alpha-1.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.4-alpha-1.txt?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -507,6 +507,16 @@ Django 1.4 also includes several smaller improvements worth noting:\n   ``pickle.HIGHEST_PROTOCOL`` for better compatibility with the other\n   cache backends.\n \n+* Support in the ORM for generating ``SELECT`` queries containing ``DISTINCT ON``\n+\n+  The ``distinct()`` ``Queryset`` method now accepts an optional list of model\n+  field names. If specified, then the ``DISTINCT`` statement is limited to these\n+  fields.  The PostgreSQL is the only of the database backends shipped with\n+  Django that supports this new functionality.\n+\n+  For more details, see the documentation for\n+  :meth:`~django.db.models.query.QuerySet.distinct`.\n+\n Backwards incompatible changes in 1.4\n =====================================\n "
        },
        {
            "sha": "4c1caee309ffdedc71383acd1b6fd041383f0b8d",
            "filename": "docs/releases/1.4.txt",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/docs%2Freleases%2F1.4.txt",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/docs%2Freleases%2F1.4.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.4.txt?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -498,6 +498,16 @@ Django 1.4 also includes several smaller improvements worth noting:\n   ``pickle.HIGHEST_PROTOCOL`` for better compatibility with the other\n   cache backends.\n \n+* Support in the ORM for generating ``SELECT`` queries containing ``DISTINCT ON``\n+\n+  The ``distinct()`` ``Queryset`` method now accepts an optional list of model\n+  field names. If specified, then the ``DISTINCT`` statement is limited to these\n+  fields.  The PostgreSQL is the only of the database backends shipped with\n+  Django that supports this new functionality.\n+\n+  For more details, see the documentation for\n+  :meth:`~django.db.models.query.QuerySet.distinct`.\n+\n .. _backwards-incompatible-changes-1.4:\n \n Backwards incompatible changes in 1.4"
        },
        {
            "sha": "792d6005489ebee62cde02066f19c5521e620451",
            "filename": "tests/modeltests/distinct_on_fields/__init__.py",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/tests%2Fmodeltests%2Fdistinct_on_fields%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/tests%2Fmodeltests%2Fdistinct_on_fields%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fdistinct_on_fields%2F__init__.py?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -0,0 +1 @@\n+#"
        },
        {
            "sha": "be0b591107e2f7b7c72d6d471ebcb4a110c5a04b",
            "filename": "tests/modeltests/distinct_on_fields/models.py",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/tests%2Fmodeltests%2Fdistinct_on_fields%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/tests%2Fmodeltests%2Fdistinct_on_fields%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fdistinct_on_fields%2Fmodels.py?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -0,0 +1,39 @@\n+from django.db import models\n+\n+class Tag(models.Model):\n+    name = models.CharField(max_length=10)\n+    parent = models.ForeignKey('self', blank=True, null=True,\n+            related_name='children')\n+\n+    class Meta:\n+        ordering = ['name']\n+\n+    def __unicode__(self):\n+        return self.name\n+\n+class Celebrity(models.Model):\n+    name = models.CharField(\"Name\", max_length=20)\n+    greatest_fan = models.ForeignKey(\"Fan\", null=True, unique=True)\n+\n+    def __unicode__(self):\n+        return self.name\n+\n+class Fan(models.Model):\n+    fan_of = models.ForeignKey(Celebrity)\n+\n+class Staff(models.Model):\n+    id = models.IntegerField(primary_key=True)\n+    name = models.CharField(max_length=50)\n+    organisation = models.CharField(max_length=100)\n+    tags = models.ManyToManyField(Tag, through='StaffTag')\n+    coworkers = models.ManyToManyField('self')\n+\n+    def __unicode__(self):\n+        return self.name\n+\n+class StaffTag(models.Model):\n+    staff = models.ForeignKey(Staff)\n+    tag = models.ForeignKey(Tag)\n+\n+    def __unicode__(self):\n+        return u\"%s -> %s\" % (self.tag, self.staff)"
        },
        {
            "sha": "5021bc808804a50aaff8f308c5d7c3e5ccc55bdf",
            "filename": "tests/modeltests/distinct_on_fields/tests.py",
            "status": "added",
            "additions": 116,
            "deletions": 0,
            "changes": 116,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/tests%2Fmodeltests%2Fdistinct_on_fields%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/tests%2Fmodeltests%2Fdistinct_on_fields%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fdistinct_on_fields%2Ftests.py?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -0,0 +1,116 @@\n+from __future__ import absolute_import, with_statement\n+\n+from django.db.models import Max\n+from django.test import TestCase, skipUnlessDBFeature\n+\n+from .models import Tag, Celebrity, Fan, Staff, StaffTag\n+\n+class DistinctOnTests(TestCase):\n+    def setUp(self):\n+        t1 = Tag.objects.create(name='t1')\n+        t2 = Tag.objects.create(name='t2', parent=t1)\n+        t3 = Tag.objects.create(name='t3', parent=t1)\n+        t4 = Tag.objects.create(name='t4', parent=t3)\n+        t5 = Tag.objects.create(name='t5', parent=t3)\n+\n+        p1_o1 = Staff.objects.create(id=1, name=\"p1\", organisation=\"o1\")\n+        p2_o1 = Staff.objects.create(id=2, name=\"p2\", organisation=\"o1\")\n+        p3_o1 = Staff.objects.create(id=3, name=\"p3\", organisation=\"o1\")\n+        p1_o2 = Staff.objects.create(id=4, name=\"p1\", organisation=\"o2\")\n+        p1_o1.coworkers.add(p2_o1, p3_o1)\n+        StaffTag.objects.create(staff=p1_o1, tag=t1)\n+        StaffTag.objects.create(staff=p1_o1, tag=t1)\n+\n+        celeb1 = Celebrity.objects.create(name=\"c1\")\n+        celeb2 = Celebrity.objects.create(name=\"c2\")\n+\n+        self.fan1 = Fan.objects.create(fan_of=celeb1)\n+        self.fan2 = Fan.objects.create(fan_of=celeb1)\n+        self.fan3 = Fan.objects.create(fan_of=celeb2)\n+\n+    @skipUnlessDBFeature('can_distinct_on_fields')\n+    def test_basic_distinct_on(self):\n+        \"\"\"QuerySet.distinct('field', ...) works\"\"\"\n+        # (qset, expected) tuples\n+        qsets = (\n+            (\n+                Staff.objects.distinct().order_by('name'),\n+                ['<Staff: p1>', '<Staff: p1>', '<Staff: p2>', '<Staff: p3>'],\n+            ),\n+            (\n+                Staff.objects.distinct('name').order_by('name'),\n+                ['<Staff: p1>', '<Staff: p2>', '<Staff: p3>'],\n+            ),\n+            (\n+                Staff.objects.distinct('organisation').order_by('organisation', 'name'),\n+                ['<Staff: p1>', '<Staff: p1>'],\n+            ),\n+            (\n+                Staff.objects.distinct('name', 'organisation').order_by('name', 'organisation'),\n+                ['<Staff: p1>', '<Staff: p1>', '<Staff: p2>', '<Staff: p3>'],\n+            ),\n+            (\n+                Celebrity.objects.filter(fan__in=[self.fan1, self.fan2, self.fan3]).\\\n+                    distinct('name').order_by('name'),\n+                ['<Celebrity: c1>', '<Celebrity: c2>'],\n+            ),\n+            # Does combining querysets work?\n+            (\n+                (Celebrity.objects.filter(fan__in=[self.fan1, self.fan2]).\\\n+                    distinct('name').order_by('name')\n+                |Celebrity.objects.filter(fan__in=[self.fan3]).\\\n+                    distinct('name').order_by('name')),\n+                ['<Celebrity: c1>', '<Celebrity: c2>'],\n+            ),\n+            (\n+                StaffTag.objects.distinct('staff','tag'),\n+                ['<StaffTag: t1 -> p1>'],\n+            ),\n+            (\n+                Tag.objects.order_by('parent__pk', 'pk').distinct('parent'),\n+                ['<Tag: t2>', '<Tag: t4>', '<Tag: t1>'],\n+            ),\n+            (\n+                StaffTag.objects.select_related('staff').distinct('staff__name').order_by('staff__name'),\n+                ['<StaffTag: t1 -> p1>'],\n+            ),\n+            # Fetch the alphabetically first coworker for each worker\n+            (\n+                (Staff.objects.distinct('id').order_by('id', 'coworkers__name').\n+                               values_list('id', 'coworkers__name')),\n+                [\"(1, u'p2')\", \"(2, u'p1')\", \"(3, u'p1')\", \"(4, None)\"]\n+            ),\n+        )\n+        for qset, expected in qsets:\n+            self.assertQuerysetEqual(qset, expected)\n+            self.assertEqual(qset.count(), len(expected))\n+\n+        # Combining queries with different distinct_fields is not allowed.\n+        base_qs = Celebrity.objects.all()\n+        self.assertRaisesMessage(\n+            AssertionError,\n+            \"Cannot combine queries with different distinct fields.\",\n+            lambda: (base_qs.distinct('id') & base_qs.distinct('name'))\n+        )\n+\n+        # Test join unreffing\n+        c1 = Celebrity.objects.distinct('greatest_fan__id', 'greatest_fan__fan_of')\n+        self.assertIn('OUTER JOIN', str(c1.query))\n+        c2 = c1.distinct('pk')\n+        self.assertNotIn('OUTER JOIN', str(c2.query))\n+\n+    @skipUnlessDBFeature('can_distinct_on_fields')\n+    def test_distinct_not_implemented_checks(self):\n+        # distinct + annotate not allowed\n+        with self.assertRaises(NotImplementedError):\n+            Celebrity.objects.annotate(Max('id')).distinct('id')[0]\n+        with self.assertRaises(NotImplementedError):\n+            Celebrity.objects.distinct('id').annotate(Max('id'))[0]\n+\n+        # However this check is done only when the query executes, so you\n+        # can use distinct() to remove the fields before execution.\n+        Celebrity.objects.distinct('id').annotate(Max('id')).distinct()[0]\n+        # distinct + aggregate not allowed\n+        with self.assertRaises(NotImplementedError):\n+            Celebrity.objects.distinct('id').aggregate(Max('id'))\n+"
        },
        {
            "sha": "2f4c1453d7b98baae96985a78073c21188aade77",
            "filename": "tests/regressiontests/queries/models.py",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/tests%2Fregressiontests%2Fqueries%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/tests%2Fregressiontests%2Fqueries%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Fmodels.py?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -209,6 +209,9 @@ class Celebrity(models.Model):\n     name = models.CharField(\"Name\", max_length=20)\n     greatest_fan = models.ForeignKey(\"Fan\", null=True, unique=True)\n \n+    def __unicode__(self):\n+        return self.name\n+\n class TvChef(Celebrity):\n     pass\n \n@@ -343,4 +346,3 @@ class OneToOneCategory(models.Model):\n \n     def __unicode__(self):\n         return \"one2one \" + self.new_name\n-"
        },
        {
            "sha": "8e9705e9f7f567943da07cd8d35c7ada0ac6cee5",
            "filename": "tests/regressiontests/queries/tests.py",
            "status": "modified",
            "additions": 13,
            "deletions": 7,
            "changes": 20,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Ftests.py?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -234,18 +234,22 @@ def test_ticket2253(self):\n             ['<Item: four>', '<Item: one>']\n         )\n \n-    # FIXME: This is difficult to fix and very much an edge case, so punt for\n-    # now.  This is related to the order_by() tests for ticket #2253, but the\n-    # old bug exhibited itself here (q2 was pulling too many tables into the\n-    # combined query with the new ordering, but only because we have evaluated\n-    # q2 already).\n-    @unittest.expectedFailure\n     def test_order_by_tables(self):\n         q1 = Item.objects.order_by('name')\n         q2 = Item.objects.filter(id=self.i1.id)\n         list(q2)\n         self.assertEqual(len((q1 & q2).order_by('name').query.tables), 1)\n \n+    def test_order_by_join_unref(self):\n+        \"\"\"\n+        This test is related to the above one, testing that there aren't\n+        old JOINs in the query.\n+        \"\"\"\n+        qs = Celebrity.objects.order_by('greatest_fan__fan_of')\n+        self.assertIn('OUTER JOIN', str(qs.query))\n+        qs = qs.order_by('id')\n+        self.assertNotIn('OUTER JOIN', str(qs.query))\n+\n     def test_tickets_4088_4306(self):\n         self.assertQuerysetEqual(\n             Report.objects.filter(creator=1001),\n@@ -1728,7 +1732,7 @@ def test_recursive_fk_reverse(self):\n \n \n class ConditionalTests(BaseQuerysetTest):\n-    \"\"\"Tests whose execution depend on dfferent environment conditions like\n+    \"\"\"Tests whose execution depend on different environment conditions like\n     Python version or DB backend features\"\"\"\n \n     def setUp(self):\n@@ -1739,6 +1743,7 @@ def setUp(self):\n         t4 = Tag.objects.create(name='t4', parent=t3)\n         t5 = Tag.objects.create(name='t5', parent=t3)\n \n+\n     # In Python 2.6 beta releases, exceptions raised in __len__ are swallowed\n     # (Python issue 1242657), so these cases return an empty list, rather than\n     # raising an exception. Not a lot we can do about that, unfortunately, due to\n@@ -1810,6 +1815,7 @@ def test_ticket14244(self):\n             2500\n         )\n \n+\n class UnionTests(unittest.TestCase):\n     \"\"\"\n     Tests for the union of two querysets. Bug #12252."
        },
        {
            "sha": "4cd4f788e2b44362d7d2e95fe6d4a2c526cea27b",
            "filename": "tests/regressiontests/select_related_regress/tests.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/287565779d3ae4d3229ecbb2ff356c79b920e7d0/tests%2Fregressiontests%2Fselect_related_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/287565779d3ae4d3229ecbb2ff356c79b920e7d0/tests%2Fregressiontests%2Fselect_related_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fselect_related_regress%2Ftests.py?ref=287565779d3ae4d3229ecbb2ff356c79b920e7d0",
            "patch": "@@ -40,9 +40,9 @@ def test_regression_7110(self):\n         self.assertEqual([(c.id, unicode(c.start), unicode(c.end)) for c in connections],\n             [(c1.id, u'router/4', u'switch/7'), (c2.id, u'switch/7', u'server/1')])\n \n-        # This final query should only join seven tables (port, device and building\n-        # twice each, plus connection once).\n-        self.assertEqual(connections.query.count_active_tables(), 7)\n+        # This final query should only have seven tables (port, device and building\n+        # twice each, plus connection once). Thus, 6 joins plus the FROM table.\n+        self.assertEqual(str(connections.query).count(\" JOIN \"), 6)\n \n \n     def test_regression_8106(self):"
        }
    ],
    "stats": {
        "total": 417,
        "additions": 374,
        "deletions": 43
    }
}