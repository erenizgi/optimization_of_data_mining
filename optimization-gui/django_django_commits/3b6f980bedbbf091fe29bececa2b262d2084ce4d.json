{
    "author": "freakboy3742",
    "message": "Fixed #19049 -- Ensure that swapped models aren't included in reverse field caches.\n\nThanks to Ivan Virabyan for the report.",
    "sha": "3b6f980bedbbf091fe29bececa2b262d2084ce4d",
    "files": [
        {
            "sha": "a9b0c260620f521f01c1b3873c5b7d4a2dbe2a1b",
            "filename": "django/core/management/validation.py",
            "status": "modified",
            "additions": 13,
            "deletions": 12,
            "changes": 25,
            "blob_url": "https://github.com/django/django/blob/3b6f980bedbbf091fe29bececa2b262d2084ce4d/django%2Fcore%2Fmanagement%2Fvalidation.py",
            "raw_url": "https://github.com/django/django/raw/3b6f980bedbbf091fe29bececa2b262d2084ce4d/django%2Fcore%2Fmanagement%2Fvalidation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fvalidation.py?ref=3b6f980bedbbf091fe29bececa2b262d2084ce4d",
            "patch": "@@ -23,7 +23,6 @@ def get_validation_errors(outfile, app=None):\n     validates all models of all installed apps. Writes errors, if any, to outfile.\n     Returns number of errors.\n     \"\"\"\n-    from django.conf import settings\n     from django.db import models, connection\n     from django.db.models.loading import get_app_errors\n     from django.db.models.fields.related import RelatedObject\n@@ -37,7 +36,19 @@ def get_validation_errors(outfile, app=None):\n     for cls in models.get_models(app):\n         opts = cls._meta\n \n-        # Do field-specific validation.\n+        # Check swappable attribute.\n+        if opts.swapped:\n+            try:\n+                app_label, model_name = opts.swapped.split('.')\n+            except ValueError:\n+                e.add(opts, \"%s is not of the form 'app_label.app_name'.\" % opts.swappable)\n+                continue\n+            if not models.get_model(app_label, model_name):\n+                e.add(opts, \"Model has been swapped out for '%s' which has not been installed or is abstract.\" % opts.swapped)\n+            # No need to perform any other validation checks on a swapped model.\n+            continue\n+\n+        # Model isn't swapped; do field-specific validation.\n         for f in opts.local_fields:\n             if f.name == 'id' and not f.primary_key and opts.pk.name == 'id':\n                 e.add(opts, '\"%s\": You can\\'t use \"id\" as a field name, because each model automatically gets an \"id\" field if none of the fields have primary_key=True. You need to either remove/rename your \"id\" field or add primary_key=True to a field.' % f.name)\n@@ -285,16 +296,6 @@ def get_validation_errors(outfile, app=None):\n                     if r.get_accessor_name() == rel_query_name:\n                         e.add(opts, \"Reverse query name for m2m field '%s' clashes with related field '%s.%s'. Add a related_name argument to the definition for '%s'.\" % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))\n \n-        # Check swappable attribute.\n-        if opts.swapped:\n-            try:\n-                app_label, model_name = opts.swapped.split('.')\n-            except ValueError:\n-                e.add(opts, \"%s is not of the form 'app_label.app_name'.\" % opts.swappable)\n-                continue\n-            if not models.get_model(app_label, model_name):\n-                e.add(opts, \"Model has been swapped out for '%s' which has not been installed or is abstract.\" % opts.swapped)\n-\n         # Check ordering attribute.\n         if opts.ordering:\n             for field_name in opts.ordering:"
        },
        {
            "sha": "2c35411d7c9a77f3ebc7630ab565c9c95e25e191",
            "filename": "django/db/models/fields/related.py",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/3b6f980bedbbf091fe29bececa2b262d2084ce4d/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "raw_url": "https://github.com/django/django/raw/3b6f980bedbbf091fe29bececa2b262d2084ce4d/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2Frelated.py?ref=3b6f980bedbbf091fe29bececa2b262d2084ce4d",
            "patch": "@@ -1025,8 +1025,8 @@ def contribute_to_class(self, cls, name):\n \n     def contribute_to_related_class(self, cls, related):\n         # Internal FK's - i.e., those with a related name ending with '+' -\n-        # don't get a related descriptor.\n-        if not self.rel.is_hidden():\n+        # and swapped models don't get a related descriptor.\n+        if not self.rel.is_hidden() and related.model._meta.swapped:\n             setattr(cls, related.get_accessor_name(), ForeignRelatedObjectsDescriptor(related))\n             if self.rel.limit_choices_to:\n                 cls._meta.related_fkey_lookups.append(self.rel.limit_choices_to)\n@@ -1265,8 +1265,8 @@ def resolve_through_model(field, model, cls):\n \n     def contribute_to_related_class(self, cls, related):\n         # Internal M2Ms (i.e., those with a related name ending with '+')\n-        # don't get a related descriptor.\n-        if not self.rel.is_hidden():\n+        # and swapped models don't get a related descriptor.\n+        if not self.rel.is_hidden() and not related.model._meta.swapped:\n             setattr(cls, related.get_accessor_name(), ManyRelatedObjectsDescriptor(related))\n \n         # Set up the accessors for the column names on the m2m table"
        },
        {
            "sha": "d471bba262b4c4c160eda0521c391fa0124f8db4",
            "filename": "django/db/models/options.py",
            "status": "modified",
            "additions": 14,
            "deletions": 10,
            "changes": 24,
            "blob_url": "https://github.com/django/django/blob/3b6f980bedbbf091fe29bececa2b262d2084ce4d/django%2Fdb%2Fmodels%2Foptions.py",
            "raw_url": "https://github.com/django/django/raw/3b6f980bedbbf091fe29bececa2b262d2084ce4d/django%2Fdb%2Fmodels%2Foptions.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Foptions.py?ref=3b6f980bedbbf091fe29bececa2b262d2084ce4d",
            "patch": "@@ -418,13 +418,14 @@ def _fill_related_objects_cache(self):\n         # Collect also objects which are in relation to some proxy child/parent of self.\n         proxy_cache = cache.copy()\n         for klass in get_models(include_auto_created=True, only_installed=False):\n-            for f in klass._meta.local_fields:\n-                if f.rel and not isinstance(f.rel.to, six.string_types):\n-                    if self == f.rel.to._meta:\n-                        cache[RelatedObject(f.rel.to, klass, f)] = None\n-                        proxy_cache[RelatedObject(f.rel.to, klass, f)] = None\n-                    elif self.concrete_model == f.rel.to._meta.concrete_model:\n-                        proxy_cache[RelatedObject(f.rel.to, klass, f)] = None\n+            if not klass._meta.swapped:\n+                for f in klass._meta.local_fields:\n+                    if f.rel and not isinstance(f.rel.to, six.string_types):\n+                        if self == f.rel.to._meta:\n+                            cache[RelatedObject(f.rel.to, klass, f)] = None\n+                            proxy_cache[RelatedObject(f.rel.to, klass, f)] = None\n+                        elif self.concrete_model == f.rel.to._meta.concrete_model:\n+                            proxy_cache[RelatedObject(f.rel.to, klass, f)] = None\n         self._related_objects_cache = cache\n         self._related_objects_proxy_cache = proxy_cache\n \n@@ -460,9 +461,12 @@ def _fill_related_many_to_many_cache(self):\n                 else:\n                     cache[obj] = model\n         for klass in get_models(only_installed=False):\n-            for f in klass._meta.local_many_to_many:\n-                if f.rel and not isinstance(f.rel.to, six.string_types) and self == f.rel.to._meta:\n-                    cache[RelatedObject(f.rel.to, klass, f)] = None\n+            if not klass._meta.swapped:\n+                for f in klass._meta.local_many_to_many:\n+                    if (f.rel\n+                            and not isinstance(f.rel.to, six.string_types)\n+                            and self == f.rel.to._meta):\n+                        cache[RelatedObject(f.rel.to, klass, f)] = None\n         if app_cache_ready():\n             self._related_many_to_many_cache = cache\n         return cache"
        },
        {
            "sha": "ccb639635219c730d301eee4491118111885a174",
            "filename": "tests/modeltests/invalid_models/invalid_models/models.py",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/django/django/blob/3b6f980bedbbf091fe29bececa2b262d2084ce4d/tests%2Fmodeltests%2Finvalid_models%2Finvalid_models%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/3b6f980bedbbf091fe29bececa2b262d2084ce4d/tests%2Fmodeltests%2Finvalid_models%2Finvalid_models%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Finvalid_models%2Finvalid_models%2Fmodels.py?ref=3b6f980bedbbf091fe29bececa2b262d2084ce4d",
            "patch": "@@ -303,13 +303,28 @@ class SwappedModel(models.Model):\n     References to this model *should* raise a validation error.\n     Requires TEST_SWAPPED_MODEL to be defined in the test environment;\n     this is guaranteed by the test runner using @override_settings.\n+\n+    The foreign keys and m2m relations on this model *shouldn't*\n+    install related accessors, so there shouldn't be clashes with\n+    the equivalent names on the replacement.\n     \"\"\"\n     name = models.CharField(max_length=100)\n \n+    foreign = models.ForeignKey(Target, related_name='swappable_fk_set')\n+    m2m = models.ManyToManyField(Target, related_name='swappable_m2m_set')\n+\n     class Meta:\n         swappable = 'TEST_SWAPPED_MODEL'\n \n \n+class ReplacementModel(models.Model):\n+    \"\"\"A replacement model for swapping purposes.\"\"\"\n+    name = models.CharField(max_length=100)\n+\n+    foreign = models.ForeignKey(Target, related_name='swappable_fk_set')\n+    m2m = models.ManyToManyField(Target, related_name='swappable_m2m_set')\n+\n+\n class BadSwappableValue(models.Model):\n     \"\"\"A model that can be swapped out; during testing, the swappable\n     value is not of the format app.model"
        },
        {
            "sha": "5f6224c45d7e50e1f056b8cfeb1829c2a302507b",
            "filename": "tests/modeltests/invalid_models/tests.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/3b6f980bedbbf091fe29bececa2b262d2084ce4d/tests%2Fmodeltests%2Finvalid_models%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/3b6f980bedbbf091fe29bececa2b262d2084ce4d/tests%2Fmodeltests%2Finvalid_models%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Finvalid_models%2Ftests.py?ref=3b6f980bedbbf091fe29bececa2b262d2084ce4d",
            "patch": "@@ -37,7 +37,7 @@ def tearDown(self):\n     # easier to set this up as an override than to require every developer\n     # to specify a value in their test settings.\n     @override_settings(\n-        TEST_SWAPPED_MODEL='invalid_models.Target',\n+        TEST_SWAPPED_MODEL='invalid_models.ReplacementModel',\n         TEST_SWAPPED_MODEL_BAD_VALUE='not-a-model',\n         TEST_SWAPPED_MODEL_BAD_MODEL='not_an_app.Target',\n     )"
        }
    ],
    "stats": {
        "total": 74,
        "additions": 47,
        "deletions": 27
    }
}