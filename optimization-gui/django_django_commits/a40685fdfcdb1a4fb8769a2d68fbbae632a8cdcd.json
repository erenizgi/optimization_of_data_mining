{
    "author": "unknown",
    "message": "Fixed #15308 -- Sphinx/reST fixes for the Custom Model Fields docs.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15547 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "a40685fdfcdb1a4fb8769a2d68fbbae632a8cdcd",
    "files": [
        {
            "sha": "5753abd56bf345228b4d91b88ad5bead91ba7a8e",
            "filename": "docs/howto/custom-model-fields.txt",
            "status": "modified",
            "additions": 57,
            "deletions": 54,
            "changes": 111,
            "blob_url": "https://github.com/django/django/blob/a40685fdfcdb1a4fb8769a2d68fbbae632a8cdcd/docs%2Fhowto%2Fcustom-model-fields.txt",
            "raw_url": "https://github.com/django/django/raw/a40685fdfcdb1a4fb8769a2d68fbbae632a8cdcd/docs%2Fhowto%2Fcustom-model-fields.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fhowto%2Fcustom-model-fields.txt?ref=a40685fdfcdb1a4fb8769a2d68fbbae632a8cdcd",
            "patch": "@@ -105,6 +105,8 @@ say, all the *north* cards first, then the *east*, *south* and *west* cards. So\n What does a field class do?\n ---------------------------\n \n+.. class:: Field\n+\n All of Django's fields (and when we say *fields* in this document, we always\n mean model fields and not :doc:`form fields </ref/forms/fields>`) are subclasses\n of :class:`django.db.models.Field`. Most of the information that Django records\n@@ -190,6 +192,8 @@ card values plus their suits; 104 characters in total.\n     you want your fields to be more strict about the options they select, or\n     to use the simpler, more permissive behavior of the current fields.\n \n+.. method:: Field.__init__\n+\n The :meth:`~django.db.models.Field.__init__` method takes the following\n parameters:\n \n@@ -228,6 +232,8 @@ meaning they do for normal Django fields. See the :doc:`field documentation\n The ``SubfieldBase`` metaclass\n ------------------------------\n \n+.. class:: django.db.models.SubfieldBase\n+\n As we indicated in the introduction_, field subclasses are often needed for\n two reasons: either to take advantage of a custom database column type, or to\n handle complex Python types. Obviously, a combination of the two is also\n@@ -242,8 +248,6 @@ appropriate Python object. The details of how this happens internally are a\n little complex, but the code you need to write in your ``Field`` class is\n simple: make sure your field subclass uses a special metaclass:\n \n-.. class:: django.db.models.SubfieldBase\n-\n For example::\n \n     class HandField(models.Field):\n@@ -255,13 +259,13 @@ For example::\n         def __init__(self, *args, **kwargs):\n             # ...\n \n-This ensures that the :meth:`to_python` method, documented below, will always be\n-called when the attribute is initialized.\n+This ensures that the :meth:`.to_python` method, documented below, will always\n+be called when the attribute is initialized.\n \n ModelForms and custom fields\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-If you use :class:`~django.db.models.SubfieldBase`, :meth:`to_python`\n+If you use :class:`~django.db.models.SubfieldBase`, :meth:`.to_python`\n will be called every time an instance of the field is assigned a\n value. This means that whenever a value may be assigned to the field,\n you need to ensure that it will be of the correct datatype, or that\n@@ -277,24 +281,22 @@ Therefore, you must ensure that the form field used to represent your\n custom field performs whatever input validation and data cleaning is\n necessary to convert user-provided form input into a\n `to_python()`-compatible model field value. This may require writing a\n-custom form field, and/or implementing the :meth:`formfield` method on\n+custom form field, and/or implementing the :meth:`.formfield` method on\n your field to return a form field class whose `to_python()` returns the\n correct datatype.\n \n Documenting your custom field\n -----------------------------\n \n-.. class:: django.db.models.Field\n-\n-.. attribute:: description\n+.. attribute:: Field.description\n \n As always, you should document your field type, so users will know what it is.\n In addition to providing a docstring for it, which is useful for developers,\n you can also allow users of the admin app to see a short description of the\n field type via the :doc:`django.contrib.admindocs\n </ref/contrib/admin/admindocs>` application. To do this simply provide\n descriptive text in a ``description`` class attribute of your custom field. In\n-the above example, the type description displayed by the ``admindocs``\n+the above example, the description displayed by the ``admindocs``\n application for a ``HandField`` will be 'A hand of cards (bridge style)'.\n \n Useful methods\n@@ -308,7 +310,7 @@ approximately decreasing order of importance, so start from the top.\n Custom database types\n ~~~~~~~~~~~~~~~~~~~~~\n \n-.. method:: db_type(self, connection)\n+.. method:: Field.db_type(self, connection)\n \n .. versionadded:: 1.2\n    The ``connection`` argument was added to support multiple databases.\n@@ -317,8 +319,8 @@ Returns the database column data type for the :class:`~django.db.models.Field`,\n taking into account the connection object, and the settings associated with it.\n \n Say you've created a PostgreSQL custom type called ``mytype``. You can use this\n-field with Django by subclassing ``Field`` and implementing the :meth:`db_type`\n-method, like so::\n+field with Django by subclassing ``Field`` and implementing the\n+:meth:`.db_type` method, like so::\n \n     from django.db import models\n \n@@ -337,8 +339,8 @@ Once you have ``MytypeField``, you can use it in any model, just like any other\n If you aim to build a database-agnostic application, you should account for\n differences in database column types. For example, the date/time column type\n in PostgreSQL is called ``timestamp``, while the same column in MySQL is called\n-``datetime``. The simplest way to handle this in a ``db_type()`` method is to\n-check the ``connection.settings_dict['ENGINE']`` attribute.\n+``datetime``. The simplest way to handle this in a :meth:`.db_type`\n+method is to check the ``connection.settings_dict['ENGINE']`` attribute.\n \n For example::\n \n@@ -349,11 +351,11 @@ For example::\n             else:\n                 return 'timestamp'\n \n-The :meth:`db_type` method is only called by Django when the framework\n-constructs the ``CREATE TABLE`` statements for your application -- that is, when\n-you first create your tables. It's not called at any other time, so it can\n-afford to execute slightly complex code, such as the ``connection.settings_dict``\n-check in the above example.\n+The :meth:`.db_type` method is only called by Django when the framework\n+constructs the ``CREATE TABLE`` statements for your application -- that is,\n+when you first create your tables. It's not called at any other time, so it can\n+afford to execute slightly complex code, such as the\n+``connection.settings_dict`` check in the above example.\n \n Some database column types accept parameters, such as ``CHAR(25)``, where the\n parameter ``25`` represents the maximum column length. In cases like these,\n@@ -390,15 +392,15 @@ time -- i.e., when the class is instantiated. To do that, just implement\n         my_field = BetterCharField(25)\n \n Finally, if your column requires truly complex SQL setup, return ``None`` from\n-:meth:`db_type`. This will cause Django's SQL creation code to skip over this\n-field. You are then responsible for creating the column in the right table in\n-some other way, of course, but this gives you a way to tell Django to get out of\n-the way.\n+:meth:`.db_type`. This will cause Django's SQL creation code to skip\n+over this field. You are then responsible for creating the column in the right\n+table in some other way, of course, but this gives you a way to tell Django to\n+get out of the way.\n \n Converting database values to Python objects\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-.. method:: to_python(self, value)\n+.. method:: Field.to_python(self, value)\n \n Converts a value as returned by your database (or a serializer) to a Python\n object.\n@@ -420,7 +422,7 @@ with any of the following arguments:\n \n In our ``HandField`` class, we're storing the data as a VARCHAR field in the\n database, so we need to be able to process strings and ``Hand`` instances in\n-:meth:`to_python`::\n+:meth:`.to_python`::\n \n     import re\n \n@@ -442,17 +444,18 @@ Python object type we want to store in the model's attribute.\n \n **Remember:** If your custom field needs the :meth:`to_python` method to be\n called when it is created, you should be using `The SubfieldBase metaclass`_\n-mentioned earlier. Otherwise :meth:`to_python` won't be called automatically.\n+mentioned earlier. Otherwise :meth:`.to_python` won't be called\n+automatically.\n \n Converting Python objects to query values\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-.. method:: get_prep_value(self, value)\n+.. method:: Field.get_prep_value(self, value)\n \n .. versionadded:: 1.2\n    This method was factored out of ``get_db_prep_value()``\n \n-This is the reverse of :meth:`to_python` when working with the\n+This is the reverse of :meth:`.to_python` when working with the\n database backends (as opposed to serialization). The ``value``\n parameter is the current value of the model's attribute (a field has\n no reference to its containing model, so it cannot retrieve the value\n@@ -461,7 +464,7 @@ prepared for use as a parameter in a query.\n \n This conversion should *not* include any database-specific\n conversions. If database-specific conversions are required, they\n-should be made in the call to :meth:`get_db_prep_value`.\n+should be made in the call to :meth:`.get_db_prep_value`.\n \n For example::\n \n@@ -475,43 +478,43 @@ For example::\n Converting query values to database values\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-.. method:: get_db_prep_value(self, value, connection, prepared=False)\n+.. method:: Field.get_db_prep_value(self, value, connection, prepared=False)\n \n .. versionadded:: 1.2\n    The ``connection`` and ``prepared`` arguments were added to support multiple databases.\n \n Some data types (for example, dates) need to be in a specific format\n before they can be used by a database backend.\n-:meth:`get_db_prep_value` is the method where those conversions should\n+:meth:`.get_db_prep_value` is the method where those conversions should\n be made. The specific connection that will be used for the query is\n passed as the ``connection`` parameter. This allows you to use\n backend-specific conversion logic if it is required.\n \n The ``prepared`` argument describes whether or not the value has\n-already been passed through :meth:`get_prep_value` conversions. When\n+already been passed through :meth:`.get_prep_value` conversions. When\n ``prepared`` is False, the default implementation of\n-:meth:`get_db_prep_value` will call :meth:`get_prep_value` to do\n+:meth:`.get_db_prep_value` will call :meth:`.get_prep_value` to do\n initial data conversions before performing any database-specific\n processing.\n \n-.. method:: get_db_prep_save(self, value, connection)\n+.. method:: Field.get_db_prep_save(self, value, connection)\n \n .. versionadded:: 1.2\n    The ``connection`` argument was added to support multiple databases.\n \n Same as the above, but called when the Field value must be *saved* to\n the database. As the default implementation just calls\n-``get_db_prep_value``, you shouldn't need to implement this method\n+:meth:`.get_db_prep_value`, you shouldn't need to implement this method\n unless your custom field needs a special conversion when being saved\n that is not the same as the conversion used for normal query\n-parameters (which is implemented by ``get_db_prep_value``).\n+parameters (which is implemented by :meth:`.get_db_prep_value`).\n \n Preprocessing values before saving\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-.. method:: pre_save(self, model_instance, add)\n+.. method:: Field.pre_save(self, model_instance, add)\n \n-This method is called just prior to :meth:`get_db_prep_save` and should return\n+This method is called just prior to :meth:`.get_db_prep_save` and should return\n the value of the appropriate attribute from ``model_instance`` for this field.\n The attribute name is in ``self.attname`` (this is set up by\n :class:`~django.db.models.Field`). If the model is being saved to the database\n@@ -535,12 +538,12 @@ Preparing values for use in database lookups\n As with value conversions, preparing a value for database lookups is a\n two phase process.\n \n-.. method:: get_prep_lookup(self, lookup_type, value)\n+.. method:: Field.get_prep_lookup(self, lookup_type, value)\n \n .. versionadded:: 1.2\n    This method was factored out of ``get_db_prep_lookup()``\n \n-:meth:`get_prep_lookup` performs the first phase of lookup preparation,\n+:meth:`.get_prep_lookup` performs the first phase of lookup preparation,\n performing generic data validity checks\n \n Prepares the ``value`` for passing to the database when used in a lookup (a\n@@ -555,7 +558,7 @@ should raise either a ``ValueError`` if the ``value`` is of the wrong sort (a\n list when you were expecting an object, for example) or a ``TypeError`` if\n your field does not support that type of lookup. For many fields, you can get\n by with handling the lookup types that need special handling for your field\n-and pass the rest to the :meth:`get_db_prep_lookup` method of the parent class.\n+and pass the rest to the :meth:`.get_db_prep_lookup` method of the parent class.\n \n If you needed to implement ``get_db_prep_save()``, you will usually need to\n implement ``get_prep_lookup()``. If you don't, ``get_prep_value`` will be\n@@ -586,21 +589,21 @@ accepted lookup types to ``exact`` and ``in``::\n             else:\n                 raise TypeError('Lookup type %r not supported.' % lookup_type)\n \n-.. method:: get_db_prep_lookup(self, lookup_type, value, connection, prepared=False)\n+.. method:: Field.get_db_prep_lookup(self, lookup_type, value, connection, prepared=False)\n \n .. versionadded:: 1.2\n    The ``connection`` and ``prepared`` arguments were added to support multiple databases.\n \n Performs any database-specific data conversions required by a lookup.\n-As with :meth:`get_db_prep_value`, the specific connection that will\n+As with :meth:`.get_db_prep_value`, the specific connection that will\n be used for the query is passed as the ``connection`` parameter.\n The ``prepared`` argument describes whether the value has already been\n-prepared with :meth:`get_prep_lookup`.\n+prepared with :meth:`.get_prep_lookup`.\n \n Specifying the form field for a model field\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-.. method:: formfield(self, form_class=forms.CharField, **kwargs)\n+.. method:: Field.formfield(self, form_class=forms.CharField, **kwargs)\n \n Returns the default form field to use when this field is displayed in a model.\n This method is called by the :class:`~django.forms.ModelForm` helper.\n@@ -613,7 +616,7 @@ field (and even a form widget). See the :doc:`forms documentation\n </topics/forms/index>` for information about this, and take a look at the code in\n :mod:`django.contrib.localflavor` for some examples of custom widgets.\n \n-Continuing our ongoing example, we can write the :meth:`formfield` method as::\n+Continuing our ongoing example, we can write the :meth:`.formfield` method as::\n \n     class HandField(models.Field):\n         # ...\n@@ -635,14 +638,14 @@ fields.\n Emulating built-in field types\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-.. method:: get_internal_type(self)\n+.. method:: Field.get_internal_type(self)\n \n Returns a string giving the name of the :class:`~django.db.models.Field`\n subclass we are emulating at the database level. This is used to determine the\n type of database column for simple cases.\n \n-If you have created a :meth:`db_type` method, you don't need to worry about\n-:meth:`get_internal_type` -- it won't be used much. Sometimes, though, your\n+If you have created a :meth:`.db_type` method, you don't need to worry about\n+:meth:`.get_internal_type` -- it won't be used much. Sometimes, though, your\n database storage is similar in type to some other field, so you can use that\n other field's logic to create the right column.\n \n@@ -657,19 +660,19 @@ For example::\n No matter which database backend we are using, this will mean that ``syncdb``\n and other SQL commands create the right column type for storing a string.\n \n-If :meth:`get_internal_type` returns a string that is not known to Django for\n+If :meth:`.get_internal_type` returns a string that is not known to Django for\n the database backend you are using -- that is, it doesn't appear in\n ``django.db.backends.<db_name>.creation.DATA_TYPES`` -- the string will still be\n-used by the serializer, but the default :meth:`db_type` method will return\n-``None``. See the documentation of :meth:`db_type` for reasons why this might be\n+used by the serializer, but the default :meth:`.db_type` method will return\n+``None``. See the documentation of :meth:`.db_type` for reasons why this might be\n useful. Putting a descriptive string in as the type of the field for the\n serializer is a useful idea if you're ever going to be using the serializer\n output in some other place, outside of Django.\n \n Converting field data for serialization\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-.. method:: value_to_string(self, obj)\n+.. method:: Field.value_to_string(self, obj)\n \n This method is used by the serializers to convert the field into a string for\n output. Calling :meth:`Field._get_val_from_obj(obj)` is the best way to get the"
        }
    ],
    "stats": {
        "total": 111,
        "additions": 57,
        "deletions": 54
    }
}