{
    "author": "spookylukey",
    "message": "Fixed #17014  - added protection against infinite recursion.\n\nThanks to akaariai for the report and tests.\n\nNo tests have been added, since unittests for termination are basically\nimpossible, and the failure condition will take down the developer's machine\nin this case. It has been tested against the cases in #17014.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16940 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "64da8eec3077eaaba5cfa62775523da772f4de44",
    "files": [
        {
            "sha": "be42d02006ca0ec4d36b09d6ee025d44c52e7cac",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 21,
            "deletions": 9,
            "changes": 30,
            "blob_url": "https://github.com/django/django/blob/64da8eec3077eaaba5cfa62775523da772f4de44/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/64da8eec3077eaaba5cfa62775523da772f4de44/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=64da8eec3077eaaba5cfa62775523da772f4de44",
            "patch": "@@ -3,6 +3,7 @@\n \"\"\"\n \n import copy\n+import itertools\n \n from django.db import connections, router, transaction, IntegrityError\n from django.db.models.fields import AutoField\n@@ -1574,9 +1575,12 @@ def prefetch_related_objects(result_cache, related_lookups):\n     # ensure we don't do duplicate work.\n     done_lookups = set() # list of lookups like foo__bar__baz\n     done_queries = {}    # dictionary of things like 'foo__bar': [results]\n-    related_lookups = list(related_lookups)\n \n-    # We may expand related_lookups, so need a loop that allows for that\n+    manual_lookups = list(related_lookups)\n+    auto_lookups = [] # we add to this as we go through.\n+    followed_descriptors = set() # recursion protection\n+\n+    related_lookups = itertools.chain(manual_lookups, auto_lookups)\n     for lookup in related_lookups:\n         if lookup in done_lookups:\n             # We've done exactly this already, skip the whole thing\n@@ -1616,7 +1620,7 @@ def prefetch_related_objects(result_cache, related_lookups):\n             # We assume that objects retrieved are homogenous (which is the premise\n             # of prefetch_related), so what applies to first object applies to all.\n             first_obj = obj_list[0]\n-            prefetcher, attr_found, is_fetched = get_prefetcher(first_obj, attr)\n+            prefetcher, descriptor, attr_found, is_fetched = get_prefetcher(first_obj, attr)\n \n             if not attr_found:\n                 raise AttributeError(\"Cannot find '%s' on %s object, '%s' is an invalid \"\n@@ -1638,10 +1642,17 @@ def prefetch_related_objects(result_cache, related_lookups):\n                     obj_list = done_queries[current_lookup]\n                 else:\n                     obj_list, additional_prl = prefetch_one_level(obj_list, prefetcher, attr)\n-                    for f in additional_prl:\n-                        new_prl = LOOKUP_SEP.join([current_lookup, f])\n-                        related_lookups.append(new_prl)\n-                    done_queries[current_lookup] = obj_list\n+                    # We need to ensure we don't keep adding lookups from the\n+                    # same relationships to stop infinite recursion. So, if we\n+                    # are already on an automatically added lookup, don't add\n+                    # the new lookups from relationships we've seen already.\n+                    if not (lookup in auto_lookups and\n+                            descriptor in followed_descriptors):\n+                        for f in additional_prl:\n+                            new_prl = LOOKUP_SEP.join([current_lookup, f])\n+                            auto_lookups.append(new_prl)\n+                        done_queries[current_lookup] = obj_list\n+                    followed_descriptors.add(descriptor)\n             else:\n                 # Either a singly related object that has already been fetched\n                 # (e.g. via select_related), or hopefully some other property\n@@ -1659,8 +1670,9 @@ def get_prefetcher(instance, attr):\n     \"\"\"\n     For the attribute 'attr' on the given instance, finds\n     an object that has a get_prefetch_query_set().\n-    Return a 3 tuple containing:\n+    Returns a 4 tuple containing:\n     (the object with get_prefetch_query_set (or None),\n+     the descriptor object representing this relationship (or None),\n      a boolean that is False if the attribute was not found at all,\n      a boolean that is True if the attribute has already been fetched)\n     \"\"\"\n@@ -1694,7 +1706,7 @@ def get_prefetcher(instance, attr):\n                 rel_obj = getattr(instance, attr)\n                 if hasattr(rel_obj, 'get_prefetch_query_set'):\n                     prefetcher = rel_obj\n-    return prefetcher, attr_found, is_fetched\n+    return prefetcher, rel_obj_descriptor, attr_found, is_fetched\n \n \n def prefetch_one_level(instances, prefetcher, attname):"
        }
    ],
    "stats": {
        "total": 30,
        "additions": 21,
        "deletions": 9
    }
}