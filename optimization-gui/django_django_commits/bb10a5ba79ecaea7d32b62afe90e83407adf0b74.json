{
    "author": "ramiro",
    "message": "Fixed grammar and tweaked notes about MySQL database/table collation interaction with text fields. Refs #14417.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@14779 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "bb10a5ba79ecaea7d32b62afe90e83407adf0b74",
    "files": [
        {
            "sha": "ef0d78ac02bc0acf4bd0a1f7c3d94e06dc8c14e2",
            "filename": "docs/ref/databases.txt",
            "status": "modified",
            "additions": 17,
            "deletions": 15,
            "changes": 32,
            "blob_url": "https://github.com/django/django/blob/bb10a5ba79ecaea7d32b62afe90e83407adf0b74/docs%2Fref%2Fdatabases.txt",
            "raw_url": "https://github.com/django/django/raw/bb10a5ba79ecaea7d32b62afe90e83407adf0b74/docs%2Fref%2Fdatabases.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fdatabases.txt?ref=bb10a5ba79ecaea7d32b62afe90e83407adf0b74",
            "patch": "@@ -227,18 +227,19 @@ non-unique) with the default collation.\n In many cases, this default will not be a problem. However, if you really want\n case-sensitive comparisons on a particular column or table, you would change\n the column or table to use the ``utf8_bin`` collation. The main thing to be\n-aware of in this case is that if you are using MySQLdb 1.2.2, the database backend in Django will then return\n-bytestrings (instead of unicode strings) for any character fields it returns\n-receive from the database. This is a strong variation from Django's normal\n-practice of *always* returning unicode strings. It is up to you, the\n-developer, to handle the fact that you will receive bytestrings if you\n-configure your table(s) to use ``utf8_bin`` collation. Django itself should work\n-smoothly with such columns, but if your code must be prepared to call\n-``django.utils.encoding.smart_unicode()`` at times if it really wants to work\n-with consistent data -- Django will not do this for you (the database backend\n-layer and the model population layer are separated internally so the database\n-layer doesn't know it needs to make this conversion in this one particular\n-case).\n+aware of in this case is that if you are using MySQLdb 1.2.2, the database\n+backend in Django will then return bytestrings (instead of unicode strings) for\n+any character fields it receive from the database. This is a strong variation\n+from Django's normal practice of *always* returning unicode strings. It is up\n+to you, the developer, to handle the fact that you will receive bytestrings if\n+you configure your table(s) to use ``utf8_bin`` collation. Django itself should\n+mostly work smoothly with such columns (except for the ``contrib.sessions``\n+``Session`` and ``contrib.admin`` ``LogEntry`` tables described below), but\n+your code must be prepared to call ``django.utils.encoding.smart_unicode()`` at\n+times if it really wants to work with consistent data -- Django will not do\n+this for you (the database backend layer and the model population layer are\n+separated internally so the database layer doesn't know it needs to make this\n+conversion in this one particular case).\n \n If you're using MySQLdb 1.2.1p2, Django's standard\n :class:`~django.db.models.CharField` class will return unicode strings even\n@@ -249,11 +250,12 @@ the information needed to make the necessary conversions isn't available when\n the data is read in from the database. This problem was `fixed in MySQLdb\n 1.2.2`_, so if you want to use :class:`~django.db.models.TextField` with\n ``utf8_bin`` collation, upgrading to version 1.2.2 and then dealing with the\n-bytestrings (which shouldn't be too difficult) is the recommended solution.\n+bytestrings (which shouldn't be too difficult) as described above is the\n+recommended solution.\n \n Should you decide to use ``utf8_bin`` collation for some of your tables with\n-MySQLdb 1.2.1p2, you should still use ``utf8_collation_ci_swedish`` (the\n-default) collation for the :class:`django.contrib.sessions.models.Session`\n+MySQLdb 1.2.1p2 or 1.2.2, you should still use ``utf8_collation_ci_swedish``\n+(the default) collation for the :class:`django.contrib.sessions.models.Session`\n table (usually called ``django_session``) and the\n :class:`django.contrib.admin.models.LogEntry` table (usually called\n ``django_admin_log``). Those are the two standard tables that use"
        }
    ],
    "stats": {
        "total": 32,
        "additions": 17,
        "deletions": 15
    }
}