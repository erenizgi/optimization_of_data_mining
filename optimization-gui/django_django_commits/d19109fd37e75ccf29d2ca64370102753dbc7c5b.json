{
    "author": "ramiro",
    "message": "Fixed #19497 -- Refactored testing docs.\n\nThanks Tim Graham for the review and suggestions.",
    "sha": "d19109fd37e75ccf29d2ca64370102753dbc7c5b",
    "files": [
        {
            "sha": "ab00da271c3c0e66585f8c8d6e7c1660a6281eaf",
            "filename": "docs/index.txt",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Findex.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Findex.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Findex.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -180,7 +180,11 @@ testing of Django applications:\n   :doc:`Overview <ref/django-admin>` |\n   :doc:`Adding custom commands <howto/custom-management-commands>`\n \n-* **Testing:**  :doc:`Overview <topics/testing>`\n+* **Testing:**\n+  :doc:`Overview <topics/testing/index>` |\n+  :doc:`Writing and running tests <topics/testing/overview>` |\n+  :doc:`Advanced topics <topics/testing/advanced>` |\n+  :doc:`Doctests <topics/testing/doctests>`\n \n * **Deployment:**\n   :doc:`Overview <howto/deployment/index>` |"
        },
        {
            "sha": "afef554a8c4d7c01eb1c1c3030ec772c8aff2255",
            "filename": "docs/internals/contributing/writing-code/unit-tests.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Finternals%2Fcontributing%2Fwriting-code%2Funit-tests.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Finternals%2Fcontributing%2Fwriting-code%2Funit-tests.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Finternals%2Fcontributing%2Fwriting-code%2Funit-tests.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -15,8 +15,8 @@ The tests cover:\n We appreciate any and all contributions to the test suite!\n \n The Django tests all use the testing infrastructure that ships with Django for\n-testing applications. See :doc:`Testing Django applications </topics/testing>`\n-for an explanation of how to write new tests.\n+testing applications. See :doc:`Testing Django applications\n+</topics/testing/overview>` for an explanation of how to write new tests.\n \n .. _running-unit-tests:\n "
        },
        {
            "sha": "c94038bc56e74e33e1db42a933bf3817e17d4f41",
            "filename": "docs/intro/contributing.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Fintro%2Fcontributing.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Fintro%2Fcontributing.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fintro%2Fcontributing.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -281,7 +281,7 @@ correctly in a couple different situations.\n     computer programming, so there's lots of information out there:\n \n     * A good first look at writing tests for Django can be found in the\n-      documentation on :doc:`Testing Django applications</topics/testing/>`.\n+      documentation on :doc:`Testing Django applications </topics/testing/overview>`.\n     * Dive Into Python (a free online book for beginning Python developers)\n       includes a great `introduction to Unit Testing`__.\n     * After reading those, if you want something a little meatier to sink"
        },
        {
            "sha": "d1f95176edc50d640ec0e819b93a10ec927ca403",
            "filename": "docs/intro/tutorial05.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Fintro%2Ftutorial05.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Fintro%2Ftutorial05.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fintro%2Ftutorial05.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -632,7 +632,7 @@ a piece of code, it usually means that code should be refactored or removed.\n Coverage will help to identify dead code. See\n :ref:`topics-testing-code-coverage` for details.\n \n-:doc:`Testing Django applications </topics/testing>` has comprehensive\n+:doc:`Testing Django applications </topics/testing/index>` has comprehensive\n information about testing.\n \n .. _Selenium: http://seleniumhq.org/"
        },
        {
            "sha": "a13cb5de69b6acb4591311a6681129d794c086cf",
            "filename": "docs/misc/api-stability.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Fmisc%2Fapi-stability.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Fmisc%2Fapi-stability.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fmisc%2Fapi-stability.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -71,7 +71,7 @@ of 1.0. This includes these APIs:\n   external template tags. Before adding any such tags, we'll ensure that\n   Django raises an error if it tries to load tags with duplicate names.\n \n-- :doc:`Testing </topics/testing>`\n+- :doc:`Testing </topics/testing/index>`\n \n - :doc:`django-admin utility </ref/django-admin>`.\n "
        },
        {
            "sha": "6ab3b1d133edd799dd7bed49bf9fe44d6b393b1b",
            "filename": "docs/ref/django-admin.txt",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Fref%2Fdjango-admin.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Fref%2Fdjango-admin.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fdjango-admin.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -1036,7 +1036,7 @@ test <app or test identifier>\n \n .. django-admin:: test\n \n-Runs tests for all installed models. See :doc:`/topics/testing` for more\n+Runs tests for all installed models. See :doc:`/topics/testing/index` for more\n information.\n \n .. django-admin-option:: --failfast\n@@ -1072,15 +1072,15 @@ For example, this command::\n \n ...would perform the following steps:\n \n-1. Create a test database, as described in :doc:`/topics/testing`.\n+1. Create a test database, as described in :ref:`the-test-database`.\n 2. Populate the test database with fixture data from the given fixtures.\n    (For more on fixtures, see the documentation for ``loaddata`` above.)\n 3. Runs the Django development server (as in ``runserver``), pointed at\n    this newly created test database instead of your production database.\n \n This is useful in a number of ways:\n \n-* When you're writing :doc:`unit tests </topics/testing>` of how your views\n+* When you're writing :doc:`unit tests </topics/testing/overview>` of how your views\n   act with certain fixture data, you can use ``testserver`` to interact with\n   the views in a Web browser, manually.\n "
        },
        {
            "sha": "5ecc221039f3b592083953ae38ca6be867cfe168",
            "filename": "docs/ref/settings.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Fref%2Fsettings.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Fref%2Fsettings.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fsettings.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -562,7 +562,7 @@ If the default value (``None``) is used with the SQLite database engine, the\n tests will use a memory resident database. For all other database engines the\n test database will use the name ``'test_' + DATABASE_NAME``.\n \n-See :doc:`/topics/testing`.\n+See :ref:`the-test-database`.\n \n .. setting:: TEST_CREATE\n \n@@ -1982,9 +1982,7 @@ TEST_RUNNER\n Default: ``'django.test.simple.DjangoTestSuiteRunner'``\n \n The name of the class to use for starting the test suite. See\n-:doc:`/topics/testing`.\n-\n-.. _Testing Django Applications: ../testing/\n+:ref:`other-testing-frameworks`.\n \n .. setting:: THOUSAND_SEPARATOR\n "
        },
        {
            "sha": "3315f9781ba4d6a3777d4d8659a1891b339d3c5f",
            "filename": "docs/ref/signals.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Fref%2Fsignals.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Fref%2Fsignals.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fsignals.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -476,7 +476,7 @@ Test signals\n .. module:: django.test.signals\n    :synopsis: Signals sent during testing.\n \n-Signals only sent when :doc:`running tests </topics/testing>`.\n+Signals only sent when :ref:`running tests <running-tests>`.\n \n setting_changed\n ---------------"
        },
        {
            "sha": "a00f878df356f092b4200aa76b36e9672c3fde24",
            "filename": "docs/releases/0.96.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Freleases%2F0.96.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Freleases%2F0.96.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F0.96.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -220,7 +220,7 @@ supported :doc:`serialization formats </topics/serialization>`, that will be\n loaded into your database at the start of your tests. This makes testing with\n real data much easier.\n \n-See :doc:`the testing documentation </topics/testing>` for the full details.\n+See :doc:`the testing documentation </topics/testing/index>` for the full details.\n \n Improvements to the admin interface\n -----------------------------------"
        },
        {
            "sha": "c8ac56cf48a5030562451198a9da9aff1f71f768",
            "filename": "docs/releases/1.1-alpha-1.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Freleases%2F1.1-alpha-1.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Freleases%2F1.1-alpha-1.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.1-alpha-1.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -51,7 +51,7 @@ Performance improvements\n \n .. currentmodule:: django.test\n \n-Tests written using Django's :doc:`testing framework </topics/testing>` now run\n+Tests written using Django's :doc:`testing framework </topics/testing/index>` now run\n dramatically faster (as much as 10 times faster in many cases).\n \n This was accomplished through the introduction of transaction-based tests: when"
        },
        {
            "sha": "1555a9464ae687c6d8b5862c9ca59b4a91e284ee",
            "filename": "docs/releases/1.1-beta-1.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Freleases%2F1.1-beta-1.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Freleases%2F1.1-beta-1.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.1-beta-1.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -102,7 +102,7 @@ Testing improvements\n .. currentmodule:: django.test.client\n \n A couple of small but very useful improvements have been made to the\n-:doc:`testing framework </topics/testing>`:\n+:doc:`testing framework </topics/testing/index>`:\n \n * The test :class:`Client` now can automatically follow redirects with the\n   ``follow`` argument to :meth:`Client.get` and :meth:`Client.post`. This"
        },
        {
            "sha": "84af7fc1d98aef81d2eefeebfc1b283849227fca",
            "filename": "docs/releases/1.1.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Freleases%2F1.1.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Freleases%2F1.1.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.1.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -264,14 +264,14 @@ Testing improvements\n --------------------\n \n A few notable improvements have been made to the :doc:`testing framework\n-</topics/testing>`.\n+</topics/testing/index>`.\n \n Test performance improvements\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n .. currentmodule:: django.test\n \n-Tests written using Django's :doc:`testing framework </topics/testing>` now run\n+Tests written using Django's :doc:`testing framework </topics/testing/index>` now run\n dramatically faster (as much as 10 times faster in many cases).\n \n This was accomplished through the introduction of transaction-based tests: when"
        },
        {
            "sha": "82c5859b2cb51cf65cd89768cc45ec696139e4a6",
            "filename": "docs/topics/index.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Findex.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Findex.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Findex.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -13,7 +13,7 @@ Introductions to all the key parts of Django you'll need to know:\n    templates\n    class-based-views/index\n    files\n-   testing\n+   testing/index\n    auth\n    cache\n    conditional-view-processing"
        },
        {
            "sha": "0c3767d3e1234d481d0cd2f683d6591a40781521",
            "filename": "docs/topics/install.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Finstall.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Finstall.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Finstall.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -135,7 +135,7 @@ table once ``syncdb`` has created it. After creating a database user with these\n permissions, you'll specify the details in your project's settings file,\n see :setting:`DATABASES` for details.\n \n-If you're using Django's :doc:`testing framework</topics/testing>` to test\n+If you're using Django's :doc:`testing framework</topics/testing/index>` to test\n database queries, Django will need permission to create a test database.\n \n .. _PostgreSQL: http://www.postgresql.org/"
        },
        {
            "sha": "7211c0f3bee50e8eef6ae29a97e516fd26a806ed",
            "filename": "docs/topics/testing/_images/django_unittest_classes_hierarchy.graffle",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2F_images%2Fdjango_unittest_classes_hierarchy.graffle",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2F_images%2Fdjango_unittest_classes_hierarchy.graffle",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Ftesting%2F_images%2Fdjango_unittest_classes_hierarchy.graffle?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "previous_filename": "docs/topics/_images/django_unittest_classes_hierarchy.graffle"
        },
        {
            "sha": "cedaba22ac7f5e26690d43ddf9aa081c2c28eedb",
            "filename": "docs/topics/testing/_images/django_unittest_classes_hierarchy.pdf",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2F_images%2Fdjango_unittest_classes_hierarchy.pdf",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2F_images%2Fdjango_unittest_classes_hierarchy.pdf",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Ftesting%2F_images%2Fdjango_unittest_classes_hierarchy.pdf?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "previous_filename": "docs/topics/_images/django_unittest_classes_hierarchy.pdf"
        },
        {
            "sha": "0482f044dd8ce0593aa286b1f36a6383468a14eb",
            "filename": "docs/topics/testing/_images/django_unittest_classes_hierarchy.svg",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2F_images%2Fdjango_unittest_classes_hierarchy.svg",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2F_images%2Fdjango_unittest_classes_hierarchy.svg",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Ftesting%2F_images%2Fdjango_unittest_classes_hierarchy.svg?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "previous_filename": "docs/topics/_images/django_unittest_classes_hierarchy.svg"
        },
        {
            "sha": "0674b2e41b11d112d8789ba7e38bd43d51e0cb3d",
            "filename": "docs/topics/testing/advanced.txt",
            "status": "added",
            "additions": 429,
            "deletions": 0,
            "changes": 429,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2Fadvanced.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2Fadvanced.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Ftesting%2Fadvanced.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -0,0 +1,429 @@\n+=======================\n+Advanced testing topics\n+=======================\n+\n+The request factory\n+===================\n+\n+.. module:: django.test.client\n+\n+.. class:: RequestFactory\n+\n+The :class:`~django.test.client.RequestFactory` shares the same API as\n+the test client. However, instead of behaving like a browser, the\n+RequestFactory provides a way to generate a request instance that can\n+be used as the first argument to any view. This means you can test a\n+view function the same way as you would test any other function -- as\n+a black box, with exactly known inputs, testing for specific outputs.\n+\n+The API for the :class:`~django.test.client.RequestFactory` is a slightly\n+restricted subset of the test client API:\n+\n+* It only has access to the HTTP methods :meth:`~Client.get()`,\n+  :meth:`~Client.post()`, :meth:`~Client.put()`,\n+  :meth:`~Client.delete()`, :meth:`~Client.head()` and\n+  :meth:`~Client.options()`.\n+\n+* These methods accept all the same arguments *except* for\n+  ``follows``. Since this is just a factory for producing\n+  requests, it's up to you to handle the response.\n+\n+* It does not support middleware. Session and authentication\n+  attributes must be supplied by the test itself if required\n+  for the view to function properly.\n+\n+Example\n+-------\n+\n+The following is a simple unit test using the request factory::\n+\n+    from django.utils import unittest\n+    from django.test.client import RequestFactory\n+\n+    class SimpleTest(unittest.TestCase):\n+        def setUp(self):\n+            # Every test needs access to the request factory.\n+            self.factory = RequestFactory()\n+\n+        def test_details(self):\n+            # Create an instance of a GET request.\n+            request = self.factory.get('/customer/details')\n+\n+            # Test my_view() as if it were deployed at /customer/details\n+            response = my_view(request)\n+            self.assertEqual(response.status_code, 200)\n+\n+.. _topics-testing-advanced-multidb:\n+\n+Tests and multiple databases\n+============================\n+\n+.. _topics-testing-masterslave:\n+\n+Testing master/slave configurations\n+-----------------------------------\n+\n+If you're testing a multiple database configuration with master/slave\n+replication, this strategy of creating test databases poses a problem.\n+When the test databases are created, there won't be any replication,\n+and as a result, data created on the master won't be seen on the\n+slave.\n+\n+To compensate for this, Django allows you to define that a database is\n+a *test mirror*. Consider the following (simplified) example database\n+configuration::\n+\n+    DATABASES = {\n+        'default': {\n+            'ENGINE': 'django.db.backends.mysql',\n+            'NAME': 'myproject',\n+            'HOST': 'dbmaster',\n+             # ... plus some other settings\n+        },\n+        'slave': {\n+            'ENGINE': 'django.db.backends.mysql',\n+            'NAME': 'myproject',\n+            'HOST': 'dbslave',\n+            'TEST_MIRROR': 'default'\n+            # ... plus some other settings\n+        }\n+    }\n+\n+In this setup, we have two database servers: ``dbmaster``, described\n+by the database alias ``default``, and ``dbslave`` described by the\n+alias ``slave``. As you might expect, ``dbslave`` has been configured\n+by the database administrator as a read slave of ``dbmaster``, so in\n+normal activity, any write to ``default`` will appear on ``slave``.\n+\n+If Django created two independent test databases, this would break any\n+tests that expected replication to occur. However, the ``slave``\n+database has been configured as a test mirror (using the\n+:setting:`TEST_MIRROR` setting), indicating that under testing,\n+``slave`` should be treated as a mirror of ``default``.\n+\n+When the test environment is configured, a test version of ``slave``\n+will *not* be created. Instead the connection to ``slave``\n+will be redirected to point at ``default``. As a result, writes to\n+``default`` will appear on ``slave`` -- but because they are actually\n+the same database, not because there is data replication between the\n+two databases.\n+\n+.. _topics-testing-creation-dependencies:\n+\n+Controlling creation order for test databases\n+---------------------------------------------\n+\n+By default, Django will always create the ``default`` database first.\n+However, no guarantees are made on the creation order of any other\n+databases in your test setup.\n+\n+If your database configuration requires a specific creation order, you\n+can specify the dependencies that exist using the\n+:setting:`TEST_DEPENDENCIES` setting. Consider the following\n+(simplified) example database configuration::\n+\n+    DATABASES = {\n+        'default': {\n+             # ... db settings\n+             'TEST_DEPENDENCIES': ['diamonds']\n+        },\n+        'diamonds': {\n+            # ... db settings\n+        },\n+        'clubs': {\n+            # ... db settings\n+            'TEST_DEPENDENCIES': ['diamonds']\n+        },\n+        'spades': {\n+            # ... db settings\n+            'TEST_DEPENDENCIES': ['diamonds','hearts']\n+        },\n+        'hearts': {\n+            # ... db settings\n+            'TEST_DEPENDENCIES': ['diamonds','clubs']\n+        }\n+    }\n+\n+Under this configuration, the ``diamonds`` database will be created first,\n+as it is the only database alias without dependencies. The ``default`` and\n+``clubs`` alias will be created next (although the order of creation of this\n+pair is not guaranteed); then ``hearts``; and finally ``spades``.\n+\n+If there are any circular dependencies in the\n+:setting:`TEST_DEPENDENCIES` definition, an ``ImproperlyConfigured``\n+exception will be raised.\n+\n+Running tests outside the test runner\n+=====================================\n+\n+If you want to run tests outside of ``./manage.py test`` -- for example,\n+from a shell prompt -- you will need to set up the test\n+environment first. Django provides a convenience method to do this::\n+\n+    >>> from django.test.utils import setup_test_environment\n+    >>> setup_test_environment()\n+\n+This convenience method sets up the test database, and puts other\n+Django features into modes that allow for repeatable testing.\n+\n+The call to :meth:`~django.test.utils.setup_test_environment` is made\n+automatically as part of the setup of ``./manage.py test``. You only\n+need to manually invoke this method if you're not using running your\n+tests via Django's test runner.\n+\n+.. _other-testing-frameworks:\n+\n+Using different testing frameworks\n+==================================\n+\n+Clearly, :mod:`doctest` and :mod:`unittest` are not the only Python testing\n+frameworks. While Django doesn't provide explicit support for alternative\n+frameworks, it does provide a way to invoke tests constructed for an\n+alternative framework as if they were normal Django tests.\n+\n+When you run ``./manage.py test``, Django looks at the :setting:`TEST_RUNNER`\n+setting to determine what to do. By default, :setting:`TEST_RUNNER` points to\n+``'django.test.simple.DjangoTestSuiteRunner'``. This class defines the default Django\n+testing behavior. This behavior involves:\n+\n+#. Performing global pre-test setup.\n+\n+#. Looking for unit tests and doctests in the ``models.py`` and\n+   ``tests.py`` files in each installed application.\n+\n+#. Creating the test databases.\n+\n+#. Running ``syncdb`` to install models and initial data into the test\n+   databases.\n+\n+#. Running the unit tests and doctests that are found.\n+\n+#. Destroying the test databases.\n+\n+#. Performing global post-test teardown.\n+\n+If you define your own test runner class and point :setting:`TEST_RUNNER` at\n+that class, Django will execute your test runner whenever you run\n+``./manage.py test``. In this way, it is possible to use any test framework\n+that can be executed from Python code, or to modify the Django test execution\n+process to satisfy whatever testing requirements you may have.\n+\n+.. _topics-testing-test_runner:\n+\n+Defining a test runner\n+----------------------\n+\n+.. currentmodule:: django.test.simple\n+\n+A test runner is a class defining a ``run_tests()`` method. Django ships\n+with a ``DjangoTestSuiteRunner`` class that defines the default Django\n+testing behavior. This class defines the ``run_tests()`` entry point,\n+plus a selection of other methods that are used to by ``run_tests()`` to\n+set up, execute and tear down the test suite.\n+\n+.. class:: DjangoTestSuiteRunner(verbosity=1, interactive=True, failfast=True, **kwargs)\n+\n+    ``verbosity`` determines the amount of notification and debug information\n+    that will be printed to the console; ``0`` is no output, ``1`` is normal\n+    output, and ``2`` is verbose output.\n+\n+    If ``interactive`` is ``True``, the test suite has permission to ask the\n+    user for instructions when the test suite is executed. An example of this\n+    behavior would be asking for permission to delete an existing test\n+    database. If ``interactive`` is ``False``, the test suite must be able to\n+    run without any manual intervention.\n+\n+    If ``failfast`` is ``True``, the test suite will stop running after the\n+    first test failure is detected.\n+\n+    Django will, from time to time, extend the capabilities of\n+    the test runner by adding new arguments. The ``**kwargs`` declaration\n+    allows for this expansion. If you subclass ``DjangoTestSuiteRunner`` or\n+    write your own test runner, ensure accept and handle the ``**kwargs``\n+    parameter.\n+\n+    .. versionadded:: 1.4\n+\n+    Your test runner may also define additional command-line options.\n+    If you add an ``option_list`` attribute to a subclassed test runner,\n+    those options will be added to the list of command-line options that\n+    the :djadmin:`test` command can use.\n+\n+Attributes\n+~~~~~~~~~~\n+\n+.. attribute:: DjangoTestSuiteRunner.option_list\n+\n+    .. versionadded:: 1.4\n+\n+    This is the tuple of ``optparse`` options which will be fed into the\n+    management command's ``OptionParser`` for parsing arguments. See the\n+    documentation for Python's ``optparse`` module for more details.\n+\n+Methods\n+~~~~~~~\n+\n+.. method:: DjangoTestSuiteRunner.run_tests(test_labels, extra_tests=None, **kwargs)\n+\n+    Run the test suite.\n+\n+    ``test_labels`` is a list of strings describing the tests to be run. A test\n+    label can take one of three forms:\n+\n+    * ``app.TestCase.test_method`` -- Run a single test method in a test\n+      case.\n+    * ``app.TestCase`` -- Run all the test methods in a test case.\n+    * ``app`` -- Search for and run all tests in the named application.\n+\n+    If ``test_labels`` has a value of ``None``, the test runner should run\n+    search for tests in all the applications in :setting:`INSTALLED_APPS`.\n+\n+    ``extra_tests`` is a list of extra ``TestCase`` instances to add to the\n+    suite that is executed by the test runner. These extra tests are run\n+    in addition to those discovered in the modules listed in ``test_labels``.\n+\n+    This method should return the number of tests that failed.\n+\n+.. method:: DjangoTestSuiteRunner.setup_test_environment(**kwargs)\n+\n+    Sets up the test environment ready for testing.\n+\n+.. method:: DjangoTestSuiteRunner.build_suite(test_labels, extra_tests=None, **kwargs)\n+\n+    Constructs a test suite that matches the test labels provided.\n+\n+    ``test_labels`` is a list of strings describing the tests to be run. A test\n+    label can take one of three forms:\n+\n+    * ``app.TestCase.test_method`` -- Run a single test method in a test\n+      case.\n+    * ``app.TestCase`` -- Run all the test methods in a test case.\n+    * ``app`` -- Search for and run all tests in the named application.\n+\n+    If ``test_labels`` has a value of ``None``, the test runner should run\n+    search for tests in all the applications in :setting:`INSTALLED_APPS`.\n+\n+    ``extra_tests`` is a list of extra ``TestCase`` instances to add to the\n+    suite that is executed by the test runner. These extra tests are run\n+    in addition to those discovered in the modules listed in ``test_labels``.\n+\n+    Returns a ``TestSuite`` instance ready to be run.\n+\n+.. method:: DjangoTestSuiteRunner.setup_databases(**kwargs)\n+\n+    Creates the test databases.\n+\n+    Returns a data structure that provides enough detail to undo the changes\n+    that have been made. This data will be provided to the ``teardown_databases()``\n+    function at the conclusion of testing.\n+\n+.. method:: DjangoTestSuiteRunner.run_suite(suite, **kwargs)\n+\n+    Runs the test suite.\n+\n+    Returns the result produced by the running the test suite.\n+\n+.. method:: DjangoTestSuiteRunner.teardown_databases(old_config, **kwargs)\n+\n+    Destroys the test databases, restoring pre-test conditions.\n+\n+    ``old_config`` is a data structure defining the changes in the\n+    database configuration that need to be reversed. It is the return\n+    value of the ``setup_databases()`` method.\n+\n+.. method:: DjangoTestSuiteRunner.teardown_test_environment(**kwargs)\n+\n+    Restores the pre-test environment.\n+\n+.. method:: DjangoTestSuiteRunner.suite_result(suite, result, **kwargs)\n+\n+    Computes and returns a return code based on a test suite, and the result\n+    from that test suite.\n+\n+\n+Testing utilities\n+-----------------\n+\n+.. module:: django.test.utils\n+   :synopsis: Helpers to write custom test runners.\n+\n+To assist in the creation of your own test runner, Django provides a number of\n+utility methods in the ``django.test.utils`` module.\n+\n+.. function:: setup_test_environment()\n+\n+    Performs any global pre-test setup, such as the installing the\n+    instrumentation of the template rendering system and setting up\n+    the dummy email outbox.\n+\n+.. function:: teardown_test_environment()\n+\n+    Performs any global post-test teardown, such as removing the black\n+    magic hooks into the template system and restoring normal email\n+    services.\n+\n+.. currentmodule:: django.db.connection.creation\n+\n+The creation module of the database backend (``connection.creation``)\n+also provides some utilities that can be useful during testing.\n+\n+.. function:: create_test_db([verbosity=1, autoclobber=False])\n+\n+    Creates a new test database and runs ``syncdb`` against it.\n+\n+    ``verbosity`` has the same behavior as in ``run_tests()``.\n+\n+    ``autoclobber`` describes the behavior that will occur if a\n+    database with the same name as the test database is discovered:\n+\n+    * If ``autoclobber`` is ``False``, the user will be asked to\n+      approve destroying the existing database. ``sys.exit`` is\n+      called if the user does not approve.\n+\n+    * If autoclobber is ``True``, the database will be destroyed\n+      without consulting the user.\n+\n+    Returns the name of the test database that it created.\n+\n+    ``create_test_db()`` has the side effect of modifying the value of\n+    :setting:`NAME` in :setting:`DATABASES` to match the name of the test\n+    database.\n+\n+.. function:: destroy_test_db(old_database_name, [verbosity=1])\n+\n+    Destroys the database whose name is the value of :setting:`NAME` in\n+    :setting:`DATABASES`, and sets :setting:`NAME` to the value of\n+    ``old_database_name``.\n+\n+    The ``verbosity`` argument has the same behavior as for\n+    :class:`~django.test.simple.DjangoTestSuiteRunner`.\n+\n+.. _topics-testing-code-coverage:\n+\n+Integration with coverage.py\n+============================\n+\n+Code coverage describes how much source code has been tested. It shows which\n+parts of your code are being exercised by tests and which are not. It's an\n+important part of testing applications, so it's strongly recommended to check\n+the coverage of your tests.\n+\n+Django can be easily integrated with `coverage.py`_, a tool for measuring code\n+coverage of Python programs. First, `install coverage.py`_. Next, run the\n+following from your project folder containing ``manage.py``::\n+\n+   coverage run --source='.' manage.py test myapp\n+\n+This runs your tests and collects coverage data of the executed files in your\n+project. You can see a report of this data by typing following command::\n+\n+   coverage report\n+\n+Note that some Django code was executed while running tests, but it is not\n+listed here because of the ``source`` flag passed to the previous command.\n+\n+For more options like annotated HTML listings detailing missed lines, see the\n+`coverage.py`_ docs.\n+\n+.. _coverage.py: http://nedbatchelder.com/code/coverage/\n+.. _install coverage.py: http://pypi.python.org/pypi/coverage"
        },
        {
            "sha": "5036e946a97df296e6d851ca8a1594566aba3c7a",
            "filename": "docs/topics/testing/doctests.txt",
            "status": "added",
            "additions": 81,
            "deletions": 0,
            "changes": 81,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2Fdoctests.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2Fdoctests.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Ftesting%2Fdoctests.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -0,0 +1,81 @@\n+===================\n+Django and doctests\n+===================\n+\n+Doctests use Python's standard :mod:`doctest` module, which searches your\n+docstrings for statements that resemble a session of the Python interactive\n+interpreter. A full explanation of how :mod:`doctest` works is out of the scope\n+of this document; read Python's official documentation for the details.\n+\n+.. admonition:: What's a **docstring**?\n+\n+    A good explanation of docstrings (and some guidelines for using them\n+    effectively) can be found in :pep:`257`:\n+\n+        A docstring is a string literal that occurs as the first statement in\n+        a module, function, class, or method definition.  Such a docstring\n+        becomes the ``__doc__`` special attribute of that object.\n+\n+    For example, this function has a docstring that describes what it does::\n+\n+        def add_two(num):\n+            \"Return the result of adding two to the provided number.\"\n+            return num + 2\n+\n+    Because tests often make great documentation, putting tests directly in\n+    your docstrings is an effective way to document *and* test your code.\n+\n+As with unit tests, for a given Django application, the test runner looks for\n+doctests in two places:\n+\n+* The ``models.py`` file. You can define module-level doctests and/or a\n+  doctest for individual models. It's common practice to put\n+  application-level doctests in the module docstring and model-level\n+  doctests in the model docstrings.\n+\n+* A file called ``tests.py`` in the application directory -- i.e., the\n+  directory that holds ``models.py``. This file is a hook for any and all\n+  doctests you want to write that aren't necessarily related to models.\n+\n+This example doctest is equivalent to the example given in the unittest section\n+above::\n+\n+    # models.py\n+\n+    from django.db import models\n+\n+    class Animal(models.Model):\n+        \"\"\"\n+        An animal that knows how to make noise\n+\n+        # Create some animals\n+        >>> lion = Animal.objects.create(name=\"lion\", sound=\"roar\")\n+        >>> cat = Animal.objects.create(name=\"cat\", sound=\"meow\")\n+\n+        # Make 'em speak\n+        >>> lion.speak()\n+        'The lion says \"roar\"'\n+        >>> cat.speak()\n+        'The cat says \"meow\"'\n+        \"\"\"\n+        name = models.CharField(max_length=20)\n+        sound = models.CharField(max_length=20)\n+\n+        def speak(self):\n+            return 'The %s says \"%s\"' % (self.name, self.sound)\n+\n+When you :ref:`run your tests <running-tests>`, the test runner will find this\n+docstring, notice that portions of it look like an interactive Python session,\n+and execute those lines while checking that the results match.\n+\n+In the case of model tests, note that the test runner takes care of creating\n+its own test database. That is, any test that accesses a database -- by\n+creating and saving model instances, for example -- will not affect your\n+production database. However, the database is not refreshed between doctests,\n+so if your doctest requires a certain state you should consider flushing the\n+database or loading a fixture. (See the section on :ref:`fixtures\n+<topics-testing-fixtures>` for more on this.) Note that to use this feature,\n+the database user Django is connecting as must have ``CREATE DATABASE``\n+rights.\n+\n+For more details about :mod:`doctest`, see the Python documentation."
        },
        {
            "sha": "0345b72703369f3c5804085556f03dff6354f145",
            "filename": "docs/topics/testing/index.txt",
            "status": "added",
            "additions": 111,
            "deletions": 0,
            "changes": 111,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2Findex.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2Findex.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Ftesting%2Findex.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -0,0 +1,111 @@\n+=================\n+Testing in Django\n+=================\n+\n+.. toctree::\n+   :hidden:\n+\n+   overview\n+   doctests\n+   advanced\n+\n+Automated testing is an extremely useful bug-killing tool for the modern\n+Web developer. You can use a collection of tests -- a **test suite** -- to\n+solve, or avoid, a number of problems:\n+\n+* When you're writing new code, you can use tests to validate your code\n+  works as expected.\n+\n+* When you're refactoring or modifying old code, you can use tests to\n+  ensure your changes haven't affected your application's behavior\n+  unexpectedly.\n+\n+Testing a Web application is a complex task, because a Web application is made\n+of several layers of logic -- from HTTP-level request handling, to form\n+validation and processing, to template rendering. With Django's test-execution\n+framework and assorted utilities, you can simulate requests, insert test data,\n+inspect your application's output and generally verify your code is doing what\n+it should be doing.\n+\n+The best part is, it's really easy.\n+\n+Unit tests v. doctests\n+======================\n+\n+There are two primary ways to write tests with Django, corresponding to the\n+two test frameworks that ship in the Python standard library. The two\n+frameworks are:\n+\n+* **Unit tests** -- tests that are expressed as methods on a Python class\n+  that subclasses :class:`unittest.TestCase` or Django's customized\n+  :class:`TestCase`. For example::\n+\n+      import unittest\n+\n+      class MyFuncTestCase(unittest.TestCase):\n+          def testBasic(self):\n+              a = ['larry', 'curly', 'moe']\n+              self.assertEqual(my_func(a, 0), 'larry')\n+              self.assertEqual(my_func(a, 1), 'curly')\n+\n+* **Doctests** -- tests that are embedded in your functions' docstrings and\n+  are written in a way that emulates a session of the Python interactive\n+  interpreter. For example::\n+\n+      def my_func(a_list, idx):\n+          \"\"\"\n+          >>> a = ['larry', 'curly', 'moe']\n+          >>> my_func(a, 0)\n+          'larry'\n+          >>> my_func(a, 1)\n+          'curly'\n+          \"\"\"\n+          return a_list[idx]\n+\n+Which should I use?\n+-------------------\n+\n+Because Django supports both of the standard Python test frameworks, it's up to\n+you and your tastes to decide which one to use. You can even decide to use\n+*both*.\n+\n+For developers new to testing, however, this choice can seem confusing. Here,\n+then, are a few key differences to help you decide which approach is right for\n+you:\n+\n+* If you've been using Python for a while, :mod:`doctest` will probably feel\n+  more \"pythonic\". It's designed to make writing tests as easy as possible,\n+  so it requires no overhead of writing classes or methods. You simply put\n+  tests in docstrings. This has the added advantage of serving as\n+  documentation (and correct documentation, at that!). However, while\n+  doctests are good for some simple example code, they are not very good if\n+  you want to produce either high quality, comprehensive tests or high\n+  quality documentation. Test failures are often difficult to debug\n+  as it can be unclear exactly why the test failed. Thus, doctests should\n+  generally be avoided and used primarily for documentation examples only.\n+\n+* The :mod:`unittest` framework will probably feel very familiar to\n+  developers coming from Java. :mod:`unittest` is inspired by Java's JUnit,\n+  so you'll feel at home with this method if you've used JUnit or any test\n+  framework inspired by JUnit.\n+\n+* If you need to write a bunch of tests that share similar code, then\n+  you'll appreciate the :mod:`unittest` framework's organization around\n+  classes and methods. This makes it easy to abstract common tasks into\n+  common methods. The framework also supports explicit setup and/or cleanup\n+  routines, which give you a high level of control over the environment\n+  in which your test cases are run.\n+\n+* If you're writing tests for Django itself, you should use :mod:`unittest`.\n+\n+Where to go from here\n+=====================\n+\n+As unit tests are preferred in Django, we treat them in detail in the\n+:doc:`overview` document.\n+\n+:doc:`doctests` describes Django-specific features when using doctests.\n+\n+You can also use any *other* Python test framework, Django provides an API and\n+tools for that kind of integration. They are described in the\n+:ref:`other-testing-frameworks` section of :doc:`advanced`."
        },
        {
            "sha": "5f64789019b62062b86f4ddc588d6af57414ae63",
            "filename": "docs/topics/testing/overview.txt",
            "status": "renamed",
            "additions": 267,
            "deletions": 842,
            "changes": 1109,
            "blob_url": "https://github.com/django/django/blob/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2Foverview.txt",
            "raw_url": "https://github.com/django/django/raw/d19109fd37e75ccf29d2ca64370102753dbc7c5b/docs%2Ftopics%2Ftesting%2Foverview.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Ftesting%2Foverview.txt?ref=d19109fd37e75ccf29d2ca64370102753dbc7c5b",
            "patch": "@@ -5,69 +5,17 @@ Testing Django applications\n .. module:: django.test\n    :synopsis: Testing tools for Django applications.\n \n-Automated testing is an extremely useful bug-killing tool for the modern\n-Web developer. You can use a collection of tests -- a **test suite** -- to\n-solve, or avoid, a number of problems:\n+.. seealso::\n \n-* When you're writing new code, you can use tests to validate your code\n-  works as expected.\n+    The :doc:`testing tutorial </intro/tutorial05>` and the\n+    :doc:`advanced testing topics </topics/testing/advanced>`.\n \n-* When you're refactoring or modifying old code, you can use tests to\n-  ensure your changes haven't affected your application's behavior\n-  unexpectedly.\n-\n-Testing a Web application is a complex task, because a Web application is made\n-of several layers of logic -- from HTTP-level request handling, to form\n-validation and processing, to template rendering. With Django's test-execution\n-framework and assorted utilities, you can simulate requests, insert test data,\n-inspect your application's output and generally verify your code is doing what\n-it should be doing.\n-\n-The best part is, it's really easy.\n-\n-This document is split into two primary sections. First, we explain how to\n-write tests with Django. Then, we explain how to run them.\n+This document is split into two primary sections. First, we explain how to write\n+tests with Django. Then, we explain how to run them.\n \n Writing tests\n =============\n \n-There are two primary ways to write tests with Django, corresponding to the\n-two test frameworks that ship in the Python standard library. The two\n-frameworks are:\n-\n-* **Unit tests** -- tests that are expressed as methods on a Python class\n-  that subclasses :class:`unittest.TestCase` or Django's customized\n-  :class:`TestCase`. For example::\n-\n-      import unittest\n-\n-      class MyFuncTestCase(unittest.TestCase):\n-          def testBasic(self):\n-              a = ['larry', 'curly', 'moe']\n-              self.assertEqual(my_func(a, 0), 'larry')\n-              self.assertEqual(my_func(a, 1), 'curly')\n-\n-* **Doctests** -- tests that are embedded in your functions' docstrings and\n-  are written in a way that emulates a session of the Python interactive\n-  interpreter. For example::\n-\n-      def my_func(a_list, idx):\n-          \"\"\"\n-          >>> a = ['larry', 'curly', 'moe']\n-          >>> my_func(a, 0)\n-          'larry'\n-          >>> my_func(a, 1)\n-          'curly'\n-          \"\"\"\n-          return a_list[idx]\n-\n-We'll discuss choosing the appropriate test framework later, however, most\n-experienced developers prefer unit tests. You can also use any *other* Python\n-test framework, as we'll explain in a bit.\n-\n-Writing unit tests\n-------------------\n-\n Django's unit tests use a Python standard library module: :mod:`unittest`. This\n module defines tests in class-based approach.\n \n@@ -151,122 +99,6 @@ For more details about :mod:`unittest`, see the Python documentation.\n     applications the scope of tests you will be able to write this way will\n     be fairly limited, so it's easiest to use :class:`django.test.TestCase`.\n \n-Writing doctests\n-----------------\n-\n-Doctests use Python's standard :mod:`doctest` module, which searches your\n-docstrings for statements that resemble a session of the Python interactive\n-interpreter. A full explanation of how :mod:`doctest` works is out of the scope\n-of this document; read Python's official documentation for the details.\n-\n-.. admonition:: What's a **docstring**?\n-\n-    A good explanation of docstrings (and some guidelines for using them\n-    effectively) can be found in :pep:`257`:\n-\n-        A docstring is a string literal that occurs as the first statement in\n-        a module, function, class, or method definition.  Such a docstring\n-        becomes the ``__doc__`` special attribute of that object.\n-\n-    For example, this function has a docstring that describes what it does::\n-\n-        def add_two(num):\n-            \"Return the result of adding two to the provided number.\"\n-            return num + 2\n-\n-    Because tests often make great documentation, putting tests directly in\n-    your docstrings is an effective way to document *and* test your code.\n-\n-As with unit tests, for a given Django application, the test runner looks for\n-doctests in two places:\n-\n-* The ``models.py`` file. You can define module-level doctests and/or a\n-  doctest for individual models. It's common practice to put\n-  application-level doctests in the module docstring and model-level\n-  doctests in the model docstrings.\n-\n-* A file called ``tests.py`` in the application directory -- i.e., the\n-  directory that holds ``models.py``. This file is a hook for any and all\n-  doctests you want to write that aren't necessarily related to models.\n-\n-This example doctest is equivalent to the example given in the unittest section\n-above::\n-\n-    # models.py\n-\n-    from django.db import models\n-\n-    class Animal(models.Model):\n-        \"\"\"\n-        An animal that knows how to make noise\n-\n-        # Create some animals\n-        >>> lion = Animal.objects.create(name=\"lion\", sound=\"roar\")\n-        >>> cat = Animal.objects.create(name=\"cat\", sound=\"meow\")\n-\n-        # Make 'em speak\n-        >>> lion.speak()\n-        'The lion says \"roar\"'\n-        >>> cat.speak()\n-        'The cat says \"meow\"'\n-        \"\"\"\n-        name = models.CharField(max_length=20)\n-        sound = models.CharField(max_length=20)\n-\n-        def speak(self):\n-            return 'The %s says \"%s\"' % (self.name, self.sound)\n-\n-When you :ref:`run your tests <running-tests>`, the test runner will find this\n-docstring, notice that portions of it look like an interactive Python session,\n-and execute those lines while checking that the results match.\n-\n-In the case of model tests, note that the test runner takes care of creating\n-its own test database. That is, any test that accesses a database -- by\n-creating and saving model instances, for example -- will not affect your\n-production database. However, the database is not refreshed between doctests,\n-so if your doctest requires a certain state you should consider flushing the\n-database or loading a fixture. (See the section on fixtures, below, for more\n-on this.) Note that to use this feature, the database user Django is connecting\n-as must have ``CREATE DATABASE`` rights.\n-\n-For more details about :mod:`doctest`, see the Python documentation.\n-\n-Which should I use?\n--------------------\n-\n-Because Django supports both of the standard Python test frameworks, it's up to\n-you and your tastes to decide which one to use. You can even decide to use\n-*both*.\n-\n-For developers new to testing, however, this choice can seem confusing. Here,\n-then, are a few key differences to help you decide which approach is right for\n-you:\n-\n-* If you've been using Python for a while, :mod:`doctest` will probably feel\n-  more \"pythonic\". It's designed to make writing tests as easy as possible,\n-  so it requires no overhead of writing classes or methods. You simply put\n-  tests in docstrings. This has the added advantage of serving as\n-  documentation (and correct documentation, at that!). However, while\n-  doctests are good for some simple example code, they are not very good if\n-  you want to produce either high quality, comprehensive tests or high\n-  quality documentation. Test failures are often difficult to debug\n-  as it can be unclear exactly why the test failed. Thus, doctests should\n-  generally be avoided and used primarily for documentation examples only.\n-\n-* The :mod:`unittest` framework will probably feel very familiar to\n-  developers coming from Java. :mod:`unittest` is inspired by Java's JUnit,\n-  so you'll feel at home with this method if you've used JUnit or any test\n-  framework inspired by JUnit.\n-\n-* If you need to write a bunch of tests that share similar code, then\n-  you'll appreciate the :mod:`unittest` framework's organization around\n-  classes and methods. This makes it easy to abstract common tasks into\n-  common methods. The framework also supports explicit setup and/or cleanup\n-  routines, which give you a high level of control over the environment\n-  in which your test cases are run.\n-\n-* If you're writing tests for Django itself, you should use :mod:`unittest`.\n-\n .. _running-tests:\n \n Running tests\n@@ -341,23 +173,7 @@ be reported, and any test databases created by the run will not be destroyed.\n     flag areas in your code that aren't strictly wrong but could benefit\n     from a better implementation.\n \n-Running tests outside the test runner\n--------------------------------------\n-\n-If you want to run tests outside of ``./manage.py test`` -- for example,\n-from a shell prompt -- you will need to set up the test\n-environment first. Django provides a convenience method to do this::\n-\n-    >>> from django.test.utils import setup_test_environment\n-    >>> setup_test_environment()\n-\n-This convenience method sets up the test database, and puts other\n-Django features into modes that allow for repeatable testing.\n-\n-The call to :meth:`~django.test.utils.setup_test_environment` is made\n-automatically as part of the setup of ``./manage.py test``. You only\n-need to manually invoke this method if you're not using running your\n-tests via Django's test runner.\n+.. _the-test-database:\n \n The test database\n -----------------\n@@ -400,100 +216,9 @@ advanced settings.\n     your tests. *It is a bad idea to have such import-time database queries in\n     your code* anyway - rewrite your code so that it doesn't do this.\n \n-.. _topics-testing-masterslave:\n-\n-Testing master/slave configurations\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-If you're testing a multiple database configuration with master/slave\n-replication, this strategy of creating test databases poses a problem.\n-When the test databases are created, there won't be any replication,\n-and as a result, data created on the master won't be seen on the\n-slave.\n-\n-To compensate for this, Django allows you to define that a database is\n-a *test mirror*. Consider the following (simplified) example database\n-configuration::\n-\n-    DATABASES = {\n-        'default': {\n-            'ENGINE': 'django.db.backends.mysql',\n-            'NAME': 'myproject',\n-            'HOST': 'dbmaster',\n-             # ... plus some other settings\n-        },\n-        'slave': {\n-            'ENGINE': 'django.db.backends.mysql',\n-            'NAME': 'myproject',\n-            'HOST': 'dbslave',\n-            'TEST_MIRROR': 'default'\n-            # ... plus some other settings\n-        }\n-    }\n-\n-In this setup, we have two database servers: ``dbmaster``, described\n-by the database alias ``default``, and ``dbslave`` described by the\n-alias ``slave``. As you might expect, ``dbslave`` has been configured\n-by the database administrator as a read slave of ``dbmaster``, so in\n-normal activity, any write to ``default`` will appear on ``slave``.\n-\n-If Django created two independent test databases, this would break any\n-tests that expected replication to occur. However, the ``slave``\n-database has been configured as a test mirror (using the\n-:setting:`TEST_MIRROR` setting), indicating that under testing,\n-``slave`` should be treated as a mirror of ``default``.\n-\n-When the test environment is configured, a test version of ``slave``\n-will *not* be created. Instead the connection to ``slave``\n-will be redirected to point at ``default``. As a result, writes to\n-``default`` will appear on ``slave`` -- but because they are actually\n-the same database, not because there is data replication between the\n-two databases.\n-\n-.. _topics-testing-creation-dependencies:\n-\n-Controlling creation order for test databases\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-By default, Django will always create the ``default`` database first.\n-However, no guarantees are made on the creation order of any other\n-databases in your test setup.\n-\n-If your database configuration requires a specific creation order, you\n-can specify the dependencies that exist using the\n-:setting:`TEST_DEPENDENCIES` setting. Consider the following\n-(simplified) example database configuration::\n-\n-    DATABASES = {\n-        'default': {\n-             # ... db settings\n-             'TEST_DEPENDENCIES': ['diamonds']\n-        },\n-        'diamonds': {\n-            # ... db settings\n-        },\n-        'clubs': {\n-            # ... db settings\n-            'TEST_DEPENDENCIES': ['diamonds']\n-        },\n-        'spades': {\n-            # ... db settings\n-            'TEST_DEPENDENCIES': ['diamonds','hearts']\n-        },\n-        'hearts': {\n-            # ... db settings\n-            'TEST_DEPENDENCIES': ['diamonds','clubs']\n-        }\n-    }\n-\n-Under this configuration, the ``diamonds`` database will be created first,\n-as it is the only database alias without dependencies. The ``default`` and\n-``clubs`` alias will be created next (although the order of creation of this\n-pair is not guaranteed); then ``hearts``; and finally ``spades``.\n-\n-If there are any circular dependencies in the\n-:setting:`TEST_DEPENDENCIES` definition, an ``ImproperlyConfigured``\n-exception will be raised.\n+.. seealso::\n+\n+    The :ref:`advanced multi-db testing topics <topics-testing-advanced-multidb>`.\n \n Order in which tests are executed\n ---------------------------------\n@@ -610,36 +335,6 @@ to a faster hashing algorithm::\n Don't forget to also include in :setting:`PASSWORD_HASHERS` any hashing\n algorithm used in fixtures, if any.\n \n-.. _topics-testing-code-coverage:\n-\n-Integration with coverage.py\n-----------------------------\n-\n-Code coverage describes how much source code has been tested. It shows which\n-parts of your code are being exercised by tests and which are not. It's an\n-important part of testing applications, so it's strongly recommended to check\n-the coverage of your tests.\n-\n-Django can be easily integrated with `coverage.py`_, a tool for measuring code\n-coverage of Python programs. First, `install coverage.py`_. Next, run the\n-following from your project folder containing ``manage.py``::\n-\n-   coverage run --source='.' manage.py test myapp\n-\n-This runs your tests and collects coverage data of the executed files in your\n-project. You can see a report of this data by typing following command::\n-\n-   coverage report\n-\n-Note that some Django code was executed while running tests, but it is not\n-listed here because of the ``source`` flag passed to the previous command.\n-\n-For more options like annotated HTML listings detailing missed lines, see the\n-`coverage.py`_ docs.\n-\n-.. _coverage.py: http://nedbatchelder.com/code/coverage/\n-.. _install coverage.py: http://pypi.python.org/pypi/coverage\n-\n Testing tools\n =============\n \n@@ -1136,60 +831,12 @@ The following is a simple unit test using the test client::\n             # Check that the rendered context contains 5 customers.\n             self.assertEqual(len(response.context['customers']), 5)\n \n-The request factory\n--------------------\n-\n-.. class:: RequestFactory\n-\n-The :class:`~django.test.client.RequestFactory` shares the same API as\n-the test client. However, instead of behaving like a browser, the\n-RequestFactory provides a way to generate a request instance that can\n-be used as the first argument to any view. This means you can test a\n-view function the same way as you would test any other function -- as\n-a black box, with exactly known inputs, testing for specific outputs.\n-\n-The API for the :class:`~django.test.client.RequestFactory` is a slightly\n-restricted subset of the test client API:\n-\n-* It only has access to the HTTP methods :meth:`~Client.get()`,\n-  :meth:`~Client.post()`, :meth:`~Client.put()`,\n-  :meth:`~Client.delete()`, :meth:`~Client.head()` and\n-  :meth:`~Client.options()`.\n-\n-* These methods accept all the same arguments *except* for\n-  ``follows``. Since this is just a factory for producing\n-  requests, it's up to you to handle the response.\n-\n-* It does not support middleware. Session and authentication\n-  attributes must be supplied by the test itself if required\n-  for the view to function properly.\n-\n-Example\n-~~~~~~~\n-\n-The following is a simple unit test using the request factory::\n-\n-    from django.utils import unittest\n-    from django.test.client import RequestFactory\n-\n-    class SimpleTest(unittest.TestCase):\n-        def setUp(self):\n-            # Every test needs access to the request factory.\n-            self.factory = RequestFactory()\n-\n-        def test_details(self):\n-            # Create an instance of a GET request.\n-            request = self.factory.get('/customer/details')\n-\n-            # Test my_view() as if it were deployed at /customer/details\n-            response = my_view(request)\n-            self.assertEqual(response.status_code, 200)\n+.. seealso::\n \n-Test cases\n-----------\n+    :class:`django.test.client.RequestFactory`\n \n Provided test case classes\n-~~~~~~~~~~~~~~~~~~~~~~~~~~\n+--------------------------\n \n .. currentmodule:: django.test\n \n@@ -1208,37 +855,39 @@ Normal Python unit test classes extend a base class of\n Regardless of the version of Python you're using, if you've installed\n :mod:`unittest2`, :mod:`django.utils.unittest` will point to that library.\n \n-TestCase\n-^^^^^^^^\n-\n-.. class:: TestCase()\n+SimpleTestCase\n+~~~~~~~~~~~~~~\n \n-This class provides some additional capabilities that can be useful for testing\n-Web sites.\n+.. class:: SimpleTestCase()\n \n-Converting a normal :class:`unittest.TestCase` to a Django :class:`TestCase` is\n-easy: Just change the base class of your test from `'unittest.TestCase'` to\n-`'django.test.TestCase'`. All of the standard Python unit test functionality\n-will continue to be available, but it will be augmented with some useful\n-additions, including:\n+.. versionadded:: 1.4\n \n-* Automatic loading of fixtures.\n+A very thin subclass of :class:`unittest.TestCase`, it extends it with some\n+basic functionality like:\n \n-* Wraps each test in a transaction.\n+* Saving and restoring the Python warning machinery state.\n+* Checking that a callable :meth:`raises a certain exception <SimpleTestCase.assertRaisesMessage>`.\n+* :meth:`Testing form field rendering <SimpleTestCase.assertFieldOutput>`.\n+* Testing server :ref:`HTML responses for the presence/lack of a given fragment <assertions>`.\n+* The ability to run tests with :ref:`modified settings <overriding-settings>`\n \n-* Creates a TestClient instance.\n+If you need any of the other more complex and heavyweight Django-specific\n+features like:\n \n-* Django-specific assertions for testing for things like redirection and form\n-  errors.\n+* Using the :attr:`~TestCase.client` :class:`~django.test.client.Client`.\n+* Testing or using the ORM.\n+* Database :attr:`~TestCase.fixtures`.\n+* Custom test-time :attr:`URL maps <TestCase.urls>`.\n+* Test :ref:`skipping based on database backend features <skipping-tests>`.\n+* The remaining specialized :ref:`assert* <assertions>` methods.\n \n-.. versionchanged:: 1.5\n-    The order in which tests are run has changed. See `Order in which tests are\n-    executed`_.\n+then you should use :class:`~django.test.TransactionTestCase` or\n+:class:`~django.test.TestCase` instead.\n \n-``TestCase`` inherits from :class:`~django.test.TransactionTestCase`.\n+``SimpleTestCase`` inherits from :class:`django.utils.unittest.TestCase`.\n \n TransactionTestCase\n-^^^^^^^^^^^^^^^^^^^\n+~~~~~~~~~~~~~~~~~~~\n \n .. class:: TransactionTestCase()\n \n@@ -1309,121 +958,270 @@ to test the effects of commit and rollback:\n     Using ``reset_sequences = True`` will slow down the test, since the primary\n     key reset is an relatively expensive database operation.\n \n-SimpleTestCase\n-^^^^^^^^^^^^^^\n-\n-.. class:: SimpleTestCase()\n+TestCase\n+~~~~~~~~\n \n-.. versionadded:: 1.4\n+.. class:: TestCase()\n \n-A very thin subclass of :class:`unittest.TestCase`, it extends it with some\n-basic functionality like:\n+This class provides some additional capabilities that can be useful for testing\n+Web sites.\n \n-* Saving and restoring the Python warning machinery state.\n-* Checking that a callable :meth:`raises a certain exception <SimpleTestCase.assertRaisesMessage>`.\n-* :meth:`Testing form field rendering <SimpleTestCase.assertFieldOutput>`.\n-* Testing server :ref:`HTML responses for the presence/lack of a given fragment <assertions>`.\n-* The ability to run tests with :ref:`modified settings <overriding-settings>`\n+Converting a normal :class:`unittest.TestCase` to a Django :class:`TestCase` is\n+easy: Just change the base class of your test from `'unittest.TestCase'` to\n+`'django.test.TestCase'`. All of the standard Python unit test functionality\n+will continue to be available, but it will be augmented with some useful\n+additions, including:\n \n-If you need any of the other more complex and heavyweight Django-specific\n-features like:\n+* Automatic loading of fixtures.\n \n-* Using the :attr:`~TestCase.client` :class:`~django.test.client.Client`.\n-* Testing or using the ORM.\n-* Database :attr:`~TestCase.fixtures`.\n-* Custom test-time :attr:`URL maps <TestCase.urls>`.\n-* Test :ref:`skipping based on database backend features <skipping-tests>`.\n-* The remaining specialized :ref:`assert* <assertions>` methods.\n+* Wraps each test in a transaction.\n \n-then you should use :class:`~django.test.TransactionTestCase` or\n-:class:`~django.test.TestCase` instead.\n+* Creates a TestClient instance.\n \n-``SimpleTestCase`` inherits from :class:`django.utils.unittest.TestCase`.\n+* Django-specific assertions for testing for things like redirection and form\n+  errors.\n \n-Default test client\n-~~~~~~~~~~~~~~~~~~~\n+.. versionchanged:: 1.5\n+    The order in which tests are run has changed. See `Order in which tests are\n+    executed`_.\n \n-.. attribute:: TestCase.client\n+``TestCase`` inherits from :class:`~django.test.TransactionTestCase`.\n \n-Every test case in a ``django.test.TestCase`` instance has access to an\n-instance of a Django test client. This client can be accessed as\n-``self.client``. This client is recreated for each test, so you don't have to\n-worry about state (such as cookies) carrying over from one test to another.\n+.. _live-test-server:\n \n-This means, instead of instantiating a ``Client`` in each test::\n+LiveServerTestCase\n+~~~~~~~~~~~~~~~~~~\n \n-    from django.utils import unittest\n-    from django.test.client import Client\n+.. versionadded:: 1.4\n \n-    class SimpleTest(unittest.TestCase):\n-        def test_details(self):\n-            client = Client()\n-            response = client.get('/customer/details/')\n-            self.assertEqual(response.status_code, 200)\n+.. class:: LiveServerTestCase()\n \n-        def test_index(self):\n-            client = Client()\n-            response = client.get('/customer/index/')\n-            self.assertEqual(response.status_code, 200)\n+``LiveServerTestCase`` does basically the same as\n+:class:`~django.test.TransactionTestCase` with one extra feature: it launches a\n+live Django server in the background on setup, and shuts it down on teardown.\n+This allows the use of automated test clients other than the\n+:ref:`Django dummy client <test-client>` such as, for example, the Selenium_\n+client, to execute a series of functional tests inside a browser and simulate a\n+real user's actions.\n \n-...you can just refer to ``self.client``, like so::\n+By default the live server's address is `'localhost:8081'` and the full URL\n+can be accessed during the tests with ``self.live_server_url``. If you'd like\n+to change the default address (in the case, for example, where the 8081 port is\n+already taken) then you may pass a different one to the :djadmin:`test` command\n+via the :djadminopt:`--liveserver` option, for example:\n \n-    from django.test import TestCase\n+.. code-block:: bash\n \n-    class SimpleTest(TestCase):\n-        def test_details(self):\n-            response = self.client.get('/customer/details/')\n-            self.assertEqual(response.status_code, 200)\n+    ./manage.py test --liveserver=localhost:8082\n \n-        def test_index(self):\n-            response = self.client.get('/customer/index/')\n-            self.assertEqual(response.status_code, 200)\n+Another way of changing the default server address is by setting the\n+`DJANGO_LIVE_TEST_SERVER_ADDRESS` environment variable somewhere in your\n+code (for example, in a :ref:`custom test runner<topics-testing-test_runner>`):\n \n-Customizing the test client\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+.. code-block:: python\n \n-.. attribute:: TestCase.client_class\n+    import os\n+    os.environ['DJANGO_LIVE_TEST_SERVER_ADDRESS'] = 'localhost:8082'\n \n-If you want to use a different ``Client`` class (for example, a subclass\n-with customized behavior), use the :attr:`~TestCase.client_class` class\n-attribute::\n+In the case where the tests are run by multiple processes in parallel (for\n+example, in the context of several simultaneous `continuous integration`_\n+builds), the processes will compete for the same address, and therefore your\n+tests might randomly fail with an \"Address already in use\" error. To avoid this\n+problem, you can pass a comma-separated list of ports or ranges of ports (at\n+least as many as the number of potential parallel processes). For example:\n \n-    from django.test import TestCase\n-    from django.test.client import Client\n+.. code-block:: bash\n \n-    class MyTestClient(Client):\n-        # Specialized methods for your environment...\n+    ./manage.py test --liveserver=localhost:8082,8090-8100,9000-9200,7041\n \n-    class MyTest(TestCase):\n-        client_class = MyTestClient\n+Then, during test execution, each new live test server will try every specified\n+port until it finds one that is free and takes it.\n \n-        def test_my_stuff(self):\n-            # Here self.client is an instance of MyTestClient...\n-            call_some_test_code()\n+.. _continuous integration: http://en.wikipedia.org/wiki/Continuous_integration\n \n-.. _topics-testing-fixtures:\n+To demonstrate how to use ``LiveServerTestCase``, let's write a simple Selenium\n+test. First of all, you need to install the `selenium package`_ into your\n+Python path:\n \n-Fixture loading\n-~~~~~~~~~~~~~~~\n+.. code-block:: bash\n \n-.. attribute:: TestCase.fixtures\n+   pip install selenium\n \n-A test case for a database-backed Web site isn't much use if there isn't any\n-data in the database. To make it easy to put test data into the database,\n-Django's custom ``TestCase`` class provides a way of loading **fixtures**.\n+Then, add a ``LiveServerTestCase``-based test to your app's tests module\n+(for example: ``myapp/tests.py``). The code for this test may look as follows:\n \n-A fixture is a collection of data that Django knows how to import into a\n-database. For example, if your site has user accounts, you might set up a\n-fixture of fake user accounts in order to populate your database during tests.\n+.. code-block:: python\n \n-The most straightforward way of creating a fixture is to use the\n-:djadmin:`manage.py dumpdata <dumpdata>` command. This assumes you\n-already have some data in your database. See the :djadmin:`dumpdata\n-documentation<dumpdata>` for more details.\n+    from django.test import LiveServerTestCase\n+    from selenium.webdriver.firefox.webdriver import WebDriver\n \n-.. note::\n+    class MySeleniumTests(LiveServerTestCase):\n+        fixtures = ['user-data.json']\n \n-    If you've ever run :djadmin:`manage.py syncdb<syncdb>`, you've\n+        @classmethod\n+        def setUpClass(cls):\n+            cls.selenium = WebDriver()\n+            super(MySeleniumTests, cls).setUpClass()\n+\n+        @classmethod\n+        def tearDownClass(cls):\n+            cls.selenium.quit()\n+            super(MySeleniumTests, cls).tearDownClass()\n+\n+        def test_login(self):\n+            self.selenium.get('%s%s' % (self.live_server_url, '/login/'))\n+            username_input = self.selenium.find_element_by_name(\"username\")\n+            username_input.send_keys('myuser')\n+            password_input = self.selenium.find_element_by_name(\"password\")\n+            password_input.send_keys('secret')\n+            self.selenium.find_element_by_xpath('//input[@value=\"Log in\"]').click()\n+\n+Finally, you may run the test as follows:\n+\n+.. code-block:: bash\n+\n+    ./manage.py test myapp.MySeleniumTests.test_login\n+\n+This example will automatically open Firefox then go to the login page, enter\n+the credentials and press the \"Log in\" button. Selenium offers other drivers in\n+case you do not have Firefox installed or wish to use another browser. The\n+example above is just a tiny fraction of what the Selenium client can do; check\n+out the `full reference`_ for more details.\n+\n+.. _Selenium: http://seleniumhq.org/\n+.. _selenium package: http://pypi.python.org/pypi/selenium\n+.. _full reference: http://selenium-python.readthedocs.org/en/latest/api.html\n+.. _Firefox: http://www.mozilla.com/firefox/\n+\n+.. note::\n+\n+    ``LiveServerTestCase`` makes use of the :doc:`staticfiles contrib app\n+    </howto/static-files>` so you'll need to have your project configured\n+    accordingly (in particular by setting :setting:`STATIC_URL`).\n+\n+.. note::\n+\n+    When using an in-memory SQLite database to run the tests, the same database\n+    connection will be shared by two threads in parallel: the thread in which\n+    the live server is run and the thread in which the test case is run. It's\n+    important to prevent simultaneous database queries via this shared\n+    connection by the two threads, as that may sometimes randomly cause the\n+    tests to fail. So you need to ensure that the two threads don't access the\n+    database at the same time. In particular, this means that in some cases\n+    (for example, just after clicking a link or submitting a form), you might\n+    need to check that a response is received by Selenium and that the next\n+    page is loaded before proceeding with further test execution.\n+    Do this, for example, by making Selenium wait until the `<body>` HTML tag\n+    is found in the response (requires Selenium > 2.13):\n+\n+    .. code-block:: python\n+\n+        def test_login(self):\n+            from selenium.webdriver.support.wait import WebDriverWait\n+            timeout = 2\n+            ...\n+            self.selenium.find_element_by_xpath('//input[@value=\"Log in\"]').click()\n+            # Wait until the response is received\n+            WebDriverWait(self.selenium, timeout).until(\n+                lambda driver: driver.find_element_by_tag_name('body'))\n+\n+    The tricky thing here is that there's really no such thing as a \"page load,\"\n+    especially in modern Web apps that generate HTML dynamically after the\n+    server generates the initial document. So, simply checking for the presence\n+    of `<body>` in the response might not necessarily be appropriate for all\n+    use cases. Please refer to the `Selenium FAQ`_ and\n+    `Selenium documentation`_ for more information.\n+\n+    .. _Selenium FAQ: http://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions#Q:_WebDriver_fails_to_find_elements_/_Does_not_block_on_page_loa\n+    .. _Selenium documentation: http://seleniumhq.org/docs/04_webdriver_advanced.html#explicit-waits\n+\n+Test cases features\n+-------------------\n+\n+Default test client\n+~~~~~~~~~~~~~~~~~~~\n+\n+.. attribute:: TestCase.client\n+\n+Every test case in a ``django.test.TestCase`` instance has access to an\n+instance of a Django test client. This client can be accessed as\n+``self.client``. This client is recreated for each test, so you don't have to\n+worry about state (such as cookies) carrying over from one test to another.\n+\n+This means, instead of instantiating a ``Client`` in each test::\n+\n+    from django.utils import unittest\n+    from django.test.client import Client\n+\n+    class SimpleTest(unittest.TestCase):\n+        def test_details(self):\n+            client = Client()\n+            response = client.get('/customer/details/')\n+            self.assertEqual(response.status_code, 200)\n+\n+        def test_index(self):\n+            client = Client()\n+            response = client.get('/customer/index/')\n+            self.assertEqual(response.status_code, 200)\n+\n+...you can just refer to ``self.client``, like so::\n+\n+    from django.test import TestCase\n+\n+    class SimpleTest(TestCase):\n+        def test_details(self):\n+            response = self.client.get('/customer/details/')\n+            self.assertEqual(response.status_code, 200)\n+\n+        def test_index(self):\n+            response = self.client.get('/customer/index/')\n+            self.assertEqual(response.status_code, 200)\n+\n+Customizing the test client\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+.. attribute:: TestCase.client_class\n+\n+If you want to use a different ``Client`` class (for example, a subclass\n+with customized behavior), use the :attr:`~TestCase.client_class` class\n+attribute::\n+\n+    from django.test import TestCase\n+    from django.test.client import Client\n+\n+    class MyTestClient(Client):\n+        # Specialized methods for your environment...\n+\n+    class MyTest(TestCase):\n+        client_class = MyTestClient\n+\n+        def test_my_stuff(self):\n+            # Here self.client is an instance of MyTestClient...\n+            call_some_test_code()\n+\n+.. _topics-testing-fixtures:\n+\n+Fixture loading\n+~~~~~~~~~~~~~~~\n+\n+.. attribute:: TestCase.fixtures\n+\n+A test case for a database-backed Web site isn't much use if there isn't any\n+data in the database. To make it easy to put test data into the database,\n+Django's custom ``TestCase`` class provides a way of loading **fixtures**.\n+\n+A fixture is a collection of data that Django knows how to import into a\n+database. For example, if your site has user accounts, you might set up a\n+fixture of fake user accounts in order to populate your database during tests.\n+\n+The most straightforward way of creating a fixture is to use the\n+:djadmin:`manage.py dumpdata <dumpdata>` command. This assumes you\n+already have some data in your database. See the :djadmin:`dumpdata\n+documentation<dumpdata>` for more details.\n+\n+.. note::\n+\n+    If you've ever run :djadmin:`manage.py syncdb<syncdb>`, you've\n     already used a fixture without even knowing it! When you call\n     :djadmin:`syncdb` in the database for the first time, Django\n     installs a fixture called ``initial_data``. This gives you a way\n@@ -1638,7 +1436,7 @@ Emptying the test outbox\n If you use Django's custom ``TestCase`` class, the test runner will clear the\n contents of the test email outbox at the start of each test case.\n \n-For more detail on email services during tests, see `Email services`_.\n+For more detail on email services during tests, see `Email services`_ below.\n \n .. _assertions:\n \n@@ -1984,376 +1782,3 @@ under MySQL with MyISAM tables)::\n         @skipUnlessDBFeature('supports_transactions')\n         def test_transaction_behavior(self):\n             # ... conditional test code\n-\n-Live test server\n-----------------\n-\n-.. versionadded:: 1.4\n-\n-.. currentmodule:: django.test\n-\n-.. class:: LiveServerTestCase()\n-\n-``LiveServerTestCase`` does basically the same as\n-:class:`~django.test.TransactionTestCase` with one extra feature: it launches a\n-live Django server in the background on setup, and shuts it down on teardown.\n-This allows the use of automated test clients other than the\n-:ref:`Django dummy client <test-client>` such as, for example, the Selenium_\n-client, to execute a series of functional tests inside a browser and simulate a\n-real user's actions.\n-\n-By default the live server's address is `'localhost:8081'` and the full URL\n-can be accessed during the tests with ``self.live_server_url``. If you'd like\n-to change the default address (in the case, for example, where the 8081 port is\n-already taken) then you may pass a different one to the :djadmin:`test` command\n-via the :djadminopt:`--liveserver` option, for example:\n-\n-.. code-block:: bash\n-\n-    ./manage.py test --liveserver=localhost:8082\n-\n-Another way of changing the default server address is by setting the\n-`DJANGO_LIVE_TEST_SERVER_ADDRESS` environment variable somewhere in your\n-code (for example, in a :ref:`custom test runner<topics-testing-test_runner>`):\n-\n-.. code-block:: python\n-\n-    import os\n-    os.environ['DJANGO_LIVE_TEST_SERVER_ADDRESS'] = 'localhost:8082'\n-\n-In the case where the tests are run by multiple processes in parallel (for\n-example, in the context of several simultaneous `continuous integration`_\n-builds), the processes will compete for the same address, and therefore your\n-tests might randomly fail with an \"Address already in use\" error. To avoid this\n-problem, you can pass a comma-separated list of ports or ranges of ports (at\n-least as many as the number of potential parallel processes). For example:\n-\n-.. code-block:: bash\n-\n-    ./manage.py test --liveserver=localhost:8082,8090-8100,9000-9200,7041\n-\n-Then, during test execution, each new live test server will try every specified\n-port until it finds one that is free and takes it.\n-\n-.. _continuous integration: http://en.wikipedia.org/wiki/Continuous_integration\n-\n-To demonstrate how to use ``LiveServerTestCase``, let's write a simple Selenium\n-test. First of all, you need to install the `selenium package`_ into your\n-Python path:\n-\n-.. code-block:: bash\n-\n-   pip install selenium\n-\n-Then, add a ``LiveServerTestCase``-based test to your app's tests module\n-(for example: ``myapp/tests.py``). The code for this test may look as follows:\n-\n-.. code-block:: python\n-\n-    from django.test import LiveServerTestCase\n-    from selenium.webdriver.firefox.webdriver import WebDriver\n-\n-    class MySeleniumTests(LiveServerTestCase):\n-        fixtures = ['user-data.json']\n-\n-        @classmethod\n-        def setUpClass(cls):\n-            cls.selenium = WebDriver()\n-            super(MySeleniumTests, cls).setUpClass()\n-\n-        @classmethod\n-        def tearDownClass(cls):\n-            cls.selenium.quit()\n-            super(MySeleniumTests, cls).tearDownClass()\n-\n-        def test_login(self):\n-            self.selenium.get('%s%s' % (self.live_server_url, '/login/'))\n-            username_input = self.selenium.find_element_by_name(\"username\")\n-            username_input.send_keys('myuser')\n-            password_input = self.selenium.find_element_by_name(\"password\")\n-            password_input.send_keys('secret')\n-            self.selenium.find_element_by_xpath('//input[@value=\"Log in\"]').click()\n-\n-Finally, you may run the test as follows:\n-\n-.. code-block:: bash\n-\n-    ./manage.py test myapp.MySeleniumTests.test_login\n-\n-This example will automatically open Firefox then go to the login page, enter\n-the credentials and press the \"Log in\" button. Selenium offers other drivers in\n-case you do not have Firefox installed or wish to use another browser. The\n-example above is just a tiny fraction of what the Selenium client can do; check\n-out the `full reference`_ for more details.\n-\n-.. _Selenium: http://seleniumhq.org/\n-.. _selenium package: http://pypi.python.org/pypi/selenium\n-.. _full reference: http://selenium-python.readthedocs.org/en/latest/api.html\n-.. _Firefox: http://www.mozilla.com/firefox/\n-\n-.. note::\n-\n-    ``LiveServerTestCase`` makes use of the :doc:`staticfiles contrib app\n-    </howto/static-files>` so you'll need to have your project configured\n-    accordingly (in particular by setting :setting:`STATIC_URL`).\n-\n-.. note::\n-\n-    When using an in-memory SQLite database to run the tests, the same database\n-    connection will be shared by two threads in parallel: the thread in which\n-    the live server is run and the thread in which the test case is run. It's\n-    important to prevent simultaneous database queries via this shared\n-    connection by the two threads, as that may sometimes randomly cause the\n-    tests to fail. So you need to ensure that the two threads don't access the\n-    database at the same time. In particular, this means that in some cases\n-    (for example, just after clicking a link or submitting a form), you might\n-    need to check that a response is received by Selenium and that the next\n-    page is loaded before proceeding with further test execution.\n-    Do this, for example, by making Selenium wait until the `<body>` HTML tag\n-    is found in the response (requires Selenium > 2.13):\n-\n-    .. code-block:: python\n-\n-        def test_login(self):\n-            from selenium.webdriver.support.wait import WebDriverWait\n-            timeout = 2\n-            ...\n-            self.selenium.find_element_by_xpath('//input[@value=\"Log in\"]').click()\n-            # Wait until the response is received\n-            WebDriverWait(self.selenium, timeout).until(\n-                lambda driver: driver.find_element_by_tag_name('body'))\n-\n-    The tricky thing here is that there's really no such thing as a \"page load,\"\n-    especially in modern Web apps that generate HTML dynamically after the\n-    server generates the initial document. So, simply checking for the presence\n-    of `<body>` in the response might not necessarily be appropriate for all\n-    use cases. Please refer to the `Selenium FAQ`_ and\n-    `Selenium documentation`_ for more information.\n-\n-    .. _Selenium FAQ: http://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions#Q:_WebDriver_fails_to_find_elements_/_Does_not_block_on_page_loa\n-    .. _Selenium documentation: http://seleniumhq.org/docs/04_webdriver_advanced.html#explicit-waits\n-\n-Using different testing frameworks\n-==================================\n-\n-Clearly, :mod:`doctest` and :mod:`unittest` are not the only Python testing\n-frameworks. While Django doesn't provide explicit support for alternative\n-frameworks, it does provide a way to invoke tests constructed for an\n-alternative framework as if they were normal Django tests.\n-\n-When you run ``./manage.py test``, Django looks at the :setting:`TEST_RUNNER`\n-setting to determine what to do. By default, :setting:`TEST_RUNNER` points to\n-``'django.test.simple.DjangoTestSuiteRunner'``. This class defines the default Django\n-testing behavior. This behavior involves:\n-\n-#. Performing global pre-test setup.\n-\n-#. Looking for unit tests and doctests in the ``models.py`` and\n-   ``tests.py`` files in each installed application.\n-\n-#. Creating the test databases.\n-\n-#. Running ``syncdb`` to install models and initial data into the test\n-   databases.\n-\n-#. Running the unit tests and doctests that are found.\n-\n-#. Destroying the test databases.\n-\n-#. Performing global post-test teardown.\n-\n-If you define your own test runner class and point :setting:`TEST_RUNNER` at\n-that class, Django will execute your test runner whenever you run\n-``./manage.py test``. In this way, it is possible to use any test framework\n-that can be executed from Python code, or to modify the Django test execution\n-process to satisfy whatever testing requirements you may have.\n-\n-.. _topics-testing-test_runner:\n-\n-Defining a test runner\n-----------------------\n-\n-.. currentmodule:: django.test.simple\n-\n-A test runner is a class defining a ``run_tests()`` method. Django ships\n-with a ``DjangoTestSuiteRunner`` class that defines the default Django\n-testing behavior. This class defines the ``run_tests()`` entry point,\n-plus a selection of other methods that are used to by ``run_tests()`` to\n-set up, execute and tear down the test suite.\n-\n-.. class:: DjangoTestSuiteRunner(verbosity=1, interactive=True, failfast=True, **kwargs)\n-\n-    ``verbosity`` determines the amount of notification and debug information\n-    that will be printed to the console; ``0`` is no output, ``1`` is normal\n-    output, and ``2`` is verbose output.\n-\n-    If ``interactive`` is ``True``, the test suite has permission to ask the\n-    user for instructions when the test suite is executed. An example of this\n-    behavior would be asking for permission to delete an existing test\n-    database. If ``interactive`` is ``False``, the test suite must be able to\n-    run without any manual intervention.\n-\n-    If ``failfast`` is ``True``, the test suite will stop running after the\n-    first test failure is detected.\n-\n-    Django will, from time to time, extend the capabilities of\n-    the test runner by adding new arguments. The ``**kwargs`` declaration\n-    allows for this expansion. If you subclass ``DjangoTestSuiteRunner`` or\n-    write your own test runner, ensure accept and handle the ``**kwargs``\n-    parameter.\n-\n-    .. versionadded:: 1.4\n-\n-    Your test runner may also define additional command-line options.\n-    If you add an ``option_list`` attribute to a subclassed test runner,\n-    those options will be added to the list of command-line options that\n-    the :djadmin:`test` command can use.\n-\n-Attributes\n-~~~~~~~~~~\n-\n-.. attribute:: DjangoTestSuiteRunner.option_list\n-\n-    .. versionadded:: 1.4\n-\n-    This is the tuple of ``optparse`` options which will be fed into the\n-    management command's ``OptionParser`` for parsing arguments. See the\n-    documentation for Python's ``optparse`` module for more details.\n-\n-Methods\n-~~~~~~~\n-\n-.. method:: DjangoTestSuiteRunner.run_tests(test_labels, extra_tests=None, **kwargs)\n-\n-    Run the test suite.\n-\n-    ``test_labels`` is a list of strings describing the tests to be run. A test\n-    label can take one of three forms:\n-\n-    * ``app.TestCase.test_method`` -- Run a single test method in a test\n-      case.\n-    * ``app.TestCase`` -- Run all the test methods in a test case.\n-    * ``app`` -- Search for and run all tests in the named application.\n-\n-    If ``test_labels`` has a value of ``None``, the test runner should run\n-    search for tests in all the applications in :setting:`INSTALLED_APPS`.\n-\n-    ``extra_tests`` is a list of extra ``TestCase`` instances to add to the\n-    suite that is executed by the test runner. These extra tests are run\n-    in addition to those discovered in the modules listed in ``test_labels``.\n-\n-    This method should return the number of tests that failed.\n-\n-.. method:: DjangoTestSuiteRunner.setup_test_environment(**kwargs)\n-\n-    Sets up the test environment ready for testing.\n-\n-.. method:: DjangoTestSuiteRunner.build_suite(test_labels, extra_tests=None, **kwargs)\n-\n-    Constructs a test suite that matches the test labels provided.\n-\n-    ``test_labels`` is a list of strings describing the tests to be run. A test\n-    label can take one of three forms:\n-\n-    * ``app.TestCase.test_method`` -- Run a single test method in a test\n-      case.\n-    * ``app.TestCase`` -- Run all the test methods in a test case.\n-    * ``app`` -- Search for and run all tests in the named application.\n-\n-    If ``test_labels`` has a value of ``None``, the test runner should run\n-    search for tests in all the applications in :setting:`INSTALLED_APPS`.\n-\n-    ``extra_tests`` is a list of extra ``TestCase`` instances to add to the\n-    suite that is executed by the test runner. These extra tests are run\n-    in addition to those discovered in the modules listed in ``test_labels``.\n-\n-    Returns a ``TestSuite`` instance ready to be run.\n-\n-.. method:: DjangoTestSuiteRunner.setup_databases(**kwargs)\n-\n-    Creates the test databases.\n-\n-    Returns a data structure that provides enough detail to undo the changes\n-    that have been made. This data will be provided to the ``teardown_databases()``\n-    function at the conclusion of testing.\n-\n-.. method:: DjangoTestSuiteRunner.run_suite(suite, **kwargs)\n-\n-    Runs the test suite.\n-\n-    Returns the result produced by the running the test suite.\n-\n-.. method:: DjangoTestSuiteRunner.teardown_databases(old_config, **kwargs)\n-\n-    Destroys the test databases, restoring pre-test conditions.\n-\n-    ``old_config`` is a data structure defining the changes in the\n-    database configuration that need to be reversed. It is the return\n-    value of the ``setup_databases()`` method.\n-\n-.. method:: DjangoTestSuiteRunner.teardown_test_environment(**kwargs)\n-\n-    Restores the pre-test environment.\n-\n-.. method:: DjangoTestSuiteRunner.suite_result(suite, result, **kwargs)\n-\n-    Computes and returns a return code based on a test suite, and the result\n-    from that test suite.\n-\n-\n-Testing utilities\n------------------\n-\n-.. module:: django.test.utils\n-   :synopsis: Helpers to write custom test runners.\n-\n-To assist in the creation of your own test runner, Django provides a number of\n-utility methods in the ``django.test.utils`` module.\n-\n-.. function:: setup_test_environment()\n-\n-    Performs any global pre-test setup, such as the installing the\n-    instrumentation of the template rendering system and setting up\n-    the dummy email outbox.\n-\n-.. function:: teardown_test_environment()\n-\n-    Performs any global post-test teardown, such as removing the black\n-    magic hooks into the template system and restoring normal email\n-    services.\n-\n-.. currentmodule:: django.db.connection.creation\n-\n-The creation module of the database backend (``connection.creation``)\n-also provides some utilities that can be useful during testing.\n-\n-.. function:: create_test_db([verbosity=1, autoclobber=False])\n-\n-    Creates a new test database and runs ``syncdb`` against it.\n-\n-    ``verbosity`` has the same behavior as in ``run_tests()``.\n-\n-    ``autoclobber`` describes the behavior that will occur if a\n-    database with the same name as the test database is discovered:\n-\n-    * If ``autoclobber`` is ``False``, the user will be asked to\n-      approve destroying the existing database. ``sys.exit`` is\n-      called if the user does not approve.\n-\n-    * If autoclobber is ``True``, the database will be destroyed\n-      without consulting the user.\n-\n-    Returns the name of the test database that it created.\n-\n-    ``create_test_db()`` has the side effect of modifying the value of\n-    :setting:`NAME` in :setting:`DATABASES` to match the name of the test\n-    database.\n-\n-.. function:: destroy_test_db(old_database_name, [verbosity=1])\n-\n-    Destroys the database whose name is the value of :setting:`NAME` in\n-    :setting:`DATABASES`, and sets :setting:`NAME` to the value of\n-    ``old_database_name``.\n-\n-    The ``verbosity`` argument has the same behavior as for\n-    :class:`~django.test.simple.DjangoTestSuiteRunner`.",
            "previous_filename": "docs/topics/testing.txt"
        }
    ],
    "stats": {
        "total": 1774,
        "additions": 911,
        "deletions": 863
    }
}