{
    "author": "ramiro",
    "message": "Refactored URL mapping documentation.\n\nReorganized topic document so it introduces concepts form simple to more\ncomplex. Moved reference parts to their own documents.",
    "sha": "b6b8a3f66b5cf4f00bd7ce668ac04f21bb73e0b9",
    "files": [
        {
            "sha": "e1959d44a61b798a490c4af74372d3f06d0bbf7a",
            "filename": "docs/ref/index.txt",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/b6b8a3f66b5cf4f00bd7ce668ac04f21bb73e0b9/docs%2Fref%2Findex.txt",
            "raw_url": "https://github.com/django/django/raw/b6b8a3f66b5cf4f00bd7ce668ac04f21bb73e0b9/docs%2Fref%2Findex.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Findex.txt?ref=b6b8a3f66b5cf4f00bd7ce668ac04f21bb73e0b9",
            "patch": "@@ -6,7 +6,7 @@ API Reference\n    :maxdepth: 1\n \n    authbackends\n-   class-based-views/index   \n+   class-based-views/index\n    clickjacking\n    contrib/index\n    databases\n@@ -22,5 +22,7 @@ API Reference\n    signals\n    templates/index\n    unicode\n+   urlresolvers\n+   urls\n    utils\n    validators"
        },
        {
            "sha": "965cafb29ba51afbfc9a16edb3112a1099b3c116",
            "filename": "docs/ref/urlresolvers.txt",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/django/django/blob/b6b8a3f66b5cf4f00bd7ce668ac04f21bb73e0b9/docs%2Fref%2Furlresolvers.txt",
            "raw_url": "https://github.com/django/django/raw/b6b8a3f66b5cf4f00bd7ce668ac04f21bb73e0b9/docs%2Fref%2Furlresolvers.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Furlresolvers.txt?ref=b6b8a3f66b5cf4f00bd7ce668ac04f21bb73e0b9",
            "patch": "@@ -0,0 +1,204 @@\n+==============================================\n+``django.core.urlresolvers`` utility functions\n+==============================================\n+\n+.. module:: django.core.urlresolvers\n+\n+reverse()\n+---------\n+\n+If you need to use something similar to the :ttag:`url` template tag in\n+your code, Django provides the following function (in the\n+:mod:`django.core.urlresolvers` module):\n+\n+.. function:: reverse(viewname, [urlconf=None, args=None, kwargs=None, current_app=None])\n+\n+``viewname`` is either the function name (either a function reference, or the\n+string version of the name, if you used that form in ``urlpatterns``) or the\n+:ref:`URL pattern name <naming-url-patterns>`.  Normally, you won't need to\n+worry about the ``urlconf`` parameter and will only pass in the positional and\n+keyword arguments to use in the URL matching. For example::\n+\n+    from django.core.urlresolvers import reverse\n+\n+    def myview(request):\n+        return HttpResponseRedirect(reverse('arch-summary', args=[1945]))\n+\n+The ``reverse()`` function can reverse a large variety of regular expression\n+patterns for URLs, but not every possible one. The main restriction at the\n+moment is that the pattern cannot contain alternative choices using the\n+vertical bar (``\"|\"``) character. You can quite happily use such patterns for\n+matching against incoming URLs and sending them off to views, but you cannot\n+reverse such patterns.\n+\n+The ``current_app`` argument allows you to provide a hint to the resolver\n+indicating the application to which the currently executing view belongs.\n+This ``current_app`` argument is used as a hint to resolve application\n+namespaces into URLs on specific application instances, according to the\n+:ref:`namespaced URL resolution strategy <topics-http-reversing-url-namespaces>`.\n+\n+You can use ``kwargs`` instead of ``args``. For example::\n+\n+    >>> reverse('admin:app_list', kwargs={'app_label': 'auth'})\n+    '/admin/auth/'\n+\n+``args`` and ``kwargs`` cannot be passed to ``reverse()`` at the same time.\n+\n+.. admonition:: Make sure your views are all correct.\n+\n+    As part of working out which URL names map to which patterns, the\n+    ``reverse()`` function has to import all of your URLconf files and examine\n+    the name of each view. This involves importing each view function. If\n+    there are *any* errors whilst importing any of your view functions, it\n+    will cause ``reverse()`` to raise an error, even if that view function is\n+    not the one you are trying to reverse.\n+\n+    Make sure that any views you reference in your URLconf files exist and can\n+    be imported correctly. Do not include lines that reference views you\n+    haven't written yet, because those views will not be importable.\n+\n+.. note::\n+\n+    The string returned by :meth:`~django.core.urlresolvers.reverse` is already\n+    :ref:`urlquoted <uri-and-iri-handling>`. For example::\n+\n+        >>> reverse('cities', args=[u'Orléans'])\n+        '.../Orl%C3%A9ans/'\n+\n+    Applying further encoding (such as :meth:`~django.utils.http.urlquote` or\n+    ``urllib.quote``) to the output of :meth:`~django.core.urlresolvers.reverse`\n+    may produce undesirable results.\n+\n+reverse_lazy()\n+--------------\n+\n+.. versionadded:: 1.4\n+\n+A lazily evaluated version of `reverse()`_.\n+\n+.. function:: reverse_lazy(viewname, [urlconf=None, args=None, kwargs=None, current_app=None])\n+\n+It is useful for when you need to use a URL reversal before your project's\n+URLConf is loaded. Some common cases where this function is necessary are:\n+\n+* providing a reversed URL as the ``url`` attribute of a generic class-based\n+  view.\n+\n+* providing a reversed URL to a decorator (such as the ``login_url`` argument\n+  for the :func:`django.contrib.auth.decorators.permission_required`\n+  decorator).\n+\n+* providing a reversed URL as a default value for a parameter in a function's\n+  signature.\n+\n+resolve()\n+---------\n+\n+The :func:`django.core.urlresolvers.resolve` function can be used for\n+resolving URL paths to the corresponding view functions. It has the\n+following signature:\n+\n+.. function:: resolve(path, urlconf=None)\n+\n+``path`` is the URL path you want to resolve. As with\n+:func:`~django.core.urlresolvers.reverse`, you don't need to\n+worry about the ``urlconf`` parameter. The function returns a\n+:class:`ResolverMatch` object that allows you\n+to access various meta-data about the resolved URL.\n+\n+If the URL does not resolve, the function raises an\n+:class:`~django.http.Http404` exception.\n+\n+.. class:: ResolverMatch\n+\n+    .. attribute:: ResolverMatch.func\n+\n+        The view function that would be used to serve the URL\n+\n+    .. attribute:: ResolverMatch.args\n+\n+        The arguments that would be passed to the view function, as\n+        parsed from the URL.\n+\n+    .. attribute:: ResolverMatch.kwargs\n+\n+        The keyword arguments that would be passed to the view\n+        function, as parsed from the URL.\n+\n+    .. attribute:: ResolverMatch.url_name\n+\n+        The name of the URL pattern that matches the URL.\n+\n+    .. attribute:: ResolverMatch.app_name\n+\n+        The application namespace for the URL pattern that matches the\n+        URL.\n+\n+    .. attribute:: ResolverMatch.namespace\n+\n+        The instance namespace for the URL pattern that matches the\n+        URL.\n+\n+    .. attribute:: ResolverMatch.namespaces\n+\n+        The list of individual namespace components in the full\n+        instance namespace for the URL pattern that matches the URL.\n+        i.e., if the namespace is ``foo:bar``, then namespaces will be\n+        ``['foo', 'bar']``.\n+\n+A :class:`ResolverMatch` object can then be interrogated to provide\n+information about the URL pattern that matches a URL::\n+\n+    # Resolve a URL\n+    match = resolve('/some/path/')\n+    # Print the URL pattern that matches the URL\n+    print(match.url_name)\n+\n+A :class:`ResolverMatch` object can also be assigned to a triple::\n+\n+    func, args, kwargs = resolve('/some/path/')\n+\n+One possible use of :func:`~django.core.urlresolvers.resolve` would be to test\n+whether a view would raise a ``Http404`` error before redirecting to it::\n+\n+    from urlparse import urlparse\n+    from django.core.urlresolvers import resolve\n+    from django.http import HttpResponseRedirect, Http404\n+\n+    def myview(request):\n+        next = request.META.get('HTTP_REFERER', None) or '/'\n+        response = HttpResponseRedirect(next)\n+\n+        # modify the request and response as required, e.g. change locale\n+        # and set corresponding locale cookie\n+\n+        view, args, kwargs = resolve(urlparse(next)[2])\n+        kwargs['request'] = request\n+        try:\n+            view(*args, **kwargs)\n+        except Http404:\n+            return HttpResponseRedirect('/')\n+        return response\n+\n+\n+permalink()\n+-----------\n+\n+The :func:`django.db.models.permalink` decorator is useful for writing short\n+methods that return a full URL path. For example, a model's\n+``get_absolute_url()`` method. See :func:`django.db.models.permalink` for more.\n+\n+get_script_prefix()\n+-------------------\n+\n+.. function:: get_script_prefix()\n+\n+Normally, you should always use :func:`~django.core.urlresolvers.reverse` or\n+:func:`~django.db.models.permalink` to define URLs within your application.\n+However, if your application constructs part of the URL hierarchy itself, you\n+may occasionally need to generate URLs. In that case, you need to be able to\n+find the base URL of the Django project within its Web server\n+(normally, :func:`~django.core.urlresolvers.reverse` takes care of this for\n+you). In that case, you can call ``get_script_prefix()``, which will return the\n+script prefix portion of the URL for your Django project. If your Django\n+project is at the root of its Web server, this is always ``\"/\"``."
        },
        {
            "sha": "3d860fc0edbdd18157f51d5a69886f351b2d3cea",
            "filename": "docs/ref/urls.txt",
            "status": "added",
            "additions": 139,
            "deletions": 0,
            "changes": 139,
            "blob_url": "https://github.com/django/django/blob/b6b8a3f66b5cf4f00bd7ce668ac04f21bb73e0b9/docs%2Fref%2Furls.txt",
            "raw_url": "https://github.com/django/django/raw/b6b8a3f66b5cf4f00bd7ce668ac04f21bb73e0b9/docs%2Fref%2Furls.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Furls.txt?ref=b6b8a3f66b5cf4f00bd7ce668ac04f21bb73e0b9",
            "patch": "@@ -0,0 +1,139 @@\n+======================================\n+``django.conf.urls`` utility functions\n+======================================\n+\n+.. module:: django.conf.urls\n+\n+.. versionchanged:: 1.4\n+    Starting with Django 1.4 functions ``patterns``, ``url``, ``include`` plus\n+    the ``handler*`` symbols described below live in the ``django.conf.urls``\n+    module.\n+\n+    Until Django 1.3 they were located in ``django.conf.urls.defaults``. You\n+    still can import them from there but it will be removed in Django 1.6.\n+\n+patterns()\n+----------\n+\n+.. function:: patterns(prefix, pattern_description, ...)\n+\n+A function that takes a prefix, and an arbitrary number of URL patterns, and\n+returns a list of URL patterns in the format Django needs.\n+\n+The first argument to ``patterns()`` is a string ``prefix``. See\n+:ref:`The view prefix <urlpatterns-view-prefix>`.\n+\n+The remaining arguments should be tuples in this format::\n+\n+    (regular expression, Python callback function [, optional_dictionary [, optional_name]])\n+\n+The ``optional_dictionary`` and ``optional_name`` parameters are described in\n+:ref:`Passing extra options to view functions <views-extra-options>`.\n+\n+.. note::\n+    Because `patterns()` is a function call, it accepts a maximum of 255\n+    arguments (URL patterns, in this case). This is a limit for all Python\n+    function calls. This is rarely a problem in practice, because you'll\n+    typically structure your URL patterns modularly by using `include()`\n+    sections. However, on the off-chance you do hit the 255-argument limit,\n+    realize that `patterns()` returns a Python list, so you can split up the\n+    construction of the list.\n+\n+    ::\n+\n+        urlpatterns = patterns('',\n+            ...\n+            )\n+        urlpatterns += patterns('',\n+            ...\n+            )\n+\n+    Python lists have unlimited size, so there's no limit to how many URL\n+    patterns you can construct. The only limit is that you can only create 254\n+    at a time (the 255th argument is the initial prefix argument).\n+\n+url()\n+-----\n+\n+.. function:: url(regex, view, kwargs=None, name=None, prefix='')\n+\n+You can use the ``url()`` function, instead of a tuple, as an argument to\n+``patterns()``. This is convenient if you want to specify a name without the\n+optional extra arguments dictionary. For example::\n+\n+    urlpatterns = patterns('',\n+        url(r'^index/$', index_view, name=\"main-view\"),\n+        ...\n+    )\n+\n+This function takes five arguments, most of which are optional::\n+\n+    url(regex, view, kwargs=None, name=None, prefix='')\n+\n+See :ref:`Naming URL patterns <naming-url-patterns>` for why the ``name``\n+parameter is useful.\n+\n+The ``prefix`` parameter has the same meaning as the first argument to\n+``patterns()`` and is only relevant when you're passing a string as the\n+``view`` parameter.\n+\n+include()\n+---------\n+\n+.. function:: include(<module or pattern_list>)\n+\n+A function that takes a full Python import path to another URLconf module that\n+should be \"included\" in this place.\n+\n+:func:`include` also accepts as an argument an iterable that returns URL\n+patterns.\n+\n+See :ref:`Including other URLconfs <including-other-urlconfs>`.\n+\n+handler403\n+----------\n+\n+.. data:: handler403\n+\n+A callable, or a string representing the full Python import path to the view\n+that should be called if the user doesn't have the permissions required to\n+access a resource.\n+\n+By default, this is ``'django.views.defaults.permission_denied'``. That default\n+value should suffice.\n+\n+See the documentation about :ref:`the 403 (HTTP Forbidden) view\n+<http_forbidden_view>` for more information.\n+\n+.. versionadded:: 1.4\n+    ``handler403`` is new in Django 1.4.\n+\n+handler404\n+----------\n+\n+.. data:: handler404\n+\n+A callable, or a string representing the full Python import path to the view\n+that should be called if none of the URL patterns match.\n+\n+By default, this is ``'django.views.defaults.page_not_found'``. That default\n+value should suffice.\n+\n+See the documentation about :ref:`the 404 (HTTP Not Found) view\n+<http_not_found_view>` for more information.\n+\n+handler500\n+----------\n+\n+.. data:: handler500\n+\n+A callable, or a string representing the full Python import path to the view\n+that should be called in case of server errors. Server errors happen when you\n+have runtime errors in view code.\n+\n+By default, this is ``'django.views.defaults.server_error'``. That default\n+value should suffice.\n+\n+See the documentation about :ref:`the 500 (HTTP Internal Server Error) view\n+<http_internal_server_error_view>` for more information.\n+"
        },
        {
            "sha": "79eac888526a1e007bb2c62739280c90bd1524a9",
            "filename": "docs/topics/http/urls.txt",
            "status": "modified",
            "additions": 84,
            "deletions": 399,
            "changes": 483,
            "blob_url": "https://github.com/django/django/blob/b6b8a3f66b5cf4f00bd7ce668ac04f21bb73e0b9/docs%2Ftopics%2Fhttp%2Furls.txt",
            "raw_url": "https://github.com/django/django/raw/b6b8a3f66b5cf4f00bd7ce668ac04f21bb73e0b9/docs%2Ftopics%2Fhttp%2Furls.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fhttp%2Furls.txt?ref=b6b8a3f66b5cf4f00bd7ce668ac04f21bb73e0b9",
            "patch": "@@ -2,8 +2,6 @@\n URL dispatcher\n ==============\n \n-.. module:: django.core.urlresolvers\n-\n A clean, elegant URL scheme is an important detail in a high-quality Web\n application. Django lets you design URLs however you want, with no framework\n limitations.\n@@ -160,7 +158,8 @@ vs. non-named groups in a regular expression:\n \n 2. Otherwise, it will pass all non-named arguments as positional arguments.\n \n-In both cases, any extra keyword arguments that have been given as per `Passing extra options to view functions`_ (below) will also be passed to the view.\n+In both cases, any extra keyword arguments that have been given as per `Passing\n+extra options to view functions`_ (below) will also be passed to the view.\n \n What the URLconf searches against\n =================================\n@@ -215,162 +214,42 @@ Performance\n Each regular expression in a ``urlpatterns`` is compiled the first time it's\n accessed. This makes the system blazingly fast.\n \n-\n Syntax of the urlpatterns variable\n ==================================\n \n ``urlpatterns`` should be a Python list, in the format returned by the function\n :func:`django.conf.urls.patterns`. Always use ``patterns()`` to create\n the ``urlpatterns`` variable.\n \n-``django.conf.urls`` utility functions\n-======================================\n-\n-.. module:: django.conf.urls\n-\n-.. deprecated:: 1.4\n-    Starting with Django 1.4 functions ``patterns``, ``url``, ``include`` plus\n-    the ``handler*`` symbols described below live in the ``django.conf.urls``\n-    module.\n-\n-    Until Django 1.3 they were located in ``django.conf.urls.defaults``. You\n-    still can import them from there but it will be removed in Django 1.6.\n-\n-patterns\n---------\n-\n-.. function:: patterns(prefix, pattern_description, ...)\n-\n-A function that takes a prefix, and an arbitrary number of URL patterns, and\n-returns a list of URL patterns in the format Django needs.\n-\n-The first argument to ``patterns()`` is a string ``prefix``. See\n-`The view prefix`_ below.\n-\n-The remaining arguments should be tuples in this format::\n-\n-    (regular expression, Python callback function [, optional_dictionary [, optional_name]])\n-\n-The ``optional_dictionary`` and ``optional_name`` parameters are described in\n-`Passing extra options to view functions`_ below.\n-\n-.. note::\n-    Because `patterns()` is a function call, it accepts a maximum of 255\n-    arguments (URL patterns, in this case). This is a limit for all Python\n-    function calls. This is rarely a problem in practice, because you'll\n-    typically structure your URL patterns modularly by using `include()`\n-    sections. However, on the off-chance you do hit the 255-argument limit,\n-    realize that `patterns()` returns a Python list, so you can split up the\n-    construction of the list.\n-\n-    ::\n-\n-        urlpatterns = patterns('',\n-            ...\n-            )\n-        urlpatterns += patterns('',\n-            ...\n-            )\n-\n-    Python lists have unlimited size, so there's no limit to how many URL\n-    patterns you can construct. The only limit is that you can only create 254\n-    at a time (the 255th argument is the initial prefix argument).\n-\n-url\n----\n-\n-.. function:: url(regex, view, kwargs=None, name=None, prefix='')\n-\n-You can use the ``url()`` function, instead of a tuple, as an argument to\n-``patterns()``. This is convenient if you want to specify a name without the\n-optional extra arguments dictionary. For example::\n-\n-    urlpatterns = patterns('',\n-        url(r'^index/$', index_view, name=\"main-view\"),\n-        ...\n-    )\n-\n-This function takes five arguments, most of which are optional::\n-\n-    url(regex, view, kwargs=None, name=None, prefix='')\n-\n-See `Naming URL patterns`_ for why the ``name`` parameter is useful.\n-\n-The ``prefix`` parameter has the same meaning as the first argument to\n-``patterns()`` and is only relevant when you're passing a string as the\n-``view`` parameter.\n-\n-include\n--------\n-\n-.. function:: include(<module or pattern_list>)\n-\n-A function that takes a full Python import path to another URLconf module that\n-should be \"included\" in this place.\n-\n-:func:`include` also accepts as an argument an iterable that returns URL\n-patterns.\n-\n-See `Including other URLconfs`_ below.\n-\n Error handling\n ==============\n \n When Django can't find a regex matching the requested URL, or when an\n-exception is raised, Django will invoke an error-handling view. The\n-views to use for these cases are specified by three variables which can\n-be set in your root URLconf. Setting these variables in any other\n-URLconf will have no effect.\n+exception is raised, Django will invoke an error-handling view.\n \n-See the documentation on :ref:`customizing error views\n-<customizing-error-views>` for more details.\n+The views to use for these cases are specified by three variables. Their\n+default values should suffice for most projects, but further customization is\n+possible by assigning values to them.\n \n-handler403\n-----------\n+See the documentation on :ref:`customizing error views\n+<customizing-error-views>` for the full details.\n \n-.. data:: handler403\n+Such values can be set in your root URLconf. Setting these variables in any\n+other URLconf will have no effect.\n \n-A callable, or a string representing the full Python import path to the view\n-that should be called if the user doesn't have the permissions required to\n-access a resource.\n+Values must be callables, or strings representing the full Python import path\n+to the view that should be called to handle the error condition at hand.\n \n-By default, this is ``'django.views.defaults.permission_denied'``. That default\n-value should suffice.\n+The variables are:\n \n-See the documentation about :ref:`the 403 (HTTP Forbidden) view\n-<http_forbidden_view>` for more information.\n+* ``handler404`` -- See :data:`django.conf.urls.handler404`.\n+* ``handler500`` -- See :data:`django.conf.urls.handler500`.\n+* ``handler403`` -- See :data:`django.conf.urls.handler403`.\n \n .. versionadded:: 1.4\n     ``handler403`` is new in Django 1.4.\n \n-handler404\n-----------\n-\n-.. data:: handler404\n-\n-A callable, or a string representing the full Python import path to the view\n-that should be called if none of the URL patterns match.\n-\n-By default, this is ``'django.views.defaults.page_not_found'``. That default\n-value should suffice.\n-\n-See the documentation about :ref:`the 404 (HTTP Not Found) view\n-<http_not_found_view>` for more information.\n-\n-handler500\n-----------\n-\n-.. data:: handler500\n-\n-A callable, or a string representing the full Python import path to the view\n-that should be called in case of server errors. Server errors happen when you\n-have runtime errors in view code.\n-\n-By default, this is ``'django.views.defaults.server_error'``. That default\n-value should suffice.\n-\n-See the documentation about :ref:`the 500 (HTTP Internal Server Error) view\n-<http_internal_server_error_view>` for more information.\n+.. _urlpatterns-view-prefix:\n \n The view prefix\n ===============\n@@ -437,6 +316,8 @@ New::\n         (r'^tag/(?P<tag>\\w+)/$', 'tag'),\n     )\n \n+.. _including-other-urlconfs:\n+\n Including other URLconfs\n ========================\n \n@@ -459,13 +340,14 @@ itself. It includes a number of other URLconfs::\n \n Note that the regular expressions in this example don't have a ``$``\n (end-of-string match character) but do include a trailing slash. Whenever\n-Django encounters ``include()``, it chops off whatever part of the URL matched\n-up to that point and sends the remaining string to the included URLconf for\n-further processing.\n+Django encounters ``include()`` (:func:`django.conf.urls.include()`), it chops\n+off whatever part of the URL matched up to that point and sends the remaining\n+string to the included URLconf for further processing.\n \n Another possibility is to include additional URL patterns not by specifying the\n-URLconf Python module defining them as the `include`_ argument but by using\n-directly the pattern list as returned by `patterns`_ instead. For example::\n+URLconf Python module defining them as the ``include()`` argument but by using\n+directly the pattern list as returned by :func:`~django.conf.urls.patterns`\n+instead. For example::\n \n     from django.conf.urls import patterns, url, include\n \n@@ -510,57 +392,7 @@ the following example is valid::\n In the above example, the captured ``\"username\"`` variable is passed to the\n included URLconf, as expected.\n \n-.. _topics-http-defining-url-namespaces:\n-\n-Defining URL namespaces\n------------------------\n-\n-When you need to deploy multiple instances of a single application, it can be\n-helpful to be able to differentiate between instances. This is especially\n-important when using :ref:`named URL patterns <naming-url-patterns>`, since\n-multiple instances of a single application will share named URLs. Namespaces\n-provide a way to tell these named URLs apart.\n-\n-A URL namespace comes in two parts, both of which are strings:\n-\n-* An **application namespace**. This describes the name of the application\n-  that is being deployed. Every instance of a single application will have\n-  the same application namespace. For example, Django's admin application\n-  has the somewhat predictable application namespace of ``admin``.\n-\n-* An **instance namespace**. This identifies a specific instance of an\n-  application. Instance namespaces should be unique across your entire\n-  project. However, an instance namespace can be the same as the\n-  application namespace. This is used to specify a default instance of an\n-  application. For example, the default Django Admin instance has an\n-  instance namespace of ``admin``.\n-\n-URL Namespaces can be specified in two ways.\n-\n-Firstly, you can provide the application and instance namespace as arguments\n-to ``include()`` when you construct your URL patterns. For example,::\n-\n-    (r'^help/', include('apps.help.urls', namespace='foo', app_name='bar')),\n-\n-This will include the URLs defined in ``apps.help.urls`` into the application\n-namespace ``bar``, with the instance namespace ``foo``.\n-\n-Secondly, you can include an object that contains embedded namespace data. If\n-you ``include()`` a ``patterns`` object, that object will be added to the\n-global namespace. However, you can also ``include()`` an object that contains\n-a 3-tuple containing::\n-\n-    (<patterns object>, <application namespace>, <instance namespace>)\n-\n-This will include the nominated URL patterns into the given application and\n-instance namespace. For example, the ``urls`` attribute of Django's\n-:class:`~django.contrib.admin.AdminSite` object returns a 3-tuple that contains\n-all the patterns in an admin site, plus the name of the admin instance, and the\n-application namespace ``admin``.\n-\n-Once you have defined namespaced URLs, you can reverse them. For details on\n-reversing namespaced urls, see the documentation on :ref:`reversing namespaced\n-URLs <topics-http-reversing-url-namespaces>`.\n+.. _views-extra-options:\n \n Passing extra options to view functions\n =======================================\n@@ -698,10 +530,10 @@ view::\n     )\n \n This is completely valid, but it leads to problems when you try to do reverse\n-URL matching (through the ``permalink()`` decorator or the :ttag:`url` template\n-tag). Continuing this example, if you wanted to retrieve the URL for the\n-``archive`` view, Django's reverse URL matcher would get confused, because *two*\n-URL patterns point at that view.\n+URL matching (through the :func:`~django.db.models.permalink` decorator or the\n+:ttag:`url` template tag). Continuing this example, if you wanted to retrieve\n+the URL for the ``archive`` view, Django's reverse URL matcher would get\n+confused, because *two* URL patterns point at that view.\n \n To solve this problem, Django supports **named URL patterns**. That is, you can\n give a name to a URL pattern in order to distinguish it from other patterns\n@@ -741,10 +573,36 @@ not restricted to valid Python names.\n     name, will decrease the chances of collision. We recommend something like\n     ``myapp-comment`` instead of ``comment``.\n \n-.. _topics-http-reversing-url-namespaces:\n+.. _topics-http-defining-url-namespaces:\n \n URL namespaces\n---------------\n+==============\n+\n+Introduction\n+------------\n+\n+When you need to deploy multiple instances of a single application, it can be\n+helpful to be able to differentiate between instances. This is especially\n+important when using :ref:`named URL patterns <naming-url-patterns>`, since\n+multiple instances of a single application will share named URLs. Namespaces\n+provide a way to tell these named URLs apart.\n+\n+A URL namespace comes in two parts, both of which are strings:\n+\n+.. glossary::\n+\n+  application namespace\n+    This describes the name of the application that is being deployed. Every\n+    instance of a single application will have the same application namespace.\n+    For example, Django's admin application has the somewhat predictable\n+    application namespace of ``admin``.\n+\n+  instance namespace\n+    This identifies a specific instance of an application. Instance namespaces\n+    should be unique across your entire project. However, an instance namespace\n+    can be the same as the application namespace. This is used to specify a\n+    default instance of an application. For example, the default Django Admin\n+    instance has an instance namespace of ``admin``.\n \n Namespaced URLs are specified using the ``:`` operator. For example, the main\n index page of the admin application is referenced using ``admin:index``. This\n@@ -754,6 +612,11 @@ Namespaces can also be nested. The named URL ``foo:bar:whiz`` would look for\n a pattern named ``whiz`` in the namespace ``bar`` that is itself defined within\n the top-level namespace ``foo``.\n \n+.. _topics-http-reversing-url-namespaces:\n+\n+Reversing namespaced URLs\n+-------------------------\n+\n When given a namespaced URL (e.g. ``myapp:index``) to resolve, Django splits\n the fully qualified name into parts, and then tries the following lookup:\n \n@@ -787,6 +650,9 @@ If there are nested namespaces, these steps are repeated for each part of the\n namespace until only the view name is unresolved. The view name will then be\n resolved into a URL in the namespace that has been found.\n \n+Example\n+~~~~~~~\n+\n To show this resolution strategy in action, consider an example of two instances\n of ``myapp``: one called ``foo``, and one called ``bar``. ``myapp`` has a main\n index page with a URL named `index`. Using this setup, the following lookups are\n@@ -818,209 +684,28 @@ following would happen:\n \n * ``foo:index`` will again resolve to the index page of the instance ``foo``.\n \n+URL namespaces and included URLconfs\n+------------------------------------\n \n-``django.core.urlresolvers`` utility functions\n-==============================================\n-\n-.. currentmodule:: django.core.urlresolvers\n-\n-reverse()\n----------\n-\n-If you need to use something similar to the :ttag:`url` template tag in\n-your code, Django provides the following function (in the\n-:mod:`django.core.urlresolvers` module):\n-\n-.. function:: reverse(viewname, [urlconf=None, args=None, kwargs=None, current_app=None])\n-\n-``viewname`` is either the function name (either a function reference, or the\n-string version of the name, if you used that form in ``urlpatterns``) or the\n-`URL pattern name`_.  Normally, you won't need to worry about the\n-``urlconf`` parameter and will only pass in the positional and keyword\n-arguments to use in the URL matching. For example::\n-\n-    from django.core.urlresolvers import reverse\n-\n-    def myview(request):\n-        return HttpResponseRedirect(reverse('arch-summary', args=[1945]))\n-\n-.. _URL pattern name: `Naming URL patterns`_\n-\n-The ``reverse()`` function can reverse a large variety of regular expression\n-patterns for URLs, but not every possible one. The main restriction at the\n-moment is that the pattern cannot contain alternative choices using the\n-vertical bar (``\"|\"``) character. You can quite happily use such patterns for\n-matching against incoming URLs and sending them off to views, but you cannot\n-reverse such patterns.\n-\n-The ``current_app`` argument allows you to provide a hint to the resolver\n-indicating the application to which the currently executing view belongs.\n-This ``current_app`` argument is used as a hint to resolve application\n-namespaces into URLs on specific application instances, according to the\n-:ref:`namespaced URL resolution strategy <topics-http-reversing-url-namespaces>`.\n-\n-You can use ``kwargs`` instead of ``args``. For example::\n-\n-    >>> reverse('admin:app_list', kwargs={'app_label': 'auth'})\n-    '/admin/auth/'\n-\n-``args`` and ``kwargs`` cannot be passed to ``reverse()`` at the same time.\n-\n-.. admonition:: Make sure your views are all correct.\n-\n-    As part of working out which URL names map to which patterns, the\n-    ``reverse()`` function has to import all of your URLconf files and examine\n-    the name of each view. This involves importing each view function. If\n-    there are *any* errors whilst importing any of your view functions, it\n-    will cause ``reverse()`` to raise an error, even if that view function is\n-    not the one you are trying to reverse.\n-\n-    Make sure that any views you reference in your URLconf files exist and can\n-    be imported correctly. Do not include lines that reference views you\n-    haven't written yet, because those views will not be importable.\n-\n-.. note::\n-\n-    The string returned by :meth:`~django.core.urlresolvers.reverse` is already\n-    :ref:`urlquoted <uri-and-iri-handling>`. For example::\n-\n-        >>> reverse('cities', args=[u'Orléans'])\n-        '.../Orl%C3%A9ans/'\n-\n-    Applying further encoding (such as :meth:`~django.utils.http.urlquote` or\n-    ``urllib.quote``) to the output of :meth:`~django.core.urlresolvers.reverse`\n-    may produce undesirable results.\n-\n-reverse_lazy()\n---------------\n-\n-.. versionadded:: 1.4\n-\n-A lazily evaluated version of `reverse()`_.\n-\n-.. function:: reverse_lazy(viewname, [urlconf=None, args=None, kwargs=None, current_app=None])\n-\n-It is useful for when you need to use a URL reversal before your project's\n-URLConf is loaded. Some common cases where this function is necessary are:\n-\n-* providing a reversed URL as the ``url`` attribute of a generic class-based\n-  view.\n-\n-* providing a reversed URL to a decorator (such as the ``login_url`` argument\n-  for the :func:`django.contrib.auth.decorators.permission_required`\n-  decorator).\n-\n-* providing a reversed URL as a default value for a parameter in a function's\n-  signature.\n-\n-resolve()\n----------\n+URL namespaces of included URLconfs can be specified in two ways.\n \n-The :func:`django.core.urlresolvers.resolve` function can be used for\n-resolving URL paths to the corresponding view functions. It has the\n-following signature:\n-\n-.. function:: resolve(path, urlconf=None)\n-\n-``path`` is the URL path you want to resolve. As with\n-:func:`~django.core.urlresolvers.reverse`, you don't need to\n-worry about the ``urlconf`` parameter. The function returns a\n-:class:`ResolverMatch` object that allows you\n-to access various meta-data about the resolved URL.\n-\n-If the URL does not resolve, the function raises an\n-:class:`~django.http.Http404` exception.\n-\n-.. class:: ResolverMatch\n-\n-    .. attribute:: ResolverMatch.func\n-\n-        The view function that would be used to serve the URL\n-\n-    .. attribute:: ResolverMatch.args\n-\n-        The arguments that would be passed to the view function, as\n-        parsed from the URL.\n-\n-    .. attribute:: ResolverMatch.kwargs\n-\n-        The keyword arguments that would be passed to the view\n-        function, as parsed from the URL.\n-\n-    .. attribute:: ResolverMatch.url_name\n-\n-        The name of the URL pattern that matches the URL.\n-\n-    .. attribute:: ResolverMatch.app_name\n-\n-        The application namespace for the URL pattern that matches the\n-        URL.\n-\n-    .. attribute:: ResolverMatch.namespace\n-\n-        The instance namespace for the URL pattern that matches the\n-        URL.\n-\n-    .. attribute:: ResolverMatch.namespaces\n-\n-        The list of individual namespace components in the full\n-        instance namespace for the URL pattern that matches the URL.\n-        i.e., if the namespace is ``foo:bar``, then namespaces will be\n-        ``['foo', 'bar']``.\n-\n-A :class:`ResolverMatch` object can then be interrogated to provide\n-information about the URL pattern that matches a URL::\n-\n-    # Resolve a URL\n-    match = resolve('/some/path/')\n-    # Print the URL pattern that matches the URL\n-    print(match.url_name)\n-\n-A :class:`ResolverMatch` object can also be assigned to a triple::\n-\n-    func, args, kwargs = resolve('/some/path/')\n-\n-One possible use of :func:`~django.core.urlresolvers.resolve` would be to test\n-whether a view would raise a ``Http404`` error before redirecting to it::\n-\n-    from urlparse import urlparse\n-    from django.core.urlresolvers import resolve\n-    from django.http import HttpResponseRedirect, Http404\n-\n-    def myview(request):\n-        next = request.META.get('HTTP_REFERER', None) or '/'\n-        response = HttpResponseRedirect(next)\n-\n-        # modify the request and response as required, e.g. change locale\n-        # and set corresponding locale cookie\n-\n-        view, args, kwargs = resolve(urlparse(next)[2])\n-        kwargs['request'] = request\n-        try:\n-            view(*args, **kwargs)\n-        except Http404:\n-            return HttpResponseRedirect('/')\n-        return response\n+Firstly, you can provide the application and instance namespace as arguments\n+to ``include()`` when you construct your URL patterns. For example,::\n \n+    (r'^help/', include('apps.help.urls', namespace='foo', app_name='bar')),\n \n-permalink()\n------------\n+This will include the URLs defined in ``apps.help.urls`` into the application\n+namespace ``bar``, with the instance namespace ``foo``.\n \n-The :func:`django.db.models.permalink` decorator is useful for writing short\n-methods that return a full URL path. For example, a model's\n-``get_absolute_url()`` method. See :func:`django.db.models.permalink` for more.\n+Secondly, you can include an object that contains embedded namespace data. If\n+you ``include()`` a ``patterns`` object, that object will be added to the\n+global namespace. However, you can also ``include()`` an object that contains\n+a 3-tuple containing::\n \n-get_script_prefix()\n--------------------\n+    (<patterns object>, <application namespace>, <instance namespace>)\n \n-.. function:: get_script_prefix()\n-\n-Normally, you should always use :func:`~django.core.urlresolvers.reverse` or\n-:func:`~django.db.models.permalink` to define URLs within your application.\n-However, if your application constructs part of the URL hierarchy itself, you\n-may occasionally need to generate URLs. In that case, you need to be able to\n-find the base URL of the Django project within its Web server\n-(normally, :func:`~django.core.urlresolvers.reverse` takes care of this for\n-you). In that case, you can call ``get_script_prefix()``, which will return the\n-script prefix portion of the URL for your Django project. If your Django\n-project is at the root of its Web server, this is always ``\"/\"``.\n+This will include the nominated URL patterns into the given application and\n+instance namespace. For example, the ``urls`` attribute of Django's\n+:class:`~django.contrib.admin.AdminSite` object returns a 3-tuple that contains\n+all the patterns in an admin site, plus the name of the admin instance, and the\n+application namespace ``admin``."
        }
    ],
    "stats": {
        "total": 830,
        "additions": 430,
        "deletions": 400
    }
}