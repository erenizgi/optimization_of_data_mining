{
    "author": "jezdez",
    "message": "Fixed #15190 -- Refactored the collectstatic command to improve the symlink mode and generally straighten out its behavior.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15388 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "5cd561280844865182277ef49070e75ad5ec881e",
    "files": [
        {
            "sha": "54eaab01695a83a1ce4fafa9811b0bf3d446e982",
            "filename": "django/contrib/staticfiles/management/commands/collectstatic.py",
            "status": "modified",
            "additions": 104,
            "deletions": 83,
            "changes": 187,
            "blob_url": "https://github.com/django/django/blob/5cd561280844865182277ef49070e75ad5ec881e/django%2Fcontrib%2Fstaticfiles%2Fmanagement%2Fcommands%2Fcollectstatic.py",
            "raw_url": "https://github.com/django/django/raw/5cd561280844865182277ef49070e75ad5ec881e/django%2Fcontrib%2Fstaticfiles%2Fmanagement%2Fcommands%2Fcollectstatic.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fstaticfiles%2Fmanagement%2Fcommands%2Fcollectstatic.py?ref=5cd561280844865182277ef49070e75ad5ec881e",
            "patch": "@@ -34,16 +34,16 @@ class Command(NoArgsCommand):\n \n     def __init__(self, *args, **kwargs):\n         super(NoArgsCommand, self).__init__(*args, **kwargs)\n-        self.copied_files = set()\n-        self.symlinked_files = set()\n-        self.unmodified_files = set()\n-        self.destination_storage = get_storage_class(settings.STATICFILES_STORAGE)()\n+        self.copied_files = []\n+        self.symlinked_files = []\n+        self.unmodified_files = []\n+        self.storage = get_storage_class(settings.STATICFILES_STORAGE)()\n         try:\n-            self.destination_storage.path('')\n+            self.storage.path('')\n         except NotImplementedError:\n-            self.destination_local = False\n+            self.local = False\n         else:\n-            self.destination_local = True\n+            self.local = True\n         # Use ints for file times (ticket #14665)\n         os.stat_float_times(False)\n \n@@ -59,25 +59,33 @@ def handle_noargs(self, **options):\n             if sys.platform == 'win32':\n                 raise CommandError(\"Symlinking is not supported by this \"\n                                    \"platform (%s).\" % sys.platform)\n-            if not self.destination_local:\n+            if not self.local:\n                 raise CommandError(\"Can't symlink to a remote destination.\")\n \n         # Warn before doing anything more.\n         if options.get('interactive'):\n             confirm = raw_input(\"\"\"\n-You have requested to collate static files and collect them at the destination\n-location as specified in your settings file.\n+You have requested to collect static files at the destination\n+location as specified in your settings file ('%s').\n \n This will overwrite existing files.\n Are you sure you want to do this?\n \n-Type 'yes' to continue, or 'no' to cancel: \"\"\")\n+Type 'yes' to continue, or 'no' to cancel: \"\"\" % settings.STATIC_ROOT)\n             if confirm != 'yes':\n                 raise CommandError(\"Collecting static files cancelled.\")\n \n         for finder in finders.get_finders():\n-            for source, storage in finder.list(ignore_patterns):\n-                self.copy_file(source, storage, **options)\n+            for path, storage in finder.list(ignore_patterns):\n+                # Prefix the relative path if the source storage contains it\n+                if getattr(storage, 'prefix', None):\n+                    prefixed_path = os.path.join(storage.prefix, path)\n+                else:\n+                    prefixed_path = path\n+                if symlink:\n+                    self.link_file(path, prefixed_path, storage, **options)\n+                else:\n+                    self.copy_file(path, prefixed_path, storage, **options)\n \n         actual_count = len(self.copied_files) + len(self.symlinked_files)\n         unmodified_count = len(self.unmodified_files)\n@@ -98,84 +106,97 @@ def log(self, msg, level=2):\n         if self.verbosity >= level:\n             self.stdout.write(msg)\n \n-    def copy_file(self, source, source_storage, **options):\n-        \"\"\"\n-        Attempt to copy (or symlink) ``source`` to ``destination``,\n-        returning True if successful.\n-        \"\"\"\n-        source_path = source_storage.path(source)\n-        try:\n-            source_last_modified = source_storage.modified_time(source)\n-        except (OSError, NotImplementedError):\n-            source_last_modified = None\n-        if getattr(source_storage, 'prefix', None):\n-            destination = os.path.join(source_storage.prefix, source)\n-        else:\n-            destination = source\n+    def delete_file(self, path, prefixed_path, source_storage, **options):\n+        # Whether we are in symlink mode\n         symlink = options['link']\n-        dry_run = options['dry_run']\n-\n-        if destination in self.copied_files:\n-            self.log(\"Skipping '%s' (already copied earlier)\" % destination)\n-            return False\n-\n-        if destination in self.symlinked_files:\n-            self.log(\"Skipping '%s' (already linked earlier)\" % destination)\n-            return False\n-\n-        if self.destination_storage.exists(destination):\n+        # Checks if the target file should be deleted if it already exists\n+        if self.storage.exists(prefixed_path):\n             try:\n-                destination_last_modified = \\\n-                    self.destination_storage.modified_time(destination)\n+                # When was the target file modified last time?\n+                target_last_modified = self.storage.modified_time(prefixed_path)\n             except (OSError, NotImplementedError):\n-                # storage doesn't support ``modified_time`` or failed.\n+                # The storage doesn't support ``modified_time`` or failed\n                 pass\n             else:\n-                destination_is_link = (self.destination_local and\n-                    os.path.islink(self.destination_storage.path(destination)))\n-                if destination_last_modified >= source_last_modified:\n-                    if (not symlink and not destination_is_link):\n-                        self.log(\"Skipping '%s' (not modified)\" % destination)\n-                        self.unmodified_files.add(destination)\n-                        return False\n-            if dry_run:\n-                self.log(\"Pretending to delete '%s'\" % destination)\n+                try:\n+                    # When was the source file modified last time?\n+                    source_last_modified = source_storage.modified_time(path)\n+                except (OSError, NotImplementedError):\n+                    pass\n+                else:\n+                    # The full path of the target file\n+                    if self.local:\n+                        full_path = self.storage.path(prefixed_path)\n+                    else:\n+                        full_path = None\n+                    # Skip the file if the source file is younger\n+                    if target_last_modified >= source_last_modified:\n+                        if not ((symlink and full_path and not os.path.islink(full_path)) or\n+                                (not symlink and full_path and os.path.islink(full_path))):\n+                            if prefixed_path not in self.unmodified_files:\n+                                self.unmodified_files.append(prefixed_path)\n+                            self.log(\"Skipping '%s' (not modified)\" % path)\n+                            return False\n+            # Then delete the existing file if really needed\n+            if options['dry_run']:\n+                self.log(\"Pretending to delete '%s'\" % path)\n             else:\n-                self.log(\"Deleting '%s'\" % destination)\n-                self.destination_storage.delete(destination)\n+                self.log(\"Deleting '%s'\" % path)\n+                self.storage.delete(prefixed_path)\n+        return True\n \n-        if symlink:\n-            destination_path = self.destination_storage.path(destination)\n-            if dry_run:\n-                self.log(\"Pretending to link '%s' to '%s'\" %\n-                         (source_path, destination_path), level=1)\n-            else:\n-                self.log(\"Linking '%s' to '%s'\" %\n-                         (source_path, destination_path), level=1)\n+    def link_file(self, path, prefixed_path, source_storage, **options):\n+        \"\"\"\n+        Attempt to link ``path``\n+        \"\"\"\n+        # Skip this file if it was already copied earlier\n+        if prefixed_path in self.symlinked_files:\n+            return self.log(\"Skipping '%s' (already linked earlier)\" % path)\n+        # Delete the target file if needed or break\n+        if not self.delete_file(path, prefixed_path, source_storage, **options):\n+            return\n+        # The full path of the source file\n+        source_path = source_storage.path(path)\n+        # Finally link the file\n+        if options['dry_run']:\n+            self.log(\"Pretending to link '%s'\" % source_path, level=1)\n+        else:\n+            self.log(\"Linking '%s'\" % source_path, level=1)\n+            full_path = self.storage.path(prefixed_path)\n+            try:\n+                os.makedirs(os.path.dirname(full_path))\n+            except OSError:\n+                pass\n+            os.symlink(source_path, full_path)\n+        if prefixed_path not in self.symlinked_files:\n+            self.symlinked_files.append(prefixed_path)\n+\n+    def copy_file(self, path, prefixed_path, source_storage, **options):\n+        \"\"\"\n+        Attempt to copy ``path`` with storage\n+        \"\"\"\n+        # Skip this file if it was already copied earlier\n+        if prefixed_path in self.copied_files:\n+            return self.log(\"Skipping '%s' (already copied earlier)\" % path)\n+        # Delete the target file if needed or break\n+        if not self.delete_file(path, prefixed_path, source_storage, **options):\n+            return\n+        # The full path of the source file\n+        source_path = source_storage.path(path)\n+        # Finally start copying\n+        if options['dry_run']:\n+            self.log(\"Pretending to copy '%s'\" % source_path, level=1)\n+        else:\n+            self.log(\"Copying '%s'\" % source_path, level=1)\n+            if self.local:\n+                full_path = self.storage.path(prefixed_path)\n                 try:\n-                    os.makedirs(os.path.dirname(destination_path))\n+                    os.makedirs(os.path.dirname(full_path))\n                 except OSError:\n                     pass\n-                os.symlink(source_path, destination_path)\n-            self.symlinked_files.add(destination)\n-        else:\n-            if dry_run:\n-                self.log(\"Pretending to copy '%s' to '%s'\" %\n-                         (source_path, destination), level=1)\n+                shutil.copy2(source_path, full_path)\n             else:\n-                if self.destination_local:\n-                    destination_path = self.destination_storage.path(destination)\n-                    try:\n-                        os.makedirs(os.path.dirname(destination_path))\n-                    except OSError:\n-                        pass\n-                    shutil.copy2(source_path, destination_path)\n-                    self.log(\"Copying '%s' to '%s'\" %\n-                             (source_path, destination_path), level=1)\n-                else:\n-                    source_file = source_storage.open(source)\n-                    self.destination_storage.save(destination, source_file)\n-                    self.log(\"Copying %s to %s\" %\n-                             (source_path, destination), level=1)\n-            self.copied_files.add(destination)\n-        return True\n+                source_file = source_storage.open(path)\n+                self.storage.save(prefixed_path, source_file)\n+        if not prefixed_path in self.copied_files:\n+            self.copied_files.append(prefixed_path)"
        }
    ],
    "stats": {
        "total": 187,
        "additions": 104,
        "deletions": 83
    }
}