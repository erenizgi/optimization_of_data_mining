{
    "author": "ubernostrum",
    "message": "Ticket 18657: Fix inconsistent DB names in router example.\n\nThis rewrites the entire example to use the same DB names throughout,\nand also is hopefully a bit more sensibly described. Additionally, the\nmissing import of the random module for choosing a read slave is\nincluded in the example now.",
    "sha": "5d1f09f450686c53ead6f2784ba5c94ea6dccf36",
    "files": [
        {
            "sha": "ef9c5a26487e7c749c7215231433534d3bd009a3",
            "filename": "docs/topics/db/multi-db.txt",
            "status": "modified",
            "additions": 116,
            "deletions": 60,
            "changes": 176,
            "blob_url": "https://github.com/django/django/blob/5d1f09f450686c53ead6f2784ba5c94ea6dccf36/docs%2Ftopics%2Fdb%2Fmulti-db.txt",
            "raw_url": "https://github.com/django/django/raw/5d1f09f450686c53ead6f2784ba5c94ea6dccf36/docs%2Ftopics%2Fdb%2Fmulti-db.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Fmulti-db.txt?ref=5d1f09f450686c53ead6f2784ba5c94ea6dccf36",
            "patch": "@@ -201,73 +201,129 @@ An example\n     write to propagate to the slaves). It also doesn't consider the\n     interaction of transactions with the database utilization strategy.\n \n-So - what does this mean in practice? Say you want ``myapp`` to\n-exist on the ``other`` database, and you want all other models in a\n-master/slave relationship between the databases ``master``, ``slave1`` and\n-``slave2``. To implement this, you would need 2 routers::\n+So - what does this mean in practice? Let's consider another sample\n+configuration. This one will have several databases: one for the\n+``auth`` application, and all other apps using a master/slave setup\n+with two read slaves. Here are the settings specifying these\n+databases::\n \n-    class MyAppRouter(object):\n-        \"\"\"A router to control all database operations on models in\n-        the myapp application\"\"\"\n+    DATABASES = {\n+        'auth_db': {\n+            'NAME': 'auth_db',\n+            'ENGINE': 'django.db.backends.mysql',\n+            'USER': 'mysql_user',\n+            'PASSWORD': 'swordfish',\n+        },\n+        'master': {\n+            'NAME': 'master',\n+            'ENGINE': 'django.db.backends.mysql',\n+            'USER': 'mysql_user',\n+            'PASSWORD': 'spam',\n+        },\n+        'slave1': {\n+            'NAME': 'slave1',\n+            'ENGINE': 'django.db.backends.mysql',\n+            'USER': 'mysql_user',\n+            'PASSWORD': 'eggs',\n+        },\n+        'slave2': {\n+            'NAME': 'slave2',\n+            'ENGINE': 'django.db.backends.mysql',\n+            'USER': 'mysql_user',\n+            'PASSWORD': 'bacon',\n+        },\n+    }\n \n-        def db_for_read(self, model, **hints):\n-            \"Point all operations on myapp models to 'other'\"\n-            if model._meta.app_label == 'myapp':\n-                return 'other'\n-            return None\n-\n-        def db_for_write(self, model, **hints):\n-            \"Point all operations on myapp models to 'other'\"\n-            if model._meta.app_label == 'myapp':\n-                return 'other'\n-            return None\n-\n-        def allow_relation(self, obj1, obj2, **hints):\n-            \"Allow any relation if a model in myapp is involved\"\n-            if obj1._meta.app_label == 'myapp' or obj2._meta.app_label == 'myapp':\n-                return True\n-            return None\n-\n-        def allow_syncdb(self, db, model):\n-            \"Make sure the myapp app only appears on the 'other' db\"\n-            if db == 'other':\n-                return model._meta.app_label == 'myapp'\n-            elif model._meta.app_label == 'myapp':\n-                return False\n-            return None\n+Now we'll need to handle routing. First we want a router that knows to\n+send queries for the ``auth`` app to ``auth_db``::\n+\n+    class AuthRouter(object):\n+        \"\"\"\n+        A router to control all database operations on models in the\n+        auth application.\n+        \"\"\"\n+\tdef db_for_read(self, model, **hints):\n+\t    \"\"\"\n+\t    Attempts to read auth models go to auth_db.\n+\t    \"\"\"\n+\t    if model._meta.app_label == 'auth':\n+\t        return 'auth_db'\n+ \t    return None\n+\n+\tdef db_for_write(self, model, **hints):\n+\t    \"\"\"\n+\t    Attempts to write auth models go to auth_db.\n+\t    \"\"\"\n+\t    if model._meta.app_label == 'auth':\n+\t        return 'auth_db'\n+\t    return Non\n+\n+\tdef allow_relation(self, obj1, obj2, **hints):\n+\t    \"\"\"\n+\t    Allow relations if a model in the auth app is involved.\n+\t    \"\"\"\n+\t    if obj1._meta.app_label == 'auth' or \\\n+               obj2._meta.app_label == 'auth':\n+\t       return True\n+\t    return None\n+\n+\tdef allow_syncdb(self, db, model):\n+\t    \"\"\"\n+\t    Make sure the auth app only appears in the 'auth_db'\n+\t    database.\n+\t    \"\"\"\n+\t    if db == 'auth_db':\n+\t        return model._meta.app_label == 'auth'\n+\t    elif model._meta.app_label == 'auth':\n+\t        return False\n+\t    return None\n+\n+And we also want a router that sends all other apps to the\n+master/slave configuration, and randomly chooses a slave to read\n+from::\n+\n+    import random\n \n     class MasterSlaveRouter(object):\n-        \"\"\"A router that sets up a simple master/slave configuration\"\"\"\n-\n         def db_for_read(self, model, **hints):\n-            \"Point all read operations to a random slave\"\n-            return random.choice(['slave1','slave2'])\n-\n-        def db_for_write(self, model, **hints):\n-            \"Point all write operations to the master\"\n-            return 'master'\n-\n-        def allow_relation(self, obj1, obj2, **hints):\n-            \"Allow any relation between two objects in the db pool\"\n-            db_list = ('master','slave1','slave2')\n-            if obj1._state.db in db_list and obj2._state.db in db_list:\n-                return True\n-            return None\n-\n-        def allow_syncdb(self, db, model):\n-            \"Explicitly put all models on all databases.\"\n-            return True\n-\n-Then, in your settings file, add the following (substituting ``path.to.`` with\n-the actual python path to the module where you define the routers)::\n-\n-    DATABASE_ROUTERS = ['path.to.MyAppRouter', 'path.to.MasterSlaveRouter']\n+\t    \"\"\"\n+\t    Reads go to a randomly-chosen slave.\n+\t    \"\"\"\n+\t    return random.choice(['slave1', 'slave2'])\n+\n+\tdef db_for_write(self, model, **hints):\n+\t    \"\"\"\n+\t    Writes always go to master.\n+\t    \"\"\"\n+\t    return 'master'\n+\n+\tdef allow_relation(self, obj1, obj2, **hints):\n+\t    \"\"\"\n+\t    Relations between objects are allowed if both objects are\n+\t    in the master/slave pool.\n+\t    \"\"\"\n+\t    db_list = ('master', 'slave1', 'slave2')\n+\t    if obj1.state.db in db_list and obj2.state.db in db_list:\n+\t        return True\n+\t    return None\n+\n+\tdef allow_syncdb(self, db, model):\n+\t    \"\"\"\n+\t    All non-auth models end up in this pool.\n+\t    \"\"\"\n+\t    return True\n+\n+Finally, in the settings file, we add the following (substituting\n+``path.to.`` with the actual python path to the module(s) where the\n+routers are defined)::\n+\n+    DATABASE_ROUTERS = ['path.to.AuthRouter', 'path.to.MasterSlaveRouter']\n \n The order in which routers are processed is significant. Routers will\n be queried in the order the are listed in the\n :setting:`DATABASE_ROUTERS` setting . In this example, the\n-``MyAppRouter`` is processed before the ``MasterSlaveRouter``, and as a\n-result, decisions concerning the models in ``myapp`` are processed\n+``AuthRouter`` is processed before the ``MasterSlaveRouter``, and as a\n+result, decisions concerning the models in ``auth`` are processed\n before any other decision is made. If the :setting:`DATABASE_ROUTERS`\n setting listed the two routers in the other order,\n ``MasterSlaveRouter.allow_syncdb()`` would be processed first. The\n@@ -276,11 +332,11 @@ that all models would be available on all databases.\n \n With this setup installed, lets run some Django code::\n \n-    >>> # This retrieval will be performed on the 'credentials' database\n+    >>> # This retrieval will be performed on the 'auth_db' database\n     >>> fred = User.objects.get(username='fred')\n     >>> fred.first_name = 'Frederick'\n \n-    >>> # This save will also be directed to 'credentials'\n+    >>> # This save will also be directed to 'auth_db'\n     >>> fred.save()\n \n     >>> # These retrieval will be randomly allocated to a slave database"
        }
    ],
    "stats": {
        "total": 176,
        "additions": 116,
        "deletions": 60
    }
}