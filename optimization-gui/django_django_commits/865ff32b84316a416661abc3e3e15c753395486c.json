{
    "author": "timgraham",
    "message": "Fixed #16980 - Misc updates to the auth docs. Thanks Preston Holmes for the patch.",
    "sha": "865ff32b84316a416661abc3e3e15c753395486c",
    "files": [
        {
            "sha": "307691bd4ae8d263185725e645edbbe88265c53f",
            "filename": "docs/topics/auth.txt",
            "status": "modified",
            "additions": 40,
            "deletions": 25,
            "changes": 65,
            "blob_url": "https://github.com/django/django/blob/865ff32b84316a416661abc3e3e15c753395486c/docs%2Ftopics%2Fauth.txt",
            "raw_url": "https://github.com/django/django/raw/865ff32b84316a416661abc3e3e15c753395486c/docs%2Ftopics%2Fauth.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fauth.txt?ref=865ff32b84316a416661abc3e3e15c753395486c",
            "patch": "@@ -98,12 +98,13 @@ Fields\n \n         This doesn't necessarily control whether or not the user can log in.\n         Authentication backends aren't required to check for the ``is_active``\n-        flag, so if you want to reject a login based on ``is_active`` being\n-        ``False``, it's up to you to check that in your own login view.\n-        However, the :class:`~django.contrib.auth.forms.AuthenticationForm`\n-        used by the :func:`~django.contrib.auth.views.login` view *does*\n-        perform this check, as do the permission-checking methods such as\n-        :meth:`~models.User.has_perm` and the authentication in the Django\n+        flag, and the default backends do not. If you want to reject a login\n+        based on ``is_active`` being ``False``, it's up to you to check that in\n+        your own login view or a custom authentication backend. However, the\n+        :class:`~django.contrib.auth.forms.AuthenticationForm` used by the\n+        :func:`~django.contrib.auth.views.login` view (which is the default)\n+        *does* perform this check, as do the permission-checking methods such\n+        as :meth:`~models.User.has_perm` and the authentication in the Django\n         admin. All of those functions/methods will return ``False`` for\n         inactive users.\n \n@@ -1748,7 +1749,11 @@ By default, :setting:`AUTHENTICATION_BACKENDS` is set to::\n \n     ('django.contrib.auth.backends.ModelBackend',)\n \n-That's the basic authentication scheme that checks the Django users database.\n+That's the basic authentication backend that checks the Django users database\n+and queries the builtin permissions. It does not provide protection against\n+brute force attacks via any rate limiting mechanism. You may either implement\n+your own rate limiting mechanism in a custom auth backend, or use the\n+mechanisms provided by most Web servers.\n \n The order of :setting:`AUTHENTICATION_BACKENDS` matters, so if the same\n username and password is valid in multiple backends, Django will stop\n@@ -1768,8 +1773,9 @@ processing at the first positive match.\n Writing an authentication backend\n ---------------------------------\n \n-An authentication backend is a class that implements two methods:\n-``get_user(user_id)`` and ``authenticate(**credentials)``.\n+An authentication backend is a class that implements two required methods:\n+``get_user(user_id)`` and ``authenticate(**credentials)``, as well as a set of\n+optional permission related :ref:`authorization methods <authorization_methods>`.\n \n The ``get_user`` method takes a ``user_id`` -- which could be a username,\n database ID or whatever -- and returns a ``User`` object.\n@@ -1838,6 +1844,8 @@ object the first time a user authenticates::\n             except User.DoesNotExist:\n                 return None\n \n+.. _authorization_methods:\n+\n Handling authorization in custom backends\n -----------------------------------------\n \n@@ -1868,13 +1876,16 @@ fairly simply::\n                 return False\n \n This gives full permissions to the user granted access in the above example.\n-Notice that the backend auth functions all take the user object as an argument,\n-and they also accept the same arguments given to the associated\n-:class:`django.contrib.auth.models.User` functions.\n+Notice that in addition to the same arguments given to the associated\n+:class:`django.contrib.auth.models.User` functions, the backend auth functions\n+all take the user object, which may be an anonymous user, as an argument.\n \n-A full authorization implementation can be found in\n-`django/contrib/auth/backends.py`_, which is the default backend and queries\n-the ``auth_permission`` table most of the time.\n+A full authorization implementation can be found in the ``ModelBackend`` class\n+in `django/contrib/auth/backends.py`_, which is the default backend and queries\n+the ``auth_permission`` table most of the time. If you wish to provide\n+custom behavior for only part of the backend API, you can take advantage of\n+Python inheritence and subclass ``ModelBackend`` instead of implementing the\n+complete API in a custom backend.\n \n .. _django/contrib/auth/backends.py: https://github.com/django/django/blob/master/django/contrib/auth/backends.py\n \n@@ -1890,35 +1901,39 @@ authorize anonymous users to browse most of the site, and many allow anonymous\n posting of comments etc.\n \n Django's permission framework does not have a place to store permissions for\n-anonymous users. However, it has a foundation that allows custom authentication\n-backends to specify authorization for anonymous users. This is especially useful\n-for the authors of re-usable apps, who can delegate all questions of authorization\n-to the auth backend, rather than needing settings, for example, to control\n-anonymous access.\n+anonymous users. However, the user object passed to an authentication backend\n+may be an :class:`django.contrib.auth.models.AnonymousUser` object, allowing\n+the backend to specify custom authorization behavior for anonymous users. This\n+is especially useful for the authors of re-usable apps, who can delegate all\n+questions of authorization to the auth backend, rather than needing settings,\n+for example, to control anonymous access.\n \n+.. _inactive_auth:\n \n Authorization for inactive users\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-.. versionadded:: 1.3\n+.. versionchanged:: 1.3\n \n An inactive user is a one that is authenticated but has its attribute\n ``is_active`` set to ``False``. However this does not mean they are not\n authorized to do anything. For example they are allowed to activate their\n account.\n \n-The support for anonymous users in the permission system allows for\n-anonymous users to have permissions to do something while inactive\n+The support for anonymous users in the permission system allows for a scenario\n+where anonymous users have permissions to do something while inactive\n authenticated users do not.\n \n Do not forget to test for the ``is_active`` attribute of the user in your own\n backend permission methods.\n \n \n Handling object permissions\n----------------------------\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n Django's permission framework has a foundation for object permissions, though\n there is no implementation for it in the core. That means that checking for\n object permissions will always return ``False`` or an empty list (depending on\n-the check performed).\n+the check performed). An authentication backend will receive the keyword\n+parameters ``obj`` and ``user_obj`` for each object related authorization\n+method and can return the object level permission as appropriate."
        }
    ],
    "stats": {
        "total": 65,
        "additions": 40,
        "deletions": 25
    }
}