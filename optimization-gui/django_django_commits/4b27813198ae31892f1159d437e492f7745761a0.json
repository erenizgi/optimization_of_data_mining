{
    "author": "aaugustin",
    "message": "Fixed #7581 -- Added streaming responses.\n\nThanks mrmachine and everyone else involved on this long-standing ticket.",
    "sha": "4b27813198ae31892f1159d437e492f7745761a0",
    "files": [
        {
            "sha": "49acd57af3746c7545b3ed12a73df541deb3b294",
            "filename": "django/http/__init__.py",
            "status": "modified",
            "additions": 146,
            "deletions": 32,
            "changes": 178,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/django%2Fhttp%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/django%2Fhttp%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2F__init__.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -528,45 +528,48 @@ def parse_cookie(cookie):\n class BadHeaderError(ValueError):\n     pass\n \n-class HttpResponse(object):\n-    \"\"\"A basic HTTP response, with content and dictionary-accessed headers.\"\"\"\n+class HttpResponseBase(object):\n+    \"\"\"\n+    An HTTP response base class with dictionary-accessed headers.\n+\n+    This class doesn't handle content. It should not be used directly.\n+    Use the HttpResponse and StreamingHttpResponse subclasses instead.\n+    \"\"\"\n \n     status_code = 200\n \n-    def __init__(self, content='', content_type=None, status=None,\n-            mimetype=None):\n+    def __init__(self, content_type=None, status=None, mimetype=None):\n         # _headers is a mapping of the lower-case name to the original case of\n         # the header (required for working with legacy systems) and the header\n         # value. Both the name of the header and its value are ASCII strings.\n         self._headers = {}\n         self._charset = settings.DEFAULT_CHARSET\n+        self._closable_objects = []\n         if mimetype:\n             warnings.warn(\"Using mimetype keyword argument is deprecated, use\"\n                           \" content_type instead\", PendingDeprecationWarning)\n             content_type = mimetype\n         if not content_type:\n             content_type = \"%s; charset=%s\" % (settings.DEFAULT_CONTENT_TYPE,\n                     self._charset)\n-        # content is a bytestring. See the content property methods.\n-        self.content = content\n         self.cookies = SimpleCookie()\n         if status:\n             self.status_code = status\n \n         self['Content-Type'] = content_type\n \n-    def serialize(self):\n-        \"\"\"Full HTTP message, including headers, as a bytestring.\"\"\"\n+    def serialize_headers(self):\n+        \"\"\"HTTP headers as a bytestring.\"\"\"\n         headers = [\n             ('%s: %s' % (key, value)).encode('us-ascii')\n             for key, value in self._headers.values()\n         ]\n-        return b'\\r\\n'.join(headers) + b'\\r\\n\\r\\n' + self.content\n+        return b'\\r\\n'.join(headers)\n \n     if six.PY3:\n-        __bytes__ = serialize\n+        __bytes__ = serialize_headers\n     else:\n-        __str__ = serialize\n+        __str__ = serialize_headers\n \n     def _convert_to_charset(self, value, charset, mime_encode=False):\n         \"\"\"Converts headers key/value to ascii/latin1 native strings.\n@@ -690,24 +693,75 @@ def delete_cookie(self, key, path='/', domain=None):\n         self.set_cookie(key, max_age=0, path=path, domain=domain,\n                         expires='Thu, 01-Jan-1970 00:00:00 GMT')\n \n+    # Common methods used by subclasses\n+\n+    def make_bytes(self, value):\n+        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n+        # For backwards compatibility, this method supports values that are\n+        # unlikely to occur in real applications. It has grown complex and\n+        # should be refactored. It also overlaps __next__. See #18796.\n+        if self.has_header('Content-Encoding'):\n+            if isinstance(value, int):\n+                value = six.text_type(value)\n+            if isinstance(value, six.text_type):\n+                value = value.encode('ascii')\n+            # force conversion to bytes in case chunk is a subclass\n+            return bytes(value)\n+        else:\n+            return force_bytes(value, self._charset)\n+\n+    # These methods partially implement the file-like object interface.\n+    # See http://docs.python.org/lib/bltin-file-objects.html\n+\n+    # The WSGI server must call this method upon completion of the request.\n+    # See http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html\n+    def close(self):\n+        for closable in self._closable_objects:\n+            closable.close()\n+\n+    def write(self, content):\n+        raise Exception(\"This %s instance is not writable\" % self.__class__.__name__)\n+\n+    def flush(self):\n+        pass\n+\n+    def tell(self):\n+        raise Exception(\"This %s instance cannot tell its position\" % self.__class__.__name__)\n+\n+class HttpResponse(HttpResponseBase):\n+    \"\"\"\n+    An HTTP response class with a string as content.\n+\n+    This content that can be read, appended to or replaced.\n+    \"\"\"\n+\n+    streaming = False\n+\n+    def __init__(self, content='', *args, **kwargs):\n+        super(HttpResponse, self).__init__(*args, **kwargs)\n+        # Content is a bytestring. See the `content` property methods.\n+        self.content = content\n+\n+    def serialize(self):\n+        \"\"\"Full HTTP message, including headers, as a bytestring.\"\"\"\n+        return self.serialize_headers() + b'\\r\\n\\r\\n' + self.content\n+\n+    if six.PY3:\n+        __bytes__ = serialize\n+    else:\n+        __str__ = serialize\n+\n     @property\n     def content(self):\n-        if self.has_header('Content-Encoding'):\n-            def make_bytes(value):\n-                if isinstance(value, int):\n-                    value = six.text_type(value)\n-                if isinstance(value, six.text_type):\n-                    value = value.encode('ascii')\n-                # force conversion to bytes in case chunk is a subclass\n-                return bytes(value)\n-            return b''.join(make_bytes(e) for e in self._container)\n-        return b''.join(force_bytes(e, self._charset) for e in self._container)\n+        return b''.join(self.make_bytes(e) for e in self._container)\n \n     @content.setter\n     def content(self, value):\n         if hasattr(value, '__iter__') and not isinstance(value, (bytes, six.string_types)):\n             self._container = value\n             self._base_content_is_iter = True\n+            if hasattr(value, 'close'):\n+                self._closable_objects.append(value)\n         else:\n             self._container = [value]\n             self._base_content_is_iter = False\n@@ -727,25 +781,85 @@ def __next__(self):\n \n     next = __next__             # Python 2 compatibility\n \n-    def close(self):\n-        if hasattr(self._container, 'close'):\n-            self._container.close()\n-\n-    # The remaining methods partially implement the file-like object interface.\n-    # See http://docs.python.org/lib/bltin-file-objects.html\n     def write(self, content):\n         if self._base_content_is_iter:\n-            raise Exception(\"This %s instance is not writable\" % self.__class__)\n+            raise Exception(\"This %s instance is not writable\" % self.__class__.__name__)\n         self._container.append(content)\n \n-    def flush(self):\n-        pass\n-\n     def tell(self):\n         if self._base_content_is_iter:\n-            raise Exception(\"This %s instance cannot tell its position\" % self.__class__)\n+            raise Exception(\"This %s instance cannot tell its position\" % self.__class__.__name__)\n         return sum([len(chunk) for chunk in self])\n \n+class StreamingHttpResponse(HttpResponseBase):\n+    \"\"\"\n+    A streaming HTTP response class with an iterator as content.\n+\n+    This should only be iterated once, when the response is streamed to the\n+    client. However, it can be appended to or replaced with a new iterator\n+    that wraps the original content (or yields entirely new content).\n+    \"\"\"\n+\n+    streaming = True\n+\n+    def __init__(self, streaming_content=(), *args, **kwargs):\n+        super(StreamingHttpResponse, self).__init__(*args, **kwargs)\n+        # `streaming_content` should be an iterable of bytestrings.\n+        # See the `streaming_content` property methods.\n+        self.streaming_content = streaming_content\n+\n+    @property\n+    def content(self):\n+        raise AttributeError(\"This %s instance has no `content` attribute. \"\n+            \"Use `streaming_content` instead.\" % self.__class__.__name__)\n+\n+    @property\n+    def streaming_content(self):\n+        return self._iterator\n+\n+    @streaming_content.setter\n+    def streaming_content(self, value):\n+        # Ensure we can never iterate on \"value\" more than once.\n+        self._iterator = iter(value)\n+        if hasattr(value, 'close'):\n+            self._closable_objects.append(value)\n+\n+    def __iter__(self):\n+        return self\n+\n+    def __next__(self):\n+        return self.make_bytes(next(self._iterator))\n+\n+    next = __next__             # Python 2 compatibility\n+\n+class CompatibleStreamingHttpResponse(StreamingHttpResponse):\n+    \"\"\"\n+    This class maintains compatibility with middleware that doesn't know how\n+    to handle the content of a streaming response by exposing a `content`\n+    attribute that will consume and cache the content iterator when accessed.\n+\n+    These responses will stream only if no middleware attempts to access the\n+    `content` attribute. Otherwise, they will behave like a regular response,\n+    and raise a `PendingDeprecationWarning`.\n+    \"\"\"\n+    @property\n+    def content(self):\n+        warnings.warn(\n+            'Accessing the `content` attribute on a streaming response is '\n+            'deprecated. Use the `streaming_content` attribute instead.',\n+            PendingDeprecationWarning)\n+        content = b''.join(self)\n+        self.streaming_content = [content]\n+        return content\n+\n+    @content.setter\n+    def content(self, content):\n+        warnings.warn(\n+            'Accessing the `content` attribute on a streaming response is '\n+            'deprecated. Use the `streaming_content` attribute instead.',\n+            PendingDeprecationWarning)\n+        self.streaming_content = [content]\n+\n class HttpResponseRedirectBase(HttpResponse):\n     allowed_schemes = ['http', 'https', 'ftp']\n "
        },
        {
            "sha": "f7ff477f09a25b9b44ce99f4cb621c79d0fc60d4",
            "filename": "django/http/utils.py",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/django%2Fhttp%2Futils.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/django%2Fhttp%2Futils.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2Futils.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -26,10 +26,16 @@ def conditional_content_removal(request, response):\n     responses. Ensures compliance with RFC 2616, section 4.3.\n     \"\"\"\n     if 100 <= response.status_code < 200 or response.status_code in (204, 304):\n-       response.content = ''\n-       response['Content-Length'] = 0\n+        if response.streaming:\n+            response.streaming_content = []\n+        else:\n+            response.content = ''\n+        response['Content-Length'] = '0'\n     if request.method == 'HEAD':\n-        response.content = ''\n+        if response.streaming:\n+            response.streaming_content = []\n+        else:\n+            response.content = ''\n     return response\n \n def fix_IE_for_attach(request, response):"
        },
        {
            "sha": "6fbbf4304414f0e805e17e9471c5730075d2f85c",
            "filename": "django/middleware/common.py",
            "status": "modified",
            "additions": 10,
            "deletions": 6,
            "changes": 16,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/django%2Fmiddleware%2Fcommon.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/django%2Fmiddleware%2Fcommon.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fmiddleware%2Fcommon.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -113,14 +113,18 @@ def process_response(self, request, response):\n         if settings.USE_ETAGS:\n             if response.has_header('ETag'):\n                 etag = response['ETag']\n+            elif response.streaming:\n+                etag = None\n             else:\n                 etag = '\"%s\"' % hashlib.md5(response.content).hexdigest()\n-            if response.status_code >= 200 and response.status_code < 300 and request.META.get('HTTP_IF_NONE_MATCH') == etag:\n-                cookies = response.cookies\n-                response = http.HttpResponseNotModified()\n-                response.cookies = cookies\n-            else:\n-                response['ETag'] = etag\n+            if etag is not None:\n+                if (200 <= response.status_code < 300\n+                    and request.META.get('HTTP_IF_NONE_MATCH') == etag):\n+                    cookies = response.cookies\n+                    response = http.HttpResponseNotModified()\n+                    response.cookies = cookies\n+                else:\n+                    response['ETag'] = etag\n \n         return response\n "
        },
        {
            "sha": "fb54501a032f04cefb1b7a78d7ac8ca0b3872e4f",
            "filename": "django/middleware/gzip.py",
            "status": "modified",
            "additions": 15,
            "deletions": 9,
            "changes": 24,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/django%2Fmiddleware%2Fgzip.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/django%2Fmiddleware%2Fgzip.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fmiddleware%2Fgzip.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -1,6 +1,6 @@\n import re\n \n-from django.utils.text import compress_string\n+from django.utils.text import compress_sequence, compress_string\n from django.utils.cache import patch_vary_headers\n \n re_accepts_gzip = re.compile(r'\\bgzip\\b')\n@@ -13,7 +13,7 @@ class GZipMiddleware(object):\n     \"\"\"\n     def process_response(self, request, response):\n         # It's not worth attempting to compress really short responses.\n-        if len(response.content) < 200:\n+        if not response.streaming and len(response.content) < 200:\n             return response\n \n         patch_vary_headers(response, ('Accept-Encoding',))\n@@ -32,15 +32,21 @@ def process_response(self, request, response):\n         if not re_accepts_gzip.search(ae):\n             return response\n \n-        # Return the compressed content only if it's actually shorter.\n-        compressed_content = compress_string(response.content)\n-        if len(compressed_content) >= len(response.content):\n-            return response\n+        if response.streaming:\n+            # Delete the `Content-Length` header for streaming content, because\n+            # we won't know the compressed size until we stream it.\n+            response.streaming_content = compress_sequence(response.streaming_content)\n+            del response['Content-Length']\n+        else:\n+            # Return the compressed content only if it's actually shorter.\n+            compressed_content = compress_string(response.content)\n+            if len(compressed_content) >= len(response.content):\n+                return response\n+            response.content = compressed_content\n+            response['Content-Length'] = str(len(response.content))\n \n         if response.has_header('ETag'):\n             response['ETag'] = re.sub('\"$', ';gzip\"', response['ETag'])\n-\n-        response.content = compressed_content\n         response['Content-Encoding'] = 'gzip'\n-        response['Content-Length'] = str(len(response.content))\n+\n         return response"
        },
        {
            "sha": "5a46e049469804bd8109f5988442ff11e66c3d9a",
            "filename": "django/middleware/http.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/django%2Fmiddleware%2Fhttp.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/django%2Fmiddleware%2Fhttp.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fmiddleware%2Fhttp.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -10,7 +10,7 @@ class ConditionalGetMiddleware(object):\n     \"\"\"\n     def process_response(self, request, response):\n         response['Date'] = http_date()\n-        if not response.has_header('Content-Length'):\n+        if not response.streaming and not response.has_header('Content-Length'):\n             response['Content-Length'] = str(len(response.content))\n \n         if response.has_header('ETag'):"
        },
        {
            "sha": "cfa2cde643c70d6429ebf18de9afeac9fedf668b",
            "filename": "django/test/testcases.py",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/django%2Ftest%2Ftestcases.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/django%2Ftest%2Ftestcases.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Ftestcases.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -596,7 +596,9 @@ def assertContains(self, response, text, count=None, status_code=200,\n             msg_prefix + \"Couldn't retrieve content: Response code was %d\"\n             \" (expected %d)\" % (response.status_code, status_code))\n         text = force_text(text, encoding=response._charset)\n-        content = response.content.decode(response._charset)\n+        content = b''.join(response).decode(response._charset)\n+        # Avoid ResourceWarning about unclosed files.\n+        response.close()\n         if html:\n             content = assert_and_parse_html(self, content, None,\n                 \"Response's content is not valid HTML:\")"
        },
        {
            "sha": "0fceaa96e68475b43adc106f2117a0763025bad5",
            "filename": "django/utils/cache.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/django%2Futils%2Fcache.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/django%2Futils%2Fcache.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fcache.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -95,7 +95,8 @@ def get_max_age(response):\n             pass\n \n def _set_response_etag(response):\n-    response['ETag'] = '\"%s\"' % hashlib.md5(response.content).hexdigest()\n+    if not response.streaming:\n+        response['ETag'] = '\"%s\"' % hashlib.md5(response.content).hexdigest()\n     return response\n \n def patch_response_headers(response, cache_timeout=None):"
        },
        {
            "sha": "d75ca8dbca89f21b49d67da9c040fdcc5c8157fb",
            "filename": "django/utils/text.py",
            "status": "modified",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/django%2Futils%2Ftext.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/django%2Futils%2Ftext.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Ftext.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -288,6 +288,37 @@ def compress_string(s):\n     zfile.close()\n     return zbuf.getvalue()\n \n+class StreamingBuffer(object):\n+    def __init__(self):\n+        self.vals = []\n+\n+    def write(self, val):\n+        self.vals.append(val)\n+\n+    def read(self):\n+        ret = b''.join(self.vals)\n+        self.vals = []\n+        return ret\n+\n+    def flush(self):\n+        return\n+\n+    def close(self):\n+        return\n+\n+# Like compress_string, but for iterators of strings.\n+def compress_sequence(sequence):\n+    buf = StreamingBuffer()\n+    zfile = GzipFile(mode='wb', compresslevel=6, fileobj=buf)\n+    # Output headers...\n+    yield buf.read()\n+    for item in sequence:\n+        zfile.write(item)\n+        zfile.flush()\n+        yield buf.read()\n+    zfile.close()\n+    yield buf.read()\n+\n ustring_re = re.compile(\"([\\u0080-\\uffff])\")\n \n def javascript_quote(s, quote_double_quotes=False):"
        },
        {
            "sha": "23e18c54a0205eb28079840b69f5e5480c84121e",
            "filename": "django/views/generic/base.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/django%2Fviews%2Fgeneric%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/django%2Fviews%2Fgeneric%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fviews%2Fgeneric%2Fbase.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -99,7 +99,7 @@ def options(self, request, *args, **kwargs):\n         \"\"\"\n         response = http.HttpResponse()\n         response['Allow'] = ', '.join(self._allowed_methods())\n-        response['Content-Length'] = 0\n+        response['Content-Length'] = '0'\n         return response\n \n     def _allowed_methods(self):"
        },
        {
            "sha": "f61ba28bd58a0b233b153c2df10bb449f95150c2",
            "filename": "django/views/static.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/django%2Fviews%2Fstatic.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/django%2Fviews%2Fstatic.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fviews%2Fstatic.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -14,7 +14,8 @@\n except ImportError:     # Python 2\n     from urllib import unquote\n \n-from django.http import Http404, HttpResponse, HttpResponseRedirect, HttpResponseNotModified\n+from django.http import (CompatibleStreamingHttpResponse, Http404,\n+    HttpResponse, HttpResponseRedirect, HttpResponseNotModified)\n from django.template import loader, Template, Context, TemplateDoesNotExist\n from django.utils.http import http_date, parse_http_date\n from django.utils.translation import ugettext as _, ugettext_noop\n@@ -62,8 +63,7 @@ def serve(request, path, document_root=None, show_indexes=False):\n     if not was_modified_since(request.META.get('HTTP_IF_MODIFIED_SINCE'),\n                               statobj.st_mtime, statobj.st_size):\n         return HttpResponseNotModified()\n-    with open(fullpath, 'rb') as f:\n-        response = HttpResponse(f.read(), content_type=mimetype)\n+    response = CompatibleStreamingHttpResponse(open(fullpath, 'rb'), content_type=mimetype)\n     response[\"Last-Modified\"] = http_date(statobj.st_mtime)\n     if stat.S_ISREG(statobj.st_mode):\n         response[\"Content-Length\"] = statobj.st_size"
        },
        {
            "sha": "89d0fe847ceabe9def8dbb4bdc7078773229d89f",
            "filename": "docs/ref/request-response.txt",
            "status": "modified",
            "additions": 81,
            "deletions": 6,
            "changes": 87,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/docs%2Fref%2Frequest-response.txt",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/docs%2Fref%2Frequest-response.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Frequest-response.txt?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -566,13 +566,21 @@ file-like object::\n Passing iterators\n ~~~~~~~~~~~~~~~~~\n \n-Finally, you can pass ``HttpResponse`` an iterator rather than passing it\n-hard-coded strings. If you use this technique, follow these guidelines:\n+Finally, you can pass ``HttpResponse`` an iterator rather than strings. If you\n+use this technique, the iterator should return strings.\n \n-* The iterator should return strings.\n-* If an :class:`HttpResponse` has been initialized with an iterator as its\n-  content, you can't use the :class:`HttpResponse` instance as a file-like\n-  object. Doing so will raise ``Exception``.\n+.. versionchanged:: 1.5\n+\n+    Passing an iterator as content to :class:`HttpResponse` creates a\n+    streaming response if (and only if) no middleware accesses the\n+    :attr:`HttpResponse.content` attribute before the response is returned.\n+\n+    If you want to guarantee that your response will stream to the client, you\n+    should use the new :class:`StreamingHttpResponse` class instead.\n+\n+If an :class:`HttpResponse` instance has been initialized with an iterator as\n+its content, you can't use it as a file-like object. Doing so will raise an\n+exception.\n \n Setting headers\n ~~~~~~~~~~~~~~~\n@@ -614,6 +622,13 @@ Attributes\n \n     The `HTTP Status code`_ for the response.\n \n+.. attribute:: HttpResponse.streaming\n+\n+    This is always ``False``.\n+\n+    This attribute exists so middleware can treat streaming responses\n+    differently from regular responses.\n+\n Methods\n -------\n \n@@ -781,3 +796,63 @@ types of HTTP responses. Like ``HttpResponse``, these subclasses live in\n     method, Django will treat it as emulating a\n     :class:`~django.template.response.SimpleTemplateResponse`, and the\n     ``render`` method must itself return a valid response object.\n+\n+StreamingHttpResponse objects\n+=============================\n+\n+.. versionadded:: 1.5\n+\n+.. class:: StreamingHttpResponse\n+\n+The :class:`StreamingHttpResponse` class is used to stream a response from\n+Django to the browser. You might want to do this if generating the response\n+takes too long or uses too much memory. For instance, it's useful for\n+generating large CSV files.\n+\n+.. admonition:: Performance considerations\n+\n+    Django is designed for short-lived requests. Streaming responses will tie\n+    a worker process and keep a database connection idle in transaction for\n+    the entire duration of the response. This may result in poor performance.\n+\n+    Generally speaking, you should perform expensive tasks outside of the\n+    request-response cycle, rather than resorting to a streamed response.\n+\n+The :class:`StreamingHttpResponse` is not a subclass of :class:`HttpResponse`,\n+because it features a slightly different API. However, it is almost identical,\n+with the following notable differences:\n+\n+* It should be given an iterator that yields strings as content.\n+\n+* You cannot access its content, except by iterating the response object\n+  itself. This should only occur when the response is returned to the client.\n+\n+* It has no ``content`` attribute. Instead, it has a\n+  :attr:`~StreamingHttpResponse.streaming_content` attribute.\n+\n+* You cannot use the file-like object ``tell()`` or ``write()`` methods.\n+  Doing so will raise an exception.\n+\n+* Any iterators that have a ``close()`` method and are assigned as content will\n+  be closed automatically after the response has been iterated.\n+\n+:class:`StreamingHttpResponse` should only be used in situations where it is\n+absolutely required that the whole content isn't iterated before transferring\n+the data to the client. Because the content can't be accessed, many\n+middlewares can't function normally. For example the ``ETag`` and ``Content-\n+Length`` headers can't be generated for streaming responses.\n+\n+Attributes\n+----------\n+\n+.. attribute:: StreamingHttpResponse.streaming_content\n+\n+    An iterator of strings representing the content.\n+\n+.. attribute:: HttpResponse.status_code\n+\n+    The `HTTP Status code`_ for the response.\n+\n+.. attribute:: HttpResponse.streaming\n+\n+    This is always ``True``."
        },
        {
            "sha": "f7467bc06a1a6c40ef274d49f409718e867c8679",
            "filename": "docs/releases/1.5.txt",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/docs%2Freleases%2F1.5.txt",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/docs%2Freleases%2F1.5.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.5.txt?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -84,6 +84,24 @@ For one-to-one relationships, both sides can be cached. For many-to-one\n relationships, only the single side of the relationship can be cached. This\n is particularly helpful in combination with ``prefetch_related``.\n \n+Explicit support for streaming responses\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Before Django 1.5, it was possible to create a streaming response by passing\n+an iterator to :class:`~django.http.HttpResponse`. But this was unreliable:\n+any middleware that accessed the :attr:`~django.http.HttpResponse.content`\n+attribute would consume the iterator prematurely.\n+\n+You can now explicitly generate a streaming response with the new\n+:class:`~django.http.StreamingHttpResponse` class. This class exposes a\n+:class:`~django.http.StreamingHttpResponse.streaming_content` attribute which\n+is an iterator.\n+\n+Since :class:`~django.http.StreamingHttpResponse` does not have a ``content``\n+attribute, middleware that need access to the response content must test for\n+streaming responses and behave accordingly. See :ref:`response-middleware` for\n+more information.\n+\n ``{% verbatim %}`` template tag\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "c27e7e86908656115cd778fa5f09218c448c1c3e",
            "filename": "docs/topics/http/middleware.txt",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/docs%2Ftopics%2Fhttp%2Fmiddleware.txt",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/docs%2Ftopics%2Fhttp%2Fmiddleware.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fhttp%2Fmiddleware.txt?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -164,6 +164,23 @@ an earlier middleware method returned an :class:`~django.http.HttpResponse`\n classes are applied in reverse order, from the bottom up. This means classes\n defined at the end of :setting:`MIDDLEWARE_CLASSES` will be run first.\n \n+.. versionchanged:: 1.5\n+    ``response`` may also be an :class:`~django.http.StreamingHttpResponse`\n+    object.\n+\n+Unlike :class:`~django.http.HttpResponse`,\n+:class:`~django.http.StreamingHttpResponse` does not have a ``content``\n+attribute. As a result, middleware can no longer assume that all responses\n+will have a ``content`` attribute. If they need access to the content, they\n+must test for streaming responses and adjust their behavior accordingly::\n+\n+    if response.streaming:\n+        response.streaming_content = wrap_streaming_content(response.streaming_content)\n+    else:\n+        response.content = wrap_content(response.content)\n+\n+``streaming_content`` should be assumed to be too large to hold in memory.\n+Middleware may wrap it in a new generator, but must not consume it.\n \n .. _exception-middleware:\n "
        },
        {
            "sha": "a6eff8950bf87a77de46c2257d420260eb645d29",
            "filename": "tests/regressiontests/cache/tests.py",
            "status": "modified",
            "additions": 25,
            "deletions": 1,
            "changes": 26,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/tests%2Fregressiontests%2Fcache%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/tests%2Fregressiontests%2Fcache%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fcache%2Ftests.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -19,7 +19,8 @@\n from django.core.cache.backends.base import (CacheKeyWarning,\n     InvalidCacheBackendError)\n from django.db import router\n-from django.http import HttpResponse, HttpRequest, QueryDict\n+from django.http import (HttpResponse, HttpRequest, StreamingHttpResponse,\n+    QueryDict)\n from django.middleware.cache import (FetchFromCacheMiddleware,\n     UpdateCacheMiddleware, CacheMiddleware)\n from django.template import Template\n@@ -1416,6 +1417,29 @@ def set_cache(request, lang, msg):\n         # reset the language\n         translation.deactivate()\n \n+    @override_settings(\n+            CACHE_MIDDLEWARE_KEY_PREFIX=\"test\",\n+            CACHE_MIDDLEWARE_SECONDS=60,\n+            USE_ETAGS=True,\n+    )\n+    def test_middleware_with_streaming_response(self):\n+        # cache with non empty request.GET\n+        request = self._get_request_cache(query_string='foo=baz&other=true')\n+\n+        # first access, cache must return None\n+        get_cache_data = FetchFromCacheMiddleware().process_request(request)\n+        self.assertEqual(get_cache_data, None)\n+\n+        # pass streaming response through UpdateCacheMiddleware.\n+        content = 'Check for cache with QUERY_STRING and streaming content'\n+        response = StreamingHttpResponse(content)\n+        UpdateCacheMiddleware().process_response(request, response)\n+\n+        # second access, cache must still return None, because we can't cache\n+        # streaming response.\n+        get_cache_data = FetchFromCacheMiddleware().process_request(request)\n+        self.assertEqual(get_cache_data, None)\n+\n \n @override_settings(\n         CACHES={"
        },
        {
            "sha": "6bac42b3ad094791e5643b984c67d61f2511e342",
            "filename": "tests/regressiontests/httpwrappers/abc.txt",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/tests%2Fregressiontests%2Fhttpwrappers%2Fabc.txt",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/tests%2Fregressiontests%2Fhttpwrappers%2Fabc.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fhttpwrappers%2Fabc.txt?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -0,0 +1 @@\n+random content"
        },
        {
            "sha": "bfb4ae1fd5520e4662aaab6a6372dcedc9cc06e4",
            "filename": "tests/regressiontests/httpwrappers/tests.py",
            "status": "modified",
            "additions": 109,
            "deletions": 2,
            "changes": 111,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/tests%2Fregressiontests%2Fhttpwrappers%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/tests%2Fregressiontests%2Fhttpwrappers%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fhttpwrappers%2Ftests.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -2,12 +2,13 @@\n from __future__ import unicode_literals\n \n import copy\n+import os\n import pickle\n \n from django.core.exceptions import SuspiciousOperation\n from django.http import (QueryDict, HttpResponse, HttpResponseRedirect,\n                          HttpResponsePermanentRedirect, HttpResponseNotAllowed,\n-                         HttpResponseNotModified,\n+                         HttpResponseNotModified, StreamingHttpResponse,\n                          SimpleCookie, BadHeaderError,\n                          parse_cookie)\n from django.test import TestCase\n@@ -351,7 +352,6 @@ def test_unsafe_redirect(self):\n             self.assertRaises(SuspiciousOperation,\n                               HttpResponsePermanentRedirect, url)\n \n-\n class HttpResponseSubclassesTests(TestCase):\n     def test_redirect(self):\n         response = HttpResponseRedirect('/redirected/')\n@@ -379,6 +379,113 @@ def test_not_allowed(self):\n             content_type='text/html')\n         self.assertContains(response, 'Only the GET method is allowed', status_code=405)\n \n+class StreamingHttpResponseTests(TestCase):\n+    def test_streaming_response(self):\n+        r = StreamingHttpResponse(iter(['hello', 'world']))\n+\n+        # iterating over the response itself yields bytestring chunks.\n+        chunks = list(r)\n+        self.assertEqual(chunks, [b'hello', b'world'])\n+        for chunk in chunks:\n+            self.assertIsInstance(chunk, six.binary_type)\n+\n+        # and the response can only be iterated once.\n+        self.assertEqual(list(r), [])\n+\n+        # even when a sequence that can be iterated many times, like a list,\n+        # is given as content.\n+        r = StreamingHttpResponse(['abc', 'def'])\n+        self.assertEqual(list(r), [b'abc', b'def'])\n+        self.assertEqual(list(r), [])\n+\n+        # streaming responses don't have a `content` attribute.\n+        self.assertFalse(hasattr(r, 'content'))\n+\n+        # and you can't accidentally assign to a `content` attribute.\n+        with self.assertRaises(AttributeError):\n+            r.content = 'xyz'\n+\n+        # but they do have a `streaming_content` attribute.\n+        self.assertTrue(hasattr(r, 'streaming_content'))\n+\n+        # that exists so we can check if a response is streaming, and wrap or\n+        # replace the content iterator.\n+        r.streaming_content = iter(['abc', 'def'])\n+        r.streaming_content = (chunk.upper() for chunk in r.streaming_content)\n+        self.assertEqual(list(r), [b'ABC', b'DEF'])\n+\n+        # coercing a streaming response to bytes doesn't return a complete HTTP\n+        # message like a regular response does. it only gives us the headers.\n+        r = StreamingHttpResponse(iter(['hello', 'world']))\n+        self.assertEqual(\n+            six.binary_type(r), b'Content-Type: text/html; charset=utf-8')\n+\n+        # and this won't consume its content.\n+        self.assertEqual(list(r), [b'hello', b'world'])\n+\n+        # additional content cannot be written to the response.\n+        r = StreamingHttpResponse(iter(['hello', 'world']))\n+        with self.assertRaises(Exception):\n+            r.write('!')\n+\n+        # and we can't tell the current position.\n+        with self.assertRaises(Exception):\n+            r.tell()\n+\n+class FileCloseTests(TestCase):\n+    def test_response(self):\n+        filename = os.path.join(os.path.dirname(__file__), 'abc.txt')\n+\n+        # file isn't closed until we close the response.\n+        file1 = open(filename)\n+        r = HttpResponse(file1)\n+        self.assertFalse(file1.closed)\n+        r.close()\n+        self.assertTrue(file1.closed)\n+\n+        # don't automatically close file when we finish iterating the response.\n+        file1 = open(filename)\n+        r = HttpResponse(file1)\n+        self.assertFalse(file1.closed)\n+        list(r)\n+        self.assertFalse(file1.closed)\n+        r.close()\n+        self.assertTrue(file1.closed)\n+\n+        # when multiple file are assigned as content, make sure they are all\n+        # closed with the response.\n+        file1 = open(filename)\n+        file2 = open(filename)\n+        r = HttpResponse(file1)\n+        r.content = file2\n+        self.assertFalse(file1.closed)\n+        self.assertFalse(file2.closed)\n+        r.close()\n+        self.assertTrue(file1.closed)\n+        self.assertTrue(file2.closed)\n+\n+    def test_streaming_response(self):\n+        filename = os.path.join(os.path.dirname(__file__), 'abc.txt')\n+\n+        # file isn't closed until we close the response.\n+        file1 = open(filename)\n+        r = StreamingHttpResponse(file1)\n+        self.assertFalse(file1.closed)\n+        r.close()\n+        self.assertTrue(file1.closed)\n+\n+        # when multiple file are assigned as content, make sure they are all\n+        # closed with the response.\n+        file1 = open(filename)\n+        file2 = open(filename)\n+        r = StreamingHttpResponse(file1)\n+        r.streaming_content = file2\n+        self.assertFalse(file1.closed)\n+        self.assertFalse(file2.closed)\n+        r.close()\n+        self.assertTrue(file1.closed)\n+        self.assertTrue(file2.closed)\n+\n class CookieTests(unittest.TestCase):\n     def test_encode(self):\n         \"\"\""
        },
        {
            "sha": "de901f4a800450cf11b9200d8c14e35953a01cfa",
            "filename": "tests/regressiontests/middleware/tests.py",
            "status": "modified",
            "additions": 42,
            "deletions": 1,
            "changes": 43,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/tests%2Fregressiontests%2Fmiddleware%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/tests%2Fregressiontests%2Fmiddleware%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fmiddleware%2Ftests.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -8,7 +8,7 @@\n from django.conf import settings\n from django.core import mail\n from django.http import HttpRequest\n-from django.http import HttpResponse\n+from django.http import HttpResponse, StreamingHttpResponse\n from django.middleware.clickjacking import XFrameOptionsMiddleware\n from django.middleware.common import CommonMiddleware\n from django.middleware.http import ConditionalGetMiddleware\n@@ -322,6 +322,12 @@ def test_content_length_header_added(self):\n         self.assertTrue('Content-Length' in self.resp)\n         self.assertEqual(int(self.resp['Content-Length']), content_length)\n \n+    def test_content_length_header_not_added(self):\n+        resp = StreamingHttpResponse('content')\n+        self.assertFalse('Content-Length' in resp)\n+        resp = ConditionalGetMiddleware().process_response(self.req, resp)\n+        self.assertFalse('Content-Length' in resp)\n+\n     def test_content_length_header_not_changed(self):\n         bad_content_length = len(self.resp.content) + 10\n         self.resp['Content-Length'] = bad_content_length\n@@ -351,6 +357,29 @@ def test_if_none_match_and_different_etag(self):\n         self.resp = ConditionalGetMiddleware().process_response(self.req, self.resp)\n         self.assertEqual(self.resp.status_code, 200)\n \n+    @override_settings(USE_ETAGS=True)\n+    def test_etag(self):\n+        req = HttpRequest()\n+        res = HttpResponse('content')\n+        self.assertTrue(\n+            CommonMiddleware().process_response(req, res).has_header('ETag'))\n+\n+    @override_settings(USE_ETAGS=True)\n+    def test_etag_streaming_response(self):\n+        req = HttpRequest()\n+        res = StreamingHttpResponse(['content'])\n+        res['ETag'] = 'tomatoes'\n+        self.assertEqual(\n+            CommonMiddleware().process_response(req, res).get('ETag'),\n+            'tomatoes')\n+\n+    @override_settings(USE_ETAGS=True)\n+    def test_no_etag_streaming_response(self):\n+        req = HttpRequest()\n+        res = StreamingHttpResponse(['content'])\n+        self.assertFalse(\n+            CommonMiddleware().process_response(req, res).has_header('ETag'))\n+\n     # Tests for the Last-Modified header\n \n     def test_if_modified_since_and_no_last_modified(self):\n@@ -511,6 +540,7 @@ class GZipMiddlewareTest(TestCase):\n     short_string = b\"This string is too short to be worth compressing.\"\n     compressible_string = b'a' * 500\n     uncompressible_string = b''.join(six.int2byte(random.randint(0, 255)) for _ in xrange(500))\n+    sequence = [b'a' * 500, b'b' * 200, b'a' * 300]\n \n     def setUp(self):\n         self.req = HttpRequest()\n@@ -525,6 +555,8 @@ def setUp(self):\n         self.resp.status_code = 200\n         self.resp.content = self.compressible_string\n         self.resp['Content-Type'] = 'text/html; charset=UTF-8'\n+        self.stream_resp = StreamingHttpResponse(self.sequence)\n+        self.stream_resp['Content-Type'] = 'text/html; charset=UTF-8'\n \n     @staticmethod\n     def decompress(gzipped_string):\n@@ -539,6 +571,15 @@ def test_compress_response(self):\n         self.assertEqual(r.get('Content-Encoding'), 'gzip')\n         self.assertEqual(r.get('Content-Length'), str(len(r.content)))\n \n+    def test_compress_streaming_response(self):\n+        \"\"\"\n+        Tests that compression is performed on responses with streaming content.\n+        \"\"\"\n+        r = GZipMiddleware().process_response(self.req, self.stream_resp)\n+        self.assertEqual(self.decompress(b''.join(r)), b''.join(self.sequence))\n+        self.assertEqual(r.get('Content-Encoding'), 'gzip')\n+        self.assertFalse(r.has_header('Content-Length'))\n+\n     def test_compress_non_200_response(self):\n         \"\"\"\n         Tests that compression is performed on responses with a status other than 200."
        },
        {
            "sha": "221244a4a5b5072407e60d2e22dabb93b3e27f71",
            "filename": "tests/regressiontests/views/tests/static.py",
            "status": "modified",
            "additions": 19,
            "deletions": 8,
            "changes": 27,
            "blob_url": "https://github.com/django/django/blob/4b27813198ae31892f1159d437e492f7745761a0/tests%2Fregressiontests%2Fviews%2Ftests%2Fstatic.py",
            "raw_url": "https://github.com/django/django/raw/4b27813198ae31892f1159d437e492f7745761a0/tests%2Fregressiontests%2Fviews%2Ftests%2Fstatic.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fviews%2Ftests%2Fstatic.py?ref=4b27813198ae31892f1159d437e492f7745761a0",
            "patch": "@@ -31,28 +31,35 @@ def test_serve(self):\n         media_files = ['file.txt', 'file.txt.gz']\n         for filename in media_files:\n             response = self.client.get('/views/%s/%s' % (self.prefix, filename))\n+            response_content = b''.join(response)\n+            response.close()\n             file_path = path.join(media_dir, filename)\n             with open(file_path, 'rb') as fp:\n-                self.assertEqual(fp.read(), response.content)\n-            self.assertEqual(len(response.content), int(response['Content-Length']))\n+                self.assertEqual(fp.read(), response_content)\n+            self.assertEqual(len(response_content), int(response['Content-Length']))\n             self.assertEqual(mimetypes.guess_type(file_path)[1], response.get('Content-Encoding', None))\n \n     def test_unknown_mime_type(self):\n         response = self.client.get('/views/%s/file.unknown' % self.prefix)\n+        response.close()\n         self.assertEqual('application/octet-stream', response['Content-Type'])\n \n     def test_copes_with_empty_path_component(self):\n         file_name = 'file.txt'\n         response = self.client.get('/views/%s//%s' % (self.prefix, file_name))\n+        response_content = b''.join(response)\n+        response.close()\n         with open(path.join(media_dir, file_name), 'rb') as fp:\n-            self.assertEqual(fp.read(), response.content)\n+            self.assertEqual(fp.read(), response_content)\n \n     def test_is_modified_since(self):\n         file_name = 'file.txt'\n         response = self.client.get('/views/%s/%s' % (self.prefix, file_name),\n             HTTP_IF_MODIFIED_SINCE='Thu, 1 Jan 1970 00:00:00 GMT')\n+        response_content = b''.join(response)\n+        response.close()\n         with open(path.join(media_dir, file_name), 'rb') as fp:\n-            self.assertEqual(fp.read(), response.content)\n+            self.assertEqual(fp.read(), response_content)\n \n     def test_not_modified_since(self):\n         file_name = 'file.txt'\n@@ -74,9 +81,11 @@ def test_invalid_if_modified_since(self):\n         invalid_date = 'Mon, 28 May 999999999999 28:25:26 GMT'\n         response = self.client.get('/views/%s/%s' % (self.prefix, file_name),\n                                    HTTP_IF_MODIFIED_SINCE=invalid_date)\n+        response_content = b''.join(response)\n+        response.close()\n         with open(path.join(media_dir, file_name), 'rb') as fp:\n-            self.assertEqual(fp.read(), response.content)\n-        self.assertEqual(len(response.content),\n+            self.assertEqual(fp.read(), response_content)\n+        self.assertEqual(len(response_content),\n                           int(response['Content-Length']))\n \n     def test_invalid_if_modified_since2(self):\n@@ -89,9 +98,11 @@ def test_invalid_if_modified_since2(self):\n         invalid_date = ': 1291108438, Wed, 20 Oct 2010 14:05:00 GMT'\n         response = self.client.get('/views/%s/%s' % (self.prefix, file_name),\n                                    HTTP_IF_MODIFIED_SINCE=invalid_date)\n+        response_content = b''.join(response)\n+        response.close()\n         with open(path.join(media_dir, file_name), 'rb') as fp:\n-            self.assertEqual(fp.read(), response.content)\n-        self.assertEqual(len(response.content),\n+            self.assertEqual(fp.read(), response_content)\n+        self.assertEqual(len(response_content),\n                           int(response['Content-Length']))\n \n "
        }
    ],
    "stats": {
        "total": 608,
        "additions": 533,
        "deletions": 75
    }
}