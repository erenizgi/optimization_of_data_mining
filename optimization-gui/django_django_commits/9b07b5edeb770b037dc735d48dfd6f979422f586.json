{
    "author": "aaugustin",
    "message": "Fixed #18916 -- Allowed non-ASCII headers.\n\nThanks Malcolm Tredinnick for the review.",
    "sha": "9b07b5edeb770b037dc735d48dfd6f979422f586",
    "files": [
        {
            "sha": "ecb39129addfcce5863bf65f9cfbbd49eb68a94f",
            "filename": "django/http/__init__.py",
            "status": "modified",
            "additions": 35,
            "deletions": 21,
            "changes": 56,
            "blob_url": "https://github.com/django/django/blob/9b07b5edeb770b037dc735d48dfd6f979422f586/django%2Fhttp%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/9b07b5edeb770b037dc735d48dfd6f979422f586/django%2Fhttp%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2F__init__.py?ref=9b07b5edeb770b037dc735d48dfd6f979422f586",
            "patch": "@@ -2,6 +2,7 @@\n \n import copy\n import datetime\n+from email.header import Header\n import os\n import re\n import sys\n@@ -560,31 +561,44 @@ def serialize(self):\n     else:\n         __str__ = serialize\n \n-    def _convert_to_ascii(self, *values):\n-        \"\"\"Converts all values to ascii strings.\"\"\"\n-        for value in values:\n-            if not isinstance(value, six.string_types):\n-                value = str(value)\n-            try:\n-                if six.PY3:\n-                    # Ensure string only contains ASCII\n-                    value.encode('us-ascii')\n+    def _convert_to_charset(self, value, charset, mime_encode=False):\n+        \"\"\"Converts headers key/value to ascii/latin1 native strings.\n+\n+        `charset` must be 'ascii' or 'latin-1'. If `mime_encode` is True and\n+        `value` value can't be represented in the given charset, MIME-encoding\n+        is applied.\n+        \"\"\"\n+        if not isinstance(value, (bytes, six.text_type)):\n+            value = str(value)\n+        try:\n+            if six.PY3:\n+                if isinstance(value, str):\n+                    # Ensure string is valid in given charset\n+                    value.encode(charset)\n                 else:\n-                    if isinstance(value, str):\n-                        # Ensure string only contains ASCII\n-                        value.decode('us-ascii')\n-                    else:\n-                        # Convert unicode to an ASCII string\n-                        value = value.encode('us-ascii')\n-            except UnicodeError as e:\n-                e.reason += ', HTTP response headers must be in US-ASCII format'\n+                    # Convert bytestring using given charset\n+                    value = value.decode(charset)\n+            else:\n+                if isinstance(value, str):\n+                    # Ensure string is valid in given charset\n+                    value.decode(charset)\n+                else:\n+                    # Convert unicode string to given charset\n+                    value = value.encode(charset)\n+        except UnicodeError as e:\n+            if mime_encode:\n+                # Wrapping in str() is a workaround for #12422 under Python 2.\n+                value = str(Header(value, 'utf-8').encode())\n+            else:\n+                e.reason += ', HTTP response headers must be in %s format' % charset\n                 raise\n-            if '\\n' in value or '\\r' in value:\n-                raise BadHeaderError(\"Header values can't contain newlines (got %r)\" % value)\n-            yield value\n+        if str('\\n') in value or str('\\r') in value:\n+            raise BadHeaderError(\"Header values can't contain newlines (got %r)\" % value)\n+        return value\n \n     def __setitem__(self, header, value):\n-        header, value = self._convert_to_ascii(header, value)\n+        header = self._convert_to_charset(header, 'ascii')\n+        value = self._convert_to_charset(value, 'latin1', mime_encode=True)\n         self._headers[header.lower()] = (header, value)\n \n     def __delitem__(self, header):"
        },
        {
            "sha": "4c6aed1b97a41b8556176721318f3e9585a09470",
            "filename": "tests/regressiontests/httpwrappers/tests.py",
            "status": "modified",
            "additions": 42,
            "deletions": 22,
            "changes": 64,
            "blob_url": "https://github.com/django/django/blob/9b07b5edeb770b037dc735d48dfd6f979422f586/tests%2Fregressiontests%2Fhttpwrappers%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/9b07b5edeb770b037dc735d48dfd6f979422f586/tests%2Fregressiontests%2Fhttpwrappers%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fhttpwrappers%2Ftests.py?ref=9b07b5edeb770b037dc735d48dfd6f979422f586",
            "patch": "@@ -11,6 +11,7 @@\n                          SimpleCookie, BadHeaderError,\n                          parse_cookie)\n from django.test import TestCase\n+from django.utils.encoding import smart_str\n from django.utils import six\n from django.utils import unittest\n \n@@ -228,33 +229,52 @@ def test_non_default_encoding(self):\n         self.assertEqual(copy.deepcopy(q).encoding, 'iso-8859-15')\n \n class HttpResponseTests(unittest.TestCase):\n-    def test_unicode_headers(self):\n-        r = HttpResponse()\n-\n-        # If we insert a unicode value it will be converted to an ascii\n-        r['value'] = 'test value'\n-        self.assertTrue(isinstance(r['value'], str))\n-\n-        # An error is raised when a unicode object with non-ascii is assigned.\n-        self.assertRaises(UnicodeEncodeError, r.__setitem__, 'value', 't\\xebst value')\n \n-        # An error is raised when  a unicode object with non-ASCII format is\n-        # passed as initial mimetype or content_type.\n-        self.assertRaises(UnicodeEncodeError, HttpResponse,\n-                content_type='t\\xebst value')\n+    def test_headers_type(self):\n+        r = HttpResponse()\n \n-        # HttpResponse headers must be convertible to ASCII.\n-        self.assertRaises(UnicodeEncodeError, HttpResponse,\n-                content_type='t\\xebst value')\n+        # The following tests explicitly test types in addition to values\n+        # because in Python 2 u'foo' == b'foo'.\n+\n+        # ASCII unicode or bytes values are converted to native strings.\n+        r['key'] = 'test'\n+        self.assertEqual(r['key'], str('test'))\n+        self.assertIsInstance(r['key'], str)\n+        r['key'] = 'test'.encode('ascii')\n+        self.assertEqual(r['key'], str('test'))\n+        self.assertIsInstance(r['key'], str)\n+\n+        # Latin-1 unicode or bytes values are also converted to native strings.\n+        r['key'] = 'café'\n+        self.assertEqual(r['key'], smart_str('café', 'latin-1'))\n+        self.assertIsInstance(r['key'], str)\n+        r['key'] = 'café'.encode('latin-1')\n+        self.assertEqual(r['key'], smart_str('café', 'latin-1'))\n+        self.assertIsInstance(r['key'], str)\n+\n+        # Other unicode values are MIME-encoded (there's no way to pass them as bytes).\n+        r['key'] = '†'\n+        self.assertEqual(r['key'], str('=?utf-8?b?4oCg?='))\n+        self.assertIsInstance(r['key'], str)\n+\n+        # The response also converts unicode or bytes keys to strings, but requires\n+        # them to contain ASCII\n+        r = HttpResponse()\n+        r['foo'] = 'bar'\n+        l = list(r.items())\n+        self.assertEqual(l[0], ('foo', 'bar'))\n+        self.assertIsInstance(l[0][0], str)\n \n-        # The response also converts unicode keys to strings.)\n-        r['test'] = 'testing key'\n+        r = HttpResponse()\n+        r[b'foo'] = 'bar'\n         l = list(r.items())\n-        l.sort()\n-        self.assertEqual(l[1], ('test', 'testing key'))\n+        self.assertEqual(l[0], ('foo', 'bar'))\n+        self.assertIsInstance(l[0][0], str)\n+\n+        r = HttpResponse()\n+        self.assertRaises(UnicodeError, r.__setitem__, 'føø', 'bar')\n+        self.assertRaises(UnicodeError, r.__setitem__, 'føø'.encode('utf-8'), 'bar')\n \n-        # It will also raise errors for keys with non-ascii data.\n-        self.assertRaises(UnicodeEncodeError, r.__setitem__, 't\\xebst key', 'value')\n \n     def test_newlines_in_headers(self):\n         # Bug #10188: Do not allow newlines in headers (CR or LF)"
        }
    ],
    "stats": {
        "total": 120,
        "additions": 77,
        "deletions": 43
    }
}