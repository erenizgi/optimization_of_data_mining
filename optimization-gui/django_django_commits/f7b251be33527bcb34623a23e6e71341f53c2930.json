{
    "author": "ramiro",
    "message": "Fixed #11436 -- Updated bundled copy of doctests.py to the one shipped with Python 2.5, preserved local tweaks.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16292 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "f7b251be33527bcb34623a23e6e71341f53c2930",
    "files": [
        {
            "sha": "cd562bbd9b16f7a8e1c84b7e3362c8a25c9198b8",
            "filename": "django/test/_doctest.py",
            "status": "modified",
            "additions": 68,
            "deletions": 102,
            "changes": 170,
            "blob_url": "https://github.com/django/django/blob/f7b251be33527bcb34623a23e6e71341f53c2930/django%2Ftest%2F_doctest.py",
            "raw_url": "https://github.com/django/django/raw/f7b251be33527bcb34623a23e6e71341f53c2930/django%2Ftest%2F_doctest.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2F_doctest.py?ref=f7b251be33527bcb34623a23e6e71341f53c2930",
            "patch": "@@ -1,4 +1,4 @@\n-# This is a slightly modified version of the doctest.py that shipped with Python 2.4\n+# This is a slightly modified version of the doctest.py that shipped with Python 2.5\n # It incorporates changes that have been submitted to the Python ticket tracker\n # as ticket #1521051. These changes allow for a DoctestRunner and Doctest base\n # class to be specified when constructing a DoctestSuite.\n@@ -59,6 +59,7 @@ def _test():\n     'DONT_ACCEPT_BLANKLINE',\n     'NORMALIZE_WHITESPACE',\n     'ELLIPSIS',\n+    'SKIP',\n     'IGNORE_EXCEPTION_DETAIL',\n     'COMPARISON_FLAGS',\n     'REPORT_UDIFF',\n@@ -67,7 +68,6 @@ def _test():\n     'REPORT_ONLY_FIRST_FAILURE',\n     'REPORTING_FLAGS',\n     # 1. Utility Functions\n-    'is_private',\n     # 2. Example & DocTest\n     'Example',\n     'DocTest',\n@@ -113,11 +113,6 @@ def patched_isclass(obj):\n         return patched_isclass\n     inspect.isclass = patch_isclass(inspect.isclass)\n \n-# Don't whine about the deprecated is_private function in this\n-# module's tests.\n-warnings.filterwarnings(\"ignore\", \"is_private\", DeprecationWarning,\n-                        __name__, 0)\n-\n # There are 4 basic classes:\n #  - Example: a <source, want> pair, plus an intra-docstring line number.\n #  - DocTest: a collection of examples, parsed from a docstring, plus\n@@ -141,20 +136,21 @@ def patched_isclass(obj):\n \n OPTIONFLAGS_BY_NAME = {}\n def register_optionflag(name):\n-    flag = 1 << len(OPTIONFLAGS_BY_NAME)\n-    OPTIONFLAGS_BY_NAME[name] = flag\n-    return flag\n+    # Create a new flag unless `name` is already known.\n+    return OPTIONFLAGS_BY_NAME.setdefault(name, 1 << len(OPTIONFLAGS_BY_NAME))\n \n DONT_ACCEPT_TRUE_FOR_1 = register_optionflag('DONT_ACCEPT_TRUE_FOR_1')\n DONT_ACCEPT_BLANKLINE = register_optionflag('DONT_ACCEPT_BLANKLINE')\n NORMALIZE_WHITESPACE = register_optionflag('NORMALIZE_WHITESPACE')\n ELLIPSIS = register_optionflag('ELLIPSIS')\n+SKIP = register_optionflag('SKIP')\n IGNORE_EXCEPTION_DETAIL = register_optionflag('IGNORE_EXCEPTION_DETAIL')\n \n COMPARISON_FLAGS = (DONT_ACCEPT_TRUE_FOR_1 |\n                     DONT_ACCEPT_BLANKLINE |\n                     NORMALIZE_WHITESPACE |\n                     ELLIPSIS |\n+                    SKIP |\n                     IGNORE_EXCEPTION_DETAIL)\n \n REPORT_UDIFF = register_optionflag('REPORT_UDIFF')\n@@ -189,35 +185,6 @@ def register_optionflag(name):\n ## 1. Utility Functions\n ######################################################################\n \n-def is_private(prefix, base):\n-    \"\"\"prefix, base -> true iff name prefix + \".\" + base is \"private\".\n-\n-    Prefix may be an empty string, and base does not contain a period.\n-    Prefix is ignored (although functions you write conforming to this\n-    protocol may make use of it).\n-    Return true iff base begins with an (at least one) underscore, but\n-    does not both begin and end with (at least) two underscores.\n-\n-    >>> is_private(\"a.b\", \"my_func\")\n-    False\n-    >>> is_private(\"____\", \"_my_func\")\n-    True\n-    >>> is_private(\"someclass\", \"__init__\")\n-    False\n-    >>> is_private(\"sometypo\", \"__init_\")\n-    True\n-    >>> is_private(\"x.y.z\", \"_\")\n-    True\n-    >>> is_private(\"_x.y.z\", \"__\")\n-    False\n-    >>> is_private(\"\", \"\")  # senseless but consistent\n-    False\n-    \"\"\"\n-    warnings.warn(\"is_private is deprecated; it wasn't useful; \"\n-                  \"examine DocTestFinder.find() lists instead\",\n-                  DeprecationWarning, stacklevel=2)\n-    return base[:1] == \"_\" and not base[:2] == \"__\" == base[-2:]\n-\n def _extract_future_flags(globs):\n     \"\"\"\n     Return the compiler-flags associated with the future features that\n@@ -249,6 +216,18 @@ def _normalize_module(module, depth=2):\n     else:\n         raise TypeError(\"Expected a module, string, or None\")\n \n+def _load_testfile(filename, package, module_relative):\n+    if module_relative:\n+        package = _normalize_module(package, 3)\n+        filename = _module_relative_path(package, filename)\n+        if hasattr(package, '__loader__'):\n+            if hasattr(package.__loader__, 'get_data'):\n+                file_contents = package.__loader__.get_data(filename)\n+                # get_data() opens files as 'rb', so one must do the equivalent\n+                # conversion as universal newlines would do.\n+                return file_contents.replace(os.linesep, '\\n'), filename\n+    return open(filename).read(), filename\n+\n def _indent(s, indent=4):\n     \"\"\"\n     Add the given number of space characters to the beginning every\n@@ -355,15 +334,17 @@ class _OutputRedirectingPdb(pdb.Pdb):\n     def __init__(self, out):\n         self.__out = out\n         self.__debugger_used = False\n-        pdb.Pdb.__init__(self)\n+        pdb.Pdb.__init__(self, stdout=out)\n \n-    def set_trace(self):\n+    def set_trace(self, frame=None):\n         self.__debugger_used = True\n-        pdb.Pdb.set_trace(self)\n+        if frame is None:\n+            frame = sys._getframe().f_back\n+        pdb.Pdb.set_trace(self, frame)\n \n     def set_continue(self):\n-        # Calling set_continue unconditionally would break unit test coverage\n-        # reporting, as Bdb.set_continue calls sys.settrace(None).\n+        # Calling set_continue unconditionally would break unit test\n+        # coverage reporting, as Bdb.set_continue calls sys.settrace(None).\n         if self.__debugger_used:\n             pdb.Pdb.set_continue(self)\n \n@@ -772,7 +753,7 @@ class DocTestFinder:\n     \"\"\"\n \n     def __init__(self, verbose=False, parser=DocTestParser(),\n-                 recurse=True, _namefilter=None, exclude_empty=True):\n+                 recurse=True, exclude_empty=True):\n         \"\"\"\n         Create a new doctest finder.\n \n@@ -792,12 +773,8 @@ def __init__(self, verbose=False, parser=DocTestParser(),\n         self._verbose = verbose\n         self._recurse = recurse\n         self._exclude_empty = exclude_empty\n-        # _namefilter is undocumented, and exists only for temporary backward-\n-        # compatibility support of testmod's deprecated isprivate mess.\n-        self._namefilter = _namefilter\n \n-    def find(self, obj, name=None, module=None, globs=None,\n-             extraglobs=None):\n+    def find(self, obj, name=None, module=None, globs=None, extraglobs=None):\n         \"\"\"\n         Return a list of the DocTests that are defined by the given\n         object's docstring, or by any of its contained objects'\n@@ -875,13 +852,6 @@ def find(self, obj, name=None, module=None, globs=None,\n         self._find(tests, obj, name, module, source_lines, globs, {})\n         return tests\n \n-    def _filter(self, obj, prefix, base):\n-        \"\"\"\n-        Return true if the given object should not be examined.\n-        \"\"\"\n-        return (self._namefilter is not None and\n-                self._namefilter(prefix, base))\n-\n     def _from_module(self, module, object):\n         \"\"\"\n         Return true if the given object is defined in the given\n@@ -923,9 +893,6 @@ def _find(self, tests, obj, name, module, source_lines, globs, seen):\n         # Look for tests in a module's contained objects.\n         if inspect.ismodule(obj) and self._recurse:\n             for valname, val in obj.__dict__.items():\n-                # Check if this contained object should be ignored.\n-                if self._filter(val, name, valname):\n-                    continue\n                 valname = '%s.%s' % (name, valname)\n                 # Recurse to functions & classes.\n                 if ((inspect.isfunction(val) or inspect.isclass(val)) and\n@@ -954,9 +921,6 @@ def _find(self, tests, obj, name, module, source_lines, globs, seen):\n         # Look for tests in a class's contained objects.\n         if inspect.isclass(obj) and self._recurse:\n             for valname, val in obj.__dict__.items():\n-                # Check if this contained object should be ignored.\n-                if self._filter(val, name, valname):\n-                    continue\n                 # Special handling for staticmethod/classmethod.\n                 if isinstance(val, staticmethod):\n                     val = getattr(obj, valname)\n@@ -1248,6 +1212,10 @@ def __run(self, test, compileflags, out):\n                     else:\n                         self.optionflags &= ~optionflag\n \n+            # If 'SKIP' is set, then skip this example.\n+            if self.optionflags & SKIP:\n+                continue\n+\n             # Record that we started this example.\n             tries += 1\n             if not quiet:\n@@ -1349,10 +1317,7 @@ def __patched_linecache_getlines(self, filename, module_globals=None):\n             example = self.test.examples[int(m.group('examplenum'))]\n             return example.source.splitlines(True)\n         else:\n-            if sys.version_info < (2, 5, 0):\n-                return self.save_linecache_getlines(filename)\n-            else:\n-                return self.save_linecache_getlines(filename, module_globals)\n+            return self.save_linecache_getlines(filename, module_globals)\n \n     def run(self, test, compileflags=None, out=None, clear_globs=True):\n         \"\"\"\n@@ -1619,7 +1584,7 @@ class DocTestFailure(Exception):\n \n     - test: the DocTest object being run\n \n-    - excample: the Example object that failed\n+    - example: the Example object that failed\n \n     - got: the actual output\n     \"\"\"\n@@ -1638,7 +1603,7 @@ class UnexpectedException(Exception):\n \n     - test: the DocTest object being run\n \n-    - excample: the Example object that failed\n+    - example: the Example object that failed\n \n     - exc_info: the exception info\n     \"\"\"\n@@ -1762,17 +1727,16 @@ def report_failure(self, out, test, example, got):\n # class, updated by testmod.\n master = None\n \n-def testmod(m=None, name=None, globs=None, verbose=None, isprivate=None,\n+def testmod(m=None, name=None, globs=None, verbose=None,\n             report=True, optionflags=0, extraglobs=None,\n             raise_on_error=False, exclude_empty=False):\n-    \"\"\"m=None, name=None, globs=None, verbose=None, isprivate=None,\n-       report=True, optionflags=0, extraglobs=None, raise_on_error=False,\n+    \"\"\"m=None, name=None, globs=None, verbose=None, report=True,\n+       optionflags=0, extraglobs=None, raise_on_error=False,\n        exclude_empty=False\n \n     Test examples in docstrings in functions and classes reachable\n     from module m (or the current module if m is not supplied), starting\n-    with m.__doc__.  Unless isprivate is specified, private names\n-    are not skipped.\n+    with m.__doc__.\n \n     Also test examples reachable from dict m.__test__ if it exists and is\n     not None.  m.__test__ maps names to functions, classes and strings;\n@@ -1810,6 +1774,7 @@ def testmod(m=None, name=None, globs=None, verbose=None, isprivate=None,\n         DONT_ACCEPT_BLANKLINE\n         NORMALIZE_WHITESPACE\n         ELLIPSIS\n+        SKIP\n         IGNORE_EXCEPTION_DETAIL\n         REPORT_UDIFF\n         REPORT_CDIFF\n@@ -1820,13 +1785,6 @@ def testmod(m=None, name=None, globs=None, verbose=None, isprivate=None,\n     first unexpected exception or failure. This allows failures to be\n     post-mortem debugged.\n \n-    Deprecated in Python 2.4:\n-    Optional keyword arg \"isprivate\" specifies a function used to\n-    determine whether a name is private.  The default function is\n-    treat all functions as public.  Optionally, \"isprivate\" can be\n-    set to doctest.is_private to skip over functions marked as private\n-    using the underscore naming convention; see its docs for details.\n-\n     Advanced tomfoolery:  testmod runs methods of a local instance of\n     class doctest.Tester, then merges the results into (or creates)\n     global Tester instance doctest.master.  Methods of doctest.master\n@@ -1837,11 +1795,6 @@ class doctest.Tester, then merges the results into (or creates)\n     \"\"\"\n     global master\n \n-    if isprivate is not None:\n-        warnings.warn(\"the isprivate argument is deprecated; \"\n-                      \"examine DocTestFinder.find() lists instead\",\n-                      DeprecationWarning)\n-\n     # If no module was given, then use __main__.\n     if m is None:\n         # DWA - m will still be None if this wasn't invoked from the command\n@@ -1858,7 +1811,7 @@ class doctest.Tester, then merges the results into (or creates)\n         name = m.__name__\n \n     # Find, parse, and run all tests in the given module.\n-    finder = DocTestFinder(_namefilter=isprivate, exclude_empty=exclude_empty)\n+    finder = DocTestFinder(exclude_empty=exclude_empty)\n \n     if raise_on_error:\n         runner = DebugRunner(verbose=verbose, optionflags=optionflags)\n@@ -1880,7 +1833,8 @@ class doctest.Tester, then merges the results into (or creates)\n \n def testfile(filename, module_relative=True, name=None, package=None,\n              globs=None, verbose=None, report=True, optionflags=0,\n-             extraglobs=None, raise_on_error=False, parser=DocTestParser()):\n+             extraglobs=None, raise_on_error=False, parser=DocTestParser(),\n+             encoding=None):\n     \"\"\"\n     Test examples in the given file.  Return (#failures, #tests).\n \n@@ -1932,6 +1886,7 @@ def testfile(filename, module_relative=True, name=None, package=None,\n         DONT_ACCEPT_BLANKLINE\n         NORMALIZE_WHITESPACE\n         ELLIPSIS\n+        SKIP\n         IGNORE_EXCEPTION_DETAIL\n         REPORT_UDIFF\n         REPORT_CDIFF\n@@ -1945,6 +1900,9 @@ def testfile(filename, module_relative=True, name=None, package=None,\n     Optional keyword arg \"parser\" specifies a DocTestParser (or\n     subclass) that should be used to extract tests from the files.\n \n+    Optional keyword arg \"encoding\" specifies an encoding that should\n+    be used to convert the file to unicode.\n+\n     Advanced tomfoolery:  testmod runs methods of a local instance of\n     class doctest.Tester, then merges the results into (or creates)\n     global Tester instance doctest.master.  Methods of doctest.master\n@@ -1960,9 +1918,7 @@ class doctest.Tester, then merges the results into (or creates)\n                          \"relative paths.\")\n \n     # Relativize the path\n-    if module_relative:\n-        package = _normalize_module(package)\n-        filename = _module_relative_path(package, filename)\n+    text, filename = _load_testfile(filename, package, module_relative)\n \n     # If no name was given, then use the file's name.\n     if name is None:\n@@ -1981,9 +1937,11 @@ class doctest.Tester, then merges the results into (or creates)\n     else:\n         runner = DocTestRunner(verbose=verbose, optionflags=optionflags)\n \n+    if encoding is not None:\n+        text = text.decode(encoding)\n+\n     # Read the file, convert it to a test, and run it.\n-    s = open(filename).read()\n-    test = parser.get_doctest(s, globs, name, filename, 0)\n+    test = parser.get_doctest(text, globs, name, filename, 0)\n     runner.run(test)\n \n     if report:\n@@ -2026,8 +1984,7 @@ def run_docstring_examples(f, globs, verbose=False, name=\"NoName\",\n # actually used in any way.\n \n class Tester:\n-    def __init__(self, mod=None, globs=None, verbose=None,\n-                 isprivate=None, optionflags=0):\n+    def __init__(self, mod=None, globs=None, verbose=None, optionflags=0):\n \n         warnings.warn(\"class Tester is deprecated; \"\n                       \"use class doctest.DocTestRunner instead\",\n@@ -2042,9 +1999,8 @@ def __init__(self, mod=None, globs=None, verbose=None,\n         self.globs = globs\n \n         self.verbose = verbose\n-        self.isprivate = isprivate\n         self.optionflags = optionflags\n-        self.testfinder = DocTestFinder(_namefilter=isprivate)\n+        self.testfinder = DocTestFinder()\n         self.testrunner = DocTestRunner(verbose=verbose,\n                                         optionflags=optionflags)\n \n@@ -2353,22 +2309,29 @@ def format_failure(self, err):\n                 )\n \n def DocFileTest(path, module_relative=True, package=None,\n-                globs=None, parser=DocTestParser(), **options):\n+                globs=None, parser=DocTestParser(),\n+                encoding=None, **options):\n     if globs is None:\n         globs = {}\n+    else:\n+        globs = globs.copy()\n \n     if package and not module_relative:\n         raise ValueError(\"Package may only be specified for module-\"\n                          \"relative paths.\")\n \n     # Relativize the path.\n-    if module_relative:\n-        package = _normalize_module(package)\n-        path = _module_relative_path(package, path)\n+    doc, path = _load_testfile(path, package, module_relative)\n+\n+    if \"__file__\" not in globs:\n+        globs[\"__file__\"] = path\n \n     # Find the file and read it.\n     name = os.path.basename(path)\n-    doc = open(path).read()\n+\n+    # If an encoding is specified, use it to convert the file to unicode\n+    if encoding is not None:\n+        doc = doc.decode(encoding)\n \n     # Convert it to a test, and wrap it in a DocFileCase.\n     test = parser.get_doctest(doc, globs, name, path, 0)\n@@ -2426,6 +2389,9 @@ def DocFileSuite(*paths, **kw):\n     parser\n       A DocTestParser (or subclass) that should be used to extract\n       tests from the files.\n+\n+    encoding\n+      An encoding that will be used to convert the files to unicode.\n     \"\"\"\n     suite = unittest.TestSuite()\n "
        }
    ],
    "stats": {
        "total": 170,
        "additions": 68,
        "deletions": 102
    }
}