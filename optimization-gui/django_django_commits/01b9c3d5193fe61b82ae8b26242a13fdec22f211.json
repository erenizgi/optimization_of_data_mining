{
    "author": "akaariai",
    "message": "Fixed #16715 -- Fixed join promotion logic for nested nullable FKs\n\nThe joins for nested nullable foreign keys were often created as INNER\nwhen they should have been OUTER joins. The reason was that only the\nfirst join in the chain was promoted correctly. There were also issues\nwith select_related etc.\n\nThe basic structure for this problem was:\n  A -[nullable]-> B -[nonnull]-> C\n\nAnd the basic problem was that the A->B join was correctly LOUTER,\nthe B->C join not.\n\nThe major change taken in this patch is that now if we promote a join\nA->B, we will automatically promote joins B->X for all X in the query.\nAlso, we now make sure there aren't ever join chains like:\n   a LOUTER b INNER c\nIf the a -> b needs to be LOUTER, then the INNER at the end of the\nchain will cancel the LOUTER join and we have a broken query.\n\nSebastian reported this problem and did also major portions of the\npatch.",
    "sha": "01b9c3d5193fe61b82ae8b26242a13fdec22f211",
    "files": [
        {
            "sha": "cf7cad29bd42e9af4a4c15694d2d91d611b522db",
            "filename": "django/db/models/sql/compiler.py",
            "status": "modified",
            "additions": 4,
            "deletions": 8,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/01b9c3d5193fe61b82ae8b26242a13fdec22f211/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "raw_url": "https://github.com/django/django/raw/01b9c3d5193fe61b82ae8b26242a13fdec22f211/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fcompiler.py?ref=01b9c3d5193fe61b82ae8b26242a13fdec22f211",
            "patch": "@@ -470,9 +470,7 @@ def _setup_joins(self, pieces, opts, alias):\n         # Must use left outer joins for nullable fields and their relations.\n         # Ordering or distinct must not affect the returned set, and INNER\n         # JOINS for nullable fields could do this.\n-        if joins_to_promote:\n-            self.query.promote_alias_chain(joins_to_promote,\n-                self.query.alias_map[joins_to_promote[0]].join_type == self.query.LOUTER)\n+        self.query.promote_joins(joins_to_promote)\n         return field, col, alias, joins, opts\n \n     def _final_join_removal(self, col, alias):\n@@ -645,8 +643,6 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n                     alias_chain.append(alias)\n                     for (dupe_opts, dupe_col) in dupe_set:\n                         self.query.update_dupe_avoidance(dupe_opts, dupe_col, alias)\n-                if self.query.alias_map[root_alias].join_type == self.query.LOUTER:\n-                    self.query.promote_alias_chain(alias_chain, True)\n             else:\n                 alias = root_alias\n \n@@ -663,8 +659,6 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n             columns, aliases = self.get_default_columns(start_alias=alias,\n                     opts=f.rel.to._meta, as_pairs=True)\n             self.query.related_select_cols.extend(columns)\n-            if self.query.alias_map[alias].join_type == self.query.LOUTER:\n-                self.query.promote_alias_chain(aliases, True)\n             self.query.related_select_fields.extend(f.rel.to._meta.fields)\n             if restricted:\n                 next = requested.get(f.name, {})\n@@ -738,7 +732,9 @@ def fill_related_selections(self, opts=None, root_alias=None, cur_depth=1,\n                 self.query.related_select_fields.extend(model._meta.fields)\n \n                 next = requested.get(f.related_query_name(), {})\n-                new_nullable = f.null or None\n+                # Use True here because we are looking at the _reverse_ side of\n+                # the relation, which is always nullable.\n+                new_nullable = True\n \n                 self.fill_related_selections(model._meta, table, cur_depth+1,\n                     used, next, restricted, new_nullable)"
        },
        {
            "sha": "1915efa7b9bb6ed0c23f8cc95e9e373185642fb5",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 48,
            "deletions": 49,
            "changes": 97,
            "blob_url": "https://github.com/django/django/blob/01b9c3d5193fe61b82ae8b26242a13fdec22f211/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/01b9c3d5193fe61b82ae8b26242a13fdec22f211/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=01b9c3d5193fe61b82ae8b26242a13fdec22f211",
            "patch": "@@ -505,7 +505,7 @@ def combine(self, rhs, connector):\n                 # Again, some of the tables won't have aliases due to\n                 # the trimming of unnecessary tables.\n                 if self.alias_refcount.get(alias) or rhs.alias_refcount.get(alias):\n-                    self.promote_alias(alias, True)\n+                    self.promote_joins([alias], True)\n \n         # Now relabel a copy of the rhs where-clause and add it to the current\n         # one.\n@@ -682,32 +682,38 @@ def unref_alias(self, alias, amount=1):\n         \"\"\" Decreases the reference count for this alias. \"\"\"\n         self.alias_refcount[alias] -= amount\n \n-    def promote_alias(self, alias, unconditional=False):\n-        \"\"\"\n-        Promotes the join type of an alias to an outer join if it's possible\n-        for the join to contain NULL values on the left. If 'unconditional' is\n-        False, the join is only promoted if it is nullable, otherwise it is\n-        always promoted.\n-\n-        Returns True if the join was promoted by this call.\n-        \"\"\"\n-        if ((unconditional or self.alias_map[alias].nullable) and\n-                self.alias_map[alias].join_type != self.LOUTER):\n-            data = self.alias_map[alias]\n-            data = data._replace(join_type=self.LOUTER)\n-            self.alias_map[alias] = data\n-            return True\n-        return False\n-\n-    def promote_alias_chain(self, chain, must_promote=False):\n-        \"\"\"\n-        Walks along a chain of aliases, promoting the first nullable join and\n-        any joins following that. If 'must_promote' is True, all the aliases in\n-        the chain are promoted.\n-        \"\"\"\n-        for alias in chain:\n-            if self.promote_alias(alias, must_promote):\n-                must_promote = True\n+    def promote_joins(self, aliases, unconditional=False):\n+        \"\"\"\n+        Promotes recursively the join type of given aliases and its children to\n+        an outer join. If 'unconditional' is False, the join is only promoted if\n+        it is nullable or the parent join is an outer join.\n+\n+        Note about join promotion: When promoting any alias, we make sure all\n+        joins which start from that alias are promoted, too. When adding a join\n+        in join(), we make sure any join added to already existing LOUTER join\n+        is generated as LOUTER. This ensures we don't ever have broken join\n+        chains which contain first a LOUTER join, then an INNER JOIN, that is\n+        this kind of join should never be generated: a LOUTER b INNER c. The\n+        reason for avoiding this type of join chain is that the INNER after\n+        the LOUTER will effectively remove any effect the LOUTER had.\n+        \"\"\"\n+        aliases = list(aliases)\n+        while aliases:\n+            alias = aliases.pop(0)\n+            parent_alias = self.alias_map[alias].lhs_alias\n+            parent_louter = (parent_alias\n+                and self.alias_map[parent_alias].join_type == self.LOUTER)\n+            already_louter = self.alias_map[alias].join_type == self.LOUTER\n+            if ((unconditional or self.alias_map[alias].nullable\n+                 or parent_louter) and not already_louter):\n+                data = self.alias_map[alias]._replace(join_type=self.LOUTER)\n+                self.alias_map[alias] = data\n+                # Join type of 'alias' changed, so re-examine all aliases that\n+                # refer to this one.\n+                aliases.extend(\n+                    join for join in self.alias_map.keys()\n+                    if (self.alias_map[join].lhs_alias == alias\n+                        and join not in aliases))\n \n     def reset_refcounts(self, to_counts):\n         \"\"\"\n@@ -726,19 +732,10 @@ def promote_unused_aliases(self, initial_refcounts, used_aliases):\n         then and which ones haven't been used and promotes all of those\n         aliases, plus any children of theirs in the alias tree, to outer joins.\n         \"\"\"\n-        # FIXME: There's some (a lot of!) overlap with the similar OR promotion\n-        # in add_filter(). It's not quite identical, but is very similar. So\n-        # pulling out the common bits is something for later.\n-        considered = {}\n         for alias in self.tables:\n-            if alias not in used_aliases:\n-                continue\n-            if (alias not in initial_refcounts or\n+            if alias in used_aliases and (alias not in initial_refcounts or\n                     self.alias_refcount[alias] == initial_refcounts[alias]):\n-                parent = self.alias_map[alias].lhs_alias\n-                must_promote = considered.get(parent, False)\n-                promoted = self.promote_alias(alias, must_promote)\n-                considered[alias] = must_promote or promoted\n+                self.promote_joins([alias])\n \n     def change_aliases(self, change_map):\n         \"\"\"\n@@ -875,6 +872,9 @@ def join(self, connection, always_create=False, exclusions=(),\n         LOUTER join type. This is used when joining certain types of querysets\n         and Q-objects together.\n \n+        A join is always created as LOUTER if the lhs alias is LOUTER to make\n+        sure we do not generate chains like a LOUTER b INNER c.\n+\n         If 'nullable' is True, the join can potentially involve NULL values and\n         is a candidate for promotion (to \"left outer\") when combining querysets.\n         \"\"\"\n@@ -900,8 +900,8 @@ def join(self, connection, always_create=False, exclusions=(),\n                     if self.alias_map[alias].lhs_alias != lhs:\n                         continue\n                     self.ref_alias(alias)\n-                    if promote:\n-                        self.promote_alias(alias)\n+                    if promote or (lhs and self.alias_map[lhs].join_type == self.LOUTER):\n+                        self.promote_joins([alias])\n                     return alias\n \n         # No reuse is possible, so we need a new alias.\n@@ -1009,8 +1009,7 @@ def add_aggregate(self, aggregate, model, alias, is_summary):\n             # If the aggregate references a model or field that requires a join,\n             # those joins must be LEFT OUTER - empty join rows must be returned\n             # in order for zeros to be returned for those aggregates.\n-            for column_alias in join_list:\n-                self.promote_alias(column_alias, unconditional=True)\n+            self.promote_joins(join_list, True)\n \n             col = (join_list[-1], col)\n         else:\n@@ -1129,7 +1128,7 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n             # If the comparison is against NULL, we may need to use some left\n             # outer joins when creating the join chain. This is only done when\n             # needed, as it's less efficient at the database level.\n-            self.promote_alias_chain(join_list)\n+            self.promote_joins(join_list)\n             join_promote = True\n \n         # Process the join list to see if we can remove any inner joins from\n@@ -1160,16 +1159,16 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n                     # This means that we are dealing with two different query\n                     # subtrees, so we don't need to do any join promotion.\n                     continue\n-                join_promote = join_promote or self.promote_alias(join, unconditional)\n+                join_promote = join_promote or self.promote_joins([join], unconditional)\n                 if table != join:\n-                    table_promote = self.promote_alias(table)\n+                    table_promote = self.promote_joins([table])\n                 # We only get here if we have found a table that exists\n                 # in the join list, but isn't on the original tables list.\n                 # This means we've reached the point where we only have\n                 # new tables, so we can break out of this promotion loop.\n                 break\n-            self.promote_alias_chain(join_it, join_promote)\n-            self.promote_alias_chain(table_it, table_promote or join_promote)\n+            self.promote_joins(join_it, join_promote)\n+            self.promote_joins(table_it, table_promote or join_promote)\n \n         if having_clause or force_having:\n             if (alias, col) not in self.group_by:\n@@ -1181,7 +1180,7 @@ def add_filter(self, filter_expr, connector=AND, negate=False, trim=False,\n                 connector)\n \n         if negate:\n-            self.promote_alias_chain(join_list)\n+            self.promote_joins(join_list)\n             if lookup_type != 'isnull':\n                 if len(join_list) > 1:\n                     for alias in join_list:\n@@ -1655,7 +1654,7 @@ def add_fields(self, field_names, allow_m2m=True):\n                         final_alias = join.lhs_alias\n                         col = join.lhs_join_col\n                         joins = joins[:-1]\n-                self.promote_alias_chain(joins[1:])\n+                self.promote_joins(joins[1:])\n                 self.select.append((final_alias, col))\n                 self.select_fields.append(field)\n         except MultiJoin:"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/regressiontests/nested_foreign_keys/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/django/django/blob/01b9c3d5193fe61b82ae8b26242a13fdec22f211/tests%2Fregressiontests%2Fnested_foreign_keys%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/01b9c3d5193fe61b82ae8b26242a13fdec22f211/tests%2Fregressiontests%2Fnested_foreign_keys%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fnested_foreign_keys%2F__init__.py?ref=01b9c3d5193fe61b82ae8b26242a13fdec22f211"
        },
        {
            "sha": "50d447951b58b23e51512c88adfdaa7c962ae2ba",
            "filename": "tests/regressiontests/nested_foreign_keys/models.py",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/django/django/blob/01b9c3d5193fe61b82ae8b26242a13fdec22f211/tests%2Fregressiontests%2Fnested_foreign_keys%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/01b9c3d5193fe61b82ae8b26242a13fdec22f211/tests%2Fregressiontests%2Fnested_foreign_keys%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fnested_foreign_keys%2Fmodels.py?ref=01b9c3d5193fe61b82ae8b26242a13fdec22f211",
            "patch": "@@ -0,0 +1,28 @@\n+from django.db import models\n+\n+\n+class Person(models.Model):\n+    name = models.CharField(max_length=200)\n+\n+\n+class Movie(models.Model):\n+    title = models.CharField(max_length=200)\n+    director = models.ForeignKey(Person)\n+\n+\n+class Event(models.Model):\n+    pass\n+\n+\n+class Screening(Event):\n+    movie = models.ForeignKey(Movie)\n+\n+class ScreeningNullFK(Event):\n+    movie = models.ForeignKey(Movie, null=True)\n+\n+\n+class Package(models.Model):\n+    screening = models.ForeignKey(Screening, null=True)\n+\n+class PackageNullFK(models.Model):\n+    screening = models.ForeignKey(ScreeningNullFK, null=True)"
        },
        {
            "sha": "a976d124532013a58db1d42f1d2043bc4b261e7e",
            "filename": "tests/regressiontests/nested_foreign_keys/tests.py",
            "status": "added",
            "additions": 166,
            "deletions": 0,
            "changes": 166,
            "blob_url": "https://github.com/django/django/blob/01b9c3d5193fe61b82ae8b26242a13fdec22f211/tests%2Fregressiontests%2Fnested_foreign_keys%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/01b9c3d5193fe61b82ae8b26242a13fdec22f211/tests%2Fregressiontests%2Fnested_foreign_keys%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fnested_foreign_keys%2Ftests.py?ref=01b9c3d5193fe61b82ae8b26242a13fdec22f211",
            "patch": "@@ -0,0 +1,166 @@\n+from __future__ import absolute_import\n+from django.test import TestCase\n+\n+from .models import Person, Movie, Event, Screening, ScreeningNullFK, Package, PackageNullFK\n+\n+\n+# These are tests for #16715. The basic scheme is always the same: 3 models with\n+# 2 relations. The first relation may be null, while the second is non-nullable.\n+# In some cases, Django would pick the wrong join type for the second relation,\n+# resulting in missing objects in the queryset.\n+#\n+#   Model A\n+#   | (Relation A/B : nullable)\n+#   Model B\n+#   | (Relation B/C : non-nullable)\n+#   Model C\n+#\n+# Because of the possibility of NULL rows resulting from the LEFT OUTER JOIN\n+# between Model A and Model B (i.e. instances of A without reference to B),\n+# the second join must also be LEFT OUTER JOIN, so that we do not ignore\n+# instances of A that do not reference B.\n+#\n+# Relation A/B can either be an explicit foreign key or an implicit reverse\n+# relation such as introduced by one-to-one relations (through multi-table\n+# inheritance).\n+class NestedForeignKeysTests(TestCase):\n+    def setUp(self):\n+        self.director = Person.objects.create(name='Terry Gilliam / Terry Jones')\n+        self.movie = Movie.objects.create(title='Monty Python and the Holy Grail', director=self.director)\n+\n+\n+    # This test failed in #16715 because in some cases INNER JOIN was selected\n+    # for the second foreign key relation instead of LEFT OUTER JOIN.\n+    def testInheritance(self):\n+        some_event = Event.objects.create()\n+        screening = Screening.objects.create(movie=self.movie)\n+\n+        self.assertEqual(len(Event.objects.all()), 2)\n+        self.assertEqual(len(Event.objects.select_related('screening')), 2)\n+        # This failed.\n+        self.assertEqual(len(Event.objects.select_related('screening__movie')), 2)\n+\n+        self.assertEqual(len(Event.objects.values()), 2)\n+        self.assertEqual(len(Event.objects.values('screening__pk')), 2)\n+        self.assertEqual(len(Event.objects.values('screening__movie__pk')), 2)\n+        self.assertEqual(len(Event.objects.values('screening__movie__title')), 2)\n+        # This failed.\n+        self.assertEqual(len(Event.objects.values('screening__movie__pk', 'screening__movie__title')), 2)\n+\n+        # Simple filter/exclude queries for good measure.\n+        self.assertEqual(Event.objects.filter(screening__movie=self.movie).count(), 1)\n+        self.assertEqual(Event.objects.exclude(screening__movie=self.movie).count(), 1)\n+\n+\n+    # These all work because the second foreign key in the chain has null=True.\n+    def testInheritanceNullFK(self):\n+        some_event = Event.objects.create()\n+        screening = ScreeningNullFK.objects.create(movie=None)\n+        screening_with_movie = ScreeningNullFK.objects.create(movie=self.movie)\n+\n+        self.assertEqual(len(Event.objects.all()), 3)\n+        self.assertEqual(len(Event.objects.select_related('screeningnullfk')), 3)\n+        self.assertEqual(len(Event.objects.select_related('screeningnullfk__movie')), 3)\n+\n+        self.assertEqual(len(Event.objects.values()), 3)\n+        self.assertEqual(len(Event.objects.values('screeningnullfk__pk')), 3)\n+        self.assertEqual(len(Event.objects.values('screeningnullfk__movie__pk')), 3)\n+        self.assertEqual(len(Event.objects.values('screeningnullfk__movie__title')), 3)\n+        self.assertEqual(len(Event.objects.values('screeningnullfk__movie__pk', 'screeningnullfk__movie__title')), 3)\n+\n+        self.assertEqual(Event.objects.filter(screeningnullfk__movie=self.movie).count(), 1)\n+        self.assertEqual(Event.objects.exclude(screeningnullfk__movie=self.movie).count(), 2)\n+\n+\n+    # This test failed in #16715 because in some cases INNER JOIN was selected\n+    # for the second foreign key relation instead of LEFT OUTER JOIN.\n+    def testExplicitForeignKey(self):\n+        package = Package.objects.create()\n+        screening = Screening.objects.create(movie=self.movie)\n+        package_with_screening = Package.objects.create(screening=screening)\n+\n+        self.assertEqual(len(Package.objects.all()), 2)\n+        self.assertEqual(len(Package.objects.select_related('screening')), 2)\n+        self.assertEqual(len(Package.objects.select_related('screening__movie')), 2)\n+\n+        self.assertEqual(len(Package.objects.values()), 2)\n+        self.assertEqual(len(Package.objects.values('screening__pk')), 2)\n+        self.assertEqual(len(Package.objects.values('screening__movie__pk')), 2)\n+        self.assertEqual(len(Package.objects.values('screening__movie__title')), 2)\n+        # This failed.\n+        self.assertEqual(len(Package.objects.values('screening__movie__pk', 'screening__movie__title')), 2)\n+\n+        self.assertEqual(Package.objects.filter(screening__movie=self.movie).count(), 1)\n+        self.assertEqual(Package.objects.exclude(screening__movie=self.movie).count(), 1)\n+\n+\n+    # These all work because the second foreign key in the chain has null=True.\n+    def testExplicitForeignKeyNullFK(self):\n+        package = PackageNullFK.objects.create()\n+        screening = ScreeningNullFK.objects.create(movie=None)\n+        screening_with_movie = ScreeningNullFK.objects.create(movie=self.movie)\n+        package_with_screening = PackageNullFK.objects.create(screening=screening)\n+        package_with_screening_with_movie = PackageNullFK.objects.create(screening=screening_with_movie)\n+\n+        self.assertEqual(len(PackageNullFK.objects.all()), 3)\n+        self.assertEqual(len(PackageNullFK.objects.select_related('screening')), 3)\n+        self.assertEqual(len(PackageNullFK.objects.select_related('screening__movie')), 3)\n+\n+        self.assertEqual(len(PackageNullFK.objects.values()), 3)\n+        self.assertEqual(len(PackageNullFK.objects.values('screening__pk')), 3)\n+        self.assertEqual(len(PackageNullFK.objects.values('screening__movie__pk')), 3)\n+        self.assertEqual(len(PackageNullFK.objects.values('screening__movie__title')), 3)\n+        self.assertEqual(len(PackageNullFK.objects.values('screening__movie__pk', 'screening__movie__title')), 3)\n+\n+        self.assertEqual(PackageNullFK.objects.filter(screening__movie=self.movie).count(), 1)\n+        self.assertEqual(PackageNullFK.objects.exclude(screening__movie=self.movie).count(), 2)\n+\n+\n+# Some additional tests for #16715. The only difference is the depth of the\n+# nesting as we now use 4 models instead of 3 (and thus 3 relations). This\n+# checks if promotion of join types works for deeper nesting too.\n+class DeeplyNestedForeignKeysTests(TestCase):\n+    def setUp(self):\n+        self.director = Person.objects.create(name='Terry Gilliam / Terry Jones')\n+        self.movie = Movie.objects.create(title='Monty Python and the Holy Grail', director=self.director)\n+\n+\n+    def testInheritance(self):\n+        some_event = Event.objects.create()\n+        screening = Screening.objects.create(movie=self.movie)\n+\n+        self.assertEqual(len(Event.objects.all()), 2)\n+        self.assertEqual(len(Event.objects.select_related('screening__movie__director')), 2)\n+\n+        self.assertEqual(len(Event.objects.values()), 2)\n+        self.assertEqual(len(Event.objects.values('screening__movie__director__pk')), 2)\n+        self.assertEqual(len(Event.objects.values('screening__movie__director__name')), 2)\n+        self.assertEqual(len(Event.objects.values('screening__movie__director__pk', 'screening__movie__director__name')), 2)\n+        self.assertEqual(len(Event.objects.values('screening__movie__pk', 'screening__movie__director__pk')), 2)\n+        self.assertEqual(len(Event.objects.values('screening__movie__pk', 'screening__movie__director__name')), 2)\n+        self.assertEqual(len(Event.objects.values('screening__movie__title', 'screening__movie__director__pk')), 2)\n+        self.assertEqual(len(Event.objects.values('screening__movie__title', 'screening__movie__director__name')), 2)\n+\n+        self.assertEqual(Event.objects.filter(screening__movie__director=self.director).count(), 1)\n+        self.assertEqual(Event.objects.exclude(screening__movie__director=self.director).count(), 1)\n+\n+\n+    def testExplicitForeignKey(self):\n+        package = Package.objects.create()\n+        screening = Screening.objects.create(movie=self.movie)\n+        package_with_screening = Package.objects.create(screening=screening)\n+\n+        self.assertEqual(len(Package.objects.all()), 2)\n+        self.assertEqual(len(Package.objects.select_related('screening__movie__director')), 2)\n+\n+        self.assertEqual(len(Package.objects.values()), 2)\n+        self.assertEqual(len(Package.objects.values('screening__movie__director__pk')), 2)\n+        self.assertEqual(len(Package.objects.values('screening__movie__director__name')), 2)\n+        self.assertEqual(len(Package.objects.values('screening__movie__director__pk', 'screening__movie__director__name')), 2)\n+        self.assertEqual(len(Package.objects.values('screening__movie__pk', 'screening__movie__director__pk')), 2)\n+        self.assertEqual(len(Package.objects.values('screening__movie__pk', 'screening__movie__director__name')), 2)\n+        self.assertEqual(len(Package.objects.values('screening__movie__title', 'screening__movie__director__pk')), 2)\n+        self.assertEqual(len(Package.objects.values('screening__movie__title', 'screening__movie__director__name')), 2)\n+\n+        self.assertEqual(Package.objects.filter(screening__movie__director=self.director).count(), 1)\n+        self.assertEqual(Package.objects.exclude(screening__movie__director=self.director).count(), 1)"
        }
    ],
    "stats": {
        "total": 303,
        "additions": 246,
        "deletions": 57
    }
}