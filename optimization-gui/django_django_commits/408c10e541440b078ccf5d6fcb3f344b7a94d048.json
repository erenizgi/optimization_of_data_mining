{
    "author": "ubernostrum",
    "message": "Untabify multi-db docs.",
    "sha": "408c10e541440b078ccf5d6fcb3f344b7a94d048",
    "files": [
        {
            "sha": "82218692d8d1042e4be1aad9155f6cee405759db",
            "filename": "docs/topics/db/multi-db.txt",
            "status": "modified",
            "additions": 60,
            "deletions": 60,
            "changes": 120,
            "blob_url": "https://github.com/django/django/blob/408c10e541440b078ccf5d6fcb3f344b7a94d048/docs%2Ftopics%2Fdb%2Fmulti-db.txt",
            "raw_url": "https://github.com/django/django/raw/408c10e541440b078ccf5d6fcb3f344b7a94d048/docs%2Ftopics%2Fdb%2Fmulti-db.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Fmulti-db.txt?ref=408c10e541440b078ccf5d6fcb3f344b7a94d048",
            "patch": "@@ -242,41 +242,41 @@ send queries for the ``auth`` app to ``auth_db``::\n         A router to control all database operations on models in the\n         auth application.\n         \"\"\"\n-\tdef db_for_read(self, model, **hints):\n-\t    \"\"\"\n-\t    Attempts to read auth models go to auth_db.\n-\t    \"\"\"\n-\t    if model._meta.app_label == 'auth':\n-\t        return 'auth_db'\n- \t    return None\n-\n-\tdef db_for_write(self, model, **hints):\n-\t    \"\"\"\n-\t    Attempts to write auth models go to auth_db.\n-\t    \"\"\"\n-\t    if model._meta.app_label == 'auth':\n-\t        return 'auth_db'\n-\t    return Non\n-\n-\tdef allow_relation(self, obj1, obj2, **hints):\n-\t    \"\"\"\n-\t    Allow relations if a model in the auth app is involved.\n-\t    \"\"\"\n-\t    if obj1._meta.app_label == 'auth' or \\\n+        def db_for_read(self, model, **hints):\n+            \"\"\"\n+            Attempts to read auth models go to auth_db.\n+            \"\"\"\n+            if model._meta.app_label == 'auth':\n+                return 'auth_db'\n+            return None\n+\n+        def db_for_write(self, model, **hints):\n+            \"\"\"\n+            Attempts to write auth models go to auth_db.\n+            \"\"\"\n+            if model._meta.app_label == 'auth':\n+                return 'auth_db'\n+            return Non\n+\n+        def allow_relation(self, obj1, obj2, **hints):\n+            \"\"\"\n+            Allow relations if a model in the auth app is involved.\n+            \"\"\"\n+            if obj1._meta.app_label == 'auth' or \\\n                obj2._meta.app_label == 'auth':\n-\t       return True\n-\t    return None\n-\n-\tdef allow_syncdb(self, db, model):\n-\t    \"\"\"\n-\t    Make sure the auth app only appears in the 'auth_db'\n-\t    database.\n-\t    \"\"\"\n-\t    if db == 'auth_db':\n-\t        return model._meta.app_label == 'auth'\n-\t    elif model._meta.app_label == 'auth':\n-\t        return False\n-\t    return None\n+               return True\n+            return None\n+\n+        def allow_syncdb(self, db, model):\n+            \"\"\"\n+            Make sure the auth app only appears in the 'auth_db'\n+            database.\n+            \"\"\"\n+            if db == 'auth_db':\n+                return model._meta.app_label == 'auth'\n+            elif model._meta.app_label == 'auth':\n+                return False\n+            return None\n \n And we also want a router that sends all other apps to the\n master/slave configuration, and randomly chooses a slave to read\n@@ -286,32 +286,32 @@ from::\n \n     class MasterSlaveRouter(object):\n         def db_for_read(self, model, **hints):\n-\t    \"\"\"\n-\t    Reads go to a randomly-chosen slave.\n-\t    \"\"\"\n-\t    return random.choice(['slave1', 'slave2'])\n-\n-\tdef db_for_write(self, model, **hints):\n-\t    \"\"\"\n-\t    Writes always go to master.\n-\t    \"\"\"\n-\t    return 'master'\n-\n-\tdef allow_relation(self, obj1, obj2, **hints):\n-\t    \"\"\"\n-\t    Relations between objects are allowed if both objects are\n-\t    in the master/slave pool.\n-\t    \"\"\"\n-\t    db_list = ('master', 'slave1', 'slave2')\n-\t    if obj1.state.db in db_list and obj2.state.db in db_list:\n-\t        return True\n-\t    return None\n-\n-\tdef allow_syncdb(self, db, model):\n-\t    \"\"\"\n-\t    All non-auth models end up in this pool.\n-\t    \"\"\"\n-\t    return True\n+            \"\"\"\n+            Reads go to a randomly-chosen slave.\n+            \"\"\"\n+            return random.choice(['slave1', 'slave2'])\n+\n+        def db_for_write(self, model, **hints):\n+            \"\"\"\n+            Writes always go to master.\n+            \"\"\"\n+            return 'master'\n+\n+        def allow_relation(self, obj1, obj2, **hints):\n+            \"\"\"\n+            Relations between objects are allowed if both objects are\n+            in the master/slave pool.\n+            \"\"\"\n+            db_list = ('master', 'slave1', 'slave2')\n+            if obj1.state.db in db_list and obj2.state.db in db_list:\n+                return True\n+            return None\n+\n+        def allow_syncdb(self, db, model):\n+            \"\"\"\n+            All non-auth models end up in this pool.\n+            \"\"\"\n+            return True\n \n Finally, in the settings file, we add the following (substituting\n ``path.to.`` with the actual python path to the module(s) where the"
        }
    ],
    "stats": {
        "total": 120,
        "additions": 60,
        "deletions": 60
    }
}