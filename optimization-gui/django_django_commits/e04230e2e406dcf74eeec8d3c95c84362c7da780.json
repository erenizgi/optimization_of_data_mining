{
    "author": "aaugustin",
    "message": "[py3] Ported django.http according to PEP 3333.\n\nPerfomed some style cleanup while I was in the area.",
    "sha": "e04230e2e406dcf74eeec8d3c95c84362c7da780",
    "files": [
        {
            "sha": "62415da3c6a07330cd8eb6fc0a4ca066ba44b496",
            "filename": "django/http/__init__.py",
            "status": "modified",
            "additions": 63,
            "deletions": 43,
            "changes": 106,
            "blob_url": "https://github.com/django/django/blob/e04230e2e406dcf74eeec8d3c95c84362c7da780/django%2Fhttp%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/e04230e2e406dcf74eeec8d3c95c84362c7da780/django%2Fhttp%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fhttp%2F__init__.py?ref=e04230e2e406dcf74eeec8d3c95c84362c7da780",
            "patch": "@@ -113,7 +113,7 @@ def build_request_repr(request, path_override=None, GET_override=None,\n         get = (pformat(GET_override)\n                if GET_override is not None\n                else pformat(request.GET))\n-    except:\n+    except Exception:\n         get = '<could not parse>'\n     if request._post_parse_error:\n         post = '<could not parse>'\n@@ -122,19 +122,19 @@ def build_request_repr(request, path_override=None, GET_override=None,\n             post = (pformat(POST_override)\n                     if POST_override is not None\n                     else pformat(request.POST))\n-        except:\n+        except Exception:\n             post = '<could not parse>'\n     try:\n         cookies = (pformat(COOKIES_override)\n                    if COOKIES_override is not None\n                    else pformat(request.COOKIES))\n-    except:\n+    except Exception:\n         cookies = '<could not parse>'\n     try:\n         meta = (pformat(META_override)\n                 if META_override is not None\n                 else pformat(request.META))\n-    except:\n+    except Exception:\n         meta = '<could not parse>'\n     path = path_override if path_override is not None else request.path\n     return smart_str('<%s\\npath:%s,\\nGET:%s,\\nPOST:%s,\\nCOOKIES:%s,\\nMETA:%s>' %\n@@ -177,14 +177,14 @@ def get_host(self):\n             # Reconstruct the host using the algorithm from PEP 333.\n             host = self.META['SERVER_NAME']\n             server_port = str(self.META['SERVER_PORT'])\n-            if server_port != (self.is_secure() and '443' or '80'):\n+            if server_port != ('443' if self.is_secure() else '80'):\n                 host = '%s:%s' % (host, server_port)\n         return host\n \n     def get_full_path(self):\n         # RFC 3986 requires query string arguments to be in the ASCII range.\n         # Rather than crash if this doesn't happen, we encode defensively.\n-        return '%s%s' % (self.path, self.META.get('QUERY_STRING', '') and ('?' + iri_to_uri(self.META.get('QUERY_STRING', ''))) or '')\n+        return '%s%s' % (self.path, ('?' + iri_to_uri(self.META.get('QUERY_STRING', ''))) if self.META.get('QUERY_STRING', '') else '')\n \n     def get_signed_cookie(self, key, default=RAISE_ERROR, salt='', max_age=None):\n         \"\"\"\n@@ -218,7 +218,7 @@ def build_absolute_uri(self, location=None):\n         if not location:\n             location = self.get_full_path()\n         if not absolute_http_url_re.match(location):\n-            current_uri = '%s://%s%s' % (self.is_secure() and 'https' or 'http',\n+            current_uri = '%s://%s%s' % ('https' if self.is_secure() else 'http',\n                                          self.get_host(), self.path)\n             location = urljoin(current_uri, location)\n         return iri_to_uri(location)\n@@ -281,7 +281,7 @@ def parse_file_upload(self, META, post_data):\n         \"\"\"Returns a tuple of (POST QueryDict, FILES MultiValueDict).\"\"\"\n         self.upload_handlers = ImmutableList(\n             self.upload_handlers,\n-            warning = \"You cannot alter upload handlers after the upload has been processed.\"\n+            warning=\"You cannot alter upload handlers after the upload has been processed.\"\n         )\n         parser = MultiPartParser(META, post_data, self.upload_handlers, self.encoding)\n         return parser.parse()\n@@ -294,7 +294,7 @@ def body(self):\n             try:\n                 self._body = self.read()\n             except IOError as e:\n-                six.reraise(UnreadablePostError, UnreadablePostError(*tuple(e.args)), sys.exc_info()[2])\n+                six.reraise(UnreadablePostError, UnreadablePostError(*e.args), sys.exc_info()[2])\n             self._stream = BytesIO(self._body)\n         return self._body\n \n@@ -360,6 +360,7 @@ def xreadlines(self):\n             if not buf:\n                 break\n             yield buf\n+\n     __iter__ = xreadlines\n \n     def readlines(self):\n@@ -384,9 +385,16 @@ def __init__(self, query_string, mutable=False, encoding=None):\n         if not encoding:\n             encoding = settings.DEFAULT_CHARSET\n         self.encoding = encoding\n-        for key, value in parse_qsl((query_string or ''), True): # keep_blank_values=True\n-            self.appendlist(force_text(key, encoding, errors='replace'),\n-                            force_text(value, encoding, errors='replace'))\n+        if six.PY3:\n+            for key, value in parse_qsl(query_string or '',\n+                                        keep_blank_values=True,\n+                                        encoding=encoding):\n+                self.appendlist(key, value)\n+        else:\n+            for key, value in parse_qsl(query_string or '',\n+                                        keep_blank_values=True):\n+                self.appendlist(force_text(key, encoding, errors='replace'),\n+                                force_text(value, encoding, errors='replace'))\n         self._mutable = mutable\n \n     def _get_encoding(self):\n@@ -405,8 +413,8 @@ def _assert_mutable(self):\n \n     def __setitem__(self, key, value):\n         self._assert_mutable()\n-        key = str_to_unicode(key, self.encoding)\n-        value = str_to_unicode(value, self.encoding)\n+        key = bytes_to_text(key, self.encoding)\n+        value = bytes_to_text(value, self.encoding)\n         super(QueryDict, self).__setitem__(key, value)\n \n     def __delitem__(self, key):\n@@ -428,8 +436,8 @@ def __deepcopy__(self, memo):\n \n     def setlist(self, key, list_):\n         self._assert_mutable()\n-        key = str_to_unicode(key, self.encoding)\n-        list_ = [str_to_unicode(elt, self.encoding) for elt in list_]\n+        key = bytes_to_text(key, self.encoding)\n+        list_ = [bytes_to_text(elt, self.encoding) for elt in list_]\n         super(QueryDict, self).setlist(key, list_)\n \n     def setlistdefault(self, key, default_list=None):\n@@ -438,8 +446,8 @@ def setlistdefault(self, key, default_list=None):\n \n     def appendlist(self, key, value):\n         self._assert_mutable()\n-        key = str_to_unicode(key, self.encoding)\n-        value = str_to_unicode(value, self.encoding)\n+        key = bytes_to_text(key, self.encoding)\n+        value = bytes_to_text(value, self.encoding)\n         super(QueryDict, self).appendlist(key, value)\n \n     def pop(self, key, *args):\n@@ -456,8 +464,8 @@ def clear(self):\n \n     def setdefault(self, key, default=None):\n         self._assert_mutable()\n-        key = str_to_unicode(key, self.encoding)\n-        default = str_to_unicode(default, self.encoding)\n+        key = bytes_to_text(key, self.encoding)\n+        default = bytes_to_text(default, self.encoding)\n         return super(QueryDict, self).setdefault(key, default)\n \n     def copy(self):\n@@ -531,37 +539,48 @@ def __init__(self, content='', content_type=None, status=None,\n         if not content_type:\n             content_type = \"%s; charset=%s\" % (settings.DEFAULT_CONTENT_TYPE,\n                     self._charset)\n+        # content is a bytestring. See _get_content / _set_content.\n         self.content = content\n         self.cookies = SimpleCookie()\n         if status:\n             self.status_code = status\n \n         self['Content-Type'] = content_type\n \n-    def __str__(self):\n-        \"\"\"Full HTTP message, including headers.\"\"\"\n-        return '\\n'.join(['%s: %s' % (key, value)\n-            for key, value in self._headers.values()]) \\\n-            + '\\n\\n' + self.content\n+    def serialize(self):\n+        \"\"\"Full HTTP message, including headers, as a bytestring.\"\"\"\n+        headers = [\n+            b'%s: %s' % (key.encode('us-ascii'), value.encode('us-ascii'))\n+            for key, value in self._headers.values()\n+        ]\n+        return b'\\r\\n'.join(headers) + b'\\r\\n\\r\\n' + self.content\n+\n+    if six.PY3:\n+        __bytes__ = serialize\n+    else:\n+        __str__ = serialize\n \n     def _convert_to_ascii(self, *values):\n         \"\"\"Converts all values to ascii strings.\"\"\"\n         for value in values:\n-            if isinstance(value, six.text_type):\n-                try:\n-                    if not six.PY3:\n-                        value = value.encode('us-ascii')\n-                    else:\n-                        # In Python 3, use a string in headers,\n-                        # but ensure in only contains ASCII characters.\n-                        value.encode('us-ascii')\n-                except UnicodeError as e:\n-                    e.reason += ', HTTP response headers must be in US-ASCII format'\n-                    raise\n-            else:\n+            if not isinstance(value, six.string_types):\n                 value = str(value)\n+            try:\n+                if six.PY3:\n+                    # Ensure string only contains ASCII\n+                    value.encode('us-ascii')\n+                else:\n+                    if isinstance(value, str):\n+                        # Ensure string only contains ASCII\n+                        value.decode('us-ascii')\n+                    else:\n+                        # Convert unicode to an ASCII string\n+                        value = value.encode('us-ascii')\n+            except UnicodeError as e:\n+                e.reason += ', HTTP response headers must be in US-ASCII format'\n+                raise\n             if '\\n' in value or '\\r' in value:\n-                raise BadHeaderError(\"Header values can't contain newlines (got %r)\" % (value))\n+                raise BadHeaderError(\"Header values can't contain newlines (got %r)\" % value)\n             yield value\n \n     def __setitem__(self, header, value):\n@@ -652,11 +671,12 @@ def delete_cookie(self, key, path='/', domain=None):\n \n     def _get_content(self):\n         if self.has_header('Content-Encoding'):\n-            return b''.join([str(e) for e in self._container])\n+            # XXX this doesn't work under Python 3 when e is an integer (#18764)\n+            return b''.join([bytes(e) for e in self._container])\n         return b''.join([smart_bytes(e, self._charset) for e in self._container])\n \n     def _set_content(self, value):\n-        if hasattr(value, '__iter__') and not isinstance(value, (bytes, six.text_type)):\n+        if hasattr(value, '__iter__') and not isinstance(value, six.string_types):\n             self._container = value\n             self._base_content_is_iter = True\n         else:\n@@ -673,7 +693,7 @@ def __next__(self):\n         chunk = next(self._iterator)\n         if isinstance(chunk, six.text_type):\n             chunk = chunk.encode(self._charset)\n-        return str(chunk)\n+        return bytes(chunk)\n \n     next = __next__             # Python 2 compatibility\n \n@@ -743,8 +763,8 @@ def get_host(request):\n \n # It's neither necessary nor appropriate to use\n # django.utils.encoding.smart_text for parsing URLs and form inputs. Thus,\n-# this slightly more restricted function.\n-def str_to_unicode(s, encoding):\n+# this slightly more restricted function, used by QueryDict.\n+def bytes_to_text(s, encoding):\n     \"\"\"\n     Converts basestring objects to unicode, using the given encoding. Illegally\n     encoded input characters are replaced with Unicode \"unknown\" codepoint"
        },
        {
            "sha": "332f25dfe9849f3693704bb7cbbcaecce9fb9ccf",
            "filename": "tests/regressiontests/httpwrappers/tests.py",
            "status": "modified",
            "additions": 67,
            "deletions": 62,
            "changes": 129,
            "blob_url": "https://github.com/django/django/blob/e04230e2e406dcf74eeec8d3c95c84362c7da780/tests%2Fregressiontests%2Fhttpwrappers%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e04230e2e406dcf74eeec8d3c95c84362c7da780/tests%2Fregressiontests%2Fhttpwrappers%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fhttpwrappers%2Ftests.py?ref=e04230e2e406dcf74eeec8d3c95c84362c7da780",
            "patch": "@@ -9,16 +9,17 @@\n                          HttpResponsePermanentRedirect,\n                          SimpleCookie, BadHeaderError,\n                          parse_cookie)\n+from django.utils import six\n from django.utils import unittest\n \n \n class QueryDictTests(unittest.TestCase):\n     def test_missing_key(self):\n-        q = QueryDict('')\n+        q = QueryDict(str(''))\n         self.assertRaises(KeyError, q.__getitem__, 'foo')\n \n     def test_immutability(self):\n-        q = QueryDict('')\n+        q = QueryDict(str(''))\n         self.assertRaises(AttributeError, q.__setitem__, 'something', 'bar')\n         self.assertRaises(AttributeError, q.setlist, 'foo', ['bar'])\n         self.assertRaises(AttributeError, q.appendlist, 'foo', ['bar'])\n@@ -28,26 +29,26 @@ def test_immutability(self):\n         self.assertRaises(AttributeError, q.clear)\n \n     def test_immutable_get_with_default(self):\n-        q = QueryDict('')\n+        q = QueryDict(str(''))\n         self.assertEqual(q.get('foo', 'default'), 'default')\n \n     def test_immutable_basic_operations(self):\n-        q = QueryDict('')\n+        q = QueryDict(str(''))\n         self.assertEqual(q.getlist('foo'), [])\n-        self.assertEqual(q.has_key('foo'), False)\n+        if not six.PY3:\n+            self.assertEqual(q.has_key('foo'), False)\n         self.assertEqual('foo' in q, False)\n-        self.assertEqual(q.items(), [])\n-        self.assertEqual(q.lists(), [])\n-        self.assertEqual(q.items(), [])\n-        self.assertEqual(q.keys(), [])\n-        self.assertEqual(q.values(), [])\n+        self.assertEqual(list(six.iteritems(q)), [])\n+        self.assertEqual(list(six.iterlists(q)), [])\n+        self.assertEqual(list(six.iterkeys(q)), [])\n+        self.assertEqual(list(six.itervalues(q)), [])\n         self.assertEqual(len(q), 0)\n         self.assertEqual(q.urlencode(), '')\n \n     def test_single_key_value(self):\n         \"\"\"Test QueryDict with one key/value pair\"\"\"\n \n-        q = QueryDict('foo=bar')\n+        q = QueryDict(str('foo=bar'))\n         self.assertEqual(q['foo'], 'bar')\n         self.assertRaises(KeyError, q.__getitem__, 'bar')\n         self.assertRaises(AttributeError, q.__setitem__, 'something', 'bar')\n@@ -60,15 +61,17 @@ def test_single_key_value(self):\n         self.assertRaises(AttributeError, q.setlist, 'foo', ['bar'])\n         self.assertRaises(AttributeError, q.appendlist, 'foo', ['bar'])\n \n-        self.assertTrue(q.has_key('foo'))\n+        if not six.PY3:\n+            self.assertTrue(q.has_key('foo'))\n         self.assertTrue('foo' in q)\n-        self.assertFalse(q.has_key('bar'))\n+        if not six.PY3:\n+            self.assertFalse(q.has_key('bar'))\n         self.assertFalse('bar' in q)\n \n-        self.assertEqual(q.items(), [('foo', 'bar')])\n-        self.assertEqual(q.lists(), [('foo', ['bar'])])\n-        self.assertEqual(q.keys(), ['foo'])\n-        self.assertEqual(q.values(), ['bar'])\n+        self.assertEqual(list(six.iteritems(q)), [('foo', 'bar')])\n+        self.assertEqual(list(six.iterlists(q)), [('foo', ['bar'])])\n+        self.assertEqual(list(six.iterkeys(q)), ['foo'])\n+        self.assertEqual(list(six.itervalues(q)), ['bar'])\n         self.assertEqual(len(q), 1)\n \n         self.assertRaises(AttributeError, q.update, {'foo': 'bar'})\n@@ -80,30 +83,30 @@ def test_single_key_value(self):\n         self.assertEqual(q.urlencode(), 'foo=bar')\n \n     def test_urlencode(self):\n-        q = QueryDict('', mutable=True)\n+        q = QueryDict(str(''), mutable=True)\n         q['next'] = '/a&b/'\n         self.assertEqual(q.urlencode(), 'next=%2Fa%26b%2F')\n         self.assertEqual(q.urlencode(safe='/'), 'next=/a%26b/')\n-        q = QueryDict('', mutable=True)\n+        q = QueryDict(str(''), mutable=True)\n         q['next'] = '/t\\xebst&key/'\n         self.assertEqual(q.urlencode(), 'next=%2Ft%C3%ABst%26key%2F')\n         self.assertEqual(q.urlencode(safe='/'), 'next=/t%C3%ABst%26key/')\n \n     def test_mutable_copy(self):\n         \"\"\"A copy of a QueryDict is mutable.\"\"\"\n-        q = QueryDict('').copy()\n+        q = QueryDict(str('')).copy()\n         self.assertRaises(KeyError, q.__getitem__, \"foo\")\n         q['name'] = 'john'\n         self.assertEqual(q['name'], 'john')\n \n     def test_mutable_delete(self):\n-        q = QueryDict('').copy()\n+        q = QueryDict(str('')).copy()\n         q['name'] = 'john'\n         del q['name']\n         self.assertFalse('name' in q)\n \n     def test_basic_mutable_operations(self):\n-        q = QueryDict('').copy()\n+        q = QueryDict(str('')).copy()\n         q['name'] = 'john'\n         self.assertEqual(q.get('foo', 'default'), 'default')\n         self.assertEqual(q.get('name', 'default'), 'john')\n@@ -117,13 +120,14 @@ def test_basic_mutable_operations(self):\n         q.appendlist('foo', 'another')\n         self.assertEqual(q.getlist('foo'), ['bar', 'baz', 'another'])\n         self.assertEqual(q['foo'], 'another')\n-        self.assertTrue(q.has_key('foo'))\n+        if not six.PY3:\n+            self.assertTrue(q.has_key('foo'))\n         self.assertTrue('foo' in q)\n \n-        self.assertEqual(q.items(),  [('foo', 'another'), ('name', 'john')])\n-        self.assertEqual(q.lists(), [('foo', ['bar', 'baz', 'another']), ('name', ['john'])])\n-        self.assertEqual(q.keys(), ['foo', 'name'])\n-        self.assertEqual(q.values(), ['another', 'john'])\n+        self.assertEqual(list(six.iteritems(q)),  [('foo', 'another'), ('name', 'john')])\n+        self.assertEqual(list(six.iterlists(q)), [('foo', ['bar', 'baz', 'another']), ('name', ['john'])])\n+        self.assertEqual(list(six.iterkeys(q)), ['foo', 'name'])\n+        self.assertEqual(list(six.itervalues(q)), ['another', 'john'])\n         self.assertEqual(len(q), 2)\n \n         q.update({'foo': 'hello'})\n@@ -144,7 +148,7 @@ def test_basic_mutable_operations(self):\n     def test_multiple_keys(self):\n         \"\"\"Test QueryDict with two key/value pairs with same keys.\"\"\"\n \n-        q = QueryDict('vote=yes&vote=no')\n+        q = QueryDict(str('vote=yes&vote=no'))\n \n         self.assertEqual(q['vote'], 'no')\n         self.assertRaises(AttributeError, q.__setitem__, 'something', 'bar')\n@@ -158,14 +162,16 @@ def test_multiple_keys(self):\n         self.assertRaises(AttributeError, q.setlist, 'foo', ['bar', 'baz'])\n         self.assertRaises(AttributeError, q.appendlist, 'foo', ['bar'])\n \n-        self.assertEqual(q.has_key('vote'), True)\n+        if not six.PY3:\n+            self.assertEqual(q.has_key('vote'), True)\n         self.assertEqual('vote' in q, True)\n-        self.assertEqual(q.has_key('foo'), False)\n+        if not six.PY3:\n+            self.assertEqual(q.has_key('foo'), False)\n         self.assertEqual('foo' in q, False)\n-        self.assertEqual(q.items(), [('vote', 'no')])\n-        self.assertEqual(q.lists(), [('vote', ['yes', 'no'])])\n-        self.assertEqual(q.keys(), ['vote'])\n-        self.assertEqual(q.values(), ['no'])\n+        self.assertEqual(list(six.iteritems(q)), [('vote', 'no')])\n+        self.assertEqual(list(six.iterlists(q)), [('vote', ['yes', 'no'])])\n+        self.assertEqual(list(six.iterkeys(q)), ['vote'])\n+        self.assertEqual(list(six.itervalues(q)), ['no'])\n         self.assertEqual(len(q), 1)\n \n         self.assertRaises(AttributeError, q.update, {'foo': 'bar'})\n@@ -175,45 +181,49 @@ def test_multiple_keys(self):\n         self.assertRaises(AttributeError, q.setdefault, 'foo', 'bar')\n         self.assertRaises(AttributeError, q.__delitem__, 'vote')\n \n-    def test_invalid_input_encoding(self):\n-        \"\"\"\n-        QueryDicts must be able to handle invalid input encoding (in this\n-        case, bad UTF-8 encoding).\n-        \"\"\"\n-        q = QueryDict(b'foo=bar&foo=\\xff')\n-        self.assertEqual(q['foo'], '\\ufffd')\n-        self.assertEqual(q.getlist('foo'), ['bar', '\\ufffd'])\n+    if not six.PY3:\n+        def test_invalid_input_encoding(self):\n+            \"\"\"\n+            QueryDicts must be able to handle invalid input encoding (in this\n+            case, bad UTF-8 encoding).\n+\n+            This test doesn't apply under Python 3 because the URL is a string\n+            and not a bytestring.\n+            \"\"\"\n+            q = QueryDict(str(b'foo=bar&foo=\\xff'))\n+            self.assertEqual(q['foo'], '\\ufffd')\n+            self.assertEqual(q.getlist('foo'), ['bar', '\\ufffd'])\n \n     def test_pickle(self):\n-        q = QueryDict('')\n+        q = QueryDict(str(''))\n         q1 = pickle.loads(pickle.dumps(q, 2))\n         self.assertEqual(q == q1, True)\n-        q = QueryDict('a=b&c=d')\n+        q = QueryDict(str('a=b&c=d'))\n         q1 = pickle.loads(pickle.dumps(q, 2))\n         self.assertEqual(q == q1, True)\n-        q = QueryDict('a=b&c=d&a=1')\n+        q = QueryDict(str('a=b&c=d&a=1'))\n         q1 = pickle.loads(pickle.dumps(q, 2))\n         self.assertEqual(q == q1, True)\n \n     def test_update_from_querydict(self):\n         \"\"\"Regression test for #8278: QueryDict.update(QueryDict)\"\"\"\n-        x = QueryDict(\"a=1&a=2\", mutable=True)\n-        y = QueryDict(\"a=3&a=4\")\n+        x = QueryDict(str(\"a=1&a=2\"), mutable=True)\n+        y = QueryDict(str(\"a=3&a=4\"))\n         x.update(y)\n         self.assertEqual(x.getlist('a'), ['1', '2', '3', '4'])\n \n     def test_non_default_encoding(self):\n         \"\"\"#13572 - QueryDict with a non-default encoding\"\"\"\n-        q = QueryDict(b'sbb=one', encoding='rot_13')\n-        self.assertEqual(q.encoding , 'rot_13' )\n-        self.assertEqual(q.items() , [('foo', 'bar')] )\n-        self.assertEqual(q.urlencode() , 'sbb=one' )\n+        q = QueryDict(str('cur=%A4'), encoding='iso-8859-15')\n+        self.assertEqual(q.encoding, 'iso-8859-15')\n+        self.assertEqual(list(six.iteritems(q)), [('cur', '€')])\n+        self.assertEqual(q.urlencode(), 'cur=%A4')\n         q = q.copy()\n-        self.assertEqual(q.encoding , 'rot_13' )\n-        self.assertEqual(q.items() , [('foo', 'bar')] )\n-        self.assertEqual(q.urlencode() , 'sbb=one' )\n-        self.assertEqual(copy.copy(q).encoding , 'rot_13' )\n-        self.assertEqual(copy.deepcopy(q).encoding , 'rot_13')\n+        self.assertEqual(q.encoding, 'iso-8859-15')\n+        self.assertEqual(list(six.iteritems(q)), [('cur', '€')])\n+        self.assertEqual(q.urlencode(), 'cur=%A4')\n+        self.assertEqual(copy.copy(q).encoding, 'iso-8859-15')\n+        self.assertEqual(copy.deepcopy(q).encoding, 'iso-8859-15')\n \n class HttpResponseTests(unittest.TestCase):\n     def test_unicode_headers(self):\n@@ -283,13 +293,8 @@ def test_iter_content(self):\n         #test retrieval explicitly using iter and odd inputs\n         r = HttpResponse()\n         r.content = ['1', '2', 3, '\\u079e']\n-        result = []\n         my_iter = r.__iter__()\n-        while True:\n-            try:\n-                result.append(next(my_iter))\n-            except StopIteration:\n-                break\n+        result = list(my_iter)\n         #'\\xde\\x9e' == unichr(1950).encode('utf-8')\n         self.assertEqual(result, ['1', '2', '3', b'\\xde\\x9e'])\n         self.assertEqual(r.content, b'123\\xde\\x9e')"
        },
        {
            "sha": "5a40bd88e22221c6a6dcea79a3dbceac32abca49",
            "filename": "tests/regressiontests/wsgi/tests.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/e04230e2e406dcf74eeec8d3c95c84362c7da780/tests%2Fregressiontests%2Fwsgi%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/e04230e2e406dcf74eeec8d3c95c84362c7da780/tests%2Fregressiontests%2Fwsgi%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fwsgi%2Ftests.py?ref=e04230e2e406dcf74eeec8d3c95c84362c7da780",
            "patch": "@@ -40,8 +40,8 @@ def start_response(status, headers):\n             response_data[\"headers\"],\n             [('Content-Type', 'text/html; charset=utf-8')])\n         self.assertEqual(\n-            six.text_type(response),\n-            \"Content-Type: text/html; charset=utf-8\\n\\nHello World!\")\n+            bytes(response),\n+            b\"Content-Type: text/html; charset=utf-8\\r\\n\\r\\nHello World!\")\n \n \n class GetInternalWSGIApplicationTest(unittest.TestCase):"
        }
    ],
    "stats": {
        "total": 239,
        "additions": 132,
        "deletions": 107
    }
}