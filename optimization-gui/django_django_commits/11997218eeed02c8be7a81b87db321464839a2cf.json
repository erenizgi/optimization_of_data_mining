{
    "author": "freakboy3742",
    "message": "Fixed #15042 -- Ensured that email addresses without a domain can still be mail recipients. Patch also improves the IDN handling introduced by r15006, and refactors the test suite to ensure even feature coverage. Thanks to net147 for the report, and to Łukasz Rekucki for the awesome patch.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15211 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "11997218eeed02c8be7a81b87db321464839a2cf",
    "files": [
        {
            "sha": "bb184ab31250b05fe0291687e228e1739bdd6c69",
            "filename": "django/core/mail/backends/smtp.py",
            "status": "modified",
            "additions": 5,
            "deletions": 8,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/11997218eeed02c8be7a81b87db321464839a2cf/django%2Fcore%2Fmail%2Fbackends%2Fsmtp.py",
            "raw_url": "https://github.com/django/django/raw/11997218eeed02c8be7a81b87db321464839a2cf/django%2Fcore%2Fmail%2Fbackends%2Fsmtp.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmail%2Fbackends%2Fsmtp.py?ref=11997218eeed02c8be7a81b87db321464839a2cf",
            "patch": "@@ -1,12 +1,13 @@\n \"\"\"SMTP email backend class.\"\"\"\n-\n import smtplib\n import socket\n import threading\n \n from django.conf import settings\n from django.core.mail.backends.base import BaseEmailBackend\n from django.core.mail.utils import DNS_NAME\n+from django.core.mail.message import sanitize_address\n+\n \n class EmailBackend(BaseEmailBackend):\n     \"\"\"\n@@ -91,17 +92,13 @@ def send_messages(self, email_messages):\n             self._lock.release()\n         return num_sent\n \n-    def _sanitize(self, email):\n-        name, domain = email.split('@', 1)\n-        email = '@'.join([name, domain.encode('idna')])\n-        return email\n-\n     def _send(self, email_message):\n         \"\"\"A helper method that does the actual sending.\"\"\"\n         if not email_message.recipients():\n             return False\n-        from_email = self._sanitize(email_message.from_email)\n-        recipients = map(self._sanitize, email_message.recipients())\n+        from_email = sanitize_address(email_message.from_email, email_message.encoding)\n+        recipients = [sanitize_address(addr, email_message.encoding)\n+                      for addr in email_message.recipients()]\n         try:\n             self.connection.sendmail(from_email, recipients,\n                     email_message.message().as_string())"
        },
        {
            "sha": "96ff689fd434f9a3a83502455fb98bd27247234b",
            "filename": "django/core/mail/message.py",
            "status": "modified",
            "additions": 48,
            "deletions": 17,
            "changes": 65,
            "blob_url": "https://github.com/django/django/blob/11997218eeed02c8be7a81b87db321464839a2cf/django%2Fcore%2Fmail%2Fmessage.py",
            "raw_url": "https://github.com/django/django/raw/11997218eeed02c8be7a81b87db321464839a2cf/django%2Fcore%2Fmail%2Fmessage.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmail%2Fmessage.py?ref=11997218eeed02c8be7a81b87db321464839a2cf",
            "patch": "@@ -12,6 +12,7 @@\n from django.conf import settings\n from django.core.mail.utils import DNS_NAME\n from django.utils.encoding import smart_str, force_unicode\n+from email.Utils import parseaddr\n \n # Don't BASE64-encode UTF-8 messages so that we avoid unwanted attention from\n # some spam filters.\n@@ -54,6 +55,22 @@ def make_msgid(idstring=None):\n     return msgid\n \n \n+# Header names that contain structured address data (RFC #5322)\n+ADDRESS_HEADERS = set([\n+    'from',\n+    'sender',\n+    'reply-to',\n+    'to',\n+    'cc',\n+    'bcc',\n+    'resent-from',\n+    'resent-sender',\n+    'resent-to',\n+    'resent-cc',\n+    'resent-bcc',\n+])\n+\n+\n def forbid_multi_line_headers(name, val, encoding):\n     \"\"\"Forbids multi-line headers, to prevent header injection.\"\"\"\n     encoding = encoding or settings.DEFAULT_CHARSET\n@@ -63,43 +80,57 @@ def forbid_multi_line_headers(name, val, encoding):\n     try:\n         val = val.encode('ascii')\n     except UnicodeEncodeError:\n-        if name.lower() in ('to', 'from', 'cc'):\n-            result = []\n-            for nm, addr in getaddresses((val,)):\n-                nm = str(Header(nm.encode(encoding), encoding))\n-                try:\n-                    addr = addr.encode('ascii')\n-                except UnicodeEncodeError:  # IDN\n-                    addr = str(Header(addr.encode(encoding), encoding))\n-                result.append(formataddr((nm, addr)))\n-            val = ', '.join(result)\n+        if name.lower() in ADDRESS_HEADERS:\n+            val = ', '.join(sanitize_address(addr, encoding)\n+                for addr in getaddresses((val,)))\n         else:\n-            val = Header(val.encode(encoding), encoding)\n+            val = str(Header(val, encoding))\n     else:\n         if name.lower() == 'subject':\n             val = Header(val)\n     return name, val\n \n+\n+def sanitize_address(addr, encoding):\n+    if isinstance(addr, basestring):\n+        addr = parseaddr(force_unicode(addr))\n+    nm, addr = addr\n+    nm = str(Header(nm, encoding))\n+    try:\n+        addr = addr.encode('ascii')\n+    except UnicodeEncodeError:  # IDN\n+        if u'@' in addr:\n+            localpart, domain = addr.split(u'@', 1)\n+            localpart = str(Header(localpart, encoding))\n+            domain = domain.encode('idna')\n+            addr = '@'.join([localpart, domain])\n+        else:\n+            addr = str(Header(addr, encoding))\n+    return formataddr((nm, addr))\n+\n+\n class SafeMIMEText(MIMEText):\n-    \n+\n     def __init__(self, text, subtype, charset):\n         self.encoding = charset\n         MIMEText.__init__(self, text, subtype, charset)\n-    \n-    def __setitem__(self, name, val):    \n+\n+    def __setitem__(self, name, val):\n         name, val = forbid_multi_line_headers(name, val, self.encoding)\n         MIMEText.__setitem__(self, name, val)\n \n+\n class SafeMIMEMultipart(MIMEMultipart):\n-    \n+\n     def __init__(self, _subtype='mixed', boundary=None, _subparts=None, encoding=None, **_params):\n         self.encoding = encoding\n         MIMEMultipart.__init__(self, _subtype, boundary, _subparts, **_params)\n-        \n+\n     def __setitem__(self, name, val):\n         name, val = forbid_multi_line_headers(name, val, self.encoding)\n         MIMEMultipart.__setitem__(self, name, val)\n \n+\n class EmailMessage(object):\n     \"\"\"\n     A container for email information.\n@@ -274,7 +305,7 @@ def __init__(self, subject='', body='', from_email=None, to=None, bcc=None,\n         conversions.\n         \"\"\"\n         super(EmailMultiAlternatives, self).__init__(subject, body, from_email, to, bcc, connection, attachments, headers, cc)\n-        self.alternatives=alternatives or []\n+        self.alternatives = alternatives or []\n \n     def attach_alternative(self, content, mimetype):\n         \"\"\"Attach an alternative content representation.\"\"\""
        },
        {
            "sha": "8bdc562c81861676dac7026e897450c987fac33c",
            "filename": "tests/regressiontests/mail/tests.py",
            "status": "modified",
            "additions": 421,
            "deletions": 223,
            "changes": 644,
            "blob_url": "https://github.com/django/django/blob/11997218eeed02c8be7a81b87db321464839a2cf/tests%2Fregressiontests%2Fmail%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/11997218eeed02c8be7a81b87db321464839a2cf/tests%2Fregressiontests%2Fmail%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fmail%2Ftests.py?ref=11997218eeed02c8be7a81b87db321464839a2cf",
            "patch": "@@ -1,21 +1,62 @@\n # coding: utf-8\n+import asyncore\n import email\n import os\n import shutil\n+import smtpd\n import sys\n-import tempfile\n from StringIO import StringIO\n+import tempfile\n+import threading\n+\n from django.conf import settings\n from django.core import mail\n from django.core.mail import EmailMessage, mail_admins, mail_managers, EmailMultiAlternatives\n from django.core.mail import send_mail, send_mass_mail\n-from django.core.mail.backends.base import BaseEmailBackend\n from django.core.mail.backends import console, dummy, locmem, filebased, smtp\n from django.core.mail.message import BadHeaderError\n from django.test import TestCase\n from django.utils.translation import ugettext_lazy\n+from django.utils.functional import wraps\n+\n+\n+def alter_django_settings(**kwargs):\n+    oldvalues = {}\n+    nonexistant = []\n+    for setting, newvalue in kwargs.iteritems():\n+        try:\n+            oldvalues[setting] = getattr(settings, setting)\n+        except AttributeError:\n+            nonexistant.append(setting)\n+        setattr(settings, setting, newvalue)\n+    return oldvalues, nonexistant\n+\n+\n+def restore_django_settings(state):\n+    oldvalues, nonexistant = state\n+    for setting, oldvalue in oldvalues.iteritems():\n+        setattr(settings, setting, oldvalue)\n+    for setting in nonexistant:\n+        delattr(settings, setting)\n+\n+\n+def with_django_settings(**kwargs):\n+    def decorator(test):\n+        @wraps(test)\n+        def decorated_test(self):\n+            state = alter_django_settings(**kwargs)\n+            try:\n+                return test(self)\n+            finally:\n+                restore_django_settings(state)\n+        return decorated_test\n+    return decorator\n+\n \n class MailTests(TestCase):\n+    \"\"\"\n+    Non-backend specific tests.\n+    \"\"\"\n \n     def test_ascii(self):\n         email = EmailMessage('Subject', 'Content', 'from@example.com', ['to@example.com'])\n@@ -26,7 +67,7 @@ def test_ascii(self):\n         self.assertEqual(message['To'], 'to@example.com')\n \n     def test_multiple_recipients(self):\n-        email = EmailMessage('Subject', 'Content', 'from@example.com', ['to@example.com','other@example.com'])\n+        email = EmailMessage('Subject', 'Content', 'from@example.com', ['to@example.com', 'other@example.com'])\n         message = email.message()\n         self.assertEqual(message['Subject'].encode(), 'Subject')\n         self.assertEqual(message.get_payload(), 'Content')\n@@ -40,14 +81,6 @@ def test_cc(self):\n         self.assertEqual(message['Cc'], 'cc@example.com')\n         self.assertEqual(email.recipients(), ['to@example.com', 'cc@example.com'])\n \n-        # Verify headers\n-        old_stdout = sys.stdout\n-        sys.stdout = StringIO()\n-        connection = console.EmailBackend()\n-        connection.send_messages([email])\n-        self.assertTrue(sys.stdout.getvalue().startswith('Content-Type: text/plain; charset=\"utf-8\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: quoted-printable\\nSubject: Subject\\nFrom: from@example.com\\nTo: to@example.com\\nCc: cc@example.com\\nDate: '))\n-        sys.stdout = old_stdout\n-\n         # Test multiple CC with multiple To\n         email = EmailMessage('Subject', 'Content', 'from@example.com', ['to@example.com', 'other@example.com'], cc=['cc@example.com', 'cc.other@example.com'])\n         message = email.message()\n@@ -83,33 +116,6 @@ def test_message_header_overrides(self):\n         email = EmailMessage('subject', 'content', 'from@example.com', ['to@example.com'], headers=headers)\n         self.assertEqual(email.message().as_string(), 'Content-Type: text/plain; charset=\"utf-8\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: quoted-printable\\nSubject: subject\\nFrom: from@example.com\\nTo: to@example.com\\ndate: Fri, 09 Nov 2001 01:08:47 -0000\\nMessage-ID: foo\\n\\ncontent')\n \n-    def test_empty_admins(self):\n-        \"\"\"\n-        Test that mail_admins/mail_managers doesn't connect to the mail server\n-        if there are no recipients (#9383)\n-        \"\"\"\n-        old_admins = settings.ADMINS\n-        old_managers = settings.MANAGERS\n-\n-        settings.ADMINS = settings.MANAGERS = [('nobody','nobody@example.com')]\n-        mail.outbox = []\n-        mail_admins('hi', 'there')\n-        self.assertEqual(len(mail.outbox), 1)\n-        mail.outbox = []\n-        mail_managers('hi', 'there')\n-        self.assertEqual(len(mail.outbox), 1)\n-\n-        settings.ADMINS = settings.MANAGERS = []\n-        mail.outbox = []\n-        mail_admins('hi', 'there')\n-        self.assertEqual(len(mail.outbox), 0)\n-        mail.outbox = []\n-        mail_managers('hi', 'there')\n-        self.assertEqual(len(mail.outbox), 0)\n-\n-        settings.ADMINS = old_admins\n-        settings.MANAGERS = old_managers\n-\n     def test_from_header(self):\n         \"\"\"\n         Make sure we can manually set the From header (#9214)\n@@ -129,17 +135,26 @@ def test_multiple_message_call(self):\n         message = email.message()\n         self.assertEqual(message['From'], 'from@example.com')\n \n-    def test_unicode_header(self):\n+    def test_unicode_address_header(self):\n         \"\"\"\n         Regression for #11144 - When a to/from/cc header contains unicode,\n         make sure the email addresses are parsed correctly (especially with\n         regards to commas)\n         \"\"\"\n-        email = EmailMessage('Subject', 'Content', 'from@example.com', ['\"Firstname Sürname\" <to@example.com>','other@example.com'])\n+        email = EmailMessage('Subject', 'Content', 'from@example.com', ['\"Firstname Sürname\" <to@example.com>', 'other@example.com'])\n         self.assertEqual(email.message()['To'], '=?utf-8?q?Firstname_S=C3=BCrname?= <to@example.com>, other@example.com')\n-        email = EmailMessage('Subject', 'Content', 'from@example.com', ['\"Sürname, Firstname\" <to@example.com>','other@example.com'])\n+        email = EmailMessage('Subject', 'Content', 'from@example.com', ['\"Sürname, Firstname\" <to@example.com>', 'other@example.com'])\n         self.assertEqual(email.message()['To'], '=?utf-8?q?S=C3=BCrname=2C_Firstname?= <to@example.com>, other@example.com')\n \n+    def test_unicode_headers(self):\n+        email = EmailMessage(u\"Gżegżółka\", \"Content\", \"from@example.com\", [\"to@example.com\"],\n+                             headers={\"Sender\": '\"Firstname Sürname\" <sender@example.com>',\n+                                      \"Comments\": 'My Sürname is non-ASCII'})\n+        message = email.message()\n+        self.assertEqual(message['Subject'], '=?utf-8?b?R8W8ZWfFvMOzxYJrYQ==?=')\n+        self.assertEqual(message['Sender'], '=?utf-8?q?Firstname_S=C3=BCrname?= <sender@example.com>')\n+        self.assertEqual(message['Comments'], '=?utf-8?q?My_S=C3=BCrname_is_non-ASCII?=')\n+\n     def test_safe_mime_multipart(self):\n         \"\"\"\n         Make sure headers can be set with a different encoding than utf-8 in\n@@ -193,79 +208,14 @@ def test_attachments(self):\n         self.assertEqual(payload[0].get_content_type(), 'multipart/alternative')\n         self.assertEqual(payload[1].get_content_type(), 'application/pdf')\n \n-    def test_arbitrary_stream(self):\n-        \"\"\"\n-        Test that the console backend can be pointed at an arbitrary stream.\n-        \"\"\"\n-        s = StringIO()\n-        connection = mail.get_connection('django.core.mail.backends.console.EmailBackend', stream=s)\n-        send_mail('Subject', 'Content', 'from@example.com', ['to@example.com'], connection=connection)\n-        self.assertTrue(s.getvalue().startswith('Content-Type: text/plain; charset=\"utf-8\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: quoted-printable\\nSubject: Subject\\nFrom: from@example.com\\nTo: to@example.com\\nDate: '))\n-\n-    def test_stdout(self):\n-        \"\"\"Make sure that the console backend writes to stdout by default\"\"\"\n-        old_stdout = sys.stdout\n-        sys.stdout = StringIO()\n-        connection = console.EmailBackend()\n-        email = EmailMessage('Subject', 'Content', 'bounce@example.com', ['to@example.com'], headers={'From': 'from@example.com'})\n-        connection.send_messages([email])\n-        self.assertTrue(sys.stdout.getvalue().startswith('Content-Type: text/plain; charset=\"utf-8\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: quoted-printable\\nSubject: Subject\\nFrom: from@example.com\\nTo: to@example.com\\nDate: '))\n-        sys.stdout = old_stdout\n-\n-    def test_dummy(self):\n+    def test_dummy_backend(self):\n         \"\"\"\n         Make sure that dummy backends returns correct number of sent messages\n         \"\"\"\n         connection = dummy.EmailBackend()\n         email = EmailMessage('Subject', 'Content', 'bounce@example.com', ['to@example.com'], headers={'From': 'from@example.com'})\n         self.assertEqual(connection.send_messages([email, email, email]), 3)\n \n-    def test_locmem(self):\n-        \"\"\"\n-        Make sure that the locmen backend populates the outbox.\n-        \"\"\"\n-        mail.outbox = []\n-        connection = locmem.EmailBackend()\n-        email1 = EmailMessage('Subject', 'Content', 'bounce@example.com', ['to@example.com'], headers={'From': 'from@example.com'})\n-        email2 = EmailMessage('Subject 2', 'Content', 'bounce@example.com', ['to@example.com'], headers={'From': 'from@example.com'})\n-        connection.send_messages([email1, email2])\n-        self.assertEqual(len(mail.outbox), 2)\n-        self.assertEqual(mail.outbox[0].subject, 'Subject')\n-        self.assertEqual(mail.outbox[1].subject, 'Subject 2')\n-\n-        # Make sure that multiple locmem connections share mail.outbox\n-        mail.outbox = []\n-        connection2 = locmem.EmailBackend()\n-        email = EmailMessage('Subject', 'Content', 'bounce@example.com', ['to@example.com'], headers={'From': 'from@example.com'})\n-        connection.send_messages([email])\n-        connection2.send_messages([email])\n-        self.assertEqual(len(mail.outbox), 2)\n-\n-    def test_file_backend(self):\n-        tmp_dir = tempfile.mkdtemp()\n-        connection = filebased.EmailBackend(file_path=tmp_dir)\n-        email1 = EmailMessage('Subject', 'Content', 'bounce@example.com', ['to@example.com'], headers={'From': 'from@example.com'})\n-        connection.send_messages([email1])\n-        self.assertEqual(len(os.listdir(tmp_dir)), 1)\n-        message = email.message_from_file(open(os.path.join(tmp_dir, os.listdir(tmp_dir)[0])))\n-        self.assertEqual(message.get_content_type(), 'text/plain')\n-        self.assertEqual(message.get('subject'), 'Subject')\n-        self.assertEqual(message.get('from'), 'from@example.com')\n-        self.assertEqual(message.get('to'), 'to@example.com')\n-        connection2 = filebased.EmailBackend(file_path=tmp_dir)\n-        connection2.send_messages([email1])\n-        self.assertEqual(len(os.listdir(tmp_dir)), 2)\n-        connection.send_messages([email1])\n-        self.assertEqual(len(os.listdir(tmp_dir)), 2)\n-        email1.connection = filebased.EmailBackend(file_path=tmp_dir)\n-        connection_created = connection.open()\n-        email1.send()\n-        self.assertEqual(len(os.listdir(tmp_dir)), 3)\n-        email1.send()\n-        self.assertEqual(len(os.listdir(tmp_dir)), 3)\n-        connection.close()\n-        shutil.rmtree(tmp_dir)\n-\n     def test_arbitrary_keyword(self):\n         \"\"\"\n         Make sure that get_connection() accepts arbitrary keyword that might be\n@@ -289,144 +239,392 @@ def test_backend_arg(self):\n         self.assertTrue(isinstance(mail.get_connection('django.core.mail.backends.dummy.EmailBackend'), dummy.EmailBackend))\n         self.assertTrue(isinstance(mail.get_connection('django.core.mail.backends.console.EmailBackend'), console.EmailBackend))\n         tmp_dir = tempfile.mkdtemp()\n-        self.assertTrue(isinstance(mail.get_connection('django.core.mail.backends.filebased.EmailBackend', file_path=tmp_dir), filebased.EmailBackend))\n-        shutil.rmtree(tmp_dir)\n+        try:\n+            self.assertTrue(isinstance(mail.get_connection('django.core.mail.backends.filebased.EmailBackend', file_path=tmp_dir), filebased.EmailBackend))\n+        finally:\n+            shutil.rmtree(tmp_dir)\n         self.assertTrue(isinstance(mail.get_connection(), locmem.EmailBackend))\n \n+    @with_django_settings(\n+        EMAIL_BACKEND='django.core.mail.backends.locmem.EmailBackend',\n+        ADMINS=[('nobody', 'nobody@example.com')],\n+        MANAGERS=[('nobody', 'nobody@example.com')])\n     def test_connection_arg(self):\n         \"\"\"Test connection argument to send_mail(), et. al.\"\"\"\n-        connection = mail.get_connection('django.core.mail.backends.locmem.EmailBackend')\n-\n         mail.outbox = []\n+\n+        # Send using non-default connection\n+        connection = mail.get_connection('regressiontests.mail.custombackend.EmailBackend')\n         send_mail('Subject', 'Content', 'from@example.com', ['to@example.com'], connection=connection)\n-        self.assertEqual(len(mail.outbox), 1)\n-        message = mail.outbox[0]\n-        self.assertEqual(message.subject, 'Subject')\n-        self.assertEqual(message.from_email, 'from@example.com')\n-        self.assertEqual(message.to, ['to@example.com'])\n+        self.assertEqual(mail.outbox, [])\n+        self.assertEqual(len(connection.test_outbox), 1)\n+        self.assertEqual(connection.test_outbox[0].subject, 'Subject')\n \n-        mail.outbox = []\n+        connection = mail.get_connection('regressiontests.mail.custombackend.EmailBackend')\n         send_mass_mail([\n                 ('Subject1', 'Content1', 'from1@example.com', ['to1@example.com']),\n-                ('Subject2', 'Content2', 'from2@example.com', ['to2@example.com'])\n+                ('Subject2', 'Content2', 'from2@example.com', ['to2@example.com']),\n             ], connection=connection)\n-        self.assertEqual(len(mail.outbox), 2)\n-        message = mail.outbox[0]\n-        self.assertEqual(message.subject, 'Subject1')\n-        self.assertEqual(message.from_email, 'from1@example.com')\n-        self.assertEqual(message.to, ['to1@example.com'])\n-        message = mail.outbox[1]\n-        self.assertEqual(message.subject, 'Subject2')\n-        self.assertEqual(message.from_email, 'from2@example.com')\n-        self.assertEqual(message.to, ['to2@example.com'])\n-\n-        old_admins = settings.ADMINS\n-        old_managers = settings.MANAGERS\n-        settings.ADMINS = settings.MANAGERS = [('nobody','nobody@example.com')]\n+        self.assertEqual(mail.outbox, [])\n+        self.assertEqual(len(connection.test_outbox), 2)\n+        self.assertEqual(connection.test_outbox[0].subject, 'Subject1')\n+        self.assertEqual(connection.test_outbox[1].subject, 'Subject2')\n \n-        mail.outbox = []\n-        mail_admins('Subject', 'Content', connection=connection)\n-        self.assertEqual(len(mail.outbox), 1)\n-        message = mail.outbox[0]\n-        self.assertEqual(message.subject, '[Django] Subject')\n-        self.assertEqual(message.from_email, 'root@localhost')\n-        self.assertEqual(message.to, ['nobody@example.com'])\n+        connection = mail.get_connection('regressiontests.mail.custombackend.EmailBackend')\n+        mail_admins('Admin message', 'Content', connection=connection)\n+        self.assertEqual(mail.outbox, [])\n+        self.assertEqual(len(connection.test_outbox), 1)\n+        self.assertEqual(connection.test_outbox[0].subject, '[Django] Admin message')\n \n-        mail.outbox = []\n-        mail_managers('Subject', 'Content', connection=connection)\n-        self.assertEqual(len(mail.outbox), 1)\n-        message = mail.outbox[0]\n-        self.assertEqual(message.subject, '[Django] Subject')\n-        self.assertEqual(message.from_email, 'root@localhost')\n-        self.assertEqual(message.to, ['nobody@example.com'])\n-\n-        settings.ADMINS = old_admins\n-        settings.MANAGERS = old_managers\n-\n-    def test_mail_prefix(self):\n-        \"\"\"Test prefix argument in manager/admin mail.\"\"\"\n-        # Regression for #13494.\n-        old_admins = settings.ADMINS\n-        old_managers = settings.MANAGERS\n-        settings.ADMINS = settings.MANAGERS = [('nobody','nobody@example.com')]\n+        connection = mail.get_connection('regressiontests.mail.custombackend.EmailBackend')\n+        mail_managers('Manager message', 'Content', connection=connection)\n+        self.assertEqual(mail.outbox, [])\n+        self.assertEqual(len(connection.test_outbox), 1)\n+        self.assertEqual(connection.test_outbox[0].subject, '[Django] Manager message')\n+\n+\n+class BaseEmailBackendTests(object):\n+    email_backend = None\n+\n+    def setUp(self):\n+        self.__settings_state = alter_django_settings(EMAIL_BACKEND=self.email_backend)\n+\n+    def tearDown(self):\n+        restore_django_settings(self.__settings_state)\n \n+    def assertStartsWith(self, first, second):\n+        if not first.startswith(second):\n+            self.longMessage = True\n+            self.assertEqual(first[:len(second)], second, \"First string doesn't start with the second.\")\n+\n+    def get_mailbox_content(self):\n+        raise NotImplementedError\n+\n+    def flush_mailbox(self):\n+        raise NotImplementedError\n+\n+    def get_the_message(self):\n+        mailbox = self.get_mailbox_content()\n+        self.assertEqual(len(mailbox), 1,\n+            \"Expected exactly one message, got %d.\\n%r\" % (len(mailbox), [\n+                m.as_string() for m in mailbox]))\n+        return mailbox[0]\n+\n+    def test_send(self):\n+        email = EmailMessage('Subject', 'Content', 'from@example.com', ['to@example.com'])\n+        num_sent = mail.get_connection().send_messages([email])\n+        self.assertEqual(num_sent, 1)\n+        message = self.get_the_message()\n+        self.assertEqual(message[\"subject\"], \"Subject\")\n+        self.assertEqual(message.get_payload(), \"Content\")\n+        self.assertEqual(message[\"from\"], \"from@example.com\")\n+        self.assertEqual(message.get_all(\"to\"), [\"to@example.com\"])\n+\n+    def test_send_many(self):\n+        email1 = EmailMessage('Subject', 'Content1', 'from@example.com', ['to@example.com'])\n+        email2 = EmailMessage('Subject', 'Content2', 'from@example.com', ['to@example.com'])\n+        num_sent = mail.get_connection().send_messages([email1, email2])\n+        self.assertEqual(num_sent, 2)\n+        messages = self.get_mailbox_content()\n+        self.assertEquals(len(messages), 2)\n+        self.assertEqual(messages[0].get_payload(), \"Content1\")\n+        self.assertEqual(messages[1].get_payload(), \"Content2\")\n+\n+    def test_send_verbose_name(self):\n+        email = EmailMessage(\"Subject\", \"Content\", '\"Firstname Sürname\" <from@example.com>',\n+                             [\"to@example.com\"])\n+        email.send()\n+        message = self.get_the_message()\n+        self.assertEqual(message[\"subject\"], \"Subject\")\n+        self.assertEqual(message.get_payload(), \"Content\")\n+        self.assertEqual(message[\"from\"], \"=?utf-8?q?Firstname_S=C3=BCrname?= <from@example.com>\")\n+\n+    @with_django_settings(MANAGERS=[('nobody', 'nobody@example.com')])\n+    def test_html_mail_managers(self):\n+        \"\"\"Test html_message argument to mail_managers\"\"\"\n+        mail_managers('Subject', 'Content', html_message='HTML Content')\n+        message = self.get_the_message()\n+\n+        self.assertEqual(message.get('subject'), '[Django] Subject')\n+        self.assertEqual(message.get_all('to'), ['nobody@example.com'])\n+        self.assertTrue(message.is_multipart())\n+        self.assertEqual(len(message.get_payload()), 2)\n+        self.assertEqual(message.get_payload(0).get_payload(), 'Content')\n+        self.assertEqual(message.get_payload(0).get_content_type(), 'text/plain')\n+        self.assertEqual(message.get_payload(1).get_payload(), 'HTML Content')\n+        self.assertEqual(message.get_payload(1).get_content_type(), 'text/html')\n+\n+    @with_django_settings(ADMINS=[('nobody', 'nobody@example.com')])\n+    def test_html_mail_admins(self):\n+        \"\"\"Test html_message argument to mail_admins \"\"\"\n+        mail_admins('Subject', 'Content', html_message='HTML Content')\n+        message = self.get_the_message()\n+\n+        self.assertEqual(message.get('subject'), '[Django] Subject')\n+        self.assertEqual(message.get_all('to'), ['nobody@example.com'])\n+        self.assertTrue(message.is_multipart())\n+        self.assertEqual(len(message.get_payload()), 2)\n+        self.assertEqual(message.get_payload(0).get_payload(), 'Content')\n+        self.assertEqual(message.get_payload(0).get_content_type(), 'text/plain')\n+        self.assertEqual(message.get_payload(1).get_payload(), 'HTML Content')\n+        self.assertEqual(message.get_payload(1).get_content_type(), 'text/html')\n+\n+    @with_django_settings(ADMINS=[('nobody', 'nobody+admin@example.com')],\n+                         MANAGERS=[('nobody', 'nobody+manager@example.com')])\n+    def test_manager_and_admin_mail_prefix(self):\n+        \"\"\"\n+        String prefix + lazy translated subject = bad output\n+        Regression for #13494\n+        \"\"\"\n         mail_managers(ugettext_lazy('Subject'), 'Content')\n-        self.assertEqual(len(mail.outbox), 1)\n-        message = mail.outbox[0]\n-        self.assertEqual(message.subject, '[Django] Subject')\n+        message = self.get_the_message()\n+        self.assertEqual(message.get('subject'), '[Django] Subject')\n \n-        mail.outbox = []\n+        self.flush_mailbox()\n         mail_admins(ugettext_lazy('Subject'), 'Content')\n-        self.assertEqual(len(mail.outbox), 1)\n-        message = mail.outbox[0]\n-        self.assertEqual(message.subject, '[Django] Subject')\n+        message = self.get_the_message()\n+        self.assertEqual(message.get('subject'), '[Django] Subject')\n \n-        settings.ADMINS = old_admins\n-        settings.MANAGERS = old_managers\n+    @with_django_settings(ADMINS=(), MANAGERS=())\n+    def test_empty_admins(self):\n+        \"\"\"\n+        Test that mail_admins/mail_managers doesn't connect to the mail server\n+        if there are no recipients (#9383)\n+        \"\"\"\n+        mail_admins('hi', 'there')\n+        self.assertEqual(self.get_mailbox_content(), [])\n+        mail_managers('hi', 'there')\n+        self.assertEqual(self.get_mailbox_content(), [])\n \n-    def test_html_mail_admins(self):\n-        \"\"\"Test html_message argument to mail_admins and mail_managers\"\"\"\n-        old_admins = settings.ADMINS\n-        settings.ADMINS = [('nobody','nobody@example.com')]\n+    def test_message_cc_header(self):\n+        \"\"\"\n+        Regression test for #7722\n+        \"\"\"\n+        email = EmailMessage('Subject', 'Content', 'from@example.com', ['to@example.com'], cc=['cc@example.com'])\n+        mail.get_connection().send_messages([email])\n+        message = self.get_the_message()\n+        self.assertStartsWith(message.as_string(), 'Content-Type: text/plain; charset=\"utf-8\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: quoted-printable\\nSubject: Subject\\nFrom: from@example.com\\nTo: to@example.com\\nCc: cc@example.com\\nDate: ')\n \n-        mail.outbox = []\n-        mail_admins('Subject', 'Content', html_message='HTML Content')\n-        self.assertEqual(len(mail.outbox), 1)\n-        message = mail.outbox[0]\n-        self.assertEqual(message.subject, '[Django] Subject')\n-        self.assertEqual(message.body, 'Content')\n-        self.assertEqual(message.alternatives, [('HTML Content', 'text/html')])\n+    def test_idn_send(self):\n+        \"\"\"\n+        Regression test for #14301\n+        \"\"\"\n+        self.assertTrue(send_mail('Subject', 'Content', 'from@öäü.com', [u'to@öäü.com']))\n+        message = self.get_the_message()\n+        self.assertEqual(message.get('subject'), 'Subject')\n+        self.assertEqual(message.get('from'), 'from@xn--4ca9at.com')\n+        self.assertEqual(message.get('to'), 'to@xn--4ca9at.com')\n+\n+        self.flush_mailbox()\n+        m = EmailMessage('Subject', 'Content', 'from@öäü.com',\n+                     [u'to@öäü.com'], cc=[u'cc@öäü.com'])\n+        m.send()\n+        message = self.get_the_message()\n+        self.assertEqual(message.get('subject'), 'Subject')\n+        self.assertEqual(message.get('from'), 'from@xn--4ca9at.com')\n+        self.assertEqual(message.get('to'), 'to@xn--4ca9at.com')\n+        self.assertEqual(message.get('cc'), 'cc@xn--4ca9at.com')\n+\n+    def test_recipient_without_domain(self):\n+        \"\"\"\n+        Regression test for #15042\n+        \"\"\"\n+        self.assertTrue(send_mail(\"Subject\", \"Content\", \"tester\", [\"django\"]))\n+        message = self.get_the_message()\n+        self.assertEqual(message.get('subject'), 'Subject')\n+        self.assertEqual(message.get('from'), \"tester\")\n+        self.assertEqual(message.get('to'), \"django\")\n \n-        settings.ADMINS = old_admins\n \n-    def test_html_mail_managers(self):\n-        \"\"\"Test html_message argument to mail_admins and mail_managers\"\"\"\n-        old_managers = settings.MANAGERS\n-        settings.MANAGERS = [('nobody','nobody@example.com')]\n+class LocmemBackendTests(BaseEmailBackendTests, TestCase):\n+    email_backend = 'django.core.mail.backends.locmem.EmailBackend'\n \n-        mail.outbox = []\n-        mail_managers('Subject', 'Content', html_message='HTML Content')\n-        self.assertEqual(len(mail.outbox), 1)\n-        message = mail.outbox[0]\n-        self.assertEqual(message.subject, '[Django] Subject')\n-        self.assertEqual(message.body, 'Content')\n-        self.assertEqual(message.alternatives, [('HTML Content', 'text/html')])\n+    def get_mailbox_content(self):\n+        return [m.message() for m in mail.outbox]\n \n-        settings.MANAGERS = old_managers\n+    def flush_mailbox(self):\n+        mail.outbox = []\n \n-    def test_idn_validation(self):\n-        \"\"\"Test internationalized email adresses\"\"\"\n-        # Regression for #14301.\n+    def tearDown(self):\n+        super(LocmemBackendTests, self).tearDown()\n         mail.outbox = []\n-        from_email = u'fröm@öäü.com'\n-        to_email = u'tö@öäü.com'\n-        connection = mail.get_connection('django.core.mail.backends.locmem.EmailBackend')\n-        send_mail('Subject', 'Content', from_email, [to_email], connection=connection)\n-        self.assertEqual(len(mail.outbox), 1)\n-        message = mail.outbox[0]\n-        self.assertEqual(message.subject, 'Subject')\n-        self.assertEqual(message.from_email, from_email)\n-        self.assertEqual(message.to, [to_email])\n-        self.assertTrue(message.message().as_string().startswith('Content-Type: text/plain; charset=\"utf-8\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: quoted-printable\\nSubject: Subject\\nFrom: =?utf-8?b?ZnLDtm1Aw7bDpMO8LmNvbQ==?=\\nTo: =?utf-8?b?dMO2QMO2w6TDvC5jb20=?='))\n-\n-    def test_idn_smtp_send(self):\n-        import smtplib\n-        smtplib.SMTP = MockSMTP\n-        from_email = u'fröm@öäü.com'\n-        to_email = u'tö@öäü.com'\n-        connection = mail.get_connection('django.core.mail.backends.smtp.EmailBackend')\n-        self.assertTrue(send_mail('Subject', 'Content', from_email, [to_email], connection=connection))\n-\n-class MockSMTP(object):\n-    def __init__(self, host='', port=0, local_hostname=None,\n-                 timeout=1):\n-        pass\n-\n-    def sendmail(self, from_addr, to_addrs, msg, mail_options=[],\n-                 rcpt_options=[]):\n-        for addr in to_addrs:\n-            str(addr.split('@', 1)[-1])\n-        return {}\n-\n-    def quit(self):\n-        return 0\n+\n+    def test_locmem_shared_messages(self):\n+        \"\"\"\n+        Make sure that the locmen backend populates the outbox.\n+        \"\"\"\n+        connection = locmem.EmailBackend()\n+        connection2 = locmem.EmailBackend()\n+        email = EmailMessage('Subject', 'Content', 'bounce@example.com', ['to@example.com'], headers={'From': 'from@example.com'})\n+        connection.send_messages([email])\n+        connection2.send_messages([email])\n+        self.assertEqual(len(mail.outbox), 2)\n+\n+\n+class FileBackendTests(BaseEmailBackendTests, TestCase):\n+    email_backend = 'django.core.mail.backends.filebased.EmailBackend'\n+\n+    def setUp(self):\n+        super(FileBackendTests, self).setUp()\n+        self.tmp_dir = tempfile.mkdtemp()\n+        self.__settings_state = alter_django_settings(EMAIL_FILE_PATH=self.tmp_dir)\n+\n+    def tearDown(self):\n+        restore_django_settings(self.__settings_state)\n+        shutil.rmtree(self.tmp_dir)\n+        super(FileBackendTests, self).tearDown()\n+\n+    def flush_mailbox(self):\n+        for filename in os.listdir(self.tmp_dir):\n+            os.unlink(os.path.join(self.tmp_dir, filename))\n+\n+    def get_mailbox_content(self):\n+        messages = []\n+        for filename in os.listdir(self.tmp_dir):\n+            session = open(os.path.join(self.tmp_dir, filename)).read().split('\\n' + ('-' * 79) + '\\n')\n+            messages.extend(email.message_from_string(m) for m in session if m)\n+        return messages\n+\n+    def test_file_sessions(self):\n+        \"\"\"Make sure opening a connection creates a new file\"\"\"\n+        msg = EmailMessage('Subject', 'Content', 'bounce@example.com', ['to@example.com'], headers={'From': 'from@example.com'})\n+        connection = mail.get_connection()\n+        connection.send_messages([msg])\n+\n+        self.assertEqual(len(os.listdir(self.tmp_dir)), 1)\n+        message = email.message_from_file(open(os.path.join(self.tmp_dir, os.listdir(self.tmp_dir)[0])))\n+        self.assertEqual(message.get_content_type(), 'text/plain')\n+        self.assertEqual(message.get('subject'), 'Subject')\n+        self.assertEqual(message.get('from'), 'from@example.com')\n+        self.assertEqual(message.get('to'), 'to@example.com')\n+\n+        connection2 = mail.get_connection()\n+        connection2.send_messages([msg])\n+        self.assertEqual(len(os.listdir(self.tmp_dir)), 2)\n+\n+        connection.send_messages([msg])\n+        self.assertEqual(len(os.listdir(self.tmp_dir)), 2)\n+\n+        msg.connection = mail.get_connection()\n+        self.assertTrue(connection.open())\n+        msg.send()\n+        self.assertEqual(len(os.listdir(self.tmp_dir)), 3)\n+        msg.send()\n+        self.assertEqual(len(os.listdir(self.tmp_dir)), 3)\n+\n+\n+class ConsoleBackendTests(BaseEmailBackendTests, TestCase):\n+    email_backend = 'django.core.mail.backends.console.EmailBackend'\n+\n+    def setUp(self):\n+        super(ConsoleBackendTests, self).setUp()\n+        self.__stdout = sys.stdout\n+        self.stream = sys.stdout = StringIO()\n+\n+    def tearDown(self):\n+        del self.stream\n+        sys.stdout = self.__stdout\n+        del self.__stdout\n+        super(ConsoleBackendTests, self).tearDown()\n+\n+    def flush_mailbox(self):\n+        self.stream = sys.stdout = StringIO()\n+\n+    def get_mailbox_content(self):\n+        messages = self.stream.getvalue().split('\\n' + ('-' * 79) + '\\n')\n+        return [email.message_from_string(m) for m in messages if m]\n+\n+    def test_console_stream_kwarg(self):\n+        \"\"\"\n+        Test that the console backend can be pointed at an arbitrary stream.\n+        \"\"\"\n+        s = StringIO()\n+        connection = mail.get_connection('django.core.mail.backends.console.EmailBackend', stream=s)\n+        send_mail('Subject', 'Content', 'from@example.com', ['to@example.com'], connection=connection)\n+        self.assertTrue(s.getvalue().startswith('Content-Type: text/plain; charset=\"utf-8\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: quoted-printable\\nSubject: Subject\\nFrom: from@example.com\\nTo: to@example.com\\nDate: '))\n+\n+\n+class FakeSMTPServer(smtpd.SMTPServer, threading.Thread):\n+    \"\"\"\n+    Asyncore SMTP server wrapped into a thread. Based on DummyFTPServer from:\n+    http://svn.python.org/view/python/branches/py3k/Lib/test/test_ftplib.py?revision=86061&view=markup\n+    \"\"\"\n+\n+    def __init__(self, *args, **kwargs):\n+        threading.Thread.__init__(self)\n+        smtpd.SMTPServer.__init__(self, *args, **kwargs)\n+        self._sink = []\n+        self.active = False\n+        self.active_lock = threading.Lock()\n+        self.sink_lock = threading.Lock()\n+\n+    def process_message(self, peer, mailfrom, rcpttos, data):\n+        m = email.message_from_string(data)\n+        maddr = email.Utils.parseaddr(m.get('from'))[1]\n+        if mailfrom != maddr:\n+            return \"553 '%s' != '%s'\" % (mailfrom, maddr)\n+        self.sink_lock.acquire()\n+        self._sink.append(m)\n+        self.sink_lock.release()\n+\n+    def get_sink(self):\n+        self.sink_lock.acquire()\n+        try:\n+            return self._sink[:]\n+        finally:\n+            self.sink_lock.release()\n+\n+    def flush_sink(self):\n+        self.sink_lock.acquire()\n+        self._sink[:] = []\n+        self.sink_lock.release()\n+\n+    def start(self):\n+        assert not self.active\n+        self.__flag = threading.Event()\n+        threading.Thread.start(self)\n+        self.__flag.wait()\n+\n+    def run(self):\n+        self.active = True\n+        self.__flag.set()\n+        while self.active and asyncore.socket_map:\n+            self.active_lock.acquire()\n+            asyncore.loop(timeout=0.1, count=1)\n+            self.active_lock.release()\n+        asyncore.close_all()\n+\n+    def stop(self):\n+        assert self.active\n+        self.active = False\n+        self.join()\n+\n+\n+class SMTPBackendTests(BaseEmailBackendTests, TestCase):\n+    email_backend = 'django.core.mail.backends.smtp.EmailBackend'\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.server = FakeSMTPServer(('127.0.0.1', 0), None)\n+        cls.settings = alter_django_settings(\n+            EMAIL_HOST=\"127.0.0.1\",\n+            EMAIL_PORT=cls.server.socket.getsockname()[1])\n+        cls.server.start()\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        cls.server.stop()\n+\n+    def setUp(self):\n+        super(SMTPBackendTests, self).setUp()\n+        self.server.flush_sink()\n+\n+    def tearDown(self):\n+        self.server.flush_sink()\n+        super(SMTPBackendTests, self).tearDown()\n+\n+    def flush_mailbox(self):\n+        self.server.flush_sink()\n+\n+    def get_mailbox_content(self):\n+        return self.server.get_sink()"
        }
    ],
    "stats": {
        "total": 722,
        "additions": 474,
        "deletions": 248
    }
}