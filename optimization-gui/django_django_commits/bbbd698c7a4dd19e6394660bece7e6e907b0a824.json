{
    "author": "unknown",
    "message": "Added a ManyToManyField(db_constraint=False) option, this allows not creating constraints on the intermediary models.",
    "sha": "bbbd698c7a4dd19e6394660bece7e6e907b0a824",
    "files": [
        {
            "sha": "399d16600ccee499cfacbc38989b544ea22006c5",
            "filename": "django/db/models/fields/related.py",
            "status": "modified",
            "additions": 11,
            "deletions": 6,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/bbbd698c7a4dd19e6394660bece7e6e907b0a824/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "raw_url": "https://github.com/django/django/raw/bbbd698c7a4dd19e6394660bece7e6e907b0a824/django%2Fdb%2Fmodels%2Ffields%2Frelated.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Ffields%2Frelated.py?ref=bbbd698c7a4dd19e6394660bece7e6e907b0a824",
            "patch": "@@ -955,7 +955,9 @@ def __init__(self, to, field_name, related_name=None, limit_choices_to=None,\n \n class ManyToManyRel(object):\n     def __init__(self, to, related_name=None, limit_choices_to=None,\n-            symmetrical=True, through=None):\n+            symmetrical=True, through=None, db_constraint=True):\n+        if through and not db_constraint:\n+            raise ValueError(\"Can't supply a through model and db_constraint=False\")\n         self.to = to\n         self.related_name = related_name\n         if limit_choices_to is None:\n@@ -964,6 +966,7 @@ def __init__(self, to, related_name=None, limit_choices_to=None,\n         self.symmetrical = symmetrical\n         self.multiple = True\n         self.through = through\n+        self.db_constraint = db_constraint\n \n     def is_hidden(self):\n         \"Should the related object be hidden?\"\n@@ -1196,15 +1199,15 @@ def set_managed(field, model, cls):\n     return type(name, (models.Model,), {\n         'Meta': meta,\n         '__module__': klass.__module__,\n-        from_: models.ForeignKey(klass, related_name='%s+' % name, db_tablespace=field.db_tablespace),\n-        to: models.ForeignKey(to_model, related_name='%s+' % name, db_tablespace=field.db_tablespace)\n+        from_: models.ForeignKey(klass, related_name='%s+' % name, db_tablespace=field.db_tablespace, db_constraint=field.rel.db_constraint),\n+        to: models.ForeignKey(to_model, related_name='%s+' % name, db_tablespace=field.db_tablespace, db_constraint=field.rel.db_constraint)\n     })\n \n \n class ManyToManyField(RelatedField, Field):\n     description = _(\"Many-to-many relationship\")\n \n-    def __init__(self, to, **kwargs):\n+    def __init__(self, to, db_constraint=True, **kwargs):\n         try:\n             assert not to._meta.abstract, \"%s cannot define a relation with abstract class %s\" % (self.__class__.__name__, to._meta.object_name)\n         except AttributeError:  # to._meta doesn't exist, so it must be RECURSIVE_RELATIONSHIP_CONSTANT\n@@ -1219,13 +1222,15 @@ def __init__(self, to, **kwargs):\n             related_name=kwargs.pop('related_name', None),\n             limit_choices_to=kwargs.pop('limit_choices_to', None),\n             symmetrical=kwargs.pop('symmetrical', to == RECURSIVE_RELATIONSHIP_CONSTANT),\n-            through=kwargs.pop('through', None))\n+            through=kwargs.pop('through', None),\n+            db_constraint=db_constraint,\n+        )\n \n         self.db_table = kwargs.pop('db_table', None)\n         if kwargs['rel'].through is not None:\n             assert self.db_table is None, \"Cannot specify a db_table if an intermediary model is used.\"\n \n-        Field.__init__(self, **kwargs)\n+        super(ManyToManyField, self).__init__(**kwargs)\n \n         msg = _('Hold down \"Control\", or \"Command\" on a Mac, to select more than one.')\n         self.help_text = string_concat(self.help_text, ' ', msg)"
        },
        {
            "sha": "1b801961832d8b7aeca467ae91eb971da702930a",
            "filename": "docs/ref/models/fields.txt",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/bbbd698c7a4dd19e6394660bece7e6e907b0a824/docs%2Fref%2Fmodels%2Ffields.txt",
            "raw_url": "https://github.com/django/django/raw/bbbd698c7a4dd19e6394660bece7e6e907b0a824/docs%2Fref%2Fmodels%2Ffields.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Ffields.txt?ref=bbbd698c7a4dd19e6394660bece7e6e907b0a824",
            "patch": "@@ -1227,6 +1227,20 @@ that control how the relationship functions.\n     the table for the model defining the relationship and the name of the field\n     itself.\n \n+.. attribute:: ManyToManyField.db_constraint\n+\n+    Controls whether or not constraints should be created in the database for\n+    the foreign keys in the intermediary table. The default is ``True``, and\n+    that's almost certainly what you want; setting this to ``False`` can be\n+    very bad for data integrity. That said, here are some scenarios where you\n+    might want to do this:\n+\n+    * You have legacy data that is not valid.\n+    * You're sharding your database.\n+\n+    It is an error to pass both ``db_constraint`` and ``through``.\n+\n+\n .. _ref-onetoone:\n \n ``OneToOneField``"
        },
        {
            "sha": "81b1e48d258215b2b012661f2f06c63382509863",
            "filename": "docs/releases/1.6.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/bbbd698c7a4dd19e6394660bece7e6e907b0a824/docs%2Freleases%2F1.6.txt",
            "raw_url": "https://github.com/django/django/raw/bbbd698c7a4dd19e6394660bece7e6e907b0a824/docs%2Freleases%2F1.6.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.6.txt?ref=bbbd698c7a4dd19e6394660bece7e6e907b0a824",
            "patch": "@@ -113,8 +113,8 @@ Minor features\n * The ``MemcachedCache`` cache backend now uses the latest :mod:`pickle`\n   protocol available.\n \n-* Added the :attr:`django.db.models.ForeignKey.db_constraint`\n-  option.\n+* Added the :attr:`django.db.models.ForeignKey.db_constraint` and\n+  :attr:`django.db.models.ManyToManyField.db_constraint` options.\n \n * The jQuery library embedded in the admin has been upgraded to version 1.9.1.\n "
        },
        {
            "sha": "94be36cfaf0376b98cea0677ae53aa2be3da4188",
            "filename": "tests/backends/models.py",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/bbbd698c7a4dd19e6394660bece7e6e907b0a824/tests%2Fbackends%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/bbbd698c7a4dd19e6394660bece7e6e907b0a824/tests%2Fbackends%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fbackends%2Fmodels.py?ref=bbbd698c7a4dd19e6394660bece7e6e907b0a824",
            "patch": "@@ -90,7 +90,10 @@ def __str__(self):\n \n @python_2_unicode_compatible\n class Object(models.Model):\n-    pass\n+    related_objects = models.ManyToManyField(\"self\", db_constraint=False, symmetrical=False)\n+\n+    def __str__(self):\n+        return str(self.id)\n \n \n @python_2_unicode_compatible"
        },
        {
            "sha": "103a44684e3d9bbbfa14371a0f1377e5d9897637",
            "filename": "tests/backends/tests.py",
            "status": "modified",
            "additions": 34,
            "deletions": 13,
            "changes": 47,
            "blob_url": "https://github.com/django/django/blob/bbbd698c7a4dd19e6394660bece7e6e907b0a824/tests%2Fbackends%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/bbbd698c7a4dd19e6394660bece7e6e907b0a824/tests%2Fbackends%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fbackends%2Ftests.py?ref=bbbd698c7a4dd19e6394660bece7e6e907b0a824",
            "patch": "@@ -12,13 +12,12 @@\n from django.db.backends.signals import connection_created\n from django.db.backends.postgresql_psycopg2 import version as pg_version\n from django.db.models import Sum, Avg, Variance, StdDev\n-from django.db.utils import ConnectionHandler, DatabaseError\n+from django.db.utils import ConnectionHandler\n from django.test import (TestCase, skipUnlessDBFeature, skipIfDBFeature,\n     TransactionTestCase)\n from django.test.utils import override_settings, str_prefix\n-from django.utils import six\n+from django.utils import six, unittest\n from django.utils.six.moves import xrange\n-from django.utils import unittest\n \n from . import models\n \n@@ -52,7 +51,7 @@ def test_dbms_session(self):\n         convert_unicode = backend.convert_unicode\n         cursor = connection.cursor()\n         cursor.callproc(convert_unicode('DBMS_SESSION.SET_IDENTIFIER'),\n-                        [convert_unicode('_django_testing!'),])\n+                        [convert_unicode('_django_testing!')])\n \n     @unittest.skipUnless(connection.vendor == 'oracle',\n                          \"No need to check Oracle cursor semantics\")\n@@ -72,7 +71,7 @@ def test_long_string(self):\n         c = connection.cursor()\n         c.execute('CREATE TABLE ltext (\"TEXT\" NCLOB)')\n         long_str = ''.join([six.text_type(x) for x in xrange(4000)])\n-        c.execute('INSERT INTO ltext VALUES (%s)',[long_str])\n+        c.execute('INSERT INTO ltext VALUES (%s)', [long_str])\n         c.execute('SELECT text FROM ltext')\n         row = c.fetchone()\n         self.assertEqual(long_str, row[0].read())\n@@ -99,6 +98,7 @@ def test_order_of_nls_parameters(self):\n         c.execute(query)\n         self.assertEqual(c.fetchone()[0], 1)\n \n+\n class MySQLTests(TestCase):\n     @unittest.skipUnless(connection.vendor == 'mysql',\n                         \"Test valid only for MySQL\")\n@@ -117,7 +117,7 @@ def test_autoincrement(self):\n         found_reset = False\n         for sql in statements:\n             found_reset = found_reset or 'ALTER TABLE' in sql\n-        if connection.mysql_version < (5,0,13):\n+        if connection.mysql_version < (5, 0, 13):\n             self.assertTrue(found_reset)\n         else:\n             self.assertFalse(found_reset)\n@@ -182,6 +182,7 @@ def test_no_interpolation_on_sqlite(self):\n         self.assertEqual(connection.queries[-1]['sql'],\n             str_prefix(\"QUERY = %(_)s\\\"SELECT strftime('%%Y', 'now');\\\" - PARAMS = ()\"))\n \n+\n class ParameterHandlingTest(TestCase):\n     def test_bad_parameter_count(self):\n         \"An executemany call with too many/not enough parameters will raise an exception (Refs #12612)\"\n@@ -191,8 +192,9 @@ def test_bad_parameter_count(self):\n             connection.ops.quote_name('root'),\n             connection.ops.quote_name('square')\n         ))\n-        self.assertRaises(Exception, cursor.executemany, query, [(1,2,3),])\n-        self.assertRaises(Exception, cursor.executemany, query, [(1,),])\n+        self.assertRaises(Exception, cursor.executemany, query, [(1, 2, 3)])\n+        self.assertRaises(Exception, cursor.executemany, query, [(1,)])\n+\n \n # Unfortunately, the following tests would be a good test to run on all\n # backends, but it breaks MySQL hard. Until #13711 is fixed, it can't be run\n@@ -240,6 +242,7 @@ def test_sequence_name_length_limits_flush(self):\n         for statement in connection.ops.sql_flush(no_style(), tables, sequences):\n             cursor.execute(statement)\n \n+\n class SequenceResetTest(TestCase):\n     def test_generic_relation(self):\n         \"Sequence names are correct when resetting generic relations (Ref #13941)\"\n@@ -257,6 +260,7 @@ def test_generic_relation(self):\n         obj = models.Post.objects.create(name='New post', text='goodbye world')\n         self.assertTrue(obj.pk > 10)\n \n+\n class PostgresVersionTest(TestCase):\n     def assert_parses(self, version_string, version):\n         self.assertEqual(pg_version._parse_version(version_string), version)\n@@ -291,6 +295,7 @@ def cursor(self):\n         conn = OlderConnectionMock()\n         self.assertEqual(pg_version.get_version(conn), 80300)\n \n+\n class PostgresNewConnectionTest(TestCase):\n     \"\"\"\n     #17062: PostgreSQL shouldn't roll back SET TIME ZONE, even if the first\n@@ -338,17 +343,18 @@ class ConnectionCreatedSignalTest(TestCase):\n     @skipUnlessDBFeature('test_db_allows_multiple_connections')\n     def test_signal(self):\n         data = {}\n+\n         def receiver(sender, connection, **kwargs):\n             data[\"connection\"] = connection\n \n         connection_created.connect(receiver)\n         connection.close()\n-        cursor = connection.cursor()\n+        connection.cursor()\n         self.assertTrue(data[\"connection\"].connection is connection.connection)\n \n         connection_created.disconnect(receiver)\n         data.clear()\n-        cursor = connection.cursor()\n+        connection.cursor()\n         self.assertTrue(data == {})\n \n \n@@ -443,7 +449,7 @@ def test_unicode_password(self):\n         old_password = connection.settings_dict['PASSWORD']\n         connection.settings_dict['PASSWORD'] = \"fran√ßois\"\n         try:\n-            cursor = connection.cursor()\n+            connection.cursor()\n         except DatabaseError:\n             # As password is probably wrong, a database exception is expected\n             pass\n@@ -470,14 +476,14 @@ def test_duplicate_table_error(self):\n         with self.assertRaises(DatabaseError):\n             cursor.execute(query)\n \n+\n # We don't make these tests conditional because that means we would need to\n # check and differentiate between:\n # * MySQL+InnoDB, MySQL+MYISAM (something we currently can't do).\n # * if sqlite3 (if/once we get #14204 fixed) has referential integrity turned\n #   on or not, something that would be controlled by runtime support and user\n #   preference.\n # verify if its type is django.database.db.IntegrityError.\n-\n class FkConstraintsTests(TransactionTestCase):\n \n     def setUp(self):\n@@ -581,6 +587,7 @@ def test_default_connection_thread_local(self):\n         connections_dict = {}\n         connection.cursor()\n         connections_dict[id(connection)] = connection\n+\n         def runner():\n             # Passing django.db.connection between threads doesn't work while\n             # connections[DEFAULT_DB_ALIAS] does.\n@@ -602,7 +609,7 @@ def runner():\n         # Finish by closing the connections opened by the other threads (the\n         # connection opened in the main thread will automatically be closed on\n         # teardown).\n-        for conn in connections_dict.values() :\n+        for conn in connections_dict.values():\n             if conn is not connection:\n                 conn.close()\n \n@@ -616,6 +623,7 @@ def test_connections_thread_local(self):\n         connections_dict = {}\n         for conn in connections.all():\n             connections_dict[id(conn)] = conn\n+\n         def runner():\n             from django.db import connections\n             for conn in connections.all():\n@@ -682,6 +690,7 @@ def test_closing_non_shared_connections(self):\n         \"\"\"\n         # First, without explicitly enabling the connection for sharing.\n         exceptions = set()\n+\n         def runner1():\n             def runner2(other_thread_connection):\n                 try:\n@@ -699,6 +708,7 @@ def runner2(other_thread_connection):\n \n         # Then, with explicitly enabling the connection for sharing.\n         exceptions = set()\n+\n         def runner1():\n             def runner2(other_thread_connection):\n                 try:\n@@ -746,3 +756,14 @@ def test_can_reference_non_existant(self):\n \n         with self.assertRaises(models.Object.DoesNotExist):\n             ref.obj\n+\n+    def test_many_to_many(self):\n+        obj = models.Object.objects.create()\n+        obj.related_objects.create()\n+        self.assertEqual(models.Object.objects.count(), 2)\n+        self.assertEqual(obj.related_objects.count(), 1)\n+\n+        intermediary_model = models.Object._meta.get_field_by_name(\"related_objects\")[0].rel.through\n+        intermediary_model.objects.create(from_object_id=obj.id, to_object_id=12345)\n+        self.assertEqual(obj.related_objects.count(), 1)\n+        self.assertEqual(intermediary_model.objects.count(), 2)"
        }
    ],
    "stats": {
        "total": 87,
        "additions": 65,
        "deletions": 22
    }
}