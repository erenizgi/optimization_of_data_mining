{
    "author": "shepdl",
    "message": "Fixed #19243 - Edited GeoDjango Tutorial for consistency and style.",
    "sha": "8e5573e99abd5351dfbd6de1214662ecf7f6c9ba",
    "files": [
        {
            "sha": "5000622ad477f7c35242e0c1ba21276e2bbabd80",
            "filename": "docs/ref/contrib/gis/tutorial.txt",
            "status": "modified",
            "additions": 136,
            "deletions": 145,
            "changes": 281,
            "blob_url": "https://github.com/django/django/blob/8e5573e99abd5351dfbd6de1214662ecf7f6c9ba/docs%2Fref%2Fcontrib%2Fgis%2Ftutorial.txt",
            "raw_url": "https://github.com/django/django/raw/8e5573e99abd5351dfbd6de1214662ecf7f6c9ba/docs%2Fref%2Fcontrib%2Fgis%2Ftutorial.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fcontrib%2Fgis%2Ftutorial.txt?ref=8e5573e99abd5351dfbd6de1214662ecf7f6c9ba",
            "patch": "@@ -5,28 +5,28 @@ GeoDjango Tutorial\n Introduction\n ============\n \n-GeoDjango is an add-on for Django that turns it into a world-class geographic\n-Web framework.  GeoDjango strives to make it as simple as possible to create\n-geographic Web applications, like location-based services.  Some features\n-include:\n+GeoDjango is an included contrib module for Django that turns it into a\n+world-class geographic Web framework.  GeoDjango strives to make it as simple\n+as possible to create geographic Web applications, like location-based services.\n+Its features include:\n \n * Django model fields for `OGC`_ geometries.\n-* Extensions to Django's ORM for the querying and manipulation of spatial data.\n+* Extensions to Django's ORM for querying and manipulating spatial data.\n * Loosely-coupled, high-level Python interfaces for GIS geometry operations and\n   data formats.\n-* Editing of geometry fields inside the admin.\n+* Editing geometry fields from the admin.\n \n-This tutorial assumes a familiarity with Django; thus, if you're brand new to\n-Django please read through the :doc:`regular tutorial </intro/tutorial01>` to\n-introduce yourself with basic Django concepts.\n+This tutorial assumes familiarity with Django; thus, if you're brand new to\n+Django, please read through the :doc:`regular tutorial </intro/tutorial01>` to\n+familiarize yourself with Django first.\n \n .. note::\n \n-    GeoDjango has special prerequisites overwhat is required by Django --\n+    GeoDjango has additional requirements beyond what Django requires --\n     please consult the :ref:`installation documentation <ref-gis-install>`\n     for more details.\n \n-This tutorial will guide you through the creation of a geographic Web\n+This tutorial will guide you through the creation of a geographic web\n application for viewing the `world borders`_. [#]_ Some of the code\n used in this tutorial is taken from and/or inspired by the `GeoDjango\n basic apps`_ project. [#]_\n@@ -51,46 +51,45 @@ Create a Spatial Database\n     MySQL and Oracle users can skip this section because spatial types\n     are already built into the database.\n \n-First, a spatial database needs to be created for our project.  If using\n-PostgreSQL and PostGIS, then the following commands will\n-create the database from a :ref:`spatial database template\n-<spatialdb_template>`:\n+First, create a spatial database for your project.\n+\n+If you are using PostGIS, create the database from the :ref:`spatial database\n+template <spatialdb_template>`:\n \n .. code-block:: bash\n \n     $ createdb -T template_postgis geodjango\n \n .. note::\n \n-    This command must be issued by a database user that has permissions to\n-    create a database.  Here is an example set of commands to create such\n-    a user:\n+    This command must be issued by a database user with enough privileges to\n+    create a database.  To create a user with ``CREATE DATABASE`` privileges in\n+    PostgreSQL, use the following commands:\n \n     .. code-block:: bash\n \n         $ sudo su - postgres\n         $ createuser --createdb geo\n         $ exit\n \n-    Replace ``geo`` with the system login user name that will be\n-    connecting to the database.  For example, ``johndoe`` if that is the\n-    system user that will be running GeoDjango.\n+    Replace ``geo`` with your Postgres database user's username.\n+    (In PostgreSQL, this user will also be an OS-level user.)\n \n-Users of SQLite and SpatiaLite should consult the instructions on how\n+If you are using SQLite and SpatiaLite, consult the instructions on how\n to create a :ref:`SpatiaLite database <create_spatialite_db>`.\n \n-Create GeoDjango Project\n+Create a New Project\n ------------------------\n \n-Use the ``django-admin.py`` script like normal to create a ``geodjango``\n-project:\n+Use the standard ``django-admin.py`` script to create a project called\n+``geodjango``:\n \n .. code-block:: bash\n \n     $ django-admin.py startproject geodjango\n \n-With the project initialized, now create a ``world`` Django application within\n-the ``geodjango`` project:\n+This will initialize a new project. Now, create a ``world`` Django application\n+within the ``geodjango`` project:\n \n .. code-block:: bash\n \n@@ -101,7 +100,7 @@ Configure ``settings.py``\n -------------------------\n \n The ``geodjango`` project settings are stored in the ``geodjango/settings.py``\n-file. Edit the database connection settings appropriately::\n+file. Edit the database connection settings to match your setup::\n \n     DATABASES = {\n         'default': {\n@@ -113,7 +112,7 @@ file. Edit the database connection settings appropriately::\n \n In addition, modify the :setting:`INSTALLED_APPS` setting to include\n :mod:`django.contrib.admin`, :mod:`django.contrib.gis`,\n-and ``world`` (our newly created application)::\n+and ``world`` (your newly created application)::\n \n     INSTALLED_APPS = (\n         'django.contrib.auth',\n@@ -135,9 +134,9 @@ Geographic Data\n World Borders\n -------------\n \n-The world borders data is available in this `zip file`__.  Create a data\n+The world borders data is available in this `zip file`__.  Create a ``data``\n directory in the ``world`` application, download the world borders data, and\n-unzip. On GNU/Linux platforms the following commands should do it:\n+unzip. On GNU/Linux platforms, use the following commands:\n \n .. code-block:: bash\n \n@@ -149,7 +148,7 @@ unzip. On GNU/Linux platforms the following commands should do it:\n \n The world borders ZIP file contains a set of data files collectively known as\n an `ESRI Shapefile`__, one of the most popular geospatial data formats.  When\n-unzipped the world borders data set includes files with the following\n+unzipped, the world borders dataset includes files with the following\n extensions:\n \n * ``.shp``: Holds the vector data for the world borders geometries.\n@@ -165,8 +164,8 @@ __ http://en.wikipedia.org/wiki/Shapefile\n Use ``ogrinfo`` to examine spatial data\n ---------------------------------------\n \n-The GDAL ``ogrinfo`` utility is excellent for examining metadata about\n-shapefiles (or other vector data sources):\n+The GDAL ``ogrinfo`` utility allows examining the metadata of shapefiles or\n+other vector data sources:\n \n .. code-block:: bash\n \n@@ -175,9 +174,9 @@ shapefiles (or other vector data sources):\n           using driver `ESRI Shapefile' successful.\n     1: TM_WORLD_BORDERS-0.3 (Polygon)\n \n-Here ``ogrinfo`` is telling us that the shapefile has one layer, and that such\n-layer contains polygon data.  To find out more we'll specify the layer name\n-and use the ``-so`` option to get only important summary information:\n+``ogrinfo`` tells us that the shapefile has one layer, and that this\n+layer contains polygon data.  To find out more, we'll specify the layer name\n+and use the ``-so`` option to get only the important summary information:\n \n .. code-block:: bash\n \n@@ -208,23 +207,20 @@ and use the ``-so`` option to get only important summary information:\n     LAT: Real (7.3)\n \n This detailed summary information tells us the number of features in the layer\n-(246), the geographical extent, the spatial reference system (\"SRS WKT\"),\n-as well as detailed information for each attribute field.  For example,\n-``FIPS: String (2.0)`` indicates that there's a ``FIPS`` character field\n-with a maximum length of 2; similarly, ``LON: Real (8.3)`` is a floating-point\n-field that holds a maximum of 8 digits up to three decimal places.  Although\n-this information may be found right on the `world borders`_ Web site, this\n-shows you how to determine this information yourself when such metadata is not\n-provided.\n+(246), the geographic bounds of the data, the spatial reference system\n+(\"SRS WKT\"), as well as type information for each attribute field. For example,\n+``FIPS: String (2.0)`` indicates that the ``FIPS`` character field has\n+a maximum length of 2.  Similarly, ``LON: Real (8.3)`` is a floating-point\n+field that holds a maximum of 8 digits up to three decimal places.\n \n Geographic Models\n =================\n \n Defining a Geographic Model\n ---------------------------\n \n-Now that we've examined our world borders data set using ``ogrinfo``, we can\n-create a GeoDjango model to represent this data::\n+Now that you've examined your dataset using ``ogrinfo``, create a GeoDjango\n+model to represent this data::\n \n     from django.contrib.gis.db import models\n \n@@ -252,32 +248,30 @@ create a GeoDjango model to represent this data::\n         def __unicode__(self):\n             return self.name\n \n-Two important things to note:\n+Please note two important things:\n \n 1. The ``models`` module is imported from :mod:`django.contrib.gis.db`.\n-2. The model overrides its default manager with\n-   :class:`~django.contrib.gis.db.models.GeoManager`; this is *required*\n-   to perform spatial queries.\n+2. You must override the model's default manager with\n+   :class:`~django.contrib.gis.db.models.GeoManager` to perform spatial queries.\n \n-When declaring a geometry field on your model the default spatial reference\n-system is WGS84 (meaning the `SRID`__ is 4326) -- in other words, the field\n-coordinates are in longitude/latitude pairs in units of degrees.  If you want\n-the coordinate system to be different, then SRID of the geometry field may be\n-customized by setting the ``srid`` with an integer corresponding to the\n-coordinate system of your choice.\n+The default spatial reference system for geometry fields is WGS84 (meaning\n+the `SRID`__ is 4326) -- in other words, the field coordinates are in\n+longitude, latitude pairs in units of degrees.  To use a different\n+coordinate system, set the SRID of the geometry field with the ``srid``\n+argument. Use an integer representing the coordinate system's EPSG code.\n \n __ http://en.wikipedia.org/wiki/SRID\n \n Run ``syncdb``\n --------------\n \n-After you've defined your model, it needs to be synced with the spatial\n-database. First, let's look at the SQL that will generate the table for the\n+After defining your model, you need to sync it with the database. First,\n+let's look at the SQL that will generate the table for the\n ``WorldBorder`` model::\n \n     $ python manage.py sqlall world\n \n-This management command should produce the following output:\n+This command should produce the following output:\n \n .. code-block:: sql\n \n@@ -302,32 +296,28 @@ This management command should produce the following output:\n     CREATE INDEX \"world_worldborder_mpoly_id\" ON \"world_worldborder\" USING GIST ( \"mpoly\" GIST_GEOMETRY_OPS );\n     COMMIT;\n \n-If satisfied, you may then create this table in the database by running the\n-``syncdb`` management command::\n+If this looks correct, run ``syncdb`` to create this table in the database::\n \n     $ python manage.py syncdb\n     Creating table world_worldborder\n     Installing custom SQL for world.WorldBorder model\n \n-The ``syncdb`` command may also prompt you to create an admin user; go ahead\n-and do so (not required now, may be done at any point in the future using the\n-``createsuperuser`` management command).\n+The ``syncdb`` command may also prompt you to create an admin user. Either\n+do so now, or later by running ``django-admin.py createsuperuser``.\n \n Importing Spatial Data\n ======================\n \n-This section will show you how to take the data from the world borders\n-shapefile and import it into GeoDjango models using the\n+This section will show you how to import the world borders\n+shapefile into the database via GeoDjango models using the\n :ref:`ref-layermapping`.\n-There are many different ways to import data in to a spatial database --\n-besides the tools included within GeoDjango, you may also use the following to\n-populate your spatial database:\n+There are many different ways to import data into a spatial database --\n+besides the tools included within GeoDjango, you may also use the following:\n \n-* `ogr2ogr`_: Command-line utility, included with GDAL, that\n-  supports loading a multitude of vector data formats into\n-  the PostGIS, MySQL, and Oracle spatial databases.\n-* `shp2pgsql`_: This utility is included with PostGIS and only supports\n-  ESRI shapefiles.\n+* `ogr2ogr`_: A command-line utility included with GDAL that\n+  can import many vector data formats into PostGIS, MySQL, and Oracle databases.\n+* `shp2pgsql`_: This utility included with PostGIS imports ESRI shapefiles into\n+  PostGIS.\n \n .. _ogr2ogr: http://www.gdal.org/ogr2ogr.html\n .. _shp2pgsql: http://postgis.refractions.net/documentation/manual-1.5/ch04.html#shp2pgsql_usage\n@@ -337,27 +327,26 @@ populate your spatial database:\n GDAL Interface\n --------------\n \n-Earlier we used the ``ogrinfo`` to explore the contents of the world borders\n-shapefile.  Included within GeoDjango is an interface to GDAL's powerful OGR\n-library -- in other words, you'll be able explore all the vector data sources\n-that OGR supports via a Pythonic API.\n+Earlier, you used ``ogrinfo`` to examine the contents of the world borders\n+shapefile.  GeoDjango also includes a Pythonic interface to GDAL's powerful OGR\n+library that can work with all the vector data sources that OGR supports.\n \n First, invoke the Django shell:\n \n .. code-block:: bash\n \n     $ python manage.py shell\n \n-If the :ref:`worldborders` data was downloaded like earlier in the\n-tutorial, then we can determine the path using Python's built-in\n+If you downloaded the :ref:`worldborders` data earlier in the\n+tutorial, then you can determine its path using Python's built-in\n ``os`` module::\n \n     >>> import os\n     >>> import world\n     >>> world_shp = os.path.abspath(os.path.join(os.path.dirname(world.__file__),\n     ...                             'data/TM_WORLD_BORDERS-0.3.shp'))\n \n-Now, the world borders shapefile may be opened using GeoDjango's\n+Now, open the world borders shapefile using GeoDjango's\n :class:`~django.contrib.gis.gdal.DataSource` interface::\n \n     >>> from django.contrib.gis.gdal import DataSource\n@@ -374,8 +363,7 @@ shapefiles are only allowed to have one layer::\n     >>> print(lyr)\n     TM_WORLD_BORDERS-0.3\n \n-You can see what the geometry type of the layer is and how many features it\n-contains::\n+You can see the layer's geometry type and how many features it contains::\n \n     >>> print(lyr.geom_type)\n     Polygon\n@@ -384,16 +372,16 @@ contains::\n \n .. note::\n \n-    Unfortunately the shapefile data format does not allow for greater\n+    Unfortunately, the shapefile data format does not allow for greater\n     specificity with regards to geometry types.  This shapefile, like\n-    many others, actually includes ``MultiPolygon`` geometries in its\n-    features.  You need to watch out for this when creating your models\n-    as a GeoDjango ``PolygonField`` will not accept a ``MultiPolygon``\n-    type geometry -- thus a ``MultiPolygonField`` is used in our model's\n-    definition instead.\n+    many others, actually includes ``MultiPolygon`` geometries, not Polygons.\n+    It's important to use a more general field type in models: a\n+    GeoDjango ``MultiPolygonField`` will accept a ``Polygon`` geometry, but a\n+    ``PolygonField`` will not accept a ``MultiPolygon`` type geometry.  This\n+    is why the ``WorldBorder`` model defined above uses a ``MultiPolygonField``.\n \n The :class:`~django.contrib.gis.gdal.Layer` may also have a spatial reference\n-system associated with it -- if it does, the ``srs`` attribute will return a\n+system associated with it.  If it does, the ``srs`` attribute will return a\n :class:`~django.contrib.gis.gdal.SpatialReference` object::\n \n     >>> srs = lyr.srs\n@@ -406,18 +394,18 @@ system associated with it -- if it does, the ``srs`` attribute will return a\n     >>> srs.proj4 # PROJ.4 representation\n     '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs '\n \n-Here we've noticed that the shapefile is in the popular WGS84 spatial reference\n-system -- in other words, the data uses units of degrees longitude and\n-latitude.\n+This shapefile is in the popular WGS84 spatial reference\n+system -- in other words, the data uses longitude, latitude pairs in\n+units of degrees.\n \n In addition, shapefiles also support attribute fields that may contain\n additional data.  Here are the fields on the World Borders layer:\n \n     >>> print(lyr.fields)\n     ['FIPS', 'ISO2', 'ISO3', 'UN', 'NAME', 'AREA', 'POP2005', 'REGION', 'SUBREGION', 'LON', 'LAT']\n \n-Here we are examining the OGR types (e.g., whether a field is an integer or\n-a string) associated with each of the fields:\n+The following code will let you examine the OGR types (e.g. integer or\n+string) associated with each of the fields:\n \n     >>> [fld.__name__ for fld in lyr.field_types]\n     ['OFTString', 'OFTString', 'OFTString', 'OFTInteger', 'OFTString', 'OFTInteger', 'OFTInteger', 'OFTInteger', 'OFTInteger', 'OFTReal', 'OFTReal']\n@@ -446,8 +434,7 @@ And individual features may be retrieved by their feature ID::\n     >>> print(feat.get('NAME'))\n     San Marino\n \n-Here the boundary geometry for San Marino is extracted and looking\n-exported to WKT and GeoJSON::\n+Boundary geometries may be exported as WKT and GeoJSON::\n \n     >>> geom = feat.geom\n     >>> print(geom.wkt)\n@@ -459,8 +446,9 @@ exported to WKT and GeoJSON::\n ``LayerMapping``\n ----------------\n \n-We're going to dive right in -- create a file called ``load.py`` inside the\n-``world`` application, and insert the following::\n+To import the data, use a LayerMapping in a Python script.\n+Create a file called ``load.py`` inside the ``world`` application,\n+with the following code::\n \n     import os\n     from django.contrib.gis.utils import LayerMapping\n@@ -492,29 +480,29 @@ We're going to dive right in -- create a file called ``load.py`` inside the\n A few notes about what's going on:\n \n * Each key in the ``world_mapping`` dictionary corresponds to a field in the\n-  ``WorldBorder`` model, and the value is the name of the shapefile field\n+  ``WorldBorder`` model.  The value is the name of the shapefile field\n   that data will be loaded from.\n * The key ``mpoly`` for the geometry field is ``MULTIPOLYGON``, the\n-  geometry type we wish to import as.  Even if simple polygons are encountered\n-  in the shapefile they will automatically be converted into collections prior\n-  to insertion into the database.\n+  geometry type GeoDjango will import the field as.  Even simple polygons in\n+  the shapefile will automatically be converted into collections prior to\n+  insertion into the database.\n * The path to the shapefile is not absolute -- in other words, if you move the\n   ``world`` application (with ``data`` subdirectory) to a different location,\n-  then the script will still work.\n+  the script will still work.\n * The ``transform`` keyword is set to ``False`` because the data in the\n   shapefile does not need to be converted -- it's already in WGS84 (SRID=4326).\n-* The ``encoding`` keyword is set to the character encoding of string values in\n-  the shapefile. This ensures that string values are read and saved correctly\n-  from their original encoding system.\n+* The ``encoding`` keyword is set to the character encoding of the string\n+  values in the shapefile. This ensures that string values are read and saved\n+  correctly from their original encoding system.\n \n Afterwards, invoke the Django shell from the ``geodjango`` project directory:\n \n .. code-block:: bash\n \n    $ python manage.py shell\n \n-Next, import the ``load`` module, call the ``run`` routine, and watch ``LayerMapping``\n-do the work::\n+Next, import the ``load`` module, call the ``run`` routine, and watch\n+``LayerMapping`` do the work::\n \n    >>> from world import load\n    >>> load.run()\n@@ -536,7 +524,7 @@ The general usage of the command goes as follows:\n \n     $ python manage.py ogrinspect [options] <data_source> <model_name> [options]\n \n-Where ``data_source`` is the path to the GDAL-supported data source and\n+``data_source`` is the path to the GDAL-supported data source and\n ``model_name`` is the name to use for the model.  Command-line options may\n be used to further define how the model is generated.\n \n@@ -600,9 +588,9 @@ Spatial Queries\n \n Spatial Lookups\n ---------------\n-GeoDjango extends the Django ORM and allows the use of spatial lookups.\n-Let's do an example where we find the ``WorldBorder`` model that contains\n-a point.  First, fire up the management shell:\n+GeoDjango adds spatial lookups to the Django ORM.  For example, you\n+can find the country in the ``WorldBorder`` table that contains\n+a particular point.  First, fire up the management shell:\n \n .. code-block:: bash\n \n@@ -613,8 +601,8 @@ Now, define a point of interest [#]_::\n     >>> pnt_wkt = 'POINT(-95.3385 29.7245)'\n \n The ``pnt_wkt`` string represents the point at -95.3385 degrees longitude,\n-and 29.7245 degrees latitude.  The geometry is in a format known as\n-Well Known Text (WKT), an open standard issued by the Open Geospatial\n+29.7245 degrees latitude.  The geometry is in a format known as\n+Well Known Text (WKT), a standard issued by the Open Geospatial\n Consortium (OGC). [#]_  Import the ``WorldBorder`` model, and perform\n a ``contains`` lookup using the ``pnt_wkt`` as the parameter::\n \n@@ -623,28 +611,30 @@ a ``contains`` lookup using the ``pnt_wkt`` as the parameter::\n     >>> qs\n     [<WorldBorder: United States>]\n \n-Here we retrieved a ``GeoQuerySet`` that has only one model: the one\n-for the United States (which is what we would expect).  Similarly,\n-a :ref:`GEOS geometry object <ref-geos>` may also be used -- here the\n-``intersects`` spatial lookup is combined with the ``get`` method to retrieve\n-only the ``WorldBorder`` instance for San Marino instead of a queryset::\n+Here, you retrieved a ``GeoQuerySet`` with only one model: the border of\n+the United States (exactly what you would expect).\n+\n+Similarly, you may also use a :ref:`GEOS geometry object <ref-geos>`.\n+Here, you can combine the ``intersects`` spatial lookup with the ``get``\n+method to retrieve only the ``WorldBorder`` instance for San Marino instead\n+of a queryset::\n \n     >>> from django.contrib.gis.geos import Point\n     >>> pnt = Point(12.4604, 43.9420)\n     >>> sm = WorldBorder.objects.get(mpoly__intersects=pnt)\n     >>> sm\n     <WorldBorder: San Marino>\n \n-The ``contains`` and ``intersects`` lookups are just a subset of what's\n-available -- the :ref:`ref-gis-db-api` documentation has more.\n+The ``contains`` and ``intersects`` lookups are just a subset of the\n+available queries -- the :ref:`ref-gis-db-api` documentation has more.\n \n Automatic Spatial Transformations\n ---------------------------------\n-When querying the spatial database GeoDjango automatically transforms\n+When doing spatial queries, GeoDjango automatically transforms\n geometries if they're in a different coordinate system.  In the following\n-example, the coordinate will be expressed in terms of `EPSG SRID 32140`__,\n+example, coordinates will be expressed in `EPSG SRID 32140`__,\n a coordinate system specific to south Texas **only** and in units of\n-**meters** and not degrees::\n+**meters**, not degrees::\n \n     >>> from django.contrib.gis.geos import Point, GEOSGeometry\n     >>> pnt = Point(954158.1, 4215137.1, srid=32140)\n@@ -654,7 +644,7 @@ WKT that includes the SRID::\n \n     >>> pnt = GEOSGeometry('SRID=32140;POINT(954158.1 4215137.1)')\n \n-When using GeoDjango's ORM, it will automatically wrap geometry values\n+GeoDjango's ORM will automatically wrap geometry values\n in transformation SQL, allowing the developer to work at a higher level\n of abstraction::\n \n@@ -675,7 +665,7 @@ __ http://spatialreference.org/ref/epsg/32140/\n \n     When using :doc:`raw queries </topics/db/sql>`, you should generally wrap\n     your geometry fields with the ``asText()`` SQL function (or ``ST_AsText``\n-    for PostGIS) so as the field value will be recognized by GEOS::\n+    for PostGIS) so that the field value will be recognized by GEOS::\n \n         City.objects.raw('SELECT id, name, asText(point) from myapp_city')\n \n@@ -684,8 +674,8 @@ __ http://spatialreference.org/ref/epsg/32140/\n \n Lazy Geometries\n ---------------\n-Geometries come to GeoDjango in a standardized textual representation.  Upon\n-access of the geometry field, GeoDjango creates a `GEOS geometry object\n+GeoDjango loads geometries in a standardized textual representation.  When the\n+geometry field is first accessed, GeoDjango creates a `GEOS geometry object\n <ref-geos>`, exposing powerful functionality, such as serialization properties\n for popular geospatial formats::\n \n@@ -715,31 +705,27 @@ the GEOS library::\n Putting your data on the map\n ============================\n \n-Google\n-------\n-\n Geographic Admin\n ----------------\n \n GeoDjango extends :doc:`Django's admin application </ref/contrib/admin/index>`\n-to enable support for editing geometry fields.\n+with support for editing geometry fields.\n \n Basics\n ^^^^^^\n \n GeoDjango also supplements the Django admin by allowing users to create\n and modify geometries on a JavaScript slippy map (powered by `OpenLayers`_).\n \n-Let's dive in again -- create a file called ``admin.py`` inside the\n-``world`` application, and insert the following::\n+Let's dive right in.  Create a file called ``admin.py`` inside the\n+``world`` application with the following code::\n \n     from django.contrib.gis import admin\n     from models import WorldBorder\n \n     admin.site.register(WorldBorder, admin.GeoModelAdmin)\n \n-Next, edit your ``urls.py`` in the ``geodjango`` application folder to look\n-as follows::\n+Next, edit your ``urls.py`` in the ``geodjango`` application folder as follows::\n \n     from django.conf.urls import patterns, url, include\n     from django.contrib.gis import admin\n@@ -775,24 +761,29 @@ With the :class:`~django.contrib.gis.admin.OSMGeoAdmin`, GeoDjango uses\n a `Open Street Map`_ layer in the admin.\n This provides more context (including street and thoroughfare details) than\n available with the :class:`~django.contrib.gis.admin.GeoModelAdmin`\n-(which uses the `Vector Map Level 0`_ WMS data set hosted at `OSGeo`_).\n+(which uses the `Vector Map Level 0`_ WMS dataset hosted at `OSGeo`_).\n \n-First, there are some important requirements and limitations:\n+First, there are some important requirements:\n \n * :class:`~django.contrib.gis.admin.OSMGeoAdmin` requires that the\n   :ref:`spherical mercator projection be added <addgoogleprojection>`\n   to the ``spatial_ref_sys`` table (PostGIS 1.3 and below, only).\n * The PROJ.4 datum shifting files must be installed (see the\n   :ref:`PROJ.4 installation instructions <proj4>` for more details).\n \n-If you meet these requirements, then just substitute in the ``OSMGeoAdmin``\n+If you meet these requirements, then just substitute the ``OSMGeoAdmin``\n option class in your ``admin.py`` file::\n \n     admin.site.register(WorldBorder, admin.OSMGeoAdmin)\n \n .. rubric:: Footnotes\n \n-.. [#] Special thanks to Bjørn Sandvik of `thematicmapping.org <http://thematicmapping.org>`_ for providing and maintaining this data set.\n-.. [#] GeoDjango basic apps was written by Dane Springmeyer, Josh Livni, and Christopher Schmidt.\n-.. [#] Here the point is for the `University of Houston Law Center <http://www.law.uh.edu/>`_.\n-.. [#] Open Geospatial Consortium, Inc., `OpenGIS Simple Feature Specification For SQL <http://www.opengeospatial.org/standards/sfs>`_.\n+.. [#] Special thanks to Bjørn Sandvik of `thematicmapping.org\n+       <http://thematicmapping.org>`_ for providing and maintaining this\n+       dataset.\n+.. [#] GeoDjango basic apps was written by Dane Springmeyer, Josh Livni, and\n+       Christopher Schmidt.\n+.. [#] This point is the `University of Houston Law Center\n+       <http://www.law.uh.edu/>`_.\n+.. [#] Open Geospatial Consortium, Inc., `OpenGIS Simple Feature Specification\n+       For SQL <http://www.opengeospatial.org/standards/sfs>`_."
        }
    ],
    "stats": {
        "total": 281,
        "additions": 136,
        "deletions": 145
    }
}