{
    "author": "kmtracey",
    "message": "Fixed #3615: Added support for loading fixtures with forward references on database backends (such as MySQL/InnoDB) that do not support deferred constraint checking. Many thanks to jsdalton for coming up with a clever solution to this long-standing issue, and to jacob, ramiro, graham_king, and russellm for review/testing. (Apologies if I missed anyone else who helped here.)\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16590 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "be87f0b0ec992e6f3e72735d8e95c654da969f6d",
    "files": [
        {
            "sha": "952b1cb20abd7541adefe883e93fcfe45950fed2",
            "filename": "django/core/management/commands/loaddata.py",
            "status": "modified",
            "additions": 18,
            "deletions": 6,
            "changes": 24,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Floaddata.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -1,3 +1,7 @@\n+# This is necessary in Python 2.5 to enable the with statement, in 2.6\n+# and up it is no longer necessary.\n+from __future__ import with_statement\n+\n import sys\n import os\n import gzip\n@@ -166,12 +170,20 @@ def read(self):\n                                     (format, fixture_name, humanize(fixture_dir)))\n                             try:\n                                 objects = serializers.deserialize(format, fixture, using=using)\n-                                for obj in objects:\n-                                    objects_in_fixture += 1\n-                                    if router.allow_syncdb(using, obj.object.__class__):\n-                                        loaded_objects_in_fixture += 1\n-                                        models.add(obj.object.__class__)\n-                                        obj.save(using=using)\n+\n+                                with connection.constraint_checks_disabled():\n+                                    for obj in objects:\n+                                        objects_in_fixture += 1\n+                                        if router.allow_syncdb(using, obj.object.__class__):\n+                                            loaded_objects_in_fixture += 1\n+                                            models.add(obj.object.__class__)\n+                                            obj.save(using=using)\n+\n+                                # Since we disabled constraint checks, we must manually check for\n+                                # any invalid keys that might have been added\n+                                table_names = [model._meta.db_table for model in models]\n+                                connection.check_constraints(table_names=table_names)\n+\n                                 loaded_object_count += loaded_objects_in_fixture\n                                 fixture_object_count += objects_in_fixture\n                                 label_found = True"
        },
        {
            "sha": "23ddedb4c6953207c803989382e008721ef3df6f",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -3,6 +3,7 @@\n except ImportError:\n     import dummy_thread as thread\n from threading import local\n+from contextlib import contextmanager\n \n from django.conf import settings\n from django.db import DEFAULT_DB_ALIAS\n@@ -238,6 +239,35 @@ def savepoint_commit(self, sid):\n         if self.savepoint_state:\n             self._savepoint_commit(sid)\n \n+    @contextmanager\n+    def constraint_checks_disabled(self):\n+        disabled = self.disable_constraint_checking()\n+        try:\n+            yield\n+        finally:\n+            if disabled:\n+                self.enable_constraint_checking()\n+\n+    def disable_constraint_checking(self):\n+        \"\"\"\n+        Backends can implement as needed to temporarily disable foreign key constraint\n+        checking.\n+        \"\"\"\n+        pass\n+\n+    def enable_constraint_checking(self):\n+        \"\"\"\n+        Backends can implement as needed to re-enable foreign key constraint checking.\n+        \"\"\"\n+        pass\n+\n+    def check_constraints(self, table_names=None):\n+        \"\"\"\n+        Backends can override this method if they can apply constraint checking (e.g. via \"SET CONSTRAINTS\n+        ALL IMMEDIATE\"). Should raise an IntegrityError if any invalid foreign key references are encountered.\n+        \"\"\"\n+        pass\n+\n     def close(self):\n         if self.connection is not None:\n             self.connection.close()\n@@ -869,6 +899,19 @@ def sequence_list(self):\n \n         return sequence_list\n \n+    def get_key_columns(self, cursor, table_name):\n+        \"\"\"\n+        Backends can override this to return a list of (column_name, referenced_table_name,\n+        referenced_column_name) for all key columns in given table.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def get_primary_key_column(self, cursor, table_name):\n+        \"\"\"\n+        Backends can override this to return the column name of the primary key for the given table.\n+        \"\"\"\n+        raise NotImplementedError\n+\n class BaseDatabaseClient(object):\n     \"\"\"\n     This class encapsulates all backend-specific methods for opening a"
        },
        {
            "sha": "746f26bacca37c556d82d04562cb8ec214fd4d04",
            "filename": "django/db/backends/dummy/base.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Fdummy%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Fdummy%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fdummy%2Fbase.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -34,6 +34,7 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n     get_table_description = complain\n     get_relations = complain\n     get_indexes = complain\n+    get_key_columns = complain\n \n class DatabaseWrapper(BaseDatabaseWrapper):\n     operators = {}"
        },
        {
            "sha": "f4523e4e820137d64e16b02b114398077af26194",
            "filename": "django/db/backends/mysql/base.py",
            "status": "modified",
            "additions": 49,
            "deletions": 0,
            "changes": 49,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -349,3 +349,52 @@ def get_server_version(self):\n                 raise Exception('Unable to determine MySQL version from version string %r' % self.connection.get_server_info())\n             self.server_version = tuple([int(x) for x in m.groups()])\n         return self.server_version\n+\n+    def disable_constraint_checking(self):\n+        \"\"\"\n+        Disables foreign key checks, primarily for use in adding rows with forward references. Always returns True,\n+        to indicate constraint checks need to be re-enabled.\n+        \"\"\"\n+        self.cursor().execute('SET foreign_key_checks=0')\n+        return True\n+\n+    def enable_constraint_checking(self):\n+        \"\"\"\n+        Re-enable foreign key checks after they have been disabled.\n+        \"\"\"\n+        self.cursor().execute('SET foreign_key_checks=1')\n+\n+    def check_constraints(self, table_names=None):\n+        \"\"\"\n+        Checks each table name in table-names for rows with invalid foreign key references. This method is\n+        intended to be used in conjunction with `disable_constraint_checking()` and `enable_constraint_checking()`, to\n+        determine if rows with invalid references were entered while constraint checks were off.\n+\n+        Raises an IntegrityError on the first invalid foreign key reference encountered (if any) and provides\n+        detailed information about the invalid reference in the error message.\n+\n+        Backends can override this method if they can more directly apply constraint checking (e.g. via \"SET CONSTRAINTS\n+        ALL IMMEDIATE\")\n+        \"\"\"\n+        cursor = self.cursor()\n+        if table_names is None:\n+            table_names = self.introspection.get_table_list(cursor)\n+        for table_name in table_names:\n+            primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n+            if not primary_key_column_name:\n+                continue\n+            key_columns = self.introspection.get_key_columns(cursor, table_name)\n+            for column_name, referenced_table_name, referenced_column_name in key_columns:\n+                cursor.execute(\"\"\"\n+                    SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING\n+                    LEFT JOIN `%s` as REFERRED\n+                    ON (REFERRING.`%s` = REFERRED.`%s`)\n+                    WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL\"\"\"\n+                    % (primary_key_column_name, column_name, table_name, referenced_table_name,\n+                    column_name, referenced_column_name, column_name, referenced_column_name))\n+                for bad_row in cursor.fetchall():\n+                    raise utils.IntegrityError(\"The row in table '%s' with primary key '%s' has an invalid \"\n+                        \"foreign key: %s.%s contains a value '%s' that does not have a corresponding value in %s.%s.\"\n+                        % (table_name, bad_row[0],\n+                        table_name, column_name, bad_row[1],\n+                        referenced_table_name, referenced_column_name))"
        },
        {
            "sha": "ab4eebea900ff1170eac5ae492e74b1922cf1f88",
            "filename": "django/db/backends/mysql/introspection.py",
            "status": "modified",
            "additions": 24,
            "deletions": 10,
            "changes": 34,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Fmysql%2Fintrospection.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Fmysql%2Fintrospection.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fintrospection.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -51,18 +51,29 @@ def get_relations(self, cursor, table_name):\n         representing all relationships to the given table. Indexes are 0-based.\n         \"\"\"\n         my_field_dict = self._name_to_index(cursor, table_name)\n-        constraints = []\n+        constraints = self.get_key_columns(cursor, table_name)\n         relations = {}\n+        for my_fieldname, other_table, other_field in constraints:\n+            other_field_index = self._name_to_index(cursor, other_table)[other_field]\n+            my_field_index = my_field_dict[my_fieldname]\n+            relations[my_field_index] = (other_field_index, other_table)\n+        return relations\n+\n+    def get_key_columns(self, cursor, table_name):\n+        \"\"\"\n+        Returns a list of (column_name, referenced_table_name, referenced_column_name) for all\n+        key columns in given table.\n+        \"\"\"\n+        key_columns = []\n         try:\n-            # This should work for MySQL 5.0.\n             cursor.execute(\"\"\"\n                 SELECT column_name, referenced_table_name, referenced_column_name\n                 FROM information_schema.key_column_usage\n                 WHERE table_name = %s\n                     AND table_schema = DATABASE()\n                     AND referenced_table_name IS NOT NULL\n                     AND referenced_column_name IS NOT NULL\"\"\", [table_name])\n-            constraints.extend(cursor.fetchall())\n+            key_columns.extend(cursor.fetchall())\n         except (ProgrammingError, OperationalError):\n             # Fall back to \"SHOW CREATE TABLE\", for previous MySQL versions.\n             # Go through all constraints and save the equal matches.\n@@ -74,14 +85,17 @@ def get_relations(self, cursor, table_name):\n                     if match == None:\n                         break\n                     pos = match.end()\n-                    constraints.append(match.groups())\n+                    key_columns.append(match.groups())\n+        return key_columns\n \n-        for my_fieldname, other_table, other_field in constraints:\n-            other_field_index = self._name_to_index(cursor, other_table)[other_field]\n-            my_field_index = my_field_dict[my_fieldname]\n-            relations[my_field_index] = (other_field_index, other_table)\n-\n-        return relations\n+    def get_primary_key_column(self, cursor, table_name):\n+        \"\"\"\n+        Returns the name of the primary key column for the given table\n+        \"\"\"\n+        for column in self.get_indexes(cursor, table_name).iteritems():\n+            if column[1]['primary_key']:\n+                return column[0]\n+        return None\n \n     def get_indexes(self, cursor, table_name):\n         \"\"\""
        },
        {
            "sha": "3cadb6617dae55bbc6af8c736d3fffc31192ac9f",
            "filename": "django/db/backends/oracle/base.py",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Foracle%2Fbase.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -428,6 +428,14 @@ def __init__(self, *args, **kwargs):\n         self.introspection = DatabaseIntrospection(self)\n         self.validation = BaseDatabaseValidation(self)\n \n+    def check_constraints(self, table_names=None):\n+        \"\"\"\n+        To check constraints, we set constraints to immediate. Then, when, we're done we must ensure they\n+        are returned to deferred.\n+        \"\"\"\n+        self.cursor().execute('SET CONSTRAINTS ALL IMMEDIATE')\n+        self.cursor().execute('SET CONSTRAINTS ALL DEFERRED')\n+\n     def _valid_connection(self):\n         return self.connection is not None\n "
        },
        {
            "sha": "37aa072f6b6b4dae1c3d49edc6c99388a1a39b49",
            "filename": "django/db/backends/postgresql_psycopg2/base.py",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -106,6 +106,14 @@ def __init__(self, *args, **kwargs):\n         self.validation = BaseDatabaseValidation(self)\n         self._pg_version = None\n \n+    def check_constraints(self, table_names=None):\n+        \"\"\"\n+        To check constraints, we set constraints to immediate. Then, when, we're done we must ensure they\n+        are returned to deferred.\n+        \"\"\"\n+        self.cursor().execute('SET CONSTRAINTS ALL IMMEDIATE')\n+        self.cursor().execute('SET CONSTRAINTS ALL DEFERRED')\n+\n     def _get_pg_version(self):\n         if self._pg_version is None:\n             self._pg_version = get_version(self.connection)"
        },
        {
            "sha": "f922d386382c812fa273b15acc15411d4c7b16ab",
            "filename": "django/db/backends/sqlite3/base.py",
            "status": "modified",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -206,6 +206,40 @@ def _cursor(self):\n             connection_created.send(sender=self.__class__, connection=self)\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    def check_constraints(self, table_names=None):\n+        \"\"\"\n+        Checks each table name in table-names for rows with invalid foreign key references. This method is\n+        intended to be used in conjunction with `disable_constraint_checking()` and `enable_constraint_checking()`, to\n+        determine if rows with invalid references were entered while constraint checks were off.\n+\n+        Raises an IntegrityError on the first invalid foreign key reference encountered (if any) and provides\n+        detailed information about the invalid reference in the error message.\n+\n+        Backends can override this method if they can more directly apply constraint checking (e.g. via \"SET CONSTRAINTS\n+        ALL IMMEDIATE\")\n+        \"\"\"\n+        cursor = self.cursor()\n+        if table_names is None:\n+            table_names = self.introspection.get_table_list(cursor)\n+        for table_name in table_names:\n+            primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n+            if not primary_key_column_name:\n+                continue\n+            key_columns = self.introspection.get_key_columns(cursor, table_name)\n+            for column_name, referenced_table_name, referenced_column_name in key_columns:\n+                cursor.execute(\"\"\"\n+                    SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING\n+                    LEFT JOIN `%s` as REFERRED\n+                    ON (REFERRING.`%s` = REFERRED.`%s`)\n+                    WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL\"\"\"\n+                    % (primary_key_column_name, column_name, table_name, referenced_table_name,\n+                    column_name, referenced_column_name, column_name, referenced_column_name))\n+                for bad_row in cursor.fetchall():\n+                    raise utils.IntegrityError(\"The row in table '%s' with primary key '%s' has an invalid \"\n+                        \"foreign key: %s.%s contains a value '%s' that does not have a corresponding value in %s.%s.\"\n+                        % (table_name, bad_row[0], table_name, column_name, bad_row[1],\n+                        referenced_table_name, referenced_column_name))\n+\n     def close(self):\n         # If database is in memory, closing the connection destroys the\n         # database. To prevent accidental data loss, ignore close requests on"
        },
        {
            "sha": "9652a4da6a041d60024773444cc8e43bfe567674",
            "filename": "django/db/backends/sqlite3/introspection.py",
            "status": "modified",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Fsqlite3%2Fintrospection.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/django%2Fdb%2Fbackends%2Fsqlite3%2Fintrospection.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fintrospection.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -103,6 +103,35 @@ def get_relations(self, cursor, table_name):\n \n         return relations\n \n+    def get_key_columns(self, cursor, table_name):\n+        \"\"\"\n+        Returns a list of (column_name, referenced_table_name, referenced_column_name) for all\n+        key columns in given table.\n+        \"\"\"\n+        key_columns = []\n+\n+        # Schema for this table\n+        cursor.execute(\"SELECT sql FROM sqlite_master WHERE tbl_name = %s AND type = %s\", [table_name, \"table\"])\n+        results = cursor.fetchone()[0].strip()\n+        results = results[results.index('(')+1:results.rindex(')')]\n+\n+        # Walk through and look for references to other tables. SQLite doesn't\n+        # really have enforced references, but since it echoes out the SQL used\n+        # to create the table we can look for REFERENCES statements used there.\n+        for field_index, field_desc in enumerate(results.split(',')):\n+            field_desc = field_desc.strip()\n+            if field_desc.startswith(\"UNIQUE\"):\n+                continue\n+\n+            m = re.search('\"(.*)\".*references (.*) \\([\"|](.*)[\"|]\\)', field_desc, re.I)\n+            if not m:\n+                continue\n+\n+            # This will append (column_name, referenced_table_name, referenced_column_name) to key_columns\n+            key_columns.append(tuple([s.strip('\"') for s in m.groups()]))\n+\n+        return key_columns\n+\n     def get_indexes(self, cursor, table_name):\n         \"\"\"\n         Returns a dictionary of fieldname -> infodict for the given table,\n@@ -128,6 +157,21 @@ def get_indexes(self, cursor, table_name):\n             indexes[name]['unique'] = True\n         return indexes\n \n+    def get_primary_key_column(self, cursor, table_name):\n+        \"\"\"\n+        Get the column name of the primary key for the given table.\n+        \"\"\"\n+        # Don't use PRAGMA because that causes issues with some transactions\n+        cursor.execute(\"SELECT sql FROM sqlite_master WHERE tbl_name = %s AND type = %s\", [table_name, \"table\"])\n+        results = cursor.fetchone()[0].strip()\n+        results = results[results.index('(')+1:results.rindex(')')]\n+        for field_desc in results.split(','):\n+            field_desc = field_desc.strip()\n+            m = re.search('\"(.*)\".*PRIMARY KEY$', field_desc)\n+            if m:\n+                return m.groups()[0]\n+        return None\n+\n     def _table_info(self, cursor, name):\n         cursor.execute('PRAGMA table_info(%s)' % self.connection.ops.quote_name(name))\n         # cid, name, type, notnull, dflt_value, pk"
        },
        {
            "sha": "5a2042a02af9ba35e96f44a6b5304eb761a7f787",
            "filename": "docs/ref/databases.txt",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/docs%2Fref%2Fdatabases.txt",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/docs%2Fref%2Fdatabases.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fdatabases.txt?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -142,6 +142,18 @@ currently the only engine that supports full-text indexing and searching.\n The InnoDB_ engine is fully transactional and supports foreign key references\n and is probably the best choice at this point in time.\n \n+.. versionchanged:: 1.4\n+\n+In previous versions of Django, fixtures with forward references (i.e.\n+relations to rows that have not yet been inserted into the database) would fail\n+to load when using the InnoDB storage engine. This was due to the fact that InnoDB\n+deviates from the SQL standard by checking foreign key constraints immediately\n+instead of deferring the check until the transaction is committed. This\n+problem has been resolved in Django 1.4. Fixture data is now loaded with foreign key\n+checks turned off; foreign key checks are then re-enabled when the data has\n+finished loading, at which point the entire table is checked for invalid foreign\n+key references and an `IntegrityError` is raised if any are found.\n+\n .. _storage engines: http://dev.mysql.com/doc/refman/5.5/en/storage-engines.html\n .. _MyISAM: http://dev.mysql.com/doc/refman/5.5/en/myisam-storage-engine.html\n .. _InnoDB: http://dev.mysql.com/doc/refman/5.5/en/innodb.html"
        },
        {
            "sha": "ec4eae09af92725572aa14d9721920cf5fec23c4",
            "filename": "docs/releases/1.4.txt",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/docs%2Freleases%2F1.4.txt",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/docs%2Freleases%2F1.4.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.4.txt?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -235,6 +235,9 @@ Django 1.4 also includes several smaller improvements worth noting:\n   to delete all files at the destination before copying or linking the static\n   files.\n \n+* It is now possible to load fixtures containing forward references when using\n+  MySQL with the InnoDB database engine.\n+\n .. _backwards-incompatible-changes-1.4:\n \n Backwards incompatible changes in 1.4"
        },
        {
            "sha": "def0254a9f49dceb485c4858211a1d804f271571",
            "filename": "tests/modeltests/serializers/tests.py",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/tests%2Fmodeltests%2Fserializers%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/tests%2Fmodeltests%2Fserializers%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fserializers%2Ftests.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -1,11 +1,15 @@\n+# This is necessary in Python 2.5 to enable the with statement, in 2.6\n+# and up it is no longer necessary.\n+from __future__ import with_statement\n+\n # -*- coding: utf-8 -*-\n from datetime import datetime\n from StringIO import StringIO\n from xml.dom import minidom\n \n from django.conf import settings\n from django.core import serializers\n-from django.db import transaction\n+from django.db import transaction, connection\n from django.test import TestCase, TransactionTestCase, Approximate\n from django.utils import simplejson, unittest\n \n@@ -252,8 +256,9 @@ def test_forward_refs(self):\n         transaction.enter_transaction_management()\n         transaction.managed(True)\n         objs = serializers.deserialize(self.serializer_name, self.fwd_ref_str)\n-        for obj in objs:\n-            obj.save()\n+        with connection.constraint_checks_disabled():\n+            for obj in objs:\n+                obj.save()\n         transaction.commit()\n         transaction.leave_transaction_management()\n "
        },
        {
            "sha": "27d3dfdddcd3fa44262d4498ec81b14ae1096188",
            "filename": "tests/regressiontests/backends/tests.py",
            "status": "modified",
            "additions": 61,
            "deletions": 3,
            "changes": 64,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/tests%2Fregressiontests%2Fbackends%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/tests%2Fregressiontests%2Fbackends%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fbackends%2Ftests.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -1,10 +1,11 @@\n # -*- coding: utf-8 -*-\n # Unit and doctests for specific database backends.\n+from __future__ import with_statement\n import datetime\n \n from django.conf import settings\n from django.core.management.color import no_style\n-from django.db import backend, connection, connections, DEFAULT_DB_ALIAS, IntegrityError\n+from django.db import backend, connection, connections, DEFAULT_DB_ALIAS, IntegrityError, transaction\n from django.db.backends.signals import connection_created\n from django.db.backends.postgresql_psycopg2 import version as pg_version\n from django.test import TestCase, skipUnlessDBFeature, TransactionTestCase\n@@ -328,7 +329,8 @@ def test_integrity_checks_on_creation(self):\n         try:\n             a.save()\n         except IntegrityError:\n-            pass\n+            return\n+        self.skipTest(\"This backend does not support integrity checks.\")\n \n     def test_integrity_checks_on_update(self):\n         \"\"\"\n@@ -343,4 +345,60 @@ def test_integrity_checks_on_update(self):\n         try:\n             a.save()\n         except IntegrityError:\n-            pass\n+            return\n+        self.skipTest(\"This backend does not support integrity checks.\")\n+\n+    def test_disable_constraint_checks_manually(self):\n+        \"\"\"\n+        When constraint checks are disabled, should be able to write bad data without IntegrityErrors.\n+        \"\"\"\n+        with transaction.commit_manually():\n+            # Create an Article.\n+            models.Article.objects.create(headline=\"Test article\", pub_date=datetime.datetime(2010, 9, 4), reporter=self.r)\n+            # Retrive it from the DB\n+            a = models.Article.objects.get(headline=\"Test article\")\n+            a.reporter_id = 30\n+            try:\n+                connection.disable_constraint_checking()\n+                a.save()\n+                connection.enable_constraint_checking()\n+            except IntegrityError:\n+                self.fail(\"IntegrityError should not have occurred.\")\n+            finally:\n+                transaction.rollback()\n+\n+    def test_disable_constraint_checks_context_manager(self):\n+        \"\"\"\n+        When constraint checks are disabled (using context manager), should be able to write bad data without IntegrityErrors.\n+        \"\"\"\n+        with transaction.commit_manually():\n+            # Create an Article.\n+            models.Article.objects.create(headline=\"Test article\", pub_date=datetime.datetime(2010, 9, 4), reporter=self.r)\n+            # Retrive it from the DB\n+            a = models.Article.objects.get(headline=\"Test article\")\n+            a.reporter_id = 30\n+            try:\n+                with connection.constraint_checks_disabled():\n+                    a.save()\n+            except IntegrityError:\n+                self.fail(\"IntegrityError should not have occurred.\")\n+            finally:\n+                transaction.rollback()\n+\n+    def test_check_constraints(self):\n+        \"\"\"\n+        Constraint checks should raise an IntegrityError when bad data is in the DB.\n+        \"\"\"\n+        with transaction.commit_manually():\n+            # Create an Article.\n+            models.Article.objects.create(headline=\"Test article\", pub_date=datetime.datetime(2010, 9, 4), reporter=self.r)\n+            # Retrive it from the DB\n+            a = models.Article.objects.get(headline=\"Test article\")\n+            a.reporter_id = 30\n+            try:\n+                with connection.constraint_checks_disabled():\n+                    a.save()\n+                    with self.assertRaises(IntegrityError):\n+                        connection.check_constraints()\n+            finally:\n+                transaction.rollback()"
        },
        {
            "sha": "b67155d42696b254cc6e776fd7035267c5595f8a",
            "filename": "tests/regressiontests/fixtures_regress/tests.py",
            "status": "modified",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/tests%2Fregressiontests%2Ffixtures_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/tests%2Fregressiontests%2Ffixtures_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ffixtures_regress%2Ftests.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -362,6 +362,35 @@ def test_proxy_model_included(self):\n             % widget.pk\n             )\n \n+    def test_loaddata_works_when_fixture_has_forward_refs(self):\n+        \"\"\"\n+        Regression for #3615 - Forward references cause fixtures not to load in MySQL (InnoDB)\n+        \"\"\"\n+        management.call_command(\n+            'loaddata',\n+            'forward_ref.json',\n+            verbosity=0,\n+            commit=False\n+        )\n+        self.assertEqual(Book.objects.all()[0].id, 1)\n+        self.assertEqual(Person.objects.all()[0].id, 4)\n+\n+    def test_loaddata_raises_error_when_fixture_has_invalid_foreign_key(self):\n+        \"\"\"\n+        Regression for #3615 - Ensure data with nonexistent child key references raises error\n+        \"\"\"\n+        stderr = StringIO()\n+        management.call_command(\n+            'loaddata',\n+            'forward_ref_bad_data.json',\n+            verbosity=0,\n+            commit=False,\n+            stderr=stderr,\n+        )\n+        self.assertTrue(\n+            stderr.getvalue().startswith('Problem installing fixture')\n+        )\n+\n \n class NaturalKeyFixtureTests(TestCase):\n     def assertRaisesMessage(self, exc, msg, func, *args, **kwargs):"
        },
        {
            "sha": "fdf30126cdb5e40d79153d1d712bacc84e48ea0a",
            "filename": "tests/regressiontests/introspection/tests.py",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/tests%2Fregressiontests%2Fintrospection%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/tests%2Fregressiontests%2Fintrospection%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fintrospection%2Ftests.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -95,6 +95,16 @@ def test_get_relations(self):\n             # That's {field_index: (field_index_other_table, other_table)}\n             self.assertEqual(relations, {3: (0, Reporter._meta.db_table)})\n \n+    def test_get_key_columns(self):\n+        cursor = connection.cursor()\n+        key_columns = connection.introspection.get_key_columns(cursor, Article._meta.db_table)\n+        self.assertEqual(key_columns, [(u'reporter_id', Reporter._meta.db_table, u'id')])\n+\n+    def test_get_primary_key_column(self):\n+        cursor = connection.cursor()\n+        primary_key_column = connection.introspection.get_primary_key_column(cursor, Article._meta.db_table)\n+        self.assertEqual(primary_key_column, u'id')\n+\n     def test_get_indexes(self):\n         cursor = connection.cursor()\n         indexes = connection.introspection.get_indexes(cursor, Article._meta.db_table)"
        },
        {
            "sha": "bb6f5987192e0890fe7cfc45741a6fc55b6c973c",
            "filename": "tests/regressiontests/serializers_regress/tests.py",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/django/django/blob/be87f0b0ec992e6f3e72735d8e95c654da969f6d/tests%2Fregressiontests%2Fserializers_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/be87f0b0ec992e6f3e72735d8e95c654da969f6d/tests%2Fregressiontests%2Fserializers_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fserializers_regress%2Ftests.py?ref=be87f0b0ec992e6f3e72735d8e95c654da969f6d",
            "patch": "@@ -6,6 +6,8 @@\n the serializers. This includes all valid data values, plus\n forward, backwards and self references.\n \"\"\"\n+# This is necessary in Python 2.5 to enable the with statement, in 2.6\n+# and up it is no longer necessary.\n from __future__ import with_statement\n \n import datetime\n@@ -382,7 +384,8 @@ def serializerTest(format, self):\n     objects = []\n     instance_count = {}\n     for (func, pk, klass, datum) in test_data:\n-        objects.extend(func[0](pk, klass, datum))\n+        with connection.constraint_checks_disabled():\n+            objects.extend(func[0](pk, klass, datum))\n \n     # Get a count of the number of objects created for each class\n     for klass in instance_count:"
        }
    ],
    "stats": {
        "total": 379,
        "additions": 356,
        "deletions": 23
    }
}