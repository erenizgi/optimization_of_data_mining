{
    "author": "claudep",
    "message": "[py3] Fixed mail tests with Python 3",
    "sha": "751774c29f6ad8f6ad08bc48a4d085829dd279e0",
    "files": [
        {
            "sha": "b332ffba04fa7fbdb4fa7e8af2a78ff3b0599479",
            "filename": "django/core/mail/message.py",
            "status": "modified",
            "additions": 17,
            "deletions": 17,
            "changes": 34,
            "blob_url": "https://github.com/django/django/blob/751774c29f6ad8f6ad08bc48a4d085829dd279e0/django%2Fcore%2Fmail%2Fmessage.py",
            "raw_url": "https://github.com/django/django/raw/751774c29f6ad8f6ad08bc48a4d085829dd279e0/django%2Fcore%2Fmail%2Fmessage.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmail%2Fmessage.py?ref=751774c29f6ad8f6ad08bc48a4d085829dd279e0",
            "patch": "@@ -11,11 +11,10 @@\n from email.mime.base import MIMEBase\n from email.header import Header\n from email.utils import formatdate, getaddresses, formataddr, parseaddr\n-from io import BytesIO\n \n from django.conf import settings\n from django.core.mail.utils import DNS_NAME\n-from django.utils.encoding import smart_bytes, force_text\n+from django.utils.encoding import force_text\n from django.utils import six\n \n \n@@ -83,34 +82,34 @@ def forbid_multi_line_headers(name, val, encoding):\n     if '\\n' in val or '\\r' in val:\n         raise BadHeaderError(\"Header values can't contain newlines (got %r for header %r)\" % (val, name))\n     try:\n-        val = val.encode('ascii')\n+        val.encode('ascii')\n     except UnicodeEncodeError:\n         if name.lower() in ADDRESS_HEADERS:\n             val = ', '.join(sanitize_address(addr, encoding)\n                 for addr in getaddresses((val,)))\n         else:\n-            val = str(Header(val, encoding))\n+            val = Header(val, encoding).encode()\n     else:\n         if name.lower() == 'subject':\n-            val = Header(val)\n-    return smart_bytes(name), val\n+            val = Header(val).encode()\n+    return str(name), val\n \n \n def sanitize_address(addr, encoding):\n     if isinstance(addr, six.string_types):\n         addr = parseaddr(force_text(addr))\n     nm, addr = addr\n-    nm = str(Header(nm, encoding))\n+    nm = Header(nm, encoding).encode()\n     try:\n-        addr = addr.encode('ascii')\n+        addr.encode('ascii')\n     except UnicodeEncodeError:  # IDN\n         if '@' in addr:\n             localpart, domain = addr.split('@', 1)\n             localpart = str(Header(localpart, encoding))\n-            domain = domain.encode('idna')\n+            domain = domain.encode('idna').decode('ascii')\n             addr = '@'.join([localpart, domain])\n         else:\n-            addr = str(Header(addr, encoding))\n+            addr = Header(addr, encoding).encode()\n     return formataddr((nm, addr))\n \n \n@@ -132,7 +131,7 @@ def as_string(self, unixfrom=False):\n         This overrides the default as_string() implementation to not mangle\n         lines that begin with 'From '. See bug #13433 for details.\n         \"\"\"\n-        fp = BytesIO()\n+        fp = six.StringIO()\n         g = Generator(fp, mangle_from_ = False)\n         g.flatten(self, unixfrom=unixfrom)\n         return fp.getvalue()\n@@ -156,7 +155,7 @@ def as_string(self, unixfrom=False):\n         This overrides the default as_string() implementation to not mangle\n         lines that begin with 'From '. See bug #13433 for details.\n         \"\"\"\n-        fp = BytesIO()\n+        fp = six.StringIO()\n         g = Generator(fp, mangle_from_ = False)\n         g.flatten(self, unixfrom=unixfrom)\n         return fp.getvalue()\n@@ -210,8 +209,7 @@ def get_connection(self, fail_silently=False):\n \n     def message(self):\n         encoding = self.encoding or settings.DEFAULT_CHARSET\n-        msg = SafeMIMEText(smart_bytes(self.body, encoding),\n-                           self.content_subtype, encoding)\n+        msg = SafeMIMEText(self.body, self.content_subtype, encoding)\n         msg = self._create_message(msg)\n         msg['Subject'] = self.subject\n         msg['From'] = self.extra_headers.get('From', self.from_email)\n@@ -293,7 +291,7 @@ def _create_mime_attachment(self, content, mimetype):\n         basetype, subtype = mimetype.split('/', 1)\n         if basetype == 'text':\n             encoding = self.encoding or settings.DEFAULT_CHARSET\n-            attachment = SafeMIMEText(smart_bytes(content, encoding), subtype, encoding)\n+            attachment = SafeMIMEText(content, subtype, encoding)\n         else:\n             # Encode non-text attachments with base64.\n             attachment = MIMEBase(basetype, subtype)\n@@ -313,9 +311,11 @@ def _create_attachment(self, filename, content, mimetype=None):\n         attachment = self._create_mime_attachment(content, mimetype)\n         if filename:\n             try:\n-                filename = filename.encode('ascii')\n+                filename.encode('ascii')\n             except UnicodeEncodeError:\n-                filename = ('utf-8', '', filename.encode('utf-8'))\n+                if not six.PY3:\n+                    filename = filename.encode('utf-8')\n+                filename = ('utf-8', '', filename)\n             attachment.add_header('Content-Disposition', 'attachment',\n                                   filename=filename)\n         return attachment"
        },
        {
            "sha": "c948662bc34bb830a76491abee69a89a2cfbc8d3",
            "filename": "tests/regressiontests/mail/tests.py",
            "status": "modified",
            "additions": 29,
            "deletions": 25,
            "changes": 54,
            "blob_url": "https://github.com/django/django/blob/751774c29f6ad8f6ad08bc48a4d085829dd279e0/tests%2Fregressiontests%2Fmail%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/751774c29f6ad8f6ad08bc48a4d085829dd279e0/tests%2Fregressiontests%2Fmail%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fmail%2Ftests.py?ref=751774c29f6ad8f6ad08bc48a4d085829dd279e0",
            "patch": "@@ -17,7 +17,7 @@\n from django.core.mail.message import BadHeaderError\n from django.test import TestCase\n from django.test.utils import override_settings\n-from django.utils.six import StringIO\n+from django.utils.six import PY3, StringIO\n from django.utils.translation import ugettext_lazy\n \n \n@@ -29,15 +29,15 @@ class MailTests(TestCase):\n     def test_ascii(self):\n         email = EmailMessage('Subject', 'Content', 'from@example.com', ['to@example.com'])\n         message = email.message()\n-        self.assertEqual(message['Subject'].encode(), 'Subject')\n+        self.assertEqual(message['Subject'], 'Subject')\n         self.assertEqual(message.get_payload(), 'Content')\n         self.assertEqual(message['From'], 'from@example.com')\n         self.assertEqual(message['To'], 'to@example.com')\n \n     def test_multiple_recipients(self):\n         email = EmailMessage('Subject', 'Content', 'from@example.com', ['to@example.com', 'other@example.com'])\n         message = email.message()\n-        self.assertEqual(message['Subject'].encode(), 'Subject')\n+        self.assertEqual(message['Subject'], 'Subject')\n         self.assertEqual(message.get_payload(), 'Content')\n         self.assertEqual(message['From'], 'from@example.com')\n         self.assertEqual(message['To'], 'to@example.com, other@example.com')\n@@ -77,9 +77,10 @@ def test_space_continuation(self):\n         \"\"\"\n         Test for space continuation character in long (ascii) subject headers (#7747)\n         \"\"\"\n-        email = EmailMessage('Long subject lines that get wrapped should use a space continuation character to get expected behavior in Outlook and Thunderbird', 'Content', 'from@example.com', ['to@example.com'])\n+        email = EmailMessage('Long subject lines that get wrapped should contain a space continuation character to get expected behavior in Outlook and Thunderbird', 'Content', 'from@example.com', ['to@example.com'])\n         message = email.message()\n-        self.assertEqual(message['Subject'], 'Long subject lines that get wrapped should use a space continuation\\n character to get expected behavior in Outlook and Thunderbird')\n+        # Note that in Python 3, maximum line length has increased from 76 to 78\n+        self.assertEqual(message['Subject'].encode(), b'Long subject lines that get wrapped should contain a space continuation\\n character to get expected behavior in Outlook and Thunderbird')\n \n     def test_message_header_overrides(self):\n         \"\"\"\n@@ -88,7 +89,7 @@ def test_message_header_overrides(self):\n         \"\"\"\n         headers = {\"date\": \"Fri, 09 Nov 2001 01:08:47 -0000\", \"Message-ID\": \"foo\"}\n         email = EmailMessage('subject', 'content', 'from@example.com', ['to@example.com'], headers=headers)\n-        self.assertEqual(email.message().as_string(), b'Content-Type: text/plain; charset=\"utf-8\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: 7bit\\nSubject: subject\\nFrom: from@example.com\\nTo: to@example.com\\ndate: Fri, 09 Nov 2001 01:08:47 -0000\\nMessage-ID: foo\\n\\ncontent')\n+        self.assertEqual(email.message().as_string(), 'Content-Type: text/plain; charset=\"utf-8\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: 7bit\\nSubject: subject\\nFrom: from@example.com\\nTo: to@example.com\\ndate: Fri, 09 Nov 2001 01:08:47 -0000\\nMessage-ID: foo\\n\\ncontent')\n \n     def test_from_header(self):\n         \"\"\"\n@@ -160,7 +161,7 @@ def test_safe_mime_multipart(self):\n         msg.attach_alternative(html_content, \"text/html\")\n         msg.encoding = 'iso-8859-1'\n         self.assertEqual(msg.message()['To'], '=?iso-8859-1?q?S=FCrname=2C_Firstname?= <to@example.com>')\n-        self.assertEqual(msg.message()['Subject'].encode(), '=?iso-8859-1?q?Message_from_Firstname_S=FCrname?=')\n+        self.assertEqual(msg.message()['Subject'], '=?iso-8859-1?q?Message_from_Firstname_S=FCrname?=')\n \n     def test_encoding(self):\n         \"\"\"\n@@ -170,7 +171,7 @@ def test_encoding(self):\n         email = EmailMessage('Subject', 'Firstname Sürname is a great guy.', 'from@example.com', ['other@example.com'])\n         email.encoding = 'iso-8859-1'\n         message = email.message()\n-        self.assertTrue(message.as_string().startswith(b'Content-Type: text/plain; charset=\"iso-8859-1\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: quoted-printable\\nSubject: Subject\\nFrom: from@example.com\\nTo: other@example.com'))\n+        self.assertTrue(message.as_string().startswith('Content-Type: text/plain; charset=\"iso-8859-1\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: quoted-printable\\nSubject: Subject\\nFrom: from@example.com\\nTo: other@example.com'))\n         self.assertEqual(message.get_payload(), 'Firstname S=FCrname is a great guy.')\n \n         # Make sure MIME attachments also works correctly with other encodings than utf-8\n@@ -179,8 +180,8 @@ def test_encoding(self):\n         msg = EmailMultiAlternatives('Subject', text_content, 'from@example.com', ['to@example.com'])\n         msg.encoding = 'iso-8859-1'\n         msg.attach_alternative(html_content, \"text/html\")\n-        self.assertEqual(msg.message().get_payload(0).as_string(), b'Content-Type: text/plain; charset=\"iso-8859-1\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: quoted-printable\\n\\nFirstname S=FCrname is a great guy.')\n-        self.assertEqual(msg.message().get_payload(1).as_string(), b'Content-Type: text/html; charset=\"iso-8859-1\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: quoted-printable\\n\\n<p>Firstname S=FCrname is a <strong>great</strong> guy.</p>')\n+        self.assertEqual(msg.message().get_payload(0).as_string(), 'Content-Type: text/plain; charset=\"iso-8859-1\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: quoted-printable\\n\\nFirstname S=FCrname is a great guy.')\n+        self.assertEqual(msg.message().get_payload(1).as_string(), 'Content-Type: text/html; charset=\"iso-8859-1\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: quoted-printable\\n\\n<p>Firstname S=FCrname is a <strong>great</strong> guy.</p>')\n \n     def test_attachments(self):\n         \"\"\"Regression test for #9367\"\"\"\n@@ -291,31 +292,31 @@ def test_dont_mangle_from_in_body(self):\n         # Regression for #13433 - Make sure that EmailMessage doesn't mangle\n         # 'From ' in message body.\n         email = EmailMessage('Subject', 'From the future', 'bounce@example.com', ['to@example.com'], headers={'From': 'from@example.com'})\n-        self.assertFalse(b'>From the future' in email.message().as_string())\n+        self.assertFalse('>From the future' in email.message().as_string())\n \n     def test_dont_base64_encode(self):\n         # Ticket #3472\n         # Shouldn't use Base64 encoding at all\n         msg = EmailMessage('Subject', 'UTF-8 encoded body', 'bounce@example.com', ['to@example.com'], headers={'From': 'from@example.com'})\n-        self.assertFalse(b'Content-Transfer-Encoding: base64' in msg.message().as_string())\n+        self.assertFalse('Content-Transfer-Encoding: base64' in msg.message().as_string())\n \n         # Ticket #11212\n         # Shouldn't use quoted printable, should detect it can represent content with 7 bit data\n         msg = EmailMessage('Subject', 'Body with only ASCII characters.', 'bounce@example.com', ['to@example.com'], headers={'From': 'from@example.com'})\n         s = msg.message().as_string()\n-        self.assertFalse(b'Content-Transfer-Encoding: quoted-printable' in s)\n-        self.assertTrue(b'Content-Transfer-Encoding: 7bit' in s)\n+        self.assertFalse('Content-Transfer-Encoding: quoted-printable' in s)\n+        self.assertTrue('Content-Transfer-Encoding: 7bit' in s)\n \n         # Shouldn't use quoted printable, should detect it can represent content with 8 bit data\n         msg = EmailMessage('Subject', 'Body with latin characters: àáä.', 'bounce@example.com', ['to@example.com'], headers={'From': 'from@example.com'})\n         s = msg.message().as_string()\n-        self.assertFalse(b'Content-Transfer-Encoding: quoted-printable' in s)\n-        self.assertTrue(b'Content-Transfer-Encoding: 8bit' in s)\n+        self.assertFalse(str('Content-Transfer-Encoding: quoted-printable') in s)\n+        self.assertTrue(str('Content-Transfer-Encoding: 8bit') in s)\n \n         msg = EmailMessage('Subject', 'Body with non latin characters: А Б В Г Д Е Ж Ѕ З И І К Л М Н О П.', 'bounce@example.com', ['to@example.com'], headers={'From': 'from@example.com'})\n         s = msg.message().as_string()\n-        self.assertFalse(b'Content-Transfer-Encoding: quoted-printable' in s)\n-        self.assertTrue(b'Content-Transfer-Encoding: 8bit' in s)\n+        self.assertFalse(str('Content-Transfer-Encoding: quoted-printable') in s)\n+        self.assertTrue(str('Content-Transfer-Encoding: 8bit') in s)\n \n \n class BaseEmailBackendTests(object):\n@@ -440,7 +441,7 @@ def test_message_cc_header(self):\n         email = EmailMessage('Subject', 'Content', 'from@example.com', ['to@example.com'], cc=['cc@example.com'])\n         mail.get_connection().send_messages([email])\n         message = self.get_the_message()\n-        self.assertStartsWith(message.as_string(), b'Content-Type: text/plain; charset=\"utf-8\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: 7bit\\nSubject: Subject\\nFrom: from@example.com\\nTo: to@example.com\\nCc: cc@example.com\\nDate: ')\n+        self.assertStartsWith(message.as_string(), 'Content-Type: text/plain; charset=\"utf-8\"\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: 7bit\\nSubject: Subject\\nFrom: from@example.com\\nTo: to@example.com\\nCc: cc@example.com\\nDate: ')\n \n     def test_idn_send(self):\n         \"\"\"\n@@ -519,9 +520,9 @@ def flush_mailbox(self):\n     def get_mailbox_content(self):\n         messages = []\n         for filename in os.listdir(self.tmp_dir):\n-            with open(os.path.join(self.tmp_dir, filename), 'rb') as fp:\n-                session = fp.read().split(b'\\n' + (b'-' * 79) + b'\\n')\n-            messages.extend(email.message_from_string(m) for m in session if m)\n+            with open(os.path.join(self.tmp_dir, filename), 'r') as fp:\n+                session = fp.read().split('\\n' + ('-' * 79) + '\\n')\n+            messages.extend(email.message_from_string(str(m)) for m in session if m)\n         return messages\n \n     def test_file_sessions(self):\n@@ -571,8 +572,8 @@ def flush_mailbox(self):\n         self.stream = sys.stdout = StringIO()\n \n     def get_mailbox_content(self):\n-        messages = self.stream.getvalue().split(b'\\n' + (b'-' * 79) + b'\\n')\n-        return [email.message_from_string(m) for m in messages if m]\n+        messages = self.stream.getvalue().split('\\n' + ('-' * 79) + '\\n')\n+        return [email.message_from_string(str(m)) for m in messages if m]\n \n     def test_console_stream_kwarg(self):\n         \"\"\"\n@@ -600,7 +601,10 @@ def __init__(self, *args, **kwargs):\n \n     def process_message(self, peer, mailfrom, rcpttos, data):\n         m = email.message_from_string(data)\n-        maddr = email.Utils.parseaddr(m.get('from'))[1]\n+        if PY3:\n+            maddr = email.utils.parseaddr(m.get('from'))[1]\n+        else:\n+            maddr = email.Utils.parseaddr(m.get('from'))[1]\n         if mailfrom != maddr:\n             return \"553 '%s' != '%s'\" % (mailfrom, maddr)\n         with self.sink_lock:"
        }
    ],
    "stats": {
        "total": 88,
        "additions": 46,
        "deletions": 42
    }
}