{
    "author": "ramiro",
    "message": "Removed code duplicated in SQLite3 and SpatiaLite GeoDjango DB backends.\n\nMoved it to an auxiliary method in the SQLite3 backend cursor class.\nDid this to reduce the chances of us forgetting to port changes in DB\nconnection setup process from the former to the latter one like it\nhappened e.g. in r17205.\n\nRefs #17258.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17499 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "5a4e63e62a8cde925d5a7b05c44a2ec14853b46e",
    "files": [
        {
            "sha": "aea52f577783777829213ad2990c9311666da778",
            "filename": "django/contrib/gis/db/backends/spatialite/base.py",
            "status": "modified",
            "additions": 1,
            "deletions": 16,
            "changes": 17,
            "blob_url": "https://github.com/django/django/blob/5a4e63e62a8cde925d5a7b05c44a2ec14853b46e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fspatialite%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/5a4e63e62a8cde925d5a7b05c44a2ec14853b46e/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fspatialite%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fspatialite%2Fbase.py?ref=5a4e63e62a8cde925d5a7b05c44a2ec14853b46e",
            "patch": "@@ -38,22 +38,7 @@ def __init__(self, *args, **kwargs):\n \n     def _cursor(self):\n         if self.connection is None:\n-            ## The following is the same as in django.db.backends.sqlite3.base ##\n-            settings_dict = self.settings_dict\n-            if not settings_dict['NAME']:\n-                raise ImproperlyConfigured(\"Please fill out the database NAME in the settings module before using the database.\")\n-            kwargs = {\n-                'database': settings_dict['NAME'],\n-                'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,\n-            }\n-            kwargs.update(settings_dict['OPTIONS'])\n-            self.connection = Database.connect(**kwargs)\n-            # Register extract, date_trunc, and regexp functions.\n-            self.connection.create_function(\"django_extract\", 2, _sqlite_extract)\n-            self.connection.create_function(\"django_date_trunc\", 2, _sqlite_date_trunc)\n-            self.connection.create_function(\"regexp\", 2, _sqlite_regexp)\n-            self.connection.create_function(\"django_format_dtdelta\", 5, _sqlite_format_dtdelta)\n-            connection_created.send(sender=self.__class__, connection=self)\n+            self._sqlite_create_connection()\n \n             ## From here on, customized for GeoDjango ##\n "
        },
        {
            "sha": "f5f0c644e914baabf5781c19f85b3c0ce886c628",
            "filename": "django/db/backends/sqlite3/base.py",
            "status": "modified",
            "additions": 34,
            "deletions": 31,
            "changes": 65,
            "blob_url": "https://github.com/django/django/blob/5a4e63e62a8cde925d5a7b05c44a2ec14853b46e/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/5a4e63e62a8cde925d5a7b05c44a2ec14853b46e/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py?ref=5a4e63e62a8cde925d5a7b05c44a2ec14853b46e",
            "patch": "@@ -230,39 +230,42 @@ def __init__(self, *args, **kwargs):\n         self.introspection = DatabaseIntrospection(self)\n         self.validation = BaseDatabaseValidation(self)\n \n+    def _sqlite_create_connection(self):\n+        settings_dict = self.settings_dict\n+        if not settings_dict['NAME']:\n+            from django.core.exceptions import ImproperlyConfigured\n+            raise ImproperlyConfigured(\"Please fill out the database NAME in the settings module before using the database.\")\n+        kwargs = {\n+            'database': settings_dict['NAME'],\n+            'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,\n+        }\n+        kwargs.update(settings_dict['OPTIONS'])\n+        # Always allow the underlying SQLite connection to be shareable\n+        # between multiple threads. The safe-guarding will be handled at a\n+        # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`\n+        # property. This is necessary as the shareability is disabled by\n+        # default in pysqlite and it cannot be changed once a connection is\n+        # opened.\n+        if 'check_same_thread' in kwargs and kwargs['check_same_thread']:\n+            warnings.warn(\n+                'The `check_same_thread` option was provided and set to '\n+                'True. It will be overriden with False. Use the '\n+                '`DatabaseWrapper.allow_thread_sharing` property instead '\n+                'for controlling thread shareability.',\n+                RuntimeWarning\n+            )\n+        kwargs.update({'check_same_thread': False})\n+        self.connection = Database.connect(**kwargs)\n+        # Register extract, date_trunc, and regexp functions.\n+        self.connection.create_function(\"django_extract\", 2, _sqlite_extract)\n+        self.connection.create_function(\"django_date_trunc\", 2, _sqlite_date_trunc)\n+        self.connection.create_function(\"regexp\", 2, _sqlite_regexp)\n+        self.connection.create_function(\"django_format_dtdelta\", 5, _sqlite_format_dtdelta)\n+        connection_created.send(sender=self.__class__, connection=self)\n+\n     def _cursor(self):\n         if self.connection is None:\n-            settings_dict = self.settings_dict\n-            if not settings_dict['NAME']:\n-                from django.core.exceptions import ImproperlyConfigured\n-                raise ImproperlyConfigured(\"Please fill out the database NAME in the settings module before using the database.\")\n-            kwargs = {\n-                'database': settings_dict['NAME'],\n-                'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,\n-            }\n-            kwargs.update(settings_dict['OPTIONS'])\n-            # Always allow the underlying SQLite connection to be shareable\n-            # between multiple threads. The safe-guarding will be handled at a\n-            # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`\n-            # property. This is necessary as the shareability is disabled by\n-            # default in pysqlite and it cannot be changed once a connection is\n-            # opened.\n-            if 'check_same_thread' in kwargs and kwargs['check_same_thread']:\n-                warnings.warn(\n-                    'The `check_same_thread` option was provided and set to '\n-                    'True. It will be overriden with False. Use the '\n-                    '`DatabaseWrapper.allow_thread_sharing` property instead '\n-                    'for controlling thread shareability.',\n-                    RuntimeWarning\n-                )\n-            kwargs.update({'check_same_thread': False})\n-            self.connection = Database.connect(**kwargs)\n-            # Register extract, date_trunc, and regexp functions.\n-            self.connection.create_function(\"django_extract\", 2, _sqlite_extract)\n-            self.connection.create_function(\"django_date_trunc\", 2, _sqlite_date_trunc)\n-            self.connection.create_function(\"regexp\", 2, _sqlite_regexp)\n-            self.connection.create_function(\"django_format_dtdelta\", 5, _sqlite_format_dtdelta)\n-            connection_created.send(sender=self.__class__, connection=self)\n+            self._sqlite_create_connection()\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n     def check_constraints(self, table_names=None):"
        }
    ],
    "stats": {
        "total": 82,
        "additions": 35,
        "deletions": 47
    }
}