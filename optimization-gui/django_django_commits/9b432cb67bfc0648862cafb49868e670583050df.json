{
    "author": "carljm",
    "message": "Fixed #5768 -- Added support for ManyToManyFields and reverse relations in values() and values_list(). Thanks to mrmachine for the patch.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@14655 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "9b432cb67bfc0648862cafb49868e670583050df",
    "files": [
        {
            "sha": "9b19ec1cafe321869002817f58eded3bcbcf1f55",
            "filename": "django/db/models/query.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/9b432cb67bfc0648862cafb49868e670583050df/django%2Fdb%2Fmodels%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/9b432cb67bfc0648862cafb49868e670583050df/django%2Fdb%2Fmodels%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fquery.py?ref=9b432cb67bfc0648862cafb49868e670583050df",
            "patch": "@@ -870,7 +870,7 @@ def _setup_query(self):\n         self.query.select = []\n         if self.extra_names is not None:\n             self.query.set_extra_mask(self.extra_names)\n-        self.query.add_fields(self.field_names, False)\n+        self.query.add_fields(self.field_names, True)\n         if self.aggregate_names is not None:\n             self.query.set_aggregate_mask(self.aggregate_names)\n "
        },
        {
            "sha": "ccea5884edee64f728583d2f38f8d336dd0aaee5",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 23,
            "deletions": 4,
            "changes": 27,
            "blob_url": "https://github.com/django/django/blob/9b432cb67bfc0648862cafb49868e670583050df/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/9b432cb67bfc0648862cafb49868e670583050df/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=9b432cb67bfc0648862cafb49868e670583050df",
            "patch": "@@ -398,11 +398,8 @@ Example::\n     >>> Blog.objects.values('id', 'name')\n     [{'id': 1, 'name': 'Beatles Blog'}]\n \n-A couple of subtleties that are worth mentioning:\n+A few subtleties that are worth mentioning:\n \n-    * The ``values()`` method does not return anything for\n-      :class:`~django.db.models.ManyToManyField` attributes and will raise an\n-      error if you try to pass in this type of field to it.\n     * If you have a field called ``foo`` that is a\n       :class:`~django.db.models.ForeignKey`, the default ``values()`` call\n       will return a dictionary key called ``foo_id``, since this is the name\n@@ -453,6 +450,28 @@ followed (optionally) by any output-affecting methods (such as ``values()``),\n but it doesn't really matter. This is your chance to really flaunt your\n individualism.\n \n+.. versionchanged:: 1.3\n+\n+The ``values()`` method previously did not return anything for\n+:class:`~django.db.models.ManyToManyField` attributes and would raise an error\n+if you tried to pass this type of field to it.\n+\n+This restriction has been lifted, and you can now also refer to fields on\n+related models with reverse relations through ``OneToOneField``, ``ForeignKey``\n+and ``ManyToManyField`` attributes::\n+\n+\tBlog.objects.values('name', 'entry__headline')\n+\t[{'name': 'My blog', 'entry__headline': 'An entry'},\n+         {'name': 'My blog', 'entry__headline': 'Another entry'}, ...]\n+\n+.. warning::\n+\n+   Because :class:`~django.db.models.ManyToManyField` attributes and reverse\n+   relations can have multiple related rows, including these can have a\n+   multiplier effect on the size of your result set. This will be especially\n+   pronounced if you include multiple such fields in your ``values()`` query,\n+   in which case all possible combinations will be returned.\n+\n ``values_list(*fields)``\n ~~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "d8075318501c6c0223ffe9bdd836104e3dfaa50f",
            "filename": "tests/modeltests/lookup/models.py",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/9b432cb67bfc0648862cafb49868e670583050df/tests%2Fmodeltests%2Flookup%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/9b432cb67bfc0648862cafb49868e670583050df/tests%2Fmodeltests%2Flookup%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Flookup%2Fmodels.py?ref=9b432cb67bfc0648862cafb49868e670583050df",
            "patch": "@@ -7,11 +7,23 @@\n from django.db import models, DEFAULT_DB_ALIAS, connection\n from django.conf import settings\n \n+class Author(models.Model):\n+    name = models.CharField(max_length=100)\n+    class Meta:\n+        ordering = ('name', )\n+\n class Article(models.Model):\n     headline = models.CharField(max_length=100)\n     pub_date = models.DateTimeField()\n+    author = models.ForeignKey(Author, blank=True, null=True)\n     class Meta:\n         ordering = ('-pub_date', 'headline')\n \n     def __unicode__(self):\n         return self.headline\n+\n+class Tag(models.Model):\n+    articles = models.ManyToManyField(Article)\n+    name = models.CharField(max_length=100)\n+    class Meta:\n+        ordering = ('name', )"
        },
        {
            "sha": "cf18a83945ae2081e762798a75e5d31e47060b88",
            "filename": "tests/modeltests/lookup/tests.py",
            "status": "modified",
            "additions": 74,
            "deletions": 9,
            "changes": 83,
            "blob_url": "https://github.com/django/django/blob/9b432cb67bfc0648862cafb49868e670583050df/tests%2Fmodeltests%2Flookup%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/9b432cb67bfc0648862cafb49868e670583050df/tests%2Fmodeltests%2Flookup%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Flookup%2Ftests.py?ref=9b432cb67bfc0648862cafb49868e670583050df",
            "patch": "@@ -3,28 +3,43 @@\n from django.core.exceptions import FieldError\n from django.db import connection\n from django.test import TestCase, skipUnlessDBFeature\n-from models import Article\n+from models import Author, Article, Tag\n \n \n class LookupTests(TestCase):\n \n     #def setUp(self):\n     def setUp(self):\n+        # Create a few Authors.\n+        self.au1 = Author(name='Author 1')\n+        self.au1.save()\n+        self.au2 = Author(name='Author 2')\n+        self.au2.save()\n         # Create a couple of Articles.\n-        self.a1 = Article(headline='Article 1', pub_date=datetime(2005, 7, 26))\n+        self.a1 = Article(headline='Article 1', pub_date=datetime(2005, 7, 26), author=self.au1)\n         self.a1.save()\n-        self.a2 = Article(headline='Article 2', pub_date=datetime(2005, 7, 27))\n+        self.a2 = Article(headline='Article 2', pub_date=datetime(2005, 7, 27), author=self.au1)\n         self.a2.save()\n-        self.a3 = Article(headline='Article 3', pub_date=datetime(2005, 7, 27))\n+        self.a3 = Article(headline='Article 3', pub_date=datetime(2005, 7, 27), author=self.au1)\n         self.a3.save()\n-        self.a4 = Article(headline='Article 4', pub_date=datetime(2005, 7, 28))\n+        self.a4 = Article(headline='Article 4', pub_date=datetime(2005, 7, 28), author=self.au1)\n         self.a4.save()\n-        self.a5 = Article(headline='Article 5', pub_date=datetime(2005, 8, 1, 9, 0))\n+        self.a5 = Article(headline='Article 5', pub_date=datetime(2005, 8, 1, 9, 0), author=self.au2)\n         self.a5.save()\n-        self.a6 = Article(headline='Article 6', pub_date=datetime(2005, 8, 1, 8, 0))\n+        self.a6 = Article(headline='Article 6', pub_date=datetime(2005, 8, 1, 8, 0), author=self.au2)\n         self.a6.save()\n-        self.a7 = Article(headline='Article 7', pub_date=datetime(2005, 7, 27))\n+        self.a7 = Article(headline='Article 7', pub_date=datetime(2005, 7, 27), author=self.au2)\n         self.a7.save()\n+        # Create a few Tags.\n+        self.t1 = Tag(name='Tag 1')\n+        self.t1.save()\n+        self.t1.articles.add(self.a1, self.a2, self.a3)\n+        self.t2 = Tag(name='Tag 2')\n+        self.t2.save()\n+        self.t2.articles.add(self.a3, self.a4, self.a5)\n+        self.t3 = Tag(name='Tag 3')\n+        self.t3.save()\n+        self.t3.articles.add(self.a5, self.a6, self.a7)\n \n     def test_exists(self):\n         # We can use .exists() to check that there are some\n@@ -182,6 +197,42 @@ def test_values(self):\n                 'id_plus_seven': self.a1.id + 7,\n                 'id_plus_eight': self.a1.id + 8,\n             }], transform=identity)\n+        # You can specify fields from forward and reverse relations, just like filter().\n+        self.assertQuerysetEqual(\n+            Article.objects.values('headline', 'author__name'),\n+            [\n+                {'headline': self.a5.headline, 'author__name': self.au2.name},\n+                {'headline': self.a6.headline, 'author__name': self.au2.name},\n+                {'headline': self.a4.headline, 'author__name': self.au1.name},\n+                {'headline': self.a2.headline, 'author__name': self.au1.name},\n+                {'headline': self.a3.headline, 'author__name': self.au1.name},\n+                {'headline': self.a7.headline, 'author__name': self.au2.name},\n+                {'headline': self.a1.headline, 'author__name': self.au1.name},\n+            ], transform=identity)\n+        self.assertQuerysetEqual(\n+            Author.objects.values('name', 'article__headline').order_by('name', 'article__headline'),\n+            [\n+                {'name': self.au1.name, 'article__headline': self.a1.headline},\n+                {'name': self.au1.name, 'article__headline': self.a2.headline},\n+                {'name': self.au1.name, 'article__headline': self.a3.headline},\n+                {'name': self.au1.name, 'article__headline': self.a4.headline},\n+                {'name': self.au2.name, 'article__headline': self.a5.headline},\n+                {'name': self.au2.name, 'article__headline': self.a6.headline},\n+                {'name': self.au2.name, 'article__headline': self.a7.headline},\n+            ], transform=identity)\n+        self.assertQuerysetEqual(\n+            Author.objects.values('name', 'article__headline', 'article__tag__name').order_by('name', 'article__headline', 'article__tag__name'),\n+            [\n+                {'name': self.au1.name, 'article__headline': self.a1.headline, 'article__tag__name': self.t1.name},\n+                {'name': self.au1.name, 'article__headline': self.a2.headline, 'article__tag__name': self.t1.name},\n+                {'name': self.au1.name, 'article__headline': self.a3.headline, 'article__tag__name': self.t1.name},\n+                {'name': self.au1.name, 'article__headline': self.a3.headline, 'article__tag__name': self.t2.name},\n+                {'name': self.au1.name, 'article__headline': self.a4.headline, 'article__tag__name': self.t2.name},\n+                {'name': self.au2.name, 'article__headline': self.a5.headline, 'article__tag__name': self.t2.name},\n+                {'name': self.au2.name, 'article__headline': self.a5.headline, 'article__tag__name': self.t3.name},\n+                {'name': self.au2.name, 'article__headline': self.a6.headline, 'article__tag__name': self.t3.name},\n+                {'name': self.au2.name, 'article__headline': self.a7.headline, 'article__tag__name': self.t3.name},\n+            ], transform=identity)\n         # However, an exception FieldDoesNotExist will be thrown if you specify\n         # a non-existent field name in values() (a field that is neither in the\n         # model nor in extra(select)).\n@@ -192,6 +243,7 @@ def test_values(self):\n         self.assertQuerysetEqual(Article.objects.filter(id=self.a5.id).values(),\n             [{\n                 'id': self.a5.id,\n+                'author_id': self.au2.id, \n                 'headline': 'Article 5',\n                 'pub_date': datetime(2005, 8, 1, 9, 0)\n             }], transform=identity)\n@@ -250,6 +302,19 @@ def test_values_list(self):\n                 (self.a7.id, self.a7.id+1)\n             ],\n             transform=identity)\n+        self.assertQuerysetEqual(\n+            Author.objects.values_list('name', 'article__headline', 'article__tag__name').order_by('name', 'article__headline', 'article__tag__name'),\n+            [\n+                (self.au1.name, self.a1.headline, self.t1.name),\n+                (self.au1.name, self.a2.headline, self.t1.name),\n+                (self.au1.name, self.a3.headline, self.t1.name),\n+                (self.au1.name, self.a3.headline, self.t2.name),\n+                (self.au1.name, self.a4.headline, self.t2.name),\n+                (self.au2.name, self.a5.headline, self.t2.name),\n+                (self.au2.name, self.a5.headline, self.t3.name),\n+                (self.au2.name, self.a6.headline, self.t3.name),\n+                (self.au2.name, self.a7.headline, self.t3.name),\n+            ], transform=identity)\n         self.assertRaises(TypeError, Article.objects.values_list, 'id', 'headline', flat=True)\n \n     def test_get_next_previous_by(self):\n@@ -402,7 +467,7 @@ def test_error_messages(self):\n             self.fail('FieldError not raised')\n         except FieldError, ex:\n             self.assertEqual(str(ex), \"Cannot resolve keyword 'pub_date_year' \"\n-                             \"into field. Choices are: headline, id, pub_date\")\n+                             \"into field. Choices are: author, headline, id, pub_date, tag\")\n         try:\n             Article.objects.filter(headline__starts='Article')\n             self.fail('FieldError not raised')"
        }
    ],
    "stats": {
        "total": 124,
        "additions": 110,
        "deletions": 14
    }
}