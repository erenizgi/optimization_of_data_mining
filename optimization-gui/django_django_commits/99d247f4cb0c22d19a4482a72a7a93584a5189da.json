{
    "author": "freakboy3742",
    "message": "Fixed #13795 -- Added a site-wide cache prefix and cache versioning. Thanks to bruth for the patch.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@14623 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "99d247f4cb0c22d19a4482a72a7a93584a5189da",
    "files": [
        {
            "sha": "599200ad0bc23922bd90c197afb64fef67e6b08d",
            "filename": "django/conf/global_settings.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fconf%2Fglobal_settings.py",
            "raw_url": "https://github.com/django/django/raw/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fconf%2Fglobal_settings.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fconf%2Fglobal_settings.py?ref=99d247f4cb0c22d19a4482a72a7a93584a5189da",
            "patch": "@@ -433,6 +433,9 @@\n # The cache backend to use.  See the docstring in django.core.cache for the\n # possible values.\n CACHE_BACKEND = 'locmem://'\n+CACHE_VERSION = 1\n+CACHE_KEY_PREFIX = ''\n+CACHE_KEY_FUNCTION = None\n CACHE_MIDDLEWARE_KEY_PREFIX = ''\n CACHE_MIDDLEWARE_SECONDS = 600\n "
        },
        {
            "sha": "d26eabd0c38a1b4601e9d77cf8035b46282a3376",
            "filename": "django/core/cache/__init__.py",
            "status": "modified",
            "additions": 15,
            "deletions": 3,
            "changes": 18,
            "blob_url": "https://github.com/django/django/blob/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2F__init__.py?ref=99d247f4cb0c22d19a4482a72a7a93584a5189da",
            "patch": "@@ -67,18 +67,30 @@ def parse_backend_uri(backend_uri):\n \n     return scheme, host, params\n \n-def get_cache(backend_uri):\n+def get_cache(backend_uri, key_prefix=None, version=None, key_func=None):\n+    if key_prefix is None:\n+        key_prefix = settings.CACHE_KEY_PREFIX\n+    if version is None:\n+        version = settings.CACHE_VERSION\n+    if key_func is None:\n+        key_func = settings.CACHE_KEY_FUNCTION\n+\n+    if key_func is not None and not callable(key_func):\n+        key_func_module_path, key_func_name = key_func.rsplit('.', 1)\n+        key_func_module = importlib.import_module(key_func_module_path)\n+        key_func = getattr(key_func_module, key_func_name)\n+\n     scheme, host, params = parse_backend_uri(backend_uri)\n     if scheme in BACKENDS:\n         name = 'django.core.cache.backends.%s' % BACKENDS[scheme]\n     else:\n         name = scheme\n     module = importlib.import_module(name)\n-    return module.CacheClass(host, params)\n+    return module.CacheClass(host, params, key_prefix=key_prefix, version=version, key_func=key_func)\n \n cache = get_cache(settings.CACHE_BACKEND)\n \n-# Some caches -- pythont-memcached in particular -- need to do a cleanup at the\n+# Some caches -- python-memcached in particular -- need to do a cleanup at the\n # end of a request cycle. If the cache provides a close() method, wire it up\n # here.\n if hasattr(cache, 'close'):"
        },
        {
            "sha": "1296a853a5506477861f1e07842b9d7402b00f7a",
            "filename": "django/core/cache/backends/base.py",
            "status": "modified",
            "additions": 68,
            "deletions": 19,
            "changes": 87,
            "blob_url": "https://github.com/django/django/blob/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2Fbackends%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2Fbackends%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Fbase.py?ref=99d247f4cb0c22d19a4482a72a7a93584a5189da",
            "patch": "@@ -3,6 +3,7 @@\n import warnings\n \n from django.core.exceptions import ImproperlyConfigured, DjangoRuntimeWarning\n+from django.utils.encoding import smart_str\n \n class InvalidCacheBackendError(ImproperlyConfigured):\n     pass\n@@ -13,8 +14,17 @@ class CacheKeyWarning(DjangoRuntimeWarning):\n # Memcached does not accept keys longer than this.\n MEMCACHE_MAX_KEY_LENGTH = 250\n \n+def default_key_func(key, key_prefix, version):\n+    \"\"\"Default function to generate keys.\n+\n+    Constructs the key used by all other methods. By default it prepends\n+    the `key_prefix'. CACHE_KEY_FUNCTION can be used to specify an alternate\n+    function with custom key making behavior.\n+    \"\"\"\n+    return ':'.join([key_prefix, str(version), smart_str(key)])\n+\n class BaseCache(object):\n-    def __init__(self, params):\n+    def __init__(self, params, key_prefix='', version=1, key_func=None):\n         timeout = params.get('timeout', 300)\n         try:\n             timeout = int(timeout)\n@@ -34,7 +44,25 @@ def __init__(self, params):\n         except (ValueError, TypeError):\n             self._cull_frequency = 3\n \n-    def add(self, key, value, timeout=None):\n+        self.key_prefix = smart_str(key_prefix)\n+        self.version = version\n+        self.key_func = key_func or default_key_func\n+\n+    def make_key(self, key, version=None):\n+        \"\"\"Constructs the key used by all other methods. By default it\n+        uses the key_func to generate a key (which, by default,\n+        prepends the `key_prefix' and 'version'). An different key\n+        function can be provided at the time of cache construction;\n+        alternatively, you can subclass the cache backend to provide\n+        custom key making behavior.\n+        \"\"\"\n+        if version is None:\n+            version = self.version\n+\n+        new_key = self.key_func(key, self.key_prefix, version)\n+        return new_key\n+\n+    def add(self, key, value, timeout=None, version=None):\n         \"\"\"\n         Set a value in the cache if the key does not already exist. If\n         timeout is given, that timeout will be used for the key; otherwise\n@@ -44,27 +72,27 @@ def add(self, key, value, timeout=None):\n         \"\"\"\n         raise NotImplementedError\n \n-    def get(self, key, default=None):\n+    def get(self, key, default=None, version=None):\n         \"\"\"\n         Fetch a given key from the cache. If the key does not exist, return\n         default, which itself defaults to None.\n         \"\"\"\n         raise NotImplementedError\n \n-    def set(self, key, value, timeout=None):\n+    def set(self, key, value, timeout=None, version=None):\n         \"\"\"\n         Set a value in the cache. If timeout is given, that timeout will be\n         used for the key; otherwise the default cache timeout will be used.\n         \"\"\"\n         raise NotImplementedError\n \n-    def delete(self, key):\n+    def delete(self, key, version=None):\n         \"\"\"\n         Delete a key from the cache, failing silently.\n         \"\"\"\n         raise NotImplementedError\n \n-    def get_many(self, keys):\n+    def get_many(self, keys, version=None):\n         \"\"\"\n         Fetch a bunch of keys from the cache. For certain backends (memcached,\n         pgsql) this can be *much* faster when fetching multiple values.\n@@ -74,34 +102,35 @@ def get_many(self, keys):\n         \"\"\"\n         d = {}\n         for k in keys:\n-            val = self.get(k)\n+            val = self.get(k, version=version)\n             if val is not None:\n                 d[k] = val\n         return d\n \n-    def has_key(self, key):\n+    def has_key(self, key, version=None):\n         \"\"\"\n         Returns True if the key is in the cache and has not expired.\n         \"\"\"\n-        return self.get(key) is not None\n+        return self.get(key, version=version) is not None\n \n-    def incr(self, key, delta=1):\n+    def incr(self, key, delta=1, version=None):\n         \"\"\"\n         Add delta to value in the cache. If the key does not exist, raise a\n         ValueError exception.\n         \"\"\"\n-        if key not in self:\n+        value = self.get(key, version=version)\n+        if value is None:\n             raise ValueError(\"Key '%s' not found\" % key)\n-        new_value = self.get(key) + delta\n-        self.set(key, new_value)\n+        new_value = value + delta\n+        self.set(key, new_value, version=version)\n         return new_value\n \n-    def decr(self, key, delta=1):\n+    def decr(self, key, delta=1, version=None):\n         \"\"\"\n         Subtract delta from value in the cache. If the key does not exist, raise\n         a ValueError exception.\n         \"\"\"\n-        return self.incr(key, -delta)\n+        return self.incr(key, -delta, version=version)\n \n     def __contains__(self, key):\n         \"\"\"\n@@ -112,7 +141,7 @@ def __contains__(self, key):\n         # if a subclass overrides it.\n         return self.has_key(key)\n \n-    def set_many(self, data, timeout=None):\n+    def set_many(self, data, timeout=None, version=None):\n         \"\"\"\n         Set a bunch of values in the cache at once from a dict of key/value\n         pairs.  For certain backends (memcached), this is much more efficient\n@@ -122,16 +151,16 @@ def set_many(self, data, timeout=None):\n         the default cache timeout will be used.\n         \"\"\"\n         for key, value in data.items():\n-            self.set(key, value, timeout)\n+            self.set(key, value, timeout=timeout, version=version)\n \n-    def delete_many(self, keys):\n+    def delete_many(self, keys, version=None):\n         \"\"\"\n         Set a bunch of values in the cache at once.  For certain backends\n         (memcached), this is much more efficient than calling delete() multiple\n         times.\n         \"\"\"\n         for key in keys:\n-            self.delete(key)\n+            self.delete(key, version=version)\n \n     def clear(self):\n         \"\"\"Remove *all* values from the cache at once.\"\"\"\n@@ -154,3 +183,23 @@ def validate_key(self, key):\n                         'errors if used with memcached: %r' % key,\n                               CacheKeyWarning)\n \n+    def incr_version(self, key, delta=1, version=None):\n+        \"\"\"Adds delta to the cache version for the supplied key. Returns the\n+        new version.\n+        \"\"\"\n+        if version is None:\n+            version = self.version\n+\n+        value = self.get(key, version=version)\n+        if value is None:\n+            raise ValueError(\"Key '%s' not found\" % key)\n+\n+        self.set(key, value, version=version+delta)\n+        self.delete(key, version=version)\n+        return version+delta\n+\n+    def decr_version(self, key, delta=1, version=None):\n+        \"\"\"Substracts delta from the cache version for the supplied key. Returns\n+        the new version.\n+        \"\"\"\n+        return self.incr_version(key, -delta, version)"
        },
        {
            "sha": "68cd2e015edafcefd208a65b92d928669e08245d",
            "filename": "django/core/cache/backends/db.py",
            "status": "modified",
            "additions": 14,
            "deletions": 7,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2Fbackends%2Fdb.py",
            "raw_url": "https://github.com/django/django/raw/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2Fbackends%2Fdb.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Fdb.py?ref=99d247f4cb0c22d19a4482a72a7a93584a5189da",
            "patch": "@@ -26,16 +26,17 @@ def __init__(self, table):\n         self.proxy = False\n \n class BaseDatabaseCacheClass(BaseCache):\n-    def __init__(self, table, params):\n-        BaseCache.__init__(self, params)\n+    def __init__(self, table, params, key_prefix='', version=1, key_func=None):\n+        BaseCache.__init__(self, params, key_prefix, version, key_func)\n         self._table = table\n \n         class CacheEntry(object):\n             _meta = Options(table)\n         self.cache_model_class = CacheEntry\n \n class CacheClass(BaseDatabaseCacheClass):\n-    def get(self, key, default=None):\n+    def get(self, key, default=None, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n         db = router.db_for_read(self.cache_model_class)\n         table = connections[db].ops.quote_name(self._table)\n@@ -55,11 +56,13 @@ def get(self, key, default=None):\n         value = connections[db].ops.process_clob(row[1])\n         return pickle.loads(base64.decodestring(value))\n \n-    def set(self, key, value, timeout=None):\n+    def set(self, key, value, timeout=None, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n         self._base_set('set', key, value, timeout)\n \n-    def add(self, key, value, timeout=None):\n+    def add(self, key, value, timeout=None, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n         return self._base_set('add', key, value, timeout)\n \n@@ -95,17 +98,21 @@ def _base_set(self, mode, key, value, timeout=None):\n             transaction.commit_unless_managed(using=db)\n             return True\n \n-    def delete(self, key):\n+    def delete(self, key, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n+\n         db = router.db_for_write(self.cache_model_class)\n         table = connections[db].ops.quote_name(self._table)\n         cursor = connections[db].cursor()\n \n         cursor.execute(\"DELETE FROM %s WHERE cache_key = %%s\" % table, [key])\n         transaction.commit_unless_managed(using=db)\n \n-    def has_key(self, key):\n+    def has_key(self, key, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n+\n         db = router.db_for_read(self.cache_model_class)\n         table = connections[db].ops.quote_name(self._table)\n         cursor = connections[db].cursor()"
        },
        {
            "sha": "7d90ddace4243f4540a23f1ac65a99052165b9a4",
            "filename": "django/core/cache/backends/dummy.py",
            "status": "modified",
            "additions": 15,
            "deletions": 10,
            "changes": 25,
            "blob_url": "https://github.com/django/django/blob/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2Fbackends%2Fdummy.py",
            "raw_url": "https://github.com/django/django/raw/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2Fbackends%2Fdummy.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Fdummy.py?ref=99d247f4cb0c22d19a4482a72a7a93584a5189da",
            "patch": "@@ -3,34 +3,39 @@\n from django.core.cache.backends.base import BaseCache\n \n class CacheClass(BaseCache):\n-    def __init__(self, *args, **kwargs):\n-        pass\n+    def __init__(self, host, *args, **kwargs):\n+        BaseCache.__init__(self, *args, **kwargs)\n \n-    def add(self, key, *args, **kwargs):\n+    def add(self, key, value, timeout=None, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n         return True\n \n-    def get(self, key, default=None):\n+    def get(self, key, default=None, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n         return default\n \n-    def set(self, key, *args, **kwargs):\n+    def set(self, key, value, timeout=None, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n \n-    def delete(self, key, *args, **kwargs):\n+    def delete(self, key, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n \n-    def get_many(self, *args, **kwargs):\n+    def get_many(self, keys, version=None):\n         return {}\n \n-    def has_key(self, key, *args, **kwargs):\n+    def has_key(self, key, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n         return False\n \n-    def set_many(self, *args, **kwargs):\n+    def set_many(self, data, version=None):\n         pass\n \n-    def delete_many(self, *args, **kwargs):\n+    def delete_many(self, keys, version=None):\n         pass\n \n     def clear(self):"
        },
        {
            "sha": "1f95faf5ee9b61c06657c35fe5551cded6204ebf",
            "filename": "django/core/cache/backends/filebased.py",
            "status": "modified",
            "additions": 16,
            "deletions": 11,
            "changes": 27,
            "blob_url": "https://github.com/django/django/blob/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2Fbackends%2Ffilebased.py",
            "raw_url": "https://github.com/django/django/raw/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2Fbackends%2Ffilebased.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Ffilebased.py?ref=99d247f4cb0c22d19a4482a72a7a93584a5189da",
            "patch": "@@ -12,22 +12,23 @@\n from django.utils.hashcompat import md5_constructor\n \n class CacheClass(BaseCache):\n-    def __init__(self, dir, params):\n-        BaseCache.__init__(self, params)\n+    def __init__(self, dir, params, key_prefix='', version=1, key_func=None):\n+        BaseCache.__init__(self, params, key_prefix, version, key_func)\n         self._dir = dir\n         if not os.path.exists(self._dir):\n             self._createdir()\n \n-    def add(self, key, value, timeout=None):\n-        self.validate_key(key)\n-        if self.has_key(key):\n+    def add(self, key, value, timeout=None, version=None):\n+        if self.has_key(key, version=version):\n             return False\n \n-        self.set(key, value, timeout)\n+        self.set(key, value, timeout, version=version)\n         return True\n \n-    def get(self, key, default=None):\n+    def get(self, key, default=None, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n+\n         fname = self._key_to_file(key)\n         try:\n             f = open(fname, 'rb')\n@@ -44,8 +45,10 @@ def get(self, key, default=None):\n             pass\n         return default\n \n-    def set(self, key, value, timeout=None):\n+    def set(self, key, value, timeout=None, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n+\n         fname = self._key_to_file(key)\n         dirname = os.path.dirname(fname)\n \n@@ -68,7 +71,8 @@ def set(self, key, value, timeout=None):\n         except (IOError, OSError):\n             pass\n \n-    def delete(self, key):\n+    def delete(self, key, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n         try:\n             self._delete(self._key_to_file(key))\n@@ -85,7 +89,8 @@ def _delete(self, fname):\n         except (IOError, OSError):\n             pass\n \n-    def has_key(self, key):\n+    def has_key(self, key, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n         fname = self._key_to_file(key)\n         try:\n@@ -140,7 +145,7 @@ def _key_to_file(self, key):\n         Thus, a cache key of \"foo\" gets turnned into a file named\n         ``{cache-dir}ac/bd/18db4cc2f85cedef654fccc4a4d8``.\n         \"\"\"\n-        path = md5_constructor(key.encode('utf-8')).hexdigest()\n+        path = md5_constructor(key).hexdigest()\n         path = os.path.join(path[:2], path[2:4], path[4:])\n         return os.path.join(self._dir, path)\n "
        },
        {
            "sha": "17fd8f33ce7c50f161af61151ecaf408a5131e90",
            "filename": "django/core/cache/backends/locmem.py",
            "status": "modified",
            "additions": 12,
            "deletions": 7,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2Fbackends%2Flocmem.py",
            "raw_url": "https://github.com/django/django/raw/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2Fbackends%2Flocmem.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Flocmem.py?ref=99d247f4cb0c22d19a4482a72a7a93584a5189da",
            "patch": "@@ -10,13 +10,14 @@\n from django.utils.synch import RWLock\n \n class CacheClass(BaseCache):\n-    def __init__(self, _, params):\n-        BaseCache.__init__(self, params)\n+    def __init__(self, _, params, key_prefix='', version=1, key_func=None):\n+        BaseCache.__init__(self, params, key_prefix, version, key_func)\n         self._cache = {}\n         self._expire_info = {}\n         self._lock = RWLock()\n \n-    def add(self, key, value, timeout=None):\n+    def add(self, key, value, timeout=None, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n         self._lock.writer_enters()\n         try:\n@@ -31,7 +32,8 @@ def add(self, key, value, timeout=None):\n         finally:\n             self._lock.writer_leaves()\n \n-    def get(self, key, default=None):\n+    def get(self, key, default=None, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n         self._lock.reader_enters()\n         try:\n@@ -64,7 +66,8 @@ def _set(self, key, value, timeout=None):\n         self._cache[key] = value\n         self._expire_info[key] = time.time() + timeout\n \n-    def set(self, key, value, timeout=None):\n+    def set(self, key, value, timeout=None, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n         self._lock.writer_enters()\n         # Python 2.4 doesn't allow combined try-except-finally blocks.\n@@ -76,7 +79,8 @@ def set(self, key, value, timeout=None):\n         finally:\n             self._lock.writer_leaves()\n \n-    def has_key(self, key):\n+    def has_key(self, key, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n         self._lock.reader_enters()\n         try:\n@@ -117,7 +121,8 @@ def _delete(self, key):\n         except KeyError:\n             pass\n \n-    def delete(self, key):\n+    def delete(self, key, version=None):\n+        key = self.make_key(key, version=version)\n         self.validate_key(key)\n         self._lock.writer_enters()\n         try:"
        },
        {
            "sha": "4bd854708503ec90b1255b950f6f87dc9ed4d031",
            "filename": "django/core/cache/backends/memcached.py",
            "status": "modified",
            "additions": 36,
            "deletions": 21,
            "changes": 57,
            "blob_url": "https://github.com/django/django/blob/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2Fbackends%2Fmemcached.py",
            "raw_url": "https://github.com/django/django/raw/99d247f4cb0c22d19a4482a72a7a93584a5189da/django%2Fcore%2Fcache%2Fbackends%2Fmemcached.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Fmemcached.py?ref=99d247f4cb0c22d19a4482a72a7a93584a5189da",
            "patch": "@@ -3,7 +3,6 @@\n import time\n \n from django.core.cache.backends.base import BaseCache, InvalidCacheBackendError\n-from django.utils.encoding import smart_unicode, smart_str\n \n try:\n     import cmemcache as memcache\n@@ -19,8 +18,8 @@\n         raise InvalidCacheBackendError(\"Memcached cache backend requires either the 'memcache' or 'cmemcache' library\")\n \n class CacheClass(BaseCache):\n-    def __init__(self, server, params):\n-        BaseCache.__init__(self, params)\n+    def __init__(self, server, params, key_prefix='', version=1, key_func=None):\n+        BaseCache.__init__(self, params, key_prefix, version, key_func)\n         self._cache = memcache.Client(server.split(';'))\n \n     def _get_memcache_timeout(self, timeout):\n@@ -39,30 +38,43 @@ def _get_memcache_timeout(self, timeout):\n             timeout += int(time.time())\n         return timeout\n \n-    def add(self, key, value, timeout=0):\n+    def add(self, key, value, timeout=0, version=None):\n+        key = self.make_key(key, version=version)\n         if isinstance(value, unicode):\n             value = value.encode('utf-8')\n-        return self._cache.add(smart_str(key), value, self._get_memcache_timeout(timeout))\n+        return self._cache.add(key, value, self._get_memcache_timeout(timeout))\n \n-    def get(self, key, default=None):\n-        val = self._cache.get(smart_str(key))\n+    def get(self, key, default=None, version=None):\n+        key = self.make_key(key, version=version)\n+        val = self._cache.get(key)\n         if val is None:\n             return default\n         return val\n \n-    def set(self, key, value, timeout=0):\n-        self._cache.set(smart_str(key), value, self._get_memcache_timeout(timeout))\n-\n-    def delete(self, key):\n-        self._cache.delete(smart_str(key))\n-\n-    def get_many(self, keys):\n-        return self._cache.get_multi(map(smart_str,keys))\n+    def set(self, key, value, timeout=0, version=None):\n+        key = self.make_key(key, version=version)\n+        self._cache.set(key, value, self._get_memcache_timeout(timeout))\n+\n+    def delete(self, key, version=None):\n+        key = self.make_key(key, version=version)\n+        self._cache.delete(key)\n+\n+    def get_many(self, keys, version=None):\n+        new_keys = map(lambda x: self.make_key(x, version=version), keys)\n+        ret = self._cache.get_multi(new_keys)\n+        if ret:\n+            _ = {}\n+            m = dict(zip(new_keys, keys))\n+            for k, v in ret.items():\n+                _[m[k]] = v\n+            ret = _\n+        return ret\n \n     def close(self, **kwargs):\n         self._cache.disconnect_all()\n \n-    def incr(self, key, delta=1):\n+    def incr(self, key, delta=1, version=None):\n+        key = self.make_key(key, version=version)\n         try:\n             val = self._cache.incr(key, delta)\n \n@@ -76,7 +88,8 @@ def incr(self, key, delta=1):\n \n         return val\n \n-    def decr(self, key, delta=1):\n+    def decr(self, key, delta=1, version=None):\n+        key = self.make_key(key, version=version)\n         try:\n             val = self._cache.decr(key, delta)\n \n@@ -89,16 +102,18 @@ def decr(self, key, delta=1):\n             raise ValueError(\"Key '%s' not found\" % key)\n         return val\n \n-    def set_many(self, data, timeout=0):\n+    def set_many(self, data, timeout=0, version=None):\n         safe_data = {}\n         for key, value in data.items():\n+            key = self.make_key(key, version=version)\n             if isinstance(value, unicode):\n                 value = value.encode('utf-8')\n-            safe_data[smart_str(key)] = value\n+            safe_data[key] = value\n         self._cache.set_multi(safe_data, self._get_memcache_timeout(timeout))\n \n-    def delete_many(self, keys):\n-        self._cache.delete_multi(map(smart_str, keys))\n+    def delete_many(self, keys, version=None):\n+        l = lambda x: self.make_key(x, version=version)\n+        self._cache.delete_multi(map(l, keys))\n \n     def clear(self):\n         self._cache.flush_all()"
        },
        {
            "sha": "87219b228a60e11c747b53cb7823fd8c6e2d0749",
            "filename": "docs/ref/settings.txt",
            "status": "modified",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/django/django/blob/99d247f4cb0c22d19a4482a72a7a93584a5189da/docs%2Fref%2Fsettings.txt",
            "raw_url": "https://github.com/django/django/raw/99d247f4cb0c22d19a4482a72a7a93584a5189da/docs%2Fref%2Fsettings.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fsettings.txt?ref=99d247f4cb0c22d19a4482a72a7a93584a5189da",
            "patch": "@@ -136,6 +136,25 @@ Default: ``'locmem://'``\n \n The cache backend to use. See :doc:`/topics/cache`.\n \n+.. setting:: CACHE_KEY_FUNCTION\n+\n+CACHE_KEY_FUNCTION\n+------------------\n+\n+Default: ``None``\n+\n+A string containing a dotted path to a function that defines how to\n+compose a prefix, version and key into a final cache key. The default\n+implementation is equivalent to the function::\n+\n+    def make_key(key, key_prefix, version):\n+        return ':'.join([key_prefix, str(version), smart_str(key)])\n+\n+You may use any key function you want, as long as it has the same\n+argument signature.\n+\n+See the :ref:`cache documentation <cache_key_transformation>` for more information.\n+\n .. setting:: CACHE_MIDDLEWARE_ANONYMOUS_ONLY\n \n CACHE_MIDDLEWARE_ANONYMOUS_ONLY\n@@ -172,6 +191,30 @@ Default: ``600``\n The default number of seconds to cache a page when the caching middleware or\n ``cache_page()`` decorator is used.\n \n+.. setting:: CACHE_PREFIX\n+\n+CACHE_PREFIX\n+------------\n+\n+Default: ``''`` (Empty string)\n+\n+A string that will be automatically included (prepended by default) to\n+all cache keys used by the Django server.\n+\n+See the :ref:`cache documentation <cache_key_prefixing>` for more information.\n+\n+.. setting:: CACHE_VERSION\n+\n+CACHE_VERSION\n+-------------\n+\n+Default: ``1``\n+\n+The default version number for cache keys generated by the Django server.\n+\n+See the :ref:`cache documentation <cache_versioning>` for more information.\n+\n+\n .. setting:: CSRF_COOKIE_DOMAIN\n \n CSRF_COOKIE_DOMAIN"
        },
        {
            "sha": "ed72b94ab22f51f6e2a76fdf15c2945f7e11b01d",
            "filename": "docs/releases/1.3.txt",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/99d247f4cb0c22d19a4482a72a7a93584a5189da/docs%2Freleases%2F1.3.txt",
            "raw_url": "https://github.com/django/django/raw/99d247f4cb0c22d19a4482a72a7a93584a5189da/docs%2Freleases%2F1.3.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.3.txt?ref=99d247f4cb0c22d19a4482a72a7a93584a5189da",
            "patch": "@@ -155,6 +155,9 @@ requests. These include:\n       :meth:`~django.test.client.Client.assertNumQueries` -- making it\n       easier to test the database activity associated with a view.\n \n+    * :ref:`Versioning <cache_versioning>`, :ref:`site-wide prefixing\n+      <cache_key_prefixing>` and :ref:`transformation\n+      <cache_key_transformation>` has been added to the cache API.\n \n .. _backwards-incompatible-changes-1.3:\n "
        },
        {
            "sha": "a98762f11adce6cfa6878611058524e1a16acb34",
            "filename": "docs/topics/cache.txt",
            "status": "modified",
            "additions": 95,
            "deletions": 0,
            "changes": 95,
            "blob_url": "https://github.com/django/django/blob/99d247f4cb0c22d19a4482a72a7a93584a5189da/docs%2Ftopics%2Fcache.txt",
            "raw_url": "https://github.com/django/django/raw/99d247f4cb0c22d19a4482a72a7a93584a5189da/docs%2Ftopics%2Fcache.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fcache.txt?ref=99d247f4cb0c22d19a4482a72a7a93584a5189da",
            "patch": "@@ -643,6 +643,101 @@ nonexistent cache key.::\n     However, if the backend doesn't natively provide an increment/decrement\n     operation, it will be implemented using a two-step retrieve/update.\n \n+.. _cache_key_prefixing:\n+\n+Cache key prefixing\n+-------------------\n+\n+.. versionadded:: 1.3\n+\n+If you are sharing a cache instance between servers, or between your\n+production and development environments, it's possible for data cached\n+by one server to be used by another server. If the format of cached\n+data is different between servers, this can lead to some very hard to\n+diagnose problems.\n+\n+To prevent this, Django provides the ability to prefix all cache keys\n+used by a server. When a particular cache key is saved or retrieved,\n+Django will automatically prefix the cache key with the value of the\n+:setting:`CACHE_KEY_PREFIX` setting.\n+\n+By ensuring each Django instance has a different\n+:setting:`CACHE_KEY_PREFIX`, you can ensure that there will be no\n+collisions in cache values.\n+\n+.. _cache_versioning:\n+\n+Cache versioning\n+----------------\n+\n+.. versionadded:: 1.3\n+\n+When you change running code that uses cached values, you may need to\n+purge any existing cached values. The easiest way to do this is to\n+flush the entire cache, but this can lead to the loss of cache values\n+that are still valid and useful.\n+\n+Django provides a better way to target individual cache values.\n+Django's cache framework has a system-wide version identifier,\n+specified using the :setting:`CACHE_VERSION` setting. The value of\n+this setting is automatically combined with the cache prefix and the\n+user-provided cache key to obtain the final cache key.\n+\n+By default, any key request will automatically include the site\n+default cache key version. However, the primitive cache functions all\n+include a ``version`` argument, so you can specify a particular cache\n+key version to set or get. For example::\n+\n+    # Set version 2 of a cache key\n+    >>> cache.set('my_key', 'hello world!', version=2)\n+    # Get the default version (assuming version=1)\n+    >>> cache.get('my_key')\n+    None\n+    # Get version 2 of the same key\n+    >>> cache.get('my_key', version=2)\n+    'hello world!'\n+\n+The version of a specific key can be incremented and decremented using\n+the :func:`incr_version()` and :func:`decr_version()` methods. This\n+enables specific keys to be bumped to a new version, leaving other\n+keys unaffected. Continuing our previous example::\n+\n+    # Increment the version of 'my_key'\n+    >>> cache.incr_version('my_key')\n+    # The default version still isn't available\n+    >>> cache.get('my_key')\n+    None\n+    # Version 2 isn't available, either\n+    >>> cache.get('my_key', version=2)\n+    None\n+    # But version 3 *is* availble\n+    >>> cache.get('my_key', version=3)\n+    'hello world!'\n+\n+.. _cache_key_transformation:\n+\n+Cache key transformation\n+------------------------\n+\n+.. versionadded:: 1.3\n+\n+As described in the previous two sections, the cache key provided by a\n+user is not used verbatim -- it is combined with the cache prefix and\n+key version to provide a final cache key. By default, the three parts\n+are joined using colons to produce a final string::\n+\n+    def make_key(key, key_prefix, version):\n+        return ':'.join([key_prefix, str(version), smart_str(key)])\n+\n+If you want to combine the parts in different ways, or apply other\n+processing to the final key (e.g., taking a hash digest of the key\n+parts), you can provide a custom key function.\n+\n+The setting :setting:`CACHE_KEY_FUNCTION` specifies a dotted-path to\n+a function matching the prototype of :func:`make_key()` above. If\n+provided, this custom key function will be used instead of the default\n+key combining function.\n+\n Cache key warnings\n ------------------\n "
        },
        {
            "sha": "82ab47c6c4fddf455add8bcede4636a334055847",
            "filename": "tests/regressiontests/cache/tests.py",
            "status": "modified",
            "additions": 376,
            "deletions": 9,
            "changes": 385,
            "blob_url": "https://github.com/django/django/blob/99d247f4cb0c22d19a4482a72a7a93584a5189da/tests%2Fregressiontests%2Fcache%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/99d247f4cb0c22d19a4482a72a7a93584a5189da/tests%2Fregressiontests%2Fcache%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fcache%2Ftests.py?ref=99d247f4cb0c22d19a4482a72a7a93584a5189da",
            "patch": "@@ -145,11 +145,21 @@ def test_clear(self):\n         \"clear does nothing for the dummy cache backend\"\n         self.cache.clear()\n \n+    def test_incr_version(self):\n+        \"Dummy cache versions can't be incremented\"\n+        self.cache.set('answer', 42)\n+        self.assertRaises(ValueError, self.cache.incr_version, 'answer')\n+        self.assertRaises(ValueError, self.cache.incr_version, 'does_not_exist')\n+\n+    def test_decr_version(self):\n+        \"Dummy cache versions can't be decremented\"\n+        self.cache.set('answer', 42)\n+        self.assertRaises(ValueError, self.cache.decr_version, 'answer')\n+        self.assertRaises(ValueError, self.cache.decr_version, 'does_not_exist')\n+\n \n class BaseCacheTests(object):\n     # A common set of tests to apply to all cache backends\n-    def tearDown(self):\n-        self.cache.clear()\n \n     def test_simple(self):\n         # Simple cache set/get works\n@@ -163,6 +173,18 @@ def test_add(self):\n         self.assertEqual(result, False)\n         self.assertEqual(self.cache.get(\"addkey1\"), \"value\")\n \n+    def test_prefix(self):\n+        # Test for same cache key conflicts between shared backend\n+        self.cache.set('somekey', 'value')\n+\n+        # should not be set in the prefixed cache\n+        self.assertFalse(self.prefix_cache.has_key('somekey'))\n+\n+        self.prefix_cache.set('somekey', 'value2')\n+\n+        self.assertEqual(self.cache.get('somekey'), 'value')\n+        self.assertEqual(self.prefix_cache.get('somekey'), 'value2')\n+\n     def test_non_existent(self):\n         # Non-existent cache keys return as None/default\n         # get with non-existent keys\n@@ -376,6 +398,13 @@ def test_invalid_keys(self):\n         with more liberal key rules. Refs #6447.\n \n         \"\"\"\n+        # mimic custom ``make_key`` method being defined since the default will\n+        # never show the below warnings\n+        def func(key, *args):\n+            return key\n+\n+        old_func = self.cache.key_func\n+        self.cache.key_func = func\n         # On Python 2.6+ we could use the catch_warnings context\n         # manager to test this warning nicely. Since we can't do that\n         # yet, the cleanest option is to temporarily ask for\n@@ -390,13 +419,296 @@ def test_invalid_keys(self):\n             self.assertRaises(CacheKeyWarning, self.cache.set, 'a' * 251, 'value')\n         finally:\n             restore_warnings_state(_warnings_state)\n+            self.cache.key_func = old_func\n+\n+    def test_cache_versioning_get_set(self):\n+        # set, using default version = 1\n+        self.cache.set('answer1', 42)\n+        self.assertEqual(self.cache.get('answer1'), 42)\n+        self.assertEqual(self.cache.get('answer1', version=1), 42)\n+        self.assertEqual(self.cache.get('answer1', version=2), None)\n+\n+        self.assertEqual(self.v2_cache.get('answer1'), None)\n+        # print '---'\n+        # print 'c1',self.cache._cache\n+        # print 'v2',self.v2_cache._cache\n+        self.assertEqual(self.v2_cache.get('answer1', version=1), 42)\n+        self.assertEqual(self.v2_cache.get('answer1', version=2), None)\n+\n+        # set, default version = 1, but manually override version = 2\n+        self.cache.set('answer2', 42, version=2)\n+        self.assertEqual(self.cache.get('answer2'), None)\n+        self.assertEqual(self.cache.get('answer2', version=1), None)\n+        self.assertEqual(self.cache.get('answer2', version=2), 42)\n+\n+        self.assertEqual(self.v2_cache.get('answer2'), 42)\n+        self.assertEqual(self.v2_cache.get('answer2', version=1), None)\n+        self.assertEqual(self.v2_cache.get('answer2', version=2), 42)\n+\n+        # v2 set, using default version = 2\n+        self.v2_cache.set('answer3', 42)\n+        self.assertEqual(self.cache.get('answer3'), None)\n+        self.assertEqual(self.cache.get('answer3', version=1), None)\n+        self.assertEqual(self.cache.get('answer3', version=2), 42)\n+\n+        self.assertEqual(self.v2_cache.get('answer3'), 42)\n+        self.assertEqual(self.v2_cache.get('answer3', version=1), None)\n+        self.assertEqual(self.v2_cache.get('answer3', version=2), 42)\n+\n+        # v2 set, default version = 2, but manually override version = 1\n+        self.v2_cache.set('answer4', 42, version=1)\n+        self.assertEqual(self.cache.get('answer4'), 42)\n+        self.assertEqual(self.cache.get('answer4', version=1), 42)\n+        self.assertEqual(self.cache.get('answer4', version=2), None)\n+\n+        self.assertEqual(self.v2_cache.get('answer4'), None)\n+        self.assertEqual(self.v2_cache.get('answer4', version=1), 42)\n+        self.assertEqual(self.v2_cache.get('answer4', version=2), None)\n+\n+    def test_cache_versioning_add(self):\n+\n+        # add, default version = 1, but manually override version = 2\n+        self.cache.add('answer1', 42, version=2)\n+        self.assertEqual(self.cache.get('answer1', version=1), None)\n+        self.assertEqual(self.cache.get('answer1', version=2), 42)\n+\n+        self.cache.add('answer1', 37, version=2)\n+        self.assertEqual(self.cache.get('answer1', version=1), None)\n+        self.assertEqual(self.cache.get('answer1', version=2), 42)\n+\n+        self.cache.add('answer1', 37, version=1)\n+        self.assertEqual(self.cache.get('answer1', version=1), 37)\n+        self.assertEqual(self.cache.get('answer1', version=2), 42)\n+\n+        # v2 add, using default version = 2\n+        self.v2_cache.add('answer2', 42)\n+        self.assertEqual(self.cache.get('answer2', version=1), None)\n+        self.assertEqual(self.cache.get('answer2', version=2), 42)\n+\n+        self.v2_cache.add('answer2', 37)\n+        self.assertEqual(self.cache.get('answer2', version=1), None)\n+        self.assertEqual(self.cache.get('answer2', version=2), 42)\n+\n+        self.v2_cache.add('answer2', 37, version=1)\n+        self.assertEqual(self.cache.get('answer2', version=1), 37)\n+        self.assertEqual(self.cache.get('answer2', version=2), 42)\n+\n+        # v2 add, default version = 2, but manually override version = 1\n+        self.v2_cache.add('answer3', 42, version=1)\n+        self.assertEqual(self.cache.get('answer3', version=1), 42)\n+        self.assertEqual(self.cache.get('answer3', version=2), None)\n+\n+        self.v2_cache.add('answer3', 37, version=1)\n+        self.assertEqual(self.cache.get('answer3', version=1), 42)\n+        self.assertEqual(self.cache.get('answer3', version=2), None)\n+\n+        self.v2_cache.add('answer3', 37)\n+        self.assertEqual(self.cache.get('answer3', version=1), 42)\n+        self.assertEqual(self.cache.get('answer3', version=2), 37)\n+\n+    def test_cache_versioning_has_key(self):\n+        self.cache.set('answer1', 42)\n+\n+        # has_key\n+        self.assertTrue(self.cache.has_key('answer1'))\n+        self.assertTrue(self.cache.has_key('answer1', version=1))\n+        self.assertFalse(self.cache.has_key('answer1', version=2))\n+\n+        self.assertFalse(self.v2_cache.has_key('answer1'))\n+        self.assertTrue(self.v2_cache.has_key('answer1', version=1))\n+        self.assertFalse(self.v2_cache.has_key('answer1', version=2))\n+\n+    def test_cache_versioning_delete(self):\n+        self.cache.set('answer1', 37, version=1)\n+        self.cache.set('answer1', 42, version=2)\n+        self.cache.delete('answer1')\n+        self.assertEqual(self.cache.get('answer1', version=1), None)\n+        self.assertEqual(self.cache.get('answer1', version=2), 42)\n+\n+        self.cache.set('answer2', 37, version=1)\n+        self.cache.set('answer2', 42, version=2)\n+        self.cache.delete('answer2', version=2)\n+        self.assertEqual(self.cache.get('answer2', version=1), 37)\n+        self.assertEqual(self.cache.get('answer2', version=2), None)\n+\n+        self.cache.set('answer3', 37, version=1)\n+        self.cache.set('answer3', 42, version=2)\n+        self.v2_cache.delete('answer3')\n+        self.assertEqual(self.cache.get('answer3', version=1), 37)\n+        self.assertEqual(self.cache.get('answer3', version=2), None)\n+\n+        self.cache.set('answer4', 37, version=1)\n+        self.cache.set('answer4', 42, version=2)\n+        self.v2_cache.delete('answer4', version=1)\n+        self.assertEqual(self.cache.get('answer4', version=1), None)\n+        self.assertEqual(self.cache.get('answer4', version=2), 42)\n+\n+    def test_cache_versioning_incr_decr(self):\n+        self.cache.set('answer1', 37, version=1)\n+        self.cache.set('answer1', 42, version=2)\n+        self.cache.incr('answer1')\n+        self.assertEqual(self.cache.get('answer1', version=1), 38)\n+        self.assertEqual(self.cache.get('answer1', version=2), 42)\n+        self.cache.decr('answer1')\n+        self.assertEqual(self.cache.get('answer1', version=1), 37)\n+        self.assertEqual(self.cache.get('answer1', version=2), 42)\n+\n+        self.cache.set('answer2', 37, version=1)\n+        self.cache.set('answer2', 42, version=2)\n+        self.cache.incr('answer2', version=2)\n+        self.assertEqual(self.cache.get('answer2', version=1), 37)\n+        self.assertEqual(self.cache.get('answer2', version=2), 43)\n+        self.cache.decr('answer2', version=2)\n+        self.assertEqual(self.cache.get('answer2', version=1), 37)\n+        self.assertEqual(self.cache.get('answer2', version=2), 42)\n+\n+        self.cache.set('answer3', 37, version=1)\n+        self.cache.set('answer3', 42, version=2)\n+        self.v2_cache.incr('answer3')\n+        self.assertEqual(self.cache.get('answer3', version=1), 37)\n+        self.assertEqual(self.cache.get('answer3', version=2), 43)\n+        self.v2_cache.decr('answer3')\n+        self.assertEqual(self.cache.get('answer3', version=1), 37)\n+        self.assertEqual(self.cache.get('answer3', version=2), 42)\n+\n+        self.cache.set('answer4', 37, version=1)\n+        self.cache.set('answer4', 42, version=2)\n+        self.v2_cache.incr('answer4', version=1)\n+        self.assertEqual(self.cache.get('answer4', version=1), 38)\n+        self.assertEqual(self.cache.get('answer4', version=2), 42)\n+        self.v2_cache.decr('answer4', version=1)\n+        self.assertEqual(self.cache.get('answer4', version=1), 37)\n+        self.assertEqual(self.cache.get('answer4', version=2), 42)\n+\n+    def test_cache_versioning_get_set_many(self):\n+        # set, using default version = 1\n+        self.cache.set_many({'ford1': 37, 'arthur1': 42})\n+        self.assertEqual(self.cache.get_many(['ford1','arthur1']),\n+                         {'ford1': 37, 'arthur1': 42})\n+        self.assertEqual(self.cache.get_many(['ford1','arthur1'], version=1),\n+                         {'ford1': 37, 'arthur1': 42})\n+        self.assertEqual(self.cache.get_many(['ford1','arthur1'], version=2), {})\n+\n+        self.assertEqual(self.v2_cache.get_many(['ford1','arthur1']), {})\n+        self.assertEqual(self.v2_cache.get_many(['ford1','arthur1'], version=1),\n+                         {'ford1': 37, 'arthur1': 42})\n+        self.assertEqual(self.v2_cache.get_many(['ford1','arthur1'], version=2), {})\n+\n+        # set, default version = 1, but manually override version = 2\n+        self.cache.set_many({'ford2': 37, 'arthur2': 42}, version=2)\n+        self.assertEqual(self.cache.get_many(['ford2','arthur2']), {})\n+        self.assertEqual(self.cache.get_many(['ford2','arthur2'], version=1), {})\n+        self.assertEqual(self.cache.get_many(['ford2','arthur2'], version=2),\n+                         {'ford2': 37, 'arthur2': 42})\n+\n+        self.assertEqual(self.v2_cache.get_many(['ford2','arthur2']),\n+                         {'ford2': 37, 'arthur2': 42})\n+        self.assertEqual(self.v2_cache.get_many(['ford2','arthur2'], version=1), {})\n+        self.assertEqual(self.v2_cache.get_many(['ford2','arthur2'], version=2),\n+                         {'ford2': 37, 'arthur2': 42})\n+\n+        # v2 set, using default version = 2\n+        self.v2_cache.set_many({'ford3': 37, 'arthur3': 42})\n+        self.assertEqual(self.cache.get_many(['ford3','arthur3']), {})\n+        self.assertEqual(self.cache.get_many(['ford3','arthur3'], version=1), {})\n+        self.assertEqual(self.cache.get_many(['ford3','arthur3'], version=2),\n+                         {'ford3': 37, 'arthur3': 42})\n+\n+        self.assertEqual(self.v2_cache.get_many(['ford3','arthur3']),\n+                         {'ford3': 37, 'arthur3': 42})\n+        self.assertEqual(self.v2_cache.get_many(['ford3','arthur3'], version=1), {})\n+        self.assertEqual(self.v2_cache.get_many(['ford3','arthur3'], version=2),\n+                         {'ford3': 37, 'arthur3': 42})\n+\n+        # v2 set, default version = 2, but manually override version = 1\n+        self.v2_cache.set_many({'ford4': 37, 'arthur4': 42}, version=1)\n+        self.assertEqual(self.cache.get_many(['ford4','arthur4']),\n+                         {'ford4': 37, 'arthur4': 42})\n+        self.assertEqual(self.cache.get_many(['ford4','arthur4'], version=1),\n+                         {'ford4': 37, 'arthur4': 42})\n+        self.assertEqual(self.cache.get_many(['ford4','arthur4'], version=2), {})\n+\n+        self.assertEqual(self.v2_cache.get_many(['ford4','arthur4']), {})\n+        self.assertEqual(self.v2_cache.get_many(['ford4','arthur4'], version=1),\n+                         {'ford4': 37, 'arthur4': 42})\n+        self.assertEqual(self.v2_cache.get_many(['ford4','arthur4'], version=2), {})\n+\n+    def test_incr_version(self):\n+        self.cache.set('answer', 42, version=2)\n+        self.assertEqual(self.cache.get('answer'), None)\n+        self.assertEqual(self.cache.get('answer', version=1), None)\n+        self.assertEqual(self.cache.get('answer', version=2), 42)\n+        self.assertEqual(self.cache.get('answer', version=3), None)\n+\n+        self.assertEqual(self.cache.incr_version('answer', version=2), 3)\n+        self.assertEqual(self.cache.get('answer'), None)\n+        self.assertEqual(self.cache.get('answer', version=1), None)\n+        self.assertEqual(self.cache.get('answer', version=2), None)\n+        self.assertEqual(self.cache.get('answer', version=3), 42)\n+\n+        self.v2_cache.set('answer2', 42)\n+        self.assertEqual(self.v2_cache.get('answer2'), 42)\n+        self.assertEqual(self.v2_cache.get('answer2', version=1), None)\n+        self.assertEqual(self.v2_cache.get('answer2', version=2), 42)\n+        self.assertEqual(self.v2_cache.get('answer2', version=3), None)\n+\n+        self.assertEqual(self.v2_cache.incr_version('answer2'), 3)\n+        self.assertEqual(self.v2_cache.get('answer2'), None)\n+        self.assertEqual(self.v2_cache.get('answer2', version=1), None)\n+        self.assertEqual(self.v2_cache.get('answer2', version=2), None)\n+        self.assertEqual(self.v2_cache.get('answer2', version=3), 42)\n+\n+        self.assertRaises(ValueError, self.cache.incr_version, 'does_not_exist')\n+\n+    def test_decr_version(self):\n+        self.cache.set('answer', 42, version=2)\n+        self.assertEqual(self.cache.get('answer'), None)\n+        self.assertEqual(self.cache.get('answer', version=1), None)\n+        self.assertEqual(self.cache.get('answer', version=2), 42)\n+\n+        self.assertEqual(self.cache.decr_version('answer', version=2), 1)\n+        self.assertEqual(self.cache.get('answer'), 42)\n+        self.assertEqual(self.cache.get('answer', version=1), 42)\n+        self.assertEqual(self.cache.get('answer', version=2), None)\n+\n+        self.v2_cache.set('answer2', 42)\n+        self.assertEqual(self.v2_cache.get('answer2'), 42)\n+        self.assertEqual(self.v2_cache.get('answer2', version=1), None)\n+        self.assertEqual(self.v2_cache.get('answer2', version=2), 42)\n+\n+        self.assertEqual(self.v2_cache.decr_version('answer2'), 1)\n+        self.assertEqual(self.v2_cache.get('answer2'), None)\n+        self.assertEqual(self.v2_cache.get('answer2', version=1), 42)\n+        self.assertEqual(self.v2_cache.get('answer2', version=2), None)\n+\n+        self.assertRaises(ValueError, self.cache.decr_version, 'does_not_exist', version=2)\n+\n+    def test_custom_key_func(self):\n+        # Two caches with different key functions aren't visible to each other\n+        self.cache.set('answer1', 42)\n+        self.assertEqual(self.cache.get('answer1'), 42)\n+        self.assertEqual(self.custom_key_cache.get('answer1'), None)\n+        self.assertEqual(self.custom_key_cache2.get('answer1'), None)\n+\n+        self.custom_key_cache.set('answer2', 42)\n+        self.assertEqual(self.cache.get('answer2'), None)\n+        self.assertEqual(self.custom_key_cache.get('answer2'), 42)\n+        self.assertEqual(self.custom_key_cache2.get('answer2'), 42)\n+\n+def custom_key_func(key, key_prefix, version):\n+    \"A customized cache key function\"\n+    return 'CUSTOM-' + '-'.join([key_prefix, str(version), key])\n \n class DBCacheTests(unittest.TestCase, BaseCacheTests):\n     def setUp(self):\n         # Spaces are used in the table name to ensure quoting/escaping is working\n         self._table_name = 'test cache table'\n         management.call_command('createcachetable', self._table_name, verbosity=0, interactive=False)\n         self.cache = get_cache('db://%s?max_entries=30' % self._table_name)\n+        self.prefix_cache = get_cache('db://%s' % self._table_name, key_prefix='cacheprefix')\n+        self.v2_cache = get_cache('db://%s' % self._table_name, version=2)\n+        self.custom_key_cache = get_cache('db://%s' % self._table_name, key_func=custom_key_func)\n+        self.custom_key_cache2 = get_cache('db://%s' % self._table_name, key_func='regressiontests.cache.tests.custom_key_func')\n \n     def tearDown(self):\n         from django.db import connection\n@@ -413,6 +725,24 @@ def test_zero_cull(self):\n class LocMemCacheTests(unittest.TestCase, BaseCacheTests):\n     def setUp(self):\n         self.cache = get_cache('locmem://?max_entries=30')\n+        self.prefix_cache = get_cache('locmem://', key_prefix='cacheprefix')\n+        self.v2_cache = get_cache('locmem://', version=2)\n+        self.custom_key_cache = get_cache('locmem://?max_entries=30', key_func=custom_key_func)\n+        self.custom_key_cache2 = get_cache('locmem://?max_entries=30', key_func='regressiontests.cache.tests.custom_key_func')\n+\n+        # LocMem requires a hack to make the other caches\n+        # share a data store with the 'normal' cache.\n+        self.prefix_cache._cache = self.cache._cache\n+        self.prefix_cache._expire_info = self.cache._expire_info\n+\n+        self.v2_cache._cache = self.cache._cache\n+        self.v2_cache._expire_info = self.cache._expire_info\n+\n+        self.custom_key_cache._cache = self.cache._cache\n+        self.custom_key_cache._expire_info = self.cache._expire_info\n+\n+        self.custom_key_cache2._cache = self.cache._cache\n+        self.custom_key_cache2._expire_info = self.cache._expire_info\n \n     def test_cull(self):\n         self.perform_cull_test(50, 29)\n@@ -428,6 +758,13 @@ def test_zero_cull(self):\n class MemcachedCacheTests(unittest.TestCase, BaseCacheTests):\n     def setUp(self):\n         self.cache = get_cache(settings.CACHE_BACKEND)\n+        self.prefix_cache = get_cache(settings.CACHE_BACKEND, key_prefix='cacheprefix')\n+        self.v2_cache = get_cache(settings.CACHE_BACKEND, version=2)\n+        self.custom_key_cache = get_cache(settings.CACHE_BACKEND, key_func=custom_key_func)\n+        self.custom_key_cache2 = get_cache(settings.CACHE_BACKEND, key_func='regressiontests.cache.tests.custom_key_func')\n+\n+    def tearDown(self):\n+        self.cache.clear()\n \n     def test_invalid_keys(self):\n         \"\"\"\n@@ -443,6 +780,7 @@ def test_invalid_keys(self):\n         self.assertRaises(Exception, self.cache.set, 'key with spaces', 'value')\n         # memcached limits key length to 250\n         self.assertRaises(Exception, self.cache.set, 'a' * 251, 'value')\n+\n MemcachedCacheTests = unittest.skipUnless(settings.CACHE_BACKEND.startswith('memcached://'), \"memcached not available\")(MemcachedCacheTests)\n \n class FileBasedCacheTests(unittest.TestCase, BaseCacheTests):\n@@ -452,11 +790,19 @@ class FileBasedCacheTests(unittest.TestCase, BaseCacheTests):\n     def setUp(self):\n         self.dirname = tempfile.mkdtemp()\n         self.cache = get_cache('file://%s?max_entries=30' % self.dirname)\n+        self.prefix_cache = get_cache('file://%s' % self.dirname, key_prefix='cacheprefix')\n+        self.v2_cache = get_cache('file://%s' % self.dirname, version=2)\n+        self.custom_key_cache = get_cache('file://%s' % self.dirname, key_func=custom_key_func)\n+        self.custom_key_cache2 = get_cache('file://%s' % self.dirname, key_func='regressiontests.cache.tests.custom_key_func')\n+\n+    def tearDown(self):\n+        self.cache.clear()\n \n     def test_hashing(self):\n         \"\"\"Test that keys are hashed into subdirectories correctly\"\"\"\n         self.cache.set(\"foo\", \"bar\")\n-        keyhash = md5_constructor(\"foo\").hexdigest()\n+        key = self.cache.make_key(\"foo\")\n+        keyhash = md5_constructor(key).hexdigest()\n         keypath = os.path.join(self.dirname, keyhash[:2], keyhash[2:4], keyhash[4:])\n         self.assert_(os.path.exists(keypath))\n \n@@ -465,7 +811,8 @@ def test_subdirectory_removal(self):\n         Make sure that the created subdirectories are correctly removed when empty.\n         \"\"\"\n         self.cache.set(\"foo\", \"bar\")\n-        keyhash = md5_constructor(\"foo\").hexdigest()\n+        key = self.cache.make_key(\"foo\")\n+        keyhash = md5_constructor(key).hexdigest()\n         keypath = os.path.join(self.dirname, keyhash[:2], keyhash[2:4], keyhash[4:])\n         self.assert_(os.path.exists(keypath))\n \n@@ -475,7 +822,7 @@ def test_subdirectory_removal(self):\n         self.assert_(not os.path.exists(os.path.dirname(os.path.dirname(keypath))))\n \n     def test_cull(self):\n-        self.perform_cull_test(50, 28)\n+        self.perform_cull_test(50, 29)\n \n class CustomCacheKeyValidationTests(unittest.TestCase):\n     \"\"\"\n@@ -498,16 +845,16 @@ class CacheUtils(unittest.TestCase):\n \n     def setUp(self):\n         self.path = '/cache/test/'\n-        self.old_settings_key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n-        self.old_middleware_seconds = settings.CACHE_MIDDLEWARE_SECONDS\n+        self.old_cache_middleware_key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n+        self.old_cache_middleware_seconds = settings.CACHE_MIDDLEWARE_SECONDS\n         self.orig_use_i18n = settings.USE_I18N\n         settings.CACHE_MIDDLEWARE_KEY_PREFIX = 'settingsprefix'\n         settings.CACHE_MIDDLEWARE_SECONDS = 1\n         settings.USE_I18N = False\n \n     def tearDown(self):\n-        settings.CACHE_MIDDLEWARE_KEY_PREFIX = self.old_settings_key_prefix\n-        settings.CACHE_MIDDLEWARE_SECONDS = self.old_middleware_seconds\n+        settings.CACHE_MIDDLEWARE_KEY_PREFIX = self.old_cache_middleware_key_prefix\n+        settings.CACHE_MIDDLEWARE_SECONDS = self.old_cache_middleware_seconds\n         settings.USE_I18N = self.orig_use_i18n\n \n     def _get_request(self, path, method='GET'):\n@@ -561,6 +908,16 @@ def test_learn_cache_key(self):\n         learn_cache_key(request, response)\n         self.assertEqual(get_cache_key(request), 'views.decorators.cache.cache_page.settingsprefix.HEAD.a8c87a3d8c44853d7f79474f7ffe4ad5.d41d8cd98f00b204e9800998ecf8427e')\n \n+class PrefixedCacheUtils(CacheUtils):\n+    def setUp(self):\n+        super(PrefixedCacheUtils, self).setUp()\n+        self.old_cache_key_prefix = settings.CACHE_KEY_PREFIX\n+        settings.CACHE_KEY_PREFIX = 'cacheprefix'\n+\n+    def tearDown(self):\n+        super(PrefixedCacheUtils, self).tearDown()\n+        settings.CACHE_KEY_PREFIX = self.old_cache_key_prefix\n+\n class CacheHEADTest(unittest.TestCase):\n \n     def setUp(self):\n@@ -714,5 +1071,15 @@ def set_cache(request, lang, msg):\n         get_cache_data = FetchFromCacheMiddleware().process_request(request)\n         self.assertEqual(get_cache_data.content, es_message)\n \n+class PrefixedCacheI18nTest(CacheI18nTest):\n+    def setUp(self):\n+        super(PrefixedCacheI18nTest, self).setUp()\n+        self.old_cache_key_prefix = settings.CACHE_KEY_PREFIX\n+        settings.CACHE_KEY_PREFIX = 'cacheprefix'\n+\n+    def tearDown(self):\n+        super(PrefixedCacheI18nTest, self).tearDown()\n+        settings.CACHE_KEY_PREFIX = self.old_cache_key_prefix\n+\n if __name__ == '__main__':\n     unittest.main()"
        }
    ],
    "stats": {
        "total": 783,
        "additions": 696,
        "deletions": 87
    }
}