{
    "author": "jphalip",
    "message": "Fixed #13956 -- Enabled `*args` and `**kwargs` support for `simple_tag`, `inclusion_tag` and `assignment_tag`. Many thanks to Stephen Burrows for the report and initial patch, to Gregor MuÌˆllegger for the initial tests, to SamBull for the suggestions, and to Jannis Leidel for the review and PEP8 cleanup.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16908 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "8137027fd770ceb02d593605b22b8cfff1ef2e66",
    "files": [
        {
            "sha": "8642f4d4f5e79d9c2ec854b719db1cd9660e32d7",
            "filename": "django/template/base.py",
            "status": "modified",
            "additions": 375,
            "deletions": 185,
            "changes": 560,
            "blob_url": "https://github.com/django/django/blob/8137027fd770ceb02d593605b22b8cfff1ef2e66/django%2Ftemplate%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/8137027fd770ceb02d593605b22b8cfff1ef2e66/django%2Ftemplate%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2Fbase.py?ref=8137027fd770ceb02d593605b22b8cfff1ef2e66",
            "patch": "@@ -3,13 +3,16 @@\n from inspect import getargspec\n \n from django.conf import settings\n-from django.template.context import Context, RequestContext, ContextPopException\n+from django.template.context import (Context, RequestContext,\n+    ContextPopException)\n from django.utils.importlib import import_module\n from django.utils.itercompat import is_iterable\n-from django.utils.text import smart_split, unescape_string_literal, get_text_list\n+from django.utils.text import (smart_split, unescape_string_literal,\n+    get_text_list)\n from django.utils.encoding import smart_unicode, force_unicode, smart_str\n from django.utils.translation import ugettext_lazy\n-from django.utils.safestring import SafeData, EscapeData, mark_safe, mark_for_escaping\n+from django.utils.safestring import (SafeData, EscapeData, mark_safe,\n+    mark_for_escaping)\n from django.utils.formats import localize\n from django.utils.html import escape\n from django.utils.module_loading import module_has_submodule\n@@ -19,6 +22,12 @@\n TOKEN_VAR = 1\n TOKEN_BLOCK = 2\n TOKEN_COMMENT = 3\n+TOKEN_MAPPING = {\n+    TOKEN_TEXT: 'Text',\n+    TOKEN_VAR: 'Var',\n+    TOKEN_BLOCK: 'Block',\n+    TOKEN_COMMENT: 'Comment',\n+}\n \n # template syntax constants\n FILTER_SEPARATOR = '|'\n@@ -34,16 +43,19 @@\n SINGLE_BRACE_START = '{'\n SINGLE_BRACE_END = '}'\n \n-ALLOWED_VARIABLE_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.'\n+ALLOWED_VARIABLE_CHARS = ('abcdefghijklmnopqrstuvwxyz'\n+                         'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.')\n \n # what to report as the origin for templates that come from non-loader sources\n # (e.g. strings)\n UNKNOWN_SOURCE = '<unknown source>'\n \n-# match a variable or block tag and capture the entire tag, including start/end delimiters\n-tag_re = re.compile('(%s.*?%s|%s.*?%s|%s.*?%s)' % (re.escape(BLOCK_TAG_START), re.escape(BLOCK_TAG_END),\n-                                          re.escape(VARIABLE_TAG_START), re.escape(VARIABLE_TAG_END),\n-                                          re.escape(COMMENT_TAG_START), re.escape(COMMENT_TAG_END)))\n+# match a variable or block tag and capture the entire tag, including start/end\n+# delimiters\n+tag_re = (re.compile('(%s.*?%s|%s.*?%s|%s.*?%s)' %\n+          (re.escape(BLOCK_TAG_START), re.escape(BLOCK_TAG_END),\n+           re.escape(VARIABLE_TAG_START), re.escape(VARIABLE_TAG_END),\n+           re.escape(COMMENT_TAG_START), re.escape(COMMENT_TAG_END))))\n \n # global dictionary of libraries that have been loaded using get_library\n libraries = {}\n@@ -73,7 +85,8 @@ def __str__(self):\n         return unicode(self).encode('utf-8')\n \n     def __unicode__(self):\n-        return self.msg % tuple([force_unicode(p, errors='replace') for p in self.params])\n+        return self.msg % tuple([force_unicode(p, errors='replace')\n+                                 for p in self.params])\n \n class InvalidTemplateLibrary(Exception):\n     pass\n@@ -97,11 +110,13 @@ def reload(self):\n         return self.source\n \n class Template(object):\n-    def __init__(self, template_string, origin=None, name='<Unknown Template>'):\n+    def __init__(self, template_string, origin=None,\n+                 name='<Unknown Template>'):\n         try:\n             template_string = smart_unicode(template_string)\n         except UnicodeDecodeError:\n-            raise TemplateEncodingError(\"Templates can only be constructed from unicode or UTF-8 strings.\")\n+            raise TemplateEncodingError(\"Templates can only be constructed \"\n+                                        \"from unicode or UTF-8 strings.\")\n         if settings.TEMPLATE_DEBUG and origin is None:\n             origin = StringOrigin(template_string)\n         self.nodelist = compile_string(template_string, origin)\n@@ -136,14 +151,15 @@ def compile_string(template_string, origin):\n \n class Token(object):\n     def __init__(self, token_type, contents):\n-        # token_type must be TOKEN_TEXT, TOKEN_VAR, TOKEN_BLOCK or TOKEN_COMMENT.\n+        # token_type must be TOKEN_TEXT, TOKEN_VAR, TOKEN_BLOCK or\n+        # TOKEN_COMMENT.\n         self.token_type, self.contents = token_type, contents\n         self.lineno = None\n \n     def __str__(self):\n-        return '<%s token: \"%s...\">' % \\\n-            ({TOKEN_TEXT: 'Text', TOKEN_VAR: 'Var', TOKEN_BLOCK: 'Block', TOKEN_COMMENT: 'Comment'}[self.token_type],\n-            self.contents[:20].replace('\\n', ''))\n+        token_name = TOKEN_MAPPING[self.token_type]\n+        return ('<%s token: \"%s...\">' %\n+                (token_name, self.contents[:20].replace('\\n', '')))\n \n     def split_contents(self):\n         split = []\n@@ -167,7 +183,9 @@ def __init__(self, template_string, origin):\n         self.lineno = 1\n \n     def tokenize(self):\n-        \"Return a list of tokens from a given template_string.\"\n+        \"\"\"\n+        Return a list of tokens from a given template_string.\n+        \"\"\"\n         in_tag = False\n         result = []\n         for bit in tag_re.split(self.template_string):\n@@ -184,13 +202,21 @@ def create_token(self, token_string, in_tag):\n         \"\"\"\n         if in_tag:\n             if token_string.startswith(VARIABLE_TAG_START):\n-                token = Token(TOKEN_VAR, token_string[len(VARIABLE_TAG_START):-len(VARIABLE_TAG_END)].strip())\n+                token = Token(TOKEN_VAR,\n+                              token_string[\n+                                len(VARIABLE_TAG_START):-len(VARIABLE_TAG_END)\n+                              ].strip())\n             elif token_string.startswith(BLOCK_TAG_START):\n-                token = Token(TOKEN_BLOCK, token_string[len(BLOCK_TAG_START):-len(BLOCK_TAG_END)].strip())\n+                token = Token(TOKEN_BLOCK,\n+                              token_string[\n+                                len(BLOCK_TAG_START):-len(BLOCK_TAG_END)\n+                              ].strip())\n             elif token_string.startswith(COMMENT_TAG_START):\n                 content = ''\n                 if token_string.find(TRANSLATOR_COMMENT_MARK):\n-                    content = token_string[len(COMMENT_TAG_START):-len(COMMENT_TAG_END)].strip()\n+                    content = token_string[\n+                                len(COMMENT_TAG_START):-len(COMMENT_TAG_END)\n+                              ].strip()\n                 token = Token(TOKEN_COMMENT, content)\n         else:\n             token = Token(TOKEN_TEXT, token_string)\n@@ -207,7 +233,8 @@ def __init__(self, tokens):\n             self.add_library(lib)\n \n     def parse(self, parse_until=None):\n-        if parse_until is None: parse_until = []\n+        if parse_until is None:\n+            parse_until = []\n         nodelist = self.create_nodelist()\n         while self.tokens:\n             token = self.next_token()\n@@ -218,17 +245,19 @@ def parse(self, parse_until=None):\n                     self.empty_variable(token)\n                 filter_expression = self.compile_filter(token.contents)\n                 var_node = self.create_variable_node(filter_expression)\n-                self.extend_nodelist(nodelist, var_node,token)\n+                self.extend_nodelist(nodelist, var_node, token)\n             elif token.token_type == TOKEN_BLOCK:\n                 if token.contents in parse_until:\n-                    # put token back on token list so calling code knows why it terminated\n+                    # put token back on token list so calling\n+                    # code knows why it terminated\n                     self.prepend_token(token)\n                     return nodelist\n                 try:\n                     command = token.contents.split()[0]\n                 except IndexError:\n                     self.empty_block_tag(token)\n-                # execute callback function for this tag and append resulting node\n+                # execute callback function for this tag and append\n+                # resulting node\n                 self.enter_command(command, token)\n                 try:\n                     compile_func = self.tags[command]\n@@ -264,7 +293,8 @@ def extend_nodelist(self, nodelist, node, token):\n                 if nodelist.contains_nontext:\n                     raise AttributeError\n             except AttributeError:\n-                raise TemplateSyntaxError(\"%r must be the first tag in the template.\" % node)\n+                raise TemplateSyntaxError(\"%r must be the first tag \"\n+                                          \"in the template.\" % node)\n         if isinstance(nodelist, NodeList) and not isinstance(node, TextNode):\n             nodelist.contains_nontext = True\n         nodelist.append(node)\n@@ -286,11 +316,12 @@ def empty_block_tag(self, token):\n \n     def invalid_block_tag(self, token, command, parse_until=None):\n         if parse_until:\n-            raise self.error(token, \"Invalid block tag: '%s', expected %s\" % (command, get_text_list([\"'%s'\" % p for p in parse_until])))\n+            raise self.error(token, \"Invalid block tag: '%s', expected %s\" %\n+                (command, get_text_list([\"'%s'\" % p for p in parse_until])))\n         raise self.error(token, \"Invalid block tag: '%s'\" % command)\n \n     def unclosed_block_tag(self, parse_until):\n-        raise self.error(None, \"Unclosed tags: %s \" %  ', '.join(parse_until))\n+        raise self.error(None, \"Unclosed tags: %s \" % ', '.join(parse_until))\n \n     def compile_function_error(self, token, e):\n         pass\n@@ -309,7 +340,9 @@ def add_library(self, lib):\n         self.filters.update(lib.filters)\n \n     def compile_filter(self, token):\n-        \"Convenient wrapper for FilterExpression\"\n+        \"\"\"\n+        Convenient wrapper for FilterExpression\n+        \"\"\"\n         return FilterExpression(token, self)\n \n     def find_filter(self, filter_name):\n@@ -320,8 +353,9 @@ def find_filter(self, filter_name):\n \n class TokenParser(object):\n     \"\"\"\n-    Subclass this and implement the top() method to parse a template line. When\n-    instantiating the parser, pass in the line from the Django template parser.\n+    Subclass this and implement the top() method to parse a template line.\n+    When instantiating the parser, pass in the line from the Django template\n+    parser.\n \n     The parser's \"tagname\" instance-variable stores the name of the tag that\n     the filter was called with.\n@@ -333,25 +367,35 @@ def __init__(self, subject):\n         self.tagname = self.tag()\n \n     def top(self):\n-        \"Overload this method to do the actual parsing and return the result.\"\n+        \"\"\"\n+        Overload this method to do the actual parsing and return the result.\n+        \"\"\"\n         raise NotImplementedError()\n \n     def more(self):\n-        \"Returns True if there is more stuff in the tag.\"\n+        \"\"\"\n+        Returns True if there is more stuff in the tag.\n+        \"\"\"\n         return self.pointer < len(self.subject)\n \n     def back(self):\n-        \"Undoes the last microparser. Use this for lookahead and backtracking.\"\n+        \"\"\"\n+        Undoes the last microparser. Use this for lookahead and backtracking.\n+        \"\"\"\n         if not len(self.backout):\n-            raise TemplateSyntaxError(\"back called without some previous parsing\")\n+            raise TemplateSyntaxError(\"back called without some previous \"\n+                                      \"parsing\")\n         self.pointer = self.backout.pop()\n \n     def tag(self):\n-        \"A microparser that just returns the next tag from the line.\"\n+        \"\"\"\n+        A microparser that just returns the next tag from the line.\n+        \"\"\"\n         subject = self.subject\n         i = self.pointer\n         if i >= len(subject):\n-            raise TemplateSyntaxError(\"expected another tag, found end of string: %s\" % subject)\n+            raise TemplateSyntaxError(\"expected another tag, found \"\n+                                      \"end of string: %s\" % subject)\n         p = i\n         while i < len(subject) and subject[i] not in (' ', '\\t'):\n             i += 1\n@@ -363,35 +407,48 @@ def tag(self):\n         return s\n \n     def value(self):\n-        \"A microparser that parses for a value: some string constant or variable name.\"\n+        \"\"\"\n+        A microparser that parses for a value: some string constant or\n+        variable name.\n+        \"\"\"\n         subject = self.subject\n         i = self.pointer\n \n         def next_space_index(subject, i):\n-            \"Increment pointer until a real space (i.e. a space not within quotes) is encountered\"\n+            \"\"\"\n+            Increment pointer until a real space (i.e. a space not within\n+            quotes) is encountered\n+            \"\"\"\n             while i < len(subject) and subject[i] not in (' ', '\\t'):\n                 if subject[i] in ('\"', \"'\"):\n                     c = subject[i]\n                     i += 1\n                     while i < len(subject) and subject[i] != c:\n                         i += 1\n                     if i >= len(subject):\n-                        raise TemplateSyntaxError(\"Searching for value. Unexpected end of string in column %d: %s\" % (i, subject))\n+                        raise TemplateSyntaxError(\"Searching for value. \"\n+                            \"Unexpected end of string in column %d: %s\" %\n+                            (i, subject))\n                 i += 1\n             return i\n \n         if i >= len(subject):\n-            raise TemplateSyntaxError(\"Searching for value. Expected another value but found end of string: %s\" % subject)\n+            raise TemplateSyntaxError(\"Searching for value. Expected another \"\n+                                      \"value but found end of string: %s\" %\n+                                      subject)\n         if subject[i] in ('\"', \"'\"):\n             p = i\n             i += 1\n             while i < len(subject) and subject[i] != subject[p]:\n                 i += 1\n             if i >= len(subject):\n-                raise TemplateSyntaxError(\"Searching for value. Unexpected end of string in column %d: %s\" % (i, subject))\n+                raise TemplateSyntaxError(\"Searching for value. Unexpected \"\n+                                          \"end of string in column %d: %s\" %\n+                                          (i, subject))\n             i += 1\n \n-            # Continue parsing until next \"real\" space, so that filters are also included\n+            # Continue parsing until next \"real\" space,\n+            # so that filters are also included\n             i = next_space_index(subject, i)\n \n             res = subject[p:i]\n@@ -419,10 +476,10 @@ def next_space_index(subject, i):\n %(strdq)s|\n %(strsq)s)\n \"\"\" % {\n-    'strdq': r'\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"', # double-quoted string\n-    'strsq': r\"'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\", # single-quoted string\n-    'i18n_open' : re.escape(\"_(\"),\n-    'i18n_close' : re.escape(\")\"),\n+    'strdq': r'\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"',  # double-quoted string\n+    'strsq': r\"'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\",  # single-quoted string\n+    'i18n_open': re.escape(\"_(\"),\n+    'i18n_close': re.escape(\")\"),\n     }\n constant_string = constant_string.replace(\"\\n\", \"\")\n \n@@ -440,18 +497,19 @@ def next_space_index(subject, i):\n  )\"\"\" % {\n     'constant': constant_string,\n     'num': r'[-+\\.]?\\d[\\d\\.e]*',\n-    'var_chars': \"\\w\\.\" ,\n+    'var_chars': \"\\w\\.\",\n     'filter_sep': re.escape(FILTER_SEPARATOR),\n     'arg_sep': re.escape(FILTER_ARGUMENT_SEPARATOR),\n   }\n \n-filter_re = re.compile(filter_raw_string, re.UNICODE|re.VERBOSE)\n+filter_re = re.compile(filter_raw_string, re.UNICODE | re.VERBOSE)\n \n class FilterExpression(object):\n-    r\"\"\"\n+    \"\"\"\n     Parses a variable token and its optional filters (all as a single string),\n     and return a list of tuples of the filter name and arguments.\n-    Sample:\n+    Sample::\n+\n         >>> token = 'variable|default:\"Default value\"|date:\"Y-m-d\"'\n         >>> p = Parser('')\n         >>> fe = FilterExpression(token, p)\n@@ -472,8 +530,10 @@ def __init__(self, token, parser):\n         for match in matches:\n             start = match.start()\n             if upto != start:\n-                raise TemplateSyntaxError(\"Could not parse some characters: %s|%s|%s\"  % \\\n-                        (token[:upto], token[upto:start], token[start:]))\n+                raise TemplateSyntaxError(\"Could not parse some characters: \"\n+                                          \"%s|%s|%s\" %\n+                                          (token[:upto], token[upto:start],\n+                                           token[start:]))\n             if var_obj is None:\n                 var, constant = match.group(\"var\", \"constant\")\n                 if constant:\n@@ -482,7 +542,8 @@ def __init__(self, token, parser):\n                     except VariableDoesNotExist:\n                         var_obj = None\n                 elif var is None:\n-                    raise TemplateSyntaxError(\"Could not find variable at start of %s.\" % token)\n+                    raise TemplateSyntaxError(\"Could not find variable at \"\n+                                              \"start of %s.\" % token)\n                 else:\n                     var_obj = Variable(var)\n             else:\n@@ -498,7 +559,8 @@ def __init__(self, token, parser):\n                 filters.append((filter_func, args))\n             upto = match.end()\n         if upto != len(token):\n-            raise TemplateSyntaxError(\"Could not parse the remainder: '%s' from '%s'\" % (token[upto:], token))\n+            raise TemplateSyntaxError(\"Could not parse the remainder: '%s' \"\n+                                      \"from '%s'\" % (token[upto:], token))\n \n         self.filters = filters\n         self.var = var_obj\n@@ -559,7 +621,8 @@ def args_check(name, func, provided):\n                 provided.pop(0)\n         except IndexError:\n             # Not enough\n-            raise TemplateSyntaxError(\"%s requires %d arguments, %d provided\" % (name, len(nondefs), plen))\n+            raise TemplateSyntaxError(\"%s requires %d arguments, %d provided\" %\n+                                      (name, len(nondefs), plen))\n \n         # Defaults can be overridden.\n         defaults = defaults and list(defaults) or []\n@@ -568,7 +631,8 @@ def args_check(name, func, provided):\n                 defaults.pop(0)\n         except IndexError:\n             # Too many.\n-            raise TemplateSyntaxError(\"%s requires %d arguments, %d provided\" % (name, len(nondefs), plen))\n+            raise TemplateSyntaxError(\"%s requires %d arguments, %d provided\" %\n+                                      (name, len(nondefs), plen))\n \n         return True\n     args_check = staticmethod(args_check)\n@@ -586,9 +650,9 @@ def resolve_variable(path, context):\n     return Variable(path).resolve(context)\n \n class Variable(object):\n-    r\"\"\"\n-    A template variable, resolvable against a given context. The variable may be\n-    a hard-coded string (if it begins and ends with single or double quote\n+    \"\"\"\n+    A template variable, resolvable against a given context. The variable may\n+    be a hard-coded string (if it begins and ends with single or double quote\n     marks)::\n \n         >>> c = {'article': {'section':u'News'}}\n@@ -642,7 +706,9 @@ def __init__(self, var):\n                 # Otherwise we'll set self.lookups so that resolve() knows we're\n                 # dealing with a bonafide variable\n                 if var.find(VARIABLE_ATTRIBUTE_SEPARATOR + '_') > -1 or var[0] == '_':\n-                    raise TemplateSyntaxError(\"Variables and attributes may not begin with underscores: '%s'\" % var)\n+                    raise TemplateSyntaxError(\"Variables and attributes may \"\n+                                              \"not begin with underscores: '%s'\" %\n+                                              var)\n                 self.lookups = tuple(var.split(VARIABLE_ATTRIBUTE_SEPARATOR))\n \n     def resolve(self, context):\n@@ -673,22 +739,23 @@ def _resolve_lookup(self, context):\n         instead.\n         \"\"\"\n         current = context\n-        try: # catch-all for silent variable failures\n+        try:  # catch-all for silent variable failures\n             for bit in self.lookups:\n-                try: # dictionary lookup\n+                try:  # dictionary lookup\n                     current = current[bit]\n                 except (TypeError, AttributeError, KeyError):\n-                    try: # attribute lookup\n+                    try:  # attribute lookup\n                         current = getattr(current, bit)\n                     except (TypeError, AttributeError):\n-                        try: # list-index lookup\n+                        try:  # list-index lookup\n                             current = current[int(bit)]\n-                        except (IndexError, # list index out of range\n-                                ValueError, # invalid literal for int()\n-                                KeyError,   # current is a dict without `int(bit)` key\n-                                TypeError,  # unsubscriptable object\n-                                ):\n-                            raise VariableDoesNotExist(\"Failed lookup for key [%s] in %r\", (bit, current)) # missing attribute\n+                        except (IndexError,  # list index out of range\n+                                ValueError,  # invalid literal for int()\n+                                KeyError,    # current is a dict without `int(bit)` key\n+                                TypeError):  # unsubscriptable object\n+                            raise VariableDoesNotExist(\"Failed lookup for key \"\n+                                                       \"[%s] in %r\",\n+                                                       (bit, current))  # missing attribute\n                 if callable(current):\n                     if getattr(current, 'do_not_call_in_templates', False):\n                         pass\n@@ -700,7 +767,7 @@ def _resolve_lookup(self, context):\n                         except TypeError: # arguments *were* required\n                             # GOTCHA: This will also catch any TypeError\n                             # raised in the function itself.\n-                            current = settings.TEMPLATE_STRING_IF_INVALID # invalid method call\n+                            current = settings.TEMPLATE_STRING_IF_INVALID  # invalid method call\n         except Exception, e:\n             if getattr(e, 'silent_variable_failure', False):\n                 current = settings.TEMPLATE_STRING_IF_INVALID\n@@ -716,14 +783,19 @@ class Node(object):\n     child_nodelists = ('nodelist',)\n \n     def render(self, context):\n-        \"Return the node rendered as a string\"\n+        \"\"\"\n+        Return the node rendered as a string.\n+        \"\"\"\n         pass\n \n     def __iter__(self):\n         yield self\n \n     def get_nodes_by_type(self, nodetype):\n-        \"Return a list of all nodes (within this node and its nodelist) of the given type\"\n+        \"\"\"\n+        Return a list of all nodes (within this node and its nodelist)\n+        of the given type\n+        \"\"\"\n         nodes = []\n         if isinstance(self, nodetype):\n             nodes.append(self)\n@@ -776,7 +848,8 @@ def _render_value_in_context(value, context):\n     \"\"\"\n     value = localize(value, use_l10n=context.use_l10n)\n     value = force_unicode(value)\n-    if (context.autoescape and not isinstance(value, SafeData)) or isinstance(value, EscapeData):\n+    if ((context.autoescape and not isinstance(value, SafeData)) or\n+            isinstance(value, EscapeData)):\n         return escape(value)\n     else:\n         return value\n@@ -793,34 +866,170 @@ def render(self, context):\n             output = self.filter_expression.resolve(context)\n         except UnicodeDecodeError:\n             # Unicode conversion can fail sometimes for reasons out of our\n-            # control (e.g. exception rendering). In that case, we fail quietly.\n+            # control (e.g. exception rendering). In that case, we fail\n+            # quietly.\n             return ''\n         return _render_value_in_context(output, context)\n \n-def generic_tag_compiler(params, defaults, name, node_class, parser, token):\n-    \"Returns a template.Node subclass.\"\n-    bits = token.split_contents()[1:]\n-    bmax = len(params)\n-    def_len = defaults and len(defaults) or 0\n-    bmin = bmax - def_len\n-    if(len(bits) < bmin or len(bits) > bmax):\n-        if bmin == bmax:\n-            message = \"%s takes %s arguments\" % (name, bmin)\n+# Regex for token keyword arguments\n+kwarg_re = re.compile(r\"(?:(\\w+)=)?(.+)\")\n+\n+def token_kwargs(bits, parser, support_legacy=False):\n+    \"\"\"\n+    A utility method for parsing token keyword arguments.\n+\n+    :param bits: A list containing remainder of the token (split by spaces)\n+        that is to be checked for arguments. Valid arguments will be removed\n+        from this list.\n+\n+    :param support_legacy: If set to true ``True``, the legacy format\n+        ``1 as foo`` will be accepted. Otherwise, only the standard ``foo=1``\n+        format is allowed.\n+\n+    :returns: A dictionary of the arguments retrieved from the ``bits`` token\n+        list.\n+\n+    There is no requirement for all remaining token ``bits`` to be keyword\n+    arguments, so the dictionary will be returned as soon as an invalid\n+    argument format is reached.\n+    \"\"\"\n+    if not bits:\n+        return {}\n+    match = kwarg_re.match(bits[0])\n+    kwarg_format = match and match.group(1)\n+    if not kwarg_format:\n+        if not support_legacy:\n+            return {}\n+        if len(bits) < 3 or bits[1] != 'as':\n+            return {}\n+\n+    kwargs = {}\n+    while bits:\n+        if kwarg_format:\n+            match = kwarg_re.match(bits[0])\n+            if not match or not match.group(1):\n+                return kwargs\n+            key, value = match.groups()\n+            del bits[:1]\n+        else:\n+            if len(bits) < 3 or bits[1] != 'as':\n+                return kwargs\n+            key, value = bits[2], bits[0]\n+            del bits[:3]\n+        kwargs[key] = parser.compile_filter(value)\n+        if bits and not kwarg_format:\n+            if bits[0] != 'and':\n+                return kwargs\n+            del bits[:1]\n+    return kwargs\n+\n+def parse_bits(parser, bits, params, varargs, varkw, defaults,\n+               takes_context, name):\n+    \"\"\"\n+    Parses bits for template tag helpers (simple_tag, include_tag and\n+    assignment_tag), in particular by detecting syntax errors and by\n+    extracting positional and keyword arguments.\n+    \"\"\"\n+    if takes_context:\n+        if params[0] == 'context':\n+            params = params[1:]\n+        else:\n+            raise TemplateSyntaxError(\n+                \"'%s' is decorated with takes_context=True so it must \"\n+                \"have a first argument of 'context'\" % name)\n+    args = []\n+    kwargs = {}\n+    unhandled_params = list(params)\n+    for bit in bits:\n+        # First we try to extract a potential kwarg from the bit\n+        kwarg = token_kwargs([bit], parser)\n+        if kwarg:\n+            # The kwarg was successfully extracted\n+            param, value = kwarg.items()[0]\n+            if param not in params and varkw is None:\n+                # An unexpected keyword argument was supplied\n+                raise TemplateSyntaxError(\n+                    \"'%s' received unexpected keyword argument '%s'\" %\n+                    (name, param))\n+            elif param in kwargs:\n+                # The keyword argument has already been supplied once\n+                raise TemplateSyntaxError(\n+                    \"'%s' received multiple values for keyword argument '%s'\" %\n+                    (name, param))\n+            else:\n+                # All good, record the keyword argument\n+                kwargs[str(param)] = value\n+                if param in unhandled_params:\n+                    # If using the keyword syntax for a positional arg, then\n+                    # consume it.\n+                    unhandled_params.remove(param)\n         else:\n-            message = \"%s takes between %s and %s arguments\" % (name, bmin, bmax)\n-        raise TemplateSyntaxError(message)\n-    return node_class(bits)\n+            if kwargs:\n+                raise TemplateSyntaxError(\n+                    \"'%s' received some positional argument(s) after some \"\n+                    \"keyword argument(s)\" % name)\n+            else:\n+                # Record the positional argument\n+                args.append(parser.compile_filter(bit))\n+                try:\n+                    # Consume from the list of expected positional arguments\n+                    unhandled_params.pop(0)\n+                except IndexError:\n+                    if varargs is None:\n+                        raise TemplateSyntaxError(\n+                            \"'%s' received too many positional arguments\" %\n+                            name)\n+    if defaults is not None:\n+        # Consider the last n params handled, where n is the\n+        # number of defaults.\n+        unhandled_params = unhandled_params[:-len(defaults)]\n+    if unhandled_params:\n+        # Some positional arguments were not supplied\n+        raise TemplateSyntaxError(\n+            u\"'%s' did not receive value(s) for the argument(s): %s\" %\n+            (name, u\", \".join([u\"'%s'\" % p for p in unhandled_params])))\n+    return args, kwargs\n+\n+def generic_tag_compiler(parser, token, params, varargs, varkw, defaults,\n+                         name, takes_context, node_class):\n+    \"\"\"\n+    Returns a template.Node subclass.\n+    \"\"\"\n+    bits = token.split_contents()[1:]\n+    args, kwargs = parse_bits(parser, bits, params, varargs, varkw,\n+                              defaults, takes_context, name)\n+    return node_class(takes_context, args, kwargs)\n+\n+class TagHelperNode(Node):\n+    \"\"\"\n+    Base class for tag helper nodes such as SimpleNode, InclusionNode and\n+    AssignmentNode. Manages the positional and keyword arguments to be passed\n+    to the decorated function.\n+    \"\"\"\n+\n+    def __init__(self, takes_context, args, kwargs):\n+        self.takes_context = takes_context\n+        self.args = args\n+        self.kwargs = kwargs\n+\n+    def get_resolved_arguments(self, context):\n+        resolved_args = [var.resolve(context) for var in self.args]\n+        if self.takes_context:\n+            resolved_args = [context] + resolved_args\n+        resolved_kwargs = dict((k, v.resolve(context))\n+                                for k, v in self.kwargs.items())\n+        return resolved_args, resolved_kwargs\n \n class Library(object):\n     def __init__(self):\n         self.filters = {}\n         self.tags = {}\n \n     def tag(self, name=None, compile_function=None):\n-        if name == None and compile_function == None:\n+        if name is None and compile_function is None:\n             # @register.tag()\n             return self.tag_function\n-        elif name != None and compile_function == None:\n+        elif name is not None and compile_function is None:\n             if callable(name):\n                 # @register.tag\n                 return self.tag_function(name)\n@@ -829,22 +1038,23 @@ def tag(self, name=None, compile_function=None):\n                 def dec(func):\n                     return self.tag(name, func)\n                 return dec\n-        elif name != None and compile_function != None:\n+        elif name is not None and compile_function is not None:\n             # register.tag('somename', somefunc)\n             self.tags[name] = compile_function\n             return compile_function\n         else:\n-            raise InvalidTemplateLibrary(\"Unsupported arguments to Library.tag: (%r, %r)\", (name, compile_function))\n+            raise InvalidTemplateLibrary(\"Unsupported arguments to \"\n+                \"Library.tag: (%r, %r)\", (name, compile_function))\n \n-    def tag_function(self,func):\n+    def tag_function(self, func):\n         self.tags[getattr(func, \"_decorated_function\", func).__name__] = func\n         return func\n \n     def filter(self, name=None, filter_func=None):\n-        if name == None and filter_func == None:\n+        if name is None and filter_func is None:\n             # @register.filter()\n             return self.filter_function\n-        elif filter_func == None:\n+        elif filter_func is None:\n             if callable(name):\n                 # @register.filter\n                 return self.filter_function(name)\n@@ -853,40 +1063,34 @@ def filter(self, name=None, filter_func=None):\n                 def dec(func):\n                     return self.filter(name, func)\n                 return dec\n-        elif name != None and filter_func != None:\n+        elif name is not None and filter_func is not None:\n             # register.filter('somename', somefunc)\n             self.filters[name] = filter_func\n             return filter_func\n         else:\n-            raise InvalidTemplateLibrary(\"Unsupported arguments to Library.filter: (%r, %r)\", (name, filter_func))\n+            raise InvalidTemplateLibrary(\"Unsupported arguments to \"\n+                \"Library.filter: (%r, %r)\", (name, filter_func))\n \n     def filter_function(self, func):\n         self.filters[getattr(func, \"_decorated_function\", func).__name__] = func\n         return func\n \n     def simple_tag(self, func=None, takes_context=None, name=None):\n         def dec(func):\n-            params, xx, xxx, defaults = getargspec(func)\n-            if takes_context:\n-                if params[0] == 'context':\n-                    params = params[1:]\n-                else:\n-                    raise TemplateSyntaxError(\"Any tag function decorated with takes_context=True must have a first argument of 'context'\")\n+            params, varargs, varkw, defaults = getargspec(func)\n \n-            class SimpleNode(Node):\n-                def __init__(self, vars_to_resolve):\n-                    self.vars_to_resolve = map(Variable, vars_to_resolve)\n+            class SimpleNode(TagHelperNode):\n \n                 def render(self, context):\n-                    resolved_vars = [var.resolve(context) for var in self.vars_to_resolve]\n-                    if takes_context:\n-                        func_args = [context] + resolved_vars\n-                    else:\n-                        func_args = resolved_vars\n-                    return func(*func_args)\n-\n-            function_name = name or getattr(func, '_decorated_function', func).__name__\n-            compile_func = partial(generic_tag_compiler, params, defaults, function_name, SimpleNode)\n+                    resolved_args, resolved_kwargs = self.get_resolved_arguments(context)\n+                    return func(*resolved_args, **resolved_kwargs)\n+\n+            function_name = (name or\n+                getattr(func, '_decorated_function', func).__name__)\n+            compile_func = partial(generic_tag_compiler,\n+                params=params, varargs=varargs, varkw=varkw,\n+                defaults=defaults, name=function_name,\n+                takes_context=takes_context, node_class=SimpleNode)\n             compile_func.__doc__ = func.__doc__\n             self.tag(function_name, compile_func)\n             return func\n@@ -902,52 +1106,33 @@ def render(self, context):\n \n     def assignment_tag(self, func=None, takes_context=None, name=None):\n         def dec(func):\n-            params, xx, xxx, defaults = getargspec(func)\n-            if takes_context:\n-                if params[0] == 'context':\n-                    params = params[1:]\n-                else:\n-                    raise TemplateSyntaxError(\"Any tag function decorated with takes_context=True must have a first argument of 'context'\")\n+            params, varargs, varkw, defaults = getargspec(func)\n \n-            class AssignmentNode(Node):\n-                def __init__(self, params_vars, target_var):\n-                    self.params_vars = map(Variable, params_vars)\n+            class AssignmentNode(TagHelperNode):\n+                def __init__(self, takes_context, args, kwargs, target_var):\n+                    super(AssignmentNode, self).__init__(takes_context, args, kwargs)\n                     self.target_var = target_var\n \n                 def render(self, context):\n-                    resolved_vars = [var.resolve(context) for var in self.params_vars]\n-                    if takes_context:\n-                        func_args = [context] + resolved_vars\n-                    else:\n-                        func_args = resolved_vars\n-                    context[self.target_var] = func(*func_args)\n+                    resolved_args, resolved_kwargs = self.get_resolved_arguments(context)\n+                    context[self.target_var] = func(*resolved_args, **resolved_kwargs)\n                     return ''\n \n+            function_name = (name or\n+                getattr(func, '_decorated_function', func).__name__)\n+\n             def compile_func(parser, token):\n-                bits = token.split_contents()\n-                tag_name = bits[0]\n-                bits = bits[1:]\n-                params_max = len(params)\n-                defaults_length = defaults and len(defaults) or 0\n-                params_min = params_max - defaults_length\n-                if (len(bits) < 2 or bits[-2] != 'as'):\n+                bits = token.split_contents()[1:]\n+                if len(bits) < 2 or bits[-2] != 'as':\n                     raise TemplateSyntaxError(\n                         \"'%s' tag takes at least 2 arguments and the \"\n-                        \"second last argument must be 'as'\" % tag_name)\n-                params_vars = bits[:-2]\n+                        \"second last argument must be 'as'\" % function_name)\n                 target_var = bits[-1]\n-                if (len(params_vars) < params_min or\n-                        len(params_vars) > params_max):\n-                    if params_min == params_max:\n-                        raise TemplateSyntaxError(\n-                            \"%s takes %s arguments\" % (tag_name, params_min))\n-                    else:\n-                        raise TemplateSyntaxError(\n-                            \"%s takes between %s and %s arguments\"\n-                            % (tag_name, params_min, params_max))\n-                return AssignmentNode(params_vars, target_var)\n+                bits = bits[:-2]\n+                args, kwargs = parse_bits(parser, bits, params,\n+                    varargs, varkw, defaults, takes_context, function_name)\n+                return AssignmentNode(takes_context, args, kwargs, target_var)\n \n-            function_name = name or getattr(func, '_decorated_function', func).__name__\n             compile_func.__doc__ = func.__doc__\n             self.tag(function_name, compile_func)\n             return func\n@@ -963,25 +1148,13 @@ def compile_func(parser, token):\n \n     def inclusion_tag(self, file_name, context_class=Context, takes_context=False, name=None):\n         def dec(func):\n-            params, xx, xxx, defaults = getargspec(func)\n-            if takes_context:\n-                if params[0] == 'context':\n-                    params = params[1:]\n-                else:\n-                    raise TemplateSyntaxError(\"Any tag function decorated with takes_context=True must have a first argument of 'context'\")\n+            params, varargs, varkw, defaults = getargspec(func)\n \n-            class InclusionNode(Node):\n-                def __init__(self, vars_to_resolve):\n-                    self.vars_to_resolve = map(Variable, vars_to_resolve)\n+            class InclusionNode(TagHelperNode):\n \n                 def render(self, context):\n-                    resolved_vars = [var.resolve(context) for var in self.vars_to_resolve]\n-                    if takes_context:\n-                        args = [context] + resolved_vars\n-                    else:\n-                        args = resolved_vars\n-\n-                    dict = func(*args)\n+                    resolved_args, resolved_kwargs = self.get_resolved_arguments(context)\n+                    _dict = func(*resolved_args, **resolved_kwargs)\n \n                     if not getattr(self, 'nodelist', False):\n                         from django.template.loader import get_template, select_template\n@@ -992,62 +1165,73 @@ def render(self, context):\n                         else:\n                             t = get_template(file_name)\n                         self.nodelist = t.nodelist\n-                    new_context = context_class(dict, **{\n+                    new_context = context_class(_dict, **{\n                         'autoescape': context.autoescape,\n                         'current_app': context.current_app,\n                         'use_l10n': context.use_l10n,\n                     })\n-                    # Copy across the CSRF token, if present, because inclusion\n-                    # tags are often used for forms, and we need instructions\n-                    # for using CSRF protection to be as simple as possible.\n+                    # Copy across the CSRF token, if present, because\n+                    # inclusion tags are often used for forms, and we need\n+                    # instructions for using CSRF protection to be as simple\n+                    # as possible.\n                     csrf_token = context.get('csrf_token', None)\n                     if csrf_token is not None:\n                         new_context['csrf_token'] = csrf_token\n                     return self.nodelist.render(new_context)\n \n-            function_name = name or getattr(func, '_decorated_function', func).__name__\n-            compile_func = partial(generic_tag_compiler, params, defaults, function_name, InclusionNode)\n+            function_name = (name or\n+                getattr(func, '_decorated_function', func).__name__)\n+            compile_func = partial(generic_tag_compiler,\n+                params=params, varargs=varargs, varkw=varkw,\n+                defaults=defaults, name=function_name,\n+                takes_context=takes_context, node_class=InclusionNode)\n             compile_func.__doc__ = func.__doc__\n             self.tag(function_name, compile_func)\n             return func\n         return dec\n \n def import_library(taglib_module):\n-    \"\"\"Load a template tag library module.\n+    \"\"\"\n+    Load a template tag library module.\n \n     Verifies that the library contains a 'register' attribute, and\n     returns that attribute as the representation of the library\n     \"\"\"\n-    app_path, taglib = taglib_module.rsplit('.',1)\n+    app_path, taglib = taglib_module.rsplit('.', 1)\n     app_module = import_module(app_path)\n     try:\n         mod = import_module(taglib_module)\n     except ImportError, e:\n-        # If the ImportError is because the taglib submodule does not exist, that's not\n-        # an error that should be raised. If the submodule exists and raised an ImportError\n-        # on the attempt to load it, that we want to raise.\n+        # If the ImportError is because the taglib submodule does not exist,\n+        # that's not an error that should be raised. If the submodule exists\n+        # and raised an ImportError on the attempt to load it, that we want\n+        # to raise.\n         if not module_has_submodule(app_module, taglib):\n             return None\n         else:\n-            raise InvalidTemplateLibrary(\"ImportError raised loading %s: %s\" % (taglib_module, e))\n+            raise InvalidTemplateLibrary(\"ImportError raised loading %s: %s\" %\n+                                         (taglib_module, e))\n     try:\n         return mod.register\n     except AttributeError:\n-        raise InvalidTemplateLibrary(\"Template library %s does not have a variable named 'register'\" % taglib_module)\n+        raise InvalidTemplateLibrary(\"Template library %s does not have \"\n+                                     \"a variable named 'register'\" %\n+                                     taglib_module)\n \n templatetags_modules = []\n \n def get_templatetags_modules():\n-    \"\"\"Return the list of all available template tag modules.\n+    \"\"\"\n+    Return the list of all available template tag modules.\n \n     Caches the result for faster access.\n     \"\"\"\n     global templatetags_modules\n     if not templatetags_modules:\n         _templatetags_modules = []\n-        # Populate list once per process. Mutate the local list first, and then\n-        # assign it to the global name to ensure there are no cases where two\n-        # threads try to populate it simultaneously.\n+        # Populate list once per process. Mutate the local list first, and\n+        # then assign it to the global name to ensure there are no cases where\n+        # two threads try to populate it simultaneously.\n         for app_module in ['django'] + list(settings.INSTALLED_APPS):\n             try:\n                 templatetag_module = '%s.templatetags' % app_module\n@@ -1062,12 +1246,13 @@ def get_library(library_name):\n     \"\"\"\n     Load the template library module with the given name.\n \n-    If library is not already loaded loop over all templatetags modules to locate it.\n+    If library is not already loaded loop over all templatetags modules\n+    to locate it.\n \n     {% load somelib %} and {% load someotherlib %} loops twice.\n \n-    Subsequent loads eg. {% load somelib %} in the same process will grab the cached\n-    module from libraries.\n+    Subsequent loads eg. {% load somelib %} in the same process will grab\n+    the cached module from libraries.\n     \"\"\"\n     lib = libraries.get(library_name, None)\n     if not lib:\n@@ -1081,11 +1266,16 @@ def get_library(library_name):\n                 libraries[library_name] = lib\n                 break\n         if not lib:\n-            raise InvalidTemplateLibrary(\"Template library %s not found, tried %s\" % (library_name, ','.join(tried_modules)))\n+            raise InvalidTemplateLibrary(\"Template library %s not found, \"\n+                                         \"tried %s\" %\n+                                         (library_name,\n+                                          ','.join(tried_modules)))\n     return lib\n \n+\n def add_to_builtins(module):\n     builtins.append(import_library(module))\n \n+\n add_to_builtins('django.template.defaulttags')\n add_to_builtins('django.template.defaultfilters')"
        },
        {
            "sha": "9620d1cb81e8c189e4a8a8b5230355a5736d1645",
            "filename": "django/template/defaulttags.py",
            "status": "modified",
            "additions": 1,
            "deletions": 52,
            "changes": 53,
            "blob_url": "https://github.com/django/django/blob/8137027fd770ceb02d593605b22b8cfff1ef2e66/django%2Ftemplate%2Fdefaulttags.py",
            "raw_url": "https://github.com/django/django/raw/8137027fd770ceb02d593605b22b8cfff1ef2e66/django%2Ftemplate%2Fdefaulttags.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftemplate%2Fdefaulttags.py?ref=8137027fd770ceb02d593605b22b8cfff1ef2e66",
            "patch": "@@ -10,64 +10,13 @@\n     TemplateSyntaxError, VariableDoesNotExist, InvalidTemplateLibrary,\n     BLOCK_TAG_START, BLOCK_TAG_END, VARIABLE_TAG_START, VARIABLE_TAG_END,\n     SINGLE_BRACE_START, SINGLE_BRACE_END, COMMENT_TAG_START, COMMENT_TAG_END,\n-    get_library)\n+    get_library, token_kwargs, kwarg_re)\n from django.template.smartif import IfParser, Literal\n from django.template.defaultfilters import date\n from django.utils.encoding import smart_str, smart_unicode\n from django.utils.safestring import mark_safe\n \n register = Library()\n-# Regex for token keyword arguments\n-kwarg_re = re.compile(r\"(?:(\\w+)=)?(.+)\")\n-\n-def token_kwargs(bits, parser, support_legacy=False):\n-    \"\"\"\n-    A utility method for parsing token keyword arguments.\n-\n-    :param bits: A list containing remainder of the token (split by spaces)\n-        that is to be checked for arguments. Valid arguments will be removed\n-        from this list.\n-\n-    :param support_legacy: If set to true ``True``, the legacy format\n-        ``1 as foo`` will be accepted. Otherwise, only the standard ``foo=1``\n-        format is allowed.\n-\n-    :returns: A dictionary of the arguments retrieved from the ``bits`` token\n-        list.\n-\n-    There is no requirement for all remaining token ``bits`` to be keyword\n-    arguments, so the dictionary will be returned as soon as an invalid\n-    argument format is reached.\n-    \"\"\"\n-    if not bits:\n-        return {}\n-    match = kwarg_re.match(bits[0])\n-    kwarg_format = match and match.group(1)\n-    if not kwarg_format:\n-        if not support_legacy:\n-            return {}\n-        if len(bits) < 3 or bits[1] != 'as':\n-            return {}\n-\n-    kwargs = {}\n-    while bits:\n-        if kwarg_format:\n-            match = kwarg_re.match(bits[0])\n-            if not match or not match.group(1):\n-                return kwargs\n-            key, value = match.groups()\n-            del bits[:1]\n-        else:\n-            if len(bits) < 3 or bits[1] != 'as':\n-                return kwargs\n-            key, value = bits[2], bits[0]\n-            del bits[:3]\n-        kwargs[key] = parser.compile_filter(value)\n-        if bits and not kwarg_format:\n-            if bits[0] != 'and':\n-                return kwargs\n-            del bits[:1]\n-    return kwargs\n \n class AutoEscapeControlNode(Node):\n     \"\"\"Implements the actions of the autoescape tag.\"\"\""
        },
        {
            "sha": "4001794680845d3f04ff69b07220fb0896092f27",
            "filename": "docs/howto/custom-template-tags.txt",
            "status": "modified",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/django/django/blob/8137027fd770ceb02d593605b22b8cfff1ef2e66/docs%2Fhowto%2Fcustom-template-tags.txt",
            "raw_url": "https://github.com/django/django/raw/8137027fd770ceb02d593605b22b8cfff1ef2e66/docs%2Fhowto%2Fcustom-template-tags.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fhowto%2Fcustom-template-tags.txt?ref=8137027fd770ceb02d593605b22b8cfff1ef2e66",
            "patch": "@@ -698,6 +698,29 @@ If you need to rename your tag, you can provide a custom name for it::\n     def some_function(value):\n         return value - 1\n \n+.. versionadded:: 1.4\n+\n+``simple_tag`` functions may accept any number of positional or keyword\n+arguments. For example:\n+\n+.. code-block:: python\n+\n+    @register.simple_tag\n+    def my_tag(a, b, *args, **kwargs):\n+        warning = kwargs['warning']\n+        profile = kwargs['profile']\n+        ...\n+        return ...\n+\n+Then in the template any number of arguments, separated by spaces, may be\n+passed to the template tag. Like in Python, the values for keyword arguments\n+are set using the equal sign (\"``=``\") and must be provided after the positional\n+arguments. For example:\n+\n+.. code-block:: html+django\n+\n+    {% my_tag 123 \"abcd\" book.title warning=message|lower profile=user.profile %}\n+\n .. _howto-custom-template-tags-assignment-tags:\n \n Assignment tags\n@@ -761,6 +784,27 @@ Or, using decorator syntax:\n For more information on how the ``takes_context`` option works, see the section\n on :ref:`inclusion tags<howto-custom-template-tags-inclusion-tags>`.\n \n+``assignment_tag`` functions may accept any number of positional or keyword\n+arguments. For example:\n+\n+.. code-block:: python\n+\n+    @register.assignment_tag\n+    def my_tag(a, b, *args, **kwargs):\n+        warning = kwargs['warning']\n+        profile = kwargs['profile']\n+        ...\n+        return ...\n+\n+Then in the template any number of arguments, separated by spaces, may be\n+passed to the template tag. Like in Python, the values for keyword arguments\n+are set using the equal sign (\"``=``\") and must be provided after the positional\n+arguments. For example:\n+\n+.. code-block:: html+django\n+\n+    {% my_tag 123 \"abcd\" book.title warning=message|lower profile=user.profile as the_result %}\n+\n .. _howto-custom-template-tags-inclusion-tags:\n \n Inclusion tags\n@@ -884,6 +928,29 @@ The ``takes_context`` parameter defaults to ``False``. When it's set to *True*,\n the tag is passed the context object, as in this example. That's the only\n difference between this case and the previous ``inclusion_tag`` example.\n \n+.. versionadded:: 1.4\n+\n+``inclusion_tag`` functions may accept any number of positional or keyword\n+arguments. For example:\n+\n+.. code-block:: python\n+\n+    @register.inclusion_tag('my_template.html')\n+    def my_tag(a, b, *args, **kwargs):\n+        warning = kwargs['warning']\n+        profile = kwargs['profile']\n+        ...\n+        return ...\n+\n+Then in the template any number of arguments, separated by spaces, may be\n+passed to the template tag. Like in Python, the values for keyword arguments\n+are set using the equal sign (\"``=``\") and must be provided after the positional\n+arguments. For example:\n+\n+.. code-block:: html+django\n+\n+    {% my_tag 123 \"abcd\" book.title warning=message|lower profile=user.profile %}\n+\n Setting a variable in the context\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "29fd5ef49f37023f6a6321cc4170e70d3209adbf",
            "filename": "docs/releases/1.4.txt",
            "status": "modified",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/django/django/blob/8137027fd770ceb02d593605b22b8cfff1ef2e66/docs%2Freleases%2F1.4.txt",
            "raw_url": "https://github.com/django/django/raw/8137027fd770ceb02d593605b22b8cfff1ef2e66/docs%2Freleases%2F1.4.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.4.txt?ref=8137027fd770ceb02d593605b22b8cfff1ef2e66",
            "patch": "@@ -162,6 +162,31 @@ A new helper function,\n ``template.Library`` to ease the creation of template tags that store some\n data in a specified context variable.\n \n+``*args`` and ``**kwargs`` support for template tag helper functions\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+:ref:`simple_tag<howto-custom-template-tags-simple-tags>`, :ref:`inclusion_tag\n+<howto-custom-template-tags-inclusion-tags>` and the newly introduced\n+:ref:`assignment_tag<howto-custom-template-tags-assignment-tags>` template\n+helper functions may now accept any number of positional or keyword arguments.\n+For example:\n+\n+.. code-block:: python\n+\n+    @register.simple_tag\n+    def my_tag(a, b, *args, **kwargs):\n+        warning = kwargs['warning']\n+        profile = kwargs['profile']\n+        ...\n+        return ...\n+\n+Then in the template any number of arguments may be passed to the template tag.\n+For example:\n+\n+.. code-block:: html+django\n+\n+    {% my_tag 123 \"abcd\" book.title warning=message|lower profile=user.profile %}\n+\n ``truncatechars`` template filter\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n "
        },
        {
            "sha": "c05229e6f2887cba0d6a02804db4db9823467cf7",
            "filename": "tests/regressiontests/templates/custom.py",
            "status": "modified",
            "additions": 217,
            "deletions": 18,
            "changes": 235,
            "blob_url": "https://github.com/django/django/blob/8137027fd770ceb02d593605b22b8cfff1ef2e66/tests%2Fregressiontests%2Ftemplates%2Fcustom.py",
            "raw_url": "https://github.com/django/django/raw/8137027fd770ceb02d593605b22b8cfff1ef2e66/tests%2Fregressiontests%2Ftemplates%2Fcustom.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftemplates%2Fcustom.py?ref=8137027fd770ceb02d593605b22b8cfff1ef2e66",
            "patch": "@@ -35,23 +35,71 @@ def test_simple_tags(self):\n         t = template.Template('{% load custom %}{% params_and_context 37 %}')\n         self.assertEqual(t.render(c), u'params_and_context - Expected result (context value: 42): 37')\n \n+        t = template.Template('{% load custom %}{% simple_two_params 37 42 %}')\n+        self.assertEqual(t.render(c), u'simple_two_params - Expected result: 37, 42')\n+\n+        t = template.Template('{% load custom %}{% simple_one_default 37 %}')\n+        self.assertEqual(t.render(c), u'simple_one_default - Expected result: 37, hi')\n+\n+        t = template.Template('{% load custom %}{% simple_one_default 37 two=\"hello\" %}')\n+        self.assertEqual(t.render(c), u'simple_one_default - Expected result: 37, hello')\n+\n+        t = template.Template('{% load custom %}{% simple_one_default one=99 two=\"hello\" %}')\n+        self.assertEqual(t.render(c), u'simple_one_default - Expected result: 99, hello')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'simple_one_default' received unexpected keyword argument 'three'\",\n+            template.Template, '{% load custom %}{% simple_one_default 99 two=\"hello\" three=\"foo\" %}')\n+\n+        t = template.Template('{% load custom %}{% simple_one_default 37 42 %}')\n+        self.assertEqual(t.render(c), u'simple_one_default - Expected result: 37, 42')\n+\n+        t = template.Template('{% load custom %}{% simple_unlimited_args 37 %}')\n+        self.assertEqual(t.render(c), u'simple_unlimited_args - Expected result: 37, hi')\n+\n+        t = template.Template('{% load custom %}{% simple_unlimited_args 37 42 56 89 %}')\n+        self.assertEqual(t.render(c), u'simple_unlimited_args - Expected result: 37, 42, 56, 89')\n+\n+        t = template.Template('{% load custom %}{% simple_only_unlimited_args %}')\n+        self.assertEqual(t.render(c), u'simple_only_unlimited_args - Expected result: ')\n+\n+        t = template.Template('{% load custom %}{% simple_only_unlimited_args 37 42 56 89 %}')\n+        self.assertEqual(t.render(c), u'simple_only_unlimited_args - Expected result: 37, 42, 56, 89')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'simple_two_params' received too many positional arguments\",\n+            template.Template, '{% load custom %}{% simple_two_params 37 42 56 %}')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'simple_one_default' received too many positional arguments\",\n+            template.Template, '{% load custom %}{% simple_one_default 37 42 56 %}')\n+\n+        t = template.Template('{% load custom %}{% simple_unlimited_args_kwargs 37 40|add:2 56 eggs=\"scrambled\" four=1|add:3 %}')\n+        self.assertEqual(t.render(c), u'simple_unlimited_args_kwargs - Expected result: 37, 42, 56 / eggs=scrambled, four=4')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'simple_unlimited_args_kwargs' received some positional argument\\(s\\) after some keyword argument\\(s\\)\",\n+            template.Template, '{% load custom %}{% simple_unlimited_args_kwargs 37 40|add:2 eggs=\"scrambled\" 56 four=1|add:3 %}')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'simple_unlimited_args_kwargs' received multiple values for keyword argument 'eggs'\",\n+            template.Template, '{% load custom %}{% simple_unlimited_args_kwargs 37 eggs=\"scrambled\" eggs=\"scrambled\" %}')\n+\n     def test_simple_tag_registration(self):\n         # Test that the decorators preserve the decorated function's docstring, name and attributes.\n         self.verify_tag(custom.no_params, 'no_params')\n         self.verify_tag(custom.one_param, 'one_param')\n         self.verify_tag(custom.explicit_no_context, 'explicit_no_context')\n         self.verify_tag(custom.no_params_with_context, 'no_params_with_context')\n         self.verify_tag(custom.params_and_context, 'params_and_context')\n+        self.verify_tag(custom.simple_unlimited_args_kwargs, 'simple_unlimited_args_kwargs')\n+        self.verify_tag(custom.simple_tag_without_context_parameter, 'simple_tag_without_context_parameter')\n \n     def test_simple_tag_missing_context(self):\n-        # That the 'context' parameter must be present when takes_context is True\n-        def a_simple_tag_without_parameters(arg):\n-            \"\"\"Expected __doc__\"\"\"\n-            return \"Expected result\"\n-\n-        register = template.Library()\n-        decorator = register.simple_tag(takes_context=True)\n-        self.assertRaises(template.TemplateSyntaxError, decorator, a_simple_tag_without_parameters)\n+        # The 'context' parameter must be present when takes_context is True\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'simple_tag_without_context_parameter' is decorated with takes_context=True so it must have a first argument of 'context'\",\n+            template.Template, '{% load custom %}{% simple_tag_without_context_parameter 123 %}')\n \n     def test_inclusion_tags(self):\n         c = template.Context({'value': 42})\n@@ -71,6 +119,70 @@ def test_inclusion_tags(self):\n         t = template.Template('{% load custom %}{% inclusion_params_and_context 37 %}')\n         self.assertEqual(t.render(c), u'inclusion_params_and_context - Expected result (context value: 42): 37\\n')\n \n+        t = template.Template('{% load custom %}{% inclusion_two_params 37 42 %}')\n+        self.assertEqual(t.render(c), u'inclusion_two_params - Expected result: 37, 42\\n')\n+\n+        t = template.Template('{% load custom %}{% inclusion_one_default 37 %}')\n+        self.assertEqual(t.render(c), u'inclusion_one_default - Expected result: 37, hi\\n')\n+\n+        t = template.Template('{% load custom %}{% inclusion_one_default 37 two=\"hello\" %}')\n+        self.assertEqual(t.render(c), u'inclusion_one_default - Expected result: 37, hello\\n')\n+\n+        t = template.Template('{% load custom %}{% inclusion_one_default one=99 two=\"hello\" %}')\n+        self.assertEqual(t.render(c), u'inclusion_one_default - Expected result: 99, hello\\n')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'inclusion_one_default' received unexpected keyword argument 'three'\",\n+            template.Template, '{% load custom %}{% inclusion_one_default 99 two=\"hello\" three=\"foo\" %}')\n+\n+        t = template.Template('{% load custom %}{% inclusion_one_default 37 42 %}')\n+        self.assertEqual(t.render(c), u'inclusion_one_default - Expected result: 37, 42\\n')\n+\n+        t = template.Template('{% load custom %}{% inclusion_unlimited_args 37 %}')\n+        self.assertEqual(t.render(c), u'inclusion_unlimited_args - Expected result: 37, hi\\n')\n+\n+        t = template.Template('{% load custom %}{% inclusion_unlimited_args 37 42 56 89 %}')\n+        self.assertEqual(t.render(c), u'inclusion_unlimited_args - Expected result: 37, 42, 56, 89\\n')\n+\n+        t = template.Template('{% load custom %}{% inclusion_only_unlimited_args %}')\n+        self.assertEqual(t.render(c), u'inclusion_only_unlimited_args - Expected result: \\n')\n+\n+        t = template.Template('{% load custom %}{% inclusion_only_unlimited_args 37 42 56 89 %}')\n+        self.assertEqual(t.render(c), u'inclusion_only_unlimited_args - Expected result: 37, 42, 56, 89\\n')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'inclusion_two_params' received too many positional arguments\",\n+            template.Template, '{% load custom %}{% inclusion_two_params 37 42 56 %}')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'inclusion_one_default' received too many positional arguments\",\n+            template.Template, '{% load custom %}{% inclusion_one_default 37 42 56 %}')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'inclusion_one_default' did not receive value\\(s\\) for the argument\\(s\\): 'one'\",\n+            template.Template, '{% load custom %}{% inclusion_one_default %}')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'inclusion_unlimited_args' did not receive value\\(s\\) for the argument\\(s\\): 'one'\",\n+            template.Template, '{% load custom %}{% inclusion_unlimited_args %}')\n+\n+        t = template.Template('{% load custom %}{% inclusion_unlimited_args_kwargs 37 40|add:2 56 eggs=\"scrambled\" four=1|add:3 %}')\n+        self.assertEqual(t.render(c), u'inclusion_unlimited_args_kwargs - Expected result: 37, 42, 56 / eggs=scrambled, four=4\\n')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'inclusion_unlimited_args_kwargs' received some positional argument\\(s\\) after some keyword argument\\(s\\)\",\n+            template.Template, '{% load custom %}{% inclusion_unlimited_args_kwargs 37 40|add:2 eggs=\"scrambled\" 56 four=1|add:3 %}')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'inclusion_unlimited_args_kwargs' received multiple values for keyword argument 'eggs'\",\n+            template.Template, '{% load custom %}{% inclusion_unlimited_args_kwargs 37 eggs=\"scrambled\" eggs=\"scrambled\" %}')\n+\n+    def test_include_tag_missing_context(self):\n+        # The 'context' parameter must be present when takes_context is True\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'inclusion_tag_without_context_parameter' is decorated with takes_context=True so it must have a first argument of 'context'\",\n+            template.Template, '{% load custom %}{% inclusion_tag_without_context_parameter 123 %}')\n+\n     def test_inclusion_tags_from_template(self):\n         c = template.Context({'value': 42})\n \n@@ -89,13 +201,42 @@ def test_inclusion_tags_from_template(self):\n         t = template.Template('{% load custom %}{% inclusion_params_and_context_from_template 37 %}')\n         self.assertEqual(t.render(c), u'inclusion_params_and_context_from_template - Expected result (context value: 42): 37\\n')\n \n+        t = template.Template('{% load custom %}{% inclusion_two_params_from_template 37 42 %}')\n+        self.assertEqual(t.render(c), u'inclusion_two_params_from_template - Expected result: 37, 42\\n')\n+\n+        t = template.Template('{% load custom %}{% inclusion_one_default_from_template 37 %}')\n+        self.assertEqual(t.render(c), u'inclusion_one_default_from_template - Expected result: 37, hi\\n')\n+\n+        t = template.Template('{% load custom %}{% inclusion_one_default_from_template 37 42 %}')\n+        self.assertEqual(t.render(c), u'inclusion_one_default_from_template - Expected result: 37, 42\\n')\n+\n+        t = template.Template('{% load custom %}{% inclusion_unlimited_args_from_template 37 %}')\n+        self.assertEqual(t.render(c), u'inclusion_unlimited_args_from_template - Expected result: 37, hi\\n')\n+\n+        t = template.Template('{% load custom %}{% inclusion_unlimited_args_from_template 37 42 56 89 %}')\n+        self.assertEqual(t.render(c), u'inclusion_unlimited_args_from_template - Expected result: 37, 42, 56, 89\\n')\n+\n+        t = template.Template('{% load custom %}{% inclusion_only_unlimited_args_from_template %}')\n+        self.assertEqual(t.render(c), u'inclusion_only_unlimited_args_from_template - Expected result: \\n')\n+\n+        t = template.Template('{% load custom %}{% inclusion_only_unlimited_args_from_template 37 42 56 89 %}')\n+        self.assertEqual(t.render(c), u'inclusion_only_unlimited_args_from_template - Expected result: 37, 42, 56, 89\\n')\n+\n     def test_inclusion_tag_registration(self):\n         # Test that the decorators preserve the decorated function's docstring, name and attributes.\n         self.verify_tag(custom.inclusion_no_params, 'inclusion_no_params')\n         self.verify_tag(custom.inclusion_one_param, 'inclusion_one_param')\n         self.verify_tag(custom.inclusion_explicit_no_context, 'inclusion_explicit_no_context')\n         self.verify_tag(custom.inclusion_no_params_with_context, 'inclusion_no_params_with_context')\n         self.verify_tag(custom.inclusion_params_and_context, 'inclusion_params_and_context')\n+        self.verify_tag(custom.inclusion_two_params, 'inclusion_two_params')\n+        self.verify_tag(custom.inclusion_one_default, 'inclusion_one_default')\n+        self.verify_tag(custom.inclusion_unlimited_args, 'inclusion_unlimited_args')\n+        self.verify_tag(custom.inclusion_only_unlimited_args, 'inclusion_only_unlimited_args')\n+        self.verify_tag(custom.inclusion_tag_without_context_parameter, 'inclusion_tag_without_context_parameter')\n+        self.verify_tag(custom.inclusion_tag_use_l10n, 'inclusion_tag_use_l10n')\n+        self.verify_tag(custom.inclusion_tag_current_app, 'inclusion_tag_current_app')\n+        self.verify_tag(custom.inclusion_unlimited_args_kwargs, 'inclusion_unlimited_args_kwargs')\n \n     def test_15070_current_app(self):\n         \"\"\"\n@@ -139,6 +280,37 @@ def test_assignment_tags(self):\n         t = template.Template('{% load custom %}{% assignment_params_and_context 37 as var %}The result is: {{ var }}')\n         self.assertEqual(t.render(c), u'The result is: assignment_params_and_context - Expected result (context value: 42): 37')\n \n+        t = template.Template('{% load custom %}{% assignment_two_params 37 42 as var %}The result is: {{ var }}')\n+        self.assertEqual(t.render(c), u'The result is: assignment_two_params - Expected result: 37, 42')\n+\n+        t = template.Template('{% load custom %}{% assignment_one_default 37 as var %}The result is: {{ var }}')\n+        self.assertEqual(t.render(c), u'The result is: assignment_one_default - Expected result: 37, hi')\n+\n+        t = template.Template('{% load custom %}{% assignment_one_default 37 two=\"hello\" as var %}The result is: {{ var }}')\n+        self.assertEqual(t.render(c), u'The result is: assignment_one_default - Expected result: 37, hello')\n+\n+        t = template.Template('{% load custom %}{% assignment_one_default one=99 two=\"hello\" as var %}The result is: {{ var }}')\n+        self.assertEqual(t.render(c), u'The result is: assignment_one_default - Expected result: 99, hello')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'assignment_one_default' received unexpected keyword argument 'three'\",\n+            template.Template, '{% load custom %}{% assignment_one_default 99 two=\"hello\" three=\"foo\" as var %}')\n+\n+        t = template.Template('{% load custom %}{% assignment_one_default 37 42 as var %}The result is: {{ var }}')\n+        self.assertEqual(t.render(c), u'The result is: assignment_one_default - Expected result: 37, 42')\n+\n+        t = template.Template('{% load custom %}{% assignment_unlimited_args 37 as var %}The result is: {{ var }}')\n+        self.assertEqual(t.render(c), u'The result is: assignment_unlimited_args - Expected result: 37, hi')\n+\n+        t = template.Template('{% load custom %}{% assignment_unlimited_args 37 42 56 89 as var %}The result is: {{ var }}')\n+        self.assertEqual(t.render(c), u'The result is: assignment_unlimited_args - Expected result: 37, 42, 56, 89')\n+\n+        t = template.Template('{% load custom %}{% assignment_only_unlimited_args as var %}The result is: {{ var }}')\n+        self.assertEqual(t.render(c), u'The result is: assignment_only_unlimited_args - Expected result: ')\n+\n+        t = template.Template('{% load custom %}{% assignment_only_unlimited_args 37 42 56 89 as var %}The result is: {{ var }}')\n+        self.assertEqual(t.render(c), u'The result is: assignment_only_unlimited_args - Expected result: 37, 42, 56, 89')\n+\n         self.assertRaisesRegexp(template.TemplateSyntaxError,\n             \"'assignment_one_param' tag takes at least 2 arguments and the second last argument must be 'as'\",\n             template.Template, '{% load custom %}{% assignment_one_param 37 %}The result is: {{ var }}')\n@@ -151,23 +323,50 @@ def test_assignment_tags(self):\n             \"'assignment_one_param' tag takes at least 2 arguments and the second last argument must be 'as'\",\n             template.Template, '{% load custom %}{% assignment_one_param 37 ass var %}The result is: {{ var }}')\n \n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'assignment_two_params' received too many positional arguments\",\n+            template.Template, '{% load custom %}{% assignment_two_params 37 42 56 as var %}The result is: {{ var }}')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'assignment_one_default' received too many positional arguments\",\n+            template.Template, '{% load custom %}{% assignment_one_default 37 42 56 as var %}The result is: {{ var }}')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'assignment_one_default' did not receive value\\(s\\) for the argument\\(s\\): 'one'\",\n+            template.Template, '{% load custom %}{% assignment_one_default as var %}The result is: {{ var }}')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'assignment_unlimited_args' did not receive value\\(s\\) for the argument\\(s\\): 'one'\",\n+            template.Template, '{% load custom %}{% assignment_unlimited_args as var %}The result is: {{ var }}')\n+\n+        t = template.Template('{% load custom %}{% assignment_unlimited_args_kwargs 37 40|add:2 56 eggs=\"scrambled\" four=1|add:3 as var %}The result is: {{ var }}')\n+        self.assertEqual(t.render(c), u'The result is: assignment_unlimited_args_kwargs - Expected result: 37, 42, 56 / eggs=scrambled, four=4')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'assignment_unlimited_args_kwargs' received some positional argument\\(s\\) after some keyword argument\\(s\\)\",\n+            template.Template, '{% load custom %}{% assignment_unlimited_args_kwargs 37 40|add:2 eggs=\"scrambled\" 56 four=1|add:3 as var %}The result is: {{ var }}')\n+\n+        self.assertRaisesRegexp(template.TemplateSyntaxError,\n+            \"'assignment_unlimited_args_kwargs' received multiple values for keyword argument 'eggs'\",\n+            template.Template, '{% load custom %}{% assignment_unlimited_args_kwargs 37 eggs=\"scrambled\" eggs=\"scrambled\" as var %}The result is: {{ var }}')\n+\n     def test_assignment_tag_registration(self):\n         # Test that the decorators preserve the decorated function's docstring, name and attributes.\n         self.verify_tag(custom.assignment_no_params, 'assignment_no_params')\n         self.verify_tag(custom.assignment_one_param, 'assignment_one_param')\n         self.verify_tag(custom.assignment_explicit_no_context, 'assignment_explicit_no_context')\n         self.verify_tag(custom.assignment_no_params_with_context, 'assignment_no_params_with_context')\n         self.verify_tag(custom.assignment_params_and_context, 'assignment_params_and_context')\n+        self.verify_tag(custom.assignment_one_default, 'assignment_one_default')\n+        self.verify_tag(custom.assignment_two_params, 'assignment_two_params')\n+        self.verify_tag(custom.assignment_unlimited_args, 'assignment_unlimited_args')\n+        self.verify_tag(custom.assignment_only_unlimited_args, 'assignment_only_unlimited_args')\n+        self.verify_tag(custom.assignment_unlimited_args, 'assignment_unlimited_args')\n+        self.verify_tag(custom.assignment_unlimited_args_kwargs, 'assignment_unlimited_args_kwargs')\n+        self.verify_tag(custom.assignment_tag_without_context_parameter, 'assignment_tag_without_context_parameter')\n \n     def test_assignment_tag_missing_context(self):\n-        # That the 'context' parameter must be present when takes_context is True\n-        def an_assignment_tag_without_parameters(arg):\n-            \"\"\"Expected __doc__\"\"\"\n-            return \"Expected result\"\n-\n-        register = template.Library()\n-        decorator = register.assignment_tag(takes_context=True)\n-\n+        # The 'context' parameter must be present when takes_context is True\n         self.assertRaisesRegexp(template.TemplateSyntaxError,\n-            \"Any tag function decorated with takes_context=True must have a first argument of 'context'\",\n-            decorator, an_assignment_tag_without_parameters)\n+            \"'assignment_tag_without_context_parameter' is decorated with takes_context=True so it must have a first argument of 'context'\",\n+            template.Template, '{% load custom %}{% assignment_tag_without_context_parameter 123 as var %}')"
        },
        {
            "sha": "86206617b896327b8ac9e24d14cefdb252cb28db",
            "filename": "tests/regressiontests/templates/templatetags/custom.py",
            "status": "modified",
            "additions": 164,
            "deletions": 11,
            "changes": 175,
            "blob_url": "https://github.com/django/django/blob/8137027fd770ceb02d593605b22b8cfff1ef2e66/tests%2Fregressiontests%2Ftemplates%2Ftemplatetags%2Fcustom.py",
            "raw_url": "https://github.com/django/django/raw/8137027fd770ceb02d593605b22b8cfff1ef2e66/tests%2Fregressiontests%2Ftemplates%2Ftemplatetags%2Fcustom.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftemplates%2Ftemplatetags%2Fcustom.py?ref=8137027fd770ceb02d593605b22b8cfff1ef2e66",
            "patch": "@@ -1,3 +1,5 @@\n+import operator\n+\n from django import template\n from django.template.defaultfilters import stringfilter\n from django.template.loader import get_template\n@@ -40,6 +42,61 @@ def params_and_context(context, arg):\n     return \"params_and_context - Expected result (context value: %s): %s\" % (context['value'], arg)\n params_and_context.anything = \"Expected params_and_context __dict__\"\n \n+@register.simple_tag\n+def simple_two_params(one, two):\n+    \"\"\"Expected simple_two_params __doc__\"\"\"\n+    return \"simple_two_params - Expected result: %s, %s\" % (one, two)\n+simple_two_params.anything = \"Expected simple_two_params __dict__\"\n+\n+@register.simple_tag\n+def simple_one_default(one, two='hi'):\n+    \"\"\"Expected simple_one_default __doc__\"\"\"\n+    return \"simple_one_default - Expected result: %s, %s\" % (one, two)\n+simple_one_default.anything = \"Expected simple_one_default __dict__\"\n+\n+@register.simple_tag\n+def simple_unlimited_args(one, two='hi', *args):\n+    \"\"\"Expected simple_unlimited_args __doc__\"\"\"\n+    return \"simple_unlimited_args - Expected result: %s\" % (', '.join([unicode(arg) for arg in [one, two] + list(args)]))\n+simple_unlimited_args.anything = \"Expected simple_unlimited_args __dict__\"\n+\n+@register.simple_tag\n+def simple_only_unlimited_args(*args):\n+    \"\"\"Expected simple_only_unlimited_args __doc__\"\"\"\n+    return \"simple_only_unlimited_args - Expected result: %s\" % ', '.join([unicode(arg) for arg in args])\n+simple_only_unlimited_args.anything = \"Expected simple_only_unlimited_args __dict__\"\n+\n+@register.simple_tag\n+def simple_unlimited_args_kwargs(one, two='hi', *args, **kwargs):\n+    \"\"\"Expected simple_unlimited_args_kwargs __doc__\"\"\"\n+    # Sort the dictionary by key to guarantee the order for testing.\n+    sorted_kwarg = sorted(kwargs.iteritems(), key=operator.itemgetter(0))\n+    return \"simple_unlimited_args_kwargs - Expected result: %s / %s\" % (\n+        ', '.join([unicode(arg) for arg in [one, two] + list(args)]),\n+        ', '.join(['%s=%s' % (k, v) for (k, v) in sorted_kwarg])\n+        )\n+simple_unlimited_args_kwargs.anything = \"Expected simple_unlimited_args_kwargs __dict__\"\n+\n+@register.simple_tag(takes_context=True)\n+def simple_tag_without_context_parameter(arg):\n+    \"\"\"Expected simple_tag_without_context_parameter __doc__\"\"\"\n+    return \"Expected result\"\n+simple_tag_without_context_parameter.anything = \"Expected simple_tag_without_context_parameter __dict__\"\n+\n+@register.simple_tag(takes_context=True)\n+def current_app(context):\n+    return \"%s\" % context.current_app\n+\n+@register.simple_tag(takes_context=True)\n+def use_l10n(context):\n+    return \"%s\" % context.use_l10n\n+\n+@register.simple_tag(name='minustwo')\n+def minustwo_overridden_name(value):\n+    return value - 2\n+\n+register.simple_tag(lambda x: x - 1, name='minusone')\n+\n @register.inclusion_tag('inclusion.html')\n def inclusion_no_params():\n     \"\"\"Expected inclusion_no_params __doc__\"\"\"\n@@ -100,21 +157,82 @@ def inclusion_params_and_context_from_template(context, arg):\n     return {\"result\" : \"inclusion_params_and_context_from_template - Expected result (context value: %s): %s\" % (context['value'], arg)}\n inclusion_params_and_context_from_template.anything = \"Expected inclusion_params_and_context_from_template __dict__\"\n \n-@register.simple_tag(takes_context=True)\n-def current_app(context):\n-    return \"%s\" % context.current_app\n+@register.inclusion_tag('inclusion.html')\n+def inclusion_two_params(one, two):\n+    \"\"\"Expected inclusion_two_params __doc__\"\"\"\n+    return {\"result\": \"inclusion_two_params - Expected result: %s, %s\" % (one, two)}\n+inclusion_two_params.anything = \"Expected inclusion_two_params __dict__\"\n+\n+@register.inclusion_tag(get_template('inclusion.html'))\n+def inclusion_two_params_from_template(one, two):\n+    \"\"\"Expected inclusion_two_params_from_template __doc__\"\"\"\n+    return {\"result\": \"inclusion_two_params_from_template - Expected result: %s, %s\" % (one, two)}\n+inclusion_two_params_from_template.anything = \"Expected inclusion_two_params_from_template __dict__\"\n+\n+@register.inclusion_tag('inclusion.html')\n+def inclusion_one_default(one, two='hi'):\n+    \"\"\"Expected inclusion_one_default __doc__\"\"\"\n+    return {\"result\": \"inclusion_one_default - Expected result: %s, %s\" % (one, two)}\n+inclusion_one_default.anything = \"Expected inclusion_one_default __dict__\"\n+\n+@register.inclusion_tag(get_template('inclusion.html'))\n+def inclusion_one_default_from_template(one, two='hi'):\n+    \"\"\"Expected inclusion_one_default_from_template __doc__\"\"\"\n+    return {\"result\": \"inclusion_one_default_from_template - Expected result: %s, %s\" % (one, two)}\n+inclusion_one_default_from_template.anything = \"Expected inclusion_one_default_from_template __dict__\"\n+\n+@register.inclusion_tag('inclusion.html')\n+def inclusion_unlimited_args(one, two='hi', *args):\n+    \"\"\"Expected inclusion_unlimited_args __doc__\"\"\"\n+    return {\"result\": \"inclusion_unlimited_args - Expected result: %s\" % (', '.join([unicode(arg) for arg in [one, two] + list(args)]))}\n+inclusion_unlimited_args.anything = \"Expected inclusion_unlimited_args __dict__\"\n+\n+@register.inclusion_tag(get_template('inclusion.html'))\n+def inclusion_unlimited_args_from_template(one, two='hi', *args):\n+    \"\"\"Expected inclusion_unlimited_args_from_template __doc__\"\"\"\n+    return {\"result\": \"inclusion_unlimited_args_from_template - Expected result: %s\" % (', '.join([unicode(arg) for arg in [one, two] + list(args)]))}\n+inclusion_unlimited_args_from_template.anything = \"Expected inclusion_unlimited_args_from_template __dict__\"\n+\n+@register.inclusion_tag('inclusion.html')\n+def inclusion_only_unlimited_args(*args):\n+    \"\"\"Expected inclusion_only_unlimited_args __doc__\"\"\"\n+    return {\"result\": \"inclusion_only_unlimited_args - Expected result: %s\" % (', '.join([unicode(arg) for arg in args]))}\n+inclusion_only_unlimited_args.anything = \"Expected inclusion_only_unlimited_args __dict__\"\n+\n+@register.inclusion_tag(get_template('inclusion.html'))\n+def inclusion_only_unlimited_args_from_template(*args):\n+    \"\"\"Expected inclusion_only_unlimited_args_from_template __doc__\"\"\"\n+    return {\"result\": \"inclusion_only_unlimited_args_from_template - Expected result: %s\" % (', '.join([unicode(arg) for arg in args]))}\n+inclusion_only_unlimited_args_from_template.anything = \"Expected inclusion_only_unlimited_args_from_template __dict__\"\n \n @register.inclusion_tag('test_incl_tag_current_app.html', takes_context=True)\n def inclusion_tag_current_app(context):\n+    \"\"\"Expected inclusion_tag_current_app __doc__\"\"\"\n     return {}\n-\n-@register.simple_tag(takes_context=True)\n-def use_l10n(context):\n-    return \"%s\" % context.use_l10n\n+inclusion_tag_current_app.anything = \"Expected inclusion_tag_current_app __dict__\"\n \n @register.inclusion_tag('test_incl_tag_use_l10n.html', takes_context=True)\n def inclusion_tag_use_l10n(context):\n+    \"\"\"Expected inclusion_tag_use_l10n __doc__\"\"\"\n+    return {}\n+inclusion_tag_use_l10n.anything = \"Expected inclusion_tag_use_l10n __dict__\"\n+\n+@register.inclusion_tag('inclusion.html')\n+def inclusion_unlimited_args_kwargs(one, two='hi', *args, **kwargs):\n+    \"\"\"Expected inclusion_unlimited_args_kwargs __doc__\"\"\"\n+    # Sort the dictionary by key to guarantee the order for testing.\n+    sorted_kwarg = sorted(kwargs.iteritems(), key=operator.itemgetter(0))\n+    return {\"result\": \"inclusion_unlimited_args_kwargs - Expected result: %s / %s\" % (\n+        ', '.join([unicode(arg) for arg in [one, two] + list(args)]),\n+        ', '.join(['%s=%s' % (k, v) for (k, v) in sorted_kwarg])\n+        )}\n+inclusion_unlimited_args_kwargs.anything = \"Expected inclusion_unlimited_args_kwargs __dict__\"\n+\n+@register.inclusion_tag('inclusion.html', takes_context=True)\n+def inclusion_tag_without_context_parameter(arg):\n+    \"\"\"Expected inclusion_tag_without_context_parameter __doc__\"\"\"\n     return {}\n+inclusion_tag_without_context_parameter.anything = \"Expected inclusion_tag_without_context_parameter __dict__\"\n \n @register.assignment_tag\n def assignment_no_params():\n@@ -146,8 +264,43 @@ def assignment_params_and_context(context, arg):\n     return \"assignment_params_and_context - Expected result (context value: %s): %s\" % (context['value'], arg)\n assignment_params_and_context.anything = \"Expected assignment_params_and_context __dict__\"\n \n-register.simple_tag(lambda x: x - 1, name='minusone')\n+@register.assignment_tag\n+def assignment_two_params(one, two):\n+    \"\"\"Expected assignment_two_params __doc__\"\"\"\n+    return \"assignment_two_params - Expected result: %s, %s\" % (one, two)\n+assignment_two_params.anything = \"Expected assignment_two_params __dict__\"\n \n-@register.simple_tag(name='minustwo')\n-def minustwo_overridden_name(value):\n-    return value - 2\n+@register.assignment_tag\n+def assignment_one_default(one, two='hi'):\n+    \"\"\"Expected assignment_one_default __doc__\"\"\"\n+    return \"assignment_one_default - Expected result: %s, %s\" % (one, two)\n+assignment_one_default.anything = \"Expected assignment_one_default __dict__\"\n+\n+@register.assignment_tag\n+def assignment_unlimited_args(one, two='hi', *args):\n+    \"\"\"Expected assignment_unlimited_args __doc__\"\"\"\n+    return \"assignment_unlimited_args - Expected result: %s\" % (', '.join([unicode(arg) for arg in [one, two] + list(args)]))\n+assignment_unlimited_args.anything = \"Expected assignment_unlimited_args __dict__\"\n+\n+@register.assignment_tag\n+def assignment_only_unlimited_args(*args):\n+    \"\"\"Expected assignment_only_unlimited_args __doc__\"\"\"\n+    return \"assignment_only_unlimited_args - Expected result: %s\" % ', '.join([unicode(arg) for arg in args])\n+assignment_only_unlimited_args.anything = \"Expected assignment_only_unlimited_args __dict__\"\n+\n+@register.assignment_tag\n+def assignment_unlimited_args_kwargs(one, two='hi', *args, **kwargs):\n+    \"\"\"Expected assignment_unlimited_args_kwargs __doc__\"\"\"\n+    # Sort the dictionary by key to guarantee the order for testing.\n+    sorted_kwarg = sorted(kwargs.iteritems(), key=operator.itemgetter(0))\n+    return \"assignment_unlimited_args_kwargs - Expected result: %s / %s\" % (\n+        ', '.join([unicode(arg) for arg in [one, two] + list(args)]),\n+        ', '.join(['%s=%s' % (k, v) for (k, v) in sorted_kwarg])\n+        )\n+assignment_unlimited_args_kwargs.anything = \"Expected assignment_unlimited_args_kwargs __dict__\"\n+\n+@register.assignment_tag(takes_context=True)\n+def assignment_tag_without_context_parameter(arg):\n+    \"\"\"Expected assignment_tag_without_context_parameter __doc__\"\"\"\n+    return \"Expected result\"\n+assignment_tag_without_context_parameter.anything = \"Expected assignment_tag_without_context_parameter __dict__\"\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 1115,
        "additions": 849,
        "deletions": 266
    }
}