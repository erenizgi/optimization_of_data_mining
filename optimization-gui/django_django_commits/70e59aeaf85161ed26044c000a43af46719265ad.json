{
    "author": "malcolmt",
    "message": "Be very clear about when it's appropriate to use defer() and only().\n\nI've been seeing a bit of over-reliance on defer() and only() in code\naround the place and it's generally better modelled with normalised data\nor shadow (unmanaged) models. This commit makes this position clearer.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16692 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "70e59aeaf85161ed26044c000a43af46719265ad",
    "files": [
        {
            "sha": "cf1b3f97e4d1f4f89b6af6a92b57229fd0fc349f",
            "filename": "docs/ref/models/options.txt",
            "status": "modified",
            "additions": 17,
            "deletions": 16,
            "changes": 33,
            "blob_url": "https://github.com/django/django/blob/70e59aeaf85161ed26044c000a43af46719265ad/docs%2Fref%2Fmodels%2Foptions.txt",
            "raw_url": "https://github.com/django/django/raw/70e59aeaf85161ed26044c000a43af46719265ad/docs%2Fref%2Fmodels%2Foptions.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Foptions.txt?ref=70e59aeaf85161ed26044c000a43af46719265ad",
            "patch": "@@ -91,29 +91,30 @@ Django quotes column and table names behind the scenes.\n \n     Defaults to ``True``, meaning Django will create the appropriate database\n     tables in :djadmin:`syncdb` and remove them as part of a :djadmin:`reset`\n-    management command. That is, Django *manages* the database tables' lifecycles.\n+    management command. That is, Django *manages* the database tables'\n+    lifecycles.\n \n     If ``False``, no database table creation or deletion operations will be\n     performed for this model. This is useful if the model represents an existing\n     table or a database view that has been created by some other means. This is\n     the *only* difference when ``managed=False``. All other aspects of\n     model handling are exactly the same as normal. This includes\n \n-        1. Adding an automatic primary key field to the model if you don't declare\n-           it.  To avoid confusion for later code readers, it's recommended to\n-           specify all the columns from the database table you are modeling when\n-           using unmanaged models.\n-\n-        2. If a model with ``managed=False`` contains a\n-           :class:`~django.db.models.ManyToManyField` that points to another\n-           unmanaged model, then the intermediate table for the many-to-many join\n-           will also not be created. However, the intermediary table between one\n-           managed and one unmanaged model *will* be created.\n-\n-           If you need to change this default behavior, create the intermediary\n-           table as an explicit model (with ``managed`` set as needed) and use the\n-           :attr:`ManyToManyField.through` attribute to make the relation use your\n-           custom model.\n+\t1. Adding an automatic primary key field to the model if you don't\n+\t   declare it.  To avoid confusion for later code readers, it's\n+\t   recommended to specify all the columns from the database table you\n+\t   are modeling when using unmanaged models.\n+\n+\t2. If a model with ``managed=False`` contains a\n+\t   :class:`~django.db.models.ManyToManyField` that points to another\n+\t   unmanaged model, then the intermediate table for the many-to-many\n+\t   join will also not be created. However, the intermediary table\n+\t   between one managed and one unmanaged model *will* be created.\n+\n+\t   If you need to change this default behavior, create the intermediary\n+\t   table as an explicit model (with ``managed`` set as needed) and use\n+\t   the :attr:`ManyToManyField.through` attribute to make the relation\n+\t   use your custom model.\n \n     For tests involving models with ``managed=False``, it's up to you to ensure\n     the correct tables are created as part of the test setup."
        },
        {
            "sha": "0a8adf6446517220ab7df4086084ac12481d52e5",
            "filename": "docs/ref/models/querysets.txt",
            "status": "modified",
            "additions": 20,
            "deletions": 4,
            "changes": 24,
            "blob_url": "https://github.com/django/django/blob/70e59aeaf85161ed26044c000a43af46719265ad/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "raw_url": "https://github.com/django/django/raw/70e59aeaf85161ed26044c000a43af46719265ad/docs%2Fref%2Fmodels%2Fquerysets.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Fquerysets.txt?ref=70e59aeaf85161ed26044c000a43af46719265ad",
            "patch": "@@ -139,7 +139,7 @@ Though you usually won't create one manually -- you'll go through a\n         clause or a default ordering on the model. ``False`` otherwise.\n \n     .. attribute:: db\n-    \n+\n         The database that will be used if this query is executed now.\n \n     .. note::\n@@ -906,9 +906,21 @@ eventually).\n     analyzed your queries closely and understand *exactly* what information\n     you need and have measured that the difference between returning the\n     fields you need and the full set of fields for the model will be\n-    significant. When you are initially developing your applications, don't\n-    bother using ``defer()``; leave it until your query construction has\n-    settled down and you understand where the hot-points are.\n+    significant.\n+\n+    Even if you think you are in the advanced use-case situation, **only use\n+    defer() when you cannot, at queryset load time, determine if you will need\n+    the extra fields or not**. If you are frequently loading and using a\n+    particular subset of your data, the best choice you can make is to\n+    normalize your models and put the non-loaded data into a separate model\n+    (and database table). If the columns *must* stay in the one table for some\n+    reason, create a model with ``Meta.managed = False`` (see the\n+    :py:attr:`managed attribute <django.db.models.Options.managed>`\n+    documentation) containing just the fields you normally need to load and use\n+    that where you might otherwise call ``defer()``. This makes your code more\n+    explicit to the reader, is slightly faster and consumes a little less\n+    memory in the Python process.\n+\n \n only\n ~~~~\n@@ -946,6 +958,10 @@ logically::\n     # existing set of fields).\n     Entry.objects.defer(\"body\").only(\"headline\", \"body\")\n \n+All of the cautions in the note for the :py:meth:`defer` documentation apply to\n+``only()`` as well. Use it cautiously and only after exhausting your other\n+options.\n+\n using\n ~~~~~\n "
        }
    ],
    "stats": {
        "total": 57,
        "additions": 37,
        "deletions": 20
    }
}