{
    "author": "andrewgodwin",
    "message": "More schema test fixing",
    "sha": "d0b353696478a05937377dd5c8289e69a95f059a",
    "files": [
        {
            "sha": "bb3f916968db58bb11b2d1c3d1b7be13bbbc16c2",
            "filename": "django/core/management/commands/syncdb.py",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/d0b353696478a05937377dd5c8289e69a95f059a/django%2Fcore%2Fmanagement%2Fcommands%2Fsyncdb.py",
            "raw_url": "https://github.com/django/django/raw/d0b353696478a05937377dd5c8289e69a95f059a/django%2Fcore%2Fmanagement%2Fcommands%2Fsyncdb.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fmanagement%2Fcommands%2Fsyncdb.py?ref=d0b353696478a05937377dd5c8289e69a95f059a",
            "patch": "@@ -71,9 +71,11 @@ def handle_noargs(self, **options):\n         def model_installed(model):\n             opts = model._meta\n             converter = connection.introspection.table_name_converter\n-            return not ((converter(opts.db_table) in tables) or\n+            # Note that if a model is unmanaged we short-circuit and never try to install it\n+            return opts.managed and not ((converter(opts.db_table) in tables) or\n                 (opts.auto_created and converter(opts.auto_created._meta.db_table) in tables))\n \n+\n         manifest = SortedDict(\n             (app_name, list(filter(model_installed, model_list)))\n             for app_name, model_list in all_models"
        },
        {
            "sha": "773050d624b1c72510f78a605fc83324b42198c9",
            "filename": "django/db/models/loading.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/d0b353696478a05937377dd5c8289e69a95f059a/django%2Fdb%2Fmodels%2Floading.py",
            "raw_url": "https://github.com/django/django/raw/d0b353696478a05937377dd5c8289e69a95f059a/django%2Fdb%2Fmodels%2Floading.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Floading.py?ref=d0b353696478a05937377dd5c8289e69a95f059a",
            "patch": "@@ -252,13 +252,14 @@ def save_state(self):\n         return {\n             \"app_store\": SortedDict(self.app_store.items()),\n             \"app_labels\": dict(self.app_labels.items()),\n-            \"app_models\": SortedDict(self.app_models.items()),\n+            \"app_models\": SortedDict((k, SortedDict(v.items())) for k, v in self.app_models.items()),\n             \"app_errors\": dict(self.app_errors.items()),\n         }\n \n     def restore_state(self, state):\n         \"\"\"\n         Restores the AppCache to a previous state from save_state.\n+        Note that the state is used by reference, not copied in.\n         \"\"\"\n         self.app_store = state['app_store']\n         self.app_labels = state['app_labels']"
        },
        {
            "sha": "df482e818162bce8fa03be535063976fe34a9cd3",
            "filename": "tests/modeltests/schema/tests.py",
            "status": "modified",
            "additions": 58,
            "deletions": 50,
            "changes": 108,
            "blob_url": "https://github.com/django/django/blob/d0b353696478a05937377dd5c8289e69a95f059a/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/d0b353696478a05937377dd5c8289e69a95f059a/tests%2Fmodeltests%2Fschema%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Fschema%2Ftests.py?ref=d0b353696478a05937377dd5c8289e69a95f059a",
            "patch": "@@ -31,20 +31,18 @@ def setUp(self):\n         # The unmanaged models need to be removed after the test in order to\n         # prevent bad interactions with the flush operation in other tests.\n         self.cache_state = cache.save_state()\n-        cache.load_app(\"modeltests.schema\")\n         for model in self.models:\n             model._meta.managed = True\n \n     def tearDown(self):\n-        # Rollback anything that may have happened\n-        connection.rollback()\n         # Delete any tables made for our models\n         self.delete_tables()\n+        # Rollback anything that may have happened\n+        connection.rollback()\n+        connection.leave_transaction_management()\n         # Unhook our models\n         for model in self.models:\n             model._meta.managed = False\n-        if \"schema\" in self.cache_state['app_labels']:\n-            del self.cache_state['app_labels']['schema']\n         cache.restore_state(self.cache_state)\n \n     def delete_tables(self):\n@@ -280,31 +278,36 @@ def test_m2m(self):\n         # Create an M2M field\n         new_field = ManyToManyField(\"schema.Tag\", related_name=\"authors\")\n         new_field.contribute_to_class(AuthorWithM2M, \"tags\")\n-        # Ensure there's no m2m table there\n-        self.assertRaises(DatabaseError, self.column_classes, new_field.rel.through)\n-        connection.rollback()\n-        # Add the field\n-        editor = connection.schema_editor()\n-        editor.start()\n-        editor.create_field(\n-            Author,\n-            new_field,\n-        )\n-        editor.commit()\n-        # Ensure there is now an m2m table there\n-        columns = self.column_classes(new_field.rel.through)\n-        self.assertEqual(columns['tag_id'][0], \"IntegerField\")\n-        # Remove the M2M table again\n-        editor = connection.schema_editor()\n-        editor.start()\n-        editor.delete_field(\n-            Author,\n-            new_field,\n-        )\n-        editor.commit()\n-        # Ensure there's no m2m table there\n-        self.assertRaises(DatabaseError, self.column_classes, new_field.rel.through)\n-        connection.rollback()\n+        try:\n+            # Ensure there's no m2m table there\n+            self.assertRaises(DatabaseError, self.column_classes, new_field.rel.through)\n+            connection.rollback()\n+            # Add the field\n+            editor = connection.schema_editor()\n+            editor.start()\n+            editor.create_field(\n+                Author,\n+                new_field,\n+            )\n+            editor.commit()\n+            # Ensure there is now an m2m table there\n+            columns = self.column_classes(new_field.rel.through)\n+            self.assertEqual(columns['tag_id'][0], \"IntegerField\")\n+            # Remove the M2M table again\n+            editor = connection.schema_editor()\n+            editor.start()\n+            editor.delete_field(\n+                Author,\n+                new_field,\n+            )\n+            editor.commit()\n+            # Ensure there's no m2m table there\n+            self.assertRaises(DatabaseError, self.column_classes, new_field.rel.through)\n+            connection.rollback()\n+        finally:\n+            # Cleanup model states\n+            AuthorWithM2M._meta.local_many_to_many.remove(new_field)\n+            del AuthorWithM2M._meta._m2m_cache\n \n     def test_m2m_repoint(self):\n         \"\"\"\n@@ -330,26 +333,31 @@ def test_m2m_repoint(self):\n         # Repoint the M2M\n         new_field = ManyToManyField(UniqueTest)\n         new_field.contribute_to_class(BookWithM2M, \"uniques\")\n-        editor = connection.schema_editor()\n-        editor.start()\n-        editor.alter_field(\n-            Author,\n-            BookWithM2M._meta.get_field_by_name(\"tags\")[0],\n-            new_field,\n-        )\n-        editor.commit()\n-        # Ensure old M2M is gone\n-        self.assertRaises(DatabaseError, self.column_classes, BookWithM2M._meta.get_field_by_name(\"tags\")[0].rel.through)\n-        connection.rollback()\n-        # Ensure the new M2M exists and points to UniqueTest\n-        constraints = connection.introspection.get_constraints(connection.cursor(), new_field.rel.through._meta.db_table)\n-        if connection.features.supports_foreign_keys:\n-            for name, details in constraints.items():\n-                if details['columns'] == set([\"uniquetest_id\"]) and details['foreign_key']:\n-                    self.assertEqual(details['foreign_key'], ('schema_uniquetest', 'id'))\n-                    break\n-            else:\n-                self.fail(\"No FK constraint for tag_id found\")\n+        try:\n+            editor = connection.schema_editor()\n+            editor.start()\n+            editor.alter_field(\n+                Author,\n+                BookWithM2M._meta.get_field_by_name(\"tags\")[0],\n+                new_field,\n+            )\n+            editor.commit()\n+            # Ensure old M2M is gone\n+            self.assertRaises(DatabaseError, self.column_classes, BookWithM2M._meta.get_field_by_name(\"tags\")[0].rel.through)\n+            connection.rollback()\n+            # Ensure the new M2M exists and points to UniqueTest\n+            constraints = connection.introspection.get_constraints(connection.cursor(), new_field.rel.through._meta.db_table)\n+            if connection.features.supports_foreign_keys:\n+                for name, details in constraints.items():\n+                    if details['columns'] == set([\"uniquetest_id\"]) and details['foreign_key']:\n+                        self.assertEqual(details['foreign_key'], ('schema_uniquetest', 'id'))\n+                        break\n+                else:\n+                    self.fail(\"No FK constraint for tag_id found\")\n+        finally:\n+            # Cleanup model states\n+            BookWithM2M._meta.local_many_to_many.remove(new_field)\n+            del BookWithM2M._meta._m2m_cache\n \n     @skipUnless(connection.features.supports_check_constraints, \"No check constraints\")\n     def test_check_constraints(self):"
        }
    ],
    "stats": {
        "total": 115,
        "additions": 63,
        "deletions": 52
    }
}