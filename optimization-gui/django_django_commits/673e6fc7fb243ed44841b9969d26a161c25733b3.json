{
    "author": "freakboy3742",
    "message": "Fixed #11675 -- Added support for the PyLibMC cache library. In order to support this, and clean up some other 1.3 caching additions, this patch also includes some changes to the way caches are defined. This means you can now have multiple caches, in the same way you have multiple databases. A huge thanks to Jacob Burch for the work on the PyLibMC backend, and to Jannis for his work on the cache definition changes.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@15005 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "673e6fc7fb243ed44841b9969d26a161c25733b3",
    "files": [
        {
            "sha": "0017f467086909f5b1cb1f7336dfeb2d79aca0b1",
            "filename": "django/conf/global_settings.py",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fconf%2Fglobal_settings.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fconf%2Fglobal_settings.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fconf%2Fglobal_settings.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -431,14 +431,15 @@\n # CACHE #\n #########\n \n+# New format\n+CACHES = {\n+}\n # The cache backend to use.  See the docstring in django.core.cache for the\n # possible values.\n CACHE_BACKEND = 'locmem://'\n-CACHE_VERSION = 1\n-CACHE_KEY_PREFIX = ''\n-CACHE_KEY_FUNCTION = None\n CACHE_MIDDLEWARE_KEY_PREFIX = ''\n CACHE_MIDDLEWARE_SECONDS = 600\n+CACHE_MIDDLEWARE_ALIAS = 'default'\n \n ####################\n # COMMENTS         #"
        },
        {
            "sha": "41baf53e7f23d95b6eaba080f16cf44bea009815",
            "filename": "django/contrib/gis/db/backends/spatialite/creation.py",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fspatialite%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fspatialite%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fgis%2Fdb%2Fbackends%2Fspatialite%2Fcreation.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -1,5 +1,7 @@\n import os\n from django.conf import settings\n+from django.core.cache import get_cache\n+from django.core.cache.backends.db import BaseDatabaseCache\n from django.core.exceptions import ImproperlyConfigured\n from django.core.management import call_command\n from django.db.backends.sqlite3.creation import DatabaseCreation\n@@ -28,11 +30,12 @@ def create_test_db(self, verbosity=1, autoclobber=False):\n         self.load_spatialite_sql()\n         call_command('syncdb', verbosity=verbosity, interactive=False, database=self.connection.alias)\n \n-        if settings.CACHE_BACKEND.startswith('db://'):\n-            from django.core.cache import parse_backend_uri\n-            _, cache_name, _ = parse_backend_uri(settings.CACHE_BACKEND)\n-            call_command('createcachetable', cache_name)\n-\n+        for cache_alias in settings.CACHES:\n+            cache = get_cache(cache_alias)\n+            if isinstance(cache, BaseDatabaseCache):\n+                from django.db import router\n+                if router.allow_syncdb(self.connection.alias, cache.cache_model_class):\n+                    call_command('createcachetable', cache._table, database=self.connection.alias)\n         # Get a cursor (even though we don't need one yet). This has\n         # the side effect of initializing the test database.\n         cursor = self.connection.cursor()"
        },
        {
            "sha": "4cc742dedfe3531ad173e2b2f108b76f5dfe0877",
            "filename": "django/core/cache/__init__.py",
            "status": "modified",
            "additions": 102,
            "deletions": 26,
            "changes": 128,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2F__init__.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -12,8 +12,13 @@\n (e.g. \"memcached://127.0.0.1:11211/\") and returns an instance of a backend\n cache class.\n \n-See docs/cache.txt for information on the public API.\n+See docs/topics/cache.txt for information on the public API.\n \"\"\"\n+from django.conf import settings\n+from django.core import signals\n+from django.core.cache.backends.base import (\n+    InvalidCacheBackendError, CacheKeyWarning, BaseCache)\n+from django.utils import importlib\n \n try:\n     # The mod_python version is more efficient, so try importing it first.\n@@ -27,10 +32,9 @@\n         # PendingDeprecationWarning\n         from cgi import parse_qsl\n \n-from django.conf import settings\n-from django.core import signals\n-from django.core.cache.backends.base import InvalidCacheBackendError, CacheKeyWarning\n-from django.utils import importlib\n+__all__ = [\n+    'get_cache', 'cache', 'DEFAULT_CACHE_ALIAS'\n+]\n \n # Name for use in settings file --> name of module in \"backends\" directory.\n # Any backend scheme that is not in this dictionary is treated as a Python\n@@ -43,6 +47,8 @@\n     'dummy': 'dummy',\n }\n \n+DEFAULT_CACHE_ALIAS = 'default'\n+\n def parse_backend_uri(backend_uri):\n     \"\"\"\n     Converts the \"backend_uri\" into a cache scheme ('db', 'memcached', etc), a\n@@ -67,32 +73,102 @@ def parse_backend_uri(backend_uri):\n \n     return scheme, host, params\n \n-def get_cache(backend_uri, key_prefix=None, version=None, key_func=None):\n-    if key_prefix is None:\n-        key_prefix = settings.CACHE_KEY_PREFIX\n-    if version is None:\n-        version = settings.CACHE_VERSION\n-    if key_func is None:\n-        key_func = settings.CACHE_KEY_FUNCTION\n-\n-    if key_func is not None and not callable(key_func):\n-        key_func_module_path, key_func_name = key_func.rsplit('.', 1)\n-        key_func_module = importlib.import_module(key_func_module_path)\n-        key_func = getattr(key_func_module, key_func_name)\n-\n-    scheme, host, params = parse_backend_uri(backend_uri)\n-    if scheme in BACKENDS:\n-        name = 'django.core.cache.backends.%s' % BACKENDS[scheme]\n+if not settings.CACHES:\n+    import warnings\n+    warnings.warn(\n+        \"settings.CACHE_* is deprecated; use settings.CACHES instead.\",\n+        PendingDeprecationWarning\n+    )\n+    # Mapping for new-style cache backend api\n+    backend_classes = {\n+        'memcached': 'memcached.CacheClass',\n+        'locmem': 'locmem.LocMemCache',\n+        'file': 'filebased.FileBasedCache',\n+        'db': 'db.DatabaseCache',\n+        'dummy': 'dummy.DummyCache',\n+    }\n+    engine, host, params = parse_backend_uri(settings.CACHE_BACKEND)\n+    if engine in backend_classes:\n+        engine = 'django.core.cache.backends.%s' % backend_classes[engine]\n+    defaults = {\n+        'BACKEND': engine,\n+        'LOCATION': host,\n+    }\n+    defaults.update(params)\n+    settings.CACHES[DEFAULT_CACHE_ALIAS] = defaults\n+\n+if DEFAULT_CACHE_ALIAS not in settings.CACHES:\n+    raise ImproperlyConfigured(\"You must define a '%s' cache\" % DEFAULT_CACHE_ALIAS)\n+\n+def parse_backend_conf(backend, **kwargs):\n+    \"\"\"\n+    Helper function to parse the backend configuration\n+    that doesn't use the URI notation.\n+    \"\"\"\n+    # Try to get the CACHES entry for the given backend name first\n+    conf = settings.CACHES.get(backend, None)\n+    if conf is not None:\n+        args = conf.copy()\n+        backend = args.pop('BACKEND')\n+        location = args.pop('LOCATION', '')\n+        return backend, location, args\n     else:\n-        name = scheme\n-    module = importlib.import_module(name)\n-    return module.CacheClass(host, params, key_prefix=key_prefix, version=version, key_func=key_func)\n+        # Trying to import the given backend, in case it's a dotted path\n+        mod_path, cls_name = backend.rsplit('.', 1)\n+        try:\n+            mod = importlib.import_module(mod_path)\n+            backend_cls = getattr(mod, cls_name)\n+        except (AttributeError, ImportError):\n+            raise InvalidCacheBackendError(\"Could not find backend '%s'\" % backend)\n+        location = kwargs.pop('LOCATION', '')\n+        return backend, location, kwargs\n+    raise InvalidCacheBackendError(\n+        \"Couldn't find a cache backend named '%s'\" % backend)\n \n-cache = get_cache(settings.CACHE_BACKEND)\n+def get_cache(backend, **kwargs):\n+    \"\"\"\n+    Function to load a cache backend dynamically. This is flexible by design\n+    to allow different use cases:\n+\n+    To load a backend with the old URI-based notation::\n+\n+        cache = get_cache('locmem://')\n+\n+    To load a backend that is pre-defined in the settings::\n+\n+        cache = get_cache('default')\n+\n+    To load a backend with its dotted import path,\n+    including arbitrary options::\n+\n+        cache = get_cache('django.core.cache.backends.memcached.MemcachedCache', **{\n+            'LOCATION': '127.0.0.1:11211', 'TIMEOUT': 30,\n+        })\n+\n+    \"\"\"\n+    try:\n+        if '://' in backend:\n+            # for backwards compatibility\n+            backend, location, params = parse_backend_uri(backend)\n+            if backend in BACKENDS:\n+                backend = 'django.core.cache.backends.%s' % BACKENDS[backend]\n+            params.update(kwargs)\n+            mod = importlib.import_module(backend)\n+            backend_cls = mod.CacheClass\n+        else:\n+            backend, location, params = parse_backend_conf(backend, **kwargs)\n+            mod_path, cls_name = backend.rsplit('.', 1)\n+            mod = importlib.import_module(mod_path)\n+            backend_cls = getattr(mod, cls_name)\n+    except (AttributeError, ImportError), e:\n+        raise InvalidCacheBackendError(\n+            \"Could not find backend '%s': %s\" % (backend, e))\n+    return backend_cls(location, params)\n+\n+cache = get_cache(DEFAULT_CACHE_ALIAS)\n \n # Some caches -- python-memcached in particular -- need to do a cleanup at the\n # end of a request cycle. If the cache provides a close() method, wire it up\n # here.\n if hasattr(cache, 'close'):\n     signals.request_finished.connect(cache.close)\n-"
        },
        {
            "sha": "513adb48fe9110ac64aaad017718df4e83d8af2d",
            "filename": "django/core/cache/backends/base.py",
            "status": "modified",
            "additions": 28,
            "deletions": 9,
            "changes": 37,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2Fbackends%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2Fbackends%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Fbase.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -2,8 +2,10 @@\n \n import warnings\n \n+from django.conf import settings\n from django.core.exceptions import ImproperlyConfigured, DjangoRuntimeWarning\n from django.utils.encoding import smart_str\n+from django.utils.importlib import import_module\n \n class InvalidCacheBackendError(ImproperlyConfigured):\n     pass\n@@ -15,38 +17,55 @@ class CacheKeyWarning(DjangoRuntimeWarning):\n MEMCACHE_MAX_KEY_LENGTH = 250\n \n def default_key_func(key, key_prefix, version):\n-    \"\"\"Default function to generate keys.\n+    \"\"\"\n+    Default function to generate keys.\n \n     Constructs the key used by all other methods. By default it prepends\n-    the `key_prefix'. CACHE_KEY_FUNCTION can be used to specify an alternate\n+    the `key_prefix'. KEY_FUNCTION can be used to specify an alternate\n     function with custom key making behavior.\n     \"\"\"\n     return ':'.join([key_prefix, str(version), smart_str(key)])\n \n+def get_key_func(key_func):\n+    \"\"\"\n+    Function to decide which key function to use.\n+\n+    Defaults to ``default_key_func``.\n+    \"\"\"\n+    if key_func is not None:\n+        if callable(key_func):\n+            return key_func\n+        else:\n+            key_func_module_path, key_func_name = key_func.rsplit('.', 1)\n+            key_func_module = import_module(key_func_module_path)\n+            return getattr(key_func_module, key_func_name)\n+    return default_key_func\n+\n class BaseCache(object):\n-    def __init__(self, params, key_prefix='', version=1, key_func=None):\n-        timeout = params.get('timeout', 300)\n+    def __init__(self, params):\n+        timeout = params.get('timeout', params.get('TIMEOUT', 300))\n         try:\n             timeout = int(timeout)\n         except (ValueError, TypeError):\n             timeout = 300\n         self.default_timeout = timeout\n \n-        max_entries = params.get('max_entries', 300)\n+        options = params.get('OPTIONS', {})\n+        max_entries = params.get('max_entries', options.get('MAX_ENTRIES', 300))\n         try:\n             self._max_entries = int(max_entries)\n         except (ValueError, TypeError):\n             self._max_entries = 300\n \n-        cull_frequency = params.get('cull_frequency', 3)\n+        cull_frequency = params.get('cull_frequency', options.get('CULL_FREQUENCY', 3))\n         try:\n             self._cull_frequency = int(cull_frequency)\n         except (ValueError, TypeError):\n             self._cull_frequency = 3\n \n-        self.key_prefix = smart_str(key_prefix)\n-        self.version = version\n-        self.key_func = key_func or default_key_func\n+        self.key_prefix = smart_str(params.get('KEY_PREFIX', ''))\n+        self.version = params.get('VERSION', 1)\n+        self.key_func = get_key_func(params.get('KEY_FUNCTION', None))\n \n     def make_key(self, key, version=None):\n         \"\"\"Constructs the key used by all other methods. By default it"
        },
        {
            "sha": "495812a48de5b0abe12ffd22dec72f8c58cf02a2",
            "filename": "django/core/cache/backends/db.py",
            "status": "modified",
            "additions": 8,
            "deletions": 4,
            "changes": 12,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2Fbackends%2Fdb.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2Fbackends%2Fdb.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Fdb.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -25,16 +25,16 @@ def __init__(self, table):\n         self.managed = True\n         self.proxy = False\n \n-class BaseDatabaseCacheClass(BaseCache):\n-    def __init__(self, table, params, key_prefix='', version=1, key_func=None):\n-        BaseCache.__init__(self, params, key_prefix, version, key_func)\n+class BaseDatabaseCache(BaseCache):\n+    def __init__(self, table, params):\n+        BaseCache.__init__(self, params)\n         self._table = table\n \n         class CacheEntry(object):\n             _meta = Options(table)\n         self.cache_model_class = CacheEntry\n \n-class CacheClass(BaseDatabaseCacheClass):\n+class DatabaseCache(BaseDatabaseCache):\n     def get(self, key, default=None, version=None):\n         key = self.make_key(key, version=version)\n         self.validate_key(key)\n@@ -140,3 +140,7 @@ def clear(self):\n         table = connections[db].ops.quote_name(self._table)\n         cursor = connections[db].cursor()\n         cursor.execute('DELETE FROM %s' % table)\n+\n+# For backwards compatibility\n+class CacheClass(DatabaseCache):\n+    pass"
        },
        {
            "sha": "af8b62c8dd0438ef7aa85cc58fcddd1d62ae8ff9",
            "filename": "django/core/cache/backends/dummy.py",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2Fbackends%2Fdummy.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2Fbackends%2Fdummy.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Fdummy.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -2,7 +2,7 @@\n \n from django.core.cache.backends.base import BaseCache\n \n-class CacheClass(BaseCache):\n+class DummyCache(BaseCache):\n     def __init__(self, host, *args, **kwargs):\n         BaseCache.__init__(self, *args, **kwargs)\n \n@@ -40,3 +40,7 @@ def delete_many(self, keys, version=None):\n \n     def clear(self):\n         pass\n+\n+# For backwards compatibility\n+class CacheClass(DummyCache):\n+    pass"
        },
        {
            "sha": "b75d636a7abd7d1c7317bbdd918e275e1f1dc901",
            "filename": "django/core/cache/backends/filebased.py",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2Fbackends%2Ffilebased.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2Fbackends%2Ffilebased.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Ffilebased.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -11,9 +11,9 @@\n from django.core.cache.backends.base import BaseCache\n from django.utils.hashcompat import md5_constructor\n \n-class CacheClass(BaseCache):\n-    def __init__(self, dir, params, key_prefix='', version=1, key_func=None):\n-        BaseCache.__init__(self, params, key_prefix, version, key_func)\n+class FileBasedCache(BaseCache):\n+    def __init__(self, dir, params):\n+        BaseCache.__init__(self, params)\n         self._dir = dir\n         if not os.path.exists(self._dir):\n             self._createdir()\n@@ -161,3 +161,7 @@ def clear(self):\n             shutil.rmtree(self._dir)\n         except (IOError, OSError):\n             pass\n+\n+# For backwards compatibility\n+class CacheClass(FileBasedCache):\n+    pass"
        },
        {
            "sha": "ecec8750badbd87d8e2710215421147c22b0061c",
            "filename": "django/core/cache/backends/locmem.py",
            "status": "modified",
            "additions": 17,
            "deletions": 6,
            "changes": 23,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2Fbackends%2Flocmem.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2Fbackends%2Flocmem.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Flocmem.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -9,12 +9,19 @@\n from django.core.cache.backends.base import BaseCache\n from django.utils.synch import RWLock\n \n-class CacheClass(BaseCache):\n-    def __init__(self, _, params, key_prefix='', version=1, key_func=None):\n-        BaseCache.__init__(self, params, key_prefix, version, key_func)\n-        self._cache = {}\n-        self._expire_info = {}\n-        self._lock = RWLock()\n+# Global in-memory store of cache data. Keyed by name, to provide\n+# multiple named local memory caches.\n+_caches = {}\n+_expire_info = {}\n+_locks = {}\n+\n+class LocMemCache(BaseCache):\n+    def __init__(self, name, params):\n+        BaseCache.__init__(self, params)\n+        global _caches, _expire_info, _locks\n+        self._cache = _caches.setdefault(name, {})\n+        self._expire_info = _expire_info.setdefault(name, {})\n+        self._lock = _locks.setdefault(name, RWLock())\n \n     def add(self, key, value, timeout=None, version=None):\n         key = self.make_key(key, version=version)\n@@ -133,3 +140,7 @@ def delete(self, key, version=None):\n     def clear(self):\n         self._cache.clear()\n         self._expire_info.clear()\n+\n+# For backwards compatibility\n+class CacheClass(LocMemCache):\n+    pass"
        },
        {
            "sha": "97d4317decfb31e992406def9a1264afa50e0bc5",
            "filename": "django/core/cache/backends/memcached.py",
            "status": "modified",
            "additions": 91,
            "deletions": 26,
            "changes": 117,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2Fbackends%2Fmemcached.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fcore%2Fcache%2Fbackends%2Fmemcached.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fcache%2Fbackends%2Fmemcached.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -1,26 +1,34 @@\n \"Memcached cache backend\"\n \n import time\n+from threading import local\n \n from django.core.cache.backends.base import BaseCache, InvalidCacheBackendError\n-\n-try:\n-    import cmemcache as memcache\n-    import warnings\n-    warnings.warn(\n-        \"Support for the 'cmemcache' library has been deprecated. Please use python-memcached instead.\",\n-        DeprecationWarning\n-    )\n-except ImportError:\n-    try:\n-        import memcache\n-    except:\n-        raise InvalidCacheBackendError(\"Memcached cache backend requires either the 'memcache' or 'cmemcache' library\")\n-\n-class CacheClass(BaseCache):\n-    def __init__(self, server, params, key_prefix='', version=1, key_func=None):\n-        BaseCache.__init__(self, params, key_prefix, version, key_func)\n-        self._cache = memcache.Client(server.split(';'))\n+from django.utils import importlib\n+\n+class BaseMemcachedCache(BaseCache):\n+    def __init__(self, server, params, library, value_not_found_exception):\n+        super(BaseMemcachedCache, self).__init__(params)\n+        if isinstance(server, basestring):\n+            self._servers = server.split(';')\n+        else:\n+            self._servers = server\n+\n+        # The exception type to catch from the underlying library for a key\n+        # that was not found. This is a ValueError for python-memcache,\n+        # pylibmc.NotFound for pylibmc, and cmemcache will return None without\n+        # raising an exception.\n+        self.LibraryValueNotFoundException = value_not_found_exception\n+\n+        self._lib = library\n+        self._options = params.get('OPTIONS', None)\n+\n+    @property\n+    def _cache(self):\n+        \"\"\"\n+        Implements transparent thread-safe access to a memcached client.\n+        \"\"\"\n+        return self._lib.Client(self._servers)\n \n     def _get_memcache_timeout(self, timeout):\n         \"\"\"\n@@ -79,24 +87,25 @@ def incr(self, key, delta=1, version=None):\n             val = self._cache.incr(key, delta)\n \n         # python-memcache responds to incr on non-existent keys by\n-        # raising a ValueError. Cmemcache returns None. In both\n-        # cases, we should raise a ValueError though.\n-        except ValueError:\n+        # raising a ValueError, pylibmc by raising a pylibmc.NotFound\n+        # and Cmemcache returns None. In all cases,\n+        # we should raise a ValueError though.\n+        except self.LibraryValueNotFoundException:\n             val = None\n         if val is None:\n             raise ValueError(\"Key '%s' not found\" % key)\n-\n         return val\n \n     def decr(self, key, delta=1, version=None):\n         key = self.make_key(key, version=version)\n         try:\n             val = self._cache.decr(key, delta)\n \n-        # python-memcache responds to decr on non-existent keys by\n-        # raising a ValueError. Cmemcache returns None. In both\n-        # cases, we should raise a ValueError though.\n-        except ValueError:\n+        # python-memcache responds to incr on non-existent keys by\n+        # raising a ValueError, pylibmc by raising a pylibmc.NotFound\n+        # and Cmemcache returns None. In all cases,\n+        # we should raise a ValueError though.\n+        except self.LibraryValueNotFoundException:\n             val = None\n         if val is None:\n             raise ValueError(\"Key '%s' not found\" % key)\n@@ -117,3 +126,59 @@ def delete_many(self, keys, version=None):\n \n     def clear(self):\n         self._cache.flush_all()\n+\n+# For backwards compatibility -- the default cache class tries a\n+# cascading lookup of cmemcache, then memcache.\n+class CacheClass(BaseMemcachedCache):\n+    def __init__(self, server, params):\n+        try:\n+            import cmemcache as memcache\n+            import warnings\n+            warnings.warn(\n+                \"Support for the 'cmemcache' library has been deprecated. Please use python-memcached or pyblimc instead.\",\n+                DeprecationWarning\n+            )\n+        except ImportError:\n+            try:\n+                import memcache\n+            except:\n+                raise InvalidCacheBackendError(\n+                    \"Memcached cache backend requires either the 'memcache' or 'cmemcache' library\"\n+                    )\n+        super(CacheClass, self).__init__(server, params,\n+                                         library=memcache,\n+                                         value_not_found_exception=ValueError)\n+\n+class MemcachedCache(BaseMemcachedCache):\n+    \"An implementation of a cache binding using python-memcached\"\n+    def __init__(self, server, params):\n+        import memcache\n+        super(MemcachedCache, self).__init__(server, params,\n+                                             library=memcache,\n+                                             value_not_found_exception=ValueError)\n+\n+class PyLibMCCache(BaseMemcachedCache):\n+    \"An implementation of a cache binding using pylibmc\"\n+    def __init__(self, server, params):\n+        import pylibmc\n+        self._local = local()\n+        super(PyLibMCCache, self).__init__(server, params,\n+                                           library=pylibmc,\n+                                           value_not_found_exception=pylibmc.NotFound)\n+\n+    @property\n+    def _cache(self):\n+        # PylibMC uses cache options as the 'behaviors' attribute.\n+        # It also needs to use threadlocals, because some versions of\n+        # PylibMC don't play well with the GIL.\n+        client = getattr(self._local, 'client', None)\n+        if client:\n+            return client\n+\n+        client = self._lib.Client(self._servers)\n+        if self._options:\n+            client.behaviors = self._options\n+\n+        self._local.client = client\n+\n+        return client"
        },
        {
            "sha": "db1fd6abb78e9fd99cf4056cec0c97a09ac182a1",
            "filename": "django/db/backends/creation.py",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fdb%2Fbackends%2Fcreation.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fdb%2Fbackends%2Fcreation.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fcreation.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -359,12 +359,14 @@ def create_test_db(self, verbosity=1, autoclobber=False):\n         # (unless you really ask to be flooded)\n         call_command('syncdb', verbosity=max(verbosity - 1, 0), interactive=False, database=self.connection.alias)\n \n-        if settings.CACHE_BACKEND.startswith('db://'):\n-            from django.core.cache import parse_backend_uri, cache\n-            from django.db import router\n-            if router.allow_syncdb(self.connection.alias, cache.cache_model_class):\n-                _, cache_name, _ = parse_backend_uri(settings.CACHE_BACKEND)\n-                call_command('createcachetable', cache_name, database=self.connection.alias)\n+        from django.core.cache import get_cache\n+        from django.core.cache.backends.db import BaseDatabaseCache\n+        for cache_alias in settings.CACHES:\n+            cache = get_cache(cache_alias)\n+            if isinstance(cache, BaseDatabaseCache):\n+                from django.db import router\n+                if router.allow_syncdb(self.connection.alias, cache.cache_model_class):\n+                    call_command('createcachetable', cache._table, database=self.connection.alias)\n \n         # Get a cursor (even though we don't need one yet). This has\n         # the side effect of initializing the test database."
        },
        {
            "sha": "54f6607db16bd46352a1860674349de86f45e8ed",
            "filename": "django/middleware/cache.py",
            "status": "modified",
            "additions": 29,
            "deletions": 8,
            "changes": 37,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fmiddleware%2Fcache.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fmiddleware%2Fcache.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fmiddleware%2Fcache.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -49,7 +49,7 @@\n \"\"\"\n \n from django.conf import settings\n-from django.core.cache import cache\n+from django.core.cache import get_cache, DEFAULT_CACHE_ALIAS\n from django.utils.cache import get_cache_key, learn_cache_key, patch_response_headers, get_max_age\n \n class UpdateCacheMiddleware(object):\n@@ -65,6 +65,7 @@ def __init__(self):\n         self.cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS\n         self.key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n         self.cache_anonymous_only = getattr(settings, 'CACHE_MIDDLEWARE_ANONYMOUS_ONLY', False)\n+        self.cache = get_cache(settings.CACHE_MIDDLEWARE_ALIAS)\n \n     def process_response(self, request, response):\n         \"\"\"Sets the cache, if needed.\"\"\"\n@@ -85,7 +86,7 @@ def process_response(self, request, response):\n         patch_response_headers(response, timeout)\n         if timeout:\n             cache_key = learn_cache_key(request, response, timeout, self.key_prefix)\n-            cache.set(cache_key, response, timeout)\n+            self.cache.set(cache_key, response, timeout)\n         return response\n \n class FetchFromCacheMiddleware(object):\n@@ -100,6 +101,7 @@ def __init__(self):\n         self.cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS\n         self.key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n         self.cache_anonymous_only = getattr(settings, 'CACHE_MIDDLEWARE_ANONYMOUS_ONLY', False)\n+        self.cache = get_cache(settings.CACHE_MIDDLEWARE_ALIAS)\n \n     def process_request(self, request):\n         \"\"\"\n@@ -124,12 +126,12 @@ def process_request(self, request):\n             request._cache_update_cache = True\n             return None # No cache information available, need to rebuild.\n \n-        response = cache.get(cache_key, None)\n+        response = self.cache.get(cache_key, None)\n \n         # if it wasn't found and we are looking for a HEAD, try looking just for that\n         if response is None and request.method == 'HEAD':\n             cache_key = get_cache_key(request, self.key_prefix, 'HEAD')\n-            response = cache.get(cache_key, None)\n+            response = self.cache.get(cache_key, None)\n \n         if response is None:\n             request._cache_update_cache = True\n@@ -146,14 +148,33 @@ class CacheMiddleware(UpdateCacheMiddleware, FetchFromCacheMiddleware):\n     Also used as the hook point for the cache decorator, which is generated\n     using the decorator-from-middleware utility.\n     \"\"\"\n-    def __init__(self, cache_timeout=None, key_prefix=None, cache_anonymous_only=None):\n+    def __init__(self, cache_timeout=None, cache_anonymous_only=None, **kwargs):\n         self.cache_timeout = cache_timeout\n         if cache_timeout is None:\n             self.cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS\n-        self.key_prefix = key_prefix\n-        if key_prefix is None:\n-            self.key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n+\n+        # We need to differentiate between \"provided, but using default value\",\n+        # and \"not provided\". If the value is provided using a default, then\n+        # we fall back to system defaults. If it is not provided at all,\n+        # we need to use middleware defaults.\n+        try:\n+            cache_alias = kwargs.get('cache_alias')\n+            if cache_alias is None:\n+                cache_alias = DEFAULT_CACHE_ALIAS\n+        except KeyError:\n+            cache_alias = settings.CACHE_MIDDLEWARE_ALIAS\n+\n+        cache_kwargs = {}\n+        try:\n+            key_prefix = kwargs.get('key_prefix')\n+            if key_prefix is not None:\n+                cache_kwargs['KEY_PREFIX'] = key_prefix\n+        except KeyError:\n+            cache_kwargs['KEY_PREFIX'] = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n+\n         if cache_anonymous_only is None:\n             self.cache_anonymous_only = getattr(settings, 'CACHE_MIDDLEWARE_ANONYMOUS_ONLY', False)\n         else:\n             self.cache_anonymous_only = cache_anonymous_only\n+\n+        self.cache = get_cache(cache_alias, **cache_kwargs)"
        },
        {
            "sha": "a836ac5c28a7ea7e35b681c17683f4d13858e52d",
            "filename": "django/views/decorators/cache.py",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fviews%2Fdecorators%2Fcache.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/django%2Fviews%2Fdecorators%2Fcache.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fviews%2Fdecorators%2Fcache.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -40,23 +40,24 @@ def cache_page(*args, **kwargs):\n \n     # We also add some asserts to give better error messages in case people are\n     # using other ways to call cache_page that no longer work.\n+    cache_alias = kwargs.pop('cache', None)\n     key_prefix = kwargs.pop('key_prefix', None)\n-    assert not kwargs, \"The only keyword argument accepted is key_prefix\"\n+    assert not kwargs, \"The only keyword arguments are cache and key_prefix\"\n     if len(args) > 1:\n         assert len(args) == 2, \"cache_page accepts at most 2 arguments\"\n         if callable(args[0]):\n-            return decorator_from_middleware_with_args(CacheMiddleware)(cache_timeout=args[1], key_prefix=key_prefix)(args[0])\n+            return decorator_from_middleware_with_args(CacheMiddleware)(cache_timeout=args[1], cache_alias=cache_alias, key_prefix=key_prefix)(args[0])\n         elif callable(args[1]):\n-            return decorator_from_middleware_with_args(CacheMiddleware)(cache_timeout=args[0], key_prefix=key_prefix)(args[1])\n+            return decorator_from_middleware_with_args(CacheMiddleware)(cache_timeout=args[0], cache_alias=cache_alias, key_prefix=key_prefix)(args[1])\n         else:\n             assert False, \"cache_page must be passed a view function if called with two arguments\"\n     elif len(args) == 1:\n         if callable(args[0]):\n-            return decorator_from_middleware_with_args(CacheMiddleware)(key_prefix=key_prefix)(args[0])\n+            return decorator_from_middleware_with_args(CacheMiddleware)(cache_alias=cache_alias, key_prefix=key_prefix)(args[0])\n         else:\n-            return decorator_from_middleware_with_args(CacheMiddleware)(cache_timeout=args[0], key_prefix=key_prefix)\n+            return decorator_from_middleware_with_args(CacheMiddleware)(cache_timeout=args[0], cache_alias=cache_alias, key_prefix=key_prefix)\n     else:\n-        return decorator_from_middleware_with_args(CacheMiddleware)(key_prefix=key_prefix)\n+        return decorator_from_middleware_with_args(CacheMiddleware)(cache_alias=cache_alias, key_prefix=key_prefix)\n \n \n def cache_control(**kwargs):"
        },
        {
            "sha": "fadf8a68a5af59ca2256ff5f6725309e1fda8220",
            "filename": "docs/internals/contributing.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/docs%2Finternals%2Fcontributing.txt",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/docs%2Finternals%2Fcontributing.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Finternals%2Fcontributing.txt?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -940,7 +940,7 @@ dependencies:\n     *  gettext_ (:ref:`gettext_on_windows`)\n \n If you want to test the memcached cache backend, you will also need to define\n-a :setting:`CACHE_BACKEND` setting that points at your memcached instance.\n+a :setting:`CACHES` setting that points at your memcached instance.\n \n Each of these dependencies is optional. If you're missing any of them, the\n associated tests will be skipped."
        },
        {
            "sha": "e358c4264d45564fec2997dd093af5e9d34c98aa",
            "filename": "docs/ref/settings.txt",
            "status": "modified",
            "additions": 125,
            "deletions": 25,
            "changes": 150,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/docs%2Fref%2Fsettings.txt",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/docs%2Fref%2Fsettings.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fsettings.txt?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -127,21 +127,63 @@ Default: Not defined\n The site-specific user profile model used by this site. See\n :ref:`auth-profiles`.\n \n-.. setting:: CACHE_BACKEND\n+.. setting:: CACHES\n \n-CACHE_BACKEND\n--------------\n+CACHES\n+------\n \n-Default: ``'locmem://'``\n+.. versionadded:: 1.3\n \n-The cache backend to use. See :doc:`/topics/cache`.\n+Default::\n \n-.. setting:: CACHE_KEY_FUNCTION\n+    {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',\n+        }\n+    }\n \n-CACHE_KEY_FUNCTION\n-------------------\n+A dictionary containing the settings for all caches to be used with\n+Django. It is a nested dictionary whose contents maps cache aliases\n+to a dictionary containing the options for an individual cache.\n \n-Default: ``None``\n+The :setting:`CACHES` setting must configure a ``default`` cache;\n+any number of additional caches may also be specified. If you\n+are using a cache backend other than the local memory cache, or\n+you need to define multiple caches, other options will be required.\n+The following cache options are available.\n+\n+.. setting:: CACHES-BACKEND\n+\n+BACKEND\n+~~~~~~~\n+\n+Default: ``''`` (Empty string)\n+\n+The cache backend to use. The built-in cache backends are:\n+\n+    * ``'django.core.cache.backends.db.DatabaseCache'``\n+    * ``'django.core.cache.backends.dummy.DummyCache'``\n+    * ``'django.core.cache.backends.filebased.FileBasedCache'``\n+    * ``'django.core.cache.backends.locmem.LocMemCache'``\n+    * ``'django.core.cache.backends.memcached.MemcachedCache'``\n+    * ``'django.core.cache.backends.memcached.PyLibMCCache'``\n+\n+You can use a cache backend that doesn't ship with Django by setting\n+:setting:`BACKEND <CACHE-BACKEND>` to a fully-qualified path of a cache\n+backend class (i.e. ``mypackage.backends.whatever.WhateverCache``).\n+Writing a whole new cache backend from scratch is left as an exercise\n+to the reader; see the other backends for examples.\n+\n+.. note::\n+    Prior to Django 1.3, you could use a URI based version of the backend\n+    name to reference the built-in cache backends (e.g., you could use\n+    ``'db://tablename'`` to refer to the database backend). This format has\n+    been deprecated, and will be removed in Django 1.5.\n+\n+.. setting:: CACHES-KEY_FUNCTION\n+\n+KEY_FUNCTION\n+~~~~~~~~~~~~\n \n A string containing a dotted path to a function that defines how to\n compose a prefix, version and key into a final cache key. The default\n@@ -155,10 +197,10 @@ argument signature.\n \n See the :ref:`cache documentation <cache_key_transformation>` for more information.\n \n-.. setting:: CACHE_KEY_PREFIX\n+.. setting:: CACHES-KEY_PREFIX\n \n-CACHE_KEY_PREFIX\n-----------------\n+KEY_PREFIX\n+~~~~~~~~~~\n \n Default: ``''`` (Empty string)\n \n@@ -167,6 +209,67 @@ all cache keys used by the Django server.\n \n See the :ref:`cache documentation <cache_key_prefixing>` for more information.\n \n+.. setting:: CACHES-LOCATION\n+\n+LOCATION\n+~~~~~~~~\n+\n+Default: ``''`` (Empty string)\n+\n+The location of the cache to use. This might be the directory for a\n+file system cache, a host and port for a memcache server, or simply an\n+identifying name for a local memory cache. e.g.::\n+\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',\n+            'LOCATION': '/var/tmp/django_cache',\n+        }\n+    }\n+\n+.. setting:: CACHES-OPTIONS\n+\n+OPTIONS\n+~~~~~~~\n+\n+Default: None\n+\n+Extra parameters to pass to the cache backend. Available parameters\n+vary depending on your cache backend.\n+\n+Some information on available parameters can be found in the\n+:doc:`Cache Backends </topics/cache>` documentation. For more information,\n+consult your backend module's own documentation.\n+\n+.. setting:: CACHES-TIMEOUT\n+\n+TIMEOUT\n+~~~~~~~\n+\n+Default: 300\n+\n+The number of seconds before a cache entry is considered stale.\n+\n+.. setting:: CACHES-VERSION\n+\n+VERSION\n+~~~~~~~\n+\n+Default: ``1``\n+\n+The default version number for cache keys generated by the Django server.\n+\n+See the :ref:`cache documentation <cache_versioning>` for more information.\n+\n+.. setting:: CACHE_MIDDLEWARE_ALIAS\n+\n+CACHE_MIDDLEWARE_ALIAS\n+----------------------\n+\n+Default: ``default``\n+\n+The cache connection to use for the cache middleware.\n+\n .. setting:: CACHE_MIDDLEWARE_ANONYMOUS_ONLY\n \n CACHE_MIDDLEWARE_ANONYMOUS_ONLY\n@@ -206,18 +309,6 @@ The default number of seconds to cache a page when the caching middleware or\n \n See :doc:`/topics/cache`.\n \n-.. setting:: CACHE_VERSION\n-\n-CACHE_VERSION\n--------------\n-\n-Default: ``1``\n-\n-The default version number for cache keys generated by the Django server.\n-\n-See the :ref:`cache documentation <cache_versioning>` for more information.\n-\n-\n .. setting:: CSRF_COOKIE_DOMAIN\n \n CSRF_COOKIE_DOMAIN\n@@ -293,7 +384,7 @@ SQLite. This can be configured using the following::\n For other database backends, or more complex SQLite configurations, other options\n will be required. The following inner options are available.\n \n-.. setting:: ENGINE\n+.. setting:: DATABASE-ENGINE\n \n ENGINE\n ~~~~~~\n@@ -1896,6 +1987,15 @@ See :tfilter:`allowed date format strings <date>`. See also ``DATE_FORMAT``,\n Deprecated settings\n ===================\n \n+.. setting:: CACHE_BACKEND\n+\n+CACHE_BACKEND\n+-------------\n+\n+.. deprecated:: 1.3\n+   This setting has been replaced by :setting:`BACKEND <CACHES-BACKEND>` in\n+   :setting:`CACHES`.\n+\n .. setting:: DATABASE_ENGINE\n \n DATABASE_ENGINE"
        },
        {
            "sha": "068670f9f2cea593e86679bf3c219d6ad0fa0e16",
            "filename": "docs/releases/1.3.txt",
            "status": "modified",
            "additions": 23,
            "deletions": 4,
            "changes": 27,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/docs%2Freleases%2F1.3.txt",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/docs%2Freleases%2F1.3.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Freleases%2F1.3.txt?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -154,6 +154,29 @@ it is needed, later in the response process.\n For more details, see the :ref:`documentation </ref/template-response>`\n on the :class:`~django.template.TemplateResponse` class.\n \n+Caching changes\n+~~~~~~~~~~~~~~~\n+\n+Django 1.3 sees the introduction of several improvements to the\n+Django's caching infrastructure.\n+\n+Firstly, Django now supports multiple named caches. In the same way\n+that Django 1.2 introduced support for multiple database connections,\n+Django 1.3 allows you to use the new :setting:`CACHES` setting to\n+define multiple named cache connections.\n+\n+Secondly, :ref:`Versioning <cache_versioning>`, :ref:`site-wide\n+prefixing <cache_key_prefixing>` and :ref:`transformation\n+<cache_key_transformation>` has been added to the cache API.\n+\n+Lastly, support for pylibmc_ has been added to the memcached cache\n+backend.\n+\n+For more details, see the :ref:`documentation on\n+caching in Django<topics/cache>`.\n+\n+.. _pylibmc: http://sendapatch.se/projects/pylibmc/\n+\n Everything else\n ~~~~~~~~~~~~~~~\n \n@@ -176,10 +199,6 @@ requests. These include:\n       :meth:`~django.test.client.Client.assertNumQueries` -- making it\n       easier to test the database activity associated with a view.\n \n-    * :ref:`Versioning <cache_versioning>`, :ref:`site-wide prefixing\n-      <cache_key_prefixing>` and :ref:`transformation\n-      <cache_key_transformation>` has been added to the cache API.\n-\n     * Support for lookups spanning relations in admin's ``list_filter``.\n \n     * Support for _HTTPOnly cookies."
        },
        {
            "sha": "dd3fd78dfd403c349af220724221f92ad1782ba6",
            "filename": "docs/topics/cache.txt",
            "status": "modified",
            "additions": 212,
            "deletions": 73,
            "changes": 285,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/docs%2Ftopics%2Fcache.txt",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/docs%2Ftopics%2Fcache.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fcache.txt?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -47,9 +47,16 @@ where your cached data should live -- whether in a database, on the filesystem\n or directly in memory. This is an important decision that affects your cache's\n performance; yes, some cache types are faster than others.\n \n-Your cache preference goes in the :setting:`CACHE_BACKEND` setting in your\n+Your cache preference goes in the :setting:`CACHES` setting in your\n settings file. Here's an explanation of all available values for\n-:setting:`CACHE_BACKEND`.\n+:setting:`CACHES`.\n+\n+.. versionchanged:: 1.3\n+    The settings used to configure caching changed in Django 1.3. In\n+    Django 1.2 and earlier, you used a single string-based\n+    :setting:`CACHE_BACKEND` setting to configure caches. This has\n+    been replaced with the new dictionary-based :setting:`CACHES`\n+    setting.\n \n Memcached\n ---------\n@@ -66,41 +73,77 @@ fast interface for adding, retrieving and deleting arbitrary data in the cache.\n All data is stored directly in memory, so there's no overhead of database or\n filesystem usage.\n \n-After installing Memcached itself, you'll need to install\n-``python-memcached``, which provides Python bindings to Memcached.\n-This is available at ftp://ftp.tummy.com/pub/python-memcached/\n+After installing Memcached itself, you'll need to install a memcached\n+binding. There are several python memcached bindings available; the\n+two most common are `python-memcached`_ and `pylibmc`_.\n+\n+.. _`python-memcached`: ftp://ftp.tummy.com/pub/python-memcached/\n+.. _`pylibmc`: http://sendapatch.se/projects/pylibmc/\n \n .. versionchanged:: 1.2\n     In Django 1.0 and 1.1, you could also use ``cmemcache`` as a binding.\n     However, support for this library was deprecated in 1.2 due to\n     a lack of maintenance on the ``cmemcache`` library itself. Support for\n     ``cmemcache`` will be removed completely in Django 1.4.\n \n-To use Memcached with Django, set :setting:`CACHE_BACKEND` to\n-``memcached://ip:port/``, where ``ip`` is the IP address of the Memcached\n-daemon and ``port`` is the port on which Memcached is running.\n+.. versionchanged:: 1.3\n+    Support for ``pylibmc`` was added.\n+\n+To use Memcached with Django:\n+\n+    * Set :setting:`BACKEND <CACHES-BACKEND>` to\n+      ``django.core.cache.backends.memcached.MemcachedCache`` or\n+      ``django.core.cache.backends.memcached.PyLibMCCache`` (depending\n+      on your chosen memcached binding)\n+\n+    * Set :setting:`LOCATION <CACHES-LOCATION>` to ``ip:port`` values,\n+      where ``ip`` is the IP address of the Memcached daemon and\n+      ``port`` is the port on which Memcached is running.\n \n-In this example, Memcached is running on localhost (127.0.0.1) port 11211::\n+In this example, Memcached is running on localhost (127.0.0.1) port 11211, using\n+the ``python-memcached`` binding::\n \n-    CACHE_BACKEND = 'memcached://127.0.0.1:11211/'\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',\n+            'LOCATION': '127.0.0.1:11211',\n+        }\n+    }\n \n One excellent feature of Memcached is its ability to share cache over multiple\n servers. This means you can run Memcached daemons on multiple machines, and the\n program will treat the group of machines as a *single* cache, without the need\n to duplicate cache values on each machine. To take advantage of this feature,\n-include all server addresses in :setting:`CACHE_BACKEND`, separated by\n-semicolons.\n+include all server addresses in :setting:`BACKEND <CACHES-BACKEND>`, either\n+separated by semicolons or as a list.\n \n In this example, the cache is shared over Memcached instances running on IP\n address 172.19.26.240 and 172.19.26.242, both on port 11211::\n \n-    CACHE_BACKEND = 'memcached://172.19.26.240:11211;172.19.26.242:11211/'\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',\n+            'LOCATION': [\n+                '172.19.26.240:11211',\n+                '172.19.26.242:11211',\n+            ]\n+        }\n+    }\n \n In the following example, the cache is shared over Memcached instances running\n on the IP addresses 172.19.26.240 (port 11211), 172.19.26.242 (port 11212), and\n 172.19.26.244 (port 11213)::\n \n-    CACHE_BACKEND = 'memcached://172.19.26.240:11211;172.19.26.242:11212;172.19.26.244:11213/'\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',\n+            'LOCATION': [\n+                '172.19.26.240:11211',\n+                '172.19.26.242:11211',\n+                '172.19.26.244:11213',\n+            ]\n+        }\n+    }\n \n A final point about Memcached is that memory-based caching has one\n disadvantage: Because the cached data is stored in memory, the data will be\n@@ -125,12 +168,19 @@ not already being used in your database.) This command creates a single table\n in your database that is in the proper format that Django's database-cache\n system expects.\n \n-Once you've created that database table, set your :setting:`CACHE_BACKEND`\n-setting to ``\"db://tablename\"``, where ``tablename`` is the name of the\n-database table. In this example, the cache table's name is\n-``my_cache_table``::\n+Once you've created that database table, set your\n+:setting:`BACKEND <CACHES-BACKEND>` setting to\n+``\"django.core.cache.backends.db.DatabaseCache\"``, and\n+:setting:`LOCATION <CACHES-LOCATION>` to ``tablename`` -- the name of the\n+database table. In this example, the cache table's name is ``my_cache_table``::\n+\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.db.DatabaseCache',\n+            'LOCATION': 'my_cache_table',\n+        }\n+    }\n \n-    CACHE_BACKEND = 'db://my_cache_table'\n \n The database caching backend uses the same database as specified in your\n settings file. You can't use a different database backend for your cache table.\n@@ -183,18 +233,28 @@ model.\n Filesystem caching\n ------------------\n \n-To store cached items on a filesystem, use the ``\"file://\"`` cache type for\n-:setting:`CACHE_BACKEND`. For example, to store cached data in\n+To store cached items on a filesystem, use\n+``\"django.core.cache.backends.filebased.FileBasedCache\"`` for\n+:setting:`BACKEND <CACHES-BACKEND>`. For example, to store cached data in\n ``/var/tmp/django_cache``, use this setting::\n \n-    CACHE_BACKEND = 'file:///var/tmp/django_cache'\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',\n+            'LOCATION': '/var/tmp/django_cache',\n+        }\n+    }\n+\n \n-Note that there are three forward slashes toward the beginning of that example.\n-The first two are for ``file://``, and the third is the first character of the\n-directory path, ``/var/tmp/django_cache``. If you're on Windows, put the\n-drive letter after the ``file://``, like this::\n+If you're on Windows, put the drive letter at the beginning of the path,\n+like this::\n \n-    file://c:/foo/bar\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',\n+            'LOCATION': 'c:/foo/bar',\n+        }\n+    }\n \n The directory path should be absolute -- that is, it should start at the root\n of your filesystem. It doesn't matter whether you put a slash at the end of the\n@@ -215,10 +275,22 @@ Local-memory caching\n \n If you want the speed advantages of in-memory caching but don't have the\n capability of running Memcached, consider the local-memory cache backend. This\n-cache is multi-process and thread-safe. To use it, set :setting:`CACHE_BACKEND`\n-to ``\"locmem://\"``. For example::\n-\n-    CACHE_BACKEND = 'locmem://'\n+cache is multi-process and thread-safe. To use it, set\n+:setting:`BACKEND <CACHES-BACKEND>` to\n+``\"django.core.cache.backends.locmem.LocMemCache\"``. For example::\n+\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',\n+            'LOCATION': 'unique-snowflake'\n+        }\n+    }\n+\n+The cache :setting:`LOCATION <CACHES-LOCATION>` is used to identify individual\n+memory stores. If you only have one locmem cache, you can omit the\n+:setting:`LOCATION <CACHES-LOCATION>`; however, if you have more that one local\n+memory cache, you will need to assign a name to at least one of them in\n+order to keep them separate.\n \n Note that each process will have its own private cache instance, which means no\n cross-process caching is possible. This obviously also means the local memory\n@@ -234,9 +306,13 @@ just implements the cache interface without doing anything.\n This is useful if you have a production site that uses heavy-duty caching in\n various places but a development/test environment where you don't want to cache\n and don't want to have to change your code to special-case the latter. To\n-activate dummy caching, set :setting:`CACHE_BACKEND` like so::\n+activate dummy caching, set :setting:`BACKEND <CACHES-BACKEND>` like so::\n \n-    CACHE_BACKEND = 'dummy://'\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.dummy.DummyCache',\n+        }\n+    }\n \n Using a custom cache backend\n ----------------------------\n@@ -245,10 +321,14 @@ Using a custom cache backend\n \n While Django includes support for a number of cache backends out-of-the-box,\n sometimes you might want to use a customized cache backend. To use an external\n-cache backend with Django, use a Python import path as the scheme portion (the\n-part before the initial colon) of the :setting:`CACHE_BACKEND` URI, like so::\n+cache backend with Django, use the Python import path as the\n+:setting:`BACKEND <CACHES-BACKEND>` of the :setting:`CACHES` setting, like so::\n \n-    CACHE_BACKEND = 'path.to.backend://'\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'path.to.backend',\n+        }\n+    }\n \n If you're building your own backend, you can use the standard cache backends\n as reference implementations. You'll find the code in the\n@@ -258,35 +338,77 @@ Note: Without a really compelling reason, such as a host that doesn't support\n them, you should stick to the cache backends included with Django. They've\n been well-tested and are easy to use.\n \n-CACHE_BACKEND arguments\n------------------------\n+Cache arguments\n+---------------\n+\n+In addition to the defining the engine and name of the each cache\n+backend, each cache backend can be given additional arguments to\n+control caching behavior. These arguments are provided as additional\n+keys in the :setting:`CACHES` setting. Valid arguments are as follows:\n+\n+    * :setting:`TIMEOUT <CACHES-TIMEOUT>`: The default timeout, in\n+      seconds, to use for the cache. This argument defaults to 300\n+      seconds (5 minutes).\n \n-Each cache backend may take arguments. They're given in query-string style on\n-the :setting:`CACHE_BACKEND` setting. Valid arguments are as follows:\n+    * :setting:`OPTIONS <CACHES-OPTIONS>`: Any options that should be\n+      passed to cache backend. The list options understood by each\n+      backend vary with each backend.\n \n-    * ``timeout``: The default timeout, in seconds, to use for the cache.\n-      This argument defaults to 300 seconds (5 minutes).\n+      Cache backends that implement their own culling strategy (i.e.,\n+      the ``locmem``, ``filesystem`` and ``database`` backends) will\n+      honor the following options:\n \n-    * ``max_entries``: For the ``locmem``, ``filesystem`` and ``database``\n-      backends, the maximum number of entries allowed in the cache before old\n-      values are deleted. This argument defaults to 300.\n+        * ``MAX_ENTRIES``: the maximum number of entries allowed in\n+          the cache before old values are deleted. This argument\n+          defaults to ``300``.\n \n-    * ``cull_frequency``: The fraction of entries that are culled when\n-      ``max_entries`` is reached. The actual ratio is ``1/cull_frequency``, so\n-      set ``cull_frequency=2`` to cull half of the entries when ``max_entries``\n-      is reached.\n+        * ``CULL_FREQUENCY``: The fraction of entries that are culled\n+          when ``MAX_ENTRIES`` is reached. The actual ratio is\n+          ``1/CULL_FREQUENCY``, so set ``CULL_FREQUENCY``: to ``2`` to\n+          cull half of the entries when ``MAX_ENTRIES`` is reached.\n \n-      A value of ``0`` for ``cull_frequency`` means that the entire cache will\n-      be dumped when ``max_entries`` is reached. This makes culling *much*\n-      faster at the expense of more cache misses.\n+          A value of ``0`` for ``CULL_FREQUENCY`` means that the\n+          entire cache will be dumped when ``MAX_ENTRIES`` is reached.\n+          This makes culling *much* faster at the expense of more\n+          cache misses.\n \n-In this example, ``timeout`` is set to ``60``::\n+      Cache backends backed by a third-party library will pass their\n+      options directly to the underlying cache library. As a result,\n+      the list of valid options depends on the library in use.\n \n-    CACHE_BACKEND = \"memcached://127.0.0.1:11211/?timeout=60\"\n+    * :setting:`KEY_PREFIX <CACHES-KEY_PREFIX>`: A string that will be\n+      automatically included (prepended by default) to all cache keys\n+      used by the Django server.\n \n-In this example, ``timeout`` is ``30`` and ``max_entries`` is ``400``::\n+      See the :ref:`cache documentation <cache_key_prefixing>` for\n+      more information.\n \n-    CACHE_BACKEND = \"locmem://?timeout=30&max_entries=400\"\n+    * :setting:`VERSION <CACHES-VERSION>`: The default version number\n+      for cache keys generated by the Django server.\n+\n+      See the :ref:`cache documentation <cache_versioning>` for more\n+      information.\n+\n+    * :setting:`KEY_FUNCTION <CACHES-KEY_FUNCTION>`\n+      A string containing a dotted path to a function that defines how\n+      to compose a prefix, version and key into a final cache key.\n+\n+      See the :ref:`cache documentation <cache_key_transformation>`\n+      for more information.\n+\n+In this example, a filesystem backend is being configured with a timeout\n+of 60 seconds, and a maximum capacity of 1000 items::\n+\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.filebased.FileCache',\n+            'LOCATION': '127.0.0.1:11211',\n+            'TIMEOUT': 60,\n+            'OPTIONS': {\n+                'MAX_ENTRIES': 1000\n+            }\n+        }\n+    }\n \n Invalid arguments are silently ignored, as are invalid values of known\n arguments.\n@@ -318,6 +440,7 @@ entire site. You'll need to add\n \n Then, add the following required settings to your Django settings file:\n \n+* :setting:`CACHE_MIDDLEWARE_ALIAS` -- The cache alias to use for storage.\n * :setting:`CACHE_MIDDLEWARE_SECONDS` -- The number of seconds each page should\n   be cached.\n * :setting:`CACHE_MIDDLEWARE_KEY_PREFIX` -- If the cache is shared across\n@@ -408,14 +531,28 @@ then requests to ``/foo/1/`` and ``/foo/23/`` will be cached separately, as\n you may expect. But once a particular URL (e.g., ``/foo/23/``) has been\n requested, subsequent requests to that URL will use the cache.\n \n-``cache_page`` can also take an optional keyword argument, ``key_prefix``,\n+``cache_page`` can also take an optional keyword argument, ``cache``,\n+which directs the decorator to use a specific cache alias when caching view\n+results. By default, the ``default`` alias will be used, but you can specify\n+any cache alias you want::\n+\n+    @cache_page(60 * 15, cache=\"special_cache\")\n+    def my_view(request):\n+        ...\n+\n+You can also override the cache prefix on a per-view basis. ``cache_page``\n+takes an optional keyword argument, ``key_prefix``,\n which works in the same way as the :setting:`CACHE_MIDDLEWARE_KEY_PREFIX`\n setting for the middleware.  It can be used like this::\n \n     @cache_page(60 * 15, key_prefix=\"site1\")\n     def my_view(request):\n         ...\n \n+The two settings can also be combined. If you specify a ``cache`` *and*\n+a ``key_prefix``, you will get all the settings of the requested cache\n+alias, but with the key_prefix overridden.\n+\n Specifying per-view cache in the URLconf\n ----------------------------------------\n \n@@ -535,7 +672,8 @@ can be pickled; refer to the Python documentation for more information about\n pickling.)\n \n The cache module, ``django.core.cache``, has a ``cache`` object that's\n-automatically created from the :setting:`CACHE_BACKEND` setting::\n+automatically created from the ``'default'`` entry in the :setting:`CACHES`\n+setting::\n \n     >>> from django.core.cache import cache\n \n@@ -546,8 +684,9 @@ The basic interface is ``set(key, value, timeout)`` and ``get(key)``::\n     'hello, world!'\n \n The ``timeout`` argument is optional and defaults to the ``timeout``\n-argument in the :setting:`CACHE_BACKEND` setting (explained above). It's the\n-number of seconds the value should be stored in the cache.\n+argument of the ``'default'`` backend in :setting:`CACHES` setting\n+(explained above). It's the number of seconds the value should be stored\n+in the cache.\n \n If the object doesn't exist in the cache, ``cache.get()`` returns ``None``::\n \n@@ -665,10 +804,10 @@ diagnose problems.\n To prevent this, Django provides the ability to prefix all cache keys\n used by a server. When a particular cache key is saved or retrieved,\n Django will automatically prefix the cache key with the value of the\n-:setting:`CACHE_KEY_PREFIX` setting.\n+:setting:`KEY_PREFIX <CACHES-KEY_PREFIX>` cache setting.\n \n By ensuring each Django instance has a different\n-:setting:`CACHE_KEY_PREFIX`, you can ensure that there will be no\n+:setting:`KEY_PREFIX <CACHES-KEY_PREFIX>`, you can ensure that there will be no\n collisions in cache values.\n \n .. _cache_versioning:\n@@ -685,9 +824,9 @@ that are still valid and useful.\n \n Django provides a better way to target individual cache values.\n Django's cache framework has a system-wide version identifier,\n-specified using the :setting:`CACHE_VERSION` setting. The value of\n-this setting is automatically combined with the cache prefix and the\n-user-provided cache key to obtain the final cache key.\n+specified using the :setting:`VERSION <CACHES-VERSION>` cache setting.\n+The value of this setting is automatically combined with the cache\n+prefix and the user-provided cache key to obtain the final cache key.\n \n By default, any key request will automatically include the site\n default cache key version. However, the primitive cache functions all\n@@ -739,10 +878,10 @@ If you want to combine the parts in different ways, or apply other\n processing to the final key (e.g., taking a hash digest of the key\n parts), you can provide a custom key function.\n \n-The setting :setting:`CACHE_KEY_FUNCTION` specifies a dotted-path to\n-a function matching the prototype of :func:`make_key()` above. If\n-provided, this custom key function will be used instead of the default\n-key combining function.\n+The :setting:`KEY_FUNCTION <CACHES-KEY_FUNCTION>` cache setting\n+specifies a dotted-path to a function matching the prototype of\n+:func:`make_key()` above. If provided, this custom key function will\n+be used instead of the default key combining function.\n \n Cache key warnings\n ------------------\n@@ -773,15 +912,15 @@ built-in backends, you can subclass it, override just the ``validate_key``\n method, and follow the instructions for `using a custom cache backend`_. For\n instance, to do this for the ``locmem`` backend, put this code in a module::\n \n-    from django.core.cache.backends.locmem import CacheClass as LocMemCacheClass\n+    from django.core.cache.backends.locmem import LocMemCache\n \n-    class CacheClass(LocMemCacheClass):\n+    class CustomLocMemCache(LocMemCache):\n         def validate_key(self, key):\n             \"\"\"Custom validation, raising exceptions or warnings as needed.\"\"\"\n             # ...\n \n-...and use the dotted Python path to this module as the scheme portion of your\n-:setting:`CACHE_BACKEND`.\n+...and use the dotted Python path to this class in the\n+:setting:`BACKEND <CACHES-BACKEND>` portion of your :setting:`CACHES` setting.\n \n Upstream caches\n ==============="
        },
        {
            "sha": "cc15b664659099e9597fb66839ce2c1d2fa7c7f5",
            "filename": "tests/regressiontests/cache/liberal_backend.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/tests%2Fregressiontests%2Fcache%2Fliberal_backend.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/tests%2Fregressiontests%2Fcache%2Fliberal_backend.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fcache%2Fliberal_backend.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -1,9 +1,9 @@\n-from django.core.cache.backends.locmem import CacheClass as LocMemCacheClass\n+from django.core.cache.backends.locmem import LocMemCache\n \n class LiberalKeyValidationMixin(object):\n     def validate_key(self, key):\n         pass\n \n-class CacheClass(LiberalKeyValidationMixin, LocMemCacheClass):\n+class CacheClass(LiberalKeyValidationMixin, LocMemCache):\n     pass\n "
        },
        {
            "sha": "6c5775830a383e189c55c16f310d902507fbcd23",
            "filename": "tests/regressiontests/cache/tests.py",
            "status": "modified",
            "additions": 67,
            "deletions": 40,
            "changes": 107,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/tests%2Fregressiontests%2Fcache%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/tests%2Fregressiontests%2Fcache%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fcache%2Ftests.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -11,7 +11,7 @@\n \n from django.conf import settings\n from django.core import management\n-from django.core.cache import get_cache\n+from django.core.cache import get_cache, DEFAULT_CACHE_ALIAS\n from django.core.cache.backends.base import InvalidCacheBackendError, CacheKeyWarning\n from django.http import HttpResponse, HttpRequest\n from django.middleware.cache import FetchFromCacheMiddleware, UpdateCacheMiddleware\n@@ -33,7 +33,7 @@ class DummyCacheTests(unittest.TestCase):\n     # The Dummy cache backend doesn't really behave like a test backend,\n     # so it has different test requirements.\n     def setUp(self):\n-        self.cache = get_cache('dummy://')\n+        self.cache = get_cache('django.core.cache.backends.dummy.DummyCache')\n \n     def test_simple(self):\n         \"Dummy cache backend ignores cache set calls\"\n@@ -429,9 +429,6 @@ def test_cache_versioning_get_set(self):\n         self.assertEqual(self.cache.get('answer1', version=2), None)\n \n         self.assertEqual(self.v2_cache.get('answer1'), None)\n-        # print '---'\n-        # print 'c1',self.cache._cache\n-        # print 'v2',self.v2_cache._cache\n         self.assertEqual(self.v2_cache.get('answer1', version=1), 42)\n         self.assertEqual(self.v2_cache.get('answer1', version=2), None)\n \n@@ -704,11 +701,11 @@ def setUp(self):\n         # Spaces are used in the table name to ensure quoting/escaping is working\n         self._table_name = 'test cache table'\n         management.call_command('createcachetable', self._table_name, verbosity=0, interactive=False)\n-        self.cache = get_cache('db://%s?max_entries=30' % self._table_name)\n-        self.prefix_cache = get_cache('db://%s' % self._table_name, key_prefix='cacheprefix')\n-        self.v2_cache = get_cache('db://%s' % self._table_name, version=2)\n-        self.custom_key_cache = get_cache('db://%s' % self._table_name, key_func=custom_key_func)\n-        self.custom_key_cache2 = get_cache('db://%s' % self._table_name, key_func='regressiontests.cache.tests.custom_key_func')\n+        self.cache = get_cache('django.core.cache.backends.db.DatabaseCache', LOCATION=self._table_name, OPTIONS={'MAX_ENTRIES': 30})\n+        self.prefix_cache = get_cache('django.core.cache.backends.db.DatabaseCache', LOCATION=self._table_name, KEY_PREFIX='cacheprefix')\n+        self.v2_cache = get_cache('django.core.cache.backends.db.DatabaseCache', LOCATION=self._table_name, VERSION=2)\n+        self.custom_key_cache = get_cache('django.core.cache.backends.db.DatabaseCache', LOCATION=self._table_name, KEY_FUNCTION=custom_key_func)\n+        self.custom_key_cache2 = get_cache('django.core.cache.backends.db.DatabaseCache', LOCATION=self._table_name, KEY_FUNCTION='regressiontests.cache.tests.custom_key_func')\n \n     def tearDown(self):\n         from django.db import connection\n@@ -719,16 +716,20 @@ def test_cull(self):\n         self.perform_cull_test(50, 29)\n \n     def test_zero_cull(self):\n+        self.cache = get_cache('django.core.cache.backends.db.DatabaseCache', LOCATION=self._table_name, OPTIONS={'MAX_ENTRIES': 30, 'CULL_FREQUENCY': 0})\n+        self.perform_cull_test(50, 18)\n+\n+    def test_old_initialization(self):\n         self.cache = get_cache('db://%s?max_entries=30&cull_frequency=0' % self._table_name)\n         self.perform_cull_test(50, 18)\n \n class LocMemCacheTests(unittest.TestCase, BaseCacheTests):\n     def setUp(self):\n-        self.cache = get_cache('locmem://?max_entries=30')\n-        self.prefix_cache = get_cache('locmem://', key_prefix='cacheprefix')\n-        self.v2_cache = get_cache('locmem://', version=2)\n-        self.custom_key_cache = get_cache('locmem://?max_entries=30', key_func=custom_key_func)\n-        self.custom_key_cache2 = get_cache('locmem://?max_entries=30', key_func='regressiontests.cache.tests.custom_key_func')\n+        self.cache = get_cache('django.core.cache.backends.locmem.LocMemCache', OPTIONS={'MAX_ENTRIES': 30})\n+        self.prefix_cache = get_cache('django.core.cache.backends.locmem.LocMemCache', KEY_PREFIX='cacheprefix')\n+        self.v2_cache = get_cache('django.core.cache.backends.locmem.LocMemCache', VERSION=2)\n+        self.custom_key_cache = get_cache('django.core.cache.backends.locmem.LocMemCache', OPTIONS={'MAX_ENTRIES': 30}, KEY_FUNCTION=custom_key_func)\n+        self.custom_key_cache2 = get_cache('django.core.cache.backends.locmem.LocMemCache', OPTIONS={'MAX_ENTRIES': 30}, KEY_FUNCTION='regressiontests.cache.tests.custom_key_func')\n \n         # LocMem requires a hack to make the other caches\n         # share a data store with the 'normal' cache.\n@@ -744,24 +745,32 @@ def setUp(self):\n         self.custom_key_cache2._cache = self.cache._cache\n         self.custom_key_cache2._expire_info = self.cache._expire_info\n \n+    def tearDown(self):\n+        self.cache.clear()\n+\n     def test_cull(self):\n         self.perform_cull_test(50, 29)\n \n     def test_zero_cull(self):\n+        self.cache = get_cache('django.core.cache.backends.locmem.LocMemCache', OPTIONS={'MAX_ENTRIES': 30, 'CULL_FREQUENCY': 0})\n+        self.perform_cull_test(50, 19)\n+\n+    def test_old_initialization(self):\n         self.cache = get_cache('locmem://?max_entries=30&cull_frequency=0')\n         self.perform_cull_test(50, 19)\n \n # memcached backend isn't guaranteed to be available.\n # To check the memcached backend, the test settings file will\n-# need to contain a CACHE_BACKEND setting that points at\n+# need to contain a cache backend setting that points at\n # your memcache server.\n class MemcachedCacheTests(unittest.TestCase, BaseCacheTests):\n     def setUp(self):\n-        self.cache = get_cache(settings.CACHE_BACKEND)\n-        self.prefix_cache = get_cache(settings.CACHE_BACKEND, key_prefix='cacheprefix')\n-        self.v2_cache = get_cache(settings.CACHE_BACKEND, version=2)\n-        self.custom_key_cache = get_cache(settings.CACHE_BACKEND, key_func=custom_key_func)\n-        self.custom_key_cache2 = get_cache(settings.CACHE_BACKEND, key_func='regressiontests.cache.tests.custom_key_func')\n+        name = settings.CACHES[DEFAULT_CACHE_ALIAS]['LOCATION']\n+        self.cache = get_cache('django.core.cache.backends.memcached.MemcachedCache', LOCATION=name)\n+        self.prefix_cache = get_cache('django.core.cache.backends.memcached.MemcachedCache', LOCATION=name, KEY_PREFIX='cacheprefix')\n+        self.v2_cache = get_cache('django.core.cache.backends.memcached.MemcachedCache', LOCATION=name, VERSION=2)\n+        self.custom_key_cache = get_cache('django.core.cache.backends.memcached.MemcachedCache', LOCATION=name, KEY_FUNCTION=custom_key_func)\n+        self.custom_key_cache2 = get_cache('django.core.cache.backends.memcached.MemcachedCache', LOCATION=name, KEY_FUNCTION='regressiontests.cache.tests.custom_key_func')\n \n     def tearDown(self):\n         self.cache.clear()\n@@ -781,19 +790,19 @@ def test_invalid_keys(self):\n         # memcached limits key length to 250\n         self.assertRaises(Exception, self.cache.set, 'a' * 251, 'value')\n \n-MemcachedCacheTests = unittest.skipUnless(settings.CACHE_BACKEND.startswith('memcached://'), \"memcached not available\")(MemcachedCacheTests)\n+MemcachedCacheTests = unittest.skipUnless(settings.CACHES[DEFAULT_CACHE_ALIAS]['BACKEND'].startswith('django.core.cache.backends.memcached.'), \"memcached not available\")(MemcachedCacheTests)\n \n class FileBasedCacheTests(unittest.TestCase, BaseCacheTests):\n     \"\"\"\n     Specific test cases for the file-based cache.\n     \"\"\"\n     def setUp(self):\n         self.dirname = tempfile.mkdtemp()\n-        self.cache = get_cache('file://%s?max_entries=30' % self.dirname)\n-        self.prefix_cache = get_cache('file://%s' % self.dirname, key_prefix='cacheprefix')\n-        self.v2_cache = get_cache('file://%s' % self.dirname, version=2)\n-        self.custom_key_cache = get_cache('file://%s' % self.dirname, key_func=custom_key_func)\n-        self.custom_key_cache2 = get_cache('file://%s' % self.dirname, key_func='regressiontests.cache.tests.custom_key_func')\n+        self.cache = get_cache('django.core.cache.backends.filebased.FileBasedCache', LOCATION=self.dirname, OPTIONS={'MAX_ENTRIES': 30})\n+        self.prefix_cache = get_cache('django.core.cache.backends.filebased.FileBasedCache', LOCATION=self.dirname, KEY_PREFIX='cacheprefix')\n+        self.v2_cache = get_cache('django.core.cache.backends.filebased.FileBasedCache', LOCATION=self.dirname, VERSION=2)\n+        self.custom_key_cache = get_cache('django.core.cache.backends.filebased.FileBasedCache', LOCATION=self.dirname, KEY_FUNCTION=custom_key_func)\n+        self.custom_key_cache2 = get_cache('django.core.cache.backends.filebased.FileBasedCache', LOCATION=self.dirname, KEY_FUNCTION='regressiontests.cache.tests.custom_key_func')\n \n     def tearDown(self):\n         self.cache.clear()\n@@ -824,6 +833,10 @@ def test_subdirectory_removal(self):\n     def test_cull(self):\n         self.perform_cull_test(50, 29)\n \n+    def test_old_initialization(self):\n+        self.cache = get_cache('file://%s?max_entries=30' % self.dirname)\n+        self.perform_cull_test(50, 29)\n+\n class CustomCacheKeyValidationTests(unittest.TestCase):\n     \"\"\"\n     Tests for the ability to mixin a custom ``validate_key`` method to\n@@ -911,28 +924,35 @@ def test_learn_cache_key(self):\n class PrefixedCacheUtils(CacheUtils):\n     def setUp(self):\n         super(PrefixedCacheUtils, self).setUp()\n-        self.old_cache_key_prefix = settings.CACHE_KEY_PREFIX\n-        settings.CACHE_KEY_PREFIX = 'cacheprefix'\n+        self.old_cache_key_prefix = settings.CACHES['default'].get('KEY_PREFIX', None)\n+        settings.CACHES['default']['KEY_PREFIX'] = 'cacheprefix'\n \n     def tearDown(self):\n         super(PrefixedCacheUtils, self).tearDown()\n-        settings.CACHE_KEY_PREFIX = self.old_cache_key_prefix\n+        if self.old_cache_key_prefix is None:\n+            del settings.CACHES['default']['KEY_PREFIX']\n+        else:\n+            settings.CACHES['default']['KEY_PREFIX'] = self.old_cache_key_prefix\n \n class CacheHEADTest(unittest.TestCase):\n \n     def setUp(self):\n         self.orig_cache_middleware_seconds = settings.CACHE_MIDDLEWARE_SECONDS\n         self.orig_cache_middleware_key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n-        self.orig_cache_backend = settings.CACHE_BACKEND\n+        self.orig_caches = settings.CACHES\n         settings.CACHE_MIDDLEWARE_SECONDS = 60\n         settings.CACHE_MIDDLEWARE_KEY_PREFIX = 'test'\n-        settings.CACHE_BACKEND = 'locmem:///'\n+        settings.CACHES = {\n+            'default': {\n+                'BACKEND': 'django.core.cache.backends.locmem.LocMemCache'\n+            }\n+        }\n         self.path = '/cache/test/'\n \n     def tearDown(self):\n         settings.CACHE_MIDDLEWARE_SECONDS = self.orig_cache_middleware_seconds\n         settings.CACHE_MIDDLEWARE_KEY_PREFIX = self.orig_cache_middleware_key_prefix\n-        settings.CACHE_BACKEND = self.orig_cache_backend\n+        settings.CACHES = self.orig_caches\n \n     def _get_request(self, method):\n         request = HttpRequest()\n@@ -981,7 +1001,7 @@ class CacheI18nTest(unittest.TestCase):\n     def setUp(self):\n         self.orig_cache_middleware_seconds = settings.CACHE_MIDDLEWARE_SECONDS\n         self.orig_cache_middleware_key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n-        self.orig_cache_backend = settings.CACHE_BACKEND\n+        self.orig_caches = settings.CACHES\n         self.orig_use_i18n = settings.USE_I18N\n         self.orig_languages =  settings.LANGUAGES\n         settings.LANGUAGES = (\n@@ -994,7 +1014,7 @@ def setUp(self):\n     def tearDown(self):\n         settings.CACHE_MIDDLEWARE_SECONDS = self.orig_cache_middleware_seconds\n         settings.CACHE_MIDDLEWARE_KEY_PREFIX = self.orig_cache_middleware_key_prefix\n-        settings.CACHE_BACKEND = self.orig_cache_backend\n+        settings.CACHES = self.orig_caches\n         settings.USE_I18N = self.orig_use_i18n\n         settings.LANGUAGES = self.orig_languages\n         translation.deactivate()\n@@ -1046,8 +1066,12 @@ def set_cache(request, lang, msg):\n             return UpdateCacheMiddleware().process_response(request, response)\n \n         settings.CACHE_MIDDLEWARE_SECONDS = 60\n-        settings.CACHE_MIDDLEWARE_KEY_PREFIX=\"test\"\n-        settings.CACHE_BACKEND='locmem:///'\n+        settings.CACHE_MIDDLEWARE_KEY_PREFIX = \"test\"\n+        settings.CACHES = {\n+            'default': {\n+                'BACKEND': 'django.core.cache.backends.locmem.LocMemCache'\n+            }\n+        }\n         settings.USE_ETAGS = True\n         settings.USE_I18N = True\n         en_message =\"Hello world!\"\n@@ -1083,12 +1107,15 @@ def set_cache(request, lang, msg):\n class PrefixedCacheI18nTest(CacheI18nTest):\n     def setUp(self):\n         super(PrefixedCacheI18nTest, self).setUp()\n-        self.old_cache_key_prefix = settings.CACHE_KEY_PREFIX\n-        settings.CACHE_KEY_PREFIX = 'cacheprefix'\n+        self.old_cache_key_prefix = settings.CACHES['default'].get('KEY_PREFIX', None)\n+        settings.CACHES['default']['KEY_PREFIX'] = 'cacheprefix'\n \n     def tearDown(self):\n         super(PrefixedCacheI18nTest, self).tearDown()\n-        settings.CACHE_KEY_PREFIX = self.old_cache_key_prefix\n+        if self.old_cache_key_prefix is not None:\n+            del settings.CACHES['default']['KEY_PREFIX']\n+        else:\n+            settings.CACHES['default']['KEY_PREFIX'] = self.old_cache_key_prefix\n \n if __name__ == '__main__':\n     unittest.main()"
        },
        {
            "sha": "99776e611a92595a868dbb21dbf248596db1ee96",
            "filename": "tests/regressiontests/templates/tests.py",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/django/django/blob/673e6fc7fb243ed44841b9969d26a161c25733b3/tests%2Fregressiontests%2Ftemplates%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/673e6fc7fb243ed44841b9969d26a161c25733b3/tests%2Fregressiontests%2Ftemplates%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Ftemplates%2Ftests.py?ref=673e6fc7fb243ed44841b9969d26a161c25733b3",
            "patch": "@@ -1453,8 +1453,6 @@ def get_template_tests(self):\n             'url-asvar03': ('{% load url from future %}{% url \"no_such_view\" as url %}{{ url }}', {}, ''),\n \n             ### CACHE TAG ######################################################\n-            'cache01': ('{% load cache %}{% cache -1 test %}cache01{% endcache %}', {}, 'cache01'),\n-            'cache02': ('{% load cache %}{% cache -1 test %}cache02{% endcache %}', {}, 'cache02'),\n             'cache03': ('{% load cache %}{% cache 2 test %}cache03{% endcache %}', {}, 'cache03'),\n             'cache04': ('{% load cache %}{% cache 2 test %}cache04{% endcache %}', {}, 'cache03'),\n             'cache05': ('{% load cache %}{% cache 2 test foo %}cache05{% endcache %}', {'foo': 1}, 'cache05'),\n@@ -1463,8 +1461,6 @@ def get_template_tests(self):\n \n             # Allow first argument to be a variable.\n             'cache08': ('{% load cache %}{% cache time test foo %}cache08{% endcache %}', {'foo': 2, 'time': 2}, 'cache06'),\n-            'cache09': ('{% load cache %}{% cache time test foo %}cache09{% endcache %}', {'foo': 3, 'time': -1}, 'cache09'),\n-            'cache10': ('{% load cache %}{% cache time test foo %}cache10{% endcache %}', {'foo': 3, 'time': -1}, 'cache10'),\n \n             # Raise exception if we don't have at least 2 args, first one integer.\n             'cache11': ('{% load cache %}{% cache %}{% endcache %}', {}, template.TemplateSyntaxError),"
        }
    ],
    "stats": {
        "total": 996,
        "additions": 744,
        "deletions": 252
    }
}