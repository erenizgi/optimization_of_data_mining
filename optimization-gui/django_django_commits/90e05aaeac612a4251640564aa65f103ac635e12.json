{
    "author": "PaulMcMillan",
    "message": "Renovated password hashing, including the forgotten files in r17253.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17254 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "90e05aaeac612a4251640564aa65f103ac635e12",
    "files": [
        {
            "sha": "0b3b6c317424a5629a48abd02fa6c3f73469962d",
            "filename": "django/contrib/auth/hashers.py",
            "status": "added",
            "additions": 362,
            "deletions": 0,
            "changes": 362,
            "blob_url": "https://github.com/django/django/blob/90e05aaeac612a4251640564aa65f103ac635e12/django%2Fcontrib%2Fauth%2Fhashers.py",
            "raw_url": "https://github.com/django/django/raw/90e05aaeac612a4251640564aa65f103ac635e12/django%2Fcontrib%2Fauth%2Fhashers.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fauth%2Fhashers.py?ref=90e05aaeac612a4251640564aa65f103ac635e12",
            "patch": "@@ -0,0 +1,362 @@\n+import hashlib\n+\n+from django.conf import settings\n+from django.utils import importlib\n+from django.utils.datastructures import SortedDict\n+from django.utils.encoding import smart_str\n+from django.core.exceptions import ImproperlyConfigured\n+from django.utils.crypto import (\n+    pbkdf2, constant_time_compare, get_random_string)\n+\n+\n+UNUSABLE_PASSWORD = '!'  # This will never be a valid encoded hash\n+HASHERS = None  # lazily loaded from PASSWORD_HASHERS\n+PREFERRED_HASHER = None  # defaults to first item in PASSWORD_HASHERS\n+\n+\n+def is_password_usable(encoded):\n+    return (encoded is not None and encoded != UNUSABLE_PASSWORD)\n+\n+\n+def check_password(password, encoded, setter=None, preferred='default'):\n+    \"\"\"\n+    Returns a boolean of whether the raw password matches the three\n+    part encoded digest.\n+\n+    If setter is specified, it'll be called when you need to\n+    regenerate the password.\n+    \"\"\"\n+    if not password or not is_password_usable(encoded):\n+        return False\n+\n+    preferred = get_hasher(preferred)\n+    raw_password = password\n+    password = smart_str(password)\n+    encoded = smart_str(encoded)\n+\n+    if len(encoded) == 32 and '$' not in encoded:\n+        hasher = get_hasher('md5')\n+    else:\n+        algorithm = encoded.split('$', 1)[0]\n+        hasher = get_hasher(algorithm)\n+\n+    must_update = hasher.algorithm != preferred.algorithm\n+    is_correct = hasher.verify(password, encoded)\n+    if setter and is_correct and must_update:\n+        setter(raw_password)\n+    return is_correct\n+\n+\n+def make_password(password, salt=None, hasher='default'):\n+    \"\"\"\n+    Turn a plain-text password into a hash for database storage\n+\n+    Same as encode() but generates a new random salt.  If\n+    password is None or blank then UNUSABLE_PASSWORD will be\n+    returned which disallows logins.\n+    \"\"\"\n+    if not password:\n+        return UNUSABLE_PASSWORD\n+\n+    hasher = get_hasher(hasher)\n+    password = smart_str(password)\n+\n+    if not salt:\n+        salt = hasher.salt()\n+    salt = smart_str(salt)\n+\n+    return hasher.encode(password, salt)\n+\n+\n+def load_hashers():\n+    global HASHERS\n+    global PREFERRED_HASHER\n+    hashers = []\n+    for backend in settings.PASSWORD_HASHERS:\n+        try:\n+            mod_path, cls_name = backend.rsplit('.', 1)\n+            mod = importlib.import_module(mod_path)\n+            hasher_cls = getattr(mod, cls_name)\n+        except (AttributeError, ImportError, ValueError):\n+            raise ImproperlyConfigured(\"hasher not found: %s\" % backend)\n+        hasher = hasher_cls()\n+        if not getattr(hasher, 'algorithm'):\n+            raise ImproperlyConfigured(\"hasher doesn't specify an \"\n+                                       \"algorithm name: %s\" % backend)\n+        hashers.append(hasher)\n+    HASHERS = dict([(hasher.algorithm, hasher) for hasher in hashers])\n+    PREFERRED_HASHER = hashers[0]\n+\n+\n+def get_hasher(algorithm='default'):\n+    \"\"\"\n+    Returns an instance of a loaded password hasher.\n+\n+    If algorithm is 'default', the default hasher will be returned.\n+    This function will also lazy import hashers specified in your\n+    settings file if needed.\n+    \"\"\"\n+    if hasattr(algorithm, 'algorithm'):\n+        return algorithm\n+\n+    elif algorithm == 'default':\n+        if PREFERRED_HASHER is None:\n+            load_hashers()\n+        return PREFERRED_HASHER\n+    else:\n+        if HASHERS is None:\n+            load_hashers()\n+        if algorithm not in HASHERS:\n+            raise ValueError(\"Unknown password hashing algorithm '%s'. \"\n+                             \"Did you specify it in the PASSWORD_HASHERS \"\n+                             \"setting?\" % algorithm)\n+        return HASHERS[algorithm]\n+\n+\n+def mask_hash(hash, show=6, char=\"*\"):\n+    \"\"\"\n+    Returns the given hash, with only the first ``show`` number shown. The\n+    rest are masked with ``char`` for security reasons.\n+    \"\"\"\n+    masked = hash[:show]\n+    masked += char * len(hash[show:])\n+    return masked\n+\n+\n+class BasePasswordHasher(object):\n+    \"\"\"\n+    Abstract base class for password hashers\n+\n+    When creating your own hasher, you need to override algorithm,\n+    verify(), encode() and safe_summary().\n+\n+    PasswordHasher objects are immutable.\n+    \"\"\"\n+    algorithm = None\n+    library = None\n+\n+    def _load_library(self):\n+        if self.library is not None:\n+            if isinstance(self.library, (tuple, list)):\n+                name, mod_path = self.library\n+            else:\n+                name = mod_path = self.library\n+            try:\n+                module = importlib.import_module(mod_path)\n+            except ImportError:\n+                raise ValueError(\"Couldn't load %s password algorithm \"\n+                                 \"library\" % name)\n+            return module\n+        raise ValueError(\"Hasher '%s' doesn't specify a library attribute\" %\n+                         self.__class__)\n+\n+    def salt(self):\n+        \"\"\"\n+        Generates a cryptographically secure nonce salt in ascii\n+        \"\"\"\n+        return get_random_string()\n+\n+    def verify(self, password, encoded):\n+        \"\"\"\n+        Checks if the given password is correct\n+        \"\"\"\n+        raise NotImplementedError()\n+\n+    def encode(self, password, salt):\n+        \"\"\"\n+        Creates an encoded database value\n+\n+        The result is normally formatted as \"algorithm$salt$hash\" and\n+        must be fewer than 128 characters.\n+        \"\"\"\n+        raise NotImplementedError()\n+\n+    def safe_summary(self, encoded):\n+        \"\"\"\n+        Returns a summary of safe values\n+\n+        The result is a dictionary and will be used where the password field\n+        must be displayed to construct a safe representation of the password.\n+        \"\"\"\n+        raise NotImplementedError()\n+\n+\n+class PBKDF2PasswordHasher(BasePasswordHasher):\n+    \"\"\"\n+    Secure password hashing using the PBKDF2 algorithm (recommended)\n+\n+    Configured to use PBKDF2 + HMAC + SHA256 with 10000 iterations.\n+    The result is a 64 byte binary string.  Iterations may be changed\n+    safely but you must rename the algorithm if you change SHA256.\n+    \"\"\"\n+    algorithm = \"pbkdf2_sha256\"\n+    iterations = 10000\n+    digest = hashlib.sha256\n+\n+    def encode(self, password, salt, iterations=None):\n+        assert password\n+        assert salt and '$' not in salt\n+        if not iterations:\n+            iterations = self.iterations\n+        hash = pbkdf2(password, salt, iterations, digest=self.digest)\n+        hash = hash.encode('base64').strip()\n+        return \"%s$%d$%s$%s\" % (self.algorithm, iterations, salt, hash)\n+\n+    def verify(self, password, encoded):\n+        algorithm, iterations, salt, hash = encoded.split('$', 3)\n+        assert algorithm == self.algorithm\n+        encoded_2 = self.encode(password, salt, int(iterations))\n+        return constant_time_compare(encoded, encoded_2)\n+\n+    def safe_summary(self, encoded):\n+        algorithm, iterations, salt, hash = encoded.split('$', 3)\n+        assert algorithm == self.algorithm\n+        return SortedDict([\n+            ('algorithm', algorithm),\n+            ('iterations', iterations),\n+            ('salt', mask_hash(salt)),\n+            ('hash', mask_hash(hash)),\n+        ])\n+\n+\n+class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):\n+    \"\"\"\n+    Alternate PBKDF2 hasher which uses SHA1, the default PRF\n+    recommended by PKCS #5. This is compatible with other\n+    implementations of PBKDF2, such as openssl's\n+    PKCS5_PBKDF2_HMAC_SHA1().\n+    \"\"\"\n+    algorithm = \"pbkdf2_sha1\"\n+    digest = hashlib.sha1\n+\n+\n+class BCryptPasswordHasher(BasePasswordHasher):\n+    \"\"\"\n+    Secure password hashing using the bcrypt algorithm (recommended)\n+\n+    This is considered by many to be the most secure algorithm but you\n+    must first install the py-bcrypt library.  Please be warned that\n+    this library depends on native C code and might cause portability\n+    issues.\n+    \"\"\"\n+    algorithm = \"bcrypt\"\n+    library = (\"py-bcrypt\", \"bcrypt\")\n+    rounds = 12\n+\n+    def salt(self):\n+        bcrypt = self._load_library()\n+        return bcrypt.gensalt(self.rounds)\n+\n+    def encode(self, password, salt):\n+        bcrypt = self._load_library()\n+        data = bcrypt.hashpw(password, salt)\n+        return \"%s$%s\" % (self.algorithm, data)\n+\n+    def verify(self, password, encoded):\n+        algorithm, data = encoded.split('$', 1)\n+        assert algorithm == self.algorithm\n+        bcrypt = self._load_library()\n+        return constant_time_compare(data, bcrypt.hashpw(password, data))\n+\n+    def safe_summary(self, encoded):\n+        algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)\n+        assert algorithm == self.algorithm\n+        salt, checksum = data[:22], data[22:]\n+        return SortedDict([\n+            ('algorithm', algorithm),\n+            ('work factor', work_factor),\n+            ('salt', mask_hash(salt)),\n+            ('checksum', mask_hash(checksum)),\n+        ])\n+\n+\n+class SHA1PasswordHasher(BasePasswordHasher):\n+    \"\"\"\n+    The SHA1 password hashing algorithm (not recommended)\n+    \"\"\"\n+    algorithm = \"sha1\"\n+\n+    def encode(self, password, salt):\n+        assert password\n+        assert salt and '$' not in salt\n+        hash = hashlib.sha1(salt + password).hexdigest()\n+        return \"%s$%s$%s\" % (self.algorithm, salt, hash)\n+\n+    def verify(self, password, encoded):\n+        algorithm, salt, hash = encoded.split('$', 2)\n+        assert algorithm == self.algorithm\n+        encoded_2 = self.encode(password, salt)\n+        return constant_time_compare(encoded, encoded_2)\n+\n+    def safe_summary(self, encoded):\n+        algorithm, salt, hash = encoded.split('$', 2)\n+        assert algorithm == self.algorithm\n+        return SortedDict([\n+            ('algorithm', algorithm),\n+            ('salt', mask_hash(salt, show=2)),\n+            ('hash', mask_hash(hash)),\n+        ])\n+\n+\n+class MD5PasswordHasher(BasePasswordHasher):\n+    \"\"\"\n+    I am an incredibly insecure algorithm you should *never* use;\n+    stores unsalted MD5 hashes without the algorithm prefix.\n+\n+    This class is implemented because Django used to store passwords\n+    this way. Some older Django installs still have these values\n+    lingering around so we need to handle and upgrade them properly.\n+    \"\"\"\n+    algorithm = \"md5\"\n+\n+    def salt(self):\n+        return ''\n+\n+    def encode(self, password, salt):\n+        return hashlib.md5(password).hexdigest()\n+\n+    def verify(self, password, encoded):\n+        encoded_2 = self.encode(password, '')\n+        return constant_time_compare(encoded, encoded_2)\n+\n+    def safe_summary(self, encoded):\n+        return SortedDict([\n+            ('algorithm', self.algorithm),\n+            ('hash', mask_hash(encoded, show=3)),\n+        ])\n+\n+\n+class CryptPasswordHasher(BasePasswordHasher):\n+    \"\"\"\n+    Password hashing using UNIX crypt (not recommended)\n+\n+    The crypt module is not supported on all platforms.\n+    \"\"\"\n+    algorithm = \"crypt\"\n+    library = \"crypt\"\n+\n+    def salt(self):\n+        return get_random_string(2)\n+\n+    def encode(self, password, salt):\n+        crypt = self._load_library()\n+        assert len(salt) == 2\n+        data = crypt.crypt(password, salt)\n+        # we don't need to store the salt, but Django used to do this\n+        return \"%s$%s$%s\" % (self.algorithm, '', data)\n+\n+    def verify(self, password, encoded):\n+        crypt = self._load_library()\n+        algorithm, salt, data = encoded.split('$', 2)\n+        assert algorithm == self.algorithm\n+        return constant_time_compare(data, crypt.crypt(password, data))\n+\n+    def safe_summary(self, encoded):\n+        algorithm, salt, data = encoded.split('$', 2)\n+        assert algorithm == self.algorithm\n+        return SortedDict([\n+            ('algorithm', algorithm),\n+            ('salt', salt),\n+            ('hash', mask_hash(data, show=3)),\n+        ])\n+"
        },
        {
            "sha": "4c66cafe34144c287e6668e97eb3d8c000e166a0",
            "filename": "django/contrib/auth/tests/hashers.py",
            "status": "added",
            "additions": 128,
            "deletions": 0,
            "changes": 128,
            "blob_url": "https://github.com/django/django/blob/90e05aaeac612a4251640564aa65f103ac635e12/django%2Fcontrib%2Fauth%2Ftests%2Fhashers.py",
            "raw_url": "https://github.com/django/django/raw/90e05aaeac612a4251640564aa65f103ac635e12/django%2Fcontrib%2Fauth%2Ftests%2Fhashers.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fauth%2Ftests%2Fhashers.py?ref=90e05aaeac612a4251640564aa65f103ac635e12",
            "patch": "@@ -0,0 +1,128 @@\n+from django.conf.global_settings import PASSWORD_HASHERS as default_hashers\n+from django.contrib.auth.hashers import (is_password_usable, \n+    check_password, make_password, PBKDF2PasswordHasher, load_hashers,\n+    PBKDF2SHA1PasswordHasher, get_hasher, UNUSABLE_PASSWORD)\n+from django.utils import unittest\n+from django.utils.unittest import skipUnless\n+from django.test.utils import override_settings\n+\n+\n+try:\n+    import crypt\n+except ImportError:\n+    crypt = None\n+\n+try:\n+    import bcrypt\n+except ImportError:\n+    bcrypt = None\n+\n+\n+class TestUtilsHashPass(unittest.TestCase):\n+    def setUp(self):\n+        load_hashers()\n+\n+    def test_simple(self):\n+        encoded = make_password('letmein')\n+        self.assertTrue(encoded.startswith('pbkdf2_sha256$'))\n+        self.assertTrue(is_password_usable(encoded))\n+        self.assertTrue(check_password(u'letmein', encoded))\n+        self.assertFalse(check_password('letmeinz', encoded))\n+\n+    def test_pkbdf2(self):\n+        encoded = make_password('letmein', 'seasalt', 'pbkdf2_sha256')\n+        self.assertEqual(encoded, \n+'pbkdf2_sha256$10000$seasalt$FQCNpiZpTb0zub+HBsH6TOwyRxJ19FwvjbweatNmK/Y=')\n+        self.assertTrue(is_password_usable(encoded))\n+        self.assertTrue(check_password(u'letmein', encoded))\n+        self.assertFalse(check_password('letmeinz', encoded))\n+\n+    def test_sha1(self):\n+        encoded = make_password('letmein', 'seasalt', 'sha1')\n+        self.assertEqual(encoded, \n+'sha1$seasalt$fec3530984afba6bade3347b7140d1a7da7da8c7')\n+        self.assertTrue(is_password_usable(encoded))\n+        self.assertTrue(check_password(u'letmein', encoded))\n+        self.assertFalse(check_password('letmeinz', encoded))\n+\n+    def test_md5(self):\n+        encoded = make_password('letmein', 'seasalt', 'md5')\n+        self.assertEqual(encoded, '0d107d09f5bbe40cade3de5c71e9e9b7')\n+        self.assertTrue(is_password_usable(encoded))\n+        self.assertTrue(check_password(u'letmein', encoded))\n+        self.assertFalse(check_password('letmeinz', encoded))\n+\n+    @skipUnless(crypt, \"no crypt module to generate password.\")\n+    def test_crypt(self):\n+        encoded = make_password('letmein', 'ab', 'crypt')\n+        self.assertEqual(encoded, 'crypt$$abN/qM.L/H8EQ')\n+        self.assertTrue(is_password_usable(encoded))\n+        self.assertTrue(check_password(u'letmein', encoded))\n+        self.assertFalse(check_password('letmeinz', encoded))\n+\n+    @skipUnless(bcrypt, \"py-bcrypt not installed\")\n+    def test_bcrypt(self):\n+        encoded = make_password('letmein', hasher='bcrypt')\n+        self.assertTrue(is_password_usable(encoded))\n+        self.assertTrue(encoded.startswith('bcrypt$'))\n+        self.assertTrue(check_password(u'letmein', encoded))\n+        self.assertFalse(check_password('letmeinz', encoded))\n+\n+    def test_unusable(self):\n+        encoded = make_password(None)\n+        self.assertFalse(is_password_usable(encoded))\n+        self.assertFalse(check_password(None, encoded))\n+        self.assertFalse(check_password(UNUSABLE_PASSWORD, encoded))\n+        self.assertFalse(check_password('', encoded))\n+        self.assertFalse(check_password(u'letmein', encoded))\n+        self.assertFalse(check_password('letmeinz', encoded))\n+\n+    def test_bad_algorithm(self):\n+        def doit():\n+            make_password('letmein', hasher='lolcat')\n+        self.assertRaises(ValueError, doit)\n+\n+    def test_low_level_pkbdf2(self):\n+        hasher = PBKDF2PasswordHasher()\n+        encoded = hasher.encode('letmein', 'seasalt')\n+        self.assertEqual(encoded, \n+'pbkdf2_sha256$10000$seasalt$FQCNpiZpTb0zub+HBsH6TOwyRxJ19FwvjbweatNmK/Y=')\n+        self.assertTrue(hasher.verify('letmein', encoded))\n+\n+    def test_low_level_pbkdf2_sha1(self):\n+        hasher = PBKDF2SHA1PasswordHasher()\n+        encoded = hasher.encode('letmein', 'seasalt')\n+        self.assertEqual(encoded, \n+'pbkdf2_sha1$10000$seasalt$91JiNKgwADC8j2j86Ije/cc4vfQ=')\n+        self.assertTrue(hasher.verify('letmein', encoded))\n+\n+    def test_upgrade(self):\n+        self.assertEqual('pbkdf2_sha256', get_hasher('default').algorithm)\n+        for algo in ('sha1', 'md5'):\n+            encoded = make_password('letmein', hasher=algo)\n+            state = {'upgraded': False}\n+            def setter(password):\n+                state['upgraded'] = True\n+            self.assertTrue(check_password('letmein', encoded, setter))\n+            self.assertTrue(state['upgraded'])\n+\n+    def test_no_upgrade(self):\n+        encoded = make_password('letmein')\n+        state = {'upgraded': False}\n+        def setter():\n+            state['upgraded'] = True\n+        self.assertFalse(check_password('WRONG', encoded, setter))\n+        self.assertFalse(state['upgraded'])\n+\n+    def test_no_upgrade_on_incorrect_pass(self):\n+        self.assertEqual('pbkdf2_sha256', get_hasher('default').algorithm)\n+        for algo in ('sha1', 'md5'):\n+            encoded = make_password('letmein', hasher=algo)\n+            state = {'upgraded': False}\n+            def setter():\n+                state['upgraded'] = True\n+            self.assertFalse(check_password('WRONG', encoded, setter))\n+            self.assertFalse(state['upgraded'])\n+\n+\n+TestUtilsHashPass = override_settings(PASSWORD_HASHERS=default_hashers)(TestUtilsHashPass)"
        },
        {
            "sha": "520c25e3c8bab04599b317e9f9bacccbf4b5425f",
            "filename": "django/contrib/auth/utils.py",
            "status": "removed",
            "additions": 0,
            "deletions": 63,
            "changes": 63,
            "blob_url": "https://github.com/django/django/blob/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Fcontrib%2Fauth%2Futils.py",
            "raw_url": "https://github.com/django/django/raw/dce820ff70f00e974afd3e6e310aa825bc55319f/django%2Fcontrib%2Fauth%2Futils.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcontrib%2Fauth%2Futils.py?ref=dce820ff70f00e974afd3e6e310aa825bc55319f",
            "patch": "@@ -1,63 +0,0 @@\n-import hashlib\n-from django.utils.encoding import smart_str\n-from django.utils.crypto import constant_time_compare\n-\n-UNUSABLE_PASSWORD = '!' # This will never be a valid hash\n-\n-def get_hexdigest(algorithm, salt, raw_password):\n-    \"\"\"\n-    Returns a string of the hexdigest of the given plaintext password and salt\n-    using the given algorithm ('md5', 'sha1' or 'crypt').\n-    \"\"\"\n-    raw_password, salt = smart_str(raw_password), smart_str(salt)\n-    if algorithm == 'crypt':\n-        try:\n-            import crypt\n-        except ImportError:\n-            raise ValueError('\"crypt\" password algorithm not supported in this environment')\n-        return crypt.crypt(raw_password, salt)\n-\n-    if algorithm == 'md5':\n-        return hashlib.md5(salt + raw_password).hexdigest()\n-    elif algorithm == 'sha1':\n-        return hashlib.sha1(salt + raw_password).hexdigest()\n-    raise ValueError(\"Got unknown password algorithm type in password.\")\n-\n-def get_random_string(length=12, allowed_chars='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):\n-    \"\"\"\n-    Returns a random string of length characters from the set of a-z, A-Z, 0-9\n-    for use as a salt.\n-\n-    The default length of 12 with the a-z, A-Z, 0-9 character set returns\n-    a 71-bit salt. log_2((26+26+10)^12) =~ 71 bits\n-    \"\"\"\n-    import random\n-    try:\n-        random = random.SystemRandom()\n-    except NotImplementedError:\n-        pass\n-    return ''.join([random.choice(allowed_chars) for i in range(length)])\n-\n-def check_password(raw_password, enc_password):\n-    \"\"\"\n-    Returns a boolean of whether the raw_password was correct. Handles\n-    hashing formats behind the scenes.\n-    \"\"\"\n-    parts = enc_password.split('$')\n-    if len(parts) != 3:\n-        return False\n-    algo, salt, hsh = parts\n-    return constant_time_compare(hsh, get_hexdigest(algo, salt, raw_password))\n-\n-def is_password_usable(encoded_password):\n-    return encoded_password is not None and encoded_password != UNUSABLE_PASSWORD\n-\n-def make_password(algo, raw_password):\n-    \"\"\"\n-    Produce a new password string in this format: algorithm$salt$hash\n-    \"\"\"\n-    if raw_password is None:\n-        return UNUSABLE_PASSWORD\n-    salt = get_random_string()\n-    hsh = get_hexdigest(algo, salt, raw_password)\n-    return '%s$%s$%s' % (algo, salt, hsh)"
        },
        {
            "sha": "f025ffa790266f30db5d109308fed0a1463de8cb",
            "filename": "tests/regressiontests/utils/crypto.py",
            "status": "added",
            "additions": 133,
            "deletions": 0,
            "changes": 133,
            "blob_url": "https://github.com/django/django/blob/90e05aaeac612a4251640564aa65f103ac635e12/tests%2Fregressiontests%2Futils%2Fcrypto.py",
            "raw_url": "https://github.com/django/django/raw/90e05aaeac612a4251640564aa65f103ac635e12/tests%2Fregressiontests%2Futils%2Fcrypto.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Futils%2Fcrypto.py?ref=90e05aaeac612a4251640564aa65f103ac635e12",
            "patch": "@@ -0,0 +1,133 @@\n+\n+import math\n+import timeit\n+import hashlib\n+\n+from django.utils import unittest\n+from django.utils.crypto import pbkdf2\n+\n+\n+class TestUtilsCryptoPBKDF2(unittest.TestCase):\n+\n+    # http://tools.ietf.org/html/draft-josefsson-pbkdf2-test-vectors-06\n+    rfc_vectors = [\n+        {\n+            \"args\": {\n+                \"password\": \"password\",\n+                \"salt\": \"salt\",\n+                \"iterations\": 1,\n+                \"dklen\": 20,\n+                \"digest\": hashlib.sha1,\n+            },\n+            \"result\": \"0c60c80f961f0e71f3a9b524af6012062fe037a6\",\n+        },\n+        {\n+            \"args\": {\n+                \"password\": \"password\",\n+                \"salt\": \"salt\",\n+                \"iterations\": 2,\n+                \"dklen\": 20,\n+                \"digest\": hashlib.sha1,\n+            },\n+            \"result\": \"ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957\",\n+        },\n+        {\n+            \"args\": {\n+                \"password\": \"password\",\n+                \"salt\": \"salt\",\n+                \"iterations\": 4096,\n+                \"dklen\": 20,\n+                \"digest\": hashlib.sha1,\n+            },\n+            \"result\": \"4b007901b765489abead49d926f721d065a429c1\",\n+        },\n+        # # this takes way too long :(\n+        # {\n+        #     \"args\": {\n+        #         \"password\": \"password\",\n+        #         \"salt\": \"salt\",\n+        #         \"iterations\": 16777216,\n+        #         \"dklen\": 20,\n+        #         \"digest\": hashlib.sha1,\n+        #     },\n+        #     \"result\": \"eefe3d61cd4da4e4e9945b3d6ba2158c2634e984\",\n+        # },\n+        {\n+            \"args\": {\n+                \"password\": \"passwordPASSWORDpassword\",\n+                \"salt\": \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",\n+                \"iterations\": 4096,\n+                \"dklen\": 25,\n+                \"digest\": hashlib.sha1,\n+            },\n+            \"result\": \"3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038\",\n+        },\n+        {\n+            \"args\": {\n+                \"password\": \"pass\\0word\",\n+                \"salt\": \"sa\\0lt\",\n+                \"iterations\": 4096,\n+                \"dklen\": 16,\n+                \"digest\": hashlib.sha1,\n+            },\n+            \"result\": \"56fa6aa75548099dcc37d7f03425e0c3\",\n+        },\n+    ]\n+\n+    regression_vectors = [\n+        {\n+            \"args\": {\n+                \"password\": \"password\",\n+                \"salt\": \"salt\",\n+                \"iterations\": 1,\n+                \"dklen\": 20,\n+                \"digest\": hashlib.sha256,\n+            },\n+            \"result\": \"120fb6cffcf8b32c43e7225256c4f837a86548c9\",\n+        },\n+        {\n+            \"args\": {\n+                \"password\": \"password\",\n+                \"salt\": \"salt\",\n+                \"iterations\": 1,\n+                \"dklen\": 20,\n+                \"digest\": hashlib.sha512,\n+            },\n+            \"result\": \"867f70cf1ade02cff3752599a3a53dc4af34c7a6\",\n+        },\n+        {\n+            \"args\": {\n+                \"password\": \"password\",\n+                \"salt\": \"salt\",\n+                \"iterations\": 1000,\n+                \"dklen\": 0,\n+                \"digest\": hashlib.sha512,\n+            },\n+            \"result\": (\"afe6c5530785b6cc6b1c6453384731bd5ee432ee\"\n+                       \"549fd42fb6695779ad8a1c5bf59de69c48f774ef\"\n+                       \"c4007d5298f9033c0241d5ab69305e7b64eceeb8d\"\n+                       \"834cfec\"),\n+        },\n+    ]\n+\n+    def test_public_vectors(self):\n+        for vector in self.rfc_vectors:\n+            result = pbkdf2(**vector['args'])\n+            self.assertEqual(result.encode('hex'), vector['result'])\n+\n+    def test_regression_vectors(self):\n+        for vector in self.regression_vectors:\n+            result = pbkdf2(**vector['args'])\n+            self.assertEqual(result.encode('hex'), vector['result'])\n+\n+    def test_performance_scalability(self):\n+        \"\"\"\n+        Theory: If you run with 100 iterations, it should take 100\n+        times as long as running with 1 iteration.\n+        \"\"\"\n+        n1, n2 = 100, 10000\n+        elapsed = lambda f: timeit.timeit(f, number=1)\n+        t1 = elapsed(lambda: pbkdf2(\"password\", \"salt\", iterations=n1))\n+        t2 = elapsed(lambda: pbkdf2(\"password\", \"salt\", iterations=n2))\n+        measured_scale_exponent = math.log(t2 / t1, n2 / n1)\n+        self.assertLess(measured_scale_exponent, 1.1)"
        }
    ],
    "stats": {
        "total": 686,
        "additions": 623,
        "deletions": 63
    }
}