{
    "author": "alex",
    "message": "Converted the model_regress doctests into unittests.  We have always been at war with doctests.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@14614 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "3ede430b9a94e3c2aed64d2cf898920635bdf4ae",
    "files": [
        {
            "sha": "f30b3eecd77944123b3f217c082d8b318e69ad67",
            "filename": "tests/regressiontests/model_regress/models.py",
            "status": "modified",
            "additions": 1,
            "deletions": 113,
            "changes": 114,
            "blob_url": "https://github.com/django/django/blob/3ede430b9a94e3c2aed64d2cf898920635bdf4ae/tests%2Fregressiontests%2Fmodel_regress%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/3ede430b9a94e3c2aed64d2cf898920635bdf4ae/tests%2Fregressiontests%2Fmodel_regress%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fmodel_regress%2Fmodels.py?ref=3ede430b9a94e3c2aed64d2cf898920635bdf4ae",
            "patch": "@@ -1,9 +1,6 @@\n # coding: utf-8\n-import datetime\n+from django.db import models\n \n-from django.conf import settings\n-from django.db import models, DEFAULT_DB_ALIAS, connection\n-from django.utils import tzinfo\n \n CHOICES = (\n     (1, 'first'),\n@@ -60,112 +57,3 @@ def __unicode__(self):\n \n class NonAutoPK(models.Model):\n     name = models.CharField(max_length=10, primary_key=True)\n-\n-__test__ = {'API_TESTS': \"\"\"\n-(NOTE: Part of the regression test here is merely parsing the model\n-declaration. The verbose_name, in particular, did not always work.)\n-\n-An empty choice field should return None for the display name.\n-\n->>> from datetime import datetime\n->>> a = Article(headline=\"Look at me!\", pub_date=datetime.now())\n->>> a.save()\n->>> a.get_status_display() is None\n-True\n-\n-Empty strings should be returned as Unicode\n->>> a2 = Article.objects.get(pk=a.id)\n->>> a2.misc_data\n-u''\n-\n-# TextFields can hold more than 4000 characters (this was broken in Oracle).\n->>> a3 = Article(headline=\"Really, really big\", pub_date=datetime.now())\n->>> a3.article_text = \"ABCDE\" * 1000\n->>> a3.save()\n->>> a4 = Article.objects.get(pk=a3.id)\n->>> len(a4.article_text)\n-5000\n-\n-# Regression test for #659\n->>> import datetime\n->>> p = Party.objects.create(when = datetime.datetime(1999, 12, 31))\n->>> p = Party.objects.create(when = datetime.datetime(1998, 12, 31))\n->>> p = Party.objects.create(when = datetime.datetime(1999, 1, 1))\n->>> [p.when for p in Party.objects.filter(when__month=2)]\n-[]\n->>> [p.when for p in Party.objects.filter(when__month=1)]\n-[datetime.date(1999, 1, 1)]\n->>> [p.when for p in Party.objects.filter(when__month=12)]\n-[datetime.date(1999, 12, 31), datetime.date(1998, 12, 31)]\n->>> [p.when for p in Party.objects.filter(when__year=1998)]\n-[datetime.date(1998, 12, 31)]\n-\n-# Regression test for #8510\n->>> [p.when for p in Party.objects.filter(when__day='31')]\n-[datetime.date(1999, 12, 31), datetime.date(1998, 12, 31)]\n->>> [p.when for p in Party.objects.filter(when__month='12')]\n-[datetime.date(1999, 12, 31), datetime.date(1998, 12, 31)]\n->>> [p.when for p in Party.objects.filter(when__year='1998')]\n-[datetime.date(1998, 12, 31)]\n-\n-# Date filtering was failing with NULL date values in SQLite (regression test\n-# for #3501, amongst other things).\n->>> _ = Party.objects.create()\n->>> p = Party.objects.filter(when__month=1)[0]\n->>> p.when\n-datetime.date(1999, 1, 1)\n->>> l = Party.objects.filter(pk=p.pk).dates(\"when\", \"month\")\n->>> l[0].month == 1\n-True\n-\n-# Check that get_next_by_FIELD and get_previous_by_FIELD don't crash when we\n-# have usecs values stored on the database\n-#\n-# [It crashed after the Field.get_db_prep_* refactor, because on most backends\n-#  DateTimeFields supports usecs, but DateTimeField.to_python didn't recognize\n-#  them. (Note that Model._get_next_or_previous_by_FIELD coerces values to\n-#  strings)]\n-#\n->>> e = Event.objects.create(when = datetime.datetime(2000, 1, 1, 16, 0, 0))\n->>> e = Event.objects.create(when = datetime.datetime(2000, 1, 1, 6, 1, 1))\n->>> e = Event.objects.create(when = datetime.datetime(2000, 1, 1, 13, 1, 1))\n->>> e = Event.objects.create(when = datetime.datetime(2000, 1, 1, 12, 0, 20, 24))\n->>> e.get_next_by_when().when\n-datetime.datetime(2000, 1, 1, 13, 1, 1)\n->>> e.get_previous_by_when().when\n-datetime.datetime(2000, 1, 1, 6, 1, 1)\n-\n-# Check Department and Worker\n->>> d = Department(id=10, name='IT')\n->>> d.save()\n->>> w = Worker(department=d, name='Full-time')\n->>> w.save()\n->>> w\n-<Worker: Full-time>\n-\n-# Models with broken unicode methods should still have a printable repr\n->>> b = BrokenUnicodeMethod(name=\"Jerry\")\n->>> b.save()\n->>> BrokenUnicodeMethod.objects.all()\n-[<BrokenUnicodeMethod: [Bad Unicode data]>]\n-\n-\"\"\"}\n-\n-if connection.features.supports_timezones:\n-    __test__[\"timezone-tests\"] = \"\"\"\n-# Saving an updating with timezone-aware datetime Python objects. Regression\n-# test for #10443.\n-\n-# The idea is that all these creations and saving should work without crashing.\n-# It's not rocket science.\n->>> Article.objects.all().delete()\n->>> dt1 = datetime.datetime(2008, 8, 31, 16, 20, tzinfo=tzinfo.FixedOffset(600))\n->>> dt2 = datetime.datetime(2008, 8, 31, 17, 20, tzinfo=tzinfo.FixedOffset(600))\n->>> obj = Article.objects.create(headline=\"A headline\", pub_date=dt1, article_text=\"foo\")\n-\n->>> obj.pub_date = dt2\n->>> obj.save()\n->>> Article.objects.filter(headline=\"A headline\").update(pub_date=dt1)\n-1\n-\n-\"\"\""
        },
        {
            "sha": "48b0f70f67982903e2cb0a6a3e3acb940941e220",
            "filename": "tests/regressiontests/model_regress/tests.py",
            "status": "modified",
            "additions": 151,
            "deletions": 8,
            "changes": 159,
            "blob_url": "https://github.com/django/django/blob/3ede430b9a94e3c2aed64d2cf898920635bdf4ae/tests%2Fregressiontests%2Fmodel_regress%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/3ede430b9a94e3c2aed64d2cf898920635bdf4ae/tests%2Fregressiontests%2Fmodel_regress%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fmodel_regress%2Ftests.py?ref=3ede430b9a94e3c2aed64d2cf898920635bdf4ae",
            "patch": "@@ -1,23 +1,166 @@\n-from django.core.exceptions import ValidationError\n-from django.test import TestCase\n+import datetime\n+from operator import attrgetter\n \n-from models import Worker, NonAutoPK\n+from django.test import TestCase, skipUnlessDBFeature\n+from django.utils import tzinfo\n \n+from models import (Worker, Article, Party, Event, Department,\n+    BrokenUnicodeMethod, NonAutoPK)\n \n-class RelatedModelOrderedLookupTest(TestCase):\n-    \"\"\"\n-    Regression test for #10153: foreign key __gte and __lte lookups.\n-    \"\"\"\n \n+\n+class ModelTests(TestCase):\n     # The bug is that the following queries would raise:\n     # \"TypeError: Related Field has invalid lookup: gte\"\n-\n     def test_related_gte_lookup(self):\n+        \"\"\"\n+        Regression test for #10153: foreign key __gte lookups.\n+        \"\"\"\n         Worker.objects.filter(department__gte=0)\n \n     def test_related_lte_lookup(self):\n+        \"\"\"\n+        Regression test for #10153: foreign key __lte lookups.\n+        \"\"\"\n         Worker.objects.filter(department__lte=0)\n \n+    def test_empty_choice(self):\n+        # NOTE: Part of the regression test here is merely parsing the model\n+        # declaration. The verbose_name, in particular, did not always work.\n+        a = Article.objects.create(\n+            headline=\"Look at me!\", pub_date=datetime.datetime.now()\n+        )\n+        # An empty choice field should return None for the display name.\n+        self.assertIs(a.get_status_display(), None)\n+\n+        # Empty strings should be returned as Unicode\n+        a = Article.objects.get(pk=a.pk)\n+        self.assertEqual(a.misc_data, u'')\n+        self.assertIs(type(a.misc_data), unicode)\n+\n+    def test_long_textfield(self):\n+        # TextFields can hold more than 4000 characters (this was broken in\n+        # Oracle).\n+        a = Article.objects.create(\n+            headline=\"Really, really big\",\n+            pub_date=datetime.datetime.now(),\n+            article_text = \"ABCDE\" * 1000\n+        )\n+        a = Article.objects.get(pk=a.pk)\n+        self.assertEqual\n+        (len(a.article_text), 5000)\n+\n+    def test_date_lookup(self):\n+        # Regression test for #659\n+        Party.objects.create(when=datetime.datetime(1999, 12, 31))\n+        Party.objects.create(when=datetime.datetime(1998, 12, 31))\n+        Party.objects.create(when=datetime.datetime(1999, 1, 1))\n+        self.assertQuerysetEqual(\n+            Party.objects.filter(when__month=2), []\n+        )\n+        self.assertQuerysetEqual(\n+            Party.objects.filter(when__month=1), [\n+                datetime.date(1999, 1, 1)\n+            ],\n+            attrgetter(\"when\")\n+        )\n+        self.assertQuerysetEqual(\n+            Party.objects.filter(when__month=12), [\n+                datetime.date(1999, 12, 31),\n+                datetime.date(1998, 12, 31),\n+            ],\n+            attrgetter(\"when\")\n+        )\n+        self.assertQuerysetEqual(\n+            Party.objects.filter(when__year=1998), [\n+                datetime.date(1998, 12, 31),\n+            ],\n+            attrgetter(\"when\")\n+        )\n+        # Regression test for #8510\n+        self.assertQuerysetEqual(\n+            Party.objects.filter(when__day=\"31\"), [\n+                datetime.date(1999, 12, 31),\n+                datetime.date(1998, 12, 31),\n+            ],\n+            attrgetter(\"when\")\n+        )\n+        self.assertQuerysetEqual(\n+            Party.objects.filter(when__month=\"12\"), [\n+                datetime.date(1999, 12, 31),\n+                datetime.date(1998, 12, 31),\n+            ],\n+            attrgetter(\"when\")\n+        )\n+        self.assertQuerysetEqual(\n+            Party.objects.filter(when__year=\"1998\"), [\n+                datetime.date(1998, 12, 31),\n+            ],\n+            attrgetter(\"when\")\n+        )\n+\n+    def test_date_filter_null(self):\n+        # Date filtering was failing with NULL date values in SQLite\n+        # (regression test for #3501, amongst other things).\n+        Party.objects.create(when=datetime.datetime(1999, 1, 1))\n+        Party.objects.create()\n+        p = Party.objects.filter(when__month=1)[0]\n+        self.assertEqual(p.when, datetime.date(1999, 1, 1))\n+        self.assertQuerysetEqual(\n+            Party.objects.filter(pk=p.pk).dates(\"when\", \"month\"), [\n+                1\n+            ],\n+            attrgetter(\"month\")\n+        )\n+\n+    def test_get_next_prev_by_field(self):\n+        # Check that get_next_by_FIELD and get_previous_by_FIELD don't crash\n+        # when we have usecs values stored on the database\n+        #\n+        # It crashed after the Field.get_db_prep_* refactor, because on most\n+        # backends DateTimeFields supports usecs, but DateTimeField.to_python\n+        # didn't recognize them. (Note that\n+        # Model._get_next_or_previous_by_FIELD coerces values to strings)\n+        Event.objects.create(when=datetime.datetime(2000, 1, 1, 16, 0, 0))\n+        Event.objects.create(when=datetime.datetime(2000, 1, 1, 6, 1, 1))\n+        Event.objects.create(when=datetime.datetime(2000, 1, 1, 13, 1, 1))\n+        e = Event.objects.create(when=datetime.datetime(2000, 1, 1, 12, 0, 20, 24))\n+\n+        self.assertEqual(\n+            e.get_next_by_when().when, datetime.datetime(2000, 1, 1, 13, 1, 1)\n+        )\n+        self.assertEqual(\n+            e.get_previous_by_when().when, datetime.datetime(2000, 1, 1, 6, 1, 1)\n+        )\n+\n+    def test_primary_key_foreign_key_types(self):\n+        # Check Department and Worker (non-default PK type)\n+        d = Department.objects.create(id=10, name=\"IT\")\n+        w = Worker.objects.create(department=d, name=\"Full-time\")\n+        self.assertEqual(unicode(w), \"Full-time\")\n+\n+    def test_broken_unicode(self):\n+        # Models with broken unicode methods should still have a printable repr\n+        b = BrokenUnicodeMethod.objects.create(name=\"Jerry\")\n+        self.assertEqual(repr(b), \"<BrokenUnicodeMethod: [Bad Unicode data]>\")\n+\n+    @skipUnlessDBFeature(\"supports_timezones\")\n+    def test_timezones(self):\n+        # Saving an updating with timezone-aware datetime Python objects.\n+        # Regression test for #10443.\n+        # The idea is that all these creations and saving should work without\n+        # crashing. It's not rocket science.\n+        dt1 = datetime.datetime(2008, 8, 31, 16, 20, tzinfo=tzinfo.FixedOffset(600))\n+        dt2 = datetime.datetime(2008, 8, 31, 17, 20, tzinfo=tzinfo.FixedOffset(600))\n+        obj = Article.objects.create(\n+            headline=\"A headline\", pub_date=dt1, article_text=\"foo\"\n+        )\n+        obj.pub_date = dt2\n+        obj.save()\n+        self.assertEqual(\n+            Article.objects.filter(headline=\"A headline\").update(pub_date=dt1),\n+            1\n+        )\n \n class ModelValidationTest(TestCase):\n     def test_pk_validation(self):"
        }
    ],
    "stats": {
        "total": 273,
        "additions": 152,
        "deletions": 121
    }
}