{
    "author": "ramiro",
    "message": "Mention backward relationships in aggregate docs.\n\nThanks Anssi and Marc Tamlyn for reviewing.\n\nFixes #19803.",
    "sha": "0560bfb705687c831e2769b1202706e2ceb1f7a7",
    "files": [
        {
            "sha": "49134e24c05372356e93f178f5fc185f703b3a33",
            "filename": "docs/topics/db/aggregation.txt",
            "status": "modified",
            "additions": 49,
            "deletions": 4,
            "changes": 53,
            "blob_url": "https://github.com/django/django/blob/0560bfb705687c831e2769b1202706e2ceb1f7a7/docs%2Ftopics%2Fdb%2Faggregation.txt",
            "raw_url": "https://github.com/django/django/raw/0560bfb705687c831e2769b1202706e2ceb1f7a7/docs%2Ftopics%2Fdb%2Faggregation.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Fdb%2Faggregation.txt?ref=0560bfb705687c831e2769b1202706e2ceb1f7a7",
            "patch": "@@ -21,14 +21,12 @@ used to track the inventory for a series of online bookstores:\n     class Author(models.Model):\n        name = models.CharField(max_length=100)\n        age = models.IntegerField()\n-       friends = models.ManyToManyField('self', blank=True)\n \n     class Publisher(models.Model):\n        name = models.CharField(max_length=300)\n        num_awards = models.IntegerField()\n \n     class Book(models.Model):\n-       isbn = models.CharField(max_length=9)\n        name = models.CharField(max_length=300)\n        pages = models.IntegerField()\n        price = models.DecimalField(max_digits=10, decimal_places=2)\n@@ -40,6 +38,7 @@ used to track the inventory for a series of online bookstores:\n     class Store(models.Model):\n        name = models.CharField(max_length=300)\n        books = models.ManyToManyField(Book)\n+       registered_users = models.PositiveIntegerField()\n \n Cheat sheet\n ===========\n@@ -64,6 +63,9 @@ In a hurry? Here's how to do common aggregate queries, assuming the models above\n     >>> Book.objects.all().aggregate(Max('price'))\n     {'price__max': Decimal('81.20')}\n \n+    # All the following queries involve traversing the Book<->Publisher\n+    # many-to-many relationship backward\n+\n     # Each publisher, each with a count of books as a \"num_books\" attribute.\n     >>> from django.db.models import Count\n     >>> pubs = Publisher.objects.annotate(num_books=Count('book'))\n@@ -73,7 +75,6 @@ In a hurry? Here's how to do common aggregate queries, assuming the models above\n     73\n \n     # The top 5 publishers, in order by number of books.\n-    >>> from django.db.models import Count\n     >>> pubs = Publisher.objects.annotate(num_books=Count('book')).order_by('-num_books')[:5]\n     >>> pubs[0].num_books\n     1323\n@@ -169,7 +170,7 @@ specify the annotation::\n Unlike ``aggregate()``, ``annotate()`` is *not* a terminal clause. The output\n of the ``annotate()`` clause is a ``QuerySet``; this ``QuerySet`` can be\n modified using any other ``QuerySet`` operation, including ``filter()``,\n-``order_by``, or even additional calls to ``annotate()``.\n+``order_by()``, or even additional calls to ``annotate()``.\n \n Joins and aggregates\n ====================\n@@ -205,6 +206,50 @@ issue the query::\n \n     >>> Store.objects.aggregate(youngest_age=Min('books__authors__age'))\n \n+Following relationships backwards\n+---------------------------------\n+\n+In a way similar to :ref:`lookups-that-span-relationships`, aggregations and\n+annotations on fields of models or models that are related to the one you are\n+querying can include traversing \"reverse\" relationships. The lowercase name\n+of related models and double-underscores are used here too.\n+\n+For example, we can ask for all publishers, annotated with their respective\n+total book stock counters (note how we use `'book'` to specify the\n+Publisher->Book reverse foreign key hop)::\n+\n+    >>> from django.db.models import Count, Min, Sum, Max, Avg\n+    >>> Publisher.objects.annotate(Count('book'))\n+\n+(Every Publisher in the resulting QuerySet will have an extra attribute called\n+``book__count``.)\n+\n+We can also ask for the oldest book of any of those managed by every publisher::\n+\n+    >>> Publisher.objects.aggregate(oldest_pubdate=Min('book__pubdate'))\n+\n+(The resulting dictionary will have a key called ``'oldest_pubdate'``. If no\n+such alias was specified, it would be the rather long ``'book__pubdate__min'``.)\n+\n+This doesn't apply just to foreign keys. It also works with many-to-many\n+relations. For example, we can ask for every author, annotated with the total\n+number of pages considering all the books he/she has (co-)authored (note how we\n+use `'book'` to specify the Author->Book reverse many-to-many hop)::\n+\n+    >>> Author.objects.annotate(total_pages=Sum('book__pages'))\n+\n+(Every Author in the resulting QuerySet will have an extra attribute called\n+``total_pages``. If no such alias was specified, it would be the rather long\n+``book__pages__sum``.)\n+\n+Or ask for the average rating of all the books written by author(s) we have on\n+file::\n+\n+    >>> Author.objects.aggregate(average_rating=Avg('book__rating'))\n+\n+(The resulting dictionary will have a key called ``'average__rating'``. If no\n+such alias was specified, it would be the rather long ``'book__rating__avg'``.)\n+\n Aggregations and other QuerySet clauses\n =======================================\n "
        }
    ],
    "stats": {
        "total": 53,
        "additions": 49,
        "deletions": 4
    }
}