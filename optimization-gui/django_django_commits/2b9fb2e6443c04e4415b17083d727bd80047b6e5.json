{
    "author": "akaariai",
    "message": "Fixed #18251 -- Removed a deadlock possibility in apploading\n\nThanks to harm for the report and comments.",
    "sha": "2b9fb2e6443c04e4415b17083d727bd80047b6e5",
    "files": [
        {
            "sha": "d651584e7af5da6116d9699db57196e36730f268",
            "filename": "django/db/models/loading.py",
            "status": "modified",
            "additions": 15,
            "deletions": 4,
            "changes": 19,
            "blob_url": "https://github.com/django/django/blob/2b9fb2e6443c04e4415b17083d727bd80047b6e5/django%2Fdb%2Fmodels%2Floading.py",
            "raw_url": "https://github.com/django/django/raw/2b9fb2e6443c04e4415b17083d727bd80047b6e5/django%2Fdb%2Fmodels%2Floading.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Floading.py?ref=2b9fb2e6443c04e4415b17083d727bd80047b6e5",
            "patch": "@@ -6,9 +6,9 @@\n from django.utils.importlib import import_module\n from django.utils.module_loading import module_has_submodule\n \n+import imp\n import sys\n import os\n-import threading\n \n __all__ = ('get_apps', 'get_app', 'get_models', 'get_model', 'register_models',\n         'load_app', 'app_cache_ready')\n@@ -39,7 +39,6 @@ class AppCache(object):\n         handled = {},\n         postponed = [],\n         nesting_level = 0,\n-        write_lock = threading.RLock(),\n         _get_models_cache = {},\n     )\n \n@@ -54,7 +53,14 @@ def _populate(self):\n         \"\"\"\n         if self.loaded:\n             return\n-        with self.write_lock:\n+        # Note that we want to use the import lock here - the app loading is\n+        # in many cases initiated implicitly by importing, and thus it is\n+        # possible to end up in deadlock when one thread initiates loading\n+        # without holding the importer lock and another thread then tries to\n+        # import something which also launches the app loading. For details of\n+        # this situation see #18251.\n+        imp.acquire_lock()\n+        try:\n             if self.loaded:\n                 return\n             for app_name in settings.INSTALLED_APPS:\n@@ -65,6 +71,8 @@ def _populate(self):\n                 for app_name in self.postponed:\n                     self.load_app(app_name)\n                 self.loaded = True\n+        finally:\n+            imp.release_lock()\n \n     def _label_for(self, app_mod):\n         \"\"\"\n@@ -135,7 +143,8 @@ def get_app(self, app_label, emptyOK=False):\n         the app has no models in it and 'emptyOK' is True, returns None.\n         \"\"\"\n         self._populate()\n-        with self.write_lock:\n+        imp.acquire_lock()\n+        try:\n             for app_name in settings.INSTALLED_APPS:\n                 if app_label == app_name.split('.')[-1]:\n                     mod = self.load_app(app_name, False)\n@@ -146,6 +155,8 @@ def get_app(self, app_label, emptyOK=False):\n                     else:\n                         return mod\n             raise ImproperlyConfigured(\"App with label %s could not be found\" % app_label)\n+        finally:\n+            imp.release_lock()\n \n     def get_app_errors(self):\n         \"Returns the map of known problems with the INSTALLED_APPS.\""
        }
    ],
    "stats": {
        "total": 19,
        "additions": 15,
        "deletions": 4
    }
}