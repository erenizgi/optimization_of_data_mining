{
    "author": "malcolmt",
    "message": "Slightly rewrite @permalink and get_absolute_url() documentation.\n\nPart 2 of the model instance documentation changes. Slightly tidied up\nget_absolute_url() and @permalink documentation to collapse some of the\nearlier versions into a preferred learning order. I'm still not\namazingly happy with this, but larger rewrites are needed to the URLconf\nstuff across a few files before I can get it into the most natural\norder, I suspect. That's a slightly longer-term project.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16702 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "77189afb7f603fc382fbb33a3a54f2b9499dc2cf",
    "files": [
        {
            "sha": "d31e887512d614c7ed1293b884a455e1c63e2561",
            "filename": "docs/ref/models/instances.txt",
            "status": "modified",
            "additions": 58,
            "deletions": 40,
            "changes": 98,
            "blob_url": "https://github.com/django/django/blob/77189afb7f603fc382fbb33a3a54f2b9499dc2cf/docs%2Fref%2Fmodels%2Finstances.txt",
            "raw_url": "https://github.com/django/django/raw/77189afb7f603fc382fbb33a3a54f2b9499dc2cf/docs%2Fref%2Fmodels%2Finstances.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Fmodels%2Finstances.txt?ref=77189afb7f603fc382fbb33a3a54f2b9499dc2cf",
            "patch": "@@ -414,60 +414,82 @@ using ``__str__()`` like this::\n .. method:: Model.get_absolute_url()\n \n Define a ``get_absolute_url()`` method to tell Django how to calculate the\n-canonical URL for an object. For example::\n+canonical URL for an object. To callers, this method should appear to return a\n+string that can be used to refer to the object over HTTP.\n+\n+For example::\n \n     def get_absolute_url(self):\n         return \"/people/%i/\" % self.id\n \n-Django uses this in its admin interface. If an object defines\n-``get_absolute_url()``, the object-editing page will have a \"View on site\"\n-link that will jump you directly to the object's public view, according to\n+(Whilst this code is correct and simple, it may not be the most portable way to\n+write this kind of method. The :func:`permalink() decorator <permalink>`,\n+documented below, is usually the best approach and you should read that section\n+before diving into code implementation.)\n+\n+One place Django uses ``get_absolute_url()`` is in the admin app. If an object\n+defines this method, the object-editing page will have a \"View on site\" link\n+that will jump you directly to the object's public view, as given by\n ``get_absolute_url()``.\n \n-Also, a couple of other bits of Django, such as the :doc:`syndication feed\n-framework </ref/contrib/syndication>`, use ``get_absolute_url()`` as a\n-convenience to reward people who've defined the method.\n+Similarly, a couple of other bits of Django, such as the :doc:`syndication feed\n+framework </ref/contrib/syndication>`, use ``get_absolute_url()`` when it is\n+defined. If it makes sense for your model's instances to each have a unique\n+URL, you should define ``get_absolute_url()``.\n \n It's good practice to use ``get_absolute_url()`` in templates, instead of\n hard-coding your objects' URLs. For example, this template code is bad::\n \n+    <!-- BAD template code. Avoid! -->\n     <a href=\"/people/{{ object.id }}/\">{{ object.name }}</a>\n \n-But this template code is good::\n+This template code is much better::\n \n     <a href=\"{{ object.get_absolute_url }}\">{{ object.name }}</a>\n \n+The logic here is that if you change the URL structure of your objects, even\n+for something simple such as correcting a spelling error, you don't want to\n+have to track down every place that the URL might be created. Specify it once,\n+in ``get_absolute_url()`` and have all your other code call that one place.\n+\n .. note::\n-    The string you return from ``get_absolute_url()`` must contain only ASCII\n-    characters (required by the URI spec, `RFC 2396`_) that have been\n-    URL-encoded, if necessary. Code and templates using ``get_absolute_url()``\n-    should be able to use the result directly without needing to do any\n-    further processing. You may wish to use the\n+    The string you return from ``get_absolute_url()`` **must** contain only\n+    ASCII characters (required by the URI specfication, `RFC 2396`_) and be\n+    URL-encoded, if necessary.\n+\n+    Code and templates calling ``get_absolute_url()`` should be able to use the\n+    result directly without any further processing. You may wish to use the\n     ``django.utils.encoding.iri_to_uri()`` function to help with this if you\n-    are using unicode strings a lot.\n+    are using unicode strings containing characters outside the ASCII range at\n+    all.\n \n .. _RFC 2396: http://www.ietf.org/rfc/rfc2396.txt\n \n The ``permalink`` decorator\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-The problem with the way we wrote ``get_absolute_url()`` above is that it\n-slightly violates the DRY principle: the URL for this object is defined both\n-in the URLconf file and in the model.\n+The way we wrote ``get_absolute_url()`` above is a slightly violation of the\n+DRY principle: the URL for this object is defined both in the URLconf file and\n+in the model.\n \n-You can further decouple your models from the URLconf using the ``permalink``\n-decorator:\n+You can decouple your models from the URLconf using the ``permalink`` decorator:\n \n .. function:: permalink()\n \n-This decorator is passed the view function, a list of positional parameters and\n-(optionally) a dictionary of named parameters. Django then works out the correct\n-full URL path using the URLconf, substituting the parameters you have given into\n-the URL. For example, if your URLconf contained a line such as::\n+This decorator takes the name of a URL pattern (either a view name or a URL\n+pattern name) and a list of position or keyword arguments and uses the URLconf\n+patterns to construct the correct, full URL. It returns a string for the\n+correct URL, with all parameters substituted in the correct positions.\n+\n+The ``permalink`` decorator is a Python-level equivalent to the :ttag:`url` template tag and a high-level wrapper for the :func:`django.core.urlresolvers.reverse()` function.\n+\n+An example should make it clear how to use ``permalink()``. Suppose your URLconf\n+contains a line such as::\n \n     (r'^people/(\\d+)/$', 'people.views.details'),\n \n-...your model could have a ``get_absolute_url`` method that looked like this::\n+...your model could have a :meth:`~django.db.models.Model.get_absolute_url()`\n+method that looked like this::\n \n     from django.db import models\n \n@@ -491,26 +513,22 @@ Similarly, if you had a URLconf entry that looked like::\n Notice that we specify an empty sequence for the second parameter in this case,\n because we only want to pass keyword parameters, not positional ones.\n \n-In this way, you're tying the model's absolute path to the view that is used\n-to display it, without repeating the URL information anywhere. You can still\n-use the ``get_absolute_url`` method in templates, as before.\n-\n-In some cases, such as the use of generic views or the re-use of\n-custom views for multiple models, specifying the view function may\n-confuse the reverse URL matcher (because multiple patterns point to\n-the same view).\n+In this way, you're associating the model's absolute path with the view that is\n+used to display it, without repeating the view's URL information anywhere. You\n+can still use the :meth:`~django.db.models.Model.get_absolute_url()` method in\n+templates, as before.\n \n-For that problem, Django has **named URL patterns**. Using a named\n-URL pattern, it's possible to give a name to a pattern, and then\n-reference the name rather than the view function. A named URL\n-pattern is defined by replacing the pattern tuple by a call to\n-the ``url`` function)::\n+In some cases, such as the use of generic views or the re-use of custom views\n+for multiple models, specifying the view function may confuse the reverse URL\n+matcher (because multiple patterns point to the same view). For that case,\n+Django has :ref:`named URL patterns <naming-url-patterns>`. Using a named URL\n+pattern, it's possible to give a name to a pattern, and then reference the name\n+rather than the view function. A named URL pattern is defined by replacing the\n+pattern tuple by a call to the ``url`` function)::\n \n     from django.conf.urls.defaults import *\n \n-    url(r'^people/(\\d+)/$',\n-        'django.views.generic.list_detail.object_detail',\n-        name='people_view'),\n+    url(r'^people/(\\d+)/$', 'blog_views.generic_detail', name='people_view'),\n \n ...and then using that name to perform the reverse URL resolution instead\n of the view name::"
        }
    ],
    "stats": {
        "total": 98,
        "additions": 58,
        "deletions": 40
    }
}