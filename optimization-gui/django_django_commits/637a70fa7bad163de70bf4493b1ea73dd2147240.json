{
    "author": "adrianholovaty",
    "message": "Negligible spacing cleanup in utils/dateparse.py\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17219 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "637a70fa7bad163de70bf4493b1ea73dd2147240",
    "files": [
        {
            "sha": "532bb259c31806457913f578fb4bb811e5e56b83",
            "filename": "django/utils/dateparse.py",
            "status": "modified",
            "additions": 19,
            "deletions": 27,
            "changes": 46,
            "blob_url": "https://github.com/django/django/blob/637a70fa7bad163de70bf4493b1ea73dd2147240/django%2Futils%2Fdateparse.py",
            "raw_url": "https://github.com/django/django/raw/637a70fa7bad163de70bf4493b1ea73dd2147240/django%2Futils%2Fdateparse.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Futils%2Fdateparse.py?ref=637a70fa7bad163de70bf4493b1ea73dd2147240",
            "patch": "@@ -1,58 +1,51 @@\n \"\"\"Functions to parse datetime objects.\"\"\"\n \n # We're using regular expressions rather than time.strptime because:\n-# - they provide both validation and parsing,\n-# - they're more flexible for datetimes,\n-# - the date/datetime/time constructors produce friendlier error messages.\n-\n+# - They provide both validation and parsing.\n+# - They're more flexible for datetimes.\n+# - The date/datetime/time constructors produce friendlier error messages.\n \n import datetime\n import re\n-\n from django.utils.timezone import utc\n from django.utils.tzinfo import FixedOffset\n \n-\n date_re = re.compile(\n-        r'(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})$'\n+    r'(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})$'\n )\n \n-\n datetime_re = re.compile(\n-        r'(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})'\n-        r'[T ](?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})'\n-        r'(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?'\n-        r'(?P<tzinfo>Z|[+-]\\d{1,2}:\\d{1,2})?$'\n+    r'(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})'\n+    r'[T ](?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})'\n+    r'(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?'\n+    r'(?P<tzinfo>Z|[+-]\\d{1,2}:\\d{1,2})?$'\n )\n \n-\n time_re = re.compile(\n-        r'(?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})'\n-        r'(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?'\n+    r'(?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})'\n+    r'(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?'\n )\n \n-\n def parse_date(value):\n-    \"\"\"Parse a string and return a datetime.date.\n+    \"\"\"Parses a string and return a datetime.date.\n \n-    Raise ValueError if the input is well formatted but not a valid date.\n-    Return None if the input isn't well formatted.\n+    Raises ValueError if the input is well formatted but not a valid date.\n+    Returns None if the input isn't well formatted.\n     \"\"\"\n     match = date_re.match(value)\n     if match:\n         kw = dict((k, int(v)) for k, v in match.groupdict().iteritems())\n         return datetime.date(**kw)\n \n-\n def parse_time(value):\n-    \"\"\"Parse a string and return a datetime.time.\n+    \"\"\"Parses a string and return a datetime.time.\n \n     This function doesn't support time zone offsets.\n \n     Sub-microsecond precision is accepted, but ignored.\n \n-    Raise ValueError if the input is well formatted but not a valid time.\n-    Return None if the input isn't well formatted, in particular if it\n+    Raises ValueError if the input is well formatted but not a valid time.\n+    Returns None if the input isn't well formatted, in particular if it\n     contains an offset.\n     \"\"\"\n     match = time_re.match(value)\n@@ -63,17 +56,16 @@ def parse_time(value):\n         kw = dict((k, int(v)) for k, v in kw.iteritems() if v is not None)\n         return datetime.time(**kw)\n \n-\n def parse_datetime(value):\n-    \"\"\"Parse a string and return a datetime.datetime.\n+    \"\"\"Parses a string and return a datetime.datetime.\n \n     This function supports time zone offsets. When the input contains one,\n     the output uses an instance of FixedOffset as tzinfo.\n \n     Sub-microsecond precision is accepted, but ignored.\n \n-    Raise ValueError if the input is well formatted but not a valid datetime.\n-    Return None if the input isn't well formatted.\n+    Raises ValueError if the input is well formatted but not a valid datetime.\n+    Returns None if the input isn't well formatted.\n     \"\"\"\n     match = datetime_re.match(value)\n     if match:"
        }
    ],
    "stats": {
        "total": 46,
        "additions": 19,
        "deletions": 27
    }
}