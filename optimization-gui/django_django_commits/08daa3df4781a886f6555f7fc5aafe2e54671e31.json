{
    "author": "timgraham",
    "message": "Fixed #11152 - Add some classes to the template docs. Thanks adamv for the patch.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@14744 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "08daa3df4781a886f6555f7fc5aafe2e54671e31",
    "files": [
        {
            "sha": "50cb5cedf0825a860dcb358ecaca269b7a92ae75",
            "filename": "docs/ref/templates/api.txt",
            "status": "modified",
            "additions": 36,
            "deletions": 20,
            "changes": 56,
            "blob_url": "https://github.com/django/django/blob/08daa3df4781a886f6555f7fc5aafe2e54671e31/docs%2Fref%2Ftemplates%2Fapi.txt",
            "raw_url": "https://github.com/django/django/raw/08daa3df4781a886f6555f7fc5aafe2e54671e31/docs%2Fref%2Ftemplates%2Fapi.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Fref%2Ftemplates%2Fapi.txt?ref=08daa3df4781a886f6555f7fc5aafe2e54671e31",
            "patch": "@@ -52,6 +52,8 @@ from the context and executing all block tags.\n Using the template system\n =========================\n \n+.. class:: django.template.Template\n+\n Using the template system in Python is a two-step process:\n \n     * First, you compile the raw template code into a ``Template`` object.\n@@ -62,7 +64,7 @@ Compiling a string\n ------------------\n \n The easiest way to create a ``Template`` object is by instantiating it\n-directly. The class lives at ``django.template.Template``. The constructor\n+directly. The class lives at :class:`django.template.Template`. The constructor\n takes one argument -- the raw template code::\n \n     >>> from django.template import Template\n@@ -82,9 +84,11 @@ takes one argument -- the raw template code::\n Rendering a context\n -------------------\n \n+.. method:: render(context)\n+\n Once you have a compiled ``Template`` object, you can render a context -- or\n multiple contexts -- with it. The ``Context`` class lives at\n-``django.template.Context``, and the constructor takes two (optional)\n+:class:`django.template.Context`, and the constructor takes two (optional)\n arguments:\n \n     * A dictionary mapping variable names to variable values.\n@@ -177,7 +181,7 @@ some things to keep in mind:\n         >>> t.render(Context({\"person\": p}))\n         \"My name is .\"\n \n-      Note that ``django.core.exceptions.ObjectDoesNotExist``, which is the\n+      Note that :exc:`django.core.exceptions.ObjectDoesNotExist`, which is the\n       base class for all Django database API ``DoesNotExist`` exceptions, has\n       ``silent_variable_failure = True``. So if you're using Django templates\n       with Django model objects, any ``DoesNotExist`` exception will fail\n@@ -190,16 +194,18 @@ some things to keep in mind:\n     * Obviously, some methods have side effects, and it'd be either foolish or\n       a security hole to allow the template system to access them.\n \n-      A good example is the ``delete()`` method on each Django model object.\n-      The template system shouldn't be allowed to do something like this::\n+      A good example is the :meth:`~django.db.models.Model.delete` method on\n+      each Django model object. The template system shouldn't be allowed to do\n+      something like this::\n \n         I will now delete this valuable data. {{ data.delete }}\n \n       To prevent this, set a function attribute ``alters_data`` on the method.\n       The template system won't execute a method if the method has\n-      ``alters_data=True`` set. The dynamically-generated ``delete()`` and\n-      ``save()`` methods on Django model objects get ``alters_data=True``\n-      automatically. Example::\n+      ``alters_data=True`` set. The dynamically-generated\n+      :meth:`~django.db.models.Model.delete` and\n+      :meth:`~django.db.models.Model.save` methods on Django model objects get\n+      ``alters_data=True`` automatically. Example::\n \n         def sensitive_function(self):\n             self.database_record.delete()\n@@ -245,6 +251,8 @@ be replaced with the name of the invalid variable.\n Playing with Context objects\n ----------------------------\n \n+.. class:: django.template.Context\n+\n Most of the time, you'll instantiate ``Context`` objects by passing in a\n fully-populated dictionary to ``Context()``. But you can add and delete items\n from a ``Context`` object once it's been instantiated, too, using standard\n@@ -260,6 +268,10 @@ dictionary syntax::\n     >>> c['newvariable']\n     'hello'\n \n+.. method:: pop()\n+.. method:: push()\n+.. exception:: django.template.ContextPopException\n+\n A ``Context`` object is a stack. That is, you can ``push()`` and ``pop()`` it.\n If you ``pop()`` too much, it'll raise\n ``django.template.ContextPopException``::\n@@ -281,6 +293,8 @@ If you ``pop()`` too much, it'll raise\n     ...\n     django.template.ContextPopException\n \n+.. method:: update(other_dict)\n+\n In addition to ``push()`` and ``pop()``, the ``Context``\n object also defines an ``update()`` method. This works like ``push()``\n but takes a dictionary as an argument and pushes that dictionary onto\n@@ -333,7 +347,7 @@ and return a dictionary of items to be merged into the context. By default,\n \n .. versionadded:: 1.2\n    In addition to these, ``RequestContext`` always uses\n-   ``'django.core.context_processors.csrf'``.  This is a security\n+   ``django.core.context_processors.csrf``.  This is a security\n    related context processor required by the admin and other contrib apps, and,\n    in case of accidental misconfiguration, it is deliberately hardcoded in and\n    cannot be turned off by the :setting:`TEMPLATE_CONTEXT_PROCESSORS` setting.\n@@ -499,9 +513,9 @@ Writing your own context processors\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n A context processor has a very simple interface: It's just a Python function\n-that takes one argument, an ``HttpRequest`` object, and returns a dictionary\n-that gets added to the template context. Each context processor *must* return\n-a dictionary.\n+that takes one argument, an :class:`~django.http.HttpRequest` object, and\n+returns a dictionary that gets added to the template context. Each context\n+processor *must* return a dictionary.\n \n Custom context processors can live anywhere in your code base. All Django cares\n about is that your custom context processors are pointed-to by your\n@@ -685,13 +699,15 @@ Django uses the template loaders in order according to the\n :setting:`TEMPLATE_LOADERS` setting. It uses each loader until a loader finds a\n match.\n \n-The ``render_to_string()`` shortcut\n+The ``render_to_string`` shortcut\n ===================================\n \n+.. function:: django.template.loader.render_to_string(template_name, dictionary=None, context_instance=None)\n+\n To cut down on the repetitive nature of loading and rendering\n templates, Django provides a shortcut function which largely\n automates the process: ``render_to_string()`` in\n-``django.template.loader``, which loads a template, renders it and\n+:mod:`django.template.loader`, which loads a template, renders it and\n returns the resulting string::\n \n     from django.template.loader import render_to_string\n@@ -713,7 +729,7 @@ the first template in the list that exists) -- and two optional arguments:\n         also be passed as the third positional argument.\n \n See also the :func:`~django.shortcuts.render_to_response()` shortcut, which\n-calls ``render_to_string`` and feeds the result into an ``HttpResponse``\n+calls ``render_to_string`` and feeds the result into an :class:`~django.http.HttpResponse`\n suitable for returning directly from a view.\n \n Configuring the template system in standalone mode\n@@ -737,7 +753,7 @@ dealing with settings files and pointing to them via environment variables.\n To solve this problem, you need to use the manual configuration option described\n in :ref:`settings-without-django-settings-module`. Simply import the appropriate\n pieces of the templating system and then, *before* you call any of the\n-templating functions, call ``django.conf.settings.configure()`` with any\n+templating functions, call :func:`django.conf.settings.configure()` with any\n settings you wish to specify. You might want to consider setting at least\n :setting:`TEMPLATE_DIRS` (if you're going to use template loaders),\n :setting:`DEFAULT_CHARSET` (although the default of ``utf-8`` is probably fine)\n@@ -763,7 +779,7 @@ features like the Django ``Context`` object and handy shortcuts like\n The core component of the Django templating system is the ``Template`` class.\n This class has a very simple interface: it has a constructor that takes a single\n positional argument specifying the template string, and a ``render()`` method\n-that takes a ``django.template.context.Context`` object and returns a string\n+that takes a :class:`~django.template.Context` object and returns a string\n containing the rendered response.\n \n Suppose we're using a template language that defines a ``Template`` object with\n@@ -783,7 +799,7 @@ That's all that's required to make our fictional ``Template`` class compatible\n with the Django loading and rendering system!\n \n The next step is to write a ``Loader`` class that returns instances of our custom\n-template class instead of the default ``django.template.Template``. Custom ``Loader``\n+template class instead of the default :class:`~django.template.Template`. Custom ``Loader``\n classes should inherit from ``django.template.loader.BaseLoader`` and override\n the ``load_template_source()`` method, which takes a ``template_name`` argument,\n loads the template from disk (or elsewhere), and returns a tuple:\n@@ -794,8 +810,8 @@ string by calling ``load_template_source()``, instantiates a ``Template`` from\n the template source, and returns a tuple: ``(template, template_origin)``. Since\n this is the method that actually instantiates the ``Template``, we'll need to\n override it to use our custom template class instead. We can inherit from the\n-builtin ``django.template.loaders.app_directories.Loader`` to take advantage of\n-the ``load_template_source()`` method implemented there::\n+builtin :class:`django.template.loaders.app_directories.Loader` to take advantage\n+of the ``load_template_source()`` method implemented there::\n \n     from django.template.loaders import app_directories\n     class Loader(app_directories.Loader):"
        }
    ],
    "stats": {
        "total": 56,
        "additions": 36,
        "deletions": 20
    }
}