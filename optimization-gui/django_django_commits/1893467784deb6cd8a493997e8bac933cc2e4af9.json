{
    "author": "akaariai",
    "message": "Fixed #19274 -- Made db connection creation overridable in subclasses\n\nConnection creation was done in db backend ._cursor() call. This\nincluded taking a new connection if needed, initializing the session\nstate for the new connection and finally creating the connection.\n\nTo allow easier modifying of these steps in subclasses (for example to\nsupport connection pools) the _cursor() now calls get_new_connection()\nand init_connection_state() if there isn't an existing connection. This\nwas done for all non-gis core backends. In addition the parameters used\nfor taking a connection are now created by get_connection_params().\n\nWe should also do the same for gis backends and encourage 3rd party\nbackends to use the same pattern. The pattern is not enforced in code,\nand as the backends are private API this will not be required by\ndocumentation either.",
    "sha": "1893467784deb6cd8a493997e8bac933cc2e4af9",
    "files": [
        {
            "sha": "f24df93bf4f581cdfeea171e417182992c1521cf",
            "filename": "django/db/backends/mysql/base.py",
            "status": "modified",
            "additions": 45,
            "deletions": 37,
            "changes": 82,
            "blob_url": "https://github.com/django/django/blob/1893467784deb6cd8a493997e8bac933cc2e4af9/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/1893467784deb6cd8a493997e8bac933cc2e4af9/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py?ref=1893467784deb6cd8a493997e8bac933cc2e4af9",
            "patch": "@@ -372,47 +372,56 @@ def _valid_connection(self):\n                 self.connection.ping()\n                 return True\n             except DatabaseError:\n-                self.connection.close()\n-                self.connection = None\n+                self.close()\n         return False\n \n+    def get_connection_params(self):\n+        kwargs = {\n+            'conv': django_conversions,\n+            'charset': 'utf8',\n+            'use_unicode': True,\n+        }\n+        settings_dict = self.settings_dict\n+        if settings_dict['USER']:\n+            kwargs['user'] = settings_dict['USER']\n+        if settings_dict['NAME']:\n+            kwargs['db'] = settings_dict['NAME']\n+        if settings_dict['PASSWORD']:\n+            kwargs['passwd'] = force_str(settings_dict['PASSWORD'])\n+        if settings_dict['HOST'].startswith('/'):\n+            kwargs['unix_socket'] = settings_dict['HOST']\n+        elif settings_dict['HOST']:\n+            kwargs['host'] = settings_dict['HOST']\n+        if settings_dict['PORT']:\n+            kwargs['port'] = int(settings_dict['PORT'])\n+        # We need the number of potentially affected rows after an\n+        # \"UPDATE\", not the number of changed rows.\n+        kwargs['client_flag'] = CLIENT.FOUND_ROWS\n+        kwargs.update(settings_dict['OPTIONS'])\n+        return kwargs\n+\n+    def get_new_connection(self, conn_params):\n+        conn = Database.connect(**conn_params)\n+        conn.encoders[SafeText] = conn.encoders[six.text_type]\n+        conn.encoders[SafeBytes] = conn.encoders[bytes]\n+        return conn\n+\n+    def init_connection_state(self):\n+        cursor = self.connection.cursor()\n+        # SQL_AUTO_IS_NULL in MySQL controls whether an AUTO_INCREMENT column\n+        # on a recently-inserted row will return when the field is tested for\n+        # NULL.  Disabling this value brings this aspect of MySQL in line with\n+        # SQL standards.\n+        cursor.execute('SET SQL_AUTO_IS_NULL = 0')\n+        cursor.close()\n+\n     def _cursor(self):\n-        new_connection = False\n         if not self._valid_connection():\n-            new_connection = True\n-            kwargs = {\n-                'conv': django_conversions,\n-                'charset': 'utf8',\n-                'use_unicode': True,\n-            }\n-            settings_dict = self.settings_dict\n-            if settings_dict['USER']:\n-                kwargs['user'] = settings_dict['USER']\n-            if settings_dict['NAME']:\n-                kwargs['db'] = settings_dict['NAME']\n-            if settings_dict['PASSWORD']:\n-                kwargs['passwd'] = force_str(settings_dict['PASSWORD'])\n-            if settings_dict['HOST'].startswith('/'):\n-                kwargs['unix_socket'] = settings_dict['HOST']\n-            elif settings_dict['HOST']:\n-                kwargs['host'] = settings_dict['HOST']\n-            if settings_dict['PORT']:\n-                kwargs['port'] = int(settings_dict['PORT'])\n-            # We need the number of potentially affected rows after an\n-            # \"UPDATE\", not the number of changed rows.\n-            kwargs['client_flag'] = CLIENT.FOUND_ROWS\n-            kwargs.update(settings_dict['OPTIONS'])\n-            self.connection = Database.connect(**kwargs)\n-            self.connection.encoders[SafeText] = self.connection.encoders[six.text_type]\n-            self.connection.encoders[SafeBytes] = self.connection.encoders[bytes]\n+            conn_params = self.get_connection_params()\n+            self.connection = self.get_new_connection(conn_params)\n+            self.init_connection_state()\n             connection_created.send(sender=self.__class__, connection=self)\n         cursor = self.connection.cursor()\n-        if new_connection:\n-            # SQL_AUTO_IS_NULL in MySQL controls whether an AUTO_INCREMENT column\n-            # on a recently-inserted row will return when the field is tested for\n-            # NULL.  Disabling this value brings this aspect of MySQL in line with\n-            # SQL standards.\n-            cursor.execute('SET SQL_AUTO_IS_NULL = 0')\n         return CursorWrapper(cursor)\n \n     def _rollback(self):\n@@ -433,8 +442,7 @@ def mysql_version(self):\n             server_info = self.connection.get_server_info()\n             if new_connection:\n                 # Make sure we close the connection\n-                self.connection.close()\n-                self.connection = None\n+                self.close()\n             m = server_version_re.match(server_info)\n             if not m:\n                 raise Exception('Unable to determine MySQL version from version string %r' % server_info)"
        },
        {
            "sha": "c6f072df3b73e55fe95dd930f91dc2d931c50657",
            "filename": "django/db/backends/oracle/base.py",
            "status": "modified",
            "additions": 69,
            "deletions": 57,
            "changes": 126,
            "blob_url": "https://github.com/django/django/blob/1893467784deb6cd8a493997e8bac933cc2e4af9/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/1893467784deb6cd8a493997e8bac933cc2e4af9/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Foracle%2Fbase.py?ref=1893467784deb6cd8a493997e8bac933cc2e4af9",
            "patch": "@@ -489,66 +489,78 @@ def _connect_string(self):\n         return \"%s/%s@%s\" % (settings_dict['USER'],\n                              settings_dict['PASSWORD'], dsn)\n \n+    def create_cursor(self, conn):\n+        return FormatStylePlaceholderCursor(conn)\n+\n+    def get_connection_params(self):\n+        conn_params = self.settings_dict['OPTIONS'].copy()\n+        if 'use_returning_into' in conn_params:\n+            del conn_params['use_returning_into']\n+        return conn_params\n+\n+    def get_new_connection(self, conn_params):\n+        conn_string = convert_unicode(self._connect_string())\n+        return Database.connect(conn_string, **conn_params)\n+\n+    def init_connection_state(self):\n+        cursor = self.create_cursor(self.connection)\n+        # Set the territory first. The territory overrides NLS_DATE_FORMAT\n+        # and NLS_TIMESTAMP_FORMAT to the territory default. When all of\n+        # these are set in single statement it isn't clear what is supposed\n+        # to happen.\n+        cursor.execute(\"ALTER SESSION SET NLS_TERRITORY = 'AMERICA'\")\n+        # Set oracle date to ansi date format.  This only needs to execute\n+        # once when we create a new connection. We also set the Territory\n+        # to 'AMERICA' which forces Sunday to evaluate to a '1' in\n+        # TO_CHAR().\n+        cursor.execute(\n+            \"ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS'\"\n+            \" NLS_TIMESTAMP_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF'\"\n+            + (\" TIME_ZONE = 'UTC'\" if settings.USE_TZ else ''))\n+        cursor.close()\n+        if 'operators' not in self.__dict__:\n+            # Ticket #14149: Check whether our LIKE implementation will\n+            # work for this connection or we need to fall back on LIKEC.\n+            # This check is performed only once per DatabaseWrapper\n+            # instance per thread, since subsequent connections will use\n+            # the same settings.\n+            cursor = self.create_cursor(self.connection)\n+            try:\n+                cursor.execute(\"SELECT 1 FROM DUAL WHERE DUMMY %s\"\n+                               % self._standard_operators['contains'],\n+                               ['X'])\n+            except utils.DatabaseError:\n+                self.operators = self._likec_operators\n+            else:\n+                self.operators = self._standard_operators\n+            cursor.close()\n+\n+        try:\n+            self.oracle_version = int(self.connection.version.split('.')[0])\n+            # There's no way for the DatabaseOperations class to know the\n+            # currently active Oracle version, so we do some setups here.\n+            # TODO: Multi-db support will need a better solution (a way to\n+            # communicate the current version).\n+            if self.oracle_version <= 9:\n+                self.ops.regex_lookup = self.ops.regex_lookup_9\n+            else:\n+                self.ops.regex_lookup = self.ops.regex_lookup_10\n+        except ValueError:\n+            pass\n+        try:\n+            self.connection.stmtcachesize = 20\n+        except:\n+            # Django docs specify cx_Oracle version 4.3.1 or higher, but\n+            # stmtcachesize is available only in 4.3.2 and up.\n+            pass\n+\n     def _cursor(self):\n-        cursor = None\n         if not self._valid_connection():\n-            conn_string = convert_unicode(self._connect_string())\n-            conn_params = self.settings_dict['OPTIONS'].copy()\n-            if 'use_returning_into' in conn_params:\n-                del conn_params['use_returning_into']\n-            self.connection = Database.connect(conn_string, **conn_params)\n-            cursor = FormatStylePlaceholderCursor(self.connection)\n-            # Set the territory first. The territory overrides NLS_DATE_FORMAT\n-            # and NLS_TIMESTAMP_FORMAT to the territory default. When all of\n-            # these are set in single statement it isn't clear what is supposed\n-            # to happen.\n-            cursor.execute(\"ALTER SESSION SET NLS_TERRITORY = 'AMERICA'\")\n-            # Set oracle date to ansi date format.  This only needs to execute\n-            # once when we create a new connection. We also set the Territory\n-            # to 'AMERICA' which forces Sunday to evaluate to a '1' in\n-            # TO_CHAR().\n-            cursor.execute(\n-                \"ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS'\"\n-                \" NLS_TIMESTAMP_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF'\"\n-                + (\" TIME_ZONE = 'UTC'\" if settings.USE_TZ else ''))\n-\n-            if 'operators' not in self.__dict__:\n-                # Ticket #14149: Check whether our LIKE implementation will\n-                # work for this connection or we need to fall back on LIKEC.\n-                # This check is performed only once per DatabaseWrapper\n-                # instance per thread, since subsequent connections will use\n-                # the same settings.\n-                try:\n-                    cursor.execute(\"SELECT 1 FROM DUAL WHERE DUMMY %s\"\n-                                   % self._standard_operators['contains'],\n-                                   ['X'])\n-                except utils.DatabaseError:\n-                    self.operators = self._likec_operators\n-                else:\n-                    self.operators = self._standard_operators\n-\n-            try:\n-                self.oracle_version = int(self.connection.version.split('.')[0])\n-                # There's no way for the DatabaseOperations class to know the\n-                # currently active Oracle version, so we do some setups here.\n-                # TODO: Multi-db support will need a better solution (a way to\n-                # communicate the current version).\n-                if self.oracle_version <= 9:\n-                    self.ops.regex_lookup = self.ops.regex_lookup_9\n-                else:\n-                    self.ops.regex_lookup = self.ops.regex_lookup_10\n-            except ValueError:\n-                pass\n-            try:\n-                self.connection.stmtcachesize = 20\n-            except:\n-                # Django docs specify cx_Oracle version 4.3.1 or higher, but\n-                # stmtcachesize is available only in 4.3.2 and up.\n-                pass\n+            conn_params = self.get_connection_params()\n+            self.connection = self.get_new_connection(conn_params)\n+            self.init_connection_state()\n             connection_created.send(sender=self.__class__, connection=self)\n-        if not cursor:\n-            cursor = FormatStylePlaceholderCursor(self.connection)\n-        return cursor\n+        return self.create_cursor(self.connection)\n \n     # Oracle doesn't support savepoint commits.  Ignore them.\n     def _savepoint_commit(self, sid):"
        },
        {
            "sha": "013aaaa91ed0f42ed5ad25ab50b1f156e92d31d3",
            "filename": "django/db/backends/postgresql_psycopg2/base.py",
            "status": "modified",
            "additions": 51,
            "deletions": 40,
            "changes": 91,
            "blob_url": "https://github.com/django/django/blob/1893467784deb6cd8a493997e8bac933cc2e4af9/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/1893467784deb6cd8a493997e8bac933cc2e4af9/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fpostgresql_psycopg2%2Fbase.py?ref=1893467784deb6cd8a493997e8bac933cc2e4af9",
            "patch": "@@ -156,48 +156,59 @@ def _get_pg_version(self):\n         return self._pg_version\n     pg_version = property(_get_pg_version)\n \n-    def _cursor(self):\n+    def get_connection_params(self):\n+        settings_dict = self.settings_dict\n+        if not settings_dict['NAME']:\n+            from django.core.exceptions import ImproperlyConfigured\n+            raise ImproperlyConfigured(\n+                \"settings.DATABASES is improperly configured. \"\n+                \"Please supply the NAME value.\")\n+        conn_params = {\n+            'database': settings_dict['NAME'],\n+        }\n+        conn_params.update(settings_dict['OPTIONS'])\n+        if 'autocommit' in conn_params:\n+            del conn_params['autocommit']\n+        if settings_dict['USER']:\n+            conn_params['user'] = settings_dict['USER']\n+        if settings_dict['PASSWORD']:\n+            conn_params['password'] = force_str(settings_dict['PASSWORD'])\n+        if settings_dict['HOST']:\n+            conn_params['host'] = settings_dict['HOST']\n+        if settings_dict['PORT']:\n+            conn_params['port'] = settings_dict['PORT']\n+        return conn_params\n+\n+    def get_new_connection(self, conn_params):\n+        return Database.connect(**conn_params)\n+\n+    def init_connection_state(self):\n         settings_dict = self.settings_dict\n+        self.connection.set_client_encoding('UTF8')\n+        tz = 'UTC' if settings.USE_TZ else settings_dict.get('TIME_ZONE')\n+        if tz:\n+            try:\n+                get_parameter_status = self.connection.get_parameter_status\n+            except AttributeError:\n+                # psycopg2 < 2.0.12 doesn't have get_parameter_status\n+                conn_tz = None\n+            else:\n+                conn_tz = get_parameter_status('TimeZone')\n+\n+            if conn_tz != tz:\n+                # Set the time zone in autocommit mode (see #17062)\n+                self.connection.set_isolation_level(\n+                        psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)\n+                self.connection.cursor().execute(\n+                        self.ops.set_time_zone_sql(), [tz])\n+        self.connection.set_isolation_level(self.isolation_level)\n+        self._get_pg_version()\n+\n+    def _cursor(self):\n         if self.connection is None:\n-            if not settings_dict['NAME']:\n-                from django.core.exceptions import ImproperlyConfigured\n-                raise ImproperlyConfigured(\n-                    \"settings.DATABASES is improperly configured. \"\n-                    \"Please supply the NAME value.\")\n-            conn_params = {\n-                'database': settings_dict['NAME'],\n-            }\n-            conn_params.update(settings_dict['OPTIONS'])\n-            if 'autocommit' in conn_params:\n-                del conn_params['autocommit']\n-            if settings_dict['USER']:\n-                conn_params['user'] = settings_dict['USER']\n-            if settings_dict['PASSWORD']:\n-                conn_params['password'] = force_str(settings_dict['PASSWORD'])\n-            if settings_dict['HOST']:\n-                conn_params['host'] = settings_dict['HOST']\n-            if settings_dict['PORT']:\n-                conn_params['port'] = settings_dict['PORT']\n-            self.connection = Database.connect(**conn_params)\n-            self.connection.set_client_encoding('UTF8')\n-            tz = 'UTC' if settings.USE_TZ else settings_dict.get('TIME_ZONE')\n-            if tz:\n-                try:\n-                    get_parameter_status = self.connection.get_parameter_status\n-                except AttributeError:\n-                    # psycopg2 < 2.0.12 doesn't have get_parameter_status\n-                    conn_tz = None\n-                else:\n-                    conn_tz = get_parameter_status('TimeZone')\n-\n-                if conn_tz != tz:\n-                    # Set the time zone in autocommit mode (see #17062)\n-                    self.connection.set_isolation_level(\n-                            psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)\n-                    self.connection.cursor().execute(\n-                            self.ops.set_time_zone_sql(), [tz])\n-            self.connection.set_isolation_level(self.isolation_level)\n-            self._get_pg_version()\n+            conn_params = self.get_connection_params()\n+            self.connection = self.get_new_connection(conn_params)\n+            self.init_connection_state()\n             connection_created.send(sender=self.__class__, connection=self)\n         cursor = self.connection.cursor()\n         cursor.tzinfo_factory = utc_tzinfo_factory if settings.USE_TZ else None"
        },
        {
            "sha": "1fcc222c80baa045106f62cfacf5b7c24d8c24d3",
            "filename": "django/db/backends/sqlite3/base.py",
            "status": "modified",
            "additions": 18,
            "deletions": 6,
            "changes": 24,
            "blob_url": "https://github.com/django/django/blob/1893467784deb6cd8a493997e8bac933cc2e4af9/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/1893467784deb6cd8a493997e8bac933cc2e4af9/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py?ref=1893467784deb6cd8a493997e8bac933cc2e4af9",
            "patch": "@@ -266,7 +266,7 @@ def __init__(self, *args, **kwargs):\n         self.introspection = DatabaseIntrospection(self)\n         self.validation = BaseDatabaseValidation(self)\n \n-    def _sqlite_create_connection(self):\n+    def get_connection_params(self):\n         settings_dict = self.settings_dict\n         if not settings_dict['NAME']:\n             from django.core.exceptions import ImproperlyConfigured\n@@ -293,12 +293,24 @@ def _sqlite_create_connection(self):\n                 RuntimeWarning\n             )\n         kwargs.update({'check_same_thread': False})\n-        self.connection = Database.connect(**kwargs)\n+        return kwargs\n+\n+    def get_new_connection(self, conn_params):\n+        conn = Database.connect(**conn_params)\n         # Register extract, date_trunc, and regexp functions.\n-        self.connection.create_function(\"django_extract\", 2, _sqlite_extract)\n-        self.connection.create_function(\"django_date_trunc\", 2, _sqlite_date_trunc)\n-        self.connection.create_function(\"regexp\", 2, _sqlite_regexp)\n-        self.connection.create_function(\"django_format_dtdelta\", 5, _sqlite_format_dtdelta)\n+        conn.create_function(\"django_extract\", 2, _sqlite_extract)\n+        conn.create_function(\"django_date_trunc\", 2, _sqlite_date_trunc)\n+        conn.create_function(\"regexp\", 2, _sqlite_regexp)\n+        conn.create_function(\"django_format_dtdelta\", 5, _sqlite_format_dtdelta)\n+        return conn\n+\n+    def init_connection_state(self):\n+        pass\n+\n+    def _sqlite_create_connection(self):\n+        conn_params = self.get_connection_params()\n+        self.connection = self.get_new_connection(conn_params)\n+        self.init_connection_state()\n         connection_created.send(sender=self.__class__, connection=self)\n \n     def _cursor(self):"
        }
    ],
    "stats": {
        "total": 323,
        "additions": 183,
        "deletions": 140
    }
}