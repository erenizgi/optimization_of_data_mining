{
    "author": "aaugustin",
    "message": "Fixed #17755 -- Ensured datetime objects that bypass the model layer (for instance, in raw SQL queries) are converted to UTC before sending them to the database when time zone support is enabled. Thanks Anssi for the report.\n\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@17596 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "ce88b57b9aca0325e5b90944019f602a92f93475",
    "files": [
        {
            "sha": "cefd86f330fb85ac8194b85af8998fabb95dc1f6",
            "filename": "django/db/backends/mysql/base.py",
            "status": "modified",
            "additions": 25,
            "deletions": 10,
            "changes": 35,
            "blob_url": "https://github.com/django/django/blob/ce88b57b9aca0325e5b90944019f602a92f93475/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/ce88b57b9aca0325e5b90944019f602a92f93475/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fmysql%2Fbase.py?ref=ce88b57b9aca0325e5b90944019f602a92f93475",
            "patch": "@@ -4,6 +4,7 @@\n Requires MySQLdb: http://sourceforge.net/projects/mysql-python\n \"\"\"\n \n+import datetime\n import re\n import sys\n \n@@ -24,6 +25,7 @@\n \n from MySQLdb.converters import conversions\n from MySQLdb.constants import FIELD_TYPE, CLIENT\n+from _mysql import string_literal\n \n from django.db import utils\n from django.db.backends import *\n@@ -33,7 +35,7 @@\n from django.db.backends.mysql.introspection import DatabaseIntrospection\n from django.db.backends.mysql.validation import DatabaseValidation\n from django.utils.safestring import SafeString, SafeUnicode\n-from django.utils.timezone import is_aware, is_naive, utc\n+from django.utils import timezone\n \n # Raise exceptions for database warnings if DEBUG is on\n from django.conf import settings\n@@ -45,15 +47,27 @@\n IntegrityError = Database.IntegrityError\n \n # It's impossible to import datetime_or_None directly from MySQLdb.times\n-datetime_or_None = conversions[FIELD_TYPE.DATETIME]\n+parse_datetime = conversions[FIELD_TYPE.DATETIME]\n \n-def datetime_or_None_with_timezone_support(value):\n-    dt = datetime_or_None(value)\n+def parse_datetime_with_timezone_support(value):\n+    dt = parse_datetime(value)\n     # Confirm that dt is naive before overwriting its tzinfo.\n-    if dt is not None and settings.USE_TZ and is_naive(dt):\n-        dt = dt.replace(tzinfo=utc)\n+    if dt is not None and settings.USE_TZ and timezone.is_naive(dt):\n+        dt = dt.replace(tzinfo=timezone.utc)\n     return dt\n \n+def adapt_datetime_with_timezone_support(value, conv):\n+    # Equivalent to DateTimeField.get_db_prep_value. Used only by raw SQL.\n+    if settings.USE_TZ:\n+        if timezone.is_naive(value):\n+            warnings.warn(u\"SQLite received a naive datetime (%s)\"\n+                          u\" while time zone support is active.\" % value,\n+                          RuntimeWarning)\n+            default_timezone = timezone.get_default_timezone()\n+            value = timezone.make_aware(value, default_timezone)\n+        value = value.astimezone(timezone.utc).replace(tzinfo=None)\n+    return string_literal(value.strftime(\"%Y-%m-%d %H:%M:%S\"), conv)\n+\n # MySQLdb-1.2.1 returns TIME columns as timedelta -- they are more like\n # timedelta in terms of actual behavior as they are signed and include days --\n # and Django expects time, so we still need to override that. We also need to\n@@ -66,7 +80,8 @@ def datetime_or_None_with_timezone_support(value):\n     FIELD_TYPE.TIME: util.typecast_time,\n     FIELD_TYPE.DECIMAL: util.typecast_decimal,\n     FIELD_TYPE.NEWDECIMAL: util.typecast_decimal,\n-    FIELD_TYPE.DATETIME: datetime_or_None_with_timezone_support,\n+    FIELD_TYPE.DATETIME: parse_datetime_with_timezone_support,\n+    datetime.datetime: adapt_datetime_with_timezone_support,\n })\n \n # This should match the numerical portion of the version numbers (we can treat\n@@ -268,9 +283,9 @@ def value_to_db_datetime(self, value):\n             return None\n \n         # MySQL doesn't support tz-aware datetimes\n-        if is_aware(value):\n+        if timezone.is_aware(value):\n             if settings.USE_TZ:\n-                value = value.astimezone(utc).replace(tzinfo=None)\n+                value = value.astimezone(timezone.utc).replace(tzinfo=None)\n             else:\n                 raise ValueError(\"MySQL backend does not support timezone-aware datetimes when USE_TZ is False.\")\n \n@@ -282,7 +297,7 @@ def value_to_db_time(self, value):\n             return None\n \n         # MySQL doesn't support tz-aware times\n-        if is_aware(value):\n+        if timezone.is_aware(value):\n             raise ValueError(\"MySQL backend does not support timezone-aware times.\")\n \n         # MySQL doesn't support microseconds"
        },
        {
            "sha": "6bc6e1dd9d95a6edea177659f2ac92d798b60db0",
            "filename": "django/db/backends/oracle/base.py",
            "status": "modified",
            "additions": 17,
            "deletions": 6,
            "changes": 23,
            "blob_url": "https://github.com/django/django/blob/ce88b57b9aca0325e5b90944019f602a92f93475/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/ce88b57b9aca0325e5b90944019f602a92f93475/django%2Fdb%2Fbackends%2Foracle%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Foracle%2Fbase.py?ref=ce88b57b9aca0325e5b90944019f602a92f93475",
            "patch": "@@ -52,7 +52,7 @@ def _setup_environment(environ):\n from django.db.backends.oracle.creation import DatabaseCreation\n from django.db.backends.oracle.introspection import DatabaseIntrospection\n from django.utils.encoding import smart_str, force_unicode\n-from django.utils.timezone import is_aware, is_naive, utc\n+from django.utils import timezone\n \n DatabaseError = Database.DatabaseError\n IntegrityError = Database.IntegrityError\n@@ -339,9 +339,9 @@ def value_to_db_datetime(self, value):\n             return None\n \n         # Oracle doesn't support tz-aware datetimes\n-        if is_aware(value):\n+        if timezone.is_aware(value):\n             if settings.USE_TZ:\n-                value = value.astimezone(utc).replace(tzinfo=None)\n+                value = value.astimezone(timezone.utc).replace(tzinfo=None)\n             else:\n                 raise ValueError(\"Oracle backend does not support timezone-aware datetimes when USE_TZ is False.\")\n \n@@ -355,7 +355,7 @@ def value_to_db_time(self, value):\n             return datetime.datetime.strptime(value, '%H:%M:%S')\n \n         # Oracle doesn't support tz-aware times\n-        if is_aware(value):\n+        if timezone.is_aware(value):\n             raise ValueError(\"Oracle backend does not support timezone-aware times.\")\n \n         return datetime.datetime(1900, 1, 1, value.hour, value.minute,\n@@ -561,6 +561,17 @@ class OracleParam(object):\n     \"\"\"\n \n     def __init__(self, param, cursor, strings_only=False):\n+        # With raw SQL queries, datetimes can reach this function\n+        # without being converted by DateTimeField.get_db_prep_value.\n+        if settings.USE_TZ and isinstance(param, datetime.datetime):\n+            if timezone.is_naive(param):\n+                warnings.warn(u\"Oracle received a naive datetime (%s)\"\n+                              u\" while time zone support is active.\" % param,\n+                              RuntimeWarning)\n+                default_timezone = timezone.get_default_timezone()\n+                param = timezone.make_aware(param, default_timezone)\n+            param = param.astimezone(timezone.utc).replace(tzinfo=None)\n+\n         if hasattr(param, 'bind_parameter'):\n             self.smart_str = param.bind_parameter(cursor)\n         else:\n@@ -783,8 +794,8 @@ def _rowfactory(row, cursor):\n         # of \"dates\" queries, which are returned as DATETIME.\n         elif desc[1] in (Database.TIMESTAMP, Database.DATETIME):\n             # Confirm that dt is naive before overwriting its tzinfo.\n-            if settings.USE_TZ and value is not None and is_naive(value):\n-                value = value.replace(tzinfo=utc)\n+            if settings.USE_TZ and value is not None and timezone.is_naive(value):\n+                value = value.replace(tzinfo=timezone.utc)\n         elif desc[1] in (Database.STRING, Database.FIXED_CHAR,\n                          Database.LONG_STRING):\n             value = to_unicode(value)"
        },
        {
            "sha": "0b19442e78ea68c0811070c2d5719140fb03e36d",
            "filename": "django/db/backends/sqlite3/base.py",
            "status": "modified",
            "additions": 20,
            "deletions": 7,
            "changes": 27,
            "blob_url": "https://github.com/django/django/blob/ce88b57b9aca0325e5b90944019f602a92f93475/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/ce88b57b9aca0325e5b90944019f602a92f93475/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2Fsqlite3%2Fbase.py?ref=ce88b57b9aca0325e5b90944019f602a92f93475",
            "patch": "@@ -19,7 +19,7 @@\n from django.db.backends.sqlite3.introspection import DatabaseIntrospection\n from django.utils.dateparse import parse_date, parse_datetime, parse_time\n from django.utils.safestring import SafeString\n-from django.utils.timezone import is_aware, is_naive, utc\n+from django.utils import timezone\n \n try:\n     try:\n@@ -37,24 +37,37 @@\n def parse_datetime_with_timezone_support(value):\n     dt = parse_datetime(value)\n     # Confirm that dt is naive before overwriting its tzinfo.\n-    if dt is not None and settings.USE_TZ and is_naive(dt):\n-        dt = dt.replace(tzinfo=utc)\n+    if dt is not None and settings.USE_TZ and timezone.is_naive(dt):\n+        dt = dt.replace(tzinfo=timezone.utc)\n     return dt\n \n+def adapt_datetime_with_timezone_support(value):\n+    # Equivalent to DateTimeField.get_db_prep_value. Used only by raw SQL.\n+    if settings.USE_TZ:\n+        if timezone.is_naive(value):\n+            warnings.warn(u\"SQLite received a naive datetime (%s)\"\n+                          u\" while time zone support is active.\" % value,\n+                          RuntimeWarning)\n+            default_timezone = timezone.get_default_timezone()\n+            value = timezone.make_aware(value, default_timezone)\n+        value = value.astimezone(timezone.utc).replace(tzinfo=None)\n+    return value.isoformat(\" \")\n+\n Database.register_converter(\"bool\", lambda s: str(s) == '1')\n Database.register_converter(\"time\", parse_time)\n Database.register_converter(\"date\", parse_date)\n Database.register_converter(\"datetime\", parse_datetime_with_timezone_support)\n Database.register_converter(\"timestamp\", parse_datetime_with_timezone_support)\n Database.register_converter(\"TIMESTAMP\", parse_datetime_with_timezone_support)\n Database.register_converter(\"decimal\", util.typecast_decimal)\n+Database.register_adapter(datetime.datetime, adapt_datetime_with_timezone_support)\n Database.register_adapter(decimal.Decimal, util.rev_typecast_decimal)\n if Database.version_info >= (2, 4, 1):\n     # Starting in 2.4.1, the str type is not accepted anymore, therefore,\n     # we convert all str objects to Unicode\n     # As registering a adapter for a primitive type causes a small\n     # slow-down, this adapter is only registered for sqlite3 versions\n-    # needing it.\n+    # needing it (Python 2.6 and up).\n     Database.register_adapter(str, lambda s: s.decode('utf-8'))\n     Database.register_adapter(SafeString, lambda s: s.decode('utf-8'))\n \n@@ -147,9 +160,9 @@ def value_to_db_datetime(self, value):\n             return None\n \n         # SQLite doesn't support tz-aware datetimes\n-        if is_aware(value):\n+        if timezone.is_aware(value):\n             if settings.USE_TZ:\n-                value = value.astimezone(utc).replace(tzinfo=None)\n+                value = value.astimezone(timezone.utc).replace(tzinfo=None)\n             else:\n                 raise ValueError(\"SQLite backend does not support timezone-aware datetimes when USE_TZ is False.\")\n \n@@ -160,7 +173,7 @@ def value_to_db_time(self, value):\n             return None\n \n         # SQLite doesn't support tz-aware datetimes\n-        if is_aware(value):\n+        if timezone.is_aware(value):\n             raise ValueError(\"SQLite backend does not support timezone-aware times.\")\n \n         return unicode(value)"
        },
        {
            "sha": "a8d2c0c332b127bb38992bd45fce3c58f5fffe49",
            "filename": "tests/modeltests/timezones/tests.py",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/django/django/blob/ce88b57b9aca0325e5b90944019f602a92f93475/tests%2Fmodeltests%2Ftimezones%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/ce88b57b9aca0325e5b90944019f602a92f93475/tests%2Fmodeltests%2Ftimezones%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fmodeltests%2Ftimezones%2Ftests.py?ref=ce88b57b9aca0325e5b90944019f602a92f93475",
            "patch": "@@ -263,6 +263,15 @@ def test_query_dates(self):\n         self.assertQuerysetEqual(Event.objects.dates('dt', 'day'),\n                 [datetime.datetime(2011, 1, 1)], transform=lambda d: d)\n \n+    def test_raw_sql(self):\n+        # Regression test for #17755\n+        dt = datetime.datetime(2011, 9, 1, 13, 20, 30)\n+        event = Event.objects.create(dt=dt)\n+        self.assertQuerysetEqual(\n+                Event.objects.raw('SELECT * FROM timezones_event WHERE dt = %s', [dt]),\n+                [event],\n+                transform=lambda d: d)\n+\n LegacyDatabaseTests = override_settings(USE_TZ=False)(LegacyDatabaseTests)\n \n \n@@ -473,6 +482,15 @@ def test_query_dates(self):\n                  datetime.datetime(2011, 1, 1, tzinfo=UTC)],\n                 transform=lambda d: d)\n \n+    def test_raw_sql(self):\n+        # Regression test for #17755\n+        dt = datetime.datetime(2011, 9, 1, 13, 20, 30, tzinfo=EAT)\n+        event = Event.objects.create(dt=dt)\n+        self.assertQuerysetEqual(\n+                Event.objects.raw('SELECT * FROM timezones_event WHERE dt = %s', [dt]),\n+                [event],\n+                transform=lambda d: d)\n+\n     def test_null_datetime(self):\n         # Regression for #17294\n         e = MaybeEvent.objects.create()"
        }
    ],
    "stats": {
        "total": 103,
        "additions": 80,
        "deletions": 23
    }
}