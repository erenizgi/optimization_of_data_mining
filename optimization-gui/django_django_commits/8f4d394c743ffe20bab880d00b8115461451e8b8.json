{
    "author": "jezdez",
    "message": "Fixed #14903 -- Removed much of the code in django.core.servers.basehttp that was previously copy-pasted from the wsgiref module which was added to Python 2.5. Many thanks to maxbublis and aaugustin.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16288 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "8f4d394c743ffe20bab880d00b8115461451e8b8",
    "files": [
        {
            "sha": "b51abcf450f751f7d82aa17fbe3e99d7c0a19c47",
            "filename": "django/core/servers/basehttp.py",
            "status": "modified",
            "additions": 19,
            "deletions": 503,
            "changes": 522,
            "blob_url": "https://github.com/django/django/blob/8f4d394c743ffe20bab880d00b8115461451e8b8/django%2Fcore%2Fservers%2Fbasehttp.py",
            "raw_url": "https://github.com/django/django/raw/8f4d394c743ffe20bab880d00b8115461451e8b8/django%2Fcore%2Fservers%2Fbasehttp.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fcore%2Fservers%2Fbasehttp.py?ref=8f4d394c743ffe20bab880d00b8115461451e8b8",
            "patch": "@@ -1,393 +1,37 @@\n \"\"\"\n-BaseHTTPServer that implements the Python WSGI protocol (PEP 333, rev 1.21).\n+HTTP server that implements the Python WSGI protocol (PEP 333, rev 1.21).\n \n-Adapted from wsgiref.simple_server: http://svn.eby-sarna.com/wsgiref/\n+Based on wsgiref.simple_server which is part of the standard library since 2.5.\n \n This is a simple server for use in testing or debugging Django apps. It hasn't\n-been reviewed for security issues. Don't use it for production use.\n+been reviewed for security issues. DON'T USE IT FOR PRODUCTION USE!\n \"\"\"\n \n-from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer\n import os\n-import re\n import socket\n import sys\n+import traceback\n import urllib\n-import warnings\n+from wsgiref import simple_server\n+from wsgiref.util import FileWrapper   # for backwards compatibility\n \n+import django\n+from django.core.exceptions import ImproperlyConfigured\n from django.core.management.color import color_style\n-from django.utils.http import http_date\n from django.utils._os import safe_join\n from django.views import static\n \n from django.contrib.staticfiles import handlers\n \n-__version__ = \"0.1\"\n-__all__ = ['WSGIServer','WSGIRequestHandler']\n+__all__ = ['WSGIServer', 'WSGIRequestHandler']\n \n-server_version = \"WSGIServer/\" + __version__\n-sys_version = \"Python/\" + sys.version.split()[0]\n-software_version = server_version + ' ' + sys_version\n \n class WSGIServerException(Exception):\n     pass\n \n-class FileWrapper(object):\n-    \"\"\"Wrapper to convert file-like objects to iterables\"\"\"\n \n-    def __init__(self, filelike, blksize=8192):\n-        self.filelike = filelike\n-        self.blksize = blksize\n-        if hasattr(filelike,'close'):\n-            self.close = filelike.close\n-\n-    def __getitem__(self,key):\n-        data = self.filelike.read(self.blksize)\n-        if data:\n-            return data\n-        raise IndexError\n-\n-    def __iter__(self):\n-        return self\n-\n-    def next(self):\n-        data = self.filelike.read(self.blksize)\n-        if data:\n-            return data\n-        raise StopIteration\n-\n-# Regular expression that matches `special' characters in parameters, the\n-# existence of which force quoting of the parameter value.\n-tspecials = re.compile(r'[ \\(\\)<>@,;:\\\\\"/\\[\\]\\?=]')\n-\n-def _formatparam(param, value=None, quote=1):\n-    \"\"\"Convenience function to format and return a key=value pair.\n-\n-    This will quote the value if needed or if quote is true.\n-    \"\"\"\n-    if value is not None and len(value) > 0:\n-        if quote or tspecials.search(value):\n-            value = value.replace('\\\\', '\\\\\\\\').replace('\"', r'\\\"')\n-            return '%s=\"%s\"' % (param, value)\n-        else:\n-            return '%s=%s' % (param, value)\n-    else:\n-        return param\n-\n-class Headers(object):\n-    \"\"\"Manage a collection of HTTP response headers\"\"\"\n-    def __init__(self,headers):\n-        if not isinstance(headers, list):\n-            raise TypeError(\"Headers must be a list of name/value tuples\")\n-        self._headers = headers\n-\n-    def __len__(self):\n-        \"\"\"Return the total number of headers, including duplicates.\"\"\"\n-        return len(self._headers)\n-\n-    def __setitem__(self, name, val):\n-        \"\"\"Set the value of a header.\"\"\"\n-        del self[name]\n-        self._headers.append((name, val))\n-\n-    def __delitem__(self,name):\n-        \"\"\"Delete all occurrences of a header, if present.\n-\n-        Does *not* raise an exception if the header is missing.\n-        \"\"\"\n-        name = name.lower()\n-        self._headers[:] = [kv for kv in self._headers if kv[0].lower()<>name]\n-\n-    def __getitem__(self,name):\n-        \"\"\"Get the first header value for 'name'\n-\n-        Return None if the header is missing instead of raising an exception.\n-\n-        Note that if the header appeared multiple times, the first exactly which\n-        occurrance gets returned is undefined.  Use getall() to get all\n-        the values matching a header field name.\n-        \"\"\"\n-        return self.get(name)\n-\n-    def has_key(self, name):\n-        \"\"\"Return true if the message contains the header.\"\"\"\n-        return self.get(name) is not None\n-\n-    __contains__ = has_key\n-\n-    def get_all(self, name):\n-        \"\"\"Return a list of all the values for the named field.\n-\n-        These will be sorted in the order they appeared in the original header\n-        list or were added to this instance, and may contain duplicates.  Any\n-        fields deleted and re-inserted are always appended to the header list.\n-        If no fields exist with the given name, returns an empty list.\n-        \"\"\"\n-        name = name.lower()\n-        return [kv[1] for kv in self._headers if kv[0].lower()==name]\n-\n-\n-    def get(self,name,default=None):\n-        \"\"\"Get the first header value for 'name', or return 'default'\"\"\"\n-        name = name.lower()\n-        for k,v in self._headers:\n-            if k.lower()==name:\n-                return v\n-        return default\n-\n-    def keys(self):\n-        \"\"\"Return a list of all the header field names.\n-\n-        These will be sorted in the order they appeared in the original header\n-        list, or were added to this instance, and may contain duplicates.\n-        Any fields deleted and re-inserted are always appended to the header\n-        list.\n-        \"\"\"\n-        return [k for k, v in self._headers]\n-\n-    def values(self):\n-        \"\"\"Return a list of all header values.\n-\n-        These will be sorted in the order they appeared in the original header\n-        list, or were added to this instance, and may contain duplicates.\n-        Any fields deleted and re-inserted are always appended to the header\n-        list.\n-        \"\"\"\n-        return [v for k, v in self._headers]\n-\n-    def items(self):\n-        \"\"\"Get all the header fields and values.\n-\n-        These will be sorted in the order they were in the original header\n-        list, or were added to this instance, and may contain duplicates.\n-        Any fields deleted and re-inserted are always appended to the header\n-        list.\n-        \"\"\"\n-        return self._headers[:]\n-\n-    def __repr__(self):\n-        return \"Headers(%s)\" % `self._headers`\n-\n-    def __str__(self):\n-        \"\"\"str() returns the formatted headers, complete with end line,\n-        suitable for direct HTTP transmission.\"\"\"\n-        return '\\r\\n'.join([\"%s: %s\" % kv for kv in self._headers]+['',''])\n-\n-    def setdefault(self,name,value):\n-        \"\"\"Return first matching header value for 'name', or 'value'\n-\n-        If there is no header named 'name', add a new header with name 'name'\n-        and value 'value'.\"\"\"\n-        result = self.get(name)\n-        if result is None:\n-            self._headers.append((name,value))\n-            return value\n-        else:\n-            return result\n-\n-    def add_header(self, _name, _value, **_params):\n-        \"\"\"Extended header setting.\n-\n-        _name is the header field to add.  keyword arguments can be used to set\n-        additional parameters for the header field, with underscores converted\n-        to dashes.  Normally the parameter will be added as key=\"value\" unless\n-        value is None, in which case only the key will be added.\n-\n-        Example:\n-\n-        h.add_header('content-disposition', 'attachment', filename='bud.gif')\n-\n-        Note that unlike the corresponding 'email.Message' method, this does\n-        *not* handle '(charset, language, value)' tuples: all values must be\n-        strings or None.\n-        \"\"\"\n-        parts = []\n-        if _value is not None:\n-            parts.append(_value)\n-        for k, v in _params.items():\n-            if v is None:\n-                parts.append(k.replace('_', '-'))\n-            else:\n-                parts.append(_formatparam(k.replace('_', '-'), v))\n-        self._headers.append((_name, \"; \".join(parts)))\n-\n-def guess_scheme(environ):\n-    \"\"\"Return a guess for whether 'wsgi.url_scheme' should be 'http' or 'https'\n-    \"\"\"\n-    if environ.get(\"HTTPS\") in ('yes','on','1'):\n-        return 'https'\n-    else:\n-        return 'http'\n-\n-_hop_headers = {\n-    'connection':1, 'keep-alive':1, 'proxy-authenticate':1,\n-    'proxy-authorization':1, 'te':1, 'trailers':1, 'transfer-encoding':1,\n-    'upgrade':1\n-}\n-\n-def is_hop_by_hop(header_name):\n-    \"\"\"Return true if 'header_name' is an HTTP/1.1 \"Hop-by-Hop\" header\"\"\"\n-    return header_name.lower() in _hop_headers\n-\n-class ServerHandler(object):\n-    \"\"\"Manage the invocation of a WSGI application\"\"\"\n-\n-    # Configuration parameters; can override per-subclass or per-instance\n-    wsgi_version = (1,0)\n-    wsgi_multithread = True\n-    wsgi_multiprocess = True\n-    wsgi_run_once = False\n-\n-    origin_server = True    # We are transmitting direct to client\n-    http_version  = \"1.0\"   # Version that should be used for response\n-    server_software = software_version\n-\n-    # os_environ is used to supply configuration from the OS environment:\n-    # by default it's a copy of 'os.environ' as of import time, but you can\n-    # override this in e.g. your __init__ method.\n-    os_environ = dict(os.environ.items())\n-\n-    # Collaborator classes\n-    wsgi_file_wrapper = FileWrapper     # set to None to disable\n-    headers_class = Headers             # must be a Headers-like class\n-\n-    # Error handling (also per-subclass or per-instance)\n-    traceback_limit = None  # Print entire traceback to self.get_stderr()\n+class ServerHandler(simple_server.ServerHandler, object):\n     error_status = \"500 INTERNAL SERVER ERROR\"\n-    error_headers = [('Content-Type','text/plain')]\n-\n-    # State variables (don't mess with these)\n-    status = result = None\n-    headers_sent = False\n-    headers = None\n-    bytes_sent = 0\n-\n-    def __init__(self, stdin, stdout, stderr, environ, multithread=True,\n-        multiprocess=False):\n-        self.stdin = stdin\n-        self.stdout = stdout\n-        self.stderr = stderr\n-        self.base_env = environ\n-        self.wsgi_multithread = multithread\n-        self.wsgi_multiprocess = multiprocess\n-\n-    def run(self, application):\n-        \"\"\"Invoke the application\"\"\"\n-        # Note to self: don't move the close()!  Asynchronous servers shouldn't\n-        # call close() from finish_response(), so if you close() anywhere but\n-        # the double-error branch here, you'll break asynchronous servers by\n-        # prematurely closing.  Async servers must return from 'run()' without\n-        # closing if there might still be output to iterate over.\n-        try:\n-            self.setup_environ()\n-            self.result = application(self.environ, self.start_response)\n-            self.finish_response()\n-        except:\n-            try:\n-                self.handle_error()\n-            except:\n-                # If we get an error handling an error, just give up already!\n-                self.close()\n-                raise   # ...and let the actual server figure it out.\n-\n-    def setup_environ(self):\n-        \"\"\"Set up the environment for one request\"\"\"\n-\n-        env = self.environ = self.os_environ.copy()\n-        self.add_cgi_vars()\n-\n-        env['wsgi.input']        = self.get_stdin()\n-        env['wsgi.errors']       = self.get_stderr()\n-        env['wsgi.version']      = self.wsgi_version\n-        env['wsgi.run_once']     = self.wsgi_run_once\n-        env['wsgi.url_scheme']   = self.get_scheme()\n-        env['wsgi.multithread']  = self.wsgi_multithread\n-        env['wsgi.multiprocess'] = self.wsgi_multiprocess\n-\n-        if self.wsgi_file_wrapper is not None:\n-            env['wsgi.file_wrapper'] = self.wsgi_file_wrapper\n-\n-        if self.origin_server and self.server_software:\n-            env.setdefault('SERVER_SOFTWARE',self.server_software)\n-\n-    def finish_response(self):\n-        \"\"\"\n-        Send any iterable data, then close self and the iterable\n-\n-        Subclasses intended for use in asynchronous servers will want to\n-        redefine this method, such that it sets up callbacks in the event loop\n-        to iterate over the data, and to call 'self.close()' once the response\n-        is finished.\n-        \"\"\"\n-        if not self.result_is_file() or not self.sendfile():\n-            for data in self.result:\n-                self.write(data)\n-            self.finish_content()\n-        self.close()\n-\n-    def get_scheme(self):\n-        \"\"\"Return the URL scheme being used\"\"\"\n-        return guess_scheme(self.environ)\n-\n-    def set_content_length(self):\n-        \"\"\"Compute Content-Length or switch to chunked encoding if possible\"\"\"\n-        try:\n-            blocks = len(self.result)\n-        except (TypeError, AttributeError, NotImplementedError):\n-            pass\n-        else:\n-            if blocks==1:\n-                self.headers['Content-Length'] = str(self.bytes_sent)\n-                return\n-        # XXX Try for chunked encoding if origin server and client is 1.1\n-\n-    def cleanup_headers(self):\n-        \"\"\"Make any necessary header changes or defaults\n-\n-        Subclasses can extend this to add other defaults.\n-        \"\"\"\n-        if 'Content-Length' not in self.headers:\n-            self.set_content_length()\n-\n-    def start_response(self, status, headers,exc_info=None):\n-        \"\"\"'start_response()' callable as specified by PEP 333\"\"\"\n-\n-        if exc_info:\n-            try:\n-                if self.headers_sent:\n-                    # Re-raise original exception if headers sent\n-                    raise exc_info[0], exc_info[1], exc_info[2]\n-            finally:\n-                exc_info = None        # avoid dangling circular ref\n-        elif self.headers is not None:\n-            raise AssertionError(\"Headers already set!\")\n-\n-        assert isinstance(status, str),\"Status must be a string\"\n-        assert len(status)>=4,\"Status must be at least 4 characters\"\n-        assert int(status[:3]),\"Status message must begin w/3-digit code\"\n-        assert status[3]==\" \", \"Status message must have a space after code\"\n-        if __debug__:\n-            for name,val in headers:\n-                assert isinstance(name, str),\"Header names must be strings\"\n-                assert isinstance(val, str),\"Header values must be strings\"\n-                assert not is_hop_by_hop(name),\"Hop-by-hop headers not allowed\"\n-        self.status = status\n-        self.headers = self.headers_class(headers)\n-        return self.write\n-\n-    def send_preamble(self):\n-        \"\"\"Transmit version/status/date/server, via self._write()\"\"\"\n-        if self.origin_server:\n-            if self.client_is_modern():\n-                self._write('HTTP/%s %s\\r\\n' % (self.http_version,self.status))\n-                if 'Date' not in self.headers:\n-                    self._write(\n-                        'Date: %s\\r\\n' % http_date()\n-                    )\n-                if self.server_software and 'Server' not in self.headers:\n-                    self._write('Server: %s\\r\\n' % self.server_software)\n-        else:\n-            self._write('Status: %s\\r\\n' % self.status)\n \n     def write(self, data):\n         \"\"\"'write()' callable as specified by PEP 333\"\"\"\n@@ -420,145 +64,29 @@ def write(self, data):\n             self._write(data)\n             self._flush()\n \n-    def sendfile(self):\n-        \"\"\"Platform-specific file transmission\n-\n-        Override this method in subclasses to support platform-specific\n-        file transmission.  It is only called if the application's\n-        return iterable ('self.result') is an instance of\n-        'self.wsgi_file_wrapper'.\n-\n-        This method should return a true value if it was able to actually\n-        transmit the wrapped file-like object using a platform-specific\n-        approach.  It should return a false value if normal iteration\n-        should be used instead.  An exception can be raised to indicate\n-        that transmission was attempted, but failed.\n-\n-        NOTE: this method should call 'self.send_headers()' if\n-        'self.headers_sent' is false and it is going to attempt direct\n-        transmission of the file1.\n-        \"\"\"\n-        return False   # No platform-specific transmission by default\n-\n-    def finish_content(self):\n-        \"\"\"Ensure headers and content have both been sent\"\"\"\n-        if not self.headers_sent:\n-            self.headers['Content-Length'] = \"0\"\n-            self.send_headers()\n-        else:\n-            pass # XXX check if content-length was too short?\n-\n-    def close(self):\n-        try:\n-            self.request_handler.log_request(self.status.split(' ',1)[0], self.bytes_sent)\n-        finally:\n-            try:\n-                if hasattr(self.result,'close'):\n-                    self.result.close()\n-            finally:\n-                self.result = self.headers = self.status = self.environ = None\n-                self.bytes_sent = 0; self.headers_sent = False\n-\n-    def send_headers(self):\n-        \"\"\"Transmit headers to the client, via self._write()\"\"\"\n-        self.cleanup_headers()\n-        self.headers_sent = True\n-        if not self.origin_server or self.client_is_modern():\n-            self.send_preamble()\n-            self._write(str(self.headers))\n-\n-    def result_is_file(self):\n-        \"\"\"True if 'self.result' is an instance of 'self.wsgi_file_wrapper'\"\"\"\n-        wrapper = self.wsgi_file_wrapper\n-        return wrapper is not None and isinstance(self.result,wrapper)\n-\n-    def client_is_modern(self):\n-        \"\"\"True if client can accept status and headers\"\"\"\n-        return self.environ['SERVER_PROTOCOL'].upper() != 'HTTP/0.9'\n-\n-    def log_exception(self,exc_info):\n-        \"\"\"Log the 'exc_info' tuple in the server log\n-\n-        Subclasses may override to retarget the output or change its format.\n-        \"\"\"\n-        try:\n-            from traceback import print_exception\n-            stderr = self.get_stderr()\n-            print_exception(\n-                exc_info[0], exc_info[1], exc_info[2],\n-                self.traceback_limit, stderr\n-            )\n-            stderr.flush()\n-        finally:\n-            exc_info = None\n-\n-    def handle_error(self):\n-        \"\"\"Log current error, and send error output to client if possible\"\"\"\n-        self.log_exception(sys.exc_info())\n-        if not self.headers_sent:\n-            self.result = self.error_output(self.environ, self.start_response)\n-            self.finish_response()\n-        # XXX else: attempt advanced recovery techniques for HTML or text?\n-\n     def error_output(self, environ, start_response):\n-        import traceback\n-        start_response(self.error_status, self.error_headers[:], sys.exc_info())\n+        super(ServerHandler, self).error_output(environ, start_response)\n         return ['\\n'.join(traceback.format_exception(*sys.exc_info()))]\n \n-    # Pure abstract methods; *must* be overridden in subclasses\n-\n-    def _write(self,data):\n-        self.stdout.write(data)\n-        self._write = self.stdout.write\n-\n-    def _flush(self):\n-        self.stdout.flush()\n-        self._flush = self.stdout.flush\n \n-    def get_stdin(self):\n-        return self.stdin\n-\n-    def get_stderr(self):\n-        return self.stderr\n-\n-    def add_cgi_vars(self):\n-        self.environ.update(self.base_env)\n-\n-class WSGIServer(HTTPServer):\n+class WSGIServer(simple_server.WSGIServer, object):\n     \"\"\"BaseHTTPServer that implements the Python WSGI protocol\"\"\"\n-    application = None\n \n     def __init__(self, *args, **kwargs):\n         if kwargs.pop('ipv6', False):\n             self.address_family = socket.AF_INET6\n-        HTTPServer.__init__(self, *args, **kwargs)\n+        super(WSGIServer, self).__init__(*args, **kwargs)\n \n     def server_bind(self):\n         \"\"\"Override server_bind to store the server name.\"\"\"\n         try:\n-            HTTPServer.server_bind(self)\n+            super(WSGIServer, self).server_bind()\n         except Exception, e:\n             raise WSGIServerException(e)\n         self.setup_environ()\n \n-    def setup_environ(self):\n-        # Set up base environment\n-        env = self.base_environ = {}\n-        env['SERVER_NAME'] = self.server_name\n-        env['GATEWAY_INTERFACE'] = 'CGI/1.1'\n-        env['SERVER_PORT'] = str(self.server_port)\n-        env['REMOTE_HOST']=''\n-        env['CONTENT_LENGTH']=''\n-        env['SCRIPT_NAME'] = ''\n-\n-    def get_app(self):\n-        return self.application\n-\n-    def set_app(self,application):\n-        self.application = application\n \n-class WSGIRequestHandler(BaseHTTPRequestHandler):\n-    server_version = \"WSGIServer/\" + __version__\n+class WSGIRequestHandler(simple_server.WSGIRequestHandler, object):\n \n     def __init__(self, *args, **kwargs):\n         from django.conf import settings\n@@ -567,7 +95,7 @@ def __init__(self, *args, **kwargs):\n         # requests (like \"OPTIONS\").\n         self.path = ''\n         self.style = color_style()\n-        BaseHTTPRequestHandler.__init__(self, *args, **kwargs)\n+        super(WSGIRequestHandler, self).__init__(*args, **kwargs)\n \n     def get_environ(self):\n         env = self.server.base_environ.copy()\n@@ -602,21 +130,10 @@ def get_environ(self):\n                 env['HTTP_'+k] = v\n         return env\n \n-    def get_stderr(self):\n-        return sys.stderr\n-\n-    def handle(self):\n-        \"\"\"Handle a single HTTP request\"\"\"\n-        self.raw_requestline = self.rfile.readline()\n-        if not self.parse_request(): # An error code has been sent, just exit\n-            return\n-        handler = ServerHandler(self.rfile, self.wfile, self.get_stderr(), self.get_environ())\n-        handler.request_handler = self      # backpointer for logging\n-        handler.run(self.server.get_app())\n-\n     def log_message(self, format, *args):\n         # Don't bother logging requests for admin images or the favicon.\n-        if self.path.startswith(self.admin_media_prefix) or self.path == '/favicon.ico':\n+        if (self.path.startswith(self.admin_media_prefix)\n+                or self.path == '/favicon.ico'):\n             return\n \n         msg = \"[%s] %s\\n\" % (self.log_date_time_string(), format % args)\n@@ -652,12 +169,10 @@ class AdminMediaHandler(handlers.StaticFilesHandler):\n     This is pending for deprecation since 1.3.\n     \"\"\"\n     def get_base_dir(self):\n-        import django\n         return os.path.join(django.__path__[0], 'contrib', 'admin', 'media')\n \n     def get_base_url(self):\n         from django.conf import settings\n-        from django.core.exceptions import ImproperlyConfigured\n         if not settings.ADMIN_MEDIA_PREFIX:\n             raise ImproperlyConfigured(\n                 \"The ADMIN_MEDIA_PREFIX setting can't be empty \"\n@@ -689,6 +204,7 @@ def _should_handle(self, path):\n         \"\"\"\n         return path.startswith(self.base_url[2]) and not self.base_url[1]\n \n+\n def run(addr, port, wsgi_handler, ipv6=False):\n     server_address = (addr, port)\n     httpd = WSGIServer(server_address, WSGIRequestHandler, ipv6=ipv6)"
        }
    ],
    "stats": {
        "total": 522,
        "additions": 19,
        "deletions": 503
    }
}