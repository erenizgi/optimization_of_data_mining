{
    "author": "akaariai",
    "message": "Fixed #19707 -- Reset transaction state after requests",
    "sha": "a4e97cf315142e61bb4bc3ed8259b95d8586d09c",
    "files": [
        {
            "sha": "94eca13d41f612b5563f02da29dedbcc6a8bb78b",
            "filename": "django/db/__init__.py",
            "status": "modified",
            "additions": 11,
            "deletions": 2,
            "changes": 13,
            "blob_url": "https://github.com/django/django/blob/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/django%2Fdb%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/django%2Fdb%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2F__init__.py?ref=a4e97cf315142e61bb4bc3ed8259b95d8586d09c",
            "patch": "@@ -42,8 +42,17 @@ def __setattr__(self, name, value):\n # Register an event that closes the database connection\n # when a Django request is finished.\n def close_connection(**kwargs):\n-    for conn in connections.all():\n-        conn.close()\n+    # Avoid circular imports\n+    from django.db import transaction\n+    for conn in connections:\n+        try:\n+            transaction.abort(conn)\n+            connections[conn].close()\n+        except Exception:\n+            # The connection's state is unknown, so it has to be\n+            # abandoned. This could happen for example if the network\n+            # connection has a failure.\n+            del connections[conn]\n signals.request_finished.connect(close_connection)\n \n # Register an event that resets connection.queries"
        },
        {
            "sha": "bbb5a5b294111499c2f4438cf5e41f8071aea70e",
            "filename": "django/db/backends/__init__.py",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/django/django/blob/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/django%2Fdb%2Fbackends%2F__init__.py",
            "raw_url": "https://github.com/django/django/raw/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/django%2Fdb%2Fbackends%2F__init__.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fbackends%2F__init__.py?ref=a4e97cf315142e61bb4bc3ed8259b95d8586d09c",
            "patch": "@@ -88,6 +88,17 @@ def _savepoint_commit(self, sid):\n             return\n         self.cursor().execute(self.ops.savepoint_commit_sql(sid))\n \n+    def abort(self):\n+        \"\"\"\n+        Roll back any ongoing transaction and clean the transaction state\n+        stack.\n+        \"\"\"\n+        if self._dirty:\n+            self._rollback()\n+            self._dirty = False\n+        while self.transaction_state:\n+            self.leave_transaction_management()\n+\n     def enter_transaction_management(self, managed=True):\n         \"\"\"\n         Enters transaction management for a running thread. It must be balanced with"
        },
        {
            "sha": "dd7e2f4dcb7745598d957c3a56c33d8d5036d193",
            "filename": "django/db/transaction.py",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/django/django/blob/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/django%2Fdb%2Ftransaction.py",
            "raw_url": "https://github.com/django/django/raw/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/django%2Fdb%2Ftransaction.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Ftransaction.py?ref=a4e97cf315142e61bb4bc3ed8259b95d8586d09c",
            "patch": "@@ -24,6 +24,21 @@ class TransactionManagementError(Exception):\n     \"\"\"\n     pass\n \n+def abort(using=None):\n+    \"\"\"\n+    Roll back any ongoing transactions and clean the transaction management\n+    state of the connection.\n+\n+    This method is to be used only in cases where using balanced\n+    leave_transaction_management() calls isn't possible. For example after a\n+    request has finished, the transaction state isn't known, yet the connection\n+    must be cleaned up for the next request.\n+    \"\"\"\n+    if using is None:\n+        using = DEFAULT_DB_ALIAS\n+    connection = connections[using]\n+    connection.abort()\n+\n def enter_transaction_management(managed=True, using=None):\n     \"\"\"\n     Enters transaction management for a running thread. It must be balanced with"
        },
        {
            "sha": "943e3e3f73a15efc5db091c3eb45cb13b08e730e",
            "filename": "django/db/utils.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/django%2Fdb%2Futils.py",
            "raw_url": "https://github.com/django/django/raw/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/django%2Fdb%2Futils.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Futils.py?ref=a4e97cf315142e61bb4bc3ed8259b95d8586d09c",
            "patch": "@@ -99,6 +99,9 @@ def __getitem__(self, alias):\n     def __setitem__(self, key, value):\n         setattr(self._connections, key, value)\n \n+    def __delitem__(self, key):\n+        delattr(self._connections, key)\n+\n     def __iter__(self):\n         return iter(self.databases)\n "
        },
        {
            "sha": "4440f377a76116d62b57e35773e7edb47f4222f3",
            "filename": "django/middleware/transaction.py",
            "status": "modified",
            "additions": 20,
            "deletions": 1,
            "changes": 21,
            "blob_url": "https://github.com/django/django/blob/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/django%2Fmiddleware%2Ftransaction.py",
            "raw_url": "https://github.com/django/django/raw/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/django%2Fmiddleware%2Ftransaction.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fmiddleware%2Ftransaction.py?ref=a4e97cf315142e61bb4bc3ed8259b95d8586d09c",
            "patch": "@@ -15,13 +15,32 @@ def process_request(self, request):\n     def process_exception(self, request, exception):\n         \"\"\"Rolls back the database and leaves transaction management\"\"\"\n         if transaction.is_dirty():\n+            # This rollback might fail because of network failure for example.\n+            # If rollback isn't possible it is impossible to clean the\n+            # connection's state. So leave the connection in dirty state and\n+            # let request_finished signal deal with cleaning the connection.\n             transaction.rollback()\n         transaction.leave_transaction_management()\n \n     def process_response(self, request, response):\n         \"\"\"Commits and leaves transaction management.\"\"\"\n         if transaction.is_managed():\n             if transaction.is_dirty():\n-                transaction.commit()\n+                # Note: it is possible that the commit fails. If the reason is\n+                # closed connection or some similar reason, then there is\n+                # little hope to proceed nicely. However, in some cases (\n+                # deferred foreign key checks for exampl) it is still possible\n+                # to rollback().\n+                try:\n+                    transaction.commit()\n+                except Exception:\n+                    # If the rollback fails, the transaction state will be\n+                    # messed up. It doesn't matter, the connection will be set\n+                    # to clean state after the request finishes. And, we can't\n+                    # clean the state here properly even if we wanted to, the\n+                    # connection is in transaction but we can't rollback...\n+                    transaction.rollback()\n+                    transaction.leave_transaction_management()\n+                    raise\n             transaction.leave_transaction_management()\n         return response"
        },
        {
            "sha": "f7c34a9f2540fa157bdcd2a11a62818eb34137c9",
            "filename": "django/test/testcases.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/django/django/blob/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/django%2Ftest%2Ftestcases.py",
            "raw_url": "https://github.com/django/django/raw/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/django%2Ftest%2Ftestcases.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Ftestcases.py?ref=a4e97cf315142e61bb4bc3ed8259b95d8586d09c",
            "patch": "@@ -70,6 +70,7 @@ def to_list(value):\n real_enter_transaction_management = transaction.enter_transaction_management\n real_leave_transaction_management = transaction.leave_transaction_management\n real_managed = transaction.managed\n+real_abort = transaction.abort\n \n def nop(*args, **kwargs):\n     return\n@@ -80,13 +81,15 @@ def disable_transaction_methods():\n     transaction.enter_transaction_management = nop\n     transaction.leave_transaction_management = nop\n     transaction.managed = nop\n+    transaction.abort = nop\n \n def restore_transaction_methods():\n     transaction.commit = real_commit\n     transaction.rollback = real_rollback\n     transaction.enter_transaction_management = real_enter_transaction_management\n     transaction.leave_transaction_management = real_leave_transaction_management\n     transaction.managed = real_managed\n+    transaction.abort = real_abort\n \n \n def assert_and_parse_html(self, html, user_msg, msg):"
        },
        {
            "sha": "6c436415abff6748935c18e4aa4a47fda509af79",
            "filename": "tests/regressiontests/middleware/tests.py",
            "status": "modified",
            "additions": 22,
            "deletions": 3,
            "changes": 25,
            "blob_url": "https://github.com/django/django/blob/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/tests%2Fregressiontests%2Fmiddleware%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/tests%2Fregressiontests%2Fmiddleware%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fmiddleware%2Ftests.py?ref=a4e97cf315142e61bb4bc3ed8259b95d8586d09c",
            "patch": "@@ -9,9 +9,9 @@\n \n from django.conf import settings\n from django.core import mail\n-from django.db import transaction\n-from django.http import HttpRequest\n-from django.http import HttpResponse, StreamingHttpResponse\n+from django.db import (transaction, connections, DEFAULT_DB_ALIAS,\n+                       IntegrityError)\n+from django.http import HttpRequest, HttpResponse, StreamingHttpResponse\n from django.middleware.clickjacking import XFrameOptionsMiddleware\n from django.middleware.common import CommonMiddleware, BrokenLinkEmailsMiddleware\n from django.middleware.http import ConditionalGetMiddleware\n@@ -710,3 +710,22 @@ def test_exception(self):\n         TransactionMiddleware().process_exception(self.request, None)\n         self.assertEqual(Band.objects.count(), 0)\n         self.assertFalse(transaction.is_dirty())\n+\n+    def test_failing_commit(self):\n+        # It is possible that connection.commit() fails. Check that\n+        # TransactionMiddleware handles such cases correctly.\n+        try:\n+            def raise_exception():\n+                raise IntegrityError()\n+            connections[DEFAULT_DB_ALIAS].commit = raise_exception\n+            transaction.enter_transaction_management()\n+            transaction.managed(True)\n+            Band.objects.create(name='The Beatles')\n+            self.assertTrue(transaction.is_dirty())\n+            with self.assertRaises(IntegrityError):\n+                TransactionMiddleware().process_response(self.request, None)\n+            self.assertEqual(Band.objects.count(), 0)\n+            self.assertFalse(transaction.is_dirty())\n+            self.assertFalse(transaction.is_managed())\n+        finally:\n+            del connections[DEFAULT_DB_ALIAS].commit"
        },
        {
            "sha": "d89f6d68be1ab434292a4caef089dc27e539a0a4",
            "filename": "tests/regressiontests/requests/tests.py",
            "status": "modified",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/django/django/blob/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/tests%2Fregressiontests%2Frequests%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/a4e97cf315142e61bb4bc3ed8259b95d8586d09c/tests%2Fregressiontests%2Frequests%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Frequests%2Ftests.py?ref=a4e97cf315142e61bb4bc3ed8259b95d8586d09c",
            "patch": "@@ -6,9 +6,12 @@\n from datetime import datetime, timedelta\n from io import BytesIO\n \n+from django.db import connection, connections, DEFAULT_DB_ALIAS\n+from django.core import signals\n from django.core.exceptions import SuspiciousOperation\n from django.core.handlers.wsgi import WSGIRequest, LimitedStream\n from django.http import HttpRequest, HttpResponse, parse_cookie, build_request_repr, UnreadablePostError\n+from django.test import TransactionTestCase\n from django.test.client import FakePayload\n from django.test.utils import override_settings, str_prefix\n from django.utils import six\n@@ -524,3 +527,42 @@ def read(self, len=0):\n \n         with self.assertRaises(UnreadablePostError):\n             request.body\n+\n+class TransactionRequestTests(TransactionTestCase):\n+    def test_request_finished_db_state(self):\n+        # The GET below will not succeed, but it will give a response with\n+        # defined ._handler_class. That is needed for sending the\n+        # request_finished signal.\n+        response = self.client.get('/')\n+        # Make sure there is an open connection\n+        connection.cursor()\n+        connection.enter_transaction_management()\n+        connection.managed(True)\n+        signals.request_finished.send(sender=response._handler_class)\n+        # In-memory sqlite doesn't actually close connections.\n+        if connection.vendor != 'sqlite':\n+            self.assertIs(connection.connection, None)\n+        self.assertEqual(len(connection.transaction_state), 0)\n+\n+    @unittest.skipIf(connection.vendor == 'sqlite',\n+                     'This test will close the connection, in-memory '\n+                     'sqlite connections must not be closed.')\n+    def test_request_finished_failed_connection(self):\n+        # See comments in test_request_finished_db_state() for the self.client\n+        # usage.\n+        response = self.client.get('/')\n+        conn = connections[DEFAULT_DB_ALIAS]\n+        conn.enter_transaction_management()\n+        conn.managed(True)\n+        conn.set_dirty()\n+        # Test that the rollback doesn't succeed (for example network failure\n+        # could cause this).\n+        def fail_horribly():\n+            raise Exception(\"Horrible failure!\")\n+        conn._rollback = fail_horribly\n+        signals.request_finished.send(sender=response._handler_class)\n+        # As even rollback wasn't possible the connection wrapper itself was\n+        # abandoned. Accessing the connections[alias] will create a new\n+        # connection wrapper, whch must be different than the original one.\n+        self.assertIsNot(conn, connections[DEFAULT_DB_ALIAS])\n+        self.assertEqual(len(connection.transaction_state), 0)"
        }
    ],
    "stats": {
        "total": 133,
        "additions": 127,
        "deletions": 6
    }
}