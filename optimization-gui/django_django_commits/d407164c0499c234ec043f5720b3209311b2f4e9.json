{
    "author": "akaariai",
    "message": "Fixed #18854 -- Join promotion in disjunction cases\n\nThe added promotion logic is based on promoting any joins used in only\nsome of the childs of an OR clause unless the join existed before the\nOR clause addition.",
    "sha": "d407164c0499c234ec043f5720b3209311b2f4e9",
    "files": [
        {
            "sha": "c71bc634aa193e4e339c06cf334a8c89a70b037e",
            "filename": "django/db/models/sql/query.py",
            "status": "modified",
            "additions": 50,
            "deletions": 56,
            "changes": 106,
            "blob_url": "https://github.com/django/django/blob/d407164c0499c234ec043f5720b3209311b2f4e9/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "raw_url": "https://github.com/django/django/raw/d407164c0499c234ec043f5720b3209311b2f4e9/django%2Fdb%2Fmodels%2Fsql%2Fquery.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fsql%2Fquery.py?ref=d407164c0499c234ec043f5720b3209311b2f4e9",
            "patch": "@@ -772,17 +772,37 @@ def reset_refcounts(self, to_counts):\n             unref_amount = cur_refcount - to_counts.get(alias, 0)\n             self.unref_alias(alias, unref_amount)\n \n-    def promote_unused_aliases(self, initial_refcounts, used_aliases):\n+    def promote_disjunction(self, aliases_before, alias_usage_counts,\n+                            num_childs):\n         \"\"\"\n-        Given a \"before\" copy of the alias_refcounts dictionary (as\n-        'initial_refcounts') and a collection of aliases that may have been\n-        changed or created, works out which aliases have been created since\n-        then and which ones haven't been used and promotes all of those\n-        aliases, plus any children of theirs in the alias tree, to outer joins.\n+        This method is to be used for promoting joins in ORed filters.\n+\n+        The principle for promotion is: any alias which is used (it is in\n+        alias_usage_counts), is not used by every child of the ORed filter,\n+        and isn't pre-existing needs to be promoted to LOUTER join.\n+\n+        Some examples (assume all joins used are nullable):\n+            - existing filter: a__f1=foo\n+            - add filter: b__f1=foo|b__f2=foo\n+            In this case we should not promote either of the joins (using INNER\n+            doesn't remove results). We correctly avoid join promotion, because\n+            a is not used in this branch, and b is used two times.\n+\n+            - add filter a__f1=foo|b__f2=foo\n+            In this case we should promote both a and b, otherwise they will\n+            remove results. We will also correctly do that as both aliases are\n+            used, and in addition both are used only once while there are two\n+            filters.\n+\n+            - existing: a__f1=bar\n+            - add filter: a__f2=foo|b__f2=foo\n+            We will not promote a as it is previously used. If the join results\n+            in null, the existing filter can't succeed.\n+\n+        The above (and some more) are tested in queries.DisjunctionPromotionTests\n         \"\"\"\n-        for alias in self.tables:\n-            if alias in used_aliases and (alias not in initial_refcounts or\n-                    self.alias_refcount[alias] == initial_refcounts[alias]):\n+        for alias, use_count in alias_usage_counts.items():\n+            if use_count < num_childs and alias not in aliases_before:\n                 self.promote_joins([alias])\n \n     def change_aliases(self, change_map):\n@@ -1150,56 +1170,19 @@ def add_filter(self, filter_expr, connector=AND, negate=False,\n                     can_reuse)\n             return\n \n-        table_promote = False\n-        join_promote = False\n-\n         if (lookup_type == 'isnull' and value is True and not negate and\n                 len(join_list) > 1):\n             # If the comparison is against NULL, we may need to use some left\n             # outer joins when creating the join chain. This is only done when\n             # needed, as it's less efficient at the database level.\n             self.promote_joins(join_list)\n-            join_promote = True\n \n         # Process the join list to see if we can remove any inner joins from\n         # the far end (fewer tables in a query is better). Note that join\n         # promotion must happen before join trimming to have the join type\n         # information available when reusing joins.\n         col, alias, join_list = self.trim_joins(target, join_list, path)\n \n-        if connector == OR:\n-            # Some joins may need to be promoted when adding a new filter to a\n-            # disjunction. We walk the list of new joins and where it diverges\n-            # from any previous joins (ref count is 1 in the table list), we\n-            # make the new additions (and any existing ones not used in the new\n-            # join list) an outer join.\n-            join_it = iter(join_list)\n-            table_it = iter(self.tables)\n-            next(join_it), next(table_it)\n-            unconditional = False\n-            for join in join_it:\n-                table = next(table_it)\n-                # Once we hit an outer join, all subsequent joins must\n-                # also be promoted, regardless of whether they have been\n-                # promoted as a result of this pass through the tables.\n-                unconditional = (unconditional or\n-                    self.alias_map[join].join_type == self.LOUTER)\n-                if join == table and self.alias_refcount[join] > 1:\n-                    # We have more than one reference to this join table.\n-                    # This means that we are dealing with two different query\n-                    # subtrees, so we don't need to do any join promotion.\n-                    continue\n-                join_promote = join_promote or self.promote_joins([join], unconditional)\n-                if table != join:\n-                    table_promote = self.promote_joins([table])\n-                # We only get here if we have found a table that exists\n-                # in the join list, but isn't on the original tables list.\n-                # This means we've reached the point where we only have\n-                # new tables, so we can break out of this promotion loop.\n-                break\n-            self.promote_joins(join_it, join_promote)\n-            self.promote_joins(table_it, table_promote or join_promote)\n-\n         if having_clause or force_having:\n             if (alias, col) not in self.group_by:\n                 self.group_by.append((alias, col))\n@@ -1256,33 +1239,36 @@ def add_q(self, q_object, used_aliases=None, force_having=False):\n                 subtree = True\n             else:\n                 subtree = False\n-            connector = AND\n+            connector = q_object.connector\n+            if connector == OR:\n+                alias_usage_counts = dict()\n+                aliases_before = set(self.tables)\n             if q_object.connector == OR and not force_having:\n                 force_having = self.need_force_having(q_object)\n             for child in q_object.children:\n-                if connector == OR:\n-                    refcounts_before = self.alias_refcount.copy()\n                 if force_having:\n                     self.having.start_subtree(connector)\n                 else:\n                     self.where.start_subtree(connector)\n+                if connector == OR:\n+                    refcounts_before = self.alias_refcount.copy()\n                 if isinstance(child, Node):\n                     self.add_q(child, used_aliases, force_having=force_having)\n                 else:\n                     self.add_filter(child, connector, q_object.negated,\n                             can_reuse=used_aliases, force_having=force_having)\n+                if connector == OR:\n+                    used = alias_diff(refcounts_before, self.alias_refcount)\n+                    for alias in used:\n+                        alias_usage_counts[alias] = alias_usage_counts.get(alias, 0) + 1\n                 if force_having:\n                     self.having.end_subtree()\n                 else:\n                     self.where.end_subtree()\n \n-                if connector == OR:\n-                    # Aliases that were newly added or not used at all need to\n-                    # be promoted to outer joins if they are nullable relations.\n-                    # (they shouldn't turn the whole conditional into the empty\n-                    # set just because they don't match anything).\n-                    self.promote_unused_aliases(refcounts_before, used_aliases)\n-                connector = q_object.connector\n+            if connector == OR:\n+                self.promote_disjunction(aliases_before, alias_usage_counts,\n+                                         len(q_object.children))\n             if q_object.negated:\n                 self.where.negate()\n             if subtree:\n@@ -2005,3 +1991,11 @@ def is_reverse_o2o(field):\n     expected to be some sort of relation field or related object.\n     \"\"\"\n     return not hasattr(field, 'rel') and field.field.unique\n+\n+def alias_diff(refcounts_before, refcounts_after):\n+    \"\"\"\n+    Given the before and after copies of refcounts works out which aliases\n+    have been added to the after copy.\n+    \"\"\"\n+    return set(t for t in refcounts_after\n+               if refcounts_after[t] > refcounts_before.get(t, 0))"
        },
        {
            "sha": "16583e891c627c0d67ce50e3b356b7a3c6bb4479",
            "filename": "tests/regressiontests/queries/models.py",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/django/django/blob/d407164c0499c234ec043f5720b3209311b2f4e9/tests%2Fregressiontests%2Fqueries%2Fmodels.py",
            "raw_url": "https://github.com/django/django/raw/d407164c0499c234ec043f5720b3209311b2f4e9/tests%2Fregressiontests%2Fqueries%2Fmodels.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Fmodels.py?ref=d407164c0499c234ec043f5720b3209311b2f4e9",
            "patch": "@@ -421,3 +421,21 @@ class Responsibility(models.Model):\n \n     def __str__(self):\n         return self.description\n+\n+# Models for disjunction join promotion low level testing.\n+class FK1(models.Model):\n+    f1 = models.TextField()\n+    f2 = models.TextField()\n+\n+class FK2(models.Model):\n+    f1 = models.TextField()\n+    f2 = models.TextField()\n+\n+class FK3(models.Model):\n+    f1 = models.TextField()\n+    f2 = models.TextField()\n+\n+class BaseA(models.Model):\n+    a = models.ForeignKey(FK1, null=True)\n+    b = models.ForeignKey(FK2, null=True)\n+    c = models.ForeignKey(FK3, null=True)"
        },
        {
            "sha": "e3e515025c7c3d4c89c7b9694892ae22cc2e3d2e",
            "filename": "tests/regressiontests/queries/tests.py",
            "status": "modified",
            "additions": 127,
            "deletions": 3,
            "changes": 130,
            "blob_url": "https://github.com/django/django/blob/d407164c0499c234ec043f5720b3209311b2f4e9/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/d407164c0499c234ec043f5720b3209311b2f4e9/tests%2Fregressiontests%2Fqueries%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fqueries%2Ftests.py?ref=d407164c0499c234ec043f5720b3209311b2f4e9",
            "patch": "@@ -8,8 +8,8 @@\n from django.conf import settings\n from django.core.exceptions import FieldError\n from django.db import DatabaseError, connection, connections, DEFAULT_DB_ALIAS\n-from django.db.models import Count\n-from django.db.models.query import Q, ITER_CHUNK_SIZE, EmptyQuerySet\n+from django.db.models import Count, F, Q\n+from django.db.models.query import ITER_CHUNK_SIZE, EmptyQuerySet\n from django.db.models.sql.where import WhereNode, EverythingNode, NothingNode\n from django.db.models.sql.datastructures import EmptyResultSet\n from django.test import TestCase, skipUnlessDBFeature\n@@ -24,7 +24,7 @@\n     Node, ObjectA, ObjectB, ObjectC, CategoryItem, SimpleCategory,\n     SpecialCategory, OneToOneCategory, NullableName, ProxyCategory,\n     SingleObject, RelatedObject, ModelA, ModelD, Responsibility, Job,\n-    JobResponsibilities)\n+    JobResponsibilities, BaseA)\n \n \n class BaseQuerysetTest(TestCase):\n@@ -2451,3 +2451,127 @@ def test_revo2o_reuse(self):\n     def test_revfk_noreuse(self):\n         qs = Author.objects.filter(report__name='r4').filter(report__name='r1')\n         self.assertEqual(str(qs.query).count('JOIN'), 2)\n+\n+class DisjunctionPromotionTests(TestCase):\n+    def test_disjunction_promotion1(self):\n+        # Pre-existing join, add two ORed filters to the same join,\n+        # all joins can be INNER JOINS.\n+        qs = BaseA.objects.filter(a__f1='foo')\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        qs = qs.filter(Q(b__f1='foo') | Q(b__f2='foo'))\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 2)\n+        # Reverse the order of AND and OR filters.\n+        qs = BaseA.objects.filter(Q(b__f1='foo') | Q(b__f2='foo'))\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        qs = qs.filter(a__f1='foo')\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 2)\n+\n+    def test_disjunction_promotion2(self):\n+        qs = BaseA.objects.filter(a__f1='foo')\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        # Now we have two different joins in an ORed condition, these\n+        # must be OUTER joins. The pre-existing join should remain INNER.\n+        qs = qs.filter(Q(b__f1='foo') | Q(c__f2='foo'))\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 2)\n+        # Reverse case.\n+        qs = BaseA.objects.filter(Q(b__f1='foo') | Q(c__f2='foo'))\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 2)\n+        qs = qs.filter(a__f1='foo')\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 2)\n+\n+    def test_disjunction_promotion3(self):\n+        qs = BaseA.objects.filter(a__f2='bar')\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        # The ANDed a__f2 filter allows us to use keep using INNER JOIN\n+        # even inside the ORed case. If the join to a__ returns nothing,\n+        # the ANDed filter for a__f2 can't be true.\n+        qs = qs.filter(Q(a__f1='foo') | Q(b__f2='foo'))\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 1)\n+\n+    @unittest.expectedFailure\n+    def test_disjunction_promotion3_failing(self):\n+        # Now the ORed filter creates LOUTER join, but we do not have\n+        # logic to unpromote it for the AND filter after it. The query\n+        # results will be correct, but we have one LOUTER JOIN too much\n+        # currently.\n+        qs = BaseA.objects.filter(\n+            Q(a__f1='foo') | Q(b__f2='foo')).filter(a__f2='bar')\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 1)\n+\n+    def test_disjunction_promotion4(self):\n+        qs = BaseA.objects.filter(Q(a=1) | Q(a=2))\n+        self.assertEqual(str(qs.query).count('JOIN'), 0)\n+        qs = qs.filter(a__f1='foo')\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        qs = BaseA.objects.filter(a__f1='foo')\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        qs = qs.filter(Q(a=1) | Q(a=2))\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+\n+    def test_disjunction_promotion5(self):\n+        qs = BaseA.objects.filter(Q(a=1) | Q(a=2))\n+        # Note that the above filters on a force the join to an\n+        # inner join even if it is trimmed.\n+        self.assertEqual(str(qs.query).count('JOIN'), 0)\n+        qs = qs.filter(Q(a__f1='foo') | Q(b__f1='foo'))\n+        # So, now the a__f1 join doesn't need promotion.\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 1)\n+\n+    @unittest.expectedFailure\n+    def test_disjunction_promotion5_failing(self):\n+        qs = BaseA.objects.filter(Q(a__f1='foo') | Q(b__f1='foo'))\n+        # Now the join to a is created as LOUTER\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 0)\n+        # The below filter should force the a to be inner joined. But,\n+        # this is failing as we do not have join unpromotion logic.\n+        qs = BaseA.objects.filter(Q(a=1) | Q(a=2))\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 1)\n+\n+    def test_disjunction_promotion6(self):\n+        qs = BaseA.objects.filter(Q(a=1) | Q(a=2))\n+        self.assertEqual(str(qs.query).count('JOIN'), 0)\n+        qs = BaseA.objects.filter(Q(a__f1='foo') & Q(b__f1='foo'))\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 2)\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 0)\n+\n+        qs = BaseA.objects.filter(Q(a__f1='foo') & Q(b__f1='foo'))\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 0)\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 2)\n+        qs = qs.filter(Q(a=1) | Q(a=2))\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 2)\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 0)\n+\n+    def test_disjunction_promotion7(self):\n+        qs = BaseA.objects.filter(Q(a=1) | Q(a=2))\n+        self.assertEqual(str(qs.query).count('JOIN'), 0)\n+        qs = BaseA.objects.filter(Q(a__f1='foo') | (Q(b__f1='foo') & Q(a__f1='bar')))\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 1)\n+        qs = BaseA.objects.filter(\n+            (Q(a__f1='foo') | Q(b__f1='foo')) & (Q(a__f1='bar') | Q(c__f1='foo'))\n+        )\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 3)\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 0)\n+        qs = BaseA.objects.filter(\n+            (Q(a__f1='foo') | (Q(a__f1='bar')) & (Q(b__f1='bar') | Q(c__f1='foo')))\n+        )\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 2)\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+\n+    def test_disjunction_promotion_fexpression(self):\n+        qs = BaseA.objects.filter(Q(a__f1=F('b__f1')) | Q(b__f1='foo'))\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 1)\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 1)\n+        qs = BaseA.objects.filter(Q(a__f1=F('c__f1')) | Q(b__f1='foo'))\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 3)\n+        qs = BaseA.objects.filter(Q(a__f1=F('b__f1')) | Q(a__f2=F('b__f2')) | Q(c__f1='foo'))\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 3)\n+        qs = BaseA.objects.filter(Q(a__f1=F('c__f1')) | (Q(pk=1) & Q(pk=2)))\n+        self.assertEqual(str(qs.query).count('LEFT OUTER JOIN'), 2)\n+        self.assertEqual(str(qs.query).count('INNER JOIN'), 0)"
        }
    ],
    "stats": {
        "total": 254,
        "additions": 195,
        "deletions": 59
    }
}