{
    "author": "claudep",
    "message": "Fixed #18590 - Reverted Python 2.4 workaround for Model pickling\n\nRevert of 08d521efa0. Refs #10547, #12121.\nThanks Michal Petrucha for the report.",
    "sha": "146aff3bac974e56ec8cb597c2720d1cd4f77b26",
    "files": [
        {
            "sha": "79af1cb34cbaa0a6bd06d8670c6ffc8b2478aadf",
            "filename": "django/db/models/base.py",
            "status": "modified",
            "additions": 11,
            "deletions": 29,
            "changes": 40,
            "blob_url": "https://github.com/django/django/blob/146aff3bac974e56ec8cb597c2720d1cd4f77b26/django%2Fdb%2Fmodels%2Fbase.py",
            "raw_url": "https://github.com/django/django/raw/146aff3bac974e56ec8cb597c2720d1cd4f77b26/django%2Fdb%2Fmodels%2Fbase.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdb%2Fmodels%2Fbase.py?ref=146aff3bac974e56ec8cb597c2720d1cd4f77b26",
            "patch": "@@ -16,7 +16,7 @@\n from django.db import (router, transaction, DatabaseError,\n     DEFAULT_DB_ALIAS)\n from django.db.models.query import Q\n-from django.db.models.query_utils import DeferredAttribute\n+from django.db.models.query_utils import DeferredAttribute, deferred_class_factory\n from django.db.models.deletion import Collector\n from django.db.models.options import Options\n from django.db.models import signals\n@@ -400,25 +400,16 @@ def __reduce__(self):\n         need to do things manually, as they're dynamically created classes and\n         only module-level classes can be pickled by the default path.\n         \"\"\"\n+        if not self._deferred:\n+            return super(Model, self).__reduce__()\n         data = self.__dict__\n-        model = self.__class__\n-        # The obvious thing to do here is to invoke super().__reduce__()\n-        # for the non-deferred case. Don't do that.\n-        # On Python 2.4, there is something weird with __reduce__,\n-        # and as a result, the super call will cause an infinite recursion.\n-        # See #10547 and #12121.\n         defers = []\n-        if self._deferred:\n-            from django.db.models.query_utils import deferred_class_factory\n-            factory = deferred_class_factory\n-            for field in self._meta.fields:\n-                if isinstance(self.__class__.__dict__.get(field.attname),\n-                        DeferredAttribute):\n-                    defers.append(field.attname)\n-            model = self._meta.proxy_for_model\n-        else:\n-            factory = simple_class_factory\n-        return (model_unpickle, (model, defers, factory), data)\n+        for field in self._meta.fields:\n+            if isinstance(self.__class__.__dict__.get(field.attname),\n+                    DeferredAttribute):\n+                defers.append(field.attname)\n+        model = self._meta.proxy_for_model\n+        return (model_unpickle, (model, defers), data)\n \n     def _get_pk_val(self, meta=None):\n         if not meta:\n@@ -926,20 +917,11 @@ def get_absolute_url(opts, func, self, *args, **kwargs):\n class Empty(object):\n     pass\n \n-def simple_class_factory(model, attrs):\n-    \"\"\"Used to unpickle Models without deferred fields.\n-\n-    We need to do this the hard way, rather than just using\n-    the default __reduce__ implementation, because of a\n-    __deepcopy__ problem in Python 2.4\n-    \"\"\"\n-    return model\n-\n-def model_unpickle(model, attrs, factory):\n+def model_unpickle(model, attrs):\n     \"\"\"\n     Used to unpickle Model subclasses with deferred fields.\n     \"\"\"\n-    cls = factory(model, attrs)\n+    cls = deferred_class_factory(model, attrs)\n     return cls.__new__(cls)\n model_unpickle.__safe_for_unpickle__ = True\n "
        }
    ],
    "stats": {
        "total": 40,
        "additions": 11,
        "deletions": 29
    }
}