{
    "author": "honzakral",
    "message": "Fixed #14533 -- Make django signals more thread-safe. Thanks milosu for the patch!\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@14662 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "f27e6f0dd198309e0d965ca78bf1c5fd04a29f8e",
    "files": [
        {
            "sha": "9beb309ac19878748bd097ba048a77896dec550e",
            "filename": "django/dispatch/dispatcher.py",
            "status": "modified",
            "additions": 35,
            "deletions": 18,
            "changes": 53,
            "blob_url": "https://github.com/django/django/blob/f27e6f0dd198309e0d965ca78bf1c5fd04a29f8e/django%2Fdispatch%2Fdispatcher.py",
            "raw_url": "https://github.com/django/django/raw/f27e6f0dd198309e0d965ca78bf1c5fd04a29f8e/django%2Fdispatch%2Fdispatcher.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Fdispatch%2Fdispatcher.py?ref=f27e6f0dd198309e0d965ca78bf1c5fd04a29f8e",
            "patch": "@@ -1,4 +1,5 @@\n import weakref\n+import threading\n \n from django.dispatch import saferef\n \n@@ -30,6 +31,7 @@ def __init__(self, providing_args=None):\n         if providing_args is None:\n             providing_args = []\n         self.providing_args = set(providing_args)\n+        self.lock = threading.Lock()\n \n     def connect(self, receiver, sender=None, weak=True, dispatch_uid=None):\n         \"\"\"\n@@ -97,11 +99,15 @@ def connect(self, receiver, sender=None, weak=True, dispatch_uid=None):\n         if weak:\n             receiver = saferef.safeRef(receiver, onDelete=self._remove_receiver)\n \n-        for r_key, _ in self.receivers:\n-            if r_key == lookup_key:\n-                break\n-        else:\n-            self.receivers.append((lookup_key, receiver))\n+        try:\n+            self.lock.acquire()\n+            for r_key, _ in self.receivers:\n+                if r_key == lookup_key:\n+                    break\n+            else:\n+                self.receivers.append((lookup_key, receiver))\n+        finally:\n+            self.lock.release()\n \n     def disconnect(self, receiver=None, sender=None, weak=True, dispatch_uid=None):\n         \"\"\"\n@@ -130,11 +136,15 @@ def disconnect(self, receiver=None, sender=None, weak=True, dispatch_uid=None):\n         else:\n             lookup_key = (_make_id(receiver), _make_id(sender))\n         \n-        for index in xrange(len(self.receivers)):\n-            (r_key, _) = self.receivers[index]\n-            if r_key == lookup_key:\n-                del self.receivers[index]\n-                break\n+        try:\n+            self.lock.acquire()\n+            for index in xrange(len(self.receivers)):\n+                (r_key, _) = self.receivers[index]\n+                if r_key == lookup_key:\n+                    del self.receivers[index]\n+                    break\n+        finally:\n+            self.lock.release()\n \n     def send(self, sender, **named):\n         \"\"\"\n@@ -227,14 +237,21 @@ def _remove_receiver(self, receiver):\n         Remove dead receivers from connections.\n         \"\"\"\n \n-        to_remove = []\n-        for key, connected_receiver in self.receivers:\n-            if connected_receiver == receiver:\n-                to_remove.append(key)\n-        for key in to_remove:\n-            for idx, (r_key, _) in enumerate(self.receivers):\n-                if r_key == key:\n-                    del self.receivers[idx]\n+        try:\n+            self.lock.acquire()\n+            to_remove = []\n+            for key, connected_receiver in self.receivers:\n+                if connected_receiver == receiver:\n+                    to_remove.append(key)\n+            for key in to_remove:\n+                last_idx = len(self.receivers) - 1\n+                # enumerate in reverse order so that indexes are valid even\n+                # after we delete some items\n+                for idx, (r_key, _) in enumerate(reversed(self.receivers)):\n+                    if r_key == key:\n+                        del self.receivers[last_idx-idx]\n+        finally:\n+            self.lock.release()\n \n \n def receiver(signal, **kwargs):"
        }
    ],
    "stats": {
        "total": 53,
        "additions": 35,
        "deletions": 18
    }
}