{
    "author": "carljm",
    "message": "Fixed #17011 - Made override_settings modify a decorated class in-place rather than creating a dynamic subclass, so as to avoid infinite recursion when used with super(). Thanks jsdalton for the report and patch.\n\ngit-svn-id: http://code.djangoproject.com/svn/django/trunk@16942 bcc190cf-cafb-0310-a4f2-bffc1f526a37",
    "sha": "b6ad1afa6813226ff7d16f9f7b5751cb2d624c4b",
    "files": [
        {
            "sha": "87f23118971aea50bd781dbc956bd1bcf8ad7692",
            "filename": "django/test/utils.py",
            "status": "modified",
            "additions": 7,
            "deletions": 13,
            "changes": 20,
            "blob_url": "https://github.com/django/django/blob/b6ad1afa6813226ff7d16f9f7b5751cb2d624c4b/django%2Ftest%2Futils.py",
            "raw_url": "https://github.com/django/django/raw/b6ad1afa6813226ff7d16f9f7b5751cb2d624c4b/django%2Ftest%2Futils.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/django%2Ftest%2Futils.py?ref=b6ad1afa6813226ff7d16f9f7b5751cb2d624c4b",
            "patch": "@@ -196,23 +196,17 @@ def __exit__(self, exc_type, exc_value, traceback):\n     def __call__(self, test_func):\n         from django.test import TransactionTestCase\n         if isinstance(test_func, type) and issubclass(test_func, TransactionTestCase):\n-            # When decorating a class, we need to construct a new class\n-            # with the same name so that the test discovery tools can\n-            # get a useful name.\n+            original_pre_setup = test_func._pre_setup\n+            original_post_teardown = test_func._post_teardown\n             def _pre_setup(innerself):\n                 self.enable()\n-                test_func._pre_setup(innerself)\n+                original_pre_setup(innerself)\n             def _post_teardown(innerself):\n-                test_func._post_teardown(innerself)\n+                original_post_teardown(innerself)\n                 self.disable()\n-            inner = type(\n-                test_func.__name__,\n-                (test_func,),\n-                {\n-                    '_pre_setup': _pre_setup,\n-                    '_post_teardown': _post_teardown,\n-                    '__module__': test_func.__module__,\n-                })\n+            test_func._pre_setup = _pre_setup\n+            test_func._post_teardown = _post_teardown\n+            return test_func\n         else:\n             @wraps(test_func)\n             def inner(*args, **kwargs):"
        },
        {
            "sha": "1a4515673a879a97815b54a6613908c54e2fd4db",
            "filename": "docs/topics/testing.txt",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/django/django/blob/b6ad1afa6813226ff7d16f9f7b5751cb2d624c4b/docs%2Ftopics%2Ftesting.txt",
            "raw_url": "https://github.com/django/django/raw/b6ad1afa6813226ff7d16f9f7b5751cb2d624c4b/docs%2Ftopics%2Ftesting.txt",
            "contents_url": "https://api.github.com/repos/django/django/contents/docs%2Ftopics%2Ftesting.txt?ref=b6ad1afa6813226ff7d16f9f7b5751cb2d624c4b",
            "patch": "@@ -1450,6 +1450,15 @@ The decorator can also be applied to test case classes::\n \n     LoginTestCase = override_settings(LOGIN_URL='/other/login/')(LoginTestCase)\n \n+.. note::\n+\n+    When given a class, the decorator modifies the class directly and\n+    returns it; it doesn't create and return a modified copy of it.  So if\n+    you try to tweak the above example to assign the return value to a\n+    different name than ``LoginTestCase``, you may be surprised to find that\n+    the original ``LoginTestCase`` is still equally affected by the\n+    decorator.\n+\n On Python 2.6 and higher you can also use the well known decorator syntax to\n decorate the class::\n "
        },
        {
            "sha": "ff2334a95fe8786cd630f935c8c6ec84deca7492",
            "filename": "tests/regressiontests/settings_tests/tests.py",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/django/django/blob/b6ad1afa6813226ff7d16f9f7b5751cb2d624c4b/tests%2Fregressiontests%2Fsettings_tests%2Ftests.py",
            "raw_url": "https://github.com/django/django/raw/b6ad1afa6813226ff7d16f9f7b5751cb2d624c4b/tests%2Fregressiontests%2Fsettings_tests%2Ftests.py",
            "contents_url": "https://api.github.com/repos/django/django/contents/tests%2Fregressiontests%2Fsettings_tests%2Ftests.py?ref=b6ad1afa6813226ff7d16f9f7b5751cb2d624c4b",
            "patch": "@@ -35,6 +35,38 @@ def test_method_override(self):\n \n FullyDecoratedTestCase = override_settings(TEST='override')(FullyDecoratedTestCase)\n \n+\n+class ClassDecoratedTestCaseSuper(TestCase):\n+    \"\"\"\n+    Dummy class for testing max recursion error in child class call to\n+    super().  Refs #17011.\n+\n+    \"\"\"\n+    def test_max_recursion_error(self):\n+        pass\n+\n+\n+@override_settings(TEST='override')\n+class ClassDecoratedTestCase(ClassDecoratedTestCaseSuper):\n+    def test_override(self):\n+        self.assertEqual(settings.TEST, 'override')\n+\n+    @override_settings(TEST='override2')\n+    def test_method_override(self):\n+        self.assertEqual(settings.TEST, 'override2')\n+\n+    def test_max_recursion_error(self):\n+        \"\"\"\n+        Overriding a method on a super class and then calling that method on\n+        the super class should not trigger infinite recursion. See #17011.\n+\n+        \"\"\"\n+        try:\n+            super(ClassDecoratedTestCase, self).test_max_recursion_error()\n+        except RuntimeError, e:\n+            self.fail()\n+\n+\n class SettingGetter(object):\n     def __init__(self):\n         self.test = getattr(settings, 'TEST', 'undefined')"
        }
    ],
    "stats": {
        "total": 61,
        "additions": 48,
        "deletions": 13
    }
}