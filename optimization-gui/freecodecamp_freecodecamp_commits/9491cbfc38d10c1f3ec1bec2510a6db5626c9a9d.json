{
    "author": "jdwilkin4",
    "message": "chore(curriculum): adding remaining two transcripts for DOM lectures (#58695)\n\nCo-authored-by: Dario-DC <105294544+Dario-DC@users.noreply.github.com>",
    "sha": "9491cbfc38d10c1f3ec1bec2510a6db5626c9a9d",
    "files": [
        {
            "sha": "c1da6e8d5863bb885723b8208934d3ccba3c1eea",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-the-event-object-and-event-delegation/6732a06aed1b095f57b0bb82.md",
            "status": "modified",
            "additions": 26,
            "deletions": 1,
            "changes": 27,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9491cbfc38d10c1f3ec1bec2510a6db5626c9a9d/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-the-event-object-and-event-delegation%2F6732a06aed1b095f57b0bb82.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9491cbfc38d10c1f3ec1bec2510a6db5626c9a9d/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-the-event-object-and-event-delegation%2F6732a06aed1b095f57b0bb82.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-the-event-object-and-event-delegation%2F6732a06aed1b095f57b0bb82.md?ref=9491cbfc38d10c1f3ec1bec2510a6db5626c9a9d",
            "patch": "@@ -8,7 +8,32 @@ dashedName: what-is-the-change-event-and-how-does-it-work\n \n # --description--\n \n-Watch the video lecture and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What is the `change` event, and how does it work?\n+\n+The `change` event is a special event which is fired when the user modifies the value of certain input elements. More specifically:\n+\n+- When a checkbox is ticked or unticked.\n+\n+- When a radio button is ticked.\n+\n+- When the user makes a selection from something like a date picker or dropdown menu.\n+\n+- When an input loses focus (the user tabs to the next field, or clicks out of the form) after the user has changed the value.\n+\n+- When the user otherwise confirms the value, such as by hitting enter after typing some text.\n+\n+Note that the `change` event does NOT fire when your user types in an input. The `change` event will only fire after they have focused on another element.\n+\n+The `change` event still generates an `Event` object, but unlike most other events it does not generate a custom implementation – the only properties and methods you will have access to are those on the base `Event` object.\n+\n+This differs from the `input` event, which generates a dedicated `InputEvent` object. The change event also differs in a few ways. An `input` event WILL trigger when a user types content into a field, for example.\n+\n+These differences are important to remember, as you might get tripped up by the timing of these events firing.\n+\n \n # --questions--\n "
        },
        {
            "sha": "86777d37ab6ee1c3c39c6e5a59728ae88e36f557",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-the-event-object-and-event-delegation/67338e93b75977a344cf6d40.md",
            "status": "modified",
            "additions": 128,
            "deletions": 2,
            "changes": 130,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9491cbfc38d10c1f3ec1bec2510a6db5626c9a9d/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-the-event-object-and-event-delegation%2F67338e93b75977a344cf6d40.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9491cbfc38d10c1f3ec1bec2510a6db5626c9a9d/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-the-event-object-and-event-delegation%2F67338e93b75977a344cf6d40.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-the-event-object-and-event-delegation%2F67338e93b75977a344cf6d40.md?ref=9491cbfc38d10c1f3ec1bec2510a6db5626c9a9d",
            "patch": "@@ -2,13 +2,139 @@\n id: 67338e93b75977a344cf6d40\n title: How Do Event Bubbling, and Event Delegation Work?\n challengeType: 11\n-videoId: 9yeVpWaYwMU\n+videoId: 4kMcX0If-AY\n dashedName: how-do-event-bubbling-and-event-delegation-work\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How do event bubbling, and event delegation work?\n+\n+Event bubbling, or propagation, refers to how an event \"bubbles up\" to parent objects when triggered. For example, consider this code:\n+\n+```html\n+<p>\n+  <span>Click me~!</span>\n+</p>\n+```\n+\n+The `p` element here would be considered the parent of the `span` element. \n+\n+When you click on the `span` element, like you are instructed to, the `span` element becomes the target of a `click` event. That event, however, also bubbles up to the parent – the `p` element can receive and consume that event as needed.\n+\n+But what does this actually mean? Well, you could attach an event listener to the `p` element:\n+\n+```js\n+const p = document.querySelector(\"p\");\n+p.addEventListener(\"click\", (event) => {\n+  console.log(event.target);\n+});\n+```\n+\n+Then, when you click on the `span` element you will see the text `Click me~!` logged to the console.\n+\n+The event propagates to the parent `p` element, which consumes it in an event listener to display the target of the event. \n+\n+Notice how the target is still the `span` element. This is because the `span` element received the initial click.\n+\n+Just to be sure how things are working, let's expand our code:\n+\n+```js\n+const p = document.querySelector(\"p\");\n+const span = document.querySelector(\"span\");\n+p.addEventListener(\"click\", (event) => {\n+  console.log(\"P listener: \");\n+  console.log(event.target);\n+});\n+span.addEventListener(\"click\", (event) => {\n+  console.log(\"Span listener: \");\n+  console.log(event.target);\n+});\n+```\n+\n+To give you an idea of how the event bubbles up, here's what you'll see in the console after clicking the `span` element:\n+\n+```html\n+\"Span listener: \"\n+<span>Click me~!</span>\n+\"P listener: \"\n+<span>Click me~!</span>\n+```\n+\n+Now let's see what happens when you prevent the propagation of an event with `stopPropagation()`. We'll call it in our `span`'s event listener:\n+\n+```js\n+const p = document.querySelector(\"p\");\n+const span = document.querySelector(\"span\");\n+p.addEventListener(\"click\", (event) => {\n+  console.log(\"P listener: \");\n+  console.log(event.target);\n+});\n+span.addEventListener(\"click\", (event) => {\n+  console.log(\"Span listener: \");\n+  console.log(event.target);\n+  event.stopPropagation();\n+});\n+```\n+\n+And then click our `span` again:\n+\n+```html\n+\"Span listener: \"\n+<span>Click me~!</span>\n+```\n+ \n+This time, we don't see our `p` listener trigger. The event never fires for the `p` element, because we told it to stop propagation while it was being processed for the child `span` element.\n+\n+Event delegation can be thought of as the opposite. It's the process of taking a captured event, and delegating it to another element. \n+\n+Going back to our code, let's update it so clicking on a `span` element changes it to red:\n+\n+```js\n+const p = document.querySelector(\"p\");\n+const span = document.querySelector(\"span\");\n+p.addEventListener(\"click\", (event) => {});\n+span.addEventListener(\"click\", (event) => {\n+  event.target.style.color = \"red\";\n+});\n+```\n+\n+But what if you have twenty `span` elements? Or maybe you use JavaScript to create more `span` elements on the fly?\n+\n+Rather than having to attach an event listener to every single `span` element, you can actually use the listener on the `p` element for all of them. In other words, you can delegate the handling of the `span` clicks to the parent `p` element.\n+\n+Our code might now look something like this:\n+\n+```js\n+const p = document.querySelector(\"p\");\n+p.addEventListener(\"click\", (event) => {\n+  event.target.style.color = \"red\";\n+});\n+```\n+\n+Notice how we no longer have any listener attached to the `span` element at all. You have properly delegated the event handling to the `p` element. But does it work?\n+\n+Let's generate a few extra `span` elements and see:\n+\n+```html\n+<p>\n+  <span>Click me~!</span>\n+  <span>Click me~!</span>\n+  <span>Click me~!</span>\n+  <span>Click me~!</span>\n+</p>\n+```\n+\n+Now, each time we click on a `span`, that element's text will become red. \n+\n+And just like that, with a single event listener we've properly allowed a `click` event to bubble up from `span` elements to the parent `p`, and delegated the logic for that `click` event to the `p` element.\n+\n+Event propagation and delegation can be a complex topic, especially as you get into heavily nested elements like tables. You are encouraged to explore this further and experiment with some of the code we've written here.\n+\n \n # --questions--\n "
        }
    ],
    "stats": {
        "total": 157,
        "additions": 154,
        "deletions": 3
    }
}