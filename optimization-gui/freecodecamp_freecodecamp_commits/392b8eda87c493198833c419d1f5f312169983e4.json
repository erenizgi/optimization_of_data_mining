{
    "author": "jdwilkin4",
    "message": "feat(curriculum): add dynamic programming review page content (#62269)",
    "sha": "392b8eda87c493198833c419d1f5f312169983e4",
    "files": [
        {
            "sha": "ca9404a3af6e02c9c902328a290ffbf78523c982",
            "filename": "curriculum/challenges/english/blocks/review-dynamic-programming/67f39e2119042d2f2ca926ff.md",
            "status": "modified",
            "additions": 60,
            "deletions": 5,
            "changes": 65,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/392b8eda87c493198833c419d1f5f312169983e4/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Freview-dynamic-programming%2F67f39e2119042d2f2ca926ff.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/392b8eda87c493198833c419d1f5f312169983e4/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Freview-dynamic-programming%2F67f39e2119042d2f2ca926ff.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Freview-dynamic-programming%2F67f39e2119042d2f2ca926ff.md?ref=392b8eda87c493198833c419d1f5f312169983e4",
            "patch": "@@ -7,14 +7,69 @@ dashedName: review-dynamic-programming\n \n # --description--\n \n-## First topic\n+## Introduction to Dynamic Programming\n \n-Describe\n+- **Definition**: Dynamic programming is an algorithmic technique that solves complex problems by breaking them down into simpler subproblems and storing the results to avoid redundant calculations. \n+- **Overlapping Subproblems**: The same smaller problems appear multiple times when solving the larger problem. Instead of recalculating these subproblems repeatedly, we store their solutions.\n+- **Optimal Substructure**: The optimal solution to the problem contains optimal solutions to its subproblems. This means we can build up the best solution by combining the best solutions to smaller parts.\n \n-## Second topic\n+## Dynamic Programming Solutions\n \n-Describe\n+- **Memoization (Top-Down Approach)**: Memoization stores the results of expensive function calls and returns the cached result when the same inputs occur again. \n+\n+```py\n+def climb_stairs_memo(n, memo={}):\n+    \"\"\"Dynamic programming with memoization\"\"\"\n+    # Check if we've already calculated this value\n+    if n in memo:\n+        return memo[n]  # Return cached result - O(1) lookup!\n+    \n+    # Base cases\n+    if n <= 2:\n+        return n\n+    \n+    # Calculate once and store in memo for future use\n+    memo[n] = climb_stairs_memo(n-1, memo) + climb_stairs_memo(n-2, memo)\n+    return memo[n]\n+```\n+\n+- **Tabulation (Bottom-Up Approach)**: Tabulation builds the solution from the ground up, filling a table with solutions to subproblems.\n+\n+```py\n+def climb_stairs_tabulation(n):\n+    \"\"\"Dynamic programming with tabulation\"\"\"\n+    if n <= 2:\n+        return n\n+    \n+    # Create array to store results for all steps from 0 to n\n+    dp = [0] * (n + 1)\n+    dp[1] = 1  # 1 way to reach step 1\n+    dp[2] = 2  # 2 ways to reach step 2\n+    \n+    # Build up the solution iteratively\n+    for i in range(3, n + 1):\n+        # Ways to reach step i = ways to reach (i-1) + ways to reach (i-2)\n+        dp[i] = dp[i-1] + dp[i-2]\n+    \n+    return dp[n]\n+```\n+\n+## Real-World Applications Using Dynamic Programming\n+\n+- **Route Optimization**: GPS systems use dynamic programming algorithms to find shortest paths between locations.\n+- **Text Processing**: Spell checkers and autocomplete features often rely on dynamic programming to calculate edit distances between words.\n+- **Financial Modeling**: Investment strategies and portfolio optimization frequently employ dynamic programming techniques.\n+- **Resource Allocation**: The knapsack problem and its variants appear in scheduling, budgeting, and resource management.\n+\n+## When to Use Dynamic Programming\n+\n+You should consider using dynamic programming in the following scenarios:\n+\n+- The problem can be broken down into overlapping subproblems.\n+- The problem exhibits optimal substructure.\n+- A naive recursive solution would involve repeated calculations.\n+- You need to optimize for time complexity at the cost of space complexity.\n \n # --assignment--\n \n-Review the Dynamic Programming topics and concepts.\n+Review Dynamic Programming topics and concepts."
        }
    ],
    "stats": {
        "total": 65,
        "additions": 60,
        "deletions": 5
    }
}