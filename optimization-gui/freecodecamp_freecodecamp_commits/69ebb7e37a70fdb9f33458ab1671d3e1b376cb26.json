{
    "author": "majestic-owl448",
    "message": "feat: add bash scripting review (#61466)\n\nCo-authored-by: Zaira <33151350+zairahira@users.noreply.github.com>",
    "sha": "69ebb7e37a70fdb9f33458ab1671d3e1b376cb26",
    "files": [
        {
            "sha": "af070be047a47d24a22390a45584aedf936d7671",
            "filename": "curriculum/challenges/english/25-front-end-development/review-bash-scripting/6724e417419c2f211bb41bfc.md",
            "status": "modified",
            "additions": 702,
            "deletions": 1,
            "changes": 703,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/69ebb7e37a70fdb9f33458ab1671d3e1b376cb26/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Freview-bash-scripting%2F6724e417419c2f211bb41bfc.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/69ebb7e37a70fdb9f33458ab1671d3e1b376cb26/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Freview-bash-scripting%2F6724e417419c2f211bb41bfc.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Freview-bash-scripting%2F6724e417419c2f211bb41bfc.md?ref=69ebb7e37a70fdb9f33458ab1671d3e1b376cb26",
            "patch": "@@ -7,7 +7,708 @@ dashedName: review-bash-scripting\n \n # --description--\n \n-Description placeholder\n+## Bash Scripting Basics\n+\n+- **Bash scripting**: Writing a sequence of Bash commands in a file, which you can then execute with Bash to run the contents of the file.\n+- **Shebang**: The commented line at the beginning of a script (e.g., `#!/bin/bash`) that indicates what interpreter should be used for the script.\n+\n+  ```bash\n+  #!/bin/bash\n+  ```\n+\n+- **Variable assignment**: Instantiate variables using the syntax `variable_name=value`.\n+\n+  ```bash\n+  servers=(\"prod\" \"dev\")\n+  ```\n+\n+- **Variable creation rules**: Create variables with `VARIABLE_NAME=VALUE` syntax. No spaces are allowed around the equal sign (`=`). Use double quotes if the value contains spaces.\n+\n+  ```bash\n+  NAME=John\n+  MESSAGE=\"Hello World\"\n+  COUNT=5\n+  TEXT=\"The next number is, \"\n+  ```\n+\n+- **Variable usage**: Access variable values by placing `$` in front of the variable name.\n+\n+  ```bash\n+  echo $NAME\n+  echo \"The message is: $MESSAGE\"\n+  ```\n+\n+- **Variable interpolation**: Use `$variable_name` to access the value of a variable within strings and commands.\n+\n+  ```bash\n+  TEXT=\"The next number is, \"\n+  NUMBER=42\n+  echo $TEXT B:$NUMBER\n+  echo $TEXT I:$NUMBER\n+  \n+  echo \"Pulling $server\"\n+  rsync --archive --verbose $server:/etc/nginx/conf.d/server.conf configs/$server.conf\n+  ```\n+\n+- **Variable scope**: Shell scripts run from top to bottom, so variables can only be used below where they are created.\n+\n+  ```bash\n+  NAME=\"Alice\"\n+  echo $NAME\n+  ```\n+\n+- **User input**: Use `read` to accept input from users and store it in a variable.\n+\n+  ```bash\n+  read USERNAME\n+  echo \"Hello $USERNAME\"\n+  ```\n+\n+- **Comments**: Add comments to your scripts using `#` followed by your comment text.\n+  - Single-line comments start with `#` and continue to the end of the line\n+  - Comments are ignored by the shell and don't affect script execution\n+\n+  ```bash\n+  # This is a single-line comment\n+  NAME=\"John\"  # Comment at end of line\n+  ```\n+\n+- **Multi-line comments**: Comment out blocks of code using colon and quotes.\n+\n+  ```bash\n+  : '\n+  This is a multi-line comment\n+  Everything between the quotes is ignored\n+  Useful for debugging or documentation\n+  '\n+  ```\n+\n+- **Built-in commands and help**: \n+  - Use `help` to see a list of built-in bash commands\n+  - Use `help <command>` to get information about specific built-in commands\n+  - Some commands (like `if`) are built-ins and don't have man pages\n+  - Built-in commands are executed directly by the shell rather than as external programs\n+  - Use `help function` to see information about creating functions\n+\n+  ```bash\n+  help\n+  help if\n+  help function\n+  ```\n+\n+- **Finding command locations**: Use `which` to locate where executables are installed.\n+  - Shows the full path to executable files\n+  - Useful for finding interpreter locations (like bash)\n+  - Helps verify which version of a command will be executed\n+\n+  ```bash\n+  which bash\n+  which python\n+  which ls\n+  ```\n+\n+- **Manual pages**: Use `man` to access detailed documentation for commands.\n+  - Provides comprehensive information about command usage\n+  - Shows all available options and examples\n+  - Use arrow keys to navigate, 'q' to quit\n+  - Not all commands have manual pages (built-ins use `help` instead)\n+\n+  ```bash\n+  man echo\n+  man ls\n+  man bash\n+  ```\n+\n+- **Help flags**: Many commands support `--help` for quick help information.\n+  - Alternative to manual pages for quick reference\n+  - Shows command syntax and common options\n+  - Not all commands support this flag (some may show error)\n+\n+  ```bash\n+  ls --help\n+  chmod --help\n+  mv --help\n+  ```\n+\n+- **Echo command options**: The `echo` command supports various options:\n+  - `-e` option enables interpretation of backslash escapes\n+  - `\\n` creates a new line\n+  - Empty lines are only printed when values are enclosed in quotes\n+  - Useful for creating formatted output and program titles\n+\n+  ```bash\n+  echo -e \"Line 1\\nLine 2\"\n+  echo \"\"\n+  echo -e \"\\n~~ Program Title ~~\\n\"\n+  echo \"Line 1\\nLine 2\"\n+  ```\n+\n+- **Script arguments**: Programs can accept arguments that are accessible using `$` variables.\n+  - `$*` prints all arguments passed to the script\n+  - `$@` prints all arguments passed to the script as separate quoted strings\n+  - `$<number>` accesses specific arguments by position (e.g., `$1`, `$2`, `$3`)\n+\n+  ```bash\n+  echo $*\n+  echo $@\n+  echo $1\n+  echo $2\n+  ```\n+\n+## Double Bracket Expressions `[[ ]]`\n+\n+- **Double bracket syntax**: Use `[[ ]]` for conditional testing and pattern matching.\n+  - Must have spaces inside the brackets and around operators\n+  - Returns exit status 0 (true) or 1 (false) based on the test result\n+\n+  ```bash\n+  [[ $variable == \"value\" ]]\n+  [[ $number -gt 10 ]]\n+  [[ -f filename.txt ]]\n+  ```\n+\n+- **String comparison operators**: Compare strings using various operators within `[[ ]]`.\n+  - `==` (equal): Tests if two strings are identical\n+  - `!=` (not equal): Tests if two strings are different\n+  - `<` (lexicographically less): String comparison in alphabetical order\n+  - `>` (lexicographically greater): String comparison in alphabetical order\n+\n+  ```bash\n+  [[ \"apple\" == \"apple\" ]]\n+  [[ \"apple\" != \"orange\" ]]\n+  [[ \"apple\" < \"banana\" ]]\n+  [[ \"zebra\" > \"apple\" ]]\n+  ```\n+\n+- **Numeric comparison operators**: Compare numbers using specific numeric operators.\n+  - `-eq` (equal): Numeric equality comparison\n+  - `-ne` (not equal): Numeric inequality comparison\n+  - `-lt` (less than): Numeric less than comparison\n+  - `-le` (less than or equal): Numeric less than or equal comparison\n+  - `-gt` (greater than): Numeric greater than comparison\n+  - `-ge` (greater than or equal): Numeric greater than or equal comparison\n+\n+  ```bash\n+  [[ $number -eq 5 ]]\n+  [[ $count -ne 0 ]]\n+  [[ $age -ge 18 ]]\n+  [[ $score -lt 100 ]]\n+  ```\n+\n+- **Logical operators**: Combine multiple conditions using logical operators.\n+  - `&&` (and): Both conditions must be true\n+  - `||` (or): At least one condition must be true\n+  - `!` (not): Negates the condition (makes true false, false true)\n+\n+  ```bash\n+  [[ $age -ge 18 && $age -le 65 ]]\n+  [[ $name == \"John\" || $name == \"Jane\" ]]\n+  [[ ! -f missing_file.txt ]]\n+  ```\n+\n+- **File test operators**: Test file properties and existence.\n+  - `-e file`: True if file exists\n+  - `-f file`: True if file exists and is a regular file\n+  - `-d file`: True if file exists and is a directory\n+  - `-r file`: True if file exists and is readable\n+  - `-w file`: True if file exists and is writable\n+  - `-x file`: True if file exists and is executable\n+  - `-s file`: True if file exists and has size greater than zero\n+\n+  ```bash\n+  [[ -e /path/to/file ]]\n+  [[ -f script.sh ]]\n+  [[ -d /home/user ]]\n+  [[ -x program ]]\n+  ```\n+\n+- **Pattern matching with `=~`**: Use regular expressions for advanced pattern matching.\n+  - `=~` operator enables regex pattern matching\n+  - Pattern should not be quoted when using regex metacharacters\n+  - Supports full regular expression syntax\n+  - Case-sensitive by default\n+\n+  ```bash\n+  [[ \"hello123\" =~ [0-9]+ ]]\n+  [[ \"email@domain.com\" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$ ]]\n+  [[ \"filename.txt\" =~ \\.txt$ ]]\n+  ```\n+\n+- **Variable existence testing**: Check if variables are set or empty.\n+  - Test if variable is empty: `[[ ! $variable ]]`\n+\n+  ```bash\n+  [[ ! $undefined_var ]]\n+  ```\n+\n+## Double Parentheses Expressions `(( ))`\n+\n+- **Arithmetic evaluation**: Use `(( ))` for mathematical calculations and numeric comparisons.\n+  - Evaluates arithmetic expressions using C-style syntax\n+  - Variables don't need `$` prefix inside double parentheses\n+  - Returns exit status 0 if result is non-zero, 1 if result is zero\n+  - Supports all standard arithmetic operators\n+\n+  ```bash\n+  (( result = 10 + 5 ))\n+  (( count++ ))\n+  (( total += value ))\n+  ```\n+\n+- **Arithmetic operators**: Mathematical operators available in `(( ))`.\n+  - `+` (addition): Add two numbers\n+  - `-` (subtraction): Subtract second number from first\n+  - `*` (multiplication): Multiply two numbers\n+  - `/` (division): Divide first number by second (integer division)\n+  - `%` (modulus): Remainder after division\n+  - `**` (exponentiation): Raise first number to power of second\n+\n+  ```bash\n+  (( sum = a + b ))\n+  (( diff = x - y ))\n+  (( product = width * height ))\n+  (( remainder = num % 10 ))\n+  (( power = base ** exponent ))\n+  ```\n+\n+- **Assignment operators**: Modify variables using arithmetic assignment operators.\n+  - `=` (assignment): Assign value to variable\n+  - `+=` (add and assign): Add value to variable\n+  - `-=` (subtract and assign): Subtract value from variable\n+  - `*=` (multiply and assign): Multiply variable by value\n+  - `/=` (divide and assign): Divide variable by value\n+  - `%=` (modulus and assign): Set variable to remainder\n+\n+  ```bash\n+  (( counter = 0 ))\n+  (( counter += 5 ))\n+  (( total -= cost ))\n+  (( area *= 2 ))\n+  (( value /= 3 ))\n+  ```\n+\n+- **Increment and decrement operators**: Modify variables by one.\n+  - `++variable` (pre-increment): Increment before use\n+  - `variable++` (post-increment): Increment after use\n+  - `--variable` (pre-decrement): Decrement before use\n+  - `variable--` (post-decrement): Decrement after use\n+\n+  ```bash\n+  (( ++counter ))\n+  (( index++ ))\n+  (( --remaining ))\n+  (( attempts-- ))\n+  ```\n+\n+- **Comparison operators**: Compare numbers using arithmetic comparison.\n+  - `==` (equal): Numbers are equal\n+  - `!=` (not equal): Numbers are not equal\n+  - `<` (less than): First number is less than second\n+  - `<=` (less than or equal): First number is less than or equal to second\n+  - `>` (greater than): First number is greater than second\n+  - `>=` (greater than or equal): First number is greater than or equal to second\n+\n+  ```bash\n+  (( age >= 18 ))\n+  (( score < 100 ))\n+  (( count == 0 ))\n+  (( temperature > freezing ))\n+  ```\n+\n+- **Logical operators**: Combine arithmetic conditions.\n+  - `&&` (and): Both conditions must be true\n+  - `||` (or): At least one condition must be true\n+  - `!` (not): Negates the condition\n+\n+  ```bash\n+  (( age >= 18 && age <= 65 ))\n+  (( score >= 90 || extra_credit > 0 ))\n+  (( !(count == 0) ))\n+  ```\n+\n+- **Bitwise operators**: Perform bit-level operations on integers.\n+  - `&` (bitwise AND): AND operation on each bit\n+  - `|` (bitwise OR): OR operation on each bit\n+  - `^` (bitwise XOR): XOR operation on each bit\n+  - `~` (bitwise NOT): Invert all bits\n+  - `<<` (left shift): Shift bits to the left\n+  - `>>` (right shift): Shift bits to the right\n+\n+  ```bash\n+  (( result = a & b ))\n+  (( flags |= new_flag ))\n+  (( shifted = value << 2 ))\n+  ```\n+\n+- **Conditional (ternary) operator**: Use `condition ? true_value : false_value` syntax.\n+  - Provides a concise way to assign values based on conditions\n+  - Similar to the ternary operator in C-style languages\n+  - Evaluates condition and returns one of two values\n+\n+  ```bash\n+  (( result = (score >= 60) ? 1 : 0 ))\n+  (( max = (a > b) ? a : b ))\n+  (( sign = (num >= 0) ? 1 : -1 ))\n+  ```\n+\n+- **Command substitution with arithmetic**: Use `$(( ))` to capture arithmetic results.\n+  - Returns the result of the arithmetic expression as a string\n+  - Can be used in assignments or command arguments\n+  - Useful for calculations that need to be used elsewhere\n+\n+  ```bash\n+  result=$(( 10 + 5 ))\n+  echo \"The answer is $(( a * b ))\"\n+  array_index=$(( RANDOM % array_length ))\n+  ```\n+\n+## Control Flow and Conditionals\n+\n+- **Conditional statements**: Use `if` statements to execute code based on conditions.\n+  - Basic syntax: `if [[ CONDITION ]] then STATEMENTS fi`\n+  - Full syntax: `if [[ CONDITION ]] then STATEMENTS elif [[ CONDITION ]] then STATEMENTS else STATEMENTS fi`\n+  - Can use both `[[ ]]` and `(( ))` expressions for different types of conditions\n+  - **elif (else if)**: Optional, can be repeated multiple times to test additional conditions in sequence\n+  - **else**: Optional, executes when all previous conditions are false\n+  - Can mix double parentheses `(( ... ))` and double brackets `[[ ... ]]` in same conditional chain\n+\n+  ```bash\n+  if (( NUMBER <= 15 ))\n+  then\n+      echo \"B:$NUMBER\"\n+  elif [[ $NUMBER -le 30 ]]\n+  then\n+      echo \"I:$NUMBER\"\n+  elif (( NUMBER < 46 ))\n+  then\n+      echo \"N:$NUMBER\"\n+  elif [[ $NUMBER -lt 61 ]]\n+  then\n+      echo \"G:$NUMBER\"\n+  else\n+      echo \"O:$NUMBER\"\n+  fi\n+  ```\n+\n+## Command Execution and Process Control\n+\n+- **Command separation**: Use semicolon (`;`) to run multiple commands on a single line.\n+  - Commands execute sequentially from left to right\n+  - Each command's exit status can be checked individually\n+\n+  ```bash\n+  [[ 4 -ge 5 ]]; echo $?\n+  ls -l; echo \"Done\"\n+  ```\n+\n+- **Exit status**: Every command has an exit status that indicates success or failure.\n+  - Access exit status of the last command with `$?`\n+  - Exit status `0` means success (true/no errors)\n+  - Any non-zero exit status means failure (false/errors occurred)\n+  - Common error codes: `127` (command not found), `1` (general error)\n+\n+  ```bash\n+  echo $?\n+  [[ 4 -le 5 ]]; echo $?\n+  ls; echo $?\n+  bad_command; echo $?\n+  ```\n+\n+- **Subshells and command substitution**: Different uses of parentheses for execution contexts.\n+  - Single parentheses `( ... )` create a subshell\n+  - `$( ... )` performs command substitution\n+  - Subshells run in separate environments and don't affect parent shell variables\n+\n+  ```bash\n+  ( cd /tmp; echo \"Current dir: $(pwd)\" )\n+  current_date=$(date)\n+  file_count=$(ls | wc -l)\n+  echo \"Today is $current_date\"\n+  echo \"Found $file_count files\"\n+  ```\n+\n+- **Sleep command**: Pause script execution for a specified number of seconds.\n+  - Useful for creating delays in scripts\n+  - Can be used with decimal values for subsecond delays\n+\n+  ```bash\n+  sleep 3\n+  sleep 0.5\n+  sleep 1\n+  ```\n+\n+## Loops\n+\n+- **While loops**: Execute code repeatedly while a condition is true.\n+  - Syntax: `while [[ CONDITION ]] do STATEMENTS done`\n+\n+  ```bash\n+  I=5\n+  while [[ $I -ge 0 ]]\n+  do\n+      echo $I\n+      (( I-- ))\n+      sleep 1\n+  done\n+  ```\n+\n+- **Until loops**: Execute code repeatedly until a condition becomes true.\n+  - Syntax: `until [[ CONDITION ]] do STATEMENTS done`\n+\n+  ```bash\n+  until [[ $QUESTION =~ \\?$ ]]\n+  do\n+      echo \"Please enter a question ending with ?\"\n+      read QUESTION\n+  done\n+  until [[ $QUESTION =~ \\?$ ]]\n+  do\n+      GET_FORTUNE again\n+  done\n+  ```\n+\n+- **For loops**: Iterate through arrays or lists using `for` loops with `do` and `done` to define the loop's logical block.\n+\n+  ```bash\n+  for server in \"${servers[@]}\"\n+  do\n+      echo \"Processing $server\"\n+  done\n+  for (( i = 1; i <= 5; i++ ))\n+  do\n+      echo \"Number: $i\"\n+  done\n+  for (( i = 5; i >= 1; i-- ))\n+  do\n+      echo \"Countdown: $i\"\n+  done\n+  for i in {1..5}\n+  do\n+      echo \"Count: $i\"\n+  done\n+  ```\n+\n+## Arrays\n+\n+- **Arrays**: Store multiple values in a single variable.\n+  - Create arrays with parentheses: `ARRAY=(\"value1\" \"value2\" \"value3\")`\n+  - Access elements by index: `${ARRAY[0]}`, `${ARRAY[1]}`\n+  - Access all elements: `${ARRAY[@]}` or `${ARRAY[*]}`\n+  - Array indexing starts at 0\n+\n+  ```bash\n+  RESPONSES=(\"Yes\" \"No\" \"Maybe\" \"Ask again later\")\n+  echo ${RESPONSES[0]}\n+  echo ${RESPONSES[1]}\n+  echo ${RESPONSES[5]}\n+  echo ${RESPONSES[@]}\n+  echo ${RESPONSES[*]}\n+  ```\n+\n+- **Array inspection with declare**: Use `declare -p` to view array details.\n+  - Shows the array type with `-a` flag\n+  - Displays all array elements and their structure\n+\n+  ```bash\n+  ARR=(\"a\" \"b\" \"c\")\n+  declare -p ARR # ARR=([0]=\"a\" [1]=\"b\" [2]=\"c\")\n+  ```\n+\n+- **Array expansion**: Use `\"${array_name[@]}\"` syntax to expand an array into individual elements.\n+\n+```bash\n+for server in \"${servers[@]}\"\n+```\n+\n+## Functions\n+\n+- **Functions**: Create reusable blocks of code.\n+  - Define with `FUNCTION_NAME() { STATEMENTS }`\n+  - Call by using the function name\n+  - Can accept arguments accessible as `$1`, `$2`, etc.\n+\n+  ```bash\n+  GET_FORTUNE() {\n+      echo \"Ask a question:\"\n+      read QUESTION\n+  }\n+  GET_FORTUNE\n+  ```\n+\n+- **Function arguments**: Functions can accept arguments just like scripts.\n+  - Arguments are passed when calling the function\n+  - Access arguments inside function using `$1`, `$2`, etc.\n+  - Use conditional logic to handle different arguments\n+\n+  ```bash\n+  GET_FORTUNE() {\n+      if [[ ! $1 ]]\n+      then\n+          echo \"Ask a yes or no question:\"\n+      else\n+          echo \"Try again. Make sure it ends with a question mark:\"\n+      fi\n+      read QUESTION\n+  }\n+  GET_FORTUNE\n+  GET_FORTUNE again\n+  ```\n+\n+## Random Numbers and Mathematical Operations\n+\n+- **Random numbers**: Generate random values using the `$RANDOM` variable.\n+  - `$RANDOM` generates numbers between 0 and 32767\n+  - Use modulus operator to limit range: `$RANDOM % 75`\n+  - Add 1 to avoid zero: `$(( RANDOM % 75 + 1 ))`\n+  - Must use `$(( ... ))` syntax for calculations with `$RANDOM`\n+\n+  ```bash\n+  NUMBER=$(( RANDOM % 6 ))\n+  DICE=$(( RANDOM % 6 + 1 ))\n+  BINGO=$(( RANDOM % 75 + 1 ))\n+  echo $(( RANDOM % 10 ))\n+  ```\n+\n+- **Random array access**: Use random numbers to access array elements randomly.\n+  - Generate random index within array bounds\n+  - Use random index to access array elements\n+  - Useful for random selections from predefined options\n+\n+  ```bash\n+  RESPONSES=(\"Yes\" \"No\" \"Maybe\" \"Outlook good\" \"Don't count on it\" \"Ask again later\")\n+  N=$(( RANDOM % 6 ))\n+  echo ${RESPONSES[$N]}\n+  ```\n+\n+- **Modulus operator**: Use `%` to get the remainder of division operations.\n+  - Essential for limiting random number ranges\n+  - Works with `$RANDOM` to create bounded random values\n+  - `RANDOM % n` gives numbers from 0 to n-1\n+\n+  ```bash\n+  echo $(( 15 % 4 ))\n+  echo $(( RANDOM % 100 ))\n+  echo $(( RANDOM % 10 + 1 ))\n+  ```\n+\n+## Environment and System Information\n+\n+- **Environment variables**: Predefined variables available in the shell environment.\n+  - `$RANDOM`: Generates random numbers between 0 and 32767\n+  - `$LANG`: System language setting\n+  - `$HOME`: User's home directory path\n+  - `$PATH`: Directories searched for executable commands\n+  - View all with `printenv` or `declare -p`\n+\n+  ```bash\n+  echo $RANDOM\n+  echo $HOME\n+  echo $LANG\n+  printenv\n+  ```\n+\n+- **Variable inspection**: Use `declare` to view and work with variables.\n+  - `declare -p`: Print all variables and their values\n+  - `declare -p VARIABLE`: Print specific variable details\n+  - Shows variable type (string, array, etc.) and attributes\n+\n+  ```bash\n+  declare -p\n+  declare -p RANDOM\n+  declare -p MY_ARRAY\n+  ```\n+\n+- **Command types**: Different categories of commands available in bash.\n+  - **Built-in commands**: Executed directly by the shell (e.g., `echo`, `read`, `if`)\n+  - **External commands**: Binary files in system directories (e.g., `ls`, `sleep`, `bash`)\n+  - **Shell keywords**: Language constructs (e.g., `then`, `do`, `done`)\n+  - Use `type <command>` to see what type a command is\n+\n+  ```bash\n+  type echo\n+  type ls\n+  type if\n+  type ./script.sh\n+  ```\n+\n+## File Creation and Management\n+\n+- **File creation**: Use `touch` to create new empty files.\n+  - Creates a new file if it doesn't exist\n+  - Updates the timestamp if the file already exists\n+  - Commonly used to create script files before editing\n+\n+  ```bash\n+  touch script.sh\n+  touch bingo.sh\n+  touch filename.txt\n+  ```\n+\n+## Creating and Running Bash Scripts\n+\n+- **Script execution methods**: Multiple ways to run bash scripts:\n+  - **`sh scriptname.sh`**: Run with the sh shell interpreter.\n+  - **`bash scriptname.sh`**: Run with the bash shell interpreter.\n+  - **`./scriptname.sh`**: Execute directly (requires executable permissions).\n+\n+```bash\n+sh questionnaire.sh\n+bash questionnaire.sh\n+./questionnaire.sh\n+```\n+\n+## File Permissions and Script Execution\n+\n+- **Permission denied error**: When using `./scriptname.sh`, you may get \"permission denied\" if the file lacks executable permissions.\n+- **Checking permissions**: Use `ls -l` to view file permissions.\n+\n+  ```bash\n+  ls -l questionnaire.sh\n+  ```\n+\n+- **Permission format**: The output shows permissions as `-rw-r--r--` where:\n+  - First character (`-`): File type (- for regular file, d for directory)\n+  - Next 9 characters: Permissions for owner, group, and others\n+  - `r` = read, `w` = write, `x` = execute\n+  \n+- **Adding executable permissions**: Use `chmod +x` to give executable permissions to everyone.\n+\n+  ```bash\n+  chmod +x questionnaire.sh\n+  ```\n+\n+- **Script organization**: Best practices for structuring bash scripts.\n+  - Start with shebang (`#!/bin/bash`)\n+  - Add descriptive comments about script purpose\n+  - Define variables at the top\n+  - Group related functions together\n+  - Main script logic at the bottom\n+\n+  ```bash\n+  #!/bin/bash\n+  NAME=\"value\"\n+  ARRAY=(\"item1\" \"item2\")\n+  my_function() {\n+      echo \"Function code here\"\n+  }\n+  my_function\n+  echo \"Script complete\"\n+  ```\n+\n+- **Sequential script execution**: Create master scripts that run multiple programs in sequence.\n+  - Useful for automating workflows that involve multiple scripts\n+  - Each script runs to completion before the next one starts\n+  - Can combine different programs into a single execution flow\n+  - Arguments can be passed to individual scripts as needed\n+  - Can include different types of programs (interactive, automated, etc.)\n+\n+  ```bash\n+  #!/bin/bash\n+  ./setup.sh\n+  ./interactive.sh\n+  ./processing.sh\n+  ./cleanup.sh\n+  ```\n \n # --assignment--\n "
        }
    ],
    "stats": {
        "total": 703,
        "additions": 702,
        "deletions": 1
    }
}