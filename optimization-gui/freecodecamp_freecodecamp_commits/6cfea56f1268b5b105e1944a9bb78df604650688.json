{
    "author": "Dario-DC",
    "message": "feat(curriculum/python): add vector space project to python curriculum (#54140)\n\nCo-authored-by: Ilenia M <nethleen@gmail.com>\r\nCo-authored-by: Zaira <33151350+zairahira@users.noreply.github.com>\r\nCo-authored-by: Ilenia <26656284+ilenia-magoni@users.noreply.github.com>\r\nCo-authored-by: Krzysztof G. <60067306+gikf@users.noreply.github.com>",
    "sha": "6cfea56f1268b5b105e1944a9bb78df604650688",
    "files": [
        {
            "sha": "10ce42899732fad716cbec35ff37efba4ba2a50c",
            "filename": "client/i18n/locales/english/intro.json",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -881,6 +881,13 @@\n           \"This is one of the required projects to claim your certification.\"\n         ]\n       },\n+      \"learn-special-methods-by-building-a-vector-space\": {\n+        \"title\": \"Learn Special Methods by Building a Vector Space\",\n+        \"intro\": [\n+          \"Python special methods are called in response to specific operations and enable you to customize the behaviour of your objects in a detailed and effective way.\",\n+          \"In this project, you are going to explore some of the most common special methods while learning about vectors by building a vector space.\"\n+        ]\n+      },\n       \"learn-encapsulation-by-building-a-projectile-trajectory-calculator\": {\n         \"title\": \"Learn Encapsulation by Building a Projectile Trajectory Calculator\",\n         \"intro\": ["
        },
        {
            "sha": "ab6aa16e6cf808fcf7e4d7963cf4c7c3cf98fa0b",
            "filename": "client/src/pages/learn/scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/index.md",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/client%2Fsrc%2Fpages%2Flearn%2Fscientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2Findex.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/client%2Fsrc%2Fpages%2Flearn%2Fscientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2Findex.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Fpages%2Flearn%2Fscientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2Findex.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,9 @@\n+---\n+title: Introduction to the Learn Special Methods by Building a Vector Space\n+block: learn-special-methods-by-building-a-vector-space\n+superBlock: scientific-computing-with-python\n+---\n+\n+## Introduction to the Learn Special Methods by Building a Vector Space\n+\n+This is a test for the new project-based curriculum."
        },
        {
            "sha": "be564ad91bf1df7a8694787dfd8398a8c1fbd662",
            "filename": "curriculum/challenges/_meta/build-a-polygon-area-calculator-project/meta.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2F_meta%2Fbuild-a-polygon-area-calculator-project%2Fmeta.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2F_meta%2Fbuild-a-polygon-area-calculator-project%2Fmeta.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2F_meta%2Fbuild-a-polygon-area-calculator-project%2Fmeta.json?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -3,7 +3,7 @@\n   \"isUpcomingChange\": false,\n   \"usesMultifileEditor\": true,\n   \"dashedName\": \"build-a-polygon-area-calculator-project\",\n-  \"order\": 14,\n+  \"order\": 15,\n   \"superBlock\": \"scientific-computing-with-python\",\n   \"challengeOrder\": [\n     {"
        },
        {
            "sha": "1d216be2e70197e198aa29260441101cdc1a08eb",
            "filename": "curriculum/challenges/_meta/build-a-probability-calculator-project/meta.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2F_meta%2Fbuild-a-probability-calculator-project%2Fmeta.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2F_meta%2Fbuild-a-probability-calculator-project%2Fmeta.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2F_meta%2Fbuild-a-probability-calculator-project%2Fmeta.json?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -3,7 +3,7 @@\n   \"isUpcomingChange\": false,\n   \"usesMultifileEditor\": true,\n   \"dashedName\": \"build-a-probability-calculator-project\",\n-  \"order\": 16,\n+  \"order\": 17,\n   \"superBlock\": \"scientific-computing-with-python\",\n   \"challengeOrder\": [\n     {"
        },
        {
            "sha": "0b510f740c3d224aa4b05dc42da7ca162181b63b",
            "filename": "curriculum/challenges/_meta/learn-encapsulation-by-building-a-projectile-trajectory-calculator/meta.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2F_meta%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2Fmeta.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2F_meta%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2Fmeta.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2F_meta%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2Fmeta.json?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -4,7 +4,7 @@\n   \"usesMultifileEditor\": true,\n   \"hasEditableBoundaries\": true,\n   \"dashedName\": \"learn-encapsulation-by-building-a-projectile-trajectory-calculator\",\n-  \"order\": 15,\n+  \"order\": 16,\n   \"superBlock\": \"scientific-computing-with-python\",\n   \"challengeOrder\": [\n     {"
        },
        {
            "sha": "f979f351705f8e8c604832f718052237001a8e87",
            "filename": "curriculum/challenges/_meta/learn-special-methods-by-building-a-vector-space/meta.json",
            "status": "added",
            "additions": 320,
            "deletions": 0,
            "changes": 320,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2F_meta%2Flearn-special-methods-by-building-a-vector-space%2Fmeta.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2F_meta%2Flearn-special-methods-by-building-a-vector-space%2Fmeta.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2F_meta%2Flearn-special-methods-by-building-a-vector-space%2Fmeta.json?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,320 @@\n+{\n+  \"name\": \"Learn Special Methods by Building a Vector Space\",\n+  \"isUpcomingChange\": false,\n+  \"usesMultifileEditor\": true,\n+  \"hasEditableBoundaries\": true,\n+  \"dashedName\": \"learn-special-methods-by-building-a-vector-space\",\n+  \"order\": 14,\n+  \"superBlock\": \"scientific-computing-with-python\",\n+  \"challengeOrder\": [\n+    {\n+      \"id\": \"65f01969115f933073b6be03\",\n+      \"title\": \"Step 1\"\n+    },\n+    {\n+      \"id\": \"65f03d9f92eac9183a4d3281\",\n+      \"title\": \"Step 2\"\n+    },\n+    {\n+      \"id\": \"65f055b9190fc41ca35549b8\",\n+      \"title\": \"Step 3\"\n+    },\n+    {\n+      \"id\": \"65f056a405239e1dc4cc2854\",\n+      \"title\": \"Step 4\"\n+    },\n+    {\n+      \"id\": \"65f058e06f34fd1f0ee6e55d\",\n+      \"title\": \"Step 5\"\n+    },\n+    {\n+      \"id\": \"65f0694fb2296f3caadf8347\",\n+      \"title\": \"Step 6\"\n+    },\n+    {\n+      \"id\": \"65f06a8e5a57673d700c79c3\",\n+      \"title\": \"Step 7\"\n+    },\n+    {\n+      \"id\": \"65f07c9b1ffb814d856dcffc\",\n+      \"title\": \"Step 8\"\n+    },\n+    {\n+      \"id\": \"65f3fa097f26b510db6c710b\",\n+      \"title\": \"Step 9\"\n+    },\n+    {\n+      \"id\": \"65f3fa60a93b84110b3f1708\",\n+      \"title\": \"Step 10\"\n+    },\n+    {\n+      \"id\": \"65f3fe07cc763212efe91285\",\n+      \"title\": \"Step 11\"\n+    },\n+    {\n+      \"id\": \"65f40051d6b09a139f253e8e\",\n+      \"title\": \"Step 12\"\n+    },\n+    {\n+      \"id\": \"65f40401e6ef53173c04e27d\",\n+      \"title\": \"Step 13\"\n+    },\n+    {\n+      \"id\": \"65f407ea37ad6e181b90462e\",\n+      \"title\": \"Step 14\"\n+    },\n+    {\n+      \"id\": \"65f40f8af784751c613d638a\",\n+      \"title\": \"Step 15\"\n+    },\n+    {\n+      \"id\": \"65f40fdb3579aa1ced28b2eb\",\n+      \"title\": \"Step 16\"\n+    },\n+    {\n+      \"id\": \"65f412c208c3791fee305acf\",\n+      \"title\": \"Step 17\"\n+    },\n+    {\n+      \"id\": \"65f4148dea0f802040225e0c\",\n+      \"title\": \"Step 18\"\n+    },\n+    {\n+      \"id\": \"65f4520e363e2642f8112e33\",\n+      \"title\": \"Step 19\"\n+    },\n+    {\n+      \"id\": \"65f4535bbdb28d436ff3ddc9\",\n+      \"title\": \"Step 20\"\n+    },\n+    {\n+      \"id\": \"65f870003444fb1a2ad171f2\",\n+      \"title\": \"Step 21\"\n+    },\n+    {\n+      \"id\": \"66680ddfd0f8c76782923cb0\",\n+      \"title\": \"Step 22\"\n+    },\n+    {\n+      \"id\": \"65f8709620b2ce1a62608f5a\",\n+      \"title\": \"Step 23\"\n+    },\n+    {\n+      \"id\": \"65f8720685ec351abef26740\",\n+      \"title\": \"Step 24\"\n+    },\n+    {\n+      \"id\": \"65f872a0fe6aa21b456ad4fe\",\n+      \"title\": \"Step 25\"\n+    },\n+    {\n+      \"id\": \"6659875502b6d7765498f324\",\n+      \"title\": \"Step 26\"\n+    },\n+    {\n+      \"id\": \"65f8749b13774b1d2e4a7fba\",\n+      \"title\": \"Step 27\"\n+    },\n+    {\n+      \"id\": \"65f876d17832001e8e1abb05\",\n+      \"title\": \"Step 28\"\n+    },\n+    {\n+      \"id\": \"65f93acbb514857003510e79\",\n+      \"title\": \"Step 29\"\n+    },\n+    {\n+      \"id\": \"65f93b67169a9c703264458a\",\n+      \"title\": \"Step 30\"\n+    },\n+    {\n+      \"id\": \"65f93d4647ce2670dc6f095c\",\n+      \"title\": \"Step 31\"\n+    },\n+    {\n+      \"id\": \"65f93e54a9121571dcdd3e79\",\n+      \"title\": \"Step 32\"\n+    },\n+    {\n+      \"id\": \"66682150151af29efec9727d\",\n+      \"title\": \"Step 33\"\n+    },\n+    {\n+      \"id\": \"666826f258fda1ab3396a509\",\n+      \"title\": \"Step 34\"\n+    },\n+    {\n+      \"id\": \"666827a6fd0dbaafe8330ea6\",\n+      \"title\": \"Step 35\"\n+    },\n+    {\n+      \"id\": \"666832e427d70bc5219dc62a\",\n+      \"title\": \"Step 36\"\n+    },\n+    {\n+      \"id\": \"6668374ed18b7fce10259cb3\",\n+      \"title\": \"Step 37\"\n+    },\n+    {\n+      \"id\": \"65f9b17a638f0d0dcce8c354\",\n+      \"title\": \"Step 38\"\n+    },\n+    {\n+      \"id\": \"65f9b486989cb90ff3e77ac8\",\n+      \"title\": \"Step 39\"\n+    },\n+    {\n+      \"id\": \"65f9b9710cca621244d3bde1\",\n+      \"title\": \"Step 40\"\n+    },\n+    {\n+      \"id\": \"65f9bb7c0d524612b2a88a4b\",\n+      \"title\": \"Step 41\"\n+    },\n+    {\n+      \"id\": \"65f9bc10a9fb1612e066e9e8\",\n+      \"title\": \"Step 42\"\n+    },\n+    {\n+      \"id\": \"65f9c2c2006feb1428ad2d4c\",\n+      \"title\": \"Step 43\"\n+    },\n+    {\n+      \"id\": \"65f9cb678070ca1668898c70\",\n+      \"title\": \"Step 44\"\n+    },\n+    {\n+      \"id\": \"65f9dd6e5a08af19c196c2df\",\n+      \"title\": \"Step 45\"\n+    },\n+    {\n+      \"id\": \"65f9dfd2e75e291a38695f13\",\n+      \"title\": \"Step 46\"\n+    },\n+    {\n+      \"id\": \"65f9e0a578b22c1a736f3d82\",\n+      \"title\": \"Step 47\"\n+    },\n+    {\n+      \"id\": \"65fa8d5cf0ef3b141010f5d8\",\n+      \"title\": \"Step 48\"\n+    },\n+    {\n+      \"id\": \"65fa8df56a0e2c149b4d24fe\",\n+      \"title\": \"Step 49\"\n+    },\n+    {\n+      \"id\": \"65fa9402d1fb5516aa42159d\",\n+      \"title\": \"Step 50\"\n+    },\n+    {\n+      \"id\": \"65fa9e1b6c6db919385359ec\",\n+      \"title\": \"Step 51\"\n+    },\n+    {\n+      \"id\": \"65faaed8f7a9772f023ea816\",\n+      \"title\": \"Step 52\"\n+    },\n+    {\n+      \"id\": \"65fc87e19930a503e5f05500\",\n+      \"title\": \"Step 53\"\n+    },\n+    {\n+      \"id\": \"65fc899d77495504d6deeccc\",\n+      \"title\": \"Step 54\"\n+    },\n+    {\n+      \"id\": \"65fc8e7c766ab1070213aadb\",\n+      \"title\": \"Step 55\"\n+    },\n+    {\n+      \"id\": \"65fc8fa7e7860407ab479bf0\",\n+      \"title\": \"Step 56\"\n+    },\n+    {\n+      \"id\": \"65fd681b20b7e45f55def415\",\n+      \"title\": \"Step 57\"\n+    },\n+    {\n+      \"id\": \"65fd9250db0d6b8198cf29ef\",\n+      \"title\": \"Step 58\"\n+    },\n+    {\n+      \"id\": \"65fd95c23beef982af29004c\",\n+      \"title\": \"Step 59\"\n+    },\n+    {\n+      \"id\": \"65fd97f3c1b4c4839bdeb8d2\",\n+      \"title\": \"Step 60\"\n+    },\n+    {\n+      \"id\": \"65fd9aa649f6cc84631882a9\",\n+      \"title\": \"Step 61\"\n+    },\n+    {\n+      \"id\": \"65fd9c6e49d7cd8513ab1005\",\n+      \"title\": \"Step 62\"\n+    },\n+    {\n+      \"id\": \"65fd9d6203afea85931094c9\",\n+      \"title\": \"Step 63\"\n+    },\n+    {\n+      \"id\": \"65fd9e2c56ff19862dfb8cbb\",\n+      \"title\": \"Step 64\"\n+    },\n+    {\n+      \"id\": \"65fdc3c8478ee70fc7966151\",\n+      \"title\": \"Step 65\"\n+    },\n+    {\n+      \"id\": \"65fdc496f4440e1055a2ac1b\",\n+      \"title\": \"Step 66\"\n+    },\n+    {\n+      \"id\": \"6601918b44a11b4a8c986c6a\",\n+      \"title\": \"Step 67\"\n+    },\n+    {\n+      \"id\": \"66019258a7c71d4ae50da42e\",\n+      \"title\": \"Step 68\"\n+    },\n+    {\n+      \"id\": \"66019319edb1cb4b57d3a793\",\n+      \"title\": \"Step 69\"\n+    },\n+    {\n+      \"id\": \"660193a2a71faa4bd8f10970\",\n+      \"title\": \"Step 70\"\n+    },\n+    {\n+      \"id\": \"66019977710caa516276c0a8\",\n+      \"title\": \"Step 71\"\n+    },\n+    {\n+      \"id\": \"6601a7eb860fb8546516674d\",\n+      \"title\": \"Step 72\"\n+    },\n+    {\n+      \"id\": \"6601a88a6e2ccc550d7d7208\",\n+      \"title\": \"Step 73\"\n+    },\n+    {\n+      \"id\": \"6601a8fb2e993b55912f9e9f\",\n+      \"title\": \"Step 74\"\n+    },\n+    {\n+      \"id\": \"6601ab2809898f57591f2f7f\",\n+      \"title\": \"Step 75\"\n+    },\n+    {\n+      \"id\": \"6601ac48a2ee6b59e6a5060d\",\n+      \"title\": \"Step 76\"\n+    },\n+    {\n+      \"id\": \"6601ad0fe415985a5c83f3cc\",\n+      \"title\": \"Step 77\"\n+    }\n+  ],\n+  \"helpCategory\": \"Python\"\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "db5675bd4bd86cb9b469b030dae6f337e198a3d2",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f01969115f933073b6be03.md",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f01969115f933073b6be03.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f01969115f933073b6be03.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f01969115f933073b6be03.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,32 @@\n+---\n+id: 65f01969115f933073b6be03\n+title: Step 1\n+challengeType: 20\n+dashedName: step-1\n+---\n+\n+# --description--\n+\n+A vector is an object that has a length (or magnitude) and a direction and it cannot be expressed by a single number. In physics, vectors are commonly used to represent forces, velocities, accelerations, and other quantities.\n+\n+In this project you are going to build a vector space, a set in which a series of operations is defined between the elements in that set. You'll learn all the details very soon.\n+\n+For now, start the project by declaring an empty class named `Vector`.\n+\n+# --hints--\n+\n+You should declare an empty class named `Vector`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_class(\"Vector\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "1817677637c6ddb5efb273d4a74e06be45d95902",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f03d9f92eac9183a4d3281.md",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f03d9f92eac9183a4d3281.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f03d9f92eac9183a4d3281.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f03d9f92eac9183a4d3281.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,39 @@\n+---\n+id: 65f03d9f92eac9183a4d3281\n+title: Step 2\n+challengeType: 20\n+dashedName: step-2\n+---\n+\n+# --description--\n+\n+A vector can be defined by two coordinates, `x` and `y`, in the Euclidean plane. The distance between the origin of the axes and the point `(x, y)` will be its length, or norm. And the vector direction will point towards `(x, y)`.\n+\n+<img class=\"img-responsive center-block\" alt=\"a 2-dimensional vector of coordinates (2, 3)\" src=\"https://cdn.freecodecamp.org/curriculum/python/2dvector.png\" style=\"background-color: white; height: 350px; width: auto; padding: 15px;\">\n+\n+Within the `Vector` class, create an `__init__` method and give it three parameters, `self`, `x`, and `y`.\n+\n+# --hints--\n+\n+You should define an `__init__` method inside the `Vector` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Vector\").has_function(\"__init__\")`)) })\n+```\n+\n+Your `__init__` method should take three parameters: `self`, `x`, and `y`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Vector\").find_function(\"__init__\").has_args(\"self, x, y\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+class Vector:\n+    pass\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "62ab349a8dbdf573a1d85e1f85bb1bf84bdf2da4",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f055b9190fc41ca35549b8.md",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f055b9190fc41ca35549b8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f055b9190fc41ca35549b8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f055b9190fc41ca35549b8.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,38 @@\n+---\n+id: 65f055b9190fc41ca35549b8\n+title: Step 3\n+challengeType: 20\n+dashedName: step-3\n+---\n+\n+# --description--\n+\n+Python offers various methods that include both a leading and trailing double underscore in their names. You may already be familiar with some, such as `__init__` and `__str__`. These methods, which follow the `__<name>__` naming pattern, are referred to as special methods, magic methods, or *dunder* (which stands for double underscore) methods.\n+\n+Defining special methods in a class affects the behavior of that class. They are called under the hood in specific situations (e.g. `__init__` during instantiation, `__str__` when the object is printed or passed to `str()`). In this project, you are going to learn some of the most commonly used special methods.\n+\n+For now, assign `x` to the `x` attribute of the `Vector` object.\n+\n+# --hints--\n+\n+You should assign `x` to `self.x`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"Vector\").find_function(\"__init__\").has_stmt(\"self.x = x\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+class Vector:\n+    def __init__(self, x, y):\n+        pass\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "85c65bb188fdc7d9235a98e0e02bb268b24186eb",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f056a405239e1dc4cc2854.md",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f056a405239e1dc4cc2854.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f056a405239e1dc4cc2854.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f056a405239e1dc4cc2854.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,34 @@\n+---\n+id: 65f056a405239e1dc4cc2854\n+title: Step 4\n+challengeType: 20\n+dashedName: step-4\n+---\n+\n+# --description--\n+\n+Now, assign `y` to the `y` attribute of the `Vector` object.\n+\n+# --hints--\n+\n+You should assign `y` to `self.y`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"Vector\").find_function(\"__init__\").find_variable(\"self.y\").is_equivalent(\"self.y = y\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+class Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "e249d26b02e8e7e93bdc3a73118b2b1e384290fd",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f058e06f34fd1f0ee6e55d.md",
            "status": "added",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f058e06f34fd1f0ee6e55d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f058e06f34fd1f0ee6e55d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f058e06f34fd1f0ee6e55d.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,45 @@\n+---\n+id: 65f058e06f34fd1f0ee6e55d\n+title: Step 5\n+challengeType: 20\n+dashedName: step-5\n+---\n+\n+# --description--\n+\n+Next, within the `Vector` class, create an empty `norm` method and give it a `self` parameter.\n+\n+# --hints--\n+\n+Your `Vector` class should have a `norm` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"Vector\").has_function(\"norm\")\n+    `))\n+})\n+```\n+\n+Your `norm` method should have a `self` parameter.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"Vector\").find_function(\"norm\").has_args(\"self\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+class Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+        self.y = y\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "c856cf8bcda9fbf374de917d289637c5db76e288",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f0694fb2296f3caadf8347.md",
            "status": "added",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f0694fb2296f3caadf8347.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f0694fb2296f3caadf8347.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f0694fb2296f3caadf8347.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,45 @@\n+---\n+id: 65f0694fb2296f3caadf8347\n+title: Step 6\n+challengeType: 20\n+dashedName: step-6\n+---\n+\n+# --description--\n+\n+The length of a vector $\\mathbf{a}$, or norm, is typically indicated as $\\\\| \\mathbf{a} \\\\|$. It can be calculated as the square root of the sum of its squared components:\n+\\\\[ \\\\| \\mathbf{a} \\\\| = \\sqrt{a_1^2 + a_2^2 + \\ldots + a_n^2}\n+ \\\\]\n+\n+Compute the vector norm and return the result from your `norm` method.\n+\n+# --hints--\n+\n+Your `norm` method should use the provided formula to calculate and return a number representing the norm of the current vector instance. Do not approximate the value.\n+\n+```js\n+({ test: () => runPython(`\n+v1 = Vector(2, 2.5)\n+v2 = Vector(0, -1)\n+v3 = Vector(-5, -0.3)\n+assert v1.norm() == 3.2015621187164243\n+assert v2.norm() == 1\n+assert v3.norm() == 5.008991914547277\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+class Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        pass\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "9a9c87becaa239580f3449d1dc5b1188933f28cd",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f06a8e5a57673d700c79c3.md",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f06a8e5a57673d700c79c3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f06a8e5a57673d700c79c3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f06a8e5a57673d700c79c3.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,38 @@\n+---\n+id: 65f06a8e5a57673d700c79c3\n+title: Step 7\n+challengeType: 20\n+dashedName: step-7\n+---\n+\n+# --description--\n+\n+Outside the `Vector` class, create an instance of `Vector` passing the integers `2` and `3` as the `x` and `y` values and assign it to a variable named `v1`.\n+\n+# --hints--\n+\n+You should declare a variable `v1` and assign it `Vector(2, 3)`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_variable(\"v1\").is_equivalent(\"v1 = Vector(2, 3)\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+class Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "4238c7dcf88f23505dd9a8b2f4b9f894b58c1417",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f07c9b1ffb814d856dcffc.md",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f07c9b1ffb814d856dcffc.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f07c9b1ffb814d856dcffc.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f07c9b1ffb814d856dcffc.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,38 @@\n+---\n+id: 65f07c9b1ffb814d856dcffc\n+title: Step 8\n+challengeType: 20\n+dashedName: step-8\n+---\n+\n+# --description--\n+\n+Test that `norm` works as expected by printing the value returned by the method.\n+\n+# --hints--\n+\n+You should call `norm()` on `v1` and print the result.\n+\n+```js\n+({\n+    test: () => assert(runPython(`_Node(_code).has_call(\"print(v1.norm())\")`))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+class Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+\n+v1 = Vector(2, 3)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "8f02dad7dc5d6db855543c49b2197ca4654a3bc8",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f3fa097f26b510db6c710b.md",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f3fa097f26b510db6c710b.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f3fa097f26b510db6c710b.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f3fa097f26b510db6c710b.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,55 @@\n+---\n+id: 65f3fa097f26b510db6c710b\n+title: Step 9\n+challengeType: 20\n+dashedName: step-9\n+---\n+\n+# --description--\n+\n+Great, `norm` is working as expected. Now, if you try to print `v1`, you'll get the default string representation of an object (something like `<__main__.Vector object at 0x11eb778>`).\n+\n+Inside the `Vector` class, declare an empty `__str__` method to implement a readable string representation. Remember to give it a `self` parameter.\n+\n+Pay attention to not print `v1` until `__str__` returns a string, otherwise you'll get a `TypeError`, because `__str__` must always return a string.\n+\n+# --hints--\n+\n+You should define a `__str__` method within the `Vector` class.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"Vector\").has_function(\"__str__\")\n+    `))\n+})\n+```\n+\n+Your `__str__` method should have a `self` parameter.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"Vector\").find_function(\"__str__\").has_args(\"self\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+class Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+\n+v1 = Vector(2, 3)\n+print(v1.norm())\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "955a0d63ae784c4cf83a210a15f586720c3701dc",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f3fa60a93b84110b3f1708.md",
            "status": "added",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f3fa60a93b84110b3f1708.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f3fa60a93b84110b3f1708.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f3fa60a93b84110b3f1708.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,57 @@\n+---\n+id: 65f3fa60a93b84110b3f1708\n+title: Step 10\n+challengeType: 20\n+dashedName: step-10\n+---\n+\n+# --description--\n+\n+You want to return a meaningful string representation. For example, in the case of `v1`, you want to return a string containing the tuple with the values of the vector components: `(2, 3)`.\n+\n+From the `__str__` method, return a string representing the vector as a tuple containing the vector components in order. Then, go outside the `Vector` class and print `v1` to check the result.\n+\n+# --hints--\n+\n+Your `__str__` method should return a string representing the vector as a tuple containing the vector components in order.\n+\n+```js\n+({ test: () => runPython(`\n+v1 = Vector(2, 3)\n+v2 = Vector(0, 0)\n+v3 = Vector(-2, -3.5)\n+assert str(v1) == '(2, 3)'\n+assert str(v2) == '(0, 0)'\n+assert str(v3) == '(-2, -3.5)'\n+`) })\n+```\n+\n+You should print `v1`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`_Node(_code).has_call(\"print(v1)\")`))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+class Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+        \n+    def __str__(self):\n+        pass\n+\n+v1 = Vector(2, 3)\n+print(v1.norm())\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "06b489a85371d9f66f1392ab0f776d2a3b8eabce",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f3fe07cc763212efe91285.md",
            "status": "added",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f3fe07cc763212efe91285.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f3fe07cc763212efe91285.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f3fe07cc763212efe91285.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,51 @@\n+---\n+id: 65f3fe07cc763212efe91285\n+title: Step 11\n+challengeType: 20\n+dashedName: step-11\n+---\n+\n+# --description--\n+\n+A vector can have a number `n` of dimensions (components). Here's a representation of a 3-dimensional vector:\n+\n+<img class=\"img-responsive center-block\" alt=\"a 3-dimensional vector of coordinates (4, 6, 3)\" src=\"https://cdn.freecodecamp.org/curriculum/python/3dvector.png\" style=\"background-color: white; height: 350px; width: auto; padding: 15px;\">\n+\n+So far, you created a 2-dimensional vector. You want to be able to represent vectors with a different number of dimensions without rewriting the necessary code for each specific case. For that, you will use inheritance.\n+\n+Start by renaming the `Vector` class into `R2Vector` to specify that this class is going to deal with 2-dimensional vectors. Remember to modify the instantiation of `v1`, too.\n+\n+# --hints--\n+\n+You should rename the `Vector` class into `R2Vector`. Remember to modify the instantiation of `v1`, too.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).has_class(\"R2Vector\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+class Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+        \n+    def __str__(self):\n+        return f'{self.x, self.y}'\n+\n+v1 = Vector(2, 3)\n+print(v1.norm())\n+print(v1)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "62b7794dba34b05e2e87daf117f1f21d5d407dd9",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f40051d6b09a139f253e8e.md",
            "status": "added",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f40051d6b09a139f253e8e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f40051d6b09a139f253e8e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f40051d6b09a139f253e8e.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,70 @@\n+---\n+id: 65f40051d6b09a139f253e8e\n+title: Step 12\n+challengeType: 20\n+dashedName: step-12\n+---\n+\n+# --description--\n+\n+Inheritance enables you to define a class from an existing one. The new class, called child, inherits all the methods and properties of the existing class, called parent.\n+\n+```py\n+class Tree:\n+    def sprout(self):\n+        print('Making new leaves!')\n+\n+class Oak(Tree):\n+    pass\n+    \n+Oak().sprout() # Output: Making new leaves!\n+```\n+\n+In the example above, the child class `Oak` inherits from `Tree` and inherits the `sprout` method from the parent class `Tree`.\n+\n+Create a new class named `R3Vector` and follow the example above to make it inherit from the `R2Vector` class.\n+\n+# --hints--\n+\n+You should define a new class `R3Vector`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).has_class(\"R3Vector\")\n+    `))\n+})\n+```\n+\n+Your new class `R3Vector` should inherit from `R2Vector`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R3Vector\").inherits_from(\"R2Vector\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+        \n+    def __str__(self):\n+        return f'{self.x, self.y}'\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+v1 = R2Vector(2, 3)\n+print(v1.norm())\n+print(v1)\n+```"
        },
        {
            "sha": "dfdb08a15d35fb40331a3fef3ea553c5ad2d2f7e",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f40401e6ef53173c04e27d.md",
            "status": "added",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f40401e6ef53173c04e27d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f40401e6ef53173c04e27d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f40401e6ef53173c04e27d.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,56 @@\n+---\n+id: 65f40401e6ef53173c04e27d\n+title: Step 13\n+challengeType: 20\n+dashedName: step-13\n+---\n+\n+# --description--\n+\n+Within your new class, declare an `__init__` method. Give it `self`, `x`, `y`, and `z` as the parameters.\n+\n+# --hints--\n+\n+You should define an `__init__` method inside your `R3Vector` class.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R3Vector\").has_function(\"__init__\")\n+    `))\n+})\n+```\n+\n+Your `__init__` method should have four parameters `self`, `x`, `y`, and `z`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R3Vector\").find_function(\"__init__\").has_args(\"self, x, y, z\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+        \n+    def __str__(self):\n+        return f'{self.x, self.y}'\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    pass\n+--fcc-editable-region--\n+v1 = R2Vector(2, 3)\n+print(v1.norm())\n+print(v1)\n+```"
        },
        {
            "sha": "f329157bd30939872bd7e1fb47552c8ebeb5ffad",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f407ea37ad6e181b90462e.md",
            "status": "added",
            "additions": 49,
            "deletions": 0,
            "changes": 49,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f407ea37ad6e181b90462e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f407ea37ad6e181b90462e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f407ea37ad6e181b90462e.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,49 @@\n+---\n+id: 65f407ea37ad6e181b90462e\n+title: Step 14\n+challengeType: 20\n+dashedName: step-14\n+---\n+\n+# --description--\n+\n+You could assign each `i` parameter to `self.i` as you did before. Although in this case you have few lines to repeat, one way to avoid this repetition is using the `super()` function. `super()` enables you to refer implicitly to the parent class: `super().__init__(x, y)` calls the `__init__` method of the parent class.\n+\n+Add a `super().__init__(x, y)` call to your `__init__` method.\n+\n+# --hints--\n+\n+You should have a `super().__init__(x, y)` call in your `__init__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R3Vector\").find_function(\"__init__\").has_stmt(\"super().__init__(x, y)\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+        \n+    def __str__(self):\n+        return f'{self.x, self.y}'\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, x, y, z):\n+        pass\n+--fcc-editable-region--\n+v1 = R2Vector(2, 3)\n+print(v1.norm())\n+print(v1)\n+```"
        },
        {
            "sha": "ecf329fe7e74945a2114bf0478286b95c390d631",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f40f8af784751c613d638a.md",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f40f8af784751c613d638a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f40f8af784751c613d638a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f40f8af784751c613d638a.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,47 @@\n+---\n+id: 65f40f8af784751c613d638a\n+title: Step 15\n+challengeType: 20\n+dashedName: step-15\n+---\n+\n+# --description--\n+\n+Now, you need to assign `z` to the `z` attribute of your `R3Vector` object.\n+\n+# --hints--\n+\n+You should assign `z` to `self.z` after the `super` call.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R3Vector\").find_function(\"__init__\").is_ordered(\"super().__init__(x, y)\", \"self.z = z\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+        \n+    def __str__(self):\n+        return f'{self.x, self.y}'\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, x, y, z):\n+        super().__init__(x, y)\n+--fcc-editable-region--\n+v1 = R2Vector(2, 3)\n+print(v1.norm())\n+print(v1)\n+```"
        },
        {
            "sha": "5a13be02b39071196989a808c322269fb83c321a",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f40fdb3579aa1ced28b2eb.md",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f40fdb3579aa1ced28b2eb.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f40fdb3579aa1ced28b2eb.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f40fdb3579aa1ced28b2eb.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,47 @@\n+---\n+id: 65f40fdb3579aa1ced28b2eb\n+title: Step 16\n+challengeType: 20\n+dashedName: step-16\n+---\n+\n+# --description--\n+\n+Create an `R3Vector` instance with `2`, `2`, and `3` as the values of `x`, `y`, and `z`, respectively. Assign the new instance to `v2`.\n+\n+# --hints--\n+\n+You should declare a variable `v2` and assign it `R3Vector(2, 2, 3)`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_variable(\"v2\").is_equivalent(\"v2 = R3Vector(2, 2, 3)\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+        \n+    def __str__(self):\n+        return f'{self.x, self.y}'\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, x, y, z):\n+        super().__init__(x, y)\n+        self.z = z\n+\n+v1 = R2Vector(2, 3)\n+print(v1.norm())\n+print(v1)\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "c659dbc84606f608ca4f935135b0cfdbbf07da50",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f412c208c3791fee305acf.md",
            "status": "added",
            "additions": 72,
            "deletions": 0,
            "changes": 72,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f412c208c3791fee305acf.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f412c208c3791fee305acf.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f412c208c3791fee305acf.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,72 @@\n+---\n+id: 65f412c208c3791fee305acf\n+title: Step 17\n+challengeType: 20\n+dashedName: step-17\n+---\n+\n+# --description--\n+\n+In Python, you can enforce the use of keyword-only arguments by adding a `*` as an additional argument to the function or method signature. Modify both `__init__` methods by adding a `*` as the second parameter (after `self`). Every parameter placed after that will require the use of a keyword argument in the function/method call.\n+\n+This means that you need to modify the `super().__init__(x, y)` call, too. Do it by giving `x` the value `x`, and `y` the value `y`.\n+\n+Finally, modify the instantiation of `v1` and `v2` by using keyword arguments.\n+\n+# --hints--\n+\n+You should enforce keyword arguments by adding a `*` as the second parameter in both your `__init__` methods.\n+\n+```js\n+({ test: () => {\n+  assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__init__\").has_args(\"self, *, x, y\")`));\n+  assert(runPython(`_Node(_code).find_class(\"R3Vector\").find_function(\"__init__\").has_args(\"self, *, x, y, z\")`));\n+} })\n+```\n+\n+You should modify your `super.__init__(x, y)` call to  use keyword arguments.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R3Vector\").find_function(\"__init__\").find_body().is_equivalent(\"super().__init__(x=x, y=y)\\\\nself.z = z\")`)) })\n+```\n+\n+You should modify the assignment of `v1` to be `R2Vector(x=2, y=3)`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_variable(\"v1\").is_equivalent(\"v1 = R2Vector(x=2, y=3)\")`)) })\n+```\n+\n+You should modify the assignment of `v2` to be `R3Vector(x=2, y=2, z=3)`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_variable(\"v2\").is_equivalent(\"v2 = R3Vector(x=2, y=2, z=3)\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+class R2Vector:\n+    def __init__(self, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+        \n+    def __str__(self):\n+        return f'{self.x, self.y}'\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, x, y, z):\n+        super().__init__(x, y)\n+        self.z = z\n+\n+v1 = R2Vector(2, 3)\n+print(v1.norm())\n+print(v1)\n+v2 = R3Vector(2, 2, 3)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "05cdf4f49a637bd3fe7f920a99676ae272736372",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f4148dea0f802040225e0c.md",
            "status": "added",
            "additions": 64,
            "deletions": 0,
            "changes": 64,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f4148dea0f802040225e0c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f4148dea0f802040225e0c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f4148dea0f802040225e0c.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,64 @@\n+---\n+id: 65f4148dea0f802040225e0c\n+title: Step 18\n+challengeType: 20\n+dashedName: step-18\n+---\n+\n+# --description--\n+\n+Remove the existing `print` calls. Then, as you did before for `v1`, print `v2` and the value returned by `v2.norm()`.\n+\n+# --hints--\n+\n+You should not have `print(v1)` and `print(v1.norm())` in your code.\n+\n+```js\n+({\n+    test: () => {\n+      assert.isFalse(runPython(`_Node(_code).has_call(\"print(v1)\")`));\n+      assert.isFalse(runPython(`_Node(_code).has_call(\"print(v1.norm())\")`));\n+    }\n+})\n+```\n+\n+You should print `v2` and `v2.norm()`.\n+\n+```js\n+({\n+    test: () => {\n+      assert(runPython(`_Node(_code).has_call(\"print(v2)\")`));\n+      assert(runPython(`_Node(_code).has_call(\"print(v2.norm())\")`));\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+        \n+    def __str__(self):\n+        return f'{self.x, self.y}'\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+print(v1.norm())\n+print(v1)\n+\n+v2 = R3Vector(x=2, y=2, z=3)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "411bc02d955dbfbd3bb97b761dabb76efed7af46",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f4520e363e2642f8112e33.md",
            "status": "added",
            "additions": 64,
            "deletions": 0,
            "changes": 64,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f4520e363e2642f8112e33.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f4520e363e2642f8112e33.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f4520e363e2642f8112e33.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,64 @@\n+---\n+id: 65f4520e363e2642f8112e33\n+title: Step 19\n+challengeType: 20\n+dashedName: step-19\n+---\n+\n+# --description--\n+\n+As you can see, something is not quite right. The `norm` and `__str__` methods inherited from `R2Vector` cannot adapt to a 3-dimensional vector. Their implementation has to be more flexible.\n+\n+Every object in Python has a special attribute named `__dict__`, which is a dictionary that stores the object attributes.\n+\n+Remove the existing `print` calls. Then, print the `__dict__` attribute of your `v1` and `v2` vectors to see what they look like.\n+\n+# --hints--\n+\n+You should not have `print(v2)` and `print(v2.norm())` in your code.\n+\n+```js\n+({\n+    test: () => {\n+      assert.isFalse(runPython(`_Node(_code).has_call(\"print(v2)\")`));\n+      assert.isFalse(runPython(`_Node(_code).has_call(\"print(v2.norm())\")`));\n+    }\n+})\n+```\n+\n+You should print the `__dict__` attribute of `v1` and `v2`.\n+\n+```js\n+({ test: () => assert(runPython(`\n+(_Node(_code).has_call(\"print(v1.__dict__)\") and _Node(_code).has_call(\"print(v2.__dict__)\")) or _Node(_code).has_call(\"print(v1.__dict__, v2.__dict__)\")\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+        \n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+        \n+    def __str__(self):\n+        return f'{self.x, self.y}'\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(v2.norm())\n+print(v2)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "2a2c8f28376334e1bc088e9ae4b07f0c496fa096",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f4535bbdb28d436ff3ddc9.md",
            "status": "added",
            "additions": 49,
            "deletions": 0,
            "changes": 49,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f4535bbdb28d436ff3ddc9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f4535bbdb28d436ff3ddc9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f4535bbdb28d436ff3ddc9.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,49 @@\n+---\n+id: 65f4535bbdb28d436ff3ddc9\n+title: Step 20\n+challengeType: 20\n+dashedName: step-20\n+---\n+\n+# --description--\n+\n+As you can see from the output, `__dict__` contains the values of your instance attributes. Instead of explicitly adding the squares of `self.x` and `self.y`, you are going to iterate over the values stored in `__dict__` to calculate the value of the norm.\n+\n+Within the `norm` method body, replace the content of the parentheses with a generator expression that elevates each value `val` in `self.__dict__.values()` to the power of `2`. Also, pass that generator expression as the argument to the `sum` function, so that all the squares are added together before calculating the square root.\n+\n+# --hints--\n+\n+You should return `sum(val**2 for val in self.__dict__.values())**0.5` from `norm()` method.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"norm\").has_return(\"sum(val**2 for val in self.__dict__.values())**0.5\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+--fcc-editable-region--\n+    def norm(self):\n+        return (self.x**2 + self.y**2)**0.5\n+--fcc-editable-region--        \n+    def __str__(self):\n+        return f'{self.x, self.y}'\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(v1.__dict__)\n+print(v2.__dict__)\n+\n+```"
        },
        {
            "sha": "bbb82436c52a8b4773e58845fa958d5727d809b2",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f870003444fb1a2ad171f2.md",
            "status": "added",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f870003444fb1a2ad171f2.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f870003444fb1a2ad171f2.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f870003444fb1a2ad171f2.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,53 @@\n+---\n+id: 65f870003444fb1a2ad171f2\n+title: Step 21\n+challengeType: 20\n+dashedName: step-21\n+---\n+\n+# --description--\n+\n+Modify the two `print` calls to print the norm of your vectors and verify that the `norm()` method works fine.\n+\n+# --hints--\n+\n+You should print `v1.norm()`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(v1.norm())\")`)) })\n+```\n+\n+You should print `v2.norm()`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(v2.norm())\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in self.__dict__.values())**0.5\n+\n+    def __str__(self):\n+        return f'{self.x, self.y}'\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(v1.__dict__)\n+print(v2.__dict__)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "22e3cab792e459f100fe90fcaa687ed10c1bd007",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f8709620b2ce1a62608f5a.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f8709620b2ce1a62608f5a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f8709620b2ce1a62608f5a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f8709620b2ce1a62608f5a.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,61 @@\n+---\n+id: 65f8709620b2ce1a62608f5a\n+title: Step 23\n+challengeType: 20\n+dashedName: step-23\n+---\n+\n+# --description--\n+\n+When you need to dynamically access some attributes starting from a string input, the built-in `getattr()` function is what you need. It takes an object as its first argument, and a string containing the attribute name as its second attribute.\n+\n+Start to fix the `__str__` method by replacing the string returned by `__str__()` with a generator expression that iterates through the object attributes and calls `getattr()` for each attribute `i`.\n+\n+# --hints--\n+\n+You should return a generator expression that iterates over `vars(self)`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__str__\").find_return().find_comp_iters()[0].is_equivalent(\"vars(self)\")`)) })\n+```\n+\n+You should return a generator expression that uses `i` as the iteration variable.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__str__\").find_return().find_comp_targets()[0].is_equivalent(\"i\")`)) })\n+```\n+\n+You should return a generator expression that calls `getattr(self, i)` for each item `i` in `vars(self)`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__str__\").find_return().find_comp_expr().is_equivalent(\"getattr(self, i)\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+--fcc-editable-region--\n+    def __str__(self):\n+        return f'{self.x, self.y}'\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(v1.norm())\n+print(v2.norm())\n+\n+```"
        },
        {
            "sha": "668bd89de56a7b776695fc353be81d32396bb645",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f8720685ec351abef26740.md",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f8720685ec351abef26740.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f8720685ec351abef26740.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f8720685ec351abef26740.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,47 @@\n+---\n+id: 65f8720685ec351abef26740\n+title: Step 24\n+challengeType: 20\n+dashedName: step-24\n+---\n+\n+# --description--\n+\n+To obtain a proper string representation, call the `tuple()` constructor and pass it the generator expression you wrote in the previous step as the argument.\n+\n+# --hints--\n+\n+You should pass the expression returned by the `__str__` method to the `tuple()` constructor.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__str__\").has_return(\"tuple(getattr(self, i) for i in vars(self))\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+--fcc-editable-region--\n+    def __str__(self):\n+        return (getattr(self, i) for i in vars(self))\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(v1.norm())\n+print(v2.norm())\n+\n+```"
        },
        {
            "sha": "f687795519e969f26d46ce57d78542c59728ed98",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f872a0fe6aa21b456ad4fe.md",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f872a0fe6aa21b456ad4fe.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f872a0fe6aa21b456ad4fe.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f872a0fe6aa21b456ad4fe.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,47 @@\n+---\n+id: 65f872a0fe6aa21b456ad4fe\n+title: Step 25\n+challengeType: 20\n+dashedName: step-25\n+---\n+\n+# --description--\n+\n+Finally, pass the `tuple()` call as the argument to the `str()` function. \n+\n+# --hints--\n+\n+You should pass the `tuple()` call you are currently returning from the `__str__` method to the `str()` function.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__str__\").has_return(\"str(tuple(getattr(self, i) for i in vars(self)))\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+--fcc-editable-region--\n+    def __str__(self):\n+        return tuple(getattr(self, i) for i in vars(self))\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(v1.norm())\n+print(v2.norm())\n+\n+```"
        },
        {
            "sha": "9f1d1e16d9213957ab9addbcf6753d87ac18a72e",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f8749b13774b1d2e4a7fba.md",
            "status": "added",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f8749b13774b1d2e4a7fba.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f8749b13774b1d2e4a7fba.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f8749b13774b1d2e4a7fba.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,56 @@\n+---\n+id: 65f8749b13774b1d2e4a7fba\n+title: Step 27\n+challengeType: 20\n+dashedName: step-27\n+---\n+\n+# --description--\n+\n+While the `__str__` method returns a human-readable string representation of an object, the `__repr__` method is supposed to return the string needed to instantiate the object.\n+\n+Add a `__repr__` method with a `self` parameter within the `R2Vector` class.\n+\n+# --hints--\n+\n+Your `R2Vector` class should have a `__repr__` method.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__repr__\")`)) })\n+```\n+\n+Your `__repr__` method should have a `self` parameter.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").has_args(\"self\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+--fcc-editable-region--\n+    \n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+```"
        },
        {
            "sha": "7f5a3e0f9c96cb7028fdc1c4a3fcd255096579f9",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f876d17832001e8e1abb05.md",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f876d17832001e8e1abb05.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f876d17832001e8e1abb05.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f876d17832001e8e1abb05.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,74 @@\n+---\n+id: 65f876d17832001e8e1abb05\n+title: Step 28\n+challengeType: 20\n+dashedName: step-28\n+---\n+\n+# --description--\n+\n+Declare a variable `arg_list`. Give it the value of a list comprehension that iterates over `key` and `val` for each key-value pair in `vars(self).items()` and computes the f-string `f'{key}={val}'` at each iteration.\n+\n+# --hints--\n+\n+You should declare a variable `arg_list`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").has_variable(\"arg_list\")`)) })\n+```\n+\n+You should assign a list comprehension that iterates over `vars(self).items()` to `arg_list`.\n+\n+```js\n+({ test: () => runPython(`\n+import ast\n+var = _Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").find_variable(\"arg_list\")\n+assert isinstance(var.tree.value, ast.ListComp), \"Expected arg_list to be a list comprehension\"\n+assert (actual := var.find_comp_iters()[0].is_equivalent(\"vars(self).items()\")), f\"Expected vars(self).items(), got {actual}\"\n+`) })\n+```\n+\n+The list comprehension assigned to `arg_list` should use `key` and `val` to iterate over `vars(self).items()`.\n+\n+```js\n+({ test: () => assert(runPython(`\n+_Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").find_variable(\"arg_list\").find_comp_targets()[0].is_equivalent(\"key, val\")\n+`)) })\n+```\n+\n+The list comprehension assigned to `arg_list` should compute the string `f'{key}={val}'` for each key-value pair in `vars(self).items()`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").find_variable(\"arg_list\").find_comp_expr().is_equivalent(\"f'{key}={val}'\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+--fcc-editable-region--\n+    def __repr__(self):\n+        pass\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+```"
        },
        {
            "sha": "0c56316394ed1c621830014e7dca2ee0d7376604",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f93acbb514857003510e79.md",
            "status": "added",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f93acbb514857003510e79.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f93acbb514857003510e79.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f93acbb514857003510e79.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,50 @@\n+---\n+id: 65f93acbb514857003510e79\n+title: Step 29\n+challengeType: 20\n+dashedName: step-29\n+---\n+\n+# --description--\n+\n+Declare a variable `args` and assign it the value returned by joining the elements in `arg_list` with the string `', '`.\n+\n+# --hints--\n+\n+You should declare a variable `args` and assign it the value returned by joining the elements in `arg_list` with the string `', '`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").find_variable(\"args\").is_equivalent(\"args = ', '.join(arg_list)\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+--fcc-editable-region--\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+```"
        },
        {
            "sha": "e826611fa576b1a0fce1bacd95caa8b71beabe95",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f93b67169a9c703264458a.md",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f93b67169a9c703264458a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f93b67169a9c703264458a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f93b67169a9c703264458a.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,52 @@\n+---\n+id: 65f93b67169a9c703264458a\n+title: Step 30\n+challengeType: 20\n+dashedName: step-30\n+---\n+\n+# --description--\n+\n+Since the method should return the string to instantiate the object for `R2Vector` as well as `R3Vector` when inherited, you cannot build the string specifying the class name.\n+\n+You can access the name of a class with `__class__.__name__`. Add a `return` statement to the `__repr__` method and return the string necessary to instantiate the object.\n+\n+# --hints--\n+\n+You should use `__class__.__name__` to build the f-string needed to instantiate a vector object and return it from the `__repr__` method.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").has_return(\"f'{self.__class__.__name__}({args})'\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+--fcc-editable-region--\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+```"
        },
        {
            "sha": "13682539c2cb0eaacd1190e600e8ea378774590c",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f93d4647ce2670dc6f095c.md",
            "status": "added",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f93d4647ce2670dc6f095c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f93d4647ce2670dc6f095c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f93d4647ce2670dc6f095c.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,57 @@\n+---\n+id: 65f93d4647ce2670dc6f095c\n+title: Step 31\n+challengeType: 20\n+dashedName: step-31\n+---\n+\n+# --description--\n+\n+The `__repr__` method is called under the hood by the `repr` function. Verify that `__repr__` works properly by adding `f'\\nrepr = {repr(v1)}'` and `f'\\nrepr = {repr(v2)}'` as the second argument to your first and second `print` calls, respectively.\n+\n+# --hints--\n+\n+You should add `f'\\nrepr = {repr(v1)}'` as the second argument to your `print(f'v1 = {v1}')` call.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 = {v1}', f'\\\\\\\\nrepr = {repr(v1)}')\")`)) })\n+```\n+\n+You should add `f'\\nrepr = {repr(v2)}'` as the second argument to your `print(f'v2 = {v2}')` call.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v2 = {v2}', f'\\\\\\\\nrepr = {repr(v2)}')\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "a25da243ba9d4b6a83f5d36a682a7563f6032206",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f93e54a9121571dcdd3e79.md",
            "status": "added",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f93e54a9121571dcdd3e79.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f93e54a9121571dcdd3e79.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f93e54a9121571dcdd3e79.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,56 @@\n+---\n+id: 65f93e54a9121571dcdd3e79\n+title: Step 32\n+challengeType: 20\n+dashedName: step-32\n+---\n+\n+# --description--\n+\n+The output is correct, `repr` is giving you the string required to instantiate the objects.\n+\n+Now comment out both your `print` calls.\n+\n+# --hints--\n+\n+You should comment out both your `print()` calls.\n+\n+```js\n+({ test: () => {\n+  assert.match(code, /#\\s*print\\s*\\(\\s*f('|\")v1 = \\{\\s*v1\\s*\\}\\1\\s*,\\s*f('|\")\\\\nrepr = \\{\\s*repr\\s*\\(\\s*v1\\s*\\)\\s*\\}\\2\\s*\\)/);\n+  assert.match(code, /#\\s*print\\s*\\(\\s*f('|\")v2 = \\{\\s*v2\\s*\\}\\1\\s*,\\s*f('|\")\\\\nrepr = \\{\\s*repr\\s*\\(\\s*v2\\s*\\)\\s*\\}\\2\\s*\\)/);\n+} })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}', f'\\nrepr = {repr(v1)}')\n+print(f'v2 = {v2}', f'\\nrepr = {repr(v2)}')\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "86133f41f323210cca93f6d8a31158b83044efcf",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f9b17a638f0d0dcce8c354.md",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9b17a638f0d0dcce8c354.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9b17a638f0d0dcce8c354.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9b17a638f0d0dcce8c354.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,62 @@\n+---\n+id: 65f9b17a638f0d0dcce8c354\n+title: Step 38\n+challengeType: 20\n+dashedName: step-38\n+---\n+\n+# --description--\n+\n+To create a vector space, you need to define how vectors should behave in several cases. Vectors can be added, forming a new vector.\n+\n+The special method `__add__` can be implemented to override what happens by default when two objects are added together using the `+` operator.\n+\n+Right now, trying to add two instances of `R2Vector` or `R3Vector` would raise an exception. Create an empty `__add__` method within the `R2Vector` class and give it two parameters: `self`, and `other`.\n+\n+# --hints--\n+\n+You should define an `__add__` method within the `R2Vector` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__add__\")`)) })\n+```\n+\n+Your `__add__` method should have two parameters, `self` and `other`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").has_args(\"self, other\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+--fcc-editable-region--\n+    \n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+```"
        },
        {
            "sha": "f90c14fe57b63165e2cc45c0ee6b9486ddbebbd4",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f9b486989cb90ff3e77ac8.md",
            "status": "added",
            "additions": 58,
            "deletions": 0,
            "changes": 58,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9b486989cb90ff3e77ac8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9b486989cb90ff3e77ac8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9b486989cb90ff3e77ac8.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,58 @@\n+---\n+id: 65f9b486989cb90ff3e77ac8\n+title: Step 39\n+challengeType: 20\n+dashedName: step-39\n+---\n+\n+# --description--\n+\n+The `other` parameter of your `__add__` method represents the operand placed at the right side of the `+` operator in an addition operation.\n+\n+You want to verify that the right-hand operand is not an object of the same class as the left-hand operand (i.e. `self`). Create an `if` statement that verifies that by checking the type of the operands.\n+\n+# --hints--\n+\n+You should create an `if` statement that checks if `type(self)` and `type(other)` are different.\n+\n+```js\n+({ test: () => assert(runPython(`\n+node = _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").find_ifs()[0].find_conditions()[0]\n+node.is_equivalent(\"type(self) != type(other)\") or node.is_equivalent(\"type(other) != type(self)\")\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+--fcc-editable-region--\n+    def __add__(self, other):\n+        pass\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+```"
        },
        {
            "sha": "1fa83e0f9aafb79b051efd66628a380c82a7e9ac",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f9b9710cca621244d3bde1.md",
            "status": "added",
            "additions": 58,
            "deletions": 0,
            "changes": 58,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9b9710cca621244d3bde1.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9b9710cca621244d3bde1.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9b9710cca621244d3bde1.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,58 @@\n+---\n+id: 65f9b9710cca621244d3bde1\n+title: Step 40\n+challengeType: 20\n+dashedName: step-40\n+---\n+\n+# --description--\n+\n+In Python, `NotImplemented` is a special value used to indicate that an operation is not implemented for a specific case.\n+\n+`NotImplemented` does not raise an exception immediately. Instead, it signals to ask to the other operand how to perform the operation. If the request cannot be satisfied, a `TypeError` is returned by default.\n+\n+Because you want to be able to sum two vectors only if they belong to the same class, return `NotImplemented` from the `if` statement you created in the previous step.\n+\n+# --hints--\n+\n+You should return `NotImplemented` from within the `if` body.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").find_ifs()[0].find_bodies()[0].has_return(\"NotImplemented\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+--fcc-editable-region--\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            pass\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+```"
        },
        {
            "sha": "9df77e468954c549ded8776424038b40b36d6c6e",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f9bb7c0d524612b2a88a4b.md",
            "status": "added",
            "additions": 58,
            "deletions": 0,
            "changes": 58,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9bb7c0d524612b2a88a4b.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9bb7c0d524612b2a88a4b.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9bb7c0d524612b2a88a4b.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,58 @@\n+---\n+id: 65f9bb7c0d524612b2a88a4b\n+title: Step 41\n+challengeType: 20\n+dashedName: step-41\n+---\n+\n+# --description--\n+\n+After the `if` statement, declare a variable `kwargs` and assign it an empty dictionary.\n+\n+# --hints--\n+\n+You should declare a variable `kwargs` and assign it an empty dictionary after the `if` statement.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").has_stmt(\"kwargs = {}\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+--fcc-editable-region--\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+```"
        },
        {
            "sha": "f5d28e43bd6813e98f2e6c9d255141983bc030d8",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f9bc10a9fb1612e066e9e8.md",
            "status": "added",
            "additions": 92,
            "deletions": 0,
            "changes": 92,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9bc10a9fb1612e066e9e8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9bc10a9fb1612e066e9e8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9bc10a9fb1612e066e9e8.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,92 @@\n+---\n+id: 65f9bc10a9fb1612e066e9e8\n+title: Step 42\n+challengeType: 20\n+dashedName: step-42\n+---\n+\n+# --description--\n+\n+When adding two vectors, each component of one vector is added to the same component of the other vector. For example, adding `(1, 2)` and `(2, 4)` generates a third vector `(3, 6)`, where `3` is the sum of `1` and `2` and `6` is the sum of `2` and `4`.\n+\n+The `kwargs` dictionary will contain the key-value pairs needed to instantiate a new vector of the same class of the two vectors added together.\n+\n+Turn the empty dictionary into a dictionary comprehension that iterates through `vars(self)` and for each key (`i`) creates a key-value pair, where the key is the same key of the current iteration and its value is the sum of the values of the `i` attributes of the two operands.\n+\n+# --hints--\n+\n+You should turn the empty dictionary assigned to `kwargs` into a dictionary comprehension that iterates over `vars(self)`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").find_variable(\"kwargs\").find_comp_iters()[0].is_equivalent(\"vars(self)\")\n+    `))\n+})\n+```\n+\n+The dictionary comprehension assigned to `kwargs` should use the variable `i` to iterate over `vars(self)`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").find_variable(\"kwargs\").find_comp_targets()[0].is_equivalent(\"i\")\n+    `))\n+})\n+```\n+\n+The dictionary comprehension assigned to `kwargs` should use `i` as the key.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").find_variable(\"kwargs\").find_comp_key().is_equivalent(\"i\")\n+    `))\n+})\n+```\n+\n+The dictionary comprehension assigned to `kwargs` should assign the sum of the `i` attribute of `self` and the `i` attribute of `other` to the `i` key for each `i` in `vars(self)`. Use the `getattr()` function for that.\n+\n+```js\n+({ test: () => assert(runPython(`\n+node = _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").find_variable(\"kwargs\").find_comp_expr()\n+node.is_equivalent(\"getattr(self, i) + getattr(other, i)\") or node.is_equivalent(\"getattr(other, i) + getattr(self, i)\")\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+--fcc-editable-region--\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {}\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+```"
        },
        {
            "sha": "d1cd1755778cfad8ec7b6066a8b38a8d8caab345",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f9c2c2006feb1428ad2d4c.md",
            "status": "added",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9c2c2006feb1428ad2d4c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9c2c2006feb1428ad2d4c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9c2c2006feb1428ad2d4c.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,70 @@\n+---\n+id: 65f9c2c2006feb1428ad2d4c\n+title: Step 43\n+challengeType: 20\n+dashedName: step-43\n+---\n+\n+# --description--\n+\n+You can unpack a dictionary into keyword arguments by using the `**` operator:\n+\n+```py\n+def spam(a, b):\n+    return a + b\n+\n+my_dict = {a: 11, b: 4}\n+\n+spam(**my_dict) # 15\n+```\n+\n+Return an instance of the current class by using `__class__` and passing `**kwargs` as the argument.\n+\n+# --hints--\n+\n+You should return `self.__class__(**kwargs)` from the `__add__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").has_return(\"self.__class__(**kwargs)\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+--fcc-editable-region--\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+```"
        },
        {
            "sha": "3a19c864a1dad3caf3847416d628d66cb8e73fd5",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f9cb678070ca1668898c70.md",
            "status": "added",
            "additions": 90,
            "deletions": 0,
            "changes": 90,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9cb678070ca1668898c70.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9cb678070ca1668898c70.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9cb678070ca1668898c70.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,90 @@\n+---\n+id: 65f9cb678070ca1668898c70\n+title: Step 44\n+challengeType: 20\n+dashedName: step-44\n+---\n+\n+# --description--\n+\n+In the same way `__add__` is called under the hood when two objects are added together, the `__sub__` method is called implicitly in case of subtraction.\n+\n+Now, define an empty `__sub__` method and give two parameters: `self`, and `other`. Inside your new method, create an if statement to check if `self` and `other` do not belong to the same class and return `NotImplemented`, as you did previously.\n+\n+# --hints--\n+\n+You should define a `__sub__` method within the `R2Vector` class.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R2Vector\").has_function(\"__sub__\")\n+    `))\n+})\n+```\n+\n+Your `__sub__` method should have two parameters, `self` and `other`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").has_args(\"self, other\")\n+    `))\n+})\n+```\n+\n+You should create an `if` statement that checks if `self` and `other` does not belong to the same class.\n+\n+```js\n+({ test: () => assert(runPython(`\n+node = _Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").find_ifs()[0].find_conditions()[0]\n+node.is_equivalent(\"type(self) != type(other)\") or node.is_equivalent(\"type(other) != type(self)\")\n+    `))\n+})\n+```\n+\n+You should return `NotImplemented` from within the `if` body.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").find_ifs()[0].find_bodies()[0].has_return(\"NotImplemented\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+--fcc-editable-region--\n+    \n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+```"
        },
        {
            "sha": "2d452d2413e1a86572aa8421a7d656d5bf5c264d",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f9dd6e5a08af19c196c2df.md",
            "status": "added",
            "additions": 89,
            "deletions": 0,
            "changes": 89,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9dd6e5a08af19c196c2df.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9dd6e5a08af19c196c2df.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9dd6e5a08af19c196c2df.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,89 @@\n+---\n+id: 65f9dd6e5a08af19c196c2df\n+title: Step 45\n+challengeType: 20\n+dashedName: step-45\n+---\n+\n+# --description--\n+\n+The vector resulting from the subtraction of one vector from another is obtained by calculating the difference of each of their components. For example, subtracting `(2, 4)` from `(7, 3)` generates a third vector `(5, -1)`, where `5` is the difference between `7` and `2` and `-1` is the difference between `3` and `4`.\n+\n+As you did before inside the `__add__` method, declare a `kwargs` variable after the `if` statement. Assign it a dictionary comprehension that iterates through the object attributes and creates a key-value pair for each key `i`, where the key is the same key as the current iteration and its value is the difference between the values of the `i` attributes of two operands.\n+\n+# --hints--\n+\n+You should declare a variable `kwargs` and assign it a dictionary comprehension that iterates over the object attributes.\n+\n+```js\n+({ test: () => assert(runPython(`\n+node = _Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").find_variable(\"kwargs\").find_comp_iters()[0]\n+node.is_equivalent(\"vars(self)\") or node.is_equivalent(\"self.__dict__\")`)) })\n+```\n+\n+The dictionary comprehension assigned to `kwargs` should use the variable `i` to iterate over the object attributes.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").find_variable(\"kwargs\").find_comp_targets()[0].is_equivalent(\"i\")\n+    `))\n+})\n+```\n+\n+The dictionary comprehension assigned to `kwargs` should use `i` as the key.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").find_variable(\"kwargs\").find_comp_key().is_equivalent(\"i\")`)) })\n+```\n+\n+The dictionary comprehension assigned to `kwargs` should assign the difference between the `i` attribute of `self` and the `i` attribute of `other` to the `i` key for each `i`.\n+\n+```js\n+({ test: () => assert(runPython(`\n+node = _Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").find_variable(\"kwargs\").find_comp_expr()\n+node.is_equivalent(\"getattr(self, i) - getattr(other, i)\") or node.is_equivalent(\"self.__getattribute__(i) - other.__getattribute__(i)\")\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+--fcc-editable-region--\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+```"
        },
        {
            "sha": "095bce27c7cf7e4dcb012b0fe1207301c4d2b9f4",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f9dfd2e75e291a38695f13.md",
            "status": "added",
            "additions": 65,
            "deletions": 0,
            "changes": 65,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9dfd2e75e291a38695f13.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9dfd2e75e291a38695f13.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9dfd2e75e291a38695f13.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,65 @@\n+---\n+id: 65f9dfd2e75e291a38695f13\n+title: Step 46\n+challengeType: 20\n+dashedName: step-46\n+---\n+\n+# --description--\n+\n+Finally, return a new vector object. Use `__class__` and unpack `kwargs` to instantiate the new vector.\n+\n+# --hints--\n+\n+You should return a new vector using `__class__` and unpacking `kwargs` from the `__sub__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").has_return(\"self.__class__(**kwargs)\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+--fcc-editable-region--\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+```"
        },
        {
            "sha": "c5cb7742541185050f6fab3c0a474e17413221a5",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65f9e0a578b22c1a736f3d82.md",
            "status": "added",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9e0a578b22c1a736f3d82.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9e0a578b22c1a736f3d82.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65f9e0a578b22c1a736f3d82.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,67 @@\n+---\n+id: 65f9e0a578b22c1a736f3d82\n+title: Step 47\n+challengeType: 20\n+dashedName: step-47\n+---\n+\n+# --description--\n+\n+Modify your `v2` variable assignment to be an `R2Vector` instance having `x=0.5` and `y=1.25`.\n+\n+# --hints--\n+\n+You should modify your `v2` variable assignment to be an `R2Vector` instance having `x=0.5` and `y=1.25`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).has_stmt(\"v2 = R2Vector(x=0.5, y=1.25)\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "1d277671da484c9b8458af0453ee457ed37e1135",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fa8d5cf0ef3b141010f5d8.md",
            "status": "added",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fa8d5cf0ef3b141010f5d8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fa8d5cf0ef3b141010f5d8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fa8d5cf0ef3b141010f5d8.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,67 @@\n+---\n+id: 65fa8d5cf0ef3b141010f5d8\n+title: Step 48\n+challengeType: 20\n+dashedName: step-48\n+---\n+\n+# --description--\n+\n+It's time to verify that the addition and subtraction operations work as expected. Declare another variable `v3` and assign it the sum of `v1` plus `v2`.\n+\n+# --hints--\n+\n+You should declare a variable `v3` and assign it the sum of `v1` and `v2`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).has_stmt(\"v3 = v1 + v2\") or _Node(_code).has_stmt(\"v3 = v2 + v1\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "87ddac5ea5f19a50feab9b3fcbe3bb657133fa24",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fa8df56a0e2c149b4d24fe.md",
            "status": "added",
            "additions": 64,
            "deletions": 0,
            "changes": 64,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fa8df56a0e2c149b4d24fe.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fa8df56a0e2c149b4d24fe.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fa8df56a0e2c149b4d24fe.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,64 @@\n+---\n+id: 65fa8df56a0e2c149b4d24fe\n+title: Step 49\n+challengeType: 20\n+dashedName: step-49\n+---\n+\n+# --description--\n+\n+Next, check the new vector by printing the following f-string `f'v1 + v2 = {v3}'`.\n+\n+# --hints--\n+\n+You should print `f'v1 + v2 = {v3}'`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 + v2 = {v3}')\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "e526a9cd4cc45835ca6727c3982601a8c54105f1",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fa9402d1fb5516aa42159d.md",
            "status": "added",
            "additions": 77,
            "deletions": 0,
            "changes": 77,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fa9402d1fb5516aa42159d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fa9402d1fb5516aa42159d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fa9402d1fb5516aa42159d.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,77 @@\n+---\n+id: 65fa9402d1fb5516aa42159d\n+title: Step 50\n+challengeType: 20\n+dashedName: step-50\n+---\n+\n+# --description--\n+\n+Feel free to modify `v3` so that it sums an `R2Vector` instance with an object of a different type, such as an integer or a string. You will be able to see a `TypeError` message printed on the console.\n+\n+Then, restore the original line and create a new variable `v4`. Assign the difference between `v1` and `v2` to your new variable and print the result following the same structure as the previous f-string.\n+\n+# --hints--\n+\n+You should declare a variable `v4` and assign it the difference between `v1` and `v2`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).has_stmt(\"v4 = v1 - v2\")\n+    `))\n+})\n+```\n+\n+You should print `f'v1 - v2 = {v4}'`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 - v2 = {v4}')\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "17afd8a185f656f9b271b035b2aec79f9b0fcf98",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fa9e1b6c6db919385359ec.md",
            "status": "added",
            "additions": 85,
            "deletions": 0,
            "changes": 85,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fa9e1b6c6db919385359ec.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fa9e1b6c6db919385359ec.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fa9e1b6c6db919385359ec.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,85 @@\n+---\n+id: 65fa9e1b6c6db919385359ec\n+title: Step 51\n+challengeType: 20\n+dashedName: step-51\n+---\n+\n+# --description--\n+\n+The special method `__mul__` can be implemented to specify what should happen when the current instance is multiplied by another object.\n+\n+Create an empty `__mul__` method within the `R2Vector` class and give it two parameters: `self`, and `other`.\n+\n+# --hints--\n+\n+You should define a `__mul__` method within the `R2Vector` class.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R2Vector\").has_function(\"__mul__\")\n+    `))\n+})\n+```\n+\n+Your `__mul__` method should have two parameters, `self` and `other`.\n+\n+```js\n+({\n+    test: () => assert(runPython(`\n+      _Node(_code).find_class(\"R2Vector\").find_function(\"__mul__\").has_args(\"self, other\")\n+    `))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+--fcc-editable-region--\n+    \n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+\n+```"
        },
        {
            "sha": "0a18b8b69d1a581034db07eb1e99a45d09161b13",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65faaed8f7a9772f023ea816.md",
            "status": "added",
            "additions": 94,
            "deletions": 0,
            "changes": 94,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65faaed8f7a9772f023ea816.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65faaed8f7a9772f023ea816.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65faaed8f7a9772f023ea816.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,94 @@\n+---\n+id: 65faaed8f7a9772f023ea816\n+title: Step 52\n+challengeType: 20\n+dashedName: step-52\n+---\n+\n+# --description--\n+\n+Vectors can be multiplied by a *scalar*, i.e. a number that multiplies each single component. The result of scalar multiplication is a vector with the same orientation as the original vector but a different magnitude.\n+\n+Implement the scalar multiplication by checking if `other` is either an `int` or a `float`. If it is, return a new instance of the current class that has each component of the starting vector multiplied by `other`. This will be the vector resulting from the scalar multiplication.\n+\n+Make sure the methods can be applied to compute the scalar multiplication of vectors with any number of dimensions.\n+\n+# --hints--\n+\n+Your method should return a new instance of the current class only when the type of `other` is either `int` or `float`.\n+\n+```js\n+({ test: () => runPython(`\n+v1 = R2Vector(x=0, y=0)\n+v2 = R3Vector(x=0, y=0, z=0)\n+types = [\"\", True, [], {}]\n+assert all((v1 * i) is None for i in types)\n+types = [1, 1.0]\n+assert all(type(v1 * i) is type(v1) for i in types)\n+assert all(type(v2 * i) is type(v2) for i in types)\n+`) })\n+```\n+\n+The vector resulting from the scalar multiplication should have each component of the starting vector multiplied by the scalar.\n+\n+```js\n+({ test: () => runPython(`\n+v1 = R2Vector(x=1, y=1.5)\n+v2 = R3Vector(x=2.2, y=3, z=-1)\n+assert vars(v1 * 3) == vars(R2Vector(x=3, y=4.5))\n+assert vars(v2 * (-2.0)) == vars(R3Vector(x=-4.4, y=-6.0, z=2.0))\n+`) })\n+```\n+\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+--fcc-editable-region--\n+    def __mul__(self, other):\n+        pass\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+\n+```"
        },
        {
            "sha": "bcf1d3d0b5522505a200b03e4490de56746d245e",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fc87e19930a503e5f05500.md",
            "status": "added",
            "additions": 79,
            "deletions": 0,
            "changes": 79,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fc87e19930a503e5f05500.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fc87e19930a503e5f05500.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fc87e19930a503e5f05500.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,79 @@\n+---\n+id: 65fc87e19930a503e5f05500\n+title: Step 53\n+challengeType: 20\n+dashedName: step-53\n+---\n+\n+# --description--\n+\n+A vector can be multiplied by another vector, too. This operation is called *dot product*, or *scalar product*.\n+\n+Create an `elif` clause that checks if `other` is an object of the same class of the current instance.\n+\n+You are going to implement the dot product inside this block during the next step.\n+\n+# --hints--\n+\n+You should create an `elif` clause that checks if `other` is an object of the same class of the current instance.\n+\n+```js\n+({ test: () => assert(runPython(`\n+node = _Node(_code).find_class(\"R2Vector\").find_function(\"__mul__\").find_ifs()[0].find_conditions()[1]\n+node.is_equivalent(\"type(self) == type(other)\") or node.is_equivalent(\"type(other) == type(self)\")\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+--fcc-editable-region--\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+\n+```"
        },
        {
            "sha": "21e11cbc791ee42b4744371876a9182024e6832e",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fc899d77495504d6deeccc.md",
            "status": "added",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fc899d77495504d6deeccc.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fc899d77495504d6deeccc.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fc899d77495504d6deeccc.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,87 @@\n+---\n+id: 65fc899d77495504d6deeccc\n+title: Step 54\n+challengeType: 20\n+dashedName: step-54\n+---\n+\n+# --description--\n+\n+The scalar product between two vectors $\\mathbf{a}$ and $\\mathbf{b}$ is indicated as:\n+\n+\\\\( \\mathbf{a} \\cdot \\mathbf{b} = a_1 \\cdot b_1 + a_2 \\cdot b_2 + \\ldots + a_n \\cdot b_n = \\sum_{i=1}^{n} a_i \\cdot b_i \\\\)\n+\n+Where each component of $\\mathbf{a}$ is multiplied by the correspondent component of $\\mathbf{b}$, and all the products are summed together, resulting in a number.\n+\n+Within the `elif` clause, implement the above formula to compute the result of a scalar product and return the result. Remember that your implementation must be valid for any vector, independently from the number of components, when the method is inherited.\n+\n+# --hints--\n+\n+You should implement the scalar product calculation and return the result inside the `elif` body of your `__mul__` method.\n+\n+```js\n+({ test: () => assert(runPython(`\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+v3 = R3Vector(x=2, y=3, z=1.5)\n+v4 = R3Vector(x=0.5, y=1.25, z=1.5)\n+v1*v2 == 4.75 and v3*v4 == 7.0      \n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+--fcc-editable-region--\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)\n+        \n+        elif type(self) == type(other):\n+            pass\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+\n+```"
        },
        {
            "sha": "7d818367bf87d69cc1a8fa69ac87e4883c8fb6b8",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fc8e7c766ab1070213aadb.md",
            "status": "added",
            "additions": 78,
            "deletions": 0,
            "changes": 78,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fc8e7c766ab1070213aadb.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fc8e7c766ab1070213aadb.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fc8e7c766ab1070213aadb.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,78 @@\n+---\n+id: 65fc8e7c766ab1070213aadb\n+title: Step 55\n+challengeType: 20\n+dashedName: step-55\n+---\n+\n+# --description--\n+\n+In case `other` is not an integer, a floating point number, or another instance of the current class, no product can be computed.\n+\n+After the `elif` clause, return `NotImplemented`.\n+\n+# --hints--\n+\n+You should return `NotImplemented` after the `elif` clause.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__mul__\").has_return(\"NotImplemented\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+--fcc-editable-region--\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)\n+        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+\n+```"
        },
        {
            "sha": "f0cc7d866b43f8998ea4673a4484d87774637faa",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fc8fa7e7860407ab479bf0.md",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fc8fa7e7860407ab479bf0.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fc8fa7e7860407ab479bf0.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fc8fa7e7860407ab479bf0.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,83 @@\n+---\n+id: 65fc8fa7e7860407ab479bf0\n+title: Step 56\n+challengeType: 20\n+dashedName: step-56\n+---\n+\n+# --description--\n+\n+It's time to test the multiplication. Declare a new variable `v5` and assign it the scalar multiplication `v1 * 3`.\n+Then, call the `print` function and pass it the following f-string: `f'v1 * 3 = {v5}'`.\n+\n+# --hints--\n+\n+You should declare a new variable `v5` and assign it the scalar multiplication `v1 * 3`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_variable(\"v5\").is_equivalent(\"v5 = v1 * 3\")`)) })\n+```\n+\n+You should print the f-string `f'v1 * 3 = {v5}'`. \n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 * 3 = {v5}')\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "603375e34cce887915cf9539a922e6bdc2b3d6da",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fd681b20b7e45f55def415.md",
            "status": "added",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd681b20b7e45f55def415.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd681b20b7e45f55def415.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd681b20b7e45f55def415.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,87 @@\n+---\n+id: 65fd681b20b7e45f55def415\n+title: Step 57\n+challengeType: 20\n+dashedName: step-57\n+---\n+\n+# --description--\n+\n+The scalar multiplication works fine. Now, modify the assignment of `v5` to be the dot product `v1 * v2`. Also, update the `print` call.\n+\n+Before doing that, feel free to experiment and multiply `v1` by an object of invalid type to see the error message printed on the console.\n+\n+\n+# --hints--\n+\n+You should update the assignment of `v5` assigning it the scalar product `v1 * v2`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_variable(\"v5\").is_equivalent(\"v5 = v1 * v2\")`)) })\n+```\n+\n+You should update your `print` call to print the f-string `f'v1 * v2 = {v5}'`. \n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 * v2 = {v5}')\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * 3\n+print(f'v1 * 3 = {v5}')\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "3773c95a395ddeb361aca3a2dd4425fc188a7311",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fd9250db0d6b8198cf29ef.md",
            "status": "added",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9250db0d6b8198cf29ef.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9250db0d6b8198cf29ef.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9250db0d6b8198cf29ef.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,87 @@\n+---\n+id: 65fd9250db0d6b8198cf29ef\n+title: Step 58\n+challengeType: 20\n+dashedName: step-58\n+---\n+\n+# --description--\n+\n+The `__eq__` method can be implemented to specify what should happen in case the comparison operator (`==`) is used to compare an object with something else.\n+\n+Within the `R2Vector` class, create an `__eq__` method and give it two parameters: `self` and `other`.\n+\n+# --hints--\n+\n+You should define a `__eq__` method within the `R2Vector` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__eq__\")`)) })\n+```\n+\n+Your `__eq__` method should take two parameters: `self` and `other`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__eq__\").has_args(\"self, other\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+--fcc-editable-region--\n+    \n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+```"
        },
        {
            "sha": "5d2d8cfc678968ba3118ceb7bdfef248c959497d",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fd95c23beef982af29004c.md",
            "status": "added",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd95c23beef982af29004c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd95c23beef982af29004c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd95c23beef982af29004c.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,88 @@\n+---\n+id: 65fd95c23beef982af29004c\n+title: Step 59\n+challengeType: 20\n+dashedName: step-59\n+---\n+\n+# --description--\n+\n+You want to compare two vectors, only when they belong to the same class. For that create an `if` statement that checks if `self` and `other` do not belong to the same class and return `NotImplemented` in that case.\n+# --hints--\n+\n+You should create an `if` statement that checks if `self` and `other` do not belong to the same class.\n+\n+```js\n+({ test: () => assert(runPython(`\n+node = _Node(_code).find_class(\"R2Vector\").find_function(\"__eq__\").find_ifs()[0].find_conditions()[0]\n+conditions = [\"type(self) != type(other)\", \"type(other) != type(self)\", \"self.__class__ != other.__class__\", \"other.__class__ != self.__class__\"]\n+any(node.is_equivalent(condition) for condition in conditions)`)) })\n+```\n+\n+You should return `NotImplemented` from your `if` body.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__eq__\").find_ifs()[0].find_bodies()[0].has_return(\"NotImplemented\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+--fcc-editable-region--\n+    def __eq__(self, other):\n+        pass\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+```"
        },
        {
            "sha": "c3bea995dc85bdd1b397f072e59c1f41127b8fa3",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fd97f3c1b4c4839bdeb8d2.md",
            "status": "added",
            "additions": 91,
            "deletions": 0,
            "changes": 91,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd97f3c1b4c4839bdeb8d2.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd97f3c1b4c4839bdeb8d2.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd97f3c1b4c4839bdeb8d2.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,91 @@\n+---\n+id: 65fd97f3c1b4c4839bdeb8d2\n+title: Step 60\n+challengeType: 20\n+dashedName: step-60\n+---\n+\n+# --description--\n+\n+To compare two vectors, you are going to check that each component of the first vector is equal to the same component of the second vector.\n+\n+After the `if` statement you created in the previous step, return `True` if each attribute of the current instance is equal to the same attribute of `other` and `False` otherwise.\n+\n+# --hints--\n+\n+The `__eq__` method should return `True` if each attribute of the current instance is equal to the same attribute of `other` and `False` otherwise.\n+\n+```js\n+({ test: () => assert(runPython(`\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=2, y=3)\n+v3 = R2Vector(x=0.5, y=1.25)\n+v4 = R3Vector(x=2, y=3, z=1.5)\n+v5 = R3Vector(x=2, y=3, z=1.5)\n+v6 = R3Vector(x=0.5, y=1.25, z=1.5)\n+v1 == v2 and not v1 == v3 and v4 == v5 and not v5 == v6\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+--fcc-editable-region--\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+```"
        },
        {
            "sha": "a7f5d701215646882093b759c37ba65f85eb18bd",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fd9aa649f6cc84631882a9.md",
            "status": "added",
            "additions": 102,
            "deletions": 0,
            "changes": 102,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9aa649f6cc84631882a9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9aa649f6cc84631882a9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9aa649f6cc84631882a9.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,102 @@\n+---\n+id: 65fd9aa649f6cc84631882a9\n+title: Step 61\n+challengeType: 20\n+dashedName: step-61\n+---\n+\n+# --description--\n+\n+The `__ne__` method is called under the hood when the `!=` operator is used. Define a `__ne__` method with two parameters `self` and `other`. From your new method, return the opposite of `self == other`.\n+\n+# --hints--\n+\n+You should define a `__ne__` method within the `R2Vector` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__ne__\")`)) })\n+```\n+\n+Your `__ne__` method should have two parameters, `self` and `other`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__ne__\").has_args(\"self, other\")`)) })\n+```\n+\n+The `__ne__` method should return `False` if each attribute of the current instance is equal to the same attribute of `other` and `True` otherwise.\n+\n+```js\n+({ test: () => assert(runPython(`\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=2, y=3)\n+v3 = R2Vector(x=0.5, y=1.25)\n+v4 = R3Vector(x=2, y=3, z=1.5)\n+v5 = R3Vector(x=2, y=3, z=1.5)\n+v6 = R3Vector(x=0.5, y=1.25, z=1.5)\n+not v1 != v2 and v1 != v3 and not v4 != v5 and v5 != v6\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+--fcc-editable-region--\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+```"
        },
        {
            "sha": "8dc85c4a70b3d2999db20e684b7e4f9c1f5aaa76",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fd9c6e49d7cd8513ab1005.md",
            "status": "added",
            "additions": 86,
            "deletions": 0,
            "changes": 86,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9c6e49d7cd8513ab1005.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9c6e49d7cd8513ab1005.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9c6e49d7cd8513ab1005.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,86 @@\n+---\n+id: 65fd9c6e49d7cd8513ab1005\n+title: Step 62\n+challengeType: 20\n+dashedName: step-62\n+---\n+\n+# --description--\n+\n+At the end of your code, use the equality operator to compare `v1` and `R2Vector(x=2, y=3)` and print the result.\n+\n+# --hints--\n+\n+You should print the result of comparing `v1` and `R2Vector(x=2, y=3)` using the equality operator.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(v1 == R2Vector(x=2, y=3))\") or _Node(_code).has_call(\"print(R2Vector(x=2, y=3) == v1)\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "b488bbcf86f0d0eb8293648fefd6d61978059f57",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fd9d6203afea85931094c9.md",
            "status": "added",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9d6203afea85931094c9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9d6203afea85931094c9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9d6203afea85931094c9.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,87 @@\n+---\n+id: 65fd9d6203afea85931094c9\n+title: Step 63\n+challengeType: 20\n+dashedName: step-63\n+---\n+\n+# --description--\n+\n+The comparison returns `True`, since the two vectors have the same components. Now, modify the argument of the `print` call you added in the previous step to use the inequality operator.\n+\n+# --hints--\n+\n+You should modify the `print` call you added in the previous step using the inequality operator to compare `v1` and `R2Vector(x=2, y=3)`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(v1 != R2Vector(x=2, y=3))\") or _Node(_code).has_call(\"print(R2Vector(x=2, y=3) != v1)\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+print(v1 == R2Vector(x=2, y=3))\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "fbc628b1a0c0c7987726ddf2899b96917167fefb",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fd9e2c56ff19862dfb8cbb.md",
            "status": "added",
            "additions": 97,
            "deletions": 0,
            "changes": 97,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9e2c56ff19862dfb8cbb.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9e2c56ff19862dfb8cbb.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fd9e2c56ff19862dfb8cbb.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,97 @@\n+---\n+id: 65fd9e2c56ff19862dfb8cbb\n+title: Step 64\n+challengeType: 20\n+dashedName: step-64\n+---\n+\n+# --description--\n+\n+The `__lt__` method is called under the hood when the `<` operator is used to compare an object with something else.\n+\n+Add an empty `__lt__` method and give it two parameters: `self`, `other`.\n+\n+# --hints--\n+\n+You should define a `__lt__` method within the `R2Vector` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__lt__\")`)) })\n+```\n+\n+Your `__lt__` method should have two parameters, `self` and `other`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__lt__\").has_args(\"self, other\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+--fcc-editable-region--\n+    \n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+print(v1 != R2Vector(x=2, y=3))\n+\n+```"
        },
        {
            "sha": "1b50fbea3d0acaa2fd3f31d853f306d4db963ecc",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fdc3c8478ee70fc7966151.md",
            "status": "added",
            "additions": 100,
            "deletions": 0,
            "changes": 100,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fdc3c8478ee70fc7966151.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fdc3c8478ee70fc7966151.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fdc3c8478ee70fc7966151.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,100 @@\n+---\n+id: 65fdc3c8478ee70fc7966151\n+title: Step 65\n+challengeType: 20\n+dashedName: step-65\n+---\n+\n+# --description--\n+\n+In the same way you did before for the `__eq__` method, create an `if` statement that checks if `self` and `other` do not belong to the same class and return `NotImplemented`.\n+\n+# --hints--\n+\n+You should create an `if` statement that checks if `self` and `other` do not belong to the same class.\n+\n+```js\n+({ test: () => assert(runPython(`\n+node = _Node(_code).find_class(\"R2Vector\").find_function(\"__lt__\").find_ifs()[0].find_conditions()[0]\n+conditions = [\"type(self) != type(other)\", \"type(other) != type(self)\", \"self.__class__ != other.__class__\", \"other.__class__ != self.__class__\"]\n+any(node.is_equivalent(condition) for condition in conditions)\n+`)) })\n+```\n+\n+You should return `NotImplemented` from your `if` body.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__lt__\").find_ifs()[0].find_bodies()[0].has_return(\"NotImplemented\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+--fcc-editable-region--\n+    def __lt__(self, other):\n+        pass\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+print(v1 != R2Vector(x=2, y=3))\n+\n+```"
        },
        {
            "sha": "cd38c9db1b5e3c6c0ca519a3ab8286d8bcb92fcd",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/65fdc496f4440e1055a2ac1b.md",
            "status": "added",
            "additions": 91,
            "deletions": 0,
            "changes": 91,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fdc496f4440e1055a2ac1b.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fdc496f4440e1055a2ac1b.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F65fdc496f4440e1055a2ac1b.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,91 @@\n+---\n+id: 65fdc496f4440e1055a2ac1b\n+title: Step 66\n+challengeType: 20\n+dashedName: step-66\n+---\n+\n+# --description--\n+\n+After the `if` statement, return the result of comparing the norm of the current instance with the norm of `other` using the less than operator.\n+\n+# --hints--\n+\n+The `__lt__` method should return the result of comparing the norm of the current instance with the norm of `other` using the `<` operator.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__lt__\").has_return(\"self.norm() < other.norm()\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+--fcc-editable-region--\n+    def __lt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+print(v1 != R2Vector(x=2, y=3))\n+\n+```"
        },
        {
            "sha": "2ce64a91350565b15c488ee19c25fb3c7c505046",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/6601918b44a11b4a8c986c6a.md",
            "status": "added",
            "additions": 122,
            "deletions": 0,
            "changes": 122,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601918b44a11b4a8c986c6a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601918b44a11b4a8c986c6a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601918b44a11b4a8c986c6a.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,122 @@\n+---\n+id: 6601918b44a11b4a8c986c6a\n+title: Step 67\n+challengeType: 20\n+dashedName: step-67\n+---\n+\n+# --description--\n+\n+The `__gt__` method is called under the hood when the `>` operator is used to compare an object with something else.\n+\n+After the `__lt__` method, in the same way you did for `__lt__`, implement the `__gt__` method. Pay attention to use the appropriate operator.\n+\n+# --hints--\n+\n+You should define a `__gt__` method within the `R2Vector` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__gt__\")`)) })\n+```\n+\n+Your `__lt__` method should have two parameters, `self` and `other`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__gt__\").has_args(\"self, other\")`)) })\n+```\n+\n+You should create an `if` statement that checks if `self` and `other` do not belong to the same class.\n+\n+```js\n+({ test: () => assert(runPython(`\n+node = _Node(_code).find_class(\"R2Vector\").find_function(\"__gt__\").find_ifs()[0].find_conditions()[0]\n+node.is_equivalent(\"type(self) != type(other)\") or node.is_equivalent(\"type(other) != type(self)\")`)) })\n+```\n+\n+You should return `NotImplemented` from your `if` body.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__gt__\").find_ifs()[0].find_bodies()[0].has_return(\"NotImplemented\")`)) })\n+```\n+\n+The `__gt__` method should return the result of comparing the norm of the current instance with the norm of `other` using the greater than operator.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__gt__\").has_return(\"self.norm() > other.norm()\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+--fcc-editable-region--\n+    def __lt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() < other.norm()\n+\n+\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+print(v1 != R2Vector(x=2, y=3))\n+\n+```"
        },
        {
            "sha": "0e7af024e72bb131ac2de31f91562867b86409ff",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/66019258a7c71d4ae50da42e.md",
            "status": "added",
            "additions": 111,
            "deletions": 0,
            "changes": 111,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66019258a7c71d4ae50da42e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66019258a7c71d4ae50da42e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66019258a7c71d4ae50da42e.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,111 @@\n+---\n+id: 66019258a7c71d4ae50da42e\n+title: Step 68\n+challengeType: 20\n+dashedName: step-68\n+---\n+\n+# --description--\n+\n+There are still two possible comparisons to implement. The `__le__` method is called when the `<=` operator is used to compare two objects.\n+\n+Define a `__le__` method with `self` and `other` as the parameters and make it return the opposite of `self > other`.\n+\n+# --hints--\n+\n+You should define a `__le__` method within the `R2Vector` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__le__\")`)) })\n+```\n+\n+Your `__le__` method should have two parameters, `self` and `other`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__le__\").has_args(\"self, other\")`)) })\n+```\n+\n+Your `__le__` method return the opposite of `self > other`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__le__\").has_return(\"not self > other\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+--fcc-editable-region--\n+    def __lt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() < other.norm()\n+\n+    def __gt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() > other.norm()\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+print(v1 != R2Vector(x=2, y=3))\n+\n+```"
        },
        {
            "sha": "090a4c25718787d89c0b4c7ac6fd651fcaca1fc5",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/66019319edb1cb4b57d3a793.md",
            "status": "added",
            "additions": 116,
            "deletions": 0,
            "changes": 116,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66019319edb1cb4b57d3a793.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66019319edb1cb4b57d3a793.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66019319edb1cb4b57d3a793.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,116 @@\n+---\n+id: 66019319edb1cb4b57d3a793\n+title: Step 69\n+challengeType: 20\n+dashedName: step-69\n+---\n+\n+# --description--\n+\n+The last method you need is `__ge__`, which is called when the `>=` is used to compare two objects.\n+\n+Define a `__ge__` method with `self` and `other` as the parameters and make it return the opposite of `self < other`.\n+\n+# --hints--\n+\n+You should define a `__ge__` method within the `R2Vector` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__ge__\")`)) })\n+```\n+\n+Your `__ge__` method should have two parameters, `self` and `other`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__ge__\").has_args(\"self, other\")`)) })\n+```\n+\n+Your `__ge__` method should return the opposite of `self < other`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__ge__\").has_return(\"not self < other\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+\n+    def __lt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() < other.norm()\n+\n+    def __gt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() > other.norm()\n+\n+    def __le__(self, other):\n+        return not self > other\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+print(v1 != R2Vector(x=2, y=3))\n+\n+```"
        },
        {
            "sha": "feda5e7fb0232c6e5506e2654068ed23b74c59de",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/660193a2a71faa4bd8f10970.md",
            "status": "added",
            "additions": 104,
            "deletions": 0,
            "changes": 104,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F660193a2a71faa4bd8f10970.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F660193a2a71faa4bd8f10970.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F660193a2a71faa4bd8f10970.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,104 @@\n+---\n+id: 660193a2a71faa4bd8f10970\n+title: Step 70\n+challengeType: 20\n+dashedName: step-70\n+---\n+\n+# --description--\n+\n+Feel free to play around with the new comparison operations you implemented. Then, remove your last `print` call.\n+\n+\n+# --hints--\n+\n+You should not have `print(v1 != R2Vector(x=2, y=3))` in your code.\n+\n+```js\n+({test: () => assert.isFalse(runPython(`_Node(_code).has_call(\"print(v1 != R2Vector(x=2, y=3))\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+\n+    def __lt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() < other.norm()\n+\n+    def __gt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() > other.norm()\n+\n+    def __le__(self, other):\n+        return not self > other\n+\n+    def __ge__(self, other):\n+        return not self < other\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+print(v1 != R2Vector(x=2, y=3))\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "6690882d473a0ca87b41ba9c1a657555efb26e28",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/66019977710caa516276c0a8.md",
            "status": "added",
            "additions": 111,
            "deletions": 0,
            "changes": 111,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66019977710caa516276c0a8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66019977710caa516276c0a8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66019977710caa516276c0a8.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,111 @@\n+---\n+id: 66019977710caa516276c0a8\n+title: Step 71\n+challengeType: 20\n+dashedName: step-71\n+---\n+\n+# --description--\n+\n+The *cross product*, or *vector product*, is defined between 3-dimensional vectors and results in a third vector perpendicular to both of them.\n+\n+The `R3Vector` class inherits from `R2Vector`, meaning it has access to all the methods and properties defined in `R2Vector`. A child class can implement additional features. You already saw a way to change the implementation of a method. Now, you are going to give the child class `R3Vector` a new method instead.\n+\n+Within the `R3Vector` class, define a `cross` method and give it two parameters: `self`, and `other`.\n+\n+# --hints--\n+\n+You should define a `cross` method within the `R3Vector` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R3Vector\").has_function(\"cross\")`)) })\n+```\n+\n+Your `cross` method should have two parameters, `self` and `other`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R3Vector\").find_function(\"cross\").has_args(\"self, other\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+\n+    def __lt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() < other.norm()\n+\n+    def __gt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() > other.norm()\n+\n+    def __le__(self, other):\n+        return not self > other\n+\n+    def __ge__(self, other):\n+        return not self < other\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+```"
        },
        {
            "sha": "f4245103e64be1700e7840bca654c303caae9496",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/6601a7eb860fb8546516674d.md",
            "status": "added",
            "additions": 114,
            "deletions": 0,
            "changes": 114,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601a7eb860fb8546516674d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601a7eb860fb8546516674d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601a7eb860fb8546516674d.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,114 @@\n+---\n+id: 6601a7eb860fb8546516674d\n+title: Step 72\n+challengeType: 20\n+dashedName: step-72\n+---\n+\n+# --description--\n+\n+Create an `if` statement that checks if `self` and `other` do not belong to the same class and return `NotImplemented`.\n+\n+# --hints--\n+\n+You should create an `if` statement that checks if `self` and `other` do not belong to the same class.\n+\n+```js\n+({ test: () => assert(runPython(`\n+node = _Node(_code).find_class(\"R3Vector\").find_function(\"cross\").find_ifs()[0].find_conditions()[0]\n+conditions = [\"type(self) != type(other)\", \"type(other) != type(self)\", \"self.__class__ != other.__class__\", \"other.__class__ != self.__class__\"]\n+any(node.is_equivalent(condition) for condition in conditions)\n+`)) })\n+```\n+\n+You should return `NotImplemented` from your `if` body.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R3Vector\").find_function(\"cross\").find_ifs()[0].find_bodies()[0].has_return(\"NotImplemented\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+\n+    def __lt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() < other.norm()\n+\n+    def __gt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() > other.norm()\n+\n+    def __le__(self, other):\n+        return not self > other\n+\n+    def __ge__(self, other):\n+        return not self < other\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+        \n+    def cross(self, other):\n+        pass\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+```"
        },
        {
            "sha": "11c27b74700baa3a9dd1e5069c29be132b559eb4",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/6601a88a6e2ccc550d7d7208.md",
            "status": "added",
            "additions": 105,
            "deletions": 0,
            "changes": 105,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601a88a6e2ccc550d7d7208.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601a88a6e2ccc550d7d7208.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601a88a6e2ccc550d7d7208.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,105 @@\n+---\n+id: 6601a88a6e2ccc550d7d7208\n+title: Step 73\n+challengeType: 20\n+dashedName: step-73\n+---\n+\n+# --description--\n+\n+After the `if` statement, declare a variable `kwargs` and assign it an empty dictionary.\n+\n+# --hints--\n+\n+You should declare a variable `kwargs` and assign it an empty dictionary after the `if` statement.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R3Vector\").find_function(\"cross\").find_variable(\"kwargs\").is_equivalent(\"kwargs = {}\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+\n+    def __lt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() < other.norm()\n+\n+    def __gt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() > other.norm()\n+\n+    def __le__(self, other):\n+        return not self > other\n+\n+    def __ge__(self, other):\n+        return not self < other\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+        \n+    def cross(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+```"
        },
        {
            "sha": "4369122717f9b3c932ea1dafc3de4145d36e3209",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/6601a8fb2e993b55912f9e9f.md",
            "status": "added",
            "additions": 117,
            "deletions": 0,
            "changes": 117,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601a8fb2e993b55912f9e9f.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601a8fb2e993b55912f9e9f.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601a8fb2e993b55912f9e9f.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,117 @@\n+---\n+id: 6601a8fb2e993b55912f9e9f\n+title: Step 74\n+challengeType: 20\n+dashedName: step-74\n+---\n+\n+# --description--\n+\n+The dot product between two 3D vectors \\\\( \\mathbf{a} \\\\) and \\\\( \\mathbf{b} \\\\) can be computed as it follows:\n+\n+\\\\[ \\mathbf{a} \\times \\mathbf{b} = \\begin{pmatrix} a_yb_z - a_zb_y \\\\\\ a_zb_x - a_xb_z \\\\\\ a_xb_y - a_yb_x \\end{pmatrix}\n+ \\\\]\n+ \n+Where the resulting vector is represented as a column vector.\n+ \n+Implement the formula above to compute the dot product between two 3-dimensional vectors and return the resulting vector from the `cross()` method.\n+\n+# --hints--\n+\n+The `cross()` method should return a new `R3Vector` instance resulting from the dot product computation.\n+\n+```js\n+({ test: () => assert(runPython(`\n+v1 = R3Vector(x=2, y=3, z=1)\n+v2 = R3Vector(x=0.5, y=1.25, z=2)\n+v1.cross(v2) == R3Vector(x=4.75, y=-3.5, z=1.0) and v2.cross(v1) == R3Vector(x=-4.75, y=3.5, z=-1.0) and v1.cross(v1) == R3Vector(x=0, y=0, z=0)\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+\n+    def __lt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() < other.norm()\n+\n+    def __gt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() > other.norm()\n+\n+    def __le__(self, other):\n+        return not self > other\n+\n+    def __ge__(self, other):\n+        return not self < other\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+        \n+    def cross(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {}\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+```"
        },
        {
            "sha": "2093aecdc16cce41255d3a2a8215a91b4d3ba4eb",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/6601ab2809898f57591f2f7f.md",
            "status": "added",
            "additions": 119,
            "deletions": 0,
            "changes": 119,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601ab2809898f57591f2f7f.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601ab2809898f57591f2f7f.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601ab2809898f57591f2f7f.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,119 @@\n+---\n+id: 6601ab2809898f57591f2f7f\n+title: Step 75\n+challengeType: 20\n+dashedName: step-75\n+---\n+\n+# --description--\n+\n+Now, modify the assignments of `v1` and `v2`. Turn them into `R3Vector` instances and pass `z=1` and `z=2` to `v1` and `v2`, respectively.\n+\n+# --hints--\n+\n+You should modify the assignment of `v1` to be an `R3Vector` instance.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_variable(\"v1\").is_equivalent(\"v1 = R3Vector(x=2, y=3, z=1)\")`)) })\n+```\n+\n+You should modify the assignment of `v2` to be an `R3Vector` instance.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_variable(\"v2\").is_equivalent(\"v2 = R3Vector(x=0.5, y=1.25, z=2)\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+\n+    def __lt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() < other.norm()\n+\n+    def __gt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() > other.norm()\n+\n+    def __le__(self, other):\n+        return not self > other\n+\n+    def __ge__(self, other):\n+        return not self < other\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+        \n+    def cross(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {\n+            'x': self.y * other.z - self.z * other.y,\n+            'y': self.z * other.x - self.x * other.z,\n+            'z': self.x * other.y - self.y * other.x\n+        }\n+        \n+        return self.__class__(**kwargs)\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R2Vector(x=0.5, y=1.25)\n+--fcc-editable-region--\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+```"
        },
        {
            "sha": "c7d46d75ac779c881be5edf4aae6fc715cd3ff67",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/6601ac48a2ee6b59e6a5060d.md",
            "status": "added",
            "additions": 113,
            "deletions": 0,
            "changes": 113,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601ac48a2ee6b59e6a5060d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601ac48a2ee6b59e6a5060d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601ac48a2ee6b59e6a5060d.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,113 @@\n+---\n+id: 6601ac48a2ee6b59e6a5060d\n+title: Step 76\n+challengeType: 20\n+dashedName: step-76\n+---\n+\n+# --description--\n+\n+Call `cross()` on `v1` and pass `v2` as the argument. Assign this call to a new variable `v6`.\n+\n+# --hints--\n+\n+You should declare a variable named `v6` and assign it a call to the `cross()` method on `v1` passing it `v2` as the `argument`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_variable(\"v6\").is_equivalent(\"v6 = v1.cross(v2)\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+\n+    def __lt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() < other.norm()\n+\n+    def __gt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() > other.norm()\n+\n+    def __le__(self, other):\n+        return not self > other\n+\n+    def __ge__(self, other):\n+        return not self < other\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+        \n+    def cross(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {\n+            'x': self.y * other.z - self.z * other.y,\n+            'y': self.z * other.x - self.x * other.z,\n+            'z': self.x * other.y - self.y * other.x\n+        }\n+        \n+        return self.__class__(**kwargs)\n+--fcc-editable-region--\n+v1 = R3Vector(x=2, y=3, z=1)\n+v2 = R3Vector(x=0.5, y=1.25, z=2)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "48e3a3a353fa6ac3c1b683a3a4d6a5e301eff25e",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/6601ad0fe415985a5c83f3cc.md",
            "status": "added",
            "additions": 210,
            "deletions": 0,
            "changes": 210,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601ad0fe415985a5c83f3cc.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601ad0fe415985a5c83f3cc.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6601ad0fe415985a5c83f3cc.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,210 @@\n+---\n+id: 6601ad0fe415985a5c83f3cc\n+title: Step 77\n+challengeType: 20\n+dashedName: step-77\n+---\n+\n+# --description--\n+\n+As a final step, call the `print` function and pass it the f-string `f'v1 x v2 = {v6}'` to see the output of the dot product.\n+\n+With that, you have completed the vector space project. Well done!\n+\n+# --hints--\n+\n+You should print `f'v1 x v2 = {v6}'`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 x v2 = {v6}')\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+\n+    def __lt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() < other.norm()\n+\n+    def __gt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() > other.norm()\n+\n+    def __le__(self, other):\n+        return not self > other\n+\n+    def __ge__(self, other):\n+        return not self < other\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+        \n+    def cross(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {\n+            'x': self.y * other.z - self.z * other.y,\n+            'y': self.z * other.x - self.x * other.z,\n+            'z': self.x * other.y - self.y * other.x\n+        }\n+        \n+        return self.__class__(**kwargs)\n+--fcc-editable-region--\n+v1 = R3Vector(x=2, y=3, z=1)\n+v2 = R3Vector(x=0.5, y=1.25, z=2)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+v6 = v1.cross(v2)\n+--fcc-editable-region--\n+```\n+\n+# --solutions--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __add__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __sub__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n+        return self.__class__(**kwargs)\n+\n+    def __mul__(self, other):\n+        if type(other) in (int, float):\n+            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n+            return self.__class__(**kwargs)        \n+        elif type(self) == type(other):\n+            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n+            return sum(args)            \n+        return NotImplemented\n+\n+    def __eq__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n+        \n+    def __ne__(self, other):\n+        return not self == other\n+\n+    def __lt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() < other.norm()\n+\n+    def __gt__(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        return self.norm() > other.norm()\n+\n+    def __le__(self, other):\n+        return not self > other\n+\n+    def __ge__(self, other):\n+        return not self < other\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+        \n+    def cross(self, other):\n+        if type(self) != type(other):\n+            return NotImplemented\n+        kwargs = {\n+            'x': self.y * other.z - self.z * other.y,\n+            'y': self.z * other.x - self.x * other.z,\n+            'z': self.x * other.y - self.y * other.x\n+        }\n+        \n+        return self.__class__(**kwargs)\n+\n+v1 = R3Vector(x=2, y=3, z=1)\n+v2 = R3Vector(x=0.5, y=1.25, z=2)\n+print(f'v1 = {v1}')\n+print(f'v2 = {v2}')\n+v3 = v1 + v2\n+print(f'v1 + v2 = {v3}')\n+v4 = v1 - v2\n+print(f'v1 - v2 = {v4}')\n+v5 = v1 * v2\n+print(f'v1 * v2 = {v5}')\n+v6 = v1.cross(v2)\n+print(f'v1 x v2 = {v6}')\n+```"
        },
        {
            "sha": "d25b1a4c723b098431588f1f9bfea608f871462f",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/6659875502b6d7765498f324.md",
            "status": "added",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6659875502b6d7765498f324.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6659875502b6d7765498f324.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6659875502b6d7765498f324.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,53 @@\n+---\n+id: 6659875502b6d7765498f324\n+title: Step 26\n+challengeType: 20\n+dashedName: step-26\n+---\n+\n+# --description--\n+\n+Use f-strings to modify your `print` calls so that they result in the output `v1 = (2, 3)` and `v2 = (2, 2, 3)`, respectively.\n+\n+# --hints--\n+\n+You should use an f-string to interpolate `v1` and generate the output `v1 = (2, 3)`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 = {v1}')\")`)) })\n+```\n+\n+You should use an f-string to interpolate `v2` and generate the output `v2 = (2, 2, 3)`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v2 = {v2}')\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in self.__dict__.values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+--fcc-editable-region--\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(v1.norm())\n+print(v2.norm())\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "ff34ca74d7ff0865482614cb47784926e9ec4e25",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/66680ddfd0f8c76782923cb0.md",
            "status": "added",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66680ddfd0f8c76782923cb0.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66680ddfd0f8c76782923cb0.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66680ddfd0f8c76782923cb0.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,51 @@\n+---\n+id: 66680ddfd0f8c76782923cb0\n+title: Step 22\n+challengeType: 20\n+dashedName: step-22\n+---\n+\n+# --description--\n+\n+The `norm()` method is returning the correct values, but there's still something you can improve: readability. \n+\n+The `vars()` built-in function takes an object as its argument and returns the `__dict__` attribute of that object.\n+\n+Instead of directly accessing the `__dict__` attribute of `self`, modify the `norm` method to use the `vars()` function.\n+\n+# --hints--\n+\n+You should modify your `norm` method to use `vars(self)` instead of `self.__dict__`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"norm\").has_return(\"sum(val**2 for val in vars(self).values())**0.5\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+--fcc-editable-region--\n+    def norm(self):\n+        return sum(val**2 for val in self.__dict__.values())**0.5\n+--fcc-editable-region--\n+    def __str__(self):\n+        return f'{self.x, self.y}'\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+print(v1.norm())\n+print(v2.norm())\n+\n+```"
        },
        {
            "sha": "0dc691b65b858df67b05205658ebf30bc56fc2de",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/66682150151af29efec9727d.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66682150151af29efec9727d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66682150151af29efec9727d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F66682150151af29efec9727d.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,61 @@\n+---\n+id: 66682150151af29efec9727d\n+title: Step 33\n+challengeType: 20\n+dashedName: step-33\n+---\n+\n+# --description--\n+\n+The `__getattribute__` method is called under the hood any time you try to access an instance attribute. If the attribute is not found at the instance level, the method will search for it at the class level, and eventually in parent classes.\n+\n+Inside your class, define a `__getattribute__` method with two parameters, `self` and `attr`, and make it return the string `'calling __getattribute__'`. You'll override momentarily the default implementation just to see how the attribute access works.\n+\n+# --hints--\n+\n+You should define a method named `__getattribute__` with two parameters, `self` and `attr`, inside the `R2Vector` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__getattribute__\").has_args(\"self, attr\")`)) })\n+```\n+\n+Your `__getattribute__` method should return the string `'calling __getattribute__'`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__getattribute__\").has_return(\"'calling __getattribute__'\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+--fcc-editable-region--\n+    \n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+# print(f'v1 = {v1}', f'\\nrepr = {repr(v1)}')\n+# print(f'v2 = {v2}', f'\\nrepr = {repr(v2)}')\n+\n+```"
        },
        {
            "sha": "80410b5510699fa9ed4b5c43434004ea7aa253e5",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/666826f258fda1ab3396a509.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F666826f258fda1ab3396a509.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F666826f258fda1ab3396a509.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F666826f258fda1ab3396a509.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,61 @@\n+---\n+id: 666826f258fda1ab3396a509\n+title: Step 34\n+challengeType: 20\n+dashedName: step-34\n+---\n+\n+# --description--\n+\n+Now, print the result of accessing the `x` attribute of `v1` both with the dot operator and the `getattr()` built-in function.\n+\n+You will see that `__getattribute__` is called in both cases.\n+\n+# --hints--\n+\n+You should print the `x` attribute of `v1` using both the dot operator and the `getattr()` function.\n+\n+```js\n+({ test: () => assert(runPython(`\n+n = _Node(_code)\n+(n.has_call(\"print(v1.x)\") and n.has_call(\"print(getattr(v1, 'x'))\")) or n.has_call(\"print(v1.x, getattr(v1, 'x'))\") or n.has_call(\"print(getattr(v1, 'x'), v1.x)\")\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+    \n+    def __getattribute__(self, attr):                \n+        return 'calling __getattribute__'\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+# print(f'v1 = {v1}', f'\\nrepr = {repr(v1)}')\n+# print(f'v2 = {v2}', f'\\nrepr = {repr(v2)}')\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "8c3a650010b7211c0d74e6d08911c774389d21da",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/666827a6fd0dbaafe8330ea6.md",
            "status": "added",
            "additions": 69,
            "deletions": 0,
            "changes": 69,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F666827a6fd0dbaafe8330ea6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F666827a6fd0dbaafe8330ea6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F666827a6fd0dbaafe8330ea6.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,69 @@\n+---\n+id: 666827a6fd0dbaafe8330ea6\n+title: Step 35\n+challengeType: 20\n+dashedName: step-35\n+---\n+\n+# --description--\n+\n+`__getattr__` is another special method that plays a role in accessing attributes.\n+\n+The default implementation of `__getattribute__` is to raise an `AttributeError` when the requested attribute is not an instance attribute or it is not present in the class tree.\n+\n+In that case, `__getattr__` is called if defined by the class. You can consider it as a sort of fallback when the usual attribute accessing procedure fails.\n+\n+Turn the `__getattribute__` method into `__getattr__` and modify the string returned by the method into `'calling __getattr__'`.\n+\n+# --hints--\n+\n+You should define a method named `__getattr__` with two parameters, `self` and `attr`, inside the `R2Vector` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__getattr__\").has_args(\"self, attr\")`)) })\n+```\n+\n+Your `__getattr__` method should return the string `'calling __getattr__'`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__getattr__\").has_return(\"'calling __getattr__'\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+--fcc-editable-region--\n+    def __getattribute__(self, attr):                \n+        return 'calling __getattribute__'\n+--fcc-editable-region--\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+# print(f'v1 = {v1}', f'\\nrepr = {repr(v1)}')\n+# print(f'v2 = {v2}', f'\\nrepr = {repr(v2)}')\n+\n+print(v1.x)\n+print(getattr(v1, 'x'))\n+\n+```"
        },
        {
            "sha": "598c9822428a07c5a0b853772811d726a75f42c0",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/666832e427d70bc5219dc62a.md",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F666832e427d70bc5219dc62a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F666832e427d70bc5219dc62a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F666832e427d70bc5219dc62a.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,62 @@\n+---\n+id: 666832e427d70bc5219dc62a\n+title: Step 36\n+challengeType: 20\n+dashedName: step-36\n+---\n+\n+# --description--\n+\n+As you can see from the output, although you defined `__getattr__` in your class, this method is not called yet. This happens because the default attribute access occurs through `__getattribute__`. Therefore, you can see the attribute value printed on the terminal.\n+\n+Now modify the last two lines of code to access the `z` attribute of `v1` in both your `print()` calls. This time, you are going to access an attribute that `v1` does not have. As a result, `__getattribute__` will raise an error and `__getattr__` will be called.\n+\n+# --hints--\n+\n+You should modify your code to print the `z` attribute of `v1` using both the dot operator and the `getattr()` function.\n+\n+```js\n+({ test: () => assert(runPython(`\n+n = _Node(_code)\n+(n.has_call(\"print(v1.z)\") and n.has_call(\"print(getattr(v1, 'z'))\")) or n.has_call(\"print(v1.z, getattr(v1, 'z'))\") or n.has_call(\"print(getattr(v1, 'z'), v1.z)\")\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+\n+    def __getattr__(self, attr):                \n+        return 'calling __getattr__'\n+\n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+# print(f'v1 = {v1}', f'\\nrepr = {repr(v1)}')\n+# print(f'v2 = {v2}', f'\\nrepr = {repr(v2)}')\n+--fcc-editable-region--\n+print(v1.x)\n+print(getattr(v1, 'x'))\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "bb55eb1f3a8dcc03fc120a5f05d7cf52667fc9da",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-special-methods-by-building-a-vector-space/6668374ed18b7fce10259cb3.md",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6668374ed18b7fce10259cb3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6cfea56f1268b5b105e1944a9bb78df604650688/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6668374ed18b7fce10259cb3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-special-methods-by-building-a-vector-space%2F6668374ed18b7fce10259cb3.md?ref=6cfea56f1268b5b105e1944a9bb78df604650688",
            "patch": "@@ -0,0 +1,75 @@\n+---\n+id: 6668374ed18b7fce10259cb3\n+title: Step 37\n+challengeType: 20\n+dashedName: step-37\n+---\n+\n+# --description--\n+\n+Now that you have an idea of how the attribute access work, remove the last two lines of your code together with the `__getattr__` method.\n+\n+Then, restore the `print()` calls you commented out before and delete the second argument from both of them.\n+\n+# --hints--\n+\n+You should not have a `__getattr__` method.\n+\n+```js\n+({ test: () => assert.isFalse(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__getattr__\")`)) })\n+```\n+\n+You should not have `print(v1.z)`and `print(getattr(v1, 'z'))` in your code.\n+\n+```js\n+({ test: () => assert.isFalse(runPython(`\n+n = _Node(_code)\n+n.has_call(\"print(v1.z)\") or n.has_call(\"print(getattr(v1, 'z'))\")\n+`)) })\n+```\n+\n+You should restore the `print()` calls you commented out before and remove the second argument from both of them.\n+\n+```js\n+({ test: () => assert(runPython(`\n+_Node(_code).has_call(\"print(f'v1 = {v1}')\") and _Node(_code).has_call(\"print(f'v2 = {v2}')\")\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class R2Vector:\n+    def __init__(self, *, x, y):\n+        self.x = x\n+        self.y = y\n+\n+    def norm(self):\n+        return sum(val**2 for val in vars(self).values())**0.5\n+\n+    def __str__(self):\n+        return str(tuple(getattr(self, i) for i in vars(self)))\n+\n+    def __repr__(self):\n+        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n+        args = ', '.join(arg_list)\n+        return f'{self.__class__.__name__}({args})'\n+--fcc-editable-region--\n+    def __getattr__(self, attr):                \n+        return 'calling __getattr__'\n+        \n+class R3Vector(R2Vector):\n+    def __init__(self, *, x, y, z):\n+        super().__init__(x=x, y=y)\n+        self.z = z\n+\n+v1 = R2Vector(x=2, y=3)\n+v2 = R3Vector(x=2, y=2, z=3)\n+# print(f'v1 = {v1}', f'\\nrepr = {repr(v1)}')\n+# print(f'v2 = {v2}', f'\\nrepr = {repr(v2)}')\n+print(v1.z)\n+print(getattr(v1, 'z'))\n+--fcc-editable-region--\n+```"
        }
    ],
    "stats": {
        "total": 5998,
        "additions": 5995,
        "deletions": 3
    }
}