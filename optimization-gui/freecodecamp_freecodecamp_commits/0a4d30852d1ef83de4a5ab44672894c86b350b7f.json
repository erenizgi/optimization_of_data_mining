{
    "author": "Ksound22",
    "message": "feat (curriculum): add OOP review (#62131)\n\nCo-authored-by: Zaira <33151350+zairahira@users.noreply.github.com>",
    "sha": "0a4d30852d1ef83de4a5ab44672894c86b350b7f",
    "files": [
        {
            "sha": "1398436955a4ad1fcac7bf6a8b4664203f52a3ca",
            "filename": "curriculum/challenges/english/blocks/review-object-oriented-programming/67f39dac6c3fac29c3d54918.md",
            "status": "modified",
            "additions": 187,
            "deletions": 4,
            "changes": 191,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/0a4d30852d1ef83de4a5ab44672894c86b350b7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Freview-object-oriented-programming%2F67f39dac6c3fac29c3d54918.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/0a4d30852d1ef83de4a5ab44672894c86b350b7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Freview-object-oriented-programming%2F67f39dac6c3fac29c3d54918.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Freview-object-oriented-programming%2F67f39dac6c3fac29c3d54918.md?ref=0a4d30852d1ef83de4a5ab44672894c86b350b7f",
            "patch": "@@ -7,13 +7,196 @@ dashedName: review-object-oriented-programming\n \n # --description--\n \n-## First topic\n+## What is Object-Oriented Programming?\n \n-Describe\n+- **Object-oriented programming**: A programming style in which developers treat everything in their code like a real-world object. It is popularly called OOP. The four key principles that help you organize and manage code effectively are **encapsulation**, **inheritance**, **polymorphism**, and **abstraction**\n+- **Classes**: The blueprint for creating objects. Every single object created from a class has attributes that define data and methods that determine the behaviors of the objects.\n \n-## Second topic\n+## What is Encapsulation?\n \n-Describe\n+- **Encapsulation**: The bundling of the attributes and methods of an object into a single unit. It lets you hide the internal state of the object behind a simple set of public methods and attributes that act like doors. Behind those doors are private attributes and methods that control how the data changes and who can see it.\n+- **Example of Encapsulation**: If you want to track a wallet balance, you will allow deposit and withdrawal, but you won't want anyone to tamper with the wallet balance itself:\n+\n+```py\n+class Wallet:\n+   def __init__(self, balance):\n+       self.__balance = balance # Private attribute\n+\n+   def deposit(self, amount):\n+       if amount > 0:\n+           self.__balance += amount # Add to the balance safely\n+\n+   def withdraw(self, amount):\n+       if 0 < amount <= self.__balance:\n+           self.__balance -= amount # Remove from the balance safely\n+\n+account = Wallet(500)\n+print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'\n+```\n+\n+- **Difference Between Prefixing Attributes with Single and Double Underscore**: Prefixing attributes and methods with a single underscore means they are meant for internal use. This is a convention, and it doesn't enforce accessing attributes from the outside. Prefixing attributes and methods with a double underscore effectively prevents them from being accessed from outside of their class.\n+\n+## What Are Getters and Setters?\n+\n+- **Getters and Setters**: Methods that let you control how the attributes of a class are accessed and modified. You retrieve values with getters and you set values with setters.\n+- **Properties**: They connect getters and setters, and allow access to data. They run extra logic behind the scenes when you get, set, or delete values.\n+- **Why Properties Instead of Methods**: Properties are used instead of methods for better readability and cleaner code. They let you access values with dot notation, like regular attributes, without parentheses.\n+- **Creating a Getter**: To create a getter, you use the `@property` decorator. Here's a getter that gets the radius of a circle:\n+\n+```py\n+class Circle:\n+    def __init__(self, radius):\n+        self._radius = radius\n+\n+    @property\n+    def radius(self): # A getter to get the radius\n+        return self._radius\n+  \n+    @property\n+    def area(self):  # A getter to calculate area\n+        return 3.14 * (self._radius ** 2)\n+\n+my_circle = Circle(3)\n+\n+print(my_circle.radius) # 3\n+print(my_circle.area) # 28.26\n+```\n+\n+- **Creating a Setter**: To create the setter that will set the radius, you have to define another method with the same name and use `@<property_name>.setter` above it:\n+\n+```py\n+class Circle:\n+    def __init__(self, radius):\n+        self._radius = radius\n+\n+    @property\n+    def radius(self):  # A getter to get the radius\n+        return self._radius\n+\n+    @radius.setter\n+    def radius(self, value):  # A setter to set the radius\n+        if value <= 0:\n+            raise ValueError('Radius must be positive')\n+        self._radius = value\n+\n+my_circle = Circle(3)\n+print('Initial radius:', my_circle.radius) # Initial radius: 3\n+\n+my_circle.radius = 8\n+print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8\n+```\n+\n+- **How Python Handles Getters and Setters**: Once you define getters and setters, Python automatically calls them under the hood whenever you use normal attribute syntax this way:\n+\n+```py\n+my_circle.radius # This will call the getter\n+my_circle.radius = 4 # This will call the setter\n+```\n+\n+ When setting a value, you should not assign to the property name itself because that will cause a `RecursionError`. Use a separate internal name, often with an underscore, to store the value.\n+\n+- **Deleter**: After setting and getting a value with setter and getter, you can control how it is deleted with a `deleter`. A deleter runs custom logic when you use the `del` statement on a property. To create a deleter, you use the `@<property_name>.deleter` decorator.\n+\n+```py\n+  # Deleter\n+    @radius.deleter\n+    def radius(self):\n+        print(\"Deleting radius...\")\n+        del self._radius\n+```\n+\n+## What Is Inheritance and How Does It Promote Code Reuse?\n+\n+- **Inheritance**: The process by which a child class uses the attributes and methods of a parent class. Inheritance promotes code reuse, provides clear hierarchies, and customizes behavior without rewriting everything. To implement inheritance, a child class takes in the name of a parent class:\n+\n+```py\n+class Parent:\n+    # Parent attributes and methods\n+\n+class Child(Parent):\n+    # Child inherits, extends, and/or overrides where necessary\n+```\n+\n+- **Single and Multiple Inheritance**: When a child class inherits properties and methods from a single parent, as you can see above, the process is called **single inheritance**. When a child class inherits properties and methods from more than one parent, that is **multiple inheritance**. Here's the syntax for that:\n+\n+```py\n+class Parent:\n+    # Attributes and methods for Parent\n+\n+class Child:\n+    # Attributes and methods for Child\n+\n+class GrandChild(Parent, Child):\n+    # GrandChild inherits from both Parent and Child\n+    # GrandChild can combine or override behavior from each\n+```\n+\n+- **`super()` Function**: A function that lets you override a method from a parent inside a child class.\n+\n+## What Is Polymorphism and How Does It Promote Code Reuse?\n+\n+- **Polymorphism**: The OOP principle that lets different classes use the same method name, but each class implements it differently when called. Here's the syntax for it:\n+\n+```py\n+class A:\n+   def action(self): ...\n+\n+class B:\n+   def action(self): ...\n+\n+class C:\n+   def action(self): ...\n+\n+Class().method()  # Works for A, B, or C\n+```\n+\n+- **Inheritance-based polymorphism**: A parent sets up a method, and each child class twists it to their use.\n+\n+## What is Name Mangling and How Does it Work?\n+\n+- **Name Mangling**: A process in which Python internally renames an attribute prefixed with a double underscore by adding an underscore and the class name as a prefix, turning `__attribute` into `_ClassName__attribute`.\n+- **The Purpose of Name Mangling**: The main purpose of name mangling is to prevent accidental attribute and method overriding when you use inheritance. Here's a code that makes that more understandable:\n+\n+```py\n+class Parent:\n+    def __init__(self):\n+        self.__data = 'Parent data'\n+\n+class Child(Parent):\n+    def __init__(self):\n+        super().__init__()\n+        self.__data = 'Child data'\n+\n+c = Child()\n+print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}\n+```\n+\n+## What Is Abstraction and How Does It Help Keep Complex Systems Organized?\n+\n+- **Abstraction**: A programming concept in which complex implementation details of object or system are hidden and only the essential features are shown. In Python and other programming languages, abstraction simplifies complex systems by increasing reusability.\n+- **Example of Abstraction**: A good example of abstraction in everyday life is a car letting you just use the wheel, pedals, and shifter without knowing how the engine or brakes work.\n+- **How Python Implements Abstraction**: Python implements abstraction through the `abc` module. The module provides the `ABC` class (abstract base class) and the `@abstractmethod` decorator. An abstract base class (ABC) defines the common methods and properties subclasses must implement. It can't be instantiated.\n+- **How Abstract Method is Defined**: An abstract method is defined with `@abstractmethod` and must be overridden in subclasses, even if it has a default implementation. The basic syntax of abstraction looks like this:\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+# Define an abstract base class\n+class AbstractClass(ABC):\n+    @abstractmethod\n+    def abstract_method(self):\n+        pass\n+\n+# Concrete subclass that implements the abstract method\n+class ConcreteClassOne(AbstractClass):\n+    def abstract_method(self):\n+        print('Implementation in ConcreteClassOne')\n+\n+# Another concrete subclass\n+class ConcreteClassTwo(AbstractClass):\n+    def abstract_method(self):\n+        print('Implementation in ConcreteClassTwo')\n+```\n \n # --assignment--\n "
        }
    ],
    "stats": {
        "total": 191,
        "additions": 187,
        "deletions": 4
    }
}