{
    "author": "zairahira",
    "message": "chore(curriculum): add form validation lecture transcripts (#58616)\n\nCo-authored-by: Dario-DC <105294544+Dario-DC@users.noreply.github.com>",
    "sha": "991f6a2f36dd01b706a4dbd185e973dd172b6bd4",
    "files": [
        {
            "sha": "ddb8fe09f08714043987f45b8bcfb4f8827edf15",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-form-validation/6733aae9d25004f60d1e86f2.md",
            "status": "modified",
            "additions": 126,
            "deletions": 0,
            "changes": 126,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/991f6a2f36dd01b706a4dbd185e973dd172b6bd4/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-form-validation%2F6733aae9d25004f60d1e86f2.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/991f6a2f36dd01b706a4dbd185e973dd172b6bd4/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-form-validation%2F6733aae9d25004f60d1e86f2.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-form-validation%2F6733aae9d25004f60d1e86f2.md?ref=991f6a2f36dd01b706a4dbd185e973dd172b6bd4",
            "patch": "@@ -10,6 +10,132 @@ dashedName: what-are-some-ways-to-validate-forms-using-javascript\n \n Watch the video lecture and answer the questions below.\n \n+# --transcript--\n+\n+What are some ways to validate forms using JavaScript?\n+\n+Let's learn about how to use JavaScript to validate your forms.\n+\n+In a previous lecture, you've learned how to use HTML to restrict the values your users can submit in your form. But sometimes that's not enough. If you want to get more complex, such as displaying your own error messages to the user, you will need to use JavaScript.\n+\n+Certain HTML elements, such as the `textarea` and `input` elements, expose a Constraint Validation API. This API allows you to assert that the user's provided value for that element passes any HTML-level validation you have written, such as minimum length or pattern matching.\n+\n+But how can you actually use it? Let's say you wanted employees at a company to send feedback messages through a form like this:\n+\n+```html\n+<form>\n+  <label>Enter your email: </label>\n+  <input required type=\"email\" />\n+\n+  <label>Enter your feedback: </label>\n+  <textarea required placeholder=\"Your feedback here...\"></textarea>\n+\n+  <button type=\"submit\">Submit Feedback</button>\n+</form>\n+```\n+\n+We are using the email `input` which comes with built in validation to check for basic validation like if the input includes the at (`@`) sign.\n+\n+But what if the user provides an email address like `example@email.com`? This would pass the basic validation, but we want to be more specific about accepting emails from those with a company email address.\n+\n+This is where we can use the `pattern` attribute to specify that the email address must end in a company email address. Here is what the updated example will look like:\n+\n+```html\n+<form>\n+  <label>Enter your email: </label>\n+  <input required placeholder=\"username@sampleCompany.com\" type=\"email\" pattern=\".+@sampleCompany\\.com\" />\n+\n+  <label>Enter your feedback: </label>\n+  <textarea required placeholder=\"Your feedback here...\"></textarea>\n+\n+  <button type=\"submit\">Submit Feedback</button>\n+</form>\n+```\n+\n+Now, if you try to submit the feedback, you will see a message saying \"Please match the requested format.\"\n+\n+Even though the `input` does have placeholder text showing them the desired format, it would be better to also include a customized error message using JavaScript.\n+\n+Let's first take a look at the `checkValidity()` method:\n+\n+```js\n+const input = document.querySelector(\"input\");\n+\n+input.addEventListener(\"input\", (e) => {\n+  console.log(e.target.checkValidity())\n+})\n+```\n+\n+In the above example, we've queried our input from the DOM, and added an input event listener.\n+\n+We know that `e.target` refers to the element that triggered the event. In this case, our `input`. But what is the `checkValidity()` method?\n+\n+This is part of the Constraint Validation API. The `checkValidity()` method returns `true` if the element matches all HTML validation (based on its attributes), and `false` if it fails.\n+\n+When we try with an invalid input, we see `false` gets logged in the console. Now that we know the input is invalid, let's report the invalidity:\n+\n+```js\n+const input = document.querySelector(\"input\");\n+\n+input.addEventListener(\"input\", (e) => {\n+  if (!e.target.checkValidity()) {\n+    e.target.reportValidity();\n+  }\n+})\n+```\n+\n+And as a result, you will see the browser's error message \"Please match the requested format.\"\n+\n+It reports the invalid state immediately, instead of waiting for us to submit the form. But it's still using the default message. This is because the `reportValidity` method only tells the browser that the input is invalid. The browser still chooses how to display why it's invalid. That's where the `setCustomValidity` method comes in.\n+\n+```js\n+const input = document.querySelector(\"input\");\n+\n+input.addEventListener(\"input\", (e) => {\n+  if (!e.target.checkValidity()) {\n+    e.target.setCustomValidity(\n+      \"You must use a company email address that ends in @sampleCompany.com\"\n+    );\n+  }\n+});\n+```\n+\n+This method accepts a custom error message, which is displayed to the user. As a result, you will see the custom error message `You must use a company email address that ends in @sampleCompany.com`.\n+\n+If you are interested in exploring more about the different types of validity states and why a particular validation has failed, you can log out the `validity` property like this:\n+\n+```js\n+const input = document.querySelector(\"input\");\n+\n+input.addEventListener(\"input\", (e) => {\n+  console.log(e.target.validity);\n+})\n+```\n+\n+The `validity` property is an instance of the `ValidityState` object. Here is an example of what the object might look like in the browser:\n+\n+```javascript\n+ValidityState {\n+  badInput: false,\n+  customError: false,\n+  patternMismatch: true,\n+  rangeOverflow: false,\n+  rangeUnderflow: false,\n+  stepMismatch: false,\n+  tooLong: false,\n+  tooShort: false,\n+  typeMismatch: true,\n+  valueMissing: false,\n+  valid: true\n+}\n+```\n+\n+There are several helpful properties which all hold the value of a boolean of `true` or `false`.\n+\n+Some of these helpful properties that you can explore more on your own would be the `valueMissing` property which is `true` when a required input field is left empty. Or the `patternMismatch` which is `true` if the value doesn't match the specified regular expression pattern.\n+\n+After this lecture video, I encourage you to play around with the examples shown in this video and explore more about the different validity properties.\n+\n # --questions--\n \n ## --text--"
        },
        {
            "sha": "99f8ec730939a5371be78ab59ae9d654997da685",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-form-validation/6733d3a33abdd27cd562bdf2.md",
            "status": "modified",
            "additions": 77,
            "deletions": 0,
            "changes": 77,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/991f6a2f36dd01b706a4dbd185e973dd172b6bd4/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-form-validation%2F6733d3a33abdd27cd562bdf2.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/991f6a2f36dd01b706a4dbd185e973dd172b6bd4/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-form-validation%2F6733d3a33abdd27cd562bdf2.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-form-validation%2F6733d3a33abdd27cd562bdf2.md?ref=991f6a2f36dd01b706a4dbd185e973dd172b6bd4",
            "patch": "@@ -10,6 +10,83 @@ dashedName: what-is-the-purpose-of-e-preventdefault\n \n Watch the lecture video and answer the questions below.\n \n+# --transcript--\n+\n+What is the purpose of the `preventDefault()` method?\n+\n+Let's learn about the purpose of the `preventDefault()` method on events.\n+\n+Every event that triggers in the DOM has some sort of default behavior. The `click` event on a checkbox toggles the state of that checkbox, by default. Pressing the space bar on a focused button activates the button. The `preventDefault()` method on these event objects stops that behavior from happening.\n+\n+Let's take a look at an example. Let's define an `input` element for a user to type in:\n+\n+```html\n+<label>Enter some characters:\n+  <input type=\"text\">\n+</label>\n+```\n+\n+And if we look at the result, we can type in the input field as expected. But maybe we don't want that. Maybe, instead, we'd like to show the character the user types in a separate element. First, let's define our element for that:\n+\n+```html\n+<label>Enter some characters:\n+  <input type=\"text\">\n+</label>\n+<p id=\"output\"></p>\n+```\n+\n+And then, we need to hook into the `keydown` event to listen for a character being typed on the keyboard. Note that we do not want the `change` or `input` events here, because we need the keyboard information.\n+\n+```javascript\n+const input = document.querySelector(\"input\");\n+\n+input.addEventListener(\"keydown\", (e) => {\n+    \n+})\n+```\n+\n+The `keydown` event fires when you press down on a keyboard key. When this happens, let's display the character in our `p` element.\n+\n+```javascript\n+const input = document.querySelector(\"input\");\n+const output = document.getElementById(\"output\");\n+\n+input.addEventListener(\"keydown\", (e) => {\n+  output.innerText = `You pressed the ${e.key} key`;\n+});\n+```\n+\n+`e.key` gives you the value of the key pressed, such as `a` for the `a` key or `Enter` for the `Enter` key.\n+\n+With the above code, when you type in the `input`, the character you type will be displayed in the `p` element. \n+\n+This is great, but we don't want to show the characters in the `input` as well. This is where our `preventDefault()` method comes in. The default behavior of a `keydown` is to render the character in the input. Let's avoid that by calling `e.preventDefault()`:\n+\n+```javascript\n+const input = document.querySelector(\"input\");\n+const output = document.getElementById(\"output\");\n+\n+input.addEventListener(\"keydown\", (e) => {\n+  e.preventDefault();\n+  output.innerText = `You pressed the ${e.key} key`;\n+});\n+```\n+\n+And just like that, you have prevented the default behavior to allow yourself to implement your own custom event handling.\n+\n+Another common example of when to use the `e.preventDefault` method has to deal with form submissions. By default, submitting a form sends data to the server and reloads the page. Using `e.preventDefault()` prevents this from happening.\n+\n+```js\n+const form = document.querySelector(\"form\");\n+\n+form.addEventListener(\"submit\", (e) => {\n+  e.preventDefault();\n+  // rest of code goes here\n+});\n+```\n+\n+Preventing the default behavior is great when you need more control over how a user interacts with the page, but it's important to keep things like accessibility in mind â€“ your custom behavior should provide the same features as the default.\n+\n # --questions--\n \n ## --text--"
        },
        {
            "sha": "765bb720f0a4041127869e57ada5b4bdeb4a22d1",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-form-validation/6733d3ab69e94b7df7ee91b0.md",
            "status": "modified",
            "additions": 69,
            "deletions": 0,
            "changes": 69,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/991f6a2f36dd01b706a4dbd185e973dd172b6bd4/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-form-validation%2F6733d3ab69e94b7df7ee91b0.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/991f6a2f36dd01b706a4dbd185e973dd172b6bd4/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-form-validation%2F6733d3ab69e94b7df7ee91b0.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-form-validation%2F6733d3ab69e94b7df7ee91b0.md?ref=991f6a2f36dd01b706a4dbd185e973dd172b6bd4",
            "patch": "@@ -10,6 +10,75 @@ dashedName: how-does-the-submit-event-work-with-forms\n \n Watch the lecture video and answer the questions below.\n \n+# --transcript--\n+\n+How does the `submit` event work with forms?\n+\n+Let's learn about how the `submit` event works with HTML forms. First, we need to understand how to submit a form. There are three ways a form can be submitted.\n+\n+The first is when the user clicks a button in the form which has the `type` attribute set to `submit`.\n+\n+The second is when the user presses the Enter key on any editable input field in the form.\n+\n+The third is through a JavaScript call to the `requestSubmit()` or `submit()` methods of the form element.\n+\n+But what happens when a form is submitted? There's a few things that happen, and the behavior of the form depends on its attributes.\n+\n+The first attribute that we need to look at is the `action` attribute. The `action` attribute should contain either a URL or a relative path for the current domain. This value determines where the form attempts to send data. If you do not set an `action` attribute, the form will send data to the current page's URL. Here is an example of a form with an `action` attribute set to a specific URL:\n+\n+```html\n+<form action=\"https://freecodecamp.org\">\n+  <input type=\"number\" id=\"input\" placeholder=\"Enter a number\" name=\"number\" />\n+  <button type=\"submit\">Submit</button>\n+</form>\n+```\n+\n+When this form is submitted, it will send data to freeCodeCamp's homepage, which probably won't do anything.\n+\n+Here's another form, which submits to a relative path:\n+\n+```html\n+<form action=\"/data\">\n+  <input type=\"number\" id=\"input\" placeholder=\"Enter a number\" name=\"number\" />\n+  <button type=\"submit\">Submit</button>\n+</form>\n+```\n+\n+This one submits to the `/data` path on the current domain. In our case, it would submit to `http://127.0.0.1:5500/data`.\n+\n+The second attribute to control how a submission behaves is the `method` attribute. This attribute accepts a standard HTTP method, such as `GET` or `POST`, and uses that method when making the request to the `action` URL.\n+\n+HTTP stands for Hypertext Transfer Protocol and it is used to transfer data over the web.\n+\n+HTTP methods are used to define the actions that can be performed on resources, such as `GET`, `POST`, `PUT`, `DELETE`, and so on. You will more about these methods in future lecture videos.\n+\n+When a method is not set, the form will default to a `GET` request. A `GET` request is used to retrieve data from a specified resource without making any changes to it, and the parameters are typically appended to the URL in the form of a query string.\n+\n+The data in the form will be URL encoded as `name=value` pairs and appended to the `action` URL as query parameters. For instance, by submitting the form from our previous example with the value of `3342` for the `input` field, the form would try to `GET` the URL `http://127.0.0.1:5500/data?number=3342`.\n+\n+This is great for something like a search form, where your user is querying data. But if you want your user to submit new data, such as in a registration form, the idiomatic method to use would be the `POST` method. The `POST` method is used to send data to the server to create or update a resource.\n+\n+Let's set the `method` attribute to the value of `POST`:\n+\n+```xml\n+<form action=\"/data\" method=\"POST\">\n+  <input type=\"number\" id=\"input\" placeholder=\"Enter a number\" name=\"number\" />\n+  <button type=\"submit\">Submit</button>\n+</form>\n+```\n+\n+When you send a `POST` request, a body can be included which contains the data for your request. So unlike a `GET`, the data are not appended to the URL, and our form sends the `POST` request to `http://127.0.0.1:5500/data`. The data, instead, can be found in the body of the request, still as URL-encoded form data.\n+\n+URL-encoded form data is when form data is converted into a string of key-value pairs, like `name=John+Doe&email=john%40example.com`, where special characters are replaced with encoded versions to safely send the data over the web. You will learn more about this in future lecture videos.\n+\n+But maybe you don't want to send the data as a URL-encoded form payload?\n+\n+The `form` element accepts an `enctype` attribute, which represents the encoding type to use for the data.\n+\n+This attribute only accepts three values: `application/x-www-form-urlencoded` (which is the default, sending the data as a URL-encoded form body), `text/plain` (which sends the data in plaintext form, in `name=value` pairs separated by new lines), or `mulitpart/form-data`, which is specifically for handling forms with a file upload.\n+\n+In this video, you've learned the basics of form submissions. In future videos, we'll dive deeper into working with forms and how they interact with the server.\n+\n # --questions--\n \n ## --text--"
        }
    ],
    "stats": {
        "total": 272,
        "additions": 272,
        "deletions": 0
    }
}