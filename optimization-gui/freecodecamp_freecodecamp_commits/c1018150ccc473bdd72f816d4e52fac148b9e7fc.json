{
    "author": "majestic-owl448",
    "message": "feat(curriculum): add graphs and trees lecture (#62055)\n\nCo-authored-by: Jessica Wilkins <67210629+jdwilkin4@users.noreply.github.com>\nCo-authored-by: Copilot <175728472+Copilot@users.noreply.github.com>",
    "sha": "c1018150ccc473bdd72f816d4e52fac148b9e7fc",
    "files": [
        {
            "sha": "14d16c7b68b9dbd85d6d9ec11802f36988ab1b8e",
            "filename": "client/i18n/locales/english/intro.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/c1018150ccc473bdd72f816d4e52fac148b9e7fc/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/c1018150ccc473bdd72f816d4e52fac148b9e7fc/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json?ref=c1018150ccc473bdd72f816d4e52fac148b9e7fc",
            "patch": "@@ -4643,7 +4643,7 @@\n       \"lecture-understanding-graphs-and-trees\": {\n         \"title\": \"Understanding Graphs and Trees\",\n         \"intro\": [\n-          \"Learn about Understanding Graphs and Trees in these lectures.\"\n+          \"In this lecture, you will learn about fundamental data structures like graphs, trees, and their practical applications in computer science.\"\n         ]\n       },\n       \"workshop-shortest-path-algorithm\": {"
        },
        {
            "sha": "97e5c6c9051049ff2c04cdf66e1e10087b45f857",
            "filename": "client/src/pages/learn/full-stack-developer/lecture-understanding-graphs-and-trees/index.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/c1018150ccc473bdd72f816d4e52fac148b9e7fc/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-understanding-graphs-and-trees%2Findex.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/c1018150ccc473bdd72f816d4e52fac148b9e7fc/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-understanding-graphs-and-trees%2Findex.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-understanding-graphs-and-trees%2Findex.md?ref=c1018150ccc473bdd72f816d4e52fac148b9e7fc",
            "patch": "@@ -6,4 +6,4 @@ superBlock: full-stack-developer\n \n ## Introduction to Understanding Graphs and Trees\n \n-Learn about Understanding Graphs and Trees in these lectures.\n+In this lecture, you will learn about fundamental data structures like graphs, trees, and their practical applications in computer science."
        },
        {
            "sha": "accdedc4aed43dc2496858b800ba9100888162e4",
            "filename": "curriculum/challenges/english/blocks/lecture-understanding-graphs-and-trees/68420c5ac17cf26ab2a4ca3c.md",
            "status": "modified",
            "additions": 152,
            "deletions": 44,
            "changes": 196,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/c1018150ccc473bdd72f816d4e52fac148b9e7fc/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68420c5ac17cf26ab2a4ca3c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/c1018150ccc473bdd72f816d4e52fac148b9e7fc/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68420c5ac17cf26ab2a4ca3c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68420c5ac17cf26ab2a4ca3c.md?ref=c1018150ccc473bdd72f816d4e52fac148b9e7fc",
            "patch": "@@ -1,135 +1,243 @@\n ---\n id: 68420c5ac17cf26ab2a4ca3c\n-# title needs to be updated to correct title when lectures are finalized\n-title: Understanding Graphs and Trees\n+title: What Are Graphs in Computer Science?\n challengeType: 19\n-# dashedName needs to be updated to correct title when lectures are finalized\n-dashedName: lecture-understanding-graphs-and-trees\n+dashedName: what-are-graphs-in-computer-science\n ---\n \n # --description--\n \n-Watch the video or read the transcript and answer the questions below.\n+Graphs are data structures used to represent the connections or relationships between objects or entities. They're often used to model networks.\n+\n+The types of networks that you can model with a graph include social networks, transportation networks, communications networks, and even recommendation systems.\n+\n+For example, graphs can represent connections between users on a social media platform, or connections between cities on a road network.\n+\n+They're very versatile.\n+\n+A graph is often represented as a collection of points or circles connected by lines.\n+\n+These circles and lines represent the two main components of a graph: nodes and edges.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-graphs-in-computer-science-1.png\" alt=\"A simple graph showing five nodes labeled A, B, C, D, and E connected by edges. Node A connects to B, B connects to A, C, and D, C connects to B and D, D connects to B, C, and E, and E connects to D.\">\n+\n+**Nodes**, also known as vertices, represent the objects or entities that are part of the network modeled by the graph. They could be users, products, stations, cities, or any other entities in the model.\n+\n+In this example, nodes are represented as circles and labeled with the letters A, B, C, D, and E to distinguish them visually.\n+\n+**Edges** are the connections between the nodes. If two nodes are connected by an edge, that means that they're somehow connected in the network.\n+\n+In this example, there are five edges connecting the different pairs of nodes. Node A is connected to node B. node B is connected to nodes A, C, and D and so on.\n+\n+The specific meaning of the connection will depend on the context. It may be physical, like a real road that connects two cities, or it could be more abstract, like the connection between two users on a social media platform.\n+\n+If two nodes are directly connected by an edge, like nodes A and B in this example, they're known as **adjacent nodes**.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-graphs-in-computer-science-2.png\" alt=\"The same graph with nodes A and B highlighted to illustrate adjacent nodes - two nodes that are directly connected by an edge.\">\n+\n+## Types of Graphs\n+\n+There are different types of graphs with different characteristics and applications. Let's go over some of them.\n+\n+### Undirected Graphs\n+\n+**Undirected graphs** are graphs where the edges don't have a specific direction. This type of edge is usually represented with a straight line between the nodes.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-graphs-in-computer-science-1.png\" alt=\"An example of an undirected graph where all edges are represented as straight lines without arrows, demonstrating that connections work in both directions between nodes.\">\n+\n+This means that, if there's an edge connecting nodes A and B, the connection works in both directions: from node A to node B and from node B to node A.\n+\n+Depending on the network that is being modeled by the graph, this connection can have different meanings.\n+\n+For example, if you're modeling connections between users of a social media platform, this means that user A is connected to user B and user B is connected to user A. The connection is bidirectional.\n+\n+### Directed Graphs\n+\n+In contrast, **directed graphs** are graphs where the edges do have a specific direction.\n+\n+If there is a connection from node A to node B, that doesn't necessarily imply that there is a connection from node B to node A.\n+\n+The edges of a directed graph are often represented as straight lines that end with an arrow to indicate the direction.\n+\n+Here's an example. In this graph, you can go from node A to node B but not from node B to node A because of the direction of the edge.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-graphs-in-computer-science-4.png\" alt=\"A directed graph example showing the same nodes as before but with arrows indicating specific one-way connections: from A to B, B to C, C to D, D to B, and D to E, demonstrating unidirectional edges.\">\n+\n+For example, if you are modeling a road network, this would be helpful to model one-way streets or roads. You can go from city A to city B through that road, but not from city B to city A. You'll need to take a different route.\n+\n+If there is a two-way connection between the nodes of a directed graph, you can represent this with two directed edges between them.\n+\n+Here you can see an example. You can go from node B to node D and from node D to node B because there are two edges connecting them, but each edge has a direction.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-graphs-in-computer-science-5.png\" alt=\"A directed graph showing bidirectional connection between nodes B and D with two arrows, one pointing from B to D and another from D to B.\">\n+\n+## Vertex Labeled Graphs\n+\n+A **vertex labeled graph** is a graph in which each node is associated with a label or identifier in addition to its data. These labels are used to identify the nodes, represent them visually, and store additional information about them.\n+\n+For example, in a transportation network graph, nodes could be cities and their labels could be their names, coordinates, or any other characteristic that would be helpful for the purposes of the model.\n+\n+## Cyclic Graphs\n+\n+**Cyclic graphs** are directed graphs with at least one cycle.\n+\n+A **cycle** is a path that you can follow through the edges of graph that will take you back to the initial node where you started.\n+\n+In this example, we have a directed graph. If you look more closely, you'll notice that it has a cycle. If we start at node B, go to node C, and then to node D, we can go back to node B again through the directed edges.\n+\n+This is a cycle, so this is a cyclic graph.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-graphs-in-computer-science-6.png\" alt=\"A directed graph showing a cycle where you can start at node B, go to node C, then to node D, and back to node B, forming a complete cycle.\">\n+\n+## Edge Labeled Graphs\n+\n+In **edge labeled graphs**, edges are associated with labels. These labels are usually drawn next to their corresponding edges.\n+\n+## Weighted Graphs\n+\n+**Weighted graphs** are a specific type of edge labeled graph in which the labels on the edges represent values that can be compared and used to perform arithmetic operations.\n+\n+Some edges have a higher weight, while others have a lower weight. These weights represent the \"cost\" of the edge.\n+\n+For example, they may represent the distance between two cities or the time it takes to get from one city to the next.\n+\n+This is an example of a weighted graph. We write each weight next to its corresponding edge. The \"cost\" of going from node B to node D is 3, and since this is an undirected graph, that's the same cost of going from node D back to node B.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-graphs-in-computer-science-7.png\" alt=\"A weighted graph showing nodes connected by edges with numerical weights labeled next to each edge, such as weight 3 between nodes B and D.\">\n+\n+## Directed Acyclic Graph\n+\n+Another very common type of graph in computer science is the **directed acyclic graph**, which is a directed graph with no cycles.\n+\n+Here's an example. It's a directed graph because each edge has a direction.\n+\n+It's acyclic because it doesn't have any cycles. Why? Notice that, if you start at a specific node, you cannot go back to it because of the direction of the edges.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-graphs-in-computer-science-8.png\" alt=\"A directed acyclic graph (DAG) with connections from A to B, B to C, B to D, C to D, and D to E, demonstrating how the directional flow prevents any cycles from forming.\">\n+\n+## Disconnected Graph\n+\n+And the last type of graph that we'll cover in this lecture is the **disconnected graph**.\n+\n+A disconnected graph is a graph with two or more groups of nodes that are not connected by any edges.\n+\n+A real-world example would be a social media network, where you have two or more groups of people who don't know each other and who have no friends in common.\n+\n+This is an example. The first component has the nodes A, B, and C. The second component has the nodes D and E. These components don't have any edges between them, so this is a disconnected graph.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-graphs-in-computer-science-9.png\" alt=\"A disconnected graph showing two separate components: the first component has nodes A, B, and C connected in sequence (A connects to B, B connects to C), and the second component has nodes D and E connected to each other, with no connections between the two components.\">\n+\n+You can implement graphs in a variety of ways, including sets, functions, and arrays. You'll learn more about this in the coming lectures.\n+\n+Understanding graphs and the characteristics of the different types of graphs is essential for solving a wide range of problems in computer science and other fields.\n \n # --questions--\n \n ## --text--\n \n-Question 1\n+What is a graph in computer science?\n \n ## --answers--\n \n-Answer 1.1\n-\n-### --feedback--\n-\n-Feedback 1\n+A data structure used to represent relationships between objects.\n \n ---\n \n-Answer 1.2\n+A mathematical equation.\n \n ### --feedback--\n \n-Feedback 1\n+Think about how graphs are used to model connections and relationships.\n \n ---\n \n-Answer 1.3\n+A visual representation of data.\n \n ### --feedback--\n \n-Feedback 1\n+Think about how graphs are used to model connections and relationships.\n \n ---\n \n-Answer 1.4\n+A programming language.\n \n ### --feedback--\n \n-Feedback 1\n+Think about how graphs are used to model connections and relationships.\n \n ## --video-solution--\n \n-5\n+1\n \n ## --text--\n \n-Question 2\n+What are the two main components of a graph?\n \n ## --answers--\n \n-Answer 2.1\n+Points and lines\n \n ### --feedback--\n \n-Feedback 2\n+Think about the basic building blocks of a graph.\n \n ---\n \n-Answer 2.2\n+Vertices and nodes\n \n ### --feedback--\n \n-Feedback 2\n+Think about the basic building blocks of a graph.\n \n ---\n \n-Answer 2.3\n-\n-### --feedback--\n-\n-Feedback 2\n+Nodes and edges\n \n ---\n \n-Answer 2.4\n+Elements and vertices\n \n ### --feedback--\n \n-Feedback 2\n+Think about the basic building blocks of a graph.\n \n ## --video-solution--\n \n-5\n+3\n \n ## --text--\n \n-Question 3\n+What is a directed graph?\n \n ## --answers--\n \n-Answer 3.1\n+A graph where edges do not have a direction.\n \n ### --feedback--\n \n-Feedback 3\n+Think about whether the connections between nodes have a specific direction.\n \n ---\n \n-Answer 3.2\n-\n-### --feedback--\n-\n-Feedback 3\n+A graph where edges have a direction.\n \n ---\n \n-Answer 3.3\n+A graph with more nodes than edges.\n \n ### --feedback--\n \n-Feedback 3\n+Think about whether the connections between nodes have a specific direction.\n \n ---\n \n-Answer 3.4\n+A graph with more edges than nodes.\n \n ### --feedback--\n \n-Feedback 3\n+Think about whether the connections between nodes have a specific direction.\n \n ## --video-solution--\n \n-5\n+2\n "
        },
        {
            "sha": "bb2c08344492336e417d3fe83235907d11737e70",
            "filename": "curriculum/challenges/english/blocks/lecture-understanding-graphs-and-trees/68baa5e4f0e07f079245ca08.md",
            "status": "added",
            "additions": 370,
            "deletions": 0,
            "changes": 370,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/c1018150ccc473bdd72f816d4e52fac148b9e7fc/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68baa5e4f0e07f079245ca08.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/c1018150ccc473bdd72f816d4e52fac148b9e7fc/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68baa5e4f0e07f079245ca08.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68baa5e4f0e07f079245ca08.md?ref=c1018150ccc473bdd72f816d4e52fac148b9e7fc",
            "patch": "@@ -0,0 +1,370 @@\n+---\n+id: 68baa5e4f0e07f079245ca08\n+title: How Do Depth First and Breadth First Search Work?\n+challengeType: 19\n+dashedName: how-do-depth-first-and-breadth-first-search-work\n+---\n+\n+# --description--\n+\n+As you start working with data structures and algorithms, you'll soon realize that one of the common operations that you'll need to perform is visiting each node.\n+\n+This process is known as \"traversing\" the data structure.\n+\n+Traversals are used to do something with every single node in the data structure, like printing their values, finding a specific value, or performing certain operations on the nodes.\n+\n+By systematically visiting each node, you make sure that the process won't skip any nodes.\n+\n+But how do you determine the order in which you should traverse the data structure? Where should the process start, and how should the next node be selected?\n+\n+Without a clear way to traverse the data structure, going through it would be like walking through a maze without a specific path to follow.\n+\n+That's where algorithms like breadth-first search (BFS) and depth-first search (DFS) become really important. They are commonly used to traverse graphs and for finding a path between two nodes.\n+\n+When they are used to traverse a data structure, they define the order in which the nodes should be visited to make sure that none of them is skipped.\n+\n+Let's start with breadth-first search (BFS).\n+\n+## Breadth-First Search (BFS)\n+\n+**Breadth-first search (BFS)** is an algorithm that visits all neighboring nodes before moving to the next level in the graph.\n+\n+It can be used to find the shortest path between two nodes in an unweighted graph because it analyzes all the nodes at each level, so it finds the path with fewest edges first.\n+\n+This algorithm is commonly implemented using a queue data structure to keep track of the nodes that have been visited. Queues follow the FIFO (first in, first out) method, where the first node that was added to the queue is the first one to be removed.\n+\n+The algorithm works like this:\n+\n+* You start at a specific node.\n+    \n+* That node is marked as visited and added to the queue.\n+    \n+* While the queue is not empty, the current node is removed from the queue (dequeued). Then, for each one of its neighbors, if the neighbor has not been visited, it is marked as visited and added to the queue.\n+    \n+\n+One important consideration is that, since breadth-first search (BFS) requires storing a queue in memory, and this queue may have a large number of nodes, the space requirements of this algorithm can be considerable. This is especially true for graphs with a large number of nodes on the same level.\n+\n+Let's see an example of BFS applied to a specific type of graph called a tree.\n+\n+You will learn more about trees in an upcoming lecture, but they are essentially graphs with no cycles, where nodes are organized in a hierarchy. Cycles are paths that start and end at the same node.\n+\n+Let's apply the breadth-first search (BFS) algorithm to this tree:\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-1.png\" alt=\"A tree diagram showing nodes A through G arranged in a hierarchy. Node A is at the root, with children B and C. Node B has children D and E, and node C has children F and G.\">\n+\n+**Step 1:**\n+\n+We start at the root of the tree, node A. We add A to the queue and immediately mark it as visited.\n+\n+* **Queue:** `[A]`\n+    \n+* **Visited:** `{A}`\n+    \n+\n+**Step 2:**\n+\n+We dequeue node A. We add its unvisited children (node B and then node C), to the queue and mark them as visited.\n+\n+* **Queue:** `[B, C]`\n+    \n+* **Visited:** `{A, B, C}`\n+    \n+\n+The order in which nodes at the same level are added to the queue is defined by the implementation of the data structure and the order in which the edges (connections) are stored in the graph representation.\n+\n+If the implementation is consistent, the specific order in which the nodes at the same level are traversed will not affect the correctness of the algorithm. It will still visit every node level by level.\n+\n+**Step 3:**\n+\n+We dequeue node B. We add its unvisited children, (node D and then node E), to the queue and mark them as visited.\n+\n+* **Queue:** `[C, D, E]`\n+    \n+* **Visited:** `{A, B, C, D, E}`\n+    \n+\n+**Step 4:**\n+\n+We dequeue node C. We add its unvisited children, (node F and then node G), to the queue and mark them as visited.\n+\n+* **Queue:** `[D, E, F, G]`\n+    \n+* **Visited:** `{A, B, C, D, E, F, G}`\n+    \n+\n+**Step 5:**\n+\n+We dequeue node D. This node does not have any unvisited children, so nothing changes in the visited set.\n+\n+* **Queue:** `[E, F, G]`\n+    \n+* **Visited:** `{A, B, C, D, E, F, G}`\n+    \n+\n+**Step 6:**\n+\n+We dequeue node E. This node does not have any unvisited children, so nothing changes in the visited set.\n+\n+* **Queue:** `[F, G]`\n+    \n+* **Visited:** `{A, B, C, D, E, F, G}`\n+    \n+\n+**Step 7:**\n+\n+We dequeue F. This node does not have any unvisited children, so nothing changes in the visited set.\n+\n+* **Queue:** `[G]`\n+    \n+* **Visited:** `{A, B, C, D, E, F, G}`\n+    \n+\n+**Step 8:**\n+\n+We dequeue G. This node does not have any unvisited children, so nothing changes in the visited set.\n+\n+* **Queue:** `[]`\n+    \n+* **Visited:** `{A, B, C, D, E, F, G}`\n+    \n+\n+When the queue is empty, the traversal is complete.\n+\n+The nodes were traversed in this order:\n+\n+**A → B → C → D → E → F → G**\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-2.png\" alt=\"The same tree diagram with arrows showing the BFS traversal order: A to B to C to D to E to F to G, demonstrating level-by-level visitation.\">\n+\n+Notice how the algorithm visits the nodes per level.\n+\n+We start at node A, then move to the next level to visit nodes B and C, then to the next level to nodes D, E, F, and G. That is the core principle of breadth-first search (BFS).\n+\n+## Depth-First Search (DFS)\n+\n+While breadth-first search (BFS) first visits all the neighboring nodes at the same level, **depth-first search (DFS)** follows each branch as deep as possible before it backtracks.\n+\n+You can imagine this algorithm as exploring a maze by choosing a specific path and following it until you reach a dead end or the exit. If you reach a dead end, you go back and choose a different path.\n+\n+Depth-first search (DFS) is commonly used to solve puzzles with a single solution, detecting cycles in a graph, and finding connected graph components.\n+\n+This algorithm can be implemented using recursion or a stack data structure to keep track of the visited nodes.\n+\n+Stacks follow the LIFO (last in, first out) method, where the last node that was added to the stack is the first one to the removed from the stack.\n+\n+The algorithm works like this:\n+\n+* Start at a specific node.\n+    \n+* That node is marked as visited and added to the stack.\n+    \n+* While the stack is not empty, the current node is popped (removed). This is when we \"visit\" or process it (for example, by printing its value). Then, all of its unvisited neighbors are marked as visited and added to the stack.\n+    \n+\n+One of the limitations of this algorithm is that it's not always guaranteed to find the shortest path between two nodes in an unweighted graph.\n+\n+Let's see an example of Depth-First Search (DFS) applied to our tree example.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-3.png\" alt=\"The same tree diagram as before, showing nodes A through G in their hierarchical structure, ready for DFS demonstration.\">\n+\n+**Step 1:**\n+\n+We start at the root node A. We mark it as visited and add it to the stack.\n+\n+* **Stack:** `[A]`\n+    \n+* **Visited:** `{A}`\n+    \n+\n+**Step 2:**\n+\n+We pop node A from the stack.\n+\n+Then, we add its unvisited children, node B and node C, to the stack. We'll add them in reverse order, `C` then `B`, so that `B` is on top (LIFO) and will be processed next. We also mark them as visited.\n+\n+* **Stack:** `[C, B]`\n+    \n+* **Visited:** `{A, B, C}`\n+    \n+\n+**Step 3:**\n+\n+We pop node B from the stack.\n+\n+Then, we add its unvisited children, node D and node E, to the stack in reverse order (`E` then `D`). We also mark them as visited.\n+\n+* **Stack:** `[C, E, D]`\n+    \n+* **Visited:** `{A, B, C, D, E}`\n+    \n+\n+**Step 4:**\n+\n+We pop node D from the stack. This node has no children to add to the stack.\n+\n+* **Stack:** `[C, E]`\n+    \n+* **Visited:** `{A, B, C, D, E}`\n+    \n+\n+**Step 5:**\n+\n+We pop node E from the stack. This node has no children to add to the stack.\n+\n+* **Stack:** `[C]`\n+    \n+* **Visited:** `{A, B, C, D, E}`\n+    \n+\n+**Step 6:**\n+\n+We pop node C.\n+\n+Then, we add its children, node F and node G, to the stack in reverse order (node G then node F) and we mark them as visited.\n+\n+* **Stack:** `[G, F]`\n+    \n+* **Visited:** `{A, B, C, D, E, F, G}`\n+    \n+\n+**Step 7:**\n+\n+We pop node F from the stack. This node has no children to add to the stack.\n+\n+* **Stack:** `[G]`\n+    \n+* **Visited:** `{A, B, C, D, E, F, G}`\n+    \n+\n+**Step 8:**\n+\n+We pop node G. This node has no children to add to the stack.\n+\n+* **Stack:** `[]`\n+    \n+* **Visited:** `{A, B, C, D, E, F, G}`\n+    \n+\n+When the stack is empty, the traversal is completed and all nodes have been visited.\n+\n+The algorithm visited the nodes in this order:\n+\n+**A → B → D → E → C → F → G**\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-4.png\" alt=\"The tree diagram with numbers showing the DFS traversal order: A(1), B(2), D(3), E(4), C(5), F(6), G(7), demonstrating depth-first exploration of branches.\">\n+\n+Notice how we start at node A, and then move all the way down the tree to node B, and nodes D and E, before we move up again to node C and then nodes F and G. This is the core principle of depth-first search (DFS), traversing full paths before backtracking and finding other paths.\n+\n+In this case, we solved this example using a stack. Alternatively, depth-first search (DFS) can be implemented using recursion, where the function processes the current node and then call itself for each of its unvisited neighbors. The function call stack implicitly manages the LIFO (last-in, first-out) order.\n+\n+Both breadth-first search (BFS) and depth-first search (DFS) are essential algorithms for traversing graphs and trees. Breadth-first search (BFS) explores nodes level by level, which is perfect for finding the shortest path in an unweighted graph. On the other hand, depth-first search (DFS) follows one branch as deep as possible before backtracking, which is perfect for solving mazes and detecting cycles. Understanding their pros and cons is helpful for choosing the right one for a particular problem.\n+\n+# --questions--\n+\n+## --text--\n+\n+Which of the following data structures is commonly used to implement a standard breadth-first search (BFS) algorithm?\n+\n+## --answers--\n+\n+Stack\n+\n+### --feedback--\n+\n+Think about how a queue processes data and how that relates to visiting nodes level by level.\n+\n+---\n+\n+Queue\n+\n+---\n+\n+Linked List\n+\n+### --feedback--\n+\n+Think about how a queue processes data and how that relates to visiting nodes level by level.\n+\n+---\n+\n+Tree\n+\n+### --feedback--\n+\n+Think about how a queue processes data and how that relates to visiting nodes level by level.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+Which of the following statements about depth-first search (DFS) is true?\n+\n+## --answers--\n+\n+Depth-first search is guaranteed to find the shortest path between two nodes in an unweighted graph.\n+\n+### --feedback--\n+\n+Think about the strategy that depth-first search (DFS) uses to traverse the data structure.\n+\n+---\n+\n+Depth-first search visits all neighbors at the current level before moving to the next level.\n+\n+### --feedback--\n+\n+Think about the strategy that depth-first search (DFS) uses to traverse the data structure.\n+\n+---\n+\n+Depth-first search is always more space-efficient than BFS.\n+\n+### --feedback--\n+\n+Think about the strategy that depth-first search (DFS) uses to traverse the data structure.\n+\n+---\n+\n+Depth-first search is typically implemented using recursion or a stack.\n+\n+## --video-solution--\n+\n+4\n+\n+## --text--\n+\n+If you wanted to find the shortest path from a starting node to a target node in an unweighted graph, which algorithm would be the most suitable choice?\n+\n+## --answers--\n+\n+Breadth-first search (BFS)\n+\n+---\n+\n+Depth-first search (DFS)\n+\n+### --feedback--\n+\n+Think about the core traversal strategy of breadth-first search and depth-first search and which one guarantees finding the shortest path between two nodes.\n+\n+---\n+\n+Binary search\n+\n+### --feedback--\n+\n+Think about the core traversal strategy of breadth-first search and depth-first search and which one guarantees finding the shortest path between two nodes.\n+\n+---\n+\n+Merge sort\n+\n+### --feedback--\n+\n+Think about the core traversal strategy of breadth-first search and depth-first search and which one guarantees finding the shortest path between two nodes.\n+\n+## --video-solution--\n+\n+1"
        },
        {
            "sha": "d93cc6d8c5b0c07dbf7c822d38df8dc26e8eedff",
            "filename": "curriculum/challenges/english/blocks/lecture-understanding-graphs-and-trees/68baa5e4f0e07f079245ca09.md",
            "status": "added",
            "additions": 252,
            "deletions": 0,
            "changes": 252,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/c1018150ccc473bdd72f816d4e52fac148b9e7fc/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68baa5e4f0e07f079245ca09.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/c1018150ccc473bdd72f816d4e52fac148b9e7fc/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68baa5e4f0e07f079245ca09.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68baa5e4f0e07f079245ca09.md?ref=c1018150ccc473bdd72f816d4e52fac148b9e7fc",
            "patch": "@@ -0,0 +1,252 @@\n+---\n+id: 68baa5e4f0e07f079245ca09\n+title: How Do Matrices and Adjacency Lists Work?\n+challengeType: 19\n+dashedName: how-do-matrices-and-adjacency-lists-work\n+---\n+\n+# --description--\n+\n+Graphs are very powerful data structures made by a set of nodes, also known as vertices, and edges that connect them.\n+\n+There are two common ways to implement graphs in your code:\n+\n+* Adjacency matrices\n+    \n+* Adjacency lists\n+    \n+\n+Let's look more into these, and go over their advantages and limitations.\n+\n+## Adjacency Matrices\n+\n+We'll start with adjacency matrices.\n+\n+An adjacency matrix is a two-dimensional list in which the rows and columns represent the graph's vertices.\n+\n+The values in the matrix represent the edges or connections between the nodes.\n+\n+For example, if you have a matrix stored in a variable named `matrix`, the value stored at `matrix[i][j]`, where `i` is the row and `j` is the column, represents the edge or connection between nodes `i` and node `j`.\n+\n+The values may have different meanings depending on whether the graph is weighted or unweighted:\n+\n+* If the graph is unweighted, a value of `1` means that there is an edge connecting these nodes, while a value of `0` means there is no edge between them.\n+    \n+* If the graph is weighted, the value would represent the weight of the edge that connects the nodes.\n+    \n+\n+One of the great advantages of using an adjacency matrix is that checking if there is an edge between two nodes takes constant time `O(1)`. This is because the program only needs to find that particular value in the 2D list.\n+\n+However, this efficiency in finding the edges comes with a tradeoff. Adjacency matrices have a large quadratic space requirement `O(V²)`, where `V` is the number of nodes in the graph.\n+\n+This is inefficient for sparse graphs, which are graphs that only have a few edges. Why? Because if the graph is sparse, you will be storing many 0s in the matrix to represent the lack of edges between the nodes, and these 0s will still take space in memory.\n+\n+Adjacency matrices are also inefficient for finding a node's neighbors because the program has to iterate over the entire row or column to find the 0s and 1s that represent the edges. In the worst case, this process can take O(V) time, where V is the number of nodes in the graph.\n+\n+Let's see an example of an adjacency matrix for this particular graph:\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-matrices-and-adjacency-lists-work-1.png\" alt=\"A graph with four nodes labeled A, B, C, and D. Node A connects to B, C, and D. Node B connects to A and D. Node C connects to A. Node D connects to A and B.\">\n+\n+In the adjacency matrix:\n+\n+* Each row represents a node. The first row represents node A, the second row represents node B, and so on.\n+    \n+* Each column represents a node too.\n+    \n+* Each value in the matrix represents whether there is an edge between each pair of nodes. A value of 0 means there isn't an edge connecting these nodes, while a value of 1 means there is an edge.\n+    \n+\n+The values in the diagonal represent whether or not each node has a self-loop, an edge that connects the node to itself. In our example, they are all 0s because the graph doesn't have any self-loops.\n+\n+This is a visual representation of the adjacency matrix to show you how the rows and columns represent the corresponding nodes.\n+\n+For example, the first row is `[0, 1, 1, 1]` because node A has edges connecting it to nodes B, C, and D:\n+\n+```markdown\n+#      A  B  C  D\n+# A   [0, 1, 1, 1],\n+# B   [1, 0, 0, 1],\n+# C   [1, 0, 0, 0],\n+# D   [1, 1, 0, 0]\n+```\n+\n+And this is the same adjacency matrix, but implemented in Python code:\n+\n+```python\n+adjacency_matrix = [\n+    [0, 1, 1, 1],  # The neighbors of A are B, C, and D\n+    [1, 0, 0, 1],  # The neighbors of B are A and D\n+    [1, 0, 0, 0],  # The only neighbor of C is A\n+    [1, 1, 0, 0]   # The neighbors of D are A and B\n+]\n+```\n+\n+## Adjacency Lists\n+\n+Another common way to represent graphs is by using adjacency lists.\n+\n+An adjacency list is an array or dictionary that stores all the neighbors of each node.\n+\n+There are two ways to implement adjacency lists:\n+\n+* As an array, where each index represents a node and the list stored at that index contains its neighbors.\n+    \n+* As a dictionary, where each key represents a node and the value associated to that key (a list) contains its neighbors.\n+    \n+\n+Adjacency lists are more efficient than adjacency matrices in terms of space requirements. They have a `O(V + E)` space complexity, where `V` is the number of vertices (nodes) and `E` is the number of edges.\n+\n+It's also efficient for finding all neighbor nodes, since this operation only requires accessing the list associated to the node.\n+\n+However, there is also a tradeoff.\n+\n+Adjacency lists are less efficient than adjacency matrices for determining if there is an edge between two nodes.\n+\n+The search process can take `O(V)` time in the worst-case, since it may have to search through a very long list of neighbors if the node is connected to all the other nodes in the graph.\n+\n+Here is an example of an adjacency list for this graph:\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-matrices-and-adjacency-lists-work-1.png\" alt=\"A graph with four nodes labeled A, B, C, and D. Node A connects to B, C, and D. Node B connects to A and D. Node C connects to A. Node D connects to A and B. It's the same image as before.\">\n+\n+This adjacency list is implemented as a dictionary. Every key in the dictionary represents a node, and the value associated to that key is a list with all the neighbors of the corresponding node:\n+\n+```python\n+adjacency_list = {\n+    'A': ['B', 'C', 'D'],\n+    'B': ['A', 'D'],\n+    'C': ['A'],\n+    'D': ['A', 'B']\n+}\n+```\n+\n+Alternatively, we could implement it as a 2D list, where each index represents a node. For example, index 0 represents node A, index 1 represents node B, and so on:\n+\n+```python\n+adjacency_list = [\n+    ['B', 'C', 'D'],  # Neighbors of A (index 0)\n+    ['A', 'D'],       # Neighbors of B (index 1)\n+    ['A'],            # Neighbors of C (index 2)\n+    ['A', 'B']        # Neighbors of D (index 3)\n+]\n+```\n+\n+Notice that even if this 2D list may look similar to the adjacency matrix, they are quite different.\n+\n+* The adjacency matrix stores 0s, 1s, or other values that represent the edges or weights of the edges in the graph.\n+    \n+* The adjacency list stores the actual list of all the neighbors of each node.\n+    \n+\n+This is a very important difference that you should be familiar with.\n+\n+Both adjacency matrices and adjacency lists are very important for implementing graphs. Choosing between them depends on the graph's size and how you need to use the data. Adjacency matrices are helpful for dense graphs with many edges, while adjacency lists are usually the preferred choice for real-world scenarios, where sparse graphs are more common.\n+\n+# --questions--\n+\n+## --text--\n+\n+For which of the following scenarios is an adjacency matrix the most efficient choice for representing a graph?\n+\n+## --answers--\n+\n+A social network with billions of people and very few connections per person.\n+\n+### --feedback--\n+\n+Think about how much memory a matrix uses and how that changes based on the number of connections.\n+\n+---\n+\n+A computer network with only five connections.\n+\n+### --feedback--\n+\n+Think about how much memory a matrix uses and how that changes based on the number of connections.\n+\n+---\n+\n+A dense graph where every node is connected to most other nodes.\n+\n+---\n+\n+A graph where the main operation is to find all neighbors of a specific node.\n+\n+### --feedback--\n+\n+Think about how much memory a matrix uses and how that changes based on the number of connections.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+When would it be more efficient to use an adjacency list over an adjacency matrix?\n+\n+## --answers--\n+\n+When the graph is dense and has many edges.\n+\n+### --feedback--\n+\n+Think about how an adjacency list saves memory when a graph is not very connected.\n+\n+---\n+\n+When you need to check if an edge exists between two nodes very quickly.\n+\n+### --feedback--\n+\n+Think about how an adjacency list saves memory when a graph is not very connected.\n+\n+---\n+\n+When the graph has a high number of vertices and many connections.\n+\n+### --feedback--\n+\n+Think about how an adjacency list saves memory when a graph is not very connected.\n+\n+---\n+\n+When the graph is sparse, with a high number of vertices and a low number of edges.\n+\n+## --video-solution--\n+\n+4\n+\n+## --text--\n+\n+Which of the following operations is faster in an adjacency matrix compared to an adjacency list?\n+\n+## --answers--\n+\n+Finding all neighbors of a single node.\n+\n+### --feedback--\n+\n+Think about how you would perform each of these operations in a grid and a list-based structure.\n+\n+---\n+\n+Checking if a direct edge exists between two specific nodes.\n+\n+---\n+\n+Iterating through all nodes in the graph.\n+\n+### --feedback--\n+\n+Think about how you would perform each of these operations in a grid and a list-based structure.\n+\n+---\n+\n+Adding a new node to the graph.\n+\n+### --feedback--\n+\n+Think about how you would perform each of these operations in a grid and a list-based structure.\n+\n+## --video-solution--\n+\n+2"
        },
        {
            "sha": "ab7ec96b91f6e833e6b8444f2fc2c8391e324455",
            "filename": "curriculum/challenges/english/blocks/lecture-understanding-graphs-and-trees/68baa5e4f0e07f079245ca0a.md",
            "status": "added",
            "additions": 216,
            "deletions": 0,
            "changes": 216,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/c1018150ccc473bdd72f816d4e52fac148b9e7fc/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68baa5e4f0e07f079245ca0a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/c1018150ccc473bdd72f816d4e52fac148b9e7fc/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68baa5e4f0e07f079245ca0a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68baa5e4f0e07f079245ca0a.md?ref=c1018150ccc473bdd72f816d4e52fac148b9e7fc",
            "patch": "@@ -0,0 +1,216 @@\n+---\n+id: 68baa5e4f0e07f079245ca0a\n+title: What Are Trees and Tries and How Do They Work?\n+challengeType: 19\n+dashedName: what-are-trees-and-tries-and-how-do-they-work\n+---\n+\n+# --description--\n+\n+Trees are very important in the world of computer science.\n+\n+A **tree** is a specific type of graph.\n+\n+For a graph to be classified as a tree, it must:\n+\n+* Have no loops or cycles (paths where the start and end nodes are the same).\n+    \n+* Be connected (every node can be reached from every other node).\n+    \n+\n+Trees are non-linear data structures that organize nodes in a hierarchy, where nodes may have children, siblings, and parent nodes.\n+\n+The root node is the very top of a tree. It's the only node in the tree without a parent node. This is the node where you will start traversing the entire data structure, usually with algorithms like breadth-first search (BFS) or depth-first search (DFS).\n+\n+This is a graphical example of a tree:\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-trees-and-tries-and-how-do-they-work-1.png\" alt=\"A tree diagram showing a hierarchical structure with node A at the root, nodes B and C as children of A, and nodes D and E as children of C. Node B is a leaf node.\">\n+\n+Since nodes are organized in a hierarchy, they have relationships between them.\n+\n+A **parent node** is a node that is immediately connected to other nodes below it. In the diagram, node A is the parent node of nodes B and C.\n+\n+A **child node** is a node that is immediately connected to a node above it. In the diagram, node D and E are the child nodes of node C.\n+\n+Nodes D and E are also classified as **leaves**. A leaf is a node that has no child nodes. You can think of them as the end of the \"branches\" of the tree.\n+\n+Tree nodes also have important properties:\n+\n+* **Depth**: the length of the path from the root to that node. For example, in the diagram, node D has depth 2 because if you start at the root, you have to go through two edges to reach it.\n+    \n+* **Height**: the length of the path from that node down to a leaf. For example, node C has a height of 1 because it's one level above the leaf nodes.\n+    \n+* **Degree:** the number of child nodes each node has. In the diagram, node B has degree 0 because it's a leaf node, so it has no child nodes. Node C has degree 2 because it has two child nodes.\n+    \n+\n+Trees also have a **height**. The height of a tree is the height of its root node.\n+\n+There are many different types of trees, including Binary Trees, Binary Search Trees, AVL trees, Red-Black Trees, and B-Trees.\n+\n+## Binary Trees and Binary Search Trees\n+\n+These are two of the most commonly used types of trees.\n+\n+A **binary tree** is a type of tree in which each node can have at most two child nodes, a left child node and a right child node. Yes, this means that the example that you have seen so far is a binary tree!\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-trees-and-tries-and-how-do-they-work-1.png\" alt=\"The same binary tree example highlighting that it's a binary tree, with each node having at most two children.\">\n+\n+A **binary search tree** is a more specific version of a binary tree, with a very particular ordering property.\n+\n+To understand it, first you need to understand subtrees. A **subtree** is a section of a tree that is a tree itself.\n+\n+In our tree example, nodes C, D, and E form a tree by themselves, so they are considered a subtree.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-trees-and-tries-and-how-do-they-work-3.png\" alt=\"A diagram highlighting a subtree within the main tree, showing nodes C, D, and E forming their own tree structure.\">\n+\n+The ordering property of binary search trees (BST) establishes that for every node, all values in its left subtree are less than the node's value, and all values in its right subtree are greater than the node's value.\n+\n+The left and right subtrees must also be binary search trees themselves.\n+\n+This ordering makes search, insertion, and deletion operations very efficient if the tree is balanced.\n+\n+A balanced tree is a tree in which the heights of the left and right subtrees of any node are very similar to make sure that operations remain efficient.\n+\n+## Tries\n+\n+Now that you know more about trees and binary search trees, let's dive into tries.\n+\n+**Tries** are tree data structures used to store a set of strings.\n+\n+Tries are also known as **prefix trees** because they are very efficient for operations that require finding strings based on their prefixes.\n+\n+Each node in the trie represents a single character of a string.\n+\n+The root node does not represent any particular character, so you can think of it as representing an empty string.\n+\n+As you traverse the trie down from the root, the path to a node defines a specific prefix. To find a word, you follow that prefix until you reach the node with the word you are looking for.\n+\n+Nodes that represent complete words are assigned end-of-word markers.\n+\n+This is an example of a trie with the words \"top\", \"tea\" and \"ten\".\n+\n+Notice how the words \"tea\" and \"ten\" share the same prefix \"te\", so the data structure follows the same path until the last character, which is marked as an end-of-word character. In this diagram, this is represented with a red border around the node:\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-are-trees-and-tries-and-how-do-they-work-4.png\" alt=\"A trie data structure showing the words 'top', 'tea', and 'ten'. The root node branches to 't', which then branches to 'o' (leading to 'top') and 'e' (leading to 'tea' and 'ten'). End-of-word nodes are marked with red borders.\">\n+\n+The worst-case time complexity for the search operation is O(L), where L is the length of the string that you are looking for.\n+\n+Insertion is also efficient. This operation only requires creating new nodes for the characters that don't exist in the trie yet.\n+\n+The great advantage of this data structure is that when multiple strings share the same prefix, their paths overlap, so the prefix itself is only stored once.\n+\n+This efficiency makes tries perfect for implementing features like autocomplete and spell checkers.\n+\n+However, tries are not efficient for all sets of strings. They can be inefficient if the set of strings has many unique characters. This would require storing many unique characters as individual nodes. These nodes would have to be traversed to find the words, which would not be optimal.\n+\n+Now that you are familiar with the different types of trees and what they are used for, you can start using them in real-world scenarios. Knowing how to choose the right one is a valuable skill to have when you need to tackle challenges in your daily work.\n+\n+# --questions--\n+\n+## --text--\n+\n+Which of the following statements about a Binary Search Tree (BST) is always true?\n+\n+## --answers--\n+\n+All values in the left subtree of a node are less than the node's value.\n+\n+---\n+\n+Every node can have up to three children.\n+\n+### --feedback--\n+\n+Think about the specific rule that governs how numbers are organized in a Binary Search Tree (BST) to allow for efficient searching.\n+\n+---\n+\n+The tree is guaranteed to be perfectly balanced after every insertion.\n+\n+### --feedback--\n+\n+Think about the specific rule that governs how numbers are organized in a Binary Search Tree (BST) to allow for efficient searching.\n+\n+---\n+\n+It is a specialized tree-like structure optimized for storing strings.\n+\n+### --feedback--\n+\n+Think about the specific rule that governs how numbers are organized in a Binary Search Tree (BST) to allow for efficient searching.\n+\n+## --video-solution--\n+\n+1\n+\n+## --text--\n+\n+For which of the following tasks is a trie, or prefix tree most effective?\n+\n+## --answers--\n+\n+Finding the smallest value in a large dataset.\n+\n+### --feedback--\n+\n+Think about the main advantage of a trie's structure and how it's built based on characters.\n+\n+---\n+\n+Managing a hierarchical file system on a computer.\n+\n+### --feedback--\n+\n+Think about the main advantage of a trie's structure and how it's built based on characters.\n+\n+---\n+\n+Implementing an autocomplete feature.\n+\n+---\n+\n+Storing an unordered list of unique numbers.\n+\n+### --feedback--\n+\n+Think about the main advantage of a trie's structure and how it's built based on characters.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+What is the fundamental difference between a general tree and a Binary Tree?\n+\n+## --answers--\n+\n+A Binary Tree can only store numbers, while a general tree can store any data type.\n+\n+### --feedback--\n+\n+Think about the number of connections each node in a Binary Tree can have, compared to general trees.\n+\n+---\n+\n+A Binary Tree has a root node, but a general tree does not.\n+\n+### --feedback--\n+\n+Think about the number of connections each node in a Binary Tree can have, compared to general trees.\n+\n+---\n+\n+A Binary Tree has no parent-child relationships, unlike a general tree.\n+\n+### --feedback--\n+\n+Think about the number of connections each node in a Binary Tree can have, compared to general trees.\n+\n+---\n+\n+A Binary Tree restricts each node to a maximum of two children, while a general tree does not.\n+\n+## --video-solution--\n+\n+4"
        },
        {
            "sha": "163936326c4ef091efca8e1dc51ec2871bb8e282",
            "filename": "curriculum/challenges/english/blocks/lecture-understanding-graphs-and-trees/68baa5e4f0e07f079245ca0b.md",
            "status": "added",
            "additions": 239,
            "deletions": 0,
            "changes": 239,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/c1018150ccc473bdd72f816d4e52fac148b9e7fc/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68baa5e4f0e07f079245ca0b.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/c1018150ccc473bdd72f816d4e52fac148b9e7fc/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68baa5e4f0e07f079245ca0b.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-graphs-and-trees%2F68baa5e4f0e07f079245ca0b.md?ref=c1018150ccc473bdd72f816d4e52fac148b9e7fc",
            "patch": "@@ -0,0 +1,239 @@\n+---\n+id: 68baa5e4f0e07f079245ca0b\n+title: How Do Priority Queues and Heaps Work?\n+challengeType: 19\n+dashedName: how-do-priority-queues-and-heaps-work\n+---\n+\n+# --description--\n+\n+A **priority queue** is an abstract data type (ADT) that works similarly to a queue or stack, but with one key difference.\n+\n+As you may already know, standard queues follow a FIFO (First-in, First-out) approach, where the first element added to the queue is the first one to be removed from the queue.\n+\n+Stacks follow a LIFO (Last-in, First-out) approach, where the last element added to the stack is the first one to be removed from the stack.\n+\n+Queues and stacks only consider the order of insertion of the elements.\n+\n+However, priority queues take the \"priority\" of the elements into account. The priority is used to determine which element should be removed next.\n+\n+Usually, the element with the highest priority is removed first, but some implementations may also choose to remove the element with the lowest priority first. This will depend on the requirements of your program.\n+\n+Priority queues are very helpful for practical applications like finding the shortest path between two locations, scheduling tasks in operating systems, simulating traffic, compressing data, and managing networks.\n+\n+In practice, priority queues are commonly implemented using a heap data structure.\n+\n+A **heap** is a tree data structure with a very specific property called the **heap property**. This property determines the relationship between each node and its children, based on the type of heap.\n+\n+There are two primary types of heaps:\n+\n+* Max-heap\n+    \n+* Min-heap\n+    \n+\n+In a **max-heap**, the value of each node is greater than or equal to the value of its children.\n+\n+In this example, you can see a tree structure with the nodes 8, 7, 5, 2, and 1. Note that node 7 is greater than node 2 and node 1, following the heap property. This is true for all the other nodes as well.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-1.png\" alt=\"A max-heap tree structure showing nodes with values 8 at the root, 7 and 5 as children of 8, and 2 and 1 as children of 7, demonstrating that each parent node is greater than its children.\">\n+\n+In contrast, in a **min-heap**, the value of each node is less than or equal to the value of its children.\n+\n+In this example, we have nodes with values 4, 7, 9, 12, and 15. For example, node 7 is less than node 12 and node 15, following the heap property. This is also true for all the other nodes.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-2.png\" alt=\"A min-heap tree structure showing nodes with values 4 at the root, 7 and 9 as children of 4, and 12 and 15 as children of 7, demonstrating that each parent node is less than its children.\">\n+\n+The heap property is key because it ensures that the maximum (or minimum) element (depending on the type of heap) always stays at the top, which makes it very easy to remove.\n+\n+In practice, heaps are typically implemented as arrays to access parent and child nodes efficiently.\n+\n+Using arrays simplifies the logic for accessing these values or \"nodes\" because behind the scenes, if the heap maintains the structure of a complete binary tree, the array implementation only requires simple mathematical operations based on their indices to find where the elements are located in memory.\n+\n+Python has a `heapq` built-in module that you can use to work with an implementation of a min-heap.\n+\n+It works by operating directly on Python lists, following specific steps that work with the elements as if the list was a heap, preserving the heap property.\n+\n+To use this module, you just need to import it:\n+\n+```python\n+import heapq\n+```\n+\n+Then, you need to define an empty list. This will be the underlying data structure for the heap:\n+\n+```python\n+my_heap = []\n+```\n+\n+To add elements to the heap, you would call `heappush()`, passing the name of the heap and the element that you want to add as arguments. This will automatically add the element to the list where it should be, to preserve the heap property:\n+\n+```python\n+heapq.heappush(my_heap, 9)\n+```\n+\n+To get the element with the lowest priority (in this case, the smallest value), you would call `heappop()`:\n+\n+```python\n+heapq.heappop(my_heap)\n+```\n+\n+`heappushpop()` combines both operations into one call.\n+\n+This is more efficient than calling them in a sequence separately, especially when the heap is large, since it only performs one \"heapify\" operation to reorder the list as a heap:\n+\n+```python\n+heapq.heappushpop(my_heap, 15)\n+```\n+\n+If you already have a list and you want to transform it into a heap, you could call `heapify()`, passing the heap as argument:\n+\n+```python\n+heapq.heapify(my_heap)\n+```\n+\n+But currently, we are sorting the elements by their values, right?\n+\n+What if we want to sort them by their \"priority\" instead?\n+\n+You could do this by storing tuples with this structure: `(priority, element)`.\n+\n+Since tuples are compared element by element from left to right, the priorities will be compared first, and the decisions will be made based on them.\n+\n+Please note that, in this case, lower values will represent higher priorities. This means that a tuple with priority of 1 will have a **higher** priority than a tuple with priority of 3:\n+\n+```python\n+my_heap = []\n+\n+heapq.heappush(my_heap, (3, \"A\"))\n+heapq.heappush(my_heap, (2, \"B\"))\n+heapq.heappush(my_heap, (1, \"C\"))\n+```\n+\n+If you need elements with the same priority to be removed in the order that they were inserted, you could consider including a unique counter as the second element of your tuple to break the tie, like this `(priority, counter, element)`.\n+\n+Now let's talk about the efficiency of heaps.\n+\n+The average and worst case time complexities for inserting and extracting the minimum or maximum value from a heap (depending on the type of heap) are logarithmic, `O(log n)`, because the number of swaps required is usually proportional to the height of the heap, which is log(n).\n+\n+The average and worst case time complexity for the \"peek\" operation is constant time, O(1). Peeking involves getting the minimum or maximum value (depending on the type of heap) without removing it.\n+\n+The \"heapify\" operation, where the heap is built from an unsorted list, has linear time complexity, O(n), in the average and worst cases.\n+\n+Similarly, both searching for and deleting an arbitrary element have linear average and worst case time complexities of O(n), since they potentially require traversing the entire heap.\n+\n+And how much space do they require?\n+\n+The space complexity of the heap is linear, O(n), where `n` is the number of elements it contains. It only needs to store the elements and a small additional overhead for the list object itself.\n+\n+Priority queues and heaps are very important in computer science. They let you quickly find and use the most important elements from a list. This efficiency is crucial for many computer programs that perform critical real-world tasks, such as finding the fastest route on a map.\n+\n+# --questions--\n+\n+## --text--\n+\n+What is the primary characteristic that distinguishes a priority queue from a standard queue or stack?\n+\n+## --answers--\n+\n+It allows elements to be accessed by their index.\n+\n+### --feedback--\n+\n+Think about the main factor that determines which element is removed next.\n+\n+---\n+\n+It always processes elements in the order they were inserted.\n+\n+### --feedback--\n+\n+Think about the main factor that determines which element is removed next.\n+\n+---\n+\n+It retrieves elements based on an assigned priority.\n+\n+---\n+\n+It only stores elements of the same data type.\n+\n+### --feedback--\n+\n+Think about the main factor that determines which element is removed next.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+Which of the following is a common real-world application where a priority queue would be helpful?\n+\n+## --answers--\n+\n+Scheduling tasks in an operating system where some tasks are more urgent.\n+\n+---\n+\n+Managing a playlist where songs play in a fixed order.\n+\n+### --feedback--\n+\n+Think about scenarios where some items are more important and need to be handled first.\n+\n+---\n+\n+Storing a list of grocery items.\n+\n+### --feedback--\n+\n+Think about scenarios where some items are more important and need to be handled first.\n+\n+---\n+\n+Keeping track of customer names in alphabetical order.\n+\n+### --feedback--\n+\n+Think about scenarios where some items are more important and need to be handled first.\n+\n+## --video-solution--\n+\n+1\n+\n+## --text--\n+\n+What is the main reason why heaps are typically implemented as arrays in practice, despite being conceptualized as trees?\n+\n+## --answers--\n+\n+Arrays are always faster than any other data structure.\n+\n+### --feedback--\n+\n+Think about how the tree-like structure of a heap can be efficiently mapped to a linear data structure.\n+\n+---\n+\n+Arrays simplify the logic for accessing parent and child nodes using mathematical formulas.\n+\n+---\n+\n+Arrays allow for direct random access to any element, which is a core heap operation.\n+\n+### --feedback--\n+\n+Think about how the tree-like structure of a heap can be efficiently mapped to a linear data structure.\n+\n+---\n+\n+Arrays are the only data structure that can guarantee the heap property.\n+\n+### --feedback--\n+\n+Think about how the tree-like structure of a heap can be efficiently mapped to a linear data structure.\n+\n+## --video-solution--\n+\n+2"
        },
        {
            "sha": "c972f373a10c4bdb960a625bd8464f082d3d5cbe",
            "filename": "curriculum/structure/blocks/lecture-understanding-graphs-and-trees.json",
            "status": "modified",
            "additions": 24,
            "deletions": 3,
            "changes": 27,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/c1018150ccc473bdd72f816d4e52fac148b9e7fc/curriculum%2Fstructure%2Fblocks%2Flecture-understanding-graphs-and-trees.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/c1018150ccc473bdd72f816d4e52fac148b9e7fc/curriculum%2Fstructure%2Fblocks%2Flecture-understanding-graphs-and-trees.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fstructure%2Fblocks%2Flecture-understanding-graphs-and-trees.json?ref=c1018150ccc473bdd72f816d4e52fac148b9e7fc",
            "patch": "@@ -2,8 +2,29 @@\n   \"name\": \"Understanding Graphs and Trees\",\n   \"isUpcomingChange\": true,\n   \"dashedName\": \"lecture-understanding-graphs-and-trees\",\n+  \"challengeOrder\": [\n+    {\n+      \"id\": \"68420c5ac17cf26ab2a4ca3c\",\n+      \"title\": \"What Are Graphs in Computer Science?\"\n+    },\n+    {\n+      \"id\": \"68baa5e4f0e07f079245ca08\",\n+      \"title\": \"How Do Depth First and Breadth First Search Work?\"\n+    },\n+    {\n+      \"id\": \"68baa5e4f0e07f079245ca09\",\n+      \"title\": \"How Do Matrices and Adjacency Lists Work?\"\n+    },\n+    {\n+      \"id\": \"68baa5e4f0e07f079245ca0a\",\n+      \"title\": \"What Are Trees and Tries and How Do They Work?\"\n+    },\n+    {\n+      \"id\": \"68baa5e4f0e07f079245ca0b\",\n+      \"title\": \"How Do Priority Queues and Heaps Work?\"\n+    }\n+  ],\n+  \"helpCategory\": \"Python\",\n   \"blockType\": \"lecture\",\n-  \"blockLayout\": \"challenge-list\",\n-  \"challengeOrder\": [{ \"id\": \"68420c5ac17cf26ab2a4ca3c\", \"title\": \"Step 1\" }],\n-  \"helpCategory\": \"Python\"\n+  \"blockLayout\": \"challenge-list\"\n }"
        }
    ],
    "stats": {
        "total": 1304,
        "additions": 1255,
        "deletions": 49
    }
}