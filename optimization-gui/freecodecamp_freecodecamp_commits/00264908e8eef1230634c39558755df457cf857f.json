{
    "author": "ShaunSHamilton",
    "message": "fix(api): remove authn requirement for coderoad challenges (#60425)\n\nCo-authored-by: Oliver Eyton-Williams <ojeytonwilliams@gmail.com>",
    "sha": "00264908e8eef1230634c39558755df457cf857f",
    "files": [
        {
            "sha": "0ca81a2e3acbc5776743c8038122da0c6bc932fe",
            "filename": "api/src/app.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/00264908e8eef1230634c39558755df457cf857f/api%2Fsrc%2Fapp.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/00264908e8eef1230634c39558755df457cf857f/api%2Fsrc%2Fapp.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fapp.ts?ref=00264908e8eef1230634c39558755df457cf857f",
            "patch": "@@ -192,6 +192,10 @@ export const build = async (\n       await fastify.register(protectedRoutes.settingRedirectRoutes);\n     });\n   });\n+\n+  // TODO: The route should not handle its own AuthZ\n+  await fastify.register(protectedRoutes.challengeTokenRoutes);\n+\n   // Routes for signed out users:\n   void fastify.register(async function (fastify) {\n     fastify.addHook('onRequest', fastify.authorize);"
        },
        {
            "sha": "94860a47a94239b168fafa2af13c0d707048b7e8",
            "filename": "api/src/routes/protected/challenge.test.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 2,
            "changes": 31,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/00264908e8eef1230634c39558755df457cf857f/api%2Fsrc%2Froutes%2Fprotected%2Fchallenge.test.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/00264908e8eef1230634c39558755df457cf857f/api%2Fsrc%2Froutes%2Fprotected%2Fchallenge.test.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Froutes%2Fprotected%2Fchallenge.test.ts?ref=00264908e8eef1230634c39558755df457cf857f",
            "patch": "@@ -6,6 +6,7 @@ const mockVerifyTrophyWithMicrosoft = jest.fn();\n import { omit } from 'lodash';\n import { Static } from '@fastify/type-provider-typebox';\n import { DailyCodingChallengeLanguage } from '@prisma/client';\n+import request from 'supertest';\n \n import { challengeTypes } from '../../../../shared/config/challenge-types';\n import {\n@@ -246,7 +247,11 @@ describe('challengeRoutes', () => {\n \n         const token = (tokenResponse.body as { userToken: string }).userToken;\n \n-        const response = await superPost('/coderoad-challenge-completed')\n+        // This route is special since it does not have CSRF protection OR authN\n+        // protection. As such, we use a normal `request` to send the bare\n+        // minimum (no extra headers or cookies).\n+        const response = await request(fastifyTestInstance.server)\n+          .post('/coderoad-challenge-completed')\n           .set('coderoad-user-token', token)\n           .send({\n             tutorialId:\n@@ -270,6 +275,28 @@ describe('challengeRoutes', () => {\n         expect(response.status).toBe(200);\n       });\n \n+      test('Should return an error response if something goes wrong', async () => {\n+        jest\n+          .spyOn(fastifyTestInstance.prisma.userToken, 'findUnique')\n+          .mockImplementationOnce(() => {\n+            throw new Error('Database error');\n+          });\n+        const tokenResponse = await superPost('/user/user-token');\n+        const token = (tokenResponse.body as { userToken: string }).userToken;\n+\n+        const response = await superPost('/coderoad-challenge-completed')\n+          .set('coderoad-user-token', token)\n+          .send({\n+            tutorialId: 'freeCodeCamp/learn-celestial-bodies-database:v1.0.0'\n+          });\n+\n+        expect(response.body).toEqual({\n+          msg: 'An error occurred trying to submit the challenge',\n+          type: 'error'\n+        });\n+        expect(response.status).toBe(500);\n+      });\n+\n       test('Should complete project with code 200', async () => {\n         const tokenResponse = await superPost('/user/user-token');\n         expect(tokenResponse.body).toHaveProperty('userToken');\n@@ -2049,7 +2076,7 @@ describe('challengeRoutes', () => {\n     });\n \n     const endpoints: { path: string; method: 'POST' | 'GET' }[] = [\n-      { path: '/coderoad-challenge-completed', method: 'POST' },\n+      // { path: '/coderoad-challenge-completed', method: 'POST' },\n       { path: '/project-completed', method: 'POST' },\n       { path: '/backend-challenge-completed', method: 'POST' },\n       { path: '/modern-challenge-completed', method: 'POST' },"
        },
        {
            "sha": "30a95cbf376a437739f4f507f37ca02145894e7f",
            "filename": "api/src/routes/protected/challenge.ts",
            "status": "modified",
            "additions": 159,
            "deletions": 141,
            "changes": 300,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/00264908e8eef1230634c39558755df457cf857f/api%2Fsrc%2Froutes%2Fprotected%2Fchallenge.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/00264908e8eef1230634c39558755df457cf857f/api%2Fsrc%2Froutes%2Fprotected%2Fchallenge.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Froutes%2Fprotected%2Fchallenge.ts?ref=00264908e8eef1230634c39558755df457cf857f",
            "patch": "@@ -52,6 +52,8 @@ const userChallengeSelect = {\n   savedChallenges: true\n };\n \n+const challenges = getChallenges();\n+\n /**\n  * Plugin for the challenge submission endpoints.\n  *\n@@ -64,147 +66,6 @@ export const challengeRoutes: FastifyPluginCallbackTypebox = (\n   _options,\n   done\n ) => {\n-  const challenges = getChallenges();\n-\n-  fastify.post(\n-    '/coderoad-challenge-completed',\n-    {\n-      schema: schemas.coderoadChallengeCompleted,\n-      errorHandler(error, req, reply) {\n-        const logger = fastify.log.child({ req, res: reply });\n-        if (error.validation) {\n-          logger.warn({ validationError: error.validation });\n-          void reply.code(400);\n-          return formatCoderoadChallengeCompletedValidation(error.validation);\n-        } else {\n-          fastify.errorHandler(error, req, reply);\n-        }\n-      }\n-    },\n-    async (req, reply) => {\n-      const logger = fastify.log.child({ req, res: reply });\n-      logger.info(\n-        { userId: req.user?.id },\n-        'User submitted a coderoad challenge'\n-      );\n-\n-      const { 'coderoad-user-token': encodedUserToken } = req.headers;\n-      const { tutorialId } = req.body;\n-\n-      let userToken;\n-      try {\n-        const payload = jwt.verify(encodedUserToken, JWT_SECRET) as JwtPayload;\n-        userToken = payload.userToken;\n-      } catch {\n-        logger.warn('Invalid user token');\n-        void reply.code(400);\n-        return { type: 'error', msg: `invalid user token` } as const;\n-      }\n-\n-      const tutorialRepo = tutorialId.split(':')[0];\n-      const tutorialOrg = tutorialRepo?.split('/')?.[0];\n-\n-      if (tutorialOrg !== 'freeCodeCamp') {\n-        logger.warn(\n-          { tutorialId },\n-          'Tutorial not hosted on freeCodeCamp GitHub account'\n-        );\n-        void reply.code(400);\n-        return {\n-          type: 'error',\n-          msg: `Tutorial not hosted on freeCodeCamp GitHub account`\n-        } as const;\n-      }\n-\n-      const codeRoadChallenges = challenges.filter(\n-        ({ challengeType }) =>\n-          challengeType === challengeTypes.codeAllyPractice ||\n-          challengeType === challengeTypes.codeAllyCert\n-      );\n-\n-      const challenge = codeRoadChallenges.find(challenge => {\n-        return tutorialRepo && challenge.url?.endsWith(tutorialRepo);\n-      });\n-\n-      if (!challenge) {\n-        logger.warn({ tutorialRepo }, 'Tutorial repo is not valid');\n-        void reply.code(400);\n-        return { type: 'error', msg: 'Tutorial name is not valid' } as const;\n-      }\n-\n-      const { id: challengeId, challengeType } = challenge;\n-      try {\n-        const tokenInfo = await fastify.prisma.userToken.findUnique({\n-          where: { id: userToken }\n-        });\n-\n-        if (!tokenInfo) {\n-          logger.warn('User token not found');\n-          void reply.code(400);\n-          return { type: 'error', msg: 'User token not found' } as const;\n-        }\n-\n-        const { userId } = tokenInfo;\n-\n-        const user = await fastify.prisma.user.findFirstOrThrow({\n-          where: { id: userId }\n-        });\n-\n-        if (!user) {\n-          logger.warn('User not found');\n-          void reply.code(400);\n-          return {\n-            type: 'error',\n-            msg: 'User for user token not found'\n-          } as const;\n-        }\n-\n-        const completedDate = Date.now();\n-        const { completedChallenges = [], partiallyCompletedChallenges = [] } =\n-          user;\n-\n-        const isCompleted = completedChallenges.some(\n-          challenge => challenge.id === challengeId\n-        );\n-\n-        if (challengeType === challengeTypes.codeAllyCert && !isCompleted) {\n-          const finalChallenge = {\n-            id: challengeId,\n-            completedDate\n-          };\n-\n-          await fastify.prisma.user.update({\n-            where: { id: req.user?.id },\n-            data: {\n-              partiallyCompletedChallenges: uniqBy(\n-                [finalChallenge, ...partiallyCompletedChallenges],\n-                'id'\n-              )\n-            }\n-          });\n-        } else {\n-          await updateUserChallengeData(fastify, user, challengeId, {\n-            id: challengeId,\n-            completedDate\n-          });\n-        }\n-      } catch (error) {\n-        // TODO(Post-MVP): don't catch, just let Sentry handle this.\n-        logger.error(error, 'Error submitting coderoad challenge');\n-        fastify.Sentry.captureException(error);\n-        void reply.code(400);\n-        return {\n-          type: 'error',\n-          msg: 'An error occurred trying to submit the challenge'\n-        } as const;\n-      }\n-      return {\n-        type: 'success',\n-        msg: 'Successfully submitted challenge'\n-      } as const;\n-    }\n-  );\n-\n   fastify.post(\n     '/project-completed',\n     {\n@@ -975,6 +836,163 @@ export const challengeRoutes: FastifyPluginCallbackTypebox = (\n   done();\n };\n \n+/**\n+ * Plugin for challenge submissions behind AuthZ, not AuthN.\n+ *\n+ * @param fastify The Fastify instance.\n+ * @param _options Options passed to the plugin via `fastify.register(plugin, options)`.\n+ * @param done The callback to signal that the plugin is ready.\n+ */\n+export const challengeTokenRoutes: FastifyPluginCallbackTypebox = (\n+  fastify,\n+  _options,\n+  done\n+) => {\n+  fastify.post(\n+    '/coderoad-challenge-completed',\n+    {\n+      schema: schemas.coderoadChallengeCompleted,\n+      errorHandler(error, req, reply) {\n+        const logger = fastify.log.child({ req, res: reply });\n+        if (error.validation) {\n+          logger.warn({ validationError: error.validation });\n+          void reply.code(400);\n+          return formatCoderoadChallengeCompletedValidation(error.validation);\n+        } else {\n+          fastify.errorHandler(error, req, reply);\n+        }\n+      }\n+    },\n+    postCoderoadChallengeCompleted\n+  );\n+\n+  done();\n+};\n+\n+async function postCoderoadChallengeCompleted(\n+  this: FastifyInstance,\n+  req: UpdateReqType<typeof schemas.coderoadChallengeCompleted>,\n+  reply: FastifyReply\n+) {\n+  const logger = this.log.child({ req, res: reply });\n+  logger.info({ userId: req.user?.id }, 'User submitted a coderoad challenge');\n+\n+  const { 'coderoad-user-token': encodedUserToken } = req.headers;\n+  const { tutorialId } = req.body;\n+\n+  let userToken;\n+  try {\n+    const payload = jwt.verify(encodedUserToken, JWT_SECRET) as JwtPayload;\n+    userToken = payload.userToken;\n+  } catch {\n+    logger.warn('Invalid user token');\n+    void reply.code(400);\n+    return reply.send({ type: 'error', msg: `invalid user token` });\n+  }\n+\n+  const tutorialRepo = tutorialId.split(':')[0];\n+  const tutorialOrg = tutorialRepo?.split('/')?.[0];\n+\n+  if (tutorialOrg !== 'freeCodeCamp') {\n+    logger.warn(\n+      { tutorialId },\n+      'Tutorial not hosted on freeCodeCamp GitHub account'\n+    );\n+    void reply.code(400);\n+    return reply.send({\n+      type: 'error',\n+      msg: `Tutorial not hosted on freeCodeCamp GitHub account`\n+    });\n+  }\n+\n+  const codeRoadChallenges = challenges.filter(\n+    ({ challengeType }) =>\n+      challengeType === challengeTypes.codeAllyPractice ||\n+      challengeType === challengeTypes.codeAllyCert\n+  );\n+\n+  const challenge = codeRoadChallenges.find(challenge => {\n+    return tutorialRepo && challenge.url?.endsWith(tutorialRepo);\n+  });\n+\n+  if (!challenge) {\n+    logger.warn({ tutorialRepo }, 'Tutorial repo is not valid');\n+    void reply.code(400);\n+    return reply.send({ type: 'error', msg: 'Tutorial name is not valid' });\n+  }\n+\n+  const { id: challengeId, challengeType } = challenge;\n+  try {\n+    const tokenInfo = await this.prisma.userToken.findUnique({\n+      where: { id: userToken }\n+    });\n+\n+    if (!tokenInfo) {\n+      logger.warn('User token not found');\n+      void reply.code(400);\n+      return reply.send({ type: 'error', msg: 'User token not found' });\n+    }\n+\n+    const { userId } = tokenInfo;\n+\n+    const user = await this.prisma.user.findFirstOrThrow({\n+      where: { id: userId }\n+    });\n+\n+    if (!user) {\n+      logger.warn('User not found');\n+      void reply.code(400);\n+      return {\n+        type: 'error',\n+        msg: 'User for user token not found'\n+      } as const;\n+    }\n+\n+    const completedDate = Date.now();\n+    const { completedChallenges = [], partiallyCompletedChallenges = [] } =\n+      user;\n+\n+    const isCompleted = completedChallenges.some(\n+      challenge => challenge.id === challengeId\n+    );\n+\n+    if (challengeType === challengeTypes.codeAllyCert && !isCompleted) {\n+      const finalChallenge = {\n+        id: challengeId,\n+        completedDate\n+      };\n+\n+      await this.prisma.user.update({\n+        where: { id: userId },\n+        data: {\n+          partiallyCompletedChallenges: uniqBy(\n+            [finalChallenge, ...partiallyCompletedChallenges],\n+            'id'\n+          )\n+        }\n+      });\n+    } else {\n+      await updateUserChallengeData(this, user, challengeId, {\n+        id: challengeId,\n+        completedDate\n+      });\n+    }\n+  } catch (error) {\n+    // TODO(Post-MVP): don't catch, just let Sentry handle this.\n+    logger.error(error, 'Error submitting coderoad challenge');\n+    this.Sentry.captureException(error);\n+    void reply.code(500);\n+    return reply.send({\n+      type: 'error',\n+      msg: 'An error occurred trying to submit the challenge'\n+    });\n+  }\n+  reply.send({\n+    type: 'success',\n+    msg: 'Successfully submitted challenge'\n+  });\n+}\n+\n async function postDailyCodingChallengeCompleted(\n   this: FastifyInstance,\n   req: UpdateReqType<typeof schemas.dailyCodingChallengeCompleted>,"
        },
        {
            "sha": "4e29b2f5fcfa15740d21be274c7a0bd7040dbc7b",
            "filename": "api/src/schemas/challenge/coderoad-challenge-completed.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/00264908e8eef1230634c39558755df457cf857f/api%2Fsrc%2Fschemas%2Fchallenge%2Fcoderoad-challenge-completed.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/00264908e8eef1230634c39558755df457cf857f/api%2Fsrc%2Fschemas%2Fchallenge%2Fcoderoad-challenge-completed.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fschemas%2Fchallenge%2Fcoderoad-challenge-completed.ts?ref=00264908e8eef1230634c39558755df457cf857f",
            "patch": "@@ -1,5 +1,4 @@\n import { Type } from '@fastify/type-provider-typebox';\n-import { genericError } from '../types';\n \n export const coderoadChallengeCompleted = {\n   body: Type.Object({\n@@ -15,6 +14,9 @@ export const coderoadChallengeCompleted = {\n       type: Type.Literal('error'),\n       msg: Type.String()\n     }),\n-    default: genericError\n+    default: Type.Object({\n+      type: Type.Literal('error'),\n+      msg: Type.String()\n+    })\n   }\n };"
        }
    ],
    "stats": {
        "total": 341,
        "additions": 196,
        "deletions": 145
    }
}