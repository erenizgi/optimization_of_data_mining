{
    "author": "ojeytonwilliams",
    "message": "refactor: modularize typescript worker (#62668)",
    "sha": "df1c1a3f3f3c42510e1e904cecebb7e08a6bbd25",
    "files": [
        {
            "sha": "c4e908a4c0efb6c2eb96d60d942b5549b23001a8",
            "filename": "tools/client-plugins/browser-scripts/modules/react-types.json",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c1a3f3f3c42510e1e904cecebb7e08a6bbd25/tools%2Fclient-plugins%2Fbrowser-scripts%2Fmodules%2Freact-types.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c1a3f3f3c42510e1e904cecebb7e08a6bbd25/tools%2Fclient-plugins%2Fbrowser-scripts%2Fmodules%2Freact-types.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fclient-plugins%2Fbrowser-scripts%2Fmodules%2Freact-types.json?ref=df1c1a3f3f3c42510e1e904cecebb7e08a6bbd25",
            "previous_filename": "tools/client-plugins/browser-scripts/react-types.json"
        },
        {
            "sha": "80c1d45c9179ca189698ef09c366375155bfdbe6",
            "filename": "tools/client-plugins/browser-scripts/modules/typescript-compiler.ts",
            "status": "added",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c1a3f3f3c42510e1e904cecebb7e08a6bbd25/tools%2Fclient-plugins%2Fbrowser-scripts%2Fmodules%2Ftypescript-compiler.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c1a3f3f3c42510e1e904cecebb7e08a6bbd25/tools%2Fclient-plugins%2Fbrowser-scripts%2Fmodules%2Ftypescript-compiler.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fclient-plugins%2Fbrowser-scripts%2Fmodules%2Ftypescript-compiler.ts?ref=df1c1a3f3f3c42510e1e904cecebb7e08a6bbd25",
            "patch": "@@ -0,0 +1,88 @@\n+import type { VirtualTypeScriptEnvironment } from '@typescript/vfs';\n+import type { CompilerHost, CompilerOptions } from 'typescript';\n+\n+import reactTypes from './react-types.json';\n+\n+type TS = typeof import('typescript');\n+type TSVFS = typeof import('@typescript/vfs');\n+\n+export class Compiler {\n+  ts: TS;\n+  tsvfs: TSVFS;\n+  tsEnv?: VirtualTypeScriptEnvironment;\n+  compilerHost?: CompilerHost;\n+  constructor(\n+    ts: typeof import('typescript'),\n+    tsvfs: typeof import('@typescript/vfs')\n+  ) {\n+    this.ts = ts;\n+    this.tsvfs = tsvfs;\n+  }\n+\n+  async setup() {\n+    const ts = this.ts;\n+    const tsvfs = this.tsvfs;\n+\n+    const compilerOptions: CompilerOptions = {\n+      target: ts.ScriptTarget.ES2015,\n+      module: ts.ModuleKind.Preserve, // Babel is handling module transformation, so TS should leave them alone.\n+      skipLibCheck: true, // TODO: look into why this is needed. Are we doing something wrong? Could it be that it's not \"synced\"  with this TS version?\n+      // from the docs: \"Note: it's possible for this list to get out of\n+      // sync with TypeScript over time. It was last synced with TypeScript\n+      // 3.8.0-rc.\"\n+      jsx: ts.JsxEmit.Preserve, // Babel will handle JSX,\n+      allowUmdGlobalAccess: true // Necessary because React is loaded via a UMD script.\n+    };\n+    const fsMap = await tsvfs.createDefaultMapFromCDN(\n+      compilerOptions,\n+      ts.version,\n+      false, // TODO: cache this. It needs a store that's available to workers and implements https://github.com/microsoft/TypeScript-Website/blob/ac68b8b8e4a621113c4ee45c4051002fd55ede24/packages/typescript-vfs/src/index.ts#L11\n+      ts\n+    );\n+\n+    // This can be any path, but doing this means import React from 'react' works, if we ever need it.\n+    const reactTypesPath = `/node_modules/@types/react/index.d.ts`;\n+\n+    // It may be necessary to get all the types (global.d.ts etc)\n+    fsMap.set(reactTypesPath, reactTypes['react-18'] || '');\n+\n+    const system = tsvfs.createSystem(fsMap);\n+    // TODO: if passed an invalid compiler options object (e.g. { module:\n+    // ts.ModuleKind.CommonJS, moduleResolution: ts.ModuleResolutionKind.NodeNext\n+    // }), this will throw. When we allow users to set compiler options, we should\n+    // show them the diagnostics from this function.\n+    this.tsEnv = tsvfs.createVirtualTypeScriptEnvironment(\n+      system,\n+      [reactTypesPath],\n+      ts,\n+      compilerOptions\n+    );\n+\n+    this.compilerHost = tsvfs.createVirtualCompilerHost(\n+      system,\n+      compilerOptions,\n+      ts\n+    ).compilerHost;\n+  }\n+\n+  compile(code: string, fileName: string) {\n+    if (!this.tsEnv || !this.compilerHost) {\n+      throw Error('TypeScript environment not set up');\n+    }\n+    // TODO: If creating the file fresh each time is too slow, we can try checking\n+    // if the file exists and updating it if it does.\n+    this.tsEnv.createFile(fileName, code);\n+\n+    const program = this.tsEnv.languageService.getProgram()!;\n+\n+    const emitOutput = this.tsEnv.languageService.getEmitOutput(fileName);\n+    const result = emitOutput.outputFiles[0].text;\n+\n+    const error = this.ts.formatDiagnostics(\n+      this.ts.getPreEmitDiagnostics(program),\n+      this.compilerHost\n+    );\n+\n+    return { result, error };\n+  }\n+}"
        },
        {
            "sha": "d2d13d7610ef00af9a566173eb00d226a1d2577d",
            "filename": "tools/client-plugins/browser-scripts/typescript-worker.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 78,
            "changes": 92,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c1a3f3f3c42510e1e904cecebb7e08a6bbd25/tools%2Fclient-plugins%2Fbrowser-scripts%2Ftypescript-worker.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c1a3f3f3c42510e1e904cecebb7e08a6bbd25/tools%2Fclient-plugins%2Fbrowser-scripts%2Ftypescript-worker.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fclient-plugins%2Fbrowser-scripts%2Ftypescript-worker.ts?ref=df1c1a3f3f3c42510e1e904cecebb7e08a6bbd25",
            "patch": "@@ -1,14 +1,10 @@\n-import { type VirtualTypeScriptEnvironment } from '@typescript/vfs';\n-import type { CompilerOptions, CompilerHost } from 'typescript';\n-import reactTypes from './react-types.json';\n+import { Compiler } from './modules/typescript-compiler';\n \n // Most of the ts types are only a guideline. This is because we're not bundling\n // TS in this worker. The specific TS version is going to be determined by the\n // challenge (in general - it will be hardcoded in the MVP). So, the vfs types\n // should be correct, but ts may not be.\n declare const tsvfs: typeof import('@typescript/vfs');\n-declare const createDefaultMapFromCDN: typeof import('@typescript/vfs').createDefaultMapFromCDN;\n-declare const createVirtualCompilerHost: typeof import('@typescript/vfs').createVirtualCompilerHost;\n declare const ts: typeof import('typescript');\n \n const ctx: Worker & typeof globalThis = self as unknown as Worker &\n@@ -43,13 +39,11 @@ interface CancelEvent extends MessageEvent {\n // Pin at the latest TS version available as cdnjs doesn't support version range.\n const TS_VERSION = '5.9.2';\n \n-let tsEnv: VirtualTypeScriptEnvironment | null = null;\n-let compilerHost: CompilerHost | null = null;\n let cachedVersion: string | null = null;\n \n // NOTE: vfs.globals must only be imported once, otherwise it will throw.\n importScripts(\n-  'https://cdn.jsdelivr.net/npm/@typescript/vfs@1.6.0/dist/vfs.globals.js'\n+  'https://cdnjs.cloudflare.com/ajax/libs/typescript-vfs/1.6.1/vfs.globals.js'\n );\n \n function importTS(version: string) {\n@@ -65,57 +59,6 @@ function importTS(version: string) {\n   cachedVersion = version;\n }\n \n-async function setupTypeScript() {\n-  importTS(TS_VERSION);\n-  const compilerOptions: CompilerOptions = {\n-    target: ts.ScriptTarget.ES2015,\n-    module: ts.ModuleKind.Preserve, // Babel is handling module transformation, so TS should leave them alone.\n-    skipLibCheck: true, // TODO: look into why this is needed. Are we doing something wrong? Could it be that it's not \"synced\"  with this TS version?\n-    // from the docs: \"Note: it's possible for this list to get out of\n-    // sync with TypeScript over time. It was last synced with TypeScript\n-    // 3.8.0-rc.\"\n-    jsx: ts.JsxEmit.Preserve, // Babel will handle JSX,\n-    allowUmdGlobalAccess: true // Necessary because React is loaded via a UMD script.\n-  };\n-  const fsMap = await createDefaultMapFromCDN(\n-    compilerOptions,\n-    ts.version,\n-    false, // TODO: cache this. It needs a store that's available to workers and implements https://github.com/microsoft/TypeScript-Website/blob/ac68b8b8e4a621113c4ee45c4051002fd55ede24/packages/typescript-vfs/src/index.ts#L11\n-    ts\n-  );\n-\n-  // This can be any path, but doing this means import React from 'react' works, if we ever need it.\n-  const reactTypesPath = `/node_modules/@types/react/index.d.ts`;\n-\n-  // It may be necessary to get all the types (global.d.ts etc)\n-  fsMap.set(reactTypesPath, reactTypes['react-18'] || '');\n-\n-  const system = tsvfs.createSystem(fsMap);\n-  // TODO: if passed an invalid compiler options object (e.g. { module:\n-  // ts.ModuleKind.CommonJS, moduleResolution: ts.ModuleResolutionKind.NodeNext\n-  // }), this will throw. When we allow users to set compiler options, we should\n-  // show them the diagnostics from this function.\n-  const env = tsvfs.createVirtualTypeScriptEnvironment(\n-    system,\n-    [reactTypesPath],\n-    ts,\n-    compilerOptions\n-  );\n-\n-  compilerHost = createVirtualCompilerHost(\n-    system,\n-    compilerOptions,\n-    ts\n-  ).compilerHost;\n-\n-  tsEnv = env;\n-\n-  // We freeze this to prevent learners from getting the worker into a\n-  // weird state.\n-  Object.freeze(self);\n-  return env;\n-}\n-\n ctx.onmessage = (\n   e: TSCompileEvent | CheckIsReadyRequestEvent | CancelEvent\n ) => {\n@@ -129,15 +72,22 @@ ctx.onmessage = (\n   }\n };\n \n-const isTSSetup = setupTypeScript();\n+importTS(TS_VERSION);\n+\n+const compiler = new Compiler(ts, tsvfs);\n+const isSetup = compiler.setup();\n \n // This lets the client know that there is nothing to cancel.\n function handleCancelRequest({ value }: { value: number }) {\n   postMessage({ type: 'is-alive', text: value });\n }\n \n async function handleCheckIsReadyRequest(port: MessagePort) {\n-  await isTSSetup;\n+  await isSetup;\n+  // We freeze this to prevent learners from getting the worker into a weird\n+  // state.\n+  Object.freeze(self);\n+\n   port.postMessage({ type: 'ready' });\n }\n \n@@ -146,25 +96,11 @@ function handleCompileRequest(data: TSCompileEvent['data'], port: MessagePort) {\n   // permanently unable to interact with that file. The workaround is to create\n   // a file with a single newline character.\n   const code = (data.code || '').slice() || '\\n';\n-\n-  // TODO: If creating the file fresh each time is too slow, we can try checking\n-  // if the file exists and updating it if it does.\n-  // TODO: make sure the .tsx extension doesn't cause issues with vanilla TS.\n-  tsEnv?.createFile('/index.tsx', code);\n-\n-  const program = tsEnv!.languageService.getProgram()!;\n-\n-  const emitOutput = tsEnv!.languageService.getEmitOutput('index.tsx');\n-  const compiled = emitOutput.outputFiles[0].text;\n-\n+  const { result, error } = compiler.compile(code, 'index.tsx');\n   const message: TSCompiledMessage = {\n     type: 'compiled',\n-    value: compiled,\n-    // TODO: stop forcing the non-null assertions here.\n-    error: ts.formatDiagnostics(\n-      ts.getPreEmitDiagnostics(program),\n-      compilerHost!\n-    )\n+    value: result,\n+    error: error\n   };\n \n   port.postMessage(message);"
        }
    ],
    "stats": {
        "total": 180,
        "additions": 102,
        "deletions": 78
    }
}