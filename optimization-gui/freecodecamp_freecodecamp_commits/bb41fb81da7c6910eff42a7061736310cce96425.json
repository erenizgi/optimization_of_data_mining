{
    "author": "zairahira",
    "message": "fix(curriculum): add DS review page (#61771)",
    "sha": "bb41fb81da7c6910eff42a7061736310cce96425",
    "files": [
        {
            "sha": "b49b47b45241c846fe6cc0fbace2152a50bd26ee",
            "filename": "client/i18n/locales/english/intro.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/bb41fb81da7c6910eff42a7061736310cce96425/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/bb41fb81da7c6910eff42a7061736310cce96425/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json?ref=bb41fb81da7c6910eff42a7061736310cce96425",
            "patch": "@@ -4417,7 +4417,7 @@\n         \"title\": \"Data Structures Review\",\n         \"intro\": [\n           \"Before you're quizzed on data structures, you should review what you've learned about them.\",\n-          \"[Add more details]\"\n+          \"Open up this page to review concepts like the different data structures, algorithms, time and space complexity, and big O notation.\"\n         ]\n       },\n       \"quiz-data-structures\": {"
        },
        {
            "sha": "21ac29b126c5e18e5696ff1afa70607f9c43af9e",
            "filename": "client/src/pages/learn/full-stack-developer/review-data-structures/index.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/bb41fb81da7c6910eff42a7061736310cce96425/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Freview-data-structures%2Findex.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/bb41fb81da7c6910eff42a7061736310cce96425/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Freview-data-structures%2Findex.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Freview-data-structures%2Findex.md?ref=bb41fb81da7c6910eff42a7061736310cce96425",
            "patch": "@@ -6,4 +6,4 @@ superBlock: full-stack-developer\n \n ## Introduction to the Data Structures Review\n \n-Before you're quizzed on data structures, you should review what you've learned about them. [Add more details]\n+Before you're quizzed on data structures, you should review what you have learned about algorithms, time and space complexity, and big O notation."
        },
        {
            "sha": "f8fbae5ec2e57eaa1ca403ce46e11d87be063e95",
            "filename": "curriculum/challenges/english/25-front-end-development/review-data-structures/67f39dc7129b092b27099d8c.md",
            "status": "modified",
            "additions": 255,
            "deletions": 4,
            "changes": 259,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/bb41fb81da7c6910eff42a7061736310cce96425/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Freview-data-structures%2F67f39dc7129b092b27099d8c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/bb41fb81da7c6910eff42a7061736310cce96425/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Freview-data-structures%2F67f39dc7129b092b27099d8c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Freview-data-structures%2F67f39dc7129b092b27099d8c.md?ref=bb41fb81da7c6910eff42a7061736310cce96425",
            "patch": "@@ -6,14 +6,265 @@ dashedName: review-data-structures\n ---\n \n # --description--\n+ \n+## Algorithms and Big O Notation\n \n-## First topic\n+- **Algorithms**: A set of unambiguous instructions for solving a problem or carrying out a task. Algorithms must finish in a finite number of steps and each step must be precise and unambiguous.\n \n-Describe\n+- **Big O Notation**: Describes the worst-case performance, or growth rate, of an algorithm as the input size increases. It focuses on how resource usage grows with input size, ignoring constant factors and lower-order terms.\n \n-## Second topic\n+### Common Time Complexities\n \n-Describe\n+- **O(1) - Constant Time**: Algorithm takes the same amount of time regardless of input size.\n+\n+```python\n+def check_even_or_odd(number):\n+    if number % 2 == 0:\n+        return 'Even'\n+    else:\n+        return 'Odd'\n+```\n+\n+- **O(log n) - Logarithmic Time**: Time increases slowly as input grows. Common in algorithms that repeatedly reduce problem size by a fraction (like Binary Search).\n+\n+- **O(n) - Linear Time**: Running time increases proportionally to input size.\n+\n+```python\n+for grade in grades:\n+    print(grade)\n+```\n+\n+- **O(n log n) - Log-Linear Time**: Common time complexity of efficient sorting algorithms like Merge Sort and Quick Sort.\n+\n+- **O(n²) - Quadratic Time**: Running time increases quadratically. Often seen in nested loops.\n+\n+```python\n+for i in range(n):\n+    for j in range(n):\n+        print(\"Hello, World!\")\n+```\n+\n+### Space Complexity\n+\n+- **O(1) - Constant Space**: Algorithm uses same amount of memory regardless of input size.\n+- **O(n) - Linear Space**: Memory usage grows proportionally with input size.\n+- **O(n²) - Quadratic Space**: Memory usage grows quadratically with input size.\n+\n+## Problem-Solving Techniques\n+\n+- **Understanding the Problem**: Read the problem statement multiple times. Identify the input, expected output, and how to transform input to output.\n+\n+- **Pseudocode**: High-level description of algorithm logic that is language-independent. Uses common written language mixed with programming constructs like `IF`, `ELSE`, `FOR`, `WHILE`.\n+\n+```md\n+GET original_string\n+SET reversed_string = \"\"\n+FOR EACH character IN original_string:\n+  ADD character TO THE BEGINNING OF reversed_string\n+DISPLAY reversed_string\n+```\n+\n+- **Edge Cases**: Specific, valid inputs that occur at the boundaries of what an algorithm should handle. Always consider and test edge cases.\n+\n+## Arrays\n+\n+- **Static Arrays**: Have a fixed size determined at initialization. Elements stored in adjacent memory locations. Size cannot be changed during program execution.\n+\n+- **Dynamic Arrays**: Can grow or shrink automatically during program execution. Handle resizing through automatic copying to larger arrays when needed.\n+\n+### Python Lists (Dynamic Arrays)\n+\n+```python\n+numbers = [3, 4, 5, 6]\n+\n+# Access elements\n+numbers[0]  # 3\n+\n+# Update elements\n+numbers[2] = 16\n+\n+# Add elements\n+numbers.append(7)\n+numbers.insert(3, 15)  # Insert at specific index\n+\n+# Remove elements\n+numbers.pop(2)  # Remove at specific index\n+numbers.pop()   # Remove last element\n+```\n+\n+### Time Complexities for Dynamic Arrays\n+\n+- **Access**: O(1)\n+- **Insert at end**: O(1) average, O(n) when resizing needed\n+- **Insert in middle**: O(n)\n+- **Delete**: O(n) for middle, O(1) for end\n+\n+## Stacks\n+\n+- **Stacks**: Last-In, First-Out (LIFO) data structure. Elements added and removed from the top only.\n+\n+- **Push Operation**: Adding an element to the top of the stack. Time complexity: O(1).\n+\n+- **Pop Operation**: Removing an element from the top of the stack. Time complexity: O(1).\n+\n+```python\n+# Using Python list as stack\n+stack = []\n+\n+# Push operations\n+stack.append(1)\n+stack.append(2)\n+stack.append(3)\n+\n+# Pop operations\n+top_element = stack.pop()  # Returns 3\n+```\n+\n+## Queues\n+\n+- **Queues**: First-In, First-Out (FIFO) data structure. Elements added to the back and removed from the front.\n+\n+- **Enqueue Operation**: Adding an element to the back of the queue. Time complexity: O(1).\n+\n+- **Dequeue Operation**: Removing an element from the front of the queue. Time complexity: O(1).\n+\n+```python\n+from collections import deque\n+\n+# Using deque for efficient queue operations\n+queue = deque()\n+\n+# Enqueue operations\n+queue.append(1)\n+queue.append(2)\n+queue.append(3)\n+\n+# Dequeue operations\n+first_element = queue.popleft()  # Returns 1\n+```\n+\n+## Linked Lists\n+\n+- **Linked Lists**: Linear data structure where each node contains data and a reference to the next node. Nodes are connected like a chain.\n+\n+### Singly Linked Lists\n+\n+- **Structure**: Each node has data and one reference to the next node.\n+- **Traversal**: Can only move forward from head to tail.\n+- **Head Node**: First node in the list, usually the only directly accessible node.\n+- **Tail Node**: Last node in the list, points to `None`.\n+\n+### Operations and Time Complexities\n+\n+- **Insert at beginning**: O(1)\n+- **Insert at end**: O(n) - must traverse to end\n+- **Insert in middle**: O(n) - must traverse to position\n+- **Delete from beginning**: O(1)\n+- **Delete from end**: O(n) - must traverse to find previous node\n+- **Delete from middle**: O(n) - must traverse to find node\n+\n+### Doubly Linked Lists\n+\n+- **Structure**: Each node has data and two references: next node and previous node.\n+- **Traversal**: Can move in both directions.\n+- **Memory**: Requires more memory than singly linked lists due to extra reference.\n+\n+## Hash Maps and Sets\n+\n+### Maps and Hash Maps\n+\n+- **Map (Abstract Data Type)**: Manages collections of key-value pairs. Every key must be unique, but values can be repeated.\n+\n+- **Hash Map**: Concrete implementation of map ADT using hashing technique. Uses hash function to generate hash values for keys, which determine storage location in underlying array.\n+\n+### Python Dictionaries (Hash Maps)\n+\n+```python\n+# Creating dictionaries\n+my_dictionary = {\n+    \"A\": 1,\n+    \"B\": 2, \n+    \"C\": 3\n+}\n+\n+# Alternative creation\n+my_dictionary = dict(A=1, B=2, C=3)\n+\n+# Access and modify\n+value = my_dictionary[\"A\"]  # 1\n+my_dictionary[\"A\"] = 4      # Update value\n+del my_dictionary[\"A\"]      # Remove key-value pair\n+\n+# Check membership\n+\"C\" in my_dictionary\n+\n+# Get keys, values, items\n+my_dictionary.keys()\n+my_dictionary.values()\n+my_dictionary.items()\n+```\n+\n+### Time Complexities for Hash Maps\n+\n+- **Average case**: O(1) for insert, get, delete\n+- **Worst case**: O(n) when many hash collisions occur\n+\n+### Sets\n+\n+- **Sets**: Unordered collections of unique elements. No duplicates allowed, no specific order maintained.\n+\n+- **Immutable Elements Only**: Sets can only contain immutable data types (numbers, strings, tuples) because hash values must remain constant.\n+\n+```python\n+# Creating sets\n+numbers = {1, 2, 3, 4}\n+empty_set = set()  # Must use set(), not {}\n+\n+# Add and remove elements\n+numbers.add(5)\n+numbers.remove(4)      # Raises KeyError if not found\n+numbers.discard(4)     # No error if not found\n+\n+# Set operations\n+set_a = {1, 2, 3, 4}\n+set_b = {2, 3, 4, 5, 6}\n+\n+# Union, intersection, difference, symmetric difference\n+set_a.union(set_b)                    # or set_a | set_b\n+set_a.intersection(set_b)             # or set_a & set_b\n+set_a.difference(set_b)               # or set_a - set_b\n+set_a.symmetric_difference(set_b)     # or set_a ^ set_b\n+\n+# Subset and superset checks\n+set_a.issubset(set_b)\n+set_a.issuperset(set_b)\n+set_a.isdisjoint(set_b)\n+\n+# Membership testing\n+5 in numbers\n+```\n+\n+### Time Complexities for Sets\n+\n+- **Average case**: O(1) for add, remove, membership testing\n+- **Worst case**: O(n) due to hash collisions\n+\n+## Hash Collisions\n+\n+- **Hash Collision**: Occurs when two different keys produce the same hash value.\n+\n+- **Collision Resolution Strategies**:\n+  - **Chaining**: Each array index points to a linked list storing all elements with same hash value\n+  - **Open Addressing**: Search for next available index using predefined sequence\n+\n+## When to Use Each Data Structure\n+\n+- **Lists**: When you need ordered, indexed access and don't know size in advance\n+- **Stacks**: For LIFO operations (undo functionality, expression evaluation, backtracking)\n+- **Queues**: For FIFO operations (task scheduling, breadth-first search)\n+- **Linked Lists**: When frequent insertion/deletion at beginning, unknown size, no random access needed\n+- **Hash Maps**: For fast key-value lookups, counting occurrences, caching\n+- **Sets**: For uniqueness checking, mathematical set operations, removing duplicates\n \n # --assignment--\n "
        }
    ],
    "stats": {
        "total": 263,
        "additions": 257,
        "deletions": 6
    }
}