{
    "author": "akshith30388",
    "message": "feat(curriculum): Improve example in \"Working with Regular Expressions\" lesson",
    "sha": "843457665eae04483b5ae300bf02d9430c01822d",
    "files": [
        {
            "sha": "de5a8fe3be98b38d0ccaa1c7be2f833140bd45f6",
            "filename": "curriculum/challenges/english/blocks/lecture-working-with-regular-expressions/6733c5f20cc9584cada942a4.md",
            "status": "modified",
            "additions": 29,
            "deletions": 3,
            "changes": 32,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/843457665eae04483b5ae300bf02d9430c01822d/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-regular-expressions%2F6733c5f20cc9584cada942a4.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/843457665eae04483b5ae300bf02d9430c01822d/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-regular-expressions%2F6733c5f20cc9584cada942a4.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-regular-expressions%2F6733c5f20cc9584cada942a4.md?ref=843457665eae04483b5ae300bf02d9430c01822d",
            "patch": "@@ -5,9 +5,7 @@ challengeType: 19\n dashedName: what-are-capturing-groups-and-backreferences-and-how-do-they-work\n ---\n \n-# --description--\n-\n-Let's learn about capturing groups and backreferences in regular expressions.\n+# --interactive--\n \n A capturing group allows you to \"capture\" a portion of the matched string to use however you might need. Capturing groups are defined by parentheses containing the pattern to capture, with no leading characters like a lookahead.\n \n@@ -19,11 +17,15 @@ const regex = /free(code)camp/i;\n \n To confirm the behavior, we can test it against a `freecodecamp` string:\n \n+:::interactive_editor\n+\n ```js\n const regex = /free(code)camp/i;\n console.log(regex.test(\"freecodecamp\")); // true\n ```\n \n+:::\n+\n But this doesn't actually make use of our captured group. Instead, let's take a look at the result of using `match`:\n \n ```js\n@@ -44,29 +46,41 @@ Notice how the capture group matches the exact pattern `code`, where a character\n \n But how can we actually use this? Well, capture groups are often used when replacing contents of a string. Let's set up some code to do that. We're going to turn `freecodecamp` into `paidcodeworld`:\n \n+:::interactive_editor\n+\n ```js\n const regex = /free(code)camp/i;\n console.log(\"freecodecamp\".replace(regex, \"paidcodeworld\"));\n ```\n \n+:::\n+\n This works on its own, but what if we didn't know how many `o`'s were in `code`? If we need a quantifier for one or more `o`s:\n \n+:::interactive_editor\n+\n ```js\n const regex = /free(co+de)camp/i;\n console.log(\"freecoooooooodecamp\".replace(regex, \"paidcodeworld\"));\n ```\n \n+:::\n+\n We're getting `paidcodeworld` as our result. We want to preserve the number of `o`'s, so we need to reuse what was captured by the regular expression.\n \n This is where a backreference comes in. Instead of hardcoding the `code` portion of our replacement string, we can reference the captured group directly.\n \n In a `replace` call, you achieve a backreference by using a dollar sign (`$`) followed by the number of the capture group to use. In our case, that would be `$1`, since `code` is captured in the first capture group:\n \n+:::interactive_editor\n+\n ```js\n const regex = /free(co+de)camp/i;\n console.log(\"freecoooooooodecamp\".replace(regex, \"paid$1world\")); // paidcoooooooodeworld\n ```\n \n+:::\n+\n We have now successfully preserved an unknown number of `o` characters when converting `freecodecamp` into `paidcodeworld`. But backreferences aren't just limited to the replace call. You can actually use them directly in a regular expression.\n \n This would allow you to match a previously captured pattern later on in the regular expression.\n@@ -83,12 +97,16 @@ This current expression won't ensure that the number of `o` characters is the sa\n \n Inside a regular expression, a backreference is denoted with a backslash followed by the number of the capture group:\n \n+:::interactive_editor\n+\n ```js\n const regex = /free(co+de)camp.*free\\1camp/i;\n console.log(regex.test(\"freecooooodecamp is great i love freecooooodecamp\")); // true\n console.log(regex.test(\"freecooooodecamp is great i love freecodecamp\")); // false\n ```\n \n+:::\n+\n And with that, we can see that a string with the correct number of `o`s matches, while a string with two different numbers of `o`s does not.\n \n This syntax is great, but can quickly get confusing when you are referencing multiple capture groups. Thankfully, instead of using numbers, you can give your groups names.\n@@ -107,18 +125,26 @@ const regex = /free(?<code>co+de)camp.*free\\k<code>camp/i;\n \n Now if we check our `test()` call, we can see that we still pass:\n \n+:::interactive_editor\n+\n ```js\n const regex = /free(?<code>co+de)camp.*free\\k<code>camp/i;\n console.log(regex.test(\"freecooooodecamp is freecooooodecamp\")); // true\n ```\n \n+:::\n+\n To use our named capture group in a `replace()` call, we'd insert a dollar sign into the string, followed by the name enclosed in less than and greater than signs:\n \n+:::interactive_editor\n+\n ```js\n const regex = /free(?<code>co+de)camp/i;\n console.log(\"freecooooodecamp\".replace(regex, \"paid$<code>camp\")); // paidcooooodecamp\n ```\n \n+:::\n+\n Finally, sometimes you want to create a group of characters, but don't need the captured result.\n \n Let's say we want to match either `freecodecamp` or `freecandycamp`. You could create two patterns separated by an OR assertion:"
        }
    ],
    "stats": {
        "total": 32,
        "additions": 29,
        "deletions": 3
    }
}