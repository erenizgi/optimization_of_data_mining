{
    "author": "moT01",
    "message": "feat(curriculum): add git and GitHub lectures (#62116)\n\nCo-authored-by: Zaira <33151350+zairahira@users.noreply.github.com>\nCo-authored-by: Ilenia <26656284+ilenia-magoni@users.noreply.github.com>",
    "sha": "df1c226cc608cbc69eb730b7a2a8fad186957f7f",
    "files": [
        {
            "sha": "664d83f63a5b15d43c8a9bbebbe0a33d28ee69b0",
            "filename": "client/i18n/locales/english/intro.json",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -4805,7 +4805,16 @@\n           \"In this 40-lesson workshop, you will learn how to edit files in the terminal with Nano while building a castle.\"\n         ]\n       },\n-      \"rhhl\": { \"title\": \"328\", \"intro\": [] },\n+      \"lecture-introduction-to-git-and-github\": {\n+        \"title\": \"Introduction to Git and GitHub\",\n+        \"intro\": [\"Learn how to work with Git and GitHub in these lectures.\"]\n+      },\n+      \"lecture-working-with-code-reviews-branching-deployment-and-ci-cd\": {\n+        \"title\": \"Working With Code Reviews, Branching, Deployment, and CI/CD\",\n+        \"intro\": [\n+          \"Learn about code reviews, branching, deployment, and CI/CD in these lectures.\"\n+        ]\n+      },\n       \"workshop-sql-reference-object\": {\n         \"title\": \"Build an SQL Reference Object\",\n         \"intro\": ["
        },
        {
            "sha": "f23ff01bc1693854d30e6762ba94fcce7c557c83",
            "filename": "client/src/pages/learn/full-stack-developer/lecture-introduction-to-git-and-github/index.md",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-introduction-to-git-and-github%2Findex.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-introduction-to-git-and-github%2Findex.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-introduction-to-git-and-github%2Findex.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,9 @@\n+---\n+title: Introduction to Git and GitHub\n+block: lecture-introduction-to-git-and-github\n+superBlock: full-stack-developer\n+---\n+\n+## Introduction to Git and GitHub\n+\n+Learn about working with Git and GitHub in these lectures."
        },
        {
            "sha": "c2d601480a53146a9ed740462f184740ef92564c",
            "filename": "client/src/pages/learn/full-stack-developer/lecture-working-with-code-reviews-branching-deployment-and-ci-cd/index.md",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2Findex.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2Findex.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2Findex.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,9 @@\n+---\n+title: Introduction to Working With Code Reviews, Branching, Deployment, and CI/CD\n+block: lecture-working-with-code-reviews-branching-deployment-and-ci-cd\n+superBlock: full-stack-developer\n+---\n+\n+## Introduction to Working With Code Reviews, Branching, Deployment, and CI/CD\n+\n+Learn about working with code reviews, branching, deployment, and CI/CD in these lectures."
        },
        {
            "sha": "093645779199c29831f22a0e683c5b948cef810f",
            "filename": "curriculum/challenges/english/blocks/lecture-introduction-to-git-and-github/68828e965f70137025ec5031.md",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F68828e965f70137025ec5031.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F68828e965f70137025ec5031.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F68828e965f70137025ec5031.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,136 @@\n+---\n+id: 68828e965f70137025ec5031\n+title: What Is Version Control, and Why Are These Systems Necessary?\n+challengeType: 19\n+dashedName: what-is-version-control-and-why-are-these-systems-necessary\n+---\n+\n+# --description--\n+\n+If you've worked on something, like a thesis paper, where you've saved copies after making significant changes and named the files something like `Thesis-Draft`, `Thesis-Final`, `Thesis-Final-For-Real`, and `Thesis-Absolute-Final-DO-NOT-CHANGE`, you've used a very rudimentary approach to version control. But what if I told you there is a better way?\n+\n+You may have heard of tools like Git, SVN, or Mercurial before. These are version control systems, and they are a key component to every developer's workflow. A version control system allows you to track and manage changes in your project. For the purposes of these lectures, we will be focusing on Git.\n+\n+Git offers powerful tools that allow you to manage the edit history of a project. You will learn more about how to use Git and the features it offers in upcoming lectures. For now, here's what you really need to know:\n+\n+Git allows you to do things like create commits, which are a snapshot of a specific state of your codebase. You can then compare commits to see what changes you have made, revert a commit that has improper changes, and more.\n+\n+You can also create \"branches\", which you can think of as different pathways in your code. While a branch might be the road you walk down, commits are the landmarks along the way. Branches allow you to do things like work on a new feature in isolation, such that if your work goes sideways you can delete the branch without impacting the core codebase.\n+\n+These features make version control an essential component of collaboration with other developers. When you have multiple people working in the same project, branches allow each of them to work on their own code without running over each other's changes.\n+\n+You will often pair a version control system like Git with a version control provider like GitHub or Gitlab, which offers you additional collaboration tools and the ability to back up your projects to the cloud.\n+\n+But even without a cloud-based storage solution, version control systems can be a game changer for your workflows. No more `THIS-IS-THE-FINAL-COPY-FOREVER` files.\n+\n+There's a lot of cool information to cover about using these systems, so let's do a deep dive in the next few lectures!\n+\n+# --questions--\n+\n+## --text--\n+\n+What is a commit in Git?\n+\n+## --answers--\n+\n+A development branch.\n+\n+### --feedback--\n+\n+Think about what Git saves when you make changes to your project.\n+\n+---\n+\n+A snapshot of a specific state of your codebase.\n+\n+---\n+\n+A cloud backup service.\n+\n+### --feedback--\n+\n+Think about what Git saves when you make changes to your project.\n+\n+---\n+\n+A collaboration tool for developers.\n+\n+### --feedback--\n+\n+Think about what Git saves when you make changes to your project.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+Why are branches useful in version control systems like Git?\n+\n+## --answers--\n+\n+They automatically fix bugs in your code.\n+\n+### --feedback--\n+\n+Consider how branches help when multiple developers work on the same project.\n+\n+---\n+\n+They increase the speed of your application.\n+\n+### --feedback--\n+\n+Consider how branches help when multiple developers work on the same project.\n+\n+---\n+\n+They allow you to work on features in isolation.\n+\n+---\n+\n+They provide better encryption for your project files.\n+\n+### --feedback--\n+\n+Consider how branches help when multiple developers work on the same project.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+Which of the following is NOT mentioned as a version control system in the lecture?\n+\n+## --answers--\n+\n+Git\n+\n+### --feedback--\n+\n+Review the version control systems mentioned at the beginning of the lecture.\n+\n+---\n+\n+SVN\n+\n+### --feedback--\n+\n+Review the version control systems mentioned at the beginning of the lecture.\n+\n+---\n+\n+Mercurial\n+\n+### --feedback--\n+\n+Review the version control systems mentioned at the beginning of the lecture.\n+\n+---\n+\n+Docker\n+\n+## --video-solution--\n+\n+4"
        },
        {
            "sha": "15c4a78317b0e10376003fc974bc3a71b8a82071",
            "filename": "curriculum/challenges/english/blocks/lecture-introduction-to-git-and-github/688290189fecfe7206d22833.md",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F688290189fecfe7206d22833.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F688290189fecfe7206d22833.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F688290189fecfe7206d22833.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,136 @@\n+---\n+id: 688290189fecfe7206d22833\n+title: What Is the Purpose of Sites Like GitHub and GitLab, and What Are Some Benefits of Using Them?\n+challengeType: 19\n+dashedName: what-is-the-purpose-of-sites-like-github-and-gitlab\n+---\n+\n+# --description--\n+\n+In a previous lecture, we briefly mentioned GitHub. Both GitHub and Gitlab are version control providers. This means they are cloud-based solutions that offer storage of version-controlled projects in something called \"repositories\", and enable collaboration features to use with those projects.\n+\n+Before we dive in to the features these platforms offer, we need to discuss the different types of projects. Many projects are considered \"open-source\", which means people can see the code you publish, propose changes, report issues, and even run a modified version.\n+\n+But sometimes you may only want your teammates to see and work on the code. You can also publish a project as \"closed-source\", meaning the only people who can see and interact with the project are the people you explicitly authorize.\n+\n+Regardless of which approach your project takes, sites like GitHub and Gitlab can massively level up your team's collaboration.\n+\n+For example, a teammate working on a feature might be stuck and have questions. Rather than having to copy-paste the code into Discord for you to read, or hop on a call to screen share their work, they can upload the changes directly to GitHub. From there, you can view the changes in your browser or even download the changes to run and debug locally.\n+\n+When a teammate has completed a feature, they can propose the changes through these websites. You are then able to review the changes, leaving comments on specific files or lines if you have thoughts and questions. You can even propose suggested edits which they can apply to the changes right there in the browser!\n+\n+If you are happy with the changes, you can accept them and merge them into your primary branch. This means the entire team can then download the latest changes locally so they have the most up-to-date code when they start on their next task.\n+\n+Speaking of tasks, these sites also offer powerful issue trackers. You can use these to track and assign tickets to your team members, accept bug reports from the public, and even plan full sprints through things like the project boards.\n+\n+There are many more features offered by these sites. In the next few lectures, we'll cover the key aspects so you can dive right in and start collaborating!\n+\n+# --questions--\n+\n+## --text--\n+\n+What is the main purpose of GitHub and GitLab as discussed in the lecture?\n+\n+## --answers--\n+\n+Primarily for storing backups of code.\n+\n+### --feedback--\n+\n+Consider what these platforms allow teams to do with their projects.\n+\n+---\n+\n+Version control providers with collaboration features.\n+\n+---\n+\n+Platforms exclusively for open-source projects.\n+\n+### --feedback--\n+\n+Consider what these platforms allow teams to do with their projects.\n+\n+---\n+\n+Tools for writing and editing code online.\n+\n+### --feedback--\n+\n+Consider what these platforms allow teams to do with their projects.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+What is an advantage of using GitHub or GitLab for team collaboration?\n+\n+## --answers--\n+\n+They automatically fix bugs in your code.\n+\n+### --feedback--\n+\n+Think about how these platforms improve the workflow between teammates.\n+\n+---\n+\n+They eliminate the need for code reviews.\n+\n+### --feedback--\n+\n+Think about how these platforms improve the workflow between teammates.\n+\n+---\n+\n+Team members can propose changes that others can review online.\n+\n+---\n+\n+They provide free web hosting for all projects.\n+\n+### --feedback--\n+\n+Think about how these platforms improve the workflow between teammates.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+Which of the following project management features do GitHub and GitLab offer?\n+\n+## --answers--\n+\n+Automatic code generation.\n+\n+### --feedback--\n+\n+Think about how these platforms help organize work within a team.\n+\n+---\n+\n+Issue trackers and project boards.\n+\n+---\n+\n+Direct integration with Discord.\n+\n+### --feedback--\n+\n+Think about how these platforms help organize work within a team.\n+\n+---\n+\n+Free domain name registration.\n+\n+### --feedback--\n+\n+Think about how these platforms help organize work within a team.\n+\n+## --video-solution--\n+\n+2"
        },
        {
            "sha": "5a98671975fbb546c1f70cde03035dab75122be4",
            "filename": "curriculum/challenges/english/blocks/lecture-introduction-to-git-and-github/6882902bc844b1723da7eb13.md",
            "status": "added",
            "additions": 194,
            "deletions": 0,
            "changes": 194,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F6882902bc844b1723da7eb13.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F6882902bc844b1723da7eb13.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F6882902bc844b1723da7eb13.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,194 @@\n+---\n+id: 6882902bc844b1723da7eb13\n+title: How Do You Install and Set Up Git?\n+challengeType: 19\n+dashedName: how-do-you-install-and-set-up-git\n+---\n+\n+# --description--\n+\n+Before you can really start to make use of version control, and sites like GitHub, you need to have Git installed and ready to use.\n+\n+To check if Git is already installed on your machine you can run the following command in the terminal:\n+\n+```sh\n+git --version\n+```\n+\n+If you see a version number, that means Git is installed. If not, then you will need to install it.\n+\n+For Linux systems, Git often comes preinstalled with most distros. If you do not have Git pre-installed, you should be able to install it with your package manager commands such as `sudo apt-get install git` or `sudo pacman -S git`.\n+\n+For Mac users, you can install Git via Homebrew with `brew install git`, or you can download the executable installer from Git's website.\n+\n+For Windows, you can download the executable installer from Git's website. Or, if you have set up Chocolatey, you can run `choco install git.install` in PowerShell. Note that on Windows, you may also want to download GitBash so you have a Unix-like shell environment available.\n+\n+To make sure the installation worked, run the `git --version` command again in the terminal.\n+\n+Once you have Git installed, you will need to make a few changes to the configuration. You should only need to make these changes once on your computer and you won't need to continually make changes when you make upgrades.\n+\n+`git config` is used to set configuration variables that are responsible for how Git operates on your machine. To view your current setting variables and where they are stored on your system, you can run the following command:\n+\n+```sh\n+git config --list --show-origin\n+```\n+\n+Right now you should be seeing only system-level configuration settings if you just installed Git for the first time. If you have already installed Git prior to this lecture, then you might be seeing user configurations for a user name and email.\n+\n+To set your user name, you can run the following command:\n+\n+```sh\n+git config --global user.name \"Jane Doe\"\n+```\n+\n+The `--global` flag is used here to set the user name for all projects on your system that use Git. If you need to override the user name for a particular project, then you can run the command in that particular project directory without the `--global` flag.\n+\n+To set the user email address, you can run the following command:\n+\n+```sh\n+git config --global user.email janedoe@example.com\n+```\n+\n+Configuring your user name and email is important because Git will use this information for every commit you make in a project. You will learn more about commits in a future lecture.\n+\n+Another configuration you can set is the preferred editor you want Git to use. Here is an example of how to set your preferred editor to Emacs:\n+\n+```sh\n+git config --global core.editor emacs\n+```\n+\n+Other options include Vim, Nano, VS Code, and more. For example, if you use VS Code for your editor, then you can configure Git settings like this:\n+\n+```sh\n+git config --global core.editor \"code --wait\"\n+```\n+\n+If you choose not to set a preferred editor, then Git will default to your system's default editor.\n+\n+If you are using a Windows machine and want to change your editor, you will need to provide the complete path to the executable file like this:\n+\n+```sh\n+git config --global core.editor \"'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin\"\n+```\n+\n+To see your list of configurations, you can run the following command:\n+\n+```sh\n+git config --list\n+```\n+\n+Now that you have Git installed and set up, you are now ready to start adding version control to your projects.\n+\n+# --questions--\n+\n+## --text--\n+\n+What does the following command do?\n+\n+```sh\n+git config --list --show-origin\n+```\n+\n+## --answers--\n+\n+Shows a list of only editors available to use with Git and where they are stored on your system.\n+\n+### --feedback--\n+\n+Refer back to the section discussing Git configuration for the answer.\n+\n+---\n+\n+Shows a list of only color options in your Git configuration.\n+\n+### --feedback--\n+\n+Refer back to the section discussing Git configuration for the answer.\n+\n+---\n+\n+Shows your current setting variables and where they are stored on your system.\n+\n+---\n+\n+Shows a list of all projects on your system that use Git.\n+\n+### --feedback--\n+\n+Refer back to the section discussing Git configuration for the answer.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+What is the purpose of using the `--global` flag when configuring your user name?\n+\n+## --answers--\n+\n+The `--global` flag is used to set the user name for some projects on your system that use Git.\n+\n+### --feedback--\n+\n+Think about how this flag can effect all projects that use Git.\n+\n+---\n+\n+The `--global` flag is used to set the user name for all projects on your system that use Git.\n+\n+---\n+\n+The `--global` flag is used to set the user name for none of the projects on your system that use Git.\n+\n+### --feedback--\n+\n+Think about how this flag can effect all projects that use Git.\n+\n+---\n+\n+The `--global` flag is used to set the user name for only projects on your system that are more than 5 years old and use Git.\n+\n+### --feedback--\n+\n+Think about how this flag can effect all projects that use Git.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+Which of the following is NOT a valid option mentioned for setting your preferred editor in Git?\n+\n+## --answers--\n+\n+Vim\n+\n+### --feedback--\n+\n+Refer to the end of the script where Git configurations and editors were set.\n+\n+---\n+\n+Emacs\n+\n+### --feedback--\n+\n+Refer to the end of the script where Git configurations and editors were set.\n+\n+---\n+\n+Nano\n+\n+### --feedback--\n+\n+Refer to the end of the script where Git configurations and editors were set.\n+\n+---\n+\n+ESLint\n+\n+## --video-solution--\n+\n+4"
        },
        {
            "sha": "d8254d70f8adeb964ee087cbfd0fa557fe072c07",
            "filename": "curriculum/challenges/english/blocks/lecture-introduction-to-git-and-github/6882904fd7063f7258c0aef3.md",
            "status": "added",
            "additions": 190,
            "deletions": 0,
            "changes": 190,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F6882904fd7063f7258c0aef3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F6882904fd7063f7258c0aef3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F6882904fd7063f7258c0aef3.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,190 @@\n+---\n+id: 6882904fd7063f7258c0aef3\n+title: How Do You Handle Security Requirements Like SSH and GPG Keys?\n+challengeType: 19\n+dashedName: how-do-you-handle-security-requirements-like-ssh-and-gpg-keys\n+---\n+\n+# --description--\n+\n+Before you can push your repository to GitHub, you will need to be authenticated. Both SSH and GPG keys use a public-private pair. This means that you keep a private key on your local machine, which you use to authenticate yourself. You share a public key with the people or services that need to validate your auth. In other words, the private key is required to perform an action, and the public key is used to verify the action.\n+\n+GPG, or Gnu Privacy Guard, keys are typically used to sign files or commits. Someone can then use your public GPG key to verify that the file signature is from your key and that the contents of the file have not been modified or tampered with. SSH, or Secure SHell, keys are typically used to authenticate a remote connection to a server - via the `ssh` utility. However, as you'll learn in this lecture, you can also use an SSH key to sign commits.\n+\n+To generate a GPG key, you'll need to run:\n+\n+```sh\n+gpg --full-generate-key\n+```\n+\n+For an SSH key, you'll run:\n+\n+```sh\n+ssh-keygen -t ed25519 -C \"your_email@example.com\"\n+```\n+\n+Make sure to provide your actual email.\n+\n+Both of these commands should request a passphrase to secure the key. These are optional, but strongly recommended.\n+\n+For SSH keys, you'll get two files - one for your private key, and one for your public. Public key filenames will end in `.pub`, so you do not accidentally share your private key. These files will be in `~/.ssh`.\n+\n+GPG keys, however, will be in a hidden and encrypted directory. Instead, to list your public keys, you'll run:\n+\n+```sh\n+gpg --list-secret-keys --keyid-format=long\n+```\n+\n+Then, to get the public key, use:\n+\n+```sh\n+gpg --armor --export \"<key id>\"\n+```\n+\n+But what can you do with these new keys? Well, we've talked about signing your commits, and that's something you can use either of these keys for.\n+\n+In order to sign your commits with your GPG key, you'll need to upload your public key, not the private key, to your GitHub account. Then, take the short ID you got from listing the keys earlier, and run this command to set it as your git signing key:\n+\n+```sh\n+git config --global user.signingkey <your_gpg_key_id>\n+```\n+\n+Then, you can pass the `-S` flag to your `git commit` command to sign a specific commit - you'll need to provide your passphrase. Alternatively, if you want to sign every commit automatically, you can set the autosign config to `true`:\n+\n+```sh\n+git config --global commit.gpgsign true\n+```\n+\n+To sign with an SSH key, which is a relatively new feature on GitHub, you'll need to start by uploading the key to your GitHub account. Then you'll need to set the signing mode for git to use SSH:\n+\n+```sh\n+git config --global gpg.format ssh\n+```\n+\n+Then, to set the signing key, you'll pass the file path instead of an ID:\n+\n+```sh\n+git config --global user.signingkey <path_to_your_ssh_keys>\n+```\n+\n+Finally, you can enable auto signing as you would for a GPG key.\n+\n+With either of these approaches set up, you're now set to have verified commits which will get a special badge on GitHub.\n+\n+# --questions--\n+\n+## --text--\n+\n+What is the fundamental difference between private and public keys in SSH and GPG key pairs?\n+\n+## --answers--\n+\n+The private key is longer than the public key.\n+\n+### --feedback--\n+\n+Think about who has access to each key and where they're stored.\n+\n+---\n+\n+The private key stays on your local machine while the public key is shared.\n+\n+---\n+\n+The public key is used to encrypt data while the private key decrypts it.\n+\n+### --feedback--\n+\n+Think about who has access to each key and where they're stored.\n+\n+---\n+\n+The private key expires after a certain time period.\n+\n+### --feedback--\n+\n+Think about who has access to each key and where they're stored.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+Which command would you use to enable automatic signing of all commits with your GPG key?\n+\n+## --answers--\n+\n+```sh\n+git config --global gpg.autosign true\n+```\n+\n+### --feedback--\n+\n+Look at the configuration command mentioned in the lecture for automatically signing all commits.\n+\n+---\n+\n+```sh\n+git config --global commit.sign always\n+```\n+\n+### --feedback--\n+\n+Look at the configuration command mentioned in the lecture for automatically signing all commits.\n+\n+---\n+\n+```sh\n+git config --global commit.gpgsign true\n+```\n+\n+---\n+\n+```sh\n+git --enable-auto-signing\n+```\n+\n+### --feedback--\n+\n+Look at the configuration command mentioned in the lecture for automatically signing all commits.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+What's required to set up SSH key signing for Git commits on GitHub?\n+\n+## --answers--\n+\n+Only upload your public SSH key to GitHub.\n+\n+### --feedback--\n+\n+Think about the configuration steps mentioned for SSH signing.\n+\n+---\n+\n+Set the signing format to SSH and configure your signing key path.\n+\n+---\n+\n+Generate a special SSH signing key separate from your regular SSH key.\n+\n+### --feedback--\n+\n+Think about the configuration steps mentioned for SSH signing.\n+\n+---\n+\n+Enable a special GitHub feature in your account settings.\n+\n+### --feedback--\n+\n+Think about the configuration steps mentioned for SSH signing.\n+\n+## --video-solution--\n+\n+2"
        },
        {
            "sha": "0811173cf12b92e25d3222c8b8921bc797949870",
            "filename": "curriculum/challenges/english/blocks/lecture-introduction-to-git-and-github/68829061f03543726ea6f318.md",
            "status": "added",
            "additions": 180,
            "deletions": 0,
            "changes": 180,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F68829061f03543726ea6f318.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F68829061f03543726ea6f318.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F68829061f03543726ea6f318.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,180 @@\n+---\n+id: 68829061f03543726ea6f318\n+title: What Is a Repository, and How Do You Create One?\n+challengeType: 19\n+dashedName: what-is-a-repository-and-how-do-you-create-one\n+---\n+\n+# --description--\n+\n+We've talked a bit about Git and GitHub, so now we can start to put it all together. In order to do this, you need a repository. But what is a repository? You can think of a repository as a container for a project - if you are working on an app, you would keep the files for that app together in a repository.\n+\n+Repositories can be local on your computer, or remote on a service like GitHub. To create a repository, you can start with either local or remote - the result will be the same, so take whatever approach fits your workflow best. For a workflow where you start with a remote repository, you can create one directly through GitHub's website by following these instructions:\n+\n+Visit <a href=\"https://github.com\" target=\"_blank\">GitHub's website</a>, make sure you are logged in, and then click the plus icon in the top right of the navigation bar. You'll see quite a few options, but the one you care about is \"New Repository\". Select that to open the UI for creating a new repository.\n+\n+The first option you'll see there is the ability to choose a template. You likely do not have one of these set up yet, but a template is a special kind of repository that you can use as a springboard for your new repositories. These are helpful for including documentation or issue templates in all of your projects.\n+\n+Your next option is to select on owner, you can choose your user account or any organizations you own or have access to. Then you can name the repository - in general, you'll want to use a name that succinctly describes the project you are building. As a general best practice, you want to avoid spaces in your repo name. GitHub will automatically replace them with hyphens.\n+\n+Next, you can optionally add a description which will appear on the repository's home page.\n+\n+You can also choose whether the repository will be public or private. A public repository can be viewed and downloaded by anyone. A private repository can only be accessed by you, and anyone you grant explicit access to.\n+\n+Finally, if you do not select a template, you will see options to generate files in the repository automatically. A README file will appear on the repository's homepage, and is a great way to provide documentation and descriptions of your project. A `.gitignore` file allows you to specify files that Git will \"ignore\" - this is great for things like package dependencies, environment files, and other things you don't want to be saved. GitHub will offer templates for this file, which exclude the common items for the specified language or runtime. And a license is a legal document which outlines who may use your software, and what they may do with it.\n+\n+When you have your settings all configured as you like, you can click the \"Create Repository\" button to finish the process. You'll automatically be redirected to the landing page for your new repository!\n+\n+From here, you can click the \"Code\" button to get options to clone your repository to your computer.\n+\n+You can ignore the \"Codespaces\" and \"Copilot\" tabs for this lecture. Instead, we are going to focus on the three options in the \"Local\" tab. The first two, HTTPS and SSH, are used in the same way. You use the `git clone` command with the URL provided in the box to clone the remote repository to your computer. The difference between these two is the connection and authentication methods.\n+\n+For cloning a public repository, you won't actually need to authenticate. But to clone a private repository, or to push to either public or private repositories, you will have to be authenticated. An HTTPS remote URL used to authenticate you via your GitHub username and password. However, due to security concerns this is no longer supported, and you are instead required to use a username and access token. Even then, it's a much less secure method than SSH, which uses your private and public keys. This has an added benefit of automatically signing you in, rather than having to provide a token every time. There will be a separate lecture diving deeper into SSH and how it works but you can also read through the GitHub documentation on how to setup SSH.\n+\n+To clone the repository, you can run this in the terminal:\n+\n+```sh\n+git clone git@github.com:your-username/your-repository-name\n+```\n+\n+It will create a folder on your computer with your repository name and contain all the files from your repository within it. From there you can `cd` (change directory) to your cloned repository with:\n+\n+```sh\n+cd name-of-cloned-repo\n+```\n+\n+Additionally, the local copy of your repo will have a remote pointing to the copy on GitHub. To check your remotes you can run the following command:\n+\n+```sh\n+git remote -v\n+```\n+\n+Another option for cloning your repository is to use the GitHub CLI. This tool is used to do GitHub-specific tasks without leaving the command line. If you do not have it installed, you can get instructions to do so from GitHub's documentation - but you should have it available in your system's package manager.\n+\n+To clone a repository with the CLI tool, I would use:\n+\n+```sh\n+gh repo clone your-username/your-repository-name\n+```\n+\n+The end result of these commands is the same: you'll have a copy of your repository locally.\n+\n+You can also use the GitHub CLI to create a repository:\n+\n+```sh\n+gh repo create\n+```\n+\n+If you don't pass any arguments, the CLI will give you an interactive wizard to set up your repository. This wizard will give you all of the same options as the web UI. With this tool, you will also get the option to clone the new repository immediately, so you won't have to go through the manual steps outlined earlier.\n+\n+You now have a basic understanding of how repositories work, and how you can create one to start properly versioning your work. In future lectures, you will learn how to push an existing local repository to GitHub and how to push changes to remote repositories.\n+\n+# --questions--\n+\n+## --text--\n+\n+What does a repository primarily function as in Git?\n+\n+## --answers--\n+\n+A tool for automatically formatting code.\n+\n+### --feedback--\n+\n+Think about the fundamental purpose of repositories in version control.\n+\n+---\n+\n+A container for a project and its files.\n+\n+---\n+\n+A backup system for your computer.\n+\n+### --feedback--\n+\n+Think about the fundamental purpose of repositories in version control.\n+\n+---\n+\n+A collaboration platform for team meetings.\n+\n+### --feedback--\n+\n+Think about the fundamental purpose of repositories in version control.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+When creating a repository on GitHub, which of the following is NOT an automatic file generation option?\n+\n+## --answers--\n+\n+A README file.\n+\n+### --feedback--\n+\n+Review the automatic file generation options mentioned in the lecture.\n+\n+---\n+\n+A `.gitignore` file.\n+\n+### --feedback--\n+\n+Review the automatic file generation options mentioned in the lecture.\n+\n+---\n+\n+A license file.\n+\n+### --feedback--\n+\n+Review the automatic file generation options mentioned in the lecture.\n+\n+---\n+\n+A `package.json` file.\n+\n+## --video-solution--\n+\n+4\n+\n+## --text--\n+\n+Which of the following Git commands is used to clone a remote repository to your local computer?\n+\n+## --answers--\n+\n+`git cloned`\n+\n+### --feedback--\n+\n+Review the last part of the lecture.\n+\n+---\n+\n+`git clones`\n+\n+### --feedback--\n+\n+Review the last part of the lecture.\n+\n+---\n+\n+`git clone`\n+\n+---\n+\n+`git cloning`\n+\n+### --feedback--\n+\n+Review the last part of the lecture.\n+\n+## --video-solution--\n+\n+3"
        },
        {
            "sha": "2f5eac6ecbe063b05462a4b9a27b2cbd5b93e96f",
            "filename": "curriculum/challenges/english/blocks/lecture-introduction-to-git-and-github/68829079ab2abe728a822cc1.md",
            "status": "added",
            "additions": 248,
            "deletions": 0,
            "changes": 248,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F68829079ab2abe728a822cc1.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F68829079ab2abe728a822cc1.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F68829079ab2abe728a822cc1.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,248 @@\n+---\n+id: 68829079ab2abe728a822cc1\n+title: How Do You Push a Local Repository to GitHub?\n+challengeType: 19\n+dashedName: how-do-you-push-a-local-repository-to-github\n+---\n+\n+# --description--\n+\n+In a previous lecture, you learned how to create a new repository on GitHub. But what if you had an existing project locally that you want to add to GitHub? In this lecture, you will learn how to push existing local repositories to GitHub and pull changes down from remote repositories.\n+\n+Start by creating a new repository on GitHub without any files. When done correctly, you should be redirected a page that includes the URL needed to clone your repository.\n+\n+Now navigate to your terminal and select an existing project you wish to add to GitHub. In this lecture, I am choosing a local project called `super-awesome-game` with the following files inside:\n+\n+```sh\n+jessicawilkins super-awesome-game >> ls\n+README.md  index.html script.js  styles.css\n+```\n+\n+To setup version control for this project using Git, you will need to run the `git init` command in the project directory. This will initialize an empty Git repository so Git can be begin tracking changes for this project. When done correctly you should see a similar output in the terminal:\n+\n+```sh\n+jessicawilkins super-awesome-game >> git init\n+Initialized empty Git repository in /Users/jessicawilkins/workspace/freeCodeCamp/super-awesome-game/.git/\n+```\n+\n+When you initialize an empty Git repository to a project, a new `.git` hidden directory will be added. To view the addition of the directory you can run the `ls -a` command which lists all files and directories, including hidden ones:\n+\n+```sh\n+jessicawilkins super-awesome-game >> ls -a\n+.          ..         .git       README.md  index.html script.js  styles.css\n+```\n+\n+It is important not to delete that `.git` directory, otherwise all of your Git history will be lost.\n+\n+Now that the empty Git repository has been initialized, you can run the `git status` command. This command is used to show the current state of your working directory - you will be using this command a lot in your workflow. You should see an output similar to this:\n+\n+```sh\n+jessicawilkins super-awesome-game >> git status\n+On branch main\n+\n+No commits yet\n+\n+Untracked files:\n+  (use \"git add <file>...\" to include in what will be committed)\n+\tREADME.md\n+\tindex.html\n+\tscript.js\n+\tstyles.css\n+\n+nothing added to commit but untracked files present (use \"git add\" to track)\n+```\n+\n+`On branch main` means that you are on the `main` branch. A branch in Git is a separate workspace where you can make changes. The `main` branch will often represent the primary or production branch in a real world application. Developer teams will create multiple branches for new features and bug fixes and then merge those changes back into the `main` branch. You will learn more about that process in a future lecture.\n+\n+`Untracked files` means that Git has detected files that it is currently not tracking.\n+\n+There are five states that a file can be in:\n+\n+1. \"Untracked\": This means that the file is new to the repository, and Git has not \"seen\" it before.\n+2. \"Modified\": This file existed in the previous commit, and has changes that have not been committed.\n+3. \"Ignored\": You likely won't see ignored files in Git, but your IDE might have an indicator for them. Ignored files are excluded from Git operations, typically because they are included in the `.gitignore` file.\n+4. \"Deleted\": A deleted file is the opposite of an untracked file - it's a file that previously existed, and has been removed.\n+5. \"Renamed\": A renamed file is a file where the contents are unchanged, but the name or location of the file was modified. In some cases, a file can be considered renamed even if it has a small amount of changes.\n+\n+When you have uncommitted changes in your repo, you will need to first \"stage\" them. A \"staging area\" is a special file in your `.git` directory that contains information that will go into your next commit. A commit is effectively a snapshot of the current state of your repository.\n+\n+If you want to stage one file at a time, then you can use the following command:\n+\n+```sh\n+git add name-of-file\n+```\n+\n+If you want to stage all unstaged changes, then you can use `git add .` The period (`.`) is an alias for the current directory you are in. Some developers will warn against using `git add .` because you might end up staging files that you didn't intend to. If that happens, you can \"unstage\" them using the following command:\n+\n+```sh\n+git reset name-of-file\n+```\n+\n+In general though, as long as you are monitoring which files are being added using `git status` before you stage them, then you should be fine.\n+\n+Once you stage your files, then you will need to commit them. You can commit your changes by running the `git commit` command. This will open up your preferred editor of choice you set in the Git configuration. Once the editor is open, you can provide a detailed message of your changes. You can also choose to provide a shorter message by using the `git commit -m` command like this:\n+\n+```sh\n+git commit -m \"short message goes here\"\n+```\n+\n+If you are going to use the `-m` flag, you will still want to provide a descriptive message to provide context for the changes. Here are some examples of good messages you might use:\n+\n+```sh\n+git commit -m \"feat(api): implement JWT-based authentication\"\n+git commit -m \"fix(auth): correct token expiration time\"\n+git commit -m \"refactor: simplify login flow logic\"\n+```\n+\n+The `feat(api)` and `fix(auth)` follows the Conventional Commits style which is used to provide context on the types of changes in that commit.\n+\n+After you have committed your work, and run `git status` again, you should see the following output in the terminal:\n+\n+```sh\n+On branch main\n+nothing to commit, working tree clean\n+```\n+\n+To view all of your prior commits for this project you can run the `git log` command. This will list all prior commits with helpful information like the author, date of commit, commit message and commit hash. The commit hash is a long string which serves as a unique identifier for a commit.\n+\n+Once you are done committing your work, you can now push your changes to GitHub. You will first need to setup the remote connection to your remote repo. You learned about this in the previous lecture, but here is a reminder using SSH:\n+\n+```sh\n+git remote add origin git@github.com:your-github-username/name-of-repo.git\n+```\n+\n+The last step is to push your changes to GitHub using this command:\n+\n+```sh\n+git push -u origin main\n+```\n+\n+The `-u` flag is shorthand for `--set-upstream`. It connects your local `main` branch to the remote `main` branch on `origin`. You only need to use it once per new branch. After that, you can simply run `git push` without specifying the branch name.\n+\n+When done correctly, you should see a similar result in the terminal:\n+\n+```sh\n+Enumerating objects: 3, done.\n+Counting objects: 100% (3/3), done.\n+Delta compression using up to 8 threads\n+Compressing objects: 100% (2/2), done.\n+Writing objects: 100% (3/3), 253 bytes | 253.00 KiB/s, done.\n+Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)\n+To https://github.com/jdwilkin4/super-awesome-game.git\n+ * [new branch]      main -> main\n+branch 'main' set up to track 'origin/main'.\n+```\n+\n+You should also see the new changes on your GitHub repo page when you refresh the page.\n+\n+If you are collaborating with others on a project and need to pull down new changes from the repository, you can use the `git pull` command. You will learn more about working on a team and collaboration in a future lecture.\n+\n+# --questions--\n+\n+## --text--\n+\n+What command would you use to initialize a Git repository in an existing local directory?\n+\n+## --answers--\n+\n+`git create`\n+\n+### --feedback--\n+\n+This is the basic command that transforms a regular directory into a Git repository.\n+\n+---\n+\n+`git start`\n+\n+### --feedback--\n+\n+This is the basic command that transforms a regular directory into a Git repository.\n+\n+---\n+\n+`git init`\n+\n+---\n+\n+`git repository --new`\n+\n+### --feedback--\n+\n+This is the basic command that transforms a regular directory into a Git repository.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+What does the `git commit -m` command do?\n+\n+## --answers--\n+\n+It commits your changes and shows a log of all commit messages you have written so far.\n+\n+### --feedback--\n+\n+Refer back to the section discussing commits.\n+\n+---\n+\n+It commits your changes and opens an editor for you to write an elaborate message.\n+\n+### --feedback--\n+\n+Refer back to the section discussing commits.\n+\n+---\n+\n+It commits your changes and omits the message your provides.\n+\n+### --feedback--\n+\n+Refer back to the section discussing commits.\n+\n+---\n+\n+It commits your changes with a short message you provide.\n+\n+## --video-solution--\n+\n+4\n+\n+## --text--\n+\n+Which of the following commands is used to push up changes to remote repository?\n+\n+## --answers--\n+\n+`git pushing`\n+\n+### --feedback--\n+\n+Review the last bit of the lecture.\n+\n+---\n+\n+`git pushed`\n+\n+### --feedback--\n+\n+Review the last bit of the lecture.\n+\n+---\n+\n+`git push`\n+\n+---\n+\n+`git pushes`\n+\n+### --feedback--\n+\n+Review the last bit of the lecture.\n+\n+## --video-solution--\n+\n+3"
        },
        {
            "sha": "76be0fa298f339d02adbdcf93909d04d74d77fea",
            "filename": "curriculum/challenges/english/blocks/lecture-introduction-to-git-and-github/688290b7f7f46f72d3d4e73d.md",
            "status": "added",
            "additions": 166,
            "deletions": 0,
            "changes": 166,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F688290b7f7f46f72d3d4e73d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F688290b7f7f46f72d3d4e73d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F688290b7f7f46f72d3d4e73d.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,166 @@\n+---\n+id: 688290b7f7f46f72d3d4e73d\n+title: How Do You Contribute to Other People's Repositories?\n+challengeType: 19\n+dashedName: how-do-you-contribute-to-other-peoples-repositories\n+---\n+\n+# --description--\n+\n+You've learned about creating commits and pushing them up to your own repository that you control. You can do the same for other projects that you do not maintain, but there are some extra steps.\n+\n+First and foremost, you generally won't have \"write access\" to someone else's project. This means you cannot push commits directly to them. Instead, you'll need to create a copy of the repository to work from. This process is called \"forking\".\n+\n+To fork a repository, visit the repository you want to contribute to on GitHub. At the top, you'll see a \"Fork\" button. Click this to be taken to the UI for creating your fork.\n+\n+You'll see a similar screen to the one where you created your own repository, but with fewer options. You can choose an owner, either your personal account or an organization you have access to, a new name for the fork, and a new description.\n+\n+You also have an option to copy only the `main` branch (or the default configured for the repository). This is generally a good idea, unless you need to contribute to a specific feature branch. You'll learn more about branches in a future lecture. For now, leave that box ticked.\n+\n+Click \"Create fork\" and your new repository will be created, and you'll automatically be taken to it.\n+\n+Next, clone it to your local computer just like you would do with your own repository, using SSH or the GitHub CLI.\n+\n+Now, let's take a look at the remotes your local clone has configured. Open a terminal in the local repository directory and run `git remote -v` to get a full list, it should look something like this:\n+\n+```sh\n+origin git@github.com:your-username/your-repo-name.git (fetch)\n+origin git@github.com:your-username/your-repo-name.git (pull)\n+```\n+\n+By cloning a repository from GitHub, Git has automatically configured your fork as the `origin` remote. However, when you're working from a fork, you will often need to update your copy to bring in the changes from the original repository.\n+\n+To do this, let's add the original repository as another remote. Return to the page where you forked the repository from, click the \"Code\" button, and grab the SSH URL. Then run the command to create a new upstream remote:\n+\n+```sh\n+git remote add upstream git@github.com:original-repo-username/repo-name.git\n+```\n+\n+`upstream` is the name of the remote - you can name it something else, but `upstream` tends to be the convention. If you look at your remotes again, you will see your new upstream remote:\n+\n+```sh\n+origin git@github.com:your-username/your-repo-name.git (fetch)\n+origin git@github.com:your-username/your-repo-name.git (pull)\n+upstream git@github.com:original-repo-username/your-repo-name.git (fetch)\n+upstream git@github.com:original-repo-username/your-repo-name.git (pull)\n+```\n+\n+With the `upstream` remote you'll be able to do things like `git fetch upstream` and `git merge upstream/main` to get the latest changes from the original project into your local fork.\n+\n+A fork is still a repository, and you create commits and push changes in the same way. However, before diving into that, you should understand that there are certain strategies that you should follow when making changes to someone else's project. You'll learn more about these strategies in upcoming lectures.\n+\n+Projects which make their source code available to the public, allow you to modify the code, and accept code contributions are called \"open source\" projects. There are a lot of benefits to open source, such as allowing the community to help you identify and fix bugs, learning from the contributions people make to your work, and fostering a community of developers that you can turn in to a network.\n+\n+When you make changes to someone's project, you are considered an \"open source contributor\". Contributing to open source projects can be an excellent preview of what working on a professional developer team is like. And some of the strategies here will help you do just that, and carry over into your first paid role.\n+\n+And if you ever have questions about how to contribute, most open source projects will have contributing guidelines that contain an overview of everything you need to know. But if you still aren't sure, it never hurts to open an issue on the repository to ask your questions - or, if they have a community space on a platform like Discord, join and ask your questions there.\n+\n+# --questions--\n+\n+## --text--\n+\n+Why do you need to fork a repository when contributing to someone else's project?\n+\n+## --answers--\n+\n+To make the code run faster.\n+\n+### --feedback--\n+\n+Think about the permissions model for repositories you don't own.\n+\n+---\n+\n+Because you generally don't have write access to someone else's repository.\n+\n+---\n+\n+To rename the repository.\n+\n+### --feedback--\n+\n+Think about the permissions model for repositories you don't own.\n+\n+---\n+\n+To completely replace the original repository.\n+\n+### --feedback--\n+\n+Think about the permissions model for repositories you don't own.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+After forking and cloning a repository, what command would you use to add the original repository as a remote?\n+\n+## --answers--\n+\n+`git add upstream [URL]`\n+\n+### --feedback--\n+\n+Consider which Git command is used to manage remote repositories.\n+\n+---\n+\n+`git clone upstream [URL]`\n+\n+### --feedback--\n+\n+Consider which Git command is used to manage remote repositories.\n+\n+---\n+\n+`git remote add upstream [URL]`\n+\n+---\n+\n+`git push upstream [URL]`\n+\n+### --feedback--\n+\n+Consider which Git command is used to manage remote repositories.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+What is the conventional name for the remote that points to the original repository you forked from?\n+\n+## --answers--\n+\n+`origin`\n+\n+### --feedback--\n+\n+Remember the term mentioned in the lecture that is typically used for this purpose.\n+\n+---\n+\n+`main`\n+\n+### --feedback--\n+\n+Remember the term mentioned in the lecture that is typically used for this purpose.\n+\n+---\n+\n+`source`\n+\n+### --feedback--\n+\n+Remember the term mentioned in the lecture that is typically used for this purpose.\n+\n+---\n+\n+`upstream`\n+\n+## --video-solution--\n+\n+4"
        },
        {
            "sha": "47e4c13b8984c3ba7aa4b5cb372f1297765fc717",
            "filename": "curriculum/challenges/english/blocks/lecture-introduction-to-git-and-github/688290c998562972e953d34d.md",
            "status": "added",
            "additions": 232,
            "deletions": 0,
            "changes": 232,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F688290c998562972e953d34d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F688290c998562972e953d34d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F688290c998562972e953d34d.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,232 @@\n+---\n+id: 688290c998562972e953d34d\n+title: How Do You Create a New Branch for Your Repository?\n+challengeType: 19\n+dashedName: how-do-you-create-a-new-branch-for-your-repository\n+---\n+\n+# --description--\n+\n+You've previously learned how to commit changes and push them up to your remote repository, but all of that has been on your default `main` branch. That can work for a smaller project, but as you contribute to other open source projects, or as your project grows, branches are essential.\n+\n+For example, if you fork a repository and make commits to the `main` branch of your fork, you may end up with changes in your fork that the original repository did not accept. This can make it incredibly difficult to update your branch with the changes from the fork that were accepted. Or, when working on your own project, switching between different tasks becomes much more difficult if you are not using branches. Instead, you have to manually keep track of which changes relate to which feature or fix.\n+\n+But what exactly is a branch? Consider your `main` branch as a highway, with each commit being a car that enters the highway. You may decide you want to go take a look at something, like creating a new feature, so you need to get off of the highway for a bit to go see.\n+\n+A branch is essentially a deviation from your main history, where you can freely play around with changes for a new feature or a bug fix. If you are happy with your changes, you can get back on the highway by merging the branch into `main`. If you aren't happy with your changes, you can delete the branch and switch back to `main` without accepting the changes.\n+\n+Before creating a new branch, you view your branches with the `git branch` command. The output might look like this:\n+\n+```sh\n+* main\n+```\n+\n+Right now we only have the one branch, our default `main` branch. The asterisk (`*`) means that is the branch that you currently have \"checked out\". You'll learn more about that in a bit.\n+\n+You can create a new branch with the `git branch` command, with an argument to specify the new branch's name:\n+\n+```sh\n+git branch feature\n+```\n+\n+This creates a new branch named `feature`. Let's take a look at our branches again with `git branch`:\n+\n+```sh\n+  feature\n+* main\n+```\n+\n+We can now see our new branch, but we are still on the `main` branch. We need to switch to our new branch by \"checking it out\". When you check out a new branch, you're telling Git to load the files in the exact state they were in at that point.\n+\n+Let's check out our new branch with:\n+\n+```sh\n+git checkout feature\n+```\n+\n+or\n+\n+```sh\n+git switch feature\n+```\n+\n+And run `git branch` again to see:\n+\n+```sh\n+* feature\n+  main\n+```\n+\n+Notice that the asterisk has now moved to the branch you currently have \"checked out\".\n+ \n+Often times when you create a new branch, you will want to check it out immediately. Instead of creating the branch and then checking it out using two commands, you can create and switch to a branch in one command with:\n+\n+```sh\n+git checkout -b feature\n+```\n+\n+or\n+\n+```sh\n+git switch -c feature\n+```\n+\n+So now we've created and checked out a new branch. This branch is a clone of the `main` branch, it has all the same code that `main` did at the time you created the branch. Now, we can add any code to this branch without affecting the `main` branch. We've essentially gotten off the highway to create a feature. If you check your `git status`, you would see something like this:\n+\n+```sh\n+On branch feature\n+nothing to commit, working tree clean\n+```\n+\n+Create a new `feature.md` file by running this:\n+\n+```sh\n+echo \"This is our new feature\" > feature.md\n+```\n+\n+And now the status will look like this:\n+\n+```sh\n+On branch feature\n+Untracked files:\n+  (use \"git add <file>...\" to include in what will be committed)\n+\tfeature.md\n+\n+nothing added to commit but untracked files present (use \"git add\" to track)\n+```\n+\n+Next, it's time to commit your new feature. First, add the file to staging:\n+\n+```sh\n+git add feature.md\n+```\n+\n+Then, commit the changes:\n+\n+```sh\n+git commit -m \"my new feature\"\n+```\n+\n+Finally, push your `feature` branch to your repository:\n+\n+```sh\n+git push -u origin feature\n+```\n+\n+The `-u` flag connects your local `feature` branch to the remote one, so future pushes can be done with just `git push`.\n+\n+Next, we will learn how to make a pull request for our new feature!\n+\n+# --questions--\n+\n+## --text--\n+\n+What does creating a new branch in Git allow you to do?\n+\n+## --answers--\n+\n+Permanently delete the `main` branch.\n+\n+### --feedback--\n+\n+You don't want to delete your `main` branch.\n+\n+---\n+\n+Make changes without affecting the `main` branch.\n+\n+---\n+\n+Share your code directly with GitHub users.\n+\n+### --feedback--\n+\n+Sharing code involves pushing branches and possibly making pull requests.\n+\n+---\n+\n+Change the Git version on your local machine.\n+\n+### --feedback--\n+\n+Branches don't change the Git software version.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+What does the `*` symbol next to a branch name in `git branch` output indicate?\n+\n+## --answers--\n+\n+The branch is about to be deleted.\n+\n+### --feedback--\n+\n+The asterisk indicates that the branch is \"checked out\".\n+\n+---\n+\n+The branch is the oldest one in the repo.\n+\n+### --feedback--\n+\n+The asterisk indicates that the branch is \"checked out\".\n+\n+---\n+\n+The branch is being pushed to GitHub.\n+\n+### --feedback--\n+\n+The asterisk indicates that the branch is \"checked out\".\n+\n+---\n+\n+The branch is currently \"checked out\".\n+\n+## --video-solution--\n+\n+4\n+\n+## --text--\n+\n+What does the following command do?\n+\n+```sh\n+git push -u origin feature\n+```\n+\n+## --answers--\n+\n+Deletes the `feature` branch from the remote repository.\n+\n+### --feedback--\n+\n+This command doesn't remove anything.\n+\n+---\n+\n+Pushes the `feature` branch and sets it to track the remote branch.\n+\n+---\n+\n+Merges the feature branch into `main`.\n+\n+### --feedback--\n+\n+Merging is a separate action not done with this command.\n+\n+---\n+\n+Pushes all branches to the remote repository.\n+\n+### --feedback--\n+\n+This command pushes only one specific branch.\n+\n+## --video-solution--\n+\n+2"
        },
        {
            "sha": "aa791f4bd0e668aba725a1e3f7d46a8819543aa4",
            "filename": "curriculum/challenges/english/blocks/lecture-introduction-to-git-and-github/688290da3736c273009129d0.md",
            "status": "added",
            "additions": 178,
            "deletions": 0,
            "changes": 178,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F688290da3736c273009129d0.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F688290da3736c273009129d0.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-introduction-to-git-and-github%2F688290da3736c273009129d0.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,178 @@\n+---\n+id: 688290da3736c273009129d0\n+title: What Is a Pull Request, and How Do You Create One?\n+challengeType: 19\n+dashedName: what-is-a-pull-request-and-how-do-you-create-one\n+---\n+\n+# --description--\n+\n+In the previous lecture, we created a feature branch, committed a new file to that branch, and pushed it up to our remote repository. But what are our next steps? We need to create a pull request on GitHub.\n+\n+A pull request is, effectively, a request to pull changes in from your branch into the target branch. Pull requests are the flow you use when you want to contribute code changes to an open source project. This approach allows the maintainers of the project to review your changes. They can leave comments, ask questions, suggest tweaks, and (hopefully) approve your changes and merge them in!\n+\n+Let's head over to our repository on GitHub again.\n+\n+Now, after you pushed your new branch, you should see a fancy banner that says you've pushed to a branch, and a button you can click to create a pull request. This button skips a couple of steps and streamlines the process, so we're going to ignore it for now. That way you are prepared for cases where the banner does not appear.\n+\n+Click on the pull requests tab at the top the repository page, then ignore the banner again and click \"New Pull Request\". You'll be taken to a UI to prepare your request.\n+\n+Now, there are some terms we need to go over here. First, we have the \"base\" and \"compare\" drop downs. The \"base\" is your target for the merge. Since we want to merge into `main`, we can leave this alone.\n+\n+The \"compare\" is what you want to merge. We want to merge our `feature` branch, so we should change this to `feature`. This is also known as the head branch, which is a term you will want to remember.\n+\n+Once you do this, the UI will refresh. It should now show the commits on `feature` that are not on `main`, indicating what you are requesting to merge in. You'll also see what's called a \"diff\", which is a visual representation of the actual changes you've made.\n+\n+Because all we've done is add a file, the diff is pretty clean. For more complex changes, GitHub will highlight things like line modifications, additions, deletions, and more. Understanding how to read a diff can be challenging, but with some practice you will become quite proficient at it.\n+\n+For now, let's go back to our pull request. There is a small link at the top that reads \"compare across forks\". If we were working from our fork of the freeCodeCamp repository, this would give us the ability to change our PR to target the original freeCodeCamp repo, instead of just the `main` branch within our fork.\n+\n+Since we are not working with a fork, we can ignore this. However, it is very important to understand that what we are doing here is primarily for learning and exploration. You shouldn't open a PR to someone's project that just contains practice changes - this creates extra noise for the maintainers.\n+\n+Now, since we are happy with our changes and everything is configured, we can click the \"Create Pull Request\" button. This takes us to a new UI.\n+\n+Toward the bottom and out of view are the same commit list and diff view we saw earlier. It never hurts to double check one last time before creating your PR, but for this exploration you are good to move forward.\n+\n+You'll also see a couple of new inputs. The first input is the title for your pull request. GitHub will automatically generate this based on the commit you are merging, if there is only one in the PR, or the branch name, if you have multiple commits.\n+\n+The second input is for your description. In most cases, this will not be empty. Instead, maintainers of a project can define a template which gets pre-populated. If they provide one, you should respect their workflow and complete the template.\n+\n+In both cases, you'll want to read the contributing documentation for the project to ensure you understand and follow their guidelines for how to title and fill out your PR.\n+\n+Since you own this repository, you'll see on the right that you can set reviewers, assigness, labels, projects, and milestones. You won't be able to edit these, except to request a review, when you contribute to someone else's project. But if you'd like to explore those features, you can set them however you like now since this is your repository.\n+\n+Once everything is filled out and configured, click \"Create pull request\". Finally, you'll see the actual result!\n+\n+When you make a pull request to someone else's project, it needs to go through a \"code review\". This is a process where the maintainers can evaluate your pull request, request changes, ask questions, and so on. Once the maintainers have approved it, they can merge it.\n+\n+Since this is your own project, you don't need to wait for a review. Instead, you can double check the commit history under the Commits tab, the changes under the Files changed, and if you are satisfied you can merge it.\n+\n+After it's merged, you will want to pull these changes to your local repo.\n+\n+Head back to your terminal, and make sure you are still in the repo's folder. Then switch to the `main` branch with `git checkout main`.\n+\n+Next, pull down the latest changes with `git pull`.\n+\n+Now, if you look at the commit history with `git log`, you will see your commit. But you will also see a `Merge pull request #1` message. What is that?\n+\n+Well, when you merge a pull request on GitHub there are three strategies you can use:\n+\n+The default is \"Merge\", which brings all of the commits from the head branch, then creates another commit to process and log the merge.\n+\n+Another option is \"Squash and Merge\", which takes ALL of the commits from the head branch, smashes them into a single commit, and merges that new commit directly into the base branch without creating a merge commit.\n+\n+Finally, there is \"Rebase and Merge\", which takes all of the commits, resets them to \"come after\" the latest commit on the base branch, then merges the head in without a merge commit. Rebasing is a complicated topic that you will learn about in depth later, so it's okay if you do not quite understand it today.\n+\n+Each open source project will choose whatever merge strategy works best. But because of these differences in behaviour, you should ALWAYS create a new branch to commit your contributions on. Never commit directly to the default `main` branch, or things will get messy when you need to bring the changes down from the original repo.\n+\n+With all of that, you have successfully created and merged your first pull request!\n+\n+# --questions--\n+\n+## --text--\n+\n+What is a pull request in GitHub?\n+\n+## --answers--\n+\n+A way to force push code to the `main` branch.\n+\n+### --feedback--\n+\n+Think about what you're asking project maintainers to do with your code changes.\n+\n+---\n+\n+A request to pull changes from one branch into another branch.\n+\n+---\n+\n+A way to directly edit files in the main repository.\n+\n+### --feedback--\n+\n+Think about what you're asking project maintainers to do with your code changes.\n+\n+---\n+\n+A tool for downloading repositories to your local machine.\n+\n+### --feedback--\n+\n+Think about what you're asking project maintainers to do with your code changes.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+In a pull request, what do the terms \"base\" and \"compare\" (or \"head\") refer to?\n+\n+## --answers--\n+\n+\"Base\" is the source branch; \"compare\" is the target branch.\n+\n+### --feedback--\n+\n+Consider which branch will receive changes and which branch contains the changes.\n+\n+---\n+\n+\"Base\" is the target branch; \"compare\" is the source branch.\n+\n+---\n+\n+\"Base\" is the fork; \"compare\" is the original repository.\n+\n+### --feedback--\n+\n+Consider which branch will receive changes and which branch contains the changes.\n+\n+---\n+\n+\"Base\" is the original repository; \"compare\" is the fork.\n+\n+### --feedback--\n+\n+Consider which branch will receive changes and which branch contains the changes.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+Which of the following is NOT a merge strategy mentioned when merging a pull request on GitHub?\n+\n+## --answers--\n+\n+Merge\n+\n+### --feedback--\n+\n+The lecture mentioned three specific strategies for handling commits during a merge.\n+\n+---\n+\n+Squash and Merge\n+\n+### --feedback--\n+\n+The lecture mentioned three specific strategies for handling commits during a merge.\n+\n+---\n+\n+Rebase and Merge\n+\n+### --feedback--\n+\n+The lecture mentioned three specific strategies for handling commits during a merge.\n+\n+---\n+\n+Fork and Merge\n+\n+## --video-solution--\n+\n+4"
        },
        {
            "sha": "41214fcecd5307d79be774fecf66f537c685ecc9",
            "filename": "curriculum/challenges/english/blocks/lecture-working-with-code-reviews-branching-deployment-and-ci-cd/688290ef85c79973321a23af.md",
            "status": "added",
            "additions": 158,
            "deletions": 0,
            "changes": 158,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F688290ef85c79973321a23af.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F688290ef85c79973321a23af.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F688290ef85c79973321a23af.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,158 @@\n+---\n+id: 688290ef85c79973321a23af\n+title: What Does a Typical Code Review Process Look Like for Projects?\n+challengeType: 19\n+dashedName: what-does-a-typical-code-review-process-look-like-for-projects\n+---\n+\n+# --description--\n+\n+In a previous lecture, you learned how to make a pull request to your own repository. You also learned how to merge that pull request. But you could only do that because the repository belongs to you - you have maintainer access to your own repositories, which means you have permission to merge pull requests.\n+\n+When you contribute to someone else's open source project, however, you typically won't have those permissions. Instead, you'll need to wait for the maintainers to go through the code review process and accept your contribution. They will then handle merging it.\n+\n+But what does the code review process look like?\n+\n+The process that maintainers take will vary from person to person, and there may be project-specific approaches. But in general, there are typically three steps to a code review.\n+\n+The first is to confirm that the CI, or continuous integrations, passes. You'll learn more about this in a future lecture, so for now you can think of them as checks to validate that the code meets style guidelines and passes a test suite.\n+\n+If the CI fails, maintainers will typically request that you update the pull request to address the failures. These failures should include some sort of report you can look at to see what went wrong, but maintainers may also provide you more specific guidance to resolve the issue.\n+\n+Once the checks pass, the maintainers will look at your actual code changes. They can analyze the diff view to see what you've modified, added, or deleted. They may ask questions about why you took specific approaches, so it's good to be deliberate and thoughtful when you are preparing conversations.\n+\n+They may also request you make additional modifications. We'll talk about what that looks like in a bit.\n+\n+The last step is usually to pull down your changes locally. The maintainers can then run the application with your modifications, test the functionality, and verify nothing is broken or behaving in unexpected ways.\n+\n+If everything looks good, a maintainer will approve your pull request - sometimes with a \"LGTM\" comment, which stands for \"looks good to me\". After your pull request has been approved, it should be merged whenever the maintainers are ready to pull the changes in. Some projects may require more than one approval - freeCodeCamp, for example, requires two.\n+\n+But what if something is not correct with your pull request? Maintainers can perform a review in which they request changes. These requests can come in a couple of forms.\n+\n+Sometimes, a maintainer may just leave a \"comment\" with their request, maybe indicating something you should change or update, but with more freedom of how you implement it.\n+\n+Or, maintainers may also leave an official \"request changes\" comment. Typically, a comment like this blocks the pull request from being merged. You'll need to make the desired changes, and then the same maintainer who requested the changes will need to re-review and request more changes or approve your work.\n+\n+When maintainers have specific changes in mind, they can actually propose changes through GitHub's UI. When they use a direct suggestion like this, GitHub will give you a button to commit the suggestion to your branch directly. However, if there are multiple suggestions like this, you'll want to switch to the files view.\n+\n+From this view, you can add all of the suggestions (one by one) into a \"batch\", and commit them all in one go. This is incredibly useful when there are many suggestions, as doing them individually would result in many commits. All of the CI checks would have to run on each and every commit, and this can slow down the process for accepting your PR.\n+\n+If the requested changes are significant, you will likely want to make the changes locally, commit them to the same branch that you used for the PR, and push them up. GitHub will automatically update your pull request to reflect the new commits.\n+\n+There are a couple of other notes that we want to cover.\n+\n+First, remember that maintainers are people too. Open source projects rarely generate enough revenue for maintainers to work on them full time, which means they have to keep a job. It is important to be patient with the review process - don't do things like ping maintainers repeatedly for a re-review, or try to rush them in their review process.\n+\n+Making contributions can be exciting! But don't rush through the process. Instead, take your time. Make sure to test your changes locally - run any test suites the project may have, run the development server and manually confirm that your changes work, etc. And always follow the contribution guidelines for the specific project you are working on.\n+\n+If you keep all of that in mind, and put your best effort forward, your contributions should go smoothly and your code review should be a solid approval!\n+\n+# --questions--\n+\n+## --text--\n+\n+What is typically the first step in a code review process?\n+\n+## --answers--\n+\n+Looking at the actual code changes.\n+\n+### --feedback--\n+\n+Think about what maintainers check before they even look at your code.\n+\n+---\n+\n+Confirming that CI (continuous integration) passes.\n+\n+---\n+\n+Pulling down the changes locally.\n+\n+### --feedback--\n+\n+Think about what maintainers check before they even look at your code.\n+\n+---\n+\n+Approving the pull request.\n+\n+### --feedback--\n+\n+Think about what maintainers check before they even look at your code.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+What does the acronym \"LGTM\" stand for in code reviews?\n+\n+## --answers--\n+\n+Let's Get This Merged.\n+\n+### --feedback--\n+\n+This is a common approval phrase mentioned in the lecture.\n+\n+---\n+\n+Long-term Goal To Maintain.\n+\n+### --feedback--\n+\n+This is a common approval phrase mentioned in the lecture.\n+\n+---\n+\n+Looks Good To Me.\n+\n+---\n+\n+Let's Go Through More.\n+\n+### --feedback--\n+\n+This is a common approval phrase mentioned in the lecture.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+When a maintainer proposes specific changes through GitHub's UI, what can you do to efficiently handle multiple suggestions?\n+\n+## --answers--\n+\n+You must implement each suggestion manually in your local environment.\n+\n+### --feedback--\n+\n+Think about the most efficient way to handle multiple suggestions without creating numerous commits.\n+\n+---\n+\n+You can add all suggestions to a \"batch\" and commit them together.\n+\n+---\n+\n+You need to create a new pull request for each suggestion.\n+\n+### --feedback--\n+\n+Think about the most efficient way to handle multiple suggestions without creating numerous commits.\n+\n+---\n+\n+You must accept each suggestion individually with separate commits.\n+\n+### --feedback--\n+\n+Think about the most efficient way to handle multiple suggestions without creating numerous commits.\n+\n+## --video-solution--\n+\n+2"
        },
        {
            "sha": "22f67b4abfaf550edc7ef5a00bd5509a72ee3590",
            "filename": "curriculum/challenges/english/blocks/lecture-working-with-code-reviews-branching-deployment-and-ci-cd/68829101d909657350cd80af.md",
            "status": "added",
            "additions": 158,
            "deletions": 0,
            "changes": 158,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F68829101d909657350cd80af.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F68829101d909657350cd80af.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F68829101d909657350cd80af.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,158 @@\n+---\n+id: 68829101d909657350cd80af\n+title: How Do You Use GitHub Pages to Deploy a Project?\n+challengeType: 19\n+dashedName: how-do-you-use-github-pages-to-deploy-a-project\n+---\n+\n+# --description--\n+\n+GitHub Pages is a really solid option for deploying static sites, or applications that do not require a back-end server to handle logic. That is, applications that run entirely client-side, or in the user's browser, can be fully deployed on this platform.\n+\n+Additionally, GitHub Pages are completely free for open source projects. There are plenty of good reasons to make your project open source, and Pages adds yet another.\n+\n+But how do you actually deploy to GitHub Pages? Well, that depends on how your application works.\n+\n+Let's start with a basic HTML page. Here's one you can add to your existing repo if you'd like:\n+\n+```html\n+<!DOCTYPE html>\n+<html>\n+  <head>\n+    <title>freeCodeCamp</title>\n+    <link rel=\"stylesheet\" href=\"./style.css\" />\n+  </head>\n+  <body>\n+    <h1>Welcome to freeCodeCamp's Lecture!</h1>\n+    <p>Let's have some fun learning about Git and GitHub!</p>\n+  </body>\n+</html>\n+```\n+\n+Now we need to visit our repository and click the \"Settings\" tab to go to the repository settings. Then we need to select \"Pages\" from the sidebar.\n+\n+There's only a few options initially, but that's going to change as we start configuring the settings. First, we need to tell GitHub what to deploy from.\n+\n+We'll want to leave this as \"Deploy from a branch\", because we aren't using a framework and have not configured any GitHub actions at all. You'll learn more about what those are in an upcoming lecture.\n+\n+Next, set the branch that we are deploying from to `main` to deploy what's on that.\n+\n+You'll then get a choice to deploy from your project's root folder or from a `docs` folder. This feature is used by projects like freeCodeCamp - we used to bundle documentation with our app, so we could deploy just the documentation onto GitHub pages via the `docs` folder. For now, leave it as the `/` (root) folder and hit the \"Save\" button next to this drop down to save your changes.\n+\n+One you've saved, you'll see a new input to configure a custom domain. If you have one already, and would like to use it, you can follow the link to the docs to do so. For this lecture, however, we are going to leave this blank.\n+\n+You can also see the domain that your new GitHub Pages site has been deployed to. Without a custom domain, this defaults to `<username>.github.io`, where `<username>` is the name of your account (or the organization's account if you are deploying from an org-owned repository). And repository will be served on a path matching the repository's name, `<username>.github.io/<repo-name>`, for instance. If you visit the URL, you will see your site!\n+\n+Now, when you push new changes to your `main` branch, GitHub Pages will automatically update our deployed site with the latest changes. This process can take a few minutes, depending on server load - and you may need to do a hard refresh to clear the cache.\n+\n+And with that, we have successfully deployed a basic web application to GitHub Pages. You can also include CSS and JavaScript files in your Pages deployment, so you can build beautiful and interactive sites. And once you learn a framework like React or Angular, you can even deploy those on GitHub Pages too!\n+\n+# --questions--\n+\n+## --text--\n+\n+What type of applications can be deployed on GitHub Pages?\n+\n+## --answers--\n+\n+Only documentation websites.\n+\n+### --feedback--\n+\n+Think about where the application logic runs - on a server or in the browser?\n+\n+---\n+\n+Applications that require server-side processing.\n+\n+### --feedback--\n+\n+Think about where the application logic runs - on a server or in the browser?\n+\n+---\n+\n+Static sites and client-side applications.\n+\n+---\n+\n+Database-driven applications.\n+\n+### --feedback--\n+\n+Think about where the application logic runs - on a server or in the browser?\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+If your GitHub username is `johndoe` and your repository is named `my-portfolio`, what URL would your GitHub Pages site be deployed to?\n+\n+## --answers--\n+\n+`johndoe.github.io`\n+\n+### --feedback--\n+\n+Remember that repositories not matching the `username.github.io` pattern are served on a path.\n+\n+---\n+\n+`my-portfolio.github.io`\n+\n+### --feedback--\n+\n+Remember that repositories not matching the `username.github.io` pattern are served on a path.\n+\n+---\n+\n+`github.io/johndoe/my-portfolio`\n+\n+### --feedback--\n+\n+Remember that repositories not matching the `username.github.io` pattern are served on a path.\n+\n+---\n+\n+`johndoe.github.io/my-portfolio`\n+\n+## --video-solution--\n+\n+4\n+\n+## --text--\n+\n+When configuring GitHub Pages deployment, which of the following options do you need to specify?\n+\n+## --answers--\n+\n+The programming language used.\n+\n+### --feedback--\n+\n+Consider what GitHub needs to know to find and serve your static files.\n+\n+---\n+\n+The branch to deploy from and the folder location.\n+\n+---\n+\n+The server specifications.\n+\n+### --feedback--\n+\n+Consider what GitHub needs to know to find and serve your static files.\n+\n+---\n+\n+The database connection string.\n+\n+### --feedback--\n+\n+Consider what GitHub needs to know to find and serve your static files.\n+\n+## --video-solution--\n+\n+2"
        },
        {
            "sha": "ca74eaa9c291baf75ec31c3ad7d97c821727d097",
            "filename": "curriculum/challenges/english/blocks/lecture-working-with-code-reviews-branching-deployment-and-ci-cd/68829116a80ecd73681261b1.md",
            "status": "added",
            "additions": 174,
            "deletions": 0,
            "changes": 174,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F68829116a80ecd73681261b1.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F68829116a80ecd73681261b1.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F68829116a80ecd73681261b1.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,174 @@\n+---\n+id: 68829116a80ecd73681261b1\n+title: What Are Good Practices for Remaining in Sync with Your Remote Counterparts?\n+challengeType: 19\n+dashedName: what-are-good-practices-for-remaining-in-sync-with-your-remote-counterparts\n+---\n+\n+# --description--\n+\n+We've talked a bit about using branches to work on isolated changes to avoid soiling your `main` branch. But what does that mean, and why is it important?\n+\n+If you commit changes directly to your `main` branch, and the upstream repository accepts other changes that are not yours, you will end up with something called a \"divergent history\". This means that the commits on your `main` branch are no longer aligned with the commits on the upstream `main` branch. And it makes syncing the upstream changes a nightmare.\n+\n+So, let's say you've been following good branching practices, and this isn't an issue. If you followed along with our previous lectures, you should have a fork of a repository that you've cloned locally, and you should have an upstream remote that points to the original repository.\n+\n+If you did not do this, here's a quick reminder. You'll want to fork a repository, clone your fork locally, and run this command:\n+\n+```sh\n+git remote add upstream <url>\n+```\n+\n+Replace `<url>` with the SSH URL for the original repository, NOT your fork.\n+\n+With a properly configured upstream, you can run the following series of commands to pull in the latest upstream changes:\n+\n+```sh\n+git checkout main\n+git fetch upstream\n+git merge upstream/main\n+```\n+\n+What do these do? Well, you've learned about `git checkout`, so the first command ensures that you are on your `main` branch locally.\n+\n+The second command, `git fetch upstream`, tells Git to go get the latest changes that are on your upstream remote (which is the original repo). However, unlike a pull, Git will not automatically update your branch. This is important, because your `main` branch locally is connected to the `main` branch on your fork - not the `main` branch on the original repo! Performing a git pull may result in unexpected behavior.\n+\n+The final command, `git merge upstream/main`, tells Git to merge the latest changes from the `main` branch in the upstream remote into your current branch - which is your local `main` branch, because that's what we checked out.\n+\n+But what if the merge fails? What if you've accidentally committed to `main`, and Git cannot merge the divergent histories? Well... assuming you have not made any pull requests from your `main` branch, you can do a hard reset to force Git to update your branch.\n+\n+```sh\n+git reset --hard upstream/main\n+```\n+\n+The `git reset` command allows you to reset the current state of a branch. Passing the `--hard` flag tells Git to force the local files to match the branch state. This ensures that you have a clean slate to work from. And passing `upstream/main` tells Git you want your current branch (which is `main`) to match the `main` branch of the upstream remote. Be cautious with this command - any time you forcibly update a Git history, weird and unfortunate things may happen.\n+\n+Once you've got your local `main` branch updated correctly, it's important to push that state up to your remote fork (which should be `origin`, if you have followed our lectures). To do this, you can run:\n+\n+```sh\n+git push\n+```\n+\n+This will push the current state up to your remote fork. But if you've had to do a hard reset to clean up the history, it's possible your remote fork also has a divergent history and the push will fail.\n+\n+You can rectify that by forcing the push:\n+\n+```sh\n+git push --force\n+```\n+\n+**Be careful with this command**. Doing a force push effectively rewrites your remote history, and if you've done something incorrectly then a forced push becomes a nightmare to untangle.\n+\n+Pushing the synced changes up to your remote fork is important because it helps you ensure that you can safely clone the fork with the latest changes if you've lost your existing local repository.\n+\n+And once you've got your `main` branch synced, you are free to create a new branch from that state to start working on another contribution - with the latest version of the original codebase!\n+\n+# --questions--\n+\n+## --text--\n+\n+What's the main reason you should avoid committing changes directly to your `main` branch when working with forked repositories?\n+\n+## --answers--\n+\n+It creates duplicate commits.\n+\n+### --feedback--\n+\n+Think about what happens when your branch and the original repository evolve separately.\n+\n+---\n+\n+It causes a \"divergent history\" making it difficult to sync with upstream.\n+\n+---\n+\n+Git doesn't allow commits to the main branch.\n+\n+### --feedback--\n+\n+Think about what happens when your branch and the original repository evolve separately.\n+\n+---\n+\n+It automatically deletes your local changes.\n+\n+### --feedback--\n+\n+Think about what happens when your branch and the original repository evolve separately.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+Which series of commands will correctly update your local `main` branch with changes from the original repository?\n+\n+## --answers--\n+\n+`git checkout main`; `git pull upstream`\n+\n+### --feedback--\n+\n+Consider the step-by-step process needed to get upstream changes without disrupting your fork.\n+\n+---\n+\n+`git pull upstream main`\n+\n+### --feedback--\n+\n+Consider the step-by-step process needed to get upstream changes without disrupting your fork.\n+\n+---\n+\n+`git checkout main`; `git fetch upstream`; `git merge upstream/main`\n+\n+---\n+\n+`git fetch upstream/main`; `git merge`\n+\n+### --feedback--\n+\n+Consider the step-by-step process needed to get upstream changes without disrupting your fork.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+If you've accidentally committed to your `main` branch and can't merge upstream changes, what command can you use to forcibly reset your `main` branch to match the upstream (assuming you haven't made any pull requests)?\n+\n+## --answers--\n+\n+`git checkout upstream/main`\n+\n+### --feedback--\n+\n+Which command completely resets your branch to match another branch's state?\n+\n+---\n+\n+`git reset --hard upstream/main`\n+\n+---\n+\n+`git rebase upstream/main`\n+\n+### --feedback--\n+\n+Which command completely resets your branch to match another branch's state?\n+\n+---\n+\n+`git clean upstream/main`\n+\n+### --feedback--\n+\n+Which command completely resets your branch to match another branch's state?\n+\n+## --video-solution--\n+\n+2"
        },
        {
            "sha": "bee9635e7a70d4cf38e49413ae3ba707e9a7ddc7",
            "filename": "curriculum/challenges/english/blocks/lecture-working-with-code-reviews-branching-deployment-and-ci-cd/6882913b2b58c2738eaaa2d1.md",
            "status": "added",
            "additions": 264,
            "deletions": 0,
            "changes": 264,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F6882913b2b58c2738eaaa2d1.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F6882913b2b58c2738eaaa2d1.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F6882913b2b58c2738eaaa2d1.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,264 @@\n+---\n+id: 6882913b2b58c2738eaaa2d1\n+title: What Is a .gitignore File, and What Are Some Items That Should Be Included Inside It?\n+challengeType: 19\n+dashedName: what-is-a-gitignore-file-and-what-are-some-items-that-should-be-included-inside-it\n+---\n+\n+# --description--\n+\n+We have briefly touched upon the `.gitignore` file in a previous lecture. But what exactly is this file, and what should you put in it?\n+\n+The `.gitignore` file is a special type of file related to Git operations. The name suggests that this file is used to tell Git to ignore things, and that's the common use case. But what it actually does is it tells Git to stop tracking a file. This distinction is important, and will be clarified later.\n+\n+What should you actually put in this file? Well, you should list things that you don't want committed.\n+\n+The first would be your secrets files. This may be something like a `.env` file, where you've stored your API keys for your application to consume. It may be a private GPG key file that your app needs to use for authentication. Anything that contains sensitive information you would not want leaked to the public should be ignored with `.gitignore`. Even if your repository is private, you should act as if it is public - treat it like anyone can see it, and take care not to commit secrets.\n+\n+Let's take a look at what our file might look like right now:\n+\n+```sh\n+# Secrets\n+.env\n+github.key\n+```\n+\n+We've told Git to ignore the `.env` file, where we are keeping our secrets. We've also told Git to ignore a `github.key` file, which contains a private GPG key.\n+\n+The next thing to consider are the packages, or dependencies, that your project uses. As an example, when you are working with a Node.js project, you probably install packages from npm. These packages go into a `node_modules` folder in your project, so your code can import and consume them.\n+\n+But the `node_modules` folder gets prohibitively massive, and you definitely don't want to commit all of those packages and track the changes each time you update one. Instead, you commit your `package.json` file, and the relevant lockfile (e.g. `package-lock.json`, `pnpm-lock.yaml`). These files tell npm what packages and versions to install, so a contributor can install the same dependencies you are using without having to commit them to the repository.\n+\n+Let's go ahead and add `node_modules` to our `.gitignore` file:\n+\n+```sh\n+# Secrets\n+.env\n+github.key\n+\n+# Packages\n+node_modules\n+```\n+\n+Now, let's touch on an important syntax thing for `.gitignore` files. When you add an entry like `node_modules`, Git will ignore anything that matches that pattern. This means it will ignore the `node_modules` directory in the root of your project, but would also ignore the `node_modules` in the `client` directory of your project.\n+\n+If you only want to ignore something at the root, you can prefix the line with a forward slash. `node_modules` would become `/node_modules`. This would ignore the root `node_modules` directory, but not the `client/node_modules` directory. We do not want that, so let's leave our entry as just `node_modules`.\n+\n+The next thing you want to consider ignoring are your build outputs. For example, compiling a TypeScript project might result in a `dist` folder for the JavaScript output. You don't want to commit that output, because it bloats the Git history. Instead, you want to ignore that output - contributors can reproduce it for themselves by running the same build command.\n+\n+Let's go ahead and ignore the `dist` folder:\n+\n+```sh\n+# Secrets\n+.env\n+github.key\n+\n+# Packages\n+node_modules\n+\n+# Outputs\n+dist\n+```\n+\n+Sometimes, a misplaced file can cause the TypeScript compiler to break, which results in our JavaScript output ending up all over the place. Since we are exclusively writing TypeScript, let's go ahead and use glob syntax to ignore all JavaScript files:\n+\n+```sh\n+# Secrets\n+.env\n+github.key\n+\n+# Packages\n+node_modules\n+\n+# Outputs\n+dist\n+*.js\n+```\n+\n+Some other common outputs you might ignore are the `coverage` directory, for the results of unit test coverage, an `.angular` directory if you are using Angular, a `.next` directory if you are using NextJS, and so on.\n+\n+For now, we can stick with what we have here. If you're using a framework that generates files, you should confirm in their documentation what you need to add to the `.gitignore`.\n+\n+The fourth batch of things to ignore are IDE files. Jetbrains products, for example, might use an `.idea` folder for IDE-specific configurations. Visual Studio Code uses a `.vscode` folder.\n+\n+These are often good to ignore, because they'll contain files specific to your local environment that other contributors won't need (because they use their own configurations). Let's go ahead and add the Visual Studio Code directory, since that is what we are using as our IDE.\n+\n+```sh\n+# Secrets\n+.env\n+github.key\n+\n+# Packages\n+node_modules\n+\n+# Outputs\n+dist\n+*.js\n+\n+# IDE\n+.vscode\n+```\n+\n+But our `.vscode` folder does contain a `settings.json` file, which includes some workspace-specific stuff that might be useful for our contributors - this file allows them to configure their extensions and environment to better mirror our own.\n+\n+So let's go ahead and use negation syntax to \"unignore\" that file:\n+\n+```sh\n+# Secrets\n+.env\n+github.key\n+\n+# Packages\n+node_modules\n+\n+# Outputs\n+dist\n+*.js\n+\n+# IDE\n+.vscode\n+!.vscode/settings.json\n+```\n+\n+If you are on MacOS, you may be familiar with the `.DS_STORE` file. This file contains metadata that Finder uses to determine things like how to render the directory (e.g. with thumbnails, or as a list). Similarly, Windows users might see a hidden `Thumbs.db` file, which caches thumbnails for the directory.\n+\n+It's generally a good idea to ignore these files, since they're a personal setting that have no impact on the project. Let's add both of them:\n+\n+```sh\n+# Secrets\n+.env\n+github.key\n+\n+# Packages\n+node_modules\n+\n+# Outputs\n+dist\n+*.js\n+\n+# IDE\n+.vscode\n+!.vscode/settings.json\n+\n+# System Files\n+.DS_STORE\n+Thumbs.db\n+```\n+\n+A quick note about ignoring previously committed files. Say you've accidentally committed your `dist` directory earlier, but now you want to remove it and ignore it. You cannot just add it to your `.gitignore` file - this does not make previously committed content disappear, it tells Git to stop tracking the file. So if you ignore a file that's already committed, Git won't track any changes but it also won't track the deletion of the file.\n+\n+Instead, you'll first need to delete the file. Create a commit with that deletion. Then you can add the item to your `.gitignore` and create a second commit with that update. Going forward, when that file is created again, Git will ignore it and it won't show up in your commits.\n+\n+Finally, if you're working on a project in a different language, such as Python, the items you need to ignore will be different than what we've covered here. GitHub maintains a very helpful repository of `.gitignore` templates for various languages and frameworks. You can find that list at <a href=\"https://github.com/github/gitignore\" target=\"_blank\">https://github.com/github/gitignore</a>.\n+\n+With that, you're now ready to avoid committing files you don't want in your repositories!\n+\n+# --questions--\n+\n+## --text--\n+\n+What is the primary purpose of a `.gitignore` file?\n+\n+## --answers--\n+\n+To delete files from your repository.\n+\n+### --feedback--\n+\n+Think about what the `.gitignore` file prevents from happening during Git operations.\n+\n+---\n+\n+To tell Git to stop tracking specific files.\n+\n+---\n+\n+To encrypt sensitive data in your repository.\n+\n+### --feedback--\n+\n+Think about what the `.gitignore` file prevents from happening during Git operations.\n+\n+---\n+\n+To compress large files before committing them.\n+\n+### --feedback--\n+\n+Think about what the `.gitignore` file prevents from happening during Git operations.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+If you've already committed a file to Git and later add it to `.gitignore`, what will happen?\n+\n+## --answers--\n+\n+The file will be automatically deleted from the repository.\n+\n+### --feedback--\n+\n+Consider what the lecture said about ignoring previously committed files.\n+\n+---\n+\n+The file will remain in the repository but future changes won't be tracked.\n+\n+---\n+\n+Git will throw an error until you resolve the conflict.\n+\n+### --feedback--\n+\n+Consider what the lecture said about ignoring previously committed files.\n+\n+---\n+\n+The file will be hidden but still tracked by Git.\n+\n+### --feedback--\n+\n+Consider what the lecture said about ignoring previously committed files.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+What syntax would you use in a `.gitignore` file to ignore all files in a directory, but then make an exception for one specific file?\n+\n+## --answers--\n+\n+Use glob wildcards (`*`) and then negate (`!`) the specific file.\n+\n+---\n+\n+Use comments (`#`) to manually specify exceptions.\n+\n+### --feedback--\n+\n+Remember the example with the `.vscode` directory and `settings.json` file.\n+\n+---\n+\n+Use a slash (`/`) to indicate directory structures.\n+\n+### --feedback--\n+\n+Remember the example with the `.vscode` directory and `settings.json` file.\n+\n+---\n+\n+Use brackets (`[]`) to create pattern exclusions.\n+\n+### --feedback--\n+\n+Remember the example with the `.vscode` directory and `settings.json` file.\n+\n+## --video-solution--\n+\n+1"
        },
        {
            "sha": "991ddb91d319f62f1985002c11d2610ee7dc689c",
            "filename": "curriculum/challenges/english/blocks/lecture-working-with-code-reviews-branching-deployment-and-ci-cd/6882915386c73273ac489f38.md",
            "status": "added",
            "additions": 148,
            "deletions": 0,
            "changes": 148,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F6882915386c73273ac489f38.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F6882915386c73273ac489f38.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F6882915386c73273ac489f38.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,148 @@\n+---\n+id: 6882915386c73273ac489f38\n+title: What Are Some Best Practices for Developing a Git Branching Strategy?\n+challengeType: 19\n+dashedName: what-are-some-best-practices-for-developing-a-git-branching-strategy\n+---\n+\n+# --description--\n+\n+We've talked a bit about branches in the previous lectures. You've learned how to create branches, why you shouldn't commit directly to `main`, and similar. But when and why should you actually create branches?\n+\n+First, let's talk about why you shouldn't just push a bunch of commits to `main`. Your default branch should be reliably stable - that is, at any given time I should be able to pull down your current `main` branch and build, run, and test your application. If you are pushing up partially completed features, or WIP commits, then this may not always be true.\n+\n+Additionally, it is very common to work on multiple features in tandem. If you're pushing partial work to `main` for multiple features simultaneously, it becomes much more challenging to debug a potential issue since you do not have isolated changes. On top of that, context switching (or changing which tasks you are working on) is nowhere near as clean.\n+\n+So when should you create a branch? A general rule of thumb is to create a branch for every isolated unit of work. That is, if you are working on a new OAuth feature, that work should be on a dedicated branch. If you then need to fix a bug in your password authentication, that work should be on its own dedicated branch. Need to redesign the user profile page? That's another branch.\n+\n+Note that you should always create your branches off of `main`. So, if you are working on a branch for your OAuth feature, you would checkout `main` before creating a new branch for your password authentication fix. Otherwise, if you create a branch for the password fix directly from your OAuth branch, you'll end up with the commits from your OAuth work and the history will be muddied.\n+\n+But how should you name your branches? Well, that's entirely up to you (or the project you are contributing to), but here are a few common conventions:\n+\n+`scope/description` - where `scope` is something like `feat` or `fix`, and `description` is a very short explanation of the branch's changes. For example: `feat/oauth-support`.\n+\n+`scope/issue/description` - similar to the previous convention, but including the number associated with the related issue. For example: `fix/25/password-auth`.\n+\n+`username/scope/description` - For projects where you all work off of branches in the original repository instead of forking it (this is common with private internal repositories), it can be helpful to include your username at the start of the branch. For example: `naomi-lgbt/feat/profile-redesign`.\n+\n+Let's cover a few other notes about branching strategies.\n+\n+For long-lived feature work, such as a beta feature that requires significant developer-hours, you may want to use a feature flag to selectively enable the logic rather than a branch. The longer a branch remains unmerged, the more likely you are to encounter conflicts.\n+\n+You may, however, wish to maintain dedicated branches for deployment environments or releases. For example, the freeCodeCamp repository uses `prod-staging` and `prod-current` to trigger deployments to staging and production servers, respectively. This can free up the team to iterate faster, merging as things are ready and approved without having to trigger a deployment for every merge. Instead, deployments are created by merging the latest `main` into those production branches.\n+\n+You may also want to maintain \"release branches\", or branches that represent a major version of your product. This allows you to have a clean state for each major release, so if you need to backport a critical security patch to an earlier release version you can do so without having to include any of the new version's changes.\n+\n+And finally, you should avoid merging your branches into `main` using the local CLI. Instead, create a pull request with your changes and merge through that flow. This gives you a chance to ensure any tests pass in your CI (which you will learn about in a future lecture), and to double check the diff view to make sure you have included only the changes you want merged.\n+\n+With these tips, you can start branching your way to success!\n+\n+# --questions--\n+\n+## --text--\n+\n+Why should you avoid committing directly to the `main` branch?\n+\n+## --answers--\n+\n+Because Git doesn't allow direct commits to `main`.\n+\n+### --feedback--\n+\n+Think about the stability and reliability requirements of the default branch.\n+\n+---\n+\n+Because the `main` branch should remain reliably stable at all times.\n+\n+---\n+\n+Because commits to `main` are permanently locked and can't be changed.\n+\n+### --feedback--\n+\n+Think about the stability and reliability requirements of the default branch.\n+\n+---\n+\n+Because `main` branches have slower performance than feature branches.\n+\n+### --feedback--\n+\n+Think about the stability and reliability requirements of the default branch.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+Which of the following is a best practice when creating a new branch?\n+\n+## --answers--\n+\n+Create new branches from your current feature branch.\n+\n+### --feedback--\n+\n+Think about keeping branch histories clean and avoiding unintended code inclusion.\n+\n+---\n+\n+Always create new branches from `main`.\n+\n+---\n+\n+Only create branches for major features.\n+\n+### --feedback--\n+\n+Think about keeping branch histories clean and avoiding unintended code inclusion.\n+\n+---\n+\n+Limit yourself to one branch per week.\n+\n+### --feedback--\n+\n+Think about keeping branch histories clean and avoiding unintended code inclusion.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+What is a recommended approach for handling long-lived feature work?\n+\n+## --answers--\n+\n+Create one massive branch that contains all related work.\n+\n+### --feedback--\n+\n+Consider the potential for merge conflicts with branches that remain unmerged for long periods.\n+\n+---\n+\n+Use feature flags rather than long-lived branches.\n+\n+---\n+\n+Always merge directly to `main` using the local CLI.\n+\n+### --feedback--\n+\n+Consider the potential for merge conflicts with branches that remain unmerged for long periods.\n+\n+---\n+\n+Create a new repository for each major feature.\n+\n+### --feedback--\n+\n+Consider the potential for merge conflicts with branches that remain unmerged for long periods.\n+\n+## --video-solution--\n+\n+2"
        },
        {
            "sha": "2ad81b779fd7968eceec235e915aa4467268964c",
            "filename": "curriculum/challenges/english/blocks/lecture-working-with-code-reviews-branching-deployment-and-ci-cd/68829162a7f96d73c8505d3d.md",
            "status": "added",
            "additions": 212,
            "deletions": 0,
            "changes": 212,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F68829162a7f96d73c8505d3d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F68829162a7f96d73c8505d3d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F68829162a7f96d73c8505d3d.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,212 @@\n+---\n+id: 68829162a7f96d73c8505d3d\n+title: What Are Merge Conflicts, and How Can You Resolve Them?\n+challengeType: 19\n+dashedName: what-are-merge-conflicts-and-how-can-you-resolve-them\n+---\n+\n+# --description--\n+\n+If you've been around experienced developers, whether in an online community or in person, you have probably heard about the \"dreaded merge conflicts\". But what exactly are they?\n+\n+Well, when you are using a proper branching strategy like we've discussed in previous lectures, you may be working on two different features on two different branches at the same time. Or maybe you're working on something, and a colleague is working on another branch. Either way, you have two independent changes going on. But sometimes, both of those branches will edit the same file. And if the other branch gets merged into `main` first, your branch's changes are now behind.\n+\n+Most of the time, this can be fixed by merging `main` back into your feature branch. But when the changes from the other branch conflict with your branch, Git cannot tell which changes you want to keep during a merge. This is called a \"merge conflict\".\n+\n+But how can you fix it? Well, for smaller and simpler conflicts, GitHub will give you a web UI to fix it. A \"Resolve conflicts\" button will show up at the bottom of a PR if there's conflicts. If you click it, you will see the file with conflicts that includes your code and the conflicting code. Git will add \"merge conflict markers\" around your code and the conflicting code to help identify the issue. It looks something like this:\n+\n+```sh\n+1 <<<<<<< feat/conflict\n+2 Here's some code from my first PR :)\n+3 =======\n+4 Here's some code that was merged to main that conflicts with the code on my PR\n+5 >>>>>>> main\n+```\n+\n+The opening marker is the `<<<<<<< feat/conflict`, and indicates the start of the changes that our current branch is making. Then we see the `Here's some code from my first PR :)`. After that is the `=======` marker, which indicates the end of our changes and the start of the `main` branch's changes. We can see that the changes made on `main` are the line `Here's some code that was merged to main that conflicts with the code on my PR`. And after that is the closing `>>>>>> main` marker to show the end of the conflicts.\n+\n+But how do we fix it? Well, you need to decide which changes you want to keep as part of the merge conflicts. If you want to keep both changes, you could remove just the conflict markers and leave the changes unchanged. Alternatively, if you want to keep the changes from only one branch, you would delete the conflict markers and the changes from the other branch (those that you do not wish to keep). And finally, if you don't like any of the changes at all, you can remove everything from the opening marker to the closing marker (inclusive).\n+\n+Let's remove the `main` branch changes, but keep ours. Here's what we have now:\n+\n+```sh\n+1 Here's some code from my first PR :)\n+```\n+\n+Click the \"Mark as resolved\" button, which tells GitHub you are satisfied with your resolution. If there were additional files, GitHub would switch to the next one. But since this is our only conflicted file, you'll see a \"Commit merge\" button appear. Click that button and GitHub will create a merge commit for you. You'll be taken back to the pull request, where you'll see your new merge commit and the conflicts resolved. And we're all set!\n+\n+But what if you can't edit the conflicts directly on GitHub, because they are too complex?\n+\n+Well, if your branch has few commits, or only a couple of commits modify that file, you may be able to merge `main` into your branch:\n+\n+```sh\n+git checkout feat/conflict\n+git fetch origin\n+git merge origin/main\n+```\n+\n+As Git processes this merge, you'll get conflicts to resolve manually. Git will notify you of which files need to be fixed. When we open the files with conflicts in our editor, we get the same conflict markers, with some helpful UI additions thanks to VSCode. Go ahead and fix the conflicts in the file in the same way. But this time, we'll need to manually create the commit. It's the same as creating any other commit:\n+\n+```sh\n+git add .\n+git commit -m \"chore: resolve conflicts\"\n+```\n+\n+After running these commands, we can see Git has accepted our resolution.\n+\n+Sometimes, when you have many commits or conflicts, a rebase can be helpful. Instead of merging changes, a rebase takes all the commits on your branch and reapplies them so they come after the latest changes on `main`. In Git terms, this effectively \"resets\" the base of your branch to the most recent commit on `main`.\n+\n+In order to experiment with this, we need a new branch:\n+\n+```sh\n+git checkout main\n+git pull\n+git checkout -b feat/rebase\n+```\n+\n+Let's go ahead and generate a bunch of commits for our branch, so we can practice rebasing:\n+\n+```sh\n+echo \"change one\" > README.md\n+git add .\n+git commit -m \"change one\"\n+echo \"change two\" > README.md\n+git add .\n+git commit -m \"change two\"\n+echo \"change three\" > README.md\n+git add .\n+git commit -m \"change three\"\n+```\n+\n+Now, let's go make another change on `main` to create a conflict:\n+\n+```sh\n+git checkout main\n+echo \"change four\" > README.md\n+git add .\n+git commit -m \"change four\"\n+```\n+\n+And checkout our rebase branch:\n+\n+```sh\n+git checkout feat/rebase\n+```\n+\n+Next, run `git rebase -i main`. It will rebase our branch onto the current state of the `main` branch. The `-i` flag tells Git to perform a rebase in interactive mode. You will see your commits with the word `pick` next to them. `pick` tells Git to use the commit as-is for the rebase. Save and close the file, and we'll get an error message telling us there is conflicts.\n+\n+Our `change one` commit conflicts with the `change four` commit, and we need to resolve that. Open the file in your editor, and you'll see the same UI as we got with the conflicts earlier. Let's keep our `change one` changes. Then, you'll need to run `git add .` to add the changes, and `git rebase --continue` to tell Git we're ready to continue rebasing. Since we've resolved the conflict in the first commit, Git can automatically handle rebasing the rest of the commits.\n+\n+Now, just as a last bit of cleanup, let's squash our three change commits into one single commit for a cleaner history. Run `git rebase -i main` again to get to the editor. Then, leave the first command as `pick` but change the next two to `squash`. You may run in to the same conflict again. If you do, resolve it the same way you did before. Once you've resolved and continued the rebase (or immediately, if you had no conflict), you'll see a new commit message editor pop up. This message will be your new commit, containing the changes from the three commits we've squashed. Let's name this one `change three complete`. Save and close the editor, and Git will finalize the rebase.\n+\n+If we check your commit history now, we can see that we now have our single `change three complete` commit, and it's correctly based on the `change four` commit. That means you've successfully completed a rebase with squashed commits! And now you've got the tools you need to become a merge conflict champion!\n+\n+# --questions--\n+\n+## --text--\n+\n+What are the merge conflict markers that Git adds to help identify conflicting changes?\n+\n+## --answers--\n+\n+`<<< current branch`, `=== separator`, `>>> other branch`\n+\n+### --feedback--\n+\n+Think about the specific syntax Git uses to mark the beginning, middle, and end of conflicts.\n+\n+---\n+\n+`[[ current branch`, `|| separator`, `]] other branch`\n+\n+### --feedback--\n+\n+Think about the specific syntax Git uses to mark the beginning, middle, and end of conflicts.\n+\n+---\n+\n+`<<<<<<< current branch`, `======= separator`, `>>>>>>> other branch`\n+\n+---\n+\n+`--- current branch`, `+++ separator`, `--- other branch`\n+\n+### --feedback--\n+\n+Think about the specific syntax Git uses to mark the beginning, middle, and end of conflicts.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+After manually resolving a merge conflict in your local repository, what commands do you need to run to complete the merge?\n+\n+## --answers--\n+\n+`git push origin main` and `git rebase -i origin/main`\n+\n+### --feedback--\n+\n+After fixing conflicts, you need to stage and commit the resolved changes just like any other commit.\n+\n+---\n+\n+`git add` and `git commit`\n+\n+---\n+\n+`git merge --abort` and `git commit`\n+\n+### --feedback--\n+\n+After fixing conflicts, you need to stage and commit the resolved changes just like any other commit.\n+\n+---\n+\n+`git reset --hard` and `git push -f`\n+\n+### --feedback--\n+\n+After fixing conflicts, you need to stage and commit the resolved changes just like any other commit.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+What is the main difference between merging and rebasing when dealing with branch conflicts?\n+\n+## --answers--\n+\n+Merging creates a new commit, while rebasing rewrites history to place your commits after the other branch's commits.\n+\n+---\n+\n+Rebasing is faster than merging.\n+\n+### --feedback--\n+\n+Consider how each operation affects the commit history.\n+\n+---\n+\n+Merging can only be done on GitHub, rebasing must be done locally.\n+\n+### --feedback--\n+\n+Consider how each operation affects the commit history.\n+\n+---\n+\n+There is no difference, they are the same operation.\n+\n+### --feedback--\n+\n+Consider how each operation affects the commit history.\n+\n+## --video-solution--\n+\n+1"
        },
        {
            "sha": "ba8c728cee2b8bb7bead1020ac4f31c191c88f7f",
            "filename": "curriculum/challenges/english/blocks/lecture-working-with-code-reviews-branching-deployment-and-ci-cd/688291b65db00473e1136725.md",
            "status": "added",
            "additions": 238,
            "deletions": 0,
            "changes": 238,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F688291b65db00473e1136725.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F688291b65db00473e1136725.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd%2F688291b65db00473e1136725.md?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,238 @@\n+---\n+id: 688291b65db00473e1136725\n+title: What Is CI/CD, and How Does CI Work with GitHub Actions?\n+challengeType: 19\n+dashedName: what-is-ci-cd-and-how-does-ci-work-with-github-actions\n+---\n+\n+# --description--\n+\n+CI stands for Continuous Integration, and CD stands for Continuous Delivery or Continuous Deployment. Together, these processes allow you to automatically deploy changes to your application after ensuring those changes are functional.\n+\n+In a CI pipeline, you might run your linter and tests against the code. CI pipelines typically run on pull requests to ensure the changes made aren't breaking the app, and also on the `main` branch to ensure it is ready to deploy.\n+\n+A CD pipeline might also run on pull requests, if you set up a preview environment so you can look at the changes live. But you'll also run it on your `main` branch to continuously deploy changes as they are accepted and merged.\n+\n+But how do these actually work with GitHub Actions? First, we need to understand what GitHub Actions actually are. GitHub Actions provides ephemeral runners (think like a temporary computer) that allows you to execute specific commands.\n+\n+Actions are configured with a YAML file. You can have multiple files to specify different actions to run. For example, you might have one file for your CI and another for your CD.\n+\n+Let's take a look at a basic CI example:\n+\n+```yml\n+name: Node.js CI\n+on:\n+  push:\n+    branches:\n+      - main\n+  pull_request:\n+    branches:\n+      - main\n+\n+jobs:\n+  lint:\n+    name: Lint and Test\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+      - name: Checkout Source Files\n+        uses: actions/checkout@v4\n+\n+      - name: Use Node.js v22\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: 22\n+\n+      - name: Setup pnpm\n+        uses: pnpm/action-setup@v2\n+        with:\n+          version: 10\n+\n+      - name: Install Dependencies\n+        run: pnpm install\n+\n+      - name: Lint Source Files\n+        run: pnpm run lint\n+\n+      - name: Verify Build\n+        run: pnpm run build\n+\n+      - name: Run Tests\n+        run: pnpm run test\n+```\n+\n+This is a lot, so let's break it down. Looking at the first section:\n+\n+```yml\n+name: Node.js CI\n+on:\n+  push:\n+    branches:\n+      - main\n+  pull_request:\n+    branches:\n+      - main\n+```\n+\n+The `name` defines the name of the action itself. This appears in areas like the status checks section of a PR. The `on` properties define what's called \"workflow triggers\" - these are the events that will trigger your action to run.\n+\n+In this example, we run the action when commits are pushed to `main`, and when a pull request targets `main`. This means the CI runs when someone makes a pull request, and again when we merge it.\n+\n+The `jobs` section is where you define what your action actually does. The `lint:` key is an arbitrary key that defines the internal name for that job. The `name` property defines the external name for this particular job. And the `runs-on` property defines what kind of environment your action should run in - for this case, we're running it in the latest supported version of Ubuntu.\n+\n+The `steps` property is where the magic happens. This block defines the actual steps your action should take. Let's take a look at the first block there:\n+\n+```yml\n+      - name: Checkout Source Files\n+        uses: actions/checkout@v4\n+```\n+\n+This step has two properties, the `name` the step should have, and a `uses` property. This `uses` property is special, in that it tells the action runner to go get a public action from GitHub and run it, instead of running a command. The `actions/checkout` action handles cloning and setting up the repository within your runner.\n+\n+```yml\n+      - name: Use Node.js v22\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: 22\n+\n+      - name: Setup pnpm\n+        uses: pnpm/action-setup@v2\n+        with:\n+          version: 10\n+```\n+\n+The next two blocks also use third-party actions. These steps set up Node and the pnpm package manager. Both of them have a `with` key, which you can use to pass arguments to those third party actions. Think of this as like passing arguments to a function.\n+\n+The final four blocks are where the magic really happens.\n+\n+```yml\n+      - name: Install Dependencies\n+        run: pnpm install\n+\n+      - name: Lint Source Files\n+        run: pnpm run lint\n+\n+      - name: Verify Build\n+        run: pnpm run build\n+\n+      - name: Run Tests\n+        run: pnpm run test\n+```\n+\n+We have an `Install Dependencies` block, which installs the npm packages. Our `Lint Source Files` block runs the linter, the `Verify Build` block ensures that the Typescript code can compile, and the `Run Tests` block runs the unit tests.\n+\n+The important thing to know about actions is, by default, if one of these steps fails the remaining ones will be skipped and the entire run will be marked as a failure.\n+\n+Where do you put your YAML files so you can run these actions? They need to go in a `.github/workflows` directory in your repository for GitHub to find and consume them.\n+\n+There are a lot of additional things actions can do, and I encourage you to read the documentation and explore existing actions in projects like the freeCodeCamp repository. But for now, you should have a decent understanding of the basics of GitHub Actions and CI/CD!\n+\n+# --questions--\n+\n+## --text--\n+\n+What does the on property define in a GitHub Actions workflow file?\n+\n+## --answers--\n+\n+The name of the action.\n+\n+### --feedback--\n+\n+Think about when you want your actions to automatically run.\n+\n+---\n+\n+The events that trigger the workflow to run.\n+\n+---\n+\n+The operating system to run on.\n+\n+### --feedback--\n+\n+Think about when you want your actions to automatically run.\n+\n+---\n+\n+The steps to execute.\n+\n+### --feedback--\n+\n+Think about when you want your actions to automatically run.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+Where should GitHub Actions workflow YAML files be placed in a repository?\n+\n+## --answers--\n+\n+In the root directory.\n+\n+### --feedback--\n+\n+GitHub looks for workflow files in a specific directory structure.\n+\n+---\n+\n+In a `.github/actions` directory.\n+\n+### --feedback--\n+\n+GitHub looks for workflow files in a specific directory structure.\n+\n+---\n+\n+In a `.github/workflows` directory.\n+\n+---\n+\n+In a `workflows` directory.\n+\n+### --feedback--\n+\n+GitHub looks for workflow files in a specific directory structure.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+What happens by default when a step fails in a GitHub Actions workflow?\n+\n+## --answers--\n+\n+The workflow continues with a warning.\n+\n+### --feedback--\n+\n+Consider how GitHub Actions handles errors in the workflow execution.\n+\n+---\n+\n+Only that specific step is marked as failed.\n+\n+### --feedback--\n+\n+Consider how GitHub Actions handles errors in the workflow execution.\n+\n+---\n+\n+The workflow restarts from the beginning.\n+\n+### --feedback--\n+\n+Consider how GitHub Actions handles errors in the workflow execution.\n+\n+---\n+\n+Remaining steps are skipped and the run is marked as a failure.\n+\n+## --video-solution--\n+\n+4"
        },
        {
            "sha": "a8097c3ce7b9ec83cd2199980ed4b2db95a8df37",
            "filename": "curriculum/structure/blocks/lecture-introduction-to-git-and-github.json",
            "status": "added",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fstructure%2Fblocks%2Flecture-introduction-to-git-and-github.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fstructure%2Fblocks%2Flecture-introduction-to-git-and-github.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fstructure%2Fblocks%2Flecture-introduction-to-git-and-github.json?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,46 @@\n+{\n+  \"name\": \"Introduction to Git and GitHub\",\n+  \"blockType\": \"lecture\",\n+  \"blockLayout\": \"challenge-list\",\n+  \"isUpcomingChange\": true,\n+  \"dashedName\": \"lecture-introduction-to-git-and-github\",\n+  \"helpCategory\": \"Backend Development\",\n+  \"challengeOrder\": [\n+    {\n+      \"id\": \"68828e965f70137025ec5031\",\n+      \"title\": \"What Is Version Control, and Why Are These Systems Necessary?\"\n+    },\n+    {\n+      \"id\": \"688290189fecfe7206d22833\",\n+      \"title\": \"What Is the Purpose of Sites Like GitHub and GitLab, and What Are Some Benefits of Using Them?\"\n+    },\n+    {\n+      \"id\": \"6882902bc844b1723da7eb13\",\n+      \"title\": \"How Do You Install and Set Up Git?\"\n+    },\n+    {\n+      \"id\": \"68829061f03543726ea6f318\",\n+      \"title\": \"What Is a Repository, and How Do You Create One?\"\n+    },\n+    {\n+      \"id\": \"6882904fd7063f7258c0aef3\",\n+      \"title\": \"How Do You Handle Security Requirements Like SSH and GPG Keys?\"\n+    },\n+    {\n+      \"id\": \"68829079ab2abe728a822cc1\",\n+      \"title\": \"How Do You Push a Local Repository to GitHub?\"\n+    },\n+    {\n+      \"id\": \"688290b7f7f46f72d3d4e73d\",\n+      \"title\": \"How Do You Contribute to Other People's Repositories?\"\n+    },\n+    {\n+      \"id\": \"688290c998562972e953d34d\",\n+      \"title\": \"How Do You Create a New Branch for Your Repository?\"\n+    },\n+    {\n+      \"id\": \"688290da3736c273009129d0\",\n+      \"title\": \"What Is a Pull Request, and How Do You Create One?\"\n+    }\n+  ]\n+}"
        },
        {
            "sha": "3ad16709470fd681ef8f89c2536ce589e35f3a76",
            "filename": "curriculum/structure/blocks/lecture-working-with-code-reviews-branching-deployment-and-ci-cd.json",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fstructure%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fstructure%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fstructure%2Fblocks%2Flecture-working-with-code-reviews-branching-deployment-and-ci-cd.json?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -0,0 +1,38 @@\n+{\n+  \"name\": \"Working With Code Reviews, Branching, Deployment, and CI/CD\",\n+  \"blockType\": \"lecture\",\n+  \"blockLayout\": \"challenge-list\",\n+  \"isUpcomingChange\": true,\n+  \"dashedName\": \"lecture-working-with-code-reviews-branching-deployment-and-ci-cd\",\n+  \"helpCategory\": \"Backend Development\",\n+  \"challengeOrder\": [\n+    {\n+      \"id\": \"688290ef85c79973321a23af\",\n+      \"title\": \"What Does a Typical Code Review Process Look Like for Projects?\"\n+    },\n+    {\n+      \"id\": \"68829101d909657350cd80af\",\n+      \"title\": \"How Do You Use GitHub Pages to Deploy a Project?\"\n+    },\n+    {\n+      \"id\": \"68829116a80ecd73681261b1\",\n+      \"title\": \"What Are Good Practices for Remaining in Sync with Your Remote Counterparts?\"\n+    },\n+    {\n+      \"id\": \"6882913b2b58c2738eaaa2d1\",\n+      \"title\": \"What Is a .gitignore File, and What Are Some Items That Should Be Included Inside It?\"\n+    },\n+    {\n+      \"id\": \"6882915386c73273ac489f38\",\n+      \"title\": \"What Are Some Best Practices for Developing a Git Branching Strategy?\"\n+    },\n+    {\n+      \"id\": \"68829162a7f96d73c8505d3d\",\n+      \"title\": \"What Are Merge Conflicts, and How Can You Resolve Them?\"\n+    },\n+    {\n+      \"id\": \"688291b65db00473e1136725\",\n+      \"title\": \"What Is CI/CD, and How Does CI Work with GitHub Actions?\"\n+    }\n+  ]\n+}"
        },
        {
            "sha": "154192a1ddc975bf8203c044b856ebf56293797a",
            "filename": "curriculum/structure/superblocks/full-stack-developer.json",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fstructure%2Fsuperblocks%2Ffull-stack-developer.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/df1c226cc608cbc69eb730b7a2a8fad186957f7f/curriculum%2Fstructure%2Fsuperblocks%2Ffull-stack-developer.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fstructure%2Fsuperblocks%2Ffull-stack-developer.json?ref=df1c226cc608cbc69eb730b7a2a8fad186957f7f",
            "patch": "@@ -820,6 +820,8 @@\n           \"blocks\": [\n             \"lecture-working-with-nano\",\n             \"workshop-castle\",\n+            \"lecture-introduction-to-git-and-github\",\n+            \"lecture-working-with-code-reviews-branching-deployment-and-ci-cd\",\n             \"workshop-sql-reference-object\",\n             \"lab-periodic-table-database\",\n             \"lab-number-guessing-game\","
        }
    ],
    "stats": {
        "total": 3127,
        "additions": 3126,
        "deletions": 1
    }
}