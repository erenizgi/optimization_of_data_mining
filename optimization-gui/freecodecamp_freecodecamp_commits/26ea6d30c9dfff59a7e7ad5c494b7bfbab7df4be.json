{
    "author": "gikf",
    "message": "fix(curriculum): replace flaky solution (#54616)",
    "sha": "26ea6d30c9dfff59a7e7ad5c494b7bfbab7df4be",
    "files": [
        {
            "sha": "acf6ed00556c06581917ac6b2456cf6fe43a24f7",
            "filename": "curriculum/challenges/english/18-project-euler/project-euler-problems-1-to-100/problem-84-monopoly-odds.md",
            "status": "modified",
            "additions": 124,
            "deletions": 76,
            "changes": 200,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/26ea6d30c9dfff59a7e7ad5c494b7bfbab7df4be/curriculum%2Fchallenges%2Fenglish%2F18-project-euler%2Fproject-euler-problems-1-to-100%2Fproblem-84-monopoly-odds.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/26ea6d30c9dfff59a7e7ad5c494b7bfbab7df4be/curriculum%2Fchallenges%2Fenglish%2F18-project-euler%2Fproject-euler-problems-1-to-100%2Fproblem-84-monopoly-odds.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F18-project-euler%2Fproject-euler-problems-1-to-100%2Fproblem-84-monopoly-odds.md?ref=26ea6d30c9dfff59a7e7ad5c494b7bfbab7df4be",
            "patch": "@@ -172,97 +172,145 @@ monopolyOdds(8);\n # --solutions--\n \n ```js\n-function monopolyOdds(n) {\n-  function chanceCard(position, chanceCardPosition) {\n-    chanceCardPosition = (chanceCardPosition + 1) % 16;\n-    if (chanceCardPosition < 6) {\n-      position = chanceCardsMoves[chanceCardPosition];\n-    } else if (chanceCardPosition === 6 || chanceCardPosition === 7) {\n-      position = nextMovesFromR[position];\n-    } else if (chanceCardPosition === 8) {\n-      position = nextMovesFromU[position];\n-    } else if (chanceCardPosition === 9) {\n-      position -= 3;\n+const GO = 0;\n+const JAIL = 10;\n+const GO_TO_JAIL = 30;\n+\n+const C1 = 11;\n+const E3 = 24;\n+const H2 = 39;\n+\n+const R1 = 5;\n+const R2 = 15;\n+const R3 = 25;\n+\n+const U1 = 12;\n+const U2 = 28;\n+\n+const SPECIAL_CARDS = 16;\n+const GAME_SQUARES = 40;\n+\n+const CC1 = 2;\n+const CC2 = 17;\n+const CC3 = 33;\n+const CHESTS = [CC1, CC2, CC3];\n+const chestCardsMoves = [GO, JAIL];\n+\n+const CH1 = 7;\n+const CH2 = 22;\n+const CH3 = 36;\n+const CHANCES = [CH1, CH2, CH3];\n+const chanceCardsMoves = [GO, JAIL, C1, E3, H2, R1];\n+const chanceToRailroad = { [CH1]: R2, [CH2]: R3, [CH3]: R1 };\n+const chanceToUtility = { [CH1]: U1, [CH2]: U2, [CH3]: U1 };\n+\n+function multiplyMatrix(matrix1, matrix2) {\n+  const multiplied = [];\n+\n+  for (let row = 0; row < matrix1.length; row++) {\n+    const newRow = [];\n+    for (let col = 0; col < matrix1[row].length; col++) {\n+      let newCell = 0;\n+      for (let i = 0; i < matrix1[row].length; i++) {\n+        const value1 = matrix1[row][i];\n+        const value2 = matrix2[i][col];\n+        newCell += value1 * value2;\n+      }\n+      newRow.push(newCell);\n     }\n-    return [position, chanceCardPosition];\n+    multiplied.push(newRow);\n   }\n+  return multiplied;\n+}\n \n-  function chestCard(position, chestPosition) {\n-    chestPosition = (chestPosition + 1) % 16;\n-    if (chestPosition < 2) {\n-      position = chestCardsMoves[chestPosition];\n+function normalizeRow(row) {\n+  const sum = row.reduce((total, value) => total + value, 0);\n+  if (sum > 0) {\n+    for (let j = 0; j < row.length; j++) {\n+      const value = row[j];\n+      row[j] = value / sum;\n     }\n-    return [position, chestPosition];\n-  }\n-\n-  function isChest(position) {\n-    return position === 2 || position === 17 || position === 33;\n   }\n+}\n \n-  function isChance(position) {\n-    return position === 7 || position === 22 || position === 36;\n-  }\n+function sortByProbability(board) {\n+  return board\n+    .map((probability, squareNo) => [squareNo, probability])\n+    .sort((a, b) => a[1] - b[1])\n+}\n \n-  function isJail(position) {\n-    return position === 30;\n-  }\n+function getTopThree(board) {\n+  return sortByProbability(board)\n+    .slice(-3)\n+    .reverse()\n+    .map(([squareNo, _]) => squareNo.toString().padStart(2, '0')\n+    )\n+    .join('');\n+}\n \n-  function roll(dice) {\n-    return Math.floor(Math.random() * dice) + 1;\n-  }\n+function didConverge(matrix1, matrix2, precision) {\n+  return matrix1.every((row, rowNo) => row.every((value1, colNo) => Math.abs(value1 - matrix2[rowNo][colNo]) <= precision))\n+}\n \n-  function getTopThree(board) {\n-    return sortByVisits(board)\n-      .slice(0, 3)\n-      .map(elem => elem[0].toString().padStart(2, '0'))\n-      .join('');\n-  }\n+function monopolyOdds(diceSides) {\n+  // Based on https://github.com/ByteThisCoding/project-euler/blob/master/problems/0084/0084.ts\n \n-  function sortByVisits(board) {\n-    return board\n-      .map((element, index) => [index, element])\n-      .sort((a, b) => a[1] - b[1])\n-      .reverse();\n+  const timesRolled = new Array(diceSides * 2 + 1).fill(0);\n+  for (let dice1 = 1; dice1 <= diceSides; dice1++) {\n+    for (let dice2 = 1; dice2 <= diceSides; dice2++) {\n+      timesRolled[dice1 + dice2]++;\n+    }\n   }\n \n-  const rounds = 2000000;\n-  const chestCardsMoves = [0, 10];\n-  const chanceCardsMoves = [0, 10, 11, 24, 39, 5];\n-  const nextMovesFromR = { 7: 15, 22: 25, 36: 5 };\n-  const nextMovesFromU = { 7: 12, 36: 12, 22: 28 };\n-\n-  const board = new Array(40).fill(0);\n-  let doubleCount = 0;\n-  let curPosition = 0;\n-  let curChestCard = 0;\n-  let curChanceCard = 0;\n-\n-  for (let i = 0; i < rounds; i++) {\n-    const dice1 = roll(n);\n-    const dice2 = roll(n);\n-\n-    if (dice1 === dice2) {\n-      doubleCount++;\n-    } else {\n-      doubleCount = 0;\n+  // Transitions matrix contain probabilities of reaching each square (row values)\n+  // from each starting square (row no.).\n+  let transitions = [];\n+  for (let startSquare = 0; startSquare < GAME_SQUARES; startSquare++) {\n+    const row = new Array(GAME_SQUARES).fill(0);\n+    for (let rollResult = 2; rollResult <= diceSides * 2; rollResult++) {\n+      const rollChance = timesRolled[rollResult]\n+      const position = (startSquare + rollResult) % GAME_SQUARES;\n+\n+      if (CHANCES.includes(position)) {\n+        // Chance cards ordering movement.\n+        for (let i = 0; i < chanceCardsMoves.length; i++) {\n+          const nextSquare = chanceCardsMoves[i];\n+          row[nextSquare] += rollChance / SPECIAL_CARDS;\n+        }\n+        row[chanceToRailroad[position]] += 2 * rollChance / SPECIAL_CARDS;\n+        row[chanceToUtility[position]] += rollChance / SPECIAL_CARDS;\n+        row[position - 3] += rollChance / SPECIAL_CARDS;\n+\n+        // Rest non-moving Chance cards.\n+        row[position] += (SPECIAL_CARDS - chanceCardsMoves.length) * rollChance / SPECIAL_CARDS;\n+      } else if (CHESTS.includes(position)) {\n+        // Community Chest cards ordering movement.\n+        for (let i = 0; i < chestCardsMoves.length; i++) {\n+          const nextSquare = chestCardsMoves[i];\n+          row[nextSquare] += rollChance / SPECIAL_CARDS;\n+        }\n+        // Rest non-moving Community Chest cards.\n+        row[position] += (SPECIAL_CARDS - chestCardsMoves.length) * rollChance / SPECIAL_CARDS\n+      } else if (position === GO_TO_JAIL) {\n+        row[JAIL] += rollChance;\n+      } else {\n+        row[position] += rollChance;\n+      }\n     }\n+    normalizeRow(row)\n+    transitions.push(row);\n+  }\n \n-    if (doubleCount > 2) {\n-      curPosition = 10;\n-      doubleCount = 0;\n-    } else {\n-      curPosition = (curPosition + dice1 + dice2) % 40;\n-\n-      if (isChance(curPosition)) {\n-        [curPosition, curChanceCard] = chanceCard(curPosition, curChanceCard);\n-      } else if (isChest(curPosition)) {\n-        [curPosition, curChestCard] = chestCard(curPosition, curChestCard);\n-      } else if (isJail(curPosition)) {\n-        curPosition = 10;\n-      }\n+  const precision = 0.000001;\n+  for (let i = 0; i < GAME_SQUARES; i++) {\n+    const next = multiplyMatrix(transitions, transitions);\n+    if (didConverge(transitions, next, precision)) {\n+      break;\n     }\n-    board[curPosition]++;\n+    transitions = next;\n   }\n-  return getTopThree(board);\n+\n+  // All rows converge to the same values.\n+  return getTopThree(transitions[0]);\n }\n ```"
        }
    ],
    "stats": {
        "total": 200,
        "additions": 124,
        "deletions": 76
    }
}