{
    "author": "camperbot",
    "message": "chore(i18n,learn): processed translations (#55169)",
    "sha": "9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
    "files": [
        {
            "sha": "abf4a3fbf33486dfa17f944cc8b14021a8a045e7",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65f569725359e10d345bc52a.md",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,75 @@\n+---\n+id: 65f569725359e10d345bc52a\n+title: Step 1\n+challengeType: 20\n+dashedName: step-1\n+---\n+\n+# --description--\n+\n+You are going to build a program that calculates and draws the trajectory of a projectile given the angle, speed and height of the throw.\n+\n+Start by importing `math`, you will use it a lot in this project as it has useful methods like `math.radians`, `math.cos`, `math.sin` and others.\n+\n+Also create these variables to have the value of the gravitational acceleration and some special symbols that will be useful later (use copy and paste for these).\n+\n+```py\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+```\n+\n+# --hints--\n+\n+Use `import math` to import the `math` module.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_import('import math')`))})\n+```\n+\n+You should have a `GRAVITATIONAL_ACCELERATION` variable with value of `9.81`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"GRAVITATIONAL_ACCELERATION\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"GRAVITATIONAL_ACCELERATION\").is_equivalent('GRAVITATIONAL_ACCELERATION = 9.81'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `PROJECTILE` variable with value of `\"∙\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"PROJECTILE\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"PROJECTILE\").is_equivalent('PROJECTILE = \"∙\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `x_axis_tick` variable with value of `\"T\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"x_axis_tick\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"x_axis_tick\").is_equivalent('x_axis_tick = \"T\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `y_axis_tick` variable with value of `\"⊣\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"y_axis_tick\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"y_axis_tick\").is_equivalent('y_axis_tick = \"⊣\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "db286166f195ed43a10e0605bfc4be0fc2f6c69c",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4b3bedee044b4b957d33.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,61 @@\n+---\n+id: 65fd4b3bedee044b4b957d33\n+title: Step 2\n+challengeType: 20\n+dashedName: step-2\n+---\n+\n+# --description--\n+\n+Create a `Projectile` class with an `__init__` method that initializes the class using three arguments: the starting speed, the starting height, and the starting angle of the throw of the projectile, in this order.\n+\n+Inside the `__init__` method, assign these arguments to three private attributes: `__speed`, `__height`, and `__angle`. The angle provided will be in degrees; however, it should be stored internally in radians. To achieve this, use the `math.radians()` function to convert the angle from degrees to radians when assigning it to `__angle`.\n+\n+The use of two underscores before an attribute name triggers name mangling in Python. This means the attributes are not directly accessible from outside the class using their given names, and must be accessed with the mangled names like `ball._Projectile__height` if needed externally, indicating these are intended for internal use only.\n+\n+# --hints--\n+\n+You should use `class Projectile:` to create the class.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_class(\"Projectile\")`))})\n+\n+```\n+\n+You should have an `__init__` method inside the `Projectile` class.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_body().has_function(\"__init__\")`))})\n+```\n+\n+A new `Projectile` class instance should have the values of the three attributes properly initialized.\n+\n+```js\n+({test: () => assert(runPython(`\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+p = Projectile(20, 21, 22)\n+p._Projectile__height == 21 and p._Projectile__speed == 20 and p._Projectile__angle == math.radians(22)\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "b9cd836b59b48f169c5d29a78dac81b1940b204c",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4bd84561a14d3e720061.md",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,48 @@\n+---\n+id: 65fd4bd84561a14d3e720061\n+title: Step 3\n+challengeType: 20\n+dashedName: step-3\n+---\n+\n+# --description--\n+\n+The class variable `__slots__` has a special usage in Python classes. Declaring `__slots__` and assigning it a sequence of strings restricts the creation of attributes to those included in that sequence. Also, it prevents the creation of the `__dict__` special attribute and it allows for more efficient attribute access.\n+\n+You should use the `__slots__` variable inside the class to define which attributes the class has: assign to `__slots__` a tuple containing 3 strings, each equal to one of the attribute names defined in the `__init__`.\n+\n+# --hints--\n+\n+You should assign to `__slots__` a tuple that contains `'__height'`, `'__speed'`, and `'__angle'`.\n+\n+```js\n+({test: () => assert(runPython(`\n+from itertools import permutations\n+slots = _Node(_code).find_class(\"Projectile\").find_body().find_variable(\"__slots__\")\n+perms = permutations((\"__height\", \"__speed\", \"__angle\"))\n+any(slots.is_equivalent(f'__slots__ = {perm}') for perm in perms)\n+`))})\n+\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+--fcc-editable-region--\n+class Projectile:\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "8c5270d99f59f323256adadc87929e55f6123f4c",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660400f02cf3a76795b82d4e.md",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,74 @@\n+---\n+id: 660400f02cf3a76795b82d4e\n+title: Step 4\n+challengeType: 20\n+dashedName: step-4\n+---\n+\n+# --description--\n+\n+The first thing to set up is a method that calculates the displacement of the projectile, which is the horizontal space traveled from the throw to when the projectile touches the ground.\n+\n+Create a method `__calculate_displacement`, which has only `self` as a parameter, and return the displacement of the projectile.\n+\n+Use the following formula to compute the projectile displacement: \\\\[ d = \\frac{v \\cdot \\cos\\theta \\cdot \\left(v\\cdot\\sin\\theta + \\sqrt{v^2\\sin^2\\theta + 2 \\cdot g \\cdot h}\\right)}{g} \\\\]\n+\n+In which $d$ is the displacement, $v$ is the starting speed, $\\theta$ is the angle and $h$ is the starting height of the projectile. For $g$ you can use the `GRAVITATIONAL_ACCELERATION` variable.\n+\n+You should use the methods `math.cos()` and `math.sin()` for the trigonometric functions and `math.sqrt()` to calculate the square root. Also you should know that $x^y$ is written as `x ** y` in python. Also $\\sin^2\\theta$ means that the value resulting from the sine is then squared.\n+\n+Remember that with name mangling you need to call the method as `_Projectile__calculate_displacement` if you want to test, or use it from outside of the class:\n+\n+```py\n+ball = Projectile(10, 3, 45)\n+displacement_of_ball = ball._Projectile__calculate_displacement() # 12.6173996009878\n+```\n+\n+# --hints--\n+\n+You should declare a function called `__calculate_displacement` with `def __calculate_displacement(self):`.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").has_function(\"__calculate_displacement\")`))})\n+```\n+\n+The `__calculate_displacement` method should have only the `self` argument.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_function(\"__calculate_displacement\").has_args('self')`))})\n+```\n+\n+The `__calculate_displacement` method should return the correct value.\n+\n+```js\n+({test: () => assert(runPython(`\n+p = Projectile(20, 21, 22)\n+disp = p._Projectile__calculate_displacement()\n+round(disp, 2) == 55.06 and round(disp, 2) != disp\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "eefd3dc7de816fb5abe2e8953fa8f6d6989ad361",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660fcf3e1b9bb056b2edb567.md",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,120 @@\n+---\n+id: 660fcf3e1b9bb056b2edb567\n+title: Step 5\n+challengeType: 20\n+dashedName: step-5\n+---\n+\n+# --description--\n+\n+At this point you are ready to create the string representation. Start by creating an instance of the `Projectile` class. Below the class definition, create a `ball` variable and assign it a call to `Projectile` using `10, 3, 45` as arguments.\n+\n+Define a `__str__` method within the class, to give your instance a proper string representation, and make it return a string with the following format:\n+\n+```py\n+\n+Projectile details:\n+speed: 10 m/s\n+height: 3 m\n+angle: 45°\n+displacement: 12.6 m\n+\n+```\n+\n+It should start and end with a new line character, the angle has to be written as an integer in degrees and the displacement should be printed with one decimal digit.\n+\n+You will find useful `math.degrees` to convert the angle from radians to degrees.\n+\n+When you are ready you can `print(ball)` to test your function.\n+\n+# --hints--\n+\n+You should have a `ball` variable.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_variable('ball')`))})\n+```\n+\n+The `ball` variable should have a value of `Projectile(10, 3, 45)`.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_variable('ball').is_equivalent('ball = Projectile(10, 3, 45)')`))})\n+```\n+\n+The string representation for `Projectile(45, 45, 45)` should be correct.\n+\n+```js\n+({test: () => assert(runPython(\n+`\n+ball = Projectile(45, 45, 45)\n+str(ball) == \"\"\"\n+Projectile details:\n+speed: 45 m/s\n+height: 45 m\n+angle: 45°\n+displacement: 244.4 m\n+\"\"\"`\n+))})\n+```\n+\n+The string representation should also be correct for other instances.\n+\n+```js\n+({test: () => assert(runPython(`p = Projectile(10, 10, 10)\n+str(\n+    p\n+) == \"\"\"\n+Projectile details:\n+speed: 10 m/s\n+height: 10 m\n+angle: 10°\n+displacement: 15.9 m\n+\"\"\"`))})\n+```\n+\n+You should have a `print(ball)` call.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    calls = _Node(_code).find_calls('print')\n+    assert any(c.is_equivalent('print(ball)') for c in calls)\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "ccfbf71ff43271f6871fdb3cf38d0f2c27675c7f",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6616ec0bf9ee8548ce6b0f08.md",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,109 @@\n+---\n+id: 6616ec0bf9ee8548ce6b0f08\n+title: Step 6\n+challengeType: 20\n+dashedName: step-6\n+---\n+\n+# --description--\n+\n+Now it's time to work on the function to calculate the coordinates of the trajectory! Create a method of the `Projectile` class named `__calculate_y_coordinate`, it should have, other than `self`, an `x` parameter.\n+\n+\\\\[ y = y_0 + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta} \\\\]\n+\n+The above is the formula to calculate the vertical position $y$ for any given horizontal position $x$, having the starting angle $\\theta$, speed $v_0$ and height $y_0$.\n+\n+You will need to use `math.tan()` and `math.cos()` and remember that `x ** y` is the way to write $x^y$, and that the value of $g$ is in the variable `GRAVITATIONAL_ACCELERATION`.\n+\n+Implement the method so that it returns the $y$ coordinate.\n+\n+If you want to test the method, from outside of class, you can call `ball._Projectile__calculate_y_coordinate()` with a number as an argument after `ball` is declared.\n+\n+# --hints--\n+\n+Your `Projectile` class should have a method named `__calculate_y_coordinate`.\n+\n+```js\n+({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').has_function('__calculate_y_coordinate')`))}})\n+```\n+\n+The `__calculate_y_coordinate` method should have `self, x` as arguments.\n+\n+```js\n+({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').find_function('__calculate_y_coordinate').has_args('self, x')`))}})\n+```\n+\n+The method should return the correct value. For `Projectile(12, 12, 12)`, given the 4 $x$ coordinates of 0, 1, 2 and 3, the y coordinate should be approximately 12, 12.18, 12.28, 12.32.\n+\n+```js\n+({test: () => {\n+    assert(runPython(`\n+    a = Projectile(12, 12, 12)\n+    all([round(a._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(0, 12.0), (1, 12.18), (2, 12.28), (3, 12.32)]])\n+    `))\n+}})\n+```\n+\n+The method should return the correct value. For `Projectile(45, 12, 22)`, given the $x$ coordinates of 6, 9, 10 and 12 the y coordinate should be approximately 14.32, 15.41, 15.76, 16.44.\n+\n+```js\n+({test: () => {\n+    assert(runPython(`\n+    b = Projectile(45, 12, 22)\n+    all([round(b._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(6, 14.32), (9, 15.41), (10, 15.76), (12, 16.44)]])\n+    `))\n+}})\n+```\n+\n+The `__calculate_y_coordinate` method should not round the result.\n+\n+```js\n+({test: () => assert.isFalse(runPython(`Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5) == round(Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5), 2)`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    --fcc-editable-region--\n+\n+    --fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+\n+```"
        },
        {
            "sha": "4cff93b9e8f559830239b74ee912725513ce046e",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662f9f65c50bd21d05ffdee9.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,110 @@\n+---\n+id: 662f9f65c50bd21d05ffdee9\n+title: Step 7\n+challengeType: 20\n+dashedName: step-7\n+---\n+\n+# --description--\n+\n+Define a method named `calculate_all_coordinates`, which calculates the coordinates for all \\\\(x\\\\) values from `0` up to the displacement rounded up (not inclusive), and then returns them as a list of tuples `(x, y)`.\n+\n+Then, call the `calculate_all_coordinates` method on the `ball` instance and assign the output to a new variable named `coordinates`.\n+\n+You can use `math.ceil()` to round up a number to the smallest integer greater than or equal to that number.\n+\n+# --hints--\n+\n+You should define a `calculate_all_coordinates` method with a single argument, `self` .\n+\n+```js\n+({test: () => assert(runPython(`\n+c = _Node(_code).find_class('Projectile')\n+c.has_function('calculate_all_coordinates') and c.find_function('calculate_all_coordinates').has_args('self')\n+`))})\n+```\n+\n+You should call the `calculate_all_coordinates` method on `ball` and assign the result to a variable named `coordinates`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+        assert _Node(_code).has_variable('coordinates'), \"coordinates variable is missing\"\n+\n+        assert _Node(_code).find_variable('coordinates').is_equivalent('coordinates = ball.calculate_all_coordinates()'), \"wrong value assigned to coordinates variable\"\n+    `)\n+})\n+```\n+\n+The `calculate_all_coordinates` method should return a list containing all the `(x, y)` coordinates.\n+\n+```js\n+({test: () => assert(runPython(`\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+ball = Projectile(12, 13, 14)\n+expected = [(x, ball._Projectile__calculate_y_coordinate(x)) for x in range(math.ceil(ball._Projectile__calculate_displacement()))]\n+actual = ball.calculate_all_coordinates()\n+expected == actual\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x**2 / (\n+                2 * self.__speed**2 * math.cos(self.__angle)**2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    --fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+   --fcc-editable-region--\n+```"
        },
        {
            "sha": "4bb9cd3ad62b572df845a78672e0b21c3e994443",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fa453ec8033322b3ab2e3.md",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,129 @@\n+---\n+id: 662fa453ec8033322b3ab2e3\n+title: Step 8\n+challengeType: 20\n+dashedName: step-8\n+---\n+\n+# --description--\n+\n+It's time to talk about encapsulation and getters. You have written the three instance attributes to be private using a leading double underscore. Note that these attributes are called private by convention: although they can still be accessed from outside, it is agreed upon to not do that.\n+\n+Getters are what can be used to get the values from outside. To define a getter, you define a method that returns the value of the desired attribute and give it a `@property` decorator:\n+\n+```py\n+class Nest:\n+    ...\n+    @property\n+    def number_of_eggs(self):\n+        return self.__number_of_eggs\n+```\n+\n+ The decorator changes the method into a property, meaning that the method is not called like a regular method, but it's used like an attribute:\n+\n+```py\n+n = Nest()\n+print(n.number_of_eggs)\n+```\n+\n+In the example above, the private attribute `__number of eggs` is accessed through the `number_of_eggs` property of `n`.\n+\n+Create a getter named `speed` and make it return the value of the private attribute `__speed`.\n+\n+# --hints--\n+\n+You should define a `speed` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('speed')\n+`))})\n+```\n+\n+Your `speed` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('speed').has_args('self')\n+`))})\n+```\n+\n+Your `speed` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('speed').has_decorators('property')\n+`))})\n+```\n+\n+Your `speed` method should return the value of the private attribute `__speed`.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.speed == 22\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "2b6b033fce5f1228ea15aa55035d277fee85077f",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fc35902038376c7a00b3c.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,186 @@\n+---\n+id: 662fc35902038376c7a00b3c\n+title: Step 10\n+challengeType: 20\n+dashedName: step-10\n+---\n+\n+# --description--\n+\n+Once you have the getters, you can write the setters, which allow you to set the value of an attribute in an indirect manner. Following the example of the last step, a setter would be written as:\n+\n+```py\n+class Nest:\n+    ...\n+    @number_of_eggs.setter\n+    def number_of_eggs(self, new_value):\n+        self.__number_of_eggs = new_value\n+```\n+\n+Same as the getter, a setter is not called like a method but used like an attribute:\n+\n+```py\n+nest = Nest()\n+nest.number_of_eggs = 12\n+```\n+\n+This way of writing calls the setter and set the new value.\n+\n+For this step you will have to write the setters for the three private attributes. Remember that for the angle the value is received in degrees but saved internally in radians.\n+\n+# --hints--\n+\n+You should define a new `speed` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('speed')) == 2\n+`))})\n+```\n+\n+Your new `speed` method should have a `@speed.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('speed')[1].has_decorators('speed.setter')\n+`))})\n+```\n+\n+Your new `speed` method should set the value of the private `__speed` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.speed = 33\n+a.speed == 33\n+`))})\n+```\n+\n+You should define a new `height` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('height')) == 2\n+`))})\n+```\n+\n+Your new `height` method should have a `@height.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('height')[1].has_decorators('height.setter')\n+`))})\n+```\n+\n+Your new `height` method should set the value of the private `__height` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.height = 44\n+a.height == 44\n+`))})\n+```\n+\n+You should define a new `angle` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('angle')) == 2\n+`))})\n+```\n+\n+Your new `angle` method should have a `@angle.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('angle')[1].has_decorators('angle.setter')\n+`))})\n+```\n+\n+Your `angle` method should set the value of the private `__angle` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.angle = 12\n+a.angle == 12\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "767c9c4f043405d60efeaf03dae28ab119f431dc",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66335223f3e2a31d62d84367.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,203 @@\n+---\n+id: 66335223f3e2a31d62d84367\n+title: Step 13\n+challengeType: 20\n+dashedName: step-13\n+---\n+\n+# --description--\n+\n+Going back to the projectile trajectory calculator, now you'll create a new class that accepts a list of coordinates and creates the trajectory drawing.\n+\n+Create a new class `Graph`, which should be instantiated with a private attribute `__coordinates` where the list of coordinates is stored. Declare the `__slots__` class variable and define the  `__init__` and `__repr__` special methods.\n+\n+Also, create a `Graph` instance passing the `coordinates` variable and assign it to a new `graph` variable.\n+\n+# --hints--\n+\n+You should create a new `Graph` class.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).has_class('Graph')`\n+    ))\n+})\n+```\n+\n+You should have the `__slots__` variable inside the class.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_variable('__slots__')`\n+    ))\n+})\n+```\n+\n+The `__slots__` variable should have a value of `('__coordinates')` or `['__coordinates']`.\n+\n+```js\n+({\n+    test: () => (runPython(\n+        `\n+        slots = _Node(_code).find_class('Graph').find_variable('__slots__')\n+\n+        assert any(slots.is_equivalent(str) for str in ['__slots__ = (\"__coordinates\")', '__slots__ = [\"__coordinates\"]'])`\n+    ))\n+})\n+```\n+\n+You should have an `__init__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('__init__')`\n+    ))\n+})\n+```\n+\n+The `__init__` method should instantiate the `__coordinates` private property with the passed in value.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+        l = [(3, 4), (4, 1), (3, 9)]\n+        g = Graph(l)\n+        g._Graph__coordinates == l\n+        `\n+    ))\n+})\n+```\n+\n+You should have a `__repr__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('__repr__')`\n+    ))\n+})\n+```\n+\n+The `__repr__` method should return the correct string.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+        ball = Projectile(10, 3, 45)\n+        coords = ball.calculate_all_coordinates()\n+        repr(Graph(coords)) == f'Graph({coords})'\n+        `\n+    ))\n+})\n+```\n+\n+You should create a `Graph` instance passing in the `coordinates` variable and assign it to `graph` variable.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+\n+        assert _Node(_code).has_variable('graph'), \"variable graph is missing\"\n+\n+        assert _Node(_code).find_variable('graph').is_equivalent('graph = Graph(coordinates)'), \"assignment to graph is wrong\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f\"{self.__class__.__name__}({self.speed}, {self.height}, {self.angle})\"\n+\n+--fcc-editable-region--\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+--fcc-editable-region-- \n+```"
        },
        {
            "sha": "afe4a4b500557bd25c1732e3b9e0168c51c544b0",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/663353465bfb14259717da93.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,186 @@\n+---\n+id: 663353465bfb14259717da93\n+title: Step 14\n+challengeType: 20\n+dashedName: step-14\n+---\n+\n+# --description--\n+\n+Create a method `create_coordinates_table`, then at the end of the code print `graph.create_coordinates_table())`.\n+\n+The method should use the `__coordinates` property and return a string containing all the coordinates, where x and y have always the same position, the values for x are always integers, and the values for y are always rounded to two decimal places:\n+\n+```py\n+  x      y\n+  0   3.00\n+  1   3.90\n+  2   4.61\n+  3   5.12\n+  4   5.43\n+  5   5.55\n+  6   5.47\n+  7   5.19\n+  8   4.72\n+  9   4.05\n+ 10   3.19\n+ 11   2.13\n+ 12   0.87  \n+```\n+\n+The table should start with a newline character and end with a newline character.\n+\n+# --hints--\n+\n+You should have a `create_coordinates_table()` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('create_coordinates_table')`\n+    ))\n+})\n+```\n+\n+The method should return the correct output.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `str = \"\"\"\n+  x      y\n+  0   3.00\n+  1   3.90\n+  2   4.61\n+  3   5.12\n+  4   5.43\n+  5   5.55\n+  6   5.47\n+  7   5.19\n+  8   4.72\n+  9   4.05\n+ 10   3.19\n+ 11   2.13\n+ 12   0.87\n+\"\"\"\n+ball = Projectile(10, 3, 45)\n+g = Graph(ball.calculate_all_coordinates())\n+g.create_coordinates_table() == str`\n+    ))\n+})\n+```\n+\n+You should print `graph.create_coordiantes_table()`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+        prints = _Node(_code).find_calls('print')\n+        assert any(p.is_equivalent('print(graph.create_coordinates_table())') for p in prints), \"print(graph.create_coordiantes_table()) is missing\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f'Graph({self.__coordinates})'\n+\n+--fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+graph = Graph(coordinates)\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "a86e8fab60b1753ae08a7c20d1251e34a4d1263a",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b26c4f2d603072ef0818.md",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,136 @@\n+---\n+id: 6633b26c4f2d603072ef0818\n+title: Step 12\n+challengeType: 20\n+dashedName: step-12\n+---\n+\n+# --description--\n+\n+It's good practice to give a representation to the class by using the `__repr__` special method. While the `__str__` method returns a readable string representation that's intended to be user friendly, `__repr__` is intended for programmers. Often `__repr__` provides a string that can be used to recreate the object.\n+\n+Write the `__repr__` method, which will return the string needed to instantiate the object.\n+\n+You can test this by calling the `repr` function and passing it an instance of the class.\n+\n+# --hints--\n+\n+The `Projectile` class should have a `__repr__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Projectile').has_function('__repr__')`\n+    ))\n+})\n+```\n+\n+The instance `Projectile(12, 12, 12)` should have representation equal to `'Projectile(12, 12, 12)'`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `repr(Projectile(12, 12, 12)) == 'Projectile(12, 12, 12)' or \\\\\n+        repr(Projectile(12, 12, 12)) == 'Projectile(12, 12, 12.0)'`\n+    ))\n+})\n+```\n+\n+The instance `Projectile(21, 22, 45)` should have representation equal to `'Projectile(21, 22, 45)'`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `repr(Projectile(21, 22, 45)) == 'Projectile(21, 22, 45)' or \\\\\n+        repr(Projectile(21, 22, 45)) == 'Projectile(21, 22, 45.0)'`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+```"
        },
        {
            "sha": "b0ba04423b9d0981453df5445f4ce8e61a4831e1",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b4d3271d5b3aea1c1195.md",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,173 @@\n+---\n+id: 6633b4d3271d5b3aea1c1195\n+title: Step 15\n+challengeType: 20\n+dashedName: step-15\n+---\n+\n+# --description--\n+\n+Now it's time for the graph. Create a method `create_trajectory` and replace the last `print` call at the bottom of your code with `print(graph.create_trajectory())`.\n+\n+As the first step of this new function, make a local copy of the coordinates but where all the values are rounded to integers. Save this new version of the coordinates in a variable named `rounded_coords`, and return this variable.\n+\n+# --hints--\n+\n+You should define a method named `create_trajectory`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('create_trajectory')`\n+    ))\n+})\n+```\n+\n+You should replace `print(graph.create_coordinates_table())` with `print(graph.create_trajectory())`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    prints = _Node(_code).find_calls('print')\n+\n+    assert all(not p.is_equivalent('print(graph.create_coordinates_table())') for p in prints), \"print(graph.create_coordinates_table()) should not be present\"\n+\n+    assert any(p.is_equivalent('print(graph.create_trajectory())') for p in prints), \"print(graph.create_trajectory()) not found\"\n+    `)\n+})\n+```\n+\n+The function should return `rounded_coords`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_class('Graph').find_function('create_trajectory').has_return('rounded_coords'), \"return rounded_coords missing\"\n+    `)\n+})\n+```\n+\n+The `rounded_coords` variable should contain the rounded coordinates.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert [(round(x), round(y)) for x,y in coordinates] == graph.create_trajectory(), \"coordinates are not rounded correctly\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_coordinates_table())\n+\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "af06d95e150d51f5cea0544a8cf49d51fef094b3",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bdc3ca38c068c3735984.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,203 @@\n+---\n+id: 6633bdc3ca38c068c3735984\n+title: Step 21\n+challengeType: 20\n+dashedName: step-21\n+---\n+\n+# --description--\n+\n+Add the x and y axes to the graph to obtain the following output:\n+\n+```py\n+[\n+    \"⊣     ∙       \",\n+    \"⊣  ∙∙∙ ∙∙∙    \",\n+    \"⊣ ∙       ∙   \",\n+    \"⊣∙         ∙  \",\n+    \"⊣           ∙ \",\n+    \"⊣            ∙\",\n+    \"⊣             \",\n+    \" TTTTTTTTTTTTT\",\n+]\n+```\n+\n+The symbols are available as `x_axis_tick` and `y_axis_tick`.\n+\n+# --hints--\n+\n+The method should return the correct output.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+gr = [\n+    \"⊣     ∙       \",\n+    \"⊣  ∙∙∙ ∙∙∙    \",\n+    \"⊣ ∙       ∙   \",\n+    \"⊣∙         ∙  \",\n+    \"⊣           ∙ \",\n+    \"⊣            ∙\",\n+    \"⊣             \",\n+    \" TTTTTTTTTTTTT\",\n+]\n+ball = Projectile(10, 3, 45)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+g.create_trajectory() == gr`\n+    ))\n+})\n+```\n+\n+The method should return the correct output for different instances.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+gr = [\n+    \"⊣     ∙∙             \",\n+    \"⊣ ∙∙∙∙  ∙∙∙          \",\n+    \"⊣∙         ∙∙        \",\n+    \"⊣            ∙       \",\n+    \"⊣             ∙      \",\n+    \"⊣              ∙     \",\n+    \"⊣               ∙    \",\n+    \"⊣                ∙   \",\n+    \"⊣                 ∙  \",\n+    \"⊣                  ∙ \",\n+    \"⊣                    \",\n+    \"⊣                   ∙\",\n+    \" TTTTTTTTTTTTTTTTTTTT\",\n+]\n+ball = Projectile(11, 9, 30)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+g.create_trajectory() == gr`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        return matrix\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "3d29b59fbfd71f58386bc322cb68fd7e29811389",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bfcef57e1d70cc3142c6.md",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,167 @@\n+---\n+id: 6633bfcef57e1d70cc3142c6\n+title: Step 23\n+challengeType: 20\n+dashedName: step-23\n+---\n+\n+# --description--\n+\n+Finally, make the final output a multiline string. It should start with a newline character and end with a newline character.\n+\n+```py\n+\n+⊣     ∙       \n+⊣  ∙∙∙ ∙∙∙    \n+⊣ ∙       ∙   \n+⊣∙         ∙  \n+⊣           ∙ \n+⊣            ∙\n+⊣             \n+ TTTTTTTTTTTTT\n+\n+```\n+\n+# --hints--\n+\n+The method should return the correct string.\n+\n+```js\n+({\n+    test: () => (runPython(\n+        `gr = '\\\\n⊣     ∙       \\\\n⊣  ∙∙∙ ∙∙∙    \\\\n⊣ ∙       ∙   \\\\n⊣∙         ∙  \\\\n⊣           ∙ \\\\n⊣            ∙\\\\n⊣             \\\\n TTTTTTTTTTTTT\\\\n'\n+ball = Projectile(10, 3, 45)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+actual = g.create_trajectory()\n+expected = gr\n+assert actual == expected, f'expected {repr(expected)} but found {repr(actual)}'`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        return matrix_axes\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "c3fbb93afa003c93fc3ca6b1fe4c509cb1448866",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633c06601c081735063b528.md",
            "status": "added",
            "additions": 329,
            "deletions": 0,
            "changes": 329,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,329 @@\n+---\n+id: 6633c06601c081735063b528\n+title: Step 24\n+challengeType: 20\n+dashedName: step-24\n+---\n+\n+# --description--\n+\n+You have built a projectile trajectory calculator.\n+\n+Now to conclude, modify the code you wrote outside the classes, and incorporate it into a little utility function called `projectile_helper` that takes in the desired values for speed, height and angle and prints to the terminal in sequence, the details of the projectile, the table of coordinates and the graph of the trajectory.\n+\n+Call `projectile_helper` once with values of your choice.\n+\n+# --hints--\n+\n+You should create `projectile_helper` in the global scope.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).has_function('projectile_helper')    \n+    `)\n+})\n+```\n+\n+You should print the requested strings in order. Do not print other values.\n+\n+```js\n+({\n+    test: () => {\n+        let code_ = code.replaceAll('print(', '__result.append(')\n+\n+        runPython(`\n+__result = []\n+${code_}\n+__result = [] # code_ includes a call, so let's reset it here\n+projectile_helper(12, 13, 14)\n+bullet = Projectile(12, 13, 14)\n+assert str(__result[0]) == str(bullet)\n+c = bullet.calculate_all_coordinates()\n+g = Graph(c)\n+assert __result[1] == g.create_coordinates_table()\n+assert __result[2] == g.create_trajectory()\n+        `)\n+    }\n+})\n+```\n+\n+You should call the `projectile_helper` function at least once.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert len(_Node(_code).find_calls('projectile_helper')) > 0\n+    `)\n+})\n+```\n+\n+You should not have variables or print calls in the global scope.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_calls('print') == [], \"found print\"\n+    assert not _Node(_code).has_variable('graph'), \"found graph\"\n+    assert not _Node(_code).has_variable('ball'), \"found ball\"\n+    assert not _Node(_code).has_variable('coordinates'), \"found coordinates\"\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        graph = \"\\n\" + \"\\n\".join(matrix_axes) + \"\\n\"\n+\n+        return graph\n+\n+--fcc-editable-region--\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+--fcc-editable-region--\n+```\n+\n+# --solutions--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def __str__(self):\n+        return self.create_trajectory()\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        graph = \"\\n\" + \"\\n\".join(matrix_axes) + \"\\n\"\n+\n+        return graph\n+\n+def projectile_helper(speed, height, angle):\n+    p = Projectile(speed, height, angle)\n+    print(p)\n+    coord = p.calculate_all_coordinates()\n+    g = Graph(coord)\n+    print(g.create_coordinates_table())\n+    print(g.create_trajectory())\n+\n+projectile_helper(12, 43, 1)\n+\n+```"
        },
        {
            "sha": "7a5dc5ce39e5eba44b6d2e35b025007821bba047",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6634fa2417d7194b0c9425f9.md",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,145 @@\n+---\n+id: 6634fa2417d7194b0c9425f9\n+title: Step 9\n+challengeType: 20\n+dashedName: step-9\n+---\n+\n+# --description--\n+\n+Now create the two getters for `__height` and `__angle`. Remember that for the angle, the value is given to the class in degrees, but is saved internally in radians, so have the getter return the degrees value. You can use `math.degrees`, and the `round` function for this.\n+\n+# --hints--\n+You should define a `height` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('height')\n+`))})\n+```\n+\n+Your `height` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('height').has_args('self')\n+`))})\n+```\n+\n+Your `height` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('height').has_decorators('property')\n+`))})\n+```\n+\n+Your `height` method should return the value of the private attribute `__height`.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.height == 23\n+`))})\n+```\n+\n+You should define an `angle` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('angle')\n+`))})\n+```\n+\n+Your `angle` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('angle').has_decorators('property')\n+`))})\n+```\n+\n+Your `angle` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('angle').has_args('self')\n+`))})\n+```\n+\n+Your `angle` method should return the value of the private attribute `__angle` converted to degrees.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.angle == 24\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+--fcc-editable-region--\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+```"
        },
        {
            "sha": "6841ba5771d91dedf28c95bd710c1e0c18045ce2",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475bab40e5125c84b03337.md",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,172 @@\n+---\n+id: 66475bab40e5125c84b03337\n+title: Step 16\n+challengeType: 20\n+dashedName: step-16\n+---\n+\n+# --description--\n+\n+Now that you have the rounded coordinates, find the maximum value between all the x coordinates and the maximum value between all the y coordinates.\n+\n+These max values will be the number of rows and columns in the graph. Save the first in a new variable named `x_max` and the second in a variable named `y_max`.\n+\n+Return `x_max, y_max`.\n+\n+# --hints--\n+\n+The function should return `x_max, y_max`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_class('Graph').find_function('create_trajectory').has_return('x_max, y_max'), \"return x_max, y_max missing\"\n+    `)\n+})\n+```\n+\n+The variable `x_max` should contain the highest x value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert graph.create_trajectory()[0] == round(max(coordinates, key=lambda i: round(i[0]))[0])\n+\n+        `)\n+    }\n+})\n+```\n+\n+The variable `y_max` should contain the highest y value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert graph.create_trajectory()[1] == round(max(coordinates, key=lambda i: round(i[1]))[1])\n+\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        displacement = horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+        return displacement\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        return rounded_coords\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "b9ea0fe21ec83155050358605c83ff08a9e70324",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475d40dd42fb614f14fd03.md",
            "status": "added",
            "additions": 201,
            "deletions": 0,
            "changes": 201,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,201 @@\n+---\n+id: 66475d40dd42fb614f14fd03\n+title: Step 17\n+challengeType: 20\n+dashedName: step-17\n+---\n+\n+# --description--\n+\n+Now that you have `x_max` and `y_max` you can use these as number of rows and columns to start building the graph structure: create a list of lists where the external list contains `y_max` +1 lists, each with inside `x_max` +1 elements, where each element is a string containing a single space.\n+\n+Save this list of lists in a variable named `matrix_list` and return this value.\n+\n+`matrix_list` should look like this:\n+\n+```py\n+[\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+The `create_trajectory` method should return the right value for any instance.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        return x_max, y_max\n+\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "70fb15ef003f144416e3939aae0e2d8a14f106c7",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475e40f3891c645d50135e.md",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,199 @@\n+---\n+id: 66475e40f3891c645d50135e\n+title: Step 19\n+challengeType: 20\n+dashedName: step-19\n+---\n+\n+# --description--\n+\n+`matrix_list` is a list of lists, each element has an `(x, y)` coordinate. Use the list of coordinates in `rounded_coords` to change the elements in `matrix_list` at the coordinates in the list to the symbol in the `PROJECTILE` variable. Remember that a coordinates graph has the `(0, 0)` in the bottom left corner.\n+\n+```py\n+[\n+    [\" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \" \", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \" \", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+The method should return the correct value for different instances.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        return matrix_list\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "49dd62d1c58388faf938ce720da442332b4d02c0",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475f7b91d7c6681987739d.md",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,204 @@\n+---\n+id: 66475f7b91d7c6681987739d\n+title: Step 20\n+challengeType: 20\n+dashedName: step-20\n+---\n+\n+# --description--\n+\n+You have a list of lists of strings. Join the inner lists to have a list of strings.\n+\n+It should look like this:\n+\n+```py\n+[\n+    \"     ∙       \",\n+    \"  ∙∙∙ ∙∙∙    \",\n+    \" ∙       ∙   \",\n+    \"∙         ∙  \",\n+    \"           ∙ \",\n+    \"            ∙\",\n+    \"             \",\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    \"     ∙       \",\n+    \"  ∙∙∙ ∙∙∙    \",\n+    \" ∙       ∙   \",\n+    \"∙         ∙  \",\n+    \"           ∙ \",\n+    \"            ∙\",\n+    \"             \",\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+`create_trajectory()` should calculate the correct output for different instances.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    \"  ∙∙∙∙∙        \",\n+    \"∙∙     ∙       \",\n+    \"        ∙∙     \",\n+    \"          ∙    \",\n+    \"           ∙   \",\n+    \"               \",\n+    \"            ∙  \",\n+    \"             ∙ \",\n+    \"               \",\n+    \"              ∙\",\n+    \"               \",\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for (x, y) in rounded_coords:\n+            matrix_list[-y-1][x] = PROJECTILE\n+\n+        return matrix_list\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "a8c7d3d299897690a7d2d202b8869208db5b1ca7",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/665d949e628d9f3fe305b6e8.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,164 @@\n+---\n+id: 665d949e628d9f3fe305b6e8\n+title: Step 18\n+challengeType: 20\n+dashedName: step-18\n+---\n+\n+# --description--\n+\n+The output is becoming quite difficult to read, so you should replace the `print(graph.create_trajectory())` with a loop that prints each row separately.\n+\n+# --hints--\n+\n+Remove the `print(graph.create_trajectory())` call.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+prnt = _Node(_code).find_calls('print')\n+assert not any(p.is_equivalent('print(graph.create_trajectory())') for p in prnt), \"print still present\"\n+        `)\n+    }\n+})\n+```\n+\n+You should have a loop that iterates over `graph.create_trajectory()`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+iter = _Node(_code).find_for_loops()[0].find_for_iter()\n+assert iter.is_equivalent('graph.create_trajectory()'), \"loop is missing\"\n+        `)\n+    }\n+})\n+```\n+\n+You should print each row in `graph.create_trajectory()`.\n+\n+```js\n+({ test: () => runPython(`\n+loop = _Node(_code).find_for_loops()[0]\n+var = str(loop.find_for_vars())\n+assert loop.find_bodies()[0].has_call(f\"print({var})\")\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        return matrix_list\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+--fcc-editable-region--\n+print(graph.create_trajectory())\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "81d985809714b0ca514f09d38e4b368397ff0bbf",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66601c3c460ee12fbd669d6a.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,164 @@\n+---\n+id: 66601c3c460ee12fbd669d6a\n+title: Step 22\n+challengeType: 20\n+dashedName: step-22\n+---\n+\n+# --description--\n+\n+Now you can remove the loop to print each row of the output, and replace it with `print(graph.create_trajectory())`.\n+\n+# --hints--\n+\n+You should not have a loop in the global scope.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+assert not _Node(_code).find_for_loops(), \"loop still present\"\n+        `)\n+    }\n+})\n+```\n+\n+You should have `print(graph.create_trajectory())`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+prnt = _Node(_code).find_calls('print')\n+assert any(p.is_equivalent('print(graph.create_trajectory())') for p in prnt), \"print not present\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        return matrix_axes\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+--fcc-editable-region--\n+for row in graph.create_trajectory():\n+    print(row)\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "56966b5faea5d838476dfaeb0b5b976bb76333ca",
            "filename": "curriculum/challenges/arabic/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66671a41b55e531d08ab82b5.md",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Farabic%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,142 @@\n+---\n+id: 66671a41b55e531d08ab82b5\n+title: Step 11\n+challengeType: 20\n+dashedName: step-11\n+---\n+\n+# --description--\n+\n+The `__str__` method refers to the attributes of the class directly, but now that you have created the getters it is better to use those to obtain those values.\n+\n+Edit the `__str__` method to not reference the attributes anymore, but to use the getters.\n+\n+# --hints--\n+\n+The string representation for `Projectile(45, 45, 45)` should be correct.\n+\n+```js\n+({test: () => assert(runPython(\n+`\n+ball = Projectile(45, 45, 45)\n+str(ball) == \"\"\"\n+Projectile details:\n+speed: 45 m/s\n+height: 45 m\n+angle: 45°\n+displacement: 244.4 m\n+\"\"\"`\n+))})\n+```\n+\n+The string representation should also be correct for other instances.\n+\n+```js\n+({test: () => assert(runPython(`p = Projectile(10, 10, 10)\n+str(\n+    p\n+) == \"\"\"\n+Projectile details:\n+speed: 10 m/s\n+height: 10 m\n+angle: 10°\n+displacement: 15.9 m\n+\"\"\"`))})\n+```\n+\n+You should not be referencing the private properties directly.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    rtrn = str(_Node(_code).find_class('Projectile').find_function('__str__').find_return())\n+    assert not 'self.__angle' in rtrn\n+    assert not 'self.__speed' in rtrn\n+    assert not 'self.__height' in rtrn\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+--fcc-editable-region--    \n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+--fcc-editable-region--\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "abf4a3fbf33486dfa17f944cc8b14021a8a045e7",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65f569725359e10d345bc52a.md",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,75 @@\n+---\n+id: 65f569725359e10d345bc52a\n+title: Step 1\n+challengeType: 20\n+dashedName: step-1\n+---\n+\n+# --description--\n+\n+You are going to build a program that calculates and draws the trajectory of a projectile given the angle, speed and height of the throw.\n+\n+Start by importing `math`, you will use it a lot in this project as it has useful methods like `math.radians`, `math.cos`, `math.sin` and others.\n+\n+Also create these variables to have the value of the gravitational acceleration and some special symbols that will be useful later (use copy and paste for these).\n+\n+```py\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+```\n+\n+# --hints--\n+\n+Use `import math` to import the `math` module.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_import('import math')`))})\n+```\n+\n+You should have a `GRAVITATIONAL_ACCELERATION` variable with value of `9.81`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"GRAVITATIONAL_ACCELERATION\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"GRAVITATIONAL_ACCELERATION\").is_equivalent('GRAVITATIONAL_ACCELERATION = 9.81'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `PROJECTILE` variable with value of `\"∙\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"PROJECTILE\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"PROJECTILE\").is_equivalent('PROJECTILE = \"∙\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `x_axis_tick` variable with value of `\"T\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"x_axis_tick\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"x_axis_tick\").is_equivalent('x_axis_tick = \"T\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `y_axis_tick` variable with value of `\"⊣\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"y_axis_tick\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"y_axis_tick\").is_equivalent('y_axis_tick = \"⊣\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "db286166f195ed43a10e0605bfc4be0fc2f6c69c",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4b3bedee044b4b957d33.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,61 @@\n+---\n+id: 65fd4b3bedee044b4b957d33\n+title: Step 2\n+challengeType: 20\n+dashedName: step-2\n+---\n+\n+# --description--\n+\n+Create a `Projectile` class with an `__init__` method that initializes the class using three arguments: the starting speed, the starting height, and the starting angle of the throw of the projectile, in this order.\n+\n+Inside the `__init__` method, assign these arguments to three private attributes: `__speed`, `__height`, and `__angle`. The angle provided will be in degrees; however, it should be stored internally in radians. To achieve this, use the `math.radians()` function to convert the angle from degrees to radians when assigning it to `__angle`.\n+\n+The use of two underscores before an attribute name triggers name mangling in Python. This means the attributes are not directly accessible from outside the class using their given names, and must be accessed with the mangled names like `ball._Projectile__height` if needed externally, indicating these are intended for internal use only.\n+\n+# --hints--\n+\n+You should use `class Projectile:` to create the class.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_class(\"Projectile\")`))})\n+\n+```\n+\n+You should have an `__init__` method inside the `Projectile` class.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_body().has_function(\"__init__\")`))})\n+```\n+\n+A new `Projectile` class instance should have the values of the three attributes properly initialized.\n+\n+```js\n+({test: () => assert(runPython(`\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+p = Projectile(20, 21, 22)\n+p._Projectile__height == 21 and p._Projectile__speed == 20 and p._Projectile__angle == math.radians(22)\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "b9cd836b59b48f169c5d29a78dac81b1940b204c",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4bd84561a14d3e720061.md",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,48 @@\n+---\n+id: 65fd4bd84561a14d3e720061\n+title: Step 3\n+challengeType: 20\n+dashedName: step-3\n+---\n+\n+# --description--\n+\n+The class variable `__slots__` has a special usage in Python classes. Declaring `__slots__` and assigning it a sequence of strings restricts the creation of attributes to those included in that sequence. Also, it prevents the creation of the `__dict__` special attribute and it allows for more efficient attribute access.\n+\n+You should use the `__slots__` variable inside the class to define which attributes the class has: assign to `__slots__` a tuple containing 3 strings, each equal to one of the attribute names defined in the `__init__`.\n+\n+# --hints--\n+\n+You should assign to `__slots__` a tuple that contains `'__height'`, `'__speed'`, and `'__angle'`.\n+\n+```js\n+({test: () => assert(runPython(`\n+from itertools import permutations\n+slots = _Node(_code).find_class(\"Projectile\").find_body().find_variable(\"__slots__\")\n+perms = permutations((\"__height\", \"__speed\", \"__angle\"))\n+any(slots.is_equivalent(f'__slots__ = {perm}') for perm in perms)\n+`))})\n+\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+--fcc-editable-region--\n+class Projectile:\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "8c5270d99f59f323256adadc87929e55f6123f4c",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660400f02cf3a76795b82d4e.md",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,74 @@\n+---\n+id: 660400f02cf3a76795b82d4e\n+title: Step 4\n+challengeType: 20\n+dashedName: step-4\n+---\n+\n+# --description--\n+\n+The first thing to set up is a method that calculates the displacement of the projectile, which is the horizontal space traveled from the throw to when the projectile touches the ground.\n+\n+Create a method `__calculate_displacement`, which has only `self` as a parameter, and return the displacement of the projectile.\n+\n+Use the following formula to compute the projectile displacement: \\\\[ d = \\frac{v \\cdot \\cos\\theta \\cdot \\left(v\\cdot\\sin\\theta + \\sqrt{v^2\\sin^2\\theta + 2 \\cdot g \\cdot h}\\right)}{g} \\\\]\n+\n+In which $d$ is the displacement, $v$ is the starting speed, $\\theta$ is the angle and $h$ is the starting height of the projectile. For $g$ you can use the `GRAVITATIONAL_ACCELERATION` variable.\n+\n+You should use the methods `math.cos()` and `math.sin()` for the trigonometric functions and `math.sqrt()` to calculate the square root. Also you should know that $x^y$ is written as `x ** y` in python. Also $\\sin^2\\theta$ means that the value resulting from the sine is then squared.\n+\n+Remember that with name mangling you need to call the method as `_Projectile__calculate_displacement` if you want to test, or use it from outside of the class:\n+\n+```py\n+ball = Projectile(10, 3, 45)\n+displacement_of_ball = ball._Projectile__calculate_displacement() # 12.6173996009878\n+```\n+\n+# --hints--\n+\n+You should declare a function called `__calculate_displacement` with `def __calculate_displacement(self):`.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").has_function(\"__calculate_displacement\")`))})\n+```\n+\n+The `__calculate_displacement` method should have only the `self` argument.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_function(\"__calculate_displacement\").has_args('self')`))})\n+```\n+\n+The `__calculate_displacement` method should return the correct value.\n+\n+```js\n+({test: () => assert(runPython(`\n+p = Projectile(20, 21, 22)\n+disp = p._Projectile__calculate_displacement()\n+round(disp, 2) == 55.06 and round(disp, 2) != disp\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "eefd3dc7de816fb5abe2e8953fa8f6d6989ad361",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660fcf3e1b9bb056b2edb567.md",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,120 @@\n+---\n+id: 660fcf3e1b9bb056b2edb567\n+title: Step 5\n+challengeType: 20\n+dashedName: step-5\n+---\n+\n+# --description--\n+\n+At this point you are ready to create the string representation. Start by creating an instance of the `Projectile` class. Below the class definition, create a `ball` variable and assign it a call to `Projectile` using `10, 3, 45` as arguments.\n+\n+Define a `__str__` method within the class, to give your instance a proper string representation, and make it return a string with the following format:\n+\n+```py\n+\n+Projectile details:\n+speed: 10 m/s\n+height: 3 m\n+angle: 45°\n+displacement: 12.6 m\n+\n+```\n+\n+It should start and end with a new line character, the angle has to be written as an integer in degrees and the displacement should be printed with one decimal digit.\n+\n+You will find useful `math.degrees` to convert the angle from radians to degrees.\n+\n+When you are ready you can `print(ball)` to test your function.\n+\n+# --hints--\n+\n+You should have a `ball` variable.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_variable('ball')`))})\n+```\n+\n+The `ball` variable should have a value of `Projectile(10, 3, 45)`.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_variable('ball').is_equivalent('ball = Projectile(10, 3, 45)')`))})\n+```\n+\n+The string representation for `Projectile(45, 45, 45)` should be correct.\n+\n+```js\n+({test: () => assert(runPython(\n+`\n+ball = Projectile(45, 45, 45)\n+str(ball) == \"\"\"\n+Projectile details:\n+speed: 45 m/s\n+height: 45 m\n+angle: 45°\n+displacement: 244.4 m\n+\"\"\"`\n+))})\n+```\n+\n+The string representation should also be correct for other instances.\n+\n+```js\n+({test: () => assert(runPython(`p = Projectile(10, 10, 10)\n+str(\n+    p\n+) == \"\"\"\n+Projectile details:\n+speed: 10 m/s\n+height: 10 m\n+angle: 10°\n+displacement: 15.9 m\n+\"\"\"`))})\n+```\n+\n+You should have a `print(ball)` call.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    calls = _Node(_code).find_calls('print')\n+    assert any(c.is_equivalent('print(ball)') for c in calls)\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "ccfbf71ff43271f6871fdb3cf38d0f2c27675c7f",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6616ec0bf9ee8548ce6b0f08.md",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,109 @@\n+---\n+id: 6616ec0bf9ee8548ce6b0f08\n+title: Step 6\n+challengeType: 20\n+dashedName: step-6\n+---\n+\n+# --description--\n+\n+Now it's time to work on the function to calculate the coordinates of the trajectory! Create a method of the `Projectile` class named `__calculate_y_coordinate`, it should have, other than `self`, an `x` parameter.\n+\n+\\\\[ y = y_0 + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta} \\\\]\n+\n+The above is the formula to calculate the vertical position $y$ for any given horizontal position $x$, having the starting angle $\\theta$, speed $v_0$ and height $y_0$.\n+\n+You will need to use `math.tan()` and `math.cos()` and remember that `x ** y` is the way to write $x^y$, and that the value of $g$ is in the variable `GRAVITATIONAL_ACCELERATION`.\n+\n+Implement the method so that it returns the $y$ coordinate.\n+\n+If you want to test the method, from outside of class, you can call `ball._Projectile__calculate_y_coordinate()` with a number as an argument after `ball` is declared.\n+\n+# --hints--\n+\n+Your `Projectile` class should have a method named `__calculate_y_coordinate`.\n+\n+```js\n+({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').has_function('__calculate_y_coordinate')`))}})\n+```\n+\n+The `__calculate_y_coordinate` method should have `self, x` as arguments.\n+\n+```js\n+({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').find_function('__calculate_y_coordinate').has_args('self, x')`))}})\n+```\n+\n+The method should return the correct value. For `Projectile(12, 12, 12)`, given the 4 $x$ coordinates of 0, 1, 2 and 3, the y coordinate should be approximately 12, 12.18, 12.28, 12.32.\n+\n+```js\n+({test: () => {\n+    assert(runPython(`\n+    a = Projectile(12, 12, 12)\n+    all([round(a._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(0, 12.0), (1, 12.18), (2, 12.28), (3, 12.32)]])\n+    `))\n+}})\n+```\n+\n+The method should return the correct value. For `Projectile(45, 12, 22)`, given the $x$ coordinates of 6, 9, 10 and 12 the y coordinate should be approximately 14.32, 15.41, 15.76, 16.44.\n+\n+```js\n+({test: () => {\n+    assert(runPython(`\n+    b = Projectile(45, 12, 22)\n+    all([round(b._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(6, 14.32), (9, 15.41), (10, 15.76), (12, 16.44)]])\n+    `))\n+}})\n+```\n+\n+The `__calculate_y_coordinate` method should not round the result.\n+\n+```js\n+({test: () => assert.isFalse(runPython(`Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5) == round(Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5), 2)`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    --fcc-editable-region--\n+\n+    --fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+\n+```"
        },
        {
            "sha": "4cff93b9e8f559830239b74ee912725513ce046e",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662f9f65c50bd21d05ffdee9.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,110 @@\n+---\n+id: 662f9f65c50bd21d05ffdee9\n+title: Step 7\n+challengeType: 20\n+dashedName: step-7\n+---\n+\n+# --description--\n+\n+Define a method named `calculate_all_coordinates`, which calculates the coordinates for all \\\\(x\\\\) values from `0` up to the displacement rounded up (not inclusive), and then returns them as a list of tuples `(x, y)`.\n+\n+Then, call the `calculate_all_coordinates` method on the `ball` instance and assign the output to a new variable named `coordinates`.\n+\n+You can use `math.ceil()` to round up a number to the smallest integer greater than or equal to that number.\n+\n+# --hints--\n+\n+You should define a `calculate_all_coordinates` method with a single argument, `self` .\n+\n+```js\n+({test: () => assert(runPython(`\n+c = _Node(_code).find_class('Projectile')\n+c.has_function('calculate_all_coordinates') and c.find_function('calculate_all_coordinates').has_args('self')\n+`))})\n+```\n+\n+You should call the `calculate_all_coordinates` method on `ball` and assign the result to a variable named `coordinates`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+        assert _Node(_code).has_variable('coordinates'), \"coordinates variable is missing\"\n+\n+        assert _Node(_code).find_variable('coordinates').is_equivalent('coordinates = ball.calculate_all_coordinates()'), \"wrong value assigned to coordinates variable\"\n+    `)\n+})\n+```\n+\n+The `calculate_all_coordinates` method should return a list containing all the `(x, y)` coordinates.\n+\n+```js\n+({test: () => assert(runPython(`\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+ball = Projectile(12, 13, 14)\n+expected = [(x, ball._Projectile__calculate_y_coordinate(x)) for x in range(math.ceil(ball._Projectile__calculate_displacement()))]\n+actual = ball.calculate_all_coordinates()\n+expected == actual\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x**2 / (\n+                2 * self.__speed**2 * math.cos(self.__angle)**2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    --fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+   --fcc-editable-region--\n+```"
        },
        {
            "sha": "4bb9cd3ad62b572df845a78672e0b21c3e994443",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fa453ec8033322b3ab2e3.md",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,129 @@\n+---\n+id: 662fa453ec8033322b3ab2e3\n+title: Step 8\n+challengeType: 20\n+dashedName: step-8\n+---\n+\n+# --description--\n+\n+It's time to talk about encapsulation and getters. You have written the three instance attributes to be private using a leading double underscore. Note that these attributes are called private by convention: although they can still be accessed from outside, it is agreed upon to not do that.\n+\n+Getters are what can be used to get the values from outside. To define a getter, you define a method that returns the value of the desired attribute and give it a `@property` decorator:\n+\n+```py\n+class Nest:\n+    ...\n+    @property\n+    def number_of_eggs(self):\n+        return self.__number_of_eggs\n+```\n+\n+ The decorator changes the method into a property, meaning that the method is not called like a regular method, but it's used like an attribute:\n+\n+```py\n+n = Nest()\n+print(n.number_of_eggs)\n+```\n+\n+In the example above, the private attribute `__number of eggs` is accessed through the `number_of_eggs` property of `n`.\n+\n+Create a getter named `speed` and make it return the value of the private attribute `__speed`.\n+\n+# --hints--\n+\n+You should define a `speed` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('speed')\n+`))})\n+```\n+\n+Your `speed` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('speed').has_args('self')\n+`))})\n+```\n+\n+Your `speed` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('speed').has_decorators('property')\n+`))})\n+```\n+\n+Your `speed` method should return the value of the private attribute `__speed`.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.speed == 22\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "2b6b033fce5f1228ea15aa55035d277fee85077f",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fc35902038376c7a00b3c.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,186 @@\n+---\n+id: 662fc35902038376c7a00b3c\n+title: Step 10\n+challengeType: 20\n+dashedName: step-10\n+---\n+\n+# --description--\n+\n+Once you have the getters, you can write the setters, which allow you to set the value of an attribute in an indirect manner. Following the example of the last step, a setter would be written as:\n+\n+```py\n+class Nest:\n+    ...\n+    @number_of_eggs.setter\n+    def number_of_eggs(self, new_value):\n+        self.__number_of_eggs = new_value\n+```\n+\n+Same as the getter, a setter is not called like a method but used like an attribute:\n+\n+```py\n+nest = Nest()\n+nest.number_of_eggs = 12\n+```\n+\n+This way of writing calls the setter and set the new value.\n+\n+For this step you will have to write the setters for the three private attributes. Remember that for the angle the value is received in degrees but saved internally in radians.\n+\n+# --hints--\n+\n+You should define a new `speed` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('speed')) == 2\n+`))})\n+```\n+\n+Your new `speed` method should have a `@speed.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('speed')[1].has_decorators('speed.setter')\n+`))})\n+```\n+\n+Your new `speed` method should set the value of the private `__speed` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.speed = 33\n+a.speed == 33\n+`))})\n+```\n+\n+You should define a new `height` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('height')) == 2\n+`))})\n+```\n+\n+Your new `height` method should have a `@height.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('height')[1].has_decorators('height.setter')\n+`))})\n+```\n+\n+Your new `height` method should set the value of the private `__height` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.height = 44\n+a.height == 44\n+`))})\n+```\n+\n+You should define a new `angle` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('angle')) == 2\n+`))})\n+```\n+\n+Your new `angle` method should have a `@angle.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('angle')[1].has_decorators('angle.setter')\n+`))})\n+```\n+\n+Your `angle` method should set the value of the private `__angle` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.angle = 12\n+a.angle == 12\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "767c9c4f043405d60efeaf03dae28ab119f431dc",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66335223f3e2a31d62d84367.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,203 @@\n+---\n+id: 66335223f3e2a31d62d84367\n+title: Step 13\n+challengeType: 20\n+dashedName: step-13\n+---\n+\n+# --description--\n+\n+Going back to the projectile trajectory calculator, now you'll create a new class that accepts a list of coordinates and creates the trajectory drawing.\n+\n+Create a new class `Graph`, which should be instantiated with a private attribute `__coordinates` where the list of coordinates is stored. Declare the `__slots__` class variable and define the  `__init__` and `__repr__` special methods.\n+\n+Also, create a `Graph` instance passing the `coordinates` variable and assign it to a new `graph` variable.\n+\n+# --hints--\n+\n+You should create a new `Graph` class.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).has_class('Graph')`\n+    ))\n+})\n+```\n+\n+You should have the `__slots__` variable inside the class.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_variable('__slots__')`\n+    ))\n+})\n+```\n+\n+The `__slots__` variable should have a value of `('__coordinates')` or `['__coordinates']`.\n+\n+```js\n+({\n+    test: () => (runPython(\n+        `\n+        slots = _Node(_code).find_class('Graph').find_variable('__slots__')\n+\n+        assert any(slots.is_equivalent(str) for str in ['__slots__ = (\"__coordinates\")', '__slots__ = [\"__coordinates\"]'])`\n+    ))\n+})\n+```\n+\n+You should have an `__init__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('__init__')`\n+    ))\n+})\n+```\n+\n+The `__init__` method should instantiate the `__coordinates` private property with the passed in value.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+        l = [(3, 4), (4, 1), (3, 9)]\n+        g = Graph(l)\n+        g._Graph__coordinates == l\n+        `\n+    ))\n+})\n+```\n+\n+You should have a `__repr__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('__repr__')`\n+    ))\n+})\n+```\n+\n+The `__repr__` method should return the correct string.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+        ball = Projectile(10, 3, 45)\n+        coords = ball.calculate_all_coordinates()\n+        repr(Graph(coords)) == f'Graph({coords})'\n+        `\n+    ))\n+})\n+```\n+\n+You should create a `Graph` instance passing in the `coordinates` variable and assign it to `graph` variable.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+\n+        assert _Node(_code).has_variable('graph'), \"variable graph is missing\"\n+\n+        assert _Node(_code).find_variable('graph').is_equivalent('graph = Graph(coordinates)'), \"assignment to graph is wrong\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f\"{self.__class__.__name__}({self.speed}, {self.height}, {self.angle})\"\n+\n+--fcc-editable-region--\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+--fcc-editable-region-- \n+```"
        },
        {
            "sha": "afe4a4b500557bd25c1732e3b9e0168c51c544b0",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/663353465bfb14259717da93.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,186 @@\n+---\n+id: 663353465bfb14259717da93\n+title: Step 14\n+challengeType: 20\n+dashedName: step-14\n+---\n+\n+# --description--\n+\n+Create a method `create_coordinates_table`, then at the end of the code print `graph.create_coordinates_table())`.\n+\n+The method should use the `__coordinates` property and return a string containing all the coordinates, where x and y have always the same position, the values for x are always integers, and the values for y are always rounded to two decimal places:\n+\n+```py\n+  x      y\n+  0   3.00\n+  1   3.90\n+  2   4.61\n+  3   5.12\n+  4   5.43\n+  5   5.55\n+  6   5.47\n+  7   5.19\n+  8   4.72\n+  9   4.05\n+ 10   3.19\n+ 11   2.13\n+ 12   0.87  \n+```\n+\n+The table should start with a newline character and end with a newline character.\n+\n+# --hints--\n+\n+You should have a `create_coordinates_table()` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('create_coordinates_table')`\n+    ))\n+})\n+```\n+\n+The method should return the correct output.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `str = \"\"\"\n+  x      y\n+  0   3.00\n+  1   3.90\n+  2   4.61\n+  3   5.12\n+  4   5.43\n+  5   5.55\n+  6   5.47\n+  7   5.19\n+  8   4.72\n+  9   4.05\n+ 10   3.19\n+ 11   2.13\n+ 12   0.87\n+\"\"\"\n+ball = Projectile(10, 3, 45)\n+g = Graph(ball.calculate_all_coordinates())\n+g.create_coordinates_table() == str`\n+    ))\n+})\n+```\n+\n+You should print `graph.create_coordiantes_table()`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+        prints = _Node(_code).find_calls('print')\n+        assert any(p.is_equivalent('print(graph.create_coordinates_table())') for p in prints), \"print(graph.create_coordiantes_table()) is missing\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f'Graph({self.__coordinates})'\n+\n+--fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+graph = Graph(coordinates)\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "a86e8fab60b1753ae08a7c20d1251e34a4d1263a",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b26c4f2d603072ef0818.md",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,136 @@\n+---\n+id: 6633b26c4f2d603072ef0818\n+title: Step 12\n+challengeType: 20\n+dashedName: step-12\n+---\n+\n+# --description--\n+\n+It's good practice to give a representation to the class by using the `__repr__` special method. While the `__str__` method returns a readable string representation that's intended to be user friendly, `__repr__` is intended for programmers. Often `__repr__` provides a string that can be used to recreate the object.\n+\n+Write the `__repr__` method, which will return the string needed to instantiate the object.\n+\n+You can test this by calling the `repr` function and passing it an instance of the class.\n+\n+# --hints--\n+\n+The `Projectile` class should have a `__repr__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Projectile').has_function('__repr__')`\n+    ))\n+})\n+```\n+\n+The instance `Projectile(12, 12, 12)` should have representation equal to `'Projectile(12, 12, 12)'`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `repr(Projectile(12, 12, 12)) == 'Projectile(12, 12, 12)' or \\\\\n+        repr(Projectile(12, 12, 12)) == 'Projectile(12, 12, 12.0)'`\n+    ))\n+})\n+```\n+\n+The instance `Projectile(21, 22, 45)` should have representation equal to `'Projectile(21, 22, 45)'`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `repr(Projectile(21, 22, 45)) == 'Projectile(21, 22, 45)' or \\\\\n+        repr(Projectile(21, 22, 45)) == 'Projectile(21, 22, 45.0)'`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+```"
        },
        {
            "sha": "b0ba04423b9d0981453df5445f4ce8e61a4831e1",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b4d3271d5b3aea1c1195.md",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,173 @@\n+---\n+id: 6633b4d3271d5b3aea1c1195\n+title: Step 15\n+challengeType: 20\n+dashedName: step-15\n+---\n+\n+# --description--\n+\n+Now it's time for the graph. Create a method `create_trajectory` and replace the last `print` call at the bottom of your code with `print(graph.create_trajectory())`.\n+\n+As the first step of this new function, make a local copy of the coordinates but where all the values are rounded to integers. Save this new version of the coordinates in a variable named `rounded_coords`, and return this variable.\n+\n+# --hints--\n+\n+You should define a method named `create_trajectory`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('create_trajectory')`\n+    ))\n+})\n+```\n+\n+You should replace `print(graph.create_coordinates_table())` with `print(graph.create_trajectory())`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    prints = _Node(_code).find_calls('print')\n+\n+    assert all(not p.is_equivalent('print(graph.create_coordinates_table())') for p in prints), \"print(graph.create_coordinates_table()) should not be present\"\n+\n+    assert any(p.is_equivalent('print(graph.create_trajectory())') for p in prints), \"print(graph.create_trajectory()) not found\"\n+    `)\n+})\n+```\n+\n+The function should return `rounded_coords`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_class('Graph').find_function('create_trajectory').has_return('rounded_coords'), \"return rounded_coords missing\"\n+    `)\n+})\n+```\n+\n+The `rounded_coords` variable should contain the rounded coordinates.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert [(round(x), round(y)) for x,y in coordinates] == graph.create_trajectory(), \"coordinates are not rounded correctly\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_coordinates_table())\n+\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "af06d95e150d51f5cea0544a8cf49d51fef094b3",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bdc3ca38c068c3735984.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,203 @@\n+---\n+id: 6633bdc3ca38c068c3735984\n+title: Step 21\n+challengeType: 20\n+dashedName: step-21\n+---\n+\n+# --description--\n+\n+Add the x and y axes to the graph to obtain the following output:\n+\n+```py\n+[\n+    \"⊣     ∙       \",\n+    \"⊣  ∙∙∙ ∙∙∙    \",\n+    \"⊣ ∙       ∙   \",\n+    \"⊣∙         ∙  \",\n+    \"⊣           ∙ \",\n+    \"⊣            ∙\",\n+    \"⊣             \",\n+    \" TTTTTTTTTTTTT\",\n+]\n+```\n+\n+The symbols are available as `x_axis_tick` and `y_axis_tick`.\n+\n+# --hints--\n+\n+The method should return the correct output.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+gr = [\n+    \"⊣     ∙       \",\n+    \"⊣  ∙∙∙ ∙∙∙    \",\n+    \"⊣ ∙       ∙   \",\n+    \"⊣∙         ∙  \",\n+    \"⊣           ∙ \",\n+    \"⊣            ∙\",\n+    \"⊣             \",\n+    \" TTTTTTTTTTTTT\",\n+]\n+ball = Projectile(10, 3, 45)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+g.create_trajectory() == gr`\n+    ))\n+})\n+```\n+\n+The method should return the correct output for different instances.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+gr = [\n+    \"⊣     ∙∙             \",\n+    \"⊣ ∙∙∙∙  ∙∙∙          \",\n+    \"⊣∙         ∙∙        \",\n+    \"⊣            ∙       \",\n+    \"⊣             ∙      \",\n+    \"⊣              ∙     \",\n+    \"⊣               ∙    \",\n+    \"⊣                ∙   \",\n+    \"⊣                 ∙  \",\n+    \"⊣                  ∙ \",\n+    \"⊣                    \",\n+    \"⊣                   ∙\",\n+    \" TTTTTTTTTTTTTTTTTTTT\",\n+]\n+ball = Projectile(11, 9, 30)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+g.create_trajectory() == gr`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        return matrix\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "3d29b59fbfd71f58386bc322cb68fd7e29811389",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bfcef57e1d70cc3142c6.md",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,167 @@\n+---\n+id: 6633bfcef57e1d70cc3142c6\n+title: Step 23\n+challengeType: 20\n+dashedName: step-23\n+---\n+\n+# --description--\n+\n+Finally, make the final output a multiline string. It should start with a newline character and end with a newline character.\n+\n+```py\n+\n+⊣     ∙       \n+⊣  ∙∙∙ ∙∙∙    \n+⊣ ∙       ∙   \n+⊣∙         ∙  \n+⊣           ∙ \n+⊣            ∙\n+⊣             \n+ TTTTTTTTTTTTT\n+\n+```\n+\n+# --hints--\n+\n+The method should return the correct string.\n+\n+```js\n+({\n+    test: () => (runPython(\n+        `gr = '\\\\n⊣     ∙       \\\\n⊣  ∙∙∙ ∙∙∙    \\\\n⊣ ∙       ∙   \\\\n⊣∙         ∙  \\\\n⊣           ∙ \\\\n⊣            ∙\\\\n⊣             \\\\n TTTTTTTTTTTTT\\\\n'\n+ball = Projectile(10, 3, 45)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+actual = g.create_trajectory()\n+expected = gr\n+assert actual == expected, f'expected {repr(expected)} but found {repr(actual)}'`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        return matrix_axes\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "c3fbb93afa003c93fc3ca6b1fe4c509cb1448866",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633c06601c081735063b528.md",
            "status": "added",
            "additions": 329,
            "deletions": 0,
            "changes": 329,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,329 @@\n+---\n+id: 6633c06601c081735063b528\n+title: Step 24\n+challengeType: 20\n+dashedName: step-24\n+---\n+\n+# --description--\n+\n+You have built a projectile trajectory calculator.\n+\n+Now to conclude, modify the code you wrote outside the classes, and incorporate it into a little utility function called `projectile_helper` that takes in the desired values for speed, height and angle and prints to the terminal in sequence, the details of the projectile, the table of coordinates and the graph of the trajectory.\n+\n+Call `projectile_helper` once with values of your choice.\n+\n+# --hints--\n+\n+You should create `projectile_helper` in the global scope.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).has_function('projectile_helper')    \n+    `)\n+})\n+```\n+\n+You should print the requested strings in order. Do not print other values.\n+\n+```js\n+({\n+    test: () => {\n+        let code_ = code.replaceAll('print(', '__result.append(')\n+\n+        runPython(`\n+__result = []\n+${code_}\n+__result = [] # code_ includes a call, so let's reset it here\n+projectile_helper(12, 13, 14)\n+bullet = Projectile(12, 13, 14)\n+assert str(__result[0]) == str(bullet)\n+c = bullet.calculate_all_coordinates()\n+g = Graph(c)\n+assert __result[1] == g.create_coordinates_table()\n+assert __result[2] == g.create_trajectory()\n+        `)\n+    }\n+})\n+```\n+\n+You should call the `projectile_helper` function at least once.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert len(_Node(_code).find_calls('projectile_helper')) > 0\n+    `)\n+})\n+```\n+\n+You should not have variables or print calls in the global scope.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_calls('print') == [], \"found print\"\n+    assert not _Node(_code).has_variable('graph'), \"found graph\"\n+    assert not _Node(_code).has_variable('ball'), \"found ball\"\n+    assert not _Node(_code).has_variable('coordinates'), \"found coordinates\"\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        graph = \"\\n\" + \"\\n\".join(matrix_axes) + \"\\n\"\n+\n+        return graph\n+\n+--fcc-editable-region--\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+--fcc-editable-region--\n+```\n+\n+# --solutions--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def __str__(self):\n+        return self.create_trajectory()\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        graph = \"\\n\" + \"\\n\".join(matrix_axes) + \"\\n\"\n+\n+        return graph\n+\n+def projectile_helper(speed, height, angle):\n+    p = Projectile(speed, height, angle)\n+    print(p)\n+    coord = p.calculate_all_coordinates()\n+    g = Graph(coord)\n+    print(g.create_coordinates_table())\n+    print(g.create_trajectory())\n+\n+projectile_helper(12, 43, 1)\n+\n+```"
        },
        {
            "sha": "7a5dc5ce39e5eba44b6d2e35b025007821bba047",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6634fa2417d7194b0c9425f9.md",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,145 @@\n+---\n+id: 6634fa2417d7194b0c9425f9\n+title: Step 9\n+challengeType: 20\n+dashedName: step-9\n+---\n+\n+# --description--\n+\n+Now create the two getters for `__height` and `__angle`. Remember that for the angle, the value is given to the class in degrees, but is saved internally in radians, so have the getter return the degrees value. You can use `math.degrees`, and the `round` function for this.\n+\n+# --hints--\n+You should define a `height` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('height')\n+`))})\n+```\n+\n+Your `height` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('height').has_args('self')\n+`))})\n+```\n+\n+Your `height` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('height').has_decorators('property')\n+`))})\n+```\n+\n+Your `height` method should return the value of the private attribute `__height`.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.height == 23\n+`))})\n+```\n+\n+You should define an `angle` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('angle')\n+`))})\n+```\n+\n+Your `angle` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('angle').has_decorators('property')\n+`))})\n+```\n+\n+Your `angle` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('angle').has_args('self')\n+`))})\n+```\n+\n+Your `angle` method should return the value of the private attribute `__angle` converted to degrees.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.angle == 24\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+--fcc-editable-region--\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+```"
        },
        {
            "sha": "6841ba5771d91dedf28c95bd710c1e0c18045ce2",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475bab40e5125c84b03337.md",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,172 @@\n+---\n+id: 66475bab40e5125c84b03337\n+title: Step 16\n+challengeType: 20\n+dashedName: step-16\n+---\n+\n+# --description--\n+\n+Now that you have the rounded coordinates, find the maximum value between all the x coordinates and the maximum value between all the y coordinates.\n+\n+These max values will be the number of rows and columns in the graph. Save the first in a new variable named `x_max` and the second in a variable named `y_max`.\n+\n+Return `x_max, y_max`.\n+\n+# --hints--\n+\n+The function should return `x_max, y_max`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_class('Graph').find_function('create_trajectory').has_return('x_max, y_max'), \"return x_max, y_max missing\"\n+    `)\n+})\n+```\n+\n+The variable `x_max` should contain the highest x value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert graph.create_trajectory()[0] == round(max(coordinates, key=lambda i: round(i[0]))[0])\n+\n+        `)\n+    }\n+})\n+```\n+\n+The variable `y_max` should contain the highest y value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert graph.create_trajectory()[1] == round(max(coordinates, key=lambda i: round(i[1]))[1])\n+\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        displacement = horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+        return displacement\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        return rounded_coords\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "b9ea0fe21ec83155050358605c83ff08a9e70324",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475d40dd42fb614f14fd03.md",
            "status": "added",
            "additions": 201,
            "deletions": 0,
            "changes": 201,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,201 @@\n+---\n+id: 66475d40dd42fb614f14fd03\n+title: Step 17\n+challengeType: 20\n+dashedName: step-17\n+---\n+\n+# --description--\n+\n+Now that you have `x_max` and `y_max` you can use these as number of rows and columns to start building the graph structure: create a list of lists where the external list contains `y_max` +1 lists, each with inside `x_max` +1 elements, where each element is a string containing a single space.\n+\n+Save this list of lists in a variable named `matrix_list` and return this value.\n+\n+`matrix_list` should look like this:\n+\n+```py\n+[\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+The `create_trajectory` method should return the right value for any instance.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        return x_max, y_max\n+\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "70fb15ef003f144416e3939aae0e2d8a14f106c7",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475e40f3891c645d50135e.md",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,199 @@\n+---\n+id: 66475e40f3891c645d50135e\n+title: Step 19\n+challengeType: 20\n+dashedName: step-19\n+---\n+\n+# --description--\n+\n+`matrix_list` is a list of lists, each element has an `(x, y)` coordinate. Use the list of coordinates in `rounded_coords` to change the elements in `matrix_list` at the coordinates in the list to the symbol in the `PROJECTILE` variable. Remember that a coordinates graph has the `(0, 0)` in the bottom left corner.\n+\n+```py\n+[\n+    [\" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \" \", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \" \", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+The method should return the correct value for different instances.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        return matrix_list\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "49dd62d1c58388faf938ce720da442332b4d02c0",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475f7b91d7c6681987739d.md",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,204 @@\n+---\n+id: 66475f7b91d7c6681987739d\n+title: Step 20\n+challengeType: 20\n+dashedName: step-20\n+---\n+\n+# --description--\n+\n+You have a list of lists of strings. Join the inner lists to have a list of strings.\n+\n+It should look like this:\n+\n+```py\n+[\n+    \"     ∙       \",\n+    \"  ∙∙∙ ∙∙∙    \",\n+    \" ∙       ∙   \",\n+    \"∙         ∙  \",\n+    \"           ∙ \",\n+    \"            ∙\",\n+    \"             \",\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    \"     ∙       \",\n+    \"  ∙∙∙ ∙∙∙    \",\n+    \" ∙       ∙   \",\n+    \"∙         ∙  \",\n+    \"           ∙ \",\n+    \"            ∙\",\n+    \"             \",\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+`create_trajectory()` should calculate the correct output for different instances.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    \"  ∙∙∙∙∙        \",\n+    \"∙∙     ∙       \",\n+    \"        ∙∙     \",\n+    \"          ∙    \",\n+    \"           ∙   \",\n+    \"               \",\n+    \"            ∙  \",\n+    \"             ∙ \",\n+    \"               \",\n+    \"              ∙\",\n+    \"               \",\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for (x, y) in rounded_coords:\n+            matrix_list[-y-1][x] = PROJECTILE\n+\n+        return matrix_list\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "a8c7d3d299897690a7d2d202b8869208db5b1ca7",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/665d949e628d9f3fe305b6e8.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,164 @@\n+---\n+id: 665d949e628d9f3fe305b6e8\n+title: Step 18\n+challengeType: 20\n+dashedName: step-18\n+---\n+\n+# --description--\n+\n+The output is becoming quite difficult to read, so you should replace the `print(graph.create_trajectory())` with a loop that prints each row separately.\n+\n+# --hints--\n+\n+Remove the `print(graph.create_trajectory())` call.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+prnt = _Node(_code).find_calls('print')\n+assert not any(p.is_equivalent('print(graph.create_trajectory())') for p in prnt), \"print still present\"\n+        `)\n+    }\n+})\n+```\n+\n+You should have a loop that iterates over `graph.create_trajectory()`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+iter = _Node(_code).find_for_loops()[0].find_for_iter()\n+assert iter.is_equivalent('graph.create_trajectory()'), \"loop is missing\"\n+        `)\n+    }\n+})\n+```\n+\n+You should print each row in `graph.create_trajectory()`.\n+\n+```js\n+({ test: () => runPython(`\n+loop = _Node(_code).find_for_loops()[0]\n+var = str(loop.find_for_vars())\n+assert loop.find_bodies()[0].has_call(f\"print({var})\")\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        return matrix_list\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+--fcc-editable-region--\n+print(graph.create_trajectory())\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "81d985809714b0ca514f09d38e4b368397ff0bbf",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66601c3c460ee12fbd669d6a.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,164 @@\n+---\n+id: 66601c3c460ee12fbd669d6a\n+title: Step 22\n+challengeType: 20\n+dashedName: step-22\n+---\n+\n+# --description--\n+\n+Now you can remove the loop to print each row of the output, and replace it with `print(graph.create_trajectory())`.\n+\n+# --hints--\n+\n+You should not have a loop in the global scope.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+assert not _Node(_code).find_for_loops(), \"loop still present\"\n+        `)\n+    }\n+})\n+```\n+\n+You should have `print(graph.create_trajectory())`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+prnt = _Node(_code).find_calls('print')\n+assert any(p.is_equivalent('print(graph.create_trajectory())') for p in prnt), \"print not present\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        return matrix_axes\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+--fcc-editable-region--\n+for row in graph.create_trajectory():\n+    print(row)\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "56966b5faea5d838476dfaeb0b5b976bb76333ca",
            "filename": "curriculum/challenges/chinese-traditional/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66671a41b55e531d08ab82b5.md",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese-traditional%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,142 @@\n+---\n+id: 66671a41b55e531d08ab82b5\n+title: Step 11\n+challengeType: 20\n+dashedName: step-11\n+---\n+\n+# --description--\n+\n+The `__str__` method refers to the attributes of the class directly, but now that you have created the getters it is better to use those to obtain those values.\n+\n+Edit the `__str__` method to not reference the attributes anymore, but to use the getters.\n+\n+# --hints--\n+\n+The string representation for `Projectile(45, 45, 45)` should be correct.\n+\n+```js\n+({test: () => assert(runPython(\n+`\n+ball = Projectile(45, 45, 45)\n+str(ball) == \"\"\"\n+Projectile details:\n+speed: 45 m/s\n+height: 45 m\n+angle: 45°\n+displacement: 244.4 m\n+\"\"\"`\n+))})\n+```\n+\n+The string representation should also be correct for other instances.\n+\n+```js\n+({test: () => assert(runPython(`p = Projectile(10, 10, 10)\n+str(\n+    p\n+) == \"\"\"\n+Projectile details:\n+speed: 10 m/s\n+height: 10 m\n+angle: 10°\n+displacement: 15.9 m\n+\"\"\"`))})\n+```\n+\n+You should not be referencing the private properties directly.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    rtrn = str(_Node(_code).find_class('Projectile').find_function('__str__').find_return())\n+    assert not 'self.__angle' in rtrn\n+    assert not 'self.__speed' in rtrn\n+    assert not 'self.__height' in rtrn\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+--fcc-editable-region--    \n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+--fcc-editable-region--\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "abf4a3fbf33486dfa17f944cc8b14021a8a045e7",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65f569725359e10d345bc52a.md",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,75 @@\n+---\n+id: 65f569725359e10d345bc52a\n+title: Step 1\n+challengeType: 20\n+dashedName: step-1\n+---\n+\n+# --description--\n+\n+You are going to build a program that calculates and draws the trajectory of a projectile given the angle, speed and height of the throw.\n+\n+Start by importing `math`, you will use it a lot in this project as it has useful methods like `math.radians`, `math.cos`, `math.sin` and others.\n+\n+Also create these variables to have the value of the gravitational acceleration and some special symbols that will be useful later (use copy and paste for these).\n+\n+```py\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+```\n+\n+# --hints--\n+\n+Use `import math` to import the `math` module.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_import('import math')`))})\n+```\n+\n+You should have a `GRAVITATIONAL_ACCELERATION` variable with value of `9.81`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"GRAVITATIONAL_ACCELERATION\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"GRAVITATIONAL_ACCELERATION\").is_equivalent('GRAVITATIONAL_ACCELERATION = 9.81'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `PROJECTILE` variable with value of `\"∙\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"PROJECTILE\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"PROJECTILE\").is_equivalent('PROJECTILE = \"∙\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `x_axis_tick` variable with value of `\"T\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"x_axis_tick\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"x_axis_tick\").is_equivalent('x_axis_tick = \"T\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `y_axis_tick` variable with value of `\"⊣\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"y_axis_tick\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"y_axis_tick\").is_equivalent('y_axis_tick = \"⊣\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "db286166f195ed43a10e0605bfc4be0fc2f6c69c",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4b3bedee044b4b957d33.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,61 @@\n+---\n+id: 65fd4b3bedee044b4b957d33\n+title: Step 2\n+challengeType: 20\n+dashedName: step-2\n+---\n+\n+# --description--\n+\n+Create a `Projectile` class with an `__init__` method that initializes the class using three arguments: the starting speed, the starting height, and the starting angle of the throw of the projectile, in this order.\n+\n+Inside the `__init__` method, assign these arguments to three private attributes: `__speed`, `__height`, and `__angle`. The angle provided will be in degrees; however, it should be stored internally in radians. To achieve this, use the `math.radians()` function to convert the angle from degrees to radians when assigning it to `__angle`.\n+\n+The use of two underscores before an attribute name triggers name mangling in Python. This means the attributes are not directly accessible from outside the class using their given names, and must be accessed with the mangled names like `ball._Projectile__height` if needed externally, indicating these are intended for internal use only.\n+\n+# --hints--\n+\n+You should use `class Projectile:` to create the class.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_class(\"Projectile\")`))})\n+\n+```\n+\n+You should have an `__init__` method inside the `Projectile` class.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_body().has_function(\"__init__\")`))})\n+```\n+\n+A new `Projectile` class instance should have the values of the three attributes properly initialized.\n+\n+```js\n+({test: () => assert(runPython(`\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+p = Projectile(20, 21, 22)\n+p._Projectile__height == 21 and p._Projectile__speed == 20 and p._Projectile__angle == math.radians(22)\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "b9cd836b59b48f169c5d29a78dac81b1940b204c",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4bd84561a14d3e720061.md",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,48 @@\n+---\n+id: 65fd4bd84561a14d3e720061\n+title: Step 3\n+challengeType: 20\n+dashedName: step-3\n+---\n+\n+# --description--\n+\n+The class variable `__slots__` has a special usage in Python classes. Declaring `__slots__` and assigning it a sequence of strings restricts the creation of attributes to those included in that sequence. Also, it prevents the creation of the `__dict__` special attribute and it allows for more efficient attribute access.\n+\n+You should use the `__slots__` variable inside the class to define which attributes the class has: assign to `__slots__` a tuple containing 3 strings, each equal to one of the attribute names defined in the `__init__`.\n+\n+# --hints--\n+\n+You should assign to `__slots__` a tuple that contains `'__height'`, `'__speed'`, and `'__angle'`.\n+\n+```js\n+({test: () => assert(runPython(`\n+from itertools import permutations\n+slots = _Node(_code).find_class(\"Projectile\").find_body().find_variable(\"__slots__\")\n+perms = permutations((\"__height\", \"__speed\", \"__angle\"))\n+any(slots.is_equivalent(f'__slots__ = {perm}') for perm in perms)\n+`))})\n+\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+--fcc-editable-region--\n+class Projectile:\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "8c5270d99f59f323256adadc87929e55f6123f4c",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660400f02cf3a76795b82d4e.md",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,74 @@\n+---\n+id: 660400f02cf3a76795b82d4e\n+title: Step 4\n+challengeType: 20\n+dashedName: step-4\n+---\n+\n+# --description--\n+\n+The first thing to set up is a method that calculates the displacement of the projectile, which is the horizontal space traveled from the throw to when the projectile touches the ground.\n+\n+Create a method `__calculate_displacement`, which has only `self` as a parameter, and return the displacement of the projectile.\n+\n+Use the following formula to compute the projectile displacement: \\\\[ d = \\frac{v \\cdot \\cos\\theta \\cdot \\left(v\\cdot\\sin\\theta + \\sqrt{v^2\\sin^2\\theta + 2 \\cdot g \\cdot h}\\right)}{g} \\\\]\n+\n+In which $d$ is the displacement, $v$ is the starting speed, $\\theta$ is the angle and $h$ is the starting height of the projectile. For $g$ you can use the `GRAVITATIONAL_ACCELERATION` variable.\n+\n+You should use the methods `math.cos()` and `math.sin()` for the trigonometric functions and `math.sqrt()` to calculate the square root. Also you should know that $x^y$ is written as `x ** y` in python. Also $\\sin^2\\theta$ means that the value resulting from the sine is then squared.\n+\n+Remember that with name mangling you need to call the method as `_Projectile__calculate_displacement` if you want to test, or use it from outside of the class:\n+\n+```py\n+ball = Projectile(10, 3, 45)\n+displacement_of_ball = ball._Projectile__calculate_displacement() # 12.6173996009878\n+```\n+\n+# --hints--\n+\n+You should declare a function called `__calculate_displacement` with `def __calculate_displacement(self):`.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").has_function(\"__calculate_displacement\")`))})\n+```\n+\n+The `__calculate_displacement` method should have only the `self` argument.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_function(\"__calculate_displacement\").has_args('self')`))})\n+```\n+\n+The `__calculate_displacement` method should return the correct value.\n+\n+```js\n+({test: () => assert(runPython(`\n+p = Projectile(20, 21, 22)\n+disp = p._Projectile__calculate_displacement()\n+round(disp, 2) == 55.06 and round(disp, 2) != disp\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "eefd3dc7de816fb5abe2e8953fa8f6d6989ad361",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660fcf3e1b9bb056b2edb567.md",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,120 @@\n+---\n+id: 660fcf3e1b9bb056b2edb567\n+title: Step 5\n+challengeType: 20\n+dashedName: step-5\n+---\n+\n+# --description--\n+\n+At this point you are ready to create the string representation. Start by creating an instance of the `Projectile` class. Below the class definition, create a `ball` variable and assign it a call to `Projectile` using `10, 3, 45` as arguments.\n+\n+Define a `__str__` method within the class, to give your instance a proper string representation, and make it return a string with the following format:\n+\n+```py\n+\n+Projectile details:\n+speed: 10 m/s\n+height: 3 m\n+angle: 45°\n+displacement: 12.6 m\n+\n+```\n+\n+It should start and end with a new line character, the angle has to be written as an integer in degrees and the displacement should be printed with one decimal digit.\n+\n+You will find useful `math.degrees` to convert the angle from radians to degrees.\n+\n+When you are ready you can `print(ball)` to test your function.\n+\n+# --hints--\n+\n+You should have a `ball` variable.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_variable('ball')`))})\n+```\n+\n+The `ball` variable should have a value of `Projectile(10, 3, 45)`.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_variable('ball').is_equivalent('ball = Projectile(10, 3, 45)')`))})\n+```\n+\n+The string representation for `Projectile(45, 45, 45)` should be correct.\n+\n+```js\n+({test: () => assert(runPython(\n+`\n+ball = Projectile(45, 45, 45)\n+str(ball) == \"\"\"\n+Projectile details:\n+speed: 45 m/s\n+height: 45 m\n+angle: 45°\n+displacement: 244.4 m\n+\"\"\"`\n+))})\n+```\n+\n+The string representation should also be correct for other instances.\n+\n+```js\n+({test: () => assert(runPython(`p = Projectile(10, 10, 10)\n+str(\n+    p\n+) == \"\"\"\n+Projectile details:\n+speed: 10 m/s\n+height: 10 m\n+angle: 10°\n+displacement: 15.9 m\n+\"\"\"`))})\n+```\n+\n+You should have a `print(ball)` call.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    calls = _Node(_code).find_calls('print')\n+    assert any(c.is_equivalent('print(ball)') for c in calls)\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "ccfbf71ff43271f6871fdb3cf38d0f2c27675c7f",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6616ec0bf9ee8548ce6b0f08.md",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,109 @@\n+---\n+id: 6616ec0bf9ee8548ce6b0f08\n+title: Step 6\n+challengeType: 20\n+dashedName: step-6\n+---\n+\n+# --description--\n+\n+Now it's time to work on the function to calculate the coordinates of the trajectory! Create a method of the `Projectile` class named `__calculate_y_coordinate`, it should have, other than `self`, an `x` parameter.\n+\n+\\\\[ y = y_0 + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta} \\\\]\n+\n+The above is the formula to calculate the vertical position $y$ for any given horizontal position $x$, having the starting angle $\\theta$, speed $v_0$ and height $y_0$.\n+\n+You will need to use `math.tan()` and `math.cos()` and remember that `x ** y` is the way to write $x^y$, and that the value of $g$ is in the variable `GRAVITATIONAL_ACCELERATION`.\n+\n+Implement the method so that it returns the $y$ coordinate.\n+\n+If you want to test the method, from outside of class, you can call `ball._Projectile__calculate_y_coordinate()` with a number as an argument after `ball` is declared.\n+\n+# --hints--\n+\n+Your `Projectile` class should have a method named `__calculate_y_coordinate`.\n+\n+```js\n+({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').has_function('__calculate_y_coordinate')`))}})\n+```\n+\n+The `__calculate_y_coordinate` method should have `self, x` as arguments.\n+\n+```js\n+({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').find_function('__calculate_y_coordinate').has_args('self, x')`))}})\n+```\n+\n+The method should return the correct value. For `Projectile(12, 12, 12)`, given the 4 $x$ coordinates of 0, 1, 2 and 3, the y coordinate should be approximately 12, 12.18, 12.28, 12.32.\n+\n+```js\n+({test: () => {\n+    assert(runPython(`\n+    a = Projectile(12, 12, 12)\n+    all([round(a._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(0, 12.0), (1, 12.18), (2, 12.28), (3, 12.32)]])\n+    `))\n+}})\n+```\n+\n+The method should return the correct value. For `Projectile(45, 12, 22)`, given the $x$ coordinates of 6, 9, 10 and 12 the y coordinate should be approximately 14.32, 15.41, 15.76, 16.44.\n+\n+```js\n+({test: () => {\n+    assert(runPython(`\n+    b = Projectile(45, 12, 22)\n+    all([round(b._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(6, 14.32), (9, 15.41), (10, 15.76), (12, 16.44)]])\n+    `))\n+}})\n+```\n+\n+The `__calculate_y_coordinate` method should not round the result.\n+\n+```js\n+({test: () => assert.isFalse(runPython(`Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5) == round(Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5), 2)`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    --fcc-editable-region--\n+\n+    --fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+\n+```"
        },
        {
            "sha": "4cff93b9e8f559830239b74ee912725513ce046e",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662f9f65c50bd21d05ffdee9.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,110 @@\n+---\n+id: 662f9f65c50bd21d05ffdee9\n+title: Step 7\n+challengeType: 20\n+dashedName: step-7\n+---\n+\n+# --description--\n+\n+Define a method named `calculate_all_coordinates`, which calculates the coordinates for all \\\\(x\\\\) values from `0` up to the displacement rounded up (not inclusive), and then returns them as a list of tuples `(x, y)`.\n+\n+Then, call the `calculate_all_coordinates` method on the `ball` instance and assign the output to a new variable named `coordinates`.\n+\n+You can use `math.ceil()` to round up a number to the smallest integer greater than or equal to that number.\n+\n+# --hints--\n+\n+You should define a `calculate_all_coordinates` method with a single argument, `self` .\n+\n+```js\n+({test: () => assert(runPython(`\n+c = _Node(_code).find_class('Projectile')\n+c.has_function('calculate_all_coordinates') and c.find_function('calculate_all_coordinates').has_args('self')\n+`))})\n+```\n+\n+You should call the `calculate_all_coordinates` method on `ball` and assign the result to a variable named `coordinates`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+        assert _Node(_code).has_variable('coordinates'), \"coordinates variable is missing\"\n+\n+        assert _Node(_code).find_variable('coordinates').is_equivalent('coordinates = ball.calculate_all_coordinates()'), \"wrong value assigned to coordinates variable\"\n+    `)\n+})\n+```\n+\n+The `calculate_all_coordinates` method should return a list containing all the `(x, y)` coordinates.\n+\n+```js\n+({test: () => assert(runPython(`\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+ball = Projectile(12, 13, 14)\n+expected = [(x, ball._Projectile__calculate_y_coordinate(x)) for x in range(math.ceil(ball._Projectile__calculate_displacement()))]\n+actual = ball.calculate_all_coordinates()\n+expected == actual\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x**2 / (\n+                2 * self.__speed**2 * math.cos(self.__angle)**2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    --fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+   --fcc-editable-region--\n+```"
        },
        {
            "sha": "4bb9cd3ad62b572df845a78672e0b21c3e994443",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fa453ec8033322b3ab2e3.md",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,129 @@\n+---\n+id: 662fa453ec8033322b3ab2e3\n+title: Step 8\n+challengeType: 20\n+dashedName: step-8\n+---\n+\n+# --description--\n+\n+It's time to talk about encapsulation and getters. You have written the three instance attributes to be private using a leading double underscore. Note that these attributes are called private by convention: although they can still be accessed from outside, it is agreed upon to not do that.\n+\n+Getters are what can be used to get the values from outside. To define a getter, you define a method that returns the value of the desired attribute and give it a `@property` decorator:\n+\n+```py\n+class Nest:\n+    ...\n+    @property\n+    def number_of_eggs(self):\n+        return self.__number_of_eggs\n+```\n+\n+ The decorator changes the method into a property, meaning that the method is not called like a regular method, but it's used like an attribute:\n+\n+```py\n+n = Nest()\n+print(n.number_of_eggs)\n+```\n+\n+In the example above, the private attribute `__number of eggs` is accessed through the `number_of_eggs` property of `n`.\n+\n+Create a getter named `speed` and make it return the value of the private attribute `__speed`.\n+\n+# --hints--\n+\n+You should define a `speed` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('speed')\n+`))})\n+```\n+\n+Your `speed` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('speed').has_args('self')\n+`))})\n+```\n+\n+Your `speed` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('speed').has_decorators('property')\n+`))})\n+```\n+\n+Your `speed` method should return the value of the private attribute `__speed`.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.speed == 22\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "2b6b033fce5f1228ea15aa55035d277fee85077f",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fc35902038376c7a00b3c.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,186 @@\n+---\n+id: 662fc35902038376c7a00b3c\n+title: Step 10\n+challengeType: 20\n+dashedName: step-10\n+---\n+\n+# --description--\n+\n+Once you have the getters, you can write the setters, which allow you to set the value of an attribute in an indirect manner. Following the example of the last step, a setter would be written as:\n+\n+```py\n+class Nest:\n+    ...\n+    @number_of_eggs.setter\n+    def number_of_eggs(self, new_value):\n+        self.__number_of_eggs = new_value\n+```\n+\n+Same as the getter, a setter is not called like a method but used like an attribute:\n+\n+```py\n+nest = Nest()\n+nest.number_of_eggs = 12\n+```\n+\n+This way of writing calls the setter and set the new value.\n+\n+For this step you will have to write the setters for the three private attributes. Remember that for the angle the value is received in degrees but saved internally in radians.\n+\n+# --hints--\n+\n+You should define a new `speed` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('speed')) == 2\n+`))})\n+```\n+\n+Your new `speed` method should have a `@speed.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('speed')[1].has_decorators('speed.setter')\n+`))})\n+```\n+\n+Your new `speed` method should set the value of the private `__speed` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.speed = 33\n+a.speed == 33\n+`))})\n+```\n+\n+You should define a new `height` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('height')) == 2\n+`))})\n+```\n+\n+Your new `height` method should have a `@height.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('height')[1].has_decorators('height.setter')\n+`))})\n+```\n+\n+Your new `height` method should set the value of the private `__height` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.height = 44\n+a.height == 44\n+`))})\n+```\n+\n+You should define a new `angle` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('angle')) == 2\n+`))})\n+```\n+\n+Your new `angle` method should have a `@angle.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('angle')[1].has_decorators('angle.setter')\n+`))})\n+```\n+\n+Your `angle` method should set the value of the private `__angle` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.angle = 12\n+a.angle == 12\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "767c9c4f043405d60efeaf03dae28ab119f431dc",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66335223f3e2a31d62d84367.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,203 @@\n+---\n+id: 66335223f3e2a31d62d84367\n+title: Step 13\n+challengeType: 20\n+dashedName: step-13\n+---\n+\n+# --description--\n+\n+Going back to the projectile trajectory calculator, now you'll create a new class that accepts a list of coordinates and creates the trajectory drawing.\n+\n+Create a new class `Graph`, which should be instantiated with a private attribute `__coordinates` where the list of coordinates is stored. Declare the `__slots__` class variable and define the  `__init__` and `__repr__` special methods.\n+\n+Also, create a `Graph` instance passing the `coordinates` variable and assign it to a new `graph` variable.\n+\n+# --hints--\n+\n+You should create a new `Graph` class.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).has_class('Graph')`\n+    ))\n+})\n+```\n+\n+You should have the `__slots__` variable inside the class.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_variable('__slots__')`\n+    ))\n+})\n+```\n+\n+The `__slots__` variable should have a value of `('__coordinates')` or `['__coordinates']`.\n+\n+```js\n+({\n+    test: () => (runPython(\n+        `\n+        slots = _Node(_code).find_class('Graph').find_variable('__slots__')\n+\n+        assert any(slots.is_equivalent(str) for str in ['__slots__ = (\"__coordinates\")', '__slots__ = [\"__coordinates\"]'])`\n+    ))\n+})\n+```\n+\n+You should have an `__init__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('__init__')`\n+    ))\n+})\n+```\n+\n+The `__init__` method should instantiate the `__coordinates` private property with the passed in value.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+        l = [(3, 4), (4, 1), (3, 9)]\n+        g = Graph(l)\n+        g._Graph__coordinates == l\n+        `\n+    ))\n+})\n+```\n+\n+You should have a `__repr__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('__repr__')`\n+    ))\n+})\n+```\n+\n+The `__repr__` method should return the correct string.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+        ball = Projectile(10, 3, 45)\n+        coords = ball.calculate_all_coordinates()\n+        repr(Graph(coords)) == f'Graph({coords})'\n+        `\n+    ))\n+})\n+```\n+\n+You should create a `Graph` instance passing in the `coordinates` variable and assign it to `graph` variable.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+\n+        assert _Node(_code).has_variable('graph'), \"variable graph is missing\"\n+\n+        assert _Node(_code).find_variable('graph').is_equivalent('graph = Graph(coordinates)'), \"assignment to graph is wrong\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f\"{self.__class__.__name__}({self.speed}, {self.height}, {self.angle})\"\n+\n+--fcc-editable-region--\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+--fcc-editable-region-- \n+```"
        },
        {
            "sha": "afe4a4b500557bd25c1732e3b9e0168c51c544b0",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/663353465bfb14259717da93.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,186 @@\n+---\n+id: 663353465bfb14259717da93\n+title: Step 14\n+challengeType: 20\n+dashedName: step-14\n+---\n+\n+# --description--\n+\n+Create a method `create_coordinates_table`, then at the end of the code print `graph.create_coordinates_table())`.\n+\n+The method should use the `__coordinates` property and return a string containing all the coordinates, where x and y have always the same position, the values for x are always integers, and the values for y are always rounded to two decimal places:\n+\n+```py\n+  x      y\n+  0   3.00\n+  1   3.90\n+  2   4.61\n+  3   5.12\n+  4   5.43\n+  5   5.55\n+  6   5.47\n+  7   5.19\n+  8   4.72\n+  9   4.05\n+ 10   3.19\n+ 11   2.13\n+ 12   0.87  \n+```\n+\n+The table should start with a newline character and end with a newline character.\n+\n+# --hints--\n+\n+You should have a `create_coordinates_table()` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('create_coordinates_table')`\n+    ))\n+})\n+```\n+\n+The method should return the correct output.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `str = \"\"\"\n+  x      y\n+  0   3.00\n+  1   3.90\n+  2   4.61\n+  3   5.12\n+  4   5.43\n+  5   5.55\n+  6   5.47\n+  7   5.19\n+  8   4.72\n+  9   4.05\n+ 10   3.19\n+ 11   2.13\n+ 12   0.87\n+\"\"\"\n+ball = Projectile(10, 3, 45)\n+g = Graph(ball.calculate_all_coordinates())\n+g.create_coordinates_table() == str`\n+    ))\n+})\n+```\n+\n+You should print `graph.create_coordiantes_table()`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+        prints = _Node(_code).find_calls('print')\n+        assert any(p.is_equivalent('print(graph.create_coordinates_table())') for p in prints), \"print(graph.create_coordiantes_table()) is missing\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f'Graph({self.__coordinates})'\n+\n+--fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+graph = Graph(coordinates)\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "a86e8fab60b1753ae08a7c20d1251e34a4d1263a",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b26c4f2d603072ef0818.md",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,136 @@\n+---\n+id: 6633b26c4f2d603072ef0818\n+title: Step 12\n+challengeType: 20\n+dashedName: step-12\n+---\n+\n+# --description--\n+\n+It's good practice to give a representation to the class by using the `__repr__` special method. While the `__str__` method returns a readable string representation that's intended to be user friendly, `__repr__` is intended for programmers. Often `__repr__` provides a string that can be used to recreate the object.\n+\n+Write the `__repr__` method, which will return the string needed to instantiate the object.\n+\n+You can test this by calling the `repr` function and passing it an instance of the class.\n+\n+# --hints--\n+\n+The `Projectile` class should have a `__repr__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Projectile').has_function('__repr__')`\n+    ))\n+})\n+```\n+\n+The instance `Projectile(12, 12, 12)` should have representation equal to `'Projectile(12, 12, 12)'`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `repr(Projectile(12, 12, 12)) == 'Projectile(12, 12, 12)' or \\\\\n+        repr(Projectile(12, 12, 12)) == 'Projectile(12, 12, 12.0)'`\n+    ))\n+})\n+```\n+\n+The instance `Projectile(21, 22, 45)` should have representation equal to `'Projectile(21, 22, 45)'`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `repr(Projectile(21, 22, 45)) == 'Projectile(21, 22, 45)' or \\\\\n+        repr(Projectile(21, 22, 45)) == 'Projectile(21, 22, 45.0)'`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+```"
        },
        {
            "sha": "b0ba04423b9d0981453df5445f4ce8e61a4831e1",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b4d3271d5b3aea1c1195.md",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,173 @@\n+---\n+id: 6633b4d3271d5b3aea1c1195\n+title: Step 15\n+challengeType: 20\n+dashedName: step-15\n+---\n+\n+# --description--\n+\n+Now it's time for the graph. Create a method `create_trajectory` and replace the last `print` call at the bottom of your code with `print(graph.create_trajectory())`.\n+\n+As the first step of this new function, make a local copy of the coordinates but where all the values are rounded to integers. Save this new version of the coordinates in a variable named `rounded_coords`, and return this variable.\n+\n+# --hints--\n+\n+You should define a method named `create_trajectory`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('create_trajectory')`\n+    ))\n+})\n+```\n+\n+You should replace `print(graph.create_coordinates_table())` with `print(graph.create_trajectory())`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    prints = _Node(_code).find_calls('print')\n+\n+    assert all(not p.is_equivalent('print(graph.create_coordinates_table())') for p in prints), \"print(graph.create_coordinates_table()) should not be present\"\n+\n+    assert any(p.is_equivalent('print(graph.create_trajectory())') for p in prints), \"print(graph.create_trajectory()) not found\"\n+    `)\n+})\n+```\n+\n+The function should return `rounded_coords`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_class('Graph').find_function('create_trajectory').has_return('rounded_coords'), \"return rounded_coords missing\"\n+    `)\n+})\n+```\n+\n+The `rounded_coords` variable should contain the rounded coordinates.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert [(round(x), round(y)) for x,y in coordinates] == graph.create_trajectory(), \"coordinates are not rounded correctly\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_coordinates_table())\n+\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "af06d95e150d51f5cea0544a8cf49d51fef094b3",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bdc3ca38c068c3735984.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,203 @@\n+---\n+id: 6633bdc3ca38c068c3735984\n+title: Step 21\n+challengeType: 20\n+dashedName: step-21\n+---\n+\n+# --description--\n+\n+Add the x and y axes to the graph to obtain the following output:\n+\n+```py\n+[\n+    \"⊣     ∙       \",\n+    \"⊣  ∙∙∙ ∙∙∙    \",\n+    \"⊣ ∙       ∙   \",\n+    \"⊣∙         ∙  \",\n+    \"⊣           ∙ \",\n+    \"⊣            ∙\",\n+    \"⊣             \",\n+    \" TTTTTTTTTTTTT\",\n+]\n+```\n+\n+The symbols are available as `x_axis_tick` and `y_axis_tick`.\n+\n+# --hints--\n+\n+The method should return the correct output.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+gr = [\n+    \"⊣     ∙       \",\n+    \"⊣  ∙∙∙ ∙∙∙    \",\n+    \"⊣ ∙       ∙   \",\n+    \"⊣∙         ∙  \",\n+    \"⊣           ∙ \",\n+    \"⊣            ∙\",\n+    \"⊣             \",\n+    \" TTTTTTTTTTTTT\",\n+]\n+ball = Projectile(10, 3, 45)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+g.create_trajectory() == gr`\n+    ))\n+})\n+```\n+\n+The method should return the correct output for different instances.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+gr = [\n+    \"⊣     ∙∙             \",\n+    \"⊣ ∙∙∙∙  ∙∙∙          \",\n+    \"⊣∙         ∙∙        \",\n+    \"⊣            ∙       \",\n+    \"⊣             ∙      \",\n+    \"⊣              ∙     \",\n+    \"⊣               ∙    \",\n+    \"⊣                ∙   \",\n+    \"⊣                 ∙  \",\n+    \"⊣                  ∙ \",\n+    \"⊣                    \",\n+    \"⊣                   ∙\",\n+    \" TTTTTTTTTTTTTTTTTTTT\",\n+]\n+ball = Projectile(11, 9, 30)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+g.create_trajectory() == gr`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        return matrix\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "3d29b59fbfd71f58386bc322cb68fd7e29811389",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bfcef57e1d70cc3142c6.md",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,167 @@\n+---\n+id: 6633bfcef57e1d70cc3142c6\n+title: Step 23\n+challengeType: 20\n+dashedName: step-23\n+---\n+\n+# --description--\n+\n+Finally, make the final output a multiline string. It should start with a newline character and end with a newline character.\n+\n+```py\n+\n+⊣     ∙       \n+⊣  ∙∙∙ ∙∙∙    \n+⊣ ∙       ∙   \n+⊣∙         ∙  \n+⊣           ∙ \n+⊣            ∙\n+⊣             \n+ TTTTTTTTTTTTT\n+\n+```\n+\n+# --hints--\n+\n+The method should return the correct string.\n+\n+```js\n+({\n+    test: () => (runPython(\n+        `gr = '\\\\n⊣     ∙       \\\\n⊣  ∙∙∙ ∙∙∙    \\\\n⊣ ∙       ∙   \\\\n⊣∙         ∙  \\\\n⊣           ∙ \\\\n⊣            ∙\\\\n⊣             \\\\n TTTTTTTTTTTTT\\\\n'\n+ball = Projectile(10, 3, 45)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+actual = g.create_trajectory()\n+expected = gr\n+assert actual == expected, f'expected {repr(expected)} but found {repr(actual)}'`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        return matrix_axes\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "c3fbb93afa003c93fc3ca6b1fe4c509cb1448866",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633c06601c081735063b528.md",
            "status": "added",
            "additions": 329,
            "deletions": 0,
            "changes": 329,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,329 @@\n+---\n+id: 6633c06601c081735063b528\n+title: Step 24\n+challengeType: 20\n+dashedName: step-24\n+---\n+\n+# --description--\n+\n+You have built a projectile trajectory calculator.\n+\n+Now to conclude, modify the code you wrote outside the classes, and incorporate it into a little utility function called `projectile_helper` that takes in the desired values for speed, height and angle and prints to the terminal in sequence, the details of the projectile, the table of coordinates and the graph of the trajectory.\n+\n+Call `projectile_helper` once with values of your choice.\n+\n+# --hints--\n+\n+You should create `projectile_helper` in the global scope.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).has_function('projectile_helper')    \n+    `)\n+})\n+```\n+\n+You should print the requested strings in order. Do not print other values.\n+\n+```js\n+({\n+    test: () => {\n+        let code_ = code.replaceAll('print(', '__result.append(')\n+\n+        runPython(`\n+__result = []\n+${code_}\n+__result = [] # code_ includes a call, so let's reset it here\n+projectile_helper(12, 13, 14)\n+bullet = Projectile(12, 13, 14)\n+assert str(__result[0]) == str(bullet)\n+c = bullet.calculate_all_coordinates()\n+g = Graph(c)\n+assert __result[1] == g.create_coordinates_table()\n+assert __result[2] == g.create_trajectory()\n+        `)\n+    }\n+})\n+```\n+\n+You should call the `projectile_helper` function at least once.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert len(_Node(_code).find_calls('projectile_helper')) > 0\n+    `)\n+})\n+```\n+\n+You should not have variables or print calls in the global scope.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_calls('print') == [], \"found print\"\n+    assert not _Node(_code).has_variable('graph'), \"found graph\"\n+    assert not _Node(_code).has_variable('ball'), \"found ball\"\n+    assert not _Node(_code).has_variable('coordinates'), \"found coordinates\"\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        graph = \"\\n\" + \"\\n\".join(matrix_axes) + \"\\n\"\n+\n+        return graph\n+\n+--fcc-editable-region--\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+--fcc-editable-region--\n+```\n+\n+# --solutions--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def __str__(self):\n+        return self.create_trajectory()\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        graph = \"\\n\" + \"\\n\".join(matrix_axes) + \"\\n\"\n+\n+        return graph\n+\n+def projectile_helper(speed, height, angle):\n+    p = Projectile(speed, height, angle)\n+    print(p)\n+    coord = p.calculate_all_coordinates()\n+    g = Graph(coord)\n+    print(g.create_coordinates_table())\n+    print(g.create_trajectory())\n+\n+projectile_helper(12, 43, 1)\n+\n+```"
        },
        {
            "sha": "7a5dc5ce39e5eba44b6d2e35b025007821bba047",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6634fa2417d7194b0c9425f9.md",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,145 @@\n+---\n+id: 6634fa2417d7194b0c9425f9\n+title: Step 9\n+challengeType: 20\n+dashedName: step-9\n+---\n+\n+# --description--\n+\n+Now create the two getters for `__height` and `__angle`. Remember that for the angle, the value is given to the class in degrees, but is saved internally in radians, so have the getter return the degrees value. You can use `math.degrees`, and the `round` function for this.\n+\n+# --hints--\n+You should define a `height` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('height')\n+`))})\n+```\n+\n+Your `height` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('height').has_args('self')\n+`))})\n+```\n+\n+Your `height` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('height').has_decorators('property')\n+`))})\n+```\n+\n+Your `height` method should return the value of the private attribute `__height`.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.height == 23\n+`))})\n+```\n+\n+You should define an `angle` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('angle')\n+`))})\n+```\n+\n+Your `angle` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('angle').has_decorators('property')\n+`))})\n+```\n+\n+Your `angle` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('angle').has_args('self')\n+`))})\n+```\n+\n+Your `angle` method should return the value of the private attribute `__angle` converted to degrees.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.angle == 24\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+--fcc-editable-region--\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+```"
        },
        {
            "sha": "6841ba5771d91dedf28c95bd710c1e0c18045ce2",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475bab40e5125c84b03337.md",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,172 @@\n+---\n+id: 66475bab40e5125c84b03337\n+title: Step 16\n+challengeType: 20\n+dashedName: step-16\n+---\n+\n+# --description--\n+\n+Now that you have the rounded coordinates, find the maximum value between all the x coordinates and the maximum value between all the y coordinates.\n+\n+These max values will be the number of rows and columns in the graph. Save the first in a new variable named `x_max` and the second in a variable named `y_max`.\n+\n+Return `x_max, y_max`.\n+\n+# --hints--\n+\n+The function should return `x_max, y_max`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_class('Graph').find_function('create_trajectory').has_return('x_max, y_max'), \"return x_max, y_max missing\"\n+    `)\n+})\n+```\n+\n+The variable `x_max` should contain the highest x value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert graph.create_trajectory()[0] == round(max(coordinates, key=lambda i: round(i[0]))[0])\n+\n+        `)\n+    }\n+})\n+```\n+\n+The variable `y_max` should contain the highest y value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert graph.create_trajectory()[1] == round(max(coordinates, key=lambda i: round(i[1]))[1])\n+\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        displacement = horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+        return displacement\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        return rounded_coords\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "b9ea0fe21ec83155050358605c83ff08a9e70324",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475d40dd42fb614f14fd03.md",
            "status": "added",
            "additions": 201,
            "deletions": 0,
            "changes": 201,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,201 @@\n+---\n+id: 66475d40dd42fb614f14fd03\n+title: Step 17\n+challengeType: 20\n+dashedName: step-17\n+---\n+\n+# --description--\n+\n+Now that you have `x_max` and `y_max` you can use these as number of rows and columns to start building the graph structure: create a list of lists where the external list contains `y_max` +1 lists, each with inside `x_max` +1 elements, where each element is a string containing a single space.\n+\n+Save this list of lists in a variable named `matrix_list` and return this value.\n+\n+`matrix_list` should look like this:\n+\n+```py\n+[\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+The `create_trajectory` method should return the right value for any instance.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        return x_max, y_max\n+\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "70fb15ef003f144416e3939aae0e2d8a14f106c7",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475e40f3891c645d50135e.md",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,199 @@\n+---\n+id: 66475e40f3891c645d50135e\n+title: Step 19\n+challengeType: 20\n+dashedName: step-19\n+---\n+\n+# --description--\n+\n+`matrix_list` is a list of lists, each element has an `(x, y)` coordinate. Use the list of coordinates in `rounded_coords` to change the elements in `matrix_list` at the coordinates in the list to the symbol in the `PROJECTILE` variable. Remember that a coordinates graph has the `(0, 0)` in the bottom left corner.\n+\n+```py\n+[\n+    [\" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \" \", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \" \", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+The method should return the correct value for different instances.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        return matrix_list\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "49dd62d1c58388faf938ce720da442332b4d02c0",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475f7b91d7c6681987739d.md",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,204 @@\n+---\n+id: 66475f7b91d7c6681987739d\n+title: Step 20\n+challengeType: 20\n+dashedName: step-20\n+---\n+\n+# --description--\n+\n+You have a list of lists of strings. Join the inner lists to have a list of strings.\n+\n+It should look like this:\n+\n+```py\n+[\n+    \"     ∙       \",\n+    \"  ∙∙∙ ∙∙∙    \",\n+    \" ∙       ∙   \",\n+    \"∙         ∙  \",\n+    \"           ∙ \",\n+    \"            ∙\",\n+    \"             \",\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    \"     ∙       \",\n+    \"  ∙∙∙ ∙∙∙    \",\n+    \" ∙       ∙   \",\n+    \"∙         ∙  \",\n+    \"           ∙ \",\n+    \"            ∙\",\n+    \"             \",\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+`create_trajectory()` should calculate the correct output for different instances.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    \"  ∙∙∙∙∙        \",\n+    \"∙∙     ∙       \",\n+    \"        ∙∙     \",\n+    \"          ∙    \",\n+    \"           ∙   \",\n+    \"               \",\n+    \"            ∙  \",\n+    \"             ∙ \",\n+    \"               \",\n+    \"              ∙\",\n+    \"               \",\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for (x, y) in rounded_coords:\n+            matrix_list[-y-1][x] = PROJECTILE\n+\n+        return matrix_list\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "a8c7d3d299897690a7d2d202b8869208db5b1ca7",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/665d949e628d9f3fe305b6e8.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,164 @@\n+---\n+id: 665d949e628d9f3fe305b6e8\n+title: Step 18\n+challengeType: 20\n+dashedName: step-18\n+---\n+\n+# --description--\n+\n+The output is becoming quite difficult to read, so you should replace the `print(graph.create_trajectory())` with a loop that prints each row separately.\n+\n+# --hints--\n+\n+Remove the `print(graph.create_trajectory())` call.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+prnt = _Node(_code).find_calls('print')\n+assert not any(p.is_equivalent('print(graph.create_trajectory())') for p in prnt), \"print still present\"\n+        `)\n+    }\n+})\n+```\n+\n+You should have a loop that iterates over `graph.create_trajectory()`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+iter = _Node(_code).find_for_loops()[0].find_for_iter()\n+assert iter.is_equivalent('graph.create_trajectory()'), \"loop is missing\"\n+        `)\n+    }\n+})\n+```\n+\n+You should print each row in `graph.create_trajectory()`.\n+\n+```js\n+({ test: () => runPython(`\n+loop = _Node(_code).find_for_loops()[0]\n+var = str(loop.find_for_vars())\n+assert loop.find_bodies()[0].has_call(f\"print({var})\")\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        return matrix_list\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+--fcc-editable-region--\n+print(graph.create_trajectory())\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "81d985809714b0ca514f09d38e4b368397ff0bbf",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66601c3c460ee12fbd669d6a.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,164 @@\n+---\n+id: 66601c3c460ee12fbd669d6a\n+title: Step 22\n+challengeType: 20\n+dashedName: step-22\n+---\n+\n+# --description--\n+\n+Now you can remove the loop to print each row of the output, and replace it with `print(graph.create_trajectory())`.\n+\n+# --hints--\n+\n+You should not have a loop in the global scope.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+assert not _Node(_code).find_for_loops(), \"loop still present\"\n+        `)\n+    }\n+})\n+```\n+\n+You should have `print(graph.create_trajectory())`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+prnt = _Node(_code).find_calls('print')\n+assert any(p.is_equivalent('print(graph.create_trajectory())') for p in prnt), \"print not present\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        return matrix_axes\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+--fcc-editable-region--\n+for row in graph.create_trajectory():\n+    print(row)\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "56966b5faea5d838476dfaeb0b5b976bb76333ca",
            "filename": "curriculum/challenges/chinese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66671a41b55e531d08ab82b5.md",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fchinese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,142 @@\n+---\n+id: 66671a41b55e531d08ab82b5\n+title: Step 11\n+challengeType: 20\n+dashedName: step-11\n+---\n+\n+# --description--\n+\n+The `__str__` method refers to the attributes of the class directly, but now that you have created the getters it is better to use those to obtain those values.\n+\n+Edit the `__str__` method to not reference the attributes anymore, but to use the getters.\n+\n+# --hints--\n+\n+The string representation for `Projectile(45, 45, 45)` should be correct.\n+\n+```js\n+({test: () => assert(runPython(\n+`\n+ball = Projectile(45, 45, 45)\n+str(ball) == \"\"\"\n+Projectile details:\n+speed: 45 m/s\n+height: 45 m\n+angle: 45°\n+displacement: 244.4 m\n+\"\"\"`\n+))})\n+```\n+\n+The string representation should also be correct for other instances.\n+\n+```js\n+({test: () => assert(runPython(`p = Projectile(10, 10, 10)\n+str(\n+    p\n+) == \"\"\"\n+Projectile details:\n+speed: 10 m/s\n+height: 10 m\n+angle: 10°\n+displacement: 15.9 m\n+\"\"\"`))})\n+```\n+\n+You should not be referencing the private properties directly.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    rtrn = str(_Node(_code).find_class('Projectile').find_function('__str__').find_return())\n+    assert not 'self.__angle' in rtrn\n+    assert not 'self.__speed' in rtrn\n+    assert not 'self.__height' in rtrn\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+--fcc-editable-region--    \n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+--fcc-editable-region--\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "abf4a3fbf33486dfa17f944cc8b14021a8a045e7",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65f569725359e10d345bc52a.md",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,75 @@\n+---\n+id: 65f569725359e10d345bc52a\n+title: Step 1\n+challengeType: 20\n+dashedName: step-1\n+---\n+\n+# --description--\n+\n+You are going to build a program that calculates and draws the trajectory of a projectile given the angle, speed and height of the throw.\n+\n+Start by importing `math`, you will use it a lot in this project as it has useful methods like `math.radians`, `math.cos`, `math.sin` and others.\n+\n+Also create these variables to have the value of the gravitational acceleration and some special symbols that will be useful later (use copy and paste for these).\n+\n+```py\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+```\n+\n+# --hints--\n+\n+Use `import math` to import the `math` module.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_import('import math')`))})\n+```\n+\n+You should have a `GRAVITATIONAL_ACCELERATION` variable with value of `9.81`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"GRAVITATIONAL_ACCELERATION\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"GRAVITATIONAL_ACCELERATION\").is_equivalent('GRAVITATIONAL_ACCELERATION = 9.81'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `PROJECTILE` variable with value of `\"∙\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"PROJECTILE\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"PROJECTILE\").is_equivalent('PROJECTILE = \"∙\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `x_axis_tick` variable with value of `\"T\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"x_axis_tick\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"x_axis_tick\").is_equivalent('x_axis_tick = \"T\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `y_axis_tick` variable with value of `\"⊣\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"y_axis_tick\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"y_axis_tick\").is_equivalent('y_axis_tick = \"⊣\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "db286166f195ed43a10e0605bfc4be0fc2f6c69c",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4b3bedee044b4b957d33.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,61 @@\n+---\n+id: 65fd4b3bedee044b4b957d33\n+title: Step 2\n+challengeType: 20\n+dashedName: step-2\n+---\n+\n+# --description--\n+\n+Create a `Projectile` class with an `__init__` method that initializes the class using three arguments: the starting speed, the starting height, and the starting angle of the throw of the projectile, in this order.\n+\n+Inside the `__init__` method, assign these arguments to three private attributes: `__speed`, `__height`, and `__angle`. The angle provided will be in degrees; however, it should be stored internally in radians. To achieve this, use the `math.radians()` function to convert the angle from degrees to radians when assigning it to `__angle`.\n+\n+The use of two underscores before an attribute name triggers name mangling in Python. This means the attributes are not directly accessible from outside the class using their given names, and must be accessed with the mangled names like `ball._Projectile__height` if needed externally, indicating these are intended for internal use only.\n+\n+# --hints--\n+\n+You should use `class Projectile:` to create the class.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_class(\"Projectile\")`))})\n+\n+```\n+\n+You should have an `__init__` method inside the `Projectile` class.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_body().has_function(\"__init__\")`))})\n+```\n+\n+A new `Projectile` class instance should have the values of the three attributes properly initialized.\n+\n+```js\n+({test: () => assert(runPython(`\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+p = Projectile(20, 21, 22)\n+p._Projectile__height == 21 and p._Projectile__speed == 20 and p._Projectile__angle == math.radians(22)\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "b9cd836b59b48f169c5d29a78dac81b1940b204c",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4bd84561a14d3e720061.md",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,48 @@\n+---\n+id: 65fd4bd84561a14d3e720061\n+title: Step 3\n+challengeType: 20\n+dashedName: step-3\n+---\n+\n+# --description--\n+\n+The class variable `__slots__` has a special usage in Python classes. Declaring `__slots__` and assigning it a sequence of strings restricts the creation of attributes to those included in that sequence. Also, it prevents the creation of the `__dict__` special attribute and it allows for more efficient attribute access.\n+\n+You should use the `__slots__` variable inside the class to define which attributes the class has: assign to `__slots__` a tuple containing 3 strings, each equal to one of the attribute names defined in the `__init__`.\n+\n+# --hints--\n+\n+You should assign to `__slots__` a tuple that contains `'__height'`, `'__speed'`, and `'__angle'`.\n+\n+```js\n+({test: () => assert(runPython(`\n+from itertools import permutations\n+slots = _Node(_code).find_class(\"Projectile\").find_body().find_variable(\"__slots__\")\n+perms = permutations((\"__height\", \"__speed\", \"__angle\"))\n+any(slots.is_equivalent(f'__slots__ = {perm}') for perm in perms)\n+`))})\n+\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+--fcc-editable-region--\n+class Projectile:\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "8c5270d99f59f323256adadc87929e55f6123f4c",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660400f02cf3a76795b82d4e.md",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,74 @@\n+---\n+id: 660400f02cf3a76795b82d4e\n+title: Step 4\n+challengeType: 20\n+dashedName: step-4\n+---\n+\n+# --description--\n+\n+The first thing to set up is a method that calculates the displacement of the projectile, which is the horizontal space traveled from the throw to when the projectile touches the ground.\n+\n+Create a method `__calculate_displacement`, which has only `self` as a parameter, and return the displacement of the projectile.\n+\n+Use the following formula to compute the projectile displacement: \\\\[ d = \\frac{v \\cdot \\cos\\theta \\cdot \\left(v\\cdot\\sin\\theta + \\sqrt{v^2\\sin^2\\theta + 2 \\cdot g \\cdot h}\\right)}{g} \\\\]\n+\n+In which $d$ is the displacement, $v$ is the starting speed, $\\theta$ is the angle and $h$ is the starting height of the projectile. For $g$ you can use the `GRAVITATIONAL_ACCELERATION` variable.\n+\n+You should use the methods `math.cos()` and `math.sin()` for the trigonometric functions and `math.sqrt()` to calculate the square root. Also you should know that $x^y$ is written as `x ** y` in python. Also $\\sin^2\\theta$ means that the value resulting from the sine is then squared.\n+\n+Remember that with name mangling you need to call the method as `_Projectile__calculate_displacement` if you want to test, or use it from outside of the class:\n+\n+```py\n+ball = Projectile(10, 3, 45)\n+displacement_of_ball = ball._Projectile__calculate_displacement() # 12.6173996009878\n+```\n+\n+# --hints--\n+\n+You should declare a function called `__calculate_displacement` with `def __calculate_displacement(self):`.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").has_function(\"__calculate_displacement\")`))})\n+```\n+\n+The `__calculate_displacement` method should have only the `self` argument.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_function(\"__calculate_displacement\").has_args('self')`))})\n+```\n+\n+The `__calculate_displacement` method should return the correct value.\n+\n+```js\n+({test: () => assert(runPython(`\n+p = Projectile(20, 21, 22)\n+disp = p._Projectile__calculate_displacement()\n+round(disp, 2) == 55.06 and round(disp, 2) != disp\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "eefd3dc7de816fb5abe2e8953fa8f6d6989ad361",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660fcf3e1b9bb056b2edb567.md",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,120 @@\n+---\n+id: 660fcf3e1b9bb056b2edb567\n+title: Step 5\n+challengeType: 20\n+dashedName: step-5\n+---\n+\n+# --description--\n+\n+At this point you are ready to create the string representation. Start by creating an instance of the `Projectile` class. Below the class definition, create a `ball` variable and assign it a call to `Projectile` using `10, 3, 45` as arguments.\n+\n+Define a `__str__` method within the class, to give your instance a proper string representation, and make it return a string with the following format:\n+\n+```py\n+\n+Projectile details:\n+speed: 10 m/s\n+height: 3 m\n+angle: 45°\n+displacement: 12.6 m\n+\n+```\n+\n+It should start and end with a new line character, the angle has to be written as an integer in degrees and the displacement should be printed with one decimal digit.\n+\n+You will find useful `math.degrees` to convert the angle from radians to degrees.\n+\n+When you are ready you can `print(ball)` to test your function.\n+\n+# --hints--\n+\n+You should have a `ball` variable.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_variable('ball')`))})\n+```\n+\n+The `ball` variable should have a value of `Projectile(10, 3, 45)`.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_variable('ball').is_equivalent('ball = Projectile(10, 3, 45)')`))})\n+```\n+\n+The string representation for `Projectile(45, 45, 45)` should be correct.\n+\n+```js\n+({test: () => assert(runPython(\n+`\n+ball = Projectile(45, 45, 45)\n+str(ball) == \"\"\"\n+Projectile details:\n+speed: 45 m/s\n+height: 45 m\n+angle: 45°\n+displacement: 244.4 m\n+\"\"\"`\n+))})\n+```\n+\n+The string representation should also be correct for other instances.\n+\n+```js\n+({test: () => assert(runPython(`p = Projectile(10, 10, 10)\n+str(\n+    p\n+) == \"\"\"\n+Projectile details:\n+speed: 10 m/s\n+height: 10 m\n+angle: 10°\n+displacement: 15.9 m\n+\"\"\"`))})\n+```\n+\n+You should have a `print(ball)` call.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    calls = _Node(_code).find_calls('print')\n+    assert any(c.is_equivalent('print(ball)') for c in calls)\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "ccfbf71ff43271f6871fdb3cf38d0f2c27675c7f",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6616ec0bf9ee8548ce6b0f08.md",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,109 @@\n+---\n+id: 6616ec0bf9ee8548ce6b0f08\n+title: Step 6\n+challengeType: 20\n+dashedName: step-6\n+---\n+\n+# --description--\n+\n+Now it's time to work on the function to calculate the coordinates of the trajectory! Create a method of the `Projectile` class named `__calculate_y_coordinate`, it should have, other than `self`, an `x` parameter.\n+\n+\\\\[ y = y_0 + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta} \\\\]\n+\n+The above is the formula to calculate the vertical position $y$ for any given horizontal position $x$, having the starting angle $\\theta$, speed $v_0$ and height $y_0$.\n+\n+You will need to use `math.tan()` and `math.cos()` and remember that `x ** y` is the way to write $x^y$, and that the value of $g$ is in the variable `GRAVITATIONAL_ACCELERATION`.\n+\n+Implement the method so that it returns the $y$ coordinate.\n+\n+If you want to test the method, from outside of class, you can call `ball._Projectile__calculate_y_coordinate()` with a number as an argument after `ball` is declared.\n+\n+# --hints--\n+\n+Your `Projectile` class should have a method named `__calculate_y_coordinate`.\n+\n+```js\n+({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').has_function('__calculate_y_coordinate')`))}})\n+```\n+\n+The `__calculate_y_coordinate` method should have `self, x` as arguments.\n+\n+```js\n+({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').find_function('__calculate_y_coordinate').has_args('self, x')`))}})\n+```\n+\n+The method should return the correct value. For `Projectile(12, 12, 12)`, given the 4 $x$ coordinates of 0, 1, 2 and 3, the y coordinate should be approximately 12, 12.18, 12.28, 12.32.\n+\n+```js\n+({test: () => {\n+    assert(runPython(`\n+    a = Projectile(12, 12, 12)\n+    all([round(a._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(0, 12.0), (1, 12.18), (2, 12.28), (3, 12.32)]])\n+    `))\n+}})\n+```\n+\n+The method should return the correct value. For `Projectile(45, 12, 22)`, given the $x$ coordinates of 6, 9, 10 and 12 the y coordinate should be approximately 14.32, 15.41, 15.76, 16.44.\n+\n+```js\n+({test: () => {\n+    assert(runPython(`\n+    b = Projectile(45, 12, 22)\n+    all([round(b._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(6, 14.32), (9, 15.41), (10, 15.76), (12, 16.44)]])\n+    `))\n+}})\n+```\n+\n+The `__calculate_y_coordinate` method should not round the result.\n+\n+```js\n+({test: () => assert.isFalse(runPython(`Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5) == round(Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5), 2)`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    --fcc-editable-region--\n+\n+    --fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+\n+```"
        },
        {
            "sha": "4cff93b9e8f559830239b74ee912725513ce046e",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662f9f65c50bd21d05ffdee9.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,110 @@\n+---\n+id: 662f9f65c50bd21d05ffdee9\n+title: Step 7\n+challengeType: 20\n+dashedName: step-7\n+---\n+\n+# --description--\n+\n+Define a method named `calculate_all_coordinates`, which calculates the coordinates for all \\\\(x\\\\) values from `0` up to the displacement rounded up (not inclusive), and then returns them as a list of tuples `(x, y)`.\n+\n+Then, call the `calculate_all_coordinates` method on the `ball` instance and assign the output to a new variable named `coordinates`.\n+\n+You can use `math.ceil()` to round up a number to the smallest integer greater than or equal to that number.\n+\n+# --hints--\n+\n+You should define a `calculate_all_coordinates` method with a single argument, `self` .\n+\n+```js\n+({test: () => assert(runPython(`\n+c = _Node(_code).find_class('Projectile')\n+c.has_function('calculate_all_coordinates') and c.find_function('calculate_all_coordinates').has_args('self')\n+`))})\n+```\n+\n+You should call the `calculate_all_coordinates` method on `ball` and assign the result to a variable named `coordinates`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+        assert _Node(_code).has_variable('coordinates'), \"coordinates variable is missing\"\n+\n+        assert _Node(_code).find_variable('coordinates').is_equivalent('coordinates = ball.calculate_all_coordinates()'), \"wrong value assigned to coordinates variable\"\n+    `)\n+})\n+```\n+\n+The `calculate_all_coordinates` method should return a list containing all the `(x, y)` coordinates.\n+\n+```js\n+({test: () => assert(runPython(`\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+ball = Projectile(12, 13, 14)\n+expected = [(x, ball._Projectile__calculate_y_coordinate(x)) for x in range(math.ceil(ball._Projectile__calculate_displacement()))]\n+actual = ball.calculate_all_coordinates()\n+expected == actual\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x**2 / (\n+                2 * self.__speed**2 * math.cos(self.__angle)**2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    --fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+   --fcc-editable-region--\n+```"
        },
        {
            "sha": "4bb9cd3ad62b572df845a78672e0b21c3e994443",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fa453ec8033322b3ab2e3.md",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,129 @@\n+---\n+id: 662fa453ec8033322b3ab2e3\n+title: Step 8\n+challengeType: 20\n+dashedName: step-8\n+---\n+\n+# --description--\n+\n+It's time to talk about encapsulation and getters. You have written the three instance attributes to be private using a leading double underscore. Note that these attributes are called private by convention: although they can still be accessed from outside, it is agreed upon to not do that.\n+\n+Getters are what can be used to get the values from outside. To define a getter, you define a method that returns the value of the desired attribute and give it a `@property` decorator:\n+\n+```py\n+class Nest:\n+    ...\n+    @property\n+    def number_of_eggs(self):\n+        return self.__number_of_eggs\n+```\n+\n+ The decorator changes the method into a property, meaning that the method is not called like a regular method, but it's used like an attribute:\n+\n+```py\n+n = Nest()\n+print(n.number_of_eggs)\n+```\n+\n+In the example above, the private attribute `__number of eggs` is accessed through the `number_of_eggs` property of `n`.\n+\n+Create a getter named `speed` and make it return the value of the private attribute `__speed`.\n+\n+# --hints--\n+\n+You should define a `speed` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('speed')\n+`))})\n+```\n+\n+Your `speed` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('speed').has_args('self')\n+`))})\n+```\n+\n+Your `speed` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('speed').has_decorators('property')\n+`))})\n+```\n+\n+Your `speed` method should return the value of the private attribute `__speed`.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.speed == 22\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "2b6b033fce5f1228ea15aa55035d277fee85077f",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fc35902038376c7a00b3c.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,186 @@\n+---\n+id: 662fc35902038376c7a00b3c\n+title: Step 10\n+challengeType: 20\n+dashedName: step-10\n+---\n+\n+# --description--\n+\n+Once you have the getters, you can write the setters, which allow you to set the value of an attribute in an indirect manner. Following the example of the last step, a setter would be written as:\n+\n+```py\n+class Nest:\n+    ...\n+    @number_of_eggs.setter\n+    def number_of_eggs(self, new_value):\n+        self.__number_of_eggs = new_value\n+```\n+\n+Same as the getter, a setter is not called like a method but used like an attribute:\n+\n+```py\n+nest = Nest()\n+nest.number_of_eggs = 12\n+```\n+\n+This way of writing calls the setter and set the new value.\n+\n+For this step you will have to write the setters for the three private attributes. Remember that for the angle the value is received in degrees but saved internally in radians.\n+\n+# --hints--\n+\n+You should define a new `speed` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('speed')) == 2\n+`))})\n+```\n+\n+Your new `speed` method should have a `@speed.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('speed')[1].has_decorators('speed.setter')\n+`))})\n+```\n+\n+Your new `speed` method should set the value of the private `__speed` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.speed = 33\n+a.speed == 33\n+`))})\n+```\n+\n+You should define a new `height` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('height')) == 2\n+`))})\n+```\n+\n+Your new `height` method should have a `@height.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('height')[1].has_decorators('height.setter')\n+`))})\n+```\n+\n+Your new `height` method should set the value of the private `__height` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.height = 44\n+a.height == 44\n+`))})\n+```\n+\n+You should define a new `angle` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('angle')) == 2\n+`))})\n+```\n+\n+Your new `angle` method should have a `@angle.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('angle')[1].has_decorators('angle.setter')\n+`))})\n+```\n+\n+Your `angle` method should set the value of the private `__angle` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.angle = 12\n+a.angle == 12\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "767c9c4f043405d60efeaf03dae28ab119f431dc",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66335223f3e2a31d62d84367.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,203 @@\n+---\n+id: 66335223f3e2a31d62d84367\n+title: Step 13\n+challengeType: 20\n+dashedName: step-13\n+---\n+\n+# --description--\n+\n+Going back to the projectile trajectory calculator, now you'll create a new class that accepts a list of coordinates and creates the trajectory drawing.\n+\n+Create a new class `Graph`, which should be instantiated with a private attribute `__coordinates` where the list of coordinates is stored. Declare the `__slots__` class variable and define the  `__init__` and `__repr__` special methods.\n+\n+Also, create a `Graph` instance passing the `coordinates` variable and assign it to a new `graph` variable.\n+\n+# --hints--\n+\n+You should create a new `Graph` class.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).has_class('Graph')`\n+    ))\n+})\n+```\n+\n+You should have the `__slots__` variable inside the class.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_variable('__slots__')`\n+    ))\n+})\n+```\n+\n+The `__slots__` variable should have a value of `('__coordinates')` or `['__coordinates']`.\n+\n+```js\n+({\n+    test: () => (runPython(\n+        `\n+        slots = _Node(_code).find_class('Graph').find_variable('__slots__')\n+\n+        assert any(slots.is_equivalent(str) for str in ['__slots__ = (\"__coordinates\")', '__slots__ = [\"__coordinates\"]'])`\n+    ))\n+})\n+```\n+\n+You should have an `__init__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('__init__')`\n+    ))\n+})\n+```\n+\n+The `__init__` method should instantiate the `__coordinates` private property with the passed in value.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+        l = [(3, 4), (4, 1), (3, 9)]\n+        g = Graph(l)\n+        g._Graph__coordinates == l\n+        `\n+    ))\n+})\n+```\n+\n+You should have a `__repr__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('__repr__')`\n+    ))\n+})\n+```\n+\n+The `__repr__` method should return the correct string.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+        ball = Projectile(10, 3, 45)\n+        coords = ball.calculate_all_coordinates()\n+        repr(Graph(coords)) == f'Graph({coords})'\n+        `\n+    ))\n+})\n+```\n+\n+You should create a `Graph` instance passing in the `coordinates` variable and assign it to `graph` variable.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+\n+        assert _Node(_code).has_variable('graph'), \"variable graph is missing\"\n+\n+        assert _Node(_code).find_variable('graph').is_equivalent('graph = Graph(coordinates)'), \"assignment to graph is wrong\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f\"{self.__class__.__name__}({self.speed}, {self.height}, {self.angle})\"\n+\n+--fcc-editable-region--\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+--fcc-editable-region-- \n+```"
        },
        {
            "sha": "afe4a4b500557bd25c1732e3b9e0168c51c544b0",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/663353465bfb14259717da93.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,186 @@\n+---\n+id: 663353465bfb14259717da93\n+title: Step 14\n+challengeType: 20\n+dashedName: step-14\n+---\n+\n+# --description--\n+\n+Create a method `create_coordinates_table`, then at the end of the code print `graph.create_coordinates_table())`.\n+\n+The method should use the `__coordinates` property and return a string containing all the coordinates, where x and y have always the same position, the values for x are always integers, and the values for y are always rounded to two decimal places:\n+\n+```py\n+  x      y\n+  0   3.00\n+  1   3.90\n+  2   4.61\n+  3   5.12\n+  4   5.43\n+  5   5.55\n+  6   5.47\n+  7   5.19\n+  8   4.72\n+  9   4.05\n+ 10   3.19\n+ 11   2.13\n+ 12   0.87  \n+```\n+\n+The table should start with a newline character and end with a newline character.\n+\n+# --hints--\n+\n+You should have a `create_coordinates_table()` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('create_coordinates_table')`\n+    ))\n+})\n+```\n+\n+The method should return the correct output.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `str = \"\"\"\n+  x      y\n+  0   3.00\n+  1   3.90\n+  2   4.61\n+  3   5.12\n+  4   5.43\n+  5   5.55\n+  6   5.47\n+  7   5.19\n+  8   4.72\n+  9   4.05\n+ 10   3.19\n+ 11   2.13\n+ 12   0.87\n+\"\"\"\n+ball = Projectile(10, 3, 45)\n+g = Graph(ball.calculate_all_coordinates())\n+g.create_coordinates_table() == str`\n+    ))\n+})\n+```\n+\n+You should print `graph.create_coordiantes_table()`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+        prints = _Node(_code).find_calls('print')\n+        assert any(p.is_equivalent('print(graph.create_coordinates_table())') for p in prints), \"print(graph.create_coordiantes_table()) is missing\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f'Graph({self.__coordinates})'\n+\n+--fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+graph = Graph(coordinates)\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "a86e8fab60b1753ae08a7c20d1251e34a4d1263a",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b26c4f2d603072ef0818.md",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,136 @@\n+---\n+id: 6633b26c4f2d603072ef0818\n+title: Step 12\n+challengeType: 20\n+dashedName: step-12\n+---\n+\n+# --description--\n+\n+It's good practice to give a representation to the class by using the `__repr__` special method. While the `__str__` method returns a readable string representation that's intended to be user friendly, `__repr__` is intended for programmers. Often `__repr__` provides a string that can be used to recreate the object.\n+\n+Write the `__repr__` method, which will return the string needed to instantiate the object.\n+\n+You can test this by calling the `repr` function and passing it an instance of the class.\n+\n+# --hints--\n+\n+The `Projectile` class should have a `__repr__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Projectile').has_function('__repr__')`\n+    ))\n+})\n+```\n+\n+The instance `Projectile(12, 12, 12)` should have representation equal to `'Projectile(12, 12, 12)'`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `repr(Projectile(12, 12, 12)) == 'Projectile(12, 12, 12)' or \\\\\n+        repr(Projectile(12, 12, 12)) == 'Projectile(12, 12, 12.0)'`\n+    ))\n+})\n+```\n+\n+The instance `Projectile(21, 22, 45)` should have representation equal to `'Projectile(21, 22, 45)'`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `repr(Projectile(21, 22, 45)) == 'Projectile(21, 22, 45)' or \\\\\n+        repr(Projectile(21, 22, 45)) == 'Projectile(21, 22, 45.0)'`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+```"
        },
        {
            "sha": "b0ba04423b9d0981453df5445f4ce8e61a4831e1",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b4d3271d5b3aea1c1195.md",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,173 @@\n+---\n+id: 6633b4d3271d5b3aea1c1195\n+title: Step 15\n+challengeType: 20\n+dashedName: step-15\n+---\n+\n+# --description--\n+\n+Now it's time for the graph. Create a method `create_trajectory` and replace the last `print` call at the bottom of your code with `print(graph.create_trajectory())`.\n+\n+As the first step of this new function, make a local copy of the coordinates but where all the values are rounded to integers. Save this new version of the coordinates in a variable named `rounded_coords`, and return this variable.\n+\n+# --hints--\n+\n+You should define a method named `create_trajectory`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('create_trajectory')`\n+    ))\n+})\n+```\n+\n+You should replace `print(graph.create_coordinates_table())` with `print(graph.create_trajectory())`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    prints = _Node(_code).find_calls('print')\n+\n+    assert all(not p.is_equivalent('print(graph.create_coordinates_table())') for p in prints), \"print(graph.create_coordinates_table()) should not be present\"\n+\n+    assert any(p.is_equivalent('print(graph.create_trajectory())') for p in prints), \"print(graph.create_trajectory()) not found\"\n+    `)\n+})\n+```\n+\n+The function should return `rounded_coords`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_class('Graph').find_function('create_trajectory').has_return('rounded_coords'), \"return rounded_coords missing\"\n+    `)\n+})\n+```\n+\n+The `rounded_coords` variable should contain the rounded coordinates.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert [(round(x), round(y)) for x,y in coordinates] == graph.create_trajectory(), \"coordinates are not rounded correctly\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_coordinates_table())\n+\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "af06d95e150d51f5cea0544a8cf49d51fef094b3",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bdc3ca38c068c3735984.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,203 @@\n+---\n+id: 6633bdc3ca38c068c3735984\n+title: Step 21\n+challengeType: 20\n+dashedName: step-21\n+---\n+\n+# --description--\n+\n+Add the x and y axes to the graph to obtain the following output:\n+\n+```py\n+[\n+    \"⊣     ∙       \",\n+    \"⊣  ∙∙∙ ∙∙∙    \",\n+    \"⊣ ∙       ∙   \",\n+    \"⊣∙         ∙  \",\n+    \"⊣           ∙ \",\n+    \"⊣            ∙\",\n+    \"⊣             \",\n+    \" TTTTTTTTTTTTT\",\n+]\n+```\n+\n+The symbols are available as `x_axis_tick` and `y_axis_tick`.\n+\n+# --hints--\n+\n+The method should return the correct output.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+gr = [\n+    \"⊣     ∙       \",\n+    \"⊣  ∙∙∙ ∙∙∙    \",\n+    \"⊣ ∙       ∙   \",\n+    \"⊣∙         ∙  \",\n+    \"⊣           ∙ \",\n+    \"⊣            ∙\",\n+    \"⊣             \",\n+    \" TTTTTTTTTTTTT\",\n+]\n+ball = Projectile(10, 3, 45)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+g.create_trajectory() == gr`\n+    ))\n+})\n+```\n+\n+The method should return the correct output for different instances.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+gr = [\n+    \"⊣     ∙∙             \",\n+    \"⊣ ∙∙∙∙  ∙∙∙          \",\n+    \"⊣∙         ∙∙        \",\n+    \"⊣            ∙       \",\n+    \"⊣             ∙      \",\n+    \"⊣              ∙     \",\n+    \"⊣               ∙    \",\n+    \"⊣                ∙   \",\n+    \"⊣                 ∙  \",\n+    \"⊣                  ∙ \",\n+    \"⊣                    \",\n+    \"⊣                   ∙\",\n+    \" TTTTTTTTTTTTTTTTTTTT\",\n+]\n+ball = Projectile(11, 9, 30)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+g.create_trajectory() == gr`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        return matrix\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "3d29b59fbfd71f58386bc322cb68fd7e29811389",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bfcef57e1d70cc3142c6.md",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,167 @@\n+---\n+id: 6633bfcef57e1d70cc3142c6\n+title: Step 23\n+challengeType: 20\n+dashedName: step-23\n+---\n+\n+# --description--\n+\n+Finally, make the final output a multiline string. It should start with a newline character and end with a newline character.\n+\n+```py\n+\n+⊣     ∙       \n+⊣  ∙∙∙ ∙∙∙    \n+⊣ ∙       ∙   \n+⊣∙         ∙  \n+⊣           ∙ \n+⊣            ∙\n+⊣             \n+ TTTTTTTTTTTTT\n+\n+```\n+\n+# --hints--\n+\n+The method should return the correct string.\n+\n+```js\n+({\n+    test: () => (runPython(\n+        `gr = '\\\\n⊣     ∙       \\\\n⊣  ∙∙∙ ∙∙∙    \\\\n⊣ ∙       ∙   \\\\n⊣∙         ∙  \\\\n⊣           ∙ \\\\n⊣            ∙\\\\n⊣             \\\\n TTTTTTTTTTTTT\\\\n'\n+ball = Projectile(10, 3, 45)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+actual = g.create_trajectory()\n+expected = gr\n+assert actual == expected, f'expected {repr(expected)} but found {repr(actual)}'`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        return matrix_axes\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "c3fbb93afa003c93fc3ca6b1fe4c509cb1448866",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633c06601c081735063b528.md",
            "status": "added",
            "additions": 329,
            "deletions": 0,
            "changes": 329,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,329 @@\n+---\n+id: 6633c06601c081735063b528\n+title: Step 24\n+challengeType: 20\n+dashedName: step-24\n+---\n+\n+# --description--\n+\n+You have built a projectile trajectory calculator.\n+\n+Now to conclude, modify the code you wrote outside the classes, and incorporate it into a little utility function called `projectile_helper` that takes in the desired values for speed, height and angle and prints to the terminal in sequence, the details of the projectile, the table of coordinates and the graph of the trajectory.\n+\n+Call `projectile_helper` once with values of your choice.\n+\n+# --hints--\n+\n+You should create `projectile_helper` in the global scope.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).has_function('projectile_helper')    \n+    `)\n+})\n+```\n+\n+You should print the requested strings in order. Do not print other values.\n+\n+```js\n+({\n+    test: () => {\n+        let code_ = code.replaceAll('print(', '__result.append(')\n+\n+        runPython(`\n+__result = []\n+${code_}\n+__result = [] # code_ includes a call, so let's reset it here\n+projectile_helper(12, 13, 14)\n+bullet = Projectile(12, 13, 14)\n+assert str(__result[0]) == str(bullet)\n+c = bullet.calculate_all_coordinates()\n+g = Graph(c)\n+assert __result[1] == g.create_coordinates_table()\n+assert __result[2] == g.create_trajectory()\n+        `)\n+    }\n+})\n+```\n+\n+You should call the `projectile_helper` function at least once.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert len(_Node(_code).find_calls('projectile_helper')) > 0\n+    `)\n+})\n+```\n+\n+You should not have variables or print calls in the global scope.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_calls('print') == [], \"found print\"\n+    assert not _Node(_code).has_variable('graph'), \"found graph\"\n+    assert not _Node(_code).has_variable('ball'), \"found ball\"\n+    assert not _Node(_code).has_variable('coordinates'), \"found coordinates\"\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        graph = \"\\n\" + \"\\n\".join(matrix_axes) + \"\\n\"\n+\n+        return graph\n+\n+--fcc-editable-region--\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+--fcc-editable-region--\n+```\n+\n+# --solutions--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def __str__(self):\n+        return self.create_trajectory()\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        graph = \"\\n\" + \"\\n\".join(matrix_axes) + \"\\n\"\n+\n+        return graph\n+\n+def projectile_helper(speed, height, angle):\n+    p = Projectile(speed, height, angle)\n+    print(p)\n+    coord = p.calculate_all_coordinates()\n+    g = Graph(coord)\n+    print(g.create_coordinates_table())\n+    print(g.create_trajectory())\n+\n+projectile_helper(12, 43, 1)\n+\n+```"
        },
        {
            "sha": "7a5dc5ce39e5eba44b6d2e35b025007821bba047",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6634fa2417d7194b0c9425f9.md",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,145 @@\n+---\n+id: 6634fa2417d7194b0c9425f9\n+title: Step 9\n+challengeType: 20\n+dashedName: step-9\n+---\n+\n+# --description--\n+\n+Now create the two getters for `__height` and `__angle`. Remember that for the angle, the value is given to the class in degrees, but is saved internally in radians, so have the getter return the degrees value. You can use `math.degrees`, and the `round` function for this.\n+\n+# --hints--\n+You should define a `height` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('height')\n+`))})\n+```\n+\n+Your `height` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('height').has_args('self')\n+`))})\n+```\n+\n+Your `height` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('height').has_decorators('property')\n+`))})\n+```\n+\n+Your `height` method should return the value of the private attribute `__height`.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.height == 23\n+`))})\n+```\n+\n+You should define an `angle` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('angle')\n+`))})\n+```\n+\n+Your `angle` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('angle').has_decorators('property')\n+`))})\n+```\n+\n+Your `angle` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('angle').has_args('self')\n+`))})\n+```\n+\n+Your `angle` method should return the value of the private attribute `__angle` converted to degrees.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.angle == 24\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+--fcc-editable-region--\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+```"
        },
        {
            "sha": "6841ba5771d91dedf28c95bd710c1e0c18045ce2",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475bab40e5125c84b03337.md",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,172 @@\n+---\n+id: 66475bab40e5125c84b03337\n+title: Step 16\n+challengeType: 20\n+dashedName: step-16\n+---\n+\n+# --description--\n+\n+Now that you have the rounded coordinates, find the maximum value between all the x coordinates and the maximum value between all the y coordinates.\n+\n+These max values will be the number of rows and columns in the graph. Save the first in a new variable named `x_max` and the second in a variable named `y_max`.\n+\n+Return `x_max, y_max`.\n+\n+# --hints--\n+\n+The function should return `x_max, y_max`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_class('Graph').find_function('create_trajectory').has_return('x_max, y_max'), \"return x_max, y_max missing\"\n+    `)\n+})\n+```\n+\n+The variable `x_max` should contain the highest x value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert graph.create_trajectory()[0] == round(max(coordinates, key=lambda i: round(i[0]))[0])\n+\n+        `)\n+    }\n+})\n+```\n+\n+The variable `y_max` should contain the highest y value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert graph.create_trajectory()[1] == round(max(coordinates, key=lambda i: round(i[1]))[1])\n+\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        displacement = horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+        return displacement\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        return rounded_coords\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "b9ea0fe21ec83155050358605c83ff08a9e70324",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475d40dd42fb614f14fd03.md",
            "status": "added",
            "additions": 201,
            "deletions": 0,
            "changes": 201,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,201 @@\n+---\n+id: 66475d40dd42fb614f14fd03\n+title: Step 17\n+challengeType: 20\n+dashedName: step-17\n+---\n+\n+# --description--\n+\n+Now that you have `x_max` and `y_max` you can use these as number of rows and columns to start building the graph structure: create a list of lists where the external list contains `y_max` +1 lists, each with inside `x_max` +1 elements, where each element is a string containing a single space.\n+\n+Save this list of lists in a variable named `matrix_list` and return this value.\n+\n+`matrix_list` should look like this:\n+\n+```py\n+[\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+The `create_trajectory` method should return the right value for any instance.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        return x_max, y_max\n+\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "70fb15ef003f144416e3939aae0e2d8a14f106c7",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475e40f3891c645d50135e.md",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,199 @@\n+---\n+id: 66475e40f3891c645d50135e\n+title: Step 19\n+challengeType: 20\n+dashedName: step-19\n+---\n+\n+# --description--\n+\n+`matrix_list` is a list of lists, each element has an `(x, y)` coordinate. Use the list of coordinates in `rounded_coords` to change the elements in `matrix_list` at the coordinates in the list to the symbol in the `PROJECTILE` variable. Remember that a coordinates graph has the `(0, 0)` in the bottom left corner.\n+\n+```py\n+[\n+    [\" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \" \", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \" \", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+The method should return the correct value for different instances.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        return matrix_list\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "49dd62d1c58388faf938ce720da442332b4d02c0",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475f7b91d7c6681987739d.md",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,204 @@\n+---\n+id: 66475f7b91d7c6681987739d\n+title: Step 20\n+challengeType: 20\n+dashedName: step-20\n+---\n+\n+# --description--\n+\n+You have a list of lists of strings. Join the inner lists to have a list of strings.\n+\n+It should look like this:\n+\n+```py\n+[\n+    \"     ∙       \",\n+    \"  ∙∙∙ ∙∙∙    \",\n+    \" ∙       ∙   \",\n+    \"∙         ∙  \",\n+    \"           ∙ \",\n+    \"            ∙\",\n+    \"             \",\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    \"     ∙       \",\n+    \"  ∙∙∙ ∙∙∙    \",\n+    \" ∙       ∙   \",\n+    \"∙         ∙  \",\n+    \"           ∙ \",\n+    \"            ∙\",\n+    \"             \",\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+`create_trajectory()` should calculate the correct output for different instances.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    \"  ∙∙∙∙∙        \",\n+    \"∙∙     ∙       \",\n+    \"        ∙∙     \",\n+    \"          ∙    \",\n+    \"           ∙   \",\n+    \"               \",\n+    \"            ∙  \",\n+    \"             ∙ \",\n+    \"               \",\n+    \"              ∙\",\n+    \"               \",\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for (x, y) in rounded_coords:\n+            matrix_list[-y-1][x] = PROJECTILE\n+\n+        return matrix_list\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "a8c7d3d299897690a7d2d202b8869208db5b1ca7",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/665d949e628d9f3fe305b6e8.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,164 @@\n+---\n+id: 665d949e628d9f3fe305b6e8\n+title: Step 18\n+challengeType: 20\n+dashedName: step-18\n+---\n+\n+# --description--\n+\n+The output is becoming quite difficult to read, so you should replace the `print(graph.create_trajectory())` with a loop that prints each row separately.\n+\n+# --hints--\n+\n+Remove the `print(graph.create_trajectory())` call.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+prnt = _Node(_code).find_calls('print')\n+assert not any(p.is_equivalent('print(graph.create_trajectory())') for p in prnt), \"print still present\"\n+        `)\n+    }\n+})\n+```\n+\n+You should have a loop that iterates over `graph.create_trajectory()`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+iter = _Node(_code).find_for_loops()[0].find_for_iter()\n+assert iter.is_equivalent('graph.create_trajectory()'), \"loop is missing\"\n+        `)\n+    }\n+})\n+```\n+\n+You should print each row in `graph.create_trajectory()`.\n+\n+```js\n+({ test: () => runPython(`\n+loop = _Node(_code).find_for_loops()[0]\n+var = str(loop.find_for_vars())\n+assert loop.find_bodies()[0].has_call(f\"print({var})\")\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        return matrix_list\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+--fcc-editable-region--\n+print(graph.create_trajectory())\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "81d985809714b0ca514f09d38e4b368397ff0bbf",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66601c3c460ee12fbd669d6a.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,164 @@\n+---\n+id: 66601c3c460ee12fbd669d6a\n+title: Step 22\n+challengeType: 20\n+dashedName: step-22\n+---\n+\n+# --description--\n+\n+Now you can remove the loop to print each row of the output, and replace it with `print(graph.create_trajectory())`.\n+\n+# --hints--\n+\n+You should not have a loop in the global scope.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+assert not _Node(_code).find_for_loops(), \"loop still present\"\n+        `)\n+    }\n+})\n+```\n+\n+You should have `print(graph.create_trajectory())`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+prnt = _Node(_code).find_calls('print')\n+assert any(p.is_equivalent('print(graph.create_trajectory())') for p in prnt), \"print not present\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        return matrix_axes\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+--fcc-editable-region--\n+for row in graph.create_trajectory():\n+    print(row)\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "56966b5faea5d838476dfaeb0b5b976bb76333ca",
            "filename": "curriculum/challenges/espanol/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66671a41b55e531d08ab82b5.md",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fespanol%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,142 @@\n+---\n+id: 66671a41b55e531d08ab82b5\n+title: Step 11\n+challengeType: 20\n+dashedName: step-11\n+---\n+\n+# --description--\n+\n+The `__str__` method refers to the attributes of the class directly, but now that you have created the getters it is better to use those to obtain those values.\n+\n+Edit the `__str__` method to not reference the attributes anymore, but to use the getters.\n+\n+# --hints--\n+\n+The string representation for `Projectile(45, 45, 45)` should be correct.\n+\n+```js\n+({test: () => assert(runPython(\n+`\n+ball = Projectile(45, 45, 45)\n+str(ball) == \"\"\"\n+Projectile details:\n+speed: 45 m/s\n+height: 45 m\n+angle: 45°\n+displacement: 244.4 m\n+\"\"\"`\n+))})\n+```\n+\n+The string representation should also be correct for other instances.\n+\n+```js\n+({test: () => assert(runPython(`p = Projectile(10, 10, 10)\n+str(\n+    p\n+) == \"\"\"\n+Projectile details:\n+speed: 10 m/s\n+height: 10 m\n+angle: 10°\n+displacement: 15.9 m\n+\"\"\"`))})\n+```\n+\n+You should not be referencing the private properties directly.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    rtrn = str(_Node(_code).find_class('Projectile').find_function('__str__').find_return())\n+    assert not 'self.__angle' in rtrn\n+    assert not 'self.__speed' in rtrn\n+    assert not 'self.__height' in rtrn\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+--fcc-editable-region--    \n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+--fcc-editable-region--\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "abf4a3fbf33486dfa17f944cc8b14021a8a045e7",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65f569725359e10d345bc52a.md",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,75 @@\n+---\n+id: 65f569725359e10d345bc52a\n+title: Step 1\n+challengeType: 20\n+dashedName: step-1\n+---\n+\n+# --description--\n+\n+You are going to build a program that calculates and draws the trajectory of a projectile given the angle, speed and height of the throw.\n+\n+Start by importing `math`, you will use it a lot in this project as it has useful methods like `math.radians`, `math.cos`, `math.sin` and others.\n+\n+Also create these variables to have the value of the gravitational acceleration and some special symbols that will be useful later (use copy and paste for these).\n+\n+```py\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+```\n+\n+# --hints--\n+\n+Use `import math` to import the `math` module.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_import('import math')`))})\n+```\n+\n+You should have a `GRAVITATIONAL_ACCELERATION` variable with value of `9.81`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"GRAVITATIONAL_ACCELERATION\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"GRAVITATIONAL_ACCELERATION\").is_equivalent('GRAVITATIONAL_ACCELERATION = 9.81'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `PROJECTILE` variable with value of `\"∙\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"PROJECTILE\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"PROJECTILE\").is_equivalent('PROJECTILE = \"∙\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `x_axis_tick` variable with value of `\"T\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"x_axis_tick\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"x_axis_tick\").is_equivalent('x_axis_tick = \"T\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `y_axis_tick` variable with value of `\"⊣\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"y_axis_tick\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"y_axis_tick\").is_equivalent('y_axis_tick = \"⊣\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "db286166f195ed43a10e0605bfc4be0fc2f6c69c",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4b3bedee044b4b957d33.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,61 @@\n+---\n+id: 65fd4b3bedee044b4b957d33\n+title: Step 2\n+challengeType: 20\n+dashedName: step-2\n+---\n+\n+# --description--\n+\n+Create a `Projectile` class with an `__init__` method that initializes the class using three arguments: the starting speed, the starting height, and the starting angle of the throw of the projectile, in this order.\n+\n+Inside the `__init__` method, assign these arguments to three private attributes: `__speed`, `__height`, and `__angle`. The angle provided will be in degrees; however, it should be stored internally in radians. To achieve this, use the `math.radians()` function to convert the angle from degrees to radians when assigning it to `__angle`.\n+\n+The use of two underscores before an attribute name triggers name mangling in Python. This means the attributes are not directly accessible from outside the class using their given names, and must be accessed with the mangled names like `ball._Projectile__height` if needed externally, indicating these are intended for internal use only.\n+\n+# --hints--\n+\n+You should use `class Projectile:` to create the class.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_class(\"Projectile\")`))})\n+\n+```\n+\n+You should have an `__init__` method inside the `Projectile` class.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_body().has_function(\"__init__\")`))})\n+```\n+\n+A new `Projectile` class instance should have the values of the three attributes properly initialized.\n+\n+```js\n+({test: () => assert(runPython(`\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+p = Projectile(20, 21, 22)\n+p._Projectile__height == 21 and p._Projectile__speed == 20 and p._Projectile__angle == math.radians(22)\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "b9cd836b59b48f169c5d29a78dac81b1940b204c",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4bd84561a14d3e720061.md",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,48 @@\n+---\n+id: 65fd4bd84561a14d3e720061\n+title: Step 3\n+challengeType: 20\n+dashedName: step-3\n+---\n+\n+# --description--\n+\n+The class variable `__slots__` has a special usage in Python classes. Declaring `__slots__` and assigning it a sequence of strings restricts the creation of attributes to those included in that sequence. Also, it prevents the creation of the `__dict__` special attribute and it allows for more efficient attribute access.\n+\n+You should use the `__slots__` variable inside the class to define which attributes the class has: assign to `__slots__` a tuple containing 3 strings, each equal to one of the attribute names defined in the `__init__`.\n+\n+# --hints--\n+\n+You should assign to `__slots__` a tuple that contains `'__height'`, `'__speed'`, and `'__angle'`.\n+\n+```js\n+({test: () => assert(runPython(`\n+from itertools import permutations\n+slots = _Node(_code).find_class(\"Projectile\").find_body().find_variable(\"__slots__\")\n+perms = permutations((\"__height\", \"__speed\", \"__angle\"))\n+any(slots.is_equivalent(f'__slots__ = {perm}') for perm in perms)\n+`))})\n+\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+--fcc-editable-region--\n+class Projectile:\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "8c5270d99f59f323256adadc87929e55f6123f4c",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660400f02cf3a76795b82d4e.md",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,74 @@\n+---\n+id: 660400f02cf3a76795b82d4e\n+title: Step 4\n+challengeType: 20\n+dashedName: step-4\n+---\n+\n+# --description--\n+\n+The first thing to set up is a method that calculates the displacement of the projectile, which is the horizontal space traveled from the throw to when the projectile touches the ground.\n+\n+Create a method `__calculate_displacement`, which has only `self` as a parameter, and return the displacement of the projectile.\n+\n+Use the following formula to compute the projectile displacement: \\\\[ d = \\frac{v \\cdot \\cos\\theta \\cdot \\left(v\\cdot\\sin\\theta + \\sqrt{v^2\\sin^2\\theta + 2 \\cdot g \\cdot h}\\right)}{g} \\\\]\n+\n+In which $d$ is the displacement, $v$ is the starting speed, $\\theta$ is the angle and $h$ is the starting height of the projectile. For $g$ you can use the `GRAVITATIONAL_ACCELERATION` variable.\n+\n+You should use the methods `math.cos()` and `math.sin()` for the trigonometric functions and `math.sqrt()` to calculate the square root. Also you should know that $x^y$ is written as `x ** y` in python. Also $\\sin^2\\theta$ means that the value resulting from the sine is then squared.\n+\n+Remember that with name mangling you need to call the method as `_Projectile__calculate_displacement` if you want to test, or use it from outside of the class:\n+\n+```py\n+ball = Projectile(10, 3, 45)\n+displacement_of_ball = ball._Projectile__calculate_displacement() # 12.6173996009878\n+```\n+\n+# --hints--\n+\n+You should declare a function called `__calculate_displacement` with `def __calculate_displacement(self):`.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").has_function(\"__calculate_displacement\")`))})\n+```\n+\n+The `__calculate_displacement` method should have only the `self` argument.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_function(\"__calculate_displacement\").has_args('self')`))})\n+```\n+\n+The `__calculate_displacement` method should return the correct value.\n+\n+```js\n+({test: () => assert(runPython(`\n+p = Projectile(20, 21, 22)\n+disp = p._Projectile__calculate_displacement()\n+round(disp, 2) == 55.06 and round(disp, 2) != disp\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "eefd3dc7de816fb5abe2e8953fa8f6d6989ad361",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660fcf3e1b9bb056b2edb567.md",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,120 @@\n+---\n+id: 660fcf3e1b9bb056b2edb567\n+title: Step 5\n+challengeType: 20\n+dashedName: step-5\n+---\n+\n+# --description--\n+\n+At this point you are ready to create the string representation. Start by creating an instance of the `Projectile` class. Below the class definition, create a `ball` variable and assign it a call to `Projectile` using `10, 3, 45` as arguments.\n+\n+Define a `__str__` method within the class, to give your instance a proper string representation, and make it return a string with the following format:\n+\n+```py\n+\n+Projectile details:\n+speed: 10 m/s\n+height: 3 m\n+angle: 45°\n+displacement: 12.6 m\n+\n+```\n+\n+It should start and end with a new line character, the angle has to be written as an integer in degrees and the displacement should be printed with one decimal digit.\n+\n+You will find useful `math.degrees` to convert the angle from radians to degrees.\n+\n+When you are ready you can `print(ball)` to test your function.\n+\n+# --hints--\n+\n+You should have a `ball` variable.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_variable('ball')`))})\n+```\n+\n+The `ball` variable should have a value of `Projectile(10, 3, 45)`.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_variable('ball').is_equivalent('ball = Projectile(10, 3, 45)')`))})\n+```\n+\n+The string representation for `Projectile(45, 45, 45)` should be correct.\n+\n+```js\n+({test: () => assert(runPython(\n+`\n+ball = Projectile(45, 45, 45)\n+str(ball) == \"\"\"\n+Projectile details:\n+speed: 45 m/s\n+height: 45 m\n+angle: 45°\n+displacement: 244.4 m\n+\"\"\"`\n+))})\n+```\n+\n+The string representation should also be correct for other instances.\n+\n+```js\n+({test: () => assert(runPython(`p = Projectile(10, 10, 10)\n+str(\n+    p\n+) == \"\"\"\n+Projectile details:\n+speed: 10 m/s\n+height: 10 m\n+angle: 10°\n+displacement: 15.9 m\n+\"\"\"`))})\n+```\n+\n+You should have a `print(ball)` call.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    calls = _Node(_code).find_calls('print')\n+    assert any(c.is_equivalent('print(ball)') for c in calls)\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "ccfbf71ff43271f6871fdb3cf38d0f2c27675c7f",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6616ec0bf9ee8548ce6b0f08.md",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,109 @@\n+---\n+id: 6616ec0bf9ee8548ce6b0f08\n+title: Step 6\n+challengeType: 20\n+dashedName: step-6\n+---\n+\n+# --description--\n+\n+Now it's time to work on the function to calculate the coordinates of the trajectory! Create a method of the `Projectile` class named `__calculate_y_coordinate`, it should have, other than `self`, an `x` parameter.\n+\n+\\\\[ y = y_0 + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta} \\\\]\n+\n+The above is the formula to calculate the vertical position $y$ for any given horizontal position $x$, having the starting angle $\\theta$, speed $v_0$ and height $y_0$.\n+\n+You will need to use `math.tan()` and `math.cos()` and remember that `x ** y` is the way to write $x^y$, and that the value of $g$ is in the variable `GRAVITATIONAL_ACCELERATION`.\n+\n+Implement the method so that it returns the $y$ coordinate.\n+\n+If you want to test the method, from outside of class, you can call `ball._Projectile__calculate_y_coordinate()` with a number as an argument after `ball` is declared.\n+\n+# --hints--\n+\n+Your `Projectile` class should have a method named `__calculate_y_coordinate`.\n+\n+```js\n+({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').has_function('__calculate_y_coordinate')`))}})\n+```\n+\n+The `__calculate_y_coordinate` method should have `self, x` as arguments.\n+\n+```js\n+({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').find_function('__calculate_y_coordinate').has_args('self, x')`))}})\n+```\n+\n+The method should return the correct value. For `Projectile(12, 12, 12)`, given the 4 $x$ coordinates of 0, 1, 2 and 3, the y coordinate should be approximately 12, 12.18, 12.28, 12.32.\n+\n+```js\n+({test: () => {\n+    assert(runPython(`\n+    a = Projectile(12, 12, 12)\n+    all([round(a._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(0, 12.0), (1, 12.18), (2, 12.28), (3, 12.32)]])\n+    `))\n+}})\n+```\n+\n+The method should return the correct value. For `Projectile(45, 12, 22)`, given the $x$ coordinates of 6, 9, 10 and 12 the y coordinate should be approximately 14.32, 15.41, 15.76, 16.44.\n+\n+```js\n+({test: () => {\n+    assert(runPython(`\n+    b = Projectile(45, 12, 22)\n+    all([round(b._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(6, 14.32), (9, 15.41), (10, 15.76), (12, 16.44)]])\n+    `))\n+}})\n+```\n+\n+The `__calculate_y_coordinate` method should not round the result.\n+\n+```js\n+({test: () => assert.isFalse(runPython(`Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5) == round(Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5), 2)`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    --fcc-editable-region--\n+\n+    --fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+\n+```"
        },
        {
            "sha": "4cff93b9e8f559830239b74ee912725513ce046e",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662f9f65c50bd21d05ffdee9.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,110 @@\n+---\n+id: 662f9f65c50bd21d05ffdee9\n+title: Step 7\n+challengeType: 20\n+dashedName: step-7\n+---\n+\n+# --description--\n+\n+Define a method named `calculate_all_coordinates`, which calculates the coordinates for all \\\\(x\\\\) values from `0` up to the displacement rounded up (not inclusive), and then returns them as a list of tuples `(x, y)`.\n+\n+Then, call the `calculate_all_coordinates` method on the `ball` instance and assign the output to a new variable named `coordinates`.\n+\n+You can use `math.ceil()` to round up a number to the smallest integer greater than or equal to that number.\n+\n+# --hints--\n+\n+You should define a `calculate_all_coordinates` method with a single argument, `self` .\n+\n+```js\n+({test: () => assert(runPython(`\n+c = _Node(_code).find_class('Projectile')\n+c.has_function('calculate_all_coordinates') and c.find_function('calculate_all_coordinates').has_args('self')\n+`))})\n+```\n+\n+You should call the `calculate_all_coordinates` method on `ball` and assign the result to a variable named `coordinates`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+        assert _Node(_code).has_variable('coordinates'), \"coordinates variable is missing\"\n+\n+        assert _Node(_code).find_variable('coordinates').is_equivalent('coordinates = ball.calculate_all_coordinates()'), \"wrong value assigned to coordinates variable\"\n+    `)\n+})\n+```\n+\n+The `calculate_all_coordinates` method should return a list containing all the `(x, y)` coordinates.\n+\n+```js\n+({test: () => assert(runPython(`\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+ball = Projectile(12, 13, 14)\n+expected = [(x, ball._Projectile__calculate_y_coordinate(x)) for x in range(math.ceil(ball._Projectile__calculate_displacement()))]\n+actual = ball.calculate_all_coordinates()\n+expected == actual\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x**2 / (\n+                2 * self.__speed**2 * math.cos(self.__angle)**2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    --fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+   --fcc-editable-region--\n+```"
        },
        {
            "sha": "4bb9cd3ad62b572df845a78672e0b21c3e994443",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fa453ec8033322b3ab2e3.md",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,129 @@\n+---\n+id: 662fa453ec8033322b3ab2e3\n+title: Step 8\n+challengeType: 20\n+dashedName: step-8\n+---\n+\n+# --description--\n+\n+It's time to talk about encapsulation and getters. You have written the three instance attributes to be private using a leading double underscore. Note that these attributes are called private by convention: although they can still be accessed from outside, it is agreed upon to not do that.\n+\n+Getters are what can be used to get the values from outside. To define a getter, you define a method that returns the value of the desired attribute and give it a `@property` decorator:\n+\n+```py\n+class Nest:\n+    ...\n+    @property\n+    def number_of_eggs(self):\n+        return self.__number_of_eggs\n+```\n+\n+ The decorator changes the method into a property, meaning that the method is not called like a regular method, but it's used like an attribute:\n+\n+```py\n+n = Nest()\n+print(n.number_of_eggs)\n+```\n+\n+In the example above, the private attribute `__number of eggs` is accessed through the `number_of_eggs` property of `n`.\n+\n+Create a getter named `speed` and make it return the value of the private attribute `__speed`.\n+\n+# --hints--\n+\n+You should define a `speed` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('speed')\n+`))})\n+```\n+\n+Your `speed` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('speed').has_args('self')\n+`))})\n+```\n+\n+Your `speed` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('speed').has_decorators('property')\n+`))})\n+```\n+\n+Your `speed` method should return the value of the private attribute `__speed`.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.speed == 22\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "2b6b033fce5f1228ea15aa55035d277fee85077f",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fc35902038376c7a00b3c.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,186 @@\n+---\n+id: 662fc35902038376c7a00b3c\n+title: Step 10\n+challengeType: 20\n+dashedName: step-10\n+---\n+\n+# --description--\n+\n+Once you have the getters, you can write the setters, which allow you to set the value of an attribute in an indirect manner. Following the example of the last step, a setter would be written as:\n+\n+```py\n+class Nest:\n+    ...\n+    @number_of_eggs.setter\n+    def number_of_eggs(self, new_value):\n+        self.__number_of_eggs = new_value\n+```\n+\n+Same as the getter, a setter is not called like a method but used like an attribute:\n+\n+```py\n+nest = Nest()\n+nest.number_of_eggs = 12\n+```\n+\n+This way of writing calls the setter and set the new value.\n+\n+For this step you will have to write the setters for the three private attributes. Remember that for the angle the value is received in degrees but saved internally in radians.\n+\n+# --hints--\n+\n+You should define a new `speed` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('speed')) == 2\n+`))})\n+```\n+\n+Your new `speed` method should have a `@speed.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('speed')[1].has_decorators('speed.setter')\n+`))})\n+```\n+\n+Your new `speed` method should set the value of the private `__speed` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.speed = 33\n+a.speed == 33\n+`))})\n+```\n+\n+You should define a new `height` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('height')) == 2\n+`))})\n+```\n+\n+Your new `height` method should have a `@height.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('height')[1].has_decorators('height.setter')\n+`))})\n+```\n+\n+Your new `height` method should set the value of the private `__height` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.height = 44\n+a.height == 44\n+`))})\n+```\n+\n+You should define a new `angle` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('angle')) == 2\n+`))})\n+```\n+\n+Your new `angle` method should have a `@angle.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('angle')[1].has_decorators('angle.setter')\n+`))})\n+```\n+\n+Your `angle` method should set the value of the private `__angle` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.angle = 12\n+a.angle == 12\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "767c9c4f043405d60efeaf03dae28ab119f431dc",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66335223f3e2a31d62d84367.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,203 @@\n+---\n+id: 66335223f3e2a31d62d84367\n+title: Step 13\n+challengeType: 20\n+dashedName: step-13\n+---\n+\n+# --description--\n+\n+Going back to the projectile trajectory calculator, now you'll create a new class that accepts a list of coordinates and creates the trajectory drawing.\n+\n+Create a new class `Graph`, which should be instantiated with a private attribute `__coordinates` where the list of coordinates is stored. Declare the `__slots__` class variable and define the  `__init__` and `__repr__` special methods.\n+\n+Also, create a `Graph` instance passing the `coordinates` variable and assign it to a new `graph` variable.\n+\n+# --hints--\n+\n+You should create a new `Graph` class.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).has_class('Graph')`\n+    ))\n+})\n+```\n+\n+You should have the `__slots__` variable inside the class.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_variable('__slots__')`\n+    ))\n+})\n+```\n+\n+The `__slots__` variable should have a value of `('__coordinates')` or `['__coordinates']`.\n+\n+```js\n+({\n+    test: () => (runPython(\n+        `\n+        slots = _Node(_code).find_class('Graph').find_variable('__slots__')\n+\n+        assert any(slots.is_equivalent(str) for str in ['__slots__ = (\"__coordinates\")', '__slots__ = [\"__coordinates\"]'])`\n+    ))\n+})\n+```\n+\n+You should have an `__init__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('__init__')`\n+    ))\n+})\n+```\n+\n+The `__init__` method should instantiate the `__coordinates` private property with the passed in value.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+        l = [(3, 4), (4, 1), (3, 9)]\n+        g = Graph(l)\n+        g._Graph__coordinates == l\n+        `\n+    ))\n+})\n+```\n+\n+You should have a `__repr__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('__repr__')`\n+    ))\n+})\n+```\n+\n+The `__repr__` method should return the correct string.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+        ball = Projectile(10, 3, 45)\n+        coords = ball.calculate_all_coordinates()\n+        repr(Graph(coords)) == f'Graph({coords})'\n+        `\n+    ))\n+})\n+```\n+\n+You should create a `Graph` instance passing in the `coordinates` variable and assign it to `graph` variable.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+\n+        assert _Node(_code).has_variable('graph'), \"variable graph is missing\"\n+\n+        assert _Node(_code).find_variable('graph').is_equivalent('graph = Graph(coordinates)'), \"assignment to graph is wrong\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f\"{self.__class__.__name__}({self.speed}, {self.height}, {self.angle})\"\n+\n+--fcc-editable-region--\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+--fcc-editable-region-- \n+```"
        },
        {
            "sha": "afe4a4b500557bd25c1732e3b9e0168c51c544b0",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/663353465bfb14259717da93.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,186 @@\n+---\n+id: 663353465bfb14259717da93\n+title: Step 14\n+challengeType: 20\n+dashedName: step-14\n+---\n+\n+# --description--\n+\n+Create a method `create_coordinates_table`, then at the end of the code print `graph.create_coordinates_table())`.\n+\n+The method should use the `__coordinates` property and return a string containing all the coordinates, where x and y have always the same position, the values for x are always integers, and the values for y are always rounded to two decimal places:\n+\n+```py\n+  x      y\n+  0   3.00\n+  1   3.90\n+  2   4.61\n+  3   5.12\n+  4   5.43\n+  5   5.55\n+  6   5.47\n+  7   5.19\n+  8   4.72\n+  9   4.05\n+ 10   3.19\n+ 11   2.13\n+ 12   0.87  \n+```\n+\n+The table should start with a newline character and end with a newline character.\n+\n+# --hints--\n+\n+You should have a `create_coordinates_table()` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('create_coordinates_table')`\n+    ))\n+})\n+```\n+\n+The method should return the correct output.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `str = \"\"\"\n+  x      y\n+  0   3.00\n+  1   3.90\n+  2   4.61\n+  3   5.12\n+  4   5.43\n+  5   5.55\n+  6   5.47\n+  7   5.19\n+  8   4.72\n+  9   4.05\n+ 10   3.19\n+ 11   2.13\n+ 12   0.87\n+\"\"\"\n+ball = Projectile(10, 3, 45)\n+g = Graph(ball.calculate_all_coordinates())\n+g.create_coordinates_table() == str`\n+    ))\n+})\n+```\n+\n+You should print `graph.create_coordiantes_table()`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+        prints = _Node(_code).find_calls('print')\n+        assert any(p.is_equivalent('print(graph.create_coordinates_table())') for p in prints), \"print(graph.create_coordiantes_table()) is missing\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f'Graph({self.__coordinates})'\n+\n+--fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+graph = Graph(coordinates)\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "a86e8fab60b1753ae08a7c20d1251e34a4d1263a",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b26c4f2d603072ef0818.md",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,136 @@\n+---\n+id: 6633b26c4f2d603072ef0818\n+title: Step 12\n+challengeType: 20\n+dashedName: step-12\n+---\n+\n+# --description--\n+\n+It's good practice to give a representation to the class by using the `__repr__` special method. While the `__str__` method returns a readable string representation that's intended to be user friendly, `__repr__` is intended for programmers. Often `__repr__` provides a string that can be used to recreate the object.\n+\n+Write the `__repr__` method, which will return the string needed to instantiate the object.\n+\n+You can test this by calling the `repr` function and passing it an instance of the class.\n+\n+# --hints--\n+\n+The `Projectile` class should have a `__repr__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Projectile').has_function('__repr__')`\n+    ))\n+})\n+```\n+\n+The instance `Projectile(12, 12, 12)` should have representation equal to `'Projectile(12, 12, 12)'`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `repr(Projectile(12, 12, 12)) == 'Projectile(12, 12, 12)' or \\\\\n+        repr(Projectile(12, 12, 12)) == 'Projectile(12, 12, 12.0)'`\n+    ))\n+})\n+```\n+\n+The instance `Projectile(21, 22, 45)` should have representation equal to `'Projectile(21, 22, 45)'`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `repr(Projectile(21, 22, 45)) == 'Projectile(21, 22, 45)' or \\\\\n+        repr(Projectile(21, 22, 45)) == 'Projectile(21, 22, 45.0)'`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+```"
        },
        {
            "sha": "b0ba04423b9d0981453df5445f4ce8e61a4831e1",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b4d3271d5b3aea1c1195.md",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,173 @@\n+---\n+id: 6633b4d3271d5b3aea1c1195\n+title: Step 15\n+challengeType: 20\n+dashedName: step-15\n+---\n+\n+# --description--\n+\n+Now it's time for the graph. Create a method `create_trajectory` and replace the last `print` call at the bottom of your code with `print(graph.create_trajectory())`.\n+\n+As the first step of this new function, make a local copy of the coordinates but where all the values are rounded to integers. Save this new version of the coordinates in a variable named `rounded_coords`, and return this variable.\n+\n+# --hints--\n+\n+You should define a method named `create_trajectory`.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('create_trajectory')`\n+    ))\n+})\n+```\n+\n+You should replace `print(graph.create_coordinates_table())` with `print(graph.create_trajectory())`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    prints = _Node(_code).find_calls('print')\n+\n+    assert all(not p.is_equivalent('print(graph.create_coordinates_table())') for p in prints), \"print(graph.create_coordinates_table()) should not be present\"\n+\n+    assert any(p.is_equivalent('print(graph.create_trajectory())') for p in prints), \"print(graph.create_trajectory()) not found\"\n+    `)\n+})\n+```\n+\n+The function should return `rounded_coords`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_class('Graph').find_function('create_trajectory').has_return('rounded_coords'), \"return rounded_coords missing\"\n+    `)\n+})\n+```\n+\n+The `rounded_coords` variable should contain the rounded coordinates.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert [(round(x), round(y)) for x,y in coordinates] == graph.create_trajectory(), \"coordinates are not rounded correctly\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_coordinates_table())\n+\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "af06d95e150d51f5cea0544a8cf49d51fef094b3",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bdc3ca38c068c3735984.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,203 @@\n+---\n+id: 6633bdc3ca38c068c3735984\n+title: Step 21\n+challengeType: 20\n+dashedName: step-21\n+---\n+\n+# --description--\n+\n+Add the x and y axes to the graph to obtain the following output:\n+\n+```py\n+[\n+    \"⊣     ∙       \",\n+    \"⊣  ∙∙∙ ∙∙∙    \",\n+    \"⊣ ∙       ∙   \",\n+    \"⊣∙         ∙  \",\n+    \"⊣           ∙ \",\n+    \"⊣            ∙\",\n+    \"⊣             \",\n+    \" TTTTTTTTTTTTT\",\n+]\n+```\n+\n+The symbols are available as `x_axis_tick` and `y_axis_tick`.\n+\n+# --hints--\n+\n+The method should return the correct output.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+gr = [\n+    \"⊣     ∙       \",\n+    \"⊣  ∙∙∙ ∙∙∙    \",\n+    \"⊣ ∙       ∙   \",\n+    \"⊣∙         ∙  \",\n+    \"⊣           ∙ \",\n+    \"⊣            ∙\",\n+    \"⊣             \",\n+    \" TTTTTTTTTTTTT\",\n+]\n+ball = Projectile(10, 3, 45)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+g.create_trajectory() == gr`\n+    ))\n+})\n+```\n+\n+The method should return the correct output for different instances.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+gr = [\n+    \"⊣     ∙∙             \",\n+    \"⊣ ∙∙∙∙  ∙∙∙          \",\n+    \"⊣∙         ∙∙        \",\n+    \"⊣            ∙       \",\n+    \"⊣             ∙      \",\n+    \"⊣              ∙     \",\n+    \"⊣               ∙    \",\n+    \"⊣                ∙   \",\n+    \"⊣                 ∙  \",\n+    \"⊣                  ∙ \",\n+    \"⊣                    \",\n+    \"⊣                   ∙\",\n+    \" TTTTTTTTTTTTTTTTTTTT\",\n+]\n+ball = Projectile(11, 9, 30)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+g.create_trajectory() == gr`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        return matrix\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "3d29b59fbfd71f58386bc322cb68fd7e29811389",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bfcef57e1d70cc3142c6.md",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,167 @@\n+---\n+id: 6633bfcef57e1d70cc3142c6\n+title: Step 23\n+challengeType: 20\n+dashedName: step-23\n+---\n+\n+# --description--\n+\n+Finally, make the final output a multiline string. It should start with a newline character and end with a newline character.\n+\n+```py\n+\n+⊣     ∙       \n+⊣  ∙∙∙ ∙∙∙    \n+⊣ ∙       ∙   \n+⊣∙         ∙  \n+⊣           ∙ \n+⊣            ∙\n+⊣             \n+ TTTTTTTTTTTTT\n+\n+```\n+\n+# --hints--\n+\n+The method should return the correct string.\n+\n+```js\n+({\n+    test: () => (runPython(\n+        `gr = '\\\\n⊣     ∙       \\\\n⊣  ∙∙∙ ∙∙∙    \\\\n⊣ ∙       ∙   \\\\n⊣∙         ∙  \\\\n⊣           ∙ \\\\n⊣            ∙\\\\n⊣             \\\\n TTTTTTTTTTTTT\\\\n'\n+ball = Projectile(10, 3, 45)\n+coords = ball.calculate_all_coordinates()\n+g = Graph(coords)\n+actual = g.create_trajectory()\n+expected = gr\n+assert actual == expected, f'expected {repr(expected)} but found {repr(actual)}'`\n+    ))\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        return matrix_axes\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "c3fbb93afa003c93fc3ca6b1fe4c509cb1448866",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633c06601c081735063b528.md",
            "status": "added",
            "additions": 329,
            "deletions": 0,
            "changes": 329,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,329 @@\n+---\n+id: 6633c06601c081735063b528\n+title: Step 24\n+challengeType: 20\n+dashedName: step-24\n+---\n+\n+# --description--\n+\n+You have built a projectile trajectory calculator.\n+\n+Now to conclude, modify the code you wrote outside the classes, and incorporate it into a little utility function called `projectile_helper` that takes in the desired values for speed, height and angle and prints to the terminal in sequence, the details of the projectile, the table of coordinates and the graph of the trajectory.\n+\n+Call `projectile_helper` once with values of your choice.\n+\n+# --hints--\n+\n+You should create `projectile_helper` in the global scope.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).has_function('projectile_helper')    \n+    `)\n+})\n+```\n+\n+You should print the requested strings in order. Do not print other values.\n+\n+```js\n+({\n+    test: () => {\n+        let code_ = code.replaceAll('print(', '__result.append(')\n+\n+        runPython(`\n+__result = []\n+${code_}\n+__result = [] # code_ includes a call, so let's reset it here\n+projectile_helper(12, 13, 14)\n+bullet = Projectile(12, 13, 14)\n+assert str(__result[0]) == str(bullet)\n+c = bullet.calculate_all_coordinates()\n+g = Graph(c)\n+assert __result[1] == g.create_coordinates_table()\n+assert __result[2] == g.create_trajectory()\n+        `)\n+    }\n+})\n+```\n+\n+You should call the `projectile_helper` function at least once.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert len(_Node(_code).find_calls('projectile_helper')) > 0\n+    `)\n+})\n+```\n+\n+You should not have variables or print calls in the global scope.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_calls('print') == [], \"found print\"\n+    assert not _Node(_code).has_variable('graph'), \"found graph\"\n+    assert not _Node(_code).has_variable('ball'), \"found ball\"\n+    assert not _Node(_code).has_variable('coordinates'), \"found coordinates\"\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        graph = \"\\n\" + \"\\n\".join(matrix_axes) + \"\\n\"\n+\n+        return graph\n+\n+--fcc-editable-region--\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+--fcc-editable-region--\n+```\n+\n+# --solutions--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def __str__(self):\n+        return self.create_trajectory()\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        graph = \"\\n\" + \"\\n\".join(matrix_axes) + \"\\n\"\n+\n+        return graph\n+\n+def projectile_helper(speed, height, angle):\n+    p = Projectile(speed, height, angle)\n+    print(p)\n+    coord = p.calculate_all_coordinates()\n+    g = Graph(coord)\n+    print(g.create_coordinates_table())\n+    print(g.create_trajectory())\n+\n+projectile_helper(12, 43, 1)\n+\n+```"
        },
        {
            "sha": "7a5dc5ce39e5eba44b6d2e35b025007821bba047",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6634fa2417d7194b0c9425f9.md",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,145 @@\n+---\n+id: 6634fa2417d7194b0c9425f9\n+title: Step 9\n+challengeType: 20\n+dashedName: step-9\n+---\n+\n+# --description--\n+\n+Now create the two getters for `__height` and `__angle`. Remember that for the angle, the value is given to the class in degrees, but is saved internally in radians, so have the getter return the degrees value. You can use `math.degrees`, and the `round` function for this.\n+\n+# --hints--\n+You should define a `height` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('height')\n+`))})\n+```\n+\n+Your `height` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('height').has_args('self')\n+`))})\n+```\n+\n+Your `height` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('height').has_decorators('property')\n+`))})\n+```\n+\n+Your `height` method should return the value of the private attribute `__height`.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.height == 23\n+`))})\n+```\n+\n+You should define an `angle` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('angle')\n+`))})\n+```\n+\n+Your `angle` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('angle').has_decorators('property')\n+`))})\n+```\n+\n+Your `angle` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('angle').has_args('self')\n+`))})\n+```\n+\n+Your `angle` method should return the value of the private attribute `__angle` converted to degrees.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.angle == 24\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+--fcc-editable-region--\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+```"
        },
        {
            "sha": "6841ba5771d91dedf28c95bd710c1e0c18045ce2",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475bab40e5125c84b03337.md",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,172 @@\n+---\n+id: 66475bab40e5125c84b03337\n+title: Step 16\n+challengeType: 20\n+dashedName: step-16\n+---\n+\n+# --description--\n+\n+Now that you have the rounded coordinates, find the maximum value between all the x coordinates and the maximum value between all the y coordinates.\n+\n+These max values will be the number of rows and columns in the graph. Save the first in a new variable named `x_max` and the second in a variable named `y_max`.\n+\n+Return `x_max, y_max`.\n+\n+# --hints--\n+\n+The function should return `x_max, y_max`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    assert _Node(_code).find_class('Graph').find_function('create_trajectory').has_return('x_max, y_max'), \"return x_max, y_max missing\"\n+    `)\n+})\n+```\n+\n+The variable `x_max` should contain the highest x value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert graph.create_trajectory()[0] == round(max(coordinates, key=lambda i: round(i[0]))[0])\n+\n+        `)\n+    }\n+})\n+```\n+\n+The variable `y_max` should contain the highest y value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+            ball = Projectile(10, 3, 45)\n+            coordinates = ball.calculate_all_coordinates()\n+            graph = Graph(coordinates)\n+            assert graph.create_trajectory()[1] == round(max(coordinates, key=lambda i: round(i[1]))[1])\n+\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        displacement = horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+        return displacement\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        return rounded_coords\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "b9ea0fe21ec83155050358605c83ff08a9e70324",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475d40dd42fb614f14fd03.md",
            "status": "added",
            "additions": 201,
            "deletions": 0,
            "changes": 201,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,201 @@\n+---\n+id: 66475d40dd42fb614f14fd03\n+title: Step 17\n+challengeType: 20\n+dashedName: step-17\n+---\n+\n+# --description--\n+\n+Now that you have `x_max` and `y_max` you can use these as number of rows and columns to start building the graph structure: create a list of lists where the external list contains `y_max` +1 lists, each with inside `x_max` +1 elements, where each element is a string containing a single space.\n+\n+Save this list of lists in a variable named `matrix_list` and return this value.\n+\n+`matrix_list` should look like this:\n+\n+```py\n+[\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+The `create_trajectory` method should return the right value for any instance.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        return x_max, y_max\n+\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+print(graph.create_trajectory())\n+\n+```"
        },
        {
            "sha": "70fb15ef003f144416e3939aae0e2d8a14f106c7",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475e40f3891c645d50135e.md",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,199 @@\n+---\n+id: 66475e40f3891c645d50135e\n+title: Step 19\n+challengeType: 20\n+dashedName: step-19\n+---\n+\n+# --description--\n+\n+`matrix_list` is a list of lists, each element has an `(x, y)` coordinate. Use the list of coordinates in `rounded_coords` to change the elements in `matrix_list` at the coordinates in the list to the symbol in the `PROJECTILE` variable. Remember that a coordinates graph has the `(0, 0)` in the bottom left corner.\n+\n+```py\n+[\n+    [\" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \" \", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \" \", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+The method should return the correct value for different instances.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    [\" \", \" \", \"∙\", \"∙\", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n+    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix_list has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        return matrix_list\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "49dd62d1c58388faf938ce720da442332b4d02c0",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475f7b91d7c6681987739d.md",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,204 @@\n+---\n+id: 66475f7b91d7c6681987739d\n+title: Step 20\n+challengeType: 20\n+dashedName: step-20\n+---\n+\n+# --description--\n+\n+You have a list of lists of strings. Join the inner lists to have a list of strings.\n+\n+It should look like this:\n+\n+```py\n+[\n+    \"     ∙       \",\n+    \"  ∙∙∙ ∙∙∙    \",\n+    \" ∙       ∙   \",\n+    \"∙         ∙  \",\n+    \"           ∙ \",\n+    \"            ∙\",\n+    \"             \",\n+]\n+```\n+\n+# --hints--\n+\n+The method should return the correct value.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    \"     ∙       \",\n+    \"  ∙∙∙ ∙∙∙    \",\n+    \" ∙       ∙   \",\n+    \"∙         ∙  \",\n+    \"           ∙ \",\n+    \"            ∙\",\n+    \"             \",\n+]\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+`create_trajectory()` should calculate the correct output for different instances.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+expected = [\n+    \"  ∙∙∙∙∙        \",\n+    \"∙∙     ∙       \",\n+    \"        ∙∙     \",\n+    \"          ∙    \",\n+    \"           ∙   \",\n+    \"               \",\n+    \"            ∙  \",\n+    \"             ∙ \",\n+    \"               \",\n+    \"              ∙\",\n+    \"               \",\n+]\n+ball = Projectile(9, 9, 30)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+actual = graph.create_trajectory()\n+assert actual == expected, \"matrix has wrong value\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+--fcc-editable-region--\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for (x, y) in rounded_coords:\n+            matrix_list[-y-1][x] = PROJECTILE\n+\n+        return matrix_list\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+for row in graph.create_trajectory():\n+    print(row) \n+\n+```"
        },
        {
            "sha": "a8c7d3d299897690a7d2d202b8869208db5b1ca7",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/665d949e628d9f3fe305b6e8.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,164 @@\n+---\n+id: 665d949e628d9f3fe305b6e8\n+title: Step 18\n+challengeType: 20\n+dashedName: step-18\n+---\n+\n+# --description--\n+\n+The output is becoming quite difficult to read, so you should replace the `print(graph.create_trajectory())` with a loop that prints each row separately.\n+\n+# --hints--\n+\n+Remove the `print(graph.create_trajectory())` call.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+prnt = _Node(_code).find_calls('print')\n+assert not any(p.is_equivalent('print(graph.create_trajectory())') for p in prnt), \"print still present\"\n+        `)\n+    }\n+})\n+```\n+\n+You should have a loop that iterates over `graph.create_trajectory()`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+iter = _Node(_code).find_for_loops()[0].find_for_iter()\n+assert iter.is_equivalent('graph.create_trajectory()'), \"loop is missing\"\n+        `)\n+    }\n+})\n+```\n+\n+You should print each row in `graph.create_trajectory()`.\n+\n+```js\n+({ test: () => runPython(`\n+loop = _Node(_code).find_for_loops()[0]\n+var = str(loop.find_for_vars())\n+assert loop.find_bodies()[0].has_call(f\"print({var})\")\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        return matrix_list\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+--fcc-editable-region--\n+print(graph.create_trajectory())\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "81d985809714b0ca514f09d38e4b368397ff0bbf",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66601c3c460ee12fbd669d6a.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,164 @@\n+---\n+id: 66601c3c460ee12fbd669d6a\n+title: Step 22\n+challengeType: 20\n+dashedName: step-22\n+---\n+\n+# --description--\n+\n+Now you can remove the loop to print each row of the output, and replace it with `print(graph.create_trajectory())`.\n+\n+# --hints--\n+\n+You should not have a loop in the global scope.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+assert not _Node(_code).find_for_loops(), \"loop still present\"\n+        `)\n+    }\n+})\n+```\n+\n+You should have `print(graph.create_trajectory())`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+prnt = _Node(_code).find_calls('print')\n+assert any(p.is_equivalent('print(graph.create_trajectory())') for p in prnt), \"print not present\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f\"Graph({self.__coordinates})\"\n+\n+    def create_coordinates_table(self):\n+        table = '\\n  x      y\\n'\n+        for x, y in self.__coordinates:\n+            table += f'{x:>3}{y:>7.2f}\\n'\n+\n+        return table\n+\n+    def create_trajectory(self):\n+\n+        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n+\n+        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n+        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n+\n+        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n+\n+        for x, y in rounded_coords:\n+            matrix_list[-1 - y][x] = PROJECTILE\n+\n+        matrix = [\"\".join(line) for line in matrix_list]\n+\n+        matrix_axes = [y_axis_tick + row for row in matrix]\n+        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n+\n+        return matrix_axes\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+graph = Graph(coordinates)\n+--fcc-editable-region--\n+for row in graph.create_trajectory():\n+    print(row)\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "56966b5faea5d838476dfaeb0b5b976bb76333ca",
            "filename": "curriculum/challenges/german/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66671a41b55e531d08ab82b5.md",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fgerman%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,142 @@\n+---\n+id: 66671a41b55e531d08ab82b5\n+title: Step 11\n+challengeType: 20\n+dashedName: step-11\n+---\n+\n+# --description--\n+\n+The `__str__` method refers to the attributes of the class directly, but now that you have created the getters it is better to use those to obtain those values.\n+\n+Edit the `__str__` method to not reference the attributes anymore, but to use the getters.\n+\n+# --hints--\n+\n+The string representation for `Projectile(45, 45, 45)` should be correct.\n+\n+```js\n+({test: () => assert(runPython(\n+`\n+ball = Projectile(45, 45, 45)\n+str(ball) == \"\"\"\n+Projectile details:\n+speed: 45 m/s\n+height: 45 m\n+angle: 45°\n+displacement: 244.4 m\n+\"\"\"`\n+))})\n+```\n+\n+The string representation should also be correct for other instances.\n+\n+```js\n+({test: () => assert(runPython(`p = Projectile(10, 10, 10)\n+str(\n+    p\n+) == \"\"\"\n+Projectile details:\n+speed: 10 m/s\n+height: 10 m\n+angle: 10°\n+displacement: 15.9 m\n+\"\"\"`))})\n+```\n+\n+You should not be referencing the private properties directly.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    rtrn = str(_Node(_code).find_class('Projectile').find_function('__str__').find_return())\n+    assert not 'self.__angle' in rtrn\n+    assert not 'self.__speed' in rtrn\n+    assert not 'self.__height' in rtrn\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+--fcc-editable-region--    \n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+--fcc-editable-region--\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "abf4a3fbf33486dfa17f944cc8b14021a8a045e7",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65f569725359e10d345bc52a.md",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,75 @@\n+---\n+id: 65f569725359e10d345bc52a\n+title: Step 1\n+challengeType: 20\n+dashedName: step-1\n+---\n+\n+# --description--\n+\n+You are going to build a program that calculates and draws the trajectory of a projectile given the angle, speed and height of the throw.\n+\n+Start by importing `math`, you will use it a lot in this project as it has useful methods like `math.radians`, `math.cos`, `math.sin` and others.\n+\n+Also create these variables to have the value of the gravitational acceleration and some special symbols that will be useful later (use copy and paste for these).\n+\n+```py\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+```\n+\n+# --hints--\n+\n+Use `import math` to import the `math` module.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_import('import math')`))})\n+```\n+\n+You should have a `GRAVITATIONAL_ACCELERATION` variable with value of `9.81`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"GRAVITATIONAL_ACCELERATION\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"GRAVITATIONAL_ACCELERATION\").is_equivalent('GRAVITATIONAL_ACCELERATION = 9.81'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `PROJECTILE` variable with value of `\"∙\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"PROJECTILE\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"PROJECTILE\").is_equivalent('PROJECTILE = \"∙\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `x_axis_tick` variable with value of `\"T\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"x_axis_tick\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"x_axis_tick\").is_equivalent('x_axis_tick = \"T\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+You should have a `y_axis_tick` variable with value of `\"⊣\"`.\n+\n+```js\n+({test: () => runPython(`\n+assert _Node(_code).has_variable(\"y_axis_tick\"), \"missing variable\"\n+assert _Node(_code).find_variable(\"y_axis_tick\").is_equivalent('y_axis_tick = \"⊣\"'), \"variable has wrong value\"\n+`)})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "db286166f195ed43a10e0605bfc4be0fc2f6c69c",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4b3bedee044b4b957d33.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,61 @@\n+---\n+id: 65fd4b3bedee044b4b957d33\n+title: Step 2\n+challengeType: 20\n+dashedName: step-2\n+---\n+\n+# --description--\n+\n+Create a `Projectile` class with an `__init__` method that initializes the class using three arguments: the starting speed, the starting height, and the starting angle of the throw of the projectile, in this order.\n+\n+Inside the `__init__` method, assign these arguments to three private attributes: `__speed`, `__height`, and `__angle`. The angle provided will be in degrees; however, it should be stored internally in radians. To achieve this, use the `math.radians()` function to convert the angle from degrees to radians when assigning it to `__angle`.\n+\n+The use of two underscores before an attribute name triggers name mangling in Python. This means the attributes are not directly accessible from outside the class using their given names, and must be accessed with the mangled names like `ball._Projectile__height` if needed externally, indicating these are intended for internal use only.\n+\n+# --hints--\n+\n+You should use `class Projectile:` to create the class.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_class(\"Projectile\")`))})\n+\n+```\n+\n+You should have an `__init__` method inside the `Projectile` class.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_body().has_function(\"__init__\")`))})\n+```\n+\n+A new `Projectile` class instance should have the values of the three attributes properly initialized.\n+\n+```js\n+({test: () => assert(runPython(`\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+p = Projectile(20, 21, 22)\n+p._Projectile__height == 21 and p._Projectile__speed == 20 and p._Projectile__angle == math.radians(22)\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "b9cd836b59b48f169c5d29a78dac81b1940b204c",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4bd84561a14d3e720061.md",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,48 @@\n+---\n+id: 65fd4bd84561a14d3e720061\n+title: Step 3\n+challengeType: 20\n+dashedName: step-3\n+---\n+\n+# --description--\n+\n+The class variable `__slots__` has a special usage in Python classes. Declaring `__slots__` and assigning it a sequence of strings restricts the creation of attributes to those included in that sequence. Also, it prevents the creation of the `__dict__` special attribute and it allows for more efficient attribute access.\n+\n+You should use the `__slots__` variable inside the class to define which attributes the class has: assign to `__slots__` a tuple containing 3 strings, each equal to one of the attribute names defined in the `__init__`.\n+\n+# --hints--\n+\n+You should assign to `__slots__` a tuple that contains `'__height'`, `'__speed'`, and `'__angle'`.\n+\n+```js\n+({test: () => assert(runPython(`\n+from itertools import permutations\n+slots = _Node(_code).find_class(\"Projectile\").find_body().find_variable(\"__slots__\")\n+perms = permutations((\"__height\", \"__speed\", \"__angle\"))\n+any(slots.is_equivalent(f'__slots__ = {perm}') for perm in perms)\n+`))})\n+\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+--fcc-editable-region--\n+class Projectile:\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "8c5270d99f59f323256adadc87929e55f6123f4c",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660400f02cf3a76795b82d4e.md",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,74 @@\n+---\n+id: 660400f02cf3a76795b82d4e\n+title: Step 4\n+challengeType: 20\n+dashedName: step-4\n+---\n+\n+# --description--\n+\n+The first thing to set up is a method that calculates the displacement of the projectile, which is the horizontal space traveled from the throw to when the projectile touches the ground.\n+\n+Create a method `__calculate_displacement`, which has only `self` as a parameter, and return the displacement of the projectile.\n+\n+Use the following formula to compute the projectile displacement: \\\\[ d = \\frac{v \\cdot \\cos\\theta \\cdot \\left(v\\cdot\\sin\\theta + \\sqrt{v^2\\sin^2\\theta + 2 \\cdot g \\cdot h}\\right)}{g} \\\\]\n+\n+In which $d$ is the displacement, $v$ is the starting speed, $\\theta$ is the angle and $h$ is the starting height of the projectile. For $g$ you can use the `GRAVITATIONAL_ACCELERATION` variable.\n+\n+You should use the methods `math.cos()` and `math.sin()` for the trigonometric functions and `math.sqrt()` to calculate the square root. Also you should know that $x^y$ is written as `x ** y` in python. Also $\\sin^2\\theta$ means that the value resulting from the sine is then squared.\n+\n+Remember that with name mangling you need to call the method as `_Projectile__calculate_displacement` if you want to test, or use it from outside of the class:\n+\n+```py\n+ball = Projectile(10, 3, 45)\n+displacement_of_ball = ball._Projectile__calculate_displacement() # 12.6173996009878\n+```\n+\n+# --hints--\n+\n+You should declare a function called `__calculate_displacement` with `def __calculate_displacement(self):`.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").has_function(\"__calculate_displacement\")`))})\n+```\n+\n+The `__calculate_displacement` method should have only the `self` argument.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_function(\"__calculate_displacement\").has_args('self')`))})\n+```\n+\n+The `__calculate_displacement` method should return the correct value.\n+\n+```js\n+({test: () => assert(runPython(`\n+p = Projectile(20, 21, 22)\n+disp = p._Projectile__calculate_displacement()\n+round(disp, 2) == 55.06 and round(disp, 2) != disp\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "eefd3dc7de816fb5abe2e8953fa8f6d6989ad361",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660fcf3e1b9bb056b2edb567.md",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,120 @@\n+---\n+id: 660fcf3e1b9bb056b2edb567\n+title: Step 5\n+challengeType: 20\n+dashedName: step-5\n+---\n+\n+# --description--\n+\n+At this point you are ready to create the string representation. Start by creating an instance of the `Projectile` class. Below the class definition, create a `ball` variable and assign it a call to `Projectile` using `10, 3, 45` as arguments.\n+\n+Define a `__str__` method within the class, to give your instance a proper string representation, and make it return a string with the following format:\n+\n+```py\n+\n+Projectile details:\n+speed: 10 m/s\n+height: 3 m\n+angle: 45°\n+displacement: 12.6 m\n+\n+```\n+\n+It should start and end with a new line character, the angle has to be written as an integer in degrees and the displacement should be printed with one decimal digit.\n+\n+You will find useful `math.degrees` to convert the angle from radians to degrees.\n+\n+When you are ready you can `print(ball)` to test your function.\n+\n+# --hints--\n+\n+You should have a `ball` variable.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).has_variable('ball')`))})\n+```\n+\n+The `ball` variable should have a value of `Projectile(10, 3, 45)`.\n+\n+```js\n+({test: () => assert(runPython(`_Node(_code).find_variable('ball').is_equivalent('ball = Projectile(10, 3, 45)')`))})\n+```\n+\n+The string representation for `Projectile(45, 45, 45)` should be correct.\n+\n+```js\n+({test: () => assert(runPython(\n+`\n+ball = Projectile(45, 45, 45)\n+str(ball) == \"\"\"\n+Projectile details:\n+speed: 45 m/s\n+height: 45 m\n+angle: 45°\n+displacement: 244.4 m\n+\"\"\"`\n+))})\n+```\n+\n+The string representation should also be correct for other instances.\n+\n+```js\n+({test: () => assert(runPython(`p = Projectile(10, 10, 10)\n+str(\n+    p\n+) == \"\"\"\n+Projectile details:\n+speed: 10 m/s\n+height: 10 m\n+angle: 10°\n+displacement: 15.9 m\n+\"\"\"`))})\n+```\n+\n+You should have a `print(ball)` call.\n+\n+```js\n+({\n+    test: () => runPython(`\n+    calls = _Node(_code).find_calls('print')\n+    assert any(c.is_equivalent('print(ball)') for c in calls)\n+    `)\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+```"
        },
        {
            "sha": "ccfbf71ff43271f6871fdb3cf38d0f2c27675c7f",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6616ec0bf9ee8548ce6b0f08.md",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,109 @@\n+---\n+id: 6616ec0bf9ee8548ce6b0f08\n+title: Step 6\n+challengeType: 20\n+dashedName: step-6\n+---\n+\n+# --description--\n+\n+Now it's time to work on the function to calculate the coordinates of the trajectory! Create a method of the `Projectile` class named `__calculate_y_coordinate`, it should have, other than `self`, an `x` parameter.\n+\n+\\\\[ y = y_0 + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta} \\\\]\n+\n+The above is the formula to calculate the vertical position $y$ for any given horizontal position $x$, having the starting angle $\\theta$, speed $v_0$ and height $y_0$.\n+\n+You will need to use `math.tan()` and `math.cos()` and remember that `x ** y` is the way to write $x^y$, and that the value of $g$ is in the variable `GRAVITATIONAL_ACCELERATION`.\n+\n+Implement the method so that it returns the $y$ coordinate.\n+\n+If you want to test the method, from outside of class, you can call `ball._Projectile__calculate_y_coordinate()` with a number as an argument after `ball` is declared.\n+\n+# --hints--\n+\n+Your `Projectile` class should have a method named `__calculate_y_coordinate`.\n+\n+```js\n+({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').has_function('__calculate_y_coordinate')`))}})\n+```\n+\n+The `__calculate_y_coordinate` method should have `self, x` as arguments.\n+\n+```js\n+({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').find_function('__calculate_y_coordinate').has_args('self, x')`))}})\n+```\n+\n+The method should return the correct value. For `Projectile(12, 12, 12)`, given the 4 $x$ coordinates of 0, 1, 2 and 3, the y coordinate should be approximately 12, 12.18, 12.28, 12.32.\n+\n+```js\n+({test: () => {\n+    assert(runPython(`\n+    a = Projectile(12, 12, 12)\n+    all([round(a._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(0, 12.0), (1, 12.18), (2, 12.28), (3, 12.32)]])\n+    `))\n+}})\n+```\n+\n+The method should return the correct value. For `Projectile(45, 12, 22)`, given the $x$ coordinates of 6, 9, 10 and 12 the y coordinate should be approximately 14.32, 15.41, 15.76, 16.44.\n+\n+```js\n+({test: () => {\n+    assert(runPython(`\n+    b = Projectile(45, 12, 22)\n+    all([round(b._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(6, 14.32), (9, 15.41), (10, 15.76), (12, 16.44)]])\n+    `))\n+}})\n+```\n+\n+The `__calculate_y_coordinate` method should not round the result.\n+\n+```js\n+({test: () => assert.isFalse(runPython(`Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5) == round(Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5), 2)`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    --fcc-editable-region--\n+\n+    --fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+\n+```"
        },
        {
            "sha": "4cff93b9e8f559830239b74ee912725513ce046e",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662f9f65c50bd21d05ffdee9.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,110 @@\n+---\n+id: 662f9f65c50bd21d05ffdee9\n+title: Step 7\n+challengeType: 20\n+dashedName: step-7\n+---\n+\n+# --description--\n+\n+Define a method named `calculate_all_coordinates`, which calculates the coordinates for all \\\\(x\\\\) values from `0` up to the displacement rounded up (not inclusive), and then returns them as a list of tuples `(x, y)`.\n+\n+Then, call the `calculate_all_coordinates` method on the `ball` instance and assign the output to a new variable named `coordinates`.\n+\n+You can use `math.ceil()` to round up a number to the smallest integer greater than or equal to that number.\n+\n+# --hints--\n+\n+You should define a `calculate_all_coordinates` method with a single argument, `self` .\n+\n+```js\n+({test: () => assert(runPython(`\n+c = _Node(_code).find_class('Projectile')\n+c.has_function('calculate_all_coordinates') and c.find_function('calculate_all_coordinates').has_args('self')\n+`))})\n+```\n+\n+You should call the `calculate_all_coordinates` method on `ball` and assign the result to a variable named `coordinates`.\n+\n+```js\n+({\n+    test: () => runPython(`\n+        assert _Node(_code).has_variable('coordinates'), \"coordinates variable is missing\"\n+\n+        assert _Node(_code).find_variable('coordinates').is_equivalent('coordinates = ball.calculate_all_coordinates()'), \"wrong value assigned to coordinates variable\"\n+    `)\n+})\n+```\n+\n+The `calculate_all_coordinates` method should return a list containing all the `(x, y)` coordinates.\n+\n+```js\n+({test: () => assert(runPython(`\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+ball = Projectile(12, 13, 14)\n+expected = [(x, ball._Projectile__calculate_y_coordinate(x)) for x in range(math.ceil(ball._Projectile__calculate_displacement()))]\n+actual = ball.calculate_all_coordinates()\n+expected == actual\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x**2 / (\n+                2 * self.__speed**2 * math.cos(self.__angle)**2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    --fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+   --fcc-editable-region--\n+```"
        },
        {
            "sha": "4bb9cd3ad62b572df845a78672e0b21c3e994443",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fa453ec8033322b3ab2e3.md",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,129 @@\n+---\n+id: 662fa453ec8033322b3ab2e3\n+title: Step 8\n+challengeType: 20\n+dashedName: step-8\n+---\n+\n+# --description--\n+\n+It's time to talk about encapsulation and getters. You have written the three instance attributes to be private using a leading double underscore. Note that these attributes are called private by convention: although they can still be accessed from outside, it is agreed upon to not do that.\n+\n+Getters are what can be used to get the values from outside. To define a getter, you define a method that returns the value of the desired attribute and give it a `@property` decorator:\n+\n+```py\n+class Nest:\n+    ...\n+    @property\n+    def number_of_eggs(self):\n+        return self.__number_of_eggs\n+```\n+\n+ The decorator changes the method into a property, meaning that the method is not called like a regular method, but it's used like an attribute:\n+\n+```py\n+n = Nest()\n+print(n.number_of_eggs)\n+```\n+\n+In the example above, the private attribute `__number of eggs` is accessed through the `number_of_eggs` property of `n`.\n+\n+Create a getter named `speed` and make it return the value of the private attribute `__speed`.\n+\n+# --hints--\n+\n+You should define a `speed` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').has_function('speed')\n+`))})\n+```\n+\n+Your `speed` method should have a single parameter, `self`.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('speed').has_args('self')\n+`))})\n+```\n+\n+Your `speed` method should have a `@property` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_function('speed').has_decorators('property')\n+`))})\n+```\n+\n+Your `speed` method should return the value of the private attribute `__speed`.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.speed == 22\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "2b6b033fce5f1228ea15aa55035d277fee85077f",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fc35902038376c7a00b3c.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,186 @@\n+---\n+id: 662fc35902038376c7a00b3c\n+title: Step 10\n+challengeType: 20\n+dashedName: step-10\n+---\n+\n+# --description--\n+\n+Once you have the getters, you can write the setters, which allow you to set the value of an attribute in an indirect manner. Following the example of the last step, a setter would be written as:\n+\n+```py\n+class Nest:\n+    ...\n+    @number_of_eggs.setter\n+    def number_of_eggs(self, new_value):\n+        self.__number_of_eggs = new_value\n+```\n+\n+Same as the getter, a setter is not called like a method but used like an attribute:\n+\n+```py\n+nest = Nest()\n+nest.number_of_eggs = 12\n+```\n+\n+This way of writing calls the setter and set the new value.\n+\n+For this step you will have to write the setters for the three private attributes. Remember that for the angle the value is received in degrees but saved internally in radians.\n+\n+# --hints--\n+\n+You should define a new `speed` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('speed')) == 2\n+`))})\n+```\n+\n+Your new `speed` method should have a `@speed.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('speed')[1].has_decorators('speed.setter')\n+`))})\n+```\n+\n+Your new `speed` method should set the value of the private `__speed` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.speed = 33\n+a.speed == 33\n+`))})\n+```\n+\n+You should define a new `height` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('height')) == 2\n+`))})\n+```\n+\n+Your new `height` method should have a `@height.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('height')[1].has_decorators('height.setter')\n+`))})\n+```\n+\n+Your new `height` method should set the value of the private `__height` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.height = 44\n+a.height == 44\n+`))})\n+```\n+\n+You should define a new `angle` method.\n+\n+```js\n+({test: () => assert(runPython(`\n+len(_Node(_code).find_class('Projectile').find_functions('angle')) == 2\n+`))})\n+```\n+\n+Your new `angle` method should have a `@angle.setter` decorator.\n+\n+```js\n+({test: () => assert(runPython(`\n+_Node(_code).find_class('Projectile').find_functions('angle')[1].has_decorators('angle.setter')\n+`))})\n+```\n+\n+Your `angle` method should set the value of the private `__angle` property.\n+\n+```js\n+({test: () => assert(runPython(`\n+a = Projectile(22, 23, 24)\n+a.angle = 12\n+a.angle == 12\n+`))})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.__speed} m/s\n+height: {self.__height} m\n+angle: {round(math.degrees(self.__angle))}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+\n+\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+```"
        },
        {
            "sha": "767c9c4f043405d60efeaf03dae28ab119f431dc",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66335223f3e2a31d62d84367.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,203 @@\n+---\n+id: 66335223f3e2a31d62d84367\n+title: Step 13\n+challengeType: 20\n+dashedName: step-13\n+---\n+\n+# --description--\n+\n+Going back to the projectile trajectory calculator, now you'll create a new class that accepts a list of coordinates and creates the trajectory drawing.\n+\n+Create a new class `Graph`, which should be instantiated with a private attribute `__coordinates` where the list of coordinates is stored. Declare the `__slots__` class variable and define the  `__init__` and `__repr__` special methods.\n+\n+Also, create a `Graph` instance passing the `coordinates` variable and assign it to a new `graph` variable.\n+\n+# --hints--\n+\n+You should create a new `Graph` class.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).has_class('Graph')`\n+    ))\n+})\n+```\n+\n+You should have the `__slots__` variable inside the class.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_variable('__slots__')`\n+    ))\n+})\n+```\n+\n+The `__slots__` variable should have a value of `('__coordinates')` or `['__coordinates']`.\n+\n+```js\n+({\n+    test: () => (runPython(\n+        `\n+        slots = _Node(_code).find_class('Graph').find_variable('__slots__')\n+\n+        assert any(slots.is_equivalent(str) for str in ['__slots__ = (\"__coordinates\")', '__slots__ = [\"__coordinates\"]'])`\n+    ))\n+})\n+```\n+\n+You should have an `__init__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('__init__')`\n+    ))\n+})\n+```\n+\n+The `__init__` method should instantiate the `__coordinates` private property with the passed in value.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+        l = [(3, 4), (4, 1), (3, 9)]\n+        g = Graph(l)\n+        g._Graph__coordinates == l\n+        `\n+    ))\n+})\n+```\n+\n+You should have a `__repr__` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('__repr__')`\n+    ))\n+})\n+```\n+\n+The `__repr__` method should return the correct string.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `\n+        ball = Projectile(10, 3, 45)\n+        coords = ball.calculate_all_coordinates()\n+        repr(Graph(coords)) == f'Graph({coords})'\n+        `\n+    ))\n+})\n+```\n+\n+You should create a `Graph` instance passing in the `coordinates` variable and assign it to `graph` variable.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+\n+        assert _Node(_code).has_variable('graph'), \"variable graph is missing\"\n+\n+        assert _Node(_code).find_variable('graph').is_equivalent('graph = Graph(coordinates)'), \"assignment to graph is wrong\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f\"{self.__class__.__name__}({self.speed}, {self.height}, {self.angle})\"\n+\n+--fcc-editable-region--\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+\n+--fcc-editable-region-- \n+```"
        },
        {
            "sha": "afe4a4b500557bd25c1732e3b9e0168c51c544b0",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/663353465bfb14259717da93.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b",
            "patch": "@@ -0,0 +1,186 @@\n+---\n+id: 663353465bfb14259717da93\n+title: Step 14\n+challengeType: 20\n+dashedName: step-14\n+---\n+\n+# --description--\n+\n+Create a method `create_coordinates_table`, then at the end of the code print `graph.create_coordinates_table())`.\n+\n+The method should use the `__coordinates` property and return a string containing all the coordinates, where x and y have always the same position, the values for x are always integers, and the values for y are always rounded to two decimal places:\n+\n+```py\n+  x      y\n+  0   3.00\n+  1   3.90\n+  2   4.61\n+  3   5.12\n+  4   5.43\n+  5   5.55\n+  6   5.47\n+  7   5.19\n+  8   4.72\n+  9   4.05\n+ 10   3.19\n+ 11   2.13\n+ 12   0.87  \n+```\n+\n+The table should start with a newline character and end with a newline character.\n+\n+# --hints--\n+\n+You should have a `create_coordinates_table()` method.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `_Node(_code).find_class('Graph').has_function('create_coordinates_table')`\n+    ))\n+})\n+```\n+\n+The method should return the correct output.\n+\n+```js\n+({\n+    test: () => assert(runPython(\n+        `str = \"\"\"\n+  x      y\n+  0   3.00\n+  1   3.90\n+  2   4.61\n+  3   5.12\n+  4   5.43\n+  5   5.55\n+  6   5.47\n+  7   5.19\n+  8   4.72\n+  9   4.05\n+ 10   3.19\n+ 11   2.13\n+ 12   0.87\n+\"\"\"\n+ball = Projectile(10, 3, 45)\n+g = Graph(ball.calculate_all_coordinates())\n+g.create_coordinates_table() == str`\n+    ))\n+})\n+```\n+\n+You should print `graph.create_coordiantes_table()`.\n+\n+```js\n+({\n+    test: () => {\n+        runPython(`\n+        prints = _Node(_code).find_calls('print')\n+        assert any(p.is_equivalent('print(graph.create_coordinates_table())') for p in prints), \"print(graph.create_coordiantes_table()) is missing\"\n+        `)\n+    }\n+})\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+import math\n+\n+GRAVITATIONAL_ACCELERATION = 9.81\n+PROJECTILE = \"∙\"\n+x_axis_tick = \"T\"\n+y_axis_tick = \"⊣\"\n+\n+class Projectile:\n+    __slots__ = ('__speed', '__height', '__angle')\n+\n+    def __init__(self, speed, height, angle):\n+        self.__speed = speed\n+        self.__height = height\n+        self.__angle = math.radians(angle)\n+\n+    def __str__(self):\n+        return f'''\n+Projectile details:\n+speed: {self.speed} m/s\n+height: {self.height} m\n+angle: {self.angle}°\n+displacement: {round(self.__calculate_displacement(), 1)} m\n+'''\n+\n+    def __calculate_displacement(self):\n+        horizontal_component = self.__speed * math.cos(self.__angle)\n+        vertical_component = self.__speed * math.sin(self.__angle)\n+        squared_component = vertical_component**2\n+        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n+        sqrt_component = math.sqrt(squared_component + gh_component)\n+\n+        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n+\n+    def __calculate_y_coordinate(self, x):\n+        height_component = self.__height\n+        angle_component = math.tan(self.__angle) * x\n+        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n+                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n+        y_coordinate = height_component + angle_component - acceleration_component\n+\n+        return y_coordinate\n+\n+    def calculate_all_coordinates(self):\n+        return [\n+            (x, self.__calculate_y_coordinate(x))\n+            for x in range(math.ceil(self.__calculate_displacement()))\n+        ]\n+\n+    @property\n+    def height(self):\n+        return self.__height\n+\n+    @property\n+    def angle(self):\n+        return round(math.degrees(self.__angle))\n+\n+    @property\n+    def speed(self):\n+        return self.__speed\n+\n+    @height.setter\n+    def height(self, n):\n+        self.__height = n\n+\n+    @angle.setter\n+    def angle(self, n):\n+        self.__angle = math.radians(n)\n+\n+    @speed.setter\n+    def speed(self, s):\n+       self.__speed = s\n+\n+    def __repr__(self):\n+        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n+\n+class Graph:\n+    __slots__ = ('__coordinates')\n+\n+    def __init__(self, coord):\n+        self.__coordinates = coord\n+\n+    def __repr__(self):\n+        return f'Graph({self.__coordinates})'\n+\n+--fcc-editable-region--\n+\n+\n+\n+ball = Projectile(10, 3, 45)\n+print(ball)\n+coordinates = ball.calculate_all_coordinates()\n+\n+graph = Graph(coordinates)\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "a86e8fab60b1753ae08a7c20d1251e34a4d1263a",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b26c4f2d603072ef0818.md",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b0ba04423b9d0981453df5445f4ce8e61a4831e1",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b4d3271d5b3aea1c1195.md",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "af06d95e150d51f5cea0544a8cf49d51fef094b3",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bdc3ca38c068c3735984.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "3d29b59fbfd71f58386bc322cb68fd7e29811389",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bfcef57e1d70cc3142c6.md",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "c3fbb93afa003c93fc3ca6b1fe4c509cb1448866",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633c06601c081735063b528.md",
            "status": "added",
            "additions": 329,
            "deletions": 0,
            "changes": 329,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "7a5dc5ce39e5eba44b6d2e35b025007821bba047",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6634fa2417d7194b0c9425f9.md",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "6841ba5771d91dedf28c95bd710c1e0c18045ce2",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475bab40e5125c84b03337.md",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b9ea0fe21ec83155050358605c83ff08a9e70324",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475d40dd42fb614f14fd03.md",
            "status": "added",
            "additions": 201,
            "deletions": 0,
            "changes": 201,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "70fb15ef003f144416e3939aae0e2d8a14f106c7",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475e40f3891c645d50135e.md",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "49dd62d1c58388faf938ce720da442332b4d02c0",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475f7b91d7c6681987739d.md",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "a8c7d3d299897690a7d2d202b8869208db5b1ca7",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/665d949e628d9f3fe305b6e8.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "81d985809714b0ca514f09d38e4b368397ff0bbf",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66601c3c460ee12fbd669d6a.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "56966b5faea5d838476dfaeb0b5b976bb76333ca",
            "filename": "curriculum/challenges/italian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66671a41b55e531d08ab82b5.md",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fitalian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "abf4a3fbf33486dfa17f944cc8b14021a8a045e7",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65f569725359e10d345bc52a.md",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "db286166f195ed43a10e0605bfc4be0fc2f6c69c",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4b3bedee044b4b957d33.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b9cd836b59b48f169c5d29a78dac81b1940b204c",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4bd84561a14d3e720061.md",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "8c5270d99f59f323256adadc87929e55f6123f4c",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660400f02cf3a76795b82d4e.md",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "eefd3dc7de816fb5abe2e8953fa8f6d6989ad361",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660fcf3e1b9bb056b2edb567.md",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "ccfbf71ff43271f6871fdb3cf38d0f2c27675c7f",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6616ec0bf9ee8548ce6b0f08.md",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "4cff93b9e8f559830239b74ee912725513ce046e",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662f9f65c50bd21d05ffdee9.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "4bb9cd3ad62b572df845a78672e0b21c3e994443",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fa453ec8033322b3ab2e3.md",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "2b6b033fce5f1228ea15aa55035d277fee85077f",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fc35902038376c7a00b3c.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "767c9c4f043405d60efeaf03dae28ab119f431dc",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66335223f3e2a31d62d84367.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "afe4a4b500557bd25c1732e3b9e0168c51c544b0",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/663353465bfb14259717da93.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "a86e8fab60b1753ae08a7c20d1251e34a4d1263a",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b26c4f2d603072ef0818.md",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b0ba04423b9d0981453df5445f4ce8e61a4831e1",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b4d3271d5b3aea1c1195.md",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "af06d95e150d51f5cea0544a8cf49d51fef094b3",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bdc3ca38c068c3735984.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "3d29b59fbfd71f58386bc322cb68fd7e29811389",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bfcef57e1d70cc3142c6.md",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "c3fbb93afa003c93fc3ca6b1fe4c509cb1448866",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633c06601c081735063b528.md",
            "status": "added",
            "additions": 329,
            "deletions": 0,
            "changes": 329,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "7a5dc5ce39e5eba44b6d2e35b025007821bba047",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6634fa2417d7194b0c9425f9.md",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "6841ba5771d91dedf28c95bd710c1e0c18045ce2",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475bab40e5125c84b03337.md",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b9ea0fe21ec83155050358605c83ff08a9e70324",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475d40dd42fb614f14fd03.md",
            "status": "added",
            "additions": 201,
            "deletions": 0,
            "changes": 201,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "70fb15ef003f144416e3939aae0e2d8a14f106c7",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475e40f3891c645d50135e.md",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "49dd62d1c58388faf938ce720da442332b4d02c0",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475f7b91d7c6681987739d.md",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "a8c7d3d299897690a7d2d202b8869208db5b1ca7",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/665d949e628d9f3fe305b6e8.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "81d985809714b0ca514f09d38e4b368397ff0bbf",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66601c3c460ee12fbd669d6a.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "56966b5faea5d838476dfaeb0b5b976bb76333ca",
            "filename": "curriculum/challenges/japanese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66671a41b55e531d08ab82b5.md",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fjapanese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "abf4a3fbf33486dfa17f944cc8b14021a8a045e7",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65f569725359e10d345bc52a.md",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "db286166f195ed43a10e0605bfc4be0fc2f6c69c",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4b3bedee044b4b957d33.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b9cd836b59b48f169c5d29a78dac81b1940b204c",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4bd84561a14d3e720061.md",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "8c5270d99f59f323256adadc87929e55f6123f4c",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660400f02cf3a76795b82d4e.md",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "eefd3dc7de816fb5abe2e8953fa8f6d6989ad361",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660fcf3e1b9bb056b2edb567.md",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "ccfbf71ff43271f6871fdb3cf38d0f2c27675c7f",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6616ec0bf9ee8548ce6b0f08.md",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "4cff93b9e8f559830239b74ee912725513ce046e",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662f9f65c50bd21d05ffdee9.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "4bb9cd3ad62b572df845a78672e0b21c3e994443",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fa453ec8033322b3ab2e3.md",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "2b6b033fce5f1228ea15aa55035d277fee85077f",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fc35902038376c7a00b3c.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "767c9c4f043405d60efeaf03dae28ab119f431dc",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66335223f3e2a31d62d84367.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "afe4a4b500557bd25c1732e3b9e0168c51c544b0",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/663353465bfb14259717da93.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "a86e8fab60b1753ae08a7c20d1251e34a4d1263a",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b26c4f2d603072ef0818.md",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b0ba04423b9d0981453df5445f4ce8e61a4831e1",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b4d3271d5b3aea1c1195.md",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "af06d95e150d51f5cea0544a8cf49d51fef094b3",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bdc3ca38c068c3735984.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "3d29b59fbfd71f58386bc322cb68fd7e29811389",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bfcef57e1d70cc3142c6.md",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "c3fbb93afa003c93fc3ca6b1fe4c509cb1448866",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633c06601c081735063b528.md",
            "status": "added",
            "additions": 329,
            "deletions": 0,
            "changes": 329,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "7a5dc5ce39e5eba44b6d2e35b025007821bba047",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6634fa2417d7194b0c9425f9.md",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "6841ba5771d91dedf28c95bd710c1e0c18045ce2",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475bab40e5125c84b03337.md",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b9ea0fe21ec83155050358605c83ff08a9e70324",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475d40dd42fb614f14fd03.md",
            "status": "added",
            "additions": 201,
            "deletions": 0,
            "changes": 201,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "70fb15ef003f144416e3939aae0e2d8a14f106c7",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475e40f3891c645d50135e.md",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "49dd62d1c58388faf938ce720da442332b4d02c0",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475f7b91d7c6681987739d.md",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "a8c7d3d299897690a7d2d202b8869208db5b1ca7",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/665d949e628d9f3fe305b6e8.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "81d985809714b0ca514f09d38e4b368397ff0bbf",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66601c3c460ee12fbd669d6a.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "56966b5faea5d838476dfaeb0b5b976bb76333ca",
            "filename": "curriculum/challenges/korean/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66671a41b55e531d08ab82b5.md",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fkorean%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "a22ed38e33c4b1809941a564ab53f5591ef63641",
            "filename": "curriculum/challenges/portuguese/00-certifications/b1-english-for-developers-certification/b1-english-for-developers-certification.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F00-certifications%2Fb1-english-for-developers-certification%2Fb1-english-for-developers-certification.yml",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F00-certifications%2Fb1-english-for-developers-certification%2Fb1-english-for-developers-certification.yml",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F00-certifications%2Fb1-english-for-developers-certification%2Fb1-english-for-developers-certification.yml?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "abf4a3fbf33486dfa17f944cc8b14021a8a045e7",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65f569725359e10d345bc52a.md",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "db286166f195ed43a10e0605bfc4be0fc2f6c69c",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4b3bedee044b4b957d33.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b9cd836b59b48f169c5d29a78dac81b1940b204c",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4bd84561a14d3e720061.md",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "8c5270d99f59f323256adadc87929e55f6123f4c",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660400f02cf3a76795b82d4e.md",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "eefd3dc7de816fb5abe2e8953fa8f6d6989ad361",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660fcf3e1b9bb056b2edb567.md",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "ccfbf71ff43271f6871fdb3cf38d0f2c27675c7f",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6616ec0bf9ee8548ce6b0f08.md",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "4cff93b9e8f559830239b74ee912725513ce046e",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662f9f65c50bd21d05ffdee9.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "4bb9cd3ad62b572df845a78672e0b21c3e994443",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fa453ec8033322b3ab2e3.md",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "2b6b033fce5f1228ea15aa55035d277fee85077f",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fc35902038376c7a00b3c.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "767c9c4f043405d60efeaf03dae28ab119f431dc",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66335223f3e2a31d62d84367.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "afe4a4b500557bd25c1732e3b9e0168c51c544b0",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/663353465bfb14259717da93.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "a86e8fab60b1753ae08a7c20d1251e34a4d1263a",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b26c4f2d603072ef0818.md",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b0ba04423b9d0981453df5445f4ce8e61a4831e1",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b4d3271d5b3aea1c1195.md",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "af06d95e150d51f5cea0544a8cf49d51fef094b3",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bdc3ca38c068c3735984.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "3d29b59fbfd71f58386bc322cb68fd7e29811389",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bfcef57e1d70cc3142c6.md",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "c3fbb93afa003c93fc3ca6b1fe4c509cb1448866",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633c06601c081735063b528.md",
            "status": "added",
            "additions": 329,
            "deletions": 0,
            "changes": 329,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "7a5dc5ce39e5eba44b6d2e35b025007821bba047",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6634fa2417d7194b0c9425f9.md",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "6841ba5771d91dedf28c95bd710c1e0c18045ce2",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475bab40e5125c84b03337.md",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b9ea0fe21ec83155050358605c83ff08a9e70324",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475d40dd42fb614f14fd03.md",
            "status": "added",
            "additions": 201,
            "deletions": 0,
            "changes": 201,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "70fb15ef003f144416e3939aae0e2d8a14f106c7",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475e40f3891c645d50135e.md",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "49dd62d1c58388faf938ce720da442332b4d02c0",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475f7b91d7c6681987739d.md",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "a8c7d3d299897690a7d2d202b8869208db5b1ca7",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/665d949e628d9f3fe305b6e8.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "81d985809714b0ca514f09d38e4b368397ff0bbf",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66601c3c460ee12fbd669d6a.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "56966b5faea5d838476dfaeb0b5b976bb76333ca",
            "filename": "curriculum/challenges/portuguese/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66671a41b55e531d08ab82b5.md",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fportuguese%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "abf4a3fbf33486dfa17f944cc8b14021a8a045e7",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65f569725359e10d345bc52a.md",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "db286166f195ed43a10e0605bfc4be0fc2f6c69c",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4b3bedee044b4b957d33.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b9cd836b59b48f169c5d29a78dac81b1940b204c",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4bd84561a14d3e720061.md",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "8c5270d99f59f323256adadc87929e55f6123f4c",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660400f02cf3a76795b82d4e.md",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "eefd3dc7de816fb5abe2e8953fa8f6d6989ad361",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660fcf3e1b9bb056b2edb567.md",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "ccfbf71ff43271f6871fdb3cf38d0f2c27675c7f",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6616ec0bf9ee8548ce6b0f08.md",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "4cff93b9e8f559830239b74ee912725513ce046e",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662f9f65c50bd21d05ffdee9.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "4bb9cd3ad62b572df845a78672e0b21c3e994443",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fa453ec8033322b3ab2e3.md",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "2b6b033fce5f1228ea15aa55035d277fee85077f",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fc35902038376c7a00b3c.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "767c9c4f043405d60efeaf03dae28ab119f431dc",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66335223f3e2a31d62d84367.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "afe4a4b500557bd25c1732e3b9e0168c51c544b0",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/663353465bfb14259717da93.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "a86e8fab60b1753ae08a7c20d1251e34a4d1263a",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b26c4f2d603072ef0818.md",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b0ba04423b9d0981453df5445f4ce8e61a4831e1",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b4d3271d5b3aea1c1195.md",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "af06d95e150d51f5cea0544a8cf49d51fef094b3",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bdc3ca38c068c3735984.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "3d29b59fbfd71f58386bc322cb68fd7e29811389",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bfcef57e1d70cc3142c6.md",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "c3fbb93afa003c93fc3ca6b1fe4c509cb1448866",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633c06601c081735063b528.md",
            "status": "added",
            "additions": 329,
            "deletions": 0,
            "changes": 329,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "7a5dc5ce39e5eba44b6d2e35b025007821bba047",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6634fa2417d7194b0c9425f9.md",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "6841ba5771d91dedf28c95bd710c1e0c18045ce2",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475bab40e5125c84b03337.md",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b9ea0fe21ec83155050358605c83ff08a9e70324",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475d40dd42fb614f14fd03.md",
            "status": "added",
            "additions": 201,
            "deletions": 0,
            "changes": 201,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "70fb15ef003f144416e3939aae0e2d8a14f106c7",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475e40f3891c645d50135e.md",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "49dd62d1c58388faf938ce720da442332b4d02c0",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475f7b91d7c6681987739d.md",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "a8c7d3d299897690a7d2d202b8869208db5b1ca7",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/665d949e628d9f3fe305b6e8.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "81d985809714b0ca514f09d38e4b368397ff0bbf",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66601c3c460ee12fbd669d6a.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "56966b5faea5d838476dfaeb0b5b976bb76333ca",
            "filename": "curriculum/challenges/swahili/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66671a41b55e531d08ab82b5.md",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fswahili%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "abf4a3fbf33486dfa17f944cc8b14021a8a045e7",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65f569725359e10d345bc52a.md",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65f569725359e10d345bc52a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "db286166f195ed43a10e0605bfc4be0fc2f6c69c",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4b3bedee044b4b957d33.md",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4b3bedee044b4b957d33.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b9cd836b59b48f169c5d29a78dac81b1940b204c",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/65fd4bd84561a14d3e720061.md",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F65fd4bd84561a14d3e720061.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "8c5270d99f59f323256adadc87929e55f6123f4c",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660400f02cf3a76795b82d4e.md",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660400f02cf3a76795b82d4e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "eefd3dc7de816fb5abe2e8953fa8f6d6989ad361",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/660fcf3e1b9bb056b2edb567.md",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F660fcf3e1b9bb056b2edb567.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "ccfbf71ff43271f6871fdb3cf38d0f2c27675c7f",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6616ec0bf9ee8548ce6b0f08.md",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6616ec0bf9ee8548ce6b0f08.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "4cff93b9e8f559830239b74ee912725513ce046e",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662f9f65c50bd21d05ffdee9.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662f9f65c50bd21d05ffdee9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "4bb9cd3ad62b572df845a78672e0b21c3e994443",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fa453ec8033322b3ab2e3.md",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fa453ec8033322b3ab2e3.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "2b6b033fce5f1228ea15aa55035d277fee85077f",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/662fc35902038376c7a00b3c.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F662fc35902038376c7a00b3c.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "767c9c4f043405d60efeaf03dae28ab119f431dc",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66335223f3e2a31d62d84367.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66335223f3e2a31d62d84367.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "afe4a4b500557bd25c1732e3b9e0168c51c544b0",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/663353465bfb14259717da93.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F663353465bfb14259717da93.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "a86e8fab60b1753ae08a7c20d1251e34a4d1263a",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b26c4f2d603072ef0818.md",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b26c4f2d603072ef0818.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b0ba04423b9d0981453df5445f4ce8e61a4831e1",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633b4d3271d5b3aea1c1195.md",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633b4d3271d5b3aea1c1195.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "af06d95e150d51f5cea0544a8cf49d51fef094b3",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bdc3ca38c068c3735984.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bdc3ca38c068c3735984.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "3d29b59fbfd71f58386bc322cb68fd7e29811389",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633bfcef57e1d70cc3142c6.md",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633bfcef57e1d70cc3142c6.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "c3fbb93afa003c93fc3ca6b1fe4c509cb1448866",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6633c06601c081735063b528.md",
            "status": "added",
            "additions": 329,
            "deletions": 0,
            "changes": 329,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6633c06601c081735063b528.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "7a5dc5ce39e5eba44b6d2e35b025007821bba047",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/6634fa2417d7194b0c9425f9.md",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F6634fa2417d7194b0c9425f9.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "6841ba5771d91dedf28c95bd710c1e0c18045ce2",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475bab40e5125c84b03337.md",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475bab40e5125c84b03337.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "b9ea0fe21ec83155050358605c83ff08a9e70324",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475d40dd42fb614f14fd03.md",
            "status": "added",
            "additions": 201,
            "deletions": 0,
            "changes": 201,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475d40dd42fb614f14fd03.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "70fb15ef003f144416e3939aae0e2d8a14f106c7",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475e40f3891c645d50135e.md",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475e40f3891c645d50135e.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "49dd62d1c58388faf938ce720da442332b4d02c0",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66475f7b91d7c6681987739d.md",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66475f7b91d7c6681987739d.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "a8c7d3d299897690a7d2d202b8869208db5b1ca7",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/665d949e628d9f3fe305b6e8.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F665d949e628d9f3fe305b6e8.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "81d985809714b0ca514f09d38e4b368397ff0bbf",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66601c3c460ee12fbd669d6a.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66601c3c460ee12fbd669d6a.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "56966b5faea5d838476dfaeb0b5b976bb76333ca",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-encapsulation-by-building-a-projectile-trajectory-calculator/66671a41b55e531d08ab82b5.md",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2F66671a41b55e531d08ab82b5.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "c6726f93b097ded65075a80de7fb56874c28c930",
            "filename": "curriculum/challenges/ukrainian/07-scientific-computing-with-python/learn-string-manipulation-by-building-a-cipher/6555db4a7b788e15795674e5.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-string-manipulation-by-building-a-cipher%2F6555db4a7b788e15795674e5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-string-manipulation-by-building-a-cipher%2F6555db4a7b788e15795674e5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F07-scientific-computing-with-python%2Flearn-string-manipulation-by-building-a-cipher%2F6555db4a7b788e15795674e5.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        },
        {
            "sha": "62072f28fcf32fd09a2f5d196dc7b84e17bc0d81",
            "filename": "curriculum/challenges/ukrainian/14-responsive-web-design-22/learn-html-by-building-a-cat-photo-app/5dfb5ecbeacea3f48c6300b1.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F14-responsive-web-design-22%2Flearn-html-by-building-a-cat-photo-app%2F5dfb5ecbeacea3f48c6300b1.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b/curriculum%2Fchallenges%2Fukrainian%2F14-responsive-web-design-22%2Flearn-html-by-building-a-cat-photo-app%2F5dfb5ecbeacea3f48c6300b1.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fukrainian%2F14-responsive-web-design-22%2Flearn-html-by-building-a-cat-photo-app%2F5dfb5ecbeacea3f48c6300b1.md?ref=9fd3c0c93c461c680e3a2d7cd6bbe70b14bcca4b"
        }
    ],
    "stats": {
        "total": 40708,
        "additions": 40704,
        "deletions": 4
    }
}