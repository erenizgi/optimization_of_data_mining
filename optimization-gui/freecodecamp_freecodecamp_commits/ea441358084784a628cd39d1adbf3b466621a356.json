{
    "author": "ShaunSHamilton",
    "message": "feat(api): add exam-environment endpoints (#55662)\n\nCo-authored-by: moT01 <20648924+moT01@users.noreply.github.com>\r\nCo-authored-by: Oliver Eyton-Williams <ojeytonwilliams@gmail.com>",
    "sha": "ea441358084784a628cd39d1adbf3b466621a356",
    "files": [
        {
            "sha": "56b5d68054e345f231df0a2cf0c8b105b3926fff",
            "filename": ".dockerignore",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/.dockerignore",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/.dockerignore",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/.dockerignore?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -8,3 +8,5 @@ docker/**/Dockerfile\n **/*docker-compose*\n **/node_modules\n .eslintcache\n+api/__mocks__\n+api/src/exam-environment/seed"
        },
        {
            "sha": "14919f7207f3ccb2c05e53ed5100114f6c7ba512",
            "filename": "api/README.md",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2FREADME.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2FREADME.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2FREADME.md?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -28,3 +28,9 @@ pnpm seed\n ## Login in development/testing\n \n During development and testing, the api exposes the endpoint GET auth/dev-callback. Calling this will log you in as the user with the email `foo@bar.com` by setting the session cookie for that user.\n+\n+## Generating Exams\n+\n+```bash\n+pnpm run generate-exams <ENV_EXAM_ID> <NUMBER_OF_EXAMS_TO_GENERATE>\n+```"
        },
        {
            "sha": "7f690c2cc76c00062fc66eaf810a6ce640ea7385",
            "filename": "api/__mocks__/env-exam.ts",
            "status": "added",
            "additions": 370,
            "deletions": 0,
            "changes": 370,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2F__mocks__%2Fenv-exam.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2F__mocks__%2Fenv-exam.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2F__mocks__%2Fenv-exam.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,370 @@\n+import { Static } from '@fastify/type-provider-typebox';\n+import {\n+  EnvConfig,\n+  EnvQuestionType,\n+  EnvExamAttempt,\n+  EnvExam,\n+  EnvGeneratedExam,\n+  EnvQuestionSet\n+} from '@prisma/client';\n+import { ObjectId } from 'mongodb';\n+// import { defaultUserId } from '../jest.utils';\n+import { examEnvironmentPostExamAttempt } from '../src/exam-environment/schemas';\n+// import { generateExam } from '../src/exam-environment/utils/exam';\n+\n+export const oid = () => new ObjectId().toString();\n+\n+const defaultUserId = '64c7810107dd4782d32baee7';\n+\n+export const examId = oid();\n+\n+export const config: EnvConfig = {\n+  totalTimeInMS: 2 * 60 * 60 * 1000,\n+  tags: [],\n+  name: 'Test Exam',\n+  note: 'Some exam note...',\n+  questionSets: [\n+    {\n+      type: EnvQuestionType.MultipleChoice,\n+      numberOfSet: 1,\n+      numberOfQuestions: 1,\n+      numberOfCorrectAnswers: 1,\n+      numberOfIncorrectAnswers: 1\n+    },\n+    {\n+      type: EnvQuestionType.MultipleChoice,\n+      numberOfSet: 1,\n+      numberOfQuestions: 1,\n+      numberOfCorrectAnswers: 2,\n+      numberOfIncorrectAnswers: 1\n+    },\n+    {\n+      type: EnvQuestionType.Dialogue,\n+      numberOfSet: 1,\n+      numberOfQuestions: 2,\n+      numberOfCorrectAnswers: 1,\n+      numberOfIncorrectAnswers: 1\n+    }\n+  ]\n+};\n+\n+export const questionSets: EnvQuestionSet[] = [\n+  {\n+    id: oid(),\n+    type: EnvQuestionType.MultipleChoice,\n+    context: null,\n+    questions: [\n+      {\n+        id: oid(),\n+        tags: ['q1t1'],\n+        text: 'Question 1',\n+        deprecated: false,\n+        audio: null,\n+        answers: [\n+          {\n+            id: oid(),\n+            text: 'Answer 1',\n+            isCorrect: true\n+          },\n+          {\n+            id: oid(),\n+            text: 'Answer 2',\n+            isCorrect: true\n+          },\n+          {\n+            id: oid(),\n+            text: 'Answer 3',\n+            isCorrect: false\n+          }\n+        ]\n+      }\n+    ]\n+  },\n+  {\n+    id: oid(),\n+    type: EnvQuestionType.MultipleChoice,\n+    context: null,\n+    questions: [\n+      {\n+        id: oid(),\n+        tags: [],\n+        text: 'Question 1',\n+        deprecated: false,\n+        audio: null,\n+        answers: [\n+          {\n+            id: oid(),\n+            text: 'Answer 1',\n+            isCorrect: true\n+          },\n+          {\n+            id: oid(),\n+            text: 'Answer 2',\n+            isCorrect: false\n+          },\n+          {\n+            id: oid(),\n+            text: 'Answer 3',\n+            isCorrect: false\n+          }\n+        ]\n+      }\n+    ]\n+  },\n+  {\n+    id: oid(),\n+    type: EnvQuestionType.Dialogue,\n+    context: 'Dialogue 1 context',\n+    questions: [\n+      {\n+        id: oid(),\n+        tags: ['q1t1'],\n+        text: 'Question 1',\n+        deprecated: false,\n+        audio: null,\n+        answers: [\n+          {\n+            id: oid(),\n+            text: 'Answer 1',\n+            isCorrect: true\n+          },\n+          {\n+            id: oid(),\n+            text: 'Answer 2',\n+            isCorrect: false\n+          },\n+          {\n+            id: oid(),\n+            text: 'Answer 3',\n+            isCorrect: false\n+          }\n+        ]\n+      },\n+      {\n+        id: oid(),\n+        tags: ['q2t1', 'q2t2'],\n+        text: 'Question 2',\n+        deprecated: true,\n+        audio: {\n+          url: 'https://freecodecamp.org',\n+          captions: null\n+        },\n+        answers: [\n+          {\n+            id: oid(),\n+            text: 'Answer 1',\n+            isCorrect: true\n+          },\n+          {\n+            id: oid(),\n+            text: 'Answer 2',\n+            isCorrect: false\n+          },\n+          {\n+            id: oid(),\n+            text: 'Answer 3',\n+            isCorrect: false\n+          }\n+        ]\n+      },\n+      {\n+        id: oid(),\n+        tags: ['q3t1', 'q3t2'],\n+        text: 'Question 3',\n+        deprecated: false,\n+        audio: null,\n+        answers: [\n+          {\n+            id: oid(),\n+            text: 'Answer 1',\n+            isCorrect: true\n+          },\n+          {\n+            id: oid(),\n+            text: 'Answer 2',\n+            isCorrect: false\n+          },\n+          {\n+            id: oid(),\n+            text: 'Answer 3',\n+            isCorrect: false\n+          }\n+        ]\n+      }\n+    ]\n+  }\n+];\n+\n+export const generatedExam: EnvGeneratedExam = {\n+  examId,\n+  id: oid(),\n+  deprecated: false,\n+  questionSets: [\n+    {\n+      id: questionSets[0]!.id,\n+      questions: [\n+        {\n+          id: questionSets[0]!.questions[0]!.id,\n+          answers: [\n+            questionSets[0]!.questions[0]!.answers[0]!.id,\n+            questionSets[0]!.questions[0]!.answers[1]!.id\n+          ]\n+        }\n+      ]\n+    },\n+    {\n+      id: questionSets[1]!.id,\n+      questions: [\n+        {\n+          id: questionSets[1]!.questions[0]!.id,\n+          answers: [\n+            questionSets[1]!.questions[0]!.answers[0]!.id,\n+            questionSets[1]!.questions[0]!.answers[1]!.id,\n+            questionSets[1]!.questions[0]!.answers[2]!.id\n+          ]\n+        }\n+      ]\n+    },\n+    {\n+      id: questionSets[2]!.id,\n+      questions: [\n+        {\n+          id: questionSets[2]!.questions[0]!.id,\n+          answers: [\n+            questionSets[2]!.questions[0]!.answers[0]!.id,\n+            questionSets[2]!.questions[0]!.answers[1]!.id,\n+            questionSets[2]!.questions[0]!.answers[2]!.id\n+          ]\n+        },\n+        {\n+          id: questionSets[2]!.questions[1]!.id,\n+          answers: [\n+            questionSets[2]!.questions[1]!.answers[0]!.id,\n+            questionSets[2]!.questions[1]!.answers[1]!.id,\n+            questionSets[2]!.questions[1]!.answers[2]!.id\n+          ]\n+        }\n+      ]\n+    }\n+  ]\n+};\n+\n+export const examAttempt: EnvExamAttempt = {\n+  examId,\n+  generatedExamId: generatedExam.id,\n+  id: oid(),\n+  needsRetake: false,\n+  questionSets: [\n+    {\n+      id: generatedExam.questionSets[0]!.id,\n+      questions: [\n+        {\n+          id: generatedExam.questionSets[0]!.questions[0]!.id,\n+          answers: [generatedExam.questionSets[0]!.questions[0]!.answers[0]!],\n+          submissionTimeInMS: Date.now()\n+        }\n+      ]\n+    },\n+    {\n+      id: generatedExam.questionSets[1]!.id,\n+      questions: [\n+        {\n+          id: generatedExam.questionSets[1]!.questions[0]!.id,\n+          answers: [generatedExam.questionSets[1]!.questions[0]!.answers[1]!],\n+          submissionTimeInMS: Date.now()\n+        }\n+      ]\n+    },\n+    {\n+      id: generatedExam.questionSets[2]!.id,\n+      questions: [\n+        {\n+          id: generatedExam.questionSets[2]!.questions[0]!.id,\n+          answers: [generatedExam.questionSets[2]!.questions[0]!.answers[1]!],\n+          submissionTimeInMS: Date.now()\n+        },\n+        {\n+          id: generatedExam.questionSets[2]!.questions[1]!.id,\n+          answers: [generatedExam.questionSets[2]!.questions[1]!.answers[0]!],\n+          submissionTimeInMS: Date.now()\n+        }\n+      ]\n+    }\n+  ],\n+  startTimeInMS: Date.now(),\n+  userId: defaultUserId,\n+  submissionTimeInMS: null\n+};\n+\n+export const examAttemptSansSubmissionTimeInMS: Static<\n+  typeof examEnvironmentPostExamAttempt.body\n+>['attempt'] = {\n+  examId,\n+  questionSets: [\n+    {\n+      id: generatedExam.questionSets[0]!.id,\n+      questions: [\n+        {\n+          id: generatedExam.questionSets[0]!.questions[0]!.id,\n+          answers: [generatedExam.questionSets[0]!.questions[0]!.answers[0]!]\n+        }\n+      ]\n+    },\n+    {\n+      id: generatedExam.questionSets[1]!.id,\n+      questions: [\n+        {\n+          id: generatedExam.questionSets[1]!.questions[0]!.id,\n+          answers: [generatedExam.questionSets[1]!.questions[0]!.answers[1]!]\n+        }\n+      ]\n+    },\n+    {\n+      id: generatedExam.questionSets[2]!.id,\n+      questions: [\n+        {\n+          id: generatedExam.questionSets[2]!.questions[0]!.id,\n+          answers: [generatedExam.questionSets[2]!.questions[0]!.answers[1]!]\n+        },\n+        {\n+          id: generatedExam.questionSets[2]!.questions[1]!.id,\n+          answers: [generatedExam.questionSets[2]!.questions[1]!.answers[0]!]\n+        }\n+      ]\n+    }\n+  ]\n+};\n+\n+export const exam: EnvExam = {\n+  id: examId,\n+  config,\n+  questionSets\n+};\n+\n+export async function seedEnvExam() {\n+  await fastifyTestInstance.prisma.envExamAttempt.deleteMany({});\n+  await fastifyTestInstance.prisma.envGeneratedExam.deleteMany({});\n+  await fastifyTestInstance.prisma.envExam.deleteMany({});\n+\n+  await fastifyTestInstance.prisma.envExam.create({\n+    data: exam\n+  });\n+  await fastifyTestInstance.prisma.envGeneratedExam.create({\n+    data: generatedExam\n+  });\n+\n+  // TODO: This would be nice to use, but the test logic for examAttempt need to account\n+  //       for dynamic ids.\n+  // let numberOfExamsGenerated = 0;\n+  // while (numberOfExamsGenerated < 2) {\n+  //   try {\n+  //     const generatedExam = generateExam(exam);\n+  //     await fastifyTestInstance.prisma.envGeneratedExam.create({\n+  //       data: generatedExam\n+  //     });\n+  //     numberOfExamsGenerated++;\n+  //   } catch (_e) {\n+  //     //\n+  //   }\n+  // }\n+}"
        },
        {
            "sha": "9a0e509ba31a95df66c7535297520edc2c77129a",
            "filename": "api/package.json",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fpackage.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fpackage.json?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -47,7 +47,8 @@\n     \"jest\": \"29.7.0\",\n     \"prisma\": \"5.5.2\",\n     \"supertest\": \"6.3.3\",\n-    \"ts-jest\": \"29.1.2\"\n+    \"ts-jest\": \"29.1.2\",\n+    \"tsx\": \"4.19.1\"\n   },\n   \"engines\": {\n     \"node\": \">=18\",\n@@ -79,7 +80,9 @@\n     \"test\": \"jest --force-exit\",\n     \"prisma\": \"dotenv -e ../.env prisma\",\n     \"postinstall\": \"prisma generate\",\n-    \"lint\": \"cd .. && eslint api/src --max-warnings 0\"\n+    \"lint\": \"cd .. && eslint api/src --max-warnings 0\",\n+    \"generate-exams\": \"tsx src/exam-environment/generate/index.ts\",\n+    \"seed:env-exam\": \"tsx src/exam-environment/seed/index.ts\"\n   },\n   \"version\": \"0.0.1\"\n }"
        },
        {
            "sha": "4d823ea6af9cb26222a911319079322bc8054aca",
            "filename": "api/prisma/schema.prisma",
            "status": "modified",
            "additions": 193,
            "deletions": 1,
            "changes": 194,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fprisma%2Fschema.prisma",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fprisma%2Fschema.prisma",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fprisma%2Fschema.prisma?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -141,6 +141,187 @@ model user {\n   website                      String? // Undefined\n   yearsTopContributor          String[] // Undefined | String[]\n   isClassroomAccount           Boolean? // Undefined\n+\n+  // Relations\n+  examAttempts EnvExamAttempt[]\n+}\n+\n+// -----------------------------------\n+\n+/// An exam for the Exam Environment App as designed by the examiners\n+model EnvExam {\n+  /// Globally unique exam id\n+  id           String           @id @default(auto()) @map(\"_id\") @db.ObjectId\n+  /// All questions for a given exam\n+  questionSets EnvQuestionSet[]\n+  /// Configuration for exam metadata\n+  config       EnvConfig\n+\n+  // Relations\n+  generatedExams EnvGeneratedExam[]\n+  examAttempts   EnvExamAttempt[]\n+}\n+\n+/// A grouping of one or more questions of a given type\n+type EnvQuestionSet {\n+  /// Unique question type id\n+  id        String                      @db.ObjectId\n+  type      EnvQuestionType\n+  /// Content related to all questions in set\n+  context   String?\n+  questions EnvMultipleChoiceQuestion[]\n+}\n+\n+/// A multiple choice question for the Exam Environment App\n+type EnvMultipleChoiceQuestion {\n+  /// Unique question id\n+  id         String      @db.ObjectId\n+  /// Main question paragraph\n+  text       String\n+  /// Zero or more tags given to categorize a question\n+  tags       String[]\n+  /// Optional audio for a question\n+  audio      EnvAudio?\n+  /// Available possible answers for an exam\n+  answers    EnvAnswer[]\n+  /// TODO Possible \"deprecated_time\" to remove after all exams could possibly have been taken\n+  deprecated Boolean\n+}\n+\n+/// Audio for an Exam Environment App multiple choice question\n+type EnvAudio {\n+  /// Optional text for audio\n+  captions String?\n+  /// URL to audio file\n+  ///\n+  /// Expected in the format: `<url>#t=<start_time_in_seconds>,<end_time_in_seconds>`\n+  /// Where `start_time_in_seconds` and `end_time_in_seconds` are optional floats.\n+  url      String\n+}\n+\n+/// Type of question for the Exam Environment App\n+enum EnvQuestionType {\n+  /// Single question with one or more answers\n+  MultipleChoice\n+  /// Mass text\n+  Dialogue\n+}\n+\n+/// Answer for an Exam Environment App multiple choice question\n+type EnvAnswer {\n+  /// Unique answer id\n+  id        String  @db.ObjectId\n+  /// Whether the answer is correct\n+  isCorrect Boolean\n+  /// Answer paragraph\n+  text      String\n+}\n+\n+/// Configuration for an exam in the Exam Environment App\n+type EnvConfig {\n+  /// Human-readable exam name\n+  name          String\n+  /// Notes given about exam\n+  note          String\n+  /// Category configuration for question selection\n+  tags          EnvTagConfig[]\n+  /// Total time allocated for exam in milliseconds\n+  totalTimeInMS Int\n+  /// Configuration for sets of questions\n+  questionSets  EnvQuestionSetConfig[]\n+}\n+\n+/// Configuration for a set of questions in the Exam Environment App\n+type EnvQuestionSetConfig {\n+  type                     EnvQuestionType\n+  /// Number of this grouping of questions per exam\n+  numberOfSet              Int\n+  /// Number of multiple choice questions per grouping matching this set config\n+  numberOfQuestions        Int\n+  /// Number of correct answers given per multiple choice question\n+  numberOfCorrectAnswers   Int\n+  /// Number of incorrect answers given per multiple choice question\n+  numberOfIncorrectAnswers Int\n+}\n+\n+/// Configuration for tags in the Exam Environment App\n+///\n+/// This configures the number of questions that should resolve to a given tag set criteria.\n+type EnvTagConfig {\n+  /// Group of multiple choice question tags\n+  group             String[]\n+  /// Number of multiple choice questions per exam that should meet the group criteria\n+  numberOfQuestions Int\n+}\n+\n+/// An attempt at an exam in the Exam Environment App\n+model EnvExamAttempt {\n+  id              String @id @default(auto()) @map(\"_id\") @db.ObjectId\n+  /// Foriegn key to user\n+  userId          String @db.ObjectId\n+  /// Foreign key to exam\n+  examId          String @db.ObjectId\n+  /// Foreign key to generated exam id\n+  generatedExamId String @db.ObjectId\n+\n+  questionSets       EnvQuestionSetAttempt[]\n+  /// Time exam was started as milliseconds since epoch\n+  startTimeInMS      Int\n+  /// Time exam was submitted as milliseconds since epoch\n+  ///\n+  /// As attempt might not be submitted (disconnection or quit), field is optional\n+  submissionTimeInMS Int?\n+  needsRetake        Boolean\n+\n+  // Relations\n+  user          user             @relation(fields: [userId], references: [id])\n+  exam          EnvExam          @relation(fields: [examId], references: [id])\n+  generatedExam EnvGeneratedExam @relation(fields: [generatedExamId], references: [id])\n+}\n+\n+type EnvQuestionSetAttempt {\n+  id        String                             @db.ObjectId\n+  questions EnvMultipleChoiceQuestionAttempt[]\n+}\n+\n+type EnvMultipleChoiceQuestionAttempt {\n+  /// Foreign key to question\n+  id                 String   @db.ObjectId\n+  /// An array of foreign keys to answers\n+  answers            String[] @db.ObjectId\n+  /// Time answers to question were submitted as milliseconds since epoch\n+  ///\n+  /// If the question is later revisited, this field is updated\n+  submissionTimeInMS Int\n+}\n+\n+/// A generated exam for the Exam Environment App\n+///\n+/// This is the user-facing information for an exam.\n+/// TODO: Add userId?\n+model EnvGeneratedExam {\n+  id           String                    @id @default(auto()) @map(\"_id\") @db.ObjectId\n+  /// Foreign key to exam\n+  examId       String                    @db.ObjectId\n+  questionSets EnvGeneratedQuestionSet[]\n+  /// If `deprecated`, the generation should not longer be considered for users\n+  deprecated   Boolean\n+\n+  // Relations\n+  exam           EnvExam          @relation(fields: [examId], references: [id])\n+  EnvExamAttempt EnvExamAttempt[]\n+}\n+\n+type EnvGeneratedQuestionSet {\n+  id        String                               @db.ObjectId\n+  questions EnvGeneratedMultipleChoiceQuestion[]\n+}\n+\n+type EnvGeneratedMultipleChoiceQuestion {\n+  /// Foreign key to question id\n+  id      String   @db.ObjectId\n+  /// Each item is a foreign key to an answer\n+  answers String[] @db.ObjectId\n }\n \n // -----------------------------------\n@@ -178,7 +359,7 @@ model Donation {\n }\n \n model UserRateLimit {\n-  id             String  @id @map(\"_id\")\n+  id             String   @id @map(\"_id\")\n   counter        Int\n   expirationDate DateTime @db.Date\n \n@@ -194,6 +375,17 @@ model UserToken {\n   @@index([userId], map: \"userId_1\")\n }\n \n+/// TODO: Token has to outlive the exam attempt\n+/// Validation has to be taken as the attempt is requested\n+/// to ensure it lives long enough.\n+model ExamEnvironmentAuthorizationToken {\n+  id          String   @id @map(\"_id\")\n+  createdDate DateTime @db.Date\n+  userId      String   @db.ObjectId\n+\n+  @@index([userId], map: \"userId_1\")\n+}\n+\n model sessions {\n   id      String   @id @map(\"_id\")\n   expires DateTime @db.Date"
        },
        {
            "sha": "9c92a80f9d38e24d4961d20bc110fa41dc2a0e65",
            "filename": "api/src/app.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 1,
            "changes": 19,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fapp.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fapp.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fapp.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -34,9 +34,14 @@ import {\n   API_LOCATION,\n   EMAIL_PROVIDER,\n   FCC_ENABLE_DEV_LOGIN_MODE,\n-  FCC_ENABLE_SWAGGER_UI\n+  FCC_ENABLE_SWAGGER_UI,\n+  FREECODECAMP_NODE_ENV\n } from './utils/env';\n import { isObjectID } from './utils/validation';\n+import {\n+  examEnvironmentOpenRoutes,\n+  examEnvironmentValidatedTokenRoutes\n+} from './exam-environment/routes/exam-environment';\n \n type FastifyInstanceWithTypeProvider = FastifyInstance<\n   RawServerDefault,\n@@ -174,6 +179,18 @@ export const build = async (\n       await fastify.register(publicRoutes.authRoutes);\n     }\n   });\n+\n+  // NOTE: Code behind the `FREECODECAMP_NODE_ENV` var is not ready to be deployed yet.\n+  if (FREECODECAMP_NODE_ENV !== 'production') {\n+    void fastify.register(function (fastify, _opts, done) {\n+      fastify.addHook('onRequest', fastify.authorizeExamEnvironmentToken);\n+\n+      void fastify.register(examEnvironmentValidatedTokenRoutes);\n+      done();\n+    });\n+    void fastify.register(examEnvironmentOpenRoutes);\n+  }\n+\n   void fastify.register(publicRoutes.chargeStripeRoute);\n   void fastify.register(publicRoutes.signoutRoute);\n   void fastify.register(publicRoutes.emailSubscribtionRoutes);"
        },
        {
            "sha": "1f3d10b5122253015f9c473fd8a7fa2442387e89",
            "filename": "api/src/exam-environment/generate/index.ts",
            "status": "added",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fgenerate%2Findex.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fgenerate%2Findex.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fexam-environment%2Fgenerate%2Findex.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,54 @@\n+import { PrismaClient } from '@prisma/client';\n+import { generateExam } from '../utils/exam';\n+import { MONGOHQ_URL } from '../../utils/env';\n+\n+const args = process.argv.slice(2);\n+const ENV_EXAM_ID = args[0];\n+const NUMBER_OF_EXAMS_TO_GENERATE = Number(args[1]);\n+\n+if (!ENV_EXAM_ID) {\n+  throw 'First argument must be the EnvExam _id';\n+}\n+if (!NUMBER_OF_EXAMS_TO_GENERATE) {\n+  throw 'Second argument must be an unsigned integer';\n+}\n+\n+const prisma = new PrismaClient({\n+  datasources: {\n+    db: {\n+      url: MONGOHQ_URL\n+    }\n+  }\n+});\n+\n+/// TODO:\n+/// 1. Deprecate all previous generated exams for a given exam id?\n+async function main() {\n+  await prisma.$connect();\n+\n+  const exam = await prisma.envExam.findUnique({\n+    where: {\n+      id: ENV_EXAM_ID\n+    }\n+  });\n+\n+  if (!exam) {\n+    throw Error(`No exam with id \"${ENV_EXAM_ID}\" found.`);\n+  }\n+\n+  let numberOfExamsGenerated = 0;\n+\n+  while (numberOfExamsGenerated < NUMBER_OF_EXAMS_TO_GENERATE) {\n+    try {\n+      const generatedExam = generateExam(exam);\n+      await prisma.envGeneratedExam.create({\n+        data: generatedExam\n+      });\n+      numberOfExamsGenerated++;\n+    } catch (e) {\n+      console.log(e);\n+    }\n+  }\n+}\n+\n+void main();"
        },
        {
            "sha": "959cdc135142f914e1783b6ab0b68c360c217f66",
            "filename": "api/src/exam-environment/routes/exam-environment.test.ts",
            "status": "added",
            "additions": 594,
            "deletions": 0,
            "changes": 594,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Froutes%2Fexam-environment.test.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Froutes%2Fexam-environment.test.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fexam-environment%2Froutes%2Fexam-environment.test.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,594 @@\n+import { Static } from '@fastify/type-provider-typebox';\n+import {\n+  createSuperRequest,\n+  defaultUserId,\n+  devLogin,\n+  setupServer\n+} from '../../../jest.utils';\n+import {\n+  examEnvironmentPostExamAttempt,\n+  examEnvironmentPostExamGeneratedExam\n+} from '../schemas';\n+import * as mock from '../../../__mocks__/env-exam';\n+import { constructUserExam } from '../utils/exam';\n+\n+describe('/exam-environment/', () => {\n+  setupServer();\n+  describe('Authenticated user with exam environment authorization token', () => {\n+    let superPost: ReturnType<typeof createSuperRequest>;\n+    let examEnvironmentAuthorizationToken: string;\n+\n+    // Authenticate user\n+    beforeAll(async () => {\n+      const setCookies = await devLogin();\n+      superPost = createSuperRequest({ method: 'POST', setCookies });\n+      await mock.seedEnvExam();\n+      // Add exam environment authorization token\n+      const res = await superPost('/user/exam-environment/token');\n+      expect(res.status).toBe(200);\n+      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n+      examEnvironmentAuthorizationToken =\n+        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n+        res.body.data.examEnvironmentAuthorizationToken;\n+    });\n+\n+    describe('POST /exam-environment/exam/attempt', () => {\n+      afterEach(async () => {\n+        await fastifyTestInstance.prisma.envExamAttempt.deleteMany();\n+      });\n+\n+      it('should return an error if there are no current exam attempts matching the given id', async () => {\n+        const body: Static<typeof examEnvironmentPostExamAttempt.body> = {\n+          attempt: {\n+            examId: mock.oid(),\n+            questionSets: []\n+          }\n+        };\n+        const res = await superPost('/exam-environment/exam/attempt')\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          )\n+          .send(body);\n+\n+        expect(res.body).toStrictEqual({\n+          code: 'FCC_ERR_EXAM_ENVIRONMENT_EXAM_ATTEMPT',\n+          // NOTE: message may not necessarily be a part of the api compatability guarantee.\n+          //       That is, it could be changed without requiring a major version bump, because it is just\n+          //       a human-readable/debug message.\n+          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n+          message: expect.any(String)\n+        });\n+        expect(res.status).toBe(404);\n+      });\n+\n+      it('should return an error if the given exam id does not match an existing exam', async () => {\n+        const examId = mock.oid();\n+        // Create exam attempt with bad exam id\n+        await fastifyTestInstance.prisma.envExamAttempt.create({\n+          data: {\n+            examId,\n+            generatedExamId: mock.oid(),\n+            needsRetake: false,\n+            startTimeInMS: Date.now(),\n+            userId: defaultUserId\n+          }\n+        });\n+        const body: Static<typeof examEnvironmentPostExamAttempt.body> = {\n+          attempt: {\n+            examId,\n+            questionSets: []\n+          }\n+        };\n+        const res = await superPost('/exam-environment/exam/attempt')\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          )\n+          .send(body);\n+\n+        expect(res.body).toStrictEqual({\n+          code: 'FCC_ENOENT_EXAM_ENVIRONMENT_MISSING_EXAM',\n+          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n+          message: expect.any(String)\n+        });\n+        expect(res.status).toBe(404);\n+      });\n+\n+      it('should return an error if the attempt has expired', async () => {\n+        // Create exam attempt with expired time\n+        await fastifyTestInstance.prisma.envExamAttempt.create({\n+          data: {\n+            examId: mock.examId,\n+            generatedExamId: mock.oid(),\n+            needsRetake: false,\n+            startTimeInMS: Date.now() - (1000 * 60 * 60 * 2 + 1000),\n+            userId: defaultUserId\n+          }\n+        });\n+        const body: Static<typeof examEnvironmentPostExamAttempt.body> = {\n+          attempt: {\n+            examId: mock.examId,\n+            questionSets: []\n+          }\n+        };\n+        const res = await superPost('/exam-environment/exam/attempt')\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          )\n+          .send(body);\n+\n+        expect(res.body).toStrictEqual({\n+          code: 'FCC_EINVAL_EXAM_ENVIRONMENT_EXAM_ATTEMPT',\n+          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n+          message: expect.any(String)\n+        });\n+        expect(res.status).toBe(403);\n+      });\n+\n+      it('should return an error if there is no matching generated exam', async () => {\n+        // Create exam attempt with no matching generated exam\n+        await fastifyTestInstance.prisma.envExamAttempt.create({\n+          data: {\n+            examId: mock.examId,\n+            generatedExamId: mock.oid(),\n+            needsRetake: false,\n+            startTimeInMS: Date.now(),\n+            userId: defaultUserId\n+          }\n+        });\n+        const body: Static<typeof examEnvironmentPostExamAttempt.body> = {\n+          attempt: {\n+            examId: mock.examId,\n+            questionSets: []\n+          }\n+        };\n+        const res = await superPost('/exam-environment/exam/attempt')\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          )\n+          .send(body);\n+\n+        expect(res.body).toStrictEqual({\n+          code: 'FCC_ENOENT_EXAM_ENVIRONMENT_GENERATED_EXAM',\n+          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n+          message: expect.any(String)\n+        });\n+        expect(res.status).toBe(404);\n+      });\n+\n+      it('should return an error if the attempt does not match the generated exam', async () => {\n+        const attempt = await fastifyTestInstance.prisma.envExamAttempt.create({\n+          data: { ...mock.examAttempt, userId: defaultUserId }\n+        });\n+\n+        attempt.questionSets[0]!.id = mock.oid();\n+\n+        const body: Static<typeof examEnvironmentPostExamAttempt.body> = {\n+          attempt\n+        };\n+\n+        const res = await superPost('/exam-environment/exam/attempt')\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          )\n+          .send(body);\n+\n+        expect(res.body).toStrictEqual({\n+          code: 'FCC_EINVAL_EXAM_ENVIRONMENT_EXAM_ATTEMPT',\n+          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n+          message: expect.any(String)\n+        });\n+        expect(res.status).toBe(400);\n+\n+        // Database should mark attempt as `needsRetake`\n+        const updatedAttempt =\n+          await fastifyTestInstance.prisma.envExamAttempt.findUnique({\n+            where: { id: attempt.id }\n+          });\n+        expect(updatedAttempt).toHaveProperty('needsRetake', true);\n+      });\n+\n+      it('should return 200 if request is valid, and update attempt in database', async () => {\n+        const attempt = await fastifyTestInstance.prisma.envExamAttempt.create({\n+          data: {\n+            userId: defaultUserId,\n+            examId: mock.examId,\n+            generatedExamId: mock.generatedExam.id,\n+            startTimeInMS: Date.now(),\n+            questionSets: [],\n+            needsRetake: false\n+          }\n+        });\n+\n+        const body: Static<typeof examEnvironmentPostExamAttempt.body> = {\n+          attempt: mock.examAttemptSansSubmissionTimeInMS\n+        };\n+\n+        const res = await superPost('/exam-environment/exam/attempt')\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          )\n+          .send(body);\n+\n+        expect(res.status).toBe(200);\n+\n+        // Database should update attempt\n+        const updatedAttempt =\n+          await fastifyTestInstance.prisma.envExamAttempt.findUnique({\n+            where: { id: attempt.id }\n+          });\n+\n+        expect(updatedAttempt).toMatchObject(body.attempt);\n+      });\n+    });\n+\n+    describe('POST /exam-environment/generated-exam', () => {\n+      afterEach(async () => {\n+        await fastifyTestInstance.prisma.envExamAttempt.deleteMany();\n+        await mock.seedEnvExam();\n+      });\n+\n+      it('should return an error if the given exam id is invalid', async () => {\n+        const body: Static<typeof examEnvironmentPostExamGeneratedExam.body> = {\n+          examId: mock.oid()\n+        };\n+        const res = await superPost('/exam-environment/exam/generated-exam')\n+          .send(body)\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          );\n+\n+        expect(res.body).toStrictEqual({\n+          code: 'FCC_ENOENT_EXAM_ENVIRONMENT_MISSING_EXAM',\n+          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n+          message: expect.any(String)\n+        });\n+        expect(res.status).toBe(404);\n+      });\n+\n+      xit('should return an error if the exam prerequisites are not met', async () => {\n+        // TODO: Waiting on prerequisites\n+      });\n+\n+      it('should return an error if the exam has been attempted in the last 24 hours', async () => {\n+        const recentExamAttempt = {\n+          ...mock.examAttempt,\n+          // Set start time such that exam has just expired\n+          startTimeInMS: Date.now() - mock.exam.config.totalTimeInMS\n+        };\n+        await fastifyTestInstance.prisma.envExamAttempt.create({\n+          data: recentExamAttempt\n+        });\n+\n+        const body: Static<typeof examEnvironmentPostExamGeneratedExam.body> = {\n+          examId: mock.examId\n+        };\n+\n+        const res = await superPost('/exam-environment/exam/generated-exam')\n+          .send(body)\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          );\n+\n+        expect(res).toMatchObject({\n+          status: 429,\n+          body: {\n+            code: 'FCC_EINVAL_EXAM_ENVIRONMENT_PREREQUISITES'\n+          }\n+        });\n+\n+        await fastifyTestInstance.prisma.envExamAttempt.update({\n+          where: {\n+            id: recentExamAttempt.id\n+          },\n+          data: {\n+            // Set start time such that exam has expired, but 24 hours - 1s has passed\n+            startTimeInMS:\n+              Date.now() -\n+              (mock.exam.config.totalTimeInMS + (24 * 60 * 60 * 1000 - 1000))\n+          }\n+        });\n+\n+        const body2: Static<typeof examEnvironmentPostExamGeneratedExam.body> =\n+          {\n+            examId: mock.examId\n+          };\n+\n+        const res2 = await superPost('/exam-environment/exam/generated-exam')\n+          .send(body2)\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          );\n+\n+        expect(res2).toMatchObject({\n+          status: 429,\n+          body: {\n+            code: 'FCC_EINVAL_EXAM_ENVIRONMENT_PREREQUISITES'\n+          }\n+        });\n+      });\n+\n+      it('should use a new exam attempt if all previous attempts were started > 24 hours ago', async () => {\n+        const recentExamAttempt = structuredClone(mock.examAttempt);\n+        // Set start time such that exam has expired, but 24 hours + 1s has passed\n+        recentExamAttempt.startTimeInMS =\n+          Date.now() -\n+          (mock.exam.config.totalTimeInMS + (24 * 60 * 60 * 1000 + 1000));\n+        await fastifyTestInstance.prisma.envExamAttempt.create({\n+          data: recentExamAttempt\n+        });\n+\n+        // Generate new exam for user to be assigned\n+        const newGeneratedExam = structuredClone(mock.generatedExam);\n+        newGeneratedExam.id = mock.oid();\n+        await fastifyTestInstance.prisma.envGeneratedExam.create({\n+          data: newGeneratedExam\n+        });\n+\n+        const body: Static<typeof examEnvironmentPostExamGeneratedExam.body> = {\n+          examId: mock.examId\n+        };\n+\n+        const res = await superPost('/exam-environment/exam/generated-exam')\n+          .send(body)\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          );\n+\n+        // Time is greater than 24 hours. So, request should pass, and new exam should be generated\n+        expect(res).toMatchObject({\n+          status: 200,\n+          body: {\n+            data: {\n+              examAttempt: {\n+                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n+                id: expect.not.stringMatching(mock.examAttempt.id)\n+              }\n+            }\n+          }\n+        });\n+      });\n+\n+      it('should return the current attempt if it is still ongoing', async () => {\n+        const latestAttempt =\n+          await fastifyTestInstance.prisma.envExamAttempt.create({\n+            data: mock.examAttempt\n+          });\n+\n+        const body: Static<typeof examEnvironmentPostExamGeneratedExam.body> = {\n+          examId: mock.examId\n+        };\n+\n+        const res = await superPost('/exam-environment/exam/generated-exam')\n+          .send(body)\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          );\n+\n+        expect(res).toMatchObject({\n+          status: 200,\n+          body: {\n+            data: {\n+              examAttempt: latestAttempt\n+            }\n+          }\n+        });\n+      });\n+\n+      it('should return an error if the database has insufficient generated exams', async () => {\n+        // Add completed attempt for generated exam\n+        const submittedAttempt = structuredClone(mock.examAttempt);\n+        // Long-enough ago to be considered \"submitted\", and not trigger cooldown\n+        submittedAttempt.startTimeInMS =\n+          Date.now() -\n+          24 * 60 * 60 * 1000 -\n+          mock.exam.config.totalTimeInMS -\n+          1 * 60 * 60 * 1000;\n+        submittedAttempt.submissionTimeInMS =\n+          Date.now() - mock.exam.config.totalTimeInMS - 24 * 60 * 60 * 1000;\n+        await fastifyTestInstance.prisma.envExamAttempt.create({\n+          data: submittedAttempt\n+        });\n+\n+        const body: Static<typeof examEnvironmentPostExamGeneratedExam.body> = {\n+          examId: mock.examId\n+        };\n+        const res = await superPost('/exam-environment/exam/generated-exam')\n+          .send(body)\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          );\n+\n+        expect(res).toMatchObject({\n+          status: 500,\n+          body: {\n+            code: 'FCC_ERR_EXAM_ENVIRONMENT'\n+          }\n+        });\n+      });\n+\n+      it('should record the fact the user has started an exam by creating an exam attempt', async () => {\n+        const body: Static<typeof examEnvironmentPostExamGeneratedExam.body> = {\n+          examId: mock.examId\n+        };\n+        const res = await superPost('/exam-environment/exam/generated-exam')\n+          .send(body)\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          );\n+\n+        expect(res.status).toBe(200);\n+\n+        const generatedExam =\n+          await fastifyTestInstance.prisma.envGeneratedExam.findFirst({\n+            where: { examId: mock.examId }\n+          });\n+\n+        expect(generatedExam).toBeDefined();\n+\n+        const examAttempt =\n+          await fastifyTestInstance.prisma.envExamAttempt.findFirst({\n+            where: { generatedExamId: generatedExam!.id }\n+          });\n+\n+        expect(examAttempt).toEqual({\n+          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n+          id: expect.any(String),\n+          userId: defaultUserId,\n+          examId: mock.examId,\n+          generatedExamId: generatedExam!.id,\n+          questionSets: [],\n+          needsRetake: false,\n+          submissionTimeInMS: null,\n+          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n+          startTimeInMS: expect.any(Number)\n+        });\n+      });\n+\n+      it('should unwind (delete) the exam attempt if the user exam cannot be constructed', async () => {\n+        const _mockConstructUserExam = jest\n+          .spyOn(await import('../utils/exam'), 'constructUserExam')\n+          .mockImplementationOnce(() => {\n+            throw new Error('Test error');\n+          });\n+\n+        const body: Static<typeof examEnvironmentPostExamGeneratedExam.body> = {\n+          examId: mock.examId\n+        };\n+        const res = await superPost('/exam-environment/exam/generated-exam')\n+          .send(body)\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          );\n+\n+        expect(res.status).toBe(500);\n+\n+        const examAttempt =\n+          await fastifyTestInstance.prisma.envExamAttempt.findFirst({\n+            where: { examId: mock.examId }\n+          });\n+\n+        expect(examAttempt).toBeNull();\n+      });\n+\n+      it('should return the user exam with the exam attempt', async () => {\n+        const body: Static<typeof examEnvironmentPostExamGeneratedExam.body> = {\n+          examId: mock.examId\n+        };\n+        const res = await superPost('/exam-environment/exam/generated-exam')\n+          .send(body)\n+          .set(\n+            'exam-environment-authorization-token',\n+            examEnvironmentAuthorizationToken\n+          );\n+\n+        expect(res.status).toBe(200);\n+\n+        const generatedExam =\n+          await fastifyTestInstance.prisma.envGeneratedExam.findFirst({\n+            where: { examId: mock.examId }\n+          });\n+\n+        expect(generatedExam).toBeDefined();\n+\n+        const examAttempt =\n+          await fastifyTestInstance.prisma.envExamAttempt.findFirst({\n+            where: { generatedExamId: generatedExam!.id }\n+          });\n+\n+        const userExam = constructUserExam(generatedExam!, mock.exam);\n+\n+        expect(res).toMatchObject({\n+          status: 200,\n+          body: {\n+            data: {\n+              examAttempt,\n+              exam: userExam\n+            }\n+          }\n+        });\n+      });\n+    });\n+\n+    xdescribe('POST /exam-environment/screenshot', () => {});\n+  });\n+\n+  describe('Authenticated user without exam environment authorization token', () => {\n+    let superPost: ReturnType<typeof createSuperRequest>;\n+\n+    // Authenticate user\n+    beforeAll(async () => {\n+      const setCookies = await devLogin();\n+      superPost = createSuperRequest({ method: 'POST', setCookies });\n+      await mock.seedEnvExam();\n+    });\n+    describe('POST /exam-environment/exam/attempt', () => {\n+      it('should return 403', async () => {\n+        const body: Static<typeof examEnvironmentPostExamAttempt.body> = {\n+          attempt: {\n+            examId: mock.oid(),\n+            questionSets: []\n+          }\n+        };\n+        const res = await superPost('/exam-environment/exam/attempt')\n+          .send(body)\n+          .set('exam-environment-authorization-token', 'invalid-token');\n+\n+        expect(res.status).toBe(403);\n+      });\n+    });\n+\n+    describe('POST /exam-environment/exam/generated-exam', () => {\n+      it('should return 403', async () => {\n+        const body: Static<typeof examEnvironmentPostExamGeneratedExam.body> = {\n+          examId: mock.oid()\n+        };\n+        const res = await superPost('/exam-environment/exam/generated-exam')\n+          .send(body)\n+          .set('exam-environment-authorization-token', 'invalid-token');\n+\n+        expect(res.status).toBe(403);\n+      });\n+    });\n+\n+    describe('POST /exam-environment/screenshot', () => {\n+      it('should return 403', async () => {\n+        const res = await superPost('/exam-environment/screenshot').set(\n+          'exam-environment-authorization-token',\n+          'invalid-token'\n+        );\n+\n+        expect(res.status).toBe(403);\n+      });\n+    });\n+\n+    describe('POST /exam-environment/token/verify', () => {\n+      it('should allow a valid request', async () => {\n+        const res = await superPost('/exam-environment/token/verify').set(\n+          'exam-environment-authorization-token',\n+          'invalid-token'\n+        );\n+\n+        expect(res).toMatchObject({\n+          status: 200,\n+          body: {\n+            code: 'FCC_EINVAL_EXAM_ENVIRONMENT_AUTHORIZATION_TOKEN'\n+          }\n+        });\n+      });\n+    });\n+  });\n+});"
        },
        {
            "sha": "b17da6695572eb4b978d589f5bcad30beb8a6c00",
            "filename": "api/src/exam-environment/routes/exam-environment.ts",
            "status": "added",
            "additions": 567,
            "deletions": 0,
            "changes": 567,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Froutes%2Fexam-environment.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Froutes%2Fexam-environment.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fexam-environment%2Froutes%2Fexam-environment.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,567 @@\n+/* eslint-disable jsdoc/require-returns, jsdoc/require-param */\n+import { type FastifyPluginCallbackTypebox } from '@fastify/type-provider-typebox';\n+import { PrismaClientValidationError } from '@prisma/client/runtime/library';\n+import { type FastifyInstance, type FastifyReply } from 'fastify';\n+import jwt from 'jsonwebtoken';\n+\n+import * as schemas from '../schemas';\n+import { mapErr, syncMapErr, UpdateReqType } from '../../utils';\n+import { JWT_SECRET } from '../../utils/env';\n+import {\n+  checkAttemptAgainstGeneratedExam,\n+  checkPrerequisites,\n+  constructUserExam,\n+  userAttemptToDatabaseAttemptQuestionSets,\n+  validateAttempt\n+} from '../utils/exam';\n+import { ERRORS } from '../utils/errors';\n+\n+/**\n+ * Wrapper for endpoints related to the exam environment desktop app.\n+ *\n+ * Requires exam environment authorization token to be validated.\n+ */\n+export const examEnvironmentValidatedTokenRoutes: FastifyPluginCallbackTypebox =\n+  (fastify, _options, done) => {\n+    fastify.post(\n+      '/exam-environment/exam/generated-exam',\n+      {\n+        schema: schemas.examEnvironmentPostExamGeneratedExam\n+      },\n+      postExamGeneratedExamHandler\n+    );\n+    fastify.post(\n+      '/exam-environment/exam/attempt',\n+      {\n+        schema: schemas.examEnvironmentPostExamAttempt\n+      },\n+      postExamAttemptHandler\n+    );\n+    fastify.post(\n+      '/exam-environment/screenshot',\n+      {\n+        schema: schemas.examEnvironmentPostScreenshot\n+      },\n+      postScreenshotHandler\n+    );\n+    done();\n+  };\n+\n+/**\n+ * Wrapper for endpoints related to the exam environment desktop app.\n+ *\n+ * Does not require exam environment authorization token to be validated.\n+ */\n+export const examEnvironmentOpenRoutes: FastifyPluginCallbackTypebox = (\n+  fastify,\n+  _options,\n+  done\n+) => {\n+  fastify.post(\n+    '/exam-environment/token/verify',\n+    {\n+      schema: schemas.examEnvironmentTokenVerify\n+    },\n+    tokenVerifyHandler\n+  );\n+  done();\n+};\n+\n+interface JwtPayload {\n+  examEnvironmentAuthorizationToken: string;\n+}\n+\n+/**\n+ * Verify an authorization token has been generated for a user.\n+ *\n+ * Does not require any authentication.\n+ *\n+ * **Note**: This has no guarantees of which user the token is for. Just that one exists in the database.\n+ */\n+async function tokenVerifyHandler(\n+  this: FastifyInstance,\n+  req: UpdateReqType<typeof schemas.examEnvironmentTokenVerify>,\n+  reply: FastifyReply\n+) {\n+  const { 'exam-environment-authorization-token': encodedToken } = req.headers;\n+\n+  try {\n+    jwt.verify(encodedToken, JWT_SECRET);\n+  } catch (e) {\n+    // TODO: What to send back here? Request is valid, but token is not?\n+    void reply.code(200);\n+    return reply.send(\n+      ERRORS.FCC_EINVAL_EXAM_ENVIRONMENT_AUTHORIZATION_TOKEN(JSON.stringify(e))\n+    );\n+  }\n+\n+  const payload = jwt.decode(encodedToken) as JwtPayload;\n+\n+  const examEnvironmentAuthorizationToken =\n+    payload.examEnvironmentAuthorizationToken;\n+\n+  const token = await this.prisma.examEnvironmentAuthorizationToken.findFirst({\n+    where: {\n+      id: examEnvironmentAuthorizationToken\n+    }\n+  });\n+\n+  if (!token) {\n+    void reply.code(200);\n+    return reply.send({\n+      data: 'Token does not appear to have been created.'\n+    });\n+  } else {\n+    void reply.code(200);\n+    return reply.send({\n+      data: {\n+        createdDate: token.createdDate\n+      }\n+    });\n+  }\n+}\n+\n+/**\n+ * Generates an exam for the user.\n+ *\n+ * Requires token to be validated and TODO: live longer than the exam attempt.\n+ */\n+async function postExamGeneratedExamHandler(\n+  this: FastifyInstance,\n+  req: UpdateReqType<typeof schemas.examEnvironmentPostExamGeneratedExam>,\n+  reply: FastifyReply\n+) {\n+  // Get exam from DB\n+  const examId = req.body.examId;\n+  const maybeExam = await mapErr(\n+    this.prisma.envExam.findUnique({\n+      where: {\n+        id: examId\n+      }\n+    })\n+  );\n+  if (maybeExam.hasError) {\n+    if (maybeExam.error instanceof PrismaClientValidationError) {\n+      void reply.code(400);\n+      return reply.send(ERRORS.FCC_EINVAL_EXAM_ID(maybeExam.error.message));\n+    }\n+\n+    void reply.code(500);\n+    return reply.send(\n+      ERRORS.FCC_ERR_EXAM_ENVIRONMENT(JSON.stringify(maybeExam.error))\n+    );\n+  }\n+\n+  const exam = maybeExam.data;\n+\n+  if (!exam) {\n+    void reply.code(404);\n+    return reply.send(\n+      ERRORS.FCC_ENOENT_EXAM_ENVIRONMENT_MISSING_EXAM('Invalid exam id given.')\n+    );\n+  }\n+\n+  // Check user has completed prerequisites\n+  const user = req.user!;\n+  const isExamPrerequisitesMet = checkPrerequisites(user, true);\n+\n+  if (!isExamPrerequisitesMet) {\n+    void reply.code(403);\n+    // TODO: Consider sending unmet prerequisites\n+    return reply.send(\n+      ERRORS.FCC_EINVAL_EXAM_ENVIRONMENT_PREREQUISITES(\n+        'User has not completed prerequisites.'\n+      )\n+    );\n+  }\n+\n+  // Check user has not completed exam in last 24 hours\n+  const maybeExamAttempts = await mapErr(\n+    this.prisma.envExamAttempt.findMany({\n+      where: {\n+        userId: user.id,\n+        examId: exam.id\n+      }\n+    })\n+  );\n+\n+  if (maybeExamAttempts.hasError) {\n+    void reply.code(500);\n+    return reply.send(\n+      ERRORS.FCC_ERR_EXAM_ENVIRONMENT(JSON.stringify(maybeExamAttempts.error))\n+    );\n+  }\n+\n+  const examAttempts = maybeExamAttempts.data;\n+\n+  const lastAttempt = examAttempts.length\n+    ? examAttempts.reduce((latest, current) =>\n+        latest.startTimeInMS > current.startTimeInMS ? latest : current\n+      )\n+    : null;\n+\n+  if (lastAttempt) {\n+    const attemptIsExpired =\n+      lastAttempt.startTimeInMS + exam.config.totalTimeInMS < Date.now();\n+    if (attemptIsExpired) {\n+      // If exam is not submitted, use exam start time + time allocated for exam\n+      const effectiveSubmissionTime =\n+        lastAttempt.submissionTimeInMS ??\n+        lastAttempt.startTimeInMS + exam.config.totalTimeInMS;\n+      const twentyFourHoursAgo = Date.now() - 24 * 60 * 60 * 1000;\n+\n+      if (effectiveSubmissionTime > twentyFourHoursAgo) {\n+        void reply.code(429);\n+        // TODO: Consider sending last completed time\n+        return reply.send(\n+          ERRORS.FCC_EINVAL_EXAM_ENVIRONMENT_PREREQUISITES(\n+            'User has completed exam too recently to retake.'\n+          )\n+        );\n+      }\n+    } else {\n+      // Camper has started an attempt, but not submitted it, and there is still time left to complete it.\n+      // This is most likely to happen if the Camper's app closes and is reopened.\n+      // Send the Camper back to the exam they were working on.\n+      const generated = await mapErr(\n+        this.prisma.envGeneratedExam.findFirst({\n+          where: {\n+            id: lastAttempt.generatedExamId\n+          }\n+        })\n+      );\n+\n+      if (generated.hasError) {\n+        void reply.code(500);\n+        return reply.send(\n+          ERRORS.FCC_ERR_EXAM_ENVIRONMENT(JSON.stringify(generated.error))\n+        );\n+      }\n+\n+      if (generated.data === null) {\n+        void reply.code(500);\n+        return reply.send(\n+          ERRORS.FCC_ERR_EXAM_ENVIRONMENT(\n+            'Unreachable. Generated exam not found.'\n+          )\n+        );\n+      }\n+\n+      const userExam = constructUserExam(generated.data, exam);\n+\n+      return reply.send({\n+        data: {\n+          exam: userExam,\n+          examAttempt: lastAttempt\n+        }\n+      });\n+    }\n+  }\n+\n+  // Randomly pick a generated exam for user\n+  const maybeGeneratedExams = await mapErr(\n+    this.prisma.envGeneratedExam.findMany({\n+      where: {\n+        // Find generated exams user has not already seen\n+        examId: exam.id,\n+        id: {\n+          notIn: examAttempts.map(a => a.generatedExamId)\n+        },\n+        deprecated: false\n+      },\n+      select: {\n+        id: true\n+      }\n+    })\n+  );\n+\n+  if (maybeGeneratedExams.hasError) {\n+    void reply.code(500);\n+    return reply.send(\n+      ERRORS.FCC_ERR_EXAM_ENVIRONMENT(maybeGeneratedExams.error)\n+    );\n+  }\n+\n+  const generatedExams = maybeGeneratedExams.data;\n+\n+  if (generatedExams.length === 0) {\n+    void reply.code(500);\n+    return reply.send(\n+      ERRORS.FCC_ERR_EXAM_ENVIRONMENT(\n+        `Unable to provide a generated exam. Either all generated exams have been exhausted, or all generated exams are deprecated.`\n+      )\n+    );\n+  }\n+\n+  const randomGeneratedExam =\n+    generatedExams[Math.floor(Math.random() * generatedExams.length)]!;\n+\n+  const maybeGeneratedExam = await mapErr(\n+    this.prisma.envGeneratedExam.findFirst({\n+      where: {\n+        id: randomGeneratedExam.id\n+      }\n+    })\n+  );\n+\n+  if (maybeGeneratedExam.hasError) {\n+    void reply.code(500);\n+    return reply.send(\n+      // TODO: Consider more specific code\n+      ERRORS.FCC_ERR_EXAM_ENVIRONMENT(\n+        'Unable to query generated exam, due to: ' +\n+          JSON.stringify(maybeGeneratedExam.error)\n+      )\n+    );\n+  }\n+\n+  const generatedExam = maybeGeneratedExam.data;\n+\n+  if (generatedExam === null) {\n+    void reply.code(500);\n+    return reply.send(\n+      ERRORS.FCC_ERR_EXAM_ENVIRONMENT(`Unable to locate generated exam.`)\n+    );\n+  }\n+\n+  // Create exam attempt so, even if user disconnects, their attempt is still recorded:\n+  const attempt = await mapErr(\n+    this.prisma.envExamAttempt.create({\n+      data: {\n+        userId: user.id,\n+        examId: exam.id,\n+        generatedExamId: generatedExam.id,\n+        startTimeInMS: Date.now(),\n+        questionSets: [],\n+        needsRetake: false\n+      }\n+    })\n+  );\n+\n+  if (attempt.hasError) {\n+    void reply.code(500);\n+    return reply.send(\n+      ERRORS.FCC_ERR_EXAM_ENVIRONMENT_CREATE_EXAM_ATTEMPT(\n+        JSON.stringify(attempt.error)\n+      )\n+    );\n+  }\n+  // NOTE: Anything that goes wrong after this point needs to unwind the exam attempt.\n+\n+  const maybeUserExam = syncMapErr(() =>\n+    constructUserExam(generatedExam, exam)\n+  );\n+\n+  if (maybeUserExam.hasError) {\n+    await this.prisma.envExamAttempt.delete({\n+      where: {\n+        id: attempt.data.id\n+      }\n+    });\n+    void reply.code(500);\n+    return reply.send(\n+      ERRORS.FCC_ERR_EXAM_ENVIRONMENT(JSON.stringify(maybeUserExam.error))\n+    );\n+  }\n+\n+  const userExam = maybeUserExam.data;\n+\n+  void reply.code(200);\n+  return reply.send({\n+    data: {\n+      exam: userExam,\n+      examAttempt: attempt.data\n+    }\n+  });\n+}\n+\n+/**\n+ * Handles updates to an exam attempt.\n+ *\n+ * Requires token to be validated.\n+ *\n+ * TODO: Consider validating req.user.id == lastAttempt.user_id?\n+ *\n+ * NOTE: Currently, questions can be _unanswered_ - taken away from a previous attempt submission.\n+ * Theorectically, this is fine. Practically, it is unclear when that would be useful.\n+ */\n+async function postExamAttemptHandler(\n+  this: FastifyInstance,\n+  req: UpdateReqType<typeof schemas.examEnvironmentPostExamAttempt>,\n+  reply: FastifyReply\n+) {\n+  const { attempt } = req.body;\n+\n+  const user = req.user!;\n+\n+  const maybeAttempts = await mapErr(\n+    this.prisma.envExamAttempt.findMany({\n+      where: {\n+        examId: attempt.examId,\n+        userId: user.id\n+      }\n+    })\n+  );\n+\n+  if (maybeAttempts.hasError) {\n+    void reply.code(500);\n+    return reply.send(\n+      ERRORS.FCC_ERR_EXAM_ENVIRONMENT(JSON.stringify(maybeAttempts.error))\n+    );\n+  }\n+\n+  const attempts = maybeAttempts.data;\n+\n+  if (attempts.length === 0) {\n+    void reply.code(404);\n+    return reply.send(\n+      ERRORS.FCC_ERR_EXAM_ENVIRONMENT_EXAM_ATTEMPT(\n+        `No attempts found for user '${user.id}' with attempt id '${attempt.examId}'.`\n+      )\n+    );\n+  }\n+\n+  const latestAttempt = attempts.reduce((latest, current) =>\n+    latest.startTimeInMS > current.startTimeInMS ? latest : current\n+  );\n+\n+  // TODO: Currently, submission time is set when all questions have been answered.\n+  //       This might not necessarily be fully submitted. So, provided there is time\n+  //       left on the clock, the attempt should still be updated, even if the submission\n+  //       time is set.\n+  //       The submission time just needs to be updated.\n+  // if (latestAttempt.submissionTimeInMS !== null) {\n+  //   void reply.code(403);\n+  //   return reply.send(\n+  //     ERRORS.FCC_EINVAL_EXAM_ENVIRONMENT_EXAM_ATTEMPT(\n+  //       'Attempt has already been submitted.'\n+  //     )\n+  //   );\n+  // }\n+\n+  const maybeExam = await mapErr(\n+    this.prisma.envExam.findUnique({\n+      where: {\n+        id: attempt.examId\n+      }\n+    })\n+  );\n+\n+  if (maybeExam.hasError) {\n+    void reply.code(500);\n+    return reply.send(\n+      ERRORS.FCC_ERR_EXAM_ENVIRONMENT(JSON.stringify(maybeExam.error))\n+    );\n+  }\n+\n+  const exam = maybeExam.data;\n+\n+  if (exam === null) {\n+    void reply.code(404);\n+    return reply.send(\n+      ERRORS.FCC_ENOENT_EXAM_ENVIRONMENT_MISSING_EXAM('Invalid exam id given.')\n+    );\n+  }\n+\n+  const isAttemptExpired =\n+    latestAttempt.startTimeInMS + exam.config.totalTimeInMS < Date.now();\n+\n+  if (isAttemptExpired) {\n+    void reply.code(403);\n+    return reply.send(\n+      ERRORS.FCC_EINVAL_EXAM_ENVIRONMENT_EXAM_ATTEMPT(\n+        'Attempt has exceeded submission time.'\n+      )\n+    );\n+  }\n+\n+  // Get generated exam from database\n+  const maybeGeneratedExam = await mapErr(\n+    this.prisma.envGeneratedExam.findUnique({\n+      where: {\n+        id: latestAttempt.generatedExamId\n+      }\n+    })\n+  );\n+\n+  if (maybeGeneratedExam.hasError) {\n+    void reply.code(500);\n+    return reply.send(\n+      ERRORS.FCC_ERR_EXAM_ENVIRONMENT(JSON.stringify(maybeGeneratedExam.error))\n+    );\n+  }\n+\n+  const generatedExam = maybeGeneratedExam.data;\n+\n+  if (generatedExam === null) {\n+    void reply.code(404);\n+    return reply.send(\n+      ERRORS.FCC_ENOENT_EXAM_ENVIRONMENT_GENERATED_EXAM(\n+        'Generated exam not found.'\n+      )\n+    );\n+  }\n+\n+  const databaseAttemptQuestionSets = userAttemptToDatabaseAttemptQuestionSets(\n+    attempt,\n+    latestAttempt\n+  );\n+  // Ensure attempt matches generated exam\n+  const maybeValidExamAttempt = syncMapErr(() =>\n+    validateAttempt(generatedExam, databaseAttemptQuestionSets)\n+  );\n+\n+  // If all questions have been answered, add submission time\n+  const allQuestionsAnswered = checkAttemptAgainstGeneratedExam(\n+    databaseAttemptQuestionSets,\n+    generatedExam\n+  );\n+\n+  // Update attempt in database\n+  const maybeUpdatedAttempt = await mapErr(\n+    this.prisma.envExamAttempt.update({\n+      where: {\n+        id: latestAttempt.id\n+      },\n+      data: {\n+        // NOTE: submission time is set to null, because it just depends on whether all questions have been answered.\n+        submissionTimeInMS: allQuestionsAnswered ? Date.now() : null,\n+        questionSets: databaseAttemptQuestionSets,\n+        // If attempt is not valid, immediately flag attempt as needing retake\n+        // TODO: If `needsRetake`, prevent further submissions?\n+        needsRetake: maybeValidExamAttempt.hasError ? true : undefined\n+      }\n+    })\n+  );\n+\n+  if (maybeValidExamAttempt.hasError) {\n+    void reply.code(400);\n+    const message =\n+      maybeValidExamAttempt.error instanceof Error\n+        ? maybeValidExamAttempt.error.message\n+        : 'Unknown attempt validation error';\n+    return reply.send(ERRORS.FCC_EINVAL_EXAM_ENVIRONMENT_EXAM_ATTEMPT(message));\n+  }\n+\n+  if (maybeUpdatedAttempt.hasError) {\n+    void reply.code(500);\n+    return reply.send(\n+      ERRORS.FCC_ERR_EXAM_ENVIRONMENT(JSON.stringify(maybeUpdatedAttempt.error))\n+    );\n+  }\n+\n+  return reply.code(200).send();\n+}\n+\n+/**\n+ * Handles screenshots, sending them to the screenshot service for storage.\n+ *\n+ * Requires token to be validated.\n+ */\n+async function postScreenshotHandler(\n+  this: FastifyInstance,\n+  _req: UpdateReqType<typeof schemas.examEnvironmentPostScreenshot>,\n+  reply: FastifyReply\n+) {\n+  return reply.code(418);\n+}"
        },
        {
            "sha": "e7ceb75c30ecc1c2fc6e6195d17cb3d2a51fe192",
            "filename": "api/src/exam-environment/schemas/exam-attempt.ts",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fschemas%2Fexam-attempt.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fschemas%2Fexam-attempt.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fexam-environment%2Fschemas%2Fexam-attempt.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,31 @@\n+import { Type } from '@fastify/type-provider-typebox';\n+import { STANDARD_ERROR } from '../utils/errors';\n+\n+export const examEnvironmentPostExamAttempt = {\n+  body: Type.Object({\n+    attempt: Type.Object({\n+      examId: Type.String(),\n+      questionSets: Type.Array(\n+        Type.Object({\n+          id: Type.String(),\n+          questions: Type.Array(\n+            Type.Object({\n+              id: Type.String(),\n+              answers: Type.Array(Type.String())\n+            })\n+          )\n+        })\n+      )\n+    })\n+  }),\n+  headers: Type.Object({\n+    'exam-environment-authorization-token': Type.String()\n+  }),\n+  response: {\n+    // An empty 200 response cannot be typed \n+    400: STANDARD_ERROR,\n+    403: STANDARD_ERROR,\n+    404: STANDARD_ERROR,\n+    500: STANDARD_ERROR\n+  }\n+};"
        },
        {
            "sha": "d0f45adb940dea44da7bbc07da453160c204ca73",
            "filename": "api/src/exam-environment/schemas/exam-generated-exam.ts",
            "status": "added",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fschemas%2Fexam-generated-exam.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fschemas%2Fexam-generated-exam.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fexam-environment%2Fschemas%2Fexam-generated-exam.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,23 @@\n+import { Type } from '@fastify/type-provider-typebox';\n+import { STANDARD_ERROR } from '../utils/errors';\n+\n+export const examEnvironmentPostExamGeneratedExam = {\n+  body: Type.Object({\n+    examId: Type.String()\n+  }),\n+  headers: Type.Object({\n+    'exam-environment-authorization-token': Type.String()\n+  }),\n+  response: {\n+    200: Type.Object({\n+      data: Type.Object({\n+        exam: Type.Record(Type.String(), Type.Unknown()),\n+        examAttempt: Type.Record(Type.String(), Type.Unknown())\n+      })\n+    }),\n+    403: STANDARD_ERROR,\n+    404: STANDARD_ERROR,\n+    429: STANDARD_ERROR,\n+    500: STANDARD_ERROR\n+  }\n+};"
        },
        {
            "sha": "254e1018ae90d1a706dfc1948ec10d43918ac61d",
            "filename": "api/src/exam-environment/schemas/index.ts",
            "status": "added",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fschemas%2Findex.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fschemas%2Findex.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fexam-environment%2Fschemas%2Findex.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,4 @@\n+export { examEnvironmentPostExamAttempt } from './exam-attempt';\n+export { examEnvironmentPostExamGeneratedExam } from './exam-generated-exam';\n+export { examEnvironmentPostScreenshot } from './screenshot';\n+export { examEnvironmentTokenVerify } from './token-verify';"
        },
        {
            "sha": "ddb60f3d9ecbe346a061328b1104113e1d940c48",
            "filename": "api/src/exam-environment/schemas/screenshot.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fschemas%2Fscreenshot.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fschemas%2Fscreenshot.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fexam-environment%2Fschemas%2Fscreenshot.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,7 @@\n+// import { Type } from '@fastify/type-provider-typebox';\n+\n+export const examEnvironmentPostScreenshot = {\n+  response: {\n+    // 200: Type.Object({})\n+  }\n+};"
        },
        {
            "sha": "d8042da65f1e87b31872daa081fd1b5f8cc2c48c",
            "filename": "api/src/exam-environment/schemas/token-verify.ts",
            "status": "added",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fschemas%2Ftoken-verify.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fschemas%2Ftoken-verify.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fexam-environment%2Fschemas%2Ftoken-verify.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,21 @@\n+import { Type } from '@fastify/type-provider-typebox';\n+import { STANDARD_ERROR } from '../utils/errors';\n+\n+export const examEnvironmentTokenVerify = {\n+  headers: Type.Object({\n+    'exam-environment-authorization-token': Type.String()\n+  }),\n+  response: {\n+    200: Type.Union([\n+      Type.Object({\n+        data: Type.Union([\n+          Type.String(),\n+          Type.Object({\n+            createdDate: Type.String({ format: 'date-time' })\n+          })\n+        ])\n+      }),\n+      STANDARD_ERROR\n+    ])\n+  }\n+};"
        },
        {
            "sha": "4c0830edf1f961ffec4e895cc8ce39f6bcfeaeac",
            "filename": "api/src/exam-environment/seed/index.ts",
            "status": "added",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fseed%2Findex.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Fseed%2Findex.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fexam-environment%2Fseed%2Findex.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,24 @@\n+import { PrismaClient } from '@prisma/client';\n+import * as mocks from '../../../__mocks__/env-exam';\n+import { MONGOHQ_URL } from '../../utils/env';\n+\n+const prisma = new PrismaClient({\n+  datasources: {\n+    db: {\n+      url: MONGOHQ_URL\n+    }\n+  }\n+});\n+\n+async function main() {\n+  await prisma.$connect();\n+\n+  await prisma.envExamAttempt.deleteMany({});\n+  await prisma.envGeneratedExam.deleteMany({});\n+  await prisma.envExam.deleteMany({});\n+\n+  await prisma.envExam.create({ data: mocks.exam });\n+  await prisma.envGeneratedExam.create({ data: mocks.generatedExam });\n+}\n+\n+void main();"
        },
        {
            "sha": "ec1cf60bc8c004f9caa5a32956762ea222416a90",
            "filename": "api/src/exam-environment/utils/errors.ts",
            "status": "added",
            "additions": 59,
            "deletions": 0,
            "changes": 59,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Futils%2Ferrors.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Futils%2Ferrors.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fexam-environment%2Futils%2Ferrors.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,59 @@\n+import { format } from 'util';\n+import { Type } from '@fastify/type-provider-typebox';\n+\n+export const ERRORS = {\n+  FCC_EINVAL_EXAM_ENVIRONMENT_AUTHORIZATION_TOKEN: createError(\n+    'FCC_EINVAL_EXAM_ENVIRONMENT_AUTHORIZATION_TOKEN',\n+    '%s'\n+  ),\n+  FCC_EINVAL_EXAM_ENVIRONMENT_PREREQUISITES: createError(\n+    'FCC_EINVAL_EXAM_ENVIRONMENT_PREREQUISITES',\n+    '%s'\n+  ),\n+  FCC_ENOENT_EXAM_ENVIRONMENT_MISSING_EXAM: createError(\n+    'FCC_ENOENT_EXAM_ENVIRONMENT_MISSING_EXAM',\n+    '%s'\n+  ),\n+  FCC_ERR_EXAM_ENVIRONMENT_CREATE_EXAM_ATTEMPT: createError(\n+    'FCC_ERR_EXAM_ENVIRONMENT_CREATE_EXAM_ATTEMPT',\n+    '%s'\n+  ),\n+  FCC_ERR_EXAM_ENVIRONMENT: createError('FCC_ERR_EXAM_ENVIRONMENT', '%s'),\n+  FCC_ENOENT_EXAM_ENVIRONMENT_AUTHORIZATION_TOKEN: createError(\n+    'FCC_ENOENT_EXAM_ENVIRONMENT_AUTHORIZATION_TOKEN',\n+    '%s'\n+  ),\n+  FCC_EINVAL_EXAM_ENVIRONMENT_EXAM_ATTEMPT: createError(\n+    'FCC_EINVAL_EXAM_ENVIRONMENT_EXAM_ATTEMPT',\n+    '%s'\n+  ),\n+  FCC_ERR_EXAM_ENVIRONMENT_EXAM_ATTEMPT: createError(\n+    'FCC_ERR_EXAM_ENVIRONMENT_EXAM_ATTEMPT',\n+    '%s'\n+  ),\n+  FCC_ENOENT_EXAM_ENVIRONMENT_GENERATED_EXAM: createError(\n+    'FCC_ENOENT_EXAM_ENVIRONMENT_GENERATED_EXAM',\n+    '%s'\n+  ),\n+  FCC_EINVAL_EXAM_ID: createError('FCC_EINVAL_EXAM_ID', '%s')\n+};\n+\n+/**\n+ * Returns a function which optionally takes arguments to format an error message.\n+ * @param code - Identifier for the error.\n+ * @param message - Human-readable error message.\n+ * @returns Function which optionally takes arguments to format an error message.\n+ */\n+function createError(code: string, message: string) {\n+  return (...args: unknown[]) => {\n+    return {\n+      code,\n+      message: format(message, ...args)\n+    };\n+  };\n+}\n+\n+export const STANDARD_ERROR = Type.Object({\n+  code: Type.String(),\n+  message: Type.String()\n+});"
        },
        {
            "sha": "db223bfe137f9afb678631c7cab6c4155ff6b422",
            "filename": "api/src/exam-environment/utils/exam.test.ts",
            "status": "added",
            "additions": 292,
            "deletions": 0,
            "changes": 292,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Futils%2Fexam.test.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Futils%2Fexam.test.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fexam-environment%2Futils%2Fexam.test.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,292 @@\n+import { type Static } from '@fastify/type-provider-typebox';\n+import { exam, examAttempt, generatedExam } from '../../../__mocks__/env-exam';\n+import * as schemas from '../schemas';\n+import {\n+  checkAttemptAgainstGeneratedExam,\n+  constructUserExam,\n+  generateExam,\n+  userAttemptToDatabaseAttemptQuestionSets,\n+  validateAttempt\n+} from './exam';\n+\n+// NOTE: Whilst the tests could be run against a single generation of exam,\n+//       it is more useful to run the tests against a new generation each time.\n+//       This helps ensure the config/logic is _reasonably_ likely to be able to\n+//       generate a valid exam.\n+//       Another option is to call `generateExam` hundreds of times in a loop test :shrug:\n+describe('Exam Environment', () => {\n+  beforeAll(() => {\n+    jest.spyOn(Math, 'random').mockReturnValue(0.123456789);\n+  });\n+  describe('checkAttemptAgainstGeneratedExam()', () => {\n+    it('should return true if all questions are answered', () => {\n+      expect(\n+        checkAttemptAgainstGeneratedExam(\n+          examAttempt.questionSets,\n+          generatedExam\n+        )\n+      ).toBe(true);\n+    });\n+\n+    it('should return false if one or more questions are not answered', () => {\n+      const badExamAttempt = structuredClone(examAttempt);\n+\n+      badExamAttempt.questionSets[0]!.questions[0]!.answers = [];\n+      expect(\n+        checkAttemptAgainstGeneratedExam(\n+          badExamAttempt.questionSets,\n+          generatedExam\n+        )\n+      ).toBe(false);\n+\n+      badExamAttempt.questionSets[0]!.questions[0]!.answers = ['bad-answer'];\n+      expect(\n+        checkAttemptAgainstGeneratedExam(\n+          badExamAttempt.questionSets,\n+          generatedExam\n+        )\n+      ).toBe(false);\n+\n+      badExamAttempt.questionSets[0]!.questions = [];\n+      expect(\n+        checkAttemptAgainstGeneratedExam(\n+          badExamAttempt.questionSets,\n+          generatedExam\n+        )\n+      ).toBe(false);\n+    });\n+  });\n+  xdescribe('checkPrequisites()', () => {\n+    // TODO: Awaiting implementation\n+  });\n+  describe('constructUserExam()', () => {\n+    it('should not provide the answers', () => {\n+      const userExam = constructUserExam(generatedExam, exam);\n+      expect(userExam).not.toHaveProperty('answers.isCorrect');\n+    });\n+  });\n+\n+  describe('generateExam()', () => {\n+    it('should generate a randomized exam without throwing', () => {\n+      const _randomizedExam = generateExam(exam);\n+    });\n+\n+    it('should generate an exam matching with the correct number of question sets', () => {\n+      const generatedExam = generateExam(exam);\n+\n+      // { [type]: numberOfType }\n+      // E.g. { MultipleChoice: 2, Dialogue: 1 }\n+      const generatedNumberOfSets = generatedExam.questionSets.reduce(\n+        (acc, curr) => {\n+          const eqs = exam.questionSets.find(eqs => eqs.id === curr.id);\n+\n+          if (!eqs) {\n+            throw new Error('Generated question set not found in exam config');\n+          }\n+\n+          return {\n+            ...acc,\n+            [eqs.type]: (acc[eqs.type] || 0) + 1\n+          };\n+        },\n+        {} as Record<string, number>\n+      );\n+\n+      const configNumberOfSets = exam.config.questionSets.reduce(\n+        (acc, curr) => {\n+          return {\n+            ...acc,\n+            [curr.type]: (acc[curr.type] || 0) + curr.numberOfSet\n+          };\n+        },\n+        {} as Record<string, number>\n+      );\n+\n+      expect(generatedNumberOfSets).toEqual(configNumberOfSets);\n+    });\n+\n+    it('should not generate any deprecated questions', () => {\n+      const generatedExam = generateExam(exam);\n+\n+      const allQuestions = exam.questionSets.flatMap(qs => qs.questions);\n+\n+      const deprecatedQuestions = generatedExam.questionSets\n+        .flatMap(qs => qs.questions)\n+        .filter(q => {\n+          const eq = allQuestions.find(eq => eq.id === q.id);\n+          if (!eq) {\n+            throw new Error('Generated question not found in exam');\n+          }\n+          return eq.deprecated;\n+        });\n+\n+      expect(deprecatedQuestions).toHaveLength(0);\n+    });\n+\n+    it('should not generate an exam with duplicate questions', () => {\n+      const generatedExam = generateExam(exam);\n+\n+      const questionIds = generatedExam.questionSets.flatMap(qs =>\n+        qs.questions.map(q => q.id)\n+      );\n+\n+      const duplicateQuestions = questionIds.filter(\n+        (id, index) => questionIds.indexOf(id) !== index\n+      );\n+\n+      expect(duplicateQuestions).toHaveLength(0);\n+    });\n+\n+    it('should not generate an exam with duplicate answers', () => {\n+      const generatedExam = generateExam(exam);\n+\n+      const answerIds = generatedExam.questionSets.flatMap(qs =>\n+        qs.questions.flatMap(q => q.answers)\n+      );\n+\n+      const duplicateAnswers = answerIds.filter(\n+        (id, index) => answerIds.indexOf(id) !== index\n+      );\n+\n+      expect(duplicateAnswers).toHaveLength(0);\n+    });\n+\n+    it('should throw if the exam config is invalid', () => {\n+      const invalidExam = {\n+        ...exam,\n+        config: {\n+          ...exam.config,\n+          tags: [\n+            {\n+              group: ['non-existant-tag'],\n+              numberOfQuestions: 1\n+            }\n+          ]\n+        }\n+      };\n+      expect(() => generateExam(invalidExam)).toThrow();\n+    });\n+  });\n+\n+  describe('validateAttempt()', () => {\n+    it('should validate a correct attempt', () => {\n+      validateAttempt(generatedExam, examAttempt.questionSets);\n+    });\n+\n+    it('should invalidate an incorrect attempt', () => {\n+      const badExamAttempt = structuredClone(examAttempt);\n+      badExamAttempt.questionSets[0]!.questions[0]!.answers = ['bad-answer'];\n+      expect(() =>\n+        validateAttempt(generatedExam, badExamAttempt.questionSets)\n+      ).toThrow();\n+    });\n+  });\n+\n+  describe('userAttemptToDatabaseAttemptQuestionSets()', () => {\n+    it('should add submission time to all questions', () => {\n+      const userAttempt: Static<\n+        typeof schemas.examEnvironmentPostExamAttempt.body.properties.attempt\n+      > = {\n+        examId: '0',\n+        questionSets: [\n+          {\n+            id: '0',\n+            questions: [{ id: '00', answers: ['000'] }]\n+          },\n+          {\n+            id: '1',\n+            questions: [{ id: '10', answers: ['100'] }]\n+          }\n+        ]\n+      };\n+      const latestAttempt = structuredClone(examAttempt);\n+      latestAttempt.questionSets = [];\n+\n+      const databaseAttemptQuestionSets =\n+        userAttemptToDatabaseAttemptQuestionSets(userAttempt, latestAttempt);\n+\n+      const allQuestions = databaseAttemptQuestionSets.flatMap(\n+        qs => qs.questions\n+      );\n+      expect(allQuestions.every(q => q.submissionTimeInMS)).toBe(true);\n+    });\n+\n+    it('should not change the submission time of any questions that have not changed', () => {\n+      const userAttempt: Static<\n+        typeof schemas.examEnvironmentPostExamAttempt.body.properties.attempt\n+      > = {\n+        examId: '0',\n+        questionSets: [\n+          {\n+            id: '0',\n+            questions: [{ id: '00', answers: ['000'] }]\n+          },\n+          {\n+            id: '1',\n+            questions: [{ id: '10', answers: ['100'] }]\n+          }\n+        ]\n+      };\n+      const latestAttempt = structuredClone(examAttempt);\n+\n+      const databaseAttemptQuestionSets =\n+        userAttemptToDatabaseAttemptQuestionSets(userAttempt, latestAttempt);\n+\n+      const submissionTimes = databaseAttemptQuestionSets.flatMap(qs =>\n+        qs.questions.map(q => q.submissionTimeInMS)\n+      );\n+\n+      const sameAttempt = userAttemptToDatabaseAttemptQuestionSets(\n+        userAttempt,\n+        { ...latestAttempt, questionSets: databaseAttemptQuestionSets }\n+      );\n+\n+      const sameSubmissionTimes = sameAttempt.flatMap(qs =>\n+        qs.questions.map(q => q.submissionTimeInMS)\n+      );\n+\n+      expect(submissionTimes).toEqual(sameSubmissionTimes);\n+    });\n+\n+    it('should change all submission times of questions that have changed', async () => {\n+      const userAttempt: Static<\n+        typeof schemas.examEnvironmentPostExamAttempt.body.properties.attempt\n+      > = {\n+        examId: '0',\n+        questionSets: [\n+          {\n+            id: '0',\n+            questions: [{ id: '00', answers: ['000'] }]\n+          },\n+          {\n+            id: '1',\n+            questions: [{ id: '10', answers: ['100'] }]\n+          }\n+        ]\n+      };\n+      const latestAttempt = structuredClone(examAttempt);\n+\n+      const databaseAttemptQuestionSets =\n+        userAttemptToDatabaseAttemptQuestionSets(userAttempt, latestAttempt);\n+      userAttempt.questionSets[0]!.questions[0]!.answers = ['001'];\n+\n+      // The `userAttemptToDatabaseAttemptQuestionSets` function uses `Date.now()`\n+      // to set the submission time, so we need to wait a bit to ensure differences.\n+      await new Promise(resolve => setTimeout(resolve, 10));\n+\n+      const newAttemptQuestionSets = userAttemptToDatabaseAttemptQuestionSets(\n+        userAttempt,\n+        {\n+          ...latestAttempt,\n+          questionSets: databaseAttemptQuestionSets\n+        }\n+      );\n+\n+      expect(\n+        newAttemptQuestionSets[0]?.questions[0]?.submissionTimeInMS\n+      ).not.toEqual(\n+        databaseAttemptQuestionSets[0]?.questions[0]?.submissionTimeInMS\n+      );\n+    });\n+  });\n+});"
        },
        {
            "sha": "d6e8b92da3ce6f178090a6064141ba1e623eb0e0",
            "filename": "api/src/exam-environment/utils/exam.ts",
            "status": "added",
            "additions": 630,
            "deletions": 0,
            "changes": 630,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Futils%2Fexam.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fexam-environment%2Futils%2Fexam.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fexam-environment%2Futils%2Fexam.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,630 @@\n+/* eslint-disable jsdoc/require-returns, jsdoc/require-param */\n+import {\n+  EnvAnswer,\n+  EnvConfig,\n+  EnvExam,\n+  EnvExamAttempt,\n+  EnvGeneratedExam,\n+  EnvMultipleChoiceQuestion,\n+  EnvQuestionSet,\n+  EnvQuestionSetAttempt,\n+  user\n+} from '@prisma/client';\n+import { type Static } from '@fastify/type-provider-typebox';\n+import * as schemas from '../schemas';\n+\n+/**\n+ * Checks if all exam prerequisites have been met by the user.\n+ *\n+ * TODO: This will be done by getting the challenges required from the curriculum.\n+ */\n+export function checkPrerequisites(_user: user, _prerequisites: unknown) {\n+  return true;\n+}\n+\n+export type UserExam = Omit<EnvExam, 'questionSets' | 'config' | 'id'> & {\n+  config: Omit<EnvExam['config'], 'tags' | 'questionSets'>;\n+  questionSets: (Omit<EnvQuestionSet, 'questions'> & {\n+    questions: (Omit<\n+      EnvMultipleChoiceQuestion,\n+      'answers' | 'tags' | 'deprecated'\n+    > & {\n+      answers: Omit<EnvAnswer, 'isCorrect'>[];\n+    })[];\n+  })[];\n+} & { generatedExamId: string; examId: string };\n+\n+/**\n+ * Takes the generated exam and the original exam, and creates the user-facing exam.\n+ */\n+export function constructUserExam(\n+  generatedExam: EnvGeneratedExam,\n+  exam: EnvExam\n+): UserExam {\n+  // Map generated exam to user exam (a.k.a. public exam information for user)\n+  const userQuestionSets = generatedExam.questionSets.map(gqs => {\n+    // Get matching question from `exam`, but remove `is_correct` from `exam.questions[].answers[]`\n+    const examQuestionSet = exam.questionSets.find(eqs => eqs.id === gqs.id)!;\n+\n+    const { questions } = examQuestionSet;\n+\n+    const userQuestions = gqs.questions.map(gq => {\n+      const examQuestion = questions.find(eq => eq.id === gq.id)!;\n+\n+      // Remove `isCorrect` from question answers\n+      const answers = gq.answers.map(generatedAnswerId => {\n+        const examAnswer = examQuestion.answers.find(\n+          ea => ea.id === generatedAnswerId\n+        )!;\n+\n+        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n+        const { isCorrect, ...answer } = examAnswer;\n+        return answer;\n+      });\n+\n+      return {\n+        id: examQuestion.id,\n+        audio: examQuestion.audio,\n+        text: examQuestion.text,\n+        answers\n+      };\n+    });\n+\n+    const userQuestionSet = {\n+      type: examQuestionSet.type,\n+      questions: userQuestions,\n+      id: examQuestionSet.id,\n+      context: examQuestionSet.context\n+    };\n+    return userQuestionSet;\n+  });\n+\n+  // Order questionSets in same order as original exam\n+  const orderedUserQuestionSets = userQuestionSets.sort((a, b) => {\n+    return (\n+      exam.questionSets.findIndex(qs => qs.id === a.id) -\n+      exam.questionSets.findIndex(qs => qs.id === b.id)\n+    );\n+  });\n+\n+  const config = {\n+    totalTimeInMS: exam.config.totalTimeInMS,\n+    name: exam.config.name,\n+    note: exam.config.note\n+  };\n+\n+  const userExam: UserExam = {\n+    examId: exam.id,\n+    generatedExamId: generatedExam.id,\n+    config,\n+    questionSets: orderedUserQuestionSets\n+  };\n+\n+  return userExam;\n+}\n+\n+/**\n+ * Ensures all questions and answers in the attempt are from the generated exam.\n+ */\n+export function validateAttempt(\n+  generatedExam: EnvGeneratedExam,\n+  questionSets: EnvExamAttempt['questionSets']\n+) {\n+  for (const attemptQuestionSet of questionSets) {\n+    const generatedQuestionSet = generatedExam.questionSets.find(\n+      qt => qt.id === attemptQuestionSet.id\n+    );\n+    if (!generatedQuestionSet) {\n+      throw new Error(\n+        `Question type ${attemptQuestionSet.id} not found in generated exam.`\n+      );\n+    }\n+\n+    for (const attemptQuestion of attemptQuestionSet.questions) {\n+      const generatedQuestion = generatedQuestionSet.questions.find(\n+        q => q.id === attemptQuestion.id\n+      );\n+      if (!generatedQuestion) {\n+        throw new Error(\n+          `Question ${attemptQuestion.id} not found in generated exam.`\n+        );\n+      }\n+\n+      for (const attemptAnswer of attemptQuestion.answers) {\n+        const generatedAnswer = generatedQuestion.answers.find(\n+          a => a === attemptAnswer\n+        );\n+        if (!generatedAnswer) {\n+          throw new Error(\n+            `Answer ${attemptAnswer} not found in generated exam.`\n+          );\n+        }\n+      }\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+/**\n+ * Checks all question sets and questions in the generated exam are in the attempt.\n+ *\n+ * TODO: Consider throwing with specific issue.\n+ *\n+ * @param questionSets An exam attempt.\n+ * @param generatedExam The corresponding generated exam.\n+ * @returns Whether or not the attempt can be considered finished.\n+ */\n+export function checkAttemptAgainstGeneratedExam(\n+  questionSets: EnvQuestionSetAttempt[],\n+  generatedExam: Pick<EnvGeneratedExam, 'questionSets'>\n+): boolean {\n+  // Check all question sets and questions are in generated exam\n+  for (const generatedQuestionSet of generatedExam.questionSets) {\n+    const attemptQuestionSet = questionSets.find(\n+      q => q.id === generatedQuestionSet.id\n+    );\n+    if (!attemptQuestionSet) {\n+      return false;\n+    }\n+\n+    for (const generatedQuestion of generatedQuestionSet.questions) {\n+      const attemptQuestion = attemptQuestionSet.questions.find(\n+        q => q.id === generatedQuestion.id\n+      );\n+      if (!attemptQuestion) {\n+        return false;\n+      }\n+\n+      const atLeastOneAnswer = attemptQuestion.answers.length > 0;\n+      if (!atLeastOneAnswer) {\n+        return false;\n+      }\n+\n+      // All answers in attempt must be in generated exam\n+      const allAnswersInGeneratedExam = attemptQuestion.answers.every(a =>\n+        generatedQuestion.answers.includes(a)\n+      );\n+      if (!allAnswersInGeneratedExam) {\n+        return false;\n+      }\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+/**\n+ * Adds the current time submission time to all questions in the attempt if the question answer has changed.\n+ */\n+export function userAttemptToDatabaseAttemptQuestionSets(\n+  userAttempt: Static<\n+    typeof schemas.examEnvironmentPostExamAttempt.body.properties.attempt\n+  >,\n+  latestAttempt: EnvExamAttempt\n+): EnvExamAttempt['questionSets'] {\n+  const databaseAttemptQuestionSets: EnvExamAttempt['questionSets'] = [];\n+\n+  for (const questionSet of userAttempt.questionSets) {\n+    const latestQuestionSet = latestAttempt.questionSets.find(\n+      qs => qs.id === questionSet.id\n+    );\n+\n+    // If no latest attempt, add submission time to all questions\n+    if (!latestQuestionSet) {\n+      databaseAttemptQuestionSets.push({\n+        ...questionSet,\n+        questions: questionSet.questions.map(q => {\n+          return { ...q, submissionTimeInMS: Date.now() };\n+        })\n+      });\n+    } else {\n+      const databaseAttemptQuestionSet = {\n+        ...questionSet,\n+        questions: questionSet.questions.map(q => {\n+          const latestQuestion = latestQuestionSet.questions.find(\n+            lq => lq.id === q.id\n+          );\n+\n+          // If no latest question, add submission time\n+          if (!latestQuestion) {\n+            return { ...q, submissionTimeInMS: Date.now() };\n+          }\n+\n+          // If answers have changed, add submission time\n+          if (\n+            JSON.stringify(q.answers) !== JSON.stringify(latestQuestion.answers)\n+          ) {\n+            return { ...q, submissionTimeInMS: Date.now() };\n+          }\n+\n+          return latestQuestion;\n+        })\n+      };\n+\n+      databaseAttemptQuestionSets.push(databaseAttemptQuestionSet);\n+    }\n+  }\n+\n+  return databaseAttemptQuestionSets;\n+}\n+\n+/**\n+ * Generates an exam for the user, based on the exam configuration.\n+ */\n+export function generateExam(exam: EnvExam): Omit<EnvGeneratedExam, 'id'> {\n+  const examCopy = structuredClone(exam);\n+\n+  const TIMEOUT_IN_MS = 5_000;\n+  const START_TIME = Date.now();\n+\n+  const shuffledQuestionSets = shuffleArray(examCopy.questionSets).map(qs => {\n+    const shuffledQuestions = shuffleArray(\n+      qs.questions.filter(q => !q.deprecated)\n+    ).map(q => {\n+      const shuffledAnswers = shuffleArray(q.answers);\n+      return {\n+        ...q,\n+        answers: shuffledAnswers\n+      };\n+    });\n+\n+    return {\n+      ...qs,\n+      questions: shuffledQuestions\n+    };\n+  });\n+\n+  // Convert question set config by type: [[all question sets of type], [another type], ...]\n+  const typeConvertedQuestionSetsConfig = examCopy.config.questionSets.reduce(\n+    (acc, curr) => {\n+      // If type is already in accumulator, add to it.\n+      const typeIndex = acc.findIndex(a => a[0]?.type === curr.type);\n+      acc[typeIndex]?.push(curr) ?? acc.push([curr]);\n+      return acc;\n+    },\n+    [] as unknown as [EnvConfig['questionSets']]\n+  );\n+\n+  // Heuristic:\n+  // TODO: The lower the number of questions able to fulfill the criteria, the harder the question set.\n+  // TODO: Sort difficulty, push question, sort new difficulty, push question, ...\n+  typeConvertedQuestionSetsConfig.forEach(qsc => {\n+    // Currently, the sorted order is random as this allows the existing algorithm to be retried until\n+    // a successful exam generation.\n+    qsc.sort(() => Math.round(Math.random() * 2 - 1));\n+  });\n+\n+  const sortedQuestionSetsConfig = typeConvertedQuestionSetsConfig.flat();\n+\n+  // Move all questions from set that are used to fulfill tag config.\n+  const questionSetsConfigWithQuestions = sortedQuestionSetsConfig.map(qsc => {\n+    return {\n+      ...qsc,\n+      questionSets: [] as EnvQuestionSet[]\n+    };\n+  });\n+\n+  // Sort tag config by number of tags in descending order.\n+  const sortedTagConfig = examCopy.config.tags.sort(\n+    (a, b) => b.group.length - a.group.length\n+  );\n+\n+  questionSetsConfigWithQuestionsLoop: for (const questionSetConfig of questionSetsConfigWithQuestions) {\n+    sortedTagConfigLoop: for (const tagConfig of sortedTagConfig) {\n+      shuffledQuestionSetsLoop: for (const questionSet of shuffledQuestionSets.filter(\n+        sqs => sqs.type === questionSetConfig.type\n+      )) {\n+        // If questionSet does not have enough questions for config, do not consider.\n+        if (\n+          questionSetConfig.numberOfQuestions > questionSet.questions.length\n+        ) {\n+          continue shuffledQuestionSetsLoop;\n+        }\n+        // If tagConfig is finished, skip.\n+        if (tagConfig.numberOfQuestions === 0) {\n+          continue sortedTagConfigLoop;\n+        }\n+        // If questionSetConfig has been fulfilled, skip.\n+        if (isQuestionSetConfigFulfilled(questionSetConfig)) {\n+          continue questionSetsConfigWithQuestionsLoop;\n+        }\n+\n+        // Find question with at least all tags in the set.\n+        const questions = questionSet.questions.filter(q =>\n+          tagConfig.group.every(t => q.tags.some(qt => qt === t))\n+        );\n+\n+        questionsLoop: for (const question of questions) {\n+          // Does question fulfill criteria for questionSetConfig:\n+          const numberOfCorrectAnswers = question.answers.filter(\n+            a => a.isCorrect\n+          ).length;\n+          const numberOfIncorrectAnswers = question.answers.filter(\n+            a => !a.isCorrect\n+          ).length;\n+\n+          if (\n+            questionSetConfig.numberOfCorrectAnswers <=\n+              numberOfCorrectAnswers &&\n+            questionSetConfig.numberOfIncorrectAnswers <=\n+              numberOfIncorrectAnswers\n+          ) {\n+            if (isQuestionSetConfigFulfilled(questionSetConfig)) {\n+              continue questionSetsConfigWithQuestionsLoop;\n+            }\n+            // Push questionSet if it does not exist. Otherwise, just push question\n+            const qscqs = questionSetConfig.questionSets.find(\n+              qs => qs.id === questionSet.id\n+            );\n+            const questionWithCorrectNumberOfAnswers = {\n+              ...question,\n+              answers: getRandomAnswers(question, questionSetConfig)\n+            };\n+            if (!qscqs) {\n+              if (\n+                questionSetConfig.numberOfSet ===\n+                questionSetConfig.questionSets.length\n+              ) {\n+                break questionsLoop;\n+              }\n+              const newQuestionSetWithQuestion = {\n+                ...questionSet,\n+                questions: [questionWithCorrectNumberOfAnswers]\n+              };\n+              questionSetConfig.questionSets.push(newQuestionSetWithQuestion);\n+            } else {\n+              if (\n+                qscqs.questions.length === questionSetConfig.numberOfQuestions\n+              ) {\n+                break questionsLoop;\n+              }\n+              qscqs.questions.push(questionWithCorrectNumberOfAnswers);\n+            }\n+\n+            // TODO: Issue is question set is not being removed. So, one question set is used multiple times to fulfill config.\n+            // Just remove question set once used? Evaluate:\n+            shuffledQuestionSets.splice(\n+              shuffledQuestionSets.findIndex(qs => qs.id === questionSet.id),\n+              1\n+            );\n+            // New issue: Once the set is removed, tag config might not be able to be fulfilled.\n+\n+            // Remove question from questionSet, decrement tagConfig.numberOfQuestions and `questionSetConfig.numberOfQuestions`\n+            questionSet.questions.splice(\n+              questionSet.questions.findIndex(q => q.id === question.id),\n+              1\n+            );\n+            tagConfig.numberOfQuestions -= 1;\n+          }\n+        }\n+      }\n+    }\n+\n+    // Add questions to questionSetsConfigWithQuestions until fulfilled.\n+    while (!isQuestionSetConfigFulfilled(questionSetConfig)) {\n+      if (Date.now() - START_TIME > TIMEOUT_IN_MS) {\n+        throw `Unable to generate exam within ${TIMEOUT_IN_MS}ms`;\n+      }\n+      // Ensure all questionSets ARE FULL\n+      if (\n+        questionSetConfig.numberOfSet > questionSetConfig.questionSets.length\n+      ) {\n+        const questionSet = shuffledQuestionSets.find(qs => {\n+          if (qs.type === questionSetConfig.type) {\n+            if (qs.questions.length >= questionSetConfig.numberOfQuestions) {\n+              if (qs.questions.length >= questionSetConfig.numberOfQuestions) {\n+                // Find questionSetConfig.numberOfQuestions who have `questionSetConfig.numberOfCorrectAnswers` and `questionSetConfig.numberOfIncorrectAnswers`\n+                const questions = qs.questions.filter(q => {\n+                  const numberOfCorrectAnswers = q.answers.filter(\n+                    a => a.isCorrect\n+                  ).length;\n+                  const numberOfIncorrectAnswers = q.answers.filter(\n+                    a => !a.isCorrect\n+                  ).length;\n+                  return (\n+                    numberOfCorrectAnswers >=\n+                      questionSetConfig.numberOfCorrectAnswers &&\n+                    numberOfIncorrectAnswers >=\n+                      questionSetConfig.numberOfIncorrectAnswers\n+                  );\n+                });\n+\n+                if (questions.length >= questionSetConfig.numberOfQuestions) {\n+                  return true;\n+                }\n+              }\n+            }\n+          }\n+        });\n+\n+        if (!questionSet) {\n+          throw `Invalid Exam Configuration for ${examCopy.id}. Not enough questions for question type ${questionSetConfig.type}.`;\n+        }\n+        // Remove questionSet from shuffledQuestionSets\n+        shuffledQuestionSets.splice(\n+          shuffledQuestionSets.findIndex(qs => qs.id === questionSet.id),\n+          1\n+        );\n+\n+        const questions = questionSet.questions.filter(q => {\n+          const numberOfCorrectAnswers = q.answers.filter(\n+            a => a.isCorrect\n+          ).length;\n+          const numberOfIncorrectAnswers = q.answers.filter(\n+            a => !a.isCorrect\n+          ).length;\n+          return (\n+            numberOfCorrectAnswers >=\n+              questionSetConfig.numberOfCorrectAnswers &&\n+            numberOfIncorrectAnswers >=\n+              questionSetConfig.numberOfIncorrectAnswers\n+          );\n+        });\n+\n+        const questionSetWithCorrectNumberOfAnswers = {\n+          ...questionSet,\n+          questions: questions.map(q => ({\n+            ...q,\n+            answers: getRandomAnswers(q, questionSetConfig)\n+          }))\n+        };\n+\n+        questionSetConfig.questionSets.push(\n+          questionSetWithCorrectNumberOfAnswers\n+        );\n+      }\n+\n+      // Ensure all existing questionSets have correct number of questions\n+      for (const questionSet of questionSetConfig.questionSets) {\n+        if (\n+          questionSet.questions.length < questionSetConfig.numberOfQuestions\n+        ) {\n+          const questions = shuffledQuestionSets\n+            .find(qs => qs.id === questionSet.id)\n+            ?.questions.filter(\n+              q => !questionSet.questions.find(qsq => qsq.id === q.id)\n+            );\n+          if (!questions) {\n+            throw `Invalid Exam Configuration for ${examCopy.id}. Not enough questions for question type ${questionSetConfig.type}.`;\n+          }\n+\n+          const questionsWithEnoughAnswers = questions.filter(q => {\n+            const numberOfCorrectAnswers = q.answers.filter(\n+              a => a.isCorrect\n+            ).length;\n+            const numberOfIncorrectAnswers = q.answers.filter(\n+              a => !a.isCorrect\n+            ).length;\n+            return (\n+              numberOfCorrectAnswers >=\n+                questionSetConfig.numberOfCorrectAnswers &&\n+              numberOfIncorrectAnswers >=\n+                questionSetConfig.numberOfIncorrectAnswers\n+            );\n+          });\n+\n+          // Push as many questions as needed to fulfill questionSetConfig\n+          const questionsToAdd = questionsWithEnoughAnswers.splice(\n+            0,\n+            questionSetConfig.numberOfQuestions - questionSet.questions.length\n+          );\n+\n+          questionSet.questions.push(\n+            ...questionsToAdd.map(q => ({\n+              ...q,\n+              answers: getRandomAnswers(q, questionSetConfig)\n+            }))\n+          );\n+\n+          // Remove questions from shuffledQuestionSets\n+          questionsToAdd.forEach(q => {\n+            const index = shuffledQuestionSets\n+              .find(qs => qs.id === questionSet.id)!\n+              .questions.findIndex(qs => qs.id === q.id);\n+\n+            shuffledQuestionSets\n+              .find(qs => qs.id === questionSet.id)\n+              ?.questions.splice(index, 1);\n+          });\n+        }\n+      }\n+    }\n+  }\n+\n+  for (const tagConfig of sortedTagConfig) {\n+    if (tagConfig.numberOfQuestions > 0) {\n+      throw `Invalid Exam Configuration for exam \"${examCopy.id}\". Not enough questions for tag group \"${tagConfig.group.join(',')}\".`;\n+    }\n+  }\n+\n+  const questionSets = questionSetsConfigWithQuestions.flatMap(qsc => {\n+    const questionSets = qsc.questionSets;\n+    return questionSets.map(qs => {\n+      const questions = qs.questions.map(q => {\n+        const answers = q.answers.map(a => a.id);\n+        return {\n+          id: q.id,\n+          answers\n+        };\n+      });\n+      return {\n+        id: qs.id,\n+        questions\n+      };\n+    });\n+  });\n+\n+  return {\n+    examId: examCopy.id,\n+    questionSets,\n+    deprecated: false\n+  };\n+}\n+\n+function isQuestionSetConfigFulfilled(\n+  questionSetConfig: EnvConfig['questionSets'][number] & {\n+    questionSets: EnvQuestionSet[];\n+  }\n+) {\n+  return (\n+    questionSetConfig.numberOfSet === questionSetConfig.questionSets.length &&\n+    questionSetConfig.questionSets.every(qs => {\n+      return qs.questions.length === questionSetConfig.numberOfQuestions;\n+    })\n+  );\n+}\n+\n+/**\n+ * Gets random answers for a question.\n+ */\n+function getRandomAnswers(\n+  question: EnvMultipleChoiceQuestion,\n+  questionSetConfig: EnvConfig['questionSets'][number]\n+): EnvMultipleChoiceQuestion['answers'] {\n+  const { numberOfCorrectAnswers, numberOfIncorrectAnswers } =\n+    questionSetConfig;\n+\n+  const randomAnswers = shuffleArray(question.answers);\n+  const incorrectAnswers = randomAnswers\n+    .filter(a => !a.isCorrect)\n+    .splice(0, numberOfIncorrectAnswers);\n+  const correctAnswers = randomAnswers\n+    .filter(a => a.isCorrect)\n+    .splice(0, numberOfCorrectAnswers);\n+\n+  if (!incorrectAnswers || !correctAnswers) {\n+    throw new Error(\n+      `Question ${question.id} does not have enough correct/incorrect answers.`\n+    );\n+  }\n+\n+  const answers = incorrectAnswers.concat(correctAnswers);\n+  return answers;\n+}\n+\n+/* eslint-disable jsdoc/require-description-complete-sentence */\n+/**\n+ * Shuffles an array using the Fisher-Yates algorithm.\n+ *\n+ * https://bost.ocks.org/mike/shuffle/\n+ */\n+function shuffleArray<T>(array: Array<T>) {\n+  let m = array.length;\n+  let t;\n+  let i;\n+\n+  // While there remain elements to shuffle\n+  while (m) {\n+    // Pick a remaining element\n+    i = Math.floor(Math.random() * m--);\n+\n+    // And swap it with the current element.\n+    t = array[m]!;\n+    array[m] = array[i]!;\n+    array[i] = t;\n+  }\n+\n+  return array;\n+}\n+/* eslint-enable jsdoc/require-description-complete-sentence */"
        },
        {
            "sha": "aa227eae3c6342238a0082051738e825acc2806c",
            "filename": "api/src/plugins/auth.ts",
            "status": "modified",
            "additions": 91,
            "deletions": 1,
            "changes": 92,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fplugins%2Fauth.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fplugins%2Fauth.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fplugins%2Fauth.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -1,10 +1,11 @@\n-import { FastifyPluginCallback, FastifyRequest } from 'fastify';\n+import { FastifyPluginCallback, FastifyRequest, FastifyReply } from 'fastify';\n import fp from 'fastify-plugin';\n import jwt from 'jsonwebtoken';\n import { type user } from '@prisma/client';\n \n import { JWT_SECRET } from '../utils/env';\n import { type Token, isExpired } from '../utils/tokens';\n+import { ERRORS } from '../exam-environment/utils/errors';\n \n declare module 'fastify' {\n   interface FastifyReply {\n@@ -19,6 +20,10 @@ declare module 'fastify' {\n \n   interface FastifyInstance {\n     authorize: (req: FastifyRequest, reply: FastifyReply) => void;\n+    authorizeExamEnvironmentToken: (\n+      req: FastifyRequest,\n+      reply: FastifyReply\n+    ) => void;\n   }\n }\n \n@@ -70,9 +75,94 @@ const auth: FastifyPluginCallback = (fastify, _options, done) => {\n     req.user = user;\n   };\n \n+  async function handleExamEnvironmentTokenAuth(\n+    req: FastifyRequest,\n+    reply: FastifyReply\n+  ) {\n+    const { 'exam-environment-authorization-token': encodedToken } =\n+      req.headers;\n+\n+    if (!encodedToken || typeof encodedToken !== 'string') {\n+      void reply.code(400);\n+      return reply.send(\n+        ERRORS.FCC_EINVAL_EXAM_ENVIRONMENT_AUTHORIZATION_TOKEN(\n+          'EXAM-ENVIRONMENT-AUTHORIZATION-TOKEN header is a required string.'\n+        )\n+      );\n+    }\n+\n+    try {\n+      jwt.verify(encodedToken, JWT_SECRET);\n+    } catch (e) {\n+      void reply.code(403);\n+      return reply.send(\n+        ERRORS.FCC_EINVAL_EXAM_ENVIRONMENT_AUTHORIZATION_TOKEN(\n+          JSON.stringify(e)\n+        )\n+      );\n+    }\n+\n+    const payload = jwt.decode(encodedToken);\n+\n+    if (typeof payload !== 'object' || payload === null) {\n+      void reply.code(500);\n+      return reply.send(\n+        ERRORS.FCC_EINVAL_EXAM_ENVIRONMENT_AUTHORIZATION_TOKEN(\n+          'Unreachable. Decoded token has been verified.'\n+        )\n+      );\n+    }\n+\n+    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n+    const examEnvironmentAuthorizationToken =\n+      payload['examEnvironmentAuthorizationToken'];\n+\n+    // if (typeof examEnvironmentAuthorizationToken !== 'string') {\n+    //   // TODO: This code is debatable, because the token would have to have been signed by the api\n+    //   //       which means it is valid, but, somehow, got signed as an object instead of a string.\n+    //   void reply.code(400+500);\n+    //   return reply.send(\n+    //     ERRORS.FCC_EINVAL_EXAM_ENVIRONMENT_AUTHORIZATION_TOKEN(\n+    //       'EXAM-ENVIRONMENT-AUTHORIZATION-TOKEN is not valid.'\n+    //     )\n+    //   );\n+    // }\n+\n+    assertIsString(examEnvironmentAuthorizationToken);\n+\n+    const token =\n+      await fastify.prisma.examEnvironmentAuthorizationToken.findFirst({\n+        where: {\n+          id: examEnvironmentAuthorizationToken\n+        }\n+      });\n+\n+    if (!token) {\n+      return {\n+        message: 'Token not found'\n+      };\n+    }\n+\n+    const user = await fastify.prisma.user.findUnique({\n+      where: { id: token.userId }\n+    });\n+    if (!user) return setAccessDenied(req, TOKEN_INVALID);\n+    req.user = user;\n+  }\n+\n   fastify.decorate('authorize', handleAuth);\n+  fastify.decorate(\n+    'authorizeExamEnvironmentToken',\n+    handleExamEnvironmentTokenAuth\n+  );\n \n   done();\n };\n \n+function assertIsString(some: unknown): asserts some is string {\n+  if (typeof some !== 'string') {\n+    throw new Error('Expected a string');\n+  }\n+}\n+\n export default fp(auth, { name: 'auth', dependencies: ['cookies'] });"
        },
        {
            "sha": "4466346372ef3a9aa4239c4d09bcc55c816fe304",
            "filename": "api/src/routes/protected/certificate.test.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Froutes%2Fprotected%2Fcertificate.test.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Froutes%2Fprotected%2Fcertificate.test.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Froutes%2Fprotected%2Fcertificate.test.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -1,4 +1,3 @@\n-import { type PrismaPromise } from '@prisma/client';\n import { Certification } from '../../../../shared/config/certification-settings';\n import {\n   defaultUserEmail,\n@@ -85,7 +84,10 @@ describe('certificate routes', () => {\n         jest\n           .spyOn(fastifyTestInstance.prisma.user, 'findUnique')\n           .mockImplementation(\n-            () => Promise.resolve(null) as PrismaPromise<null>\n+            () =>\n+              Promise.resolve(null) as ReturnType<\n+                typeof fastifyTestInstance.prisma.user.findUnique\n+              >\n           );\n         const response = await superRequest('/certificate/verify', {\n           method: 'PUT',"
        },
        {
            "sha": "07c33e93063bb4c3dc5944f2ece912156605e8f0",
            "filename": "api/src/routes/protected/user.ts",
            "status": "modified",
            "additions": 58,
            "deletions": 0,
            "changes": 58,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Froutes%2Fprotected%2Fuser.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Froutes%2Fprotected%2Fuser.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Froutes%2Fprotected%2Fuser.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -1,5 +1,8 @@\n import type { FastifyPluginCallbackTypebox } from '@fastify/type-provider-typebox';\n import { ObjectId } from 'mongodb';\n+import _ from 'lodash';\n+import { FastifyInstance, FastifyReply } from 'fastify';\n+import jwt from 'jsonwebtoken';\n \n import * as schemas from '../../schemas';\n import { createResetProperties } from '../../utils/create-user';\n@@ -16,11 +19,13 @@ import {\n   normalizeTwitter,\n   removeNulls\n } from '../../utils/normalize';\n+import type { UpdateReqType } from '../../utils';\n import {\n   getCalendar,\n   getPoints,\n   ProgressTimestamp\n } from '../../utils/progress';\n+import { JWT_SECRET } from '../../utils/env';\n \n /**\n  * Helper function to get the api url from the shared transcript link.\n@@ -71,6 +76,9 @@ export const userRoutes: FastifyPluginCallbackTypebox = (\n       await fastify.prisma.user.delete({\n         where: { id: req.user!.id }\n       });\n+      await fastify.prisma.examEnvironmentAuthorizationToken.deleteMany({\n+        where: { userId: req.user!.id }\n+      });\n       reply.clearOurCookies();\n \n       return {};\n@@ -356,9 +364,59 @@ export const userRoutes: FastifyPluginCallbackTypebox = (\n     }\n   );\n \n+  fastify.post(\n+    '/user/exam-environment/token',\n+    {\n+      schema: schemas.userExamEnvironmentToken\n+    },\n+    examEnvironmentTokenHandler\n+  );\n+\n   done();\n };\n \n+// eslint-disable-next-line jsdoc/require-param\n+/**\n+ * Generate a new authorization token for the given user, and invalidates any existing tokens.\n+ *\n+ * Requires the user to be authenticated.\n+ */\n+async function examEnvironmentTokenHandler(\n+  this: FastifyInstance,\n+  req: UpdateReqType<typeof schemas.userExamEnvironmentToken>,\n+  reply: FastifyReply\n+) {\n+  const userId = req.user?.id;\n+  if (!userId) {\n+    throw new Error('Unreachable. User should be authenticated.');\n+  }\n+  // Delete (invalidate) any existing tokens for the user.\n+  await this.prisma.examEnvironmentAuthorizationToken.deleteMany({\n+    where: {\n+      userId\n+    }\n+  });\n+\n+  const token = await this.prisma.examEnvironmentAuthorizationToken.create({\n+    data: {\n+      createdDate: new Date(),\n+      id: customNanoid(),\n+      userId\n+    }\n+  });\n+\n+  const examEnvironmentAuthorizationToken = jwt.sign(\n+    { examEnvironmentAuthorizationToken: token.id },\n+    JWT_SECRET\n+  );\n+\n+  void reply.send({\n+    data: {\n+      examEnvironmentAuthorizationToken\n+    }\n+  });\n+}\n+\n /**\n  * Plugin containing GET routes for user account management. They are kept\n  * separate because they do not require CSRF protection."
        },
        {
            "sha": "d359ed7d3f33c724154762d3694eb3445c3bb1d7",
            "filename": "api/src/schemas.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fschemas.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fschemas.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fschemas.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -39,3 +39,4 @@ export { postMsUsername } from './schemas/user/post-ms-username';\n export { reportUser } from './schemas/user/report-user';\n export { resetMyProgress } from './schemas/user/reset-my-progress';\n export { submitSurvey } from './schemas/user/submit-survey';\n+export { userExamEnvironmentToken } from './schemas/user/exam-environment-token';"
        },
        {
            "sha": "c324802e861371f693d86507b7b16e4d09899532",
            "filename": "api/src/schemas/user/exam-environment-token.ts",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fschemas%2Fuser%2Fexam-environment-token.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Fschemas%2Fuser%2Fexam-environment-token.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fschemas%2Fuser%2Fexam-environment-token.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -0,0 +1,11 @@\n+import { Type } from '@fastify/type-provider-typebox';\n+\n+export const userExamEnvironmentToken = {\n+  response: {\n+    200: Type.Object({\n+      data: Type.Object({\n+        examEnvironmentAuthorizationToken: Type.String()\n+      })\n+    })\n+  }\n+};"
        },
        {
            "sha": "d34ca2c3d13f37351457d6c7a8080bec73e8d74a",
            "filename": "api/src/utils/index.ts",
            "status": "modified",
            "additions": 89,
            "deletions": 0,
            "changes": 89,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Futils%2Findex.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/api%2Fsrc%2Futils%2Findex.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Futils%2Findex.ts?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -1,4 +1,12 @@\n import { randomBytes, createHash } from 'crypto';\n+import { type TypeBoxTypeProvider } from '@fastify/type-provider-typebox';\n+import {\n+  type FastifyRequest,\n+  type FastifySchema,\n+  type RawRequestDefaultExpression,\n+  type RawServerDefault,\n+  type RouteGenericInterface\n+} from 'fastify';\n \n /**\n  * Utility to encode a buffer to a base64 URI.\n@@ -19,3 +27,84 @@ function sha256(buf: Buffer) {\n   return createHash('sha256').update(buf).digest();\n }\n export const challenge = base64URLEncode(sha256(Buffer.from(verifier)));\n+\n+export type UpdateReqType<Schema extends FastifySchema> = FastifyRequest<\n+  RouteGenericInterface,\n+  RawServerDefault,\n+  RawRequestDefaultExpression<RawServerDefault>,\n+  Schema,\n+  TypeBoxTypeProvider\n+>;\n+\n+/* eslint-disable jsdoc/require-description-complete-sentence */\n+/**\n+ * Wrapper around a promise to catch errors and return them as part of the promise.\n+ *\n+ * This is most useful to prevent callback / try...catch hell.\n+ *\n+ * ## Example:\n+ *\n+ * ```ts\n+ * const maybeWhatIWant = await mapErr(\n+ *   this.prisma.whatIWantCollection.create({\n+ *     data: {}\n+ *   })\n+ * );\n+ *\n+ * if (maybeWhatIWant.hasError) {\n+ *   void reply.code(500);\n+ *   return reply.send('Unable to generate exam, due to: ' +\n+ *     JSON.stringify(maybeWhatIWant.error)\n+ *   );\n+ * }\n+ *\n+ * const whatIWant = maybeWhatIWant.data;\n+ * ```\n+ *\n+ * @param promise - any promise to be tried.\n+ * @returns a promise with either the data or the caught error\n+ */\n+export async function mapErr<T>(promise: Promise<T>): Promise<Result<T>> {\n+  try {\n+    return { hasError: false, data: await promise };\n+  } catch (error) {\n+    return { hasError: true, error };\n+  }\n+}\n+\n+/**\n+ * Wrapper around a synchronise function to catch throws and return them as part of the value.\n+ *\n+ * This is most useful to prevent try...catch hell.\n+ *\n+ * ## Example:\n+ *\n+ * ```ts\n+ * const maybeWhatIWant = await syncMapErr(\n+ *   () => chai.assert.deepEqual({}, {})\n+ * );\n+ *\n+ * if (maybeWhatIWant.hasError) {\n+ *   void reply.code(500);\n+ *   return reply.send('Unable to generate exam, due to: ' +\n+ *     JSON.stringify(maybeWhatIWant.error)\n+ *   );\n+ * }\n+ *\n+ * const whatIWant = maybeWhatIWant.data;\n+ * ```\n+ *\n+ * @param fn - any function to be tried.\n+ * @returns the data or the caught error\n+ */\n+export function syncMapErr<T>(fn: () => T): Result<T> {\n+  try {\n+    return { hasError: false, data: fn() };\n+  } catch (error) {\n+    return { hasError: true, error };\n+  }\n+}\n+\n+export type Result<T> =\n+  | { hasError: false; data: T }\n+  | { hasError: true; error: unknown };"
        },
        {
            "sha": "a6b7fb8c1d8fa38eaeb06a587a8f965a21e1c05c",
            "filename": "package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/package.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/package.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/package.json?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -60,9 +60,10 @@\n     \"preseed\": \"npm-run-all create:shared\",\n     \"playwright:install-build-tools\": \"npx playwright install --with-deps\",\n     \"rename-challenges\": \"ts-node tools/challenge-helper-scripts/rename-challenge-files.ts\",\n-    \"seed\": \"pnpm seed:surveys && pnpm seed:exams && DEBUG=fcc:* node ./tools/scripts/seed/seed-demo-user\",\n+    \"seed\": \"pnpm seed:surveys && pnpm seed:exams && pnpm seed:env-exam && DEBUG=fcc:* node ./tools/scripts/seed/seed-demo-user\",\n     \"seed:certified-user\": \"pnpm seed:surveys && pnpm seed:exams && pnpm seed:ms-username && DEBUG=fcc:* node ./tools/scripts/seed/seed-demo-user --certified-user\",\n     \"seed:exams\": \"DEBUG=fcc:* node tools/scripts/seed-exams/create-exams\",\n+    \"seed:env-exam\": \"cd api && pnpm run seed:env-exam\",\n     \"seed:surveys\": \"DEBUG=fcc:* node ./tools/scripts/seed/seed-surveys\",\n     \"seed:ms-username\": \"DEBUG=fcc:* node ./tools/scripts/seed/seed-ms-username\",\n     \"serve:client\": \"cd ./client && pnpm run serve\","
        },
        {
            "sha": "27e2f0c11ffd74c9ef286843562d27170f170e54",
            "filename": "pnpm-lock.yaml",
            "status": "modified",
            "additions": 279,
            "deletions": 13,
            "changes": 292,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ea441358084784a628cd39d1adbf3b466621a356/pnpm-lock.yaml",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ea441358084784a628cd39d1adbf3b466621a356/pnpm-lock.yaml",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/pnpm-lock.yaml?ref=ea441358084784a628cd39d1adbf3b466621a356",
            "patch": "@@ -256,6 +256,9 @@ importers:\n       ts-jest:\n         specifier: 29.1.2\n         version: 29.1.2(@babel/core@7.23.7)(@jest/types@29.6.3)(babel-jest@29.7.0(@babel/core@7.23.7))(jest@29.7.0(@types/node@20.12.8)(babel-plugin-macros@3.1.0)(ts-node@10.9.2(@types/node@20.12.8)(typescript@5.4.5)))(typescript@5.4.5)\n+      tsx:\n+        specifier: 4.19.1\n+        version: 4.19.1\n \n   api-server:\n     dependencies:\n@@ -2673,138 +2676,282 @@ packages:\n     resolution: {integrity: sha512-R1w57YlVA6+YE01wch3GPYn6bCsrOV3YW/5oGGE2tmX6JcL9Nr+b5IikrjMPF+v9CV3ay+obImEdsDhovhJrzw==}\n     engines: {node: '>=16'}\n \n+  '@esbuild/aix-ppc64@0.23.1':\n+    resolution: {integrity: sha512-6VhYk1diRqrhBAqpJEdjASR/+WVRtfjpqKuNw11cLiaWpAT/Uu+nokB+UJnevzy/P9C/ty6AOe0dwueMrGh/iQ==}\n+    engines: {node: '>=18'}\n+    cpu: [ppc64]\n+    os: [aix]\n+\n   '@esbuild/android-arm64@0.18.20':\n     resolution: {integrity: sha512-Nz4rJcchGDtENV0eMKUNa6L12zz2zBDXuhj/Vjh18zGqB44Bi7MBMSXjgunJgjRhCmKOjnPuZp4Mb6OKqtMHLQ==}\n     engines: {node: '>=12'}\n     cpu: [arm64]\n     os: [android]\n \n+  '@esbuild/android-arm64@0.23.1':\n+    resolution: {integrity: sha512-xw50ipykXcLstLeWH7WRdQuysJqejuAGPd30vd1i5zSyKK3WE+ijzHmLKxdiCMtH1pHz78rOg0BKSYOSB/2Khw==}\n+    engines: {node: '>=18'}\n+    cpu: [arm64]\n+    os: [android]\n+\n   '@esbuild/android-arm@0.18.20':\n     resolution: {integrity: sha512-fyi7TDI/ijKKNZTUJAQqiG5T7YjJXgnzkURqmGj13C6dCqckZBLdl4h7bkhHt/t0WP+zO9/zwroDvANaOqO5Sw==}\n     engines: {node: '>=12'}\n     cpu: [arm]\n     os: [android]\n \n+  '@esbuild/android-arm@0.23.1':\n+    resolution: {integrity: sha512-uz6/tEy2IFm9RYOyvKl88zdzZfwEfKZmnX9Cj1BHjeSGNuGLuMD1kR8y5bteYmwqKm1tj8m4cb/aKEorr6fHWQ==}\n+    engines: {node: '>=18'}\n+    cpu: [arm]\n+    os: [android]\n+\n   '@esbuild/android-x64@0.18.20':\n     resolution: {integrity: sha512-8GDdlePJA8D6zlZYJV/jnrRAi6rOiNaCC/JclcXpB+KIuvfBN4owLtgzY2bsxnx666XjJx2kDPUmnTtR8qKQUg==}\n     engines: {node: '>=12'}\n     cpu: [x64]\n     os: [android]\n \n+  '@esbuild/android-x64@0.23.1':\n+    resolution: {integrity: sha512-nlN9B69St9BwUoB+jkyU090bru8L0NA3yFvAd7k8dNsVH8bi9a8cUAUSEcEEgTp2z3dbEDGJGfP6VUnkQnlReg==}\n+    engines: {node: '>=18'}\n+    cpu: [x64]\n+    os: [android]\n+\n   '@esbuild/darwin-arm64@0.18.20':\n     resolution: {integrity: sha512-bxRHW5kHU38zS2lPTPOyuyTm+S+eobPUnTNkdJEfAddYgEcll4xkT8DB9d2008DtTbl7uJag2HuE5NZAZgnNEA==}\n     engines: {node: '>=12'}\n     cpu: [arm64]\n     os: [darwin]\n \n+  '@esbuild/darwin-arm64@0.23.1':\n+    resolution: {integrity: sha512-YsS2e3Wtgnw7Wq53XXBLcV6JhRsEq8hkfg91ESVadIrzr9wO6jJDMZnCQbHm1Guc5t/CdDiFSSfWP58FNuvT3Q==}\n+    engines: {node: '>=18'}\n+    cpu: [arm64]\n+    os: [darwin]\n+\n   '@esbuild/darwin-x64@0.18.20':\n     resolution: {integrity: sha512-pc5gxlMDxzm513qPGbCbDukOdsGtKhfxD1zJKXjCCcU7ju50O7MeAZ8c4krSJcOIJGFR+qx21yMMVYwiQvyTyQ==}\n     engines: {node: '>=12'}\n     cpu: [x64]\n     os: [darwin]\n \n+  '@esbuild/darwin-x64@0.23.1':\n+    resolution: {integrity: sha512-aClqdgTDVPSEGgoCS8QDG37Gu8yc9lTHNAQlsztQ6ENetKEO//b8y31MMu2ZaPbn4kVsIABzVLXYLhCGekGDqw==}\n+    engines: {node: '>=18'}\n+    cpu: [x64]\n+    os: [darwin]\n+\n   '@esbuild/freebsd-arm64@0.18.20':\n     resolution: {integrity: sha512-yqDQHy4QHevpMAaxhhIwYPMv1NECwOvIpGCZkECn8w2WFHXjEwrBn3CeNIYsibZ/iZEUemj++M26W3cNR5h+Tw==}\n     engines: {node: '>=12'}\n     cpu: [arm64]\n     os: [freebsd]\n \n+  '@esbuild/freebsd-arm64@0.23.1':\n+    resolution: {integrity: sha512-h1k6yS8/pN/NHlMl5+v4XPfikhJulk4G+tKGFIOwURBSFzE8bixw1ebjluLOjfwtLqY0kewfjLSrO6tN2MgIhA==}\n+    engines: {node: '>=18'}\n+    cpu: [arm64]\n+    os: [freebsd]\n+\n   '@esbuild/freebsd-x64@0.18.20':\n     resolution: {integrity: sha512-tgWRPPuQsd3RmBZwarGVHZQvtzfEBOreNuxEMKFcd5DaDn2PbBxfwLcj4+aenoh7ctXcbXmOQIn8HI6mCSw5MQ==}\n     engines: {node: '>=12'}\n     cpu: [x64]\n     os: [freebsd]\n \n+  '@esbuild/freebsd-x64@0.23.1':\n+    resolution: {integrity: sha512-lK1eJeyk1ZX8UklqFd/3A60UuZ/6UVfGT2LuGo3Wp4/z7eRTRYY+0xOu2kpClP+vMTi9wKOfXi2vjUpO1Ro76g==}\n+    engines: {node: '>=18'}\n+    cpu: [x64]\n+    os: [freebsd]\n+\n   '@esbuild/linux-arm64@0.18.20':\n     resolution: {integrity: sha512-2YbscF+UL7SQAVIpnWvYwM+3LskyDmPhe31pE7/aoTMFKKzIc9lLbyGUpmmb8a8AixOL61sQ/mFh3jEjHYFvdA==}\n     engines: {node: '>=12'}\n     cpu: [arm64]\n     os: [linux]\n \n+  '@esbuild/linux-arm64@0.23.1':\n+    resolution: {integrity: sha512-/93bf2yxencYDnItMYV/v116zff6UyTjo4EtEQjUBeGiVpMmffDNUyD9UN2zV+V3LRV3/on4xdZ26NKzn6754g==}\n+    engines: {node: '>=18'}\n+    cpu: [arm64]\n+    os: [linux]\n+\n   '@esbuild/linux-arm@0.18.20':\n     resolution: {integrity: sha512-/5bHkMWnq1EgKr1V+Ybz3s1hWXok7mDFUMQ4cG10AfW3wL02PSZi5kFpYKrptDsgb2WAJIvRcDm+qIvXf/apvg==}\n     engines: {node: '>=12'}\n     cpu: [arm]\n     os: [linux]\n \n+  '@esbuild/linux-arm@0.23.1':\n+    resolution: {integrity: sha512-CXXkzgn+dXAPs3WBwE+Kvnrf4WECwBdfjfeYHpMeVxWE0EceB6vhWGShs6wi0IYEqMSIzdOF1XjQ/Mkm5d7ZdQ==}\n+    engines: {node: '>=18'}\n+    cpu: [arm]\n+    os: [linux]\n+\n   '@esbuild/linux-ia32@0.18.20':\n     resolution: {integrity: sha512-P4etWwq6IsReT0E1KHU40bOnzMHoH73aXp96Fs8TIT6z9Hu8G6+0SHSw9i2isWrD2nbx2qo5yUqACgdfVGx7TA==}\n     engines: {node: '>=12'}\n     cpu: [ia32]\n     os: [linux]\n \n+  '@esbuild/linux-ia32@0.23.1':\n+    resolution: {integrity: sha512-VTN4EuOHwXEkXzX5nTvVY4s7E/Krz7COC8xkftbbKRYAl96vPiUssGkeMELQMOnLOJ8k3BY1+ZY52tttZnHcXQ==}\n+    engines: {node: '>=18'}\n+    cpu: [ia32]\n+    os: [linux]\n+\n   '@esbuild/linux-loong64@0.18.20':\n     resolution: {integrity: sha512-nXW8nqBTrOpDLPgPY9uV+/1DjxoQ7DoB2N8eocyq8I9XuqJ7BiAMDMf9n1xZM9TgW0J8zrquIb/A7s3BJv7rjg==}\n     engines: {node: '>=12'}\n     cpu: [loong64]\n     os: [linux]\n \n+  '@esbuild/linux-loong64@0.23.1':\n+    resolution: {integrity: sha512-Vx09LzEoBa5zDnieH8LSMRToj7ir/Jeq0Gu6qJ/1GcBq9GkfoEAoXvLiW1U9J1qE/Y/Oyaq33w5p2ZWrNNHNEw==}\n+    engines: {node: '>=18'}\n+    cpu: [loong64]\n+    os: [linux]\n+\n   '@esbuild/linux-mips64el@0.18.20':\n     resolution: {integrity: sha512-d5NeaXZcHp8PzYy5VnXV3VSd2D328Zb+9dEq5HE6bw6+N86JVPExrA6O68OPwobntbNJ0pzCpUFZTo3w0GyetQ==}\n     engines: {node: '>=12'}\n     cpu: [mips64el]\n     os: [linux]\n \n+  '@esbuild/linux-mips64el@0.23.1':\n+    resolution: {integrity: sha512-nrFzzMQ7W4WRLNUOU5dlWAqa6yVeI0P78WKGUo7lg2HShq/yx+UYkeNSE0SSfSure0SqgnsxPvmAUu/vu0E+3Q==}\n+    engines: {node: '>=18'}\n+    cpu: [mips64el]\n+    os: [linux]\n+\n   '@esbuild/linux-ppc64@0.18.20':\n     resolution: {integrity: sha512-WHPyeScRNcmANnLQkq6AfyXRFr5D6N2sKgkFo2FqguP44Nw2eyDlbTdZwd9GYk98DZG9QItIiTlFLHJHjxP3FA==}\n     engines: {node: '>=12'}\n     cpu: [ppc64]\n     os: [linux]\n \n+  '@esbuild/linux-ppc64@0.23.1':\n+    resolution: {integrity: sha512-dKN8fgVqd0vUIjxuJI6P/9SSSe/mB9rvA98CSH2sJnlZ/OCZWO1DJvxj8jvKTfYUdGfcq2dDxoKaC6bHuTlgcw==}\n+    engines: {node: '>=18'}\n+    cpu: [ppc64]\n+    os: [linux]\n+\n   '@esbuild/linux-riscv64@0.18.20':\n     resolution: {integrity: sha512-WSxo6h5ecI5XH34KC7w5veNnKkju3zBRLEQNY7mv5mtBmrP/MjNBCAlsM2u5hDBlS3NGcTQpoBvRzqBcRtpq1A==}\n     engines: {node: '>=12'}\n     cpu: [riscv64]\n     os: [linux]\n \n+  '@esbuild/linux-riscv64@0.23.1':\n+    resolution: {integrity: sha512-5AV4Pzp80fhHL83JM6LoA6pTQVWgB1HovMBsLQ9OZWLDqVY8MVobBXNSmAJi//Csh6tcY7e7Lny2Hg1tElMjIA==}\n+    engines: {node: '>=18'}\n+    cpu: [riscv64]\n+    os: [linux]\n+\n   '@esbuild/linux-s390x@0.18.20':\n     resolution: {integrity: sha512-+8231GMs3mAEth6Ja1iK0a1sQ3ohfcpzpRLH8uuc5/KVDFneH6jtAJLFGafpzpMRO6DzJ6AvXKze9LfFMrIHVQ==}\n     engines: {node: '>=12'}\n     cpu: [s390x]\n     os: [linux]\n \n+  '@esbuild/linux-s390x@0.23.1':\n+    resolution: {integrity: sha512-9ygs73tuFCe6f6m/Tb+9LtYxWR4c9yg7zjt2cYkjDbDpV/xVn+68cQxMXCjUpYwEkze2RcU/rMnfIXNRFmSoDw==}\n+    engines: {node: '>=18'}\n+    cpu: [s390x]\n+    os: [linux]\n+\n   '@esbuild/linux-x64@0.18.20':\n     resolution: {integrity: sha512-UYqiqemphJcNsFEskc73jQ7B9jgwjWrSayxawS6UVFZGWrAAtkzjxSqnoclCXxWtfwLdzU+vTpcNYhpn43uP1w==}\n     engines: {node: '>=12'}\n     cpu: [x64]\n     os: [linux]\n \n+  '@esbuild/linux-x64@0.23.1':\n+    resolution: {integrity: sha512-EV6+ovTsEXCPAp58g2dD68LxoP/wK5pRvgy0J/HxPGB009omFPv3Yet0HiaqvrIrgPTBuC6wCH1LTOY91EO5hQ==}\n+    engines: {node: '>=18'}\n+    cpu: [x64]\n+    os: [linux]\n+\n   '@esbuild/netbsd-x64@0.18.20':\n     resolution: {integrity: sha512-iO1c++VP6xUBUmltHZoMtCUdPlnPGdBom6IrO4gyKPFFVBKioIImVooR5I83nTew5UOYrk3gIJhbZh8X44y06A==}\n     engines: {node: '>=12'}\n     cpu: [x64]\n     os: [netbsd]\n \n+  '@esbuild/netbsd-x64@0.23.1':\n+    resolution: {integrity: sha512-aevEkCNu7KlPRpYLjwmdcuNz6bDFiE7Z8XC4CPqExjTvrHugh28QzUXVOZtiYghciKUacNktqxdpymplil1beA==}\n+    engines: {node: '>=18'}\n+    cpu: [x64]\n+    os: [netbsd]\n+\n+  '@esbuild/openbsd-arm64@0.23.1':\n+    resolution: {integrity: sha512-3x37szhLexNA4bXhLrCC/LImN/YtWis6WXr1VESlfVtVeoFJBRINPJ3f0a/6LV8zpikqoUg4hyXw0sFBt5Cr+Q==}\n+    engines: {node: '>=18'}\n+    cpu: [arm64]\n+    os: [openbsd]\n+\n   '@esbuild/openbsd-x64@0.18.20':\n     resolution: {integrity: sha512-e5e4YSsuQfX4cxcygw/UCPIEP6wbIL+se3sxPdCiMbFLBWu0eiZOJ7WoD+ptCLrmjZBK1Wk7I6D/I3NglUGOxg==}\n     engines: {node: '>=12'}\n     cpu: [x64]\n     os: [openbsd]\n \n+  '@esbuild/openbsd-x64@0.23.1':\n+    resolution: {integrity: sha512-aY2gMmKmPhxfU+0EdnN+XNtGbjfQgwZj43k8G3fyrDM/UdZww6xrWxmDkuz2eCZchqVeABjV5BpildOrUbBTqA==}\n+    engines: {node: '>=18'}\n+    cpu: [x64]\n+    os: [openbsd]\n+\n   '@esbuild/sunos-x64@0.18.20':\n     resolution: {integrity: sha512-kDbFRFp0YpTQVVrqUd5FTYmWo45zGaXe0X8E1G/LKFC0v8x0vWrhOWSLITcCn63lmZIxfOMXtCfti/RxN/0wnQ==}\n     engines: {node: '>=12'}\n     cpu: [x64]\n     os: [sunos]\n \n+  '@esbuild/sunos-x64@0.23.1':\n+    resolution: {integrity: sha512-RBRT2gqEl0IKQABT4XTj78tpk9v7ehp+mazn2HbUeZl1YMdaGAQqhapjGTCe7uw7y0frDi4gS0uHzhvpFuI1sA==}\n+    engines: {node: '>=18'}\n+    cpu: [x64]\n+    os: [sunos]\n+\n   '@esbuild/win32-arm64@0.18.20':\n     resolution: {integrity: sha512-ddYFR6ItYgoaq4v4JmQQaAI5s7npztfV4Ag6NrhiaW0RrnOXqBkgwZLofVTlq1daVTQNhtI5oieTvkRPfZrePg==}\n     engines: {node: '>=12'}\n     cpu: [arm64]\n     os: [win32]\n \n+  '@esbuild/win32-arm64@0.23.1':\n+    resolution: {integrity: sha512-4O+gPR5rEBe2FpKOVyiJ7wNDPA8nGzDuJ6gN4okSA1gEOYZ67N8JPk58tkWtdtPeLz7lBnY6I5L3jdsr3S+A6A==}\n+    engines: {node: '>=18'}\n+    cpu: [arm64]\n+    os: [win32]\n+\n   '@esbuild/win32-ia32@0.18.20':\n     resolution: {integrity: sha512-Wv7QBi3ID/rROT08SABTS7eV4hX26sVduqDOTe1MvGMjNd3EjOz4b7zeexIR62GTIEKrfJXKL9LFxTYgkyeu7g==}\n     engines: {node: '>=12'}\n     cpu: [ia32]\n     os: [win32]\n \n+  '@esbuild/win32-ia32@0.23.1':\n+    resolution: {integrity: sha512-BcaL0Vn6QwCwre3Y717nVHZbAa4UBEigzFm6VdsVdT/MbZ38xoj1X9HPkZhbmaBGUD1W8vxAfffbDe8bA6AKnQ==}\n+    engines: {node: '>=18'}\n+    cpu: [ia32]\n+    os: [win32]\n+\n   '@esbuild/win32-x64@0.18.20':\n     resolution: {integrity: sha512-kTdfRcSiDfQca/y9QIkng02avJ+NCaQvrMejlsB3RRv5sE9rRoeBPISaZpKxHELzRxZyLvNts1P27W3wV+8geQ==}\n     engines: {node: '>=12'}\n     cpu: [x64]\n     os: [win32]\n \n+  '@esbuild/win32-x64@0.23.1':\n+    resolution: {integrity: sha512-BHpFFeslkWrXWyUPnbKm+xYYVYruCinGcftSBaa8zoF9hZO4BcSCFUvHVTtzpIY6YzUnYtuEhZ+C9iEXjxnasg==}\n+    engines: {node: '>=18'}\n+    cpu: [x64]\n+    os: [win32]\n+\n   '@eslint-community/eslint-utils@4.4.0':\n     resolution: {integrity: sha512-1/sA4dwrzBAyeUoQ6oxahHKmrZvsnLCg4RfxW3ZFGGmQkSNQPFNLV9CUEFQP1x9EYXHTo5p6xdhZM1Ne9p/AfA==}\n     engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}\n@@ -6615,6 +6762,11 @@ packages:\n     engines: {node: '>=12'}\n     hasBin: true\n \n+  esbuild@0.23.1:\n+    resolution: {integrity: sha512-VVNz/9Sa0bs5SELtn3f7qhJCDPCF5oMEl5cO9/SSinpE9hbPVvxbd572HH5AKiP7WD8INO53GgfDDhRjkylHEg==}\n+    engines: {node: '>=18'}\n+    hasBin: true\n+\n   escalade@3.1.1:\n     resolution: {integrity: sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==}\n     engines: {node: '>=6'}\n@@ -7497,6 +7649,9 @@ packages:\n   get-tsconfig@4.7.2:\n     resolution: {integrity: sha512-wuMsz4leaj5hbGgg4IvDU0bqJagpftG5l5cXIAvo8uZrqn0NJqwtfupTN00VnkQJPcIRrxYrm1Ue24btpCha2A==}\n \n+  get-tsconfig@4.8.1:\n+    resolution: {integrity: sha512-k9PN+cFBmaLWtVz29SkUoqU5O0slLuHJXt/2P+tMVFT+phsSGXGkp9t3rQIqdz0e+06EHNGs3oM6ZX1s2zHxRg==}\n+\n   get-uri@6.0.3:\n     resolution: {integrity: sha512-BzUrJBS9EcUb4cFol8r4W3v1cPsSyajLSthNkz5BxbpDcHN5tIrM10E2eNvfnvBn3DaT3DUgx0OpsBKkaOpanw==}\n     engines: {node: '>= 14'}\n@@ -12582,6 +12737,11 @@ packages:\n     peerDependencies:\n       typescript: '>=2.8.0 || >= 3.2.0-dev || >= 3.3.0-dev || >= 3.4.0-dev || >= 3.5.0-dev || >= 3.6.0-dev || >= 3.6.0-beta || >= 3.7.0-dev || >= 3.7.0-beta'\n \n+  tsx@4.19.1:\n+    resolution: {integrity: sha512-0flMz1lh74BR4wOvBjuh9olbnwqCPc35OOlfyzHba0Dc+QNUeWX/Gq2YTbnwcWPO3BMd8fkzRVrHcsR+a7z7rA==}\n+    engines: {node: '>=18.0.0'}\n+    hasBin: true\n+\n   tty-browserify@0.0.1:\n     resolution: {integrity: sha512-C3TaO7K81YvjCgQH9Q1S3R3P3BtN3RIM8n+OvX4il1K1zgE8ZhI0op7kClgkxtutIE8hQrcrHBXvIheqKUUCxw==}\n \n@@ -14156,7 +14316,7 @@ snapshots:\n       '@babel/traverse': 7.23.7\n       '@babel/types': 7.23.9\n       convert-source-map: 2.0.0\n-      debug: 4.3.4\n+      debug: 4.3.4(supports-color@8.1.1)\n       gensync: 1.0.0-beta.2\n       json5: 2.2.3\n       semver: 6.3.1\n@@ -16369,7 +16529,7 @@ snapshots:\n       '@babel/helper-split-export-declaration': 7.22.6\n       '@babel/parser': 7.23.6\n       '@babel/types': 7.23.9\n-      debug: 4.3.4\n+      debug: 4.3.4(supports-color@8.1.1)\n       globals: 11.12.0\n     transitivePeerDependencies:\n       - supports-color\n@@ -16474,72 +16634,144 @@ snapshots:\n       esquery: 1.5.0\n       jsdoc-type-pratt-parser: 4.0.0\n \n+  '@esbuild/aix-ppc64@0.23.1':\n+    optional: true\n+\n   '@esbuild/android-arm64@0.18.20':\n     optional: true\n \n+  '@esbuild/android-arm64@0.23.1':\n+    optional: true\n+\n   '@esbuild/android-arm@0.18.20':\n     optional: true\n \n+  '@esbuild/android-arm@0.23.1':\n+    optional: true\n+\n   '@esbuild/android-x64@0.18.20':\n     optional: true\n \n+  '@esbuild/android-x64@0.23.1':\n+    optional: true\n+\n   '@esbuild/darwin-arm64@0.18.20':\n     optional: true\n \n+  '@esbuild/darwin-arm64@0.23.1':\n+    optional: true\n+\n   '@esbuild/darwin-x64@0.18.20':\n     optional: true\n \n+  '@esbuild/darwin-x64@0.23.1':\n+    optional: true\n+\n   '@esbuild/freebsd-arm64@0.18.20':\n     optional: true\n \n+  '@esbuild/freebsd-arm64@0.23.1':\n+    optional: true\n+\n   '@esbuild/freebsd-x64@0.18.20':\n     optional: true\n \n+  '@esbuild/freebsd-x64@0.23.1':\n+    optional: true\n+\n   '@esbuild/linux-arm64@0.18.20':\n     optional: true\n \n+  '@esbuild/linux-arm64@0.23.1':\n+    optional: true\n+\n   '@esbuild/linux-arm@0.18.20':\n     optional: true\n \n+  '@esbuild/linux-arm@0.23.1':\n+    optional: true\n+\n   '@esbuild/linux-ia32@0.18.20':\n     optional: true\n \n+  '@esbuild/linux-ia32@0.23.1':\n+    optional: true\n+\n   '@esbuild/linux-loong64@0.18.20':\n     optional: true\n \n+  '@esbuild/linux-loong64@0.23.1':\n+    optional: true\n+\n   '@esbuild/linux-mips64el@0.18.20':\n     optional: true\n \n+  '@esbuild/linux-mips64el@0.23.1':\n+    optional: true\n+\n   '@esbuild/linux-ppc64@0.18.20':\n     optional: true\n \n+  '@esbuild/linux-ppc64@0.23.1':\n+    optional: true\n+\n   '@esbuild/linux-riscv64@0.18.20':\n     optional: true\n \n+  '@esbuild/linux-riscv64@0.23.1':\n+    optional: true\n+\n   '@esbuild/linux-s390x@0.18.20':\n     optional: true\n \n+  '@esbuild/linux-s390x@0.23.1':\n+    optional: true\n+\n   '@esbuild/linux-x64@0.18.20':\n     optional: true\n \n+  '@esbuild/linux-x64@0.23.1':\n+    optional: true\n+\n   '@esbuild/netbsd-x64@0.18.20':\n     optional: true\n \n+  '@esbuild/netbsd-x64@0.23.1':\n+    optional: true\n+\n+  '@esbuild/openbsd-arm64@0.23.1':\n+    optional: true\n+\n   '@esbuild/openbsd-x64@0.18.20':\n     optional: true\n \n+  '@esbuild/openbsd-x64@0.23.1':\n+    optional: true\n+\n   '@esbuild/sunos-x64@0.18.20':\n     optional: true\n \n+  '@esbuild/sunos-x64@0.23.1':\n+    optional: true\n+\n   '@esbuild/win32-arm64@0.18.20':\n     optional: true\n \n+  '@esbuild/win32-arm64@0.23.1':\n+    optional: true\n+\n   '@esbuild/win32-ia32@0.18.20':\n     optional: true\n \n+  '@esbuild/win32-ia32@0.23.1':\n+    optional: true\n+\n   '@esbuild/win32-x64@0.18.20':\n     optional: true\n \n+  '@esbuild/win32-x64@0.23.1':\n+    optional: true\n+\n   '@eslint-community/eslint-utils@4.4.0(eslint@8.57.0)':\n     dependencies:\n       eslint: 8.57.0\n@@ -18855,7 +19087,7 @@ snapshots:\n \n   agent-base@6.0.2:\n     dependencies:\n-      debug: 4.3.4\n+      debug: 4.3.4(supports-color@8.1.1)\n     transitivePeerDependencies:\n       - supports-color\n \n@@ -19187,7 +19419,7 @@ snapshots:\n     dependencies:\n       '@fastify/error': 3.4.1\n       archy: 1.0.0\n-      debug: 4.3.4\n+      debug: 4.3.4(supports-color@8.1.1)\n       fastq: 1.17.1\n     transitivePeerDependencies:\n       - supports-color\n@@ -20749,10 +20981,6 @@ snapshots:\n     optionalDependencies:\n       supports-color: 5.5.0\n \n-  debug@4.3.4:\n-    dependencies:\n-      ms: 2.1.2\n-\n   debug@4.3.4(supports-color@8.1.1):\n     dependencies:\n       ms: 2.1.2\n@@ -21438,6 +21666,33 @@ snapshots:\n       '@esbuild/win32-ia32': 0.18.20\n       '@esbuild/win32-x64': 0.18.20\n \n+  esbuild@0.23.1:\n+    optionalDependencies:\n+      '@esbuild/aix-ppc64': 0.23.1\n+      '@esbuild/android-arm': 0.23.1\n+      '@esbuild/android-arm64': 0.23.1\n+      '@esbuild/android-x64': 0.23.1\n+      '@esbuild/darwin-arm64': 0.23.1\n+      '@esbuild/darwin-x64': 0.23.1\n+      '@esbuild/freebsd-arm64': 0.23.1\n+      '@esbuild/freebsd-x64': 0.23.1\n+      '@esbuild/linux-arm': 0.23.1\n+      '@esbuild/linux-arm64': 0.23.1\n+      '@esbuild/linux-ia32': 0.23.1\n+      '@esbuild/linux-loong64': 0.23.1\n+      '@esbuild/linux-mips64el': 0.23.1\n+      '@esbuild/linux-ppc64': 0.23.1\n+      '@esbuild/linux-riscv64': 0.23.1\n+      '@esbuild/linux-s390x': 0.23.1\n+      '@esbuild/linux-x64': 0.23.1\n+      '@esbuild/netbsd-x64': 0.23.1\n+      '@esbuild/openbsd-arm64': 0.23.1\n+      '@esbuild/openbsd-x64': 0.23.1\n+      '@esbuild/sunos-x64': 0.23.1\n+      '@esbuild/win32-arm64': 0.23.1\n+      '@esbuild/win32-ia32': 0.23.1\n+      '@esbuild/win32-x64': 0.23.1\n+\n   escalade@3.1.1: {}\n \n   escalade@3.1.2: {}\n@@ -23029,6 +23284,10 @@ snapshots:\n     dependencies:\n       resolve-pkg-maps: 1.0.0\n \n+  get-tsconfig@4.8.1:\n+    dependencies:\n+      resolve-pkg-maps: 1.0.0\n+\n   get-uri@6.0.3:\n     dependencies:\n       basic-ftp: 5.0.5\n@@ -23626,7 +23885,7 @@ snapshots:\n   https-proxy-agent@5.0.1:\n     dependencies:\n       agent-base: 6.0.2\n-      debug: 4.3.4\n+      debug: 4.3.4(supports-color@8.1.1)\n     transitivePeerDependencies:\n       - supports-color\n \n@@ -24150,7 +24409,7 @@ snapshots:\n \n   istanbul-lib-source-maps@4.0.1:\n     dependencies:\n-      debug: 4.3.4\n+      debug: 4.3.4(supports-color@8.1.1)\n       istanbul-lib-coverage: 3.2.0\n       source-map: 0.6.1\n     transitivePeerDependencies:\n@@ -24696,7 +24955,7 @@ snapshots:\n \n   json-schema-resolver@2.0.0:\n     dependencies:\n-      debug: 4.3.4\n+      debug: 4.3.4(supports-color@8.1.1)\n       rfdc: 1.3.0\n       uri-js: 4.4.1\n     transitivePeerDependencies:\n@@ -28478,7 +28737,7 @@ snapshots:\n     dependencies:\n       '@hapi/hoek': 11.0.4\n       '@hapi/wreck': 18.1.0\n-      debug: 4.3.4\n+      debug: 4.3.4(supports-color@8.1.1)\n       joi: 17.12.2\n     transitivePeerDependencies:\n       - supports-color\n@@ -29060,7 +29319,7 @@ snapshots:\n     dependencies:\n       component-emitter: 1.3.0\n       cookiejar: 2.1.4\n-      debug: 4.3.4\n+      debug: 4.3.4(supports-color@8.1.1)\n       fast-safe-stringify: 2.1.1\n       form-data: 4.0.0\n       formidable: 2.1.2\n@@ -29456,6 +29715,13 @@ snapshots:\n       tslib: 1.14.1\n       typescript: 5.4.5\n \n+  tsx@4.19.1:\n+    dependencies:\n+      esbuild: 0.23.1\n+      get-tsconfig: 4.8.1\n+    optionalDependencies:\n+      fsevents: 2.3.3\n+\n   tty-browserify@0.0.1: {}\n \n   tunnel-agent@0.6.0:"
        }
    ],
    "stats": {
        "total": 3456,
        "additions": 3435,
        "deletions": 21
    }
}