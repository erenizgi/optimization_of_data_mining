{
    "author": "zairahira",
    "message": "chore(curriculum): add maps and sets lecture transcript (#58630)\n\nCo-authored-by: Dario-DC <105294544+Dario-DC@users.noreply.github.com>\r\nCo-authored-by: Farhan Hasin Chowdhury <shovik.is.here@gmail.com>",
    "sha": "05c1d17921c7c2ace46b4f22148c332f9de3969b",
    "files": [
        {
            "sha": "07a13b9dd1d4f97aa30c27704b538e04aa388c78",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-maps-and-sets/6733ab269b378bf724c9ac71.md",
            "status": "modified",
            "additions": 265,
            "deletions": 0,
            "changes": 265,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/05c1d17921c7c2ace46b4f22148c332f9de3969b/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-maps-and-sets%2F6733ab269b378bf724c9ac71.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/05c1d17921c7c2ace46b4f22148c332f9de3969b/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-maps-and-sets%2F6733ab269b378bf724c9ac71.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-maps-and-sets%2F6733ab269b378bf724c9ac71.md?ref=05c1d17921c7c2ace46b4f22148c332f9de3969b",
            "patch": "@@ -10,6 +10,271 @@ dashedName: what-are-sets-in-javascript-and-how-does-it-differ-from-weaksets\n \n Watch the video lecture and answer the questions below.\n \n+# --transcript--\n+\n+What are Sets in JavaScript, and how do they differ from WeakSets?\n+\n+In JavaScript, `Set` is a built-in object for managing data collections. It lets you store unique values of any type, whether primitive or object references. `Set` ensures that each value in it appears only once, making it useful for eliminating duplicates from an array or handling collections of distinct values.\n+\n+As for `WeakSet`, it’s a special type of `Set` with fewer features that allows you to store weakly held object references and symbols. Unlike `Set`, `WeakSet` does not support primitives like numbers or strings.\n+\n+Unlike a regular `Set`, a `WeakSet` only stores objects, and the references to those objects are \"weak\" meaning WeakSets do not prevent the stored objects from being garbage-collected if there are no other references to them. In simpler terms, if the object is not being used anywhere else in your code, it is removed automatically to free up memory.\n+\n+To create a `Set`, you use the `Set` constructor and assign it to a variable:\n+\n+```js\n+const myFirstSet = new Set();\n+```\n+\n+You can also initialize the `Set` with values:\n+\n+```js\n+const treeSet = new Set(['Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit']);\n+```\n+\n+If you log the `Set` to the console, this is what the output looks like:\n+\n+```js\n+/*\n+Set(4) {'Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit'}\n+  [[Entries]]\n+  0: \"Baobab\"\n+    value: \"Baobab\"\n+  1: \"Jackalberry\"\n+    value: \"Jackalberry\"\n+  2: \"Mopane Tree\"\n+    value: \"Mopane Tree\"\n+  3: \"Breadfruit\"\n+    value: \"Breadfruit\"\n+  size: 4\n+  [[Prototype]]: Set\n+*/\n+```\n+\n+If you didn't initialize the `Set` with values, you can use the `add()` method to add an item to the `Set`:\n+\n+```js\n+const treeSet = new Set();\n+\n+// Add items to the treeSet\n+treeSet.add('Baobab');\n+treeSet.add('Jackalberry');\n+treeSet.add('Mopane Tree');\n+treeSet.add('Breadfruit');\n+```\n+\n+The result and appearance of the result in the console remains the same.\n+\n+Don't forget that duplicate items will be ignored in the `Set`:\n+\n+```js\n+const treeSet = new Set();\n+\n+// Add items to the treeSet\n+treeSet.add('Baobab');\n+treeSet.add('Jackalberry');\n+treeSet.add('Mopane Tree');\n+treeSet.add('Breadfruit');\n+treeSet.add('Baobab'); //duplicate item will be ignored\n+\n+console.log(treeSet);\n+// Set(4) {'Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit'}\n+```\n+\n+The other methods you can use to manipulate a `Set` are:\n+\n+- `delete()`  \n+- `clear()`\n+- `has()`\n+- `entries()`\n+- `forEach()`\n+- `keys()`\n+- `values()`\n+\n+Let's look at how these methods work one by one. `delete()` removes a specified item from the `Set`:\n+\n+```js\n+const treeSet = new Set();\n+\n+// Add items to the treeSet\n+treeSet.add('Baobab');\n+treeSet.add('Jackalberry');\n+treeSet.add('Mopane Tree');\n+treeSet.add('Breadfruit');\n+\n+treeSet.delete('Breadfruit');\n+\n+console.log(treeSet); // Set(3) {'Baobab', 'Jackalberry', 'Mopane Tree'}\n+```\n+\n+`has()` checks if a specified value exists in the `Set`:\n+\n+```js\n+const treeSet = new Set();\n+\n+// Add items to the treeSet\n+treeSet.add('Baobab');\n+treeSet.add('Jackalberry');\n+treeSet.add('Mopane Tree');\n+treeSet.add('Breadfruit');\n+\n+treeSet.delete('Breadfruit');\n+\n+console.log(treeSet.has('Breadfruit')); // false\n+```\n+\n+`entries()` returns a `Set` iterator containing an array of the values in a `[value, value]` format:\n+\n+```js\n+const treeSet = new Set();\n+\n+// Add items to the treeSet\n+treeSet.add('Baobab');\n+treeSet.add('Jackalberry');\n+treeSet.add('Mopane Tree');\n+treeSet.add('Breadfruit');\n+\n+treeSet.delete('Breadfruit');\n+\n+console.log(treeSet.entries());\n+// SetIterator {'Baobab' => 'Baobab', 'Jackalberry' => 'Jackalberry', 'Mopane Tree' => 'Mopane Tree'}\n+```\n+\n+`keys()` and `values()` show the values in the `Set`. `keys()` is just an alias for the `values()` method:\n+\n+```js\n+const treeSet = new Set();\n+\n+// Add items to the treeSet\n+treeSet.add('Baobab');\n+treeSet.add('Jackalberry');\n+treeSet.add('Mopane Tree');\n+treeSet.add('Breadfruit');\n+\n+treeSet.delete('Breadfruit');\n+\n+console.log('Keys: ', treeSet.keys());\n+console.log('Values: ', treeSet.values());\n+// Keys: SetIterator {'Baobab', 'Jackalberry', 'Mopane Tree'}\n+// Values: SetIterator {'Baobab', 'Jackalberry', 'Mopane Tree'}\n+```\n+\n+`forEach()` lets you iterate through the `Set`:\n+\n+```js\n+const treeSet = new Set();\n+\n+// Add items to the treeSet\n+treeSet.add('Baobab');\n+treeSet.add('Jackalberry');\n+treeSet.add('Mopane Tree');\n+treeSet.add('Breadfruit');\n+\n+treeSet.delete('Breadfruit');\n+\n+treeSet.forEach((tree) => console.log(tree));\n+/*\n+Baobab\n+Jackalberry\n+Mopane Tree\n+*/\n+```\n+\n+`clear()` removes all the items of the array:\n+\n+```js\n+const treeSet = new Set();\n+\n+// Add items to the treeSet\n+treeSet.add('Baobab');\n+treeSet.add('Jackalberry');\n+treeSet.add('Mopane Tree');\n+treeSet.add('Breadfruit');\n+\n+treeSet.delete('Breadfruit');\n+\n+treeSet.clear();\n+\n+console.log(treeSet); // Set(0) {size: 0}\n+```\n+\n+It is also worth mentioning that there's a `size` property that returns the number of items in the `Set`:\n+\n+```js\n+const treeSet = new Set();\n+\n+// Add items to the treeSet\n+treeSet.add('Baobab');\n+treeSet.add('Jackalberry');\n+treeSet.add('Mopane Tree');\n+treeSet.add('Breadfruit');\n+\n+treeSet.delete('Breadfruit');\n+\n+console.log(treeSet.size); // 3\n+```\n+\n+Just like `Set`, there's also a `WeakSet` constructor you can use to create a `WeakSet`:\n+\n+```javascript\n+const treeWeakSet = new WeakSet();\n+```\n+\n+`WeakSet` also has the `add()`, `delete()`, and the `has()` methods:\n+\n+```javascript\n+const treeWeakSet = new WeakSet();\n+\n+treeWeakSet.add({ name: 'Baobab' });\n+treeWeakSet.add({ name: 'Jackalberry' });\n+treeWeakSet.add({ name: 'Mopane Tree' });\n+treeWeakSet.add({ name: 'Breadfruit' });\n+\n+treeWeakSet.delete('Jackalberry');\n+console.log(treeWeakSet.has('Jackalberry')); // false\n+\n+console.log(treeWeakSet);\n+```\n+\n+In the output, the contents of the `WeakSet` appear like this:\n+\n+```javascript\n+/*\n+WeakSet {{…}, {…}, {…}, {…}}\n+  [[Entries]]\n+    No properties\n+  [[Prototype]]: WeakSet\n+    .\n+    .\n+    .\n+*/\n+```\n+\n+The contents appear empty because WeakSets are not iterable and do not expose their contents directly.\n+\n+Don't forget that only symbols and objects with well-defined keys and values are supported. Adding a primitive, such as numbers or strings, will result in an error:\n+\n+```js\n+treeWeakSet.add('Alan Smith');\n+\n+console.log(treeWeakSet); // Invalid value used in weak set\n+//    at WeakSet.add (<anonymous>)\n+```\n+\n+The key difference between a `Set` and a `WeakSet` is that a `Set` stores any value, while a `WeakSet` can only store objects.\n+\n+Here are some other noticeable differences between a `Set` and a `WeakSet`:\n+\n+| Feature | Set | WeakSet |\n+| --- | --- | --- |\n+| Type of Values Stored | Stores any data type | Stores only objects |\n+| Referencing | Strong referencing | Weak referencing |\n+| Iteration | Supports iteration with `forEach` and loops | Does not support iteration |\n+| Methods and Properties | `add()`, `delete()`, `has()`, `keys()`, `values()`, `size`, and more | `add()`, `delete()`, and `has()` only |\n+| Use case | General-purpose collection of unique values and removing duplicates from arrays | Efficient memory tracking of object references |\n+\n+You can see the differences in the types of values that the two kinds of sets can store, their support for iterating over the stored objects and their ideal use cases. Please take a moment to read the content of this table.\n+\n # --questions--\n \n ## --text--"
        },
        {
            "sha": "f2fdd3c2a39b0ad7c12cc8099123c97b7e037658",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-maps-and-sets/6733dd694f91d61a5272b4ac.md",
            "status": "modified",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/05c1d17921c7c2ace46b4f22148c332f9de3969b/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-maps-and-sets%2F6733dd694f91d61a5272b4ac.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/05c1d17921c7c2ace46b4f22148c332f9de3969b/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-maps-and-sets%2F6733dd694f91d61a5272b4ac.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-maps-and-sets%2F6733dd694f91d61a5272b4ac.md?ref=05c1d17921c7c2ace46b4f22148c332f9de3969b",
            "patch": "@@ -10,6 +10,126 @@ dashedName: what-is-the-map-object-and-how-does-it-differ-from-weakmaps\n \n Watch the lecture video and answer the questions below.\n \n+# --transcript--\n+\n+What is the Map object, and how does it differ from WeakMaps?\n+\n+In JavaScript, a `Map` is a built-in object that stores key-value pairs, similar to an object. However, it differs from standard JavaScript objects by allowing keys of any type, including objects and functions.\n+\n+A `WeakMap` is a collection of key-value pairs, similar to a `Map`, but it uses weak references for its keys. The keys must be objects, while the values can be of any type.\n+\n+Think of the relationship between a `WeakMap` and a `Map` as similar to the relationship between a `WeakSet` and a `Set`, as you learned in the previous lecture.\n+\n+To create a `Map`, you use the `Map()` constructor prepended with the `new` keyword:\n+\n+```js\n+const myFirstMap = new Map();\n+```\n+\n+You can initialize the Map with values:\n+\n+```js\n+const myTreesMap = new Map([\n+ [{ type: 'deciduous' }, 'Maple tree'],\n+ [['forest', 'grove'], 'Pine tree'],\n+ [42, 'Oak tree'],\n+ [true, 'Birch tree'],\n+ [function() { return 'I am a function key'; }, 'Willow tree'],\n+]);\n+```\n+\n+If you didn't initialize the `Map` with values, you can use the `set()` method to add them:\n+\n+```js\n+const myTreesMap = new Map();\n+myTreesMap.set({ type: 'deciduous' }, 'Maple tree');\n+myTreesMap.set([1, 2], 'Pine tree');\n+myTreesMap.set(42, 'Oak tree');\n+myTreesMap.set(true, 'Birch tree');\n+myTreesMap.set(function() { return \"I'm a function key\"; }, 'Willow tree');\n+\n+console.log(myTreesMap);\n+```\n+\n+Here's what a `Map` looks like in the console:\n+\n+```js\n+/*\n+Map(5) {{…} => 'Maple tree', Array(2) => 'Pine tree', 42 => 'Oak tree', true => 'Birch tree', ƒ => 'Willow tree'}\n+  [[Entries]]\n+    0:{Object => \"Maple tree\"}\n+      key: {type: 'deciduous'}\n+      value: \"Maple tree\"\n+    1:{Array(2) => \"Pine tree\"}\n+      key: (2)\n+      value: \"Pine tree\"\n+    2:{42 => \"Oak tree\"}\n+      key: 42\n+      value: \"Oak tree\"\n+    3:{true => \"Birch tree\"}\n+      key: true\n+      value: \"Birch tree\"\n+    4:{ƒunction () { return \"I'm a function key\"; } => \"Willow tree\"}\n+      key: f ()\n+      value: \"Willow tree\"\n+    size: 5\n+    [[Prototype]]: Map\n+*/\n+```\n+\n+Other methods you can use to work with a `Map` are:\n+\n+- `get(key)` to retrieve the value associated with the specified `key`.\n+- `has(key)` to check if a `key` exists in the `Map`.\n+- `delete(key)` to remove a key-value pair from the `Map`.\n+- `clear()` to remove all key-value pairs.\n+- `entries()` to check the entries of the `Map` (it returns the entries in a `MapIterator`).\n+- `forEach()` to loop through the entries of the `Map`.\n+- `size` to indicate the number of key-value pairs in the `Map`.\n+    \n+\n+There's a `WeakMap()` constructor you can use to create a `WeakMap`:\n+\n+```js\n+const myFirstWeakMap = new WeakMap();\n+```\n+\n+The `set()`, `get()`, `has()`, and `delete()` methods are all available for use with a `WeakMap` as well. For example here's how you can assign items to the `Map` with the `set()` method:\n+\n+```js\n+const myTreeWeakMap = new WeakMap();\n+\n+myTreeWeakMap.set({ id: 1 }, 'Maple tree');\n+myTreeWeakMap.set({ id: 2 }, 'Pine tree');\n+myTreeWeakMap.set({ id: 3 }, 'Oak tree');\n+myTreeWeakMap.set({ id: 4 }, 'Birch tree');\n+myTreeWeakMap.set({ id: 5 }, 'Willow tree');\n+\n+console.log(myTreeWeakMap);\n+```\n+\n+Here's what a `WeakMap` looks like in the console:\n+\n+```js\n+/*\n+WeakMap {{…} => 'Willow tree', {…} => 'Maple tree', {…} => 'Pine tree', {…} => 'Oak tree'}\n+  [[Entries]]\n+    No properties\n+  [[Prototype]]: WeakMap\n+*/\n+```\n+\n+Here are the differences between a `Map` and a `WeakMap`:\n+\n+| **Feature** | **Map** | **WeakMap** |\n+| --- | --- | --- |\n+| **Key Type** | Keys can be of any data type, including strings, numbers, objects, or even functions. | Keys must be objects. |\n+| **Use Case** | Use a `Map` when you need to associate data with any type of key. | Use a `WeakMap` when you only need to associate data with objects. |\n+| **Iteration** | You can loop through a `Map` using `forEach()` `keys()`, `values()`, or `entries()`. | A `WeakMap` is not iterable. |\n+| **Size Property** | `Map` has a `size` property to get the number of key-value pairs. | `WeakMap` does not have a `size` property. |\n+\n+In the table above, you can see the differences summarized including the key type, use case, iteration and size property. Please take a moment to read the content of this table to learn more about their differences.\n+\n # --questions--\n \n ## --text--"
        }
    ],
    "stats": {
        "total": 385,
        "additions": 385,
        "deletions": 0
    }
}