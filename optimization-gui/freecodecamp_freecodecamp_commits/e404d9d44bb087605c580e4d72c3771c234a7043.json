{
    "author": "ojeytonwilliams",
    "message": "chore: stop building entire curriculum when testing subset (#59599)",
    "sha": "e404d9d44bb087605c580e4d72c3771c234a7043",
    "files": [
        {
            "sha": "2cccc4585ca747406bc5eacbf9debab3c82f4e05",
            "filename": "curriculum/get-challenges.js",
            "status": "modified",
            "additions": 92,
            "deletions": 4,
            "changes": 96,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/e404d9d44bb087605c580e4d72c3771c234a7043/curriculum%2Fget-challenges.js",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/e404d9d44bb087605c580e4d72c3771c234a7043/curriculum%2Fget-challenges.js",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fget-challenges.js?ref=e404d9d44bb087605c580e4d72c3771c234a7043",
            "patch": "@@ -4,6 +4,7 @@ const util = require('util');\n const yaml = require('js-yaml');\n const { findIndex } = require('lodash');\n const readDirP = require('readdirp');\n+const stringSimilarity = require('string-similarity');\n \n const { curriculum: curriculumLangs } =\n   require('../shared/config/i18n').availableLangs;\n@@ -176,7 +177,10 @@ const walk = (root, target, options, cb) => {\n   });\n };\n \n-exports.getChallengesForLang = async function getChallengesForLang(lang) {\n+exports.getChallengesForLang = async function getChallengesForLang(\n+  lang,\n+  filters\n+) {\n   const invalidLang = !curriculumLangs.includes(lang);\n   if (invalidLang)\n     throw Error(`${lang} is not a accepted language.\n@@ -192,11 +196,86 @@ Accepted languages are ${curriculumLangs.join(', ')}`);\n     { type: 'directories', depth: 0 },\n     buildSuperBlocks\n   );\n-  const cb = (file, curriculum) => buildChallenges(file, curriculum, lang);\n+\n+  const superBlocks = Object.keys(curriculum);\n+  const blocksWithParent = Object.entries(curriculum).flatMap(\n+    ([key, superBlock]) => {\n+      const blocks = Object.entries(superBlock.blocks);\n+      return blocks.map(([block, blockData]) => ({\n+        block,\n+        blockData,\n+        superBlock: key\n+      }));\n+    }\n+  );\n+\n+  const blocks = blocksWithParent.map(({ block }) => block);\n+\n+  let filteredCurriculum = curriculum;\n+  const updatedFilters = { ...filters };\n+  if (filters?.superBlock) {\n+    const target = stringSimilarity.findBestMatch(\n+      filters.superBlock,\n+      superBlocks\n+    ).bestMatch.target;\n+\n+    console.log('superBlock being tested:', target);\n+\n+    filteredCurriculum = {\n+      [target]: curriculum[target]\n+    };\n+    updatedFilters.superBlock = target;\n+  } else if (filters?.block) {\n+    const target = stringSimilarity.findBestMatch(filters.block, blocks)\n+      .bestMatch.target;\n+\n+    console.log('block being tested:', target);\n+    const targetBlock = blocksWithParent.find(({ block }) => block === target);\n+\n+    filteredCurriculum = {\n+      [targetBlock.superBlock]: {\n+        blocks: {\n+          [targetBlock.block]: targetBlock.blockData\n+        }\n+      }\n+    };\n+    updatedFilters.block = targetBlock.block;\n+  } else if (filters?.challengeId) {\n+    const blocksWithMeta = blocksWithParent.filter(\n+      ({ blockData }) => blockData.meta\n+    );\n+    const container = blocksWithMeta.filter(({ block, blockData }) => {\n+      return blockData.meta.challengeOrder.some(\n+        ({ id }) => id === filters.challengeId\n+      );\n+    });\n+\n+    if (container.length === 0) {\n+      throw new Error(`No block found with challengeId ${filters.challengeId}`);\n+    }\n+    if (container.length > 1) {\n+      throw new Error(\n+        `Multiple blocks found with challengeId ${filters.challengeId}`\n+      );\n+    }\n+    const targetBlock = container[0];\n+    filteredCurriculum = {\n+      [targetBlock.superBlock]: {\n+        blocks: {\n+          [targetBlock.block]: targetBlock.blockData\n+        }\n+      }\n+    };\n+    updatedFilters.block = targetBlock.block;\n+    updatedFilters.superBlock = targetBlock.superBlock;\n+  }\n+\n+  const cb = (file, curriculum) =>\n+    buildChallenges(file, curriculum, lang, updatedFilters);\n   // fill the scaffold with the challenges\n   return walk(\n     root,\n-    curriculum,\n+    filteredCurriculum,\n     { type: 'files', fileFilter: ['*.md', '*.yml'] },\n     cb\n   );\n@@ -250,11 +329,17 @@ async function buildSuperBlocks({ path, fullPath }, curriculum) {\n   return walk(fullPath, curriculum, { depth: 1, type: 'directories' }, cb);\n }\n \n-async function buildChallenges({ path: filePath }, curriculum, lang) {\n+async function buildChallenges({ path: filePath }, curriculum, lang, filters) {\n   // path is relative to getChallengesDirForLang(lang)\n   const block = getBlockNameFromPath(filePath);\n+  if (filters?.block && block !== filters.block) {\n+    return;\n+  }\n   const superBlockDir = getBaseDir(filePath);\n   const superBlock = getSuperBlockFromDir(superBlockDir);\n+  if (filters?.superBlock && superBlock !== filters.superBlock) {\n+    return;\n+  }\n   let challengeBlock;\n \n   // TODO: this try block and process exit can all go once errors terminate the\n@@ -286,6 +371,9 @@ async function buildChallenges({ path: filePath }, curriculum, lang) {\n     ? await parseCert(englishPath)\n     : await createChallenge(filePath, meta);\n \n+  // this builds the entire block, even if we only want one challenge, which is\n+  // inefficient, but finding the next challenge without building the whole\n+  // block is fiddly.\n   challengeBlock.challenges = [...challengeBlock.challenges, challenge];\n }\n "
        },
        {
            "sha": "36e9e8532121ed0c6b8ba7aeae96685674b60bd7",
            "filename": "curriculum/test/test-challenges.js",
            "status": "modified",
            "additions": 37,
            "deletions": 64,
            "changes": 101,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/e404d9d44bb087605c580e4d72c3771c234a7043/curriculum%2Ftest%2Ftest-challenges.js",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/e404d9d44bb087605c580e4d72c3771c234a7043/curriculum%2Ftest%2Ftest-challenges.js",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Ftest%2Ftest-challenges.js?ref=e404d9d44bb087605c580e4d72c3771c234a7043",
            "patch": "@@ -60,6 +60,28 @@ const { sortChallenges } = require('./utils/sort-challenges');\n \n const { flatten, isEmpty, cloneDeep } = lodash;\n \n+if (\n+  [\n+    process.env.FCC_BLOCK,\n+    process.env.FCC_CHALLENGE_ID,\n+    process.env.FCC_SUPERBLOCK\n+  ].filter(Boolean).length > 1\n+) {\n+  throw new Error(\n+    `Please use at most single input from: block, challenge id, superblock.`\n+  );\n+}\n+\n+const testFilter = {\n+  block: process.env.FCC_BLOCK ? process.env.FCC_BLOCK.trim() : undefined,\n+  challengeId: process.env.FCC_CHALLENGE_ID\n+    ? process.env.FCC_CHALLENGE_ID.trim()\n+    : undefined,\n+  superBlock: process.env.FCC_SUPERBLOCK\n+    ? process.env.FCC_SUPERBLOCK.trim()\n+    : undefined\n+};\n+\n // rethrow unhandled rejections to make sure the tests exit with non-zero code\n process.on('unhandledRejection', err => handleRejection(err));\n // If an uncaught exception gets here, then mocha is in an unexpected state. All\n@@ -122,18 +144,6 @@ setup()\n   .catch(err => handleRejection(err));\n \n async function setup() {\n-  if (\n-    [\n-      process.env.FCC_BLOCK,\n-      process.env.FCC_CHALLENGE_ID,\n-      process.env.FCC_SUPERBLOCK\n-    ].filter(Boolean).length > 1\n-  ) {\n-    throw new Error(\n-      `Please use at most single input from: block, challenge id, superblock.`\n-    );\n-  }\n-\n   // liveServer starts synchronously\n   liveServer.start({\n     host: '127.0.0.1',\n@@ -165,59 +175,21 @@ async function setup() {\n \n   const lang = testedLang();\n \n-  let challenges = await getChallenges(lang);\n+  let challenges = await getChallenges(lang, testFilter);\n \n   // the next few statements create a list of all blocks and superblocks\n   // as they appear in the list of challenges\n-  const blocks = challenges.map(({ block }) => block);\n   const superBlocks = challenges.map(({ superBlock }) => superBlock);\n-  const targetBlockStrings = [...new Set(blocks.filter(el => Boolean(el)))];\n   const targetSuperBlockStrings = [\n     ...new Set(superBlocks.filter(el => Boolean(el)))\n   ];\n \n-  // the next few statements will filter challenges based on command variables\n-  if (process.env.FCC_SUPERBLOCK) {\n-    const filter = stringSimilarity.findBestMatch(\n-      process.env.FCC_SUPERBLOCK,\n-      targetSuperBlockStrings\n-    ).bestMatch.target;\n-\n-    console.log(`\\nsuperBlock being tested: ${filter}`);\n-    challenges = challenges.filter(\n-      challenge => challenge.superBlock === filter\n-    );\n-\n-    if (!challenges.length) {\n-      throw new Error(`No challenges found with superBlock \"${filter}\"`);\n-    }\n-  }\n-\n-  if (process.env.FCC_BLOCK) {\n-    const filter = stringSimilarity.findBestMatch(\n-      process.env.FCC_BLOCK,\n-      targetBlockStrings\n-    ).bestMatch.target;\n-\n-    console.log(`\\nblock being tested: ${filter}`);\n-    challenges = challenges.filter(challenge => challenge.block === filter);\n-\n-    if (!challenges.length) {\n-      throw new Error(`No challenges found with block \"${filter}\"`);\n-    }\n-  }\n-\n-  if (process.env.FCC_CHALLENGE_ID) {\n-    console.log(\n-      `\\nChallenge Id being tested: ${process.env.FCC_CHALLENGE_ID.trim()}`\n-    );\n+  if (testFilter.challengeId) {\n     const challengeIndex = challenges.findIndex(\n-      challenge => challenge.id === process.env.FCC_CHALLENGE_ID.trim()\n+      challenge => challenge.id === testFilter.challengeId\n     );\n     if (challengeIndex === -1) {\n-      throw new Error(\n-        `No challenge found with id \"${process.env.FCC_CHALLENGE_ID}\"`\n-      );\n+      throw new Error(`No challenge found with id \"${testFilter.challengeId}\"`);\n     }\n     const { solutions = [] } = challenges[challengeIndex];\n     if (isEmpty(solutions)) {\n@@ -269,16 +241,17 @@ function runTests(challengeData) {\n   run();\n }\n \n-async function getChallenges(lang) {\n-  const challenges = await getChallengesForLang(lang).then(curriculum =>\n-    Object.keys(curriculum)\n-      .map(key => curriculum[key].blocks)\n-      .reduce((challengeArray, superBlock) => {\n-        const challengesForBlock = Object.keys(superBlock).map(\n-          key => superBlock[key].challenges\n-        );\n-        return [...challengeArray, ...flatten(challengesForBlock)];\n-      }, [])\n+async function getChallenges(lang, filters) {\n+  const challenges = await getChallengesForLang(lang, filters).then(\n+    curriculum =>\n+      Object.keys(curriculum)\n+        .map(key => curriculum[key].blocks)\n+        .reduce((challengeArray, superBlock) => {\n+          const challengesForBlock = Object.keys(superBlock).map(\n+            key => superBlock[key].challenges\n+          );\n+          return [...challengeArray, ...flatten(challengesForBlock)];\n+        }, [])\n   );\n   // This matches the order Gatsby uses (via a GraphQL query). Ideally both\n   // should be sourced and sorted using a single query, but we're not there yet."
        }
    ],
    "stats": {
        "total": 197,
        "additions": 129,
        "deletions": 68
    }
}