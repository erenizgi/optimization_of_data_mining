{
    "author": "huyenltnguyen",
    "message": "feat(client): add pinyin-to-hanzi input to fill in the blank challenge (#63986)",
    "sha": "5d6eacb6156eb1a8e3904d683fcf957b4e48719f",
    "files": [
        {
            "sha": "3051be48c2bfd46d07730c16defef9e907e55aa0",
            "filename": "client/i18n/locales/english/translations.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fi18n%2Flocales%2Fenglish%2Ftranslations.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fi18n%2Flocales%2Fenglish%2Ftranslations.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fi18n%2Flocales%2Fenglish%2Ftranslations.json?ref=5d6eacb6156eb1a8e3904d683fcf957b4e48719f",
            "patch": "@@ -963,7 +963,8 @@\n     \"editor-a11y-on-non-macos\": \"{{editorName}} editor content. Accessibility mode set to 'on'. Press Ctrl+E to disable or press Alt+F1 for more options.\",\n     \"terminal-output\": \"Terminal output\",\n     \"not-available\": \"Not available\",\n-    \"interactive-editor-desc\": \"Turn static code examples into interactive editors. This allows you to edit and run the code directly on the page.\"\n+    \"interactive-editor-desc\": \"Turn static code examples into interactive editors. This allows you to edit and run the code directly on the page.\",\n+    \"pinyin-to-hanzi-input-desc\": \"This task uses Pinyin-to-Hanzi inputs. Type pinyin with tone numbers (1 to 5). When you enter a correct syllable, it will turn into a Chinese character. If you press backspace after a Chinese character, it will change back to pinyin and remove the last thing you typed: if it's a tone number, the tone is removed; if it's a letter, the letter is removed.\"\n   },\n   \"flash\": {\n     \"no-email-in-userinfo\": \"We could not retrieve an email from your chosen provider. Please try another provider or use the 'Continue with Email' option.\","
        },
        {
            "sha": "e21795978e9c9297c233e5d9955db032d1d9935e",
            "filename": "client/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fpackage.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fpackage.json?ref=5d6eacb6156eb1a8e3904d683fcf957b4e48719f",
            "patch": "@@ -94,6 +94,7 @@\n     \"nanoid\": \"3.3.7\",\n     \"normalize-url\": \"6.1.0\",\n     \"path-browserify\": \"1.0.1\",\n+    \"pinyin-tone\": \"2.4.0\",\n     \"postcss\": \"8.4.35\",\n     \"prismjs\": \"1.29.0\",\n     \"process\": \"0.11.10\",\n@@ -143,6 +144,7 @@\n     \"@testing-library/jest-dom\": \"^6.8.0\",\n     \"@testing-library/react\": \"12.1.5\",\n     \"@testing-library/react-hooks\": \"^8.0.1\",\n+    \"@testing-library/user-event\": \"14.6.1\",\n     \"@total-typescript/ts-reset\": \"^0.5.0\",\n     \"@types/canvas-confetti\": \"^1.6.0\",\n     \"@types/gatsbyjs__reach-router\": \"1.3.0\","
        },
        {
            "sha": "f268145071935894857f24660dfb38c21974e86b",
            "filename": "client/src/redux/prop-types.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fsrc%2Fredux%2Fprop-types.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fsrc%2Fredux%2Fprop-types.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Fredux%2Fprop-types.ts?ref=5d6eacb6156eb1a8e3904d683fcf957b4e48719f",
            "patch": "@@ -1,5 +1,8 @@\n import { HandlerProps } from 'react-reflex';\n-import { SuperBlocks } from '../../../shared-dist/config/curriculum';\n+import {\n+  ChallengeLang,\n+  SuperBlocks\n+} from '../../../shared-dist/config/curriculum';\n import type { Chapter } from '../../../shared-dist/config/chapters';\n import { BlockLayouts, BlockLabel } from '../../../shared-dist/config/blocks';\n import type { ChallengeFile, Ext } from '../../../shared-dist/utils/polyvinyl';\n@@ -222,6 +225,7 @@ export type ChallengeNode = {\n     helpCategory: string;\n     hooks?: Hooks;\n     id: string;\n+    lang?: ChallengeLang;\n     instructions: string;\n     internal?: {\n       content: string;"
        },
        {
            "sha": "23295877cf3f73e3c193c07a0a2c3df4d304e236",
            "filename": "client/src/templates/Challenges/components/fill-in-the-blanks.tsx",
            "status": "modified",
            "additions": 102,
            "deletions": 61,
            "changes": 163,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Ffill-in-the-blanks.tsx",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Ffill-in-the-blanks.tsx",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Ffill-in-the-blanks.tsx?ref=5d6eacb6156eb1a8e3904d683fcf957b4e48719f",
            "patch": "@@ -6,6 +6,7 @@ import { parseBlanks, parseAnswer } from '../fill-in-the-blank/parse-blanks';\n import PrismFormatted from '../components/prism-formatted';\n import { FillInTheBlank } from '../../../redux/prop-types';\n import ChallengeHeading from './challenge-heading';\n+import PinyinToHanziInput from './pinyin-to-hanzi-input';\n \n type FillInTheBlankProps = {\n   fillInTheBlank: FillInTheBlank;\n@@ -33,8 +34,63 @@ const AnswerText = ({ answer }: { answer: string }) => {\n   );\n };\n \n+type BlankInputProps = {\n+  blankIndex: number;\n+  answer: string;\n+  isCorrect: boolean | null;\n+  className: string;\n+  onChange: (index: number, value: string) => void;\n+  ariaLabel: string;\n+  inputType?: 'pinyin-to-hanzi' | 'pinyin-tone';\n+};\n+\n+const BlankInput = ({\n+  blankIndex,\n+  answer,\n+  isCorrect,\n+  className,\n+  onChange,\n+  ariaLabel,\n+  inputType\n+}: BlankInputProps) => {\n+  const parsedAnswer = parseAnswer(answer);\n+  const answerLength =\n+    typeof parsedAnswer === 'string'\n+      ? parsedAnswer.length\n+      : parsedAnswer.pinyin.length;\n+\n+  if (inputType === 'pinyin-to-hanzi' && typeof parsedAnswer === 'object') {\n+    return (\n+      <PinyinToHanziInput\n+        index={blankIndex}\n+        expectedAnswer={parsedAnswer}\n+        isCorrect={isCorrect}\n+        onChange={onChange}\n+        className={className}\n+        maxLength={answerLength + 3}\n+        size={answerLength}\n+        ariaLabel={ariaLabel}\n+      />\n+    );\n+  }\n+\n+  // Default text input\n+  return (\n+    <input\n+      type='text'\n+      maxLength={answerLength + 3}\n+      className={className}\n+      onChange={e => onChange(blankIndex, e.target.value)}\n+      size={answerLength}\n+      autoComplete='off'\n+      aria-label={ariaLabel}\n+      {...(isCorrect === false ? { 'aria-invalid': 'true' } : {})}\n+    />\n+  );\n+};\n+\n function FillInTheBlanks({\n-  fillInTheBlank: { sentence, blanks },\n+  fillInTheBlank: { sentence, blanks, inputType },\n   answersCorrect,\n   showFeedback,\n   feedback,\n@@ -53,76 +109,61 @@ function FillInTheBlanks({\n     return cls;\n   };\n \n-  const getAnswerLength = (answer: string): number => {\n-    const parsedAnswer = parseAnswer(answer);\n-\n-    if (typeof parsedAnswer === 'string') {\n-      return parsedAnswer.length;\n-    }\n-\n-    // TODO: This is a simplification. Revisit later to account for tones and spaces.\n-    return parsedAnswer.pinyin.length;\n-  };\n-\n   const paragraphs = parseBlanks(sentence);\n   const blankAnswers = blanks.map(b => b.answer);\n \n+  const ariaInputDescription =\n+    inputType === 'pinyin-to-hanzi' ? t('aria.pinyin-to-hanzi-input-desc') : '';\n+\n   return (\n     <>\n       <ChallengeHeading heading={t('learn.fill-in-the-blank.heading')} />\n       <Spacer size='xs' />\n+      <p className='sr-only'>{t(ariaInputDescription)}</p>\n       <div className='fill-in-the-blank-wrap'>\n-        {paragraphs.map((p, i) => {\n-          return (\n-            // both keys, i and j, are stable between renders, since\n-            // the paragraphs are static.\n-            <p key={i}>\n-              {p.map((node, j) => {\n-                const { type, value } = node;\n-                if (type === 'text') {\n-                  return value;\n-                }\n-\n-                if (type === 'hanzi-pinyin') {\n-                  const { hanzi, pinyin } = value;\n-                  return (\n-                    <ruby key={j}>\n-                      {hanzi}\n-                      <rp>(</rp>\n-                      <rt>{pinyin}</rt>\n-                      <rp>)</rp>\n-                    </ruby>\n-                  );\n-                }\n-\n-                // If a blank is answered correctly, render the answer as part of the sentence.\n-                if (type === 'blank' && answersCorrect[value] === true) {\n-                  return <AnswerText key={j} answer={blankAnswers[value]} />;\n-                }\n-\n-                const answerLength = getAnswerLength(blankAnswers[value]);\n-\n+        {paragraphs.map((p, i) => (\n+          // both keys, i and j, are stable between renders, since\n+          // the paragraphs are static.\n+          <p key={i}>\n+            {p.map((node, j) => {\n+              const { type, value } = node;\n+\n+              if (type === 'text') {\n+                return value;\n+              }\n+\n+              if (type === 'hanzi-pinyin') {\n+                const { hanzi, pinyin } = value;\n                 return (\n-                  <input\n-                    key={j}\n-                    type='text'\n-                    maxLength={answerLength + 3}\n-                    className={getInputClass(value)}\n-                    onChange={e =>\n-                      handleInputChange(node.value, e.target.value)\n-                    }\n-                    size={answerLength}\n-                    autoComplete='off'\n-                    aria-label={t('learn.fill-in-the-blank.blank')}\n-                    {...(answersCorrect[value] === false\n-                      ? { 'aria-invalid': 'true' }\n-                      : {})}\n-                  />\n+                  <ruby key={j}>\n+                    {hanzi}\n+                    <rp>(</rp>\n+                    <rt>{pinyin}</rt>\n+                    <rp>)</rp>\n+                  </ruby>\n                 );\n-              })}\n-            </p>\n-          );\n-        })}\n+              }\n+\n+              // If a blank is answered correctly, render the answer as part of the sentence.\n+              if (answersCorrect[value] === true) {\n+                return <AnswerText key={j} answer={blankAnswers[value]} />;\n+              }\n+\n+              return (\n+                <BlankInput\n+                  key={j}\n+                  blankIndex={value}\n+                  answer={blankAnswers[value]}\n+                  isCorrect={answersCorrect[value]}\n+                  className={getInputClass(value)}\n+                  onChange={handleInputChange}\n+                  ariaLabel={t('learn.fill-in-the-blank.blank')}\n+                  inputType={inputType}\n+                />\n+              );\n+            })}\n+          </p>\n+        ))}\n       </div>\n       <Spacer size='m' />\n       <div aria-live='polite'>"
        },
        {
            "sha": "da71228028a9b8e7be4681bb56fa06ec5354bb0c",
            "filename": "client/src/templates/Challenges/components/pinyin-to-hanzi-input.test.tsx",
            "status": "added",
            "additions": 353,
            "deletions": 0,
            "changes": 353,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fpinyin-to-hanzi-input.test.tsx",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fpinyin-to-hanzi-input.test.tsx",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fpinyin-to-hanzi-input.test.tsx?ref=5d6eacb6156eb1a8e3904d683fcf957b4e48719f",
            "patch": "@@ -0,0 +1,353 @@\n+import React from 'react';\n+import { describe, test, expect, vi } from 'vitest';\n+import userEvent from '@testing-library/user-event';\n+\n+import { render, screen } from '@testing-library/react';\n+import PinyinToHanziInput, { convertToHanzi } from './pinyin-to-hanzi-input';\n+\n+describe('convertToHanzi', () => {\n+  test('should convert when tone number appears after final letter', () => {\n+    // Only the correct tone gets converted to hanzi\n+    expect(convertToHanzi('shen2', { hanzi: '什', pinyin: 'shén' })).toBe('什');\n+\n+    // Incorrect tones stay as pinyin\n+    expect(convertToHanzi('shen1', { hanzi: '什', pinyin: 'shén' })).toBe(\n+      'shēn'\n+    );\n+    expect(convertToHanzi('shen3', { hanzi: '什', pinyin: 'shén' })).toBe(\n+      'shěn'\n+    );\n+    expect(convertToHanzi('shen4', { hanzi: '什', pinyin: 'shén' })).toBe(\n+      'shèn'\n+    );\n+    expect(convertToHanzi('shen5', { hanzi: '什', pinyin: 'shén' })).toBe(\n+      'shen'\n+    );\n+  });\n+\n+  test('should convert when tone number appears before final letter', () => {\n+    // Only the correct tone gets converted to hanzi\n+    expect(convertToHanzi('she2n', { hanzi: '什', pinyin: 'shén' })).toBe('什');\n+\n+    // Incorrect tones stay as pinyin\n+    expect(convertToHanzi('she1n', { hanzi: '什', pinyin: 'shén' })).toBe(\n+      'shēn'\n+    );\n+    expect(convertToHanzi('she3n', { hanzi: '什', pinyin: 'shén' })).toBe(\n+      'shěn'\n+    );\n+    expect(convertToHanzi('she4n', { hanzi: '什', pinyin: 'shén' })).toBe(\n+      'shèn'\n+    );\n+    expect(convertToHanzi('she5n', { hanzi: '什', pinyin: 'shén' })).toBe(\n+      'shen'\n+    );\n+  });\n+\n+  test('should convert both correct syllables to hanzi', () => {\n+    expect(convertToHanzi('ni3hao3', { hanzi: '你好', pinyin: 'nǐ hǎo' })).toBe(\n+      '你好'\n+    );\n+  });\n+\n+  test('should handle multiple syllables with space', () => {\n+    expect(\n+      convertToHanzi('ni3    hao3', { hanzi: '你好', pinyin: 'nǐ hǎo' })\n+    ).toBe('你    好');\n+  });\n+\n+  test('should allow extra syllables and render them as pinyin', () => {\n+    expect(\n+      convertToHanzi('ni3hao3ma3', { hanzi: '你好', pinyin: 'nǐ hǎo' })\n+    ).toBe('你好mǎ');\n+  });\n+\n+  test('should show toned pinyin for wrong syllable and convert correct one', () => {\n+    expect(convertToHanzi('ni4hao3', { hanzi: '你好', pinyin: 'nǐ hǎo' })).toBe(\n+      'nì好'\n+    );\n+\n+    expect(convertToHanzi('ni3hao4', { hanzi: '你好', pinyin: 'nǐ hǎo' })).toBe(\n+      '你hào'\n+    );\n+  });\n+\n+  test('should only convert when input has tone 5', () => {\n+    expect(\n+      convertToHanzi('shen2me', { hanzi: '什么', pinyin: 'shén me' })\n+    ).toBe('什me');\n+\n+    expect(\n+      convertToHanzi('shen2me5', { hanzi: '什么', pinyin: 'shén me' })\n+    ).toBe('什么');\n+  });\n+\n+  test('should convert long phrase properly', () => {\n+    const longPhrase = {\n+      hanzi: '请问你叫什么名字',\n+      pinyin: 'qǐng wèn nǐ jiào shén me míng zi'\n+    };\n+    expect(\n+      convertToHanzi('qing3 wen4 ni3 jiao4 shen2 me5 ming2 zi5', longPhrase)\n+    ).toBe('请 问 你 叫 什 么 名 字');\n+  });\n+\n+  test('should handle uppercase input case-insensitively', () => {\n+    expect(convertToHanzi('NI3HAO3', { hanzi: '你好', pinyin: 'nǐ hǎo' })).toBe(\n+      '你好'\n+    );\n+    expect(convertToHanzi('Ni3hAO3', { hanzi: '你好', pinyin: 'nǐ hǎo' })).toBe(\n+      '你好'\n+    );\n+  });\n+});\n+\n+describe('PinyinToHanziInput component', () => {\n+  test.each([\n+    [null, false],\n+    [true, false],\n+    [false, true]\n+  ])(\n+    'should have aria-invalid=\"%s\" when isCorrect is %s',\n+    (isCorrect, expectedAriaInvalid) => {\n+      const expectedAnswer = { hanzi: '你好', pinyin: 'nǐ hǎo' };\n+      const mockOnChange = vi.fn();\n+\n+      render(\n+        <PinyinToHanziInput\n+          index={0}\n+          expectedAnswer={expectedAnswer}\n+          isCorrect={isCorrect}\n+          onChange={mockOnChange}\n+          maxLength={100}\n+          size={20}\n+          ariaLabel='blank'\n+        />\n+      );\n+\n+      const input = screen.getByLabelText<HTMLInputElement>('blank');\n+\n+      if (expectedAriaInvalid) {\n+        expect(input).toHaveAttribute('aria-invalid', 'true');\n+      } else {\n+        expect(input).not.toHaveAttribute('aria-invalid');\n+      }\n+    }\n+  );\n+\n+  test('should convert when tone number appears before final letter (she2n me5)', async () => {\n+    const expectedAnswer = { hanzi: '什么', pinyin: 'shén me' };\n+    const mockOnChange = vi.fn();\n+\n+    render(\n+      <PinyinToHanziInput\n+        index={0}\n+        expectedAnswer={expectedAnswer}\n+        isCorrect={null}\n+        onChange={mockOnChange}\n+        maxLength={100}\n+        size={20}\n+        ariaLabel='blank'\n+      />\n+    );\n+\n+    const input = screen.getByLabelText<HTMLInputElement>('blank');\n+\n+    await userEvent.type(input, 'she2nme');\n+    expect(input.value).toBe('什me');\n+\n+    // Type the final tone digit to complete the pinyin\n+    await userEvent.type(input, '5');\n+    expect(input.value).toBe('什么');\n+  });\n+\n+  test('should convert when tone number appears after final letter (shen2 me)', async () => {\n+    const expectedAnswer = { hanzi: '什么', pinyin: 'shén me' };\n+    const mockOnChange = vi.fn();\n+\n+    render(\n+      <PinyinToHanziInput\n+        index={0}\n+        expectedAnswer={expectedAnswer}\n+        isCorrect={null}\n+        onChange={mockOnChange}\n+        maxLength={100}\n+        size={20}\n+        ariaLabel='blank'\n+      />\n+    );\n+\n+    const input = screen.getByLabelText<HTMLInputElement>('blank');\n+\n+    await userEvent.type(input, 'shen2me');\n+    expect(input.value).toBe('什me');\n+\n+    // Type the final tone digit to complete the pinyin\n+    await userEvent.type(input, '5');\n+    expect(input.value).toBe('什么');\n+  });\n+\n+  test('should revert hanzi back to toned pinyin and remove tone when backspacing', async () => {\n+    const expectedAnswer = { hanzi: '什么', pinyin: 'shén me' };\n+    const mockOnChange = vi.fn();\n+    const expectedMap: Record<string, string> = {\n+      she2nme: '什me',\n+      she2nm: '什m',\n+      she2n: '什',\n+      she2: 'shé',\n+      she: 'she'\n+    };\n+\n+    render(\n+      <PinyinToHanziInput\n+        index={0}\n+        expectedAnswer={expectedAnswer}\n+        isCorrect={null}\n+        onChange={mockOnChange}\n+        maxLength={100}\n+        size={20}\n+        ariaLabel='blank'\n+      />\n+    );\n+\n+    const input = screen.getByLabelText<HTMLInputElement>('blank');\n+\n+    await userEvent.type(input, 'she2nme5');\n+    expect(input.value).toBe('什么');\n+\n+    const rawSteps = ['she2nme', 'she2nm', 'she2n', 'she2', 'she'];\n+    for (const step of rawSteps) {\n+      await userEvent.type(input, '{Backspace}');\n+      expect(input.value).toBe(expectedMap[step]);\n+    }\n+  });\n+\n+  test('should clear the input when selecting all and pressing backspace', async () => {\n+    const expectedAnswer = { hanzi: '你好', pinyin: 'nǐ hǎo' };\n+    const mockOnChange = vi.fn();\n+\n+    render(\n+      <PinyinToHanziInput\n+        index={0}\n+        expectedAnswer={expectedAnswer}\n+        isCorrect={null}\n+        onChange={mockOnChange}\n+        maxLength={100}\n+        size={20}\n+        ariaLabel='blank'\n+      />\n+    );\n+\n+    const input = screen.getByLabelText<HTMLInputElement>('blank');\n+\n+    await userEvent.type(input, 'ni3hao3');\n+    expect(input.value).toBe('你好');\n+\n+    await userEvent.clear(input);\n+    expect(input.value).toBe('');\n+  });\n+\n+  test('should revert a single hanzi character to partial pinyin when backspacing', async () => {\n+    const expectedAnswer = { hanzi: '你', pinyin: 'nǐ' };\n+    const mockOnChange = vi.fn();\n+\n+    render(\n+      <PinyinToHanziInput\n+        index={0}\n+        expectedAnswer={expectedAnswer}\n+        isCorrect={null}\n+        onChange={mockOnChange}\n+        maxLength={100}\n+        size={20}\n+        ariaLabel='blank'\n+      />\n+    );\n+\n+    const input = screen.getByLabelText<HTMLInputElement>('blank');\n+\n+    await userEvent.type(input, 'ni3');\n+    expect(input.value).toBe('你');\n+\n+    // Backspace to revert the character to partial pinyin\n+    await userEvent.type(input, '{Backspace}');\n+    expect(input.value).toBe('ni');\n+  });\n+\n+  test('should allow changing the tone digit for a syllable (shen3 -> shěn -> shèn)', async () => {\n+    const expectedAnswer = { hanzi: '什么', pinyin: 'shén me' };\n+    const mockOnChange = vi.fn();\n+\n+    render(\n+      <PinyinToHanziInput\n+        index={0}\n+        expectedAnswer={expectedAnswer}\n+        isCorrect={null}\n+        onChange={mockOnChange}\n+        maxLength={100}\n+        size={20}\n+        ariaLabel='blank'\n+      />\n+    );\n+\n+    const input = screen.getByLabelText<HTMLInputElement>('blank');\n+\n+    await userEvent.type(input, 'shen3');\n+    expect(input.value).toBe('shěn');\n+\n+    // Replace tone 3 with 4\n+    await userEvent.type(input, '4');\n+    expect(input.value).toBe('shèn');\n+  });\n+\n+  test('should allow extra syllables beyond expected answer', async () => {\n+    const expectedAnswer = { hanzi: '你好', pinyin: 'nǐ hǎo' };\n+    const mockOnChange = vi.fn();\n+\n+    render(\n+      <PinyinToHanziInput\n+        index={0}\n+        expectedAnswer={expectedAnswer}\n+        isCorrect={null}\n+        onChange={mockOnChange}\n+        maxLength={100}\n+        size={20}\n+        ariaLabel='blank'\n+      />\n+    );\n+\n+    const input = screen.getByLabelText<HTMLInputElement>('blank');\n+\n+    await userEvent.type(input, 'ni3hao3ma3');\n+    expect(input.value).toBe('你好mǎ');\n+  });\n+\n+  test('should allow inserting mid-string and preserve converted hanzi', async () => {\n+    const expectedAnswer = { hanzi: '你好', pinyin: 'nǐ hǎo' };\n+    const mockOnChange = vi.fn();\n+\n+    render(\n+      <PinyinToHanziInput\n+        index={0}\n+        expectedAnswer={expectedAnswer}\n+        isCorrect={null}\n+        onChange={mockOnChange}\n+        maxLength={100}\n+        size={20}\n+        ariaLabel='blank'\n+      />\n+    );\n+\n+    const input = screen.getByLabelText<HTMLInputElement>('blank');\n+\n+    await userEvent.type(input, 'ni3hao3');\n+    expect(input.value).toBe('你好');\n+\n+    // Simulate mid-string edit: insert 'x' between the characters\n+    await userEvent.type(input, 'x', {\n+      initialSelectionStart: 1,\n+      initialSelectionEnd: 1\n+    });\n+\n+    expect(input.value).toBe('你x好');\n+  });\n+});"
        },
        {
            "sha": "ec8d08d3cbcf08e97f2a5da6308928d6411aee4c",
            "filename": "client/src/templates/Challenges/components/pinyin-to-hanzi-input.tsx",
            "status": "added",
            "additions": 237,
            "deletions": 0,
            "changes": 237,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fpinyin-to-hanzi-input.tsx",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fpinyin-to-hanzi-input.tsx",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fpinyin-to-hanzi-input.tsx?ref=5d6eacb6156eb1a8e3904d683fcf957b4e48719f",
            "patch": "@@ -0,0 +1,237 @@\n+import React, { useState } from 'react';\n+import { convertUnspacedPinyin } from 'pinyin-tone/v2';\n+\n+// Removing tone marks from pinyin for base letter comparison.\n+// Uses Unicode NFD to decompose accented characters, then removes combining marks\n+const normalize = (s: string) =>\n+  s.normalize('NFD').replace(/\\p{M}/gu, '').toLowerCase();\n+\n+/**\n+ * Converts raw pinyin input (with tone numbers) to hanzi characters when matching expected answer.\n+ *\n+ * Key behaviors:\n+ * 1. When a complete syllable with tone matches expected pinyin -> convert to hanzi\n+ * 2. When base letters match but tone differs -> show toned pinyin (incorrect)\n+ * 3. When syllable is a prefix of expected -> wait for more letters (e.g., 'shé' is prefix of 'shén')\n+ * 4. Spaces are preserved in the output\n+ */\n+export function convertToHanzi(\n+  raw: string,\n+  expectedAnswer: { hanzi: string; pinyin: string }\n+): string {\n+  if (!raw.trim()) return raw;\n+\n+  const correctPinyins = expectedAnswer.pinyin.toLowerCase().split(/\\s+/);\n+  const correctHanzi = [...expectedAnswer.hanzi];\n+\n+  // The final string shown to the user.\n+  // Example: '你好' for correct input, 'nǐhǎo' for incorrect\n+  let displayOutput = '';\n+\n+  // Accumulates characters for the current pinyin syllable.\n+  // Example: 'ni' while typing 'nǐ'\n+  let currentPinyin = '';\n+\n+  // Index of the next expected pinyin syllable.\n+  // Example: 0 for first syllable, 1 for second\n+  let currentCorrectPinyinIndex = 0;\n+\n+  // Pinyin syllable waiting for more input to complete.\n+  // Example: 'shé' when expecting 'shén' and waiting for 'n'\n+  let pendingPinyin = '';\n+\n+  // Process each character in the raw input\n+  for (const character of raw) {\n+    // Handle spaces: flush current syllable to output and reset state\n+    if (character === ' ') {\n+      displayOutput += currentPinyin + ' ';\n+      currentPinyin = '';\n+      pendingPinyin = '';\n+      continue;\n+    }\n+\n+    // Add character to current syllable\n+    currentPinyin += character;\n+\n+    // When a tone digit is encountered, process the completed syllable\n+    if (/[1-5]/.test(character)) {\n+      // Normalize to lowercase for case-insensitive handling\n+      currentPinyin = currentPinyin.toLowerCase();\n+\n+      const diacriticPinyin = convertUnspacedPinyin(currentPinyin); // Add tone mark\n+\n+      // If all expected syllables have been processed and the user has typed more\n+      // syllables than the expected answer contains, append the additional pinyin\n+      // syllables as-is without attempting to convert them to hanzi.\n+      if (currentCorrectPinyinIndex >= correctPinyins.length) {\n+        displayOutput += diacriticPinyin;\n+        currentPinyin = '';\n+        continue;\n+      }\n+\n+      const correctSyllable = correctPinyins[currentCorrectPinyinIndex];\n+\n+      // Check if the input matches the expected syllable exactly.\n+      // If so, convert to hanzi.\n+      if (diacriticPinyin.toLowerCase() === correctSyllable.toLowerCase()) {\n+        displayOutput += correctHanzi[currentCorrectPinyinIndex]; // Convert to hanzi\n+        currentCorrectPinyinIndex++;\n+        currentPinyin = '';\n+        pendingPinyin = '';\n+      }\n+      // Check if base letters match but tone differs.\n+      // If so, show incorrect toned pinyin.\n+      else if (normalize(diacriticPinyin) === normalize(correctSyllable)) {\n+        displayOutput += diacriticPinyin;\n+        currentCorrectPinyinIndex++;\n+        currentPinyin = '';\n+        pendingPinyin = '';\n+      }\n+      // Check if input is a prefix of expected (e.g., 'shé' for 'shén').\n+      // If so, show pinyin and wait for more input.\n+      else if (\n+        normalize(correctSyllable).startsWith(normalize(diacriticPinyin))\n+      ) {\n+        displayOutput += diacriticPinyin;\n+        pendingPinyin = diacriticPinyin;\n+        currentPinyin = '';\n+      }\n+      // No match: show pinyin and move to next expected syllable\n+      else {\n+        displayOutput += diacriticPinyin;\n+        currentCorrectPinyinIndex++;\n+        currentPinyin = '';\n+        pendingPinyin = '';\n+      }\n+    }\n+    // Handle non-tone characters when there's pending pinyin.\n+    // Pending pinyin occurs when the user's input is a prefix of the expected syllable\n+    // (e.g., 'shé' for 'shén'). In this case, combine the pending pinyin with the new\n+    // non-tone characters and check if it now matches the expected syllable. If it does,\n+    // replace the pending pinyin in the output with the correct hanzi character.\n+    else if (\n+      pendingPinyin &&\n+      currentCorrectPinyinIndex < correctPinyins.length\n+    ) {\n+      const combinedPinyin = pendingPinyin + currentPinyin;\n+      const correctPinyin = correctPinyins[currentCorrectPinyinIndex];\n+\n+      // Check if combined input now matches the expected syllable exactly.\n+      if (combinedPinyin.toLowerCase() === correctPinyin.toLowerCase()) {\n+        // Replace the pending pinyin at the end of displayOutput with the correct hanzi character\n+        const endIndex = displayOutput.length - pendingPinyin.length;\n+        displayOutput =\n+          displayOutput.slice(0, endIndex) +\n+          correctHanzi[currentCorrectPinyinIndex];\n+        currentCorrectPinyinIndex++;\n+        currentPinyin = '';\n+        pendingPinyin = '';\n+      }\n+      // Check if combined input matches the base letters but tone differs\n+      else if (normalize(combinedPinyin) === normalize(correctPinyin)) {\n+        // Replace the pending pinyin at the end of displayOutput with the combined pinyin\n+        const endIndex = displayOutput.length - pendingPinyin.length;\n+        displayOutput = displayOutput.slice(0, endIndex) + combinedPinyin;\n+        currentCorrectPinyinIndex++;\n+        currentPinyin = '';\n+        pendingPinyin = '';\n+      }\n+    }\n+  }\n+\n+  // Append any unfinished syllable at the end\n+  return displayOutput + currentPinyin;\n+}\n+\n+interface PinyinToHanziInputProps {\n+  index: number;\n+  expectedAnswer: { hanzi: string; pinyin: string };\n+  isCorrect: boolean | null;\n+  onChange: (index: number, value: string) => void;\n+  className?: string;\n+  maxLength: number;\n+  size: number;\n+  ariaLabel: string;\n+}\n+\n+function PinyinToHanziInput({\n+  index,\n+  expectedAnswer,\n+  isCorrect,\n+  onChange,\n+  className,\n+  maxLength,\n+  size,\n+  ariaLabel\n+}: PinyinToHanziInputProps): JSX.Element {\n+  const [rawInput, setRawInput] = useState('');\n+  const [displayValue, setDisplayValue] = useState('');\n+\n+  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n+    const inputValue = e.target.value;\n+    const prevLength = displayValue.length;\n+    const inputLength = inputValue.length;\n+\n+    const isAppendingAtEnd =\n+      inputLength > prevLength && inputValue.startsWith(displayValue);\n+    const isDeletingFromEnd =\n+      inputLength < prevLength && displayValue.startsWith(inputValue);\n+\n+    let newRawInput: string;\n+\n+    if (isAppendingAtEnd) {\n+      const added = inputValue.substring(prevLength);\n+\n+      // Handle tone digit replacement\n+      if (\n+        added.length === 1 &&\n+        /[1-5]/.test(added) &&\n+        /[1-5]$/.test(rawInput)\n+      ) {\n+        newRawInput = rawInput.slice(0, -1) + added;\n+      } else {\n+        newRawInput = rawInput + added;\n+      }\n+    } else if (isDeletingFromEnd) {\n+      if (inputLength === 0) {\n+        // When clearing the entire input:\n+        // - If the previous display was a single character,\n+        //   assume the user wants to remove the last character from raw input\n+        //   (e.g., undo the tone digit that converted it, like 'ni3' -> 'ni').\n+        // - Otherwise, fully clear raw input to an empty string.\n+        newRawInput = prevLength === 1 ? rawInput.slice(0, -1) : '';\n+      } else {\n+        // Remove characters from raw input\n+        const charsToRemove = prevLength - inputLength;\n+        newRawInput = rawInput.slice(0, -charsToRemove);\n+      }\n+    } else {\n+      // Mid-string edit - update new raw input directly\n+      newRawInput = inputValue;\n+    }\n+\n+    setRawInput(newRawInput);\n+    const newDisplayValue = convertToHanzi(newRawInput, expectedAnswer);\n+    setDisplayValue(newDisplayValue);\n+    onChange(index, newDisplayValue);\n+  };\n+\n+  return (\n+    <input\n+      type='text'\n+      value={displayValue}\n+      onChange={handleChange}\n+      className={className}\n+      maxLength={maxLength}\n+      size={size}\n+      autoComplete='off'\n+      aria-label={ariaLabel}\n+      aria-describedby={`pinyin-description-${index}`}\n+      {...(isCorrect === false ? { 'aria-invalid': 'true' } : {})}\n+    />\n+  );\n+}\n+\n+PinyinToHanziInput.displayName = 'PinyinToHanziInput';\n+\n+export default PinyinToHanziInput;"
        },
        {
            "sha": "5b1cc32ff7661eb8b9f563bfa743004772ef8436",
            "filename": "client/src/templates/Challenges/fill-in-the-blank/show.tsx",
            "status": "modified",
            "additions": 53,
            "deletions": 9,
            "changes": 62,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fshow.tsx",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fshow.tsx",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fshow.tsx?ref=5d6eacb6156eb1a8e3904d683fcf957b4e48719f",
            "patch": "@@ -38,6 +38,7 @@ import { replaceAppleQuotes } from '../../../utils/replace-apple-quotes';\n import { parseHanziPinyinPairs } from './parse-blanks';\n \n import './show.css';\n+import { ChallengeLang } from '../../../../../shared-dist/config/curriculum';\n \n // Redux Setup\n const mapStateToProps = createSelector(\n@@ -91,7 +92,8 @@ const ShowFillInTheBlank = ({\n         fillInTheBlank,\n         helpCategory,\n         scene,\n-        tests\n+        tests,\n+        lang\n       }\n     }\n   },\n@@ -133,7 +135,7 @@ const ShowFillInTheBlank = ({\n     // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, []);\n \n-  const handleSubmit = () => {\n+  const handleSubmitNonChinese = () => {\n     const blankAnswers = fillInTheBlank.blanks.map(b => b.answer);\n \n     const newAnswersCorrect = userAnswers.map((userAnswer, i) => {\n@@ -144,14 +146,47 @@ const ShowFillInTheBlank = ({\n         userAnswer.trim()\n       ).toLowerCase();\n \n-      const pairs = parseHanziPinyinPairs(answer);\n-      const hanziPinyin = pairs.length === 1 ? pairs[0] : null;\n+      return normalizedUserAnswer === answer.toLowerCase();\n+    });\n+\n+    setAnswersCorrect(newAnswersCorrect);\n+    const hasWrongAnswer = newAnswersCorrect.some(a => a === false);\n+    if (!hasWrongAnswer) {\n+      setShowFeedback(false);\n+      setFeedback(null);\n+      openCompletionModal();\n+    } else {\n+      const firstWrongIndex = newAnswersCorrect.findIndex(a => a === false);\n+      const feedback =\n+        firstWrongIndex >= 0\n+          ? fillInTheBlank.blanks[firstWrongIndex].feedback\n+          : null;\n+\n+      setFeedback(feedback);\n+      setShowWrong(true);\n+      setShowFeedback(true);\n+    }\n+  };\n \n-      if (hanziPinyin) {\n-        const { hanzi } = hanziPinyin;\n-        // TODO: Implement full hanzi-pinyin validation logic\n-        // https://github.com/freeCodeCamp/language-curricula/issues/18\n-        return normalizedUserAnswer === hanzi;\n+  const handleSubmitChinese = () => {\n+    const blankAnswers = fillInTheBlank.blanks.map(b => b.answer);\n+\n+    const newAnswersCorrect = userAnswers.map((userAnswer, i) => {\n+      if (!userAnswer) return false;\n+\n+      const answer = blankAnswers[i];\n+      const normalizedUserAnswer = userAnswer.trim().toLowerCase();\n+\n+      if (fillInTheBlank.inputType === 'pinyin-to-hanzi') {\n+        const pairs = parseHanziPinyinPairs(answer);\n+        if (pairs.length === 1) {\n+          const hanziPinyin = pairs[0];\n+          const { hanzi } = hanziPinyin;\n+          return (\n+            normalizedUserAnswer.replace(/\\s+/g, '') ===\n+            hanzi.replace(/\\s+/g, '')\n+          );\n+        }\n       }\n \n       return normalizedUserAnswer === answer.toLowerCase();\n@@ -176,6 +211,14 @@ const ShowFillInTheBlank = ({\n     }\n   };\n \n+  const handleSubmit = () => {\n+    if (lang === ChallengeLang.Chinese) {\n+      handleSubmitChinese();\n+    } else {\n+      handleSubmitNonChinese();\n+    }\n+  };\n+\n   const handleInputChange = (inputIndex: number, value: string): void => {\n     const newUserAnswers = [...userAnswers];\n     newUserAnswers[inputIndex] = value;\n@@ -301,6 +344,7 @@ export const query = graphql`\n         helpCategory\n         superBlock\n         block\n+        lang\n         fields {\n           slug\n         }"
        },
        {
            "sha": "7ccf96f48b6392559b389d8a166e3408aa5f9736",
            "filename": "pnpm-lock.yaml",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/pnpm-lock.yaml",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5d6eacb6156eb1a8e3904d683fcf957b4e48719f/pnpm-lock.yaml",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/pnpm-lock.yaml?ref=5d6eacb6156eb1a8e3904d683fcf957b4e48719f",
            "patch": "@@ -411,6 +411,9 @@ importers:\n       path-browserify:\n         specifier: 1.0.1\n         version: 1.0.1\n+      pinyin-tone:\n+        specifier: 2.4.0\n+        version: 2.4.0\n       postcss:\n         specifier: 8.4.35\n         version: 8.4.35\n@@ -553,6 +556,9 @@ importers:\n       '@testing-library/react-hooks':\n         specifier: ^8.0.1\n         version: 8.0.1(@types/react@17.0.83)(react-dom@17.0.2(react@17.0.2))(react-test-renderer@17.0.2(react@17.0.2))(react@17.0.2)\n+      '@testing-library/user-event':\n+        specifier: 14.6.1\n+        version: 14.6.1(@testing-library/dom@10.4.0)\n       '@total-typescript/ts-reset':\n         specifier: ^0.5.0\n         version: 0.5.1\n@@ -4525,6 +4531,12 @@ packages:\n       react: <18.0.0\n       react-dom: <18.0.0\n \n+  '@testing-library/user-event@14.6.1':\n+    resolution: {integrity: sha512-vq7fv0rnt+QTXgPxr5Hjc210p6YKq2kmdziLgnsZGgLJ9e6VAShx1pACLuRjd/AS/sr7phAR58OIIpf0LlmQNw==}\n+    engines: {node: '>=12', npm: '>=6'}\n+    peerDependencies:\n+      '@testing-library/dom': '>=7.21.4'\n+\n   '@tokenizer/token@0.3.0':\n     resolution: {integrity: sha512-OvjF+z51L3ov0OyAU0duzsYuvO01PH7x4t6DJx+guahgTnBHkhJdG7soQeTSFLWN3efnHyibZ4Z8l2EuWwJN3A==}\n \n@@ -10816,6 +10828,9 @@ packages:\n     resolution: {integrity: sha512-8OEwKp5juEvb/MjpIc4hjqfgCNysrS94RIOMXYvpYCdm/jglrKEiAYmiumbmGhCvs+IcInsphYDFwqrjr7398w==}\n     hasBin: true\n \n+  pinyin-tone@2.4.0:\n+    resolution: {integrity: sha512-ATSA0WW81iOxTTePpY3FN2hXwh8OcDuO/xP5YwdkZLBGvZnkvhF1Nhbl03fS8CRtyvwvt1cBmzRnmHRR3p/7aw==}\n+\n   pirates@4.0.6:\n     resolution: {integrity: sha512-saLsH7WeYYPiD25LDuLRRY/i+6HaPYr6G1OUlN39otzkSTxKnubR9RTxS3/Kk50s1g2JTgFwWQDQyplC5/SHZg==}\n     engines: {node: '>= 6'}\n@@ -12625,6 +12640,7 @@ packages:\n   supertest@6.3.3:\n     resolution: {integrity: sha512-EMCG6G8gDu5qEqRQ3JjjPs6+FYT1a7Hv5ApHvtSghmOFJYtsU5S+pSb6Y2EUeCEY3CmEL3mmQ8YWlPOzQomabA==}\n     engines: {node: '>=6.4.0'}\n+    deprecated: Please upgrade to supertest v7.1.3+, see release notes at https://github.com/forwardemail/supertest/releases/tag/v7.1.3 - maintenance is supported by Forward Email @ https://forwardemail.net\n \n   supports-color@5.5.0:\n     resolution: {integrity: sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==}\n@@ -18952,6 +18968,10 @@ snapshots:\n       react: 17.0.2\n       react-dom: 17.0.2(react@17.0.2)\n \n+  '@testing-library/user-event@14.6.1(@testing-library/dom@10.4.0)':\n+    dependencies:\n+      '@testing-library/dom': 10.4.0\n+\n   '@tokenizer/token@0.3.0': {}\n \n   '@tootallnate/once@1.1.2': {}\n@@ -27138,6 +27158,8 @@ snapshots:\n       sonic-boom: 4.2.0\n       thread-stream: 3.1.0\n \n+  pinyin-tone@2.4.0: {}\n+\n   pirates@4.0.6: {}\n \n   pkg-dir@3.0.0:"
        }
    ],
    "stats": {
        "total": 848,
        "additions": 776,
        "deletions": 72
    }
}