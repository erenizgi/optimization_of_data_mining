{
    "author": "Hrishik03",
    "message": "fix(curriculum): added the new version and fixed typos in lec-working-with-regular-exp (#63592)",
    "sha": "37ce12aa69b35a81de9eb0f7ead00edde45d8c0c",
    "files": [
        {
            "sha": "226911e6e631f27ac083331aefc487d8bd0b2ed9",
            "filename": "curriculum/challenges/english/blocks/lecture-working-with-regular-expressions/6733c5e54e3a154c8078ed48.md",
            "status": "modified",
            "additions": 26,
            "deletions": 2,
            "changes": 28,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/37ce12aa69b35a81de9eb0f7ead00edde45d8c0c/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-regular-expressions%2F6733c5e54e3a154c8078ed48.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/37ce12aa69b35a81de9eb0f7ead00edde45d8c0c/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-regular-expressions%2F6733c5e54e3a154c8078ed48.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-regular-expressions%2F6733c5e54e3a154c8078ed48.md?ref=37ce12aa69b35a81de9eb0f7ead00edde45d8c0c",
            "patch": "@@ -5,7 +5,7 @@ challengeType: 19\n dashedName: what-are-regex-quantifiers-and-how-do-they-work\n ---\n \n-# --description--\n+# --interactive--\n \n Let's learn about quantifiers in regular expressions.\n \n@@ -25,6 +25,8 @@ const regex = /^\\d{4}$/;\n \n Notice how our quantifier contains only the number `4`. This syntax means \"match the previous character exactly four times\". Let's see how that behaves:\n \n+:::interactive_editor\n+\n ```js\n const regex = /^\\d{4}$/;\n console.log(regex.test(\"123\")); // false\n@@ -34,6 +36,8 @@ console.log(regex.test(\"123456\")); // false\n console.log(regex.test(\"1234567\")); // false\n ```\n \n+:::\n+\n The pattern only matches the string with exactly four digits, because we have used the anchors and our quantifier only allows exactly four digits. But maybe the identification code only needs to be a minimum of four digits.\n \n To allow for four or more digits, add a comma after the number in your quantifier:\n@@ -44,6 +48,8 @@ const regex = /^\\d{4,}$/;\n \n Now, our syntax allows the pattern to match four or more digits. Let's test it:\n \n+:::interactive_editor\n+\n ```js\n const regex = /^\\d{4,}$/;\n console.log(regex.test(\"123\")); // false\n@@ -53,6 +59,8 @@ console.log(regex.test(\"123456\")); // true\n console.log(regex.test(\"1234567\")); // true\n ```\n \n+:::\n+\n A seven-digit identifier is rather long. These identifiers should have a maximum of 6 digits, and a minimum of 4 digits. To achieve this, you can add a second number to your quantifier after the comma:\n \n ```js\n@@ -61,6 +69,8 @@ const regex = /^\\d{4,6}$/;\n \n And now our pattern no longer matches the seven-digit identifier, because it is greater than our six-digit maximum.\n \n+:::interactive_editor\n+\n ```js\n const regex = /^\\d{4,6}$/;\n console.log(regex.test(\"123\")); // false\n@@ -70,12 +80,14 @@ console.log(regex.test(\"123456\")); // true\n console.log(regex.test(\"1234567\")); // false\n ```\n \n+:::\n+\n Note that you cannot use this syntax to set a maximum alone – you must always set a minimum. But if you set the minimum to `1`, you can effectively achieve the same result.\n \n We've received updated requirements from our users. Identifiers can now optionally start with a letter. We already know the character class for this, so let's add that to our regular expression:\n \n ```js\n-const regex = /^[a-zA-z]\\d{4,6}$/;\n+const regex = /^[a-zA-Z]\\d{4,6}$/;\n ```\n \n But now we mandate the presence of a letter. How can we make it optional?\n@@ -94,6 +106,8 @@ const regex = /^[a-zA-Z]?\\d{4,6}$/;\n \n We should validate the result:\n \n+:::interactive_editor\n+\n ```js\n const regex = /^[a-zA-Z]?\\d{4,6}$/;\n console.log(regex.test(\"123\")); // false\n@@ -104,6 +118,8 @@ console.log(regex.test(\"X123456\")); // true\n console.log(regex.test(\"1234567\")); // false\n ```\n \n+:::\n+\n Our pattern now allows for a single optional letter, followed by four to six digits.\n \n Unfortunately, we've just realized we read the requirements wrong. We need to allow for any number of letters before the numbers. We can use our quantifier with a `0` minimum and no defined maximum:\n@@ -114,6 +130,8 @@ const regex = /^[a-zA-Z]{0,}\\d{4,6}$/;\n \n But our pattern is getting long again. Thankfully, there's another short-hand for \"match the previous character zero or more times\" –  the asterisk (`*`) symbol. Let's replace our quantifier with that in the pattern, and test it:\n \n+:::interactive_editor\n+\n ```js\n const regex = /^[a-zA-Z]*\\d{4,6}$/;\n console.log(regex.test(\"123\")); // false\n@@ -124,10 +142,14 @@ console.log(regex.test(\"X123456\")); // true\n console.log(regex.test(\"1234567\")); // false\n ```\n \n+:::\n+\n Now we successfully match any identifier with zero or more letters followed by four to six numbers. But it turns out this is crashing our system – we actually have to require at least one letter.\n \n Again, we could use a quantifier with a minimum of one and no defined maximum, or we could use yet another special syntax – the plus (`+`) symbol:\n \n+:::interactive_editor\n+\n ```js\n const regex = /^[a-zA-Z]+\\d{4,6}$/;\n console.log(regex.test(\"123\")); // false\n@@ -138,6 +160,8 @@ console.log(regex.test(\"X123456\")); // true\n console.log(regex.test(\"1234567\")); // false\n ```\n \n+:::\n+\n Now the identifiers that do not start with at least one letter fail, regardless of how many numbers there are.\n \n You can use quantifiers to greatly enhance the brevity and readability of your regular expressions."
        }
    ],
    "stats": {
        "total": 28,
        "additions": 26,
        "deletions": 2
    }
}