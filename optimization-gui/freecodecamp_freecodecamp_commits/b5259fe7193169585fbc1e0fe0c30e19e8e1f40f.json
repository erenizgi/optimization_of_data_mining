{
    "author": "jeremylt",
    "message": "fix(curriculum): faster ref solution for Euler 461 (#56578)",
    "sha": "b5259fe7193169585fbc1e0fe0c30e19e8e1f40f",
    "files": [
        {
            "sha": "3fd79d09c3ebae1abc3466de846372b3c5f23959",
            "filename": "curriculum/challenges/english/18-project-euler/project-euler-problems-401-to-480/problem-461-almost-pi.md",
            "status": "modified",
            "additions": 37,
            "deletions": 72,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/b5259fe7193169585fbc1e0fe0c30e19e8e1f40f/curriculum%2Fchallenges%2Fenglish%2F18-project-euler%2Fproject-euler-problems-401-to-480%2Fproblem-461-almost-pi.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/b5259fe7193169585fbc1e0fe0c30e19e8e1f40f/curriculum%2Fchallenges%2Fenglish%2F18-project-euler%2Fproject-euler-problems-401-to-480%2Fproblem-461-almost-pi.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F18-project-euler%2Fproject-euler-problems-401-to-480%2Fproblem-461-almost-pi.md?ref=b5259fe7193169585fbc1e0fe0c30e19e8e1f40f",
            "patch": "@@ -65,89 +65,54 @@ function almostPi(n) {\n \n ```js\n function almostPi(n) {\n-\n-  // Find all possible values where f(k, n) <= PI\n-  const f = [];\n-  let max = 0;\n-  while (1) {\n-    let current = Math.exp(max / n) - 1;\n-\n-    if (current > Math.PI) break;\n-\n-    f.push(current);\n-    ++max;\n-  }\n-\n-  // Get all pairs where f[i] + f[j] <= PI\n-  const pairs = [];\n-  for (let i = 0; i < max; ++i) {\n-    for (let j = 0; j < max; ++j) {\n-      if (f[i] + f[j] > Math.PI) break;\n-      pairs.push(f[i] + f[j]);\n+  const max_k = Math.ceil(n * Math.log(Math.PI + 1)) + 1;\n+  const     f = Array(max_k)\n+                  .fill(0)\n+                  .map((_, i) => Math.exp(i / n) - 1);\n+\n+  // Pairs of values\n+  const pairs     = Array(max_k * (max_k - 1) / 2);\n+  let   num_pairs = 0;\n+\n+  for (let b = 1; b < max_k; b++) {\n+    for (let a = 0; a < b; a++) {\n+      const value = f[a] + f[b];\n+\n+      if (value > Math.PI) break;\n+      pairs[num_pairs] = {a, b, value};\n+      num_pairs++;\n     }\n   }\n+  pairs.sort((a, b) => a.value - b.value);\n \n-  // Sort all values\n-  pairs.sort((a, b) => a - b);\n-\n-  // Optimal Value for (a + b)\n-  let left = 0;\n-  // Optimal Value for (c + d)\n-  let right = 0;\n-  // minimum error with Math.abs(a + b - Math.PI)\n-  let minError = Math.PI;\n-\n-  // Binary Search for the best match\n-  for (let i = 0; i < pairs.length; ++i) {\n-    let current = pairs[i];\n-    let need = Math.PI - current;\n-\n-    if (need < current) break;\n+  // Find lowest matching pair for each pair\n+  let min_error = Math.PI;\n+  let min_abcd  = -1;\n \n-    let match;\n-    for (let i = 1; i < pairs.length; ++i) {\n-      if (pairs[i] > need) {\n-        match = i;\n-        break;\n-      }\n-    }\n+  for (let i = 0; i < num_pairs; i++) {\n+    const error = Math.PI - pairs[i].value;\n+    let start   = i;\n+    let stop    = num_pairs - 1;\n \n-    let error = Math.abs(need - pairs[match]);\n-    if (error < minError)\n-    {\n-      minError = error;\n-      left = i;\n-      right = match;\n-    }\n+    // Find best match\n+    while (stop - start > 1) {\n+      let mid = start + Math.floor((stop - start) / 2);\n \n-    --match;\n-    error = Math.abs(need - pairs[match]);\n-    if (error < minError) {\n-      minError = error;\n-      left = i;\n-      right = match;\n+      if (pairs[mid].value > error) stop = mid - 1;\n+      else start = mid + 1;\n     }\n-  }\n \n-  let a, b, c, d;\n-\n-  OuterLoop1:\n-  for (a = 0; a < max; ++a) {\n-    for (b = a; b < max; ++b) {\n-      if (pairs[left] == f[a] + f[b]) {\n-        break OuterLoop1;\n-      }\n-    }\n-  }\n+    // Compute new best error\n+    for (const j of [start, stop]) {\n+      const new_error = Math.abs(error - pairs[j].value);\n \n-  OuterLoop2:\n-  for (c = 0; c < max; ++c) {\n-    for (d = c; d < max; ++d) {\n-      if (pairs[right] == f[c] + f[d]) {\n-        break OuterLoop2;\n+      if (new_error < min_error) {\n+        min_error = new_error;\n+        min_abcd  = pairs[i].a * pairs[i].a + pairs[i].b * pairs[i].b +\n+                    pairs[j].a * pairs[j].a + pairs[j].b * pairs[j].b;\n       }\n     }\n   }\n-  return a*a + b*b + c*c + d*d;\n+  return min_abcd;\n }\n ```"
        }
    ],
    "stats": {
        "total": 109,
        "additions": 37,
        "deletions": 72
    }
}