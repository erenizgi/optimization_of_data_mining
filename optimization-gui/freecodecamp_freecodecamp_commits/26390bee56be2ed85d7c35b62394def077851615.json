{
    "author": "Dario-DC",
    "message": "chore(curriculum): add async js transcripts (#58573)\n\nCo-authored-by: Naomi <accounts+github@nhcarrigan.com>",
    "sha": "26390bee56be2ed85d7c35b62394def077851615",
    "files": [
        {
            "sha": "abf1fd58379113e2f0ba8a2462a92242a82fda9f",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-asynchronous-programming/6733b072bd8f5b06ccdbd9e2.md",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F6733b072bd8f5b06ccdbd9e2.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F6733b072bd8f5b06ccdbd9e2.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F6733b072bd8f5b06ccdbd9e2.md?ref=26390bee56be2ed85d7c35b62394def077851615",
            "patch": "@@ -10,6 +10,46 @@ dashedName: what-is-asynchronous-javascript-and-how-does-it-differ-from-synchron\n \n Watch the video lecture and answer the questions below.\n \n+# --transcript--\n+\n+What is asynchronous JavaScript and how does it differ from synchronous JavaScript?\n+\n+Let’s learn about asynchronous JavaScript. Asynchronous events occur at different times, independently from each other.\n+\n+In the context of software development, \"asynchronous\" refers to tasks that run in the background, independently from the main flow of the program. The main advantage of asynchronous processes is that they don’t block the execution of the main program.\n+\n+That’s particularly helpful for tasks that may take a long time to run, such as fetching data from a remote server, processing large files, handling user input, and performing complex calculations. This is what we know as asynchronous programming.\n+\n+This approach contrasts with the traditional synchronous programming technique that you have been working with so far. When you write multiple lines of code, you can usually predict what will happen and when it will happen. The first line will be executed, then the second line, and so on in the order that you write them.\n+\n+In this example, the first line where you define the variable will be executed first, then the second line, and finally the third line where the string is logged to the console:\n+\n+```js\n+const topic = \"JavaScript\";\n+const learning = `I'm learning ${topic}!`;\n+console.log(learning);\n+```\n+\n+Everything is sequential and predictable. Each line is completed before the next one starts. This type of JavaScript program is known as single-threaded.\n+\n+The concept of threads is very important. A thread is a unit of execution within a process. It’s like a separate flow of control within the program.\n+\n+In synchronous programming, threads execute sequentially, one after the other. If a thread is blocked, like waiting for user input, the entire process is blocked until the thread is completed.\n+\n+In asynchronous programming, threads can be executed concurrently, running multiple threads at the same time. This way, the program can continue running multiple tasks simultaneously without making the main program unresponsive, even if one of the threads is blocked.\n+\n+Asynchronous programming often involves callbacks, promises, or async/await to handle non-blocking operations.\n+\n+As you learned in earlier lecture videos, a callback is a function that you pass to another function to be called later. Event handlers are a particular type of callback that you’ve worked with before. They used to be the most common way to implement asynchronous functions in JavaScript. However, if the callback function also takes other callback functions, the code and logic can get quite complicated very quickly. \n+\n+Currently, the most commonly used technique for implementing asynchronous programming in JavaScript is the promise. A `Promise` is an object that represents the eventual completion (or failure) of an asynchronous process and its value.\n+\n+The value of a promise is not known when the promise is created. It’s only known when the asynchronous process is completed. For example, the process of fetching data from a remote API for your web application may take some time. Meanwhile, you want your users to have a nice user experience, right?\n+\n+To implement this, you could create a promise to keep the user interface active and interactive while the asynchronous process is running. When the process is completed, the promise will contain the data that was sent back by the API, so the application can handle it or render it appropriately when it’s available.\n+\n+Asynchronous programming is a powerful tool for building efficient JavaScript applications. By understanding the differences between synchronous and asynchronous programming, you can choose the right approach for your application and write more efficient code.\n+\n # --questions--\n \n ## --text--"
        },
        {
            "sha": "35e17b835e91ae0df333c0deea87a8c41ef2ad62",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-asynchronous-programming/67340798c2c1776709d8a5fe.md",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F67340798c2c1776709d8a5fe.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F67340798c2c1776709d8a5fe.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F67340798c2c1776709d8a5fe.md?ref=26390bee56be2ed85d7c35b62394def077851615",
            "patch": "@@ -10,6 +10,38 @@ dashedName: how-does-the-async-attribute-work-inside-script-elements-and-how-doe\n \n Watch the lecture video and answer the questions below.\n \n+# --transcript--\n+\n+How does the `async` attribute work inside `script` elements and how does it differ from the `defer` attribute?\n+\n+The `async` and `defer` attributes in HTML `script` elements play a crucial role in how JavaScript files are loaded and executed in web pages. Understanding them can improve your website's performance and user experience. When you include a `script` in your HTML file, it looks like this:\n+\n+```js\n+<script src=\"example.js\"></script>\n+```\n+\n+When the browser finds this `script` tag, it stops parsing the HTML, downloads the script, executes it, and then continues parsing the HTML. This can slow down the loading of your web page, especially if you have large scripts.\n+\n+This is where the `async` and `defer` attributes come in. They provide ways to load scripts more efficiently.\n+\n+Let's start with the `async` attribute:\n+\n+```js\n+<script src=\"example.js\" async></script>\n+```\n+\n+By adding the `async` attribute to a `script` tag, the browser will continue parsing the HTML while the script is being downloaded. Once the script is fully downloaded, the browser will pause HTML parsing, execute the script, and then resume parsing the HTML. This can significantly speed up page loading.\n+\n+It's important to note that async scripts are executed as soon as they're downloaded, which means they might not run in the correct order which we desire. This is where the `defer` attribute comes in for the rescue. Let's look at how the `defer` attribute looks like:\n+\n+```js\n+<script src=\"example.js\" defer></script>\n+```\n+\n+The `defer` attribute is similar to `async` attribute. However, defer scripts are not executed immediately after they're downloaded. Instead, they wait until the HTML parsing is complete. Furthermore, defer scripts execute in the order they appear in the HTML code.\n+\n+In short, use `async` for scripts where the order of execution doesn't matter, and use `defer` when you need to ensure that scripts run in the correct order. Both attributes can significantly improve page load times by allowing the browser to continue parsing HTML while scripts are being downloaded in the background.\n+\n # --questions--\n \n ## --text--"
        },
        {
            "sha": "6e1114ae6f5d4764946d1a971d460006b2ef8805",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-asynchronous-programming/673407a223891b6734563c89.md",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407a223891b6734563c89.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407a223891b6734563c89.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407a223891b6734563c89.md?ref=26390bee56be2ed85d7c35b62394def077851615",
            "patch": "@@ -10,6 +10,30 @@ dashedName: what-is-the-fetch-api-and-what-are-common-types-of-resources-that-ar\n \n Watch the lecture video and answer the questions below.\n \n+# --transcript--\n+\n+What is the Fetch API and what are common types of resources that are fetched from the network?\n+\n+The Fetch API allows web apps to make network requests, typically to retrieve or send data to the server. This API provides a `fetch()` method that you can use to make these requests. Let's look at a basic example of how to use `fetch`:\n+\n+```js\n+fetch('https://api.example.com/data')\n+```\n+\n+In this example, we're making a `GET` request to `https://api.example.com/data`. This will then return us some data that we need to convert to JSON format and can use anywhere we want to. \n+\n+By default, the Fetch API uses the `GET` method to retrieve data. This will be covered in the next lecture, along with other common HTTP request methods.\n+\n+Now, let's discuss some common types of resources that are fetched from the network.\n+\n+In our web apps, we need some common data like weather data, professions list data, country names list, country code or country flag icons/images. Using these data we can make our app more informative and interactive. Thanks to Fetch API, we can get these resources from the network.\n+\n+Images are some frequently fetched resources. You might use fetch to load images statically or dynamically based on user actions, and display them on your web app.\n+\n+Text files are another type of resource often fetched. This could include configuration files, log files, or even entire documents that you want to display on your webpage.\n+\n+In some cases, you might fetch audio or video files. The Fetch API can handle these types of resources as well, allowing you to work with a wide variety of data types.\n+\n # --questions--\n \n ## --text--"
        },
        {
            "sha": "6bc4f75b293c37ccd3543f443504e7f11b6b52a2",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-asynchronous-programming/673407be6af21d6766ed4b96.md",
            "status": "modified",
            "additions": 68,
            "deletions": 0,
            "changes": 68,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407be6af21d6766ed4b96.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407be6af21d6766ed4b96.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407be6af21d6766ed4b96.md?ref=26390bee56be2ed85d7c35b62394def077851615",
            "patch": "@@ -10,6 +10,74 @@ dashedName: how-does-the-fetch-api-work-with-common-http-methods-and-res-json\n \n Watch the lecture video and answer the questions below.\n \n+# --transcript--\n+\n+How does the Fetch API work with common HTTP methods?\n+\n+In the previous lecture, we saw what the Fetch API is and how to use it. In this lecture, we will discuss about the `GET`, `POST`, `PUT` and `DELETE` HTTP methods of Fetch API.\n+\n+Let's start with the most common HTTP method which is the `GET` method. This is used to retrieve data from a server. When you use `fetch()` without specifying a method, it defaults to `GET`.\n+\n+```js\n+fetch('https://api.example.com/data')\n+```\n+\n+In this code, we're making a `GET` request to `https://api.example.com/data`. Now, please note that you cannot use this data directly, you have to convert the response to a JSON format. Only then you can use it anywhere you want in your project. Here’s an example of how to do it:\n+\n+```js\n+fetch('https://api.example.com/data')\n+  .then(response => response.json())\n+  .then(data => console.log(data))\n+```\n+\n+In this code, the response coming from the Fetch API is a promise, and we are using a `.then` handler to convert the response to a JSON format. In a prior lecture video, you learned that a `Promise` is an object that represents the eventual completion (or failure) of an asynchronous process and its value.\n+\n+The value of a promise is not known when the promise is created. It’s only known when the asynchronous process is completed. When we chain the two `.then` handlers to the fetch call, this is something called promise chaining which will be taught in the next lecture.\n+\n+So far we have been retrieving resources from a server. But, did you know that we can also send data to the server? The `POST` method is used to send data to a server to create a resource. Here’s an example of a `POST` method which is used to create data into the server: \n+\n+```js\n+fetch('https://api.example.com/users', {\n+  method: '`POST`',\n+  headers: {\n+    'Content-Type': 'application/json',\n+  },\n+  body: JSON.stringify({\n+    name: 'John Doe',\n+    email: 'john@example.com'\n+  })\n+})\n+```\n+\n+In this example, we're sending a `POST` request to create a new user. We specify the method as `POST`, set the appropriate headers, and include a `body` with the data we want to send. The body needs to be a string, so we use `JSON.stringify()` to convert our object to a JSON string.\n+\n+The `PUT` method is used to update existing resources of a server. Here’s an example: \n+\n+```js\n+fetch('https://api.example.com/users/45', {\n+  method: '`PUT`',\n+  headers: {\n+    'Content-Type': 'application/json',\n+  },\n+  body: JSON.stringify({\n+    name: 'John Smith',\n+    email: 'john@example.com'\n+  })\n+})\n+```\n+\n+In this example, look carefully at the URL, you can see a `45` at the end. This is typically used as a unique ID to identify the data we are trying to update. We used the `PUT` method on the code and also specified the data as the `body` which will be used to update the identified data. \n+\n+The `DELETE` method is used to delete a resource from the server. Here’s an example:\n+\n+```js\n+fetch('https://api.example.com/users/45', {\n+  method: '`DELETE`',\n+})\n+```\n+\n+In this code, we are including the `DELETE` method and an ID at the end of the url to identify the data which needs to be deleted. \n+\n # --questions--\n \n ## --text--"
        },
        {
            "sha": "9367f1a79d1538f18075f3fc8b0d58f61f829264",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-asynchronous-programming/673407ca21117a67cf9521ca.md",
            "status": "modified",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407ca21117a67cf9521ca.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407ca21117a67cf9521ca.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407ca21117a67cf9521ca.md?ref=26390bee56be2ed85d7c35b62394def077851615",
            "patch": "@@ -10,6 +10,54 @@ dashedName: what-are-promises-and-how-does-promise-chaining-work\n \n Watch the lecture video and answer the questions below.\n \n+# --transcript--\n+\n+What are promises and how does promise chaining work?\n+\n+A `Promise` is an object that represents the eventual completion or failure of an asynchronous operation. It's initially in a pending state. It can then transition to either a fulfilled state when the operation is successful, or a rejected state when the operation fails. Here's an example of creating a `Promise`:\n+\n+```js\n+const aPromise = new Promise((resolve, reject) => {\n+  setTimeout(() => {\n+    resolve(\"Operation successful!\");\n+  }, 1000);\n+});\n+```\n+\n+In this example, we create a promise that simulates an asynchronous operation using `setTimeout`. After one second, the promise is resolved with the message `Operation successful!`.\n+\n+Another way to work with promises is to use the `.then` and `.catch` methods.\n+\n+The `.then()` method is used in a promise to specify what should happen when the promise is fulfilled, while `.catch()` is used to handle any errors that occur. Let's see how we can use `.then` and `.catch` with our promise:\n+\n+```js\n+aPromise.then((result) => {\n+  console.log(result);  // Outputs: \"Operation successful!\"\n+}).catch((error) => {\n+  console.error(error);\n+});\n+```\n+\n+In this code, or instructions of what to do when the promise is fulfilled, the function passed to `.then()` will be called with the resolved value of the promise. If an error occurs, the function passed to `.catch()` will be called instead.\n+\n+Now, let's talk about promise chaining. One of the powerful features of promises is that we can chain multiple asynchronous operations together. Each `.then()` can return a new promise, allowing you to perform a sequence of asynchronous operations one after the other. Here’s an example: \n+\n+```js\n+fetch('https://api.example.com/data')\n+  .then(response => response.json())\n+  .then(data => {\n+    console.log(data);\n+    return fetch('https://api.example.com/data2');\n+  })\n+  .then(response => response.json())\n+  .then(data2 => console.log(data2))\n+  .catch(error => console.error('Error:', error));\n+```\n+\n+In this example, we're making two API calls in sequence. The first `.then()` parses the response as JSON. The second `.then()` logs the data and makes another API call. The third `.then()` parses the response of the second API call, and the fourth `.then()` logs that data. If an error occurs at any point in this chain, it will be caught by the `.catch()` at the end.\n+\n+It's important to note that `.catch()` will catch errors from any of the previous steps in the chain. This means you don't need to add error handling to each individual step, which can greatly simplify your code.\n+\n # --questions--\n \n ## --text--"
        },
        {
            "sha": "e51b382118df2f7f201722e4ce8b258b15228b16",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-asynchronous-programming/673407d56c3dce67fa97969b.md",
            "status": "modified",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407d56c3dce67fa97969b.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407d56c3dce67fa97969b.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407d56c3dce67fa97969b.md?ref=26390bee56be2ed85d7c35b62394def077851615",
            "patch": "@@ -10,6 +10,47 @@ dashedName: what-is-async-await-and-how-does-it-work\n \n Watch the lecture video and answer the questions below.\n \n+# --transcript--\n+\n+What is `async`/`await` and how does it work?\n+\n+In the previous lecture videos, you learned about asynchronous programming which allows other code to run while we wait for some time-consuming tasks to complete, like fetching data from a server, reading data from a file, and so on.\n+\n+`async`/`await`, built on top of promises, makes writing and reading asynchronous code easier. When you put the `async` keyword before a function, it means that function will always return a `Promise`. Only inside an `async` function, you can use the `await` keyword, which allows you to wait for a `Promise` to resolve before moving on to the next line of code. Here's an example to illustrate how `async`/`await` works:\n+\n+```js\n+async function delayedGreeting(name) {\n+  console.log(\"A Messenger entered the chat...\");\n+  await new Promise(resolve => setTimeout(resolve, 2000));\n+  console.log(`Hello, ${name}!`);\n+}\n+\n+delayedGreeting(\"Alice\");\n+console.log(\"First Printed Message!\");\n+```\n+\n+In this code, we define an `async` function called `delayedGreeting`. Inside this function, we use `await` to pause the execution for 2 seconds. After the delay, it prints a greeting. \n+\n+When we call this function, you'll see `First Printed Message!` appear before the greeting. This is because the function is asynchronous - it doesn't block the rest of the code from running.\n+\n+One of the biggest advantages of `async`/`await` is error handling. With promises, we often had to use `.catch()` method to handle errors. With `async`/`await`, we can use `try`/`catch` blocks. Here's an example:\n+\n+```js\n+async function fetchUserData() {\n+  try {\n+    let response = await fetch(`https://api.example.com/users`);\n+    let userData = await response.json();\n+    console.log(userData);\n+  } catch (error) {\n+    console.log(\"Error fetching user data:\", error);\n+  }\n+}\n+\n+fetchUserData();\n+```\n+\n+In this example, we're using `async`/`await` to fetch user data from an API. The `await` keyword is used twice: once to wait for the fetch operation to complete, and again to wait for the JSON parsing to finish. If any error occurs during this process, it will be caught in the `catch` block.\n+\n # --questions--\n \n ## --text--"
        },
        {
            "sha": "3ad84a1470796c697c203faf7739aed1a7d73e71",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-asynchronous-programming/673407e02bcf0d682b9a49a9.md",
            "status": "modified",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407e02bcf0d682b9a49a9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407e02bcf0d682b9a49a9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407e02bcf0d682b9a49a9.md?ref=26390bee56be2ed85d7c35b62394def077851615",
            "patch": "@@ -10,6 +10,33 @@ dashedName: how-does-the-javascript-engine-work-and-what-is-a-javascript-runtime\n \n Watch the lecture video and answer the questions below.\n \n+# --transcript--\n+\n+How does the JavaScript engine work and what is a JavaScript runtime?\n+\n+The JavaScript engine has the ability to read, understand, and execute your code. It works like a converter that takes your code, turns it into instructions that the computer can understand and work accordingly. \n+\n+One of the most well-known JavaScript engines is V8, developed by Google, used in Chrome and Node.js. The JavaScript engine works in a few steps. First, it parses your code, reading it line by line to make sure there’s no mistake in the JavaScript code. Then, it converts this code into bytecode, which is a simpler, intermediate version of your code that’s easier for the computer to understand and execute. Finally, it runs this bytecode to execute your program's instructions. Here's an example of JavaScript code:\n+\n+```js\n+const greeting = \"Hello, World!\";\n+console.log(greeting);\n+```\n+\n+When you run this code, the JavaScript engine first parses it to check for any syntax errors. Parsing means the engine reads the code and breaks it down into a structure it can understand, checking for mistakes along the way. \n+\n+Then, it compiles the code into an intermediate format (often bytecode or machine code, depending on the engine). Compiling is the process of converting the human-readable code into a more efficient format that the computer can execute faster. \n+\n+Finally, the engine executes the code, printing `Hello, World!` to the console.\n+\n+Now, let's talk about the JavaScript runtime. The JavaScript runtime is the environment in which your JavaScript code is executed. It includes the JavaScript engine (like V8 in Chrome or SpiderMonkey in Firefox), which processes and executes the code, as well as additional features provided by the environment (such as a web browser or Node.js, which you will learn more about in future lectures).\n+\n+While the core JavaScript language handles things like variables, loops, and functions, the runtime provides extra tools that allow JavaScript to interact with things outside of the language itself, like the DOM (for web pages) or the Fetch API (for making network requests).\n+\n+In short, the runtime is what allows JavaScript to do more than just basic programming tasks – like interacting with web pages or handling time-based actions – by providing these extra features beyond the language itself.\n+\n+While you don't need to know every detail of engines and runtimes to write JavaScript, having a basic understanding can help you write more efficient code and debug problems more effectively.\n+\n # --questions--\n \n ## --text--"
        },
        {
            "sha": "42b0e4c1c6459801a93b94f2530c8f7b8fe89736",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-asynchronous-programming/673407eb10ca9d68634e81d9.md",
            "status": "modified",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407eb10ca9d68634e81d9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/26390bee56be2ed85d7c35b62394def077851615/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407eb10ca9d68634e81d9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-asynchronous-programming%2F673407eb10ca9d68634e81d9.md?ref=26390bee56be2ed85d7c35b62394def077851615",
            "patch": "@@ -10,6 +10,36 @@ dashedName: what-is-the-geolocation-api-and-how-does-the-getcurrentposition-work\n \n Watch the lecture video and answer the questions below.\n \n+# --transcript--\n+\n+What is the Geolocation API and how does the `getCurrentPosition` work?\n+\n+The Geolocation API provides a way for websites to request the user's location. It's important to note that for privacy reasons, the user has to give permission before their location can be accessed via the website.\n+\n+The main method we'll be focusing on today is `getCurrentPosition`. This method is used to collect the geographic location of the device. Here's an example of how you might use `getCurrentPosition`:\n+\n+```js\n+navigator.geolocation.getCurrentPosition(\n+  (position) => {\n+    console.log(\"Latitude: \" + position.coords.latitude);\n+    console.log(\"Longitude: \" + position.coords.longitude);\n+  },\n+  (error) => {\n+    console.log(\"Error: \" + error.message);\n+  }\n+);\n+```\n+\n+In this code, we're calling `getCurrentPosition` and passing it a function which will be called when the position is successfully obtained. This position object contains various pieces of information, but we're focusing on `latitude` and `longitude` only.\n+\n+If there is an issue with getting the position, then the error will be logged to the console. \n+\n+The `getCurrentPosition` method uses GPS, Wi-Fi networks, or IP address geolocation, depending on the device and its settings. Once the location is found, the success callback function is called with a position object.\n+\n+The position object contains a various properties, where the most commonly used are `latitude` and `longitude`, but it can also include `altitude`, `accuracy`, `speed`, and `heading`, and so on.\n+\n+One important consideration when using geolocation is user privacy. Explain to your users why you need their location data and how you'll use it.\n+\n # --questions--\n \n ## --text--"
        }
    ],
    "stats": {
        "total": 310,
        "additions": 310,
        "deletions": 0
    }
}