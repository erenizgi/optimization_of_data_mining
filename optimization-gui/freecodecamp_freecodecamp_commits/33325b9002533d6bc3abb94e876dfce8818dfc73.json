{
    "author": "huyenltnguyen",
    "message": "feat(client,challenge-parser): update fill-in-the-blank to support Chinese (#63741)",
    "sha": "33325b9002533d6bc3abb94e876dfce8818dfc73",
    "files": [
        {
            "sha": "9742b286812d9ae9a42fa7550652a8117c9062bc",
            "filename": "client/gatsby-node.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/client%2Fgatsby-node.js",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/client%2Fgatsby-node.js",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fgatsby-node.js?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -410,6 +410,7 @@ exports.createSchemaCustomization = ({ actions }) => {\n     type FillInTheBlank {\n       sentence: String\n       blanks: [Blank]\n+      inputType: String\n     }\n     type Blank {\n       answer: String"
        },
        {
            "sha": "4a953cce415fc7edf137c08f03c95683f94e4295",
            "filename": "client/src/redux/prop-types.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/client%2Fsrc%2Fredux%2Fprop-types.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/client%2Fsrc%2Fredux%2Fprop-types.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Fredux%2Fprop-types.ts?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -49,6 +49,7 @@ export type Question = {\n export type FillInTheBlank = {\n   sentence: string;\n   blanks: MultipleChoiceAnswer[];\n+  inputType?: 'pinyin-tone' | 'pinyin-to-hanzi';\n };\n \n export type Fields = {"
        },
        {
            "sha": "41a840e6c7d74f4615a2e870a6e661a3831ec1eb",
            "filename": "client/src/templates/Challenges/components/fill-in-the-blanks.tsx",
            "status": "modified",
            "additions": 46,
            "deletions": 8,
            "changes": 54,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Ffill-in-the-blanks.tsx",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Ffill-in-the-blanks.tsx",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Ffill-in-the-blanks.tsx?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -2,7 +2,7 @@ import React from 'react';\n import { useTranslation } from 'react-i18next';\n import { Spacer } from '@freecodecamp/ui';\n \n-import { parseBlanks } from '../fill-in-the-blank/parse-blanks';\n+import { parseBlanks, parseAnswer } from '../fill-in-the-blank/parse-blanks';\n import PrismFormatted from '../components/prism-formatted';\n import { FillInTheBlank } from '../../../redux/prop-types';\n import ChallengeHeading from './challenge-heading';\n@@ -16,6 +16,23 @@ type FillInTheBlankProps = {\n   handleInputChange: (inputIndex: number, value: string) => void;\n };\n \n+const AnswerText = ({ answer }: { answer: string }) => {\n+  const parsedAnswer = parseAnswer(answer);\n+\n+  if (typeof parsedAnswer === 'string') {\n+    return <span className='correct-blank-answer'>{parsedAnswer}</span>;\n+  }\n+\n+  return (\n+    <ruby className='correct-blank-answer'>\n+      {parsedAnswer.hanzi}\n+      <rp>(</rp>\n+      <rt>{parsedAnswer.pinyin}</rt>\n+      <rp>)</rp>\n+    </ruby>\n+  );\n+};\n+\n function FillInTheBlanks({\n   fillInTheBlank: { sentence, blanks },\n   answersCorrect,\n@@ -36,6 +53,17 @@ function FillInTheBlanks({\n     return cls;\n   };\n \n+  const getAnswerLength = (answer: string): number => {\n+    const parsedAnswer = parseAnswer(answer);\n+\n+    if (typeof parsedAnswer === 'string') {\n+      return parsedAnswer.length;\n+    }\n+\n+    // TODO: This is a simplification. Revisit later to account for tones and spaces.\n+    return parsedAnswer.pinyin.length;\n+  };\n+\n   const paragraphs = parseBlanks(sentence);\n   const blankAnswers = blanks.map(b => b.answer);\n \n@@ -55,25 +83,35 @@ function FillInTheBlanks({\n                   return value;\n                 }\n \n-                // If a blank is answered correctly, render the answer as part of the sentence.\n-                if (type === 'blank' && answersCorrect[value] === true) {\n+                if (type === 'hanzi-pinyin') {\n+                  const { hanzi, pinyin } = value;\n                   return (\n-                    <span key={j} className='correct-blank-answer'>\n-                      {blankAnswers[value]}\n-                    </span>\n+                    <ruby key={j}>\n+                      {hanzi}\n+                      <rp>(</rp>\n+                      <rt>{pinyin}</rt>\n+                      <rp>)</rp>\n+                    </ruby>\n                   );\n                 }\n \n+                // If a blank is answered correctly, render the answer as part of the sentence.\n+                if (type === 'blank' && answersCorrect[value] === true) {\n+                  return <AnswerText key={j} answer={blankAnswers[value]} />;\n+                }\n+\n+                const answerLength = getAnswerLength(blankAnswers[value]);\n+\n                 return (\n                   <input\n                     key={j}\n                     type='text'\n-                    maxLength={blankAnswers[value].length + 3}\n+                    maxLength={answerLength + 3}\n                     className={getInputClass(value)}\n                     onChange={e =>\n                       handleInputChange(node.value, e.target.value)\n                     }\n-                    size={blankAnswers[value].length}\n+                    size={answerLength}\n                     autoComplete='off'\n                     aria-label={t('learn.fill-in-the-blank.blank')}\n                     {...(answersCorrect[value] === false"
        },
        {
            "sha": "4acf583d6f23a2c567e9f28128c6c83235c32c56",
            "filename": "client/src/templates/Challenges/fill-in-the-blank/parse-blanks.test.ts",
            "status": "modified",
            "additions": 222,
            "deletions": 1,
            "changes": 223,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fparse-blanks.test.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fparse-blanks.test.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fparse-blanks.test.ts?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -1,5 +1,9 @@\n import { describe, it, expect } from 'vitest';\n-import { parseBlanks } from './parse-blanks';\n+import {\n+  parseBlanks,\n+  parseHanziPinyinPairs,\n+  parseAnswer\n+} from './parse-blanks';\n \n describe('parseBlanks', () => {\n   it('handles strings without blanks', () => {\n@@ -129,4 +133,221 @@ describe('parseBlanks', () => {\n     expect(() => parseBlanks('<p>hello BLANK!</p>hello BLANK!')).toThrow();\n     expect(() => parseBlanks('hello BLANK!<p>hello</p>')).toThrow();\n   });\n+\n+  it('handles Chinese with single BLANK', () => {\n+    expect(\n+      parseBlanks('<p>BLANK<ruby>好<rp>(</rp><rt>hǎo</rt><rp>)</rp></ruby></p>')\n+    ).toEqual([\n+      [\n+        { type: 'blank', value: 0 },\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '好', pinyin: 'hǎo' }\n+        }\n+      ]\n+    ]);\n+  });\n+\n+  it('handles Chinese without pinyin', () => {\n+    expect(parseBlanks('<p>你BLANK好</p>')).toEqual([\n+      [\n+        { type: 'text', value: '你' },\n+        { type: 'blank', value: 0 },\n+        { type: 'text', value: '好' }\n+      ]\n+    ]);\n+  });\n+\n+  it('handles Chinese with multiple BLANKs', () => {\n+    expect(\n+      parseBlanks(\n+        '<p>BLANK<ruby>好<rp>(</rp><rt>hǎo</rt><rp>)</rp></ruby>，BLANK<ruby>是王华<rp>(</rp><rt>shì Wang Hua</rt><rp>)</rp></ruby></p>'\n+      )\n+    ).toEqual([\n+      [\n+        { type: 'blank', value: 0 },\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '好', pinyin: 'hǎo' }\n+        },\n+        { type: 'text', value: '，' },\n+        { type: 'blank', value: 1 },\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '是王华', pinyin: 'shì Wang Hua' }\n+        }\n+      ]\n+    ]);\n+  });\n+\n+  it('handles Chinese with multiple adjacent BLANKs', () => {\n+    expect(\n+      parseBlanks(\n+        '<p>BLANK BLANK<ruby>好<rp>(</rp><rt>hǎo</rt><rp>)</rp></ruby></p>'\n+      )\n+    ).toEqual([\n+      [\n+        { type: 'blank', value: 0 },\n+        { type: 'text', value: ' ' },\n+        { type: 'blank', value: 1 },\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '好', pinyin: 'hǎo' }\n+        }\n+      ]\n+    ]);\n+  });\n+\n+  it('handles Chinese with BLANK at the end', () => {\n+    expect(\n+      parseBlanks(\n+        '<p><ruby>你好<rp>(</rp><rt>nǐ hǎo</rt><rp>)</rp></ruby>BLANK</p>'\n+      )\n+    ).toEqual([\n+      [\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '你好', pinyin: 'nǐ hǎo' }\n+        },\n+        { type: 'blank', value: 0 }\n+      ]\n+    ]);\n+  });\n+\n+  it('handles Chinese with spaces around BLANK', () => {\n+    expect(\n+      parseBlanks(\n+        '<p><ruby>你<rp>(</rp><rt>nǐ</rt><rp>)</rp></ruby> BLANK <ruby>我<rp>(</rp><rt>wǒ</rt><rp>)</rp></ruby></p>'\n+      )\n+    ).toEqual([\n+      [\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '你', pinyin: 'nǐ' }\n+        },\n+        { type: 'text', value: ' ' },\n+        { type: 'blank', value: 0 },\n+        { type: 'text', value: ' ' },\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '我', pinyin: 'wǒ' }\n+        }\n+      ]\n+    ]);\n+  });\n+\n+  it('handles Latin text adjacent to BLANK', () => {\n+    expect(\n+      parseBlanks(\n+        '<p><ruby>我<rp>(</rp><rt>wǒ</rt><rp>)</rp></ruby> BLANK UI <ruby>设计师<rp>(</rp><rt>shè jì shī</rt><rp>)</rp></ruby> 。</p>'\n+      )\n+    ).toEqual([\n+      [\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '我', pinyin: 'wǒ' }\n+        },\n+        { type: 'text', value: ' ' },\n+        { type: 'blank', value: 0 },\n+        { type: 'text', value: ' UI ' },\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '设计师', pinyin: 'shè jì shī' }\n+        },\n+        { type: 'text', value: ' 。' }\n+      ]\n+    ]);\n+  });\n+\n+  it('handles Chinese with multiple separate groups', () => {\n+    expect(\n+      parseBlanks(\n+        '<p>BLANK<ruby>好<rp>(</rp><rt>hǎo</rt><rp>)</rp></ruby>，<ruby>我是王华<rp>(</rp><rt>wǒ shì Wang Hua</rt><rp>)</rp></ruby>，<ruby>请问你<rp>(</rp><rt>qǐng wèn nǐ</rt><rp>)</rp></ruby>BLANK<ruby>什么名字<rp>(</rp><rt>shén me míng zi</rt><rp>)</rp></ruby>？</p>'\n+      )\n+    ).toEqual([\n+      [\n+        { type: 'blank', value: 0 },\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '好', pinyin: 'hǎo' }\n+        },\n+        { type: 'text', value: '，' },\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '我是王华', pinyin: 'wǒ shì Wang Hua' }\n+        },\n+        { type: 'text', value: '，' },\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '请问你', pinyin: 'qǐng wèn nǐ' }\n+        },\n+        { type: 'blank', value: 1 },\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '什么名字', pinyin: 'shén me míng zi' }\n+        },\n+        { type: 'text', value: '？' }\n+      ]\n+    ]);\n+  });\n+\n+  it('handles Chinese ruby with trailing punctuation', () => {\n+    expect(\n+      parseBlanks(\n+        '<p><ruby>你是刘明吗<rp>(</rp><rt>nǐ shì Liu Ming ma</rt><rp>)</rp></ruby>？</p>'\n+      )\n+    ).toEqual([\n+      [\n+        {\n+          type: 'hanzi-pinyin',\n+          value: { hanzi: '你是刘明吗', pinyin: 'nǐ shì Liu Ming ma' }\n+        },\n+        { type: 'text', value: '？' }\n+      ]\n+    ]);\n+  });\n+});\n+\n+describe('parseHanziPinyinPairs', () => {\n+  it('parseHanziPinyinPairs returns array with one pair for well-formed input', () => {\n+    const result = parseHanziPinyinPairs('你好 (nǐ hǎo)');\n+    expect(result).toHaveLength(1);\n+    expect(result[0]).toEqual({\n+      hanzi: '你好',\n+      pinyin: 'nǐ hǎo'\n+    });\n+  });\n+\n+  it('parseHanziPinyinPairs handles parentheses without a space', () => {\n+    const result = parseHanziPinyinPairs('你好(nǐ hǎo)');\n+    expect(result).toHaveLength(1);\n+    expect(result[0]).toEqual({\n+      hanzi: '你好',\n+      pinyin: 'nǐ hǎo'\n+    });\n+  });\n+\n+  it('parseHanziPinyinPairs returns empty array for non-matching input', () => {\n+    expect(parseHanziPinyinPairs('hello')).toEqual([]);\n+  });\n+\n+  it('parseAnswer returns parsed object when pattern matches', () => {\n+    expect(parseAnswer('你好 (nǐ hǎo)')).toEqual({\n+      hanzi: '你好',\n+      pinyin: 'nǐ hǎo'\n+    });\n+  });\n+});\n+\n+describe('parseAnswer', () => {\n+  it('parseAnswer returns hanzi-pinyin string when pattern matches', () => {\n+    expect(parseAnswer('你好(nǐ hǎo)')).toEqual({\n+      hanzi: '你好',\n+      pinyin: 'nǐ hǎo'\n+    });\n+  });\n+\n+  it('parseAnswer returns original string when pattern does not match', () => {\n+    expect(parseAnswer('just some text')).toBe('just some text');\n+  });\n });"
        },
        {
            "sha": "54358a8a73701f0b663da99b80b3a80d7defc952",
            "filename": "client/src/templates/Challenges/fill-in-the-blank/parse-blanks.ts",
            "status": "modified",
            "additions": 132,
            "deletions": 22,
            "changes": 154,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fparse-blanks.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fparse-blanks.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fparse-blanks.ts?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -1,6 +1,48 @@\n-type TextNode = { type: 'text'; value: string };\n+type PlainTextNode = {\n+  type: 'text';\n+  value: string;\n+};\n+\n+// Hanzi/pinyin node representing an inline pronunciation pair\n+type HanziPinyinNode = {\n+  type: 'hanzi-pinyin';\n+  value: { hanzi: string; pinyin: string };\n+};\n+\n type BlankNode = { type: 'blank'; value: number };\n-type ParagraphElement = TextNode | BlankNode;\n+\n+type ParagraphElement = PlainTextNode | BlankNode | HanziPinyinNode;\n+\n+/**\n+ * Parses all hanzi-pinyin pairs from text\n+ * @param text - Text potentially containing hanzi (pinyin) patterns\n+ * @returns Array of parsed hanzi and pinyin pairs\n+ */\n+export function parseHanziPinyinPairs(\n+  text: string\n+): Array<{ hanzi: string; pinyin: string }> {\n+  const pairs: Array<{ hanzi: string; pinyin: string }> = [];\n+  const regex = /([^()]+?)\\s*\\(([^)]+)\\)/g;\n+  let match;\n+\n+  while ((match = regex.exec(text)) !== null) {\n+    pairs.push({\n+      hanzi: match[1].trim(),\n+      pinyin: match[2].trim()\n+    });\n+  }\n+\n+  return pairs;\n+}\n+\n+export function parseAnswer(\n+  text: string\n+): { hanzi: string; pinyin: string } | string {\n+  const pairs = parseHanziPinyinPairs(text);\n+  const hanziPinyin = pairs.length === 1 ? pairs[0] : null;\n+\n+  return hanziPinyin || text;\n+}\n \n export const parseBlanks = (text: string) => {\n   const trimmed = text.trim();\n@@ -19,27 +61,14 @@ to be wrapped in <p> tags`);\n \n   const { paragraphs } = rawParagraphs.reduce(\n     (acc, p) => {\n-      const splitByBlank = p.split('BLANK');\n-\n-      const parsedParagraph = splitByBlank\n-        .map<ParagraphElement[]>((text, i) => [\n-          { type: 'text', value: text },\n-          { type: 'blank', value: acc.count + i }\n-        ])\n-        .flat();\n-      parsedParagraph.pop(); // remove last blank\n-\n-      const paragraph = parsedParagraph.filter(p => {\n-        // remove empty strings\n-        if (p.type === 'text') {\n-          return p.value;\n-        } else {\n-          return true;\n-        }\n-      });\n+      const containsRuby = /<ruby>/.test(p);\n+      const { elements, blankCount } = containsRuby\n+        ? parseChineseParagraph(p, acc.count)\n+        : parsePlainParagraph(p, acc.count);\n+\n       return {\n-        count: acc.count + splitByBlank.length - 1,\n-        paragraphs: [...acc.paragraphs, paragraph]\n+        count: acc.count + blankCount,\n+        paragraphs: [...acc.paragraphs, elements]\n       };\n     },\n     { count: 0, paragraphs: [] } as {\n@@ -50,3 +79,84 @@ to be wrapped in <p> tags`);\n \n   return paragraphs;\n };\n+\n+/**\n+ * Parses a paragraph that contains ruby HTML elements (Chinese hanzi-pinyin)\n+ * Handles multiple ruby elements separated by text and BLANK tokens\n+ */\n+function parseChineseParagraph(\n+  paragraph: string,\n+  startingBlankIndex: number\n+): { elements: ParagraphElement[]; blankCount: number } {\n+  const elements: ParagraphElement[] = [];\n+  let blankIndex = startingBlankIndex;\n+\n+  // First, split the paragraph on BLANK tokens so we can add blanks between segments\n+  const segments = paragraph.split('BLANK');\n+\n+  for (let s = 0; s < segments.length; s++) {\n+    const segment = segments[s];\n+\n+    // Split the segment into text and ruby parts. Capturing group keeps the ruby tags.\n+    const parts = segment.split(/(<ruby>.*?<\\/ruby>)/g).filter(Boolean);\n+\n+    for (const part of parts) {\n+      if (part.startsWith('<ruby>')) {\n+        const rubyMatch = part.match(\n+          /^<ruby>([^<]+)<rp>\\(<\\/rp><rt>([^<]+)<\\/rt><rp>\\)<\\/rp><\\/ruby>$/\n+        );\n+        if (rubyMatch) {\n+          elements.push({\n+            type: 'hanzi-pinyin',\n+            value: { hanzi: rubyMatch[1], pinyin: rubyMatch[2] }\n+          });\n+        }\n+      } else if (part) {\n+        elements.push({ type: 'text', value: part });\n+      }\n+    }\n+\n+    // After each segment except the last, insert a blank node.\n+    if (s < segments.length - 1) {\n+      elements.push({ type: 'blank', value: blankIndex });\n+      blankIndex++;\n+    }\n+  }\n+\n+  return {\n+    elements,\n+    blankCount: blankIndex - startingBlankIndex\n+  };\n+}\n+\n+/**\n+ * Parses a plain (non-Chinese) paragraph\n+ */\n+function parsePlainParagraph(\n+  paragraph: string,\n+  startingBlankIndex: number\n+): { elements: ParagraphElement[]; blankCount: number } {\n+  const splitByBlank = paragraph.split('BLANK');\n+\n+  const parsedParagraph = splitByBlank\n+    .map<ParagraphElement[]>((text, i) => [\n+      { type: 'text', value: text },\n+      { type: 'blank', value: startingBlankIndex + i }\n+    ])\n+    .flat();\n+\n+  // remove last blank inserted by the mapping\n+  parsedParagraph.pop();\n+\n+  const elements = parsedParagraph.filter(p => {\n+    if (p.type === 'text') {\n+      return p.value;\n+    }\n+    return true;\n+  });\n+\n+  return {\n+    elements,\n+    blankCount: splitByBlank.length - 1\n+  };\n+}"
        },
        {
            "sha": "4c95ab326303190fb95a579943551122163c5754",
            "filename": "client/src/templates/Challenges/fill-in-the-blank/show.tsx",
            "status": "modified",
            "additions": 23,
            "deletions": 6,
            "changes": 29,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fshow.tsx",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fshow.tsx",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fshow.tsx?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -35,6 +35,7 @@ import { SceneSubject } from '../components/scene/scene-subject';\n import { getChallengePaths } from '../utils/challenge-paths';\n import { isChallengeCompletedSelector } from '../redux/selectors';\n import { replaceAppleQuotes } from '../../../utils/replace-apple-quotes';\n+import { parseHanziPinyinPairs } from './parse-blanks';\n \n import './show.css';\n \n@@ -135,12 +136,27 @@ const ShowFillInTheBlank = ({\n   const handleSubmit = () => {\n     const blankAnswers = fillInTheBlank.blanks.map(b => b.answer);\n \n-    const newAnswersCorrect = userAnswers.map(\n-      (userAnswer, i) =>\n-        !!userAnswer &&\n-        replaceAppleQuotes(userAnswer.trim()).toLowerCase() ===\n-          blankAnswers[i].toLowerCase()\n-    );\n+    const newAnswersCorrect = userAnswers.map((userAnswer, i) => {\n+      if (!userAnswer) return false;\n+\n+      const answer = blankAnswers[i];\n+      const normalizedUserAnswer = replaceAppleQuotes(\n+        userAnswer.trim()\n+      ).toLowerCase();\n+\n+      const pairs = parseHanziPinyinPairs(answer);\n+      const hanziPinyin = pairs.length === 1 ? pairs[0] : null;\n+\n+      if (hanziPinyin) {\n+        const { hanzi } = hanziPinyin;\n+        // TODO: Implement full hanzi-pinyin validation logic\n+        // https://github.com/freeCodeCamp/language-curricula/issues/18\n+        return normalizedUserAnswer === hanzi;\n+      }\n+\n+      return normalizedUserAnswer === answer.toLowerCase();\n+    });\n+\n     setAnswersCorrect(newAnswersCorrect);\n     const hasWrongAnswer = newAnswersCorrect.some(a => a === false);\n     if (!hasWrongAnswer) {\n@@ -294,6 +310,7 @@ export const query = graphql`\n             answer\n             feedback\n           }\n+          inputType\n         }\n         tests {\n           text"
        },
        {
            "sha": "1df94dbe2a56bf28213a22d0a41e40b693972c97",
            "filename": "curriculum/challenges/english/blocks/zh-a1-learn-understanding-the-questions-and-answers/6904b3933a383d68ec0e5f0d.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fzh-a1-learn-understanding-the-questions-and-answers%2F6904b3933a383d68ec0e5f0d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fzh-a1-learn-understanding-the-questions-and-answers%2F6904b3933a383d68ec0e5f0d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fzh-a1-learn-understanding-the-questions-and-answers%2F6904b3933a383d68ec0e5f0d.md?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -54,4 +54,4 @@ That is part of the question, but not how she politely begins it.\n \n `请问 (qǐng wèn)` means \"excuse me\". It's often used at the start of a question to sound polite. For example:\n \n-`请问你是刘明吗？(qǐng wèn nǐ shì Liu Ming ma)` – Excuse me, are you Liu Ming?\n+`请问你是刘明吗 (qǐng wèn nǐ shì Liu Ming ma)？` – Excuse me, are you Liu Ming?"
        },
        {
            "sha": "8922c28d1eec6ee2c8176483531d46f6302d9fc3",
            "filename": "curriculum/challenges/english/blocks/zh-a1-learn-understanding-the-questions-and-answers/6904bfa12f761c705b37b377.md",
            "status": "modified",
            "additions": 3,
            "deletions": 7,
            "changes": 10,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fzh-a1-learn-understanding-the-questions-and-answers%2F6904bfa12f761c705b37b377.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fzh-a1-learn-understanding-the-questions-and-answers%2F6904bfa12f761c705b37b377.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fzh-a1-learn-understanding-the-questions-and-answers%2F6904bfa12f761c705b37b377.md?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -21,24 +21,20 @@ Listen to the audio and complete the sentence below.\n \n ## --sentence--\n \n-`你好，我是王华，请问BLANK叫什么名字？(nǐ hǎo wǒ shì Wang Hua qǐng wèn BLANK jiào shén me míng zi)`\n+`你好 (nǐ hǎo)，我是王华 (wǒ shì Wang Hua)，请问 (qǐng wèn) BLANK 叫什么名字 (jiào shén me míng zi)？`\n \n ## --blanks--\n \n-`你`\n+`你 (nǐ)`\n \n ### --feedback--\n \n This word means \"you\" and refers to someone you are speaking to.\n \n----\n-\n-`nǐ`\n-\n # --explanation--\n \n `你 (nǐ)` means \"you\". It's used to talk directly to another person. For example:\n \n-`你是刘明吗？(nǐ shì Liu Ming ma)` – Are you Liu Ming?\n+`你是刘明吗 (nǐ shì Liu Ming ma)？` – Are you Liu Ming?\n \n You've learned how to use `我 (wǒ)` to refer to yourself. Both `我 (wǒ)` and `你 (nǐ)` are **personal pronouns**, which means they are used to refer to people."
        },
        {
            "sha": "b0d8e56a38412db6bac196895ff620c9521419e4",
            "filename": "curriculum/challenges/english/blocks/zh-a1-learn-understanding-the-questions-and-answers/6904c3aaa0b7a0757ffc4d2b.md",
            "status": "modified",
            "additions": 3,
            "deletions": 7,
            "changes": 10,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fzh-a1-learn-understanding-the-questions-and-answers%2F6904c3aaa0b7a0757ffc4d2b.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fzh-a1-learn-understanding-the-questions-and-answers%2F6904c3aaa0b7a0757ffc4d2b.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fzh-a1-learn-understanding-the-questions-and-answers%2F6904c3aaa0b7a0757ffc4d2b.md?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -21,22 +21,18 @@ Listen to the audio and complete the sentence below.\n \n ## --sentence--\n \n-`你好，我是王华，请问你BLANK什么名字？ (nǐ hǎo wǒ shì Wang Hua qǐng wèn nǐ BLANK shén me míng zi)`\n+`你好 (nǐ hǎo)，我是王华 (wǒ shì Wang Hua)，请问你 (qǐng wèn nǐ) BLANK 什么名字 (shén me míng zi)？`\n \n ## --blanks--\n \n-`叫`\n+`叫 (jiào)`\n \n ### --feedback--\n \n This character means \"to be called\" or \"to be named\".\n \n----\n-\n-`jiào`\n-\n # --explanation--\n \n `叫 (jiào)` means \"to be called\". It's often used after a subject to introduce a name. For example:\n \n-`我叫王华。(wǒ jiào Wang Hua)` – I am called Wang Hua.\n+`我叫王华 (wǒ jiào Wang Hua)。` – I am called Wang Hua."
        },
        {
            "sha": "7527714690478ccc1d090fe735cd8a530a5929b4",
            "filename": "curriculum/challenges/english/blocks/zh-a1-learn-understanding-the-questions-and-answers/6904c51ee5d1fb78335b71bf.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fzh-a1-learn-understanding-the-questions-and-answers%2F6904c51ee5d1fb78335b71bf.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fzh-a1-learn-understanding-the-questions-and-answers%2F6904c51ee5d1fb78335b71bf.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fzh-a1-learn-understanding-the-questions-and-answers%2F6904c51ee5d1fb78335b71bf.md?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -52,4 +52,4 @@ She isn't asking where the person is from.\n \n # --explanation--\n \n-`什么名字 (shén me míng zi)` means \"what name\". `你叫什么名字？(nǐ jiào shén me míng zi)` means \"what is your name?\". Wang Hua is asking for the other person's name.\n+`什么名字 (shén me míng zi)` means \"what name\". `你叫什么名字 (nǐ jiào shén me míng zi)？` means \"what is your name?\". Wang Hua is asking for the other person's name."
        },
        {
            "sha": "b4b34250ac63b22f5cd3b128bf58dfc6e18f4b40",
            "filename": "curriculum/schema/challenge-schema.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/curriculum%2Fschema%2Fchallenge-schema.js",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/curriculum%2Fschema%2Fchallenge-schema.js",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fschema%2Fchallenge-schema.js?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -228,7 +228,8 @@ const schema = Joi.object().keys({\n           feedback: Joi.string().allow(null)\n         })\n       )\n-      .required()\n+      .required(),\n+    inputType: Joi.string().valid('pinyin-tone', 'pinyin-to-hanzi').optional()\n   }),\n   forumTopicId: Joi.number(),\n   id: Joi.objectId().required(),"
        },
        {
            "sha": "8872947d889bc955044dc0b056d4a0414c4a17bc",
            "filename": "tools/challenge-parser/parser/__fixtures__/with-chinese-fill-in-the-blank-blank-answer-mismatch.md",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-blank-answer-mismatch.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-blank-answer-mismatch.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-blank-answer-mismatch.md?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -0,0 +1,9 @@\n+# --fillInTheBlank--\n+\n+## --sentence--\n+\n+`BLANK BLANK`\n+\n+## --blanks--\n+\n+`你 (nǐ)`\n\\ No newline at end of file"
        },
        {
            "sha": "ada003169f129bf4a16f1dbaa8d915252f30d32e",
            "filename": "tools/challenge-parser/parser/__fixtures__/with-chinese-fill-in-the-blank-latin.md",
            "status": "added",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-latin.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-latin.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-latin.md?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -0,0 +1,17 @@\n+# --fillInTheBlank--\n+\n+## --sentence--\n+\n+`我 (wǒ) BLANK UI 设计师 (shè jì shī) 。`\n+\n+## --blanks--\n+\n+`是 (shì)`\n+\n+### --feedback--\n+\n+Feedback text.\n+\n+# --explanation--\n+\n+Explanation text.\n\\ No newline at end of file"
        },
        {
            "sha": "b084fde5b4a11bad41aab01a4119f5cead9dc20b",
            "filename": "tools/challenge-parser/parser/__fixtures__/with-chinese-fill-in-the-blank-no-blanks.md",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-no-blanks.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-no-blanks.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-no-blanks.md?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -0,0 +1,9 @@\n+# --fillInTheBlank--\n+\n+## --sentence--\n+\n+`你好 (nǐ hǎo)`\n+\n+## --blanks--\n+\n+`你`\n\\ No newline at end of file"
        },
        {
            "sha": "ce334bee91c5b94827f967b584fef9f6db40aac8",
            "filename": "tools/challenge-parser/parser/__fixtures__/with-chinese-fill-in-the-blank-no-hanzi.md",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-no-hanzi.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-no-hanzi.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-no-hanzi.md?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -0,0 +1,9 @@\n+# --fillInTheBlank--\n+\n+## --sentence--\n+\n+`BLANK hǎo`\n+\n+## --blanks--\n+\n+`nǐ`\n\\ No newline at end of file"
        },
        {
            "sha": "386c7c272d7d00ee2c9ea9e2395207279163e34a",
            "filename": "tools/challenge-parser/parser/__fixtures__/with-chinese-fill-in-the-blank-no-pinyin.md",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-no-pinyin.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-no-pinyin.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-no-pinyin.md?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -0,0 +1,9 @@\n+# --fillInTheBlank--\n+\n+## --sentence--\n+\n+`BLANK好`\n+\n+## --blanks--\n+\n+`你 (nǐ)`\n\\ No newline at end of file"
        },
        {
            "sha": "ca01d3dc71bbd16e4db55f6ea18b585cc1603f46",
            "filename": "tools/challenge-parser/parser/__fixtures__/with-chinese-fill-in-the-blank-wrong-answer-format.md",
            "status": "added",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-wrong-answer-format.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-wrong-answer-format.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank-wrong-answer-format.md?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -0,0 +1,13 @@\n+# --fillInTheBlank--\n+\n+## --sentence--\n+\n+`BLANK 好 (hǎo) BLANK`\n+\n+## --blanks--\n+\n+`你`\n+\n+---\n+\n+`nǐ`\n\\ No newline at end of file"
        },
        {
            "sha": "eb7d1a58e5b0b92a13b523b78d6526bf07b3336b",
            "filename": "tools/challenge-parser/parser/__fixtures__/with-chinese-fill-in-the-blank.md",
            "status": "added",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-fill-in-the-blank.md?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -0,0 +1,46 @@\n+---\n+lang: zh-CN\n+inputType: pinyin-to-hanzi\n+---\n+\n+# --fillInTheBlank--\n+\n+## --sentence--\n+\n+`BLANK BLANK，BLANK 是王华 (shì Wang Hua)，请问你 (qǐng wèn nǐ) BLANK 什么名字 (shén me míng zi)？`\n+\n+## --blanks--\n+\n+`你 (nǐ)`\n+\n+### --feedback--\n+\n+Feedback text containing `汉字 (hàn zì)`.\n+\n+---\n+\n+`好 (hǎo)`\n+\n+### --feedback--\n+\n+This means \"good\" or \"well\".\n+\n+---\n+\n+`我 (wǒ)`\n+\n+### --feedback--\n+\n+This means \"I\".\n+\n+---\n+\n+`叫 (jiào)`\n+\n+### --feedback--\n+\n+This means \"to be called\".\n+\n+# --explanation--\n+\n+Explanation text containing `汉字 (hàn zì)`."
        },
        {
            "sha": "fceeae221d3eaccf07b54ad5b1fc43c673b0b5eb",
            "filename": "tools/challenge-parser/parser/__fixtures__/with-chinese-mcq.md",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-mcq.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-mcq.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fchallenge-parser%2Fparser%2F__fixtures__%2Fwith-chinese-mcq.md?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -49,4 +49,6 @@ Feedback text.\n \n # --explanation--\n \n-Wang Hua uses `请问 (qǐng wèn)` to politely start her question.\n\\ No newline at end of file\n+`我是 (wǒ shì) Web 开发者 (kāi fā zhě)。` – I am a web developer.\n+\n+`你好 (nǐ hǎo)，我是王华 (wǒ shì Wang Hua)，请问你叫什么名字 (qǐng wèn nǐ jiào shén me míng zi)？` – Hello, I am Wang Hua, may I ask what your name is?\n\\ No newline at end of file"
        },
        {
            "sha": "ce35d6204dbcdcca85e263016d95a8210dde5833",
            "filename": "tools/challenge-parser/parser/plugins/add-fill-in-the-blank.js",
            "status": "modified",
            "additions": 92,
            "deletions": 52,
            "changes": 144,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Fadd-fill-in-the-blank.js",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Fadd-fill-in-the-blank.js",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Fadd-fill-in-the-blank.js?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -3,8 +3,10 @@ const find = require('unist-util-find');\n const visit = require('unist-util-visit');\n const { getSection } = require('./utils/get-section');\n const getAllBefore = require('./utils/before-heading');\n-const mdastToHtml = require('./utils/mdast-to-html');\n-\n+const {\n+  createMdastToHtml,\n+  parseHanziPinyinPairs\n+} = require('./utils/i18n-stringify');\n const { splitOnThematicBreak } = require('./utils/split-on-thematic-break');\n \n const NOT_IN_PARAGRAPHS = `Each inline code block in the fillInTheBlank sentence section must in its own paragraph\n@@ -40,19 +42,102 @@ function plugin() {\n     if (fillInTheBlankNodes.length > 0) {\n       const fillInTheBlankTree = root(fillInTheBlankNodes);\n \n-      validateBlanksCount(fillInTheBlankTree);\n+      validateBlanksSectionCount(fillInTheBlankTree);\n \n       const sentenceNodes = getSection(fillInTheBlankTree, '--sentence--');\n       const blanksNodes = getSection(fillInTheBlankTree, '--blanks--');\n \n-      const fillInTheBlank = getfillInTheBlank(sentenceNodes, blanksNodes);\n-\n-      file.data.fillInTheBlank = fillInTheBlank;\n+      const lang = file.data.lang;\n+      const inputType = file.data.inputType;\n+      const toHtml = createMdastToHtml(lang);\n+\n+      file.data.fillInTheBlank = getFillInTheBlank(sentenceNodes, blanksNodes);\n+\n+      function getFillInTheBlank(sentenceNodes, blanksNodes) {\n+        const sentenceWithoutCodeBlocks = sentenceNodes.map(node => {\n+          node.children.forEach(child => {\n+            if (child.type === 'text' && child.value.trim() === '')\n+              throw Error(NOT_IN_PARAGRAPHS);\n+            if (child.type !== 'inlineCode') throw Error(NOT_IN_CODE_BLOCK);\n+          });\n+\n+          // For Chinese hanzi-pinyin, keep as inlineCode so handler generates ruby elements\n+          if (lang === 'zh-CN') {\n+            const hasChinesePairs = node.children.some(\n+              child =>\n+                child.type === 'inlineCode' &&\n+                parseHanziPinyinPairs(child.value).length > 0\n+            );\n+\n+            if (hasChinesePairs) {\n+              return node;\n+            }\n+          }\n+\n+          // Convert inlineCode to text for non-Chinese content\n+          const children = node.children.map(child => ({\n+            ...child,\n+            type: 'text'\n+          }));\n+          return { ...node, children };\n+        });\n+\n+        const sentence = toHtml(sentenceWithoutCodeBlocks);\n+        const blanks = getBlanks(blanksNodes);\n+\n+        if (!sentence)\n+          throw Error('sentence is missing from fill in the blank');\n+        if (!blanks) throw Error('blanks are missing from fill in the blank');\n+        if (sentence.match(/BLANK/g).length !== blanks.length)\n+          throw Error(`Number of BLANKs doesn't match the number of answers.`);\n+\n+        // For 'pinyin-to-hanzi' inputType, all answers must be of type 'hanzi-pinyin'.\n+        // This validation ensures compatibility with the pinyin input in the UI,\n+        // where users type pinyin and the system automatically converts it to hanzi\n+        // if the input value matches the expected pinyin from the answer.\n+        if (inputType === 'pinyin-to-hanzi') {\n+          const allAnswersAreHanziPinyin = blanks.every(\n+            blank => parseHanziPinyinPairs(blank.answer).length === 1\n+          );\n+\n+          if (!allAnswersAreHanziPinyin) {\n+            throw Error(\n+              `When inputType is 'pinyin-to-hanzi', all answers must be in 'hanzi (pinyin)' format.`\n+            );\n+          }\n+        }\n+\n+        return { sentence, blanks, ...(inputType && { inputType }) };\n+      }\n+\n+      function getBlanks(blanksNodes) {\n+        const blanksGroups = splitOnThematicBreak(blanksNodes);\n+\n+        return blanksGroups.map(blanksGroup => {\n+          const blanksTree = root(blanksGroup);\n+          const feedback = find(blanksTree, { value: '--feedback--' });\n+\n+          if (feedback) {\n+            const blanksNodes = getAllBefore(blanksTree, '--feedback--');\n+            const feedbackNodes = getSection(blanksTree, '--feedback--');\n+\n+            return {\n+              answer: blanksNodes[0].children[0].value,\n+              feedback: toHtml(feedbackNodes)\n+            };\n+          }\n+\n+          return {\n+            answer: blanksGroup[0].children[0].value,\n+            feedback: null\n+          };\n+        });\n+      }\n     }\n   }\n }\n \n-function validateBlanksCount(fillInTheBlankTree) {\n+function validateBlanksSectionCount(fillInTheBlankTree) {\n   let blanksCount = 0;\n   visit(fillInTheBlankTree, { value: '--blanks--' }, () => {\n     blanksCount++;\n@@ -64,49 +149,4 @@ function validateBlanksCount(fillInTheBlankTree) {\n     );\n }\n \n-function getfillInTheBlank(sentenceNodes, blanksNodes) {\n-  const sentenceWithoutCodeBlocks = sentenceNodes.map(node => {\n-    node.children.forEach(child => {\n-      if (child.type === 'text' && child.value.trim() === '')\n-        throw Error(NOT_IN_PARAGRAPHS);\n-      if (child.type !== 'inlineCode') throw Error(NOT_IN_CODE_BLOCK);\n-    });\n-\n-    const children = node.children.map(child => ({ ...child, type: 'text' }));\n-    return { ...node, children };\n-  });\n-  const sentence = mdastToHtml(sentenceWithoutCodeBlocks);\n-  const blanks = getBlanks(blanksNodes);\n-\n-  if (!sentence) throw Error('sentence is missing from fill in the blank');\n-  if (!blanks) throw Error('blanks are missing from fill in the blank');\n-  if (sentence.match(/BLANK/g).length !== blanks.length)\n-    throw Error(\n-      `Number of underscores in sentence doesn't match the number of blanks`\n-    );\n-\n-  return { sentence, blanks };\n-}\n-\n-function getBlanks(blanksNodes) {\n-  const blanksGroups = splitOnThematicBreak(blanksNodes);\n-\n-  return blanksGroups.map(blanksGroup => {\n-    const blanksTree = root(blanksGroup);\n-    const feedback = find(blanksTree, { value: '--feedback--' });\n-\n-    if (feedback) {\n-      const blanksNodes = getAllBefore(blanksTree, '--feedback--');\n-      const feedbackNodes = getSection(blanksTree, '--feedback--');\n-\n-      return {\n-        answer: blanksNodes[0].children[0].value,\n-        feedback: mdastToHtml(feedbackNodes)\n-      };\n-    }\n-\n-    return { answer: blanksGroup[0].children[0].value, feedback: null };\n-  });\n-}\n-\n module.exports = plugin;"
        },
        {
            "sha": "f3332f10cafd556615d202f9e92e767d463fc144",
            "filename": "tools/challenge-parser/parser/plugins/add-fill-in-the-blank.test.js",
            "status": "modified",
            "additions": 110,
            "deletions": 4,
            "changes": 114,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Fadd-fill-in-the-blank.test.js",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Fadd-fill-in-the-blank.test.js",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Fadd-fill-in-the-blank.test.js?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -8,7 +8,13 @@ describe('fill-in-the-blanks plugin', () => {\n     mockFillInTheBlankTwoSentencesAST,\n     mockFillInTheBlankBadSentence,\n     mockFillInTheBlankBadParagraph,\n-    mockFillInTheBlankMultipleBlanks;\n+    mockFillInTheBlankMultipleBlanks,\n+    mockChineseFillInTheBlankAST,\n+    mockChineseFillInTheBlankNoPinyinAST,\n+    mockChineseFillInTheBlankNoHanziAST,\n+    mockChineseFillInTheBlankWrongAnswerFormatAST,\n+    mockChineseFillInTheBlankBlankAnswerMismatchAST,\n+    mockChineseFillInTheBlankLatinAST;\n   const plugin = addFillInTheBlankQuestion();\n   let file = { data: {} };\n \n@@ -29,6 +35,24 @@ describe('fill-in-the-blanks plugin', () => {\n     mockFillInTheBlankMultipleBlanks = await parseFixture(\n       'with-fill-in-the-blank-many-blanks.md'\n     );\n+    mockChineseFillInTheBlankAST = await parseFixture(\n+      'with-chinese-fill-in-the-blank.md'\n+    );\n+    mockChineseFillInTheBlankNoPinyinAST = await parseFixture(\n+      'with-chinese-fill-in-the-blank-no-pinyin.md'\n+    );\n+    mockChineseFillInTheBlankNoHanziAST = await parseFixture(\n+      'with-chinese-fill-in-the-blank-no-hanzi.md'\n+    );\n+    mockChineseFillInTheBlankWrongAnswerFormatAST = await parseFixture(\n+      'with-chinese-fill-in-the-blank-wrong-answer-format.md'\n+    );\n+    mockChineseFillInTheBlankBlankAnswerMismatchAST = await parseFixture(\n+      'with-chinese-fill-in-the-blank-blank-answer-mismatch.md'\n+    );\n+    mockChineseFillInTheBlankLatinAST = await parseFixture(\n+      'with-chinese-fill-in-the-blank-latin.md'\n+    );\n   });\n \n   beforeEach(() => {\n@@ -55,15 +79,15 @@ describe('fill-in-the-blanks plugin', () => {\n     expect(Array.isArray(testObject.blanks)).toBe(true);\n     expect(testObject.blanks.length).toBe(3);\n     expect(testObject.blanks[0]).toHaveProperty('answer');\n-    expect(typeof testObject.blanks[0].answer).toBe('string');\n+    expect(testObject.blanks[0].answer).toEqual('are');\n     expect(testObject.blanks[0]).toHaveProperty('feedback');\n     expect(typeof testObject.blanks[0].feedback).toBe('string');\n     expect(testObject.blanks[1]).toHaveProperty('answer');\n-    expect(typeof testObject.blanks[1].answer).toBe('string');\n+    expect(testObject.blanks[1].answer).toEqual('right');\n     expect(testObject.blanks[1]).toHaveProperty('feedback');\n     expect(typeof testObject.blanks[1].feedback).toBe('string');\n     expect(testObject.blanks[2]).toHaveProperty('answer');\n-    expect(typeof testObject.blanks[2].answer).toBe('string');\n+    expect(testObject.blanks[2].answer).toEqual('Nice');\n     expect(testObject.blanks[2]).toHaveProperty('feedback');\n     expect(testObject.blanks[2].feedback).toBeNull();\n   });\n@@ -167,4 +191,86 @@ Example of good formatting:\n         '<p>The verb <code>to be</code> is an irregular verb. When conjugated with the pronoun <code>you</code>, <code>be</code> becomes <code>are</code>. For example: <code>You are an English learner.</code></p>'\n     });\n   });\n+\n+  it('should parse Chinese fill-in-the-blank sentence and answer correctly if they are in `hanzi (pinyin)` format', () => {\n+    file.data.lang = 'zh-CN';\n+    file.data.inputType = 'pinyin-to-hanzi';\n+    plugin(mockChineseFillInTheBlankAST, file);\n+    const testObject = file.data.fillInTheBlank;\n+\n+    expect(testObject.inputType).toBe('pinyin-to-hanzi');\n+\n+    expect(testObject.sentence).toBe(\n+      '<p>BLANK BLANK，BLANK <ruby>是王华<rp>(</rp><rt>shì Wang Hua</rt><rp>)</rp></ruby>，<ruby>请问你<rp>(</rp><rt>qǐng wèn nǐ</rt><rp>)</rp></ruby> BLANK <ruby>什么名字<rp>(</rp><rt>shén me míng zi</rt><rp>)</rp></ruby>？</p>'\n+    );\n+    expect(testObject.blanks.length).toBe(4);\n+\n+    expect(testObject.blanks[0].answer).toEqual('你 (nǐ)');\n+    expect(testObject.blanks[0].feedback).toBe(\n+      '<p>Feedback text containing <ruby>汉字<rp>(</rp><rt>hàn zì</rt><rp>)</rp></ruby>.</p>'\n+    );\n+\n+    expect(testObject.blanks[1].answer).toEqual('好 (hǎo)');\n+    expect(testObject.blanks[1].feedback).toBe(\n+      '<p>This means \"good\" or \"well\".</p>'\n+    );\n+\n+    expect(testObject.blanks[2].answer).toEqual('我 (wǒ)');\n+    expect(testObject.blanks[2].feedback).toBe('<p>This means \"I\".</p>');\n+\n+    expect(testObject.blanks[3].answer).toEqual('叫 (jiào)');\n+    expect(testObject.blanks[3].feedback).toBe(\n+      '<p>This means \"to be called\".</p>'\n+    );\n+  });\n+\n+  it('should return sentence as plain text when sentence does not contain pinyin', () => {\n+    file.data.lang = 'zh-CN';\n+    plugin(mockChineseFillInTheBlankNoPinyinAST, file);\n+    const testObject = file.data.fillInTheBlank;\n+\n+    expect(testObject.sentence).toBe('<p>BLANK好</p>');\n+    expect(testObject.blanks[0].answer).toEqual('你 (nǐ)');\n+  });\n+\n+  it('should return sentence as plain text when sentence does not contain hanzi', () => {\n+    file.data.lang = 'zh-CN';\n+    plugin(mockChineseFillInTheBlankNoHanziAST, file);\n+    const testObject = file.data.fillInTheBlank;\n+\n+    expect(testObject.sentence).toBe('<p>BLANK hǎo</p>');\n+    expect(testObject.blanks[0].answer).toEqual('nǐ');\n+  });\n+\n+  it(\"should throw if the number of blanks in the sentence doesn't match the number of answers\", () => {\n+    file.data.lang = 'zh-CN';\n+    expect(() => {\n+      plugin(mockChineseFillInTheBlankBlankAnswerMismatchAST, file);\n+    }).toThrow(`Number of BLANKs doesn't match the number of answers.`);\n+  });\n+\n+  it('should throw error when inputType is pinyin-to-hanzi but answer is not in hanzi-pinyin format', () => {\n+    file.data.lang = 'zh-CN';\n+    file.data.inputType = 'pinyin-to-hanzi';\n+\n+    expect(() => {\n+      plugin(mockChineseFillInTheBlankWrongAnswerFormatAST, file);\n+    }).toThrow(\n+      \"When inputType is 'pinyin-to-hanzi', all answers must be in 'hanzi (pinyin)' format.\"\n+    );\n+  });\n+\n+  it('should separate BLANK and adjacent Latin text in Chinese sentences', () => {\n+    file.data.lang = 'zh-CN';\n+    plugin(mockChineseFillInTheBlankLatinAST, file);\n+    const testObject = file.data.fillInTheBlank;\n+\n+    expect(testObject.sentence).toBe(\n+      '<p><ruby>我<rp>(</rp><rt>wǒ</rt><rp>)</rp></ruby> BLANK UI <ruby>设计师<rp>(</rp><rt>shè jì shī</rt><rp>)</rp></ruby> 。</p>'\n+    );\n+    expect(testObject.blanks.length).toBe(1);\n+\n+    expect(testObject.blanks[0].answer).toEqual('是 (shì)');\n+    expect(testObject.blanks[0].feedback).toBe('<p>Feedback text.</p>');\n+  });\n });"
        },
        {
            "sha": "9bb839d735194e51a6b17769f068cc21f144943e",
            "filename": "tools/challenge-parser/parser/plugins/add-text.test.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Fadd-text.test.js",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Fadd-text.test.js",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Fadd-text.test.js?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -172,7 +172,7 @@ describe('add-text', () => {\n       '<section id=\"instructions\">\\n<p>Instructions containing <ruby>汉字<rp>(</rp><rt>hàn zì</rt><rp>)</rp></ruby>.</p>\\n</section>'\n     );\n     expect(zhFile.data.explanation).toBe(\n-      '<section id=\"explanation\">\\n<p>Wang Hua uses <ruby>请问<rp>(</rp><rt>qǐng wèn</rt><rp>)</rp></ruby> to politely start her question.</p>\\n</section>'\n+      '<section id=\"explanation\">\\n<p><ruby>我是<rp>(</rp><rt>wǒ shì</rt><rp>)</rp></ruby> Web <ruby>开发者<rp>(</rp><rt>kāi fā zhě</rt><rp>)</rp></ruby>。 – I am a web developer.</p>\\n<p><ruby>你好<rp>(</rp><rt>nǐ hǎo</rt><rp>)</rp></ruby>，<ruby>我是王华<rp>(</rp><rt>wǒ shì Wang Hua</rt><rp>)</rp></ruby>，<ruby>请问你叫什么名字<rp>(</rp><rt>qǐng wèn nǐ jiào shén me míng zi</rt><rp>)</rp></ruby>？ – Hello, I am Wang Hua, may I ask what your name is?</p>\\n</section>'\n     );\n   });\n });"
        },
        {
            "sha": "8f4ab2bcfc576fb2d2823ce996a5784d18861ccb",
            "filename": "tools/challenge-parser/parser/plugins/utils/i18n-stringify.js",
            "status": "modified",
            "additions": 76,
            "deletions": 40,
            "changes": 116,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Futils%2Fi18n-stringify.js",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Futils%2Fi18n-stringify.js",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Futils%2Fi18n-stringify.js?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -1,61 +1,94 @@\n const mdastToHTML = require('./mdast-to-html');\n \n+// Captures hanzi (pinyin) pairs (hanzi, optional whitespace, then pinyin parentheses)\n+const HANZI_PINYIN_PAIR = '([\\u4e00-\\u9fff]+)\\\\s*\\\\(([^)]+)\\\\)';\n+\n+// Matches the BLANK placeholder\n+const BLANK_TOKEN = 'BLANK';\n+\n+// Matches Chinese and English punctuation\n+const PUNCTUATION = '[，。？！!?,;:；：、]+';\n+\n+// Matches Latin text with spaces\n+const OTHER_TEXT = '([a-zA-Z\\\\s]+)';\n+\n+const HANZI_PINYIN_REGEX = new RegExp(\n+  `${HANZI_PINYIN_PAIR}|${BLANK_TOKEN}|${PUNCTUATION}|${OTHER_TEXT}`,\n+  'g'\n+);\n+\n /**\n- * Parses Chinese text in format: hanzi (pinyin)\n- * @param {string} text - Text in format: hanzi (pinyin)\n- * @returns {{ hanzi: string, pinyin: string } | null} Parsed hanzi and pinyin, or null if not matching\n+ * Parses all hanzi-pinyin pairs from text\n+ * @param {string} text - Text potentially containing multiple hanzi (pinyin) patterns\n+ * @returns {Array<{hanzi: string, pinyin: string}>} Array of parsed pairs\n  */\n-function parseChinesePattern(text) {\n-  const match = text.match(/^(.+?)\\s*\\((.+?)\\)$/);\n+function parseHanziPinyinPairs(text) {\n+  const pairs = [];\n+  const regex = new RegExp(HANZI_PINYIN_REGEX);\n+  let match;\n \n-  if (!match) {\n-    return null;\n+  while ((match = regex.exec(text)) !== null) {\n+    if (match[1] && match[2]) {\n+      pairs.push({\n+        hanzi: match[1].trim(),\n+        pinyin: match[2].trim()\n+      });\n+    }\n   }\n \n-  return {\n-    hanzi: match[1].trim(),\n-    pinyin: match[2].trim()\n-  };\n+  return pairs;\n }\n \n /**\n  * Custom handler for Chinese inline code to render as ruby elements\n+ * Matches hanzi-pinyin pairs, BLANK, and punctuation as separate elements\n  * @param {object} state - The state object from mdast-util-to-hast\n  * @param {object} node - The inlineCode node\n- * @returns {object} Hast element node\n+ * @returns {object|Array<object>} Hast element node or array of nodes\n  */\n function chineseInlineCodeHandler(state, node) {\n-  const parsed = parseChinesePattern(node.value);\n-\n-  if (parsed) {\n-    return {\n-      type: 'element',\n-      tagName: 'ruby',\n-      properties: {},\n-      children: [\n-        { type: 'text', value: parsed.hanzi },\n-        {\n-          type: 'element',\n-          tagName: 'rp',\n-          properties: {},\n-          children: [{ type: 'text', value: '(' }]\n-        },\n-        {\n-          type: 'element',\n-          tagName: 'rt',\n-          properties: {},\n-          children: [{ type: 'text', value: parsed.pinyin }]\n-        },\n-        {\n+  const rubyPairs = parseHanziPinyinPairs(node.value);\n+\n+  if (rubyPairs.length > 0) {\n+    const matches = [...node.value.matchAll(HANZI_PINYIN_REGEX)];\n+    const nodes = matches.map(fullMatch => {\n+      if (fullMatch[1] && fullMatch[2]) {\n+        return {\n           type: 'element',\n-          tagName: 'rp',\n+          tagName: 'ruby',\n           properties: {},\n-          children: [{ type: 'text', value: ')' }]\n-        }\n-      ]\n-    };\n+          children: [\n+            { type: 'text', value: fullMatch[1].trim() },\n+            {\n+              type: 'element',\n+              tagName: 'rp',\n+              properties: {},\n+              children: [{ type: 'text', value: '(' }]\n+            },\n+            {\n+              type: 'element',\n+              tagName: 'rt',\n+              properties: {},\n+              children: [{ type: 'text', value: fullMatch[2].trim() }]\n+            },\n+            {\n+              type: 'element',\n+              tagName: 'rp',\n+              properties: {},\n+              children: [{ type: 'text', value: ')' }]\n+            }\n+          ]\n+        };\n+      }\n+\n+      // Other captures (BLANK, punctuation, other text including spaces) should preserve exactly\n+      return { type: 'text', value: fullMatch[0] };\n+    });\n+\n+    return nodes.length === 1 ? nodes[0] : nodes;\n   }\n \n+  // If static text, return code\n   return {\n     type: 'element',\n     // TODO: change this to span\n@@ -75,4 +108,7 @@ const rubyOptions = {\n const createMdastToHtml = lang =>\n   lang == 'zh-CN' ? x => mdastToHTML(x, rubyOptions) : mdastToHTML;\n \n-module.exports = { parseChinesePattern, createMdastToHtml };\n+module.exports = {\n+  parseHanziPinyinPairs,\n+  createMdastToHtml\n+};"
        },
        {
            "sha": "aff2e3b911053b363fc0fa2d04fc17e2d021145f",
            "filename": "tools/challenge-parser/parser/plugins/utils/i18n-stringify.test.js",
            "status": "modified",
            "additions": 135,
            "deletions": 24,
            "changes": 159,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Futils%2Fi18n-stringify.test.js",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/33325b9002533d6bc3abb94e876dfce8818dfc73/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Futils%2Fi18n-stringify.test.js",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fchallenge-parser%2Fparser%2Fplugins%2Futils%2Fi18n-stringify.test.js?ref=33325b9002533d6bc3abb94e876dfce8818dfc73",
            "patch": "@@ -1,44 +1,56 @@\n import { describe, it, expect } from 'vitest';\n-import { createMdastToHtml, parseChinesePattern } from './i18n-stringify';\n+import { createMdastToHtml, parseHanziPinyinPairs } from './i18n-stringify';\n \n-describe('parseChinesePattern', () => {\n-  it('should parse Chinese text with hanzi and pinyin', () => {\n-    const result = parseChinesePattern('你好 (nǐ hǎo)');\n-    expect(result).toEqual({\n+describe('parseHanziPinyinPairs', () => {\n+  it('should parse single hanzi-pinyin pair', () => {\n+    const withSpaceSeparator = parseHanziPinyinPairs('你好 (nǐ hǎo)');\n+\n+    expect(withSpaceSeparator).toHaveLength(1);\n+    expect(withSpaceSeparator[0]).toMatchObject({\n       hanzi: '你好',\n       pinyin: 'nǐ hǎo'\n     });\n-  });\n \n-  it('should handle text without spaces before parentheses', () => {\n-    const result = parseChinesePattern('你好(nǐ hǎo)');\n-    expect(result).toEqual({\n+    const withoutSpaceSeparator = parseHanziPinyinPairs('你好(nǐ hǎo)');\n+\n+    expect(withoutSpaceSeparator).toHaveLength(1);\n+    expect(withoutSpaceSeparator[0]).toMatchObject({\n       hanzi: '你好',\n       pinyin: 'nǐ hǎo'\n     });\n   });\n \n-  it('should handle text with multiple spaces', () => {\n-    const result = parseChinesePattern('你好   (nǐ hǎo)');\n-    expect(result).toEqual({\n+  it('should parse multiple hanzi-pinyin pairs', () => {\n+    const withSpaceSeparator = parseHanziPinyinPairs(\n+      '你好 (nǐ hǎo)，我是王华 (wǒ shì Wang Hua)'\n+    );\n+    expect(withSpaceSeparator).toHaveLength(2);\n+    expect(withSpaceSeparator[0]).toMatchObject({\n       hanzi: '你好',\n       pinyin: 'nǐ hǎo'\n     });\n-  });\n-\n-  it('should return null for text without parentheses', () => {\n-    const result = parseChinesePattern('你好');\n-    expect(result).toBeNull();\n-  });\n+    expect(withSpaceSeparator[1]).toMatchObject({\n+      hanzi: '我是王华',\n+      pinyin: 'wǒ shì Wang Hua'\n+    });\n \n-  it('should return null for text with only opening parenthesis', () => {\n-    const result = parseChinesePattern('你好 (nǐ hǎo');\n-    expect(result).toBeNull();\n+    const withoutSpaceSeparator = parseHanziPinyinPairs(\n+      '你好(nǐ hǎo)，我是王华(wǒ shì Wang Hua)'\n+    );\n+    expect(withoutSpaceSeparator).toHaveLength(2);\n+    expect(withoutSpaceSeparator[0]).toMatchObject({\n+      hanzi: '你好',\n+      pinyin: 'nǐ hǎo'\n+    });\n+    expect(withoutSpaceSeparator[1]).toMatchObject({\n+      hanzi: '我是王华',\n+      pinyin: 'wǒ shì Wang Hua'\n+    });\n   });\n \n-  it('should return null for empty string', () => {\n-    const result = parseChinesePattern('');\n-    expect(result).toBeNull();\n+  it('should return empty array for text without pairs', () => {\n+    const result = parseHanziPinyinPairs('你好');\n+    expect(result).toHaveLength(0);\n   });\n });\n \n@@ -99,6 +111,93 @@ describe('createMdastToHtml', () => {\n     );\n   });\n \n+  it('should render BLANK tokens and punctuation marks as plain text', () => {\n+    const toHtml = createMdastToHtml('zh-CN');\n+    const withoutSpacesAroundBlanks = [\n+      {\n+        type: 'paragraph',\n+        children: [\n+          {\n+            type: 'inlineCode',\n+            value:\n+              '你好 (nǐ hǎo)，BLANK是王华 (shì Wang Hua)，请问你 (qǐng wèn nǐ)BLANK什么名字 (shén me míng zi)？'\n+          }\n+        ]\n+      }\n+    ];\n+    expect(toHtml(withoutSpacesAroundBlanks)).toBe(\n+      '<p><ruby>你好<rp>(</rp><rt>nǐ hǎo</rt><rp>)</rp></ruby>，BLANK<ruby>是王华<rp>(</rp><rt>shì Wang Hua</rt><rp>)</rp></ruby>，<ruby>请问你<rp>(</rp><rt>qǐng wèn nǐ</rt><rp>)</rp></ruby>BLANK<ruby>什么名字<rp>(</rp><rt>shén me míng zi</rt><rp>)</rp></ruby>？</p>'\n+    );\n+\n+    const withSpacesAroundBlanks = [\n+      {\n+        type: 'paragraph',\n+        children: [\n+          {\n+            type: 'inlineCode',\n+            value:\n+              '你好 (nǐ hǎo)， BLANK 是王华 (shì Wang Hua)，请问你 (qǐng wèn nǐ) BLANK 什么名字 (shén me míng zi)？'\n+          }\n+        ]\n+      }\n+    ];\n+    expect(toHtml(withSpacesAroundBlanks)).toBe(\n+      '<p><ruby>你好<rp>(</rp><rt>nǐ hǎo</rt><rp>)</rp></ruby>， BLANK <ruby>是王华<rp>(</rp><rt>shì Wang Hua</rt><rp>)</rp></ruby>，<ruby>请问你<rp>(</rp><rt>qǐng wèn nǐ</rt><rp>)</rp></ruby> BLANK <ruby>什么名字<rp>(</rp><rt>shén me míng zi</rt><rp>)</rp></ruby>？</p>'\n+    );\n+  });\n+\n+  it('should render Latin words as plain text while applying ruby to hanzi-pinyin pairs', () => {\n+    const toHtml = createMdastToHtml('zh-CN');\n+    const nodes = [\n+      {\n+        type: 'paragraph',\n+        children: [\n+          {\n+            type: 'inlineCode',\n+            value: '我是 (wǒ shì) UI 设计师 (shè jì shī)'\n+          }\n+        ]\n+      }\n+    ];\n+    const actual = toHtml(nodes);\n+    expect(actual).toBe(\n+      '<p><ruby>我是<rp>(</rp><rt>wǒ shì</rt><rp>)</rp></ruby> UI <ruby>设计师<rp>(</rp><rt>shè jì shī</rt><rp>)</rp></ruby></p>'\n+    );\n+  });\n+\n+  it('should handle BLANK token and Latin word mix', () => {\n+    const toHtml = createMdastToHtml('zh-CN');\n+    const nodes = [\n+      {\n+        type: 'paragraph',\n+        children: [\n+          {\n+            type: 'inlineCode',\n+            value: '我 (wǒ) BLANK UI 设计师 (shè jì shī)'\n+          }\n+        ]\n+      }\n+    ];\n+    const actual = toHtml(nodes);\n+    expect(actual).toBe(\n+      '<p><ruby>我<rp>(</rp><rt>wǒ</rt><rp>)</rp></ruby> BLANK UI <ruby>设计师<rp>(</rp><rt>shè jì shī</rt><rp>)</rp></ruby></p>'\n+    );\n+  });\n+\n+  it('should render multiple adjacent BLANK tokens in Chinese sentence', () => {\n+    const toHtml = createMdastToHtml('zh-CN');\n+    const nodes = [\n+      {\n+        type: 'paragraph',\n+        children: [{ type: 'inlineCode', value: 'BLANK BLANK，你好 (nǐ hǎo)' }]\n+      }\n+    ];\n+    const actual = toHtml(nodes);\n+    expect(actual).toBe(\n+      '<p>BLANK BLANK，<ruby>你好<rp>(</rp><rt>nǐ hǎo</rt><rp>)</rp></ruby></p>'\n+    );\n+  });\n+\n   it('should fallback to code element if pattern does not match', () => {\n     const toHtml = createMdastToHtml('zh-CN');\n     const nodes = [\n@@ -126,4 +225,16 @@ describe('createMdastToHtml', () => {\n     const actual = toHtml(nodes);\n     expect(actual).toBe('<p><code>请问 (qǐng wèn)</code></p>');\n   });\n+\n+  it('should render as regular code when lang is not defined', () => {\n+    const toHtml = createMdastToHtml();\n+    const nodes = [\n+      {\n+        type: 'paragraph',\n+        children: [{ type: 'inlineCode', value: '请问 (qǐng wèn)' }]\n+      }\n+    ];\n+    const actual = toHtml(nodes);\n+    expect(actual).toBe('<p><code>请问 (qǐng wèn)</code></p>');\n+  });\n });"
        }
    ],
    "stats": {
        "total": 1140,
        "additions": 964,
        "deletions": 176
    }
}