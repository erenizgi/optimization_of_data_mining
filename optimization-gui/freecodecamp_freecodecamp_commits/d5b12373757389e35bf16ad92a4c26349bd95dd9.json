{
    "author": "moT01",
    "message": "feat(curriculum): vidoes and transcripts for TS lecture (#59602)",
    "sha": "d5b12373757389e35bf16ad92a4c26349bd95dd9",
    "files": [
        {
            "sha": "5bbd1dfb3b8fcacee28cb7c38f4676b7b656c2fb",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-introduction-to-typescript/67d1d96532bc095aee051657.md",
            "status": "modified",
            "additions": 42,
            "deletions": 2,
            "changes": 44,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/d5b12373757389e35bf16ad92a4c26349bd95dd9/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d1d96532bc095aee051657.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/d5b12373757389e35bf16ad92a4c26349bd95dd9/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d1d96532bc095aee051657.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d1d96532bc095aee051657.md?ref=d5b12373757389e35bf16ad92a4c26349bd95dd9",
            "patch": "@@ -2,13 +2,53 @@\n id: 67d1d96532bc095aee051657\n title: What Is TypeScript, and Why Is It Used in the Industry?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: Dce5dZUL2iI\n dashedName: what-is-typescript-and-why-is-it-used-in-the-industry\n ---\n \n # --description--\n \n-Watch the video lecture and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What is TypeScript, and why is it used in the industry?\n+\n+Let's learn about TypeScript and why it is used.\n+\n+JavaScript is considered a dynamically-typed language. This means that variables can receive any values at run time - declaring a variable as a number does not prevent you from assigning it a string value later, and function parameters can be passed any value.\n+\n+The challenge of a dynamically-typed language is that the lack of type safety can introduce errors if you are not careful. TypeScript extends the JavaScript language to include static typing, which helps catch those errors before you even deploy your code. But how does it work?\n+\n+Consider this JavaScript function:\n+\n+```js\n+const getRandomValue = (array) => {\n+  return array[Math.floor(Math.random() * array.length)];\n+}\n+```\n+\n+Our `getRandomValue` function takes an array and returns a random value from that array. But because JavaScript does not validate types, there is nothing preventing you from calling the function with a number:\n+\n+```js\n+console.log(getRandomValue(10));\n+```\n+\n+The console output for the current example will return `undefined` because it was expecting an array instead of a number.\n+\n+But with TypeScript you can define a type for the array parameter:\n+\n+```js\n+const getRandomValue = (array: string[]) => {\n+  return array[Math.floor(Math.random() * array.length)];\n+}\n+```\n+\n+This type definition tells TypeScript that the array argument must be an array of strings. Then when you call `getRandomValue` and pass it a number, you get a different type of error called a compiler error.\n+\n+Most JavaScript runtime environments, such as a browser or Node.js, cannot run TypeScript natively. Instead, you first need to compile, or translate, TypeScript code into regular JavaScript. You can do that with the built-in compiler that comes with the TypeScript language. When you run the compiler, TypeScript will evaluate your code and throw an error for any issues where the types don't match - such as passing a number into a function that expects an array.\n+\n+You'll learn more about how these types work in the next few lectures. But it's this extra safety that makes TypeScript an appealing language for many developers and organizations.\n \n # --questions--\n "
        },
        {
            "sha": "7e777da1cf0543f3a990868c0082c2f4c5cd860e",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-introduction-to-typescript/67d3018062fe6ba92b7d8299.md",
            "status": "modified",
            "additions": 116,
            "deletions": 2,
            "changes": 118,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/d5b12373757389e35bf16ad92a4c26349bd95dd9/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d3018062fe6ba92b7d8299.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/d5b12373757389e35bf16ad92a4c26349bd95dd9/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d3018062fe6ba92b7d8299.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d3018062fe6ba92b7d8299.md?ref=d5b12373757389e35bf16ad92a4c26349bd95dd9",
            "patch": "@@ -2,13 +2,127 @@\n id: 67d3018062fe6ba92b7d8299\n title: How Do the Different Types Work in TypeScript?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: UxmvUfPRqfg\n dashedName: how-do-the-different-types-work-in-typescript\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How do the different types work in TypeScript?\n+\n+Let's learn about the different types in TypeScript.\n+\n+You've already seen one in the previous lecture: `string[]`, which represents an array of strings. But how does that actually work?\n+\n+For the primitive data types `string`, `null`, `undefined`, `number`, `boolean`, and `bigint`, TypeScript offers corresponding type keywords. In our example, we are using these types to annotate our variables:\n+\n+```js\n+let str: string = \"Naomi\";\n+let num: number = 42;\n+let bool: boolean = true;\n+let nope: null = null;\n+let nada: undefined = undefined;\n+```\n+\n+Now, we have explicitly declared `str` as `string` - which might seem confusing because we assigned it a string value already, but this annotation ensures that we cannot reassign a different value type (like a number) to that variable.\n+\n+But what about arrays and objects? Well, you've already seen the syntax for an array! You can define an array of specific type with two different syntaxes:\n+\n+```js\n+const arrOne: string[] = [\"Naomi\"];\n+const arrTwo: Array<string> = [\"Camperchan\"];\n+```\n+\n+Fundamentally, these two syntaxes are the same, and the choice between the two is generally a matter of preference.\n+\n+Objects get a bit more complicated. You can define the exact structure of an object:\n+\n+```js\n+const obj: { a: string, b: number } = { a: \"Naomi\", b: 42 };\n+```\n+\n+This syntax means that property `a` must always be a string, property `b` must always be a number, and you cannot add or remove properties.\n+\n+But maybe you don't want to restrict the properties? Maybe you want an object with any keys, but the values all need to be strings. There are two ways you can do this:\n+\n+```js\n+const objOne: Record<string, string> = {};\n+const objTwo: { [key: string]: string } = {};\n+```\n+\n+Like the array types, these are fundamentally similar. With these object types, you must define both the type of the keys and the type of the values. Keys must always be strings, but you can define custom string types to further restrict those keys.\n+\n+In addition to these types, TypeScript offers four other helpful types. The first is `any`, which indicates that a value can have any type. This is effectively the Konami Code of TypeScript - it tells the compiler to stop caring about the type of that variable and let you do whatever.\n+\n+The second is `unknown`, which is generally preferred over `any`. The `unknown` type tells TypeScript that you do care about the type of the value, but you don't actually know what it is. If you then try to perform type-specific actions (like a subtraction operator, or the `slice()` method to perform a specific string operation), TypeScript will expect you to narrow down the type of that value first. You'll learn more about type narrowing in an upcoming lecture.\n+\n+The third is `void`. This is a special type that you'll typically only use when defining functions. It's effectively the opposite of `any` - it represents the absence of any type at all. Functions which don't have a return value, such as `console.log()`, have a return type of `void`.\n+\n+Finally, there is the `never` type. This is probably something you won't use often - it represents a type that will never exist. For example, passing a mock object to a function in your test suite might be a good use of `never` to indicate that such an object would never really be passed to the function.\n+\n+Expanding on these types, you have access to the `type` keyword. This keyword is like `const`, but instead of declaring a variable you can declare a type:\n+\n+```js\n+type myString = string;\n+```\n+\n+This might not seem terribly useful on its own, but when coupled with union types it becomes powerful. A union type allows you to combine two or more types into one. Here's an example:\n+\n+```js\n+type stringOrNumber = string | number;\n+```\n+\n+Our `stringOrNumber` type matches values that are a string and values that are a number. You can then combine your type with other types, like an array:\n+\n+```js\n+const stuff: stringOrNumber[] = [\"a\", 2, \"c\", 1000];\n+```\n+\n+You can also define more strict types that include only specific values:\n+\n+```js\n+type bot = \"camperchan\" | \"camperbot\" | \"naomi\";\n+type digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\n+```\n+\n+You could then combine those types to create more specific restrictions on an object:\n+\n+```js\n+const artificialIntelligence: Record<bot, digit> = { camperchan: 5 }\n+```\n+\n+Though if you need more control over the structure of an object, chances are you'll reach for our final type: `interface`. Interfaces are effectively classes, but for types. They can implement or extend other interfaces, are specifically object types, and are generally preferred unless you need a specific feature offered by a type declaration.\n+\n+```js\n+interface wowie {\n+  zowie: boolean;\n+  method: () => void;\n+}\n+```\n+\n+Finally, functions can also be given type signatures. In the previous lecture, you saw how to define the type of a particular parameter:\n+\n+```js\n+const getRandomValue = (array: string[]) => {\n+  return array[Math.floor(Math.random() * array.length)];\n+}\n+```\n+\n+But you can also define the return type of the function.\n+\n+```js\n+const getRandomValue = (array: string[]): string => {\n+  return array[Math.floor(Math.random() * array.length)];\n+}\n+```\n+\n+In this example, we've told TypeScript that the function should return a string. If we try to return anything else, TypeScript will provide a compiler error to let us know.\n+\n+And that covers the basics of TypeScript's type system. It's pretty complex, and has a lot of moving parts, but it can often help to think of it as mirroring JavaScript's types.\n \n # --questions--\n "
        },
        {
            "sha": "ca66a946b80d8662db9d8595baeba2d6ea1140ec",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-introduction-to-typescript/67d30191adb999a9909109ef.md",
            "status": "modified",
            "additions": 64,
            "deletions": 2,
            "changes": 66,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/d5b12373757389e35bf16ad92a4c26349bd95dd9/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d30191adb999a9909109ef.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/d5b12373757389e35bf16ad92a4c26349bd95dd9/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d30191adb999a9909109ef.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d30191adb999a9909109ef.md?ref=d5b12373757389e35bf16ad92a4c26349bd95dd9",
            "patch": "@@ -2,13 +2,75 @@\n id: 67d30191adb999a9909109ef\n title: What Are Generics, and How Do They Work?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: dBUOmjcR3N4\n dashedName: what-are-generics-and-how-do-they-work\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What are generics, and how do they work?\n+\n+Let's learn about generic types in TypeScript.\n+\n+You have actually seen a generic type in a previous lecture: `Array<string>`. But you'll usually use generic types in functions. In fact, they can be thought of as a special parameter you provide to a function to control the behavior of the function's type definition.\n+\n+Let's go back to our previous example of a function to get a random value from an array:\n+\n+```js\n+const getRandomValue = (array: string[]): string => {\n+  return array[Math.floor(Math.random() * array.length)];\n+}\n+```\n+\n+Our function accepts an array of strings and returns a string. But what if we wanted to pass in an array of numbers and return a number?\n+\n+You could use a union type:\n+\n+```js\n+const getRandomValue = (array: (string|number)[]): (string|number) => {\n+  return array[Math.floor(Math.random() * array.length)];\n+}\n+const val = getRandomValue([1, 2, 4])\n+```\n+\n+But with this approach, even though we have passed in an array of only numbers, TypeScript determines that the `val` variable could be a number OR a string.\n+\n+Instead, you can define a generic type for the function:\n+\n+```js\n+const getRandomValue = <T>(array: T[]): T => {\n+  return array[Math.floor(Math.random() * array.length)];\n+}\n+const val = getRandomValue([1, 2, 4])\n+```\n+\n+There are a couple of important components in our new example. First, the `<T>` syntax tells TypeScript that you are defining a generic type `T` for the function. `T` is a common name for generic types, but you can actually name it whatever you want (within JavaScript's variable conventions).\n+\n+Then, we tell TypeScript that the array parameter is an array of values matching the generic type, and that the returned value is a single element of that same type. This allows TypeScript to properly detect that `val` will be a number, because the array we passed consists solely of numbers.\n+\n+But what about functions you don't control? Let's take a look at the `document.querySelector()` method:\n+\n+```js\n+const email = document.querySelector(\"#email\");\n+console.log(email.value);\n+```\n+\n+Because we're querying with an ID selector, TypeScript doesn't know what kind of element we are querying. It knows it's an `Element` of some sort, but our attempt to access the `value` property will throw an error because the top-level element interface does not have that property.\n+\n+Thankfully, we can pass a type argument to the function call:\n+\n+```js\n+const email = document.querySelector<HTMLInputElement>(\"#email\");\n+console.log(email.value);\n+```\n+\n+Notice how we're using the angle bracket syntax again (`<HTMLInputElement>`), but this time in a function call. This tells TypeScript that the element we expect to find will be an `input` element, and we no longer get an error on the value property because input elements do have that property. Of course, `querySelector` can return `null` if an element is not found, and TypeScript will throw a compiler error here because we do not handle that case.\n+\n+But you'll learn about that in the next lecture.\n \n # --questions--\n "
        },
        {
            "sha": "6ffaabf9fc6bbaacc39087e50728a0282701f13b",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-introduction-to-typescript/67d301a5f536d1a9e5df1a8c.md",
            "status": "modified",
            "additions": 162,
            "deletions": 2,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/d5b12373757389e35bf16ad92a4c26349bd95dd9/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d301a5f536d1a9e5df1a8c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/d5b12373757389e35bf16ad92a4c26349bd95dd9/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d301a5f536d1a9e5df1a8c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d301a5f536d1a9e5df1a8c.md?ref=d5b12373757389e35bf16ad92a4c26349bd95dd9",
            "patch": "@@ -2,13 +2,173 @@\n id: 67d301a5f536d1a9e5df1a8c\n title: What Is Type Narrowing, and How Does It Work?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: hTY1_Mco_WA\n dashedName: what-is-type-narrowing-and-how-does-it-work\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What is type narrowing, and how does it work?\n+\n+Let's learn about type narrowing in TypeScript.\n+\n+There are going to be times where you have a value with a broad type and you need to narrow it down to a more specific type. For example, maybe you need to ensure an object matches an interface you defined. Or a string is within a specific list of values. There are quite a few ways to achieve this.\n+\n+The first is narrowing by truthiness. Consider our example from the last lecture:\n+\n+```js\n+const email = document.querySelector<HTMLInputElement>(\"#email\");\n+console.log(email.value);\n+```\n+\n+We get a compiler error trying to access the `value` property of `email`, because `email` might be `null`. However, we can use a conditional statement to confirm `email` is truthy before accessing the property:\n+\n+```js\n+const email = document.querySelector<HTMLInputElement>(\"#email\");\n+if (email) {\n+  console.log(email.value);\n+}\n+```\n+\n+In this updated example, because `null` is not a truthy value, TypeScript is able to infer that `email` MUST be an `input` element within the conditional block. So it no longer throws a compiler error.\n+\n+Truthiness checks can also work in the reverse direction:\n+\n+```js\n+const email = document.querySelector<HTMLInputElement>(\"#email\");\n+if (!email) {\n+  throw new ReferenceError(\"Could not find email element!\")\n+}\n+console.log(email.value);\n+```\n+\n+With this approach, we throw an error if `email` is falsy. `null` is a falsy value. Throwing an error ends the logical execution of this code, which means when we reach the `console.log()` call TypeScript knows `email` cannot be `null`.\n+\n+Optional chaining is also a form of type narrowing, under the same premise that the property access can't happen if the `email` value is `null`.\n+\n+```js\n+const email = document.querySelector<HTMLInputElement>(\"#email\");\n+console.log(email?.value);\n+```\n+\n+But what about other types? Well, you can also narrow types using the `typeof` operator. Let's look at an example of a variable we have indicated might be a string OR a number:\n+\n+```js\n+const myVal = Math.random() > 0.5 ? 222 : \"222\";\n+console.log(myVal / 10)\n+```\n+\n+In this example, we see a compiler error because we cannot perform arithmetic on a string value. But we can use a conditional to check the `typeof` the `myVal` variable:\n+\n+```js\n+const myVal = Math.random() > 0.5 ? 222 : \"222\";\n+if (typeof myVal === \"number\") {\n+  console.log(myVal / 10);\n+}\n+```\n+\n+Because we have used the `typeof` keyword, TypeScript now knows that `myVal` has to be a number, and we can safely perform arithmetic with it.\n+\n+But what about more complex object types? If the object in question happens to come from a class, you can actually use the `instanceof` keyword to narrow the type. Going back to our `querySelector()` example:\n+\n+```js\n+const email = document.querySelector(\"#email\");\n+```\n+\n+Rather than passing a generic type and telling TypeScript what the element is, we can use `instanceof` to narrow the type and write safer code:\n+\n+```js\n+const email = document.querySelector(\"#email\");\n+\n+if (email instanceof HTMLInputElement) {\n+    console.log(email.value);\n+}\n+```\n+\n+This approach may seem the same as our previous one, but `instanceof` is a runtime validation - which means, if we somehow got the TypeScript type wrong, our JavaScript code will still confirm that `email` is an `input` element.\n+\n+Next, let's look at an example where we fetch a `User` object from an API and try to print the information:\n+\n+```js\n+interface User {\n+    name: string;\n+    age: number;\n+}\n+\n+const printAge = (user: User) => \n+  console.log(`${user.name} is ${user.age} years old!`)\n+\n+const request = await fetch(\"url\")\n+const myUser = await request.json();\n+printAge(myUser);\n+```\n+\n+We'll get a compiler error trying to pass `myUser` into the function because, even though we know the API returns the correct object, TypeScript does not. And the `.json()` method does not take a generic type.\n+\n+The \"easy\" way to resolve this issue would be to cast the type:\n+\n+```js\n+interface User {\n+    name: string;\n+    age: number;\n+}\n+\n+const printAge = (user: User) => \n+  console.log(`${user.name} is ${user.age} years old!`)\n+\n+const request = await fetch(\"url\")\n+const myUser = await request.json() as User;\n+printAge(myUser);\n+```\n+\n+But whenever you cast the type, you're essentially weakening TypeScript's ability to catch potential errors. So instead of casting the type, you can write a type guard:\n+\n+```js\n+interface User {\n+    name: string;\n+    age: number;\n+}\n+\n+const isValidUser = (user: unknown): user is User => {\n+  return !!user && \n+    typeof user === \"object\" &&\n+    \"name\" in user &&\n+    \"age\" in user;\n+}\n+```\n+\n+The return type here is the key component of this function definition. The `user is User` syntax indicates that our function returns a boolean value, which when `true` means the `user` value satisfies the `User` interface. We then do some basic checks to ensure that the structure of the `user` object matches - note the use of a truthiness (`!!user`) narrowing and a `typeof` narrowing. We must do this because `typeof null` returns `\"object\"`:\n+\n+```js\n+interface User {\n+    name: string;\n+    age: number;\n+}\n+\n+const isValidUser = (user: unknown): user is User => {\n+  return !!user && \n+    typeof user === \"object\" &&\n+    \"name\" in user &&\n+    \"age\" in user;\n+}\n+\n+const printAge = (user: User) => \n+  console.log(`${user.name} is ${user.age} years old!`)\n+\n+const request = await fetch(\"url\")\n+const myUser = await request.json() as User;\n+if (isValidUser(myUser)) {\n+    printAge(myUser);\n+}\n+```\n+\n+Now, if we combine all of our logic together, we no longer get compiler errors and can successfully build our code.\n+\n+Type narrowing is a powerful feature that helps you write safer, less error-prone code - but remember that TypeScript types are not completely rigid, so avoid practices like casting the type of a value without narrowing it.\n \n # --questions--\n "
        },
        {
            "sha": "1563e4ec296bdb72fd8c627a739b9730a5edf4ee",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-introduction-to-typescript/67d301cc87b84eaa42bdcdbe.md",
            "status": "modified",
            "additions": 43,
            "deletions": 2,
            "changes": 45,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/d5b12373757389e35bf16ad92a4c26349bd95dd9/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d301cc87b84eaa42bdcdbe.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/d5b12373757389e35bf16ad92a4c26349bd95dd9/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d301cc87b84eaa42bdcdbe.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-introduction-to-typescript%2F67d301cc87b84eaa42bdcdbe.md?ref=d5b12373757389e35bf16ad92a4c26349bd95dd9",
            "patch": "@@ -2,13 +2,54 @@\n id: 67d301cc87b84eaa42bdcdbe\n title: What Is a tsconfig File, and Why Is It Important to Include in Your TypeScript Projects?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: H-n6N7zmNCg\n dashedName: what-is-a-tsconfig-file-and-why-is-it-important-to-include-in-your-typescript-projects\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What is a tsconfig file, and why is it important to include in your TypeScript projects?\n+\n+Let's learn about the tsconfig file!\n+\n+TypeScript's compiler settings can be configured to meet your project's needs. That configuration lives in a `tsconfig.json` file in the root directory of your project. In fact, without it, the compiler will not run unless you pass it command flags directly. But what exactly does this file do? Well, let's take a look at an example file:\n+\n+```json\n+{\n+  \"compilerOptions\": {\n+    \"rootDir\": \"./src\",\n+    \"outDir\": \"./prod\",\n+    \"lib\": [\"ES2023\"],\n+    \"target\": \"ES2023\",\n+    \"module\": \"ES2022\",\n+    \"moduleResolution\": \"Node\",\n+    \"esModuleInterop\": true,\n+    \"skipLibCheck\": true,\n+    \"strict\": true\n+  },\n+  \"exclude\": [\"test/\"]\n+}\n+```\n+\n+This seems like a lot! So let's break it down. The `compilerOptions` property is going to contain the \"meat\" of your configuration - this is where you control how the TypeScript compiler behaves. Looking at that nested objectâ€¦\n+\n+The `rootDir` and `outDir` tell TypeScript which directory holds your source files, and which directory should contain the transpiled JavaScript code.\n+\n+The `lib` property determines which type definitions the compiler uses, and allows you to include support for specific ES releases, the DOM, and more.\n+\n+`module` and `moduleResolution` effectively work in tandem to manage how your package uses modules - either CommonJS or ECMAScript.\n+\n+`esModuleInterop` allows for smoother interoperability between CommonJS and ES modules by automatically creating namespace objects for imports, making it easier to use modules from different systems together in your TypeScript projects, and the `skipLibCheck` option skips validating `.d.ts` files that aren't referenced by imports in your code.\n+\n+And finally we reach the `strict` mode. One might argue that TypeScript isn't truly helpful without this flag enabled, as it toggles quite a few other checks, such as requiring you to properly handle nullable types, or warn when TypeScript can't infer a type and falls back to any.\n+\n+Before we finish, a quick note about the top-level `exclude` property - when you've defined a source directory, you may have TypeScript code outside of that directory which you don't want compiled as part of your production code. For example, your test code. The `exclude` array tells the compiler to ignore these TypeScript files during compilation, but still allows tooling like Intellisense to expose potential issues.\n+\n+There are a ton of other compiler options you can explore - over 50! I encourage you to explore the documentation and experiment to find the configuration that works for your project's needs.\n \n # --questions--\n "
        }
    ],
    "stats": {
        "total": 437,
        "additions": 427,
        "deletions": 10
    }
}