{
    "author": "fhsinchy",
    "message": "feat(curriculum): added data structure quiz (#62786)\n\nCo-authored-by: Ilenia <26656284+ilenia-magoni@users.noreply.github.com>\nCo-authored-by: Zaira <33151350+zairahira@users.noreply.github.com>",
    "sha": "3c407ee8d133ec564689763c35cf21920aa746a3",
    "files": [
        {
            "sha": "78d56a93483a3bfdcdedc5d6658d703080b9c37a",
            "filename": "curriculum/challenges/english/blocks/quiz-data-structures/67f41341453c2247fb2828f7.md",
            "status": "modified",
            "additions": 100,
            "deletions": 100,
            "changes": 200,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/3c407ee8d133ec564689763c35cf21920aa746a3/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fquiz-data-structures%2F67f41341453c2247fb2828f7.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/3c407ee8d133ec564689763c35cf21920aa746a3/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fquiz-data-structures%2F67f41341453c2247fb2828f7.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Fquiz-data-structures%2F67f41341453c2247fb2828f7.md?ref=3c407ee8d133ec564689763c35cf21920aa746a3",
            "patch": "@@ -17,439 +17,439 @@ To pass the quiz, you must correctly answer at least 18 of the 20 questions belo\n \n #### --text--\n \n-Placeholder question\n+What does Big O notation describe in algorithm analysis?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+The exact runtime in seconds for a specific computer.\n \n ---\n \n-Placeholder distractor 2\n+The percentage of code lines executed during a run.\n \n ---\n \n-Placeholder distractor 3\n+How readable the code is to other developers.\n \n #### --answer--\n \n-Placeholder answer\n+How the time or space grows relative to input size (an upper bound).\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+When starting an algorithmic challenge, what is the best first step?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+Begin coding immediately to gain momentum.\n \n ---\n \n-Placeholder distractor 2\n+Optimize for performance before you understand the problem.\n \n ---\n \n-Placeholder distractor 3\n+Write unit tests only after finishing the solution.\n \n #### --answer--\n \n-Placeholder answer\n+Clarify the problem and constraints with examples and edge cases.\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+What is the key difference between dynamic arrays and static arrays?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+Dynamic arrays store values of different types; static arrays cannot.\n \n ---\n \n-Placeholder distractor 2\n+Static arrays allow duplicate values; dynamic arrays do not.\n \n ---\n \n-Placeholder distractor 3\n+Dynamic arrays are faster than static arrays for every operation.\n \n #### --answer--\n \n-Placeholder answer\n+Dynamic arrays can grow or shrink by resizing; static arrays have a fixed size.\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+What is the amortized time complexity of appending an element to the end of a dynamic array?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+`O(n)`\n \n ---\n \n-Placeholder distractor 2\n+`O(log n)`\n \n ---\n \n-Placeholder distractor 3\n+`O(n log n)`\n \n #### --answer--\n \n-Placeholder answer\n+`O(1)` amortized.\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+Why does accessing the k-th element by index in a singly linked list take `O(n)` time?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+The list must be resized before any access.\n \n ---\n \n-Placeholder distractor 2\n+The index is hashed and looked up in a table.\n \n ---\n \n-Placeholder distractor 3\n+Nodes are stored contiguously, so shifting is required.\n \n #### --answer--\n \n-Placeholder answer\n+You must traverse from the head node to the k-th node one by one.\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+Which feature does a doubly linked list have that a singly linked list does not?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+Random access to any index in `O(1)` time.\n \n ---\n \n-Placeholder distractor 2\n+A built-in array buffer for faster iteration.\n \n ---\n \n-Placeholder distractor 3\n+Automatic maintenance of the list length as a constant.\n \n #### --answer--\n \n-Placeholder answer\n+Pointers to both next and previous nodes enabling backward traversal.\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+Which of the following best describes a stack?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+First In, First Out (`FIFO`) with removals at the front.\n \n ---\n \n-Placeholder distractor 2\n+A structure where any element can be removed in `O(1)` time.\n \n ---\n \n-Placeholder distractor 3\n+A circular buffer with constant-time random access.\n \n #### --answer--\n \n-Placeholder answer\n+Last In, First Out (`LIFO`) with `push` and `pop` at the top.\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+Which operation removes the element at the front of a queue?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+`push`\n \n ---\n \n-Placeholder distractor 2\n+`pop`\n \n ---\n \n-Placeholder distractor 3\n+`peek`\n \n #### --answer--\n \n-Placeholder answer\n+`dequeue`\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+What is the typical average-case time complexity to look up a value by key in a hash map?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+`O(n)` because all keys must be scanned sequentially.\n \n ---\n \n-Placeholder distractor 2\n+`O(log n)` due to binary search within buckets.\n \n ---\n \n-Placeholder distractor 3\n+`O(n log n)` because keys are sorted during insertion.\n \n #### --answer--\n \n-Placeholder answer\n+`O(1)` on average with a good hash function and low load factor.\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+Which guarantee is provided by a set data structure?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+Elements are stored in sorted order by default.\n \n ---\n \n-Placeholder distractor 2\n+Duplicate values are allowed and kept together.\n \n ---\n \n-Placeholder distractor 3\n+Elements are indexed by their insertion position.\n \n #### --answer--\n \n-Placeholder answer\n+It stores only unique elements (no duplicates).\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+In a dynamic array, what is the worst-case time complexity of inserting an element at index i (not at the end)?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+`O(1)`\n \n ---\n \n-Placeholder distractor 2\n+`O(log n)`\n \n ---\n \n-Placeholder distractor 3\n+`O(1)` amortized\n \n #### --answer--\n \n-Placeholder answer\n+`O(n)`\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+What is the time complexity of inserting a new node at the head of a singly linked list?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+`O(n)`\n \n ---\n \n-Placeholder distractor 2\n+`O(log n)`\n \n ---\n \n-Placeholder distractor 3\n+`O(n log n)`\n \n #### --answer--\n \n-Placeholder answer\n+`O(1)`\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+Which operation returns the top element of a stack without removing it?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+`push`\n \n ---\n \n-Placeholder distractor 2\n+`pop`\n \n ---\n \n-Placeholder distractor 3\n+Insert at bottom.\n \n #### --answer--\n \n-Placeholder answer\n+`peek`\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+Which of the following best describes a queue?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+Last In, First Out (`LIFO`) with removals at the top.\n \n ---\n \n-Placeholder distractor 2\n+Random access to any index in `O(1)` time.\n \n ---\n \n-Placeholder distractor 3\n+Elements are always kept in sorted order automatically.\n \n #### --answer--\n \n-Placeholder answer\n+First In, First Out (`FIFO`) with `enqueue` at the back and `dequeue` at the front.\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+What is a hash collision in a hash map?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+When a key maps to multiple distinct values by design.\n \n ---\n \n-Placeholder distractor 2\n+When two identical keys are stored in different buckets.\n \n ---\n \n-Placeholder distractor 3\n+When the map runs out of memory and must be resized.\n \n #### --answer--\n \n-Placeholder answer\n+When two different keys produce the same hash index.\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+Why do hash maps resize (rehash) as they grow?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+To sort keys in ascending order for faster iteration.\n \n ---\n \n-Placeholder distractor 2\n+To compress values and reduce memory fragmentation.\n \n ---\n \n-Placeholder distractor 3\n+To avoid triggering the language's garbage collector.\n \n #### --answer--\n \n-Placeholder answer\n+To keep the load factor low so that average operations remain `O(1)`.\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+Which statement about sets is true?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+Sets preserve insertion order by definition.\n \n ---\n \n-Placeholder distractor 2\n+Sets allow duplicate elements and keep counts.\n \n ---\n \n-Placeholder distractor 3\n+Set membership tests are `O(n log n)` on average.\n \n #### --answer--\n \n-Placeholder answer\n+Membership tests are typically `O(1)` on average.\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+Which time complexity grows faster than `O(n log n)` as n becomes large?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+`O(n)`\n \n ---\n \n-Placeholder distractor 2\n+`O(log n)`\n \n ---\n \n-Placeholder distractor 3\n+`O(1)`\n \n #### --answer--\n \n-Placeholder answer\n+`O(n^2)`\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+After implementing a brute-force solution, what is a good next step?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+Micro-optimize constant factors before measuring.\n \n ---\n \n-Placeholder distractor 2\n+Discard tests and rewrite the solution from scratch.\n \n ---\n \n-Placeholder distractor 3\n+Avoid considering edge cases to keep the code simple.\n \n #### --answer--\n \n-Placeholder answer\n+Analyze its time/space complexity and optimize identified bottlenecks.\n \n ### --question--\n \n #### --text--\n \n-Placeholder question\n+What does space complexity measure?\n \n #### --distractors--\n \n-Placeholder distractor 1\n+How many CPU cores a program uses.\n \n ---\n \n-Placeholder distractor 2\n+The length of a program in lines of code.\n \n ---\n \n-Placeholder distractor 3\n+How long a program takes to compile.\n \n #### --answer--\n \n-Placeholder answer\n+How memory usage grows relative to input size.\n "
        }
    ],
    "stats": {
        "total": 200,
        "additions": 100,
        "deletions": 100
    }
}