{
    "author": "moT01",
    "message": "feat(curriculum): add functional programming lecture transcripts (#57631)\n\nCo-authored-by: Huyen Nguyen <25715018+huyenltnguyen@users.noreply.github.com>",
    "sha": "1d9277805f67c4b477360f03b27b1c43afd1eda7",
    "files": [
        {
            "sha": "9f51508af5df60e0fcd21557500c6ebf3a482321",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-functional-programming/6733b0451d6be0065430b418.md",
            "status": "modified",
            "additions": 64,
            "deletions": 3,
            "changes": 67,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1d9277805f67c4b477360f03b27b1c43afd1eda7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-functional-programming%2F6733b0451d6be0065430b418.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1d9277805f67c4b477360f03b27b1c43afd1eda7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-functional-programming%2F6733b0451d6be0065430b418.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-functional-programming%2F6733b0451d6be0065430b418.md?ref=1d9277805f67c4b477360f03b27b1c43afd1eda7",
            "patch": "@@ -1,14 +1,75 @@\n ---\n id: 6733b0451d6be0065430b418\n title: What Is Functional Programming?\n-challengeType: 11\n-videoId: nVAaxZ34khk\n+challengeType: 19\n+# videoId: nVAaxZ34khk\n dashedName: what-is-functional-programming\n ---\n \n # --description--\n \n-Watch the video lecture and answer the questions below.\n+The video for this lecture isn't available yet, one will be available soon. Here is a transcript of the lecture for now:\n+\n+Functional programming is about writing code that is clean, predictable, and easier to test and debug. Two key concepts we'll explore today are pure functions and avoiding side effects.\n+\n+Let's start with pure functions. \n+\n+A pure function is a function that, given the same input, will always return the same output, and it doesn't modify anything outside of itself.\n+\n+Here's an example of a pure function:\n+\n+```js\n+function add(a, b) {\n+  return a + b;\n+}\n+```\n+\n+This function is pure because it always returns the same result for the same inputs, and it doesn't change anything outside of itself. No matter how many times you call `add(2, 3)`, it will always return `5`, and it won't affect any other part of your program.\n+\n+Now, let's contrast this with an impure function:\n+\n+```js\n+let total = 0;\n+function addToTotal(value) {\n+  total += value;\n+  return total;\n+}\n+```\n+\n+This function is impure because it modifies a variable outside of itself (`total`). The result of `addToTotal(5)` will be different depending on what `total` was before the function was called. This unpredictability can make our code harder to understand and debug.\n+\n+This brings us to our next important concept and that is side effects.\n+\n+A side effect is any change that occurs in the state of the program when a function is called. This could include modifying a global variable, writing to a file, or making an API call.\n+\n+Pure functions have no side effects but impure functions have these.\n+\n+Avoiding side effects is a key principle of functional programming. When we minimize side effects, our code becomes more predictable and easier to test. \n+\n+While writing code, our main goal should be to make functions do one thing and they should do it very well without changing other parts of our program.\n+\n+Here's an example of a function with a side effect:\n+\n+```js\n+function greet(name) {\n+  console.log(`Hello, ${name}!`);\n+}\n+```\n+\n+This function has a side effect because it interacts with the outside world by logging to the console. \n+\n+In functional programming, we might rewrite this as:\n+\n+```js\n+function greet(name) {\n+  return `Hello, ${name}!`;\n+}\n+console.log(greet(\"Alice\"));\n+```\n+\n+Now `greet` is a pure function that simply returns a string, and we handle the side effect (logging to the console) separately.\n+\n+Functional programming encourages us to compose our programs using pure functions by breaking our code into small, predictable pieces. And thus, we can build programs that are easier to understand, test, and maintain.\n \n # --questions--\n "
        },
        {
            "sha": "06bc707e20b1deb8477069cf4ab34ab05e66b24a",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-functional-programming/6734061fe116df617a564a37.md",
            "status": "modified",
            "additions": 45,
            "deletions": 3,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1d9277805f67c4b477360f03b27b1c43afd1eda7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-functional-programming%2F6734061fe116df617a564a37.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1d9277805f67c4b477360f03b27b1c43afd1eda7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-functional-programming%2F6734061fe116df617a564a37.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-functional-programming%2F6734061fe116df617a564a37.md?ref=1d9277805f67c4b477360f03b27b1c43afd1eda7",
            "patch": "@@ -1,14 +1,56 @@\n ---\n id: 6734061fe116df617a564a37\n title: What Is Currying, and How Does It Work?\n-challengeType: 11\n-videoId: nVAaxZ34khk\n+challengeType: 19\n+# videoId: nVAaxZ34khk\n dashedName: what-is-currying-and-how-does-it-work\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+The video for this lecture isn't available yet, one will be available soon. Here is a transcript of the lecture for now:\n+\n+Currying is a technique where we transform a function that takes multiple arguments into a sequence of functions, each taking a single argument.\n+\n+Let's start with a basic example. Imagine we have a function that adds two numbers:\n+\n+```js\n+function add(a, b) {\n+  return a + b;\n+}\n+\n+console.log(add(3, 4)); // Output: 7\n+```\n+\n+This is a function that takes two arguments and returns their sum. Now, let's see how we can curry this function:\n+\n+```js\n+function curriedAdd(a) {\n+  return function(b) {\n+    return a + b;\n+  }\n+}\n+\n+console.log(curriedAdd(3)(4)); // Output: 7\n+```\n+\n+In this curry converted code, instead of taking two arguments at once, we have a function that takes the first argument and returns another function. This returned function then takes the second argument and performs the addition. We call it like `curriedAdd(3)(4)`, where each pair of parentheses represents a function call.\n+\n+But why would we want to do this? \n+\n+Currying allows us to create some special functions easily. For example, we could create a function that always adds five to any number:\n+\n+```js\n+const addFive = curriedAdd(5);\n+console.log(addFive(10)); // Output: 15\n+console.log(addFive(20)); // Output: 25\n+```\n+\n+Here, `addFive` is a function that's always ready to add five to whatever number we give it. This is a simple example of partial application, where we fix a certain number of arguments to a function, producing another function that takes fewer arguments.\n+\n+While our examples have focused on functions with two arguments, currying can be applied to functions with any number of arguments.\n+\n+As you continue your journey in JavaScript, you'll likely find many situations where currying can make your code cleaner and more expressive.\n \n # --questions--\n "
        }
    ],
    "stats": {
        "total": 115,
        "additions": 109,
        "deletions": 6
    }
}