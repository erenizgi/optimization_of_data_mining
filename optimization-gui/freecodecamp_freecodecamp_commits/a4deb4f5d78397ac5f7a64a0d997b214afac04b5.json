{
    "author": "Ksound22",
    "message": "feat(curriculum): adding searching and sorting review page (#61774)\n\nCo-authored-by: Zaira <33151350+zairahira@users.noreply.github.com>\nCo-authored-by: Sem Bauke <sem@freecodecamp.org>\nCo-authored-by: Dario <105294544+Dario-DC@users.noreply.github.com>",
    "sha": "a4deb4f5d78397ac5f7a64a0d997b214afac04b5",
    "files": [
        {
            "sha": "394477efd7bf3a7dec042b288e45ef0463d3a2b6",
            "filename": "curriculum/challenges/english/25-front-end-development/review-searching-and-sorting-algorithms/67f39de5ff88202c94798189.md",
            "status": "modified",
            "additions": 41,
            "deletions": 4,
            "changes": 45,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/a4deb4f5d78397ac5f7a64a0d997b214afac04b5/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Freview-searching-and-sorting-algorithms%2F67f39de5ff88202c94798189.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/a4deb4f5d78397ac5f7a64a0d997b214afac04b5/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Freview-searching-and-sorting-algorithms%2F67f39de5ff88202c94798189.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Freview-searching-and-sorting-algorithms%2F67f39de5ff88202c94798189.md?ref=a4deb4f5d78397ac5f7a64a0d997b214afac04b5",
            "patch": "@@ -7,13 +7,50 @@ dashedName: review-searching-and-sorting-algorithms\n \n # --description--\n \n-## First topic\n+## Searching Algorithms\n \n-Describe\n+Searching algorithms let you search for a target within a certain list of items.\n \n-## Second topic\n+In computer science, there are two searching algorithms you should know about. They are **linear search** and **binary search** algorithms. It is important to understand the differences between the two algorithms and when to use each one.\n \n-Describe\n+### Linear Search\n+\n+- Linear search iterates through a list of items, checking each item from the beginning until the target item is found.\n+- If the target item is found, the index where it is located in the list is returned.\n+- If the target is not found, it returns `-1`, which means **invalid index** in most programming languages.\n+- Because linear search checks each item until it finds the target, it is not efficient for a large list of items.\n+- The time complexity of linear search is  `O(n)` because the time it takes to search through the list grows linearly with the size of the list.\n+- The space complexity of linear search is `O(1)` because it doesn't require any additional space to search through the list.\n+\n+### Binary Search\n+\n+- Binary search works by dividing a list of items in half, and checking if the target value is in the middle of the list.\n+- The condition for binary search to work is that the items in the list must be in ascending order.\n+- Binary search is a more efficient algorithm for searching through a large list of items because it divides the list of items in half and ignores any half where the target is not found.\n+- If the target item is found in the middle of the list, the index of the target item is returned.\n+- If the item is not found, the algorithm checks if the target item is in the left or right half of the list.\n+- It continues to divide the remaining parts of the list into halves until the target item is found.\n+- If the target item is finally not found in the list, it returns `-1`\n+- The time complexity of binary search is `O(log n)` because the time it takes to search through the list grows logarithmically with the size of the list.\n+- The space complexity of binary search is `O(1)` because it doesn't require any additional space to search through the list.\n+\n+### How Linear Search Differs from Binary Search \n+\n+- Binary search is more suitable for a large list of items compared to linear search.\n+- The time complexity of linear search is  `O(n)` because the time it takes to search through the list grows linearly with the size of the list.\n+- The time complexity of binary search is `O(log n)` because the time it takes to search through the list grows logarithmically with the size of the list.\n+\n+## Sorting Algorithms and Divide-and-Conquer\n+\n+In computer science, divide-and-conquer is a technique used to break down a problem into smaller sub-problems so they are easier to solve. Recursion is the technique often employed in divide-and-conquer, and divide-and-conquer is a powerful strategy used to implement many efficient sorting algorithms like merge sort.\n+\n+### Merge Sort\n+\n+- Merge sort is a sorting algorithm that follows the divide-and-conquer approach.\n+- It works by recursively dividing a list into smaller sub-lists until each sub-list contains only one element.\n+- It then repeatedly merges the sub-lists back together in a sorted order.\n+- The time complexity for merge sort is `O(n log n)` because the list is continuously divided in half `(log n)` and then merged together `(O(n))`.\n+- The space complexity of merge sort is `O(n)` because it is not an in-place sorting algorithm.\n \n # --assignment--\n "
        }
    ],
    "stats": {
        "total": 45,
        "additions": 41,
        "deletions": 4
    }
}