{
    "author": "majestic-owl448",
    "message": "feat: add classes and objects lectures (#61327)\n\nCo-authored-by: Dario-DC <105294544+Dario-DC@users.noreply.github.com>",
    "sha": "1794a243acbdef46d1b21966cd99f0f7ebe681e1",
    "files": [
        {
            "sha": "aae0c4606ac07d64215defab831b0097bcb9b53e",
            "filename": "curriculum/challenges/_meta/lecture-classes-and-objects/meta.json",
            "status": "modified",
            "additions": 15,
            "deletions": 2,
            "changes": 17,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1794a243acbdef46d1b21966cd99f0f7ebe681e1/curriculum%2Fchallenges%2F_meta%2Flecture-classes-and-objects%2Fmeta.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1794a243acbdef46d1b21966cd99f0f7ebe681e1/curriculum%2Fchallenges%2F_meta%2Flecture-classes-and-objects%2Fmeta.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2F_meta%2Flecture-classes-and-objects%2Fmeta.json?ref=1794a243acbdef46d1b21966cd99f0f7ebe681e1",
            "patch": "@@ -5,6 +5,19 @@\n   \"blockType\": \"lecture\",\n   \"blockLayout\": \"challenge-list\",\n   \"superBlock\": \"full-stack-developer\",\n-  \"challengeOrder\": [{ \"id\": \"68420bd261d0d35f61922d4b\", \"title\": \"Step 1\" }],\n+  \"challengeOrder\": [\n+    {\n+      \"id\": \"68420bd261d0d35f61922d4b\",\n+      \"title\": \"How Do Classes Work and How Do They Differ From Objects?\"\n+    },\n+    {\n+      \"id\": \"6874b5fc38f90f25e18093ce\",\n+      \"title\": \"What Are Methods and Attributes, and How Do They Work?\"\n+    },\n+    {\n+      \"id\": \"6874b7d3b286c538b39d0c25\",\n+      \"title\": \"What Are Special Methods and What Are They Used For?\"\n+    }\n+  ],\n   \"helpCategory\": \"Python\"\n-}\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "50a72f7db738602d6f1142795284558527a498ed",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-classes-and-objects/68420bd261d0d35f61922d4b.md",
            "status": "modified",
            "additions": 129,
            "deletions": 46,
            "changes": 175,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1794a243acbdef46d1b21966cd99f0f7ebe681e1/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-classes-and-objects%2F68420bd261d0d35f61922d4b.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1794a243acbdef46d1b21966cd99f0f7ebe681e1/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-classes-and-objects%2F68420bd261d0d35f61922d4b.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-classes-and-objects%2F68420bd261d0d35f61922d4b.md?ref=1794a243acbdef46d1b21966cd99f0f7ebe681e1",
            "patch": "@@ -1,137 +1,220 @@\n ---\n id: 68420bd261d0d35f61922d4b\n-# title needs to be updated to correct title when lectures are finalized\n-title: Classes and Objects\n-# change back to 11 when video is added\n+title: How Do Classes Work and How Do They Differ From Objects?\n challengeType: 19\n-# videoId: new-id-goes-here-when-ready\n-# dashedName needs to be updated to correct title when lectures are finalized\n-dashedName: lecture-classes-and-objects\n+dashedName: how-do-classes-work-and-how-do-they-differ-from-objects\n ---\n \n # --description--\n \n-Watch the video or read the transcript and answer the questions below.\n+In Python, classes and objects work hand in hand to organize and manage data. You build a class to define shared behavior, then create objects that use those behaviors.\n+\n+In other words, a class is like a blueprint or template you use to create objects with.\n+\n+Let's look at what classes are, and how to use them to create objects.\n+\n+To create a class, you use the `class` keyword followed by the name of the class and a colon. Then within the class, you can add an initializer, along with any attributes and methods.\n+\n+Attributes are like variables within a class, and are used to store data. Methods are functions defined within a class, and are the actions objects created with a class can perform.\n+\n+Here's the basic syntax of a class:\n+\n+```python\n+class ClassName:\n+    def __init__(self, name, age):\n+        self.name = name\n+        self.age = age\n+\n+    def sample_method(self):               \n+        print(self.name.upper())\n+```\n+\n+* `class ClassName` is made up of the `class` keyword to create a class, followed by the name of the class, here called `ClassName`. It is common in Python to use the **PascalCase** convention when naming classes.\n+    \n+* `def __init__(self, name, age)` is the special method automatically called when a new object is created. It initializes the attributes of the objects that will be created with the class.\n+    \n+    In addition to that, the first parameter of `__init__` is always a reference to the specific object being created or used. By convention, this parameter is named `self`, but technically, you can use any name. `self` lets you access the object's own attributes and methods.\n+    \n+* `self.name = name` and `self.age = age` are the attributes the objects will have.\n+    \n+* `def sample_method(self):` is the method each object created can call.\n+    \n+* `print(self.name.upper())` is what the `sample_method` method will do, in this case, it prints the name in uppercase.\n+    \n+\n+If that all sounds like a lot, don't worry. Let's take a look at a similar example of a `Dog` class, and how you can create objects from that:\n+\n+```python\n+class Dog:\n+    def __init__(self, name, age):\n+        self.name = name\n+        self.age = age\n+\n+    def bark(self):\n+        print(f\"{self.name.upper()} says woof woof!\")\n+```\n+\n+With this `Dog` class, you can create an object. Here's the basic syntax for creating objects from a class:\n+\n+```python\n+object_1 = ClassName(attribute_1, attribute_2)\n+object_2 = ClassName(attribute_1, attribute_2)\n+```\n+\n+You can also call any of the methods defined in the class from each object:\n+\n+```python\n+object_1.method_name()\n+object_2.method_name()\n+```\n+\n+Now let's create two dogs by using the `Dog` class as the blueprint:\n+\n+```python\n+class Dog:\n+    def __init__(self, name, age):\n+        self.name = name\n+        self.age = age\n+\n+    def bark(self):\n+        print(f\"{self.name.upper()} says woof woof! I'm {self.age} years old!\")\n+\n+dog_1 = Dog(\"Jack\", 3)\n+dog_2 = Dog(\"Thatcher\", 5)\n+\n+# Call the bark method\n+dog_1.bark()  # JACK says woof woof! I'm 3 years old!\n+dog_2.bark()  # THATCHER says woof woof! I'm 5 years old!\n+```\n+\n+As you can see, we create two dog objects using the `Dog` class. When initializing `dog_1`, the string `Jack` and the number `3` are passed, which sets the `name` and `age` attributes for that instance. And `dog_2` is initialized with the string `Thatcher` and number `5` as its `name` and `age`, respectively.\n+\n+Then when you call the `.bark()` method on `dog_1` and `dog_2`, you can see how both outputs differ, and use the unique `name` and `age` attributes you passed in when creating each object.\n+\n+In summary, the difference between a class and an object is that a class is the template or the blueprint, and an object is what is created using that template.\n+\n+Also, a class defines what data and behavior the object should have, and an object holds the actual data and uses that behavior. You write a class once, and you can make many objects from it, each with different data.\n+\n \n # --questions--\n \n ## --text--\n \n-Question 1\n+What is the output of this code?\n+\n+```python\n+class Dog:  \n+    def __init__(self, name):  \n+        self.name = name\n+\n+    def bark(self):  \n+        print(f\"{self.name} says Woof!\")  \n+\n+my_dog = Dog(\"Rex\")\n+print(my_dog.name)\n+```\n \n ## --answers--\n \n-Answer 1.1\n+`Rex says Woof!`\n \n ### --feedback--\n \n-Feedback 1\n+Look at what is being printed: is it calling a method or accessing an attribute?\n \n ---\n \n-Answer 1.2\n+`name`\n \n ### --feedback--\n \n-Feedback 1\n+Look at what is being printed: is it calling a method or accessing an attribute?\n \n ---\n \n-Answer 1.3\n-\n-### --feedback--\n-\n-Feedback 1\n+`Rex`\n \n ---\n \n-Answer 1.4\n+Error\n \n ### --feedback--\n \n-Feedback 1\n+Look at what is being printed: is it calling a method or accessing an attribute?\n \n ## --video-solution--\n \n-5\n+3\n \n ## --text--\n \n-Question 2\n+What is the special method that gets automatically called when a new object is created?\n \n ## --answers--\n \n-Answer 2.1\n+`__create_object__`\n \n ### --feedback--\n \n-Feedback 2\n+Think about what initializes the attributes an object will have.\n \n ---\n \n-Answer 2.2\n-\n-### --feedback--\n-\n-Feedback 2\n+`__init__`\n \n ---\n \n-Answer 2.3\n+`__new__`\n \n ### --feedback--\n \n-Feedback 2\n+Think about what initializes the attributes an object will have.\n \n ---\n \n-Answer 2.4\n+`__setup__`\n \n ### --feedback--\n \n-Feedback 2\n+Think about what initializes the attributes an object will have.\n \n ## --video-solution--\n \n-5\n+2\n \n ## --text--\n \n-Question 3\n+What is the blueprint or template for creating objects?\n \n ## --answers--\n \n-Answer 3.1\n+A variable\n \n ### --feedback--\n \n-Feedback 3\n+Think about what defines the structure and behavior of objects created from it.\n \n ---\n \n-Answer 3.2\n+A function\n \n ### --feedback--\n \n-Feedback 3\n+Think about what defines the structure and behavior of objects created from it.\n \n ---\n \n-Answer 3.3\n-\n-### --feedback--\n-\n-Feedback 3\n+A class\n \n ---\n \n-Answer 3.4\n+A loop\n \n ### --feedback--\n \n-Feedback 3\n+Think about what defines the structure and behavior of objects created from it.\n \n ## --video-solution--\n \n-5\n+3\n "
        },
        {
            "sha": "68b65b820cbdd3d4453aeea4c608066a10cfa7ed",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-classes-and-objects/6874b5fc38f90f25e18093ce.md",
            "status": "added",
            "additions": 209,
            "deletions": 0,
            "changes": 209,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1794a243acbdef46d1b21966cd99f0f7ebe681e1/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-classes-and-objects%2F6874b5fc38f90f25e18093ce.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1794a243acbdef46d1b21966cd99f0f7ebe681e1/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-classes-and-objects%2F6874b5fc38f90f25e18093ce.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-classes-and-objects%2F6874b5fc38f90f25e18093ce.md?ref=1794a243acbdef46d1b21966cd99f0f7ebe681e1",
            "patch": "@@ -0,0 +1,209 @@\n+---\n+id: 6874b5fc38f90f25e18093ce\n+title: What Are Methods and Attributes, and How Do They Work?\n+challengeType: 19\n+dashedName: what-are-methods-and-attributes-and-how-do-they-work\n+---\n+\n+# --description--\n+\n+In the last lecture, you learned about classes and how they act as blueprints for creating objects.\n+\n+Here, we will dive deeper into attributes and methods.\n+\n+Let's take a closer look at attributes first, then methods.\n+\n+Attributes are variables that belong to an object, so they hold data. There are two kinds of attributes: instance attributes and class attributes.\n+\n+Instance attributes are unique to each object created from a class, and you usually set them with the `__init__` method. Class attributes, on the other hand, belong to the class itself and are shared by all instances of that class.\n+\n+To access an attribute, you use dot notation.\n+\n+Here are examples of both instance and class attributes, and how to access them from objects:\n+\n+```python\n+class Dog:\n+    species = \"French Bulldog\" # Class attribute\n+\n+    def __init__(self, name):\n+        self.name = name # Instance attribute\n+\n+print(Dog.species) # French Bulldog\n+\n+dog1 = Dog(\"Jack\")\n+print(dog1.name)    # Jack\n+print(dog1.species) # French Bulldog\n+\n+dog2 = Dog(\"Tom\")\n+print(dog2.name)    # Tom\n+print(dog2.species) # French Bulldog\n+```\n+\n+Note that you can access class attributes directly from the class itself, but you need to create an object and pass it data first before you can access instance attributes.\n+\n+Cars are another good example, since all cars have a model and color:\n+\n+```python\n+class Car:\n+    def __init__(self, color, model):\n+        self.color = color\n+        self.model = model\n+\n+car_1 = Car(\"red\", \"Toyota Corolla\")\n+car_2 = Car(\"green\", \"Lamborghini Revuelto\")\n+\n+print(car_1.model) # Toyota Corolla\n+print(car_2.model) # Lamborghini Revuelto\n+\n+print(car_1.color) # red\n+print(car_2.color) # green\n+```\n+\n+Methods are functions defined inside a class. With them, any object defined from a class can perform actions that operate on or modify its own data. You also access a method with dot notation.\n+\n+For example, dogs can bark. So we can have a `bark` method in the `Dog` class like you saw in a previous lecture:\n+\n+```python\n+class Dog:\n+   species = \"French Bulldog\"\n+\n+   def __init__(self, name):\n+     self.name = name\n+\n+   def bark(self):\n+       return f\"{self.name} says woof woof!\"\n+\n+jack = Dog(\"Jack\")\n+jill = Dog(\"Jill\")\n+\n+print(jack.bark()) # Jack says woof woof!\n+print(jill.bark()) # Jill says woof woof!\n+```\n+\n+A `Car` class can also have a `describe` method:\n+\n+```python\n+class Car:\n+    def __init__(self, color, model):\n+        self.color = color  # Instance attribute\n+        self.model = model  # Instance attribute\n+\n+    def describe(self):\n+        return f\"This car is a {self.color} {self.model}\"\n+\n+car_1 = Car(\"red\", \"Toyota Corolla\")\n+car_2 = Car(\"green\", \"Lamborghini Revuelto\")\n+\n+print(car_1.describe()) # This car is a red Toyota Corolla\n+print(car_2.describe()) # This car is a green Lamborghini Revuelto\n+```\n+\n+# --questions--\n+\n+## --text--\n+\n+What are the two types of attributes in Python?\n+\n+## --answers--\n+\n+Public and private attributes\n+\n+### --feedback--\n+\n+Think about the two ways you can define attributes.\n+\n+---\n+\n+Local and global attributes\n+\n+### --feedback--\n+\n+Think about the two ways you can define attributes.\n+\n+---\n+\n+Instance attributes and class attributes\n+\n+---\n+\n+Mutable and immutable attributes\n+\n+### --feedback--\n+\n+Think about the two ways you can define attributes.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+What is required to access instance attributes?\n+\n+## --answers--\n+\n+The class name only\n+\n+### --feedback--\n+\n+Think about how you access class attributes versus how you access instance attributes.\n+\n+---\n+\n+Decorators\n+\n+### --feedback--\n+\n+Think about how you access class attributes versus how you access instance attributes.\n+\n+---\n+\n+An instance or object of the class\n+\n+---\n+\n+A static method\n+\n+### --feedback--\n+\n+Think about how you access class attributes versus how you access instance attributes.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+How do you define and access methods?\n+\n+## --answers--\n+\n+As standalone functions outside a class, accessed with brackets\n+\n+### --feedback--\n+\n+They belong to the class but operate on object data.\n+\n+---\n+\n+As variables in a class, accessed like attributes\n+\n+### --feedback--\n+\n+They belong to the class but operate on object data.\n+\n+---\n+\n+With special keywords, called automatically\n+\n+### --feedback--\n+\n+They belong to the class but operate on object data.\n+\n+---\n+\n+They are defined inside a class and accessed with dot notation\n+\n+## --video-solution--\n+\n+4"
        },
        {
            "sha": "892df9af129e216e3aced07eea921391dd928268",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-classes-and-objects/6874b7d3b286c538b39d0c25.md",
            "status": "added",
            "additions": 280,
            "deletions": 0,
            "changes": 280,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1794a243acbdef46d1b21966cd99f0f7ebe681e1/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-classes-and-objects%2F6874b7d3b286c538b39d0c25.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1794a243acbdef46d1b21966cd99f0f7ebe681e1/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-classes-and-objects%2F6874b7d3b286c538b39d0c25.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-classes-and-objects%2F6874b7d3b286c538b39d0c25.md?ref=1794a243acbdef46d1b21966cd99f0f7ebe681e1",
            "patch": "@@ -0,0 +1,280 @@\n+---\n+id: 6874b7d3b286c538b39d0c25\n+title: What Are Special Methods and What Are They Used For?\n+challengeType: 19\n+dashedName: what-are-special-methods-and-what-are-they-used-for\n+---\n+\n+# --description--\n+\n+Special methods in Python, also known as \"magic methods\" or \"dunder methods\", are special Python methods that start and end with double underscores (`__`). The word \"dunder\" itself comes from double underscores (**d** for double, **under** for underscores).\n+\n+You've probably used special methods already without knowing it. Every time you write something like `3 + 4`, Python quietly runs `3.__add__(4)` under the hood. That's a special method in action. So while you *can* call special methods directly, you rarely do. Something like `3 + 4` is much clearer and easier to read than calling `3.__add__(4)` yourself.\n+\n+Apart from `__add__`, `__init__()` is another special method you'll see and use the most, as it's a class initializer. There are also others like `__len__()` and `__str__()`.\n+\n+Think of special methods as the directors of the activities between a person programming and the Python language interpreter itself.\n+\n+Remember, you don't need to call special methods directly. Instead, Python automatically calls them when certain actions happen. These operations include:\n+\n+- **Arithmetic operations like addition, subtraction, multiplication, division, and others**. In addition, `__add__()` is called, `__sub__()` for subtraction, `__mul__()` for multiplication, and `__truediv__()` for division.\n+    \n+- **String operations like concatenation, repetition, formatting, and conversion to text**. `__add__()` is called for concatenation, `__mul__()` for repetition, `__format__()` for formatting, `__str__()` and `__repr__()` for text conversion, and so on.\n+    \n+- **Comparison operations like equality, less-than, greater-than, and others**. `__eq__()` is called for equality checks, `__lt__()` for less-than, `__gt__()` for greater-than, and so on.\n+    \n+- **Iteration operations like making an object iterable and advancing through items**. `__iter__()` is called to return an iterator and  `__next__()` to fetch the next item.\n+    \n+\n+Normally, Python data types like strings and numbers already know how to add things, do concatenation, compare for equality, be used in loops, and others.\n+\n+But when you create your own class, Python won't know how to handle things automatically.\n+\n+This is where special methods come in — they let you customize Python's built-in behavior.\n+\n+Let's say you want to get the number of pages in book objects created with the class below, or compare them and get a readable string of the objects. Here's what happens without special methods:\n+\n+```python\n+class Book:\n+   def __init__(self, title, pages):\n+       self.title = title\n+       self.pages = pages\n+\n+book1 = Book(\"Built Wealth Like a Boss\", 420)\n+book2 = Book(\"Be Your Own Start\", 420)\n+\n+print(len(book1)) # TypeError: object of type 'Book' has no len()\n+print(str(book1)) # <__main__.Book object at 0x102ed2900>\n+print(book1 == book2) # False even though they have the same number of pages\n+```\n+\n+In the example:\n+\n+- `len(book1)` failed because Python doesn't know how to get the length of your book object without `__len__()`\n+    \n+- `str(book1)` printed something like `<__main__.Book object at 0x102ed2900>` because that's the default representation when you don't use `__str__()`\n+    \n+- `book1 == book2` resulted in `False` because Python just checks if both objects are the same in memory, not by content.\n+    \n+\n+Here's how you can define your own `__len__()`, `__str__()`, and `__eq__()` special methods to make working with objects created from the `Book` class easier:\n+\n+```python\n+class Book:\n+   def __init__(self, title, pages):\n+       self.title = title\n+       self.pages = pages\n+\n+   def __len__(self):\n+       return self.pages\n+\n+   def __str__(self):\n+       return f\"'{self.title}' has {self.pages} pages\"\n+\n+   def __eq__(self, other):\n+       return self.pages == other.pages\n+  \n+book1 = Book(\"Built Wealth Like a Boss\", 420)\n+book2 = Book(\"Be Your Own Start\", 420)\n+\n+print(len(book1)) # 420\n+print(len(book2)) # 420\n+print(str(book1)) # 'Built Wealth Like a Boss' has 420 pages\n+print(str(book2)) # 'Be Your Own Start' has 420 pages\n+print(book1 == book2) # True\n+```\n+\n+Another example is a shopping cart where you do the following:\n+\n+- Add items to the cart\n+    \n+- Remove items from the cart\n+    \n+- Get the number of items in the cart\n+    \n+- Check what items are in the cart\n+    \n+- Check if a specific item is in the cart\n+    \n+- Return or display an item at a specific index in the cart\n+    \n+\n+While you might have a method that adds items to the cart and removes certain items from the cart, you can create special methods for all the other functionality:\n+\n+- `__len__()` to get the length of the items in the cart\n+    \n+- `__iter__()` to loop through the items in the cart so you can see them\n+    \n+- `__contains__()` to check if a specific item is in the cart\n+    \n+- `__getitem__()` to return or display an item at a specific index in the cart\n+    \n+\n+Here's an example of a `Cart` class with these user-defined methods and special methods:\n+\n+```python\n+class Cart:\n+   def __init__(self):\n+       self.items = []\n+\n+   def add(self, item):\n+       self.items.append(item)\n+\n+   def remove(self, item):\n+       if item in self.items:\n+           self.items.remove(item)\n+       else:\n+           print(f'{item} is not in cart')\n+\n+   def list_items(self):\n+       return self.items\n+\n+   def __len__(self):\n+       return len(self.items)\n+\n+   def __getitem__(self, index):\n+       return self.items[index]\n+\n+   def __contains__(self, item):\n+       return item in self.items\n+\n+   def __iter__(self):\n+       return iter(self.items)\n+```\n+\n+And here's how you can use them:\n+\n+```python\n+cart = Cart()\n+cart.add('Laptop')\n+cart.add('Wireless mouse')\n+cart.add('Ergo keyboard')\n+cart.add('Monitor')\n+\n+for item in cart:\n+   print(item, end=' ') # Laptop Wireless mouse Ergo keyboard Monitor\n+\n+print(len(cart)) # 4\n+print(cart[3]) # Monitor\n+\n+print('Monitor' in cart) # True\n+print('banana' in cart) # False\n+\n+cart.remove('Ergo keyboard')\n+\n+print(cart.list_items()) # ['Laptop', 'Wireless mouse', 'Monitor']\n+\n+cart.remove('banana') # banana is not in cart\n+```\n+\n+And those are a few ways you'll use special methods in Python in the real-world.\n+\n+# --questions--\n+\n+## --text--\n+\n+Which of these is the special method called during an addition operation?\n+\n+## --answers--\n+\n+`__plus__()`\n+\n+### --feedback--\n+\n+Look out for what is triggered when you use the `+` operator.\n+\n+---\n+\n+`__sum__()`\n+\n+### --feedback--\n+\n+Look out for what is triggered when you use the `+` operator.\n+\n+---\n+\n+`__add__()`\n+\n+---\n+\n+`__concat__()`\n+\n+### --feedback--\n+\n+Look out for what is triggered when you use the `+` operator.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+How was the word \"dunder\" derived?\n+\n+## --answers--\n+\n+From \"dynamic under-the-hood operations\"\n+\n+### --feedback--\n+\n+Think about how the word \"dunder\" is related to how dunder methods are written.\n+\n+---\n+\n+From shortening \"double underscore\" (`__`)\n+\n+---\n+\n+From the creator of Python's nickname\n+\n+### --feedback--\n+\n+Think about how the word \"dunder\" is related to how dunder methods are written.\n+\n+---\n+\n+From \"data under\" in reference to hidden methods\n+\n+### --feedback--\n+\n+Think about how the word \"dunder\" is related to how dunder methods are written.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+Which special method is called when you use the greater-than (`>`) comparison operator?\n+\n+## --answers--\n+\n+`__more__()`\n+\n+### --feedback--\n+\n+It stands for \"greater than\" and is triggered by the `>` operator.\n+\n+---\n+\n+`__compare__()`\n+\n+### --feedback--\n+\n+It stands for \"greater than\" and is triggered by the `>` operator.\n+\n+---\n+\n+`__greater__()`\n+\n+### --feedback--\n+\n+It stands for \"greater than\" and is triggered by the `>` operator.\n+\n+---\n+\n+`__gt__()`\n+\n+## --video-solution--\n+\n+4"
        }
    ],
    "stats": {
        "total": 681,
        "additions": 633,
        "deletions": 48
    }
}