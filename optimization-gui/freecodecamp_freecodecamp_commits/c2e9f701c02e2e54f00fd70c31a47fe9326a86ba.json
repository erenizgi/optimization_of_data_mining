{
    "author": "ojeytonwilliams",
    "message": "fix(client): prevent scene audio from stopping early (#58043)",
    "sha": "c2e9f701c02e2e54f00fd70c31a47fe9326a86ba",
    "files": [
        {
            "sha": "d74118850f7563c30f76cfffa3ced7d498dd38df",
            "filename": "client/src/redux/prop-types.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/c2e9f701c02e2e54f00fd70c31a47fe9326a86ba/client%2Fsrc%2Fredux%2Fprop-types.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/c2e9f701c02e2e54f00fd70c31a47fe9326a86ba/client%2Fsrc%2Fredux%2Fprop-types.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Fredux%2Fprop-types.ts?ref=c2e9f701c02e2e54f00fd70c31a47fe9326a86ba",
            "patch": "@@ -130,8 +130,8 @@ interface SetupCharacter {\n interface SetupAudio {\n   filename: string;\n   startTime: number;\n-  startTimestamp?: number;\n-  finishTimestamp?: number;\n+  startTimestamp: number | null;\n+  finishTimestamp: number | null;\n }\n \n interface SceneSetup {"
        },
        {
            "sha": "78991eb1baf24245fea258c6181c67fde3f9ad85",
            "filename": "client/src/templates/Challenges/components/scene/scene.tsx",
            "status": "modified",
            "additions": 164,
            "deletions": 134,
            "changes": 298,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/c2e9f701c02e2e54f00fd70c31a47fe9326a86ba/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fscene%2Fscene.tsx",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/c2e9f701c02e2e54f00fd70c31a47fe9326a86ba/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fscene%2Fscene.tsx",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fscene%2Fscene.tsx?ref=c2e9f701c02e2e54f00fd70c31a47fe9326a86ba",
            "patch": "@@ -1,5 +1,12 @@\n-import React, { useEffect, useState, useRef, useMemo } from 'react'; //, ReactElement } from 'react';\n+import React, {\n+  useEffect,\n+  useState,\n+  useRef,\n+  useMemo,\n+  useCallback\n+} from 'react';\n import { Col, Spacer } from '@freecodecamp/ui';\n+import { isEmpty } from 'lodash-es';\n import { useTranslation } from 'react-i18next';\n import { FullScene } from '../../../../redux/prop-types';\n import { Loader } from '../../../../components/helpers';\n@@ -10,9 +17,7 @@ import { SceneSubject } from './scene-subject';\n \n import './scene.css';\n \n-const sToMs = (n: number) => {\n-  return n * 1000;\n-};\n+const sToMs = (n: number) => n * 1000;\n \n const loadImage = (src: string | null) => {\n   if (src) new Image().src = src;\n@@ -31,24 +36,24 @@ export function Scene({\n   const canPauseRef = useRef(false);\n   const { setup, commands } = scene;\n   const { audio, alwaysShowDialogue } = setup;\n-  const { startTimestamp = null, finishTimestamp = null } = audio;\n-\n-  const hasTimestamps = startTimestamp !== null && finishTimestamp !== null;\n-  const audioTimestamp = hasTimestamps ? `#t=${startTimestamp}` : '';\n \n   const audioRef = useRef<HTMLAudioElement>(new Audio());\n \n   // if there are timestamps, we use the difference between them as the duration\n   // if not, we assume we're playing the whole audio file.\n-  const duration = hasTimestamps\n-    ? sToMs(finishTimestamp - startTimestamp)\n-    : Infinity;\n+  const duration =\n+    audio.startTimestamp !== null && audio.finishTimestamp !== null\n+      ? sToMs(audio.finishTimestamp - audio.startTimestamp)\n+      : Infinity;\n \n   // on mount\n   useEffect(() => {\n     const { current } = audioRef;\n+    const { audio } = setup;\n \n     if (current) {\n+      const audioTimestamp =\n+        duration !== Infinity ? `#t=${audio.startTimestamp}` : '';\n       current.volume = 1;\n       current.addEventListener('canplaythrough', audioLoaded);\n       current.src = `${sounds}/${audio.filename}${audioTimestamp}`;\n@@ -78,14 +83,7 @@ export function Scene({\n         current.removeEventListener('canplaythrough', audioLoaded);\n       }\n     };\n-  }, [\n-    audioRef,\n-    audio.filename,\n-    audioTimestamp,\n-    setup.background,\n-    setup.characters,\n-    commands\n-  ]);\n+  }, [audioRef, duration, setup, commands]);\n \n   const initBackground = setup.background;\n \n@@ -111,6 +109,39 @@ export function Scene({\n   const [dialogue, setDialogue] = useState(initDialogue);\n   const [background, setBackground] = useState(initBackground);\n   const startRef = useRef<number>(0);\n+  const startTimerRef = useRef<number>();\n+  const finishTimerRef = useRef<number>();\n+  const animationRef = useRef<number>();\n+  const usedCommandsRef = useRef(new Set<number>());\n+\n+  const [currentTime, setCurrentTime] = useState(0);\n+  // TODO: I'm using a ref so that the maybeStopAudio closure doesn't get stuck\n+  // with the initial value of isPlaying. Given that we also have a state,\n+  // isPlaying, it feels like there's a better way.\n+  const isPlayingSceneRef = useRef(false);\n+\n+  // memoizing to prevent the useEffect from running on every render\n+  const sortedCommands = useMemo(() => {\n+    const normalized = commands.flatMap(command => {\n+      const { startTime, finishTime, ...rest } = command;\n+\n+      const startCommand = {\n+        ...rest,\n+        time: sToMs(startTime),\n+        isTalking: !!rest.dialogue\n+      };\n+      const finishCommand = finishTime\n+        ? { ...rest, time: sToMs(finishTime), isTalking: false }\n+        : null;\n+\n+      return finishCommand ? [startCommand, finishCommand] : [startCommand];\n+    });\n+    normalized.sort((a, b) => a.time - b.time);\n+    return normalized;\n+  }, [commands]);\n+\n+  // an extra 500ms at the end to let the characters fade out (CSS transition\n+  const resetTime = sortedCommands.at(-1)!.time + 500;\n \n   const audioLoaded = () => {\n     setSceneIsReady(true);\n@@ -122,132 +153,131 @@ export function Scene({\n     canPauseRef.current = false;\n   };\n \n-  useEffect(() => {\n-    const playScene = () => {\n-      // TODO: if we manage the playing state in another module, we should not\n-      // need the early return here. It should not be possible for this to be\n-      // called at all if the scene is already playing.\n-      if (isPlaying || !sceneIsReady) return;\n-      setIsPlaying(true);\n-      setShowDialogue(true);\n-\n-      setTimeout(() => {\n-        if (audioRef.current.paused) {\n-          startRef.current = Date.now();\n-          void audioRef.current.play().then(() => {\n-            canPauseRef.current = true;\n-          });\n-        }\n-        // if there are no timestamps, we can let the audio play to the end\n-        if (hasTimestamps) maybeStopAudio();\n-      }, sToMs(audio.startTime));\n-\n-      commands.forEach((command, commandIndex) => {\n-        // Start command timeout\n-        setTimeout(() => {\n-          if (command.background) setBackground(command.background);\n-\n-          setDialogue(\n-            command.dialogue\n-              ? { ...command.dialogue, label: command.character }\n-              : initDialogue\n-          );\n-\n-          setCharacters(prevCharacters => {\n-            const newCharacters = prevCharacters.map(character => {\n-              if (character.character === command.character) {\n-                return {\n-                  ...character,\n-                  position: command.position ?? character.position,\n-                  opacity: command.opacity ?? character.opacity,\n-                  isTalking: command.dialogue ? true : false\n-                };\n-              }\n-              return character;\n-            });\n-            return newCharacters;\n-          });\n-        }, sToMs(command.startTime));\n-\n-        // Finish command timeout, only used when there's a dialogue\n-        if (command.dialogue) {\n-          setTimeout(\n-            () => {\n-              setCharacters(prevCharacters => {\n-                const newCharacters = prevCharacters.map(character => {\n-                  if (character.character === command.character) {\n-                    return {\n-                      ...character,\n-                      isTalking: false\n-                    };\n-                  }\n-                  return character;\n-                });\n-                return newCharacters;\n-              });\n-            },\n-            sToMs(command.finishTime as number)\n-          );\n-        }\n+  const playScene = useCallback(() => {\n+    const updateCurrentTime = () => {\n+      const time = Date.now() - startRef.current;\n+      setCurrentTime(time);\n \n-        // Last command timeout\n-        if (commandIndex === commands.length - 1) {\n-          setTimeout(\n-            resetScene,\n-            // an extra 500ms at the end to let the characters fade out (CSS transition)\n-            command.finishTime\n-              ? sToMs(command.finishTime) + 500\n-              : sToMs(command.startTime) + 500\n-          );\n-        }\n-      });\n+      if (isPlayingSceneRef.current) {\n+        animationRef.current = window.requestAnimationFrame(updateCurrentTime);\n+      }\n     };\n-\n-    const resetScene = () => {\n-      const { current } = audioRef;\n-      pause();\n-      if (current) {\n-        current.src = `${sounds}/${audio.filename}${audioTimestamp}`;\n-        current.load();\n-        current.currentTime = audio.startTimestamp || 0;\n+    // TODO: if we manage the playing state in another module, we should not\n+    // need the early return here. It should not be possible for this to be\n+    // called at all if the scene is already playing.\n+    if (isPlaying || !sceneIsReady) return;\n+    setIsPlaying(true);\n+    isPlayingSceneRef.current = true;\n+    startRef.current = Date.now();\n+    setShowDialogue(true);\n+\n+    updateCurrentTime();\n+\n+    // @ts-expect-error it's not a node timer\n+    startTimerRef.current = setTimeout(() => {\n+      if (audioRef.current.paused) {\n+        void audioRef.current.play().then(() => {\n+          canPauseRef.current = true;\n+        });\n       }\n+    }, sToMs(audio.startTime));\n+\n+    // @ts-expect-error it's not a node timer\n+    finishTimerRef.current = setTimeout(\n+      () => {\n+        if (duration !== Infinity) {\n+          const endTimeStamp = sToMs(audio.finishTimestamp!); // it exists because duration is not Infinity\n+          const audioCurrentTime = sToMs(audioRef.current.currentTime);\n+          const remainingTime = endTimeStamp - audioCurrentTime;\n+          // For some reason, despite the setTimeout resolving at the right\n+          // time, the currentTime can be smaller than expected. That means\n+          // that if we pause now it will cut off the last part.\n+          if (remainingTime < 100) {\n+            // 100ms is arbitrary and may need to be adjusted if people still\n+            // notice the cut off\n+\n+            pause();\n+          } else {\n+            // @ts-expect-error it's not a node timer\n+            finishTimerRef.current = setTimeout(() => {\n+              pause();\n+            }, remainingTime);\n+          }\n+        }\n+      },\n+      duration + sToMs(audio.startTime)\n+    );\n+  }, [isPlaying, sceneIsReady, audio, duration]);\n+\n+  const resetScene = useCallback(() => {\n+    usedCommandsRef.current.clear();\n+    pause();\n+    audioRef.current.currentTime = audio.startTimestamp || 0;\n+    setCurrentTime(0);\n+    setIsPlaying(false);\n+    isPlayingSceneRef.current = false;\n+    setShowDialogue(false);\n+    setDialogue(initDialogue);\n+    setCharacters(initCharacters);\n+    setBackground(initBackground);\n+  }, [audio, initCharacters, initBackground]);\n \n-      setIsPlaying(false);\n-      setShowDialogue(false);\n-      setDialogue(initDialogue);\n-      setCharacters(initCharacters);\n-      setBackground(initBackground);\n+  useEffect(() => {\n+    sceneSubject.attach(playScene);\n+    return () => {\n+      sceneSubject.detach(playScene);\n     };\n+  }, [playScene, sceneSubject]);\n \n-    // this function exists because we couldn't reliably stop the audio when\n-    // playing only part of the audio file. So it would get cut off\n-    function maybeStopAudio() {\n-      const runningTime = Date.now() - startRef.current;\n-\n-      if (runningTime >= duration) {\n-        pause();\n-      } else {\n-        window.requestAnimationFrame(maybeStopAudio);\n+  useEffect(() => {\n+    if (isEmpty(sortedCommands)) return;\n+\n+    sortedCommands.forEach((command, commandIndex) => {\n+      // Start command timeout\n+      if (\n+        currentTime > command.time &&\n+        !usedCommandsRef.current.has(commandIndex)\n+      ) {\n+        usedCommandsRef.current.add(commandIndex);\n+        if (command.background) setBackground(command.background);\n+\n+        setDialogue(\n+          command.dialogue\n+            ? { ...command.dialogue, label: command.character }\n+            : initDialogue\n+        );\n+\n+        setCharacters(prevCharacters => {\n+          const newCharacters = prevCharacters.map(character => {\n+            if (character.character === command.character) {\n+              return {\n+                ...character,\n+                position: command.position ?? character.position,\n+                opacity: command.opacity ?? character.opacity,\n+                isTalking: command.isTalking\n+              };\n+            }\n+            return character;\n+          });\n+          return newCharacters;\n+        });\n       }\n-    }\n+    });\n \n-    sceneSubject.attach(playScene);\n+    // resetScene only works if called AFTER the commands, otherwise the\n+    // commands will undo the reset.\n+    if (currentTime >= resetTime) resetScene();\n+  }, [currentTime, resetTime, sortedCommands, resetScene]);\n \n+  useEffect(() => {\n     return () => {\n-      sceneSubject.detach(playScene);\n+      clearTimeout(startTimerRef.current);\n+      clearTimeout(finishTimerRef.current);\n+      // @ts-expect-error cancelAnimationFrame accepts undefined, but TS doesn't\n+      // know that\n+      window.cancelAnimationFrame(animationRef.current);\n     };\n-  }, [\n-    isPlaying,\n-    duration,\n-    sceneSubject,\n-    sceneIsReady,\n-    commands,\n-    audio,\n-    hasTimestamps,\n-    initCharacters,\n-    initBackground,\n-    audioTimestamp\n-  ]);\n+  }, []);\n \n   return (\n     <Col lg={10} lgOffset={1} md={10} mdOffset={1}>"
        }
    ],
    "stats": {
        "total": 302,
        "additions": 166,
        "deletions": 136
    }
}