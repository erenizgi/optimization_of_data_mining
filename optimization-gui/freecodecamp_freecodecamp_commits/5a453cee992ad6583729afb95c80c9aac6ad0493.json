{
    "author": "Dario-DC",
    "message": "feat(curriculum): add equation solver project to SCWP (#55011)\n\nCo-authored-by: Ilenia M <nethleen@gmail.com>\r\nCo-authored-by: Zaira <33151350+zairahira@users.noreply.github.com>\r\nCo-authored-by: Naomi the Technomancer <accounts+github@nhcarrigan.com>",
    "sha": "5a453cee992ad6583729afb95c80c9aac6ad0493",
    "files": [
        {
            "sha": "a69753511f79e9063b377dfbecaccafa1bc05340",
            "filename": "client/i18n/locales/english/intro.json",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -884,6 +884,14 @@\n           \"This is one of the required projects to claim your certification.\"\n         ]\n       },\n+      \"learn-interfaces-by-building-an-equation-solver\": {\n+        \"title\": \"Learn Interfaces by Building an Equation Solver\",\n+        \"intro\": [\n+          \"Abstract classes enable you to define formal interfaces - objects acting as blueprints for classes.\",\n+          \"In this project, you'll discover how to implement an interface in Python while building a simple equation solver program.\"\n+        ]\n+      },\n+\n       \"learn-special-methods-by-building-a-vector-space\": {\n         \"title\": \"Learn Special Methods by Building a Vector Space\",\n         \"intro\": ["
        },
        {
            "sha": "c3fe8c0fe941fc59d79c588ed31654ef8d6e2266",
            "filename": "client/src/pages/learn/scientific-computing-with-python/learn-inheritance-by-building-an-equation-solver/index.md",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/client%2Fsrc%2Fpages%2Flearn%2Fscientific-computing-with-python%2Flearn-inheritance-by-building-an-equation-solver%2Findex.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/client%2Fsrc%2Fpages%2Flearn%2Fscientific-computing-with-python%2Flearn-inheritance-by-building-an-equation-solver%2Findex.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Fpages%2Flearn%2Fscientific-computing-with-python%2Flearn-inheritance-by-building-an-equation-solver%2Findex.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,10 @@\n+---\n+title: Introduction to the Learn Interfaces by Building an Equation Solver\n+block: learn-interfaces-by-building-an-equation-solver\n+superBlock: scientific-computing-with-python\n+isBeta: true\n+---\n+\n+## Introduction to the Learn Interfaces by Building an Equation Solver\n+\n+This is a test for the new project-based curriculum."
        },
        {
            "sha": "a360eec97407418c94fa39acbe41295781f5ccd2",
            "filename": "curriculum/challenges/_meta/learn-encapsulation-by-building-a-projectile-trajectory-calculator/meta.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2F_meta%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2Fmeta.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2F_meta%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2Fmeta.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2F_meta%2Flearn-encapsulation-by-building-a-projectile-trajectory-calculator%2Fmeta.json?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -1,6 +1,6 @@\n {\n   \"name\": \"Learn Encapsulation by Building a Projectile Trajectory Calculator\",\n-  \"isUpcomingChange\": true,\n+  \"isUpcomingChange\": false,\n   \"usesMultifileEditor\": true,\n   \"hasEditableBoundaries\": true,\n   \"dashedName\": \"learn-encapsulation-by-building-a-projectile-trajectory-calculator\","
        },
        {
            "sha": "12bc9e0aca4fa3f13fe0e88e60c5faadabbd8423",
            "filename": "curriculum/challenges/_meta/learn-interfaces-by-building-an-equation-solver/meta.json",
            "status": "added",
            "additions": 280,
            "deletions": 0,
            "changes": 280,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2F_meta%2Flearn-interfaces-by-building-an-equation-solver%2Fmeta.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2F_meta%2Flearn-interfaces-by-building-an-equation-solver%2Fmeta.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2F_meta%2Flearn-interfaces-by-building-an-equation-solver%2Fmeta.json?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,280 @@\n+{\n+  \"name\": \"Learn Interfaces by Building an Equation Solver\",\n+  \"isUpcomingChange\": false,\n+  \"usesMultifileEditor\": true,\n+  \"hasEditableBoundaries\": true,\n+  \"dashedName\": \"learn-interfaces-by-building-an-equation-solver\",\n+  \"order\": 15,\n+  \"superBlock\": \"scientific-computing-with-python\",\n+  \"challengeOrder\": [\n+    {\n+      \"id\": \"662a6bc12cde72c32fb526f0\",\n+      \"title\": \"Step 1\"\n+    },\n+    {\n+      \"id\": \"662bd456896f16d9bd03f1a6\",\n+      \"title\": \"Step 2\"\n+    },\n+    {\n+      \"id\": \"662bd552e1c1d2db1b88ba47\",\n+      \"title\": \"Step 3\"\n+    },\n+    {\n+      \"id\": \"662bd8260da84bdd5feae419\",\n+      \"title\": \"Step 4\"\n+    },\n+    {\n+      \"id\": \"662bdd364bf2cde1487922a9\",\n+      \"title\": \"Step 5\"\n+    },\n+    {\n+      \"id\": \"662bde88dc84f1e249801b1a\",\n+      \"title\": \"Step 6\"\n+    },\n+    {\n+      \"id\": \"662f96576ef178927de87975\",\n+      \"title\": \"Step 7\"\n+    },\n+    {\n+      \"id\": \"662f6d7c92381a3049e4c987\",\n+      \"title\": \"Step 8\"\n+    },\n+    {\n+      \"id\": \"662fa2e2cf27c09f21f4f5d0\",\n+      \"title\": \"Step 9\"\n+    },\n+    {\n+      \"id\": \"66759e32b88fb5459b1e0234\",\n+      \"title\": \"Step 10\"\n+    },\n+    {\n+      \"id\": \"6675a38a8b535e4ff3274520\",\n+      \"title\": \"Step 11\"\n+    },\n+    {\n+      \"id\": \"6675aaf418b41157f6ccd692\",\n+      \"title\": \"Step 12\"\n+    },\n+    {\n+      \"id\": \"662fbcef5f05e1b84f541a0c\",\n+      \"title\": \"Step 13\"\n+    },\n+    {\n+      \"id\": \"662fc3eba556a6bf800d48c1\",\n+      \"title\": \"Step 14\"\n+    },\n+    {\n+      \"id\": \"667e623208053643ca9d3c6e\",\n+      \"title\": \"Step 15\"\n+    },\n+    {\n+      \"id\": \"6639f947d3a1818c9322c64a\",\n+      \"title\": \"Step 16\"\n+    },\n+    {\n+      \"id\": \"6639fdcc701833a54c364211\",\n+      \"title\": \"Step 17\"\n+    },\n+    {\n+      \"id\": \"664c670069bae45fd060c25d\",\n+      \"title\": \"Step 18\"\n+    },\n+    {\n+      \"id\": \"663b83a28943e6aa6275a514\",\n+      \"title\": \"Step 19\"\n+    },\n+    {\n+      \"id\": \"663b93aee129b3c4cc07d0db\",\n+      \"title\": \"Step 20\"\n+    },\n+    {\n+      \"id\": \"663b95d65caeb3ca04c5fef4\",\n+      \"title\": \"Step 21\"\n+    },\n+    {\n+      \"id\": \"663c981b9b06922e13a97fe9\",\n+      \"title\": \"Step 22\"\n+    },\n+    {\n+      \"id\": \"663c9f31306353460da54542\",\n+      \"title\": \"Step 23\"\n+    },\n+    {\n+      \"id\": \"664cb04a16fe6938708967ef\",\n+      \"title\": \"Step 24\"\n+    },\n+    {\n+      \"id\": \"663a22ba7420c4d2f7fd2aec\",\n+      \"title\": \"Step 25\"\n+    },\n+    {\n+      \"id\": \"663a2dd1901cbeecc28748bd\",\n+      \"title\": \"Step 26\"\n+    },\n+    {\n+      \"id\": \"663a32735b317af9812eb0d7\",\n+      \"title\": \"Step 27\"\n+    },\n+    {\n+      \"id\": \"665ee783d35cb68875c626d4\",\n+      \"title\": \"Step 28\"\n+    },\n+    {\n+      \"id\": \"663b7fefd437bd984e091cbf\",\n+      \"title\": \"Step 29\"\n+    },\n+    {\n+      \"id\": \"664e4a590b52ba8d2adff19f\",\n+      \"title\": \"Step 30\"\n+    },\n+    {\n+      \"id\": \"664e4e1b6c35a99cbba49e84\",\n+      \"title\": \"Step 31\"\n+    },\n+    {\n+      \"id\": \"664ee8037f4bbe3c0944c35e\",\n+      \"title\": \"Step 32\"\n+    },\n+    {\n+      \"id\": \"664eec7f38234443b42c206f\",\n+      \"title\": \"Step 33\"\n+    },\n+    {\n+      \"id\": \"664eef158d792a509e8d708a\",\n+      \"title\": \"Step 34\"\n+    },\n+    {\n+      \"id\": \"664ef4623946e65e18d59764\",\n+      \"title\": \"Step 35\"\n+    },\n+    {\n+      \"id\": \"664f0389424a6f7aa15fd3e5\",\n+      \"title\": \"Step 36\"\n+    },\n+    {\n+      \"id\": \"664f4559c17d2138ae680566\",\n+      \"title\": \"Step 37\"\n+    },\n+    {\n+      \"id\": \"6650583d9d9a194714da47f0\",\n+      \"title\": \"Step 38\"\n+    },\n+    {\n+      \"id\": \"6650633eaeccf266fee14ba6\",\n+      \"title\": \"Step 39\"\n+    },\n+    {\n+      \"id\": \"6650e11fa60e222e691bb283\",\n+      \"title\": \"Step 40\"\n+    },\n+    {\n+      \"id\": \"6650e27cf34f2335a9bbbd08\",\n+      \"title\": \"Step 41\"\n+    },\n+    {\n+      \"id\": \"6650e88cc500673ec881c9ca\",\n+      \"title\": \"Step 42\"\n+    },\n+    {\n+      \"id\": \"6650eb84e248684c2f57555c\",\n+      \"title\": \"Step 43\"\n+    },\n+    {\n+      \"id\": \"6650f037c017aa6855a608e3\",\n+      \"title\": \"Step 44\"\n+    },\n+    {\n+      \"id\": \"665460392acb7e91db2afad1\",\n+      \"title\": \"Step 45\"\n+    },\n+    {\n+      \"id\": \"665467883dded0a1dad983b2\",\n+      \"title\": \"Step 46\"\n+    },\n+    {\n+      \"id\": \"66558720bbe6e038315b7f81\",\n+      \"title\": \"Step 47\"\n+    },\n+    {\n+      \"id\": \"665621ef85db565d26632761\",\n+      \"title\": \"Step 48\"\n+    },\n+    {\n+      \"id\": \"66562f71937f877c66123bbe\",\n+      \"title\": \"Step 49\"\n+    },\n+    {\n+      \"id\": \"667938f754145d165c25725d\",\n+      \"title\": \"Step 50\"\n+    },\n+    {\n+      \"id\": \"66793a552f357b17006a8726\",\n+      \"title\": \"Step 51\"\n+    },\n+    {\n+      \"id\": \"66793c5b4bdacc17c40ff8e7\",\n+      \"title\": \"Step 52\"\n+    },\n+    {\n+      \"id\": \"66793d1e1581681871635ac6\",\n+      \"title\": \"Step 53\"\n+    },\n+    {\n+      \"id\": \"66794346ddfa141cbe70093a\",\n+      \"title\": \"Step 54\"\n+    },\n+    {\n+      \"id\": \"667944fed1f6b61da3406bd8\",\n+      \"title\": \"Step 55\"\n+    },\n+    {\n+      \"id\": \"66799278873fd2570217bffa\",\n+      \"title\": \"Step 56\"\n+    },\n+    {\n+      \"id\": \"6679934707d5fe577f898efd\",\n+      \"title\": \"Step 57\"\n+    },\n+    {\n+      \"id\": \"66799ba07c5fd58a61a604d3\",\n+      \"title\": \"Step 58\"\n+    },\n+    {\n+      \"id\": \"66799c1a0204668cef35555d\",\n+      \"title\": \"Step 59\"\n+    },\n+    {\n+      \"id\": \"667a7ce2a9925416e7b4781b\",\n+      \"title\": \"Step 60\"\n+    },\n+    {\n+      \"id\": \"6679bf00da92e5c0db0ffdc3\",\n+      \"title\": \"Step 61\"\n+    },\n+    {\n+      \"id\": \"6679bfe40a6d77c6a3c17e06\",\n+      \"title\": \"Step 62\"\n+    },\n+    {\n+      \"id\": \"667a860c3b61f61b7a18930c\",\n+      \"title\": \"Step 63\"\n+    },\n+    {\n+      \"id\": \"667a8d7a735cf221729570ff\",\n+      \"title\": \"Step 64\"\n+    },\n+    {\n+      \"id\": \"667a965d5a4b5825ffb2e1d8\",\n+      \"title\": \"Step 65\"\n+    },\n+    {\n+      \"id\": \"667a9c91a87bb453a355b63d\",\n+      \"title\": \"Step 66\"\n+    },\n+    {\n+      \"id\": \"667aa056f1240f58fb9a2c17\",\n+      \"title\": \"Step 67\"\n+    }\n+  ],\n+  \"helpCategory\": \"Python\"\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "c94104ece2e7f9df2b087b2944feb3daf0992c33",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/662a6bc12cde72c32fb526f0.md",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662a6bc12cde72c32fb526f0.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662a6bc12cde72c32fb526f0.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662a6bc12cde72c32fb526f0.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,30 @@\n+---\n+id: 662a6bc12cde72c32fb526f0\n+title: Step 1\n+challengeType: 20\n+dashedName: step-1\n+---\n+\n+# --description--\n+\n+An <dfn>interface</dfn> is like a blueprint for a class. An interface contains a set of methods and properties that a class should implement.  \n+\n+Start this project by declaring an empty class named `Equation`. You will use this class to define an interface, a blueprint for a generic equation.\n+\n+# --hints--\n+\n+You should define a new class named `Equation`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_class(\"Equation\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "0bfb730af3109ad09f51d9ce6e56476c62be04bd",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/662bd456896f16d9bd03f1a6.md",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bd456896f16d9bd03f1a6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bd456896f16d9bd03f1a6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bd456896f16d9bd03f1a6.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,47 @@\n+---\n+id: 662bd456896f16d9bd03f1a6\n+title: Step 2\n+challengeType: 20\n+dashedName: step-2\n+---\n+\n+# --description--\n+\n+Within the `Equation` class, define two new instance methods named `solve` and `analyze`.\n+\n+# --hints--\n+\n+You should define a method named `solve` within the `Equation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").has_function(\"solve\")`)) })\n+```\n+\n+Your `solve` method should take one parameter, `self`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"solve\").has_args(\"self\")`)) })\n+```\n+\n+You should define a method named `analyze` within the `Equation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").has_function(\"analyze\")`)) })\n+```\n+\n+Your `analyze` method should take one parameter, `self`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"analyze\").has_args(\"self\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+class Equation:\n+    pass\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "75c23e745e7c5fd7a8970de1c215f437eac94cdb",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/662bd552e1c1d2db1b88ba47.md",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bd552e1c1d2db1b88ba47.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bd552e1c1d2db1b88ba47.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bd552e1c1d2db1b88ba47.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,40 @@\n+---\n+id: 662bd552e1c1d2db1b88ba47\n+title: Step 3\n+challengeType: 20\n+dashedName: step-3\n+---\n+\n+# --description--\n+\n+Now, define another class named `LinearEquation` and make it inherit from `Equation`. You'll use this class to represent linear equations.\n+\n+# --hints--\n+\n+You should define a class named `LinearEquation`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_class(\"LinearEquation\")`)) })\n+```\n+\n+Your `LinearEquation` class should inherit from the `Equation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").inherits_from(\"Equation\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class Equation:\n+    def solve(self):\n+        pass\n+        \n+    def analyze(self):\n+        pass\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "6d0c00e67c2f9f77d271c317512329617af06a6f",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/662bd8260da84bdd5feae419.md",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bd8260da84bdd5feae419.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bd8260da84bdd5feae419.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bd8260da84bdd5feae419.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,48 @@\n+---\n+id: 662bd8260da84bdd5feae419\n+title: Step 4\n+challengeType: 20\n+dashedName: step-4\n+---\n+\n+# --description--\n+\n+You want the `LinearEquation` class to implement and not simply inherit all the methods defined inside the `Equation` class, which should act as an interface.\n+\n+Currently, the `Equation` class is simply the parent class of `LinearEquation`. In the next steps you will learn how to turn it into a formal interface.\n+\n+For now, create an instance of `Equation` and assign it to a variable `eq`, and an instance of `LinearEquation` and assign it to a variable `lin_eq`.\n+\n+# --hints--\n+\n+You should declare a variable `eq` and assign it an instance of `Equation`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_stmt(\"eq = Equation()\")`)) })\n+```\n+\n+You should declare a variable `lin_eq` and assign it an instance of `LinearEquation`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_stmt(\"lin_eq = LinearEquation()\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+class Equation:\n+    def solve(self):\n+        pass\n+        \n+    def analyze(self):\n+        pass\n+        \n+\n+class LinearEquation(Equation):\n+    pass\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "45cbe3806d440502f890da949b903e7d3e16cbcc",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/662bdd364bf2cde1487922a9.md",
            "status": "added",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bdd364bf2cde1487922a9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bdd364bf2cde1487922a9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bdd364bf2cde1487922a9.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,44 @@\n+---\n+id: 662bdd364bf2cde1487922a9\n+title: Step 5\n+challengeType: 20\n+dashedName: step-5\n+---\n+\n+# --description--\n+\n+Unlike other programming languages, Python does not implement interfaces in its core language, but the Python standard library allows you to define interfaces in a simple way.\n+\n+For this project, you'll use utilities from the `abc` module. Therefore, import this module in your code.\n+\n+# --hints--\n+\n+You should import the `abc` module.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_import(\"import abc\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+class Equation:\n+    def solve(self):\n+        pass\n+        \n+    def analyze(self):\n+        pass\n+        \n+\n+class LinearEquation(Equation):\n+    pass\n+    \n+\n+eq = Equation()\n+lin_eq = LinearEquation()\n+```"
        },
        {
            "sha": "010d4d465940ff3bf8ae124a7fd9628d1e34ae58",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/662bde88dc84f1e249801b1a.md",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bde88dc84f1e249801b1a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bde88dc84f1e249801b1a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662bde88dc84f1e249801b1a.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,52 @@\n+---\n+id: 662bde88dc84f1e249801b1a\n+title: Step 6\n+challengeType: 20\n+dashedName: step-6\n+---\n+\n+# --description--\n+\n+`ABC` stands for *Abstract Base Classes*. The `ABC` class enables you to turn a regular class into an abstract class, which is a class that acts as a blueprint for concrete classes.\n+\n+Modify your `import` statement to import just the `ABC` class from the `abc` module. You can import a specific object `x` from a module `y` following the import construct `from y import x`.\n+\n+Then, turn your `Equation` class into an abstract class by making it inherit from `ABC`.\n+\n+# --hints--\n+\n+You should import `ABC` from the `abc` module.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_import(\"from abc import ABC\")`)) })\n+```\n+\n+Your `Equation` class should inherit from `ABC`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").inherits_from(\"ABC\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+import abc\n+\n+\n+class Equation:\n+    def solve(self):\n+        pass\n+        \n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    pass\n+    \n+eq = Equation()\n+lin_eq = LinearEquation()\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "c9886685e8874891a47691054ef3ac8d353c42a5",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/662f6d7c92381a3049e4c987.md",
            "status": "added",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662f6d7c92381a3049e4c987.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662f6d7c92381a3049e4c987.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662f6d7c92381a3049e4c987.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,57 @@\n+---\n+id: 662f6d7c92381a3049e4c987\n+title: Step 8\n+challengeType: 20\n+dashedName: step-8\n+---\n+\n+# --description--\n+\n+An interface doesn't have to define only abstract methods, but it can also implement methods to be inherited by the concrete classes.\n+\n+Before taking care of the actual implementation of `solve` and `analyze`, within the `Equation` class, define an `__init__` method. Do not use any decorator on it.\n+\n+# --hints--\n+\n+You should define an `__init__` method in your `Equation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").has_function(\"__init__\")`)) })\n+```\n+\n+Your `__init__` method should take one parameter, `self`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").has_args(\"self\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+from abc import ABC, abstractmethod\n+\n+\n+class Equation(ABC):\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    def solve(self):\n+        pass\n+\n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation()\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "dd06ade6f6cf52d96a8b46d06c9752e3bdcdecce",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/662f96576ef178927de87975.md",
            "status": "added",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662f96576ef178927de87975.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662f96576ef178927de87975.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662f96576ef178927de87975.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,88 @@\n+---\n+id: 662f96576ef178927de87975\n+title: Step 7\n+challengeType: 20\n+dashedName: step-7\n+---\n+\n+# --description--\n+\n+In order to be recognized as an abstract method, a method should be decorated with the `@abstractmethod` decorator.\n+\n+Modify your import statement to import the `abstractmethod` decorator and decorate both the `solve` and `analyze` methods of the `Equation` class. This will raise two exceptions.\n+\n+Once a class inheriting from `ABC` has an abstract method, the class cannot be instantiated anymore. Therefore, delete the `Equation` instance to get rid of the error.\n+\n+The other error occurs because the `LinearEquation` class must implement all the abstract methods defined in the interface. Make sure to define them inside the `LinearEquation` class, too. You must not use the `abstractmethod` decorator in the concrete class.\n+\n+# --hints--\n+\n+You should import `abstractmethod` from the `abc` module.\n+\n+```js\n+({ test: () => assert(runPython(`\n+_Node(_code).has_import(\"from abc import ABC, abstractmethod\") or \\\\\n+_Node(_code).has_import(\"from abc import abstractmethod, ABC\") or \\\\\n+(_Node(_code).has_import(\"from abc import abstractmethod\") and _Node(_code).has_import(\"from abc import ABC\"))\n+`)) })\n+```\n+\n+You should decorate with `@abstractmethod` the `solve` method within the `Equation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"solve\").has_decorators(\"abstractmethod\")`)) })\n+```\n+\n+You should decorate with `@abstractmethod` the `analyze` method within the `Equation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"analyze\").has_decorators(\"abstractmethod\")`)) })\n+```\n+\n+You should define a method named `solve` within the `LinearEquation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").has_function(\"solve\")`)) })\n+```\n+\n+Your `solve` method should take one parameter, `self`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"solve\").has_args(\"self\")`)) })\n+```\n+\n+You should define a method named `analyze` within the `LinearEquation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").has_function(\"analyze\")`)) })\n+```\n+\n+Your `solve` method should take one parameter, `self`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"analyze\").has_args(\"self\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+--fcc-editable-region--\n+from abc import ABC\n+\n+\n+class Equation(ABC):\n+    def solve(self):\n+        pass\n+        \n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    pass\n+\n+eq = Equation()\n+lin_eq = LinearEquation()\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "408c31ea4c2d5ba530d22de58e78cba344dbe279",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/662fa2e2cf27c09f21f4f5d0.md",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662fa2e2cf27c09f21f4f5d0.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662fa2e2cf27c09f21f4f5d0.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662fa2e2cf27c09f21f4f5d0.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,52 @@\n+---\n+id: 662fa2e2cf27c09f21f4f5d0\n+title: Step 9\n+challengeType: 20\n+dashedName: step-9\n+---\n+\n+# --description--\n+\n+In Python, data types are recognized during runtime (when the code is executed). Therefore, you don't have to specify the data type of a variable when you declare it. Nonetheless, you can annotate a variable to clarify that it will hold a specific data type with `variable: <data type> = value` or just `variable: <data type>`. Note that the Python interpreter does not enforce the types used to annotate variables, and normally you'd need external tools to do it.\n+\n+Inside the `Equation` class, define a class attribute `degree`. Do not assign it a value. Instead use a type annotation of `int` to show that it will store an integer number inside the concrete classes.\n+\n+Later on, you'll use this class attribute as a part of the validation process of the arguments passed to instantiate the equation objects.\n+\n+# --hints--\n+\n+You should define class attribute named `degree` and annotate it with `int` within the `Equation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_variable(\"degree\").is_equivalent(\"degree: int\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+--fcc-editable-region--\n+class Equation(ABC):\n+    def __init__(self):\n+        pass\n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    def solve(self):\n+        pass\n+\n+    def analyze(self):\n+        pass\n+--fcc-editable-region--\n+lin_eq = LinearEquation()\n+```"
        },
        {
            "sha": "ad9f8ea6da2f1a6f2fda46ea58d96c5731061a76",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/662fbcef5f05e1b84f541a0c.md",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662fbcef5f05e1b84f541a0c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662fbcef5f05e1b84f541a0c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662fbcef5f05e1b84f541a0c.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,83 @@\n+---\n+id: 662fbcef5f05e1b84f541a0c\n+title: Step 13\n+challengeType: 20\n+dashedName: step-13\n+---\n+\n+# --description--\n+\n+Each equation object will be instantiated passing as many arguments as the coefficients of the equation, starting from n-th degree of \\\\( x \\\\) down to the zero-th degree, including the possible coefficient with the value of `0`.\n+\n+For example, `LinearEquation(4, 5)` would represent the equation \\\\( 4x + 5 = 0 \\\\), with `4` being the coefficient of the first (highest here) degree and `5` the coefficient of the zero-th degree.\n+\n+You need to check that the right number of arguments is passed to instantiate the equation object.\n+\n+Inside the `__init__` method, create an `if` statement to check if the length of `args` is different from the number of coefficients the equation should have (`degree + 1`). If it is, raise a `TypeError` and use the following string to provide a custom message: `f\"'{self.__class__.__name__}' object takes {self.degree + 1} positional arguments but {len(args)} were given\"`.\n+\n+Then, fix the error by passing the `2` and `3` to instantiate `lin_eq`.\n+\n+# --hints--\n+\n+You should create an `if` statement that checks if the number of coefficients used to instantiate the equation is different from `degree + 1`.\n+\n+```js\n+({ test: () => assert(runPython(`\n+cond = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[0].find_conditions()[0]\n+cond.is_equivalent(\"(self.degree + 1) != len(args)\") or cond.is_equivalent(\"len(args) != (self.degree + 1)\")\n+`)) })\n+```\n+\n+You should raise a `TypeError` within the new `if` statement and use the provided string to return a custom error message.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[0].find_bodies()[0].has_stmt('raise TypeError(f\"\\\\'{self.__class__.__name__}\\\\' object takes {self.degree + 1} positional arguments but {len(args)} were given\")')\n+`)) })\n+```\n+\n+You should pass `2` and `3` to instantiate `lin_eq`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_stmt(\"lin_eq = LinearEquation(2, 3)\")`)) })\n+```\n+\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+--fcc-editable-region--\n+    def __init__(self, *args):\n+        pass        \n+    \n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+    \n+lin_eq = LinearEquation()\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "f2c6f80ad410b8b310d5e913587cdb0b963ce0e8",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/662fc3eba556a6bf800d48c1.md",
            "status": "added",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662fc3eba556a6bf800d48c1.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662fc3eba556a6bf800d48c1.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F662fc3eba556a6bf800d48c1.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,87 @@\n+---\n+id: 662fc3eba556a6bf800d48c1\n+title: Step 14\n+challengeType: 20\n+dashedName: step-14\n+---\n+\n+# --description--\n+\n+The `isinstance()` built-in function takes two arguments and returns a Boolean indicating if the object passed as the first argument is an instance of the class passed as the second argument.\n+\n+```py\n+isinstance(7, int) # True\n+```\n+\n+Another thing you want to check is that every argument is a number. After your first `if`, create a `for` loop that iterates over `args` and checks if the argument at the current iteration is not an instance of `int` or `float`. Use the `isinstance()` function and pass it a tuple containing `int` and `float` as the second argument.\n+\n+If the argument is not a number, raise a `TypeError` saying `\"Coefficients must be of type 'int' or 'float'\"`.\n+\n+# --hints--\n+\n+You should create a `for` loop that iterates over `args` after your `if` statement.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_for_loops()[0].find_for_iter().is_equivalent(\"args\")`)) })\n+```\n+\n+You should create an `if` statement that checks if the current coefficient is not an instance of either `int` or `float` within the `for` loop.\n+\n+```js\n+({ test: () => assert(runPython(`\n+var = str(_Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_for_loops()[0].find_for_vars())\n+cond1 = f'not isinstance({var}, (int, float))'\n+cond2 = f'not isinstance({var}, (float, int))'\n+if_stmt = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_for_loops()[0].find_ifs()[0].find_conditions()[0]\n+if_stmt.is_equivalent(cond1) or if_stmt.is_equivalent(cond2)\n+`)) })\n+```\n+\n+You should use the provided string to raise a `TypeError` within the `if` statement.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_for_loops()[0].find_ifs()[0].find_bodies()[0].has_stmt(\"raise TypeError(\\\\\"Coefficients must be of type 'int' or 'float'\\\\\")\")\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+--fcc-editable-region--\n+class Equation(ABC):\n+    degree: int\n+    \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'{self.__class__.__name__}' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+--fcc-editable-region--\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+    \n+lin_eq = LinearEquation(2, 3)\n+```"
        },
        {
            "sha": "674d5a9cb66f7b939c20efa4466e9f0506b2d2d8",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6639f947d3a1818c9322c64a.md",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6639f947d3a1818c9322c64a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6639f947d3a1818c9322c64a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6639f947d3a1818c9322c64a.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,74 @@\n+---\n+id: 6639f947d3a1818c9322c64a\n+title: Step 16\n+challengeType: 20\n+dashedName: step-16\n+---\n+\n+# --description--\n+\n+The last step of validating the coefficients is checking that the highest degree coefficient is different from zero. Remember that the highest degree coefficient should be passed as the first argument when instantiating the object.\n+\n+Add an `if` statement for that and raise a `ValueError` using the following string to provide a custom message: `'Highest degree coefficient must be different from zero'`.\n+\n+# --hints--\n+\n+You should create an `if` statement that checks if the first coefficient passed to instantiate the equation is equal to zero.\n+\n+```js\n+({ test: () => assert(runPython(`\n+cond = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[2].find_conditions()[0]\n+cond.is_equivalent(\"args[0] == 0\") or cond.is_equivalent(\"0 == args[0]\") or cond.is_equivalent(\"not args[0]\")\n+`)) })\n+```\n+\n+You should raise a `ValueError` within the new `if` statement and use the provided string to return a custom error message.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[2].find_bodies()[0].has_stmt(\"raise ValueError('Highest degree coefficient must be different from zero')\")\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+--fcc-editable-region--\n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+--fcc-editable-region--\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )        \n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+    \n+lin_eq = LinearEquation(2, 3)\n+```"
        },
        {
            "sha": "07fbb005d292f87c8531b2d507d346607180bde1",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6639fdcc701833a54c364211.md",
            "status": "added",
            "additions": 94,
            "deletions": 0,
            "changes": 94,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6639fdcc701833a54c364211.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6639fdcc701833a54c364211.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6639fdcc701833a54c364211.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,94 @@\n+---\n+id: 6639fdcc701833a54c364211\n+title: Step 17\n+challengeType: 20\n+dashedName: step-17\n+---\n+\n+# --description--\n+\n+After validating the coefficients, you need to store them in an instance attribute. Use a dictionary comprehension to create a dictionary in which the key is the degree of the coefficient and the corresponding value is the coefficient, and assign it to an attribute named `coefficients`.\n+\n+For example, a `LinearEquation` object instantiated with `2` and `4` should have the following `coefficients` attribute: `{1: 2, 0: 4}`, because `2` corresponds to the first degree of `x` and `4` corresponds to zero-th degree of `x`.\n+\n+Create the key-value pairs in your new dictionary following the same order as in `args`.\n+\n+# --hints--\n+\n+You should declare an attribute named `coefficients` within your `__init__` method.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").has_variable(\"self.coefficients\")`)) })\n+```\n+\n+You should use a dictionary comprehension to store your coefficients.\n+\n+```js\n+({ test: () => runPython(`\n+import ast\n+node = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_variable(\"self.coefficients\")\n+assert isinstance(node.tree.value, ast.DictComp)\n+`) })\n+```\n+\n+Your `coefficients` attribute should be a dictionary containing key-value pairs in the form degree-coefficient. Remember to follow the same order in which coefficients are stored inside `args`.\n+\n+```js\n+({ test: () => runPython(`\n+actual1 = list(LinearEquation(1, 6).coefficients.items())\n+expected1 = list({1: 1, 0: 6}.items())\n+actual2 = list(LinearEquation(-3.5, 0).coefficients.items())\n+expected2 = list({1: -3.5, 0: 0}.items())\n+assert actual1 == expected1\n+assert actual2 == expected2\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+    \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+--fcc-editable-region--\n+        \n+--fcc-editable-region--\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+\n+    \n+lin_eq = LinearEquation(2, 3)\n+```"
        },
        {
            "sha": "792eddb80260e59ac35104284bf22305ca06eab1",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/663a22ba7420c4d2f7fd2aec.md",
            "status": "added",
            "additions": 96,
            "deletions": 0,
            "changes": 96,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663a22ba7420c4d2f7fd2aec.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663a22ba7420c4d2f7fd2aec.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663a22ba7420c4d2f7fd2aec.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,96 @@\n+---\n+id: 663a22ba7420c4d2f7fd2aec\n+title: Step 25\n+challengeType: 20\n+dashedName: step-25\n+---\n+\n+# --description--\n+\n+It's time to implement the `solve` method. Given a linear equation in the form \\\\( ax + b = 0 \\\\), the solution is \\\\(x = -\\frac{b}{a}\\\\).\n+\n+Unpack the coefficients stored in the `coefficients` attribute into the variables `a` and `b`. Note that you'll need to use the `.values()` method.\n+\n+Then, declare a variable `x`, assign it the solution of the equation and return it from the `solve` method.\n+\n+# --hints--\n+\n+You should unpack the values stored inside the `coefficients` attribute into the variables `a` and `b`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"solve\").has_stmt(\"a, b = self.coefficients.values()\")`)) })\n+```\n+\n+You should declare a variable named `x` and assign it the solution of the linear equation.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"solve\").has_stmt(\"x = -b/a\")`)) })\n+```\n+\n+You should return `x` from your `solve` method.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"solve\").has_return(\"x\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                continue\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')                \n+        equation_string = ' '.join(terms) + ' = 0'\n+        return equation_string.strip('+').strip('+')        \n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+--fcc-editable-region--\n+    def solve(self):\n+        pass\n+--fcc-editable-region--\n+    \n+    def analyze(self):\n+        pass\n+    \n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+\n+```"
        },
        {
            "sha": "c5c576c092252807414f9763a628c98e0acfb5d1",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/663a2dd1901cbeecc28748bd.md",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663a2dd1901cbeecc28748bd.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663a2dd1901cbeecc28748bd.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663a2dd1901cbeecc28748bd.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,83 @@\n+---\n+id: 663a2dd1901cbeecc28748bd\n+title: Step 26\n+challengeType: 20\n+dashedName: step-26\n+---\n+\n+# --description--\n+\n+It's time to test the `solve` method. Call it on `lin_eq` and print the result.\n+\n+# --hints--\n+\n+You should call the `solve` method of your `lin_eq` object and print the result.\n+\n+```js\n+({ test: () => assert(runPython(`\n+_Node(_code).has_call(\"print(lin_eq.solve())\")\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')                \n+        equation_string = ' '.join(terms) + ' = 0'\n+        return equation_string.strip('+')        \n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+    \n+    def analyze(self):\n+        pass\n+--fcc-editable-region--\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "26299732554e5c7828cf7734775dccc6a37f68ed",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/663a32735b317af9812eb0d7.md",
            "status": "added",
            "additions": 106,
            "deletions": 0,
            "changes": 106,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663a32735b317af9812eb0d7.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663a32735b317af9812eb0d7.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663a32735b317af9812eb0d7.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,106 @@\n+---\n+id: 663a32735b317af9812eb0d7\n+title: Step 27\n+challengeType: 20\n+dashedName: step-27\n+---\n+\n+# --description--\n+\n+In linear equations in the form \\\\( ax + b = 0 \\\\), the slope is simply the coefficient \\\\( a \\\\), and the y-intercept is the coefficient \\\\( b \\\\).\n+\n+<img alt=\"a plot of a linear function\" src=\"https://cdn.freecodecamp.org/curriculum/python/linear-equation.png\" style=\"background-color: white; height: 350px; width: auto; padding: 15px; display: block; margin-right: auto; margin-left: auto; margin-bottom: 1.2rem;\">\n+\n+You are going to use the `analyze` method to provide additional information about the equation. Inside the `analyze` method, unpack the coefficients into the variables `slope` and `intercept`.\n+\n+Then, return a dictionary with the keys `'slope'` and `'intercept'` and the values of the slope and the y-intercept, respectively. After that, call `analyze` on `lin_eq` and print the result.\n+\n+\n+# --hints--\n+\n+You should unpack the values stored in the `coefficients` attribute into the variables `slope` and `intercept` inside the `analyze` method.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"analyze\").has_stmt(\"slope, intercept = self.coefficients.values()\")`)) })\n+```\n+\n+The `analyze` method should return a dictionary with the keys `'slope'` and `'intercept'` and the values of the slope and the y-intercept, respectively.\n+\n+```js\n+({ test: () => runPython(`\n+eq = LinearEquation(2.2, 1.5)\n+a = eq.analyze()\n+assert a['slope'] == 2.2, \"Expected different slope\"\n+assert a['intercept'] == 1.5, \"Expected different intercept\"\n+`) })\n+```\n+\n+You should call the `analyze` method of your `lin_eq` object.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(lin_eq.analyze())\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')                \n+        equation_string = ' '.join(terms) + ' = 0'\n+        return equation_string.strip('+')        \n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+--fcc-editable-region--\n+    def analyze(self):\n+        pass\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+print(lin_eq.solve())\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "024c64514d002d77689fc09049959187d76f5d0b",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/663b7fefd437bd984e091cbf.md",
            "status": "added",
            "additions": 116,
            "deletions": 0,
            "changes": 116,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663b7fefd437bd984e091cbf.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663b7fefd437bd984e091cbf.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663b7fefd437bd984e091cbf.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,116 @@\n+---\n+id: 663b7fefd437bd984e091cbf\n+title: Step 29\n+challengeType: 20\n+dashedName: step-29\n+---\n+\n+# --description--\n+\n+Next, create a new class named `QuadraticEquation` and make it inherit from `Equation`. You'll use this new class to represent quadratic equations, which are second-degree equations having the form $ax^2 + bx + c = 0$. \n+\n+Inside your new class, define a `degree` class attribute with the value `2`, which is the degree of a quadratic equation. Also, define the `solve` and `analyze` methods. You will take care of the implementation in the following steps.\n+\n+# --hints--\n+\n+You should create a new class named `QuadraticEquation` and make it inherit from the `Equation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").inherits_from(\"Equation\")`)) })\n+```\n+\n+You should define a `solve` method within the `QuadraticEquation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").has_function(\"solve\")`)) })\n+```\n+\n+Your `solve` method should take a single parameter, `self`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_function(\"solve\").has_args(\"self\")`)) })\n+```\n+\n+You should define an `analyze` method within the `QuadraticEquation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").has_function(\"analyze\")`)) })\n+```\n+\n+Your `analyze` method should take a single parameter, `self`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_function(\"analyze\").has_args(\"self\")`)) })\n+```\n+\n+You should define a `degree` class attribute within the `QuadraticEquation` class and assign it the value `2`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_variable(\"degree\").is_equivalent(\"degree = 2\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')                \n+        equation_string = ' '.join(terms) + ' = 0'\n+        return equation_string.strip('+')        \n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+\n+```"
        },
        {
            "sha": "d630ae56978b186783b254069fca2f415a953df5",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/663b83a28943e6aa6275a514.md",
            "status": "added",
            "additions": 97,
            "deletions": 0,
            "changes": 97,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663b83a28943e6aa6275a514.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663b83a28943e6aa6275a514.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663b83a28943e6aa6275a514.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,97 @@\n+---\n+id: 663b83a28943e6aa6275a514\n+title: Step 19\n+challengeType: 20\n+dashedName: step-19\n+---\n+\n+# --description--\n+\n+Still within the `Equation` class, define a `__str__` method to give a proper string representation to the equation objects you are going to create.\n+\n+For now, within the `__str__` method, declare a variable `terms` and assign it an empty list. You'll use this variable to store each term (coefficient times \\\\( x^n \\\\)) of your equation.\n+\n+Then, declare a variable `equation_string`, assign it the result of joining the elements in the `terms` list with a space. Finally, return `equation_string`.\n+\n+# --hints--\n+\n+You should define a `__str__` method within the `Equation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").has_function(\"__str__\")`)) })\n+```\n+\n+Your `__str__` method should take one parameter, `self`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").has_args(\"self\")`)) })\n+```\n+\n+You should declare a variable `terms` and assign it an empty list within the `__str__` method.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").has_stmt(\"terms = []\")`)) })\n+```\n+\n+You should declare a variable `equation_string` and assign it the result of joining the elements in `terms` with a space within the `__str__` method.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").has_stmt(\"equation_string = ' '.join(terms)\")`)) })\n+```\n+\n+You should return `equation_string` from your `__str__` method.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").has_return(\"equation_string\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+    \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+--fcc-editable-region--\n+    \n+--fcc-editable-region--    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+```"
        },
        {
            "sha": "caef56c29f819eb0edc1a1c7aa961d5e83209bd2",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/663b93aee129b3c4cc07d0db.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663b93aee129b3c4cc07d0db.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663b93aee129b3c4cc07d0db.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663b93aee129b3c4cc07d0db.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,110 @@\n+---\n+id: 663b93aee129b3c4cc07d0db\n+title: Step 20\n+challengeType: 20\n+dashedName: step-20\n+---\n+\n+# --description--\n+\n+Just after the `terms` list, create a `for` loop and use the `.items()` method to iterate over the keys and values stored in the `coefficients` attribute. Use `n` and `coefficient` as the loop variables. \n+\n+Inside the loop, create an `if` statement that checks if the coefficient at the current iteration has a falsy value and skip the iteration in that case. This is because you don't want to represent coefficients with the value of zero.\n+\n+# --hints--\n+\n+You should create a `for` loop that iterates over `coefficients.items()`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_for_iter().is_equivalent(\"self.coefficients.items()\")`)) })\n+```\n+\n+Your `for` loop should use `n` and `coefficient` to iterate over `coefficients.items()`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_for_vars().is_equivalent(\"n, coefficient\")`)) })\n+```\n+\n+You should create an `if` statement to check if `coefficient` has a falsy value inside your `for` loop.\n+\n+```js\n+({ test: () => assert(runPython(`\n+if_cond = _Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[0].find_conditions()[0]\n+conditions = [\"not coefficient\", \"coefficient == 0\", \"0 == coefficient\"]\n+any(if_cond.is_equivalent(condition) for condition in conditions)\n+`)) })\n+```\n+\n+You should use the `continue` keyword inside your new `if` statement.\n+\n+```js\n+({ test: () => assert(runPython(`\n+_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[0].find_bodies()[0].has_stmt(\"continue\")\n+`)) })\n+```\n+\n+Your `for` loop should be placed just after the declaration of `terms`.\n+\n+```js\n+({ test: () => assert(runPython(`\n+loop = str(_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0])\n+_Node(_code).find_class(\"Equation\").find_function(\"__str__\").is_ordered(\"terms = []\", loop, \"equation_string = ' '.join(terms)\", \"return equation_string\")\n+`)) })\n+```\n+\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+    \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+--fcc-editable-region--\n+    def __str__(self):\n+        terms = []\n+        \n+--fcc-editable-region--\n+        equation_string = ' '.join(terms)\n+        return equation_string        \n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+```"
        },
        {
            "sha": "e1d1b22eb6f21dbae45c7703f07011d2a30fba00",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/663b95d65caeb3ca04c5fef4.md",
            "status": "added",
            "additions": 82,
            "deletions": 0,
            "changes": 82,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663b95d65caeb3ca04c5fef4.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663b95d65caeb3ca04c5fef4.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663b95d65caeb3ca04c5fef4.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,82 @@\n+---\n+id: 663b95d65caeb3ca04c5fef4\n+title: Step 21\n+challengeType: 20\n+dashedName: step-21\n+---\n+\n+# --description--\n+\n+If the coefficient has a non-zero value, you can have different cases. If `n == 0`, the term is made by the coefficient itself.\n+\n+After your `if` statement, create another `if` statement for this case and append a string containing the coefficient to the `terms` list. Use an f-string for that.\n+\n+# --hints--\n+\n+You should create an `if` statement to check if `n` is equal to `0` after your existing `if` statement.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_conditions()[0].is_equivalent(\"n==0\")`)) })\n+```\n+\n+You should append `f'{coefficient}'` to the `terms` list within your new `if` statement.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_bodies()[0].is_equivalent(\"terms.append(f'{coefficient}')\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+    \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+--fcc-editable-region--\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                continue\n+        equation_string = ' '.join(terms)\n+        return equation_string\n+--fcc-editable-region--    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+    \n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+```"
        },
        {
            "sha": "da38a17f88500f5c6cffcb3188a82ba65a07d64c",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/663c981b9b06922e13a97fe9.md",
            "status": "added",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663c981b9b06922e13a97fe9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663c981b9b06922e13a97fe9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663c981b9b06922e13a97fe9.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,84 @@\n+---\n+id: 663c981b9b06922e13a97fe9\n+title: Step 22\n+challengeType: 20\n+dashedName: step-22\n+---\n+\n+# --description--\n+\n+Create an `elif` clause for the case `n == 1`. Within the `elif` clause, create an f-string containing the coefficient directly followed by a lowercase `x` and append it to the `terms` list.\n+\n+# --hints--\n+\n+You should create an `elif` clause to check if `n` is equal to `1`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_conditions()[1].is_equivalent(\"n==1\")`)) })\n+```\n+\n+You should append `f'{coefficient}x'` to the `terms` list within your new `elif` clause.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_bodies()[1].is_equivalent(\"terms.append(f'{coefficient}x')\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+--fcc-editable-region--\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                continue\n+            if n == 0:\n+                terms.append(f'{coefficient}')\n+        equation_string = ' '.join(terms)\n+        return equation_string\n+--fcc-editable-region--\n+        \n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+    \n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+```"
        },
        {
            "sha": "f7d9b47b36f41b636d91026f7c1026aa2a40d502",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/663c9f31306353460da54542.md",
            "status": "added",
            "additions": 86,
            "deletions": 0,
            "changes": 86,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663c9f31306353460da54542.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663c9f31306353460da54542.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F663c9f31306353460da54542.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,86 @@\n+---\n+id: 663c9f31306353460da54542\n+title: Step 23\n+challengeType: 20\n+dashedName: step-23\n+---\n+\n+# --description--\n+\n+As you can see, the `+` sign is missing from the output. The number sign is displayed by default only if negative. To change this behaviour, you can write a colon after the expression to be evaluated within the curly braces of your f-string, and specify the option `+`. This will allow you to display the sign both for positive and negative numbers.\n+\n+Modify the string in your two conditional clauses by adding `:+` inside the curly braces after `coefficient`.\n+\n+# --hints--\n+\n+You should modify the string to append to the `terms` list within your `if` statement into `f'{coefficient:+}'`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_bodies()[0].is_equivalent(\"terms.append(f'{coefficient:+}')\")`)) })\n+```\n+\n+You should modify the string to insert into the `terms` list within your `elif` clause into `f'{coefficient:+}x'`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_bodies()[1].is_equivalent(\"terms.append(f'{coefficient:+}x')\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+--fcc-editable-region--\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                continue\n+            if n == 0:\n+                terms.append(f'{coefficient}')\n+            elif n == 1:\n+                terms.append(f'{coefficient}x')                \n+        equation_string = ' '.join(terms)        \n+        return equation_string\n+--fcc-editable-region--    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+    \n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+```"
        },
        {
            "sha": "44efc0e41f79575f8dfcf213cc2faad61a83a2ab",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/664c670069bae45fd060c25d.md",
            "status": "added",
            "additions": 66,
            "deletions": 0,
            "changes": 66,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664c670069bae45fd060c25d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664c670069bae45fd060c25d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664c670069bae45fd060c25d.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,66 @@\n+---\n+id: 664c670069bae45fd060c25d\n+title: Step 18\n+challengeType: 20\n+dashedName: step-18\n+---\n+\n+# --description--\n+\n+Next, print your `lin_eq` instance.\n+\n+# --hints--\n+\n+You should print `lin_eq`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(lin_eq)\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+    \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}        \n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+--fcc-editable-region--\n+lin_eq = LinearEquation(2, 3)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "dcb6ed8676d5d53be95709f19fa733a2a29d1de2",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/664cb04a16fe6938708967ef.md",
            "status": "added",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664cb04a16fe6938708967ef.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664cb04a16fe6938708967ef.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664cb04a16fe6938708967ef.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,87 @@\n+---\n+id: 664cb04a16fe6938708967ef\n+title: Step 24\n+challengeType: 20\n+dashedName: step-24\n+---\n+\n+# --description--\n+\n+After joining the terms, concatenate the string `' = 0'` to `equation_string` to display the complete equation.\n+\n+Also, to refine the output, remove any leading `+` sign from `equation_string`.\n+\n+# --hints--\n+\n+The `__str__` method should return a different string representation.\n+\n+```js\n+({ test: () => assert(runPython(`\n+eq1 = LinearEquation(4, 2)\n+str(eq1) == '4x +2 = 0'\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+        \n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                continue\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+--fcc-editable-region--\n+        equation_string = ' '.join(terms)\n+        \n+        return equation_string\n+--fcc-editable-region--\n+        \n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+    \n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+```"
        },
        {
            "sha": "6dfabf2ed41931c57cbd73f5f7d8486b91a06f65",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/664e4a590b52ba8d2adff19f.md",
            "status": "added",
            "additions": 116,
            "deletions": 0,
            "changes": 116,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664e4a590b52ba8d2adff19f.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664e4a590b52ba8d2adff19f.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664e4a590b52ba8d2adff19f.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,116 @@\n+---\n+id: 664e4a590b52ba8d2adff19f\n+title: Step 30\n+challengeType: 20\n+dashedName: step-30\n+---\n+\n+# --description--\n+\n+The discriminant of a quadratic equation in the form \\\\( ax^2 + bx + c = 0 \\\\), usually indicated by the capital Greek letter delta, is equal to \\\\(  = b^2 - 4ac \\\\).\n+\n+Within the `QuadraticEquation` class, define an `__init__` method. Use `super()` to call the `__init__` method from the parent class. Then, define a new attribute named `delta`, which stores the value of the discriminant of the equation.\n+\n+# --hints--\n+\n+You should define an `__init__` method within the `QuadraticEquation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").has_function(\"__init__\")`)) })\n+```\n+\n+Your `__init__` method should take two parameters, `self` and `*args`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_function(\"__init__\").has_args(\"self, *args\")`)) })\n+```\n+\n+You should call `super().__init__(*args)` within your `__init__` method.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_function(\"__init__\").has_call(\"super().__init__(*args)\")`)) })\n+```\n+\n+You should declare a `delta` attribute within your `__init__` method and assign it the value of the discriminant of the equation.\n+\n+```js\n+({ test: () => runPython(`\n+eq = QuadraticEquation(2, -3, -4)\n+assert eq.delta == 41\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')                \n+        equation_string = ' '.join(terms) + ' = 0'\n+        return equation_string.strip('+')        \n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+--fcc-editable-region--\n+    \n+--fcc-editable-region--    \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+\n+```"
        },
        {
            "sha": "c4b381247db208c75375d4e12dd2198f596344bd",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/664e4e1b6c35a99cbba49e84.md",
            "status": "added",
            "additions": 105,
            "deletions": 0,
            "changes": 105,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664e4e1b6c35a99cbba49e84.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664e4e1b6c35a99cbba49e84.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664e4e1b6c35a99cbba49e84.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,105 @@\n+---\n+id: 664e4e1b6c35a99cbba49e84\n+title: Step 31\n+challengeType: 20\n+dashedName: step-31\n+---\n+\n+# --description--\n+\n+Now, create an instance of the `QuadraticEquation` class to represent the equation \\\\( 11x^2 - x + 1 = 0 \\\\).\n+\n+Assign the new instance to a variable `quadr_eq`, then print your new variable. Note that, at this point, the second degree term would be missing from the string representation of the equation.\n+\n+# --hints--\n+\n+You should declare a variable named `quadr_eq` and assign it an instance of `QuadraticEquation` passing it `11`, `-1`, and `1` as the arguments.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_stmt(\"quadr_eq = QuadraticEquation(11, -1, 1)\")`)) })\n+```\n+\n+You should print your `quadr_eq` variable.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(quadr_eq)\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')                \n+        equation_string = ' '.join(terms) + ' = 0'\n+        return equation_string.strip('+')        \n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+   \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+--fcc-editable-region-- \n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "92320495d9d5e6658137a8d7e9baba54e5b5cbb9",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/664ee8037f4bbe3c0944c35e.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664ee8037f4bbe3c0944c35e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664ee8037f4bbe3c0944c35e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664ee8037f4bbe3c0944c35e.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,110 @@\n+---\n+id: 664ee8037f4bbe3c0944c35e\n+title: Step 32\n+challengeType: 20\n+dashedName: step-32\n+---\n+\n+# --description--\n+\n+As you can see, the second-degree term is missing from the string representation. Within the `__str__` method, create an `else` clause to handle the case in which the exponent of \\\\( x \\\\) is greater than `1`.\n+\n+Append a string to the `terms` list so that the term is represented as `<coefficient>x**<exponent>`. Display the number sign both for positive and negative coefficients and make sure that the inserted string is suitable to represent equations of degree > 2, too.\n+\n+# --hints--\n+\n+You should create an `else` clause after your existing `elif` clause.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_conditions()[2].is_empty()`)) })\n+```\n+\n+You should append `f'{coefficient:+}x**{n}'` to the `terms` list within your new `else` clause.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_bodies()[2].is_equivalent(\"terms.append(f'{coefficient:+}x**{n}')\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+--fcc-editable-region--\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            \n+--fcc-editable-region--\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return equation_string.strip('+')        \n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+   \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+quadr_eq = QuadraticEquation(11, -1, 1)\n+print(quadr_eq)\n+\n+```"
        },
        {
            "sha": "7763093f4dd85c5de04ec61213e38ac8413e338d",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/664eec7f38234443b42c206f.md",
            "status": "added",
            "additions": 105,
            "deletions": 0,
            "changes": 105,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664eec7f38234443b42c206f.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664eec7f38234443b42c206f.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664eec7f38234443b42c206f.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,105 @@\n+---\n+id: 664eec7f38234443b42c206f\n+title: Step 33\n+challengeType: 20\n+dashedName: step-33\n+---\n+\n+# --description--\n+\n+Your equation is currently represented as `11x**2 -1x +1 = 0`, but it would be nice not to display the coefficient multiplying \\\\( x \\\\) when it's equal to one. So that equation is represented as `11x**2 -x +1 = 0`.\n+\n+Import the `re` module. You are going to use a regular expression to substitute the coefficients for this case during the next steps.\n+\n+# --hints--\n+\n+You should import the `re` module.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_import(\"import re\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return equation_string.strip('+')        \n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+   \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+quadr_eq = QuadraticEquation(11, -1, 1)\n+print(quadr_eq)\n+\n+```"
        },
        {
            "sha": "634e10aa5d9d1c93dd4e8143b7ee9a29bd14f279",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/664eef158d792a509e8d708a.md",
            "status": "added",
            "additions": 114,
            "deletions": 0,
            "changes": 114,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664eef158d792a509e8d708a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664eef158d792a509e8d708a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664eef158d792a509e8d708a.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,114 @@\n+---\n+id: 664eef158d792a509e8d708a\n+title: Step 34\n+challengeType: 20\n+dashedName: step-34\n+---\n+\n+# --description--\n+\n+The `sub` function from the `re` module enables you to replace text inside a string based on a regex pattern.\n+\n+```py\n+verse = 'Always look on the bright side of life'\n+spam = re.sub('bright', 'spam', verse)\n+spam == 'Always look on the spam side of life' # True\n+```\n+\n+It takes three arguments: the regex pattern to match, the replacement, and the string on which you want to perform the replacement.\n+\n+From your `__str__` function, return a `sub()` call passing the string `'1'`, an empty string, and your existing `equation_string.strip('+')` call as the arguments. This will replace each `1` with an empty string. The result is not refined yet and you'll continue to work on the regex pattern in the next steps.\n+\n+# --hints--\n+\n+You should return a `re.sub()` call from your `__str__` method. Pass the string `'1'`, an empty string, and your existing `equation_string.strip('+')` call as the arguments to `re.sub()`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").has_return(\"re.sub('1', '', equation_string.strip('+'))\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+--fcc-editable-region--\n+        return equation_string.strip('+')        \n+--fcc-editable-region--\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+   \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+quadr_eq = QuadraticEquation(11, -1, 1)\n+print(quadr_eq)\n+\n+```"
        },
        {
            "sha": "979773db32fbc86564f83acb62584ee9638e588a",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/664ef4623946e65e18d59764.md",
            "status": "added",
            "additions": 124,
            "deletions": 0,
            "changes": 124,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664ef4623946e65e18d59764.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664ef4623946e65e18d59764.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664ef4623946e65e18d59764.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,124 @@\n+---\n+id: 664ef4623946e65e18d59764\n+title: Step 35\n+challengeType: 20\n+dashedName: step-35\n+---\n+\n+# --description--\n+\n+In a regex pattern, a *lookaround* is an assertion that matches a certain pattern without consuming characters in the string. One kind of lookaround is the lookbehind, which can be either positive or negative. They are denoted by `(?<=...)` and `(?<!...)`, respectively.\n+\n+```py\n+spam = 'black back bat'\n+re.sub('(?<=l)a', 'o', spam) == 'block back bat' # True\n+re.sub('(?<!l)a', 'o', spam) == 'black bock bot' # True\n+```\n+\n+In the example above, the pattern `(?<=l)a` contains a positive lookbehind, which is used to match the `a` character only when preceded by an `l`. In the last line of the example, the pattern `(?<!l)a` contains a negative lookbehind, which is used to match the `a` character only if it is **not** preceded by an `l`. Note how, in both cases, the character contained in the lookbehind is not consumed.\n+\n+Modify your regex pattern to use a negative lookbehind so that the character `1` is substituted only if not preceded by a digit.\n+\n+# --hints--\n+\n+You should modify the pattern passed as the first argument to the `re.sub()` call using a negative lookbehind. TODO: add details/improve wording\n+\n+```js\n+({ test: () => assert(runPython(`\n+node = _Node(_code).find_class(\"Equation\").find_function(\"__str__\")\n+values = [\n+  \"re.sub('(?<!\\\\d)1', '', equation_string.strip('+'))\",\n+  \"re.sub(r'(?<!\\\\d)1', '', equation_string.strip('+'))\",\n+  \"re.sub('(?<![0-9])1', '', equation_string.strip('+'))\"\n+]\n+any(node.has_return(value) for value in values)\n+`)) })\n+```\n+\n+\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+--fcc-editable-region--\n+        return re.sub('1', '', equation_string.strip('+'))        \n+--fcc-editable-region--\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+   \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+quadr_eq = QuadraticEquation(11, -1, 1)\n+print(quadr_eq)\n+\n+```"
        },
        {
            "sha": "4897c538cc3899e7dcb49986849aed4d3920ee21",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/664f0389424a6f7aa15fd3e5.md",
            "status": "added",
            "additions": 114,
            "deletions": 0,
            "changes": 114,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664f0389424a6f7aa15fd3e5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664f0389424a6f7aa15fd3e5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664f0389424a6f7aa15fd3e5.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,114 @@\n+---\n+id: 664f0389424a6f7aa15fd3e5\n+title: Step 36\n+challengeType: 20\n+dashedName: step-36\n+---\n+\n+# --description--\n+\n+Another kind of lookaround assertion is the lookahead. Positive and negative lookahead are denoted by `(?=...)` and `(?!...)`, respectively. They are used to match a pattern if followed by a certain sequence of characters, which is not consumed:\n+\n+```py\n+spam = 'black back bat'\n+re.sub('a(?=t)', 'o', spam) == 'black back bot' # True\n+re.sub('a(?!t)', 'o', spam) == 'block bock bat' # True\n+```\n+\n+In the example above, the pattern `a(?=t)` contains a positive lookahead, which is used to match the `a` character only when followed by a `t`. In the last line of the example, the pattern `a(?!t)` contains a negative lookahead, which is used to match the `a` character only if **not** followed by a `t`. Again, in both cases, the character contained in the lookahead is not consumed.\n+\n+Add a positive lookahead to your regex pattern so that the character `1` is substituted only if followed by the character `x`.\n+\n+# --hints--\n+\n+You should modify your regex pattern using a positive lookahead to substitute the character `1` only if followed by an `x`. Do not remove the negative lookbehind from your pattern.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").has_return(\"re.sub(r'(?<!\\\\d)1(?=x)', '', equation_string.strip('+'))\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+--fcc-editable-region--\n+        return re.sub(r'(?<!\\d)1', '', equation_string.strip('+'))        \n+--fcc-editable-region--\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+   \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+quadr_eq = QuadraticEquation(11, -1, 1)\n+print(quadr_eq)\n+\n+```"
        },
        {
            "sha": "9e9750eafa3fc71b1da403a4a0d01b0c2f64a33b",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/664f4559c17d2138ae680566.md",
            "status": "added",
            "additions": 111,
            "deletions": 0,
            "changes": 111,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664f4559c17d2138ae680566.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664f4559c17d2138ae680566.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F664f4559c17d2138ae680566.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,111 @@\n+---\n+id: 664f4559c17d2138ae680566\n+title: Step 37\n+challengeType: 20\n+dashedName: step-37\n+---\n+\n+# --description--\n+\n+It's time to implement the `solve` method. When the discriminant of the quadratic equation is negative, the equation does not have real solutions, or roots.\n+\n+Within the `solve` method, create an `if` statement to check if the discriminant is negative. If it is, return an empty list.\n+\n+# --hints--\n+\n+You should create an `if` statement to check if `self.delta` is lower than `0`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_function(\"solve\").find_ifs()[0].find_conditions()[0].is_equivalent(\"self.delta < 0\")`)) })\n+```\n+\n+You should return an empty list from your new `if` statement.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_function(\"solve\").find_ifs()[0].find_bodies()[0].has_return(\"[]\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+--fcc-editable-region--\n+    def solve(self):\n+        pass\n+--fcc-editable-region--\n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+quadr_eq = QuadraticEquation(11, -1, 1)\n+print(quadr_eq)\n+\n+```"
        },
        {
            "sha": "28265c8c290302a2f18e06dcb44d6053eec75b1f",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6650583d9d9a194714da47f0.md",
            "status": "added",
            "additions": 111,
            "deletions": 0,
            "changes": 111,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650583d9d9a194714da47f0.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650583d9d9a194714da47f0.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650583d9d9a194714da47f0.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,111 @@\n+---\n+id: 6650583d9d9a194714da47f0\n+title: Step 38\n+challengeType: 20\n+dashedName: step-38\n+---\n+\n+# --description--\n+\n+The roots of quadratic equations can be found by applying the formula:\n+\n+\\\\[ x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} = \\frac{-b \\pm \\sqrt{\\Delta}}{2a} \\\\]\n+\n+After the `if` statement, create two variables: assign them the root obtained by taking the plus sign between \\\\( b \\\\) and the square root of the discriminant in the formula above, and the root obtained by taking the minus sign. Then, return a list containing your two new variables.\n+\n+# --hints--\n+\n+Your `solve` method should return a list containing the correct solutions.\n+\n+```js\n+({ test: () => runPython(`\n+eq = QuadraticEquation(-1, 2, 3)\n+assert eq.solve() == [-1, 3] or eq.solve() == [3, -1]\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+--fcc-editable-region--\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+--fcc-editable-region--\n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+quadr_eq = QuadraticEquation(11, -1, 1)\n+print(quadr_eq)\n+\n+```"
        },
        {
            "sha": "9932a49af6648c344484efb8fb8985f57e443dbf",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6650633eaeccf266fee14ba6.md",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650633eaeccf266fee14ba6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650633eaeccf266fee14ba6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650633eaeccf266fee14ba6.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,109 @@\n+---\n+id: 6650633eaeccf266fee14ba6\n+title: Step 39\n+challengeType: 20\n+dashedName: step-39\n+---\n+\n+# --description--\n+\n+It's time to test the `solve` method. Call it on your `quadr_eq` instance and print the result.\n+\n+# --hints--\n+\n+You should print `quadr_eq.solve()`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(quadr_eq.solve())\") or _Node(_code).has_call(\"print(quadr_eq.solve(), quadr_eq.results)\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+--fcc-editable-region--\n+quadr_eq = QuadraticEquation(11, -1, 1)\n+print(quadr_eq)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "3b98514b8fd7837186642317a55deb7f5abc6268",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6650e11fa60e222e691bb283.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650e11fa60e222e691bb283.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650e11fa60e222e691bb283.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650e11fa60e222e691bb283.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,110 @@\n+---\n+id: 6650e11fa60e222e691bb283\n+title: Step 40\n+challengeType: 20\n+dashedName: step-40\n+---\n+\n+# --description--\n+\n+Modify the first argument used to instantiate `quadr_eq` into `-11`. In this way, the discriminant of the equation will be positive.\n+\n+# --hints--\n+\n+You should modify the first argument used to instantiate `quadr_eq` into `-11`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_stmt(\"quadr_eq = QuadraticEquation(-11, -1, 1)\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+--fcc-editable-region--\n+quadr_eq = QuadraticEquation(11, -1, 1)\n+print(quadr_eq)\n+print(quadr_eq.solve())\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "3352d7578cdc1e5e591c1cc4ac8252730b0a6b88",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6650e27cf34f2335a9bbbd08.md",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650e27cf34f2335a9bbbd08.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650e27cf34f2335a9bbbd08.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650e27cf34f2335a9bbbd08.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,110 @@\n+---\n+id: 6650e27cf34f2335a9bbbd08\n+title: Step 41\n+challengeType: 20\n+dashedName: step-41\n+---\n+\n+# --description--\n+\n+One last check: modify your `quadr_eq` instance to represent the equation \\\\( x^2 + 2x + 1 = 0 \\\\).\n+\n+# --hints--\n+\n+You should modify the first two arguments used to instantiate `quadr_eq` into `1` and `2`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_stmt(\"quadr_eq = QuadraticEquation(1, 2, 1)\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+--fcc-editable-region--\n+quadr_eq = QuadraticEquation(-11, -1, 1)\n+print(quadr_eq)\n+print(quadr_eq.solve())\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "03ab1aa63a6f54e30b6cf0b4acf5dd76f0319c56",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6650e88cc500673ec881c9ca.md",
            "status": "added",
            "additions": 126,
            "deletions": 0,
            "changes": 126,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650e88cc500673ec881c9ca.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650e88cc500673ec881c9ca.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650e88cc500673ec881c9ca.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,126 @@\n+---\n+id: 6650e88cc500673ec881c9ca\n+title: Step 42\n+challengeType: 20\n+dashedName: step-42\n+---\n+\n+# --description--\n+\n+In this case, the discriminant is zero and the two roots are coincidents.\n+\n+Create an `if` statement to check if the discriminant is zero and return a list containing the root.\n+\n+# --hints--\n+\n+You should create an `if` statement to check if the `delta` attribute is equal to zero.\n+\n+```js\n+({ test: () => assert(runPython(`\n+node = _Node(_code).find_class(\"QuadraticEquation\").find_function(\"solve\").find_ifs()[1].find_conditions()[0]\n+node.is_equivalent(\"self.delta == 0\") or node.is_equivalent(\"not self.delta\")\n+`)) })\n+```\n+\n+You should return a list containing the root within your new `if` statement.\n+\n+```js\n+({ test: () => runPython(`\n+eq = QuadraticEquation(4, 4, 1)\n+assert eq.solve() == [-0.5]\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+--fcc-editable-region--\n+        \n+--fcc-editable-region--\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(quadr_eq)\n+print(quadr_eq.solve())\n+\n+```"
        },
        {
            "sha": "c1365ac273457e52abd874077b088a3993b8090b",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6650eb84e248684c2f57555c.md",
            "status": "added",
            "additions": 115,
            "deletions": 0,
            "changes": 115,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650eb84e248684c2f57555c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650eb84e248684c2f57555c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650eb84e248684c2f57555c.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,115 @@\n+---\n+id: 6650eb84e248684c2f57555c\n+title: Step 43\n+challengeType: 20\n+dashedName: step-43\n+---\n+\n+# --description--\n+\n+In general, it is good practice to make the same methods from different classes return the same type of data. The `solve` method from the `QuadraticEquation` class returns a list, because quadratic equations can have two roots.\n+\n+Although linear equations have a single real solution, modify the `solve` method within the `LinearEquation` class to return a list containing the root, so that the `solve` methods from different classes return the same type of data.\n+\n+# --hints--\n+\n+You should return a list containing the single root from the `solve` method of your `LinearEquation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"solve\").has_return(\"[x]\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+--fcc-editable-region--\n+        return x\n+--fcc-editable-region--\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(quadr_eq)\n+print(quadr_eq.solve())\n+\n+```"
        },
        {
            "sha": "d142ad020a50f42cc8cecb323c023b846feffc54",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6650f037c017aa6855a608e3.md",
            "status": "added",
            "additions": 118,
            "deletions": 0,
            "changes": 118,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650f037c017aa6855a608e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650f037c017aa6855a608e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6650f037c017aa6855a608e3.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,118 @@\n+---\n+id: 6650f037c017aa6855a608e3\n+title: Step 44\n+challengeType: 20\n+dashedName: step-44\n+---\n+\n+# --description--\n+\n+The graph of any quadratic equation has a parabolic shape. The \\\\( x \\\\) coordinate of the vertex of the parabola can be found at \\\\( x = - \\frac{b}{2a} \\\\).\n+\n+From the `analyze` method, return the dictionary containing two keys, `'x'`, and `'y'`, and the corresponding values of the vertex \\\\( x \\\\) and \\\\( y \\\\) coordinates, respectively.\n+\n+Use the relation above to find the \\\\( x \\\\) coordinate. Then, use the \\\\( x \\\\) coordinate to calculate the \\\\( y \\\\) coordinate.\n+\n+# --hints--\n+\n+You should return a dictionary containing two keys, `'x'`, and `'y'`, and the corresponding values of vertex `x` and `y` coordinates, respectively.\n+\n+```js\n+({ test: () => runPython(`\n+eq = QuadraticEquation(16, 2, 1)\n+assert eq.analyze() == {'x': -0.0625, 'y': 0.9375}\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+--fcc-editable-region--\n+    def analyze(self):\n+        pass\n+--fcc-editable-region--\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(quadr_eq)\n+print(quadr_eq.solve())\n+\n+```"
        },
        {
            "sha": "4220c78671c83409fb79a5c3b9530de605faa3c9",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/665460392acb7e91db2afad1.md",
            "status": "added",
            "additions": 126,
            "deletions": 0,
            "changes": 126,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F665460392acb7e91db2afad1.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F665460392acb7e91db2afad1.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F665460392acb7e91db2afad1.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,126 @@\n+---\n+id: 665460392acb7e91db2afad1\n+title: Step 45\n+challengeType: 20\n+dashedName: step-45\n+---\n+\n+# --description--\n+\n+When the second-degree coefficient is positive, the parabola has a minimum point and opens upward, or it is called concave upwards. Instead, when the second-degree coefficient is negative, the parabola has a maximum point and opens downward, or it is called concave downwards.\n+\n+<img alt=\"two parabolas with different concavities\" src=\"https://cdn.freecodecamp.org/curriculum/python/parabola.png\" style=\"background-color: white; height: 350px; width: auto; padding: 15px; display: block; margin-right: auto; margin-left: auto; margin-bottom: 1.2rem;\">\n+\n+Declare a `concavity` variable and assign it either the string `'upwards'` or `'downwards'`, depending on the concavity of the parabola. Also, declare a variable named `min_max` and assign it either the string `'min'` or `'max'`, depending on if the vertex is a minimum or a maximum, respectively.\n+\n+Finally, add the dictionary to return two keys `'min_max'` and `'concavity'` with the values of `min_max'` and `concavity`, respectively.\n+\n+# --hints--\n+\n+Your `analyze` method should return a dictionary with four keys, `'x'`, `'y'`, `'min_max'`, and `'concavity'` and the values of `x`, `y`, `min_max`, and `concavity`, respectively.\n+\n+```js\n+({ test: () => runPython(`\n+eq1 = QuadraticEquation(16, 2, 1)\n+eq2 = QuadraticEquation(-16, 2, 1)\n+assert eq1.analyze() == {'x': -0.0625, 'y': 0.9375, 'min_max': 'min', 'concavity': 'upwards'}\n+assert eq2.analyze() == {'x': 0.0625, 'y': 1.0625, 'min_max': 'max', 'concavity': 'downwards'}\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+--fcc-editable-region--\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        \n+        return {'x': x, 'y': y}\n+--fcc-editable-region--\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(quadr_eq)\n+print(quadr_eq.solve())\n+\n+```"
        },
        {
            "sha": "243f3e59477a19df1e1b52cd0ed26ffc54faf319",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/665467883dded0a1dad983b2.md",
            "status": "added",
            "additions": 121,
            "deletions": 0,
            "changes": 121,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F665467883dded0a1dad983b2.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F665467883dded0a1dad983b2.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F665467883dded0a1dad983b2.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,121 @@\n+---\n+id: 665467883dded0a1dad983b2\n+title: Step 46\n+challengeType: 20\n+dashedName: step-46\n+---\n+\n+# --description--\n+\n+Now, get rid of all your `print` calls.\n+\n+# --hints--\n+\n+You should delete all your `print` calls.\n+\n+```js\n+({ test: () => assert(runPython(`\n+_Node(_code).find_calls(\"print\") == []`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+--fcc-editable-region--\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(quadr_eq)\n+print(quadr_eq.solve())\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "243b25721482bc19e95f8a73118ff8a0a0bd9dc0",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/66558720bbe6e038315b7f81.md",
            "status": "added",
            "additions": 121,
            "deletions": 0,
            "changes": 121,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66558720bbe6e038315b7f81.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66558720bbe6e038315b7f81.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66558720bbe6e038315b7f81.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,121 @@\n+---\n+id: 66558720bbe6e038315b7f81\n+title: Step 47\n+challengeType: 20\n+dashedName: step-47\n+---\n+\n+# --description--\n+\n+Next, you are going to create a function that will trigger the instance methods you wrote to solve the equation. Also, it will display the results in a formatted output.\n+\n+Outside the classes, create a new function named `solver` that takes a single parameter, `equation`.\n+\n+# --hints--\n+\n+You should define a function named `solver` that takes a single parameter, `equation`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").has_args(\"equation\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+--fcc-editable-region--\n+\n+--fcc-editable-region--\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+\n+```"
        },
        {
            "sha": "e2479ae937689c22637fac929838fe6f9ee58ea4",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/665621ef85db565d26632761.md",
            "status": "added",
            "additions": 126,
            "deletions": 0,
            "changes": 126,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F665621ef85db565d26632761.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F665621ef85db565d26632761.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F665621ef85db565d26632761.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,126 @@\n+---\n+id: 665621ef85db565d26632761\n+title: Step 48\n+challengeType: 20\n+dashedName: step-48\n+---\n+\n+# --description--\n+\n+Within your new function, create an `if` statement that checks if `equation` is not an instance of the `Equation` class and raise a `TypeError` using the string `'Argument must be an Equation object'` to provide a custom message.\n+\n+# --hints--\n+\n+You should create an `if` statement to check if `equation` is not an instance of the `Equation` class within your `solver` function.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_ifs()[0].find_conditions()[0].is_equivalent(\"not isinstance(equation, Equation)\")`)) })\n+```\n+\n+You should raise a `TypeError` with the provided string within your new `if` statement.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_ifs()[0].find_bodies()[0].has_stmt(\"raise TypeError('Argument must be an Equation object')\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+--fcc-editable-region--\n+def solver(equation):\n+    pass\n+--fcc-editable-region--\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+\n+```"
        },
        {
            "sha": "67c9d540e0251c1edd60a2e3b915b6d52a3e4d25",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/66562f71937f877c66123bbe.md",
            "status": "added",
            "additions": 152,
            "deletions": 0,
            "changes": 152,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66562f71937f877c66123bbe.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66562f71937f877c66123bbe.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66562f71937f877c66123bbe.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,152 @@\n+---\n+id: 66562f71937f877c66123bbe\n+title: Step 49\n+challengeType: 20\n+dashedName: step-49\n+---\n+\n+# --description--\n+\n+The first thing to display at the top of the output will be the equation type. Add a class attribute named `type` to the `Equation` class and annotate it with `str`.\n+\n+Then, add another `if` statement to the `__init_subclass__` method to check if the classes inheriting from `Equation` have the `type` attribute. Use the same format of the existing `if` statement with the appropriate modifications.\n+\n+Finally, add the new class attribute to the `LinearEquation` class and to the `QuadraticEquation` class. Assign it the string `'Linear Equation'` and the string `'Quadratic Equation'`, respectively.\n+\n+# --hints--\n+\n+You should define a class variable named `type` within the `Equation` class and annotate it with `str`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").has_stmt(\"type: str\")`)) })\n+```\n+\n+You should create an `if` statement that checks if `cls` does not have the attribute `type` inside the `__init_subclass__` method and raise an `AttributeError` using the provided string.\n+\n+```js\n+({ test: () => assert(runPython(`\n+if_str = \"\"\"\n+if not hasattr(cls, 'type'):\n+  raise AttributeError(\n+    f\\\\\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\\\\\"\n+  )\n+\"\"\"\n+_Node(_code).find_class(\"Equation\").find_function(\"__init_subclass__\").has_stmt(if_str)\n+`)) })\n+```\n+\n+The `type` attribute of the `LinearEquation` class shouls have the value `'Linear Equation'`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").has_stmt(\"type = 'Linear Equation'\")`)) })\n+```\n+\n+The `type` attribute of the `QuadraticEquation` class should have the value `'Quadratic Equation'`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").has_stmt(\"type = 'Quadratic Equation'\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+--fcc-editable-region--\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+--fcc-editable-region--\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+\n+```"
        },
        {
            "sha": "568add5625c76e0a819fb0f49f543682b1b828b5",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/665ee783d35cb68875c626d4.md",
            "status": "added",
            "additions": 89,
            "deletions": 0,
            "changes": 89,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F665ee783d35cb68875c626d4.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F665ee783d35cb68875c626d4.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F665ee783d35cb68875c626d4.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,89 @@\n+---\n+id: 665ee783d35cb68875c626d4\n+title: Step 28\n+challengeType: 20\n+dashedName: step-28\n+---\n+\n+# --description--\n+\n+Now, remove both the `print(lin_eq.solve())` and `print(lin_eq.analyze())` calls from your code.\n+\n+# --hints--\n+\n+You should remove both your `print(lin_eq.solve())` and `print(lin_eq.analyze())` calls.\n+\n+```js\n+({ test: () => runPython(`\n+assert not _Node(_code).has_call(\"print(lin_eq.analyze())\")\n+assert not _Node(_code).has_call(\"print(lin_eq.solve())\")\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Equation(ABC):\n+    degree: int\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')                \n+        equation_string = ' '.join(terms) + ' = 0'\n+        return equation_string.strip('+')        \n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return x\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+print(lin_eq)\n+--fcc-editable-region--\n+print(lin_eq.solve())\n+print(lin_eq.analyze())\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "a94d0534bfce6271f7d910f015035ad1e1cc4f00",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/66759e32b88fb5459b1e0234.md",
            "status": "added",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66759e32b88fb5459b1e0234.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66759e32b88fb5459b1e0234.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66759e32b88fb5459b1e0234.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,56 @@\n+---\n+id: 66759e32b88fb5459b1e0234\n+title: Step 10\n+challengeType: 20\n+dashedName: step-10\n+---\n+\n+# --description--\n+\n+The `__init_subclass__` method is called whenever the class that defines it is subclassed and it enables to customize the child classes. The method takes a parameter named by convention `cls` (standing for \"class\"), which represents the new child class.\n+\n+Define an `__init_subclass__` method in your `Equation` class and give it a `cls` parameter.\n+\n+# --hints--\n+\n+You should define an `__init_subclass__` method with a `cls` parameter in your `Equation` class.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init_subclass__\").has_args(\"cls\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    \n+    def __init__(self):\n+        pass\n+--fcc-editable-region--\n+    \n+--fcc-editable-region--\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    def solve(self):\n+        pass\n+\n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation()\n+```"
        },
        {
            "sha": "12f942a39969846342a9b055d4bb6794e9e089a1",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6675a38a8b535e4ff3274520.md",
            "status": "added",
            "additions": 73,
            "deletions": 0,
            "changes": 73,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6675a38a8b535e4ff3274520.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6675a38a8b535e4ff3274520.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6675a38a8b535e4ff3274520.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,73 @@\n+---\n+id: 6675a38a8b535e4ff3274520\n+title: Step 11\n+challengeType: 20\n+dashedName: step-11\n+---\n+\n+# --description--\n+\n+The `hasatttr` built-in function takes an object as its first argument and a string representing an attribute name as its second argument. It returns a boolean indicating if the object has the specified attribute.\n+\n+Now you are going to use the `__init_subclass__` method to check if the child class has the `degree` attribute at the moment of the instantiation.\n+\n+Create an `if` statement to check if `cls` does not have a `degree` attribute. If so, raise an `AttributeError` and use the string `f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"` to provide a custom message.\n+\n+After that, fix the error that has appeared in the terminal by declaring a `degree` class attribute inside the `LinearEquation` class. This attribute should represent the degree of the equation, which is the exponent of the highest \\\\( x \\\\) term. Therefore, assign the integer `1` to the `degree` atttribute.\n+\n+# --hints--\n+\n+You should create an `if` statement that checks if `cls` does not have the attribute `degree` inside the `__init_subclass__` method.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init_subclass__\").find_ifs()[0].find_conditions()[0].is_equivalent(\"not hasattr(cls, 'degree')\")`)) })\n+```\n+\n+You should raise an `AttributeError` using the provided string inside your `if` statement.\n+\n+```js\n+({ test: () => runPython(`\n+raise_stmt = 'raise AttributeError(f\"Cannot create \\\\'{cls.__name__}\\\\' class: missing required attribute \\\\'degree\\\\'\")'\n+node = _Node(_code).find_class(\"Equation\").find_function(\"__init_subclass__\").find_ifs()[0].find_bodies()[0]\n+assert node.has_stmt(raise_stmt) \n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    \n+    def __init__(self):\n+        pass\n+--fcc-editable-region--\n+    def __init_subclass__(cls):\n+        pass\n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    \n+--fcc-editable-region--\n+    def solve(self):\n+        pass\n+\n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation()\n+```"
        },
        {
            "sha": "ac4ab7ed0790551eeb4acb934e09aae798787f68",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6675aaf418b41157f6ccd692.md",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6675aaf418b41157f6ccd692.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6675aaf418b41157f6ccd692.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6675aaf418b41157f6ccd692.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,62 @@\n+---\n+id: 6675aaf418b41157f6ccd692\n+title: Step 12\n+challengeType: 20\n+dashedName: step-12\n+---\n+\n+# --description--\n+\n+It's time to go back to the `__init__` method. Depending on the equation type, you'll need to pass a variable number of arguments during the instantiation.\n+\n+Add a second parameter `args` to the method and use the `*` operator to make it accept a variable number of arguments.\n+\n+# --hints--\n+\n+Your `__init__` method should take two parameters, `self`, and `*args`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").has_args(\"self, *args\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+\n+class Equation(ABC):\n+    degree: int\n+--fcc-editable-region--\n+    def __init__(self):\n+        pass\n+--fcc-editable-region--\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+\n+    def solve(self):\n+        pass\n+\n+    def analyze(self):\n+        pass\n+\n+\n+lin_eq = LinearEquation()\n+```"
        },
        {
            "sha": "a0134acc133a1f239b511e78d68ff08fbd2aa6c1",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/667938f754145d165c25725d.md",
            "status": "added",
            "additions": 153,
            "deletions": 0,
            "changes": 153,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667938f754145d165c25725d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667938f754145d165c25725d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667938f754145d165c25725d.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,153 @@\n+---\n+id: 667938f754145d165c25725d\n+title: Step 50\n+challengeType: 20\n+dashedName: step-50\n+---\n+\n+# --description--\n+\n+An interesting feature of f-strings is the capability of forcing the output to be right/left-aligned, or centered. After the expression to be evaluated is inside the curly braces, you need to write a colon followed by an alignment option (`<` to left-align, `>` to right-align, `^` to center) and a number representing the width, that is the number of characters in which you want to arrange the text. For example:\n+\n+```py\n+f'{\"Hello World\":>20}'\n+```\n+\n+Printing the string from the example above would result in right-aligned text arranged in a space of 20 characters.\n+\n+Back to the `solver` function, after your `if` statement, create a variable named `output_string` and assign it an f-string containing the equation type centered in a width of `24` characters. Make the string begin with a new line character, and return `output_string` from your function.\n+\n+Then, call the `solver` function passing `lin_eq` as the argument, and print the result.\n+\n+# --hints--\n+\n+You should define a variable named `output_string` and assign it `f'\\n{equation.type:^24}'`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").has_stmt(\"output_string = f'\\\\\\\\n{equation.type:^24}'\")`)) })\n+```\n+\n+Your `solver` function should return `output_string`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").has_return(\"output_string\")`)) })\n+```\n+\n+You should print `solver(lin_eq)`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(solver(lin_eq))\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+            \n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+--fcc-editable-region--\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "20e7b1951c46cc1fef4e9f052503a6b2fc5a401f",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/66793a552f357b17006a8726.md",
            "status": "added",
            "additions": 138,
            "deletions": 0,
            "changes": 138,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66793a552f357b17006a8726.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66793a552f357b17006a8726.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66793a552f357b17006a8726.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,138 @@\n+---\n+id: 66793a552f357b17006a8726\n+title: Step 51\n+challengeType: 20\n+dashedName: step-51\n+---\n+\n+# --description--\n+\n+Between the colon and the alignment option, you can specify a fill character, which will be used to fill the space around the text within the specified width.\n+\n+Add a `-` between the colon and the `^` in your f-string.\n+\n+# --hints--\n+\n+You should add a `-` character between the colon and the `^` in your f-string.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").has_stmt(\"output_string = f'\\\\\\\\n{equation.type:-^24}'\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+            \n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+--fcc-editable-region--\n+    output_string = f'\\n{equation.type:^24}'\n+--fcc-editable-region--\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "ef2fc35e24f32ddb087d461726bf19d3af97b8c1",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/66793c5b4bdacc17c40ff8e7.md",
            "status": "added",
            "additions": 150,
            "deletions": 0,
            "changes": 150,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66793c5b4bdacc17c40ff8e7.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66793c5b4bdacc17c40ff8e7.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66793c5b4bdacc17c40ff8e7.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,150 @@\n+---\n+id: 66793c5b4bdacc17c40ff8e7\n+title: Step 52\n+challengeType: 20\n+dashedName: step-52\n+---\n+\n+# --description--\n+\n+Another feature of f-strings enables you to convert the content of the replacement field (the curly braces) into a string by using a `!` followed by the conversion type `s`. For example, `f'{obj!s}'` converts `obj` into a string and it is equivalent to `f'{str(obj)}'`.\n+\n+From now on, you'll keep building the output by concatenating strings to `output_string`.\n+\n+Create a string containing the string representation of your equation centered in a width of `24` characters. Make the string begin and end with two newline characters, and add your new string to the current value of `output_string`.\n+\n+# --hints--\n+\n+The `solver` function should return a different string.\n+\n+```js\n+({ test: () => runPython(`\n+eq = LinearEquation(4, 3)\n+expected = \"\"\"\n+----Linear Equation-----\n+\n+       4x +3 = 0        \n+\n+\"\"\"\n+assert solver(eq) == expected\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+            \n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+--fcc-editable-region--\n+    output_string = f'\\n{equation.type:-^24}'\n+    \n+--fcc-editable-region--\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "37f26b130147183e58f44441bb534e46fff9df4a",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/66793d1e1581681871635ac6.md",
            "status": "added",
            "additions": 149,
            "deletions": 0,
            "changes": 149,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66793d1e1581681871635ac6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66793d1e1581681871635ac6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66793d1e1581681871635ac6.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,149 @@\n+---\n+id: 66793d1e1581681871635ac6\n+title: Step 53\n+challengeType: 20\n+dashedName: step-53\n+---\n+\n+# --description--\n+\n+Add a new piece to your `output_string` formed by the string `'Solutions'` centered in a width of 24 characters. Use a `-` as a fill character, and make the string end with two new line characters.\n+\n+# --hints--\n+\n+The `solver` function should return a different string.\n+\n+```js\n+({ test: () => runPython(`\n+eq = LinearEquation(4, 3)\n+expected = \"\"\"\n+----Linear Equation-----\n+\n+       4x +3 = 0        \n+\n+-------Solutions--------\n+\n+\"\"\"\n+assert solver(eq) == expected\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+--fcc-editable-region--\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    \n+--fcc-editable-region--\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "800f140b182616ac504efdd21749db607ee02977",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/66794346ddfa141cbe70093a.md",
            "status": "added",
            "additions": 139,
            "deletions": 0,
            "changes": 139,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66794346ddfa141cbe70093a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66794346ddfa141cbe70093a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66794346ddfa141cbe70093a.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,139 @@\n+---\n+id: 66794346ddfa141cbe70093a\n+title: Step 54\n+challengeType: 20\n+dashedName: step-54\n+---\n+\n+# --description--\n+\n+Now, call the `solve()` method of `equation` and assign the result a variable named `results`.\n+\n+# --hints--\n+\n+You should declare a variable `results` and assign it the result of calling `equation.solve()`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").has_stmt(\"results = equation.solve()\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+--fcc-editable-region--\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    \n+--fcc-editable-region--\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "ea7025af46709fad7691e5034e8c4b50e2ba64e6",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/667944fed1f6b61da3406bd8.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667944fed1f6b61da3406bd8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667944fed1f6b61da3406bd8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667944fed1f6b61da3406bd8.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,164 @@\n+---\n+id: 667944fed1f6b61da3406bd8\n+title: Step 55\n+challengeType: 20\n+dashedName: step-55\n+---\n+\n+# --description--\n+\n+Structural pattern matching is a Python construct that enables matching a pattern with a subject value, which is specified after the `match` keyword:\n+\n+```py\n+match value:\n+    case x:\n+        <code>\n+    case y:\n+        <code>\n+```\n+\n+Each pattern is specified after the `case` statement. If the match is positive, the code inside the `case` block is run.\n+\n+Use the `match`/`case` syntax to check the length of `results`. In case the length is `0`, assign a list containing the string `'No real roots'` to a variable named `result_list`.\n+\n+# --hints--\n+\n+You should create a `match`/`case` construct using `len(results)` as the subject value.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_subject().is_equivalent(\"len(results)\")`)) })\n+```\n+\n+You should create a new `case` with the pattern `0`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[0].find_case_pattern().is_equivalent(\"0\")`)) })\n+```\n+\n+You should assign a list containing `'No real roots'` to `result_list` inside the `case` body.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[0].find_case_body().is_equivalent(\"result_list = ['No real roots']\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+--fcc-editable-region--\n+    results = equation.solve()\n+    \n+--fcc-editable-region--\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "9dc7cd9e58a943ccf8d0a59cb8c6aad27e263cd0",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/66799278873fd2570217bffa.md",
            "status": "added",
            "additions": 165,
            "deletions": 0,
            "changes": 165,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66799278873fd2570217bffa.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66799278873fd2570217bffa.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66799278873fd2570217bffa.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,165 @@\n+---\n+id: 66799278873fd2570217bffa\n+title: Step 56\n+challengeType: 20\n+dashedName: step-56\n+---\n+\n+# --description--\n+\n+Add another `case` for when the length of `results` is `1`. In this case, assign to `result_list` a list containing a string with the format `x = <root>`, where `<root>` is the solution of the equation. Format the string so that both positive and negative sign are displayed for the solution.\n+\n+# --hints--\n+\n+You should not modify the subject value of your `match` statement.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_subject().is_equivalent(\"len(results)\")`)) })\n+```\n+\n+You should not modify your existing `case` block.\n+\n+```js\n+({ test: () => runPython(`\n+case = _Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[0]\n+assert case.find_case_pattern().is_equivalent(\"0\")\n+assert case.find_case_body().is_equivalent(\"result_list = ['No real roots']\")\n+`) })\n+```\n+\n+You should create a new `case` with the pattern `1` after the existing `case` block.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[1].find_case_pattern().is_equivalent(\"1\")`)) })\n+```\n+\n+You should assign a list containing `f'x = {results[0]:+}'` to `result_list` inside your new `case` body.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[1].find_case_body().is_equivalent(\"result_list = [f'x = {results[0]:+}']\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    results = equation.solve()\n+--fcc-editable-region--\n+    match len(results):\n+        case 0:\n+            result_list = ['No real roots']\n+--fcc-editable-region--\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "014ca1bbdc4aab72b80dbd068aa031c3f9ee2b63",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6679934707d5fe577f898efd.md",
            "status": "added",
            "additions": 170,
            "deletions": 0,
            "changes": 170,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6679934707d5fe577f898efd.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6679934707d5fe577f898efd.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6679934707d5fe577f898efd.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,170 @@\n+---\n+id: 6679934707d5fe577f898efd\n+title: Step 57\n+challengeType: 20\n+dashedName: step-57\n+---\n+\n+# --description--\n+\n+Add another case for when the length of `results` is `2`. This time, assign `result_list` a list containing two strings with the format `x1 = <root1>` and `x2 = <root2>`. Again, make the solution display both positive and negative signs.\n+\n+# --hints--\n+\n+You should not modify the subject value of your `match` statement.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_subject().is_equivalent(\"len(results)\")`)) })\n+```\n+\n+You should not modify your existing `case` blocks.\n+\n+```js\n+({ test: () => runPython(`\n+case0 = _Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[0]\n+assert case0.find_case_pattern().is_equivalent(\"0\")\n+assert case0.find_case_body().is_equivalent(\"result_list = ['No real roots']\")\n+case1 = _Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[1]\n+assert case1.find_case_pattern().is_equivalent(\"1\")\n+assert case1.find_case_body().is_equivalent(\"result_list = [f'x = {results[0]:+}']\")\n+`) })\n+```\n+\n+You should create a new `case` with the pattern `2` after the existing `case` block.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[2].find_case_pattern().is_equivalent(\"2\")`)) })\n+```\n+\n+You should assign a list containing two strings with the format `x1 = <root1>` and `x2 = <root2>` to `result_list` inside your new `case` body. Display both positive and negative signs for the results.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[2].find_case_body().is_equivalent(\"result_list = [f'x1 = {results[0]:+}', f'x2 = {results[1]:+}']\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    results = equation.solve()\n+--fcc-editable-region--\n+    match len(results):\n+        case 0:\n+            result_list = ['No real roots']\n+        case 1:\n+            result_list = [f'x = {results[0]:+}']\n+--fcc-editable-region--\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "256f94d514b7eb57f3b7489f5e5b0f1c8304ed52",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/66799ba07c5fd58a61a604d3.md",
            "status": "added",
            "additions": 159,
            "deletions": 0,
            "changes": 159,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66799ba07c5fd58a61a604d3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66799ba07c5fd58a61a604d3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66799ba07c5fd58a61a604d3.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,159 @@\n+---\n+id: 66799ba07c5fd58a61a604d3\n+title: Step 58\n+challengeType: 20\n+dashedName: step-58\n+---\n+\n+# --description--\n+\n+After your `match`/`case` block, iterate through `result_list` and concatenate each element to `output_string`. Keep aligning the text to the center and make each result string end with a new line character.\n+\n+# --hints--\n+\n+The `solver` function should return a different string.\n+\n+```js\n+({ test: () => runPython(`\n+eq = LinearEquation(4, 3)\n+expected = \"\"\"\n+----Linear Equation-----\n+\n+       4x +3 = 0        \n+\n+-------Solutions--------\n+\n+       x = -0.75        \n+\"\"\"\n+assert solver(eq) == expected\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    results = equation.solve()\n+--fcc-editable-region--\n+    match len(results):\n+        case 0:\n+            result_list = ['No real roots']\n+        case 1:\n+            result_list = [f'x = {results[0]:+}']\n+        case 2:\n+            result_list = [f'x1 = {results[0]:+}', f'x2 = {results[1]:+}']\n+--fcc-editable-region--\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "29f546be0ca2ac7427e2655aebabfcd060d81727",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/66799c1a0204668cef35555d.md",
            "status": "added",
            "additions": 157,
            "deletions": 0,
            "changes": 157,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66799c1a0204668cef35555d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66799c1a0204668cef35555d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F66799c1a0204668cef35555d.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,157 @@\n+---\n+id: 66799c1a0204668cef35555d\n+title: Step 59\n+challengeType: 20\n+dashedName: step-59\n+---\n+\n+# --description--\n+\n+f-strings also enable you to set a specific precision to your numerical data by using the `.nf` format specifier, where `n` is the number of decimal digits to display.\n+\n+Within the curly braces of the f-strings contained inside `result_list`, write the format specifier needed to display `3` decimal digits just after the `:+`.\n+\n+# --hints--\n+\n+You should modify the string contained in `result_list` in your `case 1` block into `f'x = {results[0]:+.3f}'`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[1].find_case_body().is_equivalent(\"result_list = [f'x = {results[0]:+.3f}']\")`)) })\n+```\n+\n+You should modify the strings contained in `result_list` in your `case 2` block so that the results are displayed with `3` decimal digits.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[2].find_case_body().is_equivalent(\"result_list = [f'x1 = {results[0]:+.3f}', f'x2 = {results[1]:+.3f}']\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    results = equation.solve()\n+--fcc-editable-region--\n+    match len(results):\n+        case 0:\n+            result_list = ['No real roots']\n+        case 1:\n+            result_list = [f'x = {results[0]:+}']\n+        case 2:\n+            result_list = [f'x1 = {results[0]:+}', f'x2 = {results[1]:+}']\n+    for result in result_list:\n+        output_string += f'{result:^24}\\n'\n+--fcc-editable-region--\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "80f54f79e9f5e6df4bbad10a0f08e897d07a82f6",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6679bf00da92e5c0db0ffdc3.md",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6679bf00da92e5c0db0ffdc3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6679bf00da92e5c0db0ffdc3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6679bf00da92e5c0db0ffdc3.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,164 @@\n+---\n+id: 6679bf00da92e5c0db0ffdc3\n+title: Step 61\n+challengeType: 20\n+dashedName: step-61\n+---\n+\n+# --description--\n+\n+Right after your `for` loop, add another piece to your output. Create a string having the text `Details` centered. Use a `-` as a fill character and make your string begin with a single newline character and end with two newline characters.\n+\n+# --hints--\n+\n+The `solver` function should return a different string.\n+\n+```js\n+({ test: () => runPython(`\n+eq = LinearEquation(4, 3)\n+expected = \"\"\"\n+----Linear Equation-----\n+\n+       4x +3 = 0        \n+\n+-------Solutions--------\n+\n+       x = -0.750       \n+\n+--------Details---------\n+\n+\"\"\"\n+assert solver(eq) == expected\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    results = equation.solve()\n+    match results:\n+        case []:\n+            result_list = ['No real roots']\n+        case [x]:\n+            result_list = [f'x = {x:+.3f}']\n+        case [x1, x2]:\n+            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n+--fcc-editable-region--\n+    for result in result_list:\n+        output_string += f'{result:^24}\\n'\n+--fcc-editable-region--\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "aeb6f415b02a099241dfc9cf928119149c405487",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/6679bfe40a6d77c6a3c17e06.md",
            "status": "added",
            "additions": 150,
            "deletions": 0,
            "changes": 150,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6679bfe40a6d77c6a3c17e06.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6679bfe40a6d77c6a3c17e06.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F6679bfe40a6d77c6a3c17e06.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,150 @@\n+---\n+id: 6679bfe40a6d77c6a3c17e06\n+title: Step 62\n+challengeType: 20\n+dashedName: step-62\n+---\n+\n+# --description--\n+\n+Now, call the `analyze` method of `equation` and assign the result to a new variable named `details`.\n+\n+# --hints--\n+\n+You should declare a variable `details` and assign it the result of calling `equation.analyze()`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").has_stmt(\"details = equation.analyze()\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    results = equation.solve()\n+    match results:\n+        case []:\n+            result_list = ['No real roots']\n+        case [x]:\n+            result_list = [f'x = {x:+.3f}']\n+        case [x1, x2]:\n+            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n+    for result in result_list:\n+        output_string += f'{result:^24}\\n'\n+--fcc-editable-region--\n+    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n+--fcc-editable-region--\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "0e3f06d83d46755ca61ff00db61065c247f71864",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/667a7ce2a9925416e7b4781b.md",
            "status": "added",
            "additions": 197,
            "deletions": 0,
            "changes": 197,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a7ce2a9925416e7b4781b.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a7ce2a9925416e7b4781b.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a7ce2a9925416e7b4781b.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,197 @@\n+---\n+id: 667a7ce2a9925416e7b4781b\n+title: Step 60\n+challengeType: 20\n+dashedName: step-60\n+---\n+\n+# --description--\n+\n+The structural pattern matching enables you to verify that the subject has a specific structure. In addition to that, it binds names in the pattern to elements of the subject. For example:\n+\n+```py\n+match my_list:\n+    case [a]:\n+        print(a)\n+    case [a, b]:\n+        print(a, b)\n+```\n+\n+Modify your `match`/`case` construct to match `results` instead of `len(results)`. Then, modify each `case` to use a list with the appropriate number of elements. Use `x` for the case the list contains a single element, and `x1` and `x2` for the case the list contains two elements.\n+\n+Finally, modify the f-strings to use the variable names used in each `case`.\n+\n+# --hints--\n+\n+You should modify your `match` statement to use `results` as the subject value.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_subject().is_equivalent(\"results\")`)) })\n+```\n+\n+You should modify your first `case` to use the pattern `[]`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[0].find_case_pattern().is_equivalent(\"[]\")`)) })\n+```\n+\n+You should not modify your first `case` body.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[0].find_case_body().is_equivalent(\"result_list = ['No real roots']\")`)) })\n+```\n+\n+You should modify your second `case` to use the pattern `[x]`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[1].find_case_pattern().is_equivalent(\"[x]\")`)) })\n+```\n+\n+You should modify the f-string contained inside `result_list` to use `x` in place of `result[0]`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[1].find_case_body().is_equivalent(\"result_list = [f'x = {x:+.3f}']\")`)) })\n+```\n+\n+You should modify your third `case` to use a list containing `x1` and `x2` as the pattern.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[2].find_case_pattern().is_equivalent(\"[x1, x2]\")`)) })\n+```\n+\n+You should modify the f-strings contained inside `result_list` to use the bound variables from your pattern.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[2].find_case_body().is_equivalent(\"result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    results = equation.solve()\n+--fcc-editable-region--\n+    match len(results):\n+        case 0:\n+            result_list = ['No real roots']\n+        case 1:\n+            result_list = [f'x = {results[0]:+.3f}']\n+        case 2:\n+            result_list = [f'x1 = {results[0]:+.3f}', f'x2 = {results[1]:+.3f}']\n+--fcc-editable-region--\n+    for result in result_list:\n+        output_string += f'{result:^24}\\n'\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "ec440a2a70f2492600ba0e4e1d0aa68115cb252b",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/667a860c3b61f61b7a18930c.md",
            "status": "added",
            "additions": 168,
            "deletions": 0,
            "changes": 168,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a860c3b61f61b7a18930c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a860c3b61f61b7a18930c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a860c3b61f61b7a18930c.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,168 @@\n+---\n+id: 667a860c3b61f61b7a18930c\n+title: Step 63\n+challengeType: 20\n+dashedName: step-63\n+---\n+\n+# --description--\n+\n+Create another `match`/`case` construct to match the value of the `details` variable.\n+\n+When the equation is linear, `details` is a dictionary having the form `{'slope': slope, 'intercept': intercept}`. Use it as the pattern for your first `case`.\n+\n+Then, inside the `case` block, declare a variable named `details_list` and assign it a list containing two strings having the form `slope = <slope>` and `y-intercept = <intercept>`, respectively. Format the strings to display `3` decimal digits.\n+\n+# --hints--\n+\n+You should create a new `match` statement that uses `details` as the subject value.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[1].find_match_subject().is_equivalent(\"details\")`)) })\n+```\n+\n+You should create a new `case` with the pattern `{'slope': slope, 'intercept': intercept}`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[1].find_match_cases()[0].find_case_pattern().is_equivalent(\"{'slope': slope, 'intercept': intercept}\")`)) })\n+```\n+\n+You should assign a list containing two f-strings having the form `slope = <slope>` and `y-intercept = <intercept>` to `details_list` inside the `case` body. Remember to format the numerical values to display `3` decimal digits.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[1].find_match_cases()[0].find_case_body().is_equivalent(\"details_list = [f'slope = {slope:.3f}', f'y-intercept = {intercept:.3f}']\")`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    results = equation.solve()\n+    match results:\n+        case []:\n+            result_list = ['No real roots']\n+        case [x]:\n+            result_list = [f'x = {x:+.3f}']\n+        case [x1, x2]:\n+            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n+    for result in result_list:\n+        output_string += f'{result:^24}\\n'\n+    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n+--fcc-editable-region--\n+    details = equation.analyze()\n+    \n+--fcc-editable-region--\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "ac784442341e46d452cf7daf9c8aa5333fbcc4fd",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/667a8d7a735cf221729570ff.md",
            "status": "added",
            "additions": 225,
            "deletions": 0,
            "changes": 225,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a8d7a735cf221729570ff.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a8d7a735cf221729570ff.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a8d7a735cf221729570ff.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,225 @@\n+---\n+id: 667a8d7a735cf221729570ff\n+title: Step 64\n+challengeType: 20\n+dashedName: step-64\n+---\n+\n+# --description--\n+\n+Add another `case` for when the equation is quadratic. Use a dictionary with the same format returned by the `analyze` method of `QuadraticEquation`.\n+\n+Then, assign `details_list` a list containing two strings with the format `concavity = <concavity>` and `<min_max> = (<x>, <y>)`, respectively. Format `<x>` and `<y>` to display `3` decimal digits.\n+\n+Finally, after the `match`/`case` block, iterate through `details_list` and add each item to the current value of `output_string`. Make sure that each string item ends with a newline character. Do not use any additional format option here.\n+\n+# --hints--\n+\n+You should not modify the subject value of your `match` statement.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[1].find_match_subject().is_equivalent(\"details\")`)) })\n+```\n+\n+You should not modify your existing `case` block.\n+\n+```js\n+({ test: () => runPython(`\n+case = _Node(_code).find_function(\"solver\").find_matches()[1].find_match_cases()[0]\n+assert case.find_case_pattern().is_equivalent(\"{'slope': slope, 'intercept': intercept}\")\n+assert case.find_case_body().is_equivalent(\"details_list = [f'slope = {slope:.3f}', f'y-intercept = {intercept:.3f}']\")\n+`) })\n+```\n+\n+You should create a new `case` block for when `equation` is a quadratic equation.\n+\n+```js\n+({ test: () => assert(runPython(`len(_Node(_code).find_function(\"solver\").find_matches()[1].find_match_cases()) == 2`)) })\n+```\n+\n+You should create a `for` loop to iterate over `details_list`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_for_loops()[1].find_for_iter().is_equivalent(\"details_list\")`)) })\n+```\n+\n+Your `solver` function should return a different string. \n+\n+```js\n+({ test: () => runPython(`\n+expected1 = \"\"\"\n+----Linear Equation-----\n+\n+       4x +3 = 0        \n+\n+-------Solutions--------\n+\n+       x = -0.750       \n+\n+--------Details---------\n+\n+slope = 4.000\n+y-intercept = 3.000\n+\"\"\"\n+eq1 = LinearEquation(4, 3)\n+actual1 = solver(eq1)\n+assert expected1 == actual1\n+\n+expected2 = \"\"\"\n+---Quadratic Equation---\n+\n+    x**2 -3x +1 = 0     \n+\n+-------Solutions--------\n+\n+      x1 = +2.618       \n+      x2 = +0.382       \n+\n+--------Details---------\n+\n+concavity = upwards\n+min = (1.500, -1.250)\n+\"\"\"\n+eq2 = QuadraticEquation(1, -3, 1)\n+actual2 = solver(eq2)\n+assert expected2 == actual2\n+`) })\n+```\n+\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    results = equation.solve()\n+    match results:\n+        case []:\n+            result_list = ['No real roots']\n+        case [x]:\n+            result_list = [f'x = {x:+.3f}']\n+        case [x1, x2]:\n+            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n+    for result in result_list:\n+        output_string += f'{result:^24}\\n'\n+    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n+--fcc-editable-region--\n+    details = equation.analyze()\n+    match details:\n+        case {'slope': slope, 'intercept': intercept}:\n+            details_list = [f'slope = {slope:.3f}', f'y-intercept = {intercept:.3f}']\n+    \n+--fcc-editable-region--\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "dd9ca120c4097b810e777053a242ab70827455ab",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/667a965d5a4b5825ffb2e1d8.md",
            "status": "added",
            "additions": 196,
            "deletions": 0,
            "changes": 196,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a965d5a4b5825ffb2e1d8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a965d5a4b5825ffb2e1d8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a965d5a4b5825ffb2e1d8.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,196 @@\n+---\n+id: 667a965d5a4b5825ffb2e1d8\n+title: Step 65\n+challengeType: 20\n+dashedName: step-65\n+---\n+\n+# --description--\n+\n+Modify the strings contained inside `details_list` to right-align the numerical values of the slope and the intercept. The final output should look like this:\n+\n+```py\n+\n+----Linear Equation-----\n+\n+       2x +3 = 0        \n+\n+-------Solutions--------\n+\n+       x = -1.500       \n+\n+--------Details---------\n+\n+slope =            2.000\n+y-intercept =      3.000\n+\n+```\n+\n+Note that the align option and the width should be placed between the colon and the precision format specifier.\n+\n+# --hints--\n+\n+The `solver` function should return a different string.\n+\n+```js\n+({ test: () => runPython(`\n+eq = LinearEquation(44, 3)\n+expected = \"\"\"\n+----Linear Equation-----\n+\n+       44x +3 = 0       \n+\n+-------Solutions--------\n+\n+       x = -0.068       \n+\n+--------Details---------\n+\n+slope =           44.000\n+y-intercept =      3.000\n+\"\"\"\n+assert solver(eq) == expected, f'{solver(eq)}'\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    results = equation.solve()\n+    match results:\n+        case []:\n+            result_list = ['No real roots']\n+        case [x]:\n+            result_list = [f'x = {x:+.3f}']\n+        case [x1, x2]:\n+            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n+    for result in result_list:\n+        output_string += f'{result:^24}\\n'\n+    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n+    details = equation.analyze()\n+    match details:\n+        case {'slope': slope, 'intercept': intercept}:\n+--fcc-editable-region--\n+            details_list = [f'slope = {slope:.3f}', f'y-intercept = {intercept:.3f}']\n+--fcc-editable-region--\n+        case {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}:\n+            coord = f'({x:.3f}, {y:.3f})'\n+            details_list = [f'concavity = {concavity}', f'{min_max} = {coord}']\n+    for detail in details_list:\n+        output_string += f'{detail}\\n'    \n+\n+    return output_string\n+\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+\n+```"
        },
        {
            "sha": "6c5e38b28d4d5c1a63824116c24e8817b58adaad",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/667a9c91a87bb453a355b63d.md",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a9c91a87bb453a355b63d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a9c91a87bb453a355b63d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667a9c91a87bb453a355b63d.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,173 @@\n+---\n+id: 667a9c91a87bb453a355b63d\n+title: Step 66\n+challengeType: 20\n+dashedName: step-66\n+---\n+\n+# --description--\n+\n+Feel free to change the coefficients of your `lin_eq` to see how the output changes.\n+\n+Then, delete your `print(solver(lin_eq))` call, and print the result of calling `solver()` with `quadr_eq` as the argument.\n+\n+# --hints--\n+\n+You should not have `print(solver(lin_eq))` in your code.\n+\n+```js\n+({ test: () => assert.isFalse(runPython(`_Node(_code).has_call(\"print(solver(lin_eq))\")`)) })\n+```\n+\n+You should print `solver(quadr_eq)`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_call(\"print(solver(quadr_eq))\")`)) })\n+```\n+\n+# --hints--\n+\n+Test 1\n+\n+```js\n+\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    results = equation.solve()\n+    match results:\n+        case []:\n+            result_list = ['No real roots']\n+        case [x]:\n+            result_list = [f'x = {x:+.3f}']\n+        case [x1, x2]:\n+            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n+    for result in result_list:\n+        output_string += f'{result:^24}\\n'\n+    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n+    details = equation.analyze()\n+    match details:\n+        case {'slope': slope, 'intercept': intercept}:\n+            details_list = [f'slope = {slope:>16.3f}', f'y-intercept = {intercept:>10.3f}']\n+        case {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}:\n+            coord = f'({x:.3f}, {y:.3f})'\n+            details_list = [f'concavity = {concavity}', f'{min_max} = {coord}']\n+    for detail in details_list:\n+        output_string += f'{detail}\\n'\n+    return output_string\n+--fcc-editable-region--\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(lin_eq))\n+--fcc-editable-region--\n+```"
        },
        {
            "sha": "7222c18f05f0e8f979521a377e4d54ee010e20cf",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/667aa056f1240f58fb9a2c17.md",
            "status": "added",
            "additions": 331,
            "deletions": 0,
            "changes": 331,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667aa056f1240f58fb9a2c17.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667aa056f1240f58fb9a2c17.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667aa056f1240f58fb9a2c17.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,331 @@\n+---\n+id: 667aa056f1240f58fb9a2c17\n+title: Step 67\n+challengeType: 20\n+dashedName: step-67\n+---\n+\n+# --description--\n+\n+As a last step, modify the strings contained in `details_list` so that the text placed after the equal sign is right-aligned for each line. Your final output should look like this:\n+\n+```py\n+\n+---Quadratic Equation---\n+\n+    x**2 +2x +1 = 0     \n+\n+-------Solutions--------\n+\n+       x = -1.000       \n+\n+--------Details---------\n+\n+concavity =      upwards\n+min =    (-1.000, 0.000)\n+\n+```\n+\n+With that, the project is complete!\n+\n+# --hints--\n+\n+The `solver` function should return a different string.\n+\n+```js\n+({ test: () => runPython(`\n+eq = QuadraticEquation(-4, 3, 2)\n+expected = \"\"\"\n+---Quadratic Equation---\n+\n+   -4x**2 +3x +2 = 0    \n+\n+-------Solutions--------\n+\n+      x1 = -0.425       \n+      x2 = +1.175       \n+\n+--------Details---------\n+\n+concavity =    downwards\n+max =     (0.375, 2.562)\n+\"\"\"\n+assert solver(eq) == expected\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    results = equation.solve()\n+    match results:\n+        case []:\n+            result_list = ['No real roots']\n+        case [x]:\n+            result_list = [f'x = {x:+.3f}']\n+        case [x1, x2]:\n+            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n+    for result in result_list:\n+        output_string += f'{result:^24}\\n'\n+    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n+    details = equation.analyze()\n+    match details:\n+        case {'slope': slope, 'intercept': intercept}:\n+            details_list = [f'slope = {slope:>16.3f}', f'y-intercept = {intercept:>10.3f}']\n+        case {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}:\n+            coord = f'({x:.3f}, {y:.3f})'\n+--fcc-editable-region--\n+            details_list = [f'concavity = {concavity}', f'{min_max} = {coord}']\n+--fcc-editable-region--\n+    for detail in details_list:\n+        output_string += f'{detail}\\n'\n+    return output_string\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(quadr_eq))\n+\n+```\n+\n+# --solutions--\n+\n+```py\n+from abc import ABC, abstractmethod\n+import re\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    type: str\n+  \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+        if any(not isinstance(arg, (int, float)) for arg in args):\n+            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+        if args[0] == 0:\n+            raise ValueError(\"Highest degree coefficient must be different from zero\")\n+        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n+\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+        if not hasattr(cls, \"type\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n+            )\n+\n+    def __str__(self):\n+        terms = []\n+        for n, coefficient in self.coefficients.items():\n+            if not coefficient:\n+                coefficient\n+            if n == 0:\n+                terms.append(f'{coefficient:+}')\n+            elif n == 1:\n+                terms.append(f'{coefficient:+}x')\n+            else:\n+                terms.append(f\"{coefficient:+}x**{n}\")\n+        equation_string = ' '.join(terms) + ' = 0'\n+        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n+\n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+\n+\n+class LinearEquation(Equation):\n+    degree = 1\n+    type = 'Linear Equation'\n+    \n+    def solve(self):\n+        a, b = self.coefficients.values()\n+        x = -b / a\n+        return [x]\n+\n+    def analyze(self):\n+        slope, intercept = self.coefficients.values()\n+        return {'slope': slope, 'intercept': intercept}\n+\n+\n+class QuadraticEquation(Equation):\n+    degree = 2\n+    type = 'Quadratic Equation'\n+\n+    def __init__(self, *args):\n+        super().__init__(*args)\n+        a, b, c = self.coefficients.values()\n+        self.delta = b**2 - 4 * a * c\n+\n+    def solve(self):\n+        if self.delta < 0:\n+            return []\n+        a, b, _ = self.coefficients.values()\n+        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n+        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n+        if self.delta == 0:\n+            return [x1]\n+\n+        return [x1, x2]\n+\n+    def analyze(self):\n+        a, b, c = self.coefficients.values()\n+        x = -b / (2 * a)\n+        y = a * x**2 + b * x + c\n+        if a > 0:\n+            concavity = 'upwards'\n+            min_max = 'min'\n+        else:\n+            concavity = 'downwards'\n+            min_max = 'max'\n+        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n+\n+\n+def solver(equation):\n+    if not isinstance(equation, Equation):\n+        raise TypeError(\"Argument must be an Equation object\")\n+\n+    output_string = f'\\n{equation.type:-^24}'\n+    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n+    output_string += f'{\"Solutions\":-^24}\\n\\n'\n+    results = equation.solve()\n+    match results:\n+        case []:\n+            result_list = ['No real roots']\n+        case [x]:\n+            result_list = [f'x = {x:+.3f}']\n+        case [x1, x2]:\n+            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n+    for result in result_list:\n+        output_string += f'{result:^24}\\n'\n+    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n+    details = equation.analyze()\n+    match details:\n+        case {'slope': slope, 'intercept': intercept}:\n+            details_list = [f'slope = {slope:>16.3f}', f'y-intercept = {intercept>10:.3f}']\n+        case {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}:\n+            coord = f'({x:.3f}, {y:.3f})'\n+            details_list = [f'concavity = {concavity:>12}', f'{min_max} = {coord:>18}']\n+    for detail in details_list:\n+        output_string += f'{detail}\\n'\n+    return output_string\n+lin_eq = LinearEquation(2, 3)\n+quadr_eq = QuadraticEquation(1, 2, 1)\n+print(solver(quadr_eq))\n+\n+```"
        },
        {
            "sha": "4222e8403087e4ef9b086fb11df3b4317bf62ced",
            "filename": "curriculum/challenges/english/07-scientific-computing-with-python/learn-interfaces-by-building-an-equation-solver/667e623208053643ca9d3c6e.md",
            "status": "added",
            "additions": 116,
            "deletions": 0,
            "changes": 116,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667e623208053643ca9d3c6e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/5a453cee992ad6583729afb95c80c9aac6ad0493/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667e623208053643ca9d3c6e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F07-scientific-computing-with-python%2Flearn-interfaces-by-building-an-equation-solver%2F667e623208053643ca9d3c6e.md?ref=5a453cee992ad6583729afb95c80c9aac6ad0493",
            "patch": "@@ -0,0 +1,116 @@\n+---\n+id: 667e623208053643ca9d3c6e\n+title: Step 15\n+challengeType: 20\n+dashedName: step-15\n+---\n+\n+# --description--\n+\n+Now, replace the `for` loop and `if` statement you added in the previous step with an `if` statement that uses the `any()` built-in function.\n+\n+# --hints--\n+\n+The condition of your new `if` statement should be a call to `any()`.\n+\n+```js\n+({ test: () => runPython(`\n+cond = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[1].find_conditions()[0]\n+calls = _Node(str(cond)).find_calls(\"any\")\n+assert len(calls) == 1\n+`) })\n+```\n+\n+You should pass a generator expression as the argument to your `any()` call.\n+\n+```js\n+({ test: () => runPython(`\n+import ast\n+argument = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[1].find_conditions()[0].find_call_args()[0]\n+assert isinstance(argument.tree, ast.GeneratorExp)\n+`) })\n+```\n+\n+The generator expression passed to `any()` should iterate over `args`.\n+\n+```js\n+({ test: () => runPython(`\n+import ast\n+argument = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[1].find_conditions()[0].find_call_args()[0]\n+iters = argument.find_comp_iters()\n+assert len(iters) == 1\n+assert iters[0].is_equivalent(\"args\")\n+`) })\n+```\n+\n+Your `if` statement should check if any of the arguments in `args` is not an instance of either `int` or `float`.\n+\n+```js\n+({ test: () => runPython(`\n+import ast\n+argument = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[1].find_conditions()[0].find_call_args()[0]\n+target = argument.find_comp_targets()[0]\n+expr = argument.find_comp_expr()\n+solutions = [\n+  f\"not isinstance({target}, (int, float))\",\n+  f\"not isinstance({target}, (float, int))\",\n+  f\"not isinstance({target}, float) and not isinstance({target}, int)\",\n+  f\"not isinstance({target}, int) and not isinstance({target}, float)\",\n+]\n+assert any(expr.is_equivalent(sol) for sol in solutions)\n+`) })\n+```\n+\n+You should use the provided string to raise a `TypeError` within your new `if` statement.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[1].find_bodies()[0].has_stmt(\"raise TypeError(\\\\\"Coefficients must be of type 'int' or 'float'\\\\\")\")\n+`)) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+\n+class Equation(ABC):\n+    degree: int\n+    \n+    def __init__(self, *args):\n+        if (self.degree + 1) != len(args):\n+            raise TypeError(\n+                f\"'{self.__class__.__name__}' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n+            )\n+--fcc-editable-region--\n+        for arg in args:\n+            if not isinstance(arg, (int, float)):\n+                raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n+--fcc-editable-region--\n+    def __init_subclass__(cls):\n+        if not hasattr(cls, \"degree\"):\n+            raise AttributeError(\n+                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n+            )\n+    \n+    @abstractmethod\n+    def solve(self):\n+        pass\n+        \n+    @abstractmethod\n+    def analyze(self):\n+        pass\n+        \n+class LinearEquation(Equation):\n+    degree = 1\n+    \n+    def solve(self):\n+        pass\n+    \n+    def analyze(self):\n+        pass\n+    \n+lin_eq = LinearEquation(2, 3)\n+```"
        }
    ],
    "stats": {
        "total": 7997,
        "additions": 7996,
        "deletions": 1
    }
}