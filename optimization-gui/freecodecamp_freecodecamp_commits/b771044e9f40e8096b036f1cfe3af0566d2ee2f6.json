{
    "author": "clarencepenz",
    "message": "feat(curriculum): Add interactive examples to closures lesson (#63380)",
    "sha": "b771044e9f40e8096b036f1cfe3af0566d2ee2f6",
    "files": [
        {
            "sha": "d5d2d2d6fa5422a31251e5e87f2981059061069c",
            "filename": "curriculum/challenges/english/blocks/lecture-working-with-code-quality-and-execution-concepts/6732c6e281c14a61c4858361.md",
            "status": "modified",
            "additions": 23,
            "deletions": 7,
            "changes": 30,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/b771044e9f40e8096b036f1cfe3af0566d2ee2f6/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-quality-and-execution-concepts%2F6732c6e281c14a61c4858361.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/b771044e9f40e8096b036f1cfe3af0566d2ee2f6/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-quality-and-execution-concepts%2F6732c6e281c14a61c4858361.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-code-quality-and-execution-concepts%2F6732c6e281c14a61c4858361.md?ref=b771044e9f40e8096b036f1cfe3af0566d2ee2f6",
            "patch": "@@ -5,12 +5,14 @@ challengeType: 19\n dashedName: what-are-closures-and-how-do-they-work\n ---\n \n-# --description--\n+# --interactive--\n \n Closures are one of the most powerful and often misunderstood features in JavaScript. At its core, a closure is a function that has access to variables in its outer enclosing lexical scope, even after the outer function has returned. This might sound complex but it's a fundamental concept that enables many advanced programming patterns in JavaScript. \n \n To understand closures, let's start with an example:\n \n+:::interactive_editor\n+\n ```js\n function outerFunction(x) {\n     let y = 10;\n@@ -21,15 +23,19 @@ function outerFunction(x) {\n }\n \n let closure = outerFunction(5);\n-closure(); // Output: 15\n+console.log(closure()); // 15\n ```\n \n+:::\n+\n In this example, `outerFunction` takes a parameter `x` and defines a local variable `y`. It then defines an `innerFunction` that uses both `x` and `y`. Finally it returns `innerFunction`. When we call `outerFunction(5)` it returns `innerFunction` which we assign to the variable `closure`. When we later call `closure()` it still has access to `x` and `y` from `outerFunction` even though `outerFunction` has already finished executing. This is the essence of a closure.\n \n The inner function maintains a reference to its outer lexical environment, preserving access to the variables in that environment even after the outer function has completed.\n \n Closures are particularly useful for creating private variables and functions. Consider this example:\n \n+:::interactive_editor\n+\n ```js\n function createCounter() {\n     let count = 0;\n@@ -40,14 +46,18 @@ function createCounter() {\n }\n \n let counter = createCounter();\n-console.log(counter()); // Output: 1\n-console.log(counter()); // Output: 2\n+console.log(counter()); // 1\n+console.log(counter()); // 2\n ```\n \n+:::\n+\n In this case, `createCounter` returns a function that increments and returns a `count` variable. The `count` variable is not directly accessible from outside `createCounter`, but the returned function (our closure) has access to it. Each time we call `counter()`, it increments and returns the `count`.\n \n Closures can also capture multiple variables from their outer scope. For example:\n \n+:::interactive_editor\n+\n ```js\n function multiply(x) {\n     return function (y) {\n@@ -56,13 +66,17 @@ function multiply(x) {\n }\n \n let double = multiply(2);\n-console.log(double(5)); // Output: 10\n+console.log(double(5)); // 10\n ```\n \n+:::\n+\n Here the inner function captures the `x` parameter from `multiply`. When we create `double` by calling `multiply(2)` it returns a function that always multiplies its argument by `2`.\n \n One important thing to note about closures is that they capture variables, by reference not by value. This means if the value of a captured variable changes, the closure will see the new value. For example:\n \n+:::interactive_editor\n+\n ```js\n function createIncrementer() {\n     let count = 0;\n@@ -73,10 +87,12 @@ function createIncrementer() {\n }\n \n let increment = createIncrementer();\n-increment(); // Output: 1\n-increment(); // Output: 2\n+increment(); // 1\n+increment(); // 2\n ```\n \n+:::\n+\n Each time we call `increment` its working with the same `count` variable, not a copy of it's initial value. Closures are a powerful tool in JavaScript. as you continue to work with JavaScript you'll find that understanding and using closures effectively can greatly enhance your ability to write clean, efficient and powerful code.\n \n # --questions--"
        }
    ],
    "stats": {
        "total": 30,
        "additions": 23,
        "deletions": 7
    }
}