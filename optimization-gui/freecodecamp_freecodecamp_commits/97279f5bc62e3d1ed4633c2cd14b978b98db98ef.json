{
    "author": "ojeytonwilliams",
    "message": "refactor(client): clean up gatsby-node (#55640)\n\nCo-authored-by: Shaun Hamilton <shauhami020@gmail.com>",
    "sha": "97279f5bc62e3d1ed4633c2cd14b978b98db98ef",
    "files": [
        {
            "sha": "02667be7a4ccbe7ecb3fa281e3a170b4ef2ef943",
            "filename": "client/gatsby-node.js",
            "status": "modified",
            "additions": 122,
            "deletions": 179,
            "changes": 301,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/97279f5bc62e3d1ed4633c2cd14b978b98db98ef/client%2Fgatsby-node.js",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/97279f5bc62e3d1ed4633c2cd14b978b98db98ef/client%2Fgatsby-node.js",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fgatsby-node.js?ref=97279f5bc62e3d1ed4633c2cd14b978b98db98ef",
            "patch": "@@ -32,7 +32,11 @@ exports.onCreateNode = function onCreateNode({ node, actions, getNode }) {\n   }\n };\n \n-exports.createPages = function createPages({ graphql, actions, reporter }) {\n+exports.createPages = async function createPages({\n+  graphql,\n+  actions,\n+  reporter\n+}) {\n   if (!env.algoliaAPIKey || !env.algoliaAppId) {\n     if (process.env.FREECODECAMP_NODE_ENV === 'production') {\n       throw new Error(\n@@ -57,201 +61,140 @@ exports.createPages = function createPages({ graphql, actions, reporter }) {\n \n   const { createPage } = actions;\n \n-  return new Promise((resolve, reject) => {\n-    // Query for all markdown 'nodes' and for the slug we previously created.\n-    resolve(\n-      graphql(`\n-        {\n-          allChallengeNode(\n-            sort: {\n-              fields: [\n-                challenge___superOrder\n-                challenge___order\n-                challenge___challengeOrder\n-              ]\n-            }\n-          ) {\n-            edges {\n-              node {\n-                challenge {\n-                  block\n-                  certification\n-                  challengeType\n-                  dashedName\n-                  disableLoopProtectTests\n-                  disableLoopProtectPreview\n-                  fields {\n-                    slug\n-                    blockHashSlug\n-                  }\n-                  fillInTheBlank {\n-                    sentence\n-                    blanks {\n-                      answer\n-                      feedback\n-                    }\n-                  }\n-                  hasEditableBoundaries\n-                  id\n-                  msTrophyId\n-                  order\n-                  prerequisites {\n-                    id\n-                    title\n-                  }\n-                  required {\n-                    link\n-                    src\n-                  }\n-                  challengeOrder\n-                  challengeFiles {\n-                    name\n-                    ext\n-                    contents\n-                    head\n-                    tail\n-                    history\n-                    fileKey\n-                  }\n-                  solutions {\n-                    contents\n-                    ext\n-                    history\n-                  }\n-                  superBlock\n-                  superOrder\n-                  template\n-                  usesMultifileEditor\n-                  scene {\n-                    setup {\n-                      background\n-                      characters {\n-                        character\n-                        position {\n-                          x\n-                          y\n-                          z\n-                        }\n-                      }\n-                      audio {\n-                        filename\n-                        startTime\n-                        startTimestamp\n-                        finishTimestamp\n-                      }\n-                      alwaysShowDialogue\n-                    }\n-                    commands {\n-                      background\n-                      character\n-                      position {\n-                        x\n-                        y\n-                        z\n-                      }\n-                      startTime\n-                      finishTime\n-                      dialogue {\n-                        text\n-                        align\n-                      }\n-                    }\n-                  }\n-                }\n+  const result = await graphql(`\n+    {\n+      allChallengeNode(\n+        sort: {\n+          fields: [\n+            challenge___superOrder\n+            challenge___order\n+            challenge___challengeOrder\n+          ]\n+        }\n+      ) {\n+        edges {\n+          node {\n+            challenge {\n+              block\n+              certification\n+              challengeType\n+              dashedName\n+              disableLoopProtectTests\n+              disableLoopProtectPreview\n+              fields {\n+                slug\n+                blockHashSlug\n               }\n-            }\n-          }\n-          allMarkdownRemark {\n-            edges {\n-              node {\n-                fields {\n-                  slug\n-                  nodeIdentity\n-                  component\n-                }\n-                frontmatter {\n-                  certification\n-                  block\n-                  superBlock\n-                  title\n-                }\n-                htmlAst\n-                id\n-                excerpt\n+              id\n+              order\n+              required {\n+                link\n+                src\n               }\n+              challengeOrder\n+              challengeFiles {\n+                name\n+                ext\n+                contents\n+                head\n+                tail\n+                history\n+                fileKey\n+              }\n+              solutions {\n+                contents\n+                ext\n+                history\n+              }\n+              superBlock\n+              superOrder\n+              template\n+              usesMultifileEditor\n             }\n           }\n         }\n-      `).then(result => {\n-        if (result.errors) {\n-          console.log(result.errors);\n-          return reject(result.errors);\n+      }\n+      allMarkdownRemark {\n+        edges {\n+          node {\n+            fields {\n+              slug\n+              nodeIdentity\n+              component\n+            }\n+            frontmatter {\n+              certification\n+              block\n+              superBlock\n+              title\n+            }\n+            htmlAst\n+            id\n+            excerpt\n+          }\n         }\n+      }\n+    }\n+  `);\n \n-        // Create challenge pages.\n-        result.data.allChallengeNode.edges.forEach(\n-          createChallengePages(createPage)\n-        );\n+  // Create challenge pages.\n+  result.data.allChallengeNode.edges.forEach(createChallengePages(createPage));\n \n-        const blocks = uniq(\n-          result.data.allChallengeNode.edges.map(\n-            ({\n-              node: {\n-                challenge: { block }\n-              }\n-            }) => block\n-          )\n-        );\n+  const blocks = uniq(\n+    result.data.allChallengeNode.edges.map(\n+      ({\n+        node: {\n+          challenge: { block }\n+        }\n+      }) => block\n+    )\n+  );\n \n-        const superBlocks = uniq(\n-          result.data.allChallengeNode.edges.map(\n-            ({\n-              node: {\n-                challenge: { superBlock }\n-              }\n-            }) => superBlock\n-          )\n-        );\n+  const superBlocks = uniq(\n+    result.data.allChallengeNode.edges.map(\n+      ({\n+        node: {\n+          challenge: { superBlock }\n+        }\n+      }) => superBlock\n+    )\n+  );\n \n-        // Create intro pages\n-        // TODO: Remove allMarkdownRemark (populate from elsewhere)\n-        result.data.allMarkdownRemark.edges.forEach(edge => {\n-          const {\n-            node: { frontmatter, fields }\n-          } = edge;\n+  // Create intro pages\n+  // TODO: Remove allMarkdownRemark (populate from elsewhere)\n+  result.data.allMarkdownRemark.edges.forEach(edge => {\n+    const {\n+      node: { frontmatter, fields }\n+    } = edge;\n \n-          if (!fields) {\n-            return;\n-          }\n-          const { slug, nodeIdentity } = fields;\n-          if (slug.includes('LICENCE')) {\n-            return;\n-          }\n-          try {\n-            if (nodeIdentity === 'blockIntroMarkdown') {\n-              if (!blocks.includes(frontmatter.block)) {\n-                return;\n-              }\n-            } else if (!superBlocks.includes(frontmatter.superBlock)) {\n-              return;\n-            }\n-            const pageBuilder = createByIdentityMap[nodeIdentity](createPage);\n-            pageBuilder(edge);\n-          } catch (e) {\n-            console.log(e);\n-            console.log(`\n+    if (!fields) {\n+      return;\n+    }\n+    const { slug, nodeIdentity } = fields;\n+    if (slug.includes('LICENCE')) {\n+      return;\n+    }\n+    if (nodeIdentity === 'blockIntroMarkdown') {\n+      if (!blocks.includes(frontmatter.block)) {\n+        return;\n+      }\n+    } else if (!superBlocks.includes(frontmatter.superBlock)) {\n+      return;\n+    }\n+\n+    try {\n+      const pageBuilder = createByIdentityMap[nodeIdentity](createPage);\n+      pageBuilder(edge);\n+    } catch (e) {\n+      console.log(e);\n+      console.log(`\n             ident: ${nodeIdentity} does not belong to a function\n \n             ${frontmatter ? JSON.stringify(edge.node) : 'no frontmatter'}\n \n \n             `);\n-          }\n-        });\n-\n-        return null;\n-      })\n-    );\n+    }\n   });\n };\n "
        },
        {
            "sha": "45742c833029c2d5a6c7fa534b2562e4dc62e14f",
            "filename": "client/utils/gatsby/challenge-page-creator.js",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/97279f5bc62e3d1ed4633c2cd14b978b98db98ef/client%2Futils%2Fgatsby%2Fchallenge-page-creator.js",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/97279f5bc62e3d1ed4633c2cd14b978b98db98ef/client%2Futils%2Fgatsby%2Fchallenge-page-creator.js",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Futils%2Fgatsby%2Fchallenge-page-creator.js?ref=97279f5bc62e3d1ed4633c2cd14b978b98db98ef",
            "patch": "@@ -146,6 +146,9 @@ exports.createChallengePages = function (createPage) {\n   };\n };\n \n+// TODO: figure out a cleaner way to get the last challenge in a block. Create\n+// it during the curriculum build process and attach it to the first challenge?\n+// That would remove the need to analyse allChallengeEdges.\n function getProjectPreviewConfig(challenge, allChallengeEdges) {\n   const { block, challengeOrder, challengeType, usesMultifileEditor } =\n     challenge;"
        }
    ],
    "stats": {
        "total": 304,
        "additions": 125,
        "deletions": 179
    }
}