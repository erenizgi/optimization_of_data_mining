{
    "author": "ojeytonwilliams",
    "message": "fix(client): handle pyodide crashing (#55112)",
    "sha": "6fa6808424d42ba18533c9f44cd0bb508494f9e4",
    "files": [
        {
            "sha": "fdaea902be370dce0581de1fc4bb32f73584a69c",
            "filename": "tools/client-plugins/browser-scripts/python-worker.ts",
            "status": "modified",
            "additions": 44,
            "deletions": 31,
            "changes": 75,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6fa6808424d42ba18533c9f44cd0bb508494f9e4/tools%2Fclient-plugins%2Fbrowser-scripts%2Fpython-worker.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6fa6808424d42ba18533c9f44cd0bb508494f9e4/tools%2Fclient-plugins%2Fbrowser-scripts%2Fpython-worker.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/tools%2Fclient-plugins%2Fbrowser-scripts%2Fpython-worker.ts?ref=6fa6808424d42ba18533c9f44cd0bb508494f9e4",
            "patch": "@@ -8,7 +8,7 @@ import * as helpers from '@freecodecamp/curriculum-helpers';\n const ctx: Worker & typeof globalThis = self as unknown as Worker &\n   typeof globalThis;\n \n-let pyodide: PyodideInterface;\n+let pyodide: PyodideInterface | null = null;\n \n interface PythonRunEvent extends MessageEvent {\n   data: {\n@@ -67,9 +67,15 @@ async function setupPyodide() {\n   postMessage({ type: 'stopped' });\n }\n \n+function resetPyodide() {\n+  if (pyodide) pyodide = null;\n+  void setupPyodide();\n+}\n+\n void setupPyodide();\n \n function initRunPython() {\n+  if (!pyodide) throw new Error('pyodide not loaded');\n   // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n   const str = pyodide.globals.get('str') as (x: unknown) => string;\n \n@@ -115,7 +121,7 @@ function initRunPython() {\n   // The runPython helper is a shortcut for running python code with our\n   // custom globals.\n   const runPython = (pyCode: string) =>\n-    pyodide.runPython(pyCode, { globals }) as unknown;\n+    pyodide!.runPython(pyCode, { globals }) as unknown;\n   runPython(`\n   import jscustom\n   from jscustom import print\n@@ -180,36 +186,43 @@ function handleListenRequest() {\n }\n \n function handleRunRequest(data: PythonRunEvent['data']) {\n-  if (ignoreRunMessages) return;\n-  const code = (data.code.contents || '').slice();\n-  // TODO: use reset-terminal for clarity?\n-  postMessage({ type: 'reset' });\n-\n-  const { runPython, getResetId, globals, printException } = initRunPython();\n-  // use pyodide.runPythonAsync if we want top-level await\n   try {\n-    runPython(code);\n-  } catch (e) {\n-    const err = e as PythonError;\n-    // the formatted exception is printed to the terminal\n-    printException();\n-    // but the full error is logged to the console for debugging\n-    console.error(err);\n-    const resetId = getResetId();\n-    // TODO: if a user raises a KeyboardInterrupt with a custom message this\n-    // will be treated as a reset, the client will resend their code and this\n-    // will loop. Can we fix that? Perhaps by using a custom exception?\n-    if (err.type === 'KeyboardInterrupt' && resetId) {\n-      // If the client sends a lot of run messages, it's easy for them to build\n-      // up while the worker is busy. As such, we both ignore any queued run\n-      // messages...\n-      ignoreRunMessages = true;\n-      // ...and tell the client that we're ignoring them.\n-      postMessage({ type: 'stopped', text: getResetId() });\n+    if (ignoreRunMessages) return;\n+    const code = (data.code.contents || '').slice();\n+    // TODO: use reset-terminal for clarity?\n+    postMessage({ type: 'reset' });\n+\n+    const { runPython, getResetId, globals, printException } = initRunPython();\n+    // use pyodide.runPythonAsync if we want top-level await\n+    try {\n+      runPython(code);\n+    } catch (e) {\n+      const err = e as PythonError;\n+      // the formatted exception is printed to the terminal\n+      printException();\n+      // but the full error is logged to the console for debugging\n+      console.error(err);\n+      const resetId = getResetId();\n+      // TODO: if a user raises a KeyboardInterrupt with a custom message this\n+      // will be treated as a reset, the client will resend their code and this\n+      // will loop. Can we fix that? Perhaps by using a custom exception?\n+      if (err.type === 'KeyboardInterrupt' && resetId) {\n+        // If the client sends a lot of run messages, it's easy for them to build\n+        // up while the worker is busy. As such, we both ignore any queued run\n+        // messages...\n+        ignoreRunMessages = true;\n+        // ...and tell the client that we're ignoring them.\n+        postMessage({ type: 'stopped', text: getResetId() });\n+      }\n+    } finally {\n+      getResetId.destroy();\n+      printException.destroy();\n+      globals.destroy();\n     }\n-  } finally {\n-    getResetId.destroy();\n-    printException.destroy();\n-    globals.destroy();\n+  } catch (e) {\n+    // This should only be reach if pyodide crashes, but it's helpful to log\n+    // the error in case it's something else.\n+    console.error(e);\n+    void resetPyodide();\n   }\n }"
        }
    ],
    "stats": {
        "total": 75,
        "additions": 44,
        "deletions": 31
    }
}