{
    "author": "zairahira",
    "message": "chore(curriculum): add JavaScript classes transcript (#58617)\n\nCo-authored-by: Naomi <accounts+github@nhcarrigan.com>\r\nCo-authored-by: Farhan Hasin Chowdhury <shovik.is.here@gmail.com>",
    "sha": "3f4152314256755dbaf9e3dc7b5cd3a45916e4d7",
    "files": [
        {
            "sha": "92be5c61d38412b127b6a0db1d35c0fef324b324",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-how-to-work-with-classes-in-javascript/6733affc29df1304e2c97e88.md",
            "status": "modified",
            "additions": 116,
            "deletions": 0,
            "changes": 116,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/3f4152314256755dbaf9e3dc7b5cd3a45916e4d7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-how-to-work-with-classes-in-javascript%2F6733affc29df1304e2c97e88.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/3f4152314256755dbaf9e3dc7b5cd3a45916e4d7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-how-to-work-with-classes-in-javascript%2F6733affc29df1304e2c97e88.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-how-to-work-with-classes-in-javascript%2F6733affc29df1304e2c97e88.md?ref=3f4152314256755dbaf9e3dc7b5cd3a45916e4d7",
            "patch": "@@ -10,6 +10,122 @@ dashedName: what-are-classes-and-how-do-they-work-in-javascript\n \n Watch the video lecture and answer the questions below.\n \n+# --transcript--\n+\n+What are classes, and how do they work in JavaScript?\n+\n+Let's learn about classes in JavaScript.\n+\n+In modern JavaScript, classes are like blueprints that you can define in code for creating multiple objects of the same kind.\n+\n+For example, if you're modeling an inventory system, you'll need to create multiple objects per type of product.\n+\n+Each individual product will have its own properties and actions but products of the same kind can be created from the same \"blueprint\". That's what classes are used for.\n+\n+Classes can be defined as either a class expression or class declaration.\n+\n+Here is the basic syntax for a class declaration:\n+\n+```js\n+class MyClassName {\n+  // Class Methods\n+  constructor() { ... }\n+  method1() { ... }\n+  method2() { ... }\n+  ...\n+}\n+```\n+\n+You start by writing the `class` keyword followed by the name of the class. When naming classes, you should use the `PascalCase` naming convention instead of `camelCase`.\n+\n+The content inside the curly braces is known as the class body. This is where the constructor and methods will go.\n+\n+The constructor is a special method that gets called automatically when a new object is created from the class. It is typically used to initialize the properties of the object.\n+\n+In this example, you can see a `Dog` class with a constructor.\n+\n+```js\n+class Dog {\n+  constructor(name) {\n+    this.name = name;\n+  }\n+}\n+```\n+\n+The `this` keyword is used here to refer to the current instance of the `Dog` class, allowing you to assign the `name` property to the object being created. You will learn more about the `this` keyword in a future lecture.\n+\n+Below the constructor, you can have what are called methods. Methods are functions defined inside a class that perform actions or operations. They are used to define behaviors that instances of the class can perform.\n+\n+Here is an example of adding a method called `bark` to the `Dog` class.\n+\n+```js\n+class Dog {\n+  constructor(name) {\n+    this.name = name;\n+  }\n+\n+  bark() {\n+    console.log(`${this.name} says woof!`);\n+  }\n+}\n+```\n+\n+When the `bark` method gets called the message will be logged to the console with the actual name that was passed into it. If you create a `Dog` instance with the name `\"Buddy\"`, calling the `bark()` method on that instance will print `\"Buddy says woof!\"` to the console.\n+\n+Once you have your class defined, you can create an instance of the class with the `new` keyword, the name of the class, and its arguments.\n+\n+In this example, we create a new `Dog` instance with the name `Gino` and then we assign it to the variable `dog`.\n+\n+```js\n+const dog = new Dog(\"Gino\");\n+```\n+\n+When you write `new Dog(\"Gino\")` in your code, the new object is created and the constructor is called automatically with the given arguments.\n+\n+You can then access this property using the dot notation, like you can see in the following line of code:\n+\n+```js\n+console.log(dog.name);\n+```\n+\n+This will log the value of the `name` property of this particular instance:\n+\n+```js\n+Gino\n+```\n+\n+You can also call methods. In this example, we are calling the `bark()` method on the `dog` instance.\n+\n+```js\n+dog.bark();\n+```\n+\n+This will log the following message to the console:\n+\n+```js\n+Gino says woof!\n+```\n+\n+As mentioned earlier, you can also define classes as a class expression. This is where the class is anonymous and assigned to a variable.\n+\n+Here is what the earlier example looks like as a class expression:\n+\n+```js\n+const Dog = class {\n+  constructor(name) {\n+    this.name = name;\n+  }\n+\n+  bark() {\n+    console.log(`${this.name} says woof!`);\n+  }\n+};\n+```\n+\n+Most of the time, you'll use class declarations, but understanding class expressions is also valuable, as they can offer more flexibility, especially in dynamic programming situations.\n+\n+By using classes and understanding their basic syntax, you can create reusable code, organize it into logical units, and promote code modularity.\n+\n # --questions--\n \n ## --text--"
        },
        {
            "sha": "39d1048afaa01c6c48c1cdebd447feeeea426fee",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-how-to-work-with-classes-in-javascript/673403ca2bb16658309e3632.md",
            "status": "modified",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/3f4152314256755dbaf9e3dc7b5cd3a45916e4d7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-how-to-work-with-classes-in-javascript%2F673403ca2bb16658309e3632.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/3f4152314256755dbaf9e3dc7b5cd3a45916e4d7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-how-to-work-with-classes-in-javascript%2F673403ca2bb16658309e3632.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-how-to-work-with-classes-in-javascript%2F673403ca2bb16658309e3632.md?ref=3f4152314256755dbaf9e3dc7b5cd3a45916e4d7",
            "patch": "@@ -10,6 +10,89 @@ dashedName: how-does-the-this-keyword-work\n \n Watch the lecture video and answer the questions below.\n \n+# --transcript--\n+\n+How does the `this` keyword work?\n+\n+Let's learn about the `this` keyword. You learned that classes are like blueprints that you can use to create objects.\n+\n+These blueprints need a general way to refer to the specific object that is being created, accessed, or modified within the code. That's exactly what the `this` keyword is used for. It refers to the context where the code is supposed to run. If you use it within a method, the value of `this` will be a reference to the object associated to that method. This way, you can access the properties and methods of the object within the class and reuse the method on different objects.\n+\n+For example, here we have a `Dessert` class. This time, we're defining a `hasPeanuts` property.\n+\n+```js\n+class Dessert {\n+  constructor(hasPeanuts) {\n+    this.hasPeanuts = hasPeanuts;\n+  }\n+}\n+```\n+\n+Notice that we're using the `this` keyword within the constructor. Remember that the constructor is called automatically when a new object of the class is created.\n+\n+The `this` keyword is telling the program that `hasPeanuts` should be a property of the object that is currently being created.\n+\n+The right-hand side of the assignment statement is assigning the value of the `hasPeanuts` parameter to the `hasPeanuts` property of the new object.\n+\n+```js\n+this.hasPeanuts = hasPeanuts;\n+```\n+\n+That's in the context of the constructor but you can also use the `this` keyword within other methods.\n+\n+This is our `Dessert` class with a few changes. Now we have two properties: `name` and `price`.\n+\n+```js\n+class Dessert {\n+  constructor(name, price) {\n+    this.name = name;\n+    this.price = price;\n+  }\n+\n+  showPrice() {\n+    console.log(`The price of ${this.name} is $${this.price}.`);\n+  }\n+}\n+```\n+\n+We also have a new `showPrice` method. In this method, we print a descriptive message to the console with the name and the price of the dessert object.\n+\n+Notice how we're using the `this` keyword to access the properties of the object within the `showPrice` method.\n+\n+What value will the `this` keyword have in the context of this method? It will refer to the object on which the method is being called. In this case, we're creating a new Dessert instance with the name `“Brownie”` and the price `$5.99`:\n+\n+```js\n+const brownie = new Dessert(\"Brownie\", 5.99);\n+```\n+\n+If we call the `.showPrice()` method on this object:\n+\n+```js\n+brownie.showPrice();\n+```\n+\n+Here is the output:\n+\n+```js\n+The price of Brownie is $5.99.\n+```\n+\n+The name and price of the current object (`brownie`) are replaced in the string.\n+\n+This is all thanks to the `this` keyword, which gives you a general way to refer to the current object within the class. This allows you to reuse the method on different objects.\n+\n+This is in the context of object methods but the `this` keyword will also have a value in standalone functions and arrow functions.\n+\n+Its value within a standalone function typically refers to the global object (in non-strict mode) or `undefined` (in strict mode).\n+\n+The value of the `this` keyword is a bit different in arrow functions. Arrow functions inherit the value of `this` from the enclosing scope where they are defined. They don't create their own `this` binding. That means that the value of `this` depends on the context where the arrow function is defined, not where or how the arrow function is called. This makes arrow functions helpful for callbacks or for preserving context.\n+\n+However, because of this, the value of `this` will not refer to the current object in object methods, so this is something that you should keep in mind when working with arrow functions.\n+\n+The same applies to arrow functions defined within other functions. They will inherit the value of `this` from their parent scope.\n+\n+The `this` keyword is a powerful tool for accessing and manipulating objects. Understanding how it works is essential for mastering object-oriented programming in JavaScript.\n+\n # --questions--\n \n ## --text--"
        },
        {
            "sha": "acb35c3efe33150bdcf34aa547a5b3ba91d37134",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-how-to-work-with-classes-in-javascript/673403d2aa52d8586a14a269.md",
            "status": "modified",
            "additions": 148,
            "deletions": 0,
            "changes": 148,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/3f4152314256755dbaf9e3dc7b5cd3a45916e4d7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-how-to-work-with-classes-in-javascript%2F673403d2aa52d8586a14a269.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/3f4152314256755dbaf9e3dc7b5cd3a45916e4d7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-how-to-work-with-classes-in-javascript%2F673403d2aa52d8586a14a269.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-how-to-work-with-classes-in-javascript%2F673403d2aa52d8586a14a269.md?ref=3f4152314256755dbaf9e3dc7b5cd3a45916e4d7",
            "patch": "@@ -10,6 +10,154 @@ dashedName: what-is-class-inheritance-and-how-does-it-work\n \n Watch the lecture video and answer the questions below.\n \n+# --transcript--\n+\n+What is class inheritance, and how does it work?\n+\n+Let's learn about inheritance and how it works in JavaScript.\n+\n+In programming, inheritance allows you to define classes that inherit properties and methods from other classes.\n+\n+For example, a `Car` is a type of `Vehicle`, so you could define a `Vehicle` class with the most general properties and methods that are common to all types of vehicles and then define a `Car` class that inherits the properties and methods of the `Vehicle` class.\n+\n+This \"is a\" relationship is characteristic of inheritance. In this example, `Car` is a more specialized form of `Vehicle`.\n+\n+There are two main concepts that you should know about to start working with inheritance: parent class and child class.\n+\n+A parent class is a class that acts like a blueprint for other classes. It defines properties and methods that are inherited by other classes.\n+\n+A child class is a class that inherits the properties and methods of another class. Child classes can also extend the functionality of their parent classes by adding new properties and methods.\n+\n+In our previous example, `Vehicle` would be the parent class of the `Car` class while the `Car` class would be the child class of `Vehicle`.\n+\n+A parent class can have multiple child classes.\n+\n+In JavaScript, we use the `extends` keyword to implement inheritance. This keyword indicates that a class is the child class of another class.\n+\n+In this example, in which we only have the first lines of the class definitions, you can see that the `Car` class extends the `Vehicle` class, so `Car` inherits from `Vehicle`.\n+\n+```js\n+class Vehicle {\n+  // Implementation of Vehicle...\n+}\n+\n+class Car extends Vehicle {\n+  // Implementation of Car...\n+}\n+```\n+\n+Let's say that the `Vehicle` class has two properties: `brand` and `year`. You can see this in the updated code.\n+\n+`Car` has a method called `honk`. However, notice that the `Car` class doesn't have its own constructor. Let's see if it does inherit the properties.\n+\n+```js\n+class Vehicle {\n+  constructor(brand, year) {\n+    this.brand = brand;\n+    this.year = year;\n+  }\n+}\n+\n+class Car extends Vehicle {\n+  honk() {\n+    console.log(\"Honk! Honk!\");\n+  }\n+}\n+```\n+\n+To define an instance of `Car`, you'll need to pass two arguments: `brand` and `year`. In this case, the brand is `freeCodeCamp Motors` and the year is `2019`.\n+\n+```js\n+let myCar = new Car(\"freeCodeCamp Motors\", 2019);\n+```\n+\n+If you try to access these properties and call the method using dot notation:\n+\n+```js\n+console.log(myCar.brand);\n+console.log(myCar.year);\n+myCar.honk();\n+```\n+\n+Here is the output:\n+\n+```js\n+freeCodeCamp Motors\n+2019\n+Honk! Honk!\n+```\n+\n+Indeed, the output is correct, so these properties and method are defined in the `Car` instance and you just saved yourself a lot of code repetition by inheriting these properties from the `Vehicle` class.\n+\n+In this example, the child class didn't have any additional properties. That's why the class didn't have a constructor, only a method.\n+\n+If you do need to add additional properties, you'll need to define a constructor.\n+\n+Let's see an example.\n+\n+\n+```js\n+class Vehicle {\n+  constructor(brand, year) {\n+    this.brand = brand;\n+    this.year = year;\n+  }\n+}\n+\n+class Car extends Vehicle {\n+  constructor(brand, year, numDoors) {\n+    super(brand, year);\n+    this.numDoors = numDoors;\n+  }\n+}\n+```\n+\n+This time, we'll add a `numDoors` property to the `Car` subclass.\n+\n+You can see that now this class has a constructor in the updated code. Within the constructor, there's a call to `super()`, passing the arguments `brand` and `year`.\n+\n+`super()` invokes the constructor of the superclass, so by using `super(brand, year)` you will essentially be defining the properties of the superclass in the subclass. This is another terminology you can use- superclass is the parent class and the subclass is the child class.\n+\n+Then, `this.numDoors = numDoors` line defines a new property that belongs exclusively to the `Car` class, the number of doors (`numDoors`).\n+\n+This is a way to extend the `Vehicle` class, adding a property that is exclusive to `Car` instances.\n+\n+That's is an example of extensibility, one of the fundamental advantages of inheritance.\n+\n+Now, if you create an instance of the `Car` class, you'll see that it has the three properties: `brand`, `year`, and `numDoors`. You'll also need to pass the necessary arguments when you create the instance.\n+\n+```js\n+let myCar = new Car(\"freeCodeCamp Motors\", 2019, 4);\n+```\n+\n+If you print the values of these properties with `console.log()`:\n+\n+```js\n+console.log(myCar.brand);\n+console.log(myCar.year);\n+console.log(myCar.numDoors);\n+```\n+\n+This is the output:\n+\n+```js\n+freeCodeCamp Motors\n+2019\n+4\n+```\n+\n+The main advantages of inheritance are code reusability, modularity, extensibility, and improved code structure.\n+\n+By implementing a hierarchy, you can reuse code that you already wrote for a parent class in the child class, avoiding repetition.\n+\n+Inheritance also promotes modularity by breaking down complex systems into simpler components in the hierarchy.\n+\n+Also, being able to extend the functionality of the parent class makes it easier to adapt to changing requirements and add new features later on in the development process.\n+\n+Finally, the hierarchical structure can make your code easier to understand and maintain.\n+\n+Those are the fundamentals of inheritance. By understanding how inheritance works, you can design well-structured, maintainable, and extensible object-oriented programs.\n+\n # --questions--\n \n ## --text--"
        },
        {
            "sha": "fd766f62f2ba9f5bc47191f9bb5c17dfbd89cfec",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-how-to-work-with-classes-in-javascript/673403dbf5c9835898632c84.md",
            "status": "modified",
            "additions": 180,
            "deletions": 0,
            "changes": 180,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/3f4152314256755dbaf9e3dc7b5cd3a45916e4d7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-how-to-work-with-classes-in-javascript%2F673403dbf5c9835898632c84.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/3f4152314256755dbaf9e3dc7b5cd3a45916e4d7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-how-to-work-with-classes-in-javascript%2F673403dbf5c9835898632c84.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-how-to-work-with-classes-in-javascript%2F673403dbf5c9835898632c84.md?ref=3f4152314256755dbaf9e3dc7b5cd3a45916e4d7",
            "patch": "@@ -10,6 +10,186 @@ dashedName: what-are-static-properties-and-methods-in-classes\n \n Watch the lecture video and answer the questions below.\n \n+# --transcript--\n+\n+What are static properties and methods in classes?\n+\n+Let's learn about static properties and methods.\n+\n+Static properties and methods belong to the class itself, not to the individual instances of the class. You can access them directly on the class name without creating an instance of the class. They are defined within classes to encapsulate related functionality.\n+\n+You can define a static method by writing the `static` keyword before the name of the method.\n+\n+```js\n+class MyClass {\n+  static staticMethod() { ... }\n+}\n+```\n+\n+Then, you can call the static method on the class directly, using dot notation and passing any necessary arguments:\n+\n+```js\n+MyClass.staticMethod();\n+```\n+\n+Notice that you are able to call the method without creating an instance of the class. That's one of the key characteristics of static methods.\n+\n+Here's an example. Let's say that we are creating a movies application and we want to be able to compare movies based on their rating.\n+\n+We could consider this comparison method as a higher level method that is not specific to any movie:\n+\n+```js\n+if (movieA.rating < movieB.rating) {\n+      console.log(`${movieB.title} has a higher rating.`);\n+    } \n+```\n+\n+It's like a more general method related to the `Movie` class.\n+\n+For readability and maintainability purposes, it would be helpful to define it within the `Movie` class to keep all related methods relatively close to each other.\n+\n+Therefore, this is a perfect candidate for a static method. You can see it here, just below the constructor:\n+\n+```js\n+class Movie {\n+\n+  constructor(title, rating) {\n+    this.title = title;\n+    this.rating = rating;\n+  }\n+\n+  static compareMovies(movieA, movieB) {\n+    if (movieA.rating > movieB.rating) {\n+      console.log(`${movieA.title} has a higher rating.`);\n+    } else if (movieA.rating < movieB.rating) {\n+      console.log(`${movieB.title} has a higher rating.`);\n+    } else {\n+      console.log(\"These movies have the same rating.\");\n+    }\n+  }\n+\n+}\n+```\n+\n+The static method is defined with the `static` keyword and it's called `compareMovies`. It has two parameters: `movieA` and `movieB`. These will be instances of the `Movie` class.\n+\n+We will compare them based on their rating, on a range from `0` to `100`. This logic is implemented with a conditional and it will print an appropriate message based on which movie has a higher rating.\n+\n+Once the method has been defined, you can call it on the class. But first, you need to have the arguments ready and defined in your program.\n+\n+In this case, the method takes two movie instances as arguments, so we define these instances here:\n+\n+```js\n+let movieA = new Movie(\"Movie A\", 80);\n+let movieB = new Movie(\"Movie B\", 45);\n+```\n+\n+You can see that `movieA` has a higher rating than `movieB`. Let's see the output of this method.\n+\n+To call the method, you just need to use dot notation on the class itself.\n+You write the name of the class (`Movie`), followed by a dot, and then the name of the static method (`compareMovies`).\n+\n+Then, you pass the arguments within parentheses. In this case, they are the two movie instances that the method requires.\n+\n+```js\n+Movie.compareMovies(movieA, movieB);\n+```\n+\n+This is the output:\n+\n+```js\n+Movie A has a higher rating.\n+```\n+\n+Static methods are also helpful for implementing \"factory\" methods. A factory method is a method that you define in addition to the constructor to create objects based on specific criteria.\n+\n+Here's an example with a `Pizza` class. The static method `createMargherita` is a factory method that you can call to create a Margherita pizza instance with its type and price already set.\n+\n+```js\n+class Pizza {\n+  constructor(type, price) {\n+    this.type = type;\n+    this.price = price;\n+  }\n+\n+  static createMargherita() {\n+    return new this(\"Margherita\", 6.99);\n+  }\n+}\n+```\n+\n+This also brings up something very important about static methods.\n+\n+The value of the `this` keyword in static methods is the class itself, since the static method belongs to the class.\n+\n+That's why we can use `this` to create a new instance of the `Pizza` class.\n+\n+If you call this method on the `Pizza` class itself and assign the returned instance to a variable, like in this example:\n+\n+```js\n+let myPizza = Pizza.createMargherita();\n+```\n+\n+You can use it wherever you need to in your code. For example, you can print it to the console:\n+\n+```js\n+console.log(myPizza);\n+```\n+\n+This is the output:\n+\n+```js\n+Pizza { type: 'Margherita', price: 6.99 }\n+```\n+\n+You can also use dot notation to call its methods and access its properties, like this:\n+\n+```js\n+console.log(myPizza.type);\n+```\n+\n+This is the output:\n+\n+```js\n+Margherita\n+```\n+\n+In addition to methods, you can also define static properties with the `static` keyword.\n+\n+In this example, we have a static `numberOfPizzasSold` property.\n+\n+```js\n+class Pizza {\n+  static numberOfPizzasSold = 0;\n+\n+  constructor(type) {\n+    this.type = type;\n+    Pizza.numberOfPizzasSold++;\n+  }\n+}\n+```\n+\n+It's static because it doesn't belong to any particular pizza instance, it belongs to the class itself.\n+\n+It has an initial value of `0` and it's updated every time a new instance is created.\n+\n+If you create two pizza instances, the value will be updated twice:\n+\n+```js\n+let pizza1 = new Pizza(\"Margherita\");\n+let pizza2 = new Pizza(\"Neapolitan\");\n+```\n+\n+To access the value of a static property, you just need to use dot notation on the class itself, since the property belongs to the class.\n+\n+```js\n+console.log(Pizza.numberOfPizzasSold);\n+```\n+\n+In this case, the output is `2` because two pizzas were sold.\n+\n+These are the fundamentals of static properties and methods in JavaScript. Understanding static members is essential for creating reusable and efficient classes.\n+\n # --questions--\n \n ## --text--"
        }
    ],
    "stats": {
        "total": 527,
        "additions": 527,
        "deletions": 0
    }
}