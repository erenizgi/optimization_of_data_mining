{
    "author": "majestic-owl448",
    "message": "feat(curriculum): add working with common data structures lectures (#61747)\n\nCo-authored-by: Kolade Chris <65571316+Ksound22@users.noreply.github.com>\nCo-authored-by: Jessica Wilkins <67210629+jdwilkin4@users.noreply.github.com>",
    "sha": "ec815cdd35f6725e3187702f1802b60c2beabad3",
    "files": [
        {
            "sha": "7e7e0f562cba3ed806acdfc9241eb0d85f172739",
            "filename": "curriculum/challenges/_meta/lecture-working-with-common-data-structures/meta.json",
            "status": "modified",
            "additions": 27,
            "deletions": 2,
            "changes": 29,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2F_meta%2Flecture-working-with-common-data-structures%2Fmeta.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2F_meta%2Flecture-working-with-common-data-structures%2Fmeta.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2F_meta%2Flecture-working-with-common-data-structures%2Fmeta.json?ref=ec815cdd35f6725e3187702f1802b60c2beabad3",
            "patch": "@@ -5,6 +5,31 @@\n   \"blockType\": \"lecture\",\n   \"blockLayout\": \"challenge-list\",\n   \"superBlock\": \"full-stack-developer\",\n-  \"challengeOrder\": [{ \"id\": \"68420c314cdf5c6863ca8330\", \"title\": \"Step 1\" }],\n+  \"challengeOrder\": [\n+    {\n+      \"id\": \"68420c314cdf5c6863ca8330\",\n+      \"title\": \"What Is an Algorithm and How Does Big O Notation Work?\"\n+    },\n+    {\n+      \"id\": \"6895d06b5968736797c408e3\",\n+      \"title\": \"What Are Good Problem-Solving Techniques and Ways to Approach Algorithmic Challenges?\"\n+    },\n+    {\n+      \"id\": \"6895d06b5968736797c408e4\",\n+      \"title\": \"How Do Dynamic Arrays Differ From Static Arrays?\"\n+    },\n+    {\n+      \"id\": \"6895d06b5968736797c408e5\",\n+      \"title\": \"How Do Stacks and Queues Work?\"\n+    },\n+    {\n+      \"id\": \"6895d06b5968736797c408e6\",\n+      \"title\": \"How Do Singly Linked Lists Work and How Do They Differ From Doubly Linked List?\"\n+    },\n+    {\n+      \"id\": \"6895d06b5968736797c408e7\",\n+      \"title\": \"How Do Maps, Hash Maps and Sets Work?\"\n+    }\n+  ],\n   \"helpCategory\": \"Python\"\n-}\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "09c30d748fe0ce2426c11c158ddca71b4bf3ca31",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md",
            "status": "modified",
            "additions": 158,
            "deletions": 44,
            "changes": 202,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F68420c314cdf5c6863ca8330.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F68420c314cdf5c6863ca8330.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F68420c314cdf5c6863ca8330.md?ref=ec815cdd35f6725e3187702f1802b60c2beabad3",
            "patch": "@@ -1,135 +1,249 @@\n ---\n id: 68420c314cdf5c6863ca8330\n-# title needs to be updated to correct title when lectures are finalized\n-title: Working with Common Data Structures\n+title: What Is an Algorithm and How Does Big O Notation Work?\n challengeType: 19\n-# dashedName needs to be updated to correct title when lectures are finalized\n-dashedName: lecture-working-with-common-data-structures\n+dashedName: what-is-an-algorithm-and-how-does-big-o-notation-work\n ---\n \n # --description--\n \n-Watch the video or read the transcript and answer the questions below.\n+Every computer program that runs on your device has a specific set of instructions, which are executed in a specific order to complete a task.\n+\n+The task could be sorting a set of numbers, modifying an image, tracking inventory, or even running your favorite video game.\n+\n+This is where algorithms come into play. An **algorithm** is a set of unambiguous instructions for solving a problem or carrying out a task.\n+\n+You can think of algorithms as \"recipes\". When you cook, recipes list all the ingredients that you'll need, and provide step by step instructions on how to prepare a dish.\n+\n+Equivalently, you can think of algorithms as \"recipes\" that tell computers exactly what should be done and how to do it.\n+\n+Algorithms have two key characteristics:\n+\n+* They cannot continue indefinitely. They must finish in a finite number of steps.\n+    \n+* Each step must be precise and unambiguous.\n+    \n+\n+They may have zero, one, or more inputs, and generate one or more outputs.\n+\n+The steps of an algorithm are independent from any programming language.\n+\n+But to actually make them run on a computer, you need to implement them in a programming language, like Python or JavaScript.\n+\n+If an algorithm is correct, the output for any valid input should match the expected output.\n+\n+In addition to being correct, algorithms should also be efficient.\n+\n+Algorithm efficiency can be measured in terms of how long they take to run and how much space they require in memory to complete the task.\n+\n+Knowing an algorithm's efficiency is very important because it gives you an idea of how well it will perform as the input size grows.\n+\n+For example, sorting 15 integers is not the same as sorting 1 million integers.\n+\n+As the process grows in size and complexity, if the algorithm is not efficient enough to handle it, you might end up with a very slow computer program that may even crash the entire system.\n+\n+That's why it's very important to develop and choose the most efficient algorithms possible.\n+\n+This is where Big O notation becomes very important.\n+\n+Big O notation describes the worst-case performance, or growth rate, of an algorithm as the input size increases.\n+\n+The growth rate of an algorithm refers to how the resources it requires increase as the input size grows.\n+\n+Big O notation focuses on the worst-case performance because this case is very important to understand how efficient the algorithm can be, even in the worst case scenario, regardless of the input.\n+\n+Going back to our sorting example, sorting 1 million integers should intuitively take more time and resources than sorting 15 integers.\n+\n+But how much more?\n+\n+This really depends on the algorithm that you choose to sort them.\n+\n+Big O notation will not give you an exact number to describe the algorithm's efficiency, but it will give you an idea of how it scales as the input size grows, based on the number of operations performed by the algorithm.\n+\n+In Big O notation, we usually denote input size with the letter `n`. For example, if the input is a list, `n` would denote the number of elements in that list.\n+\n+Constant factors and lower-order terms are not taken into account to find the time complexity of an algorithm based on the number of operations. That's because as the size of `n` grows, the impact of these smaller terms in the total number of operations performed will become smaller and smaller.\n+\n+The term that will dominate the overall behavior of the algorithm will the term with `n`, the input size.\n+\n+For example, if an algorithm performs `7n + 20` operations to be completed, the impact of the constant `20` on the final result will be smaller and smaller as `n` grows. The term `7n` will tend to dominate and this will define the overall behavior and efficiency of the algorithm.\n+\n+Another example would be an algorithm that takes `20n² + 15n + 7` operations to be completed. The term `20n²` will tend to dominate as `n` grows, so this algorithm would have a quadratic time complexity because the dominant term has `n²`.\n+\n+Quadratic time complexity is one of many different types of time complexities that you can find in the world of algorithms.\n+\n+Let's learn about some of the most common ones.\n+\n+**`O(1)`** is known as \"Constant Time Complexity\". When an algorithm has constant time complexity, it takes the same amount of time to run, regardless of input size.\n+\n+For example, checking if a number is even or odd will always take the same amount of time, regardless of the number itself.\n+\n+```python\n+def check_even_or_odd(number):\n+    if number % 2 == 0:\n+        return 'Even'\n+    else:\n+        return 'Odd'\n+```\n+\n+**`O(log n)`** is known as \"Logarithmic Time Complexity\". This means that the time required by the algorithm increases slowly as the input size grows. This is common in problems in which the size of the problem is repeatedly reduced by a constant fraction.\n+\n+For example, a popular search algorithm called Binary Search has `O(log n)` worst-case time complexity. This is because it eliminates half of the remaining elements in each comparison, which makes it more efficient overall.\n+\n+**`O(n)`** is known as \"Linear Time Complexity\". The running time of algorithms with this time complexity increases proportionally to the input size.\n+\n+For example, a `for` loop that iterates over all the elements of a list will perform more iterations as the number of list elements increases. If the list is doubled in size, the number of operations will approximately double as well.\n+\n+```python\n+for grade in grades:  # grades is a list.\n+    print(grade)\n+```\n+\n+**`O(n log n)`** is known as \"Log-Linear Time Complexity\". This is a common time complexity of efficient sorting algorithms, like Merge Sort and Quick Sort.\n+\n+**`O(n²)`** is known as \"Quadratic Time Complexity\". The running time of these algorithms increases quadratically relative to the input size, which is generally not efficient for real-world problems.\n+\n+Nested loops are a common example of quadratic time complexity. The inner loop will perform `n` iterations for each one of the `n` iterations of the outer loop, resulting in `n` squared iterations.\n+\n+```python\n+for i in range(n):\n+    for j in range(n):\n+        print(\"Hello, World!\")\n+```\n+\n+Other time complexities include \"Exponential Time Complexity\", denoted as `O(2^n)`, and \"Factorial Time Complexity\", denoted as `O(n!)`. Both are inefficient for real-world scenarios.\n+\n+In this graph, you can compare the growth of the mathematical functions that represent the most common time complexities. Think of the x-axis (horizontal) as the input size and the y-axis (vertical) as the running time of the algorithm.\n+\n+You can see that the Quadratic Time Complexity (`O(n²)`) (yellow) grows much faster than the other ones, while the Constant Time Complexity (`O(1)`) (red) stays constant, even if the input gets larger.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-is-an-algorithm-and-how-does-big-o-notation-work-1.png\" alt=\"graph comparing time complexity\">\n+\n+Great. So far, you've learned about Big O notation in terms of time requirements, but this notation can also be applied to the context of space requirements.\n+\n+In this context, it describes how the memory space required by the algorithm grows as the input size grows.\n+\n+Algorithms with \"Constant Space Complexity\" `O(1)` always require a constant amount of memory space, even as the input gets larger.\n+\n+An example would be an algorithm that only creates and stores a few variables in memory.\n+\n+In contrast, the space required by algorithms with \"Linear Space Complexity\" `O(n)` increases proportionally as the input size grows.\n+\n+An example of this would be an algorithm that creates and stores a copy of a list of length `n`.\n+\n+And finally, the space requirements of an algorithm with \"Quadratic Space Complexity\" `O(n²)` increase quadratically as the input size grows.\n+\n+An example of this would be creating a 2D matrix, where the dimensions are determined by the input size, storing all possible pairs.\n+\n+Algorithms are the building-blocks of computer programs, while Big O notation is a powerful framework for analyzing how efficient they are, based on how their time and space requirements in the worst-case scenario scale as the input size grows. Understanding their efficiency is very important for developing software that works efficiently in real-world scenarios.\n \n # --questions--\n \n ## --text--\n \n-Question 1\n+Which of the following best describes an algorithm?\n \n ## --answers--\n \n-Answer 1.1\n+A specific programming language used to write code.\n \n ### --feedback--\n \n-Feedback 1\n+Think about what you follow when you're trying to achieve a specific task.\n \n ---\n \n-Answer 1.2\n-\n-### --feedback--\n-\n-Feedback 1\n+A set of step-by-step instructions designed to solve a problem or perform a task.\n \n ---\n \n-Answer 1.3\n+A type of computer hardware component.\n \n ### --feedback--\n \n-Feedback 1\n+Think about what you follow when you're trying to achieve a specific task.\n \n ---\n \n-Answer 1.4\n+A software application used for developing and playing games.\n \n ### --feedback--\n \n-Feedback 1\n+Think about what you follow when you're trying to achieve a specific task.\n \n ## --video-solution--\n \n-5\n+2\n \n ## --text--\n \n-Question 2\n+What is the primary purpose of Big O notation in the context of algorithms?\n \n ## --answers--\n \n-Answer 2.1\n+To measure the exact time an algorithm takes to run on a specific computer in seconds.\n \n ### --feedback--\n \n-Feedback 2\n+Think about what Big O notation helps you understand an algorithm's performance when the amount of data it processes gets very large.\n \n ---\n \n-Answer 2.2\n+To count the total number of lines of code in an algorithm.\n \n ### --feedback--\n \n-Feedback 2\n+Think about what Big O notation helps you understand an algorithm's performance when the amount of data it processes gets very large.\n \n ---\n \n-Answer 2.3\n-\n-### --feedback--\n-\n-Feedback 2\n+To describe how the resource usage of an algorithm grows as the input size increases.\n \n ---\n \n-Answer 2.4\n+To determine the best-case performance of an algorithm.\n \n ### --feedback--\n \n-Feedback 2\n+Think about what Big O notation helps you understand an algorithm's performance when the amount of data it processes gets very large.\n \n ## --video-solution--\n \n-5\n+3\n \n ## --text--\n \n-Question 3\n+If an algorithm has a time complexity of `O(n)`, what does this mean about its performance?\n \n ## --answers--\n \n-Answer 3.1\n-\n-### --feedback--\n-\n-Feedback 3\n+The algorithm's running time increases proportionally with the input size.\n \n ---\n \n-Answer 3.2\n+The algorithm's running time remains constant regardless of the input size.\n \n ### --feedback--\n \n-Feedback 3\n+Think about what \"linear\" means in terms of a direct relationship or a straight line on a graph.\n \n ---\n \n-Answer 3.3\n+The algorithm's running time grows exponentially with the input size.\n \n ### --feedback--\n \n-Feedback 3\n+Think about what \"linear\" means in terms of a direct relationship or a straight line on a graph.\n \n ---\n \n-Answer 3.4\n+The algorithm's running time decreases as the input size gets larger.\n \n ### --feedback--\n \n-Feedback 3\n+Think about what \"linear\" means in terms of a direct relationship or a straight line on a graph.\n \n ## --video-solution--\n \n-5\n+1\n "
        },
        {
            "sha": "2464157aa78edf3ce5f76084108d9bf71c30b5b9",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-common-data-structures/6895d06b5968736797c408e3.md",
            "status": "added",
            "additions": 237,
            "deletions": 0,
            "changes": 237,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e3.md?ref=ec815cdd35f6725e3187702f1802b60c2beabad3",
            "patch": "@@ -0,0 +1,237 @@\n+---\n+id: 6895d06b5968736797c408e3\n+title: What Are Good Problem-Solving Techniques and Ways to Approach Algorithmic Challenges?\n+challengeType: 19\n+dashedName: what-are-good-problem-solving-techniques-and-ways-to-approach-algorithmic-challenges\n+---\n+\n+# --description--\n+\n+During your learning journey, you should work on developing strong problem-solving skills. These core skills will be essential for tackling real-world problems in your daily work.\n+\n+Solving algorithmic challenges is a great way to practice. It requires an analytical way of thinking, being able to break the problem down into its core components, and finding a solution that generates the right output efficiently.\n+\n+But where do you start?\n+\n+There are several problem-solving techniques that you can use to start approaching these challenges.\n+\n+As an example, we'll reverse a string in Python.\n+\n+This is the challenge:\n+\n+\"Given a string, write an algorithm that returns a new string with the characters in reverse order.\"\n+\n+The first thing that you should do when you come across this type of problem is to read the description multiple times to make sure that you understand what it says. You may miss critical information if you skip this step or read it too fast.\n+\n+Then, once you are familiar with the problem, start breaking it down into its core components.\n+\n+Ask yourself:\n+\n+* \"What is the input?\"\n+    \n+* \"What is the expected output?\"\n+    \n+* \"How can I transform the input into the expected output?\"\n+    \n+\n+In this problem, you can determine that the input is a string because the challenge starts with \"Given a string…\"\n+\n+The output is \"a new string with the characters in reverse order.\"\n+\n+So you need to take the original string and reverse it.\n+\n+This initial analysis might seem a bit repetitive at first, but it's very helpful to make sure that you fully understand the requirements.\n+\n+Then, you should start thinking about how the algorithm that you will develop will transform the input into the output.\n+\n+During this planning and analysis phase, it's common to use pseudocode to map out the necessary steps.\n+\n+**Pseudocode** is a high-level description of the algorithm's logic that is general in nature, and is not based on any specific programming language.\n+\n+Pseudocode is not as formal as actual code, since it's only intended for humans to read. It should be easy to understand at a glance. Its main purpose is to give a clear idea of the sequence of steps that will be performed.\n+\n+Pseudocode is usually a mixture of a common written language, like English, with programming constructs, like `IF`, `ELSE`, `FOR`, and `WHILE`.\n+\n+This is an example of pseudocode that you may write to solve the \"Reverse a String\" challenge.\n+\n+```md\n+GET original_string\n+\n+SET reversed_string = \"\"\n+\n+FOR EACH character IN original_string:\n+  ADD character TO THE BEGINNING OF reversed_string\n+\n+DISPLAY reversed_string\n+```\n+\n+Note how the steps are outlined in a way that is easy to understand. The words and constructs themselves might vary depending on the standards that you are following.\n+\n+If you wanted to, you could implement these steps in multiple programming languages following the same logic, since the pseudocode is independent of the programming language.\n+\n+By this point, you may have already realized that this problem can be solved in many different ways. This isn't the only way to reverse a string.\n+\n+But remember that choosing the right algorithm is important.\n+\n+In a previous lecture, you learned about algorithmic complexity and why it is important to choose algorithms that are efficient in terms of time and space.\n+\n+That's where you will play a vital role as a developer. You will need to choose the most efficient algorithm to solve the challenge.\n+\n+Thinking through different available algorithms is an important problem-solving skill that you should practice. Take a moment to ask yourself if the solution that you are proposing in your pseudocode is the best one or not.\n+\n+For example, there are many different algorithms for sorting elements, but some of them are more efficient than others. Bubble sort, for example, is very inefficient for sorting large lists, while Quick Sort is usually more efficient.\n+\n+For our \"Reverse a String\" challenge, we could use either one of these approaches, assuming that we are planning to implement our algorithm in Python:\n+\n+* Using the extended slice syntax `[::-1]` to get a new reversed string.\n+    \n+* Looping over the characters from left to right and adding the new character to the beginning of the new string.\n+    \n+* Calling the `reversed()` function to get an iterator with all the characters in reverse order, and then the `““.join()` method to concatenate them back into a string.\n+    \n+\n+Which one should you use? That's your choice.\n+\n+Making these decisions based on your knowledge and experience can make a huge difference in the final performance of your application. Consider different approaches, their efficiency, implications, and implementation.\n+\n+Ask yourself:\n+\n+* \"How will I approach this problem?\"\n+    \n+* \"What data structures will I use?\"\n+    \n+* \"Are the data structures that I chose the most efficient ones for the problem at hand?\"\n+    \n+* \"Am I covering all possible edge cases?\"\n+    \n+\n+Edge cases are specific, valid inputs or conditions that occur at the boundaries of what an algorithm should handle.\n+\n+For example, in the \"Reverse a String\" challenge, an edge case would be taking an empty string as input. Are you handling this correctly? If not, consider the best way to handle this edge case and add it to your pseudocode.\n+\n+Then, once you are happy with your plan, you can move on to the implementation phase. At this phase, you will implement your algorithm in a programming language.\n+\n+When structuring your program, you should write modular code that is easy to read and understand.\n+\n+Use the tools of the programming language based on your current knowledge. Some programming languages include built-in solutions for common problems and tasks. Use them if possible.\n+\n+To be consistent, follow the best practices of the programming language of your choice.\n+\n+Test your code as you write it and make sure that you are handling edge cases appropriately.\n+\n+Once your solution is implemented, check if it works correctly for all the examples and potentially refactor your code to make it clearer or simpler.\n+\n+Going back to your solution is very important. Development is not necessarily a linear, step-by-step process. You can always go back to your code and use your critical thinking skills to improve it.\n+\n+These are some common problem-solving techniques that you can follow to approach algorithmic challenges. If you practice consistently, you will gradually develop your problem-solving skills.\n+\n+# --questions--\n+\n+## --text--\n+\n+Which of the following is the most important first step when approaching any problem-solving challenge?\n+\n+## --answers--\n+\n+Understand the problem statement, inputs, and constraints.\n+\n+---\n+\n+Search for existing solutions online.\n+\n+### --feedback--\n+\n+What should you do before you even think about solutions?\n+\n+---\n+\n+Immediately start writing code.\n+\n+### --feedback--\n+\n+What should you do before you even think about solutions?\n+\n+---\n+\n+Guess a solution and then try to make it work.\n+\n+### --feedback--\n+\n+What should you do before you even think about solutions?\n+\n+## --video-solution--\n+\n+1\n+\n+## --text--\n+\n+What is the main purpose of writing pseudocode when solving an algorithmic challenge?\n+\n+## --answers--\n+\n+To write the final, executable version of the code.\n+\n+### --feedback--\n+\n+Think about what pseudocode helps you do before you start writing code.\n+\n+---\n+\n+To test the algorithm's performance and find bugs.\n+\n+### --feedback--\n+\n+Think about what pseudocode helps you do before you start writing code.\n+\n+---\n+\n+To outline the algorithm's logic in a human-readable, language-agnostic way.\n+\n+---\n+\n+To automatically generate the actual code for the solution.\n+\n+### --feedback--\n+\n+Think about what pseudocode helps you do before you start writing code.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+Before writing the final code for an algorithmic challenge, why is it important to consider edge cases?\n+\n+## --answers--\n+\n+Edge cases are always the easiest parts of the problem to solve.\n+\n+### --feedback--\n+\n+Think about what kind of inputs might cause unexpected behavior if they are not specifically considered, even if they are valid.\n+\n+---\n+\n+They help ensure the algorithm works correctly for all valid inputs.\n+\n+---\n+\n+They are only relevant for very simple problems.\n+\n+### --feedback--\n+\n+Think about what kind of inputs might cause unexpected behavior if they are not specifically considered, even if they are valid.\n+\n+---\n+\n+They make the code shorter.\n+\n+### --feedback--\n+\n+Think about what kind of inputs might cause unexpected behavior if they are not specifically considered, even if they are valid.\n+\n+## --video-solution--\n+\n+2\n+"
        },
        {
            "sha": "258d23311a323ac67e37ad1ef09a8e0591c6b4e4",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-common-data-structures/6895d06b5968736797c408e4.md",
            "status": "added",
            "additions": 212,
            "deletions": 0,
            "changes": 212,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e4.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e4.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e4.md?ref=ec815cdd35f6725e3187702f1802b60c2beabad3",
            "patch": "@@ -0,0 +1,212 @@\n+---\n+id: 6895d06b5968736797c408e4\n+title: How Do Dynamic Arrays Differ From Static Arrays?\n+challengeType: 19\n+dashedName: how-do-dynamic-arrays-differ-from-static-arrays\n+---\n+\n+# --description--\n+\n+Arrays are a fundamental data structure in computer science. All arrays store ordered collections of data, but depending on their type, they may work differently behind the scenes.\n+\n+Their underlying behavior can have an important effect in the program's efficiency, so let's learn about dynamic and static arrays and their differences, so you can choose the most efficient one for your program.\n+\n+We'll start with static arrays.\n+\n+**Static arrays** have a fixed size. They store elements in adjacent memory locations.\n+\n+The size of a static array is determined when the array is initialized. Once that specific block of memory is allocated, it's fixed, and cannot be changed while the program is running. This is a key characteristic of static arrays.\n+\n+Storing elements in adjacent memory locations makes the data retrieval process more efficient because the program can store the location of the first element and then use indices to make simple calculations and find the other elements in memory.\n+\n+Thanks to this, accessing the values of a static array takes constant time `O(1)`, which is very efficient.\n+\n+You can use a static array when you know the number of elements that will be stored in advance. It's also helpful when the values will be accessed very frequently, since the access operation is very efficient.\n+\n+However, this data structure cannot grow or shrink, so if the number of elements that will be stored can vary, you should use a dynamic array instead.\n+\n+Trying to increase the size of a static array would involve creating a new array and copying all the elements from the old array to a new one, which is inefficient. In that case, a dynamic array would be much better because it handles this process automatically.\n+\n+Python does not include traditional static arrays as built-in data structures.\n+\n+But other programming languages, like Java, do support them. This is an example of a static array in Java that can store three integers:\n+\n+```java\n+int[] numbers = new int[3]; \n+```\n+\n+Arrays in Python are dynamic, so let's take a look at those.\n+\n+**Dynamic arrays** are more flexible because they can grow or shrink automatically while the program is running.\n+\n+They work through an automatic resizing mechanism that copies the elements into a new array when the original array is full. The process is done efficiently because the size of the new array is chosen in an efficient way that makes these computationally expensive operations less frequent.\n+\n+Accessing the elements of a dynamic array takes constant time `O(1)`, so this operation is very efficient.\n+\n+Inserting an element in the middle of the array takes linear time `O(n)` because the elements after it need to be relocated.\n+\n+Inserting an element at the end of the array takes constant time `O(1)` if there is still space available in the dynamic array, but if the array is full and needs resizing, this operation has a `O(n)` complexity.\n+\n+You should use dynamic arrays when you don't know in advance the number of values that you will need to store in the array. They are also helpful when you will be frequently inserting and deleting elements.\n+\n+Python's built-in `list` data structure works as a dynamic array. You can create a list by writing the elements within square brackets, separated by commas.\n+\n+```python\n+numbers = [3, 4, 5, 6]\n+```\n+\n+You can access an element by writing the name of the variable that holds the list, followed by square brackets, and within the square brackets, the corresponding index.\n+\n+Indices start from 0 for the first element and are incremented by 1 for each subsequent element:\n+\n+```python\n+numbers[0]  # 3\n+numbers[1]  # 4\n+numbers[2]  # 5\n+numbers[3]  # 6\n+```\n+\n+To update a value, you just need to reassign it:\n+\n+```python\n+numbers[2] = 16\n+```\n+\n+You can append elements to the list with the `.append()` method:\n+\n+```python\n+numbers.append(7)\n+```\n+\n+You can insert elements at a specific index with the `.insert()` method, passing the index as the first argument and the element itself as the second argument.\n+\n+```python\n+numbers.insert(3, 15)\n+```\n+\n+You can remove an element at a specific index with the `.pop()` method:\n+\n+```python\n+numbers.pop(2)\n+```\n+\n+If you don't specify the index, `.pop()` will remove the last element.\n+\n+There are other built-in list methods that you can check in the documentation for adding and removing elements quite easily.\n+\n+That's the power of dynamic arrays, or lists in this case.\n+\n+In general, you should use static arrays when you know the number of elements in advance and you need to access them frequently, and use dynamic arrays when the number of elements is unknown or variable over time.\n+\n+You should always consider the tradeoff between the simplicity of static arrays and the flexibility of dynamic arrays. They are both helpful for specific use cases and scenarios. Being able to choose the best one for a given problem is part of the problem-solving skills that you will gradually develop with practice.\n+\n+# --questions--\n+\n+## --text--\n+\n+What is the main difference in size between a static array and a dynamic array?\n+\n+## --answers--\n+\n+Static arrays can change their size after being created, while dynamic arrays cannot.\n+\n+### --feedback--\n+\n+Think about how much space each type of array will require.\n+\n+---\n+\n+Static arrays have a fixed size, while dynamic arrays can change size during runtime.\n+\n+---\n+\n+There is no practical difference in how their sizes are handled.\n+\n+### --feedback--\n+\n+Think about how much space each type of array will require.\n+\n+---\n+\n+Dynamic arrays are always larger than static arrays.\n+\n+### --feedback--\n+\n+Think about how much space each type of array will require.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+If you need to add more elements to a static array that is already full, what is the typical process involved?\n+\n+## --answers--\n+\n+The static array automatically expands its memory to fit the new elements.\n+\n+### --feedback--\n+\n+Think about what is necessary when a container with a fixed capacity runs out of space.\n+\n+---\n+\n+You must create a new, larger array and copy all existing elements to it.\n+\n+---\n+\n+The array automatically converts itself into a dynamic array.\n+\n+### --feedback--\n+\n+Think about what is necessary when a container with a fixed capacity runs out of space.\n+\n+---\n+\n+New elements are simply discarded if the array is full.\n+\n+### --feedback--\n+\n+Think about what is necessary when a container with a fixed capacity runs out of space.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+In which scenario would a static array typically be a more suitable choice than a dynamic array?\n+\n+## --answers--\n+\n+When the exact number of elements is unknown and changes frequently.\n+\n+### --feedback--\n+\n+Think about the main advantage of a static array related to its size and resource usage.\n+\n+---\n+\n+When you need to store a very large dataset that might grow indefinitely.\n+\n+### --feedback--\n+\n+Think about the main advantage of a static array related to its size and resource usage.\n+\n+---\n+\n+When you require frequent insertions and deletions at arbitrary positions within the collection.\n+\n+### --feedback--\n+\n+Think about the main advantage of a static array related to its size and resource usage.\n+\n+---\n+\n+When the data size is fixed and known at the time the program is written.\n+\n+## --video-solution--\n+\n+4\n+"
        },
        {
            "sha": "e6b3312b9adb2ddb43cd101d2dda27ea78a9e158",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-common-data-structures/6895d06b5968736797c408e5.md",
            "status": "added",
            "additions": 195,
            "deletions": 0,
            "changes": 195,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e5.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e5.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e5.md?ref=ec815cdd35f6725e3187702f1802b60c2beabad3",
            "patch": "@@ -0,0 +1,195 @@\n+---\n+id: 6895d06b5968736797c408e5\n+title: How Do Stacks and Queues Work?\n+challengeType: 19\n+dashedName: how-do-stacks-and-queues-work\n+---\n+\n+# --description--\n+\n+Stacks and queues are data structures commonly used in computer science.\n+\n+They're linear data structures that follow specific rules for adding and removing elements.\n+\n+## Stacks\n+\n+Let's start with **Stacks**.\n+\n+A **stack** is a Last-in, First-out (LIFO) data structure.\n+\n+This means that the last element that was added to the stack is the first one to be removed.\n+\n+Stacks have two ends, which we know as top and bottom.\n+\n+Elements are added and removed from the top of the stack.\n+\n+You can think of a stack as a pile of dishes, where you can only place dishes at the top of the pile and take dishes from the top of the pile.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-1.png\" alt=\"stack data structure visualization\">\n+\n+These operations of adding and removing elements have special names in this context.\n+\n+Adding an element to a stack is known as a \"push\" operation. We say that we \"push\" an element onto the stack when we add it to the top of the stack.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-2.png\" alt=\"stack push operation visualization\">\n+\n+Removing an element from a stack is known as a \"pop\" operation. We say that we \"pop\" an element from the stack when we remove it from the top of the stack.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-3.png\" alt=\"stack pop operation visualization\">\n+\n+You can see that we don't really perform any operations at the bottom of the stack but we keep it there as a reference.\n+\n+The time complexity of the push and pop operations is typically `O(1)`, a constant time complexity.\n+\n+When you push an element onto the stack, the element is simply added to the top.\n+\n+When you pop an element form the stack, the element at the top is removed.\n+\n+Therefore, the time it takes to perform these operations remains constant regardless of the size of the stack.\n+\n+The space complexity of the push and pop operations is usually constant `O(1)`. This means that the amount of memory required to perform these operations remains constant regardless of the size of the stack.\n+\n+## Queues\n+\n+Now that you know more about stacks, let's learn about **Queues**.\n+\n+A queue is a First-in First-out (FIFO) linear data structure. This means that the first element added to the queue is the first one to be removed.\n+\n+Queues have two ends: front and back.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-4.webp\" alt=\"queue data structure visualization\">\n+\n+Elements are added to the back of the queue and they are removed from the front of the queue.\n+\n+You can think of a queue as a line of people waiting to pay for their groceries at the supermarket. The first person in line is the first one to go to the cash register while new people join the line at the end.\n+\n+The operations of adding and removing elements have special names in the context of a queue.\n+\n+Adding an element to the back of a queue is known as an \"enqueue\" operation.\n+\n+In an enqueue operation, the new element is added to the end of the queue, becoming the end of the line.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-5.png\" alt=\"queue enqueue operation visualization\">\n+\n+Removing an element from the front of the queue is known as a \"dequeue\" operation.  \n+  \n+In the dequeue operation, the element at the front of the queue is removed, and the next element in line becomes the new front.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-6.png\" alt=\"queue dequeue operation visualization\">\n+\n+The time complexity of the enqueue and dequeue operations is `O(1)`, constant time. The time it takes to perform these operations remains constant, regardless of the size of the queue.\n+\n+The space complexity of the enqueue and dequeue operations is usually constant `O(1)`. This means that the amount of memory required to perform these operations remains constant regardless of the size of the queue.\n+\n+Stacks and queues are data structures used in computer science for organizing and managing elements. Understanding them is essential for building efficient algorithms in various programming applications.\n+\n+# --questions--\n+\n+## --text--\n+\n+What is the primary difference between a stack and a queue?\n+\n+## --answers--\n+\n+Stacks are LIFO, while queues are FIFO.\n+\n+---\n+\n+Stacks are FIFO, while queues are LIFO.\n+\n+### --feedback--\n+\n+Think about the order in which elements are added and removed from each data structure.\n+\n+---\n+\n+Stacks are used for storing data, while queues are used for processing data.\n+\n+### --feedback--\n+\n+Think about the order in which elements are added and removed from each data structure.\n+\n+---\n+\n+There is no difference between stacks and queues.\n+\n+### --feedback--\n+\n+Think about the order in which elements are added and removed from each data structure.\n+\n+## --video-solution--\n+\n+1\n+\n+## --text--\n+\n+Which operation is used to add an element to a stack?\n+\n+## --answers--\n+\n+`push`\n+\n+---\n+\n+`pop`\n+\n+### --feedback--\n+\n+Think about the analogy of a stack of plates.\n+\n+---\n+\n+`enqueue`\n+\n+### --feedback--\n+\n+Think about the analogy of a stack of plates.\n+\n+---\n+\n+`dequeue`\n+\n+### --feedback--\n+\n+Think about the analogy of a stack of plates.\n+\n+## --video-solution--\n+\n+1\n+\n+## --text--\n+\n+Which operation is used to remove an element from a queue?\n+\n+## --answers--\n+\n+`push`\n+\n+### --feedback--\n+\n+Think about the analogy of a line of people waiting.\n+\n+---\n+\n+`pop`\n+\n+### --feedback--\n+\n+Think about the analogy of a line of people waiting.\n+\n+---\n+\n+`enqueue`\n+\n+### --feedback--\n+\n+Think about the analogy of a line of people waiting.\n+\n+---\n+\n+`dequeue`\n+\n+## --video-solution--\n+\n+4\n+"
        },
        {
            "sha": "e78ec62c3c9d1f0c4da102a58fd81a6a8e60661a",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-common-data-structures/6895d06b5968736797c408e6.md",
            "status": "added",
            "additions": 231,
            "deletions": 0,
            "changes": 231,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e6.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e6.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e6.md?ref=ec815cdd35f6725e3187702f1802b60c2beabad3",
            "patch": "@@ -0,0 +1,231 @@\n+---\n+id: 6895d06b5968736797c408e6\n+title: How Do Singly Linked Lists Work and How Do They Differ From Doubly Linked List?\n+challengeType: 19\n+dashedName: how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list\n+---\n+\n+# --description--\n+\n+A **linked list** is a linear data structure in which each node is connected to the next node in the sequence.\n+\n+These connections create a data structure that looks like a chain of nodes, where each node stores data and a reference to the next node in the linked list.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-1.png\" alt=\"linked list basic structure visualization\">\n+\n+We use these references to go from the first node to the next node and so on.\n+\n+Linked lists are commonly used for implementing other data structures, such as stacks, queues, and deques. They can also be used to implement essential graph algorithms, such as depth-first search and breadth-first search.\n+\n+## Singly Linked Lists\n+\n+A **singly linked list** is a type of linked list in which each node is connected to the next node in the sequence.\n+\n+Each node is connected to the next one by storing a reference to it.\n+\n+This single reference per node allows you to traverse the linked list in one direction, from start to end.\n+\n+The search can only move forward, not backwards.\n+\n+In this example, you would start at the head node, node A.\n+\n+The **head** node is the first node in the linked list.\n+\n+In a singly linked list, the head node is usually the only node that is directly accessible. This is where the search process will start when you're trying to find a specific node.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-2.webp\" alt=\"singly linked list traversal visualization\">\n+\n+The process will start at node A, then it will continue to node B, then node C, and finally node D, the **tail** node. It may also stop before that if you implement specific logic in your code.\n+\n+The **tail** node is the last node. It's used to determine when the process has reached the end of the linked list.\n+\n+### **Inserting Nodes**\n+\n+One of the great things about linked lists is that they do not have a fixed size. They can be expanded or shrunk as needed by simply updating the connections between the nodes.\n+\n+You can **insert** a node at the start, middle, and end of a linked list.\n+\n+Linked lists don't necessarily need to store the nodes in a specific order. The order will be determined by the connections between the nodes.\n+\n+However, if you do need to keep the nodes in a specific order for your particular use case, you can do so by implementing that logic in your code and the criteria you implement will determine if the node is inserted at the start, middle, or end.\n+\n+To insert a node at the start of the linked list, you just need to create a connection between the new node and the node that used to be the head node and make the new node the head node instead.\n+\n+This is an example, where we insert node E at the start and make this new node the head node of the linked list.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-3.png\" alt=\"singly linked list insert at beginning visualization\">\n+\n+Inserting a node at the beginning of the linked list has a constant time complexity `O(1)` because it only requires updating the reference to the head node and the connection between the new head node and the next node in the sequence.\n+\n+In this example, we are inserting node E at the start of the linked list. This will work correctly. But if we wanted to keep the linked list sorted in alphabetical order, node E would have to be inserted at the end of the linked list instead.\n+\n+To insert a node at the end of the linked list, first you need to reach the end and then add a connection to the new node to make it the new tail node.\n+\n+This operation has linear time complexity, `O(n)`, where n is the number of nodes stored in the linked list, because first you need to reach the end of the linked list to make the insertion and this would require going from one node to the next and so on until the end is reached.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-4.png\" alt=\"singly linked list insert at end visualization\">\n+\n+If the node has to be inserted somewhere in the middle of the linked list, the connections between the nodes will have to be updated too. The previous node in the sequence should be connected to the new node and the new node should be connected to the next node, like in the following diagram.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-5.webp\" alt=\"singly linked list insert in middle visualization\">\n+\n+The insertion operation has a constant space complexity `O(1)`, since inserting a new node only requires creating it and updating the connections between the nodes. This operation doesn't depend on the size of the linked list itself.\n+\n+### **Removing Nodes**\n+\n+Just as you can insert nodes, you can also remove them from the start, middle, and end of the linked list.\n+\n+To remove a node from the start, you need to update the reference to the head node, which should be the next node in the sequence.\n+\n+This operation has a constant time complexity `O(1)`, because it only requires updating the linked list's reference to the head node.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-6.png\" alt=\"singly linked list remove from beginning visualization\">\n+\n+To remove a node from the middle of the linked list, you need to update the reference of the previous node to connect it to the next node in the sequence, forming a sort of \"bridge\" between them, as you can see in this diagram.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-7.png\" alt=\"singly linked list remove from middle visualization\">\n+\n+That will remove the node that you want to remove, in this case node B, from the sequence of connections, so it won't be reached the next time you traverse it.\n+\n+To remove a node from the end of the linked list, you need to remove the connection of the previous node and make this node the new tail node. Now the linked list will end at the new tail node.\n+\n+This operation has a linear time complexity `O(n)`, because first you have to reach the end of the linked list.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-8.png\" alt=\"singly linked list remove from end visualization\">\n+\n+The deletion operation has a constant space complexity `O(1)`, because no additional memory is required to delete a node.\n+\n+## Doubly Linked Lists\n+\n+Now that you know more about singly linked lists, let's talk about doubly linked lists.\n+\n+In a **doubly linked list**, each node stores two references: a reference to the next node and a reference to the previous node in the sequence.\n+\n+This means that doubly linked lists can be traversed in both directions.\n+\n+<img src=\"https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-9.webp\" alt=\"doubly linked list structure visualization\">\n+\n+In this type of linked list, it's also common to keep a reference to the tail node in the linked list itself to start the traversal from the end if necessary.\n+\n+That sounds great, right? They're more flexible than singly linked lists.\n+\n+However, doubly linked lists do require more memory than singly linked lists because each node stores **two** references instead of one.\n+\n+This is something that you should keep in mind when you're choosing the right data structure for your project.\n+\n+There **is** a tradeoff.\n+\n+The insertion and deletion operations work exactly the same. The only difference is that now you will need to update two references per node and keep track of the reference to the tail node to insert elements at the end of the doubly linked list very efficiently and start the traversal process from the back, if necessary.\n+\n+Singly and doubly linked lists are essential data structures in computer science used for storing and manipulating elements in a sequential order. Understanding their differences is essential for choosing the right one for your specific application.\n+\n+# --questions--\n+\n+## --text--\n+\n+What is a linked list?\n+\n+## --answers--\n+\n+A data structure that stores elements in a contiguous block of memory.\n+\n+### --feedback--\n+\n+Think about how nodes are connected in a linked list.\n+\n+---\n+\n+A data structure where nodes are connected using references.\n+\n+---\n+\n+A data structure that is always sorted.\n+\n+### --feedback--\n+\n+Think about how nodes are connected in a linked list.\n+\n+---\n+\n+A data structure that has a fixed size.\n+\n+### --feedback--\n+\n+Think about how nodes are connected in a linked list.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+What is the difference between a singly linked list and a doubly linked list?\n+\n+## --answers--\n+\n+Singly linked lists have a head and tail node, while doubly linked lists do not.\n+\n+### --feedback--\n+\n+Think about the references contained in each type of linked list.\n+\n+---\n+\n+Singly linked lists can only be traversed in one direction, while doubly linked lists can be traversed in both directions.\n+\n+---\n+\n+Singly linked lists are more efficient to insert elements at the end, while doubly linked lists are more efficient to insert elements at the beginning.\n+\n+### --feedback--\n+\n+Think about the references contained in each type of linked list.\n+\n+---\n+\n+Singly linked lists require more memory than doubly linked lists.\n+\n+### --feedback--\n+\n+Think about the references contained in each type of linked list.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+What is the time complexity of inserting a node at the beginning of a singly linked list?\n+\n+## --answers--\n+\n+`O(1)`\n+\n+---\n+\n+`O(n)`\n+\n+### --feedback--\n+\n+Think about the number of operations required to insert a node at the beginning of the linked list.\n+\n+---\n+\n+`O(n^2)`\n+\n+### --feedback--\n+\n+Think about the number of operations required to insert a node at the beginning of the linked list.\n+\n+---\n+\n+`O(log n)`\n+\n+### --feedback--\n+\n+Think about the number of operations required to insert a node at the beginning of the linked list.\n+\n+## --video-solution--\n+\n+1\n+"
        },
        {
            "sha": "c60c8450300ee75f72e55f5ba64fd4c48ea96aa1",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md",
            "status": "added",
            "additions": 317,
            "deletions": 0,
            "changes": 317,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e7.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/ec815cdd35f6725e3187702f1802b60c2beabad3/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e7.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-common-data-structures%2F6895d06b5968736797c408e7.md?ref=ec815cdd35f6725e3187702f1802b60c2beabad3",
            "patch": "@@ -0,0 +1,317 @@\n+---\n+id: 6895d06b5968736797c408e7\n+title: How Do Maps, Hash Maps and Sets Work?\n+challengeType: 19\n+dashedName: how-do-maps-hash-maps-and-sets-work\n+---\n+\n+# --description--\n+\n+In this lecture, we'll go over maps, hash maps, and sets. But before we do that, let's define Abstract Data Types.\n+\n+An Abstract Data Type (ADT) is a conceptual representation of a data type, including what operations can be performed on the data and the properties of that data.\n+\n+Abstract Data Types are like blueprints that describe **what** operations can be performed, not **how** they are performed. They separate the interface from the actual implementation of the operations.\n+\n+A **map** is an ADT that manages collections of key-value pairs and their operations in a very specific and efficient way.\n+\n+In a map, every value is associated with a specific key.\n+\n+One of the key characteristics of maps is that every key must be unique. This uniqueness allows for direct lookups, which makes the process of retrieving information much more efficient.\n+\n+Only keys must be unique, values can be repeated.\n+\n+The map Abstract Data Type also defines important operations, such as inserting key-value pairs, getting the value associated with a key, updating the value associated with a key, removing a key-value pair, and checking if a key exists in the map.\n+\n+It doesn't actually specify how these operations should be performed, it just lists them as part of the available operations of the data type.\n+\n+A **hash map**, also known as a hash table, is a concrete implementation of the map Abstract Data Type.\n+\n+Hash maps use a technique called \"hashing\" to perform common operations very efficiently.\n+\n+Hashing essentially works by generating a hash value for each element using a hash function.\n+\n+The hash value is generated based on the key of the key-value pair and it's used to calculate an index in an underlying array, the actual data structure where the key-value pairs are stored.\n+\n+But you might be asking yourself: What happens if two keys result in the same index?\n+\n+Hash maps solve these collisions with clever strategies.\n+\n+One option is to use the \"chaining\" strategy, where each array index points to a linked list (another data structure), where all the elements with the same index are stored.\n+\n+Another strategy is to use \"open addressing\", which involves searching for the next available index in the array based on a predefined search sequence.\n+\n+The average case time complexity of hash maps is \"Constant Time\" `O(1)` for inserting, retrieving, and deleting key-value pairs.\n+\n+The worst case time complexity of these operations is Linear Time `O(n)`, which occurs when there are many hash collisions, so the collision resolution strategy has to be applied multiple times.\n+\n+The space complexity of inserting into a hash map is constant `O(1)` on the average case, a constant amount of memory to store the new pair. However, in the worst case, it can have linear space complexity `O(n)` due to a resizing operation of the underlying array. In general, removing an element has a constant space complexity `O(1)`.\n+\n+This turns the hash table into something similar to a linear data structure where `n` elements have to be scanned to find the target key. However, this is relatively rare if the hash map is implemented properly.\n+\n+Python's **dictionaries** are implemented as hash maps behind the scenes.\n+\n+To create a Python dictionary, you just need to write the key-value pairs within curly brackets and separate them with a comma. Each key should be separated from its corresponding value with a colon.\n+\n+```python\n+my_dictionary = {\n+  \"A\": 1,\n+  \"B\": 2, \n+  \"C\": 3\n+}\n+```\n+\n+In this code, `\"A\"` is the key and `1` is the value:\n+\n+```python\n+\"A\": 1\n+```\n+\n+Alternatively, you can use `dict()`:\n+\n+```python\n+my_dictionary = dict(A=\"1\", B=\"2\", C=\"3\")\n+```\n+\n+You can get the value through its corresponding key:\n+\n+```python\n+my_dictionary[\"A\"]  # 1\n+```\n+\n+You can also update the value associated with a key:\n+\n+```python\n+my_dictionary[\"A\"] = 4\n+```\n+\n+And you can remove a key-value pair:\n+\n+```python\n+del my_dictionary[\"A\"]  \n+```\n+\n+You can also check if a key is in the dictionary (or not):\n+\n+```python\n+\"C\" in my_dictionary\n+```\n+\n+And you can call these methods to get the keys, values, and items of the dictionary, respectively.\n+\n+```python\n+my_dictionary.keys()\n+my_dictionary.values()\n+my_dictionary.items()\n+```\n+\n+Great. Now that you know more about maps and hash maps, let's talk about sets.\n+\n+**Sets** are unordered collections of unique elements.\n+\n+Let's break this concept down into its key components:\n+\n+* Sets are unordered. The elements of a set are not stored in any specific order, so you cannot access them through indices.\n+    \n+* Sets only contain unique elements. If you try to add the same value twice, only one copy of the value will be kept.\n+    \n+\n+They are analogous to sets in mathematics and they implement the same set operations, like intersection, union, and difference.\n+\n+One of the main advantages of sets is that they guarantee that the elements will be unique (no duplicates). This is why they are often used to remove duplicates from lists and other data structures.\n+\n+They are also dynamic. They can adjust to the number of elements that are currently stored. This makes them quite powerful.\n+\n+The average case time complexity of adding, removing, getting the length of the set, and checking if an element is in the set is \"Constant Time\" `O(1)`, which is very efficient.\n+\n+Since sets are implemented as hash tables, the worst case time complexity of adding, removing, and checking membership is \"Linear Time\" `O(n)`. This may occur when there are multiple hash collisions, transforming the hash table into something similar to a linear data structure, where `n` scans are required to find the key.\n+\n+In terms of space complexity, in the average case, inserting an element would have constant complexity `O(1)`, with a new unique element requiring a constant amount of memory. However, in the worst case, there could be a resizing operation of the underlying array, which could take linear space complexity `O(n)`. In general, removing an element would take constant space complexity `O(1)`.\n+\n+Python has a built-in `set` data structure that you use to work with sets in your programs.\n+\n+Behind the scenes, Python sets are implemented using a hash table where only the keys are stored, without any associated values.\n+\n+Sets can only store objects of immutable data types because their hash values always remain the same. In contrast, the hash values of mutable objects can change when they are mutated. That's why they cannot be part of sets. If the hash value of an object stored in the set changes, the program would not be able to find it anymore.\n+\n+To define a set in Python, you just need to surround the elements with curly brackets and separate them with commas:\n+\n+```python\n+numbers = {1, 2, 3, 4}\n+```\n+\n+To create an empty set, you can call `set()`:\n+\n+```python\n+numbers = set()\n+```\n+\n+Note that if you use empty curly brackets, this will automatically create a Python dictionary, not a set, so you must call the `set()` function to create an empty set.\n+\n+You can add an element to a set with the `.add()` method:\n+\n+```python\n+numbers.add(5)\n+```\n+\n+You can also remove elements from the set with the `.remove()` method:\n+\n+```python\n+numbers.remove(5)\n+```\n+\n+This will throw a `KeyError` if the element is not found. But if you don't want to throw an error in that case, you can use the `.discard()` method instead.\n+\n+The `.pop()` method returns an arbitrary element from the set, while the `.clear()` method removes all elements from the set.\n+\n+You can test if an element is in a set with the `in` operator:\n+\n+```python\n+5 in numbers\n+```\n+\n+Python also support set operations, including union, difference, symmetric difference, and intersection, which you can perform with these methods:\n+\n+```python\n+set_a = {1, 2, 3, 4}\n+set_b = {2, 3, 4, 5, 6}\n+\n+set_a.union(set_b)\n+set_a.intersection(set_b)\n+set_a.symmetric_difference(set_b)\n+set_a.difference(set_b)\n+```\n+\n+Or with their equivalent operators:\n+\n+```python\n+set_a | set_b\n+set_a & set_b\n+set_a ^ set_b\n+set_a - set_b \n+```\n+\n+The average case time complexity for adding, removing, and testing membership is \"Constant Time\" `O(1)`.\n+\n+The worst case time complexity for these operations is \"Linear Time\" `O(n)` because of the hash map's worst case collision scenario.\n+\n+You can also check if a set is a subset or superset of another one:\n+\n+```python\n+set_a.issubset(set_b)\n+set_a.issuperset(set_b)\n+```\n+\n+In general, you should use sets when you need to store a collection of unique items and frequently check for the presence of an item.\n+\n+Maps, hash maps, and sets are powerful data structures designed for efficient data organization and retrieval. Each one of them has its own unique characteristics and use cases. As a developer, you will need to choose the best one for your project.\n+\n+# --questions--\n+\n+## --text--\n+\n+What is the fundamental difference in the type of data stored by a hash map (or map) compared to a set?\n+\n+## --answers--\n+\n+Hash maps store ordered collections, while Sets store unordered collections.\n+\n+### --feedback--\n+\n+Think about what each data structure is primarily designed to store.\n+\n+---\n+\n+Hash maps store unique key-value pairs, while Sets store unique individual elements.\n+\n+---\n+\n+Hash maps cannot store duplicate values, while Sets can.\n+\n+### --feedback--\n+\n+Think about what each data structure is primarily designed to store.\n+\n+---\n+\n+Sets are used for numerical data, while hash maps are for textual data.\n+\n+### --feedback--\n+\n+Think about what each data structure is primarily designed to store.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+What is the main mechanism that allows hash maps and Sets to achieve average-case `O(1)` (constant time) performance for operations like insertion and lookup?\n+\n+## --answers--\n+\n+They keep all elements sorted, enabling fast binary search.\n+\n+### --feedback--\n+\n+Think about the special function that converts an element into an index.\n+\n+---\n+\n+They store elements in a linked list, allowing quick traversal.\n+\n+### --feedback--\n+\n+Think about the special function that converts an element into an index.\n+\n+---\n+\n+They use a hash function to compute a direct memory location for elements.\n+\n+---\n+\n+They always store a very small number of elements, making all operations fast.\n+\n+### --feedback--\n+\n+Think about the special function that converts an element into an index.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+In the context of hash maps and sets, what is a \"hash collision\"?\n+\n+## --answers--\n+\n+When an element is successfully found after a search.\n+\n+### --feedback--\n+\n+Think about the result when the hash function maps different inputs to the same output.\n+\n+---\n+\n+When an element is inserted at the very beginning of the collection.\n+\n+### --feedback--\n+\n+Think about the result when the hash function maps different inputs to the same output.\n+\n+---\n+\n+When the hash map runs out of memory and needs to resize.\n+\n+### --feedback--\n+\n+Think about the result when the hash function maps different inputs to the same output.\n+\n+---\n+\n+When two different keys or elements produce the same hash value.\n+\n+## --video-solution--\n+\n+4"
        }
    ],
    "stats": {
        "total": 1423,
        "additions": 1377,
        "deletions": 46
    }
}