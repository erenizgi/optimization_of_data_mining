{
    "author": "Dario-DC",
    "message": "feat(curriculum): add bisection method lab (#61253)\n\nCo-authored-by: Hillary Nyakundi <63947040+larymak@users.noreply.github.com>",
    "sha": "9cee50eb38ace7690fef8a738c40a30c542c52fd",
    "files": [
        {
            "sha": "86e9a618aa535b69569b9e5ce63ca8432c94d52a",
            "filename": "client/i18n/locales/english/intro.json",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9cee50eb38ace7690fef8a738c40a30c542c52fd/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9cee50eb38ace7690fef8a738c40a30c542c52fd/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json?ref=9cee50eb38ace7690fef8a738c40a30c542c52fd",
            "patch": "@@ -4420,8 +4420,10 @@\n         ]\n       },\n       \"lab-bisection-method\": {\n-        \"title\": \"Build a Bisection Method\",\n-        \"intro\": [\"\"]\n+        \"title\": \"Implement the Bisection Method\",\n+        \"intro\": [\n+          \"In this lab, you will implement the bisection method to find the square root of a number.\"\n+        ]\n       },\n       \"workshop-merge-sort\": {\n         \"title\": \"Implement the Merge Sort Algorithm\","
        },
        {
            "sha": "54a1137bcbdf5d97238a2cebbe38a491730bcab9",
            "filename": "client/src/pages/learn/full-stack-developer/lab-bisection-method/index.md",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9cee50eb38ace7690fef8a738c40a30c542c52fd/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flab-bisection-method%2Findex.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9cee50eb38ace7690fef8a738c40a30c542c52fd/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flab-bisection-method%2Findex.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flab-bisection-method%2Findex.md?ref=9cee50eb38ace7690fef8a738c40a30c542c52fd",
            "patch": "@@ -0,0 +1,9 @@\n+---\n+title: Introduction to the Implement the Bisection Method\n+block: lab-bisection-method\n+superBlock: full-stack-developer\n+---\n+\n+## Introduction to the Implement the Bisection Method\n+\n+In this lab, you will implement the bisection method to find the square root of a number."
        },
        {
            "sha": "4303cb1a8fe5052b5ff5689a5994fbca0fd0971c",
            "filename": "curriculum/challenges/_meta/lab-bisection-method/meta.json",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9cee50eb38ace7690fef8a738c40a30c542c52fd/curriculum%2Fchallenges%2F_meta%2Flab-bisection-method%2Fmeta.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9cee50eb38ace7690fef8a738c40a30c542c52fd/curriculum%2Fchallenges%2F_meta%2Flab-bisection-method%2Fmeta.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2F_meta%2Flab-bisection-method%2Fmeta.json?ref=9cee50eb38ace7690fef8a738c40a30c542c52fd",
            "patch": "@@ -0,0 +1,11 @@\n+{\n+  \"name\": \"Implement the Bisection Method\",\n+  \"isUpcomingChange\": true,\n+  \"dashedName\": \"lab-bisection-method\",\n+  \"superBlock\": \"full-stack-developer\",\n+  \"blockLayout\": \"link\",\n+  \"blockType\": \"lab\",\n+  \"helpCategory\": \"Python\",\n+  \"challengeOrder\": [{ \"id\": \"686ccc2c8b967e17ab18d593\", \"title\": \"Implement the Bisection Method\" }],\n+  \"usesMultifileEditor\": true\n+}"
        },
        {
            "sha": "b9f88126853c90be567fada3b33fc8c46eb880ba",
            "filename": "curriculum/challenges/english/25-front-end-development/lab-bisection-method/686ccc2c8b967e17ab18d593.md",
            "status": "added",
            "additions": 355,
            "deletions": 0,
            "changes": 355,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/9cee50eb38ace7690fef8a738c40a30c542c52fd/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flab-bisection-method%2F686ccc2c8b967e17ab18d593.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/9cee50eb38ace7690fef8a738c40a30c542c52fd/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flab-bisection-method%2F686ccc2c8b967e17ab18d593.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flab-bisection-method%2F686ccc2c8b967e17ab18d593.md?ref=9cee50eb38ace7690fef8a738c40a30c542c52fd",
            "patch": "@@ -0,0 +1,355 @@\n+---\n+id: 686ccc2c8b967e17ab18d593\n+title: Implement the Bisection Method\n+challengeType: 27\n+dashedName: implement-the-bisection-method\n+---\n+\n+# --description--\n+\n+The bisection method, also known as the binary search method, uses a binary search to find the roots of a real-valued function. It works by narrowing down an interval where the square root lies until it converges to a value within a specified tolerance.\n+\n+For example, if the tolerance is `0.01`, the bisection method will keep halving the interval until the difference between the upper and lower bounds is less than or equal to `0.01`.\n+\n+In this lab, you will implement a function that uses the bisection method to find the square root of a number.\n+\n+**Objective:** Fulfill the user stories below and get all the tests to pass to complete the lab.\n+\n+**User stories**\n+\n+1. You should define a function named `square_root_bisection` with three parameters:\n+    - The number for which you want to find the square root.\n+    - The tolerance being the acceptable error margin for the result. You should set a default tolerance value.\n+    - The maximum number of iterations to perform. You should set a default number of iterations.\n+\n+1. The `square_root_bisection` function should:\n+    - Raise a `ValueError` with the message `Square root of negative number is not defined in real numbers` if the number passed to the function is negative.\n+    - For numbers `0` and `1`, print the message: `The square root of [number] is [number]` and return the number itself as the square root.\n+    - For any other positive number, print the approximate square root with the message: `The square root of [square_target] is approximately [root]` and return the computed root value.\n+    - If no value meets the tolerance condition, print a failure message: `Failed to converge within the [maximum] iterations` and return `None`.\n+\n+**Note**: You cannot import any module for this lab.\n+\n+# --hints--\n+\n+You should not import any module.\n+\n+```js\n+({ test: () => assert(runPython(`len(_Node(_code).find_imports()) == 0`)) })\n+```\n+\n+You should have a function named `square_root_bisection`.\n+\n+```js\n+({ test: () => assert(runPython(`_Node(_code).has_function(\"square_root_bisection\")`)) })\n+```\n+\n+Your `square_root_bisection` function should have three parameters.\n+\n+```js\n+({ test: () => runPython(`\n+    import inspect \n+    sig = inspect.signature(square_root_bisection)\n+    assert len(sig.parameters) == 3\n+`) })\n+```\n+\n+You should set a default value for the tolerance and the maximum number of iterations.\n+\n+```js\n+({ test: () => runPython(`\n+try:\n+  import inspect \n+  sig = inspect.signature(square_root_bisection)\n+  assert len(sig.parameters) == 3\n+  square_root_bisection(4)\n+except TypeError:\n+  assert False\n+`) })\n+```\n+\n+Your `square_root_bisection` function should raise a `ValueError` with the message `Square root of negative number is not defined in real numbers` when the number passed to the function is negative.\n+\n+```js\n+({ test: () => runPython(`\n+try:\n+  square_root_bisection(-6)\n+except ValueError as e:\n+  assert str(e) == \"Square root of negative number is not defined in real numbers\"\n+else:\n+  assert False\n+`) })\n+```\n+\n+`square_root_bisection(0)` should return `0`.\n+\n+```js\n+({ test: () => runPython(`assert square_root_bisection(0) == 0`) })\n+```\n+\n+`square_root_bisection(0)` should print `The square root of 0 is 0`.\n+\n+```js\n+({ test: () => runPython(`\n+built_in_print = print\n+_out = []\n+\n+def custom_print(*args, **kwargs):\n+  call_args = [arg for arg in args]\n+  _out.extend(call_args)\n+\n+print = custom_print\n+square_root_bisection(0)\n+assert \"The square root of 0 is 0\" in _out\n+`) })\n+```\n+\n+`square_root_bisection(0.001, 1e-7, 50)` should return a number between `0.03162267660168379` and `0.031622876601683794`.\n+\n+```js\n+({ test: () => runPython(`assert 0.03162267660168379 <= square_root_bisection(0.001, 1e-7, 50) <= 0.031622876601683794`) })\n+```\n+\n+`square_root_bisection(0.001, 1e-7, 50)` should print `The square root of 0.001 is approximately X`, where `X` is a number between `0.03162267660168379` and `0.031622876601683794`.\n+\n+```js\n+({ test: () => runPython(`\n+built_in_print = print\n+_out = []\n+\n+def custom_print(*args, **kwargs):\n+  call_args = [arg for arg in args]\n+  _out.extend(call_args)\n+\n+print = custom_print\n+\n+_root = square_root_bisection(0.001, 1e-7, 50)\n+\n+assert 0.03162267660168379 <= _root <= 0.031622876601683794\n+assert f\"The square root of 0.001 is approximately {_root}\" in _out\n+`) })\n+```\n+\n+`square_root_bisection(0.25, 1e-7, 50)` should return a number between `0.4999999` and `0.5000001`.\n+\n+```js\n+({ test: () => runPython(`assert 0.4999999 <= square_root_bisection(0.25, 1e-7, 50) <= 0.5000001`) })\n+```\n+\n+`square_root_bisection(0.25, 1e-7, 50)` should print `The square root of 0.25 is approximately X`, where `X` is a number between `0.4999999` and `0.5000001`.\n+\n+```js\n+({ test: () => runPython(`\n+built_in_print = print\n+_out = []\n+\n+def custom_print(*args, **kwargs):\n+  call_args = [arg for arg in args]\n+  _out.extend(call_args)\n+\n+print = custom_print\n+\n+_root = square_root_bisection(0.25, 1e-7, 50)\n+\n+assert 0.4999999 <= _root <= 0.5000001\n+assert f\"The square root of 0.25 is approximately {_root}\" in _out\n+`) })\n+```\n+\n+`square_root_bisection(1)` should return `1`.\n+\n+```js\n+({ test: () => runPython(`assert square_root_bisection(1) == 1`) })\n+```\n+\n+`square_root_bisection(1)` should print `The square root of 1 is 1`.\n+\n+```js\n+({ test: () => runPython(`\n+built_in_print = print\n+_out = []\n+\n+def custom_print(*args, **kwargs):\n+  call_args = [arg for arg in args]\n+  _out.extend(call_args)\n+\n+print = custom_print\n+square_root_bisection(1)\n+assert \"The square root of 1 is 1\" in _out\n+`) })\n+```\n+\n+`square_root_bisection(81, 1e-3, 50)` should return a number between `8.999` and `9.001`.\n+\n+```js\n+({ test: () => runPython(`assert 8.999 <= square_root_bisection(81, 1e-3, 50) <= 9.001`) })\n+```\n+\n+`square_root_bisection(81, 1e-3, 50)` should print `The square root of 81 is approximately X`, where `X` is a number between `8.999` and `9.001`.\n+\n+```js\n+({ test: () => runPython(`\n+built_in_print = print\n+_out = []\n+\n+def custom_print(*args, **kwargs):\n+  call_args = [arg for arg in args]\n+  _out.extend(call_args)\n+\n+print = custom_print\n+\n+_root = square_root_bisection(81, 1e-3, 50)\n+\n+assert 8.999 <= _root <= 9.001\n+assert f\"The square root of 81 is approximately {_root}\" in _out\n+`) })\n+```\n+\n+`square_root_bisection(225, 1e-3, 100)` should return a number between `14.999` and `15.001`.\n+\n+```js\n+({ test: () => runPython(`assert 14.999 <= square_root_bisection(225, 1e-3, 100) <= 15.001`) })\n+```\n+\n+`square_root_bisection(225, 1e-3, 100)` should print `The square root of 225 is approximately X`, where `X` is a number between `14.999` and `15.001`.\n+\n+```js\n+({ test: () => runPython(`\n+built_in_print = print\n+_out = []\n+\n+def custom_print(*args, **kwargs):\n+  call_args = [arg for arg in args]\n+  _out.extend(call_args)\n+\n+print = custom_print\n+\n+_root = square_root_bisection(225, 1e-3, 100)\n+\n+assert 14.999 <= _root <= 15.001\n+assert f\"The square root of 225 is approximately {_root}\" in _out\n+`) })\n+```\n+\n+`square_root_bisection(225, 1e-5, 100)` should return a number between `14.99999` and `15.00001`.\n+\n+```js\n+({ test: () => runPython(`assert 14.99999 <= square_root_bisection(225, 1e-5, 100) <= 15.00001`) })\n+```\n+\n+`square_root_bisection(225, 1e-5, 100)` should print `The square root of 225 is approximately X`, where `X` is a number between `14.99999` and `15.00001`.\n+\n+```js\n+({ test: () => runPython(`\n+built_in_print = print\n+_out = []\n+\n+def custom_print(*args, **kwargs):\n+  call_args = [arg for arg in args]\n+  _out.extend(call_args)\n+\n+print = custom_print\n+\n+_root = square_root_bisection(225, 1e-5, 100)\n+\n+assert 14.99999 <= _root <= 15.00001\n+assert f\"The square root of 225 is approximately {_root}\" in _out\n+`) })\n+```\n+\n+`square_root_bisection(225, 1e-7, 100)` should return a number between `14.9999999` and `15.0000001`.\n+\n+```js\n+({ test: () => runPython(`assert 14.9999999 <= square_root_bisection(225, 1e-7, 100) <= 15.0000001`) })\n+```\n+\n+`square_root_bisection(225, 1e-7, 100)` should print `The square root of 225 is approximately X`, where `X` is a number between `14.9999999` and `15.0000001`.\n+\n+```js\n+({ test: () => runPython(`\n+built_in_print = print\n+_out = []\n+\n+def custom_print(*args, **kwargs):\n+  call_args = [arg for arg in args]\n+  _out.extend(call_args)\n+\n+print = custom_print\n+\n+_root = square_root_bisection(225, 1e-7, 100)\n+\n+assert 14.9999999 <= _root <= 15.0000001\n+assert f\"The square root of 225 is approximately {_root}\" in _out\n+`) })\n+```\n+\n+`square_root_bisection(225, 1e-7, 10)` should return `None`.\n+\n+```js\n+({ test: () => runPython(`assert square_root_bisection(225, 1e-7, 10) is None`) })\n+```\n+\n+`square_root_bisection(225, 1e-7, 10)` should print `Failed to converge within 10 iterations`.\n+\n+```js\n+({ test: () => runPython(`\n+built_in_print = print\n+_out = []\n+\n+def custom_print(*args, **kwargs):\n+  call_args = [arg for arg in args]\n+  _out.extend(call_args)\n+\n+print = custom_print\n+square_root_bisection(225, 1e-7, 10)\n+assert \"Failed to converge within 10 iterations\" in _out\n+`) })\n+```\n+\n+# --seed--\n+\n+## --seed-contents--\n+\n+```py\n+\n+```\n+\n+# --solutions--\n+\n+```py\n+def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n+    if square_target < 0:\n+        raise ValueError('Square root of negative number is not defined in real numbers')\n+    if square_target == 1:\n+        root = 1\n+        print(f'The square root of {square_target} is 1')\n+    elif square_target == 0:\n+        root = 0\n+        print(f'The square root of {square_target} is 0')\n+\n+    else:\n+        low = square_target if square_target < 1 else 1\n+        high = 1 if square_target < 1 else square_target\n+        root = None\n+\n+        for _ in range(max_iterations):\n+            mid = (low + high) / 2\n+            square_mid = mid**2\n+\n+            if high - low <= tolerance:\n+                root = mid\n+                break\n+\n+            elif square_mid < square_target:\n+                low = mid\n+            else:\n+                high = mid\n+\n+        if root is None:\n+            print(f\"Failed to converge within {max_iterations} iterations\")\n+\n+        else:   \n+            print(f'The square root of {square_target} is approximately {root}')\n+\n+    return root\n+```"
        }
    ],
    "stats": {
        "total": 381,
        "additions": 379,
        "deletions": 2
    }
}