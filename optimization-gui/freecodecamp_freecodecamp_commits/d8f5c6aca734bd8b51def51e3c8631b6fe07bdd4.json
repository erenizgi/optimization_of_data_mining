{
    "author": "Armankb2",
    "message": "feat(curriculum): add interactive examples to recursion and call stack lesson (#63679)\n\nCo-authored-by: Huyen Nguyen <25715018+huyenltnguyen@users.noreply.github.com>",
    "sha": "d8f5c6aca734bd8b51def51e3c8631b6fe07bdd4",
    "files": [
        {
            "sha": "b80c7eafb6e135452b1983b35e5b2d3d67fda66e",
            "filename": "curriculum/challenges/english/blocks/lecture-understanding-recursion-and-the-call-stack/6733b02d1e556005a544c5e3.md",
            "status": "modified",
            "additions": 44,
            "deletions": 24,
            "changes": 68,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/d8f5c6aca734bd8b51def51e3c8631b6fe07bdd4/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-recursion-and-the-call-stack%2F6733b02d1e556005a544c5e3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/d8f5c6aca734bd8b51def51e3c8631b6fe07bdd4/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-recursion-and-the-call-stack%2F6733b02d1e556005a544c5e3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-recursion-and-the-call-stack%2F6733b02d1e556005a544c5e3.md?ref=d8f5c6aca734bd8b51def51e3c8631b6fe07bdd4",
            "patch": "@@ -5,55 +5,69 @@ challengeType: 19\n dashedName: what-is-recursion-and-how-does-it-work\n ---\n \n-# --description--\n-\n-Let's learn how recursion works in JavaScript.\n+# --interactive--\n \n Recursion is a complicated feature that allows you to call a function repeatedly until a base-case is reached. Unlike a traditional loop, recursion allows you to handle something with an unknown depth, such as deeply nested objects/arrays, or a file tree. But you can also use it for more basic tasks, such as counting down from a given number.\n \n Let's construct a function to do exactly that. We’ll call our function `recursiveCountdown`, and it needs to accept a number. We’ll have it print this number to the console:\n \n+:::interactive_editor\n+\n ```js\n const recursiveCountdown = (number) => {\n   console.log(number);\n };\n+\n+recursiveCountdown(5);\n ```\n \n+:::\n+\n Now if we call this and pass the number 5, we’ll see the number print to our terminal. But nothing else happens – and the number 5 certainly isn’t a countdown.\n \n Before we start building the recursive portion of our function, we need to establish our base case first. If you don’t have a base case established, your code will run until it exceeds your memory allocation and crashes.\n \n+:::interactive_editor\n+\n ```js\n const recursiveCountdown = (number) => {\n-    if (number < 1) {\n-        return;\n-    }\n-    console.log(number);\n-  };\n+  if (number < 1) {\n+    return;\n+  }\n+  console.log(number);\n+};\n \n recursiveCountdown(5);\n ```\n \n+:::\n+\n For our base case, we want the countdown to stop if the number is less than 1. When we hit that base-case, we can return to break out of the function execution.\n \n Now that we’ve safely prepared a base-case, we can set up the recursion. The key point that makes a function recursive is that it calls itself in its execution. In this case, we want to call the function after we print the number. But in order to count down, our new number needs to be one less:\n \n+:::interactive_editor\n+\n ```js\n const recursiveCountdown = (number) => {\n-    if (number < 1) {\n-        return;\n-    }\n-    console.log(number);\n-    recursiveCountdown(number - 1);\n-  };\n+  if (number < 1) {\n+    return;\n+  }\n+  console.log(number);\n+  recursiveCountdown(number - 1);\n+};\n \n-recursiveCountdown(5); // \n+recursiveCountdown(5); \n ```\n \n+:::\n+\n This would log the numbers 5, 4, 3, 2, and 1 to the console.\n \n We do get our five numbers! But what if we wanted to count up instead? Rather than writing an entirely new function, we can swap the order of our log and our recursive call:\n \n+:::interactive_editor\n+\n ```js\n const recursiveCountdown = (number) => {\n     if (number < 1) {\n@@ -66,25 +80,31 @@ const recursiveCountdown = (number) => {\n recursiveCountdown(5);\n ```\n \n+:::\n+\n This would log the numbers 1, 2, 3, 4, and 5 to the console.\n \n But why does that work? Well, to understand this you need to understand the call stack. The call stack is how JavaScript tracks and resolves function calls. The stack functions as a last-in-first-out queue of sorts. To understand this better, let’s add some logging to our function:\n \n+:::interactive_editor\n+\n ```js\n const recursiveCountdown = (number) => {\n-    console.log(`Function execution started for number: ${number}`);\n-    if (number < 1) {\n-        console.log(`Base case reached, begin resolving stack`);\n-        return;\n-    }\n-    console.log(`Calling recursiveCountdown with number: ${number - 1}`);\n-    recursiveCountdown(number - 1);\n-    console.log(`Function execution completed for number: ${number}`);\n-  };\n+  console.log(`Function execution started for number: ${number}`);\n+  if (number < 1) {\n+    console.log(`Base case reached, begin resolving stack`);\n+    return;\n+  }\n+  console.log(`Calling recursiveCountdown with number: ${number - 1}`);\n+  recursiveCountdown(number - 1);\n+  console.log(`Function execution completed for number: ${number}`);\n+};\n \n recursiveCountdown(5);\n ```\n \n+:::\n+\n We’ve added four key statements here. The first log runs when a function call begins executing. The third log runs just before the recursive function is called. And the fourth log runs when the function execution has ended. The result is:\n \n ```md"
        }
    ],
    "stats": {
        "total": 68,
        "additions": 44,
        "deletions": 24
    }
}