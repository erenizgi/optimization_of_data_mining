{
    "author": "majestic-owl448",
    "message": "feat: add dictionaries and sets lectures (#61303)\n\nCo-authored-by: Zaira <33151350+zairahira@users.noreply.github.com>\nCo-authored-by: Dario-DC <105294544+Dario-DC@users.noreply.github.com>",
    "sha": "79338df8a3bf11827a9dcb5c7fe2572491d5f7f7",
    "files": [
        {
            "sha": "86465ef25f5836559452243501db00cc85c963ee",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-dictionaries-and-sets/683ec7a722bc7b67c1132bd3.md",
            "status": "modified",
            "additions": 174,
            "deletions": 40,
            "changes": 214,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/79338df8a3bf11827a9dcb5c7fe2572491d5f7f7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-dictionaries-and-sets%2F683ec7a722bc7b67c1132bd3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/79338df8a3bf11827a9dcb5c7fe2572491d5f7f7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-dictionaries-and-sets%2F683ec7a722bc7b67c1132bd3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-dictionaries-and-sets%2F683ec7a722bc7b67c1132bd3.md?ref=79338df8a3bf11827a9dcb5c7fe2572491d5f7f7",
            "patch": "@@ -7,127 +7,261 @@ dashedName: what-are-dictionaries-and-how-do-they-work\n \n # --description--\n \n-Lecture text\n+In Python, dictionaries are built-in data structures that store collections of key-value pairs. They work very similarly to real dictionaries, where you search for a word to find its corresponding meaning.\n+\n+With Python dictionaries, you use a key to find its corresponding value. You should use dictionaries when you need to associate values to unique keys. This is helpful when you need to find a value fast based on the key, and when you need to represent structured data.\n+\n+This is the general syntax of a Python dictionary:\n+\n+```python\n+dictionary = {\n+    key1: value1,\n+    key2: value2\n+}\n+```\n+\n+First, we find the variable that holds the dictionary. You don't necessarily need to assign the dictionary to a variable, but it's very common to do this to keep it in memory and use it later in the code.\n+\n+Then that's followed by curly braces, which are sometimes called curly brackets. And within the curly braces, there are key-value pairs.\n+\n+Each key is associated with a value, so you can use the key to access that value. After each value, except the last one, there's a comma to separate the different key-value pairs. Keys must be unique in the dictionary, and they must be an immutable data type. However, the values can be repeated, and they can be of any data type.\n+\n+Here we have an example of a dictionary that stores information about a Margherita pizza recipe:\n+\n+```python\n+pizza = {\n+    'name': 'Margherita Pizza',\n+    'price': 8.9,\n+    'calories_per_slice': 250,\n+    'toppings': ['mozzarella', 'basil']\n+}\n+```\n+\n+The dictionary is assigned to the `pizza` variable. It has four key-value pairs: `name`, `price`, `calories_per_slice`, and `toppings`.\n+\n+Another alternative would be using the `dict()` constructor, which builds the dictionary from a sequence of key-value pairs.\n+\n+This would be the equivalent syntax for our pizza example. We pass a list of tuples as argument to the `dict()` constructor. These tuples contain the key as the first element and the value as the second element.\n+\n+```python\n+pizza = dict([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250), ('toppings', ['mozzarella', 'basil'])])\n+```\n+\n+To access the value of a key-value pair, you can use this syntax, known as bracket notation. It's the name of the variable that holds the dictionary, followed by square brackets, and the key you want to access within the square brackets:\n+\n+```python\n+dictionary[key]\n+```\n+\n+In our pizza example, if you want to access the value of `name`, you would write the name of the variable, `pizza`, followed by square brackets, and the key, `name`, within quotes:\n+\n+```python\n+pizza['name']\n+```\n+\n+This will evaluate to:\n+\n+```python\n+'Margherita Pizza'\n+```\n+\n+To update a value, you just need to add the assignment operator, followed by the new value.\n+\n+If the key doesn't exist in the dictionary, a new key-value pair will be created. In recent versions of Python, dictionaries preserve the order of insertion. This is helpful when you need to iterate over the dictionary:\n+\n+```python\n+pizza['name'] = 'Margherita'\n+```\n+\n+Now the value of the key `name` is `'Margherita'`:\n+\n+```python\n+print(pizza['name']) # 'Margherita'\n+```\n+\n+Dictionaries also have helpful methods to perform common operations.\n+\n+The `.get()` method retrieves the value associated with a key. It's similar to the bracket notation that we just used, but its advantage is that you can set a default value, so you won't get an error is the key doesn't exist:\n+\n+```python\n+dictionary.get(key, default)\n+```\n+\n+In this example, if the `toppings` key doesn't exist, it will return an empty list, which is the default value that we are passing here as the second argument. But if `toppings` does exist, it will return that value:\n+\n+```python\n+pizza.get('toppings', []) # ['mozzarella', 'basil']\n+```\n+\n+The `.keys()` and `.values()` methods return a view object with all the keys and values in the dictionary, respectively:\n+\n+```python\n+pizza.keys()\n+# dict_keys(['name', 'price', 'calories_per_slice'])\n+\n+pizza.values()\n+# dict_values(['Margherita Pizza', 8.9, 250])\n+```\n+\n+A view object is just a way to see the content of a dictionary without creating a separate copy of the data.\n+\n+The `.items()` method returns a view object with all the key-value pairs in the dictionary, including both the keys and the values:\n+\n+```python\n+pizza.items()\n+# dict_items([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250)])\n+```\n+\n+The `.clear()` method removes all the key-value pairs from the dictionary:\n+\n+```python\n+pizza.clear()\n+```\n+\n+The `.pop()` method removes the key-value pair with the key that you specify as the first argument and returns its value. If the key doesn't exist, it returns the default value that you specify as the second argument. If the key doesn't exist and you don't pass a default value, a `KeyError` is raised:\n+\n+```python\n+pizza.pop('price', 10)\n+pizza.pop('total_price') # KeyError\n+```\n+\n+In Python 3.7 and more recent versions, the `.popitem()` method removes the last inserted item:\n+\n+```python\n+pizza.popitem()\n+```\n+\n+And finally, the `.update()` method updates the key-value pairs with the key-value pairs of another dictionary. If they have keys in common, their values are overwritten.\n+\n+In this example, we are updating the `pizza` dictionary. The `price` key exists in both of them, so its value will be replaced with `15`.\n+\n+But `total_time` is new, so it will be added to the `pizza` dictionary as a new key-value pair:\n+\n+```python\n+pizza.update({ 'price': 15, 'total_time': 25 })\n+```\n+\n+This is the new dictionary with the updated `price` and the new `total_time`. Notice how the price is now `15` and `total_time` is a new key-value pair:\n+\n+```python\n+{\n+    'name': 'Margherita Pizza', \n+    'price': 15, \n+    'calories_per_slice': 250, \n+    'toppings': ['mozzarella', 'basil'], \n+    'total_time': 25\n+}\n+```\n+\n+These are some of the most commonly used dictionary methods, but there are many more. Choosing the right one can be helpful for performing complex operations efficiently.\n \n # --questions--\n \n ## --text--\n \n-Question 1\n+How are elements primarily organized and accessed in a Python dictionary?\n \n ## --answers--\n \n-Answer 1.1\n+Using sequential indices, like a list.\n \n ### --feedback--\n \n-Feedback 1\n+Think about the core characteristic that distinguishes dictionaries from lists and tuples.\n \n ---\n \n-Answer 1.2\n-\n-### --feedback--\n-\n-Feedback 1\n+Using key-value pairs, where keys are unique.\n \n ---\n \n-Answer 1.3\n+Using a tree-like structure, similar to file systems.\n \n ### --feedback--\n \n-Feedback 1\n+Think about the core characteristic that distinguishes dictionaries from lists and tuples.\n \n ---\n \n-Answer 1.4\n+Using a linked list, where elements point to the next.\n \n ### --feedback--\n \n-Feedback 1\n+Think about the core characteristic that distinguishes dictionaries from lists and tuples.\n \n ## --video-solution--\n \n-5\n+2\n \n ## --text--\n \n-Question 2\n+What is the primary characteristic of a Python dictionary that makes it different from a list or tuple?\n \n ## --answers--\n \n-Answer 2.1\n+Dictionaries create duplicates of all key-value pairs. \n \n ### --feedback--\n \n-Feedback 2\n+Think about the feature that makes dictionaries particularly helpful for data retrieval based on names or labels.\n \n ---\n \n-Answer 2.2\n+Dictionaries are mutable.\n \n ### --feedback--\n \n-Feedback 2\n+Think about the feature that makes dictionaries particularly helpful for data retrieval based on names or labels.\n \n ---\n \n-Answer 2.3\n-\n-### --feedback--\n-\n-Feedback 2\n+Dictionaries allow fast lookups using keys.\n \n ---\n \n-Answer 2.4\n+Dictionaries can store duplicate values.\n \n ### --feedback--\n \n-Feedback 2\n+Think about the feature that makes dictionaries particularly helpful for data retrieval based on names or labels.\n \n ## --video-solution--\n \n-5\n+3\n \n ## --text--\n \n-Question 3\n+Which dictionary method is used to retrieve a value associated with a key, and provide a default value if the key is not found?\n \n ## --answers--\n \n-Answer 3.1\n+`.keys()`\n \n ### --feedback--\n \n-Feedback 3\n+Think about which method is designed for safe retrieval of values without throwing an error.\n \n ---\n \n-Answer 3.2\n+`.values()`\n \n ### --feedback--\n \n-Feedback 3\n+Think about which method is designed for safe retrieval of values without throwing an error.\n \n ---\n \n-Answer 3.3\n+`.pop()`\n \n ### --feedback--\n \n-Feedback 3\n+Think about which method is designed for safe retrieval of values without throwing an error.\n \n ---\n \n-Answer 3.4\n-\n-### --feedback--\n-\n-Feedback 3\n+`.get()`\n \n ## --video-solution--\n \n-5\n+4\n "
        },
        {
            "sha": "7386e7174aae639bf3001c4e075d1edca1b9b6ba",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-dictionaries-and-sets/683ec8e8a2389f713380fca8.md",
            "status": "modified",
            "additions": 246,
            "deletions": 40,
            "changes": 286,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/79338df8a3bf11827a9dcb5c7fe2572491d5f7f7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-dictionaries-and-sets%2F683ec8e8a2389f713380fca8.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/79338df8a3bf11827a9dcb5c7fe2572491d5f7f7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-dictionaries-and-sets%2F683ec8e8a2389f713380fca8.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-dictionaries-and-sets%2F683ec8e8a2389f713380fca8.md?ref=79338df8a3bf11827a9dcb5c7fe2572491d5f7f7",
            "patch": "@@ -7,127 +7,333 @@ dashedName: what-are-some-common-techniques-to-loop-over-a-dictionary\n \n # --description--\n \n-Lecture text\n+You can loop over a dictionary if you need to access and process its key-value pairs. This is helpful for updating their values or applying some logic to them.\n+\n+Let's take a look at some of the techniques you can use.\n+\n+Let's say that we have a `products` dictionary that associates every product with its price:\n+\n+```python\n+products = {\n+    'Laptop': 990,\n+    'Smartphone': 600,\n+    'Tablet': 250,\n+    'Headphones': 70,\n+}\n+```\n+\n+If we want to offer a 20% discount on all our products, we can loop over all the key-value pairs and modify the prices.\n+\n+The `.values()`, `.keys()`, and `.items()` methods are essential for these techniques. We covered them briefly in a previous lecture.\n+\n+They return a view object with the values, keys, and key-value pairs of the dictionary. You can use these view objects in `for` loops to iterate over the elements.\n+\n+For example, you can iterate over all the values of the dictionary like this.\n+\n+You write `for`, the loop variable (`price` in this case), `products.values()` to get all the values of the `products` dictionary, a colon, and then the body of the loop, where you can apply any logic to the values. In this case, we are printing them.\n+\n+The loop variable will take each one of the values, one per iteration:\n+\n+```python\n+for price in products.values():\n+    print(price)\n+```\n+\n+And here is the output. As you can see, each value is printed to the console, one by one:\n+\n+```md\n+990\n+600\n+250\n+70\n+```\n+\n+This works exactly the same for `.keys()` if you need to iterate over the keys of a dictionary. You just need to iterate over `products.keys()` or `products` directly, and assign a descriptive name for the loop variable:\n+\n+```python\n+for product in products.keys():\n+    print(product)\n+\n+for product in products:\n+    print(product)\n+```\n+\n+This is the output. Each key is printed to the console, one at a time:\n+\n+```md\n+Laptop\n+Smartphone\n+Tablet\n+Headphones\n+```\n+\n+And this works exactly the same for key-value pairs if you need to iterate over the keys and their corresponding values simultaneously. You just need to iterate over `products.items()`:\n+\n+```python\n+for product in products.items():\n+    print(product)\n+```\n+\n+This is the output. Now you get individual tuples with the keys and their corresponding values:\n+\n+```md\n+('Laptop', 990)\n+('Smartphone', 600)\n+('Tablet', 250)\n+('Headphones', 70)\n+```\n+\n+If you want to store the key and the value in separate loop variables, you just need to define them and separate them with a comma. Then, you can use them in the body of the loop.\n+\n+Here, we are defining a `product` loop variable and a `price` loop variable. Each one will hold its corresponding value. It's important to define them in order – the key first, and then the value:\n+\n+```python\n+for product, price in products.items():\n+    print(product, price)\n+```\n+\n+This is the output. We are printing them side by side, but you can use these values as you need them in your code.\n+\n+```md\n+Laptop 990\n+Smartphone 600\n+Tablet 250\n+Headphones 70\n+```\n+\n+Now that you know more about this, we can go back to our initial example. If we want to offer a 20% discount, we would multiply each price by `0.8` and reassign it as the value of that product key.\n+\n+We could also round the result down if we want to work with integers:\n+\n+```python\n+products = {\n+    'Laptop': 990,\n+    'Smartphone': 600,\n+    'Tablet': 250,\n+    'Headphones': 70,\n+}\n+\n+for product, price in products.items():\n+    products[product] = round(price * 0.8)\n+\n+print(products)\n+```\n+\n+Then, if we print the dictionary, we would get these key-value pairs with the discounted prices:\n+\n+```python\n+{\n+    'Laptop': 792, \n+    'Smartphone': 480, \n+    'Tablet': 200, \n+    'Headphones': 56\n+}\n+```\n+\n+And finally, if you need to iterate over the key-value pairs while keeping track of a counter, you can call the `enumerate()` function. This counter essentially acts as a sort of \"index\" or \"count\" for that element within the loop.\n+\n+The function returns an `enumerate` object, which assigns an integer to each key-value pair, like a counter. You can start the counter from any number, but by default, it starts from 0.\n+\n+Here, we are iterating over the keys of the `products` dictionary:\n+\n+```python\n+for product in enumerate(products):\n+    print(product)\n+```\n+\n+But the `enumerate()` function also assigns an integer to each key, so we get tuples with the integer and the key.\n+\n+Here is the output:\n+\n+```md\n+(0, 'Laptop')\n+(1, 'Smartphone')\n+(2, 'Tablet')\n+(3, 'Headphones')\n+```\n+\n+If you need to, you can assign these values to separate loop variables. Here, we have two loop variables (`index` and `product`). This is what you will commonly see and use when you work with `enumerate()`:\n+\n+```python\n+for index, product in enumerate(products):\n+    print(index, product)\n+```\n+\n+If you need to iterate over the values, you can replace `products` by `products.values()`:\n+\n+```python\n+for price in enumerate(products.values()):\n+    print(price)\n+```\n+\n+The output will have the index and the price in each tuple:\n+\n+```md\n+(0, 990)\n+(1, 600)\n+(2, 250)\n+(3, 70)\n+```\n+\n+You can assign them to separate loop variables as well:\n+\n+```python\n+for index, price in enumerate(products.values()):\n+    print(index, price)\n+```\n+\n+This will be the output. You can use them as you need to in your code:\n+\n+```md\n+0 990\n+1 600\n+2 250\n+3 70\n+```\n+\n+And with `products.items()`, you can get the entire key-value pair in addition to the \"index\" or \"counter\":\n+\n+```python\n+for index, product in enumerate(products.items()):\n+    print(index, product)\n+```\n+\n+In this example, we get the index followed by a tuple that contains the key and the value of the corresponding key-value pair:\n+\n+```md\n+0 ('Laptop', 990)\n+1 ('Smartphone', 600)\n+2 ('Tablet', 250)\n+3 ('Headphones', 70)\n+```\n+\n+To customize the initial value of the count, you can pass a second argument to `enumerate()`. For example, here we are starting the count from 1:\n+\n+```python\n+for index, product in enumerate(products.items(), 1):\n+    print(index, product)\n+```\n+\n+You can see this change in the output. Now the first integer is 1 instead of 0:\n+\n+```md\n+1 ('Laptop', 990)\n+2 ('Smartphone', 600)\n+3 ('Tablet', 250)\n+4 ('Headphones', 70)\n+```\n+\n+This works with any variation we've seen so far. You just need to pass the initial number as the second argument.\n+\n+There are many techniques to loop over a dictionary. These are some common ways, and you'll need to choose the best one for your project.\n \n # --questions--\n \n ## --text--\n \n-Question 1\n+Which dictionary method, when used in a loop, allows you to access the key-value pairs stored in the dictionary?\n \n ## --answers--\n \n-Answer 1.1\n+`.keys()`\n \n ### --feedback--\n \n-Feedback 1\n+Think about which method returns a sequence with the keys and their corresponding values.\n \n ---\n \n-Answer 1.2\n-\n-### --feedback--\n-\n-Feedback 1\n+`.items()`\n \n ---\n \n-Answer 1.3\n+`.values()`\n \n ### --feedback--\n \n-Feedback 1\n+Think about which method returns a sequence with the keys and their corresponding values.\n \n ---\n \n-Answer 1.4\n+`enumerate()`\n \n ### --feedback--\n \n-Feedback 1\n+Think about which method returns a sequence with the keys and their corresponding values.\n \n ## --video-solution--\n \n-5\n+2\n \n ## --text--\n \n-Question 2\n+When using the `enumerate()` function with `dictionary.items()`, what does the first loop variable represent?\n \n ## --answers--\n \n-Answer 2.1\n+The dictionary's keys\n \n ### --feedback--\n \n-Feedback 2\n+Think about what `enumerate()` adds to the iterable for each iteration. \n \n ---\n \n-Answer 2.2\n+The dictionary's values.\n \n ### --feedback--\n \n-Feedback 2\n+Think about what `enumerate()` adds to the iterable for each iteration. \n \n ---\n \n-Answer 2.3\n-\n-### --feedback--\n-\n-Feedback 2\n+The index or count of the key-value pair.\n \n ---\n \n-Answer 2.4\n+The key-value pair as a tuple.\n \n ### --feedback--\n \n-Feedback 2\n+Think about what `enumerate()` adds to the iterable for each iteration. \n \n ## --video-solution--\n \n-5\n+3\n \n ## --text--\n \n-Question 3\n+Which method would you use if you need to iterate over a dictionary and access only the keys?\n \n ## --answers--\n \n-Answer 3.1\n-\n-### --feedback--\n-\n-Feedback 3\n+`.keys()`\n \n ---\n \n-Answer 3.2\n+`.values()`\n \n ### --feedback--\n \n-Feedback 3\n+Think about which method gives you access to the keys of the dictionary.\n \n ---\n \n-Answer 3.3\n+`enumerate()`\n \n ### --feedback--\n \n-Feedback 3\n+Think about which method gives you access to the keys of the dictionary.\n \n ---\n \n-Answer 3.4\n+`.items()`\n \n ### --feedback--\n \n-Feedback 3\n+Think about which method gives you access to the keys of the dictionary.\n \n ## --video-solution--\n \n-5\n+1\n "
        },
        {
            "sha": "52027da7387df57a2e011d3748750bceffe6c0ee",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-dictionaries-and-sets/683ec8fd8b21827317388a45.md",
            "status": "modified",
            "additions": 155,
            "deletions": 40,
            "changes": 195,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/79338df8a3bf11827a9dcb5c7fe2572491d5f7f7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-dictionaries-and-sets%2F683ec8fd8b21827317388a45.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/79338df8a3bf11827a9dcb5c7fe2572491d5f7f7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-dictionaries-and-sets%2F683ec8fd8b21827317388a45.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-dictionaries-and-sets%2F683ec8fd8b21827317388a45.md?ref=79338df8a3bf11827a9dcb5c7fe2572491d5f7f7",
            "patch": "@@ -7,127 +7,242 @@ dashedName: what-are-sets-and-how-do-they-work\n \n # --description--\n \n-Lecture text\n+Sets are one of Python's built-in data structures. One of the core characteristics of sets is that they don't store duplicate values. If you try to add a duplicate value to a set, only one of them will be stored.\n+\n+Sets are mutable and unordered, which means that their elements are not stored in any specific order, so you cannot use indices or keys to access them. They can only contain values of immutable data types like numbers, strings, and tuples. And they support mathematical set operations, including union, intersection, difference, and symmetric difference.\n+\n+To define a set, you just need to write its elements within curly braces and separate them with commas. This is an example of a set of numbers:\n+\n+```python\n+my_set = {1, 2, 3, 4, 5} \n+```\n+\n+One quirk of working with sets is that, if you ever need to define an empty set, you must use the `set()` function. If you just write empty curly braces, like `{}`, Python will automatically create a dictionary.\n+\n+```python\n+set() # Set\n+{}    # Dictionary\n+```\n+\n+You can add an element to a set with the `.add()` method, and pass in the new element as argument:\n+\n+```python\n+my_set.add(6)\n+```\n+\n+In our example, the new set would be:\n+\n+```python\n+{1, 2, 3, 4, 5, 6}\n+```\n+\n+If you try to add an element that is already in the set, only one will be kept. In this case, we already have the number 5 in the set:\n+\n+```python\n+my_set.add(5)\n+```\n+\n+So the set will not change:\n+\n+```python\n+{1, 2, 3, 4, 5, 6}\n+```\n+\n+To remove an element from the set, you have two options. You can either use the `.remove()` method or the `.discard()` method, and pass in the element that you want to remove as argument.\n+\n+The `.remove()` method will raise a `KeyError` if the element is not found, while the `.discard()` method will not:\n+\n+```python\n+my_set.remove(4)\n+my_set.discard(4)\n+```\n+\n+The `.clear()` method removes all the elements from the set:\n+\n+```python\n+my_set.clear()\n+```\n+\n+Python sets also have powerful methods that perform common mathematical set operations.\n+\n+The `.issubset()` and the `.issuperset()` methods check if a set is a subset or superset of another set, respectively.\n+\n+Here, we are checking if `your_set` is a subset of `my_set`, which is `False` because not all the elements of `your_set` are in `my_set`.\n+\n+We are also checking if `my_set` is a superset of `your_set`. This is also `False` because `my_set` does not have all the elements of `your_set`:\n+\n+```python\n+my_set = {1, 2, 3, 4, 5}\n+your_set = {2, 3, 4, 6}\n+\n+print(your_set.issubset(my_set)) # False\n+print(my_set.issuperset(your_set)) # False\n+```\n+\n+The `.isdisjoint()` method checks if two sets are disjoint, which means they don't have any elements in common. In this case, that's `False` because `my_set` and `your_set` do have common elements – 2, 3, and 4:\n+\n+```python\n+print(my_set.isdisjoint(your_set)) # False\n+```\n+\n+The union operator `|` returns a new set with all the elements from both sets:\n+\n+```python\n+my_set | your_set # {1, 2, 3, 4, 5, 6}\n+```\n+\n+The intersection operator `&` returns a new set with only the elements that the sets have in common:\n+\n+```python\n+my_set & your_set # {2, 3, 4}\n+```\n+\n+The difference operator `-` returns a new set with the elements of the first set that are not in the other sets. In this example, the numbers 1 and 5 are in `my_set` but NOT in `your_set`:\n+\n+```python\n+my_set - your_set # {1, 5}\n+```\n+\n+The symmetric difference operator `^` returns a new set with the elements that are either on the first or the second set, but not both. In this case, 1 and 5 are in `my_set` but not in `your_set`, so they are included. And the number 6 is in `your_set` but not in `my_set`, so it's included as well:\n+\n+```python\n+my_set ^ your_set # {1, 5, 6}\n+```\n+\n+Each one of these operators also has its corresponding compound assignment operator if you add the equal sign next to it. These operators automatically assign the resulting set to the first set in the expression:\n+\n+```python\n+|= &= -= ^=\n+```\n+\n+For example, the `-=` operator finds the difference between the sets and updates the first set with that result:\n+\n+```python\n+my_set -= your_set\n+```\n+\n+After this, `my_set` will be updated to `{1, 5}`:\n+\n+```python\n+print(my_set) # {1, 5}\n+```\n+\n+You can check if an element is in a set or not with the `in` operator. Here, we are checking if 5 is in `my_set`. The result will be a boolean value `True` or `False`:\n+\n+```python\n+print(5 in my_set)\n+```\n+\n+And those are the fundamentals of sets. They are very helpful when you don't need to store the values in any specific order, and when you only need to store unique values.\n+\n \n # --questions--\n \n ## --text--\n \n-Question 1\n+Which of the following is a core characteristic of Python sets?\n \n ## --answers--\n \n-Answer 1.1\n+Elements are ordered and accessed by index.\n \n ### --feedback--\n \n-Feedback 1\n+Think about how sets are different from lists, tuples, and dictionaries.\n \n ---\n \n-Answer 1.2\n+Elements are stored as key-value pairs.\n \n ### --feedback--\n \n-Feedback 1\n+Think about how sets are different from lists, tuples, and dictionaries.\n \n ---\n \n-Answer 1.3\n-\n-### --feedback--\n-\n-Feedback 1\n+Elements are unique and unordered.\n \n ---\n \n-Answer 1.4\n+Elements can be of any data type, including lists and dictionaries.\n \n ### --feedback--\n \n-Feedback 1\n+Think about how sets are different from lists, tuples, and dictionaries.\n \n ## --video-solution--\n \n-5\n+3\n \n ## --text--\n \n-Question 2\n+What operator is used to check if an element is present in a set?\n \n ## --answers--\n \n-Answer 2.1\n+`==`\n \n ### --feedback--\n \n-Feedback 2\n+Think about the operator that tests for membership within a collection.\n \n ---\n \n-Answer 2.2\n-\n-### --feedback--\n-\n-Feedback 2\n+`in`\n \n ---\n \n-Answer 2.3\n+`get()`\n \n ### --feedback--\n \n-Feedback 2\n+Think about the operator that tests for membership within a collection.\n \n ---\n \n-Answer 2.4\n+`find()`\n \n ### --feedback--\n \n-Feedback 2\n+Think about the operator that tests for membership within a collection.\n \n ## --video-solution--\n \n-5\n+2\n \n ## --text--\n \n-Question 3\n+Which set operation returns a new set with the elements that are present in either one of the two sets, but not in both of them?\n \n ## --answers--\n \n-Answer 3.1\n+Union\n \n ### --feedback--\n \n-Feedback 3\n+Think about which operation identifies elements that are unique to each set.\n \n ---\n \n-Answer 3.2\n+Intersection\n \n ### --feedback--\n \n-Feedback 3\n+Think about which operation identifies elements that are unique to each set.\n \n ---\n \n-Answer 3.3\n+Difference\n \n ### --feedback--\n \n-Feedback 3\n+Think about which operation identifies elements that are unique to each set.\n \n ---\n \n-Answer 3.4\n-\n-### --feedback--\n-\n-Feedback 3\n+Symmetric Difference\n \n ## --video-solution--\n \n-5\n+4\n "
        },
        {
            "sha": "72cfc456972967c00323afc976ddf07cc20bfb62",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-modules/683ec7b778993c6971b56c83.md",
            "status": "modified",
            "additions": 214,
            "deletions": 40,
            "changes": 254,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/79338df8a3bf11827a9dcb5c7fe2572491d5f7f7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-modules%2F683ec7b778993c6971b56c83.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/79338df8a3bf11827a9dcb5c7fe2572491d5f7f7/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-modules%2F683ec7b778993c6971b56c83.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-modules%2F683ec7b778993c6971b56c83.md?ref=79338df8a3bf11827a9dcb5c7fe2572491d5f7f7",
            "patch": "@@ -7,127 +7,301 @@ dashedName: what-is-the-python-standard-library-and-how-do-you-import-a-module\n \n # --description--\n \n-Lecture text\n+In software development, a library is like a toolbox for developers.\n+\n+Instead of having to implement every single part of the code yourself from scratch, a library gives you pre-written and reusable code, like functions, classes, and data structures that you can use in your projects.\n+\n+Python has an extensive standard library with many different built-in modules. They're all standardized, well-vetted solutions for many of the problems and tasks you'll face daily as a programmer, such as:\n+\n+* Interacting with the operating system.\n+    \n+* Working with files.\n+    \n+* Networking.\n+    \n+* Working with date and time.\n+    \n+* Performing mathematical operations.\n+    \n+* Using regular expressions.\n+    \n+* Testing and debugging your code.\n+    \n+* And much more!\n+    \n+\n+Some examples of popular built-in modules are `math`, `random`, `re` (short for \"regular expressions\"), and `datetime`.\n+\n+The `math` module has helpful functions for performing more complex mathematical operations.\n+\n+The `random` module is helpful for generating random numbers.\n+\n+The `re` module is used for working with regular expressions.\n+\n+And the `datetime` module is helpful for working with dates and times in Python.\n+\n+But how can you access the variables, constants, functions, and classes defined in these built-in modules?\n+\n+You use an import statement. These statements let you import modules into your Python script. Import statements are generally written at the top of the file. Also, you can customize them based on your needs. First, you use the `import` statement, followed by the name of the module:\n+\n+```python\n+import module_name\n+```\n+\n+Let's say that you want to import the `math` module. In that case, you would write this at the top of your file:\n+\n+```python\n+import math\n+```\n+\n+Then, if you need to call a method from that module in your Python script, you would use dot notation, with the name of the module followed by the name of the method:\n+\n+```python\n+module_name.method_name() \n+```\n+\n+For example, to get the square root of 36, you would write `math` followed by a dot and then `sqrt`, an abbreviation of square root, and within parentheses, you would pass any necessary arguments. In this case, we only need to pass in the number we want the square root of:\n+\n+```python\n+math.sqrt(36)\n+```\n+\n+This is the most basic version of an import statement, but there are other alternatives.\n+\n+If you need to import the module with a different name (also known as an \"alias\"), you can use this syntax, with `as` followed by the alias at the end of the import statement:\n+\n+```python\n+import module_name as module_alias\n+```\n+\n+This is often used to shorten long module names, or to avoid naming conflicts.\n+\n+For example, to refer to the `math` module as `m` in your code, you can assign an alias to it, like this:\n+\n+```python\n+import math as m \n+```\n+\n+Then, you can access the elements of the module using the alias:\n+\n+```python\n+m.sqrt(36)\n+```\n+\n+But sometimes you don't need to import everything from a module. Perhaps you only need one or two specific functions or classes. Python has exactly what you need in that case.\n+\n+Now the import statement starts with `from`, followed by the name of the module, and then the `import` keyword followed by the name of the elements that you want to import:\n+\n+```python\n+from module_name import name1, name2\n+```\n+\n+Then, you can use these names without the module prefix in your Python script.\n+\n+If you want to assign aliases to these names, you can do that by using the `as` keyword after each, followed by the alias you want to use:\n+\n+```python\n+from module_name import name1 as alias1, name2 as alias2\n+```\n+\n+Let's say that you only want to import the radians, sine, and cosine functions from the `math` module. You would write:\n+\n+```python\n+from math import radians, sin, cos\n+```\n+\n+Now you can call these functions directly in your code, without the `math` module as a prefix.\n+\n+Here we have a more detailed example:\n+\n+To find the sine and cosine of a specific angle initially expressed in degrees, we can call the `radians` function to convert it to radians, and then call the sine and cosine functions, passing the angle in radians:\n+\n+```python\n+from math import radians, sin, cos\n+\n+angle_degrees = 40\n+angle_radians = radians(angle_degrees)\n+\n+sine_value = sin(angle_radians)\n+cos_value = cos(angle_radians)\n+\n+print(sine_value) # 0.6427876096865393\n+print(cos_value)  # 0.766044443118978\n+```\n+\n+Notice how we are calling the functions directly, without the name of the module as a prefix. This is because we imported the functions with this alternative syntax.\n+\n+This is helpful, but it can result in naming conflicts if you already have functions or variables with the same name defined in the Python script itself. So that's something to keep in mind when choosing which type of import statement you want to use.\n+\n+And finally, we find this import statement that ends with an asterisk. The asterisk is telling Python that you want to import everything in that module, but you want to import it so that you don't need to use the name of the module as a prefix:\n+\n+```python\n+from module_name import *\n+```\n+\n+For example, if you do this while importing the `math` module, you'll be able to call any function defined in that module without specifying the name of the module as a prefix. Here are some examples:\n+\n+```python\n+from math import *\n+print(sqrt(36))  # 6.0\n+print(pow(5, 2)) # 25.0\n+print(exp(1))    # 2.718281828459045\n+```\n+\n+However, this is generally discouraged because it can lead to namespace collisions, and make it harder to know where certain names are coming from.\n+\n+Import statements work exactly the same for functions, classes, constants, variables, and any other elements defined in the module.\n+\n+Here is an example of a constant from the `math` module, the number `pi`:\n+\n+```python\n+import math\n+print(math.pi)\n+```\n+\n+And here is an example of a class from the `datetime` module. We create a date object that represents July 15, 1959. Then, we assign that `date` object to a variable and access the day, month, and year individually using dot notation:\n+\n+```python\n+import datetime\n+birthday = datetime.date(1959, 7, 15)\n+print(birthday.day)    # 15\n+print(birthday.month)  # 7\n+print(birthday.year)   # 1959\n+```\n+\n+You can find more information about the content of the module in the official Python documentation for that module.\n+\n+Great. Now that you know more about modules, you should also know about this very important idiom in Python scripts, because they are very closely related:\n+\n+```python\n+if __name__ == '__main__': \n+    # Code\n+```\n+\n+`__name__` is a special built-in variable in Python.\n+\n+When a Python file is executed directly, Python sets the value of this variable to the string `\"__main__\"`.\n+\n+But if the Python file is imported as a module into another Python script, the value of the `__name__` variable is set to the name of that module (usually the filename without the `.py` extension).\n+\n+This is why you'll often find this conditional in Python scripts. It contains the code that you want to run **only if** the Python script is running as the main program:\n+\n+```python\n+if __name__ == '__main__': \n+    # Code\n+```\n+\n+But if the script is imported as a module, the code within that block doesn't run.\n+\n+This is helpful because it allows Python scripts to have two purposes. They can be run directly to execute their main logic, or they can be imported into another module without executing their main logic.\n \n # --questions--\n \n ## --text--\n \n-Question 1\n+Which of the following statements best describes the Python Standard Library?\n \n ## --answers--\n \n-Answer 1.1\n-\n-### --feedback--\n-\n-Feedback 1\n+It is a collection of pre-written modules and packages included with Python.\n \n ---\n \n-Answer 1.2\n+It is a collection of third-party libraries that need to be installed separately.\n \n ### --feedback--\n \n-Feedback 1\n+Think about what \"standard\" means in the content of the Python Standard Library.\n \n ---\n \n-Answer 1.3\n+It is the core syntax of the Python language itself.\n \n ### --feedback--\n \n-Feedback 1\n+Think about what \"standard\" means in the content of the Python Standard Library.\n \n ---\n \n-Answer 1.4\n+It consists of external libraries written in other programming languages.\n \n ### --feedback--\n \n-Feedback 1\n+Think about what \"standard\" means in the content of the Python Standard Library.\n \n ## --video-solution--\n \n-5\n+1\n \n ## --text--\n \n-Question 2\n+Which of the following is the correct syntax to import the entire `datetime` module and give it a shorter alias `dt`?\n \n ## --answers--\n \n-Answer 2.1\n+`import datetime`\n \n ### --feedback--\n \n-Feedback 2\n+Think about the keyword used for creating aliases during the import process.\n \n ---\n \n-Answer 2.2\n+`from datetime import date as dt`\n \n ### --feedback--\n \n-Feedback 2\n+Think about the keyword used for creating aliases during the import process.\n \n ---\n \n-Answer 2.3\n-\n-### --feedback--\n-\n-Feedback 2\n+`import datetime as dt`\n \n ---\n \n-Answer 2.4\n+`from datetime import dt`\n \n ### --feedback--\n \n-Feedback 2\n+Think about the keyword used for creating aliases during the import process.\n \n ## --video-solution--\n \n-5\n+3\n \n ## --text--\n \n-Question 3\n+If you only want to use the `mean` function from the `statistics` module directly in your code without prefixing it with `statistics`, which import statement would you use?\n \n ## --answers--\n \n-Answer 3.1\n+`import statistics`\n \n ### --feedback--\n \n-Feedback 3\n+Think about the keyword used to import specific names from a module.\n \n ---\n \n-Answer 3.2\n-\n-### --feedback--\n-\n-Feedback 3\n+`from statistics import mean`\n \n ---\n \n-Answer 3.3\n+`import mean from statistics`\n \n ### --feedback--\n \n-Feedback 3\n+Think about the keyword used to import specific names from a module.\n \n ---\n \n-Answer 3.4\n+`from statistics import *`\n \n ### --feedback--\n \n-Feedback 3\n+Think about the keyword used to import specific names from a module.\n \n ## --video-solution--\n \n-5\n+2\n "
        }
    ],
    "stats": {
        "total": 949,
        "additions": 789,
        "deletions": 160
    }
}