{
    "author": "gikf",
    "message": "fix(curriculum): extend selection sort algorithm tests (#64523)\n\nCo-authored-by: Oliver Eyton-Williams <ojeytonwilliams@gmail.com>",
    "sha": "1e4f6f0b8c6ec0dc0d26528d5c774f4867091901",
    "files": [
        {
            "sha": "7cb54e213864ef18a3882a84642ba5658bb47205",
            "filename": "curriculum/challenges/english/blocks/lab-selection-sort/680b3ef395479b0e449ecb6e.md",
            "status": "modified",
            "additions": 107,
            "deletions": 0,
            "changes": 107,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1e4f6f0b8c6ec0dc0d26528d5c774f4867091901/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flab-selection-sort%2F680b3ef395479b0e449ecb6e.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1e4f6f0b8c6ec0dc0d26528d5c774f4867091901/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flab-selection-sort%2F680b3ef395479b0e449ecb6e.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flab-selection-sort%2F680b3ef395479b0e449ecb6e.md?ref=1e4f6f0b8c6ec0dc0d26528d5c774f4867091901",
            "patch": "@@ -20,6 +20,8 @@ Selection sort results in a quadratic time complexity in the best, average, and\n 1. You should define a function named `selection_sort`.\n 1. Your `selection_sort` function should have one parameter that represents the list of items.\n 1. Your `selection_sort` function should take a list and sort the items in place from smallest to largest.\n+1. Your `selection_sort` function should modify the input list in-place, and return it once it's sorted.\n+1. Your `selection_sort` function should follow the selection sort algorithm, swapping the smallest element from the unsorted portion of the list, with the first unsorted element.\n 1. Your `selection_sort` function should not use either the built-in `sort()` method or `sorted()` function.\n \n # --hints--\n@@ -61,6 +63,111 @@ You should not use the built-in `sort()` method or `sorted()` function in your c\n )\n ```\n \n+Your `selection_sort` should return the same list as the input list.\n+\n+```js\n+(\n+    {\n+        test: () => runPython(`\n+            input_list = [32, 0, 88, 1, 203]\n+            assert selection_sort(input_list) is input_list\n+        `)\n+    }\n+)\n+```\n+\n+Your `selection_sort` should modify the input list in-place. You should not use any method adding, or removing items from the list.\n+\n+```js\n+(\n+    {\n+        test: () => runPython(`\n+            from collections import UserList\n+\n+            class CustomList(UserList):\n+                def __init__(self, *args, **kwargs):\n+                    self._record = []\n+                    super().__init__(*args, **kwargs)\n+\n+                def __setitem__(self, key, value):\n+                    self._record.append(f'Setting item {key} to {value}. Previous value: {self[key]}')\n+                    super().__setitem__(key, value)\n+\n+                def append(self, *args, **kwargs):\n+                    self._record.append(f'Appending to list: {args}, {kwargs}')\n+                    super().append(*args, **kwargs)\n+\n+                def insert(self, *args, **kwargs):\n+                    self._record.append(f'Inserting to list: {args}, {kwargs}')\n+                    super().insert(*args, **kwargs)\n+\n+                def pop(self, *args, **kwargs):\n+                    self._record.append(f'Popping from list: {args}, {kwargs}')\n+                    super().pop(*args, **kwargs)\n+\n+                def remove(self, *args, **kwargs):\n+                    self._record.append(f'Removing from list: {args}, {kwargs}')\n+                    super().remove(*args, **kwargs)\n+\n+\n+            list_to_sort = CustomList([32, 0, 88, 1, 203])\n+\n+            selection_sort(list_to_sort)\n+            assert all(\n+                'Setting item' in record\n+                for record in list_to_sort._record\n+            )\n+        `)\n+    }\n+)\n+```\n+\n+Your `selection_sort` should follow the selection sort algorithm, swapping the minimum value in unsorted part of the list with first the unsorted element.\n+\n+```js\n+(\n+    {\n+        test: () => runPython(`\n+            from collections import UserList\n+\n+            class CustomList(UserList):\n+                def __init__(self, *args, **kwargs):\n+                    self._record = []\n+                    super().__init__(*args, **kwargs)\n+\n+                def __setitem__(self, key, value):\n+                    self._record.append(f'Setting item {key} to {value}. Previous value: {self[key]}')\n+                    super().__setitem__(key, value)\n+\n+\n+            list_to_sort = CustomList([33, 1, 89, 2, 67, 245])\n+\n+            swap_pairs = [\n+                ((0, 1, 33), (1, 33, 1)),\n+                ((1, 2, 33), (3, 33, 2)),\n+                ((2, 33, 89), (3, 89, 33)),\n+                ((3, 67, 89), (4, 89, 67)),\n+            ]\n+\n+            selection_sort(list_to_sort)\n+            record = list_to_sort._record\n+\n+            actual_pairs = [\n+                (record[offset * 2], record[offset * 2 + 1])\n+                for offset, _ in enumerate(record[::2])\n+            ]\n+            assert len(swap_pairs) == len(actual_pairs)\n+\n+            for expected_pair, actual_pair in zip(swap_pairs, actual_pairs):\n+                assert (\n+                    set(f'Setting item {key} to {value}. Previous value: {old}' for key, value, old in expected_pair)\n+                    == set(actual_pair)\n+                )\n+        `)\n+    }\n+)\n+```\n+\n `selection_sort([33, 1, 89, 2, 67, 245])` should return `[1, 2, 33, 89, 67, 245]`.\n \n ```js"
        }
    ],
    "stats": {
        "total": 107,
        "additions": 107,
        "deletions": 0
    }
}