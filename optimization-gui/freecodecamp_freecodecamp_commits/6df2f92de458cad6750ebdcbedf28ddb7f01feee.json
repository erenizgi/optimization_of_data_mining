{
    "author": "manuuuskp",
    "message": "feat(curriculum): add interactive examples to currying lesson (#64074)",
    "sha": "6df2f92de458cad6750ebdcbedf28ddb7f01feee",
    "files": [
        {
            "sha": "54c11d010ee79a552b5a71d3fffa9f904fed2948",
            "filename": "curriculum/challenges/english/blocks/lecture-understanding-functional-programming/6734061fe116df617a564a37.md",
            "status": "modified",
            "additions": 23,
            "deletions": 5,
            "changes": 28,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6df2f92de458cad6750ebdcbedf28ddb7f01feee/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-functional-programming%2F6734061fe116df617a564a37.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6df2f92de458cad6750ebdcbedf28ddb7f01feee/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-functional-programming%2F6734061fe116df617a564a37.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-functional-programming%2F6734061fe116df617a564a37.md?ref=6df2f92de458cad6750ebdcbedf28ddb7f01feee",
            "patch": "@@ -5,44 +5,62 @@ challengeType: 19\n dashedName: what-is-currying-and-how-does-it-work\n ---\n \n-# --description--\n+# --interactive--\n \n Currying is a technique where we transform a function that takes multiple arguments into a sequence of functions, each taking a single argument.\n \n Let's start with a basic example. Imagine we have a function that adds two numbers:\n \n+:::interactive_editor\n+\n ```js\n function add(a, b) {\n   return a + b;\n }\n \n-console.log(add(3, 4)); // Output: 7\n+console.log(add(3, 4)); // 7\n ```\n \n+:::\n+\n This is a function that takes two arguments and returns their sum. Now, let's see how we can curry this function:\n \n+:::interactive_editor\n+\n ```js\n function curriedAdd(a) {\n   return function(b) {\n     return a + b;\n   }\n }\n \n-console.log(curriedAdd(3)(4)); // Output: 7\n+console.log(curriedAdd(3)(4)); // 7\n ```\n \n+:::\n+\n In this curry converted code, instead of taking two arguments at once, we have a function that takes the first argument and returns another function. This returned function then takes the second argument and performs the addition. We call it like `curriedAdd(3)(4)`, where each pair of parentheses represents a function call.\n \n But why would we want to do this? \n \n Currying allows us to create some special functions easily. For example, we could create a function that always adds five to any number:\n \n+:::interactive_editor\n+\n ```js\n+function curriedAdd(a) {\n+  return function(b) {\n+    return a + b;\n+  }\n+}\n+\n const addFive = curriedAdd(5);\n-console.log(addFive(10)); // Output: 15\n-console.log(addFive(20)); // Output: 25\n+console.log(addFive(10)); // 15\n+console.log(addFive(20)); // 25\n ```\n \n+:::\n+\n Here, `addFive` is a function that's always ready to add five to whatever number we give it. This is a simple example of partial application, where we fix a certain number of arguments to a function, producing another function that takes fewer arguments.\n \n While our examples have focused on functions with two arguments, currying can be applied to functions with any number of arguments."
        }
    ],
    "stats": {
        "total": 28,
        "additions": 23,
        "deletions": 5
    }
}