{
    "author": "moT01",
    "message": "feat(curriculum): add web performance transcripts (#59719)\n\nCo-authored-by: Dario-DC <105294544+Dario-DC@users.noreply.github.com>",
    "sha": "afd483f08238b75bf2cd0383b94a816e55969528",
    "files": [
        {
            "sha": "03952e7e6b8d0b8863e742a8292980af156c4b87",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d1d6af27858c4f487d3f4c.md",
            "status": "modified",
            "additions": 45,
            "deletions": 3,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d1d6af27858c4f487d3f4c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d1d6af27858c4f487d3f4c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d1d6af27858c4f487d3f4c.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,55 @@\n id: 67d1d6af27858c4f487d3f4c\n title: What Is the Difference Between Real Performance and Perceived Performance?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: M-5LrHfhBnI\n dashedName: what-is-the-difference-between-real-performance-and-perceived-performance\n ---\n \n # --description--\n \n-Watch the video lecture and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What is the difference between real performance and perceived performance?\n+\n+When we talk about performance, the term itself can feel a bit subjective, right? What is good performance? What is bad performance?\n+\n+Is there a standard way to measure performance or is it completely dependent on the user's personal preferences and perception? Let's see. \n+\n+We can classify a website's performance into two different categories: perceived performance and real performance.\n+\n+The perceived performance is how users perceive the performance of a website. It's how they evaluate it in terms of responsiveness and reliability. This is a subjective measurement, so it's hard to quantify it, but it's very important, since the user experience determines the success or failure of a website.\n+\n+In contrast, real performance is the objective and measurable performance of the website. It's measured using metrics like page load time, server response time, and rendering time. These measurements are influenced by multiple factors related to the network and to the code itself.\n+\n+Even a website with excellent perceived performance can be further optimized for an even better user experience.\n+\n+There are several techniques for improving perceived performance.\n+\n+Reducing the initial load time as much as possible by loading non-essential resources in the background is essential. This technique is known as \"lazy loading.\" That first impression can determine what users will think about your website.\n+\n+Lazy loading will also impact the real performance of your website. By using this technique, you can reduce the amount of content that has to be loaded upfront, so the page will load faster, which is a real performance metric.\n+\n+It's also very important to provide quick response and feedback to user interactions. \n+\n+For example, showing a loading indicator for a long-running process as soon as the user clicks on an element can help the user feel connected and engaged with the process, making the wait time feel shorter - or at least they'll feel more involved.\n+\n+Keeping users actively engaged with your website is very important for improving their time perception. Displaying text as soon as it arrives is helpful for keeping users engaged from the start, even if other resources, like images, have not been loaded yet.\n+\n+If a user is waiting for a long-running task to be completed, keep them informed on the progress and update it regularly.\n+\n+Another tip is to avoid content reflow and jumping content. For example, when ads or images are being loaded, the website might jump or readjust to make room for these new resources if they don't already have a space in the layout. \n+\n+These sudden changes can result in a bad user experience because users may feel like the website is still loading. To avoid this, plan ahead and assign space for these elements from the start.\n+\n+If your website has custom fonts, you should also try to minimize font loading delays, since this may result in flickering - or showing the fallback font while the custom font is being loaded. A suggestion for this is using a fallback font that is similar to the custom font, so in case this happens, the change will be much more subtle.\n+\n+Also, be sure that the interface elements are active. The user should be able to interact with them with minimal lag.\n+\n+We will go into these techniques in more detail in the next few videos.\n+\n+While real performance is important, perceived performance can have a tremendous impact on user experience. By optimizing for both, you can create websites that are and feel faster, creating a smooth and engaging user experience.\n \n # --questions--\n \n@@ -38,7 +80,7 @@ Think about how a website can be technically fast but feel slow to a user.\n \n ---\n \n-Perceived performance is more important than real performance because it is based on objective system metrics, while real performance is based on the user’s subjective experience.\n+Perceived performance is more important than real performance because it is based on objective system metrics, while real performance is based on the user's subjective experience.\n \n ### --feedback--\n "
        },
        {
            "sha": "663348591aaa8f1f2a86b1cc5fac349c2227c281",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d2f6a63acd9e781b4b5061.md",
            "status": "modified",
            "additions": 76,
            "deletions": 3,
            "changes": 79,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f6a63acd9e781b4b5061.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f6a63acd9e781b4b5061.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f6a63acd9e781b4b5061.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,86 @@\n id: 67d2f6a63acd9e781b4b5061\n title: What Are the Key Performance Concepts?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: wLaVahHQB44\n dashedName: what-are-the-key-performance-concepts\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What are the key performace concepts?\n+\n+Why do some websites feel snappy and responsive, while others feel sluggish? The answer lies in key performance concepts that affect how a page loads and renders. Understanding key web performance concepts is essential for building fast, smooth, and user-friendly websites. \n+\n+Let's break down source order, the critical rendering path, latency, and more.\n+\n+Let's look at source order first.\n+\n+Source order refers to the way HTML elements are structured in the document. This determines what loads first and can significantly impact performance and accessibility.\n+\n+Some best practices for this include:\n+\n+- Placing critical content such as headings, navigation or main text higher in the HTML structure.\n+\n+- Deferring non-essential scripts such as ones for analytics, or third-party widgets, so they don't block rendering.\n+\n+- Using progressive enhancement, to ensure the core experience works even before styles and scripts load. Progressive enhancement is a way of building websites and applications based on the idea that you should make your page work with HTML first.\n+\n+Here is an example of good source order, using the best practices we just went through.\n+\n+```html\n+<!-- Good source order: Essential content first -->\n+<h1>Welcome to FastSite!</h1>\n+<p>Critical information loads first.</p>\n+<script src=\"slow-script.js\" defer></script>\n+```\n+\n+By optimizing source order, we make sure users see important content as soon as possible.\n+\n+Now let's look at critical rendering path.\n+\n+The critical rendering path is the sequence of steps the browser follows to convert code into pixels on the screen.\n+\n+Here are the key steps that we will go into later:\n+\n+1. Parsing HTML: Builds the DOM (Document Object Model)\n+\n+2. Parsing CSS: Builds the CSSOM (CSS Object Model)\n+\n+3. JavaScript Execution: Can modify the DOM & CSSOM\n+\n+4. Render Tree Construction: Combines the DOM & CSSOM\n+\n+5. Layout & Painting: Determines element sizes & draws pixels\n+\n+6. Optimizations:\n+\n+    - Minimize render-blocking resources (e.g., large CSS files, unused JS).\n+\n+    - Use async and defer attributes for scripts:\n+\n+    - Load only essential styles first; defer non-critical CSS.\n+\n+Overall, a shorter critical rendering path equals a faster perceived performance. We will go into this in more detail later on.\n+\n+And finally, let's look at latency.\n+\n+Latency is the time it takes for a request to travel between the browser and the server. So in other words, high latency equals slow pages.\n+\n+Some ways of reducing latency include:\n+\n+- Using CDNs, or in other words, Content Delivery Networks, to serve files from closer locations.\n+\n+- Enabling compression using things such as Gzip to reduce file sizes.\n+\n+- Optimizing images and using lazy loading - which we will also go into later.\n+\n+By reducing latency, we make interactions feel instant.\n+\n+So in conclusion, by optimizing source order, reducing the critical path, and cutting down latency, you can make your website feel fast.\n \n # --questions--\n \n@@ -110,7 +183,7 @@ Think about how long it takes for data to travel between the server and the user\n \n ---\n \n-The size of a website’s JavaScript files.\n+The size of a website's JavaScript files.\n \n ### --feedback--\n "
        },
        {
            "sha": "76954c91efaff04706157c677f41d348a295eb6c",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d2f6b17844ae7898583eb3.md",
            "status": "modified",
            "additions": 18,
            "deletions": 2,
            "changes": 20,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f6b17844ae7898583eb3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f6b17844ae7898583eb3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f6b17844ae7898583eb3.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,29 @@\n id: 67d2f6b17844ae7898583eb3\n title: What Is INP?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: 9p6a5D2uofk\n dashedName: what-is-inp\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What is INP?\n+\n+Have you ever clicked on a webpage and felt like nothing happened? This delay impacts user experience and is measured by a metric called Interaction to Next Paint, or INP.\n+\n+INP assesses a page's overall responsiveness by measuring the time from when a user interacts — like a click or key press — to the next time the browser updates the display. A lower INP indicates a more responsive page.\n+\n+But why is INP important? A high INP can make users feel that a page is unresponsive, leading to frustration. Optimizing INP ensures that users receive timely feedback, enhancing their experience.\n+\n+Tools like Chrome's DevTools and web performance APIs can help measure INP by tracking interaction delays.\n+\n+To improve INP, minimize main thread work, optimize event handlers, and ensure that user interactions trigger timely visual updates.\n+\n+By understanding and optimizing INP, you can create web experiences that feel fast and responsive, keeping your users satisfied.\n \n # --questions--\n "
        },
        {
            "sha": "a5e15341a911ef37fce9913542e03dd63ea4c58c",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d2f6cea4916d78d5a27ad3.md",
            "status": "modified",
            "additions": 24,
            "deletions": 2,
            "changes": 26,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f6cea4916d78d5a27ad3.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f6cea4916d78d5a27ad3.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f6cea4916d78d5a27ad3.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,35 @@\n id: 67d2f6cea4916d78d5a27ad3\n title: How to Measure and Improve INP?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: KLnrGBW0F8M\n dashedName: how-to-measure-and-improve-inp\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How to measure INP and improve INP?\n+\n+Let's walk through a practical way to measure Interaction to Next Paint, or INP, using Chrome DevTools.\n+\n+First of all, let's open DevTools by pressing \"F12\" or Right-click and click on \"Inspect\".\n+\n+Now, let's say you have a search bar on your webpage.\n+\n+Imagine a user types a query, but it takes 600ms before the suggestion dropdown appears. Chrome DevTools would mark this high INP value.\n+\n+You can optimize by deferring heavy JavaScript, reducing long tasks, and improving event handling. The INP would then drop to 150ms, making interactions feel instant.\n+\n+Cool, right?\n+\n+Now, let's look at a practical measurement technique that helps identify interaction delays so you can create a faster and smoother user experience!\n+\n+First, we would open Chrome DevTools. We would do so, once again, by opening Google Chrome, navigating to a webpage that we want to analyze, and pressing \"F12\" or right-clicking the page and clicking \"Inspect\". Now, let's head to the \"Performance\" tab - and there is everything that you need.\n+\n+Now we are ready to identify the Interaction to Next Paint, or INP. We are going to look for the longest interaction delay recorded. A good INP is generally below 200ms, and a poor INP is above 500ms. And that's it!\n \n # --questions--\n "
        },
        {
            "sha": "d9911b00a3c31a41539f671d782241561c94cbc5",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d2f6e2836565795d789ab7.md",
            "status": "modified",
            "additions": 54,
            "deletions": 2,
            "changes": 56,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f6e2836565795d789ab7.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f6e2836565795d789ab7.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f6e2836565795d789ab7.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,65 @@\n id: 67d2f6e2836565795d789ab7\n title: How Does a Browser Render a Page?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: Fe2bWQjJS68\n dashedName: how-does-a-browser-render-a-page\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How does a browser render a page?\n+\n+Have you ever wondered what happens behind the scenes when you enter a URL and press enter? How does the browser transform code into the interactive pages we see?\n+\n+Understanding how a browser renders a web page is essential for developers aiming to optimize performance and enhance user experience.\n+\n+In this video, we'll demystify the rendering process, breaking it down into clear, digestible steps.\n+\n+First the browser parses the HTML and builds the DOM.\n+\n+The process begins with the browser fetching the HTML content of the page. It parses this HTML to construct the Document Object Model, or DOM — a tree-like structure representing the page's content.\n+\n+Consider this simple HTML snippet:\n+\n+```html\n+<html>\n+  <body>\n+    <h1>Hello, World!</h1>\n+    <p>Welcome to our website.</p>\n+  </body>\n+</html>\n+```\n+\n+The browser parses this to create a DOM tree with `html` as the root, containing `body`, which in turn contains `h1` and `p` elements.\n+\n+Next, the browser processes the CSS, constructing the CSS Object Model, or CSSOM. This is another tree structure that dictates how elements should be styled.\n+\n+Given this CSS:\n+\n+```css\n+h1 {\n+  color: blue;\n+}\n+p {\n+  font-size: 16px;\n+}\n+```\n+\n+The CSS Object Model specifies that `h1` elements are blue and `p` elements have a font size of 16 pixels.\n+\n+The browser then combines the DOM and CSS Object Model to form the render tree. This tree includes only the nodes needed to render the page, each paired with its corresponding styles.\n+\n+For our example, the render tree consists of the `h1` and `p` elements, styled appropriately.\n+\n+With the render tree in hand, the browser calculates the exact position and size of each element in a process called layout or reflow. This ensures that elements appear in the correct location and dimensions on the screen.\n+\n+Finally, the browser paints the pixels to the screen, rendering each element based on the calculated styles and layout. In complex pages, this might involve multiple layers that are composited together to form the final visual output.\n+\n+In conclusion, from parsing HTML and CSS to painting pixels on the screen, the browser's rendering process is a sophisticated sequence of steps.\n \n # --questions--\n "
        },
        {
            "sha": "847997c273ce6ad0247140667e226963acdbf1c5",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d2f70278179479d3eed390.md",
            "status": "modified",
            "additions": 63,
            "deletions": 2,
            "changes": 65,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f70278179479d3eed390.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f70278179479d3eed390.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f70278179479d3eed390.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,74 @@\n id: 67d2f70278179479d3eed390\n title: How Does Performance Impact Sustainability?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: lDI5MP59Tn0\n dashedName: how-does-performance-impact-sustainability\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How does performance impact sustainability?\n+\n+Improving web performance is crucial for delivering a fast and efficient user experience. But did you know that optimizing your website's performance doesn't just improve speed — it also helps the environment?\n+\n+Every time a page loads, energy is consumed. And when sites are inefficient, they use more resources, leading to higher carbon emissions.\n+\n+Let's break down how performance impacts sustainability and show you practical ways to optimize your code for a greener web.\n+\n+The internet accounts for around 2% of global carbon emissions — that's the same as the airline industry! Every byte transferred requires electricity, from data centers to user devices. Larger files and inefficient scripts mean more power consumption. A high-performance website isn't just faster, it also reduces unnecessary processing and energy use.\n+\n+Here's an example of inefficient JavaScript:\n+\n+```js\n+// Inefficient JavaScript\n+function fetchData() {\n+    for (let i = 0; i < 1000000; i++) {\n+        console.log(\"Processing...\");\n+    }\n+    fetch(\"https://api.example.com/data\")\n+        .then(response => response.json())\n+        .then(data => console.log(data));\n+}\n+fetchData();\n+```\n+\n+This script runs excessive console logs, wasting CPU cycles and energy.\n+\n+Now, let's optimize it:\n+\n+```js\n+// Optimized JavaScript\n+async function fetchDataOptimized() {\n+    const response = await fetch(\"https://api.example.com/data\");\n+    const data = await response.json();\n+    console.log(data);\n+}\n+fetchDataOptimized();\n+```\n+\n+By removing unnecessary loops and using `async`/`await`, we lower processing time and energy consumption.\n+\n+Here are some practical optimization tips you can use in your future projects.\n+\n+1. Minify Your Assets: Use tools like Terser or UglifyJS to shrink JavaScript and CSS files. Smaller files load faster and require less energy.\n+\n+2. Optimize Images: Use next-gen formats like WebP instead of PNGs or JPEGs to reduce file size without quality loss.\n+\n+3. Reduce Network Requests: Each request adds overhead. Combine CSS and JavaScript files and use lazy loading to reduce load times.\n+\n+4. Use Efficient Algorithms: A poorly optimized loop can increase CPU usage. This is the same as writing inefficient JavaScript that we saw in the example previously.\n+\n+5. Leverage Caching & CDNs: Caching prevents repeated downloads, and CDNs deliver content closer to users, reducing transmission energy.\n+\n+And now, what if you want to measure your impact and just how green your site is?\n+\n+Use tools like Google Lighthouse to analyze performance and estimate energy savings. Or, for a deeper sustainability check, try the Website Carbon Calculator — as it estimates your page's environmental impact.\n+\n+In conclusion, by understanding and implementing these performance fundamentals, developers can create web applications that are not only faster and more responsive but also more sustainable.\n \n # --questions--\n "
        },
        {
            "sha": "b8127a01d7b51ae7526119072f9fe09e26ec63c4",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d2f7183a537d7a4908a9ff.md",
            "status": "modified",
            "additions": 44,
            "deletions": 2,
            "changes": 46,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f7183a537d7a4908a9ff.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f7183a537d7a4908a9ff.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f7183a537d7a4908a9ff.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,55 @@\n id: 67d2f7183a537d7a4908a9ff\n title: What Are Some Ways to Reduce Page Loading Times?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: FITz3jKCZyI\n dashedName: what-are-some-ways-to-reduce-page-loading-times\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What are some ways to reduce page loading times?\n+\n+Have you ever left a website because it took too long to load? Slow page loading can frustrate users and increase bounce rates. Today, we'll explore practical ways to reduce page loading times, ensuring your audience stays engaged.\n+\n+Number 1: optimize media assets. Large images and videos are common culprits for slow load times. By optimizing these assets, you can significantly speed up your site:\n+\n+- Compress Images: Use tools like TinyPNG to reduce image file sizes without compromising quality.\n+\n+- Use Modern Formats: Implement formats like WebP for images and AV1 for videos to achieve better compression rates.\n+\n+- Lazy Loading: Defer loading off-screen images and videos until they're needed. In HTML, add the `loading=\"lazy\"` attribute to your media tags.\n+\n+Next, we have minimize HTTP requests. Each file your website requests adds to the load time. Reducing the number of HTTP requests can lead to faster page loads. You can:\n+\n+- Combine Files: Merge CSS and JavaScript files to reduce the number of requests.\n+\n+- Use Inline Critical CSS: Place essential CSS directly in the HTML to speed up initial rendering.\n+\n+- Use CSS Sprites: Combine multiple images into a single sprite sheet to minimize requests.\n+\n+And, of course, you can Leverage Browser Caching. Caching allows browsers to store parts of your website locally, reducing load times for returning visitors:\n+\n+- Set Expiry Headers: Use the `Cache-Control` header to specify how long browsers should keep files.\n+\n+- Version Assets: When updating files, change their names or use query strings to ensure browsers fetch the latest versions.\n+\n+You can do this along with minifying and Compressing files, which will reduce the size of your files can lead to quicker downloads:\n+\n+- Minify CSS and JavaScript: Remove unnecessary whitespace and comments using tools like UglifyJS for JavaScript and cssnano for CSS.\n+\n+- Enable Compression: Configure your server to use Gzip to reduce the size of transmitted files.\n+\n+You can also optimize web fonts. Web fonts can enhance design but may also slow down your site if not handled properly:\n+\n+- Limit Font Variants: Only include the character sets and styles you need.\n+\n+- Use `font-display`: Control how fonts are displayed during loading by setting the `font-display` property in your CSS.\n+\n+So in conclusion, by implementing all these strategies, you can significantly reduce your page loading times, leading to a better user experience and improved site performance.\n \n # --questions--\n "
        },
        {
            "sha": "3e5397ed4065d82d735158d23ab39cdaa4e44e9f",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d2f738dcef5d7abfe4243a.md",
            "status": "modified",
            "additions": 59,
            "deletions": 2,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f738dcef5d7abfe4243a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f738dcef5d7abfe4243a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f738dcef5d7abfe4243a.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,70 @@\n id: 67d2f738dcef5d7abfe4243a\n title: How Do You Improve \"Time to Usable\"?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: 4Vq6Czl0fJQ\n dashedName: how-do-you-improve-time-to-usable\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How do you improve time to usable?\n+\n+Improving the \"time to usable\", or in other words the interval from when a user requests a page to when they can meaningfully interact with it, is crucial for enhancing user experience.\n+\n+Let's explore effective strategies to achieve a faster time to usable.\n+\n+Begin by focusing on the content that the user sees first. This means loading essential elements immediately and deferring non-critical components.\n+\n+For example, you could try to implement lazy loading.\n+\n+We have already covered lazy loading, but here is an example of lazy load images as a refresher:\n+\n+```html\n+<img src=\"image.jpg\" loading=\"lazy\" alt=\"Description\">\n+```\n+\n+All you need to do is add the `loading=\"lazy\"` attribute to image tags. This defers the loading of images until they are needed, typically when they enter the user's viewport. By loading images and videos only when they enter the viewport, we are conserving bandwidth as well as causing the speed up of initial rendering.\n+\n+Normally, a webpage loads all images at once, even those not visible on the screen. With lazy loading, images below the fold, or in other words off-screen, they are only loaded when the user scrolls down to them.\n+\n+And here is an example of lazy load iframes:\n+\n+```html\n+<iframe src=\"video.html\" loading=\"lazy\"></iframe>\n+```\n+\n+You can apply the same attribute that you did before, but this time to iframes, and the same concept will apply.\n+\n+You can also use the `defer` attribute to delay non-critical JavaScript until after the initial page load. Here is an example of us doing just that:\n+\n+```html\n+<script src=\"non-critical.js\" defer></script>\n+```\n+\n+You could also consider minimizing render-blocking resources.\n+\n+Render-blocking resources delay the page from becoming interactive.\n+\n+To avoid this, you could try loading CSS asynchronously. For non-critical CSS, use the `media` attribute to load stylesheets conditionally. Here is an example of us doing just that:\n+\n+```html\n+<link rel=\"stylesheet\" href=\"print.css\" media=\"print\">\n+```\n+\n+By specifying media value as `print`, the `print.css` will only be loaded when the page is printed or previewed on screen. In this next example, by passing `min-width: 800px` as the value to the `media` attribute, we are saying we only want `desktop.css` to load for screens wider than 800px:\n+\n+```html\n+<!-- This stylesheet is only loaded on screens wider than 800px -->\n+<link rel=\"stylesheet\" href=\"desktop.css\" media=\"(min-width: 800px)\">\n+```\n+\n+This saves bandwidth by skipping unnecessary styles.\n+\n+So, in conclusion, by implementing these strategies, you can significantly reduce the \"time to usable\" for your website, ensuring users can interact with your content promptly.\n \n # --questions--\n "
        },
        {
            "sha": "72d506f2233ea4270519a5031f6255b1a345f146",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d2f759154eac7b4d5cb1bf.md",
            "status": "modified",
            "additions": 59,
            "deletions": 2,
            "changes": 61,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f759154eac7b4d5cb1bf.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f759154eac7b4d5cb1bf.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f759154eac7b4d5cb1bf.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,70 @@\n id: 67d2f759154eac7b4d5cb1bf\n title: How to Improve the Perceived Performance of Features?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: MDluSIaTrKw\n dashedName: how-to-improve-the-perceived-performance-of-features\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How to improve the perceived performance of features?\n+\n+As we know, perceived performance isn't just about how fast a site actually is — it's about how fast it feels to users. So, for example, if you have ever used a website that felt slow, even though it wasn't? That's perceived performance — how fast a site feels to the user.\n+\n+Small tweaks can make a huge difference in the user experience. Let's explore some practical ways to improve perceived performance!\n+\n+Spinners can make users feel like they're waiting longer than they actually are. Instead, try skeleton screens — gray placeholders that mimic real content and gradually load in:\n+\n+```html\n+<div class=\"skeleton\"></div>\n+<script>\n+  setTimeout(() => {\n+    document.querySelector(\".skeleton\").innerHTML = \"✅ Content Loaded!\";\n+  }, 2000);\n+</script>\n+```\n+\n+Users feel like the page is loading progressively, rather than waiting in the dark.\n+\n+In addition to this, users shouldn't have to wait for everything to load before they can start interacting. Load important content first, then load the rest in the background. We looked at this previously with lazy loading:\n+\n+```html\n+<img src=\"placeholder.jpg\" data-src=\"real-image.jpg\" class=\"lazy\">\n+<script>\n+  document.addEventListener(\"DOMContentLoaded\", function () {\n+    const lazyImages = document.querySelectorAll(\"img.lazy\");\n+    lazyImages.forEach(img => {\n+      img.src = img.dataset.src;\n+    });\n+  });\n+</script>\n+```\n+\n+This makes the page feel responsive, even if not everything has loaded yet.\n+\n+Now - what if your site could predict what the user will click next? With preloading, you can fetch the next page before they request it:\n+\n+```html\n+<link rel=\"preload\" href=\"next-page.html\" as=\"document\">\n+```\n+\n+This reduces perceived loading time to near zero when users navigate.\n+\n+And finally, users don't like uncertainty. When they click a button, acknowledge their action instantly:\n+\n+```html\n+<button onclick=\"this.innerText='⏳ Processing...'; setTimeout(() => this.innerText='✅ Done!', 2000);\">\n+  Click Me\n+</button>\n+```\n+\n+This means that, even if there's a delay, the user feels like something is happening.\n+\n+So, in conclusion, improving perceived performance isn't just about raw speed, it's about how speed feels to the user. Use skeleton screens, prioritize important content, preload smartly, and give instant feedback to make your site feel faster.\n \n # --questions--\n "
        },
        {
            "sha": "81e5a69ff43b6ca1181bdb5705bdac632cc8d627",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d2f778a856c37bd31c5022.md",
            "status": "modified",
            "additions": 38,
            "deletions": 2,
            "changes": 40,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f778a856c37bd31c5022.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f778a856c37bd31c5022.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f778a856c37bd31c5022.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,49 @@\n id: 67d2f778a856c37bd31c5022\n title: What Are Some Key Metrics for Measuring Performance?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: 8hAnuI_pXqo\n dashedName: what-are-some-key-metrics-for-measuring-performance\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What are some key metrics for measuring performace?\n+\n+To measure and improve web performance, we use key performance metrics like First Contentful Paint (or FCP), Speed Index, Total Blocking Time (or TBT), Bounce Rate, and Unique Users. Let's look at all of these metrics individually.\n+\n+First Contentful Paint, or FCP. This measures how quickly the first piece of content, like a text or image, appears on the screen. A good FCP is regarded as a time below 1.8 seconds, and a poor FCP is usually above 3 seconds. You can check your FCP using Chrome DevTools like this:\n+\n+Step 1: Open Chrome DevTools\n+\n+- Open Google Chrome.\n+\n+- Go to the webpage you want to test.\n+\n+- Press \"F12\" or Right-click and \"Inspect\".\n+\n+Step 2: Find and click the \"Lighthouse\" tab in the DevTools.\n+\n+Step 3: Click the \"Analyze page load\" button and wait for the analyzation to finish.\n+\n+Now we can analyze the results. We do this by scrolling down to the \"Metrics\" section and looking for the \"First Contentful Paint\" marker. We can see the exact time in milliseconds or seconds.\n+\n+FCP and Interaction to Next Paint (or INP), that we looked at previously, are both performance metrics, but they measure different aspects of user experience. It's important not to get them mixed up.\n+\n+As a reminder, FCP is about how fast users see content after loading, and INP is about how fast users see feedback after clicking or typing.\n+\n+Next we have the Speed Index.\n+\n+Speed Index measures how quickly visible parts of the page are painted. Lower scores mean better performance! You can check your Speed Index in the Lighthouse Reports.\n+\n+We also have Total Blocking Time or TBT. This shows how long the main thread is blocked by heavy JavaScript tasks. If TBT is high, users experience laggy interactions. To improve TBT, break up long tasks and defer non-essential scripts.\n+\n+Next we have the Bounce Rate. This is the percentage of visitors who leave without interacting. If your site has high bounce rates, it might be because your page is too slow.\n+\n+And finally we have unique users. This metric tracks how many individual visitors come to your site. To view the bouce rate and unique users, you can use Google Analytics. It will allow you to monitor these metrics and improve engagement.\n \n # --questions--\n "
        },
        {
            "sha": "8429ac55d5ffae37faa071f53cfbae10c93ef01e",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d2f7a69809807c59a44002.md",
            "status": "modified",
            "additions": 28,
            "deletions": 2,
            "changes": 30,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f7a69809807c59a44002.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f7a69809807c59a44002.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f7a69809807c59a44002.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,39 @@\n id: 67d2f7a69809807c59a44002\n title: What Are Some Common Performance Measurement Tools?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: sFj8e9ilwzM\n dashedName: what-are-some-common-performance-measurement-tools\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What are some common performance measurement tools?\n+\n+If you want to make your website faster and more responsive, you need the right tools to measure and optimize performance. Let's explore some common performance measurement tools and how they help.\n+\n+First up, we have Chrome DevTools.\n+\n+Chrome DevTools is a built-in tool inside Google Chrome that lets you analyze and debug performance in real-time. DevTools will show loading times, CPU usage, and render delays. It's especially useful for measuring First Contentful Paint, or FCP, which we know by now, is how fast a user sees the first visible content. If your website feels slow, DevTools will help you spot the bottlenecks.\n+\n+Next up, Lighthouse.\n+\n+Lighthouse is an automated tool that checks performance, SEO, and accessibility. To use it, simply open Chrome DevTools and go to the \"Lighthouse\" tab. Next, click \"Analyze page load\" and it will give you a score on how fast and optimized your site is, as well as provide recommendations to improve it. If you want a quick performance audit, Lighthouse is your go-to tool.\n+\n+Now, let's talk about WebPageTest.\n+\n+WebPageTest lets you test how your site loads from different locations and devices. All you have to do is visit WebPageTest.org, enter your website URL, choose a test location and browser and click \"Start Test\". It gives a detailed breakdown of your site's Speed Index, Total Blocking Time, and other key performance metrics. If you want to know how real users experience your site globally, WebPageTest is the tool for that.\n+\n+Another great tool is Google PageSpeed Insights.\n+\n+This tool analyzes your website and suggests quick improvements for both mobile and desktop. Just go to PageSpeed Insights, enter your URL, and click \"Analyze\". It will tell you what's slowing your site down and give specific recommendations — like optimizing images, removing render-blocking scripts, and reducing server response times. PageSpeed Insights is a fast and easy way to check how Google sees your site's performance.\n+\n+Lastly, let's talk about Real User Monitoring, or RUM tools. Unlike lab tests, RUM tools track actual user behavior, showing how real visitors experience your site. Popular RUM tools include Google Analytics, which tracks page load times and bounce rates. And New Relic or Datadog, which Monitors real-time performance issues. If you want data from actual users, RUM tools are essential.\n+\n+Each tool has different strengths, so use a combination to get the best insights. Start by testing with Chrome DevTools or Lighthouse, then dive deeper with WebPageTest and RUM tools.\n \n # --questions--\n "
        },
        {
            "sha": "c943b11c3cd58bba2a7cae871bc6a0481ede11f5",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d2f7cf63fafe7d20270498.md",
            "status": "modified",
            "additions": 89,
            "deletions": 3,
            "changes": 92,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f7cf63fafe7d20270498.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f7cf63fafe7d20270498.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f7cf63fafe7d20270498.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,99 @@\n id: 67d2f7cf63fafe7d20270498\n title: How Can You Use Performance Web APIs to Create Your Own Performance Measurement Tools?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: sUz4sM4gZZ0\n dashedName: how-can-you-use-performance-web-apis-to-create-your-own-performance-measurement-tools\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How can you use performace web APIs to create your own performance measurement tools?\n+\n+While tools like Lighthouse and Chrome DevTools are great, sometimes you need custom insights tailored to your site.\n+\n+That's where Performance Web APIs come in!\n+\n+In this video, we'll break down how to use three key Web APIs to measure and analyze your website's speed.\n+\n+But first, what are Performance Web APIs? \n+\n+Performance Web APIs let developers track how efficiently a webpage loads and responds, directly from code. These APIs allow you to measure page load times, track rendering and interaction delays and analyze JavaScript execution time.\n+\n+With these APIs, you can build your own performance monitoring tools without relying on third-party software!\n+\n+Let's explore three powerful Web APIs you can use today.\n+\n+First up, `performance.now()`.\n+\n+This API gives you high-precision timestamps (in milliseconds) to measure how long different parts of your site take to load.\n+\n+Let's say you want to measure how fast a function runs:\n+\n+```js\n+const start = performance.now();  \n+// Run some code here  \n+const end = performance.now();  \n+\n+console.log(`Execution time: ${end - start}ms`);\n+```\n+\n+This is more accurate than using `Date.now()` because it measures time in microseconds, avoiding clock drift issues. You can use it to track script execution time, event response delays and animation performance.\n+\n+Next, the Performance Timing API.\n+\n+This API gives you a breakdown on every single stage of page loading, from DNS lookup to `DOMContentLoaded`.\n+\n+Want to measure how long your page takes to fully load?\n+\n+```js\n+let [navigationTiming] = performance.getEntriesByType(\"navigation\");\n+\n+if (navigationTiming instanceof PerformanceNavigationTiming) {\n+  // Calculate time from navigation start to DOM content loaded\n+  const pageLoadTime =\n+    navigationTiming.domContentLoadedEventEnd - navigationTiming.startTime;\n+\n+  console.log(\"DOM Content Loaded Time:\", pageLoadTime, \"ms\");\n+}\n+```\n+\n+Key metrics you can track with this API are DNS lookup time - or in other words the connection speed, Time to First Byte (TTFB) - or server response speed, and  `DOMContentLoaded` - or in other words, when the page is ready for interaction.\n+\n+If your page load times are slow, this API pinpoints exactly where the delay happens!\n+\n+And finally, let's talk about `PerformanceObserver`.\n+\n+This API listens for performance events such as layout shifts, long tasks, and user interactions.\n+\n+Want to monitor long-running JavaScript tasks?\n+\n+```js\n+const observer = new PerformanceObserver((list) => {  \n+  list.getEntries().forEach((entry) => {  \n+    console.log(`Long task detected: ${entry.duration}ms`);  \n+  });  \n+});  \n+\n+observer.observe({ type: \"longtask\", buffered: true });\n+```\n+\n+And what can this API track? Well, it can track long tasks - or in other words, JavaScript that blocks rendering, layout shifts to detect UI jank, and First Input Delay (FID) - or how fast a page responds to user input.\n+\n+If you want real-time performance tracking, this API is a game-changer.\n+\n+So, which API should you use? Here's a quick comparison:\n+\n+| Performance API        | Best For                                           |\n+| :--------------------- | :------------------------------------------------- |\n+| `performance.now()`    | Precise timing of functions and scripts            |\n+| Performance Timing API | Measuring full page load performance               |\n+| Performance Observer   | Real-time monitoring of interactions and rendering |\n+\n+By combining these APIs, you can build your own performance measurement tools and track exactly what matters for your site most.\n \n # --questions--\n \n@@ -30,7 +116,7 @@ Think about why precision matters when measuring speed.\n \n ---\n \n-It measures system memory usage, including the browser’s memory footprint.\n+It measures system memory usage, including the browser's memory footprint.\n \n ### --feedback--\n "
        },
        {
            "sha": "baaf35da8ee3835fa8ffb87a85d1e09a21a0f552",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d2f7e9d895bf7dcef00408.md",
            "status": "modified",
            "additions": 40,
            "deletions": 2,
            "changes": 42,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f7e9d895bf7dcef00408.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f7e9d895bf7dcef00408.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f7e9d895bf7dcef00408.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,51 @@\n id: 67d2f7e9d895bf7dcef00408\n title: What Are Some Techniques for Improving CSS Performance?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: LmcHZXY1NLw\n dashedName: what-are-some-techniques-for-improving-css-performance\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+Let's review some important techniques for improving CSS performance specifically.\n+\n+Every project is unique and you should carefully consider which ones of these techniques will be most helpful for your web application.\n+\n+First, since all styles are parsed, you should remove any unnecessary styles from your CSS stylesheets.\n+\n+You should also split your CSS styles into multiple files. This way, if a file is not required to render a specific web page, it will not be loaded and it won't block the rendering process.\n+\n+By default, the browser assumes that all stylesheets should block the rendering process. But you can tell the browser when a stylesheet should be loaded by using the `media` attribute and a media query. \n+\n+In this example, the `print.css` stylesheet will only be applied when the document is being printed because it has the `media` attribute with the value `print`:\n+\n+```html\n+<link rel=\"stylesheet\" href=\"print.css\" media=\"print\" />\n+```\n+\n+You can also minify your CSS files automatically to reduce their size during the build process and compress these files in the server where you host your web application.\n+\n+Try to keep your CSS selectors as simple as possible and don't try to select more elements than necessary.\n+\n+Take advantage of the cascading nature of CSS whenever possible. Some styles will be inherited.\n+\n+Preloading resources with `rel=\"preload\"` is another important technique. Critical assets should be loaded first.\n+\n+Remember that CSS animations can have an impact on performance.\n+\n+Animating certain CSS properties, such as dimensions, position, and layout, triggers a process called \"reflow,\" during which the browser recalculates the position and geometry of certain elements on the page. This requires a repaint, which is computationally expensive.\n+\n+Therefore, it's recommended to reduce the number of CSS animations as much as possible or at least give the user an option to toggle them on or off.\n+\n+And even though fonts can enhance the visual presentation of your web application, they can have an impact on performance. Some fonts have large files, up to multiple megabytes. Try to use two or three fonts at most and use web-safe fonts whenever possible.\n+\n+You may also consider preloading the most important fonts to have them ready for quick use.\n+\n+These are some of the most important and commonly used techniques for optimizing CSS in web development. By incorporating them, you can optimize your website's performance to create a smooth user experience.\n \n # --questions--\n "
        },
        {
            "sha": "610e518a15e1f36609ce98690082f5cdaec2b953",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-performance-in-web-applications/67d2f80313efe77e43182e86.md",
            "status": "modified",
            "additions": 38,
            "deletions": 2,
            "changes": 40,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f80313efe77e43182e86.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/afd483f08238b75bf2cd0383b94a816e55969528/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f80313efe77e43182e86.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-performance-in-web-applications%2F67d2f80313efe77e43182e86.md?ref=afd483f08238b75bf2cd0383b94a816e55969528",
            "patch": "@@ -2,13 +2,49 @@\n id: 67d2f80313efe77e43182e86\n title: What Are Some Techniques for Improving JavaScript Performance?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: dQHwpQos4vk\n dashedName: what-are-some-techniques-for-improving-javascript-performance\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+Let's review some of the most important techniques for improving JavaScript performance specifically.\n+\n+You may find this surprising, but the first technique is using less JavaScript whenever possible.\n+\n+If you're developing a simple static website, you may be able to do exactly the same without frameworks that rely on JavaScript.\n+\n+You should also try to remove any unused JavaScript code and use simpler solutions, if possible.\n+\n+For example, you may consider using built-in browser features instead of custom ones. These built-in browser features include form validation, the browser's built-in video player, and CSS animations instead of custom JavaScript animations.\n+\n+Use as few animations as possible.\n+\n+Reduce the amount of DOM manipulation on your JavaScript code, since this is computationally expensive.\n+\n+Splitting your JavaScript code into modules that perform critical and non-critical tasks is also helpful. This way, you'll be able to preload the critical ones as soon as possible and defer the non-critical ones to render the page as fast as possible.\n+\n+Pre-loading files does not guarantee that they will be available when you use them, but the download will start sooner, so the overall waiting time should be shorter.\n+\n+Once your code is split into multiple files, you can minify them automatically during the build process to reduce their size and optimize their load time.\n+\n+If an event listener is no longer necessary, you should remove it:\n+\n+```js\n+element.removeEventListener(\"mousemove\", handleMouseMove);\n+```\n+\n+In this example, we remove the event listener for the `mousemove` event, so the `handleMouseMove` function is no longer called when the event is triggered. If you keep the event listener, the program will continue performing calculations that are no longer necessary, affecting the overall performance. This effect will be even more noticeable if you have multiple active event listeners simultaneously.\n+\n+And since we're on the topic of events, it's recommended to use event delegation whenever possible.\n+\n+This means that you don't need to set the event listeners on individual child elements. You can set it directly on the parent and the event will bubble up until it finds a parent that can handle it.\n+\n+Optimizing JavaScript is crucial for developing fast and responsive web applications. In a real-world project, you'll constantly analyze the performance of your website to find areas for improvement.\n \n # --questions--\n "
        }
    ],
    "stats": {
        "total": 706,
        "additions": 675,
        "deletions": 31
    }
}