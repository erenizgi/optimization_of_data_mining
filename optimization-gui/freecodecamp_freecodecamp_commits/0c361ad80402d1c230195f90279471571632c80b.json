{
    "author": "ojeytonwilliams",
    "message": "refactor: use observer pattern to play scene (#57324)\n\nCo-authored-by: Naomi <commits@nhcarrigan.com>",
    "sha": "0c361ad80402d1c230195f90279471571632c80b",
    "files": [
        {
            "sha": "81ecbcef6089e277d8553040ea9c6d22a711072b",
            "filename": "client/src/templates/Challenges/components/scene/scene-subject.tsx",
            "status": "added",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/0c361ad80402d1c230195f90279471571632c80b/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fscene%2Fscene-subject.tsx",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/0c361ad80402d1c230195f90279471571632c80b/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fscene%2Fscene-subject.tsx",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fscene%2Fscene-subject.tsx?ref=0c361ad80402d1c230195f90279471571632c80b",
            "patch": "@@ -0,0 +1,22 @@\n+type Observer = () => void;\n+\n+export class SceneSubject {\n+  #observers: Observer[];\n+  constructor() {\n+    this.#observers = [];\n+  }\n+\n+  attach(observer: Observer) {\n+    this.#observers.push(observer);\n+  }\n+\n+  detach(observer: Observer) {\n+    this.#observers = this.#observers.filter(obs => obs !== observer);\n+  }\n+\n+  // For now, we don't need to pass any data to the observers, so notify()\n+  // doesn't take any arguments.\n+  notify() {\n+    this.#observers.forEach(observer => observer());\n+  }\n+}"
        },
        {
            "sha": "ed4108a6c9b4d3072434f5b96ee9ab5a30816481",
            "filename": "client/src/templates/Challenges/components/scene/scene.tsx",
            "status": "modified",
            "additions": 145,
            "deletions": 122,
            "changes": 267,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/0c361ad80402d1c230195f90279471571632c80b/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fscene%2Fscene.tsx",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/0c361ad80402d1c230195f90279471571632c80b/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fscene%2Fscene.tsx",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Ftemplates%2FChallenges%2Fcomponents%2Fscene%2Fscene.tsx?ref=0c361ad80402d1c230195f90279471571632c80b",
            "patch": "@@ -1,11 +1,12 @@\n-import React, { useEffect, useState, useRef } from 'react'; //, ReactElement } from 'react';\n+import React, { useEffect, useState, useRef, useMemo } from 'react'; //, ReactElement } from 'react';\n import { Col, Spacer } from '@freecodecamp/ui';\n import { useTranslation } from 'react-i18next';\n import { FullScene } from '../../../../redux/prop-types';\n import { Loader } from '../../../../components/helpers';\n import ClosedCaptionsIcon from '../../../../assets/icons/closedcaptions';\n import { sounds, images, backgrounds, characterAssets } from './scene-assets';\n import Character from './character';\n+import { SceneSubject } from './scene-subject';\n \n import './scene.css';\n \n@@ -17,16 +18,17 @@ const loadImage = (src: string | null) => {\n   if (src) new Image().src = src;\n };\n \n+const initDialogue = { label: '', text: '', align: 'left' };\n+\n export function Scene({\n   scene,\n-  isPlaying,\n-  setIsPlaying\n+  sceneSubject\n }: {\n   scene: FullScene;\n-  isPlaying: boolean;\n-  setIsPlaying: (shouldPlay: boolean) => void;\n+  sceneSubject: SceneSubject;\n }): JSX.Element {\n   const { t } = useTranslation();\n+  const canPauseRef = useRef(false);\n   const { setup, commands } = scene;\n   const { audio, alwaysShowDialogue } = setup;\n   const { startTimestamp = null, finishTimestamp = null } = audio;\n@@ -84,142 +86,165 @@ export function Scene({\n   ]);\n \n   const initBackground = setup.background;\n-  const initDialogue = { label: '', text: '', align: 'left' };\n-  const initCharacters = setup.characters.map(character => {\n-    return {\n-      ...character,\n-      opacity: character.opacity ?? 1,\n-      isTalking: false\n-    };\n-  });\n \n+  // The charactesr are memoized to prevent the useEffect from running on every\n+  // render,\n+  const initCharacters = useMemo(\n+    () =>\n+      setup.characters.map(character => {\n+        return {\n+          ...character,\n+          opacity: character.opacity ?? 1,\n+          isTalking: false\n+        };\n+      }),\n+    [setup.characters]\n+  );\n+\n+  const [isPlaying, setIsPlaying] = useState(false);\n   const [sceneIsReady, setSceneIsReady] = useState(false);\n   const [showDialogue, setShowDialogue] = useState(false);\n   const [accessibilityOn, setAccessibilityOn] = useState(false);\n   const [characters, setCharacters] = useState(initCharacters);\n   const [dialogue, setDialogue] = useState(initDialogue);\n   const [background, setBackground] = useState(initBackground);\n-\n-  useEffect(() => {\n-    if (isPlaying) {\n-      playScene();\n-    } else {\n-      resetScene();\n-    }\n-    // eslint-disable-next-line react-hooks/exhaustive-deps\n-  }, [isPlaying]);\n+  const startRef = useRef<number>(0);\n \n   const audioLoaded = () => {\n     setSceneIsReady(true);\n   };\n \n-  let start = 0;\n-  let stopAudio = false;\n-\n-  // this function exists because we couldn't reliably stop the audio when\n-  // playing only part of the audio file. So it would get cut off\n-  function maybeStopAudio() {\n-    const runningTime = Date.now() - start;\n-\n-    if (runningTime >= duration) {\n-      stopAudio = true;\n-      audioRef.current.pause();\n-    }\n-\n-    if (!stopAudio) {\n-      window.requestAnimationFrame(maybeStopAudio);\n-    }\n-  }\n-\n-  const playScene = () => {\n-    setShowDialogue(true);\n+  const pause = () => {\n+    // Until the play() promise resolves, we can't pause the audio\n+    if (canPauseRef.current) audioRef.current.pause();\n+    canPauseRef.current = false;\n+  };\n \n-    setTimeout(() => {\n-      if (audioRef.current.paused) {\n-        start = Date.now();\n-        void audioRef.current.play();\n-      }\n-      // if there are no timestamps, we can let the audio play to the end\n-      if (hasTimestamps) maybeStopAudio();\n-    }, sToMs(audio.startTime));\n+  useEffect(() => {\n+    const playScene = () => {\n+      // TODO: if we manage the playing state in another module, we should not\n+      // need the early return here. It should not be possible for this to be\n+      // called at all if the scene is already playing.\n+      if (isPlaying) return;\n+      setIsPlaying(true);\n+      setShowDialogue(true);\n \n-    commands.forEach((command, commandIndex) => {\n-      // Start command timeout\n       setTimeout(() => {\n-        if (command.background) setBackground(command.background);\n-\n-        setDialogue(\n-          command.dialogue\n-            ? { ...command.dialogue, label: command.character }\n-            : initDialogue\n-        );\n-\n-        setCharacters(prevCharacters => {\n-          const newCharacters = prevCharacters.map(character => {\n-            if (character.character === command.character) {\n-              return {\n-                ...character,\n-                position: command.position ?? character.position,\n-                opacity: command.opacity ?? character.opacity,\n-                isTalking: command.dialogue ? true : false\n-              };\n-            }\n-            return character;\n+        if (audioRef.current.paused) {\n+          startRef.current = Date.now();\n+          void audioRef.current.play().then(() => {\n+            canPauseRef.current = true;\n           });\n-          return newCharacters;\n-        });\n-      }, sToMs(command.startTime));\n-\n-      // Finish command timeout, only used when there's a dialogue\n-      if (command.dialogue) {\n-        setTimeout(\n-          () => {\n-            setCharacters(prevCharacters => {\n-              const newCharacters = prevCharacters.map(character => {\n-                if (character.character === command.character) {\n-                  return {\n-                    ...character,\n-                    isTalking: false\n-                  };\n-                }\n-                return character;\n-              });\n-              return newCharacters;\n+        }\n+        // if there are no timestamps, we can let the audio play to the end\n+        if (hasTimestamps) maybeStopAudio();\n+      }, sToMs(audio.startTime));\n+\n+      commands.forEach((command, commandIndex) => {\n+        // Start command timeout\n+        setTimeout(() => {\n+          if (command.background) setBackground(command.background);\n+\n+          setDialogue(\n+            command.dialogue\n+              ? { ...command.dialogue, label: command.character }\n+              : initDialogue\n+          );\n+\n+          setCharacters(prevCharacters => {\n+            const newCharacters = prevCharacters.map(character => {\n+              if (character.character === command.character) {\n+                return {\n+                  ...character,\n+                  position: command.position ?? character.position,\n+                  opacity: command.opacity ?? character.opacity,\n+                  isTalking: command.dialogue ? true : false\n+                };\n+              }\n+              return character;\n             });\n-          },\n-          sToMs(command.finishTime as number)\n-        );\n-      }\n+            return newCharacters;\n+          });\n+        }, sToMs(command.startTime));\n+\n+        // Finish command timeout, only used when there's a dialogue\n+        if (command.dialogue) {\n+          setTimeout(\n+            () => {\n+              setCharacters(prevCharacters => {\n+                const newCharacters = prevCharacters.map(character => {\n+                  if (character.character === command.character) {\n+                    return {\n+                      ...character,\n+                      isTalking: false\n+                    };\n+                  }\n+                  return character;\n+                });\n+                return newCharacters;\n+              });\n+            },\n+            sToMs(command.finishTime as number)\n+          );\n+        }\n+\n+        // Last command timeout\n+        if (commandIndex === commands.length - 1) {\n+          setTimeout(\n+            resetScene,\n+            // an extra 500ms at the end to let the characters fade out (CSS transition)\n+            command.finishTime\n+              ? sToMs(command.finishTime) + 500\n+              : sToMs(command.startTime) + 500\n+          );\n+        }\n+      });\n+    };\n \n-      // Last command timeout\n-      if (commandIndex === commands.length - 1) {\n-        setTimeout(\n-          () => {\n-            setIsPlaying(false);\n-          },\n-          // an extra 500ms at the end to let the characters fade out (CSS transition)\n-          command.finishTime\n-            ? sToMs(command.finishTime) + 500\n-            : sToMs(command.startTime) + 500\n-        );\n+    const resetScene = () => {\n+      const { current } = audioRef;\n+      pause();\n+      if (current) {\n+        current.src = `${sounds}/${audio.filename}${audioTimestamp}`;\n+        current.load();\n+        current.currentTime = audio.startTimestamp || 0;\n       }\n-    });\n-  };\n \n-  const resetScene = () => {\n-    const { current } = audioRef;\n-    if (current) {\n-      current.pause();\n-      current.src = `${sounds}/${audio.filename}${audioTimestamp}`;\n-      current.load();\n-      current.currentTime = audio.startTimestamp || 0;\n+      setIsPlaying(false);\n+      setShowDialogue(false);\n+      setDialogue(initDialogue);\n+      setCharacters(initCharacters);\n+      setBackground(initBackground);\n+    };\n+\n+    // this function exists because we couldn't reliably stop the audio when\n+    // playing only part of the audio file. So it would get cut off\n+    function maybeStopAudio() {\n+      const runningTime = Date.now() - startRef.current;\n+\n+      if (runningTime >= duration) {\n+        pause();\n+      } else {\n+        window.requestAnimationFrame(maybeStopAudio);\n+      }\n     }\n \n-    setShowDialogue(false);\n-    setDialogue(initDialogue);\n-    setCharacters(initCharacters);\n-    setBackground(initBackground);\n-  };\n+    sceneSubject.attach(playScene);\n+\n+    return () => {\n+      sceneSubject.detach(playScene);\n+    };\n+  }, [\n+    isPlaying,\n+    duration,\n+    sceneSubject,\n+    commands,\n+    audio,\n+    hasTimestamps,\n+    initCharacters,\n+    initBackground,\n+    audioTimestamp\n+  ]);\n \n   return (\n     <Col lg={10} lgOffset={1} md={10} mdOffset={1}>\n@@ -270,9 +295,7 @@ export function Scene({\n               <div className='scene-start-screen'>\n                 <button\n                   className='scene-start-btn scene-play-btn'\n-                  onClick={() => {\n-                    setIsPlaying(true);\n-                  }}\n+                  onClick={() => sceneSubject.notify()}\n                 >\n                   <img\n                     src={`${images}/play-button.png`}"
        },
        {
            "sha": "d8c00667fa20a03e604263e8c49e888ddbe2c497",
            "filename": "client/src/templates/Challenges/fill-in-the-blank/show.tsx",
            "status": "modified",
            "additions": 7,
            "deletions": 11,
            "changes": 18,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/0c361ad80402d1c230195f90279471571632c80b/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fshow.tsx",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/0c361ad80402d1c230195f90279471571632c80b/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fshow.tsx",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Ftemplates%2FChallenges%2Ffill-in-the-blank%2Fshow.tsx?ref=0c361ad80402d1c230195f90279471571632c80b",
            "patch": "@@ -36,6 +36,7 @@ import {\n   initTests\n } from '../redux/actions';\n import Scene from '../components/scene/scene';\n+import { SceneSubject } from '../components/scene/scene-subject';\n import { getChallengePaths } from '../utils/challenge-paths';\n import { isChallengeCompletedSelector } from '../redux/selectors';\n \n@@ -114,7 +115,6 @@ const ShowFillInTheBlank = ({\n   const [allBlanksFilled, setAllBlanksFilled] = useState(false);\n   const [feedback, setFeedback] = useState<string | null>(null);\n   const [showFeedback, setShowFeedback] = useState(false);\n-  const [isScenePlaying, setIsScenePlaying] = useState(false);\n \n   const container = useRef<HTMLElement | null>(null);\n   const showNextCurriculum = useFeature('fcc-10').on;\n@@ -181,19 +181,21 @@ const ShowFillInTheBlank = ({\n     setShowWrong(false);\n   };\n \n-  const handlePlayScene = (shouldPlay: boolean) => {\n-    setIsScenePlaying(shouldPlay);\n+  const handlePlayScene = () => {\n+    sceneSubject.notify();\n   };\n \n   const blockNameTitle = `${t(\n     `intro:${superBlock}.blocks.${block}.title`\n   )} - ${title}`;\n \n+  const sceneSubject = new SceneSubject();\n+\n   return (\n     <Hotkeys\n       executeChallenge={() => handleSubmit()}\n       containerRef={container}\n-      playScene={() => handlePlayScene(true)}\n+      playScene={handlePlayScene}\n     >\n       <LearnLayout>\n         <Helmet\n@@ -214,13 +216,7 @@ const ShowFillInTheBlank = ({\n               <Spacer size='m' />\n             </Col>\n \n-            {scene && (\n-              <Scene\n-                scene={scene}\n-                isPlaying={isScenePlaying}\n-                setIsPlaying={setIsScenePlaying}\n-              />\n-            )}\n+            {scene && <Scene scene={scene} sceneSubject={sceneSubject} />}\n \n             <Col md={8} mdOffset={2} sm={10} smOffset={1} xs={12}>\n               {instructions && ("
        },
        {
            "sha": "1fcd66507c0b61a81f9c5c3b174cc5a05ad6f4fe",
            "filename": "client/src/templates/Challenges/generic/show.tsx",
            "status": "modified",
            "additions": 5,
            "deletions": 11,
            "changes": 16,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/0c361ad80402d1c230195f90279471571632c80b/client%2Fsrc%2Ftemplates%2FChallenges%2Fgeneric%2Fshow.tsx",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/0c361ad80402d1c230195f90279471571632c80b/client%2Fsrc%2Ftemplates%2FChallenges%2Fgeneric%2Fshow.tsx",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Ftemplates%2FChallenges%2Fgeneric%2Fshow.tsx?ref=0c361ad80402d1c230195f90279471571632c80b",
            "patch": "@@ -35,6 +35,7 @@ import Scene from '../components/scene/scene';\n import MultipleChoiceQuestions from '../components/multiple-choice-questions';\n import ChallengeExplanation from '../components/challenge-explanation';\n import HelpModal from '../components/help-modal';\n+import { SceneSubject } from '../components/scene/scene-subject';\n \n // Styles\n import './show.css';\n@@ -137,9 +138,6 @@ const ShowGeneric = ({\n     setVideoIsLoaded(true);\n   };\n \n-  // scene\n-  const [isScenePlaying, setIsScenePlaying] = useState(false);\n-\n   // assignments\n   const [assignmentsCompleted, setAssignmentsCompleted] = useState(0);\n   const allAssignmentsCompleted = assignmentsCompleted === assignments.length;\n@@ -187,11 +185,13 @@ const ShowGeneric = ({\n     }\n   };\n \n+  const sceneSubject = new SceneSubject();\n+\n   return (\n     <Hotkeys\n       executeChallenge={handleSubmit}\n       containerRef={container}\n-      playScene={scene ? () => setIsScenePlaying(true) : undefined}\n+      playScene={scene ? () => sceneSubject.notify() : undefined}\n     >\n       <LearnLayout>\n         <Helmet\n@@ -227,13 +227,7 @@ const ShowGeneric = ({\n               )}\n             </Col>\n \n-            {scene && (\n-              <Scene\n-                scene={scene}\n-                isPlaying={isScenePlaying}\n-                setIsPlaying={setIsScenePlaying}\n-              />\n-            )}\n+            {scene && <Scene scene={scene} sceneSubject={sceneSubject} />}\n \n             <Col md={8} mdOffset={2} sm={10} smOffset={1} xs={12}>\n               {instructions && ("
        }
    ],
    "stats": {
        "total": 323,
        "additions": 179,
        "deletions": 144
    }
}