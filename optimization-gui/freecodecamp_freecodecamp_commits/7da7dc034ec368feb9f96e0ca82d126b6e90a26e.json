{
    "author": "moT01",
    "message": "feat(curriculum): videos and transcripts for understanding react effects lectures (#59485)\n\nCo-authored-by: Dario-DC <105294544+Dario-DC@users.noreply.github.com>",
    "sha": "7da7dc034ec368feb9f96e0ca82d126b6e90a26e",
    "files": [
        {
            "sha": "42be9a9790c3f3b485757afe0f48804b5b455073",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-effects-and-referencing-values-in-react/67d1a82dad69dc95546e5f0d.md",
            "status": "modified",
            "additions": 102,
            "deletions": 3,
            "changes": 105,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/7da7dc034ec368feb9f96e0ca82d126b6e90a26e/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-effects-and-referencing-values-in-react%2F67d1a82dad69dc95546e5f0d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/7da7dc034ec368feb9f96e0ca82d126b6e90a26e/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-effects-and-referencing-values-in-react%2F67d1a82dad69dc95546e5f0d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-effects-and-referencing-values-in-react%2F67d1a82dad69dc95546e5f0d.md?ref=7da7dc034ec368feb9f96e0ca82d126b6e90a26e",
            "patch": "@@ -2,13 +2,112 @@\n id: 67d1a82dad69dc95546e5f0d\n title: How Do You Reference Values Using Refs?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: gA0MGdlEubs\n dashedName: how-do-you-reference-values-using-refs\n ---\n \n # --description--\n \n-Watch the video lecture and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How do you reference values using refs?\n+\n+In React, there may be situations where you need direct access to a DOM element. That's where \"refs\" come in handy. Refs can also store mutable values, but state is a better choice for that. \n+\n+In vanilla JavaScript, you used the `getElementById()` and `querySelector()` methods to access DOM elements. But in React, you use refs to access elements in the DOM.\n+\n+One of the main differences is that, with refs, you don't need identifiers like IDs and classes to reference elements.\n+\n+So, how can you create and use refs? React provides a `useRef()` hook that lets you do just that. \n+\n+The first step is to import the hook from React:\n+\n+```js\n+import { useRef } from \"react\";\n+```\n+\n+Next, you need to create a variable that holds the ref with the initial value of the ref inside the `useRef` hook, say a `sectionRef` initialized to `null`:\n+\n+```js\n+const sectionRef = useRef(null);\n+```\n+\n+The final thing to do is to attach the ref variable to the element in your JSX by using the `ref` attribute:\n+\n+```js\n+<section ref={sectionRef}>\n+  {/* Section content */}\n+</section>\n+```\n+\n+If you log the ref to the console, you'll see it's an object with the current value, in this case, `null`:\n+\n+```js\n+console.log(sectionRef); // { current: null }\n+```\n+\n+You can also log the current value to the console with the `current` property so you can see the value directly:\n+\n+```js\n+console.log(sectionRef.current); // null\n+```\n+\n+The subsequent values of the ref depend on the component lifecycle. \n+\n+For example, the initial value of `sectionRef` will always be `null` because that's what it was initialized to. After the component is mounted, the value of the ref will be the `section` element the ref is attached to.\n+\n+If the component is unmounted, the ref's value goes back to the initial value of `null`.\n+\n+A typical example to showcase a ref is to focus an input element on render, or by clicking a button.\n+\n+Here's how to do that when you click a button:\n+\n+```js\n+import { useRef } from \"react\";\n+\n+const Focus = () => {\n+  const inputRef = useRef(null);\n+\n+  const handleFocus = () => {\n+    if (inputRef.current) {\n+      inputRef.current.focus();\n+    }\n+  };\n+\n+  return (\n+    <div>\n+      <input ref={inputRef} type=\"text\" placeholder=\"Enter text\" />\n+      <button onClick={handleFocus}>Focus Input</button>\n+    </div>\n+  );\n+};\n+\n+export default Focus;\n+```\n+\n+In the code above, the `inputRef` is created and attached to the `input` element. There's also a button with an `onClick` event that calls a `handleFocus` function.\n+\n+All the `handleFocus` function does is call the `focus()` method on the `input` element. Note that, because `input` is a built-in component that comes with React, the actual `input` DOM element is set to the `current` property of the ref. So you call the `focus()` method with `input.current.focus()`.\n+\n+Here are some best practices you should be aware of while working with refs:\n+\n+- Use refs mainly to interact with the DOM. You can also use them for mutable data, but state is a better choice for that.\n+\n+- Don't use refs for basic state management – that is what `useState` is for.\n+\n+- Make sure you check that `ref.current` exists before accessing its properties. Here's how to do that again:\n+\n+```js\n+const handleFocus = () => {\n+  if (inputRef.current) {\n+    inputRef.current.focus();\n+  }\n+};\n+```\n+\n+This prevents errors in case the ref is accessed before it is attached to the DOM or after it is removed.\n \n # --questions--\n \n@@ -86,7 +185,7 @@ Think about how refs store a mutable object with a key for accessing the `curren\n \n ## --text--\n \n-What is the value of the ref when the component is mounted?\n+What is the value of the ref after the component is mounted?\n \n ## --answers--\n "
        },
        {
            "sha": "611d53a04eaa165096348e285eb93057e3722186",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-effects-and-referencing-values-in-react/67d1ec6711b62f1cc5cc52e1.md",
            "status": "modified",
            "additions": 121,
            "deletions": 6,
            "changes": 127,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/7da7dc034ec368feb9f96e0ca82d126b6e90a26e/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-effects-and-referencing-values-in-react%2F67d1ec6711b62f1cc5cc52e1.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/7da7dc034ec368feb9f96e0ca82d126b6e90a26e/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-effects-and-referencing-values-in-react%2F67d1ec6711b62f1cc5cc52e1.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-effects-and-referencing-values-in-react%2F67d1ec6711b62f1cc5cc52e1.md?ref=7da7dc034ec368feb9f96e0ca82d126b6e90a26e",
            "patch": "@@ -2,13 +2,128 @@\n id: 67d1ec6711b62f1cc5cc52e1\n title: What Are Effects in React, and How Does the useEffect Hook Work?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: Dtd_8qxFM1w\n dashedName: what-are-effects-in-react-and-how-does-the-useeffect-hook-work\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What are effects in React, and how does the `useEffect` hook work?\n+\n+In React, an effect is anything that happens outside the component rendering process. That is, anything React does not handle directly as part of rendering the UI.\n+\n+Common examples include fetching data, updating the browser tab's title, reading from or writing to the browser's local storage, getting the user's location, and much more. These operations interact with the outside world and are known as side effects.\n+\n+React provides the `useEffect` hook to let you handle those side effects. `useEffect` lets you run a function after the component renders or updates.\n+\n+Let's see how the `useEffect` hook works and why it's essential for modern React development.\n+\n+To use the `useEffect` hook, you first need to import it:\n+\n+```js\n+import { useEffect } from \"react\";\n+```\n+\n+Then you use it as a function, like this:\n+\n+```js\n+useEffect(() => {\n+ // Your side effect logic (usually a function) here\n+}, [dependencies]);\n+```\n+\n+The effect function runs after the component renders, while the optional `dependencies` argument controls when the effect runs.\n+\n+Note that `dependencies` can be an array of \"reactive values\" (state, props, functions, variables, and so on), an empty array, or omitted entirely. Here's how all of those options control how `useEffect` works:\n+\n+- If `dependencies` is an array that includes one or more reactive values, the effect will run whenever they change.\n+\n+- If `dependencies` is an empty array, `useEffect` runs only once when the component first renders.\n+\n+- If you omit `dependencies`, the effect runs every time the component renders or updates.\n+\n+For example, in this `Counter` application, we don't pass in a `dependencies` argument, so the effect runs when the component renders and every time it updates:\n+\n+```js\n+import { useState, useEffect } from \"react\";\n+\n+const Counter = () => {\n+  const [count, setCount] = useState(0);\n+\n+  useEffect(() => {\n+    console.log(\"Component renders\");\n+  });\n+\n+  return (\n+    <div\n+      style={{\n+        display: \"flex\",\n+        alignItems: \"center\",\n+        flexDirection: \"column\",\n+      }}\n+    >\n+      <h2>{count}</h2>\n+      <div>\n+        <button onClick={() => setCount(count + 1)}>Increase</button>\n+        <button onClick={() => setCount(count - 1)}>Decrease</button>\n+      </div>\n+    </div>\n+  );\n+};\n+\n+export default Counter;\n+```\n+\n+But if we pass in an empty array as a dependency, the effect only runs on the first render:\n+\n+```js\n+useEffect(() => {\n+  console.log('Component renders');\n+}, []);\n+```\n+\n+If you pass in the `count` state as a dependency, the effect runs when the component first render, and when `count` changes:\n+\n+```js\n+useEffect(() => {\n+  document.title = `The current count is ${count}`;\n+  console.log('component renders');\n+}, [count]);\n+```\n+\n+Note that, if the effect you set up persists beyond the component's rendering lifecycle, you might need another function to \"clean up\" that function after the component renders or updates.\n+\n+For example, if your effect function uses `setInterval()`, sets an event listener like `window.addEventListener()`, or connects to a server, you'll need a cleanup function to run `clearInterval()`, `window.removeEventListener()`, and disconnect from the server, respectively.\n+\n+Here's the syntax for returning a cleanup function from the `useEffect` hook:\n+\n+```js\n+useEffect(() => {\n+ // Your side effect logic here\n+ return () => {\n+   // Cleanup logic here (optional)\n+ };\n+}, [dependencies]);\n+```\n+\n+For instance, if you add a scroll event listener, you can clean it up by removing it in your cleanup function:\n+\n+```js\n+useEffect(() => {\n+  const handleScroll = () => {\n+    // Handle scroll logic\n+  };\n+  window.addEventListener(\"scroll\", handleScroll);\n+\n+  return () => {\n+    window.removeEventListener(\"scroll\", handleScroll);\n+  };\n+}, []);\n+```\n \n # --questions--\n \n@@ -18,15 +133,15 @@ What is considered an effect in React?\n \n ## --answers--\n \n-Any update to the component’s state.\n+Any update to the component's state.\n \n ### --feedback--\n \n Effects involve actions React doesn't control during rendering.\n \n ---\n \n-Operations outside the rendering process that React doesn’t manage.\n+Operations outside the rendering process that React doesn't manage.\n \n ---\n \n@@ -50,7 +165,7 @@ Effects involve actions React doesn't control during rendering.\n \n ## --text--\n \n-What determines how side effects run in a React app based on the dependency array?\n+What determines how side effects run in a React app?\n \n ## --answers--\n \n@@ -70,7 +185,7 @@ The behavior of the effect depends on the contents of the dependency array.\n \n ---\n \n-The dependency array determines when effects run, based on its contents.\n+The dependency array determines when effects run.\n \n ---\n "
        },
        {
            "sha": "a8c660804099423671b5e36db1a63bdfb7188970",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-understanding-effects-and-referencing-values-in-react/67d1ec87b34cee1d9219f7e9.md",
            "status": "modified",
            "additions": 134,
            "deletions": 2,
            "changes": 136,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/7da7dc034ec368feb9f96e0ca82d126b6e90a26e/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-effects-and-referencing-values-in-react%2F67d1ec87b34cee1d9219f7e9.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/7da7dc034ec368feb9f96e0ca82d126b6e90a26e/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-effects-and-referencing-values-in-react%2F67d1ec87b34cee1d9219f7e9.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-understanding-effects-and-referencing-values-in-react%2F67d1ec87b34cee1d9219f7e9.md?ref=7da7dc034ec368feb9f96e0ca82d126b6e90a26e",
            "patch": "@@ -2,13 +2,145 @@\n id: 67d1ec87b34cee1d9219f7e9\n title: How Can You Create Custom Hooks in React?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: r9MI-2J01PY\n dashedName: how-can-you-create-custom-hooks-in-react\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How can you create custom hooks in React?\n+\n+React provides many built-in hooks that let you implement different features in your projects. These include `useState`, `useEffect`, `useContext`, and others.\n+\n+But sometimes, you'll need to add a feature that none of the built-in hooks can help with. Fortunately, you can create your own custom hooks in React.\n+\n+Custom hooks are not as complicated as they might seem. They're just reusable functions that let you share logic across multiple components. That means reusability is another reason why you would want to build your own hook.\n+\n+With a custom hook, you can extract logic away from any components that use them, like data fetching, state management, toggling, side effects like checking for the online or offline status of users, and so on. \n+\n+You can then import the hook to use in any component, so you can focus on rendering and presentation within those components. That means fewer repetitions and less duplication, which means fewer places to make changes when you want to make any updates.\n+\n+Now, let's take a look at how you can make your own custom hook.\n+\n+In React, all built-in hooks start with the word `use`, so your custom hook should follow the same convention. Your custom hook's name should also clearly communicate what it does.\n+\n+So, if your custom hook…\n+\n+- fetches data, you can call it `useFetch`\n+\n+- toggles something on and off, you can call it `useToggle`\n+\n+- or if it implements debouncing, `useDebounce` is a good name\n+\n+Let's say you want to build a custom hook to add debouncing to your app.\n+\n+Debouncing is a programming technique that limits how often a function runs. It works by waiting until a user stops performing an action for a specified period of time before executing the function. For example, in a search box, instead of making an API call for every keystroke, debouncing waits until the user pauses typing for, say, 500 milliseconds.\n+\n+To create a debouncing custom hook, you first need to create a `useDebounce.jsx` or `useDebounce.js` file. Conventionally, files for any custom hooks you create are saved to a `hooks` folder.\n+\n+You can use some built-in hooks within your own custom hook. For debouncing, you need the `useState` and `useEffect` hooks, so import them at the top of your file:\n+\n+```js\n+import { useState, useEffect } from \"react\";\n+```\n+\n+Next, create a `useDebounce` function that takes `value` and `delay` as parameters. `value` is the resource you want to wait for, and `delay` is the period of time you want to wait for. Since you want to wait for some period of time, the `setTimeout` and `clearTimeout` functions would be useful:\n+\n+```js\n+function useDebounce(value, delay) {\n+  const [debouncedValue, setDebouncedValue] = useState(value);\n+\n+  useEffect(() => {\n+    const handler = setTimeout(() => {\n+      setDebouncedValue(value);\n+    }, delay);\n+\n+    return () => {\n+      clearTimeout(handler);\n+    };\n+  }, [value, delay]);\n+\n+  return debouncedValue;\n+}\n+\n+export { useDebounce };\n+```\n+\n+The `debouncedValue` state holds and returns the delayed value, which only updates after the specified timeout period.\n+\n+`useEffect` is where the magic really happens. If you recall from the previous lecture, anything that exists outside the React rendering cycle, like setting and clearing a timer, is a side effect, and you should use the `useEffect` hook to handle them.\n+\n+Within the `useEffect` hook here, you use `setTimeout` to set the `debouncedValue`. You then return a cleanup function that uses `clearTimeout` to clear the previous timeout whenever `value` or `delay` changes, or the component unmounts.\n+\n+To use this hook, we've prepared a `footballers` array to filter through with a simple search bar:\n+\n+```js\n+const footballers = [\n+   'Lionel Messi', 'Cristiano Ronaldo', 'Neymar Jr',\n+   'Kylian Mbappe', 'Mohamed Salah', 'Sadio Mane',\n+   'Kevin De Bruyne', 'Robert Lewandowski', 'Harry Kane',\n+   'Sergio Ramos', 'Virgil van Dijk', 'Alisson Becker', \n+   'Joshua Kimmich', 'Manuel Neuer', 'Karim Benzema', \n+   'Thibaut Courtois', 'Eden Hazard', 'Raheem Sterling',\n+   'Bruno Fernandes', 'Trent Alexander-Arnold', 'Son Heung-min',\n+   'Pierre-Emerick Aubameyang','Sergio Aguero', 'Luis Suarez', \n+   'Luka Modric', 'Casemiro', 'Frenkie de Jong', 'Gerard Pique',\n+   'Marc-Andre ter Stegen', 'Keylor Navas', 'Angel Di Maria', \n+   \"N'Golo Kante\", 'Kai Havertz', 'Timo Werner', 'Hakim Ziyech', \n+   'Christian Pulisic', 'Mason Mount', 'Olivier Giroud', 'Tammy Abraham', \n+   'Kepa Arrizabalaga', 'Ben Chilwell', 'Thiago Silva', 'Kurt Zouma', \n+   'John Terry', 'Didier Drogba', 'Frank Lampard', 'Ashley Cole', 'Petr Cech',\n+];\n+\n+export default footballers;\n+```\n+\n+And here's a `FootballerSearch` component that uses the `useDebounce` hook to delay searching for 1 second after the user stops typing:\n+\n+```js\n+import { useState, useEffect } from \"react\";\n+import { useDebounce } from \"./hooks/useDebounce\";\n+import footballers from \"./footballers\";\n+\n+const FootballerSearch = () => {\n+  const [query, setQuery] = useState(\"\");\n+  const debouncedQuery = useDebounce(query, 1000); // Start searching 1 second after the user stops typing\n+\n+  useEffect(() => {\n+    if (debouncedQuery) {\n+      const results = footballers.filter((footballer) =>\n+        footballer.toLowerCase().includes(debouncedQuery.toLowerCase()),\n+      );\n+      console.log(\"Search results:\", results);\n+    } else {\n+      console.log(\"Search results: []\");\n+    }\n+  }, [debouncedQuery]);\n+\n+  return (\n+    <>\n+      <h1 style={{ textAlign: \"center\" }}>Footballer Search App</h1>\n+      <div style={{ textAlign: \"center\" }}>\n+        <input\n+          style={{ padding: \"0.5rem\", width: \"30%\" }}\n+          type=\"text\"\n+          value={query}\n+          onChange={(e) => setQuery(e.target.value)}\n+          placeholder=\"Search for a footballer...\"\n+        />\n+      </div>\n+    </>\n+  );\n+};\n+\n+export default FootballerSearch;\n+```\n+\n+As you can see, the `debouncedQuery` variable is what initializes the `useDebounce` hook with the query state (what the user types), and the delay for 1,000 milliseconds, or 1 second. The search itself is handled inside the `useEffect` hook, and search results are logged to the console.\n \n # --questions--\n "
        }
    ],
    "stats": {
        "total": 368,
        "additions": 357,
        "deletions": 11
    }
}