{
    "author": "ojeytonwilliams",
    "message": "fix(api): modularize auth handlers (#55671)",
    "sha": "e9ac6c5e729afab476c1657089de1722149bb768",
    "files": [
        {
            "sha": "2dc8f06e16b0b2d2afbd353936312ada3fb448d6",
            "filename": "api/src/app.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 30,
            "changes": 63,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fapp.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fapp.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fapp.ts?ref=e9ac6c5e729afab476c1657089de1722149bb768",
            "patch": "@@ -24,7 +24,8 @@ import { SESProvider } from './plugins/mail-providers/ses';\n import mailer from './plugins/mailer';\n import redirectWithMessage from './plugins/redirect-with-message';\n import security from './plugins/security';\n-import codeFlowAuth from './plugins/code-flow-auth';\n+import auth from './plugins/auth';\n+import bouncer from './plugins/bouncer';\n import notFound from './plugins/not-found';\n import { authRoutes, mobileAuth0Routes } from './routes/auth';\n import { devAuthRoutes } from './routes/auth-dev';\n@@ -182,44 +183,46 @@ export const build = async (\n \n   // redirectWithMessage must be registered before codeFlowAuth\n   void fastify.register(redirectWithMessage);\n-  void fastify.register(codeFlowAuth);\n+  void fastify.register(auth);\n   void fastify.register(notFound);\n   void fastify.register(prismaPlugin);\n \n-  // Routes requiring authentication and CSRF protection\n-  void fastify.register(function (fastify, _opts, done) {\n-    // The order matters here, since we want to reject invalid cross site requests\n-    // before checking if the user is authenticated.\n-    // @ts-expect-error - @fastify/csrf-protection needs to update their types\n-    // eslint-disable-next-line @typescript-eslint/unbound-method\n-    fastify.addHook('onRequest', fastify.csrfProtection);\n+  // Routes requiring authentication:\n+  void fastify.register(async function (fastify, _opts) {\n+    await fastify.register(bouncer);\n     fastify.addHook('onRequest', fastify.authorize);\n+    // CSRF protection enabled:\n+    await fastify.register(async function (fastify, _opts) {\n+      // TODO: bounce unauthed requests before checking CSRF token. This will\n+      // mean moving csrfProtection into custom plugin and testing separately,\n+      // because it's a pain to mess around with other cookies/hook order.\n+      // @ts-expect-error - @fastify/csrf-protection needs to update their types\n+      // eslint-disable-next-line @typescript-eslint/unbound-method\n+      fastify.addHook('onRequest', fastify.csrfProtection);\n+      fastify.addHook('onRequest', fastify.send401IfNoUser);\n+\n+      await fastify.register(challengeRoutes);\n+      await fastify.register(donateRoutes);\n+      await fastify.register(protectedCertificateRoutes);\n+      await fastify.register(settingRoutes);\n+      await fastify.register(userRoutes);\n+    });\n \n-    void fastify.register(challengeRoutes);\n-    void fastify.register(donateRoutes);\n-    void fastify.register(protectedCertificateRoutes);\n-    void fastify.register(settingRoutes);\n-    void fastify.register(userRoutes);\n-    done();\n-  });\n-\n-  // Routes requiring authentication and NOT CSRF protection\n-  void fastify.register(function (fastify, _opts, done) {\n-    fastify.addHook('onRequest', fastify.authorize);\n+    // CSRF protection disabled:\n+    await fastify.register(async function (fastify, _opts) {\n+      fastify.addHook('onRequest', fastify.send401IfNoUser);\n \n-    void fastify.register(userGetRoutes);\n-    done();\n-  });\n+      await fastify.register(userGetRoutes);\n+    });\n \n-  // Routes requiring authentication that redirect on failure\n-  void fastify.register(function (fastify, _opts, done) {\n-    fastify.addHook('onRequest', fastify.authorizeOrRedirect);\n+    // Routes that redirect if access is denied:\n+    await fastify.register(async function (fastify, _opts) {\n+      fastify.addHook('onRequest', fastify.redirectIfNoUser);\n \n-    void fastify.register(settingRedirectRoutes);\n-    done();\n+      await fastify.register(settingRedirectRoutes);\n+    });\n   });\n-\n-  // Routes not requiring authentication\n+  // Routes not requiring authentication:\n   void fastify.register(mobileAuth0Routes);\n   // TODO: consolidate with LOCAL_MOCK_AUTH\n   if (FCC_ENABLE_DEV_LOGIN_MODE) {"
        },
        {
            "sha": "e74bff8467f97fe2fcf0b000221e786d93070bea",
            "filename": "api/src/plugins/auth.test.ts",
            "status": "added",
            "additions": 253,
            "deletions": 0,
            "changes": 253,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fplugins%2Fauth.test.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fplugins%2Fauth.test.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fplugins%2Fauth.test.ts?ref=e9ac6c5e729afab476c1657089de1722149bb768",
            "patch": "@@ -0,0 +1,253 @@\n+import Fastify, { FastifyInstance } from 'fastify';\n+import jwt from 'jsonwebtoken';\n+\n+import { COOKIE_DOMAIN, JWT_SECRET } from '../utils/env';\n+import { type Token, createAccessToken } from '../utils/tokens';\n+import cookies, { sign as signCookie, unsign as unsignCookie } from './cookies';\n+import auth from './auth';\n+\n+async function setupServer() {\n+  const fastify = Fastify();\n+  await fastify.register(cookies);\n+  await fastify.register(auth);\n+  return fastify;\n+}\n+\n+describe('auth', () => {\n+  let fastify: FastifyInstance;\n+\n+  beforeEach(async () => {\n+    fastify = await setupServer();\n+  });\n+\n+  afterEach(async () => {\n+    await fastify.close();\n+  });\n+\n+  describe('setAccessTokenCookie', () => {\n+    // We won't need to keep doubly signing the cookie when we migrate the\n+    // authentication, but for the MVP we have to be able to read the cookies\n+    // set by the api-server. So, double signing:\n+    it('should doubly sign the cookie', async () => {\n+      const token = createAccessToken('test-id');\n+      fastify.get('/test', async (req, reply) => {\n+        reply.setAccessTokenCookie(token);\n+        return { ok: true };\n+      });\n+\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/test'\n+      });\n+\n+      const { value, ...rest } = res.cookies[0]!;\n+      const unsignedOnce = unsignCookie(value);\n+      const unsignedTwice = jwt.verify(unsignedOnce.value!, JWT_SECRET) as {\n+        accessToken: Token;\n+      };\n+      expect(unsignedTwice.accessToken).toEqual(token);\n+      expect(rest).toEqual({\n+        name: 'jwt_access_token',\n+        path: '/',\n+        sameSite: 'Lax',\n+        domain: COOKIE_DOMAIN,\n+        maxAge: token.ttl\n+      });\n+    });\n+\n+    // TODO: Post-MVP sync the cookie max-age with the token ttl (i.e. the\n+    // max-age should be the ttl/1000, not ttl)\n+    it('should set the max-age of the cookie to match the ttl of the token', async () => {\n+      const token = createAccessToken('test-id', 123000);\n+      fastify.get('/test', async (req, reply) => {\n+        reply.setAccessTokenCookie(token);\n+        return { ok: true };\n+      });\n+\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/test'\n+      });\n+\n+      expect(res.cookies[0]).toEqual(\n+        expect.objectContaining({\n+          maxAge: 123000\n+        })\n+      );\n+    });\n+  });\n+\n+  describe('authorize', () => {\n+    beforeEach(() => {\n+      fastify.get('/test', (_req, reply) => {\n+        void reply.send({ ok: true });\n+      });\n+      fastify.addHook('onRequest', fastify.authorize);\n+    });\n+\n+    it('should deny if the access token is missing', async () => {\n+      expect.assertions(4);\n+\n+      fastify.addHook('onRequest', (req, _reply, done) => {\n+        expect(req.accessDeniedMessage).toEqual({\n+          type: 'info',\n+          content: 'Access token is required for this request'\n+        });\n+        expect(req.user).toBeNull();\n+        done();\n+      });\n+\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/test'\n+      });\n+\n+      expect(res.json()).toEqual({ ok: true });\n+      expect(res.statusCode).toEqual(200);\n+    });\n+\n+    it('should deny if the access token is not signed', async () => {\n+      expect.assertions(4);\n+\n+      fastify.addHook('onRequest', (req, _reply, done) => {\n+        expect(req.accessDeniedMessage).toEqual({\n+          type: 'info',\n+          content: 'Access token is required for this request'\n+        });\n+        expect(req.user).toBeNull();\n+        done();\n+      });\n+\n+      const token = jwt.sign(\n+        { accessToken: createAccessToken('123') },\n+        JWT_SECRET\n+      );\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/test',\n+        cookies: {\n+          jwt_access_token: token\n+        }\n+      });\n+\n+      expect(res.json()).toEqual({ ok: true });\n+      expect(res.statusCode).toEqual(200);\n+    });\n+\n+    it('should deny if the access token is invalid', async () => {\n+      expect.assertions(4);\n+\n+      fastify.addHook('onRequest', (req, _reply, done) => {\n+        expect(req.accessDeniedMessage).toEqual({\n+          type: 'info',\n+          content: 'Your access token is invalid'\n+        });\n+        expect(req.user).toBeNull();\n+        done();\n+      });\n+\n+      const token = jwt.sign(\n+        { accessToken: createAccessToken('123') },\n+        'invalid-secret'\n+      );\n+\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/test',\n+        cookies: {\n+          jwt_access_token: signCookie(token)\n+        }\n+      });\n+\n+      expect(res.json()).toEqual({ ok: true });\n+      expect(res.statusCode).toEqual(200);\n+    });\n+\n+    it('should deny if the access token has expired', async () => {\n+      expect.assertions(4);\n+\n+      fastify.addHook('onRequest', (req, _reply, done) => {\n+        expect(req.accessDeniedMessage).toEqual({\n+          type: 'info',\n+          content: 'Access token is no longer valid'\n+        });\n+        expect(req.user).toBeNull();\n+        done();\n+      });\n+\n+      const token = jwt.sign(\n+        { accessToken: createAccessToken('123', -1) },\n+        JWT_SECRET\n+      );\n+\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/test',\n+        cookies: {\n+          jwt_access_token: signCookie(token)\n+        }\n+      });\n+\n+      expect(res.json()).toEqual({ ok: true });\n+      expect(res.statusCode).toEqual(200);\n+    });\n+\n+    it('should deny if the user is not found', async () => {\n+      expect.assertions(4);\n+\n+      fastify.addHook('onRequest', (req, _reply, done) => {\n+        expect(req.accessDeniedMessage).toEqual({\n+          type: 'info',\n+          content: 'Your access token is invalid'\n+        });\n+        expect(req.user).toBeNull();\n+        done();\n+      });\n+\n+      // @ts-expect-error prisma isn't defined, since we're not building the\n+      // full application here.\n+      fastify.prisma = { user: { findUnique: () => null } };\n+      const token = jwt.sign(\n+        { accessToken: createAccessToken('123') },\n+        JWT_SECRET\n+      );\n+\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/test',\n+        cookies: {\n+          jwt_access_token: signCookie(token)\n+        }\n+      });\n+\n+      expect(res.json()).toEqual({ ok: true });\n+      expect(res.statusCode).toEqual(200);\n+    });\n+\n+    it('should populate the request with the user if the token is valid', async () => {\n+      const fakeUser = { id: '123', username: 'test-user' };\n+      // @ts-expect-error prisma isn't defined, since we're not building the\n+      // full application here.\n+      fastify.prisma = { user: { findUnique: () => fakeUser } };\n+      fastify.get('/test-user', req => {\n+        expect(req.user).toEqual(fakeUser);\n+        return { ok: true };\n+      });\n+\n+      const token = jwt.sign(\n+        { accessToken: createAccessToken('123') },\n+        JWT_SECRET\n+      );\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/test-user',\n+        cookies: {\n+          jwt_access_token: signCookie(token)\n+        }\n+      });\n+\n+      expect(res.json()).toEqual({ ok: true });\n+      expect(res.statusCode).toEqual(200);\n+    });\n+  });\n+});"
        },
        {
            "sha": "dec00c38987866576dc1636812a5602fa9915ecc",
            "filename": "api/src/plugins/auth.ts",
            "status": "added",
            "additions": 78,
            "deletions": 0,
            "changes": 78,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fplugins%2Fauth.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fplugins%2Fauth.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fplugins%2Fauth.ts?ref=e9ac6c5e729afab476c1657089de1722149bb768",
            "patch": "@@ -0,0 +1,78 @@\n+import { FastifyPluginCallback, FastifyRequest } from 'fastify';\n+import fp from 'fastify-plugin';\n+import jwt from 'jsonwebtoken';\n+import { type user } from '@prisma/client';\n+\n+import { JWT_SECRET } from '../utils/env';\n+import { type Token, isExpired } from '../utils/tokens';\n+\n+declare module 'fastify' {\n+  interface FastifyReply {\n+    setAccessTokenCookie: (this: FastifyReply, accessToken: Token) => void;\n+  }\n+\n+  interface FastifyRequest {\n+    // TODO: is the full user the correct type here?\n+    user: user | null;\n+    accessDeniedMessage: { type: 'info'; content: string } | null;\n+  }\n+\n+  interface FastifyInstance {\n+    authorize: (req: FastifyRequest, reply: FastifyReply) => void;\n+  }\n+}\n+\n+const auth: FastifyPluginCallback = (fastify, _options, done) => {\n+  fastify.decorateReply('setAccessTokenCookie', function (accessToken: Token) {\n+    const signedToken = jwt.sign({ accessToken }, JWT_SECRET);\n+    void this.setCookie('jwt_access_token', signedToken, {\n+      httpOnly: false,\n+      secure: false,\n+      maxAge: accessToken.ttl\n+    });\n+  });\n+\n+  fastify.decorateRequest('accessDeniedMessage', null);\n+  fastify.decorateRequest('user', null);\n+\n+  const TOKEN_REQUIRED = 'Access token is required for this request';\n+  const TOKEN_INVALID = 'Your access token is invalid';\n+  const TOKEN_EXPIRED = 'Access token is no longer valid';\n+\n+  const setAccessDenied = (req: FastifyRequest, content: string) =>\n+    (req.accessDeniedMessage = { type: 'info', content });\n+\n+  const handleAuth = async (req: FastifyRequest) => {\n+    const tokenCookie = req.cookies.jwt_access_token;\n+    if (!tokenCookie) return setAccessDenied(req, TOKEN_REQUIRED);\n+\n+    const unsignedToken = req.unsignCookie(tokenCookie);\n+    if (!unsignedToken.valid) return setAccessDenied(req, TOKEN_REQUIRED);\n+\n+    const jwtAccessToken = unsignedToken.value;\n+\n+    try {\n+      jwt.verify(jwtAccessToken, JWT_SECRET);\n+    } catch {\n+      return setAccessDenied(req, TOKEN_INVALID);\n+    }\n+\n+    const { accessToken } = jwt.decode(jwtAccessToken) as {\n+      accessToken: Token;\n+    };\n+\n+    if (isExpired(accessToken)) return setAccessDenied(req, TOKEN_EXPIRED);\n+\n+    const user = await fastify.prisma.user.findUnique({\n+      where: { id: accessToken.userId }\n+    });\n+    if (!user) return setAccessDenied(req, TOKEN_INVALID);\n+    req.user = user;\n+  };\n+\n+  fastify.decorate('authorize', handleAuth);\n+\n+  done();\n+};\n+\n+export default fp(auth, { name: 'auth', dependencies: ['cookies'] });"
        },
        {
            "sha": "d083990f3138896d9eb5bb4c716689ed7bcecd2b",
            "filename": "api/src/plugins/auth0.test.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fplugins%2Fauth0.test.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fplugins%2Fauth0.test.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fplugins%2Fauth0.test.ts?ref=e9ac6c5e729afab476c1657089de1722149bb768",
            "patch": "@@ -7,7 +7,7 @@ import prismaPlugin from '../db/prisma';\n import cookies, { sign, unsign } from './cookies';\n import { auth0Client } from './auth0';\n import redirectWithMessage, { formatMessage } from './redirect-with-message';\n-import codeFlowAuth from './code-flow-auth';\n+import auth from './auth';\n \n // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n jest.mock('../utils/env', () => ({\n@@ -23,7 +23,7 @@ describe('auth0 plugin', () => {\n \n     await fastify.register(cookies);\n     await fastify.register(redirectWithMessage);\n-    await fastify.register(codeFlowAuth);\n+    await fastify.register(auth);\n     await fastify.register(auth0Client);\n     await fastify.register(prismaPlugin);\n   });"
        },
        {
            "sha": "8618d3a32f18d5918e9f95dc7f962dffe541518c",
            "filename": "api/src/plugins/bouncer.test.ts",
            "status": "added",
            "additions": 163,
            "deletions": 0,
            "changes": 163,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fplugins%2Fbouncer.test.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fplugins%2Fbouncer.test.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fplugins%2Fbouncer.test.ts?ref=e9ac6c5e729afab476c1657089de1722149bb768",
            "patch": "@@ -0,0 +1,163 @@\n+/* eslint-disable @typescript-eslint/no-unsafe-call */\n+/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n+import Fastify, { type FastifyInstance } from 'fastify';\n+\n+import { HOME_LOCATION } from '../utils/env';\n+import bouncer from './bouncer';\n+import auth from './auth';\n+import cookies from './cookies';\n+import redirectWithMessage, { formatMessage } from './redirect-with-message';\n+\n+let authorizeSpy: jest.SpyInstance;\n+\n+async function setupServer() {\n+  const fastify = Fastify();\n+  await fastify.register(cookies);\n+  await fastify.register(auth);\n+  authorizeSpy = jest.spyOn(fastify, 'authorize');\n+\n+  await fastify.register(redirectWithMessage);\n+  await fastify.register(bouncer);\n+  fastify.addHook('onRequest', fastify.authorize);\n+  fastify.get('/', (_req, reply) => {\n+    void reply.send({ foo: 'bar' });\n+  });\n+  return fastify;\n+}\n+\n+describe('bouncer', () => {\n+  let fastify: FastifyInstance;\n+  beforeEach(async () => {\n+    fastify = await setupServer();\n+  });\n+\n+  afterEach(async () => {\n+    await fastify.close();\n+  });\n+\n+  describe('send401IfNoUser', () => {\n+    beforeEach(() => {\n+      fastify.addHook('onRequest', fastify.send401IfNoUser);\n+    });\n+\n+    it('should return 401 if no user is present', async () => {\n+      const message = {\n+        type: 'danger',\n+        content: 'Something undesirable occurred'\n+      };\n+      authorizeSpy.mockImplementationOnce((req, _reply, done) => {\n+        req.accessDeniedMessage = message;\n+        done();\n+      });\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/'\n+      });\n+\n+      expect(res.json()).toStrictEqual({\n+        type: message.type,\n+        message: message.content\n+      });\n+      expect(res.statusCode).toEqual(401);\n+    });\n+\n+    it('should not alter the response if a user is present', async () => {\n+      authorizeSpy.mockImplementationOnce((req, _reply, done) => {\n+        req.user = { id: '123' };\n+        done();\n+      });\n+\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/'\n+      });\n+\n+      expect(res.json()).toEqual({ foo: 'bar' });\n+      expect(res.statusCode).toEqual(200);\n+    });\n+  });\n+\n+  describe('redirectIfNoUser', () => {\n+    beforeEach(() => {\n+      fastify.addHook('onRequest', fastify.redirectIfNoUser);\n+    });\n+    const redirectLocation = `${HOME_LOCATION}?${formatMessage({ type: 'info', content: 'Only authenticated users can access this route. Please sign in and try again.' })}`;\n+\n+    it('should redirect to HOME_LOCATION if no user is present', async () => {\n+      const message = {\n+        type: 'danger',\n+        content: 'At the moment, content is ignored'\n+      };\n+      authorizeSpy.mockImplementationOnce((req, _reply, done) => {\n+        req.accessDeniedMessage = message;\n+        done();\n+      });\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/'\n+      });\n+\n+      expect(res.headers.location).toBe(redirectLocation);\n+      expect(res.statusCode).toEqual(302);\n+    });\n+\n+    it('should not alter the response if a user is present', async () => {\n+      authorizeSpy.mockImplementationOnce((req, _reply, done) => {\n+        req.user = { id: '123' };\n+        done();\n+      });\n+\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/'\n+      });\n+\n+      expect(res.json()).toEqual({ foo: 'bar' });\n+      expect(res.statusCode).toEqual(200);\n+    });\n+  });\n+\n+  describe('fallback hook', () => {\n+    it('should reject unauthed requests when no other reject hooks are added', async () => {\n+      const message = {\n+        type: 'danger',\n+        content: 'Something undesirable occurred'\n+      };\n+      authorizeSpy.mockImplementationOnce((req, _reply, done) => {\n+        req.accessDeniedMessage = message;\n+        done();\n+      });\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/'\n+      });\n+\n+      expect(res.json()).toStrictEqual({\n+        type: message.type,\n+        message: message.content\n+      });\n+    });\n+\n+    it('should not be called if another reject hook is added', async () => {\n+      const redirectLocation = `${HOME_LOCATION}?${formatMessage({ type: 'info', content: 'Only authenticated users can access this route. Please sign in and try again.' })}`;\n+      const message = {\n+        type: 'danger',\n+        content: 'Something undesirable occurred'\n+      };\n+      // using redirectIfNoUser as the reject hook since then it's obvious that\n+      // the fallback hook is not called.\n+      fastify.addHook('onRequest', fastify.redirectIfNoUser);\n+      authorizeSpy.mockImplementationOnce((req, _reply, done) => {\n+        req.accessDeniedMessage = message;\n+        done();\n+      });\n+      const res = await fastify.inject({\n+        method: 'GET',\n+        url: '/'\n+      });\n+\n+      expect(res.headers.location).toBe(redirectLocation);\n+      expect(res.statusCode).toEqual(302);\n+    });\n+  });\n+});"
        },
        {
            "sha": "61d6f71121dacb7de27bf73a454d5f03759300f3",
            "filename": "api/src/plugins/bouncer.ts",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fplugins%2Fbouncer.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fplugins%2Fbouncer.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fplugins%2Fbouncer.ts?ref=e9ac6c5e729afab476c1657089de1722149bb768",
            "patch": "@@ -0,0 +1,48 @@\n+import type {\n+  FastifyPluginCallback,\n+  FastifyRequest,\n+  FastifyReply\n+} from 'fastify';\n+import fp from 'fastify-plugin';\n+import { getRedirectParams } from '../utils/redirection';\n+\n+declare module 'fastify' {\n+  interface FastifyInstance {\n+    send401IfNoUser: (req: FastifyRequest, reply: FastifyReply) => void;\n+    redirectIfNoUser: (req: FastifyRequest, reply: FastifyReply) => void;\n+  }\n+}\n+\n+const plugin: FastifyPluginCallback = (fastify, _options, done) => {\n+  fastify.decorate(\n+    'send401IfNoUser',\n+    async function (req: FastifyRequest, reply: FastifyReply) {\n+      if (!req.user) {\n+        await reply.status(401).send({\n+          type: req.accessDeniedMessage?.type,\n+          message: req.accessDeniedMessage?.content\n+        });\n+      }\n+    }\n+  );\n+\n+  fastify.decorate(\n+    'redirectIfNoUser',\n+    async function (req: FastifyRequest, reply: FastifyReply) {\n+      if (!req.user) {\n+        const { origin } = getRedirectParams(req);\n+        await reply.redirectWithMessage(origin, {\n+          type: 'info',\n+          content:\n+            'Only authenticated users can access this route. Please sign in and try again.'\n+        });\n+      }\n+    }\n+  );\n+\n+  fastify.addHook('preParsing', fastify.send401IfNoUser);\n+\n+  done();\n+};\n+\n+export default fp(plugin, { dependencies: ['auth', 'redirect-with-message'] });"
        },
        {
            "sha": "86d91ad69300e2fa69dd6cfd7619353b7aac6ba7",
            "filename": "api/src/plugins/code-flow-auth.test.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 328,
            "changes": 328,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/7d84da184ade6ef45709d6808a3afafab849c4c8/api%2Fsrc%2Fplugins%2Fcode-flow-auth.test.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/7d84da184ade6ef45709d6808a3afafab849c4c8/api%2Fsrc%2Fplugins%2Fcode-flow-auth.test.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fplugins%2Fcode-flow-auth.test.ts?ref=7d84da184ade6ef45709d6808a3afafab849c4c8",
            "patch": "@@ -1,328 +0,0 @@\n-import Fastify, { FastifyInstance } from 'fastify';\n-import jwt from 'jsonwebtoken';\n-\n-import { COOKIE_DOMAIN, HOME_LOCATION, JWT_SECRET } from '../utils/env';\n-import { type Token, createAccessToken } from '../utils/tokens';\n-import cookies, { sign as signCookie, unsign as unsignCookie } from './cookies';\n-import codeFlowAuth from './code-flow-auth';\n-import redirectWithMessage, { formatMessage } from './redirect-with-message';\n-\n-describe('auth', () => {\n-  let fastify: FastifyInstance;\n-\n-  beforeEach(async () => {\n-    fastify = Fastify();\n-    await fastify.register(cookies);\n-    await fastify.register(redirectWithMessage);\n-    await fastify.register(codeFlowAuth);\n-  });\n-\n-  afterEach(async () => {\n-    await fastify.close();\n-  });\n-\n-  describe('setAccessTokenCookie', () => {\n-    // We won't need to keep doubly signing the cookie when we migrate the\n-    // authentication, but for the MVP we have to be able to read the cookies\n-    // set by the api-server. So, double signing:\n-    it('should doubly sign the cookie', async () => {\n-      const token = createAccessToken('test-id');\n-      fastify.get('/test', async (req, reply) => {\n-        reply.setAccessTokenCookie(token);\n-        return { ok: true };\n-      });\n-\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test'\n-      });\n-\n-      const { value, ...rest } = res.cookies[0]!;\n-      const unsignedOnce = unsignCookie(value);\n-      const unsignedTwice = jwt.verify(unsignedOnce.value!, JWT_SECRET) as {\n-        accessToken: Token;\n-      };\n-      expect(unsignedTwice.accessToken).toEqual(token);\n-      expect(rest).toEqual({\n-        name: 'jwt_access_token',\n-        path: '/',\n-        sameSite: 'Lax',\n-        domain: COOKIE_DOMAIN,\n-        maxAge: token.ttl\n-      });\n-    });\n-\n-    // TODO: Post-MVP sync the cookie max-age with the token ttl (i.e. the\n-    // max-age should be the ttl/1000, not ttl)\n-    it('should set the max-age of the cookie to match the ttl of the token', async () => {\n-      const token = createAccessToken('test-id', 123000);\n-      fastify.get('/test', async (req, reply) => {\n-        reply.setAccessTokenCookie(token);\n-        return { ok: true };\n-      });\n-\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test'\n-      });\n-\n-      expect(res.cookies[0]).toEqual(\n-        expect.objectContaining({\n-          maxAge: 123000\n-        })\n-      );\n-    });\n-  });\n-\n-  describe('authorize', () => {\n-    beforeEach(() => {\n-      fastify.addHook('onRequest', fastify.authorize);\n-      fastify.get('/test', () => {\n-        return { message: 'ok' };\n-      });\n-    });\n-\n-    it('should reject if the access token is missing', async () => {\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test'\n-      });\n-\n-      expect(res.json()).toEqual({\n-        type: 'info',\n-        message: 'Access token is required for this request'\n-      });\n-      expect(res.statusCode).toBe(401);\n-    });\n-\n-    it('should reject if the access token is not signed', async () => {\n-      const token = jwt.sign(\n-        { accessToken: createAccessToken('123') },\n-        JWT_SECRET\n-      );\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test',\n-        cookies: {\n-          jwt_access_token: token\n-        }\n-      });\n-\n-      expect(res.json()).toEqual({\n-        type: 'info',\n-        message: 'Access token is required for this request'\n-      });\n-      expect(res.statusCode).toBe(401);\n-    });\n-\n-    it('should reject if the access token is invalid', async () => {\n-      const token = jwt.sign(\n-        { accessToken: createAccessToken('123') },\n-        'invalid-secret'\n-      );\n-\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test',\n-        cookies: {\n-          jwt_access_token: signCookie(token)\n-        }\n-      });\n-\n-      expect(res.json()).toEqual({\n-        type: 'info',\n-        message: 'Your access token is invalid'\n-      });\n-      expect(res.statusCode).toBe(401);\n-    });\n-\n-    it('should reject if the access token has expired', async () => {\n-      const token = jwt.sign(\n-        { accessToken: createAccessToken('123', -1) },\n-        JWT_SECRET\n-      );\n-\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test',\n-        cookies: {\n-          jwt_access_token: signCookie(token)\n-        }\n-      });\n-\n-      expect(res.json()).toEqual({\n-        type: 'info',\n-        message: 'Access token is no longer valid'\n-      });\n-      expect(res.statusCode).toBe(401);\n-    });\n-\n-    it('should reject if the user is not found', async () => {\n-      // @ts-expect-error prisma isn't defined, since we're not building the\n-      // full application here.\n-      fastify.prisma = { user: { findUnique: () => null } };\n-      const token = jwt.sign(\n-        { accessToken: createAccessToken('123') },\n-        JWT_SECRET\n-      );\n-\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test',\n-        cookies: {\n-          jwt_access_token: signCookie(token)\n-        }\n-      });\n-\n-      expect(res.json()).toEqual({\n-        type: 'info',\n-        message: 'Your access token is invalid'\n-      });\n-    });\n-\n-    it('should populate the request with the user if the token is valid', async () => {\n-      const fakeUser = { id: '123', username: 'test-user' };\n-      // @ts-expect-error prisma isn't defined, since we're not building the\n-      // full application here.\n-      fastify.prisma = { user: { findUnique: () => fakeUser } };\n-      fastify.get('/test-user', req => {\n-        expect(req.user).toEqual(fakeUser);\n-        return { ok: true };\n-      });\n-\n-      const token = jwt.sign(\n-        { accessToken: createAccessToken('123') },\n-        JWT_SECRET\n-      );\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test-user',\n-        cookies: {\n-          jwt_access_token: signCookie(token)\n-        }\n-      });\n-\n-      expect(res.json()).toEqual({ ok: true });\n-    });\n-  });\n-\n-  describe('authorizeOrRedirect', () => {\n-    const redirectLocation = `${HOME_LOCATION}?${formatMessage({ type: 'info', content: 'Only authenticated users can access this route. Please sign in and try again.' })}`;\n-\n-    beforeEach(() => {\n-      fastify.addHook('onRequest', fastify.authorizeOrRedirect);\n-      fastify.get('/test', () => {\n-        return { message: 'ok' };\n-      });\n-    });\n-\n-    it('should redirect to the origin if the access token is missing', async () => {\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test'\n-      });\n-\n-      expect(res.headers.location).toBe(redirectLocation);\n-      expect(res.statusCode).toBe(302);\n-    });\n-\n-    it('should redirect to the origin if the access token is not signed', async () => {\n-      const token = jwt.sign(\n-        { accessToken: createAccessToken('123') },\n-        JWT_SECRET\n-      );\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test',\n-        cookies: {\n-          jwt_access_token: token\n-        }\n-      });\n-\n-      expect(res.headers.location).toBe(redirectLocation);\n-      expect(res.statusCode).toBe(302);\n-    });\n-\n-    it('should redirect to the origin if the access token is invalid', async () => {\n-      const token = jwt.sign(\n-        { accessToken: createAccessToken('123') },\n-        'invalid-secret'\n-      );\n-\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test',\n-        cookies: {\n-          jwt_access_token: signCookie(token)\n-        }\n-      });\n-\n-      expect(res.headers.location).toBe(redirectLocation);\n-      expect(res.statusCode).toBe(302);\n-    });\n-\n-    it('should redirect to the origin if the access token has expired', async () => {\n-      const token = jwt.sign(\n-        { accessToken: createAccessToken('123', -1) },\n-        JWT_SECRET\n-      );\n-\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test',\n-        cookies: {\n-          jwt_access_token: signCookie(token)\n-        }\n-      });\n-\n-      expect(res.headers.location).toBe(redirectLocation);\n-      expect(res.statusCode).toBe(302);\n-    });\n-\n-    it('should redirect to the origin if the user is not found', async () => {\n-      // @ts-expect-error prisma isn't defined, since we're not building the\n-      // full application here.\n-      fastify.prisma = { user: { findUnique: () => null } };\n-      const token = jwt.sign(\n-        { accessToken: createAccessToken('123') },\n-        JWT_SECRET\n-      );\n-\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test',\n-        cookies: {\n-          jwt_access_token: signCookie(token)\n-        }\n-      });\n-\n-      expect(res.headers.location).toBe(redirectLocation);\n-      expect(res.statusCode).toBe(302);\n-    });\n-\n-    it('should populate the request with the user if the token is valid', async () => {\n-      const fakeUser = { id: '123', username: 'test-user' };\n-      // @ts-expect-error prisma isn't defined, since we're not building the\n-      // full application here.\n-      fastify.prisma = { user: { findUnique: () => fakeUser } };\n-      fastify.get('/test-user', req => {\n-        expect(req.user).toEqual(fakeUser);\n-        return { ok: true };\n-      });\n-\n-      const token = jwt.sign(\n-        { accessToken: createAccessToken('123') },\n-        JWT_SECRET\n-      );\n-      const res = await fastify.inject({\n-        method: 'GET',\n-        url: '/test-user',\n-        cookies: {\n-          jwt_access_token: signCookie(token)\n-        }\n-      });\n-\n-      expect(res.json()).toEqual({ ok: true });\n-    });\n-  });\n-});"
        },
        {
            "sha": "7b9e8cca6ebf08c5de22641cea76ca044a8ea741",
            "filename": "api/src/plugins/code-flow-auth.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 106,
            "changes": 106,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/7d84da184ade6ef45709d6808a3afafab849c4c8/api%2Fsrc%2Fplugins%2Fcode-flow-auth.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/7d84da184ade6ef45709d6808a3afafab849c4c8/api%2Fsrc%2Fplugins%2Fcode-flow-auth.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fplugins%2Fcode-flow-auth.ts?ref=7d84da184ade6ef45709d6808a3afafab849c4c8",
            "patch": "@@ -1,106 +0,0 @@\n-import { FastifyPluginCallback, FastifyReply, FastifyRequest } from 'fastify';\n-import fp from 'fastify-plugin';\n-import jwt from 'jsonwebtoken';\n-import { type user } from '@prisma/client';\n-\n-import { JWT_SECRET } from '../utils/env';\n-import { type Token, isExpired } from '../utils/tokens';\n-import { getRedirectParams } from '../utils/redirection';\n-\n-declare module 'fastify' {\n-  interface FastifyReply {\n-    setAccessTokenCookie: (this: FastifyReply, accessToken: Token) => void;\n-  }\n-\n-  interface FastifyRequest {\n-    // TODO: is the full user the correct type here?\n-    user?: user;\n-  }\n-\n-  interface FastifyInstance {\n-    authorize: (req: FastifyRequest, reply: FastifyReply) => void;\n-    authorizeOrRedirect: (req: FastifyRequest, reply: FastifyReply) => void;\n-  }\n-}\n-\n-const codeFlowAuth: FastifyPluginCallback = (fastify, _options, done) => {\n-  fastify.decorateReply('setAccessTokenCookie', function (accessToken: Token) {\n-    const signedToken = jwt.sign({ accessToken }, JWT_SECRET);\n-    void this.setCookie('jwt_access_token', signedToken, {\n-      httpOnly: false,\n-      secure: false,\n-      maxAge: accessToken.ttl\n-    });\n-  });\n-\n-  const TOKEN_REQUIRED = 'Access token is required for this request';\n-  const TOKEN_INVALID = 'Your access token is invalid';\n-  const TOKEN_EXPIRED = 'Access token is no longer valid';\n-\n-  const send401 = (\n-    _req: FastifyRequest,\n-    reply: FastifyReply,\n-    message: string\n-  ): void => {\n-    void reply.status(401).send({ type: 'info', message });\n-  };\n-\n-  const redirectHome = (\n-    req: FastifyRequest,\n-    reply: FastifyReply,\n-    _ignored: string\n-  ) => {\n-    const { origin } = getRedirectParams(req);\n-\n-    void reply.redirectWithMessage(origin, {\n-      type: 'info',\n-      content:\n-        'Only authenticated users can access this route. Please sign in and try again.'\n-    });\n-  };\n-\n-  const handleAuth =\n-    (\n-      rejectStrategy: (\n-        req: FastifyRequest,\n-        reply: FastifyReply,\n-        message: string\n-      ) => void\n-    ) =>\n-    async (req: FastifyRequest, reply: FastifyReply) => {\n-      const tokenCookie = req.cookies.jwt_access_token;\n-      if (!tokenCookie) return rejectStrategy(req, reply, TOKEN_REQUIRED);\n-\n-      const unsignedToken = req.unsignCookie(tokenCookie);\n-      if (!unsignedToken.valid)\n-        return rejectStrategy(req, reply, TOKEN_REQUIRED);\n-\n-      const jwtAccessToken = unsignedToken.value;\n-\n-      try {\n-        jwt.verify(jwtAccessToken, JWT_SECRET);\n-      } catch {\n-        return rejectStrategy(req, reply, TOKEN_INVALID);\n-      }\n-\n-      const { accessToken } = jwt.decode(jwtAccessToken) as {\n-        accessToken: Token;\n-      };\n-\n-      if (isExpired(accessToken))\n-        return rejectStrategy(req, reply, TOKEN_EXPIRED);\n-\n-      const user = await fastify.prisma.user.findUnique({\n-        where: { id: accessToken.userId }\n-      });\n-      if (!user) return rejectStrategy(req, reply, TOKEN_INVALID);\n-      req.user = user;\n-    };\n-\n-  fastify.decorate('authorize', handleAuth(send401));\n-  fastify.decorate('authorizeOrRedirect', handleAuth(redirectHome));\n-\n-  done();\n-};\n-\n-export default fp(codeFlowAuth, { dependencies: ['redirect-with-message'] });"
        },
        {
            "sha": "6611855da74e2e87c42bfed70ae8f2ed29e6cd20",
            "filename": "api/src/plugins/cookies.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fplugins%2Fcookies.ts",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/e9ac6c5e729afab476c1657089de1722149bb768/api%2Fsrc%2Fplugins%2Fcookies.ts",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/api%2Fsrc%2Fplugins%2Fcookies.ts?ref=e9ac6c5e729afab476c1657089de1722149bb768",
            "patch": "@@ -75,4 +75,4 @@ const cookies: FastifyPluginCallback = (fastify, _options, done) => {\n   done();\n };\n \n-export default fp(cookies);\n+export default fp(cookies, { name: 'cookies' });"
        }
    ],
    "stats": {
        "total": 1045,
        "additions": 578,
        "deletions": 467
    }
}