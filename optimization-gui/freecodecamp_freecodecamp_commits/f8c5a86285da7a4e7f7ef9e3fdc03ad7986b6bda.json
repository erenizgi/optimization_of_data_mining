{
    "author": "scissorsneedfoodtoo",
    "message": "feat: add react debugging video ids and transcripts (#59632)\n\nCo-authored-by: Dario-DC <105294544+Dario-DC@users.noreply.github.com>\nCo-authored-by: Zaira <33151350+zairahira@users.noreply.github.com>",
    "sha": "f8c5a86285da7a4e7f7ef9e3fdc03ad7986b6bda",
    "files": [
        {
            "sha": "23e2a34aa09d8b2ca30fe229675515a3078303f6",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-react-strategies-and-debugging/67d1ad82cff954a854bcbcaa.md",
            "status": "modified",
            "additions": 107,
            "deletions": 2,
            "changes": 109,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/f8c5a86285da7a4e7f7ef9e3fdc03ad7986b6bda/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-react-strategies-and-debugging%2F67d1ad82cff954a854bcbcaa.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/f8c5a86285da7a4e7f7ef9e3fdc03ad7986b6bda/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-react-strategies-and-debugging%2F67d1ad82cff954a854bcbcaa.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-react-strategies-and-debugging%2F67d1ad82cff954a854bcbcaa.md?ref=f8c5a86285da7a4e7f7ef9e3fdc03ad7986b6bda",
            "patch": "@@ -2,13 +2,118 @@\n id: 67d1ad82cff954a854bcbcaa\n title: What Is Prop Drilling?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: 83LkOesFkWI\n dashedName: what-is-prop-drilling\n ---\n \n # --description--\n \n-Watch the video lecture and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What is prop drilling?\n+\n+Prop drilling is the most basic approach to state management in React applications. It looks simple, but can get messy quickly, and is very hard to scale.\n+\n+Let's look at what prop drilling is, why it's a problem, and a good replacement for it as an application grows.\n+\n+Prop drilling is the process of passing props from a parent component to deeply nested child components, even when some of the child components don't need the props.\n+\n+For example, say you have three components named `Parent`, `Child`, and `Grandchild`. If you want to use some data in the `Grandchild` component, but it's in the `Parent` component, you'd need to pass it from the `Parent` to the `Child` component, then from the `Child` to the `Grandchild` component.\n+\n+Or if the data is even further up the chain, the data might have to be passed to the `Parent` component, too.\n+\n+Here, the data I want to display is the string `Hello, Prop Drilling!`. It's assigned to the `greeting` variable in the root `App` component:\n+\n+```jsx\n+import \"./App.css\";\n+import Parent from \"./Parent\";\n+\n+function App() {\n+  const greeting = \"Hello, Prop Drilling!\";\n+\n+  return <Parent greeting={greeting} />;\n+}\n+\n+export default App;\n+```\n+\n+You can see the `Parent` component is also receiving the `greeting` variable as the value of a `greeting` prop. Here's the `Parent` component passing it into the `Child` component as the value of another `greeting` prop in the `Child`:\n+\n+```jsx\n+import Child from \"./Child\";\n+\n+const Parent = ({ greeting }) => {\n+  return <Child greeting={greeting} />;\n+};\n+\n+export default Parent;\n+```\n+\n+And here's the `Child` component that passes it to the `Grandchild` component:\n+\n+```jsx\n+import Grandchild from \"./Grandchild\";\n+\n+const Child = ({ greeting }) => {\n+  return <Grandchild greeting={greeting} />;\n+};\n+\n+export default Child;\n+```\n+\n+And finally the `Grandchild` component receives the greeting and uses it as the content of an `h1` element:\n+\n+```jsx\n+const Grandchild = ({ greeting }) => {\n+  return <h1>{greeting}</h1>;\n+};\n+\n+export default Grandchild;\n+```\n+\n+In the browser, you'll see a page with a single `h1` element that has the text `Hello, Prop Drilling!`.\n+\n+At first, prop drilling might not seem like such a big deal. But as your app grows, it gets harder to understand, debug, and maintain.\n+\n+If you need to pass props around, try to keep them all in a single parent component. This approach of centralizing all necessary data is called the \"single source of truth\".\n+\n+For instance, say you want to add a new `response` to go with your `greeting`, and that you want to use both of them in the `Grandchild` component. Since `greeting` is already in the `App` component, it makes sense to put `response` there, too, and pass both of them down the chain:\n+\n+```jsx\n+function App() {\n+  const greeting = \"Hello, Prop Drilling!\";\n+  const response = \"I'm not here to play!\";\n+\n+  return <Parent greeting={greeting} response={response} />;\n+}\n+\n+const Parent = ({ greeting, response }) => {\n+  return <Child greeting={greeting} response={response} />;\n+};\n+\n+const Child = ({ greeting, response }) => {\n+  return <Grandchild greeting={greeting} response={response} />;\n+};\n+\n+const Grandchild = ({ greeting, response }) => {\n+  return (\n+    <>\n+      <h1>{greeting}</h1>\n+      <h2>{response}</h2>\n+    </>\n+  );\n+};\n+\n+export default App;\n+```\n+\n+In the browser, you'll see a page with an `h1` element that has the text `Hello, Prop Drilling!` and an `h2` element that has the text `I'm not here to play!`.\n+\n+To avoid prop drilling, especially in large, complex applications, consider using the Context API or state management libraries like Redux and Redux Toolkit, Zustand, Recoil, and others.\n+\n+You'll learn more about these in the coming lectures.\n \n # --questions--\n "
        },
        {
            "sha": "87fbfccf515ae3b310abf3bee5a2f44828baf53b",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-react-strategies-and-debugging/67d2f5b78609f97400923f7f.md",
            "status": "modified",
            "additions": 196,
            "deletions": 10,
            "changes": 206,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/f8c5a86285da7a4e7f7ef9e3fdc03ad7986b6bda/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-react-strategies-and-debugging%2F67d2f5b78609f97400923f7f.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/f8c5a86285da7a4e7f7ef9e3fdc03ad7986b6bda/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-react-strategies-and-debugging%2F67d2f5b78609f97400923f7f.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-react-strategies-and-debugging%2F67d2f5b78609f97400923f7f.md?ref=f8c5a86285da7a4e7f7ef9e3fdc03ad7986b6bda",
            "patch": "@@ -2,13 +2,199 @@\n id: 67d2f5b78609f97400923f7f\n title: What Are State Management Libraries, and When Should You Use Them?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: 9GBjI8LDauU\n dashedName: what-are-state-management-libraries-and-when-should-you-use-them\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What are state management libraries, and when should you use them?\n+\n+As your app grows, managing how data flows between components can become complex.\n+\n+When starting out, React's `useState` hook might be sufficient, but as you add features, you might encounter issues with:\n+\n+- Passing props through components that don't need them, also known as prop drilling\n+- Keeping data in sync across different parts of your app\n+- Handling complex updates that affect multiple components simultaneously\n+\n+These and other challenges may arise, which can lead to a codebase that's harder to maintain, debug, and test. That's where state management libraries come in – they provide a centralized place where components can get or update the data they need.\n+\n+Let's take a look at a few different state management options you have, and when to use them.\n+\n+The Context API is a state manager built into React that lets you share state across components without using a third-party library. It's a well-established upgrade over the `useState` hook, so it is perfect for cases like theme toggling or user authentication status.\n+\n+However, the Context API does not handle frequent updates well, and can cause unnecessary re-renders, making it less suitable for complex state needs in applications like eCommerce and social media platforms. \n+\n+Here's a counter component that demonstrates the basic usage of the Context API:\n+\n+```jsx\n+import { useState, createContext } from 'react';\n+\n+const CounterContext = createContext();\n+\n+const CounterProvider = ({ children }) => {\n+  const [count, setCount] = useState(0);\n+\n+  return (\n+    <CounterContext.Provider value={{ count, setCount }}>\n+      {children}\n+    </CounterContext.Provider>\n+  );\n+};\n+\n+export { CounterContext, CounterProvider };\n+```\n+\n+This code creates a context and a provider to share a `count` state across the application.\n+\n+`CounterProvider` uses the `useState` hook to initialize and manage the `count` state and its setter. Both are then passed into child components through the `Provider`.\n+\n+So, when you wrap your whole app with the `CounterProvider`, the `count` state is available everywhere in your application.\n+\n+Here's how you can wrap `CounterProvider` around your application:\n+\n+```jsx\n+import { CounterProvider } from './context/CounterContext';\n+\n+function App() {\n+  return (\n+    <CounterProvider>\n+        {/* App components */}\n+    </CounterProvider>\n+  );\n+}\n+\n+export default App;\n+```\n+\n+And here's how you can use the `count` state:\n+\n+```jsx\n+import React, { useContext } from 'react';\n+import { CounterContext } from '../context/CounterContext';\n+\n+const Counter = () => {\n+  const { count, setCount } = useContext(CounterContext);\n+\n+  return (\n+    <>\n+      <div style={{ textAlign: 'center' }}>\n+        <h1>Context API Counter</h1>\n+        <button style={{ marginRight: '5px' }} onClick={() => setCount(count - 1)}>\n+          Decrease\n+        </button>\n+        <span>{count}</span>\n+        <button style={{ marginLeft: '5px' }} onClick={() => setCount(count + 1)}>\n+          Increase\n+        </button>\n+      </div>\n+    </>\n+  );\n+};\n+\n+export default Counter;\n+```\n+\n+As you can see, the `count` and its setter function, `setCount`, are initialized through the `useContext` function. \n+\n+The current `count` state is then displayed, and `setCount` is used to increase and decrease the `count` state when the user clicks the decrement and increment buttons respectively.\n+\n+Another popular state management library is Redux, which is one of the most popular state management libraries to use with React. It's been around for a long time, and is ideal for larger applications like eCommerce and social media platforms, forums, and so on.\n+\n+Redux handles state management by providing a central store and strict control over state updates. It uses a predictable pattern with actions, reducers, and middleware.\n+\n+Actions are payloads of information that send data from your application to the Redux store, often triggered by user interactions.\n+\n+Reducers are functions that specify how the state should change in response to those actions, ensuring the state is updated in an immutable way.\n+\n+Middleware, on the other hand, acts as a bridge between the action dispatching and the reducer, allowing you to extend Redux's functionality (for example, logging, handling async operations) without modifying the core flow.\n+\n+The most common complaint about Redux is with all the boilerplate code you need to get started. In response, the Redux team introduced \"Redux Toolkit\" and \"RTK Query\", which simplify the setup process quite a bit.\n+\n+You typically define both actions and reducers in a single file using the `createSlice()` function. It's common to name the file so it ends with the word `Slice`, for example, `productSlice`, `userSlice`, `counterSlice`, and so on.\n+\n+Here's a `counterSlice` file to show you the basics:\n+\n+```jsx\n+import { createSlice } from '@reduxjs/toolkit';\n+\n+const counterSlice = createSlice({\n+  name: 'counter',\n+\n+  initialState: { count: 0 },\n+\n+  reducers: {\n+    increment: (state) => {\n+      state.count += 1;\n+    },\n+    decrement: (state) => {\n+      state.count -= 1;\n+    },\n+  },\n+});\n+\n+export const { increment, decrement } = counterSlice.actions;\n+\n+export default counterSlice.reducer;\n+```\n+\n+From here, you then need to wrap the entire app with the `Provider`, select a piece of state from the slice with `useSelector()`, then use `useDispatch()` to make the state active.\n+\n+Another option to consider is Zustand.\n+\n+Zustand is a lightweight state management library with a simple API. It is based on hooks, so there's less boilerplate compared to Redux, making it easier and quicker to set up.\n+\n+Zustand is ideal for small to medium-scale applications. It works by using a `useStore` hook to access access state directly in components and pages. This lets you modify and access data without needing actions, reducers, or a provider.\n+\n+Here's a `useCounterStore` that implements another counter functionality:\n+\n+```jsx\n+import { create } from 'zustand';\n+\n+const useCounterStore = create((set) => ({\n+  count: 0,\n+  increment: () => set((state) => ({ count: state.count + 1 })),\n+  decrement: () => set((state) => ({ count: state.count - 1 })),\n+}));\n+\n+export default useCounterStore;\n+```\n+\n+And here's how to initialize and use the states in your app:\n+\n+```jsx\n+// Import the useCounterStore (it's just a hook)\n+import useCounterStore from '../useCounterStore';\n+\n+const Counter = () => {\n+  // Initialize the states with the useCounterStore hook\n+  const { count, increment, decrement } = useCounterStore();\n+\n+  return (\n+    <>\n+      <div style={{ textAlign: 'center' }}>\n+        <h1>Zustand Counter</h1>\n+        <button style={{ marginRight: '5px' }} onClick={() => decrement()}>\n+          Decrease\n+        </button>\n+        <span>{count}</span>\n+        <button style={{ marginLeft: '5px' }} onClick={() => increment()}>\n+          Increase\n+        </button>\n+      </div>\n+    </>\n+  );\n+};\n+\n+export default Counter;\n+```\n+\n+Even though the frontend ecosystem is constantly evolving and new state management libraries regularly emerge, the ones we've discussed are widely used in the industry.\n \n # --questions--\n \n@@ -86,35 +272,35 @@ Axios\n \n ## --text--\n \n-What is the popular complaint about Redux, and how was it addressed?\n+What was a common complaint about Redux, and how was it addressed?\n \n ## --answers--\n \n-Limited browser support; addressed by creating polyfills.\n+It had limited browser support, which was addressed by creating polyfills.\n \n ### --feedback--\n \n-Think about improvements made to reduce setup complexity.\n+Think about the improvements that were made to reduce setup complexity.\n \n ---\n \n-Performance issues; addressed by optimizing middleware.\n+It had performance issues, which were addressed by optimizing its middleware.\n \n ### --feedback--\n \n-Think about improvements made to reduce setup complexity.\n+Think about the improvements that were made to reduce setup complexity.\n \n ---\n \n-Complexity of boilerplate code; addressed with Redux Toolkit and RTK Query.\n+It required a lot of complex boilerplate code, which was addressed by Redux Toolkit and RTK Query.\n \n ---\n \n-Lack of documentation; addressed by adding more examples.\n+There was a lack of documentation, which was addressed by adding more examples.\n \n ### --feedback--\n \n-Think about improvements made to reduce setup complexity.\n+Think about the improvements that were made to reduce setup complexity.\n \n ## --video-solution--\n "
        },
        {
            "sha": "76c858753b09b65ab66453466680b8ee0750cf92",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-react-strategies-and-debugging/67d2f5dacd5e0c749e5d534c.md",
            "status": "modified",
            "additions": 86,
            "deletions": 2,
            "changes": 88,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/f8c5a86285da7a4e7f7ef9e3fdc03ad7986b6bda/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-react-strategies-and-debugging%2F67d2f5dacd5e0c749e5d534c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/f8c5a86285da7a4e7f7ef9e3fdc03ad7986b6bda/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-react-strategies-and-debugging%2F67d2f5dacd5e0c749e5d534c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-react-strategies-and-debugging%2F67d2f5dacd5e0c749e5d534c.md?ref=f8c5a86285da7a4e7f7ef9e3fdc03ad7986b6bda",
            "patch": "@@ -2,13 +2,97 @@\n id: 67d2f5dacd5e0c749e5d534c\n title: How Can You Debug Your React Components Using the React DevTools?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: ghTDVD-hPuc\n dashedName: how-can-you-debug-your-react-components-using-react-devtools\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How can you debug your React components using the React DevTools?\n+\n+The browser has built-in developer tools you can use to debug HTML, CSS, and JavaScript.\n+\n+However, they're not great for finding and fixing bugs in React apps. So the React team developed a tool called \"React Developer Tools\" (AKA React DevTools) so you can inspect, debug, and profile React apps.\n+\n+React DevTools is available as a browser extension for Chrome, Edge, and Firefox. If you're on Chrome or Edge, head over to the Chrome web store, search for \"React Developer Tools”, and add it to your browser.\n+\n+And if you use Firefox, head over to the Firefox Add-ons page, search for the tool, and add it to your browser.\n+\n+If you use Safari, you can install React DevTools from npm by running `npm install -g react-devtools` or `yarn global add react-devtools`.\n+\n+After installing and enabling React DevTools, if you open a React app in your browser, then open your browser's developer tools, you should see two extra tabs: Components and Profiler.\n+\n+The Components tab displays each component for you in a tree view format. With it, you can: \n+\n+- View the app's component hierarchy.\n+- Check and modify props, states, and context values in real time.\n+- Check the source code for each selected component.\n+- Log the component data to the console.\n+- Inspect the DOM elements for the component.\n+\n+On the other hand, the Profiler tab helps you record and analyze component performance so you can identify unnecessary re-renders, view commit durations, and things you can optimize.\n+\n+Here's a simple app to show you how you can inspect components and any props and state they have. This is similar to the code we used in a previous lecture on prop drilling:\n+\n+```jsx\n+import { useState } from \"react\";\n+\n+export default function App() {\n+  const greeting = \"Hello, Prop Drilling!\";\n+  const response = \"I'm not here to play!\";\n+\n+  return <Parent greeting={greeting} response={response} />;\n+}\n+\n+const Parent = ({ greeting, response }) => {\n+  return <Child greeting={greeting} response={response} />;\n+};\n+\n+const Child = ({ greeting, response }) => {\n+  return <Grandchild greeting={greeting} response={response} />;\n+};\n+\n+const Grandchild = ({ greeting, response }) => {\n+  const [count, setCount] = useState(0);\n+\n+  return (\n+    <>\n+      <h1>{greeting}</h1>\n+      <h2>{response}</h2>\n+\n+      <button onClick={() => setCount(count + 1)}>Increase Count</button>\n+      <h2>Count: {count}</h2>\n+      <button onClick={() => setCount(count - 1)}>Decrease Count</button>\n+    </>\n+  );\n+};\n+```\n+\n+If you look in the Components tab in React DevTools, you can see the tree view of the components. The `App` component is at the top, followed by the `Parent`, `Child`, and `Grandchild` components.\n+\n+If you select any of these components, you can see the props and state in them. If you select the `Parent` component, you can see the `greeting` and `response` props, which are `Hello, Prop Drilling!` and `I'm not here to play!`, respectively.\n+\n+You can see the props and update state in real-time, and change them if necessary. For instance, you can select the `Grandchild` component and change the `greeting` prop from `Hello, Prop Drilling!` to `Hello, Welcome to Prop Drilling!`, and see it reflected on the page immediately.\n+\n+To log data in a component to the console, inspect the matching DOM elements and view the source code of the component. The icons in the top right corner let you do that. If you select the `Grandchild` component and click the `Log the component data to the console` button, it will log the props, state, hooks, nodes, and other data in the console.\n+\n+A common bug you might encounter in React is called props mismatch.\n+\n+For example, say that for the `Child` component, you mistakenly pass in `reply` as the prop instead of `response`:\n+\n+```jsx\n+const Child = ({ greeting, response }) => {\n+  return <Grandchild greeting={greeting} reply={response} />;\n+};\n+```\n+\n+Remember that `Grandchild` expects a `response` prop. Because the component receives a different prop, it can't display that text on the page, and just adds and empty `h2` to the DOM. Instead, you'll just see the `h1` element with the text `Hello, Prop Drilling!`, along with the other buttons and text already on the page. The empty `h2` element is still there, but because it's empty, you can't see it without inspecting the DOM.\n+\n+To fix this, you can inspect the prop progression from the `Parent` component down to the `Child` and edit the prop name directly. If you go to the Components tab, select the `Child` component, and change the `reply` prop to `response`, you'll see the `h2` element on the page with the text `I'm not here to play!`.\n \n # --questions--\n "
        },
        {
            "sha": "e0f2575e3863c92b87a858a29528bc00621f6fff",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-react-strategies-and-debugging/67d2f5f19a0f0b75343f1905.md",
            "status": "modified",
            "additions": 143,
            "deletions": 2,
            "changes": 145,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/f8c5a86285da7a4e7f7ef9e3fdc03ad7986b6bda/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-react-strategies-and-debugging%2F67d2f5f19a0f0b75343f1905.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/f8c5a86285da7a4e7f7ef9e3fdc03ad7986b6bda/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-react-strategies-and-debugging%2F67d2f5f19a0f0b75343f1905.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-react-strategies-and-debugging%2F67d2f5f19a0f0b75343f1905.md?ref=f8c5a86285da7a4e7f7ef9e3fdc03ad7986b6bda",
            "patch": "@@ -2,13 +2,154 @@\n id: 67d2f5f19a0f0b75343f1905\n title: What Are React Server Components, and How Do They Work?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: weeLaRgDBmg\n dashedName: what-are-react-server-components-and-how-do-they-work\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What are React Server Components, and how do they work?\n+\n+React Server Components (RSCs) is a new trend that has changed the way React developers approach things. With RSCs, more work shifts to the server, which has a lot of benefits.\n+\n+Let's take a look at what server components are, how they work, and what led to the introduction of server components.\n+\n+React Server Components are React components that render exclusively on the server, which sends only the final HTML to the client. This means those components can directly access server-side resources and dramatically reduce the amount of JavaScript sent to the browser.\n+\n+React apps have traditionally used a \"client component\" system that handles everything in a typical React app, such as rendering, interactivity, and side effects. The term \"client component\" was rarely used until the introduction of React server components recently.\n+\n+But the client component system comes with some drawbacks like large JavaScript bundles and slower initial load times.\n+\n+React frameworks like Next.js and Gatsby found workarounds to offload some processes to the server in order to fix those problems, but none of them were standardized. If you've used either framework, you've probably heard about `getServerSideProps` and `getServerData`.\n+\n+Then came React Server Components, which let you run some components entirely on the server so you can do things like data fetching and computation before any code runs in the user's browser.\n+\n+Server components were first popularized and are readily available in Next.js. Other frameworks like Remix and Gatsby are catching up, and there's an experimental plugin for Vite called `vite-plugin-react-server` which lets you build server components.\n+\n+So how do server components work?\n+\n+One of the best ways to demonstrate React Server Components is with data fetching.\n+\n+In traditional React client components, you let the browser handle API requests. Since data fetching is a side effect, you make that API call in a `useEffect` hook.\n+\n+It's also good practice to set state variables like loading, data, and error so you can indicate that the data is loading, display the data when it's ready, or display an error in your app.\n+\n+With React Server Components, you can move the entire component to the server and fetch data there without having to use `useState` or `useEffect`:\n+\n+```jsx\n+const Users = async () => {\n+  const res = await fetch(\"https://jsonplaceholder.typicode.com/users\");\n+  const users = await res.json();\n+\n+  return (\n+    <>\n+      <h1 className=\"text-4xl text-center mt-6\">Users</h1>\n+      <ul className=\"text-center mt-3\">\n+        {users.map((user) => (\n+          <li key={user.id}>{user.name}</li>\n+        ))}\n+      </ul>\n+    </>\n+  );\n+};\n+\n+export default Users;\n+```\n+\n+Because React Server Components only run on the server, you can just fetch data from an API and render just once. Also, since data fetching happens on the server, closer to the source, your app may perform better, especially for people with slow network connections.\n+\n+Once major gotcha is that all the code for server components remain on the server, and doesn't get shipped to the browser. That means you can't use React hooks with them, and they don't have access to Web APIs or browser event listeners. So how can you add interactivity?\n+\n+In the Next.js app router, all components are server components by default. If you want to add interactivity, you need to mark the component as a client component with the `\"use client\"` directive.\n+\n+Let's say you want to make the previous example a client component. Here's how you can do that:\n+\n+```jsx\n+\"use client\";\n+\n+import { useState, useEffect } from \"react\";\n+\n+const Users2 = () => {\n+  const [status, setStatus] = useState({\n+    users: [],\n+    loading: true,\n+    error: null,\n+  });\n+\n+  async function fetchUsers() {\n+    try {\n+      const res = await fetch(\"https://jsonplaceholder.typicode.com/users\");\n+      const data = await res.json();\n+      setStatus((prevStatus) => ({\n+        ...prevStatus,\n+        users: data,\n+        loading: false,\n+      }));\n+    } catch (err) {\n+      setStatus((prevStatus) => ({\n+        ...prevStatus,\n+        error: err.message,\n+        loading: false,\n+      }));\n+    }\n+  }\n+\n+  useEffect(() => {\n+    fetchUsers();\n+  }, []);\n+\n+  if (status.loading) {\n+    return <p>Loading Users...</p>;\n+  }\n+  if (status.error) {\n+    return <p>Error getting users: {status.error}</p>;\n+  }\n+\n+  return (\n+    <>\n+      <h1 className=\"text-4xl text-center mt-6\">Users</h1>\n+      <ul className=\"text-center mt-3\">\n+        {status.users.map((user) => (\n+          <li key={user.id}>{user.name}</li>\n+        ))}\n+      </ul>\n+    </>\n+  );\n+};\n+\n+export default Users2;\n+```\n+\n+If you want to add interactivity like click events, the component also has to be marked as a client component:\n+\n+```jsx\n+\"use client\";\n+\n+import { useState } from \"react\";\n+\n+const Counter = () => {\n+  const [count, setCount] = useState(0);\n+\n+  return (\n+    <>\n+      <h1>Counter</h1>\n+      <button onClick={() => setCount(count + 1)}>Increment</button>\n+      <h2>{count}</h2>\n+      <button onClick={() => setCount(count - 1)}>Decrement</button>\n+    </>\n+  );\n+};\n+\n+export default Counter;\n+```\n+\n+If you don't add the use client directive to the component, you get an error with a message that says \"You're importing a server component that needs `useState`. This React hook only works in a client component. To fix, mark the file (or its parent) with the `\"use client\"` directive.\"\n+\n+The main benefits that come with React Server Components are that data fetching becomes simpler, the code is easier to read, and client complexity is reduced.\n \n # --questions--\n "
        }
    ],
    "stats": {
        "total": 548,
        "additions": 532,
        "deletions": 16
    }
}