{
    "author": "Almee98",
    "message": "feat(curriculum): add interactive examples to regex modifiers lesson (#63763)\n\nCo-authored-by: Almee Christian <almee@Almees-MacBook-Pro.local>",
    "sha": "069ccd361b215e6f33fe5c58db4a99528405c88e",
    "files": [
        {
            "sha": "3805582c232d471d2ce976c0be1b733030bc4485",
            "filename": "curriculum/challenges/english/blocks/lecture-working-with-regular-expressions/6733c5ba834ded4bb067e67c.md",
            "status": "modified",
            "additions": 51,
            "deletions": 1,
            "changes": 52,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/069ccd361b215e6f33fe5c58db4a99528405c88e/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-regular-expressions%2F6733c5ba834ded4bb067e67c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/069ccd361b215e6f33fe5c58db4a99528405c88e/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-regular-expressions%2F6733c5ba834ded4bb067e67c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-working-with-regular-expressions%2F6733c5ba834ded4bb067e67c.md?ref=069ccd361b215e6f33fe5c58db4a99528405c88e",
            "patch": "@@ -5,10 +5,12 @@ challengeType: 19\n dashedName: what-are-some-common-regular-expression-modifiers-used-for-searching\n ---\n \n-# --description--\n+# --interactive--\n \n Modifiers, often referred to as \"flags\", modify the behavior of a regular expression. Let's recall our example from an earlier lesson:\n \n+:::interactive_editor\n+\n ```js\n const regex = /freeCodeCamp/;\n console.log(regex.test(\"freeCodeCamp\")); // true\n@@ -21,6 +23,8 @@ console.log(regex.test(\"code\")); // false\n console.log(regex.test(\"camp\")); // false\n ```\n \n+:::\n+\n If you remember, the all-lowercase and all-uppercase `freeCodeCamp` strings failed to match the pattern. This is because, by default, regular expressions are case-sensitive.\n \n But what if we could tell the regular expression to be case-insensitive? Well, there's a modifier for that. The `i` flag makes a regex ignore case. How can we use it? Flags go after the closing forward slash in a regular expression:\n@@ -31,7 +35,11 @@ const regex = /freeCodeCamp/i;\n \n Notice the change to the regular expression on the first line. Now we can check how this changes things:\n \n+:::interactive_editor\n+\n ```js\n+const regex = /freeCodeCamp/i;\n+\n console.log(regex.test(\"freeCodeCamp\")); // true\n console.log(regex.test(\"freeCodeCamp is great\")); // true\n console.log(regex.test(\"I love freeCodeCamp\")); // true\n@@ -42,12 +50,20 @@ console.log(regex.test(\"code\")); // false\n console.log(regex.test(\"camp\")); // false\n ```\n \n+:::\n+\n Because our regular expression is now case-insensitive, the all-lowercase and all-uppercase strings have \"passed\" the test. This can also work for a string with a random mix of uppercase and lowercase letters:\n \n+:::interactive_editor\n+\n ```js\n+const regex = /freeCodeCamp/i;\n+\n console.log(regex.test(\"dO yOu LoVe fReEcOdEcAmP?\")); // true\n ```\n \n+:::\n+\n There are quite a few other flags that you can use. The `g` flag, or global modifier, allows your regular expression to match a pattern more than once. \n \n Let's see how that affects our code. You'll notice we kept the `i` flag ‚Äì a regular expression can use multiple flags (as many as needed) to achieve your desired behavior:\n@@ -58,7 +74,11 @@ const regex = /freeCodeCamp/gi;\n \n Wait a second... what's this? It would seem that the global modifier is making some of our strings that should be passing fail instead:\n \n+:::interactive_editor\n+\n ```js\n+const regex = /freeCodeCamp/gi;\n+\n console.log(regex.test(\"freeCodeCamp\")); // true\n console.log(regex.test(\"freeCodeCamp is great\")); // false\n console.log(regex.test(\"I love freeCodeCamp\")); // true\n@@ -69,6 +89,8 @@ console.log(regex.test(\"code\")); // false\n console.log(regex.test(\"camp\")); // false\n ```\n \n+:::\n+\n Why? Well, the global modifier makes your regular expression stateful. This means it keeps track of where it has previously matched a pattern. So when it matches the first `freeCodeCamp` string, it remembers that it found a match starting at index `0`.\n \n We then test it against `freeCodeCamp is great`, but it doesn't start at index `0`. The regular expression \"knows\" it found a match at index `0` already, so even though this is a different string, it starts from the end index of the match. \n@@ -79,14 +101,24 @@ Then, because it fails to find a match, it \"loses\" its state and starts the foll\n \n If we switch our logs around so that a string with the match at `0` is followed immediately by a string that has a match later than index `11`:\n \n+:::interactive_editor\n+\n ```js\n+const regex = /freeCodeCamp/gi;\n+\n console.log(regex.test(\"freeCodeCamp\")); // true\n console.log(regex.test(\"I loooooooove freeCodeCamp\")); // true\n ```\n \n+:::\n+\n When a regular expression is global, it gets a new property called `lastIndex`. Grabbing our previous code, let's see how this property works:\n \n+:::interactive_editor\n+\n ```js\n+const regex = /freeCodeCamp/gi;\n+\n console.log(regex.lastIndex); // 0\n console.log(regex.test(\"freeCodeCamp\")); // true\n console.log(regex.lastIndex); // 12\n@@ -105,6 +137,8 @@ console.log(regex.lastIndex); // 0\n console.log(regex.test(\"camp\")); // false\n ```\n \n+:::\n+\n Looking at this example, you can see how the state of the regular expression changes with each test call using the `lastIndex` to track its previous matches.\n \n The global flag is great when you need to get multiple matches from a single string. But if you're testing multiple strings with the same regular expression it's best to leave the `g` flag off.\n@@ -123,6 +157,8 @@ const end = /freecodecamp$/i;\n \n Take a moment to compare the outputs on the right:\n \n+:::interactive_editor\n+\n ```js\n const start = /^freecodecamp/i;\n const end = /freecodecamp$/i;\n@@ -136,8 +172,12 @@ console.log(start.test(\"have met freecodecamp's founder\")); // false\n console.log(end.test(\"have met freecodecamp's founder\")); // false\n ```\n \n+:::\n+\n See how the start anchor only matches at the beginning of the string, and the end anchor only matches at the end of the string? But what about matching across multiple lines? Let's take a look at that:\n \n+:::interactive_editor\n+\n ```js\n const start = /^freecodecamp/i;\n const end = /freecodecamp$/i;\n@@ -148,10 +188,14 @@ console.log(start.test(string)); // false\n console.log(end.test(string)); // false\n ```\n \n+:::\n+\n Even though `freecodecamp` is in there on its own line, it fails both tests. This is because, by default, anchors look for the beginning and end of the entire string.\n \n But you can make a regex handle multiple lines with the `m` flag, or the multi-line modifier. Let's add that to our regular expressions to see what we get:\n \n+:::interactive_editor\n+\n ```js\n const start = /^freecodecamp/im;\n const end = /freecodecamp$/im;\n@@ -162,6 +206,8 @@ console.log(start.test(string)); // true\n console.log(end.test(string)); // true\n ```\n \n+:::\n+\n Now they both match! Because the `freecodecamp` is entirely on its own line, the start anchor matches the beginning of that line, and the end anchor matches the end of that line.\n \n Finally, you have the `d` flag, or indices modifier. Remember that the `i` flag is for case-insensitivity, so the indices modifier needed a different flag.\n@@ -197,13 +243,17 @@ The first is the unicode modifier, or `u` flag. This expands the functionality o\n \n You'll learn more about character classes in a future lesson, but the `u` flag gives you access to special classes like `Extended_Pictographic` to match most emoji:\n \n+:::interactive_editor\n+\n ```js\n const regex = /üçé/u;\n \n const str = \"I have an apple üçé\";\n console.log(regex.test(str)); // true\n ```\n \n+:::\n+\n There is also a `v` flag, which further expands the functionality of the unicode matching.\n \n The second is the sticky modifier, or the `y` flag. The sticky modifier behaves very similarly to the global modifier, but with a few exceptions."
        }
    ],
    "stats": {
        "total": 52,
        "additions": 51,
        "deletions": 1
    }
}