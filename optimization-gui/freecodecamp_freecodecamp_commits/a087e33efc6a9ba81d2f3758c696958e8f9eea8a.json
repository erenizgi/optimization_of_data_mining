{
    "author": "moT01",
    "message": "feat(curriculum): add working with sql lecture scripts (#61471)\n\nCo-authored-by: Jessica Wilkins <67210629+jdwilkin4@users.noreply.github.com>\nCo-authored-by: Hillary Nyakundi <63947040+larymak@users.noreply.github.com>",
    "sha": "a087e33efc6a9ba81d2f3758c696958e8f9eea8a",
    "files": [
        {
            "sha": "755f56bedb799a6d9b6105927a08258b33c69d0d",
            "filename": "client/i18n/locales/english/intro.json",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json?ref=a087e33efc6a9ba81d2f3758c696958e8f9eea8a",
            "patch": "@@ -4584,7 +4584,12 @@\n         \"title\": \"Bash Scripting Quiz\",\n         \"intro\": [\"Test what you've learned on bash scripting in this quiz.\"]\n       },\n-      \"tkgg\": { \"title\": \"315\", \"intro\": [] },\n+      \"lecture-working-with-sql\": {\n+        \"title\": \"Working With SQL\",\n+        \"intro\": [\n+          \"In these lectures, you will learn about SQL injection, normalization, and the N+1 problem.\"\n+        ]\n+      },\n       \"workshop-sql-student-database-part-1\": {\n         \"title\": \"Build a Student Database: Part 1\",\n         \"intro\": ["
        },
        {
            "sha": "d0ae9867ecef749aecb80018617baaf9461b822e",
            "filename": "client/src/pages/learn/full-stack-developer/lecture-working-with-sql/index.md",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-working-with-sql%2Findex.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-working-with-sql%2Findex.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-working-with-sql%2Findex.md?ref=a087e33efc6a9ba81d2f3758c696958e8f9eea8a",
            "patch": "@@ -0,0 +1,9 @@\n+---\n+title: Introduction to Working With SQL\n+block: lecture-working-with-sql\n+superBlock: full-stack-developer\n+---\n+\n+## Introduction to Working With SQL\n+\n+Learn about Working With SQL in these lectures."
        },
        {
            "sha": "e03005d2829e87f15552329915bc2d30172f587c",
            "filename": "curriculum/challenges/_meta/lecture-working-with-sql/meta.json",
            "status": "added",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/curriculum%2Fchallenges%2F_meta%2Flecture-working-with-sql%2Fmeta.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/curriculum%2Fchallenges%2F_meta%2Flecture-working-with-sql%2Fmeta.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2F_meta%2Flecture-working-with-sql%2Fmeta.json?ref=a087e33efc6a9ba81d2f3758c696958e8f9eea8a",
            "patch": "@@ -0,0 +1,23 @@\n+{\n+  \"name\": \"Working With SQL\",\n+  \"blockType\": \"lecture\",\n+  \"blockLayout\": \"challenge-list\",\n+  \"isUpcomingChange\": true,\n+  \"dashedName\": \"lecture-working-with-sql\",\n+  \"superBlock\": \"full-stack-developer\",\n+  \"helpCategory\": \"Backend Development\",\n+  \"challengeOrder\": [\n+    {\n+      \"id\": \"68816f386bc30d36f59e9563\",\n+      \"title\": \"What Is Normalization in SQL?\"\n+    },\n+    {\n+      \"id\": \"68817041f57ce139bef36541\",\n+      \"title\": \"What Is SQL Injection, and What Are Some Ways to Prevent It?\"\n+    },\n+    {\n+      \"id\": \"6881705cd9860639e98d639d\",\n+      \"title\": \"What Is the N+1 Problem?\"\n+    }\n+  ]\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "cb30e3d95ec1ce49671919e9b4f6155a95854193",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-sql/68816f386bc30d36f59e9563.md",
            "status": "added",
            "additions": 243,
            "deletions": 0,
            "changes": 243,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-sql%2F68816f386bc30d36f59e9563.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-sql%2F68816f386bc30d36f59e9563.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-sql%2F68816f386bc30d36f59e9563.md?ref=a087e33efc6a9ba81d2f3758c696958e8f9eea8a",
            "patch": "@@ -0,0 +1,243 @@\n+---\n+id: 68816f386bc30d36f59e9563\n+title: What Is Normalization in SQL?\n+challengeType: 19\n+dashedName: what-is-normalization-in-sql\n+---\n+\n+# --description--\n+\n+Normalization is the process of organizing a relational database using established normal forms to reduce data redundancy and improve data integrity.\n+\n+To normalize a database, you analyze the attributes and relationships in your table structures to identify opportunities for simplification based on normalization rules. Then, you divide the data into smaller, more focused tables and establish relationships between them using primary and foreign keys. These smaller tables will store all the data that you originally had, but they will be easier to manage, organize, and work with, compared to larger tables.\n+\n+By minimizing data redundancy, normalization reduces storage space and prevents inconsistencies. For example, if a customer's address changes, you only need to update it in one customer table rather than in every order record. \n+\n+It also helps preserve data integrity by making sure that dependencies are enforced by primary and foreign key constraints. This reduces the likelihood of insertion, update, and deletion anomalies.\n+\n+A normalized database is easier to understand and maintain, which contributes to a well-designed database system.\n+\n+The set of rules that you should follow to organize your tables are called normal forms. Each normal form builds on the previous ones, with rules becoming stricter as you move to higher normal forms. The First Normal Form (1NF) is the foundational form, with the most basic rules.\n+\n+A table is in First Normal Form (1NF) if:\n+\n+- Each cell should contain only one value. For example, if you have a `students` table, you may have a student with multiple phone numbers. Instead of storing them as a comma-separated list in one cell, you should create a separate `phone_numbers` table with a foreign key pointing to the `students` table and only store one value in each cell. This keeps each value atomic and the design normalized.\n+- Every record (row) must be unique. While primary keys enforce this requirement, 1NF explicitly mandates that no duplicate rows exist in the table.\n+- The order of the rows and columns should not be relevant. Data should not depend on its physical location.\n+\n+Essentially, the First Normal Form (1NF) focuses on making values simple and atomic.\n+\n+The Second Normal Form (2NF) builds on 1NF, requiring that all 1NF requirements are met plus additional constraints.\n+\n+Understanding 2NF requires familiarity with two key concepts: superkeys and candidate keys. A superkey is any set of attributes that uniquely identifies each row in a table, meaning no two rows can have identical values across all columns in the superkey.\n+\n+For example, if we have a `customers` table with three columns:\n+\n+```sql\n+customer_id | name | email\n+```\n+\n+Let's say that `customer_id` and `email` must be unique for each record. Some examples of superkeys for this table would be:\n+\n+- `customer_id`\n+- `{ customer_id, name }`, this combination uniquely identifies rows because `customer_id` alone is unique, regardless of `name`'s uniqueness.\n+- `{ customer_id, name, email }`\n+- `email`, since we are adding the unique constraint to this column too, each record can be uniquely identified by the email.\n+\n+Any set of attributes that, together, identify each row can be a superkey.\n+\n+A candidate key is similar and yet, a bit different. It's a set of one or more columns on the table that can uniquely identify each record. A table can have multiple candidate keys but you'll need to choose one to act as the primary key.\n+\n+They sound quite similar, right? Their difference is that the superkey can also contain additional attributes that are not necessary to identify each row uniquely, while the candidate key only contains attributes that do identify the row uniquely.\n+\n+In our `customers` example, we mentioned that `customer_id`, `{ customer_id, name }`, `{ customer_id, name, email }`, and `email` can be superkeys. In this case, only `customer_id` and `email` can be candidate keys because candidate keys can't include attributes that don't identify the row uniquely, like `name`. This illustrates the minimality principle that distinguishes candidate keys from superkeys.\n+\n+Now that you're familiar with these concepts, let's go back to the Second Normal Form (2NF).\n+\n+The Second Normal Form (2NF) is based on addressing partial dependencies. A partial dependency occurs in a table when an attribute that is not part of the primary key only depends on part of a composite primary key (a composite key is a primary key made of multiple columns). This can lead to data redundancy and update anomalies.\n+\n+For example, let's say we have an `orders` table with these columns:\n+\n+```sql\n+order_id | item_id | order_date | product | quantity | order_shipping_city\n+```\n+\n+In this table, the primary key is the combination of `order_id` and `item_id` because the same item ID can be in different orders, but their combination will be unique. You can see that there is a partial dependency between `order_id` and `order_shipping_city`. `order_id` is part of the primary key. `order_shipping_city` depends on `order_id` because every order with the same ID will have the same shipping city. However, the shipping city does not depend on the `item_id`, but this is also part of the primary key. Therefore, `order_shipping_city` does not depend on the entire primary key.\n+\n+To fix this, you can split the table into two smaller tables, like `order_header` and `order_items`. In the `order_header` table, you could store the top-level information about the orders: \n+\n+```sql\n+order_id | order_date | order_shipping_city\n+```\n+\n+In the `order_items` table, you could store information about the items in the different orders that were submitted:\n+\n+```sql\n+order_id | item_id | product | quantity\n+```\n+\n+With these changes, both tables will be in Second Normal Form (2NF).\n+\n+And that leads us to the Third Normal Form (3NF). This normal form builds on the second normal form.\n+\n+For a table to be in Third Normal Form, it must:\n+\n+- Be in Second Normal Form.\n+- Have all non-key attributes depend directly on the primary key, meaning no non-key attribute should depend on another non-key attribute.\n+\n+To understand the Third Normal Form (3NF), you need to understand transitive dependencies. A transitive dependency occurs when an attribute that is not part of the primary key depends on another attribute that is not part of the primary key, which in turn depends on the primary key.\n+\n+For example, let's modify our `orders` table to have these columns:\n+\n+```sql\n+order_id | customer_id | customer_city | city_postal_code | order_date | product | quantity\n+```\n+\n+The primary key in this new table is `order_id` because it uniquely identifies each row.\n+\n+There is a transitive dependency in this table:\n+\n+```sql\n+order_id > customer_id > customer_city > city_postal_code\n+```\n+\n+The city's postal code is determined by the customer's city, which is determined by the customer's ID, which is determined by the order's ID. `city_postal_code`, an attribute that is not part of the primary key, is determined by `customer_city`, which is also not part of the primary key, but `customer_city` is determined by `order_id` through `customer_id`. This means that the city's postal code will be repeated for every order placed by customers who live in the same city. This will lead to data redundancy. Additionally, any change to a city's postal code would require updates across multiple records.\n+\n+To solve the transitive dependency, you would need to split the table into multiple tables. First, an `orders` table:\n+\n+```sql\n+order_id | customer_id | order_date | product | quantity\n+```\n+\n+Then, a `customers` table:\n+\n+```sql\n+customer_id | city_name\n+```\n+\n+And a `cities` table:\n+\n+```sql\n+city_name | city_postal_code\n+```\n+\n+This removes the transitive dependency from the table.\n+\n+And finally, we have the Boyce-Codd Normal Form (BCNF). This is also known as Normal Form 3.5 because it addresses some anomalies that the Third Normal Form may not address. For a table to be in the Boyce-Codd Normal Form (BCNF), it has to:\n+\n+- Be in Third Normal Form.\n+- Have every left-hand side of a functional dependency has to be a superkey.\n+\n+The goal of this normal form is to ensure that every attribute or set of attributes that determines another attribute is a superkey, which is a candidate key or a superset of them.\n+\n+Understanding and applying the normal forms is essential for designing robust and efficient relational databases. By eliminating data redundancy and ensuring logical data dependencies, normalization leads to improved data integrity, reduced storage requirements, and simplified database maintenance. You should usually aim to reach the Third Normal Form (3NF).\n+\n+# --questions--\n+\n+## --text--\n+\n+Which normal form is primarily concerned with replacing groups of data within a single row with single values?\n+\n+## --answers--\n+\n+First Normal Form (1NF)\n+\n+---\n+\n+Second Normal Form (2NF)\n+\n+### --feedback--\n+\n+Think about the most basic level of organization within a table and what constitutes a single, indivisible piece of data.\n+\n+---\n+\n+Third Normal Form (3NF)\n+\n+### --feedback--\n+\n+Think about the most basic level of organization within a table and what constitutes a single, indivisible piece of data.\n+\n+---\n+\n+Boyce-Codd Normal Form (BCNF)\n+\n+### --feedback--\n+\n+Think about the most basic level of organization within a table and what constitutes a single, indivisible piece of data.\n+\n+## --video-solution--\n+\n+1\n+\n+## --text--\n+\n+A table is in Second Normal Form (2NF) if it is in First Normal Form (1NF) and if which of the following is true?\n+\n+## --answers--\n+\n+All non-key attributes are transitively dependent on the primary key.\n+\n+### --feedback--\n+\n+Think about the issue that the Second Normal Form (2NF) addresses when a table has a composite primary key.\n+\n+---\n+\n+All non-key attributes are fully functionally dependent on the entire primary key.\n+\n+---\n+\n+Every determinant is a candidate key.\n+\n+### --feedback--\n+\n+Think about the issue that the Second Normal Form (2NF) addresses when a table has a composite primary key.\n+\n+---\n+\n+There are no repeating groups of data.\n+\n+### --feedback--\n+\n+Think about the issue that the Second Normal Form (2NF) addresses when a table has a composite primary key.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+Which normal form addresses transitive dependencies, where a non-key attribute depends on another non-key attribute?\n+\n+## --answers--\n+\n+First Normal Form (1NF)\n+\n+### --feedback--\n+\n+Think about the indirect relationships between non-key attributes and the primary key that this normal form aims to eliminate.\n+\n+---\n+\n+Second Normal Form (2NF)\n+\n+### --feedback--\n+\n+Think about the indirect relationships between non-key attributes and the primary key that this normal form aims to eliminate.\n+\n+---\n+\n+Third Normal Form (3NF)\n+\n+---\n+\n+Boyce-Codd Normal Form (BCNF)\n+\n+### --feedback--\n+\n+Think about the indirect relationships between non-key attributes and the primary key that this normal form aims to eliminate.\n+\n+## --video-solution--\n+\n+3"
        },
        {
            "sha": "082c9337ba6240541efa8366b378d31f036488c7",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-sql/68817041f57ce139bef36541.md",
            "status": "added",
            "additions": 159,
            "deletions": 0,
            "changes": 159,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-sql%2F68817041f57ce139bef36541.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-sql%2F68817041f57ce139bef36541.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-sql%2F68817041f57ce139bef36541.md?ref=a087e33efc6a9ba81d2f3758c696958e8f9eea8a",
            "patch": "@@ -0,0 +1,159 @@\n+---\n+id: 68817041f57ce139bef36541\n+title: What Is SQL Injection, and What Are Some Ways to Prevent It?\n+challengeType: 19\n+dashedName: what-is-sql-injection-and-what-are-some-ways-to-prevent-it\n+---\n+\n+# --description--\n+\n+SQL injection is a web security vulnerability in which attackers change or take advantage of the queries that the web application makes to the database. For example, attackers can insert malicious SQL code into the query to run the malicious code on the backend.\n+\n+This can happen when you give users the option to enter data through login forms, search bars, or URL parameters and then use that user input in string interpolation or concatenation to generate the final SQL command.\n+\n+Depending on the attacker's goal, the malicious SQL code can cause significant disruptions on your database and web application, like bypassing authentication, stealing data from the database, or modifying or removing database records. Therefore, you should take this threat very seriously.\n+\n+For example, let's say your web application uses an SQL query like this one to authenticate users, directly embedding the username and password entered by the user:\n+\n+```sql\n+'SELECT * FROM users WHERE username = ' + username_input + ' AND password = ' + password_input + ';'\n+```\n+\n+If an attacker enters something like this to the `username` field:\n+\n+```sql\n+'\" \" OR \"1\"=\"1\" --'\n+```\n+\n+And anything else in the `password` field, since `\"1\"=\"1\"` is always `true` and `--` comments out the rest of the query, the `WHERE` clause becomes:\n+\n+```sql\n+WHERE username = \" \" OR TRUE\n+```\n+\n+Which is always `true`.\n+\n+Depending on the database implementation, this may return the data of the first user or any user in the database and allow the attacker to log in without valid credentials.\n+\n+So how can you prevent this? There two main ways to prevent SQL injection:\n+\n+- Don't write dynamic queries with string concatenation.\n+- And prevent malicious SQL input from being included in queries that will be executed in the backend.\n+\n+In practice, you can use parameterized statements, also known as parameterized queries. They separate the SQL structure from the data entered by the user, which prevents the database from interpreting the input data as executable code.\n+\n+Another important technique is input validation. This is recommended as a secondary security measure in all cases, but it's specially important for parts of SQL queries related to table names, column names, and sorting order. If possible, it's recommended to assign table names and column names directly within your code, not from user input.\n+\n+If, despite all the preventive measures, you do get an SQL injection attack, you can minimize its impact on the database by limiting the permissions of each database account. Grant each database user only the permissions needed for their tasks, but nothing more. If an account only needs to read data from the database, grant it read access only. And as a preventive measure, never assign admin permissions to your application accounts. It is very dangerous to do so because an attacker could get complete access and full control over the database.\n+\n+SQL injection is a very common attack that you, as a developer, should be aware of and prevent in the implementation of your web application. With these techniques, you can protect your database and keep your user's data safe.\n+\n+# --questions--\n+\n+## --text--\n+\n+What is the primary goal of an SQL injection attack?\n+\n+## --answers--\n+\n+To improve the performance of the database.\n+\n+### --feedback--\n+\n+Think about what an \"injection\" might imply in a technical context and what part of the system the name \"SQL injection\" refers to.\n+\n+---\n+\n+To interfere with the database queries executed by an application.\n+\n+---\n+\n+To encrypt sensitive user data.\n+\n+### --feedback--\n+\n+Think about what an \"injection\" might imply in a technical context and what part of the system the name \"SQL injection\" refers to.\n+\n+---\n+\n+To enhance the visual appearance of a website.\n+\n+### --feedback--\n+\n+Think about what an \"injection\" might imply in a technical context and what part of the system the name \"SQL injection\" refers to.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+Which of the following is one of the most effective methods to prevent SQL injection vulnerabilities?\n+\n+## --answers--\n+\n+Regularly changing database passwords.\n+\n+### --feedback--\n+\n+Think about how you can separate the structure of your SQL queries from the input provided by users.\n+\n+---\n+\n+Limiting the size of user input fields.\n+\n+### --feedback--\n+\n+Think about how you can separate the structure of your SQL queries from the input provided by users.\n+\n+---\n+\n+Using parameterized statements or queries.\n+\n+---\n+\n+Displaying detailed database error messages to developers.\n+\n+### --feedback--\n+\n+Think about how you can separate the structure of your SQL queries from the input provided by users.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+If a website's login form is vulnerable to SQL injection, what could an attacker potentially achieve?\n+\n+## --answers--\n+\n+Automatically back up the entire database.\n+\n+### --feedback--\n+\n+Think about the purpose of a login form and how manipulating the database query could affect its intended function.\n+\n+---\n+\n+Bypass the login process without valid credentials.\n+\n+---\n+\n+Improve the website's search engine ranking.\n+\n+### --feedback--\n+\n+Think about the purpose of a login form and how manipulating the database query could affect its intended function.\n+\n+---\n+\n+Change the website's design and layout.\n+\n+### --feedback--\n+\n+Think about the purpose of a login form and how manipulating the database query could affect its intended function.\n+\n+## --video-solution--\n+\n+2"
        },
        {
            "sha": "c95c902470e11803e71af396682b28ae1ef47172",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-sql/6881705cd9860639e98d639d.md",
            "status": "added",
            "additions": 179,
            "deletions": 0,
            "changes": 179,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-sql%2F6881705cd9860639e98d639d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-sql%2F6881705cd9860639e98d639d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-sql%2F6881705cd9860639e98d639d.md?ref=a087e33efc6a9ba81d2f3758c696958e8f9eea8a",
            "patch": "@@ -0,0 +1,179 @@\n+---\n+id: 6881705cd9860639e98d639d\n+title: What Is the N+1 Problem?\n+challengeType: 19\n+dashedName: what-is-the-n-plus-1-problem\n+---\n+\n+# --description--\n+\n+The N+1 problem is a common performance bottleneck in database-driven applications. If you've ever experienced a really long load time while using an application, it's very likely related to the N+1 problem. This problem occurs when many small queries are being performed in a sequence to get the data you requested.\n+\n+But why would you perform many queries in a sequence? You might do this to query a list of records and additional information about those records. You would perform an initial query to get the list of records and then perform an additional query for each one of those records, to get additional information about them.\n+\n+Even if you intuitively think that performing many small and simple queries will be more efficient than performing just one large and complex query, this is usually not the case. The more queries you perform, the longer the entire process will take because you need to send each query to the server, find the data on the database, and then receive the data sent by the server for that query. This can have a very significant performance impact on your application.\n+\n+To show you a practical example, let's say you're developing an application for a food delivery service and you run a query to get the first 50 orders in the database. First, you will get a list with these orders from an `orders` table, like this one:\n+\n+```sql\n+order_id | product   | quantity | customer_id\n+1        | pizza     | 2        | 3422\n+2        | salad     | 1        | 1255\n+3        | ice cream | 4        | 2344\n+4        | donuts    | 10       | 3455\n+.        | .         | .        | .\n+.        | .         | .        | .\n+.        | .         | .        | .\n+```\n+\n+But what if you also need to get the data of the customers who submitted these orders? This information would be stored in a different `customers` table.\n+\n+One way to approach this would be to get the list of orders first and then run one query per order to get the customers' information. To get the list of orders, you could run a query like this one, to get the first 50 records from the `orders` table:\n+\n+```sql\n+SELECT * FROM orders LIMIT 50;\n+```\n+\n+This is where the 1 in N+1 comes from. It's the initial query that gives you the list of records. Then, you will need to perform another query for each one of these records to get the information of the customer who submitted the order. For this, you might write a loop in an asynchronous function to process both orders and customers. The `getCustomerData()` function will perform a SQL query to get the data of the customer who placed a specific order. It will do this in a sequence for each order that was placed:\n+\n+```js\n+for (const order of orders) {\n+  const customerId = order.customer_id;\n+  const customerData = await getCustomerData(customerId);\n+  // Process the customer's data.\n+}\n+```\n+\n+That's where the N in N+1 comes from. N represents the number of queries that will be performed to get additional data for each one of the records.\n+\n+This approach might seem simple and intuitive, but you might be surprised to know that this is exactly what you shouldn't do. You should avoid making queries in a loop because making multiple small queries will take much longer than performing a single, larger query to get all the data.\n+\n+You should try to use the tools that SQL gives you to reduce the number of queries as much as possible. In this case, we could use a `JOIN` operation to join the `orders` and `customers` table.\n+\n+```sql\n+SELECT \n+  orders.order_id,\n+  orders.product,\n+  orders.quantity,\n+  customers.customer_id,\n+  customers.name AS customer_name,\n+  customers.email AS customer_email,\n+  customers.address AS customer_address\n+FROM orders\n+JOIN customers ON orders.customer_id = customers.customer_id\n+WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50)\n+```\n+\n+With the `JOIN` operation, we can retrieve the data of the first 50 orders in the database, including the data of the customers, their names, email, and addresses, with only one query. It might look more complex, but it's actually more efficient this way.\n+\n+Now you know what the N+1 problem involves, so you can identify it and prevent it, to interact with your database in an efficient way.\n+\n+# --questions--\n+\n+## --text--\n+\n+What is the primary characteristic of the N+1 problem in the context of SQL?\n+\n+## --answers--\n+\n+Excessive data being returned in a single query.\n+\n+### --feedback--\n+\n+Think about the number of queries typically involved and what triggers the additional queries after the first one.\n+\n+---\n+\n+Executing one initial query followed by N additional queries for related data.\n+\n+---\n+\n+Inefficient use of database indexes.\n+\n+### --feedback--\n+\n+Think about the number of queries typically involved and what triggers the additional queries after the first one.\n+\n+---\n+\n+Conflicts arising from concurrent database transactions.\n+\n+### --feedback--\n+\n+Think about the number of queries typically involved and what triggers the additional queries after the first one.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+What is the main performance implication of the N+1 problem?\n+\n+## --answers--\n+\n+Increased CPU usage on the database server due to complex joins.\n+\n+### --feedback--\n+\n+Think about the overhead associated with the communication between the application and the database.\n+\n+---\n+\n+Reduced data integrity due to inconsistencies in related data.\n+\n+### --feedback--\n+\n+Think about the overhead associated with the communication between the application and the database.\n+\n+---\n+\n+Higher memory consumption on the application server due to large result sets.\n+\n+### --feedback--\n+\n+Think about the overhead associated with the communication between the application and the database.\n+\n+---\n+\n+Increased number of database round trips, leading to increased load time.\n+\n+## --video-solution--\n+\n+4\n+\n+## --text--\n+\n+A strategy to reduce the number of database queries when retrieving related data and avoid the N+1 problem involves:\n+\n+## --answers--\n+\n+Increasing the database connection pool size.\n+\n+### --feedback--\n+\n+Think about how you can combine the retrieval of the main data and its related information into a single database interaction.\n+\n+---\n+\n+Optimizing individual SQL queries for speed.\n+\n+### --feedback--\n+\n+Think about how you can combine the retrieval of the main data and its related information into a single database interaction.\n+\n+---\n+\n+Fetching related data within the initial query using JOIN clauses.\n+\n+---\n+\n+Implementing client-side data filtering and sorting.\n+\n+### --feedback--\n+\n+Think about how you can combine the retrieval of the main data and its related information into a single database interaction.\n+\n+## --video-solution--\n+\n+3"
        },
        {
            "sha": "1a8d926006e844037660620adcc75a8ddf3ae57d",
            "filename": "curriculum/superblock-structure/full-stack.json",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/curriculum%2Fsuperblock-structure%2Ffull-stack.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/a087e33efc6a9ba81d2f3758c696958e8f9eea8a/curriculum%2Fsuperblock-structure%2Ffull-stack.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fsuperblock-structure%2Ffull-stack.json?ref=a087e33efc6a9ba81d2f3758c696958e8f9eea8a",
            "patch": "@@ -1469,6 +1469,9 @@\n           \"dashedName\": \"sql-and-bash\",\n           \"comingSoon\": true,\n           \"blocks\": [\n+            {\n+              \"dashedName\": \"lecture-working-with-sql\"\n+            },\n             {\n               \"dashedName\": \"workshop-sql-student-database-part-1\"\n             },"
        }
    ],
    "stats": {
        "total": 623,
        "additions": 622,
        "deletions": 1
    }
}