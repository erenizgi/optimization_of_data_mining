{
    "author": "ojeytonwilliams",
    "message": "test: more detailed output about failing challenge (#55464)",
    "sha": "f96e12ea02634ef9b1f5501eacd01ae283692c4b",
    "files": [
        {
            "sha": "b3bdcfff89abd8122b35c52346c7297bca86c2c5",
            "filename": "curriculum/test/test-challenges.js",
            "status": "modified",
            "additions": 192,
            "deletions": 180,
            "changes": 372,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/f96e12ea02634ef9b1f5501eacd01ae283692c4b/curriculum%2Ftest%2Ftest-challenges.js",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/f96e12ea02634ef9b1f5501eacd01ae283692c4b/curriculum%2Ftest%2Ftest-challenges.js",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Ftest%2Ftest-challenges.js?ref=f96e12ea02634ef9b1f5501eacd01ae283692c4b",
            "patch": "@@ -325,152 +325,162 @@ function populateTestsForLang({ lang, challenges, meta, superBlocks }) {\n   }\n \n   superBlocks.forEach(superBlock => {\n-    describe(`Check challenges (${lang}, ${superBlock})`, function () {\n-      this.timeout(5000);\n-      const superBlockChallenges = challenges.filter(\n-        c => c.superBlock === superBlock\n-      );\n-      superBlockChallenges.forEach((challenge, id) => {\n-        // When testing single challenge, in project based curriculum,\n-        // challenge to test (current challenge) might not have solution.\n-        // Instead seed from next challenge is tested against tests from\n-        // current challenge. Next challenge is skipped from testing.\n-        if (process.env.FCC_CHALLENGE_ID && id > 0) return;\n-\n-        const dashedBlockName = challenge.block;\n-        // TODO: once certifications are not included in the list of challenges,\n-        // stop returning early here.\n-        if (typeof dashedBlockName === 'undefined') return;\n-        describe(challenge.block || 'No block', function () {\n-          describe(challenge.title || 'No title', function () {\n-            // Note: the title in meta.json are purely for human readability and\n-            // do not include translations, so we do not validate against them.\n-            it('Matches an ID in meta.json', function () {\n-              const index = meta[dashedBlockName]?.challengeOrder?.findIndex(\n-                ({ id }) => id === challenge.id\n-              );\n-\n-              if (index < 0) {\n-                throw new AssertionError(\n-                  `Cannot find ID \"${challenge.id}\" in meta.json file for block \"${dashedBlockName}\"`\n-                );\n-              }\n-            });\n+    describe(`Language: ${lang}`, function () {\n+      describe(`SuperBlock: ${superBlock}`, function () {\n+        this.timeout(5000);\n+        const superBlockChallenges = challenges.filter(\n+          c => c.superBlock === superBlock\n+        );\n+        superBlockChallenges.forEach((challenge, id) => {\n+          // When testing single challenge, in project based curriculum,\n+          // challenge to test (current challenge) might not have solution.\n+          // Instead seed from next challenge is tested against tests from\n+          // current challenge. Next challenge is skipped from testing.\n+          if (process.env.FCC_CHALLENGE_ID && id > 0) return;\n+\n+          const dashedBlockName = challenge.block;\n+          // TODO: once certifications are not included in the list of challenges,\n+          // stop returning early here.\n+          if (typeof dashedBlockName === 'undefined') return;\n+          describe(`Block: ${challenge.block}`, function () {\n+            describe(`Title: ${challenge.title}`, function () {\n+              describe(`ID: ${challenge.id}`, function () {\n+                // Note: the title in meta.json are purely for human readability and\n+                // do not include translations, so we do not validate against them.\n+                it('Matches an ID in meta.json', function () {\n+                  const index = meta[\n+                    dashedBlockName\n+                  ]?.challengeOrder?.findIndex(({ id }) => id === challenge.id);\n+\n+                  if (index < 0) {\n+                    throw new AssertionError(\n+                      `Cannot find ID \"${challenge.id}\" in meta.json file for block \"${dashedBlockName}\"`\n+                    );\n+                  }\n+                });\n \n-            it('Common checks', function () {\n-              const result = validateChallenge(challenge);\n-\n-              if (result.error) {\n-                throw new AssertionError(result.error);\n-              }\n-              const { id, title, block, dashedName } = challenge;\n-              assert.exists(\n-                dashedName,\n-                `Missing dashedName for challenge ${id} in ${block}.`\n-              );\n-              const pathAndTitle = `${block}/${dashedName}`;\n-              const idVerificationMessage = mongoIds.check(id, title);\n-              assert.isNull(idVerificationMessage, idVerificationMessage);\n-              const dupeTitleCheck = challengeTitles.check(dashedName, block);\n-              assert.isTrue(\n-                dupeTitleCheck,\n-                `All challenges within a block must have a unique dashed name. ${dashedName} (at ${pathAndTitle}) is already assigned`\n-              );\n-            });\n+                it('Common checks', function () {\n+                  const result = validateChallenge(challenge);\n \n-            const { challengeType } = challenge;\n+                  if (result.error) {\n+                    throw new AssertionError(result.error);\n+                  }\n+                  const { id, title, block, dashedName } = challenge;\n+                  assert.exists(\n+                    dashedName,\n+                    `Missing dashedName for challenge ${id} in ${block}.`\n+                  );\n+                  const pathAndTitle = `${block}/${dashedName}`;\n+                  const idVerificationMessage = mongoIds.check(id, title);\n+                  assert.isNull(idVerificationMessage, idVerificationMessage);\n+                  const dupeTitleCheck = challengeTitles.check(\n+                    dashedName,\n+                    block\n+                  );\n+                  assert.isTrue(\n+                    dupeTitleCheck,\n+                    `All challenges within a block must have a unique dashed name. ${dashedName} (at ${pathAndTitle}) is already assigned`\n+                  );\n+                });\n \n-            if (hasNoSolution(challengeType)) return;\n+                const { challengeType } = challenge;\n \n-            let { tests = [] } = challenge;\n-            tests = tests.filter(test => !!test.testString);\n-            if (tests.length === 0) {\n-              it('Check tests. No tests.');\n-              return;\n-            }\n+                if (hasNoSolution(challengeType)) return;\n+\n+                let { tests = [] } = challenge;\n+                tests = tests.filter(test => !!test.testString);\n+                if (tests.length === 0) {\n+                  it('Check tests. No tests.');\n+                  return;\n+                }\n \n-            describe('Check tests syntax', function () {\n-              tests.forEach(test => {\n-                it(`Check for: ${test.text}`, function () {\n-                  assert.doesNotThrow(() => new vm.Script(test.testString));\n+                describe('Check tests syntax', function () {\n+                  tests.forEach(test => {\n+                    it(`Check for: ${test.text}`, function () {\n+                      assert.doesNotThrow(() => new vm.Script(test.testString));\n+                    });\n+                  });\n                 });\n-              });\n-            });\n \n-            if (challengeType === challengeTypes.backend) {\n-              it('Check tests is not implemented.');\n-              return;\n-            }\n-\n-            // TODO(after python PR): simplify pipeline and sync with client.\n-            // buildChallengeData should be called and any errors handled.\n-            // canBuildChallenge does not need to exist independently.\n-            const buildChallenge =\n-              {\n-                [challengeTypes.js]: buildJSChallenge,\n-                [challengeTypes.jsProject]: buildJSChallenge,\n-                [challengeTypes.python]: buildPythonChallenge,\n-                [challengeTypes.multifilePythonCertProject]:\n-                  buildPythonChallenge\n-              }[challengeType] ?? buildDOMChallenge;\n-\n-            // The python tests are (currently) slow, so we give them more time.\n-            const timePerTest =\n-              challengeType === challengeTypes.python ? 10000 : 5000;\n-            it('Test suite must fail on the initial contents', async function () {\n-              // TODO: some tests take a surprisingly long time to setup the\n-              // test runner, so this timeout is large while we investigate.\n-              this.timeout(timePerTest * tests.length + 20000);\n-              // suppress errors in the console.\n-              const oldConsoleError = console.error;\n-              console.error = () => {};\n-              let fails = false;\n-              let testRunner;\n-              try {\n-                testRunner = await createTestRunner(\n-                  challenge,\n-                  challenge.challengeFiles,\n-                  buildChallenge\n-                );\n-              } catch {\n-                fails = true;\n-              }\n-              if (!fails) {\n-                for (const test of tests) {\n+                if (challengeType === challengeTypes.backend) {\n+                  it('Check tests is not implemented.');\n+                  return;\n+                }\n+\n+                // TODO(after python PR): simplify pipeline and sync with client.\n+                // buildChallengeData should be called and any errors handled.\n+                // canBuildChallenge does not need to exist independently.\n+                const buildChallenge =\n+                  {\n+                    [challengeTypes.js]: buildJSChallenge,\n+                    [challengeTypes.jsProject]: buildJSChallenge,\n+                    [challengeTypes.python]: buildPythonChallenge,\n+                    [challengeTypes.multifilePythonCertProject]:\n+                      buildPythonChallenge\n+                  }[challengeType] ?? buildDOMChallenge;\n+\n+                // The python tests are (currently) slow, so we give them more time.\n+                const timePerTest =\n+                  challengeType === challengeTypes.python ? 10000 : 5000;\n+                it('Test suite must fail on the initial contents', async function () {\n+                  // TODO: some tests take a surprisingly long time to setup the\n+                  // test runner, so this timeout is large while we investigate.\n+                  this.timeout(timePerTest * tests.length + 20000);\n+                  // suppress errors in the console.\n+                  const oldConsoleError = console.error;\n+                  console.error = () => {};\n+                  let fails = false;\n+                  let testRunner;\n                   try {\n-                    await testRunner(test);\n-                  } catch (e) {\n+                    testRunner = await createTestRunner(\n+                      challenge,\n+                      challenge.challengeFiles,\n+                      buildChallenge\n+                    );\n+                  } catch {\n                     fails = true;\n-                    break;\n                   }\n-                }\n-              }\n-              console.error = oldConsoleError;\n-              assert(fails, 'Test suit does not fail on the initial contents');\n-            });\n+                  if (!fails) {\n+                    for (const test of tests) {\n+                      try {\n+                        await testRunner(test);\n+                      } catch (e) {\n+                        fails = true;\n+                        break;\n+                      }\n+                    }\n+                  }\n+                  console.error = oldConsoleError;\n+                  assert(\n+                    fails,\n+                    'Test suit does not fail on the initial contents'\n+                  );\n+                });\n \n-            let { solutions = [] } = challenge;\n+                let { solutions = [] } = challenge;\n \n-            // if there's an empty string as solution, this is likely a mistake\n-            // TODO: what does this look like now? (this being detection of empty\n-            // lines in solutions - rather than entirely missing solutions)\n+                // if there's an empty string as solution, this is likely a mistake\n+                // TODO: what does this look like now? (this being detection of empty\n+                // lines in solutions - rather than entirely missing solutions)\n \n-            // We need to track where the solution came from to give better\n-            // feedback if the solution is failing.\n-            let solutionFromNext = false;\n+                // We need to track where the solution came from to give better\n+                // feedback if the solution is failing.\n+                let solutionFromNext = false;\n \n-            if (isEmpty(solutions)) {\n-              // if there are no solutions in the challenge, it's assumed the next\n-              // challenge's seed will be a solution to the current challenge.\n-              // This is expected to happen in the project based curriculum.\n+                if (isEmpty(solutions)) {\n+                  // if there are no solutions in the challenge, it's assumed the next\n+                  // challenge's seed will be a solution to the current challenge.\n+                  // This is expected to happen in the project based curriculum.\n \n-              const nextChallenge = superBlockChallenges[id + 1];\n+                  const nextChallenge = superBlockChallenges[id + 1];\n \n-              if (nextChallenge) {\n-                const solutionFiles = cloneDeep(nextChallenge.challengeFiles);\n-                if (!solutionFiles) {\n-                  throw Error(\n-                    `No solution found.\n+                  if (nextChallenge) {\n+                    const solutionFiles = cloneDeep(\n+                      nextChallenge.challengeFiles\n+                    );\n+                    if (!solutionFiles) {\n+                      throw Error(\n+                        `No solution found.\n Check the next challenge (${nextChallenge.title}): it should have a seed which solves the current challenge.\n For example:\n \n@@ -482,59 +492,61 @@ For example:\n seed goes here\n \\`\\`\\`\n                   `\n-                  );\n+                      );\n+                    }\n+                    const solutionFilesWithEditableContents = solutionFiles.map(\n+                      file => ({\n+                        ...file,\n+                        editableContents: getLines(\n+                          file.contents,\n+                          file.editableRegionBoundaries\n+                        )\n+                      })\n+                    );\n+                    // Since there is only one seed, there can only be one solution,\n+                    // but the tests assume solutions is an array.\n+                    solutions = [solutionFilesWithEditableContents];\n+                    solutionFromNext = true;\n+                  } else {\n+                    throw Error(\n+                      `solution omitted for ${challenge.superBlock} ${challenge.block} ${challenge.title}`\n+                    );\n+                  }\n                 }\n-                const solutionFilesWithEditableContents = solutionFiles.map(\n-                  file => ({\n-                    ...file,\n-                    editableContents: getLines(\n-                      file.contents,\n-                      file.editableRegionBoundaries\n-                    )\n-                  })\n-                );\n-                // Since there is only one seed, there can only be one solution,\n-                // but the tests assume solutions is an array.\n-                solutions = [solutionFilesWithEditableContents];\n-                solutionFromNext = true;\n-              } else {\n-                throw Error(\n-                  `solution omitted for ${challenge.superBlock} ${challenge.block} ${challenge.title}`\n-                );\n-              }\n-            }\n-\n-            // TODO: the no-solution filtering is a little convoluted:\n-            const noSolution = new RegExp('// solution required');\n-\n-            const filteredSolutions = solutions.filter(solution => {\n-              return !isEmpty(\n-                solution.filter(\n-                  challengeFile => !noSolution.test(challengeFile.contents)\n-                )\n-              );\n-            });\n \n-            if (isEmpty(filteredSolutions)) {\n-              it('Check tests. No solutions');\n-              return;\n-            }\n-\n-            describe('Check tests against solutions', function () {\n-              solutions.forEach((solution, index) => {\n-                it(`Solution ${\n-                  index + 1\n-                } must pass the tests`, async function () {\n-                  this.timeout(timePerTest * tests.length + 2000);\n-                  const testRunner = await createTestRunner(\n-                    challenge,\n-                    solution,\n-                    buildChallenge,\n-                    solutionFromNext\n+                // TODO: the no-solution filtering is a little convoluted:\n+                const noSolution = new RegExp('// solution required');\n+\n+                const filteredSolutions = solutions.filter(solution => {\n+                  return !isEmpty(\n+                    solution.filter(\n+                      challengeFile => !noSolution.test(challengeFile.contents)\n+                    )\n                   );\n-                  for (const test of tests) {\n-                    await testRunner(test);\n-                  }\n+                });\n+\n+                if (isEmpty(filteredSolutions)) {\n+                  it('Check tests. No solutions');\n+                  return;\n+                }\n+\n+                describe('Check tests against solutions', function () {\n+                  solutions.forEach((solution, index) => {\n+                    it(`Solution ${\n+                      index + 1\n+                    } must pass the tests`, async function () {\n+                      this.timeout(timePerTest * tests.length + 2000);\n+                      const testRunner = await createTestRunner(\n+                        challenge,\n+                        solution,\n+                        buildChallenge,\n+                        solutionFromNext\n+                      );\n+                      for (const test of tests) {\n+                        await testRunner(test);\n+                      }\n+                    });\n+                  });\n                 });\n               });\n             });"
        }
    ],
    "stats": {
        "total": 372,
        "additions": 192,
        "deletions": 180
    }
}