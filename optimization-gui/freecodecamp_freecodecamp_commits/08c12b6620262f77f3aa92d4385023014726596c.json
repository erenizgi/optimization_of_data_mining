{
    "author": "moT01",
    "message": "feat(curriculum): add react data fetching and memoization transcripts (#59638)\n\nCo-authored-by: Zaira <33151350+zairahira@users.noreply.github.com>\nCo-authored-by: Jessica Wilkins <67210629+jdwilkin4@users.noreply.github.com>\nCo-authored-by: Dario-DC <105294544+Dario-DC@users.noreply.github.com>",
    "sha": "08c12b6620262f77f3aa92d4385023014726596c",
    "files": [
        {
            "sha": "93443a1ec8b4aae0a08a55f05c26af9f63ef382c",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-data-fetching-and-memoization-in-react/67d1a99d10fd509c88faf3bf.md",
            "status": "modified",
            "additions": 289,
            "deletions": 2,
            "changes": 291,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/08c12b6620262f77f3aa92d4385023014726596c/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-data-fetching-and-memoization-in-react%2F67d1a99d10fd509c88faf3bf.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/08c12b6620262f77f3aa92d4385023014726596c/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-data-fetching-and-memoization-in-react%2F67d1a99d10fd509c88faf3bf.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-data-fetching-and-memoization-in-react%2F67d1a99d10fd509c88faf3bf.md?ref=08c12b6620262f77f3aa92d4385023014726596c",
            "patch": "@@ -2,13 +2,300 @@\n id: 67d1a99d10fd509c88faf3bf\n title: How Does Data Fetching Work in React?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: _gwWcrZ1WJo\n dashedName: how-does-data-fetching-work-in-react\n ---\n \n # --description--\n \n-Watch the video lecture and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How does data fetching work in React?\n+\n+React apps often rely on external APIs and databases for dynamic content. To access the data from those APIs and databases, you need to use some data fetching techniques.\n+\n+Let's take a look at how data fetching works in React and the different options available to you for fetching data.\n+\n+React is not opinionated about how you fetch your data, this means on a basic level, you can use the built-in Fetch API, which all modern browsers support.\n+\n+You can also use Axios and SWR. Axios is promise-based HTTP request library built on top of the XMLHttpRequest object, and SWR is a React hook for data fetching created by the Vercel team.\n+\n+Let's start with an example. You first need to import the `useState` and `useEffect` hooks:\n+\n+```js\n+import { useState, useEffect } from \"react\";\n+```\n+\n+Then you will need to create three state variables called `loading`, `data`, and `error`:\n+\n+```js\n+const [data, setData] = useState(null);\n+const [loading, setLoading] = useState(true);\n+const [error, setError] = useState(null);\n+```\n+\n+The `loading` variable will track whether the data is still being fetched. The `data` variable represents the data itself, and the `error` variable will capture any errors that might occur during the data fetching process.\n+\n+Since data fetching is a side effect, it's best to use the Fetch API inside of a `useEffect` hook.\n+\n+Here's an example of that:\n+\n+```js\n+useEffect(() => {\n+  fetch(\"https://jsonplaceholder.typicode.com/posts\")\n+    .then((res) => res.json())\n+    .then((data) => {\n+      setData(data);\n+      setLoading(false);\n+    })\n+    .catch((err) => {\n+      setError(err);\n+      setLoading(false);\n+    });\n+}, []);\n+```\n+\n+This `useEffect` fetches the data with the Fetch API and sets all the states. \n+\n+You can make things better by using `async`/`await` instead of the `.then()` syntax. That means you have to have a separate function inside the `useEffect` because you cannot prefix `useEffect` with the `async` keyword:\n+\n+```js\n+useEffect(() => {\n+  const fetchData = async () => {\n+    try {\n+      const res = await fetch(\"https://jsonplaceholder.typicode.com/posts\");\n+       \n+      if (!res.ok) {\n+        throw new Error(\"Network response was not ok\");\n+      }\n+\n+      const data = await res.json();\n+      setData(data);\n+    } catch (err) {\n+      setError(err);\n+    } finally {\n+      setLoading(false);\n+    }\n+  };\n+\n+  fetchData();\n+}, []);\n+```\n+\n+You can then go ahead and use all of those states to render the data from the API.\n+\n+Here's the full code:\n+\n+```js\n+import { useState, useEffect } from \"react\";\n+\n+const FetchPosts = () => {\n+  const [data, setData] = useState(null);\n+  const [loading, setLoading] = useState(true);\n+  const [error, setError] = useState(null);\n+\n+  useEffect(() => {\n+    const fetchData = async () => {\n+      try {\n+        const res = await fetch(\"https://jsonplaceholder.typicode.com/posts\");\n+       \n+        if (!res.ok) {\n+          throw new Error(\"Network response was not ok\");\n+        }\n+\n+        const data = await res.json();\n+        setData(data);\n+      } catch (err) {\n+        setError(err);\n+      } finally {\n+        setLoading(false);\n+      }\n+    };\n+\n+    fetchData();\n+  }, []);\n+\n+  if (loading) {\n+    return <p>Loading...</p>;\n+  }\n+\n+  if (error) {\n+    return <p>{error.message}</p>;\n+  }\n+\n+  return (\n+    <ul>\n+      {data.map((post) => (\n+        <li key={post.id}>{post.title}</li>\n+      ))}\n+    </ul>\n+  );\n+};\n+\n+export default FetchPosts;\n+```\n+\n+In the UI, you would see `Loading...` on the screen when the data is being fetched, and then the data or error would show depending on if the data fetch was successful.\n+\n+Remember we talked about data fetching with Axios and SWR too. Let's take a look at an example using Axios.\n+\n+You will first need to install Axios from the command line like this:\n+\n+```sh\n+npm i axios\n+```\n+\n+Then you will need to import Axios like this:\n+\n+```js\n+import axios from \"axios\";\n+```\n+\n+Then you can use the same state variables from earlier and fetch data from the API using `axios.get`:\n+\n+```js\n+const [data, setData] = useState(null);\n+const [loading, setLoading] = useState(true);\n+const [error, setError] = useState(null);\n+\n+useEffect(() => {\n+  const fetchData = async () => {\n+    try {\n+      const res = await axios.get(\n+        \"https://jsonplaceholder.typicode.com/users\"\n+      );\n+      setData(res.data);\n+    } catch (err) {\n+      setError(err);\n+    } finally {\n+      setLoading(false);\n+    }\n+  };\n+\n+  fetchData();\n+}, []);\n+```\n+\n+You might have noticed that there is no `await res.json()` line in this example. That's because Axios automatically parses JSON, so there's no need for that.\n+\n+The last example we will look at is to use the `useSWR` hook to fetch data.\n+\n+Just like with Axios, you will need to install SWR like this:\n+\n+```sh\n+npm install swr\n+```\n+\n+Then you will need to import the `useSWR` hook into the file like this:\n+\n+```js\n+import useSWR from \"swr\";\n+```\n+\n+In comparison to the previous examples, the SWR syntax is way shorter. What you need to do is to create a fetcher function and pass it into the `useSWR` hook as its second parameter (the endpoint is the first parameter).\n+\n+You also get to destructure both the data and error states from the `useSWR` hook, so you don't need the `useState` hook.\n+\n+Here is the syntax:\n+\n+```js\n+const fetcher = (url) => fetch(url).then((res) => res.json());\n+const { data, error } = useSWR(endpoint, fetcher);\n+```\n+\n+Note that the \"fetcher\" name here is only a convention, so you're free to name the variable whatever you want.\n+\n+Here's a component fetching todos from the JSON Placeholder API:\n+\n+```js\n+import useSWR from \"swr\";\n+\n+const fetcher = (url) => fetch(url).then((res) => res.json());\n+\n+const FetchTodos = () => {\n+ const { data, error } = useSWR(\n+   \"https://jsonplaceholder.typicode.com/todos\",\n+   fetcher\n+ );\n+\n+ if (!data) {\n+   return <h2>Loading...</h2>;\n+ }\n+ if (error) {\n+   return <h2>Error: {error.message}</h2>;\n+ }\n+\n+ return (\n+   <>\n+     <h2>Todos</h2>\n+     <div>\n+       {data.map((todo) => (\n+         <h3 key={todo.id}>{todo.title}</h3>\n+       ))}\n+     </div>\n+   </>\n+ );\n+};\n+\n+export default FetchTodos;\n+```\n+\n+As you learned in a previous lecture on custom hooks, data fetching is a logic you can extract into a custom hook. So, if you're fetching data in multiple components and pages, it is best to create a `useFetch` hook.\n+\n+Here's a `useFetch` hook that uses SWR for data fetching:\n+\n+```js\n+import useSWR from \"swr\";\n+\n+const fetcher = (url) => fetch(url).then((res) => res.json());\n+\n+const useFetch = (url) => {\n+ const { data, error } = useSWR(url, fetcher);\n+\n+ return {\n+   data,\n+   loading: !data && !error,\n+   error,\n+ };\n+};\n+\n+export default useFetch;\n+```\n+\n+And here's how to use the `useFetch` hook to rewrite the first example that fetches posts from the JSON Placeholder API:\n+\n+```js\n+import useFetch from \"./useFetch\";\n+\n+const FetchPosts = () => {\n+ const { data, loading, error } = useFetch(\n+   \"https://jsonplaceholder.typicode.com/posts\"\n+ );\n+\n+ if (loading) {\n+   return <h2>Loading...</h2>;\n+ }\n+\n+ if (error) {\n+   return <h2>{error.message}</h2>;\n+ }\n+\n+ return (\n+   <>\n+     <h2>Posts</h2>\n+     <ul>\n+       {data.map((post) => (\n+         <li key={post.id}>{post.title}</li>\n+       ))}\n+     </ul>\n+   </>\n+ );\n+};\n+\n+export default FetchPosts;\n+```\n \n # --questions--\n "
        },
        {
            "sha": "2bba65e0981f7d691a5aaf2cc03294742d0b90a6",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-data-fetching-and-memoization-in-react/67d2f4ddb4a4306fdf5bbaee.md",
            "status": "modified",
            "additions": 127,
            "deletions": 2,
            "changes": 129,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/08c12b6620262f77f3aa92d4385023014726596c/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-data-fetching-and-memoization-in-react%2F67d2f4ddb4a4306fdf5bbaee.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/08c12b6620262f77f3aa92d4385023014726596c/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-data-fetching-and-memoization-in-react%2F67d2f4ddb4a4306fdf5bbaee.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-data-fetching-and-memoization-in-react%2F67d2f4ddb4a4306fdf5bbaee.md?ref=08c12b6620262f77f3aa92d4385023014726596c",
            "patch": "@@ -2,13 +2,138 @@\n id: 67d2f4ddb4a4306fdf5bbaee\n title: What Is Memoization, and How Does the useMemo Hook Work?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: 2X7LD_6P4eI\n dashedName: what-is-memoization-and-how-does-the-usememo-hook-work\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What is memoization and how does the `useMemo` hook work?\n+\n+As your React app gets larger, unnecessary re-renders and expensive calculations can slow down performance, leading to slow UI updates and increased resource usage.\n+\n+This can be especially problematic in apps with complex state management, large lists, functions that require heavy computations, and many components with a single parent.\n+\n+This gives rise to the need to optimize your React app for better performance by minimizing redundant computations and ensuring smoother interactions.\n+\n+React solves this problem with a process called memoization, a technique which caches values and functions to prevent unnecessary recalculations, so your app can be faster and more responsive.\n+\n+By definition, memoization is an optimization technique in which the result of expensive function calls are cached (remembered) based on specific arguments. When the same arguments are provided again, the cached result is returned instead of re-computing the function.\n+\n+The memoization process happens this way:\n+\n+- Store the results of function calls along with their input arguments.\n+\n+- Before executing the function, check if the result for the current arguments already exists in the cache.\n+\n+- If it exists, return the cached result instead of running the computation again.\n+\n+- If it doesn't exist, compute the result, store it in the cache, and then return it.\n+\n+To improve developer experience with memoization, React provides three tools – `React.memo` (or `memo`), `useMemo` and `useCallback`. \n+\n+As you might guess, both `useMemo` and `useCallback` are hooks, but `React.memo` is a component wrapper, a higher-order function (HOC).\n+\n+In the next lecture, we will take a look at how the `useCallback` hook and `React.memo` work.\n+\n+`useMemo` lets you memoize computed values while `useCallback` does the same for function references.\n+\n+If you're wondering what computed values and function references are, computed values refer to the result of executing a function, while function references are the pointers to functions – the function object in memory.\n+\n+Let's see how to use the `useMemo` hook first. Here's the basic syntax of the `useMemo` hook:\n+\n+```js\n+const memoizedValue = useMemo(\n+ function () {\n+   return computeExpensiveValue(a, b);\n+ },\n+ [a, b]\n+);\n+```\n+\n+You can see all that's needed is to wrap the `useMemo` hook around the function.\n+\n+This `ExpensiveSquare` component will receive a `num` prop which it will use to calculate the square:\n+\n+```js\n+function ExpensiveSquare({ num }) {\n+ function calculateSquare(n) {\n+   console.log(\"Calculating square...\");\n+   return n * n;\n+ }\n+\n+ const squared = calculateSquare(num);\n+ return (\n+   <p>\n+     Square of {num}: {squared}\n+   </p>\n+ );\n+}\n+export default ExpensiveSquare;\n+```\n+\n+Here's the `App` component where the `ExpensiveSquare` is being used:\n+\n+```js\n+import { useState, useEffect } from \"react\";\n+import ExpensiveSquare from \"./components/ExpensiveSquare\";\n+\n+function App() {\n+ const [timer, setTimer] = useState(0);\n+ const [num, setNum] = useState(0);\n+\n+ useEffect(() => {\n+   const interval = setInterval(() => setTimer((c) => c + 1), 1000);\n+   return () => clearInterval(interval);\n+ }, []);\n+\n+ return (\n+   <div>\n+     <h1>Timer: {timer} seconds gone</h1>\n+     <ExpensiveSquare num={num} />\n+     <button onClick={() => setNum((n) => n + 1)}>Increase Number</button>\n+   </div>\n+ );\n+}\n+\n+export default App;\n+```\n+\n+The `timer` in the `useEffect`, running every second, will make the `calculateSquare` function runs any time it runs, even when you don't increase the `num` state variable.\n+\n+To solve this problem, we can use the `useMemo` hook by wrapping the function call in it and specifying the `num` variable as the dependency:\n+\n+```js\n+// import the useMemo hook\n+import { useMemo } from \"react\";\n+\n+function ExpensiveSquare({ num }) {\n+  function calculateSquare(n) {\n+    console.log(\"Calculating square...\");\n+    return n * n;\n+  }\n+\n+  // const squared = calculateSquare(num);\n+  // Wrap the function call in useMemo instead\n+  const squared = useMemo(() => calculateSquare(num), [num]);\n+\n+  return (\n+    <p>\n+      Square of {num}: {squared}\n+    </p>\n+  );\n+}\n+\n+export default ExpensiveSquare;\n+```\n+\n+This will make sure the function is memoized by caching the result, so calculation happens only when the `num` variable changes, not when anything changes in the component it's being used in.\n+\n+The `calculateSquare` function call is not running any time `timer` changes anymore but on the initial render and when `num` changes.\n \n # --questions--\n "
        },
        {
            "sha": "e2549462604cb62bed7ea3c34c77e4ebe4bb6270",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-data-fetching-and-memoization-in-react/67d2f51ff2c927713caa24fa.md",
            "status": "modified",
            "additions": 174,
            "deletions": 2,
            "changes": 176,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/08c12b6620262f77f3aa92d4385023014726596c/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-data-fetching-and-memoization-in-react%2F67d2f51ff2c927713caa24fa.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/08c12b6620262f77f3aa92d4385023014726596c/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-data-fetching-and-memoization-in-react%2F67d2f51ff2c927713caa24fa.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-data-fetching-and-memoization-in-react%2F67d2f51ff2c927713caa24fa.md?ref=08c12b6620262f77f3aa92d4385023014726596c",
            "patch": "@@ -2,13 +2,185 @@\n id: 67d2f51ff2c927713caa24fa\n title: How Do the useCallback Hook and React.memo Work?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: BGK2SLMOthI\n dashedName: how-do-the-usecallback-hook-and-react-memo-work\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How do the `useCallback` hook and `React.memo` work?\n+\n+In the last lecture, you learned about memoization and how the `useMemo` hook works.\n+\n+In this lecture, you'll learn how the `useCallback` hook and `React.memo` work.\n+\n+In the last lecture, we also mentioned that `useCallback` is for memoizing function references.\n+\n+For `React.memo`, it lets you memoize a component to prevent it from unnecessary re-renders when its prop has not changed.\n+\n+Here's the basic syntax of the `useCallback` hook:\n+\n+```js\n+const handleClick = useCallback(() => {\n+  // code goes here\n+}, [dependency]);\n+```\n+\n+And here's the basic syntax of `React.memo`:\n+\n+```js\n+const MemoizedComponent = React.memo(({ prop }) => {\n+  return (\n+    <>\n+      {/* Presentation */}\n+    </>\n+  )\n+});\n+```\n+\n+Let's look at an example of the `useCallback` hook:\n+\n+```js\n+import { useState, useEffect } from \"react\";\n+\n+function Counter() {\n+  const [count, setCount] = useState(0);\n+\n+  const handleClick = () => {\n+    setCount((prevCount) => prevCount + 1);\n+  };\n+\n+  useEffect(() => {\n+    console.log(\"useEffect runs\");\n+  }, [handleClick]);\n+\n+  return (\n+    <div>\n+      <p>Count: {count}</p>\n+      <button onClick={handleClick}>Increment</button>\n+    </div>\n+  );\n+}\n+\n+export default Counter;\n+```\n+\n+In the component, the effect runs any time `handleClick` changes because the `handleClick` function is being recreated on every render.\n+\n+To fix this, you need to tell React to treat the `handleClick` function as the same thing across renders by memoizing it with the `useCallback` hook, so it doesn't get recreated:\n+\n+```js\n+import { useState, useEffect, useCallback } from \"react\";\n+\n+function Counter() {\n+  const [count, setCount] = useState(0);\n+\n+  // Memoize the handleClick function with useCallback\n+  const handleClick = useCallback(() => {\n+    setCount((prevCount) => prevCount + 1);\n+  }, []);\n+\n+  useEffect(() => {\n+    console.log(\"useEffect runs\");\n+  }, [handleClick]);\n+\n+  return (\n+    <div>\n+      <p>Count: {count}</p>\n+      <button onClick={handleClick}>Increment</button>\n+    </div>\n+  );\n+}\n+\n+export default Counter;\n+```\n+\n+Now the `handleClick` function is not being recreated on every render.\n+\n+To show you how the `React.memo` (or `memo`) higher-order function works and the `useCallback` hook work in tandem, here's a `Counter` component with a `handleClick` function that needs `useCallback` but is currently not using it:\n+\n+```js\n+import { useState, useEffect, useCallback } from \"react\";\n+import CounterChild from \"./CounterChild\";\n+\n+function Counter() {\n+  const [count, setCount] = useState(0);\n+  const [timer, setTimer] = useState(new Date().toLocaleTimeString());\n+\n+  const handleClick = () => {\n+    setCount(count + 1);\n+  };\n+\n+  useEffect(() => {\n+    const interval = setInterval(() => {\n+      setTimer(new Date().toLocaleTimeString());\n+    }, 1000);\n+\n+    return () => clearInterval(interval);\n+  }, []);\n+\n+  return (\n+    <div>\n+      <h1>Time: {timer}</h1>\n+      <p>Count: {count}</p>\n+      <button onClick={handleClick}>Increment</button>\n+      <CounterChild onClick={handleClick} />\n+    </div>\n+  );\n+}\n+\n+export default Counter;\n+```\n+\n+This function also has a timer in state that updates every second. This makes the component re-render every time the `timer` changes, making the `handleClick` function get recreated on every render.\n+\n+That's why the `handleClick` needs to be memoized with `useCallback`.\n+\n+Here's the `CounterChild` component:\n+\n+```js\n+const CounterChild = ({ onClick }) => {\n+  console.log(\"CounterChild component rendered\");\n+  return <button onClick={onClick}>Increment from Child</button>;\n+};\n+\n+export default CounterChild;\n+```\n+\n+This `CounterChild` component takes an `onClick` prop, giving you the ability to also increment the counter from it.\n+\n+Since the `CounterChild` component is a child of the `Counter` component, it will also render any time the `Counter` re-renders due to the changing timer. So, the `CounterChild` also needs to be memoized.\n+\n+Without memoization, because as the component re-renders due to the timer updating every second, the `CounterChild` component is also re-rendered.\n+\n+To prevent this, you need to memoize the `CounterChild` component with `React.memo`:\n+\n+```js\n+import React from \"react\";\n+\n+const CounterChild = React.memo(({ onClick }) => {\n+  console.log(\"CounterChild component rendered\");\n+  return <button onClick={onClick}>Increment from Child</button>;\n+});\n+\n+export default CounterChild;\n+```\n+\n+Things do not work optimally yet even after memoizing the `CounterChild` with `React.memo`.\n+\n+This happens because the `handleClick` function is being recreated on every render, so it also needs to be memoized with `useCallback`, in order to tell React that you need the function to stay the same across renders:\n+\n+```js\n+const handleClick = useCallback(() => {\n+  setCount((prevCount) => prevCount + 1);\n+}, [count]);\n+```\n+\n+Now, the component only re-renders when the `count` state changes.\n \n # --questions--\n "
        },
        {
            "sha": "4ddfbfa68677844c4ab0e77f5e7fb35c94ed776c",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-data-fetching-and-memoization-in-react/67e2a513dbffdc8dcf1700af.md",
            "status": "modified",
            "additions": 302,
            "deletions": 6,
            "changes": 308,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/08c12b6620262f77f3aa92d4385023014726596c/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-data-fetching-and-memoization-in-react%2F67e2a513dbffdc8dcf1700af.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/08c12b6620262f77f3aa92d4385023014726596c/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-data-fetching-and-memoization-in-react%2F67e2a513dbffdc8dcf1700af.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-data-fetching-and-memoization-in-react%2F67e2a513dbffdc8dcf1700af.md?ref=08c12b6620262f77f3aa92d4385023014726596c",
            "patch": "@@ -2,31 +2,327 @@\n id: 67e2a513dbffdc8dcf1700af\n title: What Is the useOptimistic Hook, and How Does It Work?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: ZmjYqlrU4g0\n dashedName: what-is-the-useoptimistic-hook-and-how-does-it-work\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What is the `useOptimistic` hook and how does it work?\n+\n+Recent versions of React introduced server components and server actions to shift some of the rendering and logic responsibilities to the server.\n+\n+Along with those updates, React added a new hook called `useOptimistic` to keep UIs responsive while waiting for an async action to complete in the background.\n+\n+While this is often used for fetching data from a server, it's not limited to that. The hook is generally useful for handling async operations, ensuring the UI remains smooth and interactive while the action runs.\n+\n+Let's take a look at what the `useOptimistic` hook is and how it contributes to making snappy and responsive UIs. \n+\n+The `useOptimistic` hook helps manage \"optimistic updates\" in the UI, a strategy in which you provide immediate updates to the UI based on the expected outcome of an action, like waiting for a server response.\n+\n+Here's the basic syntax of the `useOptimistic` hook:\n+\n+```js\n+const [optimisticState, addOptimistic] = useOptimistic(actualState, updateFunction);\n+```\n+\n+- `optimisticState` is the temporary state that updates right away for a better user experience.\n+\n+- `addOptimistic` is the function that applies the optimistic update before the actual state changes.\n+\n+- `actualState` is the real state value that comes from the result of an action, like fetching data from a server.\n+\n+- `updateFunction` is the function that determines how the optimistic state should update when called.\n+\n+At first glance, it might seem like the `useOptimistic` hook is just another way to handle loading states in React. But it's more than that.\n+\n+A loading state controls whether you see a spinner, message, or some other indicator in the UI while something happens in the background. \n+\n+However, the `useOptimistic` hook updates the UI instantaneously based on an expected outcome, even before you, say, make a call to an API. This hook gives you a chance to show a loading indicator or message, handle potential errors gracefully, and show instant feedback to make the UI feel snappy.\n+\n+This will become clearer as we go through some examples showing how the `useOptimistic` hook works.\n+\n+Here's an action that simulates saving a task to a server. It returns the task after a 1 second delay, as it could happen with a real-world API request:\n+\n+```js\n+export async function saveTask(task) {\n+  await new Promise((res) => setTimeout(res, 1000));\n+\n+  return task;\n+}\n+```\n+\n+Here's the code that sets up the `useOptimistic` hook by importing and initializing it, with an `handleSubmit` function that sends an input to the action:\n+\n+```js\n+\"use client\";\n+\n+import { useOptimistic } from \"react\";\n+\n+export default function TaskList({ tasks, addTask }) {\n+  const [optimisticTasks, addOptimisticTask] = useOptimistic(\n+    tasks,\n+    (state, newTask) => [...state, { text: newTask, pending: true }]\n+  );\n+\n+  async function handleSubmit(e) {\n+    e.preventDefault();\n+    const formData = new FormData(e.target);\n+\n+    addOptimisticTask(formData.get(\"task\"));\n+\n+    addTask(formData);\n+    e.target.reset();\n+  }\n+\n+  return <>{/* UI */}</>;\n+}\n+```\n+\n+In the code, the `useOptimistic` hook keeps a temporary list of tasks that updates immediately when you add a new task.\n+\n+The line, `(state, newTask) => [...state, { text: newTask, pending: true }]` ensures that a new task appears with a pending status even before the server confirms something is coming from the form.\n+\n+When the form is submitted, the `handleSubmit` function extracts the task and adds it \"optimistically\" with the `addOptimisticTask` parameter. Then `addTask` is passed as a prop which sends the task to the server. Finally, the form is reset by calling `e.target.reset()`.\n+\n+Here's the `TaskList` component:\n+\n+```js\n+\"use client\";\n+import { useOptimistic, startTransition } from \"react\";\n+\n+export default function TaskList({ tasks, addTask }) {\n+  const [optimisticTasks, addOptimisticTask] = useOptimistic(\n+    tasks,\n+    (state, newTask) => [...state, { text: newTask, pending: true }]\n+  );\n+\n+  async function handleSubmit(e) {\n+    e.preventDefault();\n+    const formData = new FormData(e.target);\n+\n+    startTransition(() => {\n+      addOptimisticTask(formData.get(\"task\"));\n+    });\n+\n+    addTask(formData);\n+    e.target.reset();\n+  }\n+\n+  return (\n+    <div className=\"max-w-md mx-auto p-4\">\n+      <h3 className=\"text-xl font-medium mb-3\">Tasks</h3>\n+\n+      <ul className=\"space-y-2 mb-4\">\n+        {optimisticTasks.map((task, index) => (\n+          <li key={index} className=\"p-2 border-b\">\n+            {task.text}\n+            {task.pending && (\n+              <small className=\"ml-2 text-gray-500 text-sm\">\n+                Adding Task...\n+              </small>\n+            )}\n+          </li>\n+        ))}\n+      </ul>\n+\n+      <form onSubmit={handleSubmit} className=\"flex gap-2\">\n+        <input\n+          type=\"text\"\n+          name=\"task\"\n+          placeholder=\"Type in a task...\"\n+          className=\"flex-1 p-2 border\"\n+        />\n+        <button type=\"submit\" className=\"bg-gray-200 px-3 py-2 cursor-pointer\">\n+          Submit\n+        </button>\n+      </form>\n+    </div>\n+  );\n+}\n+```\n+\n+Here, we are looping through the `optimisticTask` parameter to display the task. When `task.pending` is `true`, the text `Adding Task...` is displayed next to the task, confirming that the task has been added optimistically before the server confirms it.\n+\n+Here's the `Task` component that manages the state for the form. It calls the `saveTask` function from the action so it can add the task, and appends the new task once it is received by the server:\n+\n+```js\n+\"use client\";\n+\n+import { useState } from \"react\";\n+import TaskList from \"./TaskList\";\n+import { saveTask } from \"./actions\";\n+\n+export default function Tasks() {\n+  const [tasks, setTasks] = useState([]);\n+\n+  async function addTask(formData) {\n+    const newTaskText = formData.get(\"task\");\n+\n+    const savedTask = await saveTask(newTaskText);\n+    setTasks((prev) => [...prev, { text: savedTask, pending: false }]);\n+  }\n+\n+  return <TaskList tasks={tasks} addTask={addTask} />;\n+}\n+```\n+\n+This ensures snappy UI updates by showing instant feedback instead of waiting for a response. Once the task is saved, the `pending` property is removed, and the final task list updates accordingly.\n+\n+In the UI, there are two things happening that are not supposed to happen. First, you can't see the `Adding Task...` text since it appears and disappears too quickly. Next, there's an error occurring after adding the task.\n+\n+There are two things we need to do to address those issues.\n+\n+First, we need to import `startTransition` from React and use it to wrap the line `addOptimisticTask(formData.get('task'))`:\n+\n+```js\n+startTransition(() => {\n+  addOptimisticTask(formData.get(\"task\"));\n+});\n+```\n+\n+Second, we need to make the `Adding Task...` text visible for some time before it goes away.\n+\n+To do this, we can modify the `addTask` function with a pending state and simulate a delay of a few seconds before marking the task as completed. `setTimeout()` is ideal for this:\n+\n+```js\n+async function addTask(formData) {\n+  const newTaskText = formData.get(\"task\");\n+\n+  // Add an optimistic task with a pending state\n+  const tempTask = { id: Date.now(), text: newTaskText, pending: true };\n+  setTasks((prev) => [...prev, tempTask]);\n+\n+  // Simulate a 3 seconds delay before marking the task as completed\n+  setTimeout(async () => {\n+    const savedTask = await saveTask(newTaskText);\n+\n+    setTasks((prev) =>\n+      prev.map((task) =>\n+        task.id === tempTask.id\n+          ? { ...task, text: savedTask, pending: false }\n+          : task\n+      )\n+    );\n+  }, 3000);\n+}\n+```\n+\n+And once you do that, everything works fine.\n \n # --questions--\n \n ## --text--\n \n-What Is the useOptimistic Hook, and How Does It Work? question?\n+What is the purpose of the `useOptimistic` hook?\n \n ## --answers--\n \n-Answer 1\n+It allows components to fetch data from the server before rendering the UI.\n+\n+### --feedback--\n+\n+This hook ensures the UI reflects expected changes before an async operation completes.\n+\n+---\n+\n+It helps manage optimistic updates by updating the UI immediately while waiting for an async operation, like a server response.\n+\n+---\n+\n+It enables automatic error handling and rollback for failed API requests in React applications.\n+\n+### --feedback--\n+\n+This hook ensures the UI reflects expected changes before an async operation completes.\n+\n+---\n+\n+It optimizes state updates by batching them together to improve performance.\n+\n+### --feedback--\n+\n+This hook ensures the UI reflects expected changes before an async operation completes.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+How is the `useOptimistic` hook different from a loading state?\n+\n+## --answers--\n+\n+A loading state shows UI feedback while waiting for a response, whereas `useOptimistic` updates the UI immediately based on an expected outcome.\n \n ---\n \n-Answer 2\n+A loading state modifies server data instantly while `useOptimistic` only updates the client UI.\n+\n+### --feedback--\n+\n+One updates the UI before the server even knows about the request.\n \n ---\n \n-Answer 3\n+The `useOptimistic` hook is used for handling errors, whereas a loading state is only for showing spinners.\n+\n+### --feedback--\n+\n+One updates the UI before the server even knows about the request.\n+\n+---\n+\n+Both are the same, but `useOptimistic` provides automatic retries for failed requests.\n+\n+### --feedback--\n+\n+One updates the UI before the server even knows about the request.\n+\n+## --video-solution--\n+\n+1\n+\n+## --text--\n+\n+What does `addOptimistic` do in the `useOptimistic` hook syntax below?\n+\n+```js\n+const [optimisticState, addOptimistic] = useOptimistic(actualState, updateFunction);\n+```\n+\n+## --answers--\n+\n+It applies the optimistic update before the actual state changes, providing a smoother user experience.\n+\n+---\n+\n+It fetches the real state from the server and updates the UI accordingly.\n+\n+### --feedback--\n+\n+This function updates the UI before the actual state changes.\n+\n+---\n+\n+It replaces the actual state with a temporary state after receiving a server response.\n+\n+### --feedback--\n+\n+This function updates the UI before the actual state changes.\n+\n+---\n+\n+It validates server data before applying the optimistic update to the UI.\n+\n+### --feedback--\n+\n+This function updates the UI before the actual state changes.\n \n ## --video-solution--\n "
        }
    ],
    "stats": {
        "total": 904,
        "additions": 892,
        "deletions": 12
    }
}