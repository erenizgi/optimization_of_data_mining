{
    "author": "Ksound22",
    "message": "feat (curriculum): add oop and encapsulation lectures (#62121)\n\nCo-authored-by: Ilenia <26656284+ilenia-magoni@users.noreply.github.com>\nCo-authored-by: Sem Bauke <sem@freecodecamp.org>\nCo-authored-by: Copilot <175728472+Copilot@users.noreply.github.com>",
    "sha": "1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd",
    "files": [
        {
            "sha": "75bb13bcc7909c6c3e890c862cdac54c281c2cd5",
            "filename": "curriculum/challenges/english/blocks/lecture-understanding-object-oriented-programming-and-encapsulation/68420be9af9d89620af7944a.md",
            "status": "modified",
            "additions": 183,
            "deletions": 35,
            "changes": 218,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68420be9af9d89620af7944a.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68420be9af9d89620af7944a.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68420be9af9d89620af7944a.md?ref=1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd",
            "patch": "@@ -1,135 +1,283 @@\n ---\n id: 68420be9af9d89620af7944a\n-# title needs to be updated to correct title when lectures are finalized\n-title: Understanding Object Oriented Programming and Encapsulation\n+title: What is Object-Oriented Programming, and How Does Encapsulation Work?\n challengeType: 19\n-# dashedName needs to be updated to correct title when lectures are finalized\n-dashedName: lecture-understanding-object-oriented-programming-and-encapsulation\n+dashedName: what-is-object-oriented-programming-and-how-does-encapsulation-work\n ---\n \n # --description--\n \n-Watch the video or read the transcript and answer the questions below.\n+Object-oriented programming, also known as OOP, is a programming style in which developers treat everything in their code like a real-world object.\n+\n+A class is like a blueprint for creating objects. Every single object created from a class has attributes that define data and methods that define the behaviors of the objects.\n+\n+In a previous lecture, you learned how to create classes. Here's a reminder of the syntax:\n+\n+```py\n+class ClassName:\n+   def __init__(self, parameters):\n+       attribute = value\n+\n+   def method_name(self):\n+       # method logic\n+```\n+\n+Here's an example of a class that uses the `__init__` special method to initialize the brand and color attributes whenever an object is created using the class:\n+\n+```py\n+class Car:\n+   def __init__(self, brand, color):\n+       self.brand = brand\n+       self.color = color\n+\n+# create two objects from the Car class\n+car1 = Car('Toyota', 'red')\n+car2 = Car('Lambo', 'green')\n+\n+print('Car 1 Brand:', car1.brand) # Car 1 Brand: Toyota\n+print('Car 1 Color:', car1.color) # Car 1 Color: red\n+\n+print('Car 2 Brand:', car2.brand) # Car 2 Brand: Lambo\n+print('Car 2 Color:', car2.color) # Car 2 Color: green\n+```\n+\n+Object-oriented programming has four key principles that help you organize and manage code effectively. They are encapsulation, inheritance, polymorphism, and abstraction.\n+\n+The rest of this lecture will focus on how encapsulation works.\n+\n+Encapsulation is the bundling of the attributes and methods of an object into a single unit, the class.\n+\n+With encapsulation, you can hide the internal state of the object behind a simple set of public methods and attributes that act like doors. Behind those doors are private attributes and methods that control how the data changes and who can see it.\n+\n+Let's say you want to track a wallet balance. You want to allow people to deposit or withdraw money from the wallet, but no one should be able to tamper with the balance directly.\n+\n+In that case, you can make `deposit()` and `withdraw()` public methods, and you hide the balance under the `_balance` attribute:\n+\n+```py\n+class Wallet:\n+   def __init__(self, balance):\n+       self._balance = balance # For internal use by convention\n+\n+   def deposit(self, amount):\n+       if amount > 0:\n+           self._balance += amount # Add to the balance safely\n+\n+   def withdraw(self, amount):\n+       if 0 < amount <= self._balance:\n+           self._balance -= amount # Remove from the balance safely\n+```\n+\n+By convention, prefixing attribute and methods with a single underscore means they are meant for internal use. No one should directly access them from outside the class since it defies the principles of encapsulation, which can lead to bugs.\n+\n+While a single underscore prefix is just a convention, prefixing attributes and methods with a double underscore effectively prevents them to be accessed from the outside of their class, making those attributes and methods private.\n+\n+```py\n+class Wallet:\n+   def __init__(self, balance):\n+       self.__balance = balance # Private attribute\n+\n+   def deposit(self, amount):\n+       if amount > 0:\n+           self.__balance += amount # Add to the balance safely\n+\n+   def withdraw(self, amount):\n+       if 0 < amount <= self.__balance:\n+           self.__balance -= amount # Remove from the balance safely\n+\n+account = Wallet(500)\n+print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'\n+```\n+\n+To get the current value of `__balance`, you can define a get_balance method. For example:\n+\n+```py\n+class Wallet:\n+   def __init__(self, balance):\n+       self.__balance = balance\n+\n+   def deposit(self, amount):\n+       if amount > 0:\n+           self.__balance += amount\n+\n+   def withdraw(self, amount):\n+       if 0 < amount <= self.__balance:\n+           self.__balance -= amount\n+  \n+   def get_balance(self):\n+       return self.__balance\n+\n+\n+acct_one = Wallet(100)\n+acct_one.deposit(50)\n+print(acct_one.get_balance()) # 150\n+\n+acct_two = Wallet(450)\n+acct_two.withdraw(28)\n+print(acct_two.get_balance()) # 422\n+\n+acct_two.deposit(150)\n+print(acct_two.get_balance()) # 572\n+```\n+\n+You can also define a private `__validate` method to check if every deposit or withdrawal amount is a positive number:\n+\n+```py\n+class Wallet:\n+   def __init__(self):\n+       self.__balance = 0\n+\n+   def __validate(self, amount):\n+       if amount < 0:\n+           raise ValueError('Amount must be positive')\n+\n+   def deposit(self, amount):\n+       self.__validate(amount)\n+       self.__balance += amount\n+\n+   def withdraw(self, amount):\n+       self.__validate(amount)\n+       if amount > self.__balance:\n+           raise ValueError('Insufficient funds')\n+       self.__balance -= amount\n+\n+   def get_balance(self):\n+       return self.__balance\n+\n+acct_one = Wallet()\n+acct_one.deposit(4) # ValueError('Amount must be positive')\n+print(acct_one.get_balance()) # 0\n+\n+acct_one.deposit(50)\n+print(acct_one.get_balance()) # 50\n+acct_one.withdraw(-8) # ValueError('Amount must be positive')\n+acct_one.withdraw(58) # ValueError('Insufficient funds')\n+```\n+\n+As you can see, the `__validate` method is private, and runs behind the scenes in the `deposit()` and `withdraw()` public methods to make sure the amount is always valid.\n+\n+In a coming lecture, you will learn more about how attributes prefixed with a double underscore works.\n+\n+In summary, encapsulation locks down internal data behind clear public methods. That's how you keep your classes safe from tampering and centralize validation in one place. You can update or extend your code freely, knowing that outside code only touches the interfaces you expose.\n \n # --questions--\n \n ## --text--\n \n-Question 1\n+What are the four key principles of Object-Oriented Programming (OOP)?\n \n ## --answers--\n \n-Answer 1.1\n+Encapsulation, Inheritance, Polymorphism, Abstraction\n \n ### --feedback--\n \n-Feedback 1\n+Look out for the principles that define how data and behavior are organized in OOP.\n \n ---\n \n-Answer 1.2\n+Variables, Functions, Loops, Conditionals\n \n ### --feedback--\n \n-Feedback 1\n+Look out for the principles that define how data and behavior are organized in OOP.\n \n ---\n \n-Answer 1.3\n+Classes, Objects, Methods, Attributes\n \n ### --feedback--\n \n-Feedback 1\n+Look out for the principles that define how data and behavior are organized in OOP.\n \n ---\n \n-Answer 1.4\n+Public, Private, Protected, Static\n \n ### --feedback--\n \n-Feedback 1\n+Look out for the principles that define how data and behavior are organized in OOP.\n \n ## --video-solution--\n \n-5\n+1\n \n ## --text--\n \n-Question 2\n+Why is it a bad practice to directly access attribute/methods prefixed with a single underscore?\n \n ## --answers--\n \n-Answer 2.1\n+Because Python will raise a syntax error if you try.\n \n ### --feedback--\n \n-Feedback 2\n+Think about how encapsulation exists to protect an object's internal state.\n \n ---\n \n-Answer 2.2\n+Because it violates encapsulation, allowing uncontrolled data access.\n \n ### --feedback--\n \n-Feedback 2\n+Think about how encapsulation exists to protect an object's internal state.\n \n ---\n \n-Answer 2.3\n+Because private properties are slower to access than public ones.\n \n ### --feedback--\n \n-Feedback 2\n+Think about how encapsulation exists to protect an object's internal state.\n \n ---\n \n-Answer 2.4\n+Because they can only be accessed from child classes.\n \n ### --feedback--\n \n-Feedback 2\n+Because they can only be accessed from child classes.\n \n ## --video-solution--\n \n-5\n+2\n \n ## --text--\n \n-Question 3\n+What is the way for indicating private attributes or methods?\n \n ## --answers--\n \n-Answer 3.1\n+Prefix with a single underscore\n \n ### --feedback--\n \n-Feedback 3\n+Look out for the symbols used to prefix the name of a private attribute or method.\n \n ---\n \n-Answer 3.2\n+Use leading and trailing double underscores\n \n ### --feedback--\n \n-Feedback 3\n+Look out for the symbols used to prefix the name of a private attribute or method.\n \n ---\n \n-Answer 3.3\n+Prefix with a double underscore\n \n ### --feedback--\n \n-Feedback 3\n+Look out for the symbols used to prefix the name of a private attribute or method.\n \n ---\n \n-Answer 3.4\n+Use the private keyword\n \n ### --feedback--\n \n-Feedback 3\n+Look out for the symbols used to prefix the name of a private attribute or method.\n \n ## --video-solution--\n \n-5\n+3\n "
        },
        {
            "sha": "a2286acd03d1ad42def7114511c2bf3cd4ae255b",
            "filename": "curriculum/challenges/english/blocks/lecture-understanding-object-oriented-programming-and-encapsulation/68c128cbd77e4ba9ed671937.md",
            "status": "added",
            "additions": 260,
            "deletions": 0,
            "changes": 260,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68c128cbd77e4ba9ed671937.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68c128cbd77e4ba9ed671937.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68c128cbd77e4ba9ed671937.md?ref=1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd",
            "patch": "@@ -0,0 +1,260 @@\n+---\n+id: 68c128cbd77e4ba9ed671937\n+title: What are Getters and Setters\n+challengeType: 19\n+dashedName: what-are-getters-and-setters\n+---\n+\n+# --description--\n+\n+Getters and setters are methods that let you control how the attributes of a class are accessed and modified. With getters you retrieve a value, and with setters you set a value.\n+\n+These actions are done through what's known as properties. They are what connect getters and setters, and allow access to data.\n+\n+Properties act like attributes but behave like methods under the hood. Think of them as data you define like methods, but work like attributes. This means you can access properties with dot notation instead of parentheses or round brackets.\n+\n+The main thing properties do is that they run extra logic behind the scenes when you get, set, or delete values with them. This makes them the perfect choice when you want to access or manipulate data within objects.\n+\n+So why use properties for that instead of methods? It's mostly about readability and convention. They make your code cleaner and easier to read.\n+\n+When you use a method, you always have to call it with parentheses. But with a property, you can access it just like a normal attribute using dot notation. That makes your code look simple even when it is doing extra work behind the scenes.\n+\n+For example, you might want to calculate a value or check that a new value is valid before saving it. Instead of calling a method for that, you can use an attribute-like way to do that.\n+\n+To create a property, you define a method and place the @property decorator above it. This tells Python to treat the method as a property.\n+\n+That takes us to getters. Here's how to create one with the @property decorator:\n+\n+```py\n+class Circle:\n+    def __init__(self, radius):\n+        self._radius = radius\n+\n+    @property\n+    def radius(self): # A getter to get the radius\n+        return self._radius\n+  \n+    @property\n+    def area(self):  # A getter to calculate area\n+        return 3.14 * (self._radius ** 2)\n+\n+my_circle = Circle(3)\n+\n+print(my_circle.radius) # 3\n+print(my_circle.area) # 28.26\n+```\n+\n+This example gets a radius and the area of a circle.\n+\n+Notice how we used `_radius` instead of radius inside the class. The underscore is a common Python convention to show that an attribute is meant to be private. In other words, it signifies that it's for internal use and should not be accessed directly from outside the class.\n+\n+To make a setter to create the radius, for example, you have to define another method with the same name and use `@<property_name>.setter` above it:\n+\n+```py\n+class Circle:\n+    def __init__(self, radius):\n+        self._radius = radius\n+\n+    @property\n+    def radius(self):  # A getter to get the radius\n+        return self._radius\n+\n+    @radius.setter\n+    def radius(self, value):  # A setter to set the radius\n+        if value <= 0:\n+            raise ValueError('Radius must be positive')\n+        self._radius = value\n+\n+my_circle = Circle(3)\n+print('Initial radius:', my_circle.radius) # Initial radius: 3\n+\n+my_circle.radius = 8\n+print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8\n+```\n+\n+In this example, the radius setter is not just setting the radius for the circle, it's also running a validation that makes sure the radius is not a negative number.\n+\n+Once you define getters and setters, Python automatically calls them under the hood whenever you use normal attribute syntax:\n+\n+```py\n+my_circle.radius # This will call the getter\n+my_circle.radius = 4 # This will call the setter\n+```\n+\n+Note that inside the setter, you cannot use same name of the property when assigning a new value. That's because `self.radius = value` will call the setter within the setter method itself, leading to infinite recursion and a `RecursionError`. So you must always use the underscore-prefixed form `self._radius = value`.\n+\n+Just like you can control how an attribute is accessed through getter and how it is modified with setter, you can also control how it is deleted using a deleter.\n+\n+A deleter runs custom logic when you use the del statement on a property. To create one, you use the `@<property_name>.deleter` decorator:\n+\n+```py\n+class Circle:\n+    def __init__(self, radius):\n+        self._radius = radius\n+\n+    # Getter\n+    @property\n+    def radius(self):\n+        return self._radius\n+\n+    # Setter\n+    @radius.setter\n+    def radius(self, value):\n+        if value <= 0:\n+            raise ValueError(\"Radius must be positive\")\n+        self._radius = value\n+\n+    # Deleter\n+    @radius.deleter\n+    def radius(self):\n+        print(\"Deleting radius...\")\n+        del self._radius\n+```\n+\n+Here's how the deleter can be put to use:\n+\n+```py\n+# Create circle object with a radius\n+my_circle = Circle(33)\n+print(\"Initial radius:\", my_circle.radius)  # 33\n+\n+# Delete the radius\n+# This calls the deleter\n+del my_circle.radius # Deleting radius...\n+print(\"Radius deleted!\") # Radius deleted!\n+\n+# Try to access radius after deletion\n+try:\n+    print(my_circle.radius)\n+except AttributeError as e:\n+    print(\"Error:\", e) # Error: 'Circle' object has no attribute '_radius'\n+```\n+\n+The takeaway from this is that:\n+\n+- Getters let you retrieve a value or even compute a value on the fly.\n+- Setters let you modify the values safely by running checks before assignment.\n+- Properties are what tie these getters and setters together so you can write logic while still using dot notation.\n+- Deleters let you define what happens when an attribute is deleted.\n+\n+# --questions--\n+\n+## --text--\n+\n+What lets you run logic behind the scenes while getting or setting an attribute's value?\n+\n+## --answers--\n+\n+Importing external modules.\n+\n+### --feedback--\n+\n+Think about methods that allow validation or computation when reading and writing data.\n+\n+---\n+\n+Class inheritance.\n+\n+### --feedback--\n+\n+Think about methods that allow validation or computation when reading and writing data.\n+\n+---\n+\n+Properties\n+\n+### --feedback--\n+\n+Think about methods that allow validation or computation when reading and writing data.\n+\n+---\n+\n+Direct attribute access.\n+\n+### --feedback--\n+\n+Think about methods that allow validation or computation when reading and writing data.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+What ties getters and setters together so you can execute logic while maintaining dot notation access?\n+\n+## --answers--\n+\n+Properties\n+\n+### --feedback--\n+\n+Think about a feature that lets you use methods like attributes with simple dot syntax.\n+\n+---\n+\n+Decorators\n+\n+### --feedback--\n+\n+Think about a feature that lets you use methods like attributes with simple dot syntax.\n+\n+---\n+\n+Class inheritance\n+\n+### --feedback--\n+\n+Think about a feature that lets you use methods like attributes with simple dot syntax.\n+\n+---\n+\n+Direct method calls\n+\n+### --feedback--\n+\n+Think about a feature that lets you use methods like attributes with simple dot syntax.\n+\n+## --video-solution--\n+\n+1\n+\n+## --text--\n+\n+What two decorators are used to create getters and setters for a property?\n+\n+## --answers--\n+\n+`@getter` and `@setter`\n+\n+### --feedback--\n+\n+Think about decorators that allow method calls to use simple dot notation without parentheses.\n+\n+---\n+\n+`@attr.get` and `@attr.set`\n+\n+### --feedback--\n+\n+Think about decorators that allow method calls to use simple dot notation without parentheses.\n+\n+---\n+\n+`@compute` and `@assign`\n+\n+### --feedback--\n+\n+Think about decorators that allow method calls to use simple dot notation without parentheses.\n+\n+---\n+\n+`@property` and `@<property_name>.setter`\n+\n+### --feedback--\n+\n+Think about decorators that allow method calls to use simple dot notation without parentheses.\n+\n+## --video-solution--\n+\n+4"
        },
        {
            "sha": "1e9e486d8c5c64ed9acac0d8222369a11fea4c1a",
            "filename": "curriculum/challenges/english/blocks/lecture-understanding-object-oriented-programming-and-encapsulation/68c3ba8940e4df8afa83a723.md",
            "status": "added",
            "additions": 255,
            "deletions": 0,
            "changes": 255,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68c3ba8940e4df8afa83a723.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68c3ba8940e4df8afa83a723.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68c3ba8940e4df8afa83a723.md?ref=1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd",
            "patch": "@@ -0,0 +1,255 @@\n+---\n+id: 68c3ba8940e4df8afa83a723\n+title: What Is Inheritance and How Does It Promote Code Reuse?\n+challengeType: 19\n+dashedName: what-is-inheritance-and-how-does-it-promote-code-reuse\n+---\n+\n+# --description--\n+\n+Inheritance is the next key concept of object-oriented programming (OOP) we'll cover.\n+\n+Let's take a deeper look at this concept and how it lets you write reusable code.\n+\n+With inheritance, a subclass (or child class) can use the attributes and methods of a base class (or parent class). This allows you to reuse code, create clear class hierarchies, and customize behavior without rewriting everything. You can customize by extending existing methods or overriding them in the child class.\n+\n+Here's the basic syntax for inheritance:\n+\n+```py\n+class Parent:\n+    # Parent attributes and methods\n+\n+class Child(Parent):\n+    # Child inherits, extends, and/or overrides where necessary\n+```\n+\n+For the `Child` class to inherit from the `Parent` class, you have to pass the Parent to the Child.\n+\n+This style is called single inheritance, since a child class inherits from exactly one parent class.\n+\n+Here's an example:\n+\n+```py\n+class Animal:\n+    def __init__(self, name):\n+        self.name = name\n+\n+    def sound(self):\n+        return f'{self.name} makes a sound'\n+\n+class Dog(Animal):\n+    bark = 'woof! woof!! woof!!!'\n+\n+jack = Dog('Jack')\n+print(jack.sound())  # Jack makes a sound\n+print(jack.bark)  # woof! woof!! woof!!!\n+```\n+\n+You can see that we're able to reuse the `self.name` attribute and the `sound()` method from the parent `Animal` class in the child `Dog` class.\n+\n+Let's override the `sound()` method from the parent `Animal` class in the child `Dog` class so we can have `sound()` use the `bark` class variable:\n+\n+```py\n+class Animal:\n+    def __init__(self, name):\n+        self.name = name\n+\n+    def sound(self):\n+        return f'{self.name} makes a sound.'\n+\n+class Dog(Animal):\n+    bark = 'woof! woof!! woof!!!'\n+\n+    # Override sound() to use bark class variable\n+    def sound(self):\n+        return f'{self.name} barks {self.bark}'\n+\n+jack = Dog('Jack')\n+print(jack.sound())  # Jack barks woof! woof!! woof!!!\n+```\n+\n+If you want to keep the return value of `sound()` and add the bark class variable later, you can extend `sound()` by using the `super()` function:\n+\n+```py\n+class Animal:\n+    def __init__(self, name):\n+        self.name = name\n+\n+    def sound(self):\n+        return f'{self.name} makes a sound'\n+\n+class Dog(Animal):\n+    bark = 'woof! woof!! woof!!!'\n+\n+    # Call Animal.sound(), then append bark\n+    def sound(self):\n+        base = super().sound()\n+        return f'{base}, then {self.name} barks {self.bark}'\n+\n+jack = Dog('Jack')\n+print(jack.sound())  # Jack makes a sound, then Jack barks woof! woof!! woof!!!\n+```\n+\n+In this example, `base` is the result of calling the `sound()` method from the `Animal` class, and then we append the `Dog` class's specific sound to it. This way, you can extend the functionality of the parent `Animal` class while still keeping its original behavior.\n+\n+There's also multiple inheritance, where a child class can inherit from more than one parent class.\n+\n+Here's the basic syntax of multiple inheritance:\n+\n+```py\n+class Parent:\n+    # Attributes and methods for Parent\n+\n+class Child:\n+    # Attributes and methods for Child\n+\n+class GrandChild(Parent, Child):\n+    # GrandChild inherits from both Parent and Child\n+    # GrandChild can combine or override behavior from each\n+```\n+\n+A simple way to demonstrate multiple inheritance is with a frog, which can both walk on land and swim in water:\n+\n+```py\n+class Walker:\n+    def walk(self):\n+        return 'I can walk on land'\n+\n+class Swimmer:\n+    def swim(self):\n+        return 'I can swim in water'\n+\n+# Amphibian inherits from both Walker and Swimmer\n+class Amphibian(Walker, Swimmer):\n+    def __init__(self, name):\n+        self.name = name\n+\n+    def introduce(self):\n+        return f\"I'm {self.name} the frog. {self.walk()} and {self.swim()}.\"\n+\n+frog = Amphibian('Freddy')\n+print(frog.introduce())\n+# Output: I'm Freddy the frog. I can walk on land and I can swim in water.\n+```\n+\n+# --questions--\n+\n+## --text--\n+\n+What is the primary purpose of inheritance in object-oriented programming?\n+\n+## --answers--\n+\n+To create identical copies of a parent class.\n+\n+### --feedback--\n+\n+Think about how a child class can reuse and extend attributes and methods from a parent class.\n+\n+---\n+\n+To allow a child class to reuse and extend attributes/methods from a parent class.\n+\n+### --feedback--\n+\n+Think about how a child class can reuse and extend attributes and methods from a parent class.\n+\n+---\n+\n+To make all methods in a class private.\n+\n+### --feedback--\n+\n+Think about how a child class can reuse and extend attributes and methods from a parent class.\n+\n+---\n+\n+To prevent code duplication by merging unrelated classes.\n+\n+### --feedback--\n+\n+Think about how a child class can reuse and extend attributes and methods from a parent class.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+What is multiple inheritance in Python?\n+\n+## --answers--\n+\n+A child class inheriting from one parent class.\n+\n+### --feedback--\n+\n+Think about the style of inheritance that allows a child to inherit from several classes.\n+\n+---\n+\n+A parent class with multiple child classes.\n+\n+### --feedback--\n+\n+Think about the style of inheritance that allows a child to inherit from several classes.\n+\n+---\n+\n+A child class inheriting from multiple parent classes.\n+\n+### --feedback--\n+\n+Think about the style of inheritance that allows a child to inherit from several classes.\n+\n+---\n+\n+A class that cannot inherit at all.\n+\n+### --feedback--\n+\n+Think about the style of inheritance that allows a child to inherit from several classes.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+How do you make a child class inherit from a parent class in Python?\n+\n+## --answers--\n+\n+By calling `Parent.inherit(Child)`.\n+\n+### --feedback--\n+\n+The syntax involves parentheses in the class definition.\n+\n+---\n+\n+By copying all methods manually.\n+\n+### --feedback--\n+\n+The syntax involves parentheses in the class definition.\n+\n+---\n+\n+By using the `extends` keyword.\n+\n+### --feedback--\n+\n+The syntax involves parentheses in the class definition.\n+\n+---\n+\n+By passing the Parent class as an argument to the Child class.\n+\n+### --feedback--\n+\n+The syntax involves parentheses in the class definition.\n+\n+## --video-solution--\n+\n+4"
        },
        {
            "sha": "97289b275b2290ab5fa2b0e768ecce76088e8013",
            "filename": "curriculum/challenges/english/blocks/lecture-understanding-object-oriented-programming-and-encapsulation/68c3bc4ddb7b469fb7d17c28.md",
            "status": "added",
            "additions": 263,
            "deletions": 0,
            "changes": 263,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68c3bc4ddb7b469fb7d17c28.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68c3bc4ddb7b469fb7d17c28.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68c3bc4ddb7b469fb7d17c28.md?ref=1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd",
            "patch": "@@ -0,0 +1,263 @@\n+---\n+id: 68c3bc4ddb7b469fb7d17c28\n+title: What Is Polymorphism and How Does It Promote Code Reuse?\n+challengeType: 19\n+dashedName: what-is-polymorphism-and-how-does-it-promote-code-reuse\n+---\n+\n+# --description--\n+\n+Polymorphism is the next key concept of object-oriented programming (OOP) we will talk about.\n+\n+With polymorphism, you have access to an interface where you can interact with many objects of the same kind.\n+\n+Let's take a deeper look at polymorphism and how it lets you reuse code.\n+\n+Polymorphism allows methods in different classes to share the same name but perform different tasks. You call the same method name on different objects, and each responds in its own way.\n+\n+Here's the basic example of polymorphism:\n+\n+```py\n+class A:\n+   def action(self): ...\n+\n+class B:\n+   def action(self): ...\n+\n+class C:\n+   def action(self): ...\n+\n+Class().method()  # Works for A, B, or C\n+```\n+\n+Here's an example using different animal sounds to depict polymorphism:\n+\n+```py\n+class Cat:\n+   def speak(self):\n+       return \"A cat meow\"\n+\n+class Bird:\n+   def speak(self):\n+       return \"A bird tweet\"\n+  \n+class Monkey:\n+   def speak(self):\n+       return \"A monkey ooh ooh aah aah ooh ooh aah aah\"\n+\n+def animal_sound(animal):\n+   print(animal.speak())\n+\n+animal_sound(Cat())\n+animal_sound(Bird())\n+animal_sound(Monkey())\n+```\n+\n+In this example, `animal_sound()` is a function that takes any object with a `speak()` method.¬†\n+\n+When you pass in a `Cat`, `Bird`, or `Monkey`, it calls the `speak()` method of the object and prints the result. Because each class defines `speak()` differently, you get different outputs from the same function. That's polymorphism in action.\n+\n+Here's another example, this time with instances and an attribute:\n+\n+```py\n+class Twitter:\n+   def __init__(self, content):\n+       self.content = content\n+\n+   def post(self):\n+       return f\"üê¶ Tweet: '{self.content}' (280 chars max)\"\n+\n+class Instagram:\n+   def __init__(self, content):\n+       self.content = content\n+\n+   def post(self):\n+       return f\"üì∏ Instagram Post: '{self.content}' + ‚ú® filters\"\n+\n+class LinkedIn:\n+   def __init__(self, content):\n+       self.content = content\n+\n+   def post(self):\n+       return f\"üíº LinkedIn Article: '{self.content}' (Professional Mode)\"\n+\n+def start(social_media):\n+   print(social_media.post())  # Calls .post() on any object\n+\n+# Instances\n+tweet = Twitter('Just learned Python polymorphism!')\n+photo = Instagram('Sunset vibes üåÖ')\n+article = LinkedIn('Why OOP matters in 2024')\n+\n+# The polymorphic calls - same function, different outputs\n+start(tweet) # üê¶ Tweet: 'Just learned Python polymorphism!' (280 chars max)\n+start(photo) # üì∏ Instagram Post: 'Sunset vibes üåÖ' + ‚ú® filters\n+start(article) # üíº LinkedIn Article: 'Why OOP matters in 2024' (Professional Mode)\n+```\n+\n+There's also a kind of polymorphism called **inheritance-based polymorphism**.\n+\n+In inheritance-based polymorphism, a parent class defines a method, and multiple child classes override that method in their own way. You can then call the same method on any child object, and it behaves differently depending on which child class it is.\n+\n+Here's an example:\n+\n+```py\n+class Animal:\n+   def speak(self):\n+       return 'Some generic sound'\n+\n+class Cat(Animal):\n+   def speak(self):\n+       return 'A cat meow'\n+\n+class Dog(Animal):\n+   def speak(self):\n+       return 'A dog barks woof woof'\n+\n+class Monkey(Animal):\n+   def speak(self):\n+       return 'A monkey ooh ooh aah aah ooh ooh aah aah'\n+  \n+print(Cat().speak()) # A cat meow\n+print(Dog().speak()) # A dog barks woof woof\n+print(Monkey().speak()) # A monkey ooh ooh aah aah ooh ooh aah aah\n+print(Animal().speak()) # Some generic sound\n+```\n+\n+You can see that each child class of the parent `Animal` class overrides the `speak()` method to provide its own implementation. So when you call the `speak()` method on an instance of each subclass, it returns the specific sound associated with that animal.\n+\n+You can also take things further and do the calling in a list, then loop through the list to display what the `speak()` method returns for each:\n+\n+```py\n+animals = [Cat(), Dog(), Monkey()]\n+\n+for animal in animals:\n+   print(animal.speak())\n+\n+# Output:\n+# A cat meow\n+# A dog barks woof woof\n+# A monkey ooh ooh aah aah ooh ooh aah aah\n+```\n+\n+# --questions--\n+\n+## --text--\n+\n+What is polymorphism in object-oriented programming?\n+\n+## --answers--\n+\n+When a class cannot have methods with the same name.\n+\n+### --feedback--\n+\n+Think about how the word ‚Äúpolymorphism‚Äù means ‚Äúmany forms‚Äù of the same action.\n+\n+---\n+\n+When different classes can use the same method name but implement it differently.\n+\n+### --feedback--\n+\n+Think about how the word ‚Äúpolymorphism‚Äù means ‚Äúmany forms‚Äù of the same action.\n+\n+---\n+\n+When a method must be unique across all classes.\n+\n+### --feedback--\n+\n+Think about how the word ‚Äúpolymorphism‚Äù means ‚Äúmany forms‚Äù of the same action.\n+\n+---\n+\n+When a child class deletes a parent class's method.\n+\n+### --feedback--\n+\n+Think about how the word ‚Äúpolymorphism‚Äù means ‚Äúmany forms‚Äù of the same action.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+In inheritance-based polymorphism, what must a child class do to provide its own implementation of a method defined in the parent class?\n+\n+## --answers--\n+\n+Override the method by redefining it with the same name.\n+\n+### --feedback--\n+\n+Think about how a child class redefines the method while keeping the same signature.\n+\n+---\n+\n+Declare the method as `@static`.\n+\n+### --feedback--\n+\n+Think about how a child class redefines the method while keeping the same signature.\n+\n+---\n+\n+Delete the parent method first.\n+\n+### --feedback--\n+\n+Think about how a child class redefines the method while keeping the same signature.\n+\n+---\n+\n+Use the `@polymorphic` decorator.\n+\n+### --feedback--\n+\n+Think about how a child class redefines the method while keeping the same signature.\n+\n+## --video-solution--\n+\n+1\n+\n+## --text--\n+\n+What is the key benefit of inheritance-based polymorphism?\n+\n+## --answers--\n+\n+It forces all child classes to implement identical behavior.\n+\n+### --feedback--\n+\n+Look out for how polymorphism lets you call the same method on different child classes.\n+\n+---\n+\n+It prevents child classes from modifying parent methods.\n+\n+### --feedback--\n+\n+Look out for how polymorphism lets you call the same method on different child classes.\n+\n+---\n+\n+It allows calling the same method name on different child objects, with each executing its own version.\n+\n+### --feedback--\n+\n+Look out for how polymorphism lets you call the same method on different child classes.\n+\n+---\n+\n+It merges all child methods into the parent class.\n+\n+### --feedback--\n+\n+Look out for how polymorphism lets you call the same method on different child classes.\n+\n+## --video-solution--\n+\n+3"
        },
        {
            "sha": "13231ffa4fbd0030cb0154750425d34cd98951d5",
            "filename": "curriculum/challenges/english/blocks/lecture-understanding-object-oriented-programming-and-encapsulation/68c3bc80f67363a31791fe1c.md",
            "status": "added",
            "additions": 288,
            "deletions": 0,
            "changes": 288,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68c3bc80f67363a31791fe1c.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68c3bc80f67363a31791fe1c.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68c3bc80f67363a31791fe1c.md?ref=1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd",
            "patch": "@@ -0,0 +1,288 @@\n+---\n+id: 68c3bc80f67363a31791fe1c\n+title: What Is Abstraction and How Does It Help Keep Complex Systems Organized?\n+challengeType: 19\n+dashedName: what-is-abstraction-and-how-does-it-help-keep-complex-systems-organized\n+---\n+\n+# --description--\n+\n+Now that we've looked at encapsulation, inheritance, and polymorphism, let's discuss the next key concept of object-oriented programming ‚Äì abstraction.\n+\n+Abstraction is the process of hiding complex implementation details and showing only the essential features of an object or system. Think of it as focusing on what something does rather than how it does it.\n+\n+Abstraction is not limited to Python. It's a programming concept that can be implemented in many languages that support object-oriented programming.\n+\n+To illustrate abstraction, imagine you're driving a car. When you're in the driver's seat, you interact with essential parts like the steering wheel, shifter, and the accelerator and brake pedals. You don't need to know the intricate details of how engine works, how the transmission shifts gears, or the physics behind the braking system, as all of those are the complex implementation details.\n+\n+That's an abstraction at work! It provides you with a simplified interface to interact with a complex system.\n+\n+In the case of a car again, the simplified interface is the steering wheel, brakes, and accelerator, while the complex system is the car itself.\n+\n+As for how Python implements abstraction, it does so through the `abc` module.\n+\n+This module provides the `ABC` class (standing for ‚Äúabstract base class‚Äù) and the  `@abstractmethod` decorator.\n+\n+`ABC` is the class that is meant to be inherited from, but you cannot create direct objects from it. It is what defines a common interface of methods and properties that its subclasses must implement.\n+\n+On the other hand, an abstract method is a method declared in an Abstract Base Class (ABC) using the `@abstractmethod` decorator. It may have no implementation or a basic default one. However, any subclass must override it to be considered concrete and instantiable, even if a default implementation is provided.\n+\n+Here's the basic syntax of abstract class in Python:\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+# Define an abstract base class\n+class AbstractClass(ABC):\n+    @abstractmethod\n+    def abstract_method(self):\n+        pass\n+\n+# Concrete subclass that implements the abstract method\n+class ConcreteClassOne(AbstractClass):\n+    def abstract_method(self):\n+        print('Implementation in ConcreteClassOne')\n+\n+# Another concrete subclass\n+class ConcreteClassTwo(AbstractClass):\n+    def abstract_method(self):\n+        print('Implementation in ConcreteClassTwo')\n+```\n+\n+Here's a basic example:\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+class Animal(ABC): # Inherits from abstract base class\n+   @abstractmethod # Abstract method decorator\n+   def make_sound(self):  # The method subclasses must override\n+       pass\n+\n+# Concrete class that will override the abstract method\n+class Dog(Animal):\n+   def make_sound(self):\n+       print('Woof!')\n+\n+# Another concrete class that will override the abstract method\n+class Cat(Animal):\n+   def make_sound(self):\n+       print('Meow!')\n+\n+# Another concrete class that will override the abstract method\n+class Monkey(Animal):\n+   def make_sound(self):\n+       print('Ooh ooh aah aah!')\n+\n+# Create instances of each concrete class\n+animals = [Dog(), Cat(), Monkey()]\n+\n+# Loop through the instances to call the make_sound method\n+for animal in animals:\n+   animal.make_sound()\n+\n+# Output:\n+# Woof!\n+# Meow!\n+# Ooh ooh aah aah!\n+```\n+\n+In this example:\n+\n+- We are importing the `ABC` class and `abstractmethod` from the `abc` module.\n+- We then create an `Animal` class that inherits from `ABC`, and create an abstract method `make_sound` in it that each subclass of `Animal` must override.\n+- We create the concrete classes `Dog`, `Cat`, and `Monkey`, which must override the `make_sound` abstract method.\n+- We instantiate the concrete classes and call their `make_sound` method to show how each of them implements the `make_sound` abstract method in its own way.\n+\n+Remember that you cannot create an instance of the Animal class. Here's what happens if you try to do that:\n+\n+```py\n+dog = Animal() \n+# TypeError: Can't instantiate abstract class Animal \n+# without an implementation for abstract method 'make_sound'\n+```\n+\n+The same rule applies to subclasses that don't provide an implementation for the abstract method. Even if you define a subclass of Animal, you can't instantiate it until it overrides make_sound. Here's an example showing that:\n+\n+```py\n+class Bird(Animal):\n+    pass\n+\n+bird = Bird()\n+# TypeError: Can't instantiate abstract class Bird \n+# without an implementation for abstract method 'make_sound'\n+```\n+\n+Here's another example, this time with an instance attribute you can pass to the instances of the concrete methods:\n+\n+```py\n+from abc import ABC, abstractmethod\n+\n+# The blueprint for any toy that can speak\n+class TalkingToy(ABC):\n+   def __init__(self, name):\n+       self.name = name\n+   @abstractmethod\n+   def speak(self):\n+       pass\n+\n+class RobotToy(TalkingToy):\n+   def speak(self):\n+       print(f'{self.name} says beep boop! I am a robot!')\n+\n+class TeddyBearToy(TalkingToy):\n+   def speak(self):\n+       print(f\"{self.name} says hug me! I'm cuddly!\")\n+\n+class DinosaurToy(TalkingToy):\n+   def speak(self):\n+       print(f'{self.name} says ROOOOAR!')\n+\n+# Create toys\n+rusty = RobotToy('Rusty')\n+fluffy = TeddyBearToy('Fluffy')\n+rex = DinosaurToy('Rex')\n+\n+toys = [rusty, fluffy, rex]\n+for toy in toys:\n+   toy.speak()\n+\n+# Output:\n+# Rusty says beep boop! I am a robot!\n+# Fluffy says hug me! I'm cuddly!\n+# Rex says ROOOOAR!\n+```\n+\n+In this example:¬†\n+\n+- We have an abstract base class `TalkingToy` that defines a blueprint for any toy that can speak.\n+- The subclasses `RobotToy`, `TeddyBearToy`, and `DinosaurToy` implement the `speak` method in their own way.\n+- When we create instances of these subclasses and call the `speak` method, each toy speaks in its own unique way.\n+\n+In conclusion, abstraction in Python simplifies complex systems by increasing reusability.\n+\n+You've seen how you can reuse a single method from an abstract class across multiple subclasses while forcing each subclass to provide its specific behavior.\n+\n+This approach keeps your code organized, flexible, and easier to maintain, especially as your application grows.\n+\n+# --questions--\n+\n+## --text--\n+\n+What is the primary goal of abstraction in object-oriented programming?\n+\n+## --answers--\n+\n+To expose all internal implementation details to users.\n+\n+### --feedback--\n+\n+Think about how abstraction simplifies interaction with complex systems.\n+\n+---\n+\n+To merge multiple classes into one.\n+\n+### --feedback--\n+\n+Think about how abstraction simplifies interaction with complex systems.\n+\n+---\n+\n+To prevent methods from being overridden in child classes.\n+\n+### --feedback--\n+\n+Think about how abstraction simplifies interaction with complex systems.\n+\n+---\n+\n+To hide complex logic and only show essential features\n+\n+### --feedback--\n+\n+Think about how abstraction simplifies interaction with complex systems.\n+\n+## --video-solution--\n+\n+4\n+\n+## --text--\n+\n+How does Python implement abstraction through its `ABC` module?\n+\n+## --answers--\n+\n+By allowing direct instantiation of abstract classes.\n+\n+### --feedback--\n+\n+The ABC module enforces method implementation in child classes.\n+\n+---\n+\n+By using decorators and inheritance to define abstract methods that subclasses must implement.\n+\n+### --feedback--\n+\n+The ABC module enforces method implementation in child classes.\n+\n+---\n+\n+By automatically hiding all methods with double underscores.\n+\n+### --feedback--\n+\n+The ABC module enforces method implementation in child classes.\n+\n+---\n+\n+By converting classes to functions.\n+\n+### --feedback--\n+\n+The ABC module enforces method implementation in child classes.\n+\n+## --video-solution--\n+\n+2\n+\n+## --text--\n+\n+In the car analogy for abstraction, what represents the simplified interface and the complex system?\n+\n+## --answers--\n+\n+The interface is the engine pistons, and the complex system is the steering wheel.\n+\n+### --feedback--\n+\n+Think about how the interface is what you directly interact with, while the complex system is how it works.\n+\n+---\n+\n+The Interface is the steering wheel, brakes, and accelerator, and the complex system is the engine, transmission, and braking physics.\n+\n+### --feedback--\n+\n+Think about how the interface is what you directly interact with, while the complex system is how it works.\n+\n+---\n+\n+The interface is the car manual, and the complex system is the dashboard controls.\n+\n+### --feedback--\n+\n+Think about how the interface is what you directly interact with, while the complex system is how it works.\n+\n+---\n+\n+The interface is the fuel type, and the complex system is the tyres.\n+\n+### --feedback--\n+\n+Think about how the interface is what you directly interact with, while the complex system is how it works.\n+\n+## --video-solution--\n+\n+2"
        },
        {
            "sha": "da02c69e75ca34f8057748c54015276fe8f3fd39",
            "filename": "curriculum/challenges/english/blocks/lecture-understanding-object-oriented-programming-and-encapsulation/68ca71c3f0ee7ece4ea1e286.md",
            "status": "added",
            "additions": 236,
            "deletions": 0,
            "changes": 236,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68ca71c3f0ee7ece4ea1e286.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68ca71c3f0ee7ece4ea1e286.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation%2F68ca71c3f0ee7ece4ea1e286.md?ref=1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd",
            "patch": "@@ -0,0 +1,236 @@\n+---\n+id: 68ca71c3f0ee7ece4ea1e286\n+title: What is Name Mangling and How Does it Work?\n+challengeType: 19\n+dashedName: what-is-name-mangling-and-how-does-it-work\n+---\n+\n+# --description--\n+\n+In a previous lecture, you learned about prefixing attributes with a single underscore and a double underscore.\n+\n+To remind you of the difference between them, a single underscore is a convention that means the attribute is meant for internal use in the class and should not be directly accessed from outside the class. Double underscore, on the other hand, prevents that attribute from being accessed directly from outside the class.\n+\n+Here's an example that demonstrates how the two work:\n+\n+```py\n+class Example:\n+    def __init__(self):\n+        self._internal = 'I can be accessed from outside the class, but should not'\n+        self.__private = 'You cannot access me directly from outside the class'\n+\n+obj = Example()\n+\n+print(obj._internal) # I can be accessed from outside the class, but should not\n+print(obj.__private)  # AttributeError: 'Example' object has no attribute '__private'\n+```\n+\n+Prefixing an attribute with a double underscore triggers Python's name mangling process, in which Python internally renames the attribute by adding an underscore and the class name as a prefix, turning `__attribute` into `_ClassName__attribute`.\n+\n+To see this in action, you create an instance of the class and use the `__dict__` special attribute of that instance, which is a dictionary containing the object's attributes:\n+\n+```py\n+class Example:\n+    def __init__(self, internal, private):\n+        self._internal = internal\n+        self.__private = private\n+\n+example1 = Example(\n+    'I can be accessed from outside the class, but should not',\n+    'I cannot be accessed directly from outside the class'\n+)\n+\n+print(example1.__dict__)\n+```\n+\n+The result would be:\n+\n+```py\n+{\n+  '_internal': 'I can be accessed from outside the class, but should not',\n+  '_Example__private': 'I cannot be accessed directly from outside the class'\n+}\n+```\n+\n+As you can see, the `__private` attribute is stored as `_Example__private`. This means you can still access that attribute outside the class this way:\n+\n+```py\n+class Example:\n+    def __init__(self, internal, private):\n+        self._internal = internal\n+        self.__private = private\n+\n+example1 = Example(\n+    'I can be accessed from outside the class, but should not',\n+    'I cannot be accessed directly from outside the class'\n+)\n+example2 = Example(\n+    'I should not be accessed from outside the class',\n+    'But I can be accessed from outside the class with name mangling'\n+)\n+\n+print(example1._Example__private) # I cannot be accessed directly from outside the class\n+print(example2._Example__private) # But I can be accessed from outside the class with name mangling\n+```\n+\n+So, why does Python do name mangling?\n+\n+The main purpose of name mangling is to prevent accidental attribute and method overriding when you use inheritance. Here's an example that makes that clear:\n+\n+```py\n+class Parent:\n+    def __init__(self):\n+        self.__data = 'Parent data'\n+\n+class Child(Parent):\n+    def __init__(self):\n+        super().__init__()\n+        self.__data = 'Child data'\n+\n+c = Child()\n+print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}\n+```\n+\n+You can see that both the `Parent` class and the `Child` that inherits from it have their separate `_class__data` attributes. This is made possible with name mangling. Otherwise, the `Child` would have overwritten the Parent data by accident.\n+\n+Here's what would have happened without allowing Python to do the name mangling, that is if you don't prefix the attributes in both classes with double underscore:\n+\n+```py\n+class Parent:\n+   def __init__(self):\n+       self.data = 'Parent data'\n+\n+class Child(Parent):\n+   def __init__(self):\n+       super().__init__()\n+       self.data = 'Child data'\n+\n+c = Child()\n+print(c.__dict__)  # {'data': 'Child data'}\n+```\n+\n+So, which should you use to prefix attributes between single underscore (`_`) and double underscore (`__`)? It depends. If an attribute is only meant for internal use within the class, stick with a single underscore. \n+\n+But if you're working with a class that will be inherited, you should use a double underscore so the attribute from the parent doesn't get overridden. \n+\n+# --questions--\n+\n+## --text--\n+\n+What is the difference between a single underscore and a double underscore?\n+\n+## --answers--\n+\n+A single underscore and a double underscore are treated the same way by Python.\n+\n+### --feedback--\n+\n+Focus on how Python handles attributes that start with `_` vs `__`.\n+\n+---\n+\n+A single underscore makes attributes completely private, while a double underscore makes them protected.\n+\n+### --feedback--\n+\n+Focus on how Python handles attributes that start with `_` vs `__`.\n+\n+---\n+\n+A single underscore prevents direct access, while a double underscore allows direct access.\n+\n+### --feedback--\n+\n+Focus on how Python handles attributes that start with `_` vs `__`.\n+\n+---\n+\n+A single underscore is just a convention, while a double underscore triggers name mangling.\n+\n+### --feedback--\n+\n+Focus on how Python handles attributes that start with `_` vs `__`.\n+\n+## --video-solution--\n+\n+4\n+\n+## --text--\n+\n+What is name mangling?\n+\n+## --answers--\n+\n+A process in which Python converts all attributes into methods for easier access.\n+\n+### --feedback--\n+\n+Think about how Python internally renames double underscore attributes.\n+\n+---\n+\n+A process in which Python deletes attributes with a single underscore to keep them hidden.\n+\n+### --feedback--\n+\n+Think about how Python internally renames double underscore attributes.\n+\n+---\n+\n+A process in which Python changes `__attribute` into `_ClassName__attribute` to avoid accidental overriding in subclasses.\n+\n+### --feedback--\n+\n+Think about how Python internally renames double underscore attributes.\n+\n+---\n+\n+A process in which Python encrypts private data to make it inaccessible from outside the class.\n+\n+### --feedback--\n+\n+Think about how Python internally renames double underscore attributes.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+What happens when you don't prefix attributes in a parent and child classes with a double underscore?\n+\n+## --answers--\n+\n+Both classes keep their own separate copies of the attribute without interfering with each other.\n+\n+### --feedback--\n+\n+Think about what `print(c.__dict__)` shows when both classes use the same attribute name without `__`.\n+\n+---\n+\n+The child class completely overrides the parent class attribute, and the parent's data is lost.\n+\n+### --feedback--\n+\n+Think about what `print(c.__dict__)` shows when both classes use the same attribute name without `__`.\n+\n+---\n+\n+The parent class attributes become read-only and cannot be changed by the child class.\n+\n+### --feedback--\n+\n+Think about what `print(c.__dict__)` shows when both classes use the same attribute name without `__`.\n+\n+---\n+\n+Python raises an error because attributes must always be prefixed with a double underscore.\n+\n+### --feedback--\n+\n+Think about what `print(c.__dict__)` shows when both classes use the same attribute name without `__`.\n+\n+## --video-solution--\n+\n+2"
        },
        {
            "sha": "82bda50589d788382ff4635443ff6bdf57280481",
            "filename": "curriculum/structure/blocks/lecture-understanding-object-oriented-programming-and-encapsulation.json",
            "status": "modified",
            "additions": 26,
            "deletions": 1,
            "changes": 27,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fstructure%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd/curriculum%2Fstructure%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fstructure%2Fblocks%2Flecture-understanding-object-oriented-programming-and-encapsulation.json?ref=1f8acc6df57d5e4a0d48e28c619dd4e3d0ad58cd",
            "patch": "@@ -4,6 +4,31 @@\n   \"dashedName\": \"lecture-understanding-object-oriented-programming-and-encapsulation\",\n   \"blockType\": \"lecture\",\n   \"blockLayout\": \"challenge-list\",\n-  \"challengeOrder\": [{ \"id\": \"68420be9af9d89620af7944a\", \"title\": \"Step 1\" }],\n+  \"challengeOrder\": [\n+    {\n+      \"id\": \"68420be9af9d89620af7944a\",\n+      \"title\": \"What is Object-Oriented Programming, and How Does Encapsulation Work?\"\n+    },\n+    {\n+      \"id\": \"68c128cbd77e4ba9ed671937\",\n+      \"title\": \"What are Getters and Setters\"\n+    },\n+    {\n+      \"id\": \"68c3ba8940e4df8afa83a723\",\n+      \"title\": \"What Is Inheritance and How Does It Promote Code Reuse?\"\n+    },\n+    {\n+      \"id\": \"68c3bc4ddb7b469fb7d17c28\",\n+      \"title\": \"What Is Polymorphism and How Does It Promote Code Reuse?\"\n+    },\n+    {\n+      \"id\": \"68ca71c3f0ee7ece4ea1e286\",\n+      \"title\": \"What is Name Mangling and How Does it Work\"\n+    },\n+    {\n+      \"id\": \"68c3bc80f67363a31791fe1c\",\n+      \"title\": \"What Is Abstraction and How Does It Help Keep Complex Systems Organized?\"\n+    }\n+  ],\n   \"helpCategory\": \"Python\"\n }"
        }
    ],
    "stats": {
        "total": 1547,
        "additions": 1511,
        "deletions": 36
    }
}