{
    "author": "larymak",
    "message": "feat(curriculum): add graphs and trees review page (#62355)",
    "sha": "8eab57a5488561aac7989816aea055605ca283cd",
    "files": [
        {
            "sha": "241db63345ec56c1925a819ef87fdbed11b31adc",
            "filename": "curriculum/challenges/english/blocks/review-graphs-and-trees/67f39e06b8a11b2de9ccd361.md",
            "status": "modified",
            "additions": 123,
            "deletions": 4,
            "changes": 127,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/8eab57a5488561aac7989816aea055605ca283cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Freview-graphs-and-trees%2F67f39e06b8a11b2de9ccd361.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/8eab57a5488561aac7989816aea055605ca283cd/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Freview-graphs-and-trees%2F67f39e06b8a11b2de9ccd361.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2Fblocks%2Freview-graphs-and-trees%2F67f39e06b8a11b2de9ccd361.md?ref=8eab57a5488561aac7989816aea055605ca283cd",
            "patch": "@@ -7,13 +7,132 @@ dashedName: review-graph-and-trees\n \n # --description--\n \n-## First topic\n+## Graphs Overview\n \n-Describe\n+A graph is a set of nodes (vertices) connected by edges (connections). Each node can connect to multiple other nodes, forming a network. The different types of graphs include:\n \n-## Second topic\n+- Directed: edges have a direction (from one node to another), often represented with straight lines and arrows.\n+- Undirected: edges have no direction, represented with simple lines.\n+- Vertex: each node is associated to a label or identifier.\n+- Cyclic: contains cycles (a path that starts and ends at the same node).\n+- Acyclic (DAG): does not contain cycles.\n+- Edge labeled: each edge has a label usually drawn next to corresponding edge.\n+- Weighted: edges have weights (values) associated with them, that can be used to perform arithmetic operations. \n+- Disconnected: contains two or more nodes that are not connected by any edges.\n \n-Describe\n+Graphs are used in various applications such as maps, networks, recommendation systems, dependency resolution.\n+\n+## Graph Traversals\n+\n+This involves visiting all the nodes in a graph. The two main algorithms are:\n+\n+- **Breadth-First Search (BFS)**\n+  - Uses a queue.\n+  - Explores level by level.\n+  - Finds shortest path in unweighted graphs.\n+\n+- **Depth-First Search (DFS)**\n+  - Uses a stack (or recursion).\n+  - Explores a branch fully before backtracking.\n+  - Useful for cycle detection and path finding.\n+\n+## Graph Representations\n+\n+Graphs can be represented in two main ways:\n+\n+- **Adjacency List**\n+  - Each node has a list of its neighbors.\n+  - Space efficient for sparse graphs.\n+  - Easy to iterate over neighbors.\n+\n+- **Adjacency Matrix**\n+  - A 2D array where rows and columns represent nodes.\n+  - Space intensive for large graphs.\n+  - Fast to check if an edge exists between two nodes.\n+\n+## Trees\n+\n+A tree is a special type of graph that is acyclic and connected. Key properties include:\n+\n+- They have no loops or cycles (paths where the start and end nodes are the same).\n+- They must be connected (every node can be reached from every other node).\n+\n+### Common types of trees\n+\n+The most common types of trees are:\n+\n+- Binary Trees\n+  - Each node has at most two children, a left and a right child.\n+\n+- Binary Search Trees (BST)\n+  - A binary tree in which every left child is less than its parent, and every right child is greater than its parent.  \n+\n+\n+## Tries\n+\n+Also known as prefix trees, they are used to store sets of strings, where each node represents a character.\n+\n+Shared prefixes are stored only once, making them efficient for tasks like autocomplete and spell checking.\n+\n+Search and insertion operations have a time complexity of O(L), where L is the length of the string.\n+\n+## Priority Queues\n+\n+A priority queue is an abstract data type where each element has a priority.\n+\n+Queues and stacks consider only the order of insertion, while priority queues consider the priority of elements. \n+\n+Standard queues follow FIFO (First In First Out) and stacks follow LIFO (Last In First Out). However, in a priority queue, elements with higher priority are served before those with lower priority, regardless of their insertion order.\n+\n+## Heaps\n+\n+It's a specialized tree-based data structure with a very specific property called the heap property. \n+\n+The heap property determines the relationship between parent and child nodes. There are two types of heaps:\n+\n+- Max-Heap\n+  - The value of each parent node is greater than or equal to the values of its children.\n+  - The largest element is at the root.\n+\n+- Min-Heap\n+  - The value of each parent node is less than or equal to the values of its children.\n+  - The smallest element is at the root.\n+\n+### Python `heap` module example\n+\n+```py\n+import heapq\n+\n+# Create empty heap\n+my_heap = []\n+\n+# Insert elements\n+heapq.heappush(my_heap, 9)\n+heapq.heappush(my_heap, 3)\n+heapq.heappush(my_heap, 5)\n+\n+# Remove smallest element\n+print(heapq.heappop(my_heap))  # 3\n+\n+# Push + Pop in one step\n+print(heapq.heappushpop(my_heap, 2)) # 2\n+\n+# Transform list into heap\n+nums = [5, 7, 3, 1]\n+heapq.heapify(nums)\n+```\n+\n+### Using Priorities\n+\n+```py\n+my_heap = []\n+heapq.heappush(my_heap, (3, \"A\"))\n+heapq.heappush(my_heap, (2, \"B\"))\n+heapq.heappush(my_heap, (1, \"C\"))\n+\n+# Removes lowest number = highest priority\n+print(heapq.heappop(my_heap))  # (1, \"C\")\n+```\n \n # --assignment--\n "
        }
    ],
    "stats": {
        "total": 127,
        "additions": 123,
        "deletions": 4
    }
}