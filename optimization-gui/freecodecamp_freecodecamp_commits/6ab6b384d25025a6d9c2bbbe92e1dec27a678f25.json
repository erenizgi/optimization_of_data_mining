{
    "author": "moT01",
    "message": "feat(curriculum): add react forms transcripts (#59621)\n\nCo-authored-by: Zaira <33151350+zairahira@users.noreply.github.com>",
    "sha": "6ab6b384d25025a6d9c2bbbe92e1dec27a678f25",
    "files": [
        {
            "sha": "bedf72abd2f59bc30513243b8e0d6fb16c56c69b",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-forms-in-react/67d1a928ae86929a85c1bb6b.md",
            "status": "modified",
            "additions": 100,
            "deletions": 2,
            "changes": 102,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6ab6b384d25025a6d9c2bbbe92e1dec27a678f25/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-forms-in-react%2F67d1a928ae86929a85c1bb6b.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6ab6b384d25025a6d9c2bbbe92e1dec27a678f25/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-forms-in-react%2F67d1a928ae86929a85c1bb6b.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-forms-in-react%2F67d1a928ae86929a85c1bb6b.md?ref=6ab6b384d25025a6d9c2bbbe92e1dec27a678f25",
            "patch": "@@ -2,13 +2,111 @@\n id: 67d1a928ae86929a85c1bb6b\n title: How Do Forms Work in React?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: t9ax7VY00m0\n dashedName: how-do-forms-work-in-react\n ---\n \n # --description--\n \n-Watch the video lecture and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+How do forms work in React?\n+\n+Forms are fundamental to every web application because they let you handle user input, collect data, and trigger actions.\n+\n+In React, forms are managed using state or refs, giving you full control over their behavior and validation. These two ways to manage forms are called \"controlled\"  and \"uncontrolled\" input.\n+\n+Let's look at what controlled and uncontrolled inputs are.\n+\n+Controlled input is the most \"React-like\" way to handle form inputs. With controlled inputs, you store the input field value in state and update it through `onChange` events. This gives you complete control over the form data and allows instant validation and conditional rendering.\n+\n+The process works like this: React maintains the form state with the `useState` hook, and you update it on every change. When a user types in an input field, the `onChange` event fires, updates the state, and React re-renders the component with the new value.\n+\n+```js\n+import { useState } from \"react\";\n+\n+function App() {\n+  const [name, setName] = useState(\"\");\n+\n+  const handleChange = (e) => {\n+    setName(e.target.value);\n+  };\n+\n+  const handleSubmit = (e) => {\n+    e.preventDefault();\n+    console.log(name);\n+  };\n+\n+  return (\n+    <>\n+      <form onSubmit={handleSubmit}>\n+        <label htmlFor=\"name\">Your name</label> <br />\n+        <input value={name} id=\"name\" onChange={handleChange} type=\"text\" />\n+        <button type=\"submit\">Submit</button>\n+      </form> \n+    </>\n+  );\n+}\n+\n+export default App;\n+```\n+\n+The benefits of controlled inputs include the following:\n+\n+- Immediate access to the form data.\n+\n+- You can implement instant validation.\n+\n+- You can conditionally disable the submit button.\n+\n+- You can control the input value programmatically.\n+\n+Uncontrolled inputs on the other hand are seen more in traditional HTML forms. So, instead of handling the inputs through the `useState` hook, uncontrolled inputs in HTML maintain their own internal state with the help of the DOM.\n+\n+Since the DOM controls the input values, what you need is to pull in the values of the input fields with ref. This approach requires less code and performs better because refs do not make React re-render.\n+\n+Here's an example of uncontrolled inputs:\n+\n+```js\n+import { useRef } from \"react\";\n+\n+function App() {\n+ const nameRef = useRef();\n+\n+ const handleSubmit = (e) => {\n+   e.preventDefault();\n+   console.log(nameRef.current.value);\n+ };\n+\n+ return (\n+   <form onSubmit={handleSubmit}>\n+     <label htmlFor=\"name\">Your</label>{\" \"}\n+     <input type=\"text\" ref={nameRef} id=\"name\" />\n+     <button type=\"submit\">Submit</button>\n+   </form>\n+ );\n+}\n+\n+export default App;\n+```\n+\n+One very noticeable advantage of uncontrolled inputs is that they require less code. They also perform better and feel more natural to React beginners who are familiar with HTML.\n+\n+So, which should you use between controlled and uncontrolled inputs? \n+\n+Use controlled inputs when you need dynamic form updates, real-time validation, or when you want to sync input values with state. They provide better control but require more re-renders.\n+\n+Use uncontrolled inputs when you need simpler forms, want to access values only on submission, or when you're working with non-React code.\n+\n+Regardless of which you use between controlled and uncontrolled inputs, here are some best practices you should adhere to while making forms in React:\n+\n+- Always prevent the default form submission.\n+\n+- Ensure you validate inputs before submission.\n+\n+- Always provide clear feedback to users with loading, validation errors or other related states.\n \n # --questions--\n "
        },
        {
            "sha": "71bb674daa8235000a791f172038a7fc402a8844",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-working-with-forms-in-react/67e2a4cab99d4e8bc795e99d.md",
            "status": "modified",
            "additions": 253,
            "deletions": 2,
            "changes": 255,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/6ab6b384d25025a6d9c2bbbe92e1dec27a678f25/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-forms-in-react%2F67e2a4cab99d4e8bc795e99d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/6ab6b384d25025a6d9c2bbbe92e1dec27a678f25/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-forms-in-react%2F67e2a4cab99d4e8bc795e99d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-working-with-forms-in-react%2F67e2a4cab99d4e8bc795e99d.md?ref=6ab6b384d25025a6d9c2bbbe92e1dec27a678f25",
            "patch": "@@ -2,13 +2,264 @@\n id: 67e2a4cab99d4e8bc795e99d\n title: What Is the useActionState Hook, and How Does It Work?\n challengeType: 11\n-videoId: nVAaxZ34khk\n+videoId: GARlXz-vIFg\n dashedName: what-is-the-useactionstate-hook-and-how-does-it-work\n ---\n \n # --description--\n \n-Watch the lecture video and answer the questions below.\n+Watch the video or read the transcript and answer the questions below.\n+\n+# --transcript--\n+\n+What is the `useActionState` hook and how does it work?\n+\n+React 19 came with two notable new features called server components and server actions. \n+\n+From that version onwards, server components became the default in frameworks like Next.js that readily support them.\n+\n+Server actions on the other hand, are functions that run on the server to allow form handling right on the server without the need for API endpoints.\n+\n+A server action looks like this: \n+\n+```js\n+\"use server\";\n+\n+async function submitForm(formData) {\n+ const name = formData.get(\"name\");\n+ return { message: `Hello, ${name}!` };\n+}\n+```\n+\n+This server action extracts a `name` field from a form and returns a string greeting that name.\n+\n+To simplify state management for server actions and remove the need for client-side JavaScript for simple forms, the React team introduced the `useActionState` hook in version 19.\n+\n+Let's take a closer look at this hook and see how it works.\n+\n+The React documentation describes the `useActionState` hook as a hook that \"allows you to update state based on the result of a form action.\"\n+\n+But this doesn't mean that you can only use the `useActionState` hook with forms. You can also use it to manage button clicks and other events, as long as you have an action in place.\n+\n+And keep in mind that, since `useActionState` is a hook, you cannot use it inside a server component.\n+\n+Here's the basic syntax of the `useActionState` hook:\n+\n+```js\n+const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);\n+```\n+\n+- `state` is the current state the action returns.\n+\n+- `action` is the function that triggers the server action.\n+\n+- `isPending` is a boolean that indicates whether the action is currently running or not.\n+\n+- The `actionFunction` parameter is the server action itself.\n+\n+- `initialState` is the parameter that represents the starting point for the state before the action runs.\n+\n+- `permalink` is an optional string that contains the unique page URL the form modifies.\n+\n+To use the `useActionState` hook, make sure you have an action in place first. Let's use the action from the previous example for this, with a bit of a twist:\n+\n+```js\n+\"use server\";\n+\n+export async function submitForm(_, formData) {\n+ const name = formData.get(\"name\");\n+\n+ const hour = new Date().getHours();\n+ let greeting;\n+\n+ if (hour < 12) {\n+   greeting = \"Good morning\";\n+ } else if (hour < 18) {\n+   greeting = \"Good afternoon\";\n+ } else {\n+   greeting = \"Good evening\";\n+ }\n+\n+ return { message: `${greeting}, ${name}` };\n+}\n+```\n+\n+In your component, you then need to import the `useActionState` hook and call it at the top level of the component body (before the return statement) just like other hooks. You should also import the action:\n+\n+```js\n+\"use client\";\n+\n+// Import the useActionState hook\n+import { useActionState } from \"react\";\n+\n+// Import the submitForm action\n+import { submitForm } from \"./actions/submitForm\";\n+\n+const Greeter = () => {\n+\n+ // Initialize the hook\n+ const [state, submit, isPending] = useActionState(submitForm, {\n+   message: \"\",\n+ });\n+\n+ return (\n+   <div className=\"flex flex-col items-center justify-center min-h-screen bg-gray-100 p-6\">\n+  {/* Rest of component */}\n+   </div>\n+ );\n+};\n+\n+export default Greeter;\n+```\n+\n+Here's what the full code looks like with a bit of styling:\n+\n+```js\n+\"use client\";\n+\n+import { useActionState } from \"react\";\n+import { submitForm } from \"./actions/submitForm\";\n+\n+const Greeter = () => {\n+ const [state, submit, isPending] = useActionState(submitForm, {\n+   message: \"\",\n+ });\n+\n+ return (\n+   <div className=\"flex flex-col items-center justify-center min-h-screen bg-gray-100 p-6\">\n+     <form\n+       action={submit}\n+       className=\"bg-white p-6 rounded-2xl shadow-md w-full max-w-md\"\n+     >\n+       <h2 className=\"text-2xl text-center font-semibold text-gray-700 mb-4\">\n+         Greet Someone\n+       </h2>\n+\n+       <input\n+         type=\"text\"\n+         name=\"name\"\n+         placeholder=\"Enter your name\"\n+         required\n+         className=\"w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-400\"\n+       />\n+\n+       <button\n+         type=\"submit\"\n+         disabled={isPending}\n+         className=\"w-full mt-4 p-3 bg-green-500 text-white font-semibold rounded-lg hover:bg-green-600 disabled:bg-gray-400 transition-all\"\n+       >\n+         {isPending ? \"Greeting...\" : \"Greet\"}\n+       </button>\n+\n+       {state.message && (\n+         <p className=\"mt-4 text-green-600 text-center font-medium\">\n+           {state.message}\n+         </p>\n+       )}\n+     </form>\n+   </div>\n+ );\n+};\n+\n+export default Greeter;\n+```\n+\n+In the browser, you would see your form button change from `Greet` to `Greeting...` while the action `isPending` - and the greeting would show `Good morning, {name}`, `Good afternoon, {name}`, or `Good evening, {name}`, depending on what time of day the form was submitted.\n+\n+Remember how we mentioned that you can also use the `useActionState` hook outside of a form?\n+\n+In this example, we'll fetch five users from JSONPlaceholder with a button click:\n+\n+```js\n+\"use server\";\n+\n+export async function getUsers() {\n+ const res = await fetch(\n+   \"https://jsonplaceholder.typicode.com/users?_start=0&_limit=5/\"\n+ );\n+ return await res.json();\n+}\n+```\n+\n+Here's the styled UI:\n+\n+```js\n+\"use client\";\n+\n+import { useActionState } from \"react\";\n+import { getUsers } from \"./actions/getUsers\";\n+\n+export default function FetchUsers() {\n+ const [users, fetchAction, isPending] = useActionState(getUsers, []);\n+\n+ return (\n+   <div className=\"p-6 max-w-lg mx-auto\">\n+     <button\n+       onClick={fetchAction}\n+       disabled={isPending}\n+       className=\"px-4 py-2 cursor-pointer bg-green-500 text-white rounded-lg hover:bg-green-600 disabled:bg-gray-400 font-bold\"\n+     >\n+       {isPending ? \"Fetching Users...\" : \"Fetch Users\"}\n+     </button>\n+\n+     <ul className=\"mt-4 space-y-2\">\n+       {users.map((user) => (\n+         <li key={user.id} className=\"p-3 bg-gray-100 rounded-lg\">\n+           <p className=\"font-semibold\">{user.name}</p>\n+           <p className=\"text-sm text-gray-600\">{user.email}</p>\n+         </li>\n+       ))}\n+     </ul>\n+   </div>\n+ );\n+}\n+```\n+\n+In the browser, you would see that the button text is never updated to `Fetching Users...` after it's clicked.\n+\n+This happens because React treats data fetching and rendering as a higher priority than the `isPending` state, which blocks `isPending` in the process and throws an error.\n+\n+To fix this issue, you need to wrap the action in `startTransition`:\n+\n+```js\n+\"use client\";\n+\n+import { useActionState } from \"react\";\n+import { getUsers } from \"./actions/getUsers\";\n+\n+// import startTransition from React\n+import { startTransition } from \"react\";\n+\n+export default function FetchUsers() {\n+ const [users, fetchAction, isPending] = useActionState(getUsers, []);\n+\n+ return (\n+   <div className=\"p-6 max-w-lg mx-auto\">\n+     <button\n+       {/* wrap fetchAction in startTransition */}\n+       onClick={() => startTransition(() => fetchAction())}\n+       disabled={isPending}\n+       className=\"px-4 py-2 bg-green-500 font-bold cursor-pointer text-white rounded-lg hover:bg-green-600 disabled:bg-gray-400\"\n+     >\n+       {isPending ? 'Fetching Users...' : 'Fetch Users'}\n+     </button>\n+\n+     <ul className=\"mt-4 space-y-2\">\n+       {users.map((user) => (\n+         <li key={user.id} className=\"p-3 bg-gray-100 rounded-lg\">\n+           <p className=\"font-semibold\">{user.name}</p>\n+           <p className=\"text-sm text-gray-600\">{user.email}</p>\n+         </li>\n+       ))}\n+     </ul>\n+   </div>\n+ );\n+}\n+```\n+\n+If you're wondering what `startTransition` is, it's a function that tells React that a state update is of low-priority and can be interrupted. This keeps the UI responsive while handling asynchronous updates like server actions.\n+\n+That's how to use the `useActionState` hook inside and outside a form.\n \n # --questions--\n "
        }
    ],
    "stats": {
        "total": 357,
        "additions": 353,
        "deletions": 4
    }
}