{
    "author": "majestic-owl448",
    "message": "feat: add lectures for searching and sorting algorithms (#61663)\n\nCo-authored-by: Dario <105294544+Dario-DC@users.noreply.github.com>\nCo-authored-by: Sem Bauke <sem@freecodecamp.org>\nCo-authored-by: Kolade Chris <65571316+Ksound22@users.noreply.github.com>",
    "sha": "2a577ade98d2f3493cd6a6efe06053eda78967ce",
    "files": [
        {
            "sha": "dca34f9b20f7dee3d900f2c207878fbfc0549b5b",
            "filename": "client/i18n/locales/english/intro.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/2a577ade98d2f3493cd6a6efe06053eda78967ce/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/2a577ade98d2f3493cd6a6efe06053eda78967ce/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json?ref=2a577ade98d2f3493cd6a6efe06053eda78967ce",
            "patch": "@@ -4417,7 +4417,8 @@\n       \"lecture-searching-and-sorting-algorithms\": {\n         \"title\": \"Searching and Sorting Algorithms\",\n         \"intro\": [\n-          \"Learn about Searching and Sorting Algorithms in these lectures.\"\n+          \"Learn about fundamental searching and sorting algorithms, including linear search, binary search, and merge sort.\",\n+          \"These lectures cover algorithm implementations, time and space complexity analysis, and the divide and conquer programming paradigm.\"\n         ]\n       },\n       \"workshop-binary-search\": {"
        },
        {
            "sha": "22d58fb393d8961047fbeb42c86dcdf0391f9d27",
            "filename": "client/src/pages/learn/full-stack-developer/lecture-searching-and-sorting-algorithms/index.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/2a577ade98d2f3493cd6a6efe06053eda78967ce/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-searching-and-sorting-algorithms%2Findex.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/2a577ade98d2f3493cd6a6efe06053eda78967ce/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-searching-and-sorting-algorithms%2Findex.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fsrc%2Fpages%2Flearn%2Ffull-stack-developer%2Flecture-searching-and-sorting-algorithms%2Findex.md?ref=2a577ade98d2f3493cd6a6efe06053eda78967ce",
            "patch": "@@ -6,4 +6,4 @@ superBlock: full-stack-developer\n \n ## Introduction to Searching and Sorting Algorithms\n \n-Learn about Searching and Sorting Algorithms in these lectures.\n+Learn about fundamental searching and sorting algorithms, including linear search, binary search, and merge sort. These lectures cover algorithm implementations, time and space complexity analysis, and the divide and conquer programming paradigm."
        },
        {
            "sha": "2ef8fa72669084dffbfffe65359e606ef50570f9",
            "filename": "curriculum/challenges/_meta/lecture-searching-and-sorting-algorithms/meta.json",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/2a577ade98d2f3493cd6a6efe06053eda78967ce/curriculum%2Fchallenges%2F_meta%2Flecture-searching-and-sorting-algorithms%2Fmeta.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/2a577ade98d2f3493cd6a6efe06053eda78967ce/curriculum%2Fchallenges%2F_meta%2Flecture-searching-and-sorting-algorithms%2Fmeta.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2F_meta%2Flecture-searching-and-sorting-algorithms%2Fmeta.json?ref=2a577ade98d2f3493cd6a6efe06053eda78967ce",
            "patch": "@@ -5,6 +5,15 @@\n   \"blockType\": \"lecture\",\n   \"blockLayout\": \"challenge-list\",\n   \"superBlock\": \"full-stack-developer\",\n-  \"challengeOrder\": [{ \"id\": \"68420c70e4bfe26d52b780dc\", \"title\": \"Step 1\" }],\n+  \"challengeOrder\": [\n+    {\n+      \"id\": \"68420c70e4bfe26d52b780dc\",\n+      \"title\": \"What Is Binary Search and How Does It Differ From Linear Search?\"\n+    },\n+    {\n+      \"id\": \"68910fc037a90c285107af04\",\n+      \"title\": \"What Is Divide and Conquer, and How Does Merge Sort Work?\"\n+    }\n+  ],\n   \"helpCategory\": \"Python\"\n }"
        },
        {
            "sha": "f40a9d083cb2e5b4ec23fea7a0955fb693d4ecd5",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-searching-and-sorting-algorithms/68420c70e4bfe26d52b780dc.md",
            "status": "modified",
            "additions": 98,
            "deletions": 44,
            "changes": 142,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/2a577ade98d2f3493cd6a6efe06053eda78967ce/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-searching-and-sorting-algorithms%2F68420c70e4bfe26d52b780dc.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/2a577ade98d2f3493cd6a6efe06053eda78967ce/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-searching-and-sorting-algorithms%2F68420c70e4bfe26d52b780dc.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-searching-and-sorting-algorithms%2F68420c70e4bfe26d52b780dc.md?ref=2a577ade98d2f3493cd6a6efe06053eda78967ce",
            "patch": "@@ -1,135 +1,189 @@\n ---\n id: 68420c70e4bfe26d52b780dc\n-# title needs to be updated to correct title when lectures are finalized\n-title: Searching and Sorting Algorithms\n+title: What Is Binary Search and How Does It Differ From Linear Search?\n challengeType: 19\n-# dashedName needs to be updated to correct title when lectures are finalized\n-dashedName: lecture-searching-and-sorting-algorithms\n+dashedName: what-is-binary-search-and-how-does-it-differ-from-linear-search\n ---\n \n # --description--\n \n-Watch the video or read the transcript and answer the questions below.\n+Searching through a list of items is a common occurrence in computer science. There are two key algorithms you should know about when it comes to searching: linear search and binary search.\n+\n+Linear search starts at the beginning of a list and iterates through each item until it finds the target value it is looking for.\n+\n+If the target value is found, the index where it's located in the list is returned. If the target value isn't found, `-1` is returned. We return `-1` because it's not a valid index in most programming languages.\n+\n+Here is what the code looks like for linear search:\n+\n+```python\n+def linear_search(arr, target):\n+    for i in range(len(arr)):\n+        if arr[i] == target:\n+            return i\n+    return -1\n+```\n+\n+If the list we'll search through is `[13, 4, 7, 9, 10]` and the target value is `9`, the function would return `3` because `9` is at index `3`.\n+\n+If we changed the target value to `5`, the function would return `-1` because `5` is not in the list.\n+\n+While this is a relatively straightforward algorithm, it is not the most efficient. If you have a large list of items, linear search can take a long time to find the target value.\n+\n+The time complexity of linear search is `O(n)` because the time it takes to search through the list grows linearly with the size of the list.\n+\n+The space complexity of linear search is `O(1)` because it doesn't require any additional space to search through the list.\n+\n+Binary search is a more efficient algorithm for searching through a large list of items. The condition here is that the list must be sorted in ascending order.\n+\n+Binary search works by dividing the list in half and checking if the target value is in the middle of the list. If the target value is in the middle of the list, the index of the target value is returned. Otherwise, the algorithm checks if the target value is in the left or right half of the list.\n+\n+It continues to divide the remaining parts of the list into halves until the target value is found. If the target value is not in the list, it returns `-1`\n+\n+Here is what the code looks like for binary search:\n+\n+```python\n+def binary_search(arr, target):\n+    low = 0\n+    high = len(arr) - 1\n+\n+    while low <= high:\n+        mid = (low + high) // 2  \n+\n+        if arr[mid] == target:\n+            return mid\n+        elif arr[mid] < target:\n+            low = mid + 1\n+        else:\n+            high = mid - 1\n+\n+    return -1\n+```\n+\n+We start by identifying a `low` and `high` index. This represents the range of the list we are searching through.\n+\n+We then check the condition of `low` being less than or equal to `high`. If `low` is greater than `high`, we have searched through the entire list and the target value is not found. In that case we stop the search and return `-1`.\n+\n+If the `low` index is less than or equal to the `high` index, we calculate the middle index of the list, `mid`. We then check if the target value is at the middle index. If it is, we return the middle index.\n+\n+Otherwise, we check if the value at the midpoint is less than the target. If it is, we update the low index to be the middle index plus one. This means we will search the right half of the list.\n+\n+Lastly, if none of the other conditions are `True`, we update the `high` index to be the middle index minus one. This means we will search the left half of the list.\n+\n+We continue to repeat this process until we find the target or determine that the target is not in the list.\n+\n+The time complexity of binary search is `O(log n)` because the time it takes to search through the list grows logarithmically with the size of the list.\n+\n+The space complexity of binary search is `O(1)` because it doesn't require any additional space to search through the list.\n+\n+Binary search and linear search can be used for a variety of problems you will encounter in computer science. It is important to understand the differences between the two algorithms and when to use each one.\n \n # --questions--\n \n ## --text--\n \n-Question 1\n+What is the main difference between linear search and binary search?\n \n ## --answers--\n \n-Answer 1.1\n+Linear search is faster than binary search.\n \n ### --feedback--\n \n-Feedback 1\n+Consider the requirements and efficiency of each algorithm.\n \n ---\n \n-Answer 1.2\n-\n-### --feedback--\n-\n-Feedback 1\n+Binary search requires a sorted list, while linear search does not.\n \n ---\n \n-Answer 1.3\n+Linear search can only be used with numbers.\n \n ### --feedback--\n \n-Feedback 1\n+Consider the requirements and efficiency of each algorithm.\n \n ---\n \n-Answer 1.4\n+Binary search always returns the first occurrence of a target.\n \n ### --feedback--\n \n-Feedback 1\n+Consider the requirements and efficiency of each algorithm.\n \n ## --video-solution--\n \n-5\n+2\n \n ## --text--\n \n-Question 2\n+What is the time complexity of linear search?\n \n ## --answers--\n \n-Answer 2.1\n+`O(1)`\n \n ### --feedback--\n \n-Feedback 2\n+Think about how the time to complete the search changes with the size of the list.\n \n ---\n \n-Answer 2.2\n+`O(log n)`\n \n ### --feedback--\n \n-Feedback 2\n+Think about how the time to complete the search changes with the size of the list.\n \n ---\n \n-Answer 2.3\n-\n-### --feedback--\n-\n-Feedback 2\n+`O(n)`\n \n ---\n \n-Answer 2.4\n+`O(n²)`\n \n ### --feedback--\n \n-Feedback 2\n+Think about how the time to complete the search changes with the size of the list.\n \n ## --video-solution--\n \n-5\n+3\n \n ## --text--\n \n-Question 3\n+In binary search, what happens if the target value is not found in the list?\n \n ## --answers--\n \n-Answer 3.1\n+It returns the middle index.\n \n ### --feedback--\n \n-Feedback 3\n+Reflect on what the function is designed to do when the target is absent.\n \n ---\n \n-Answer 3.2\n-\n-### --feedback--\n-\n-Feedback 3\n+It returns `-1`.\n \n ---\n \n-Answer 3.3\n+It returns the last index checked.\n \n ### --feedback--\n \n-Feedback 3\n+Reflect on what the function is designed to do when the target is absent.\n \n ---\n \n-Answer 3.4\n+It enters an infinite loop.\n \n ### --feedback--\n \n-Feedback 3\n+Reflect on what the function is designed to do when the target is absent.\n \n ## --video-solution--\n \n-5\n+2\n "
        },
        {
            "sha": "1eca91f112e5b974caba23c9a3d2eed69c442827",
            "filename": "curriculum/challenges/english/25-front-end-development/lecture-searching-and-sorting-algorithms/68910fc037a90c285107af04.md",
            "status": "added",
            "additions": 200,
            "deletions": 0,
            "changes": 200,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/2a577ade98d2f3493cd6a6efe06053eda78967ce/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-searching-and-sorting-algorithms%2F68910fc037a90c285107af04.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/2a577ade98d2f3493cd6a6efe06053eda78967ce/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-searching-and-sorting-algorithms%2F68910fc037a90c285107af04.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Flecture-searching-and-sorting-algorithms%2F68910fc037a90c285107af04.md?ref=2a577ade98d2f3493cd6a6efe06053eda78967ce",
            "patch": "@@ -0,0 +1,200 @@\n+---\n+id: 68910fc037a90c285107af04\n+title: What Is Divide and Conquer, and How Does Merge Sort Work?\n+challengeType: 19\n+dashedName: what-is-divide-and-conquer-and-how-does-merge-sort-work\n+---\n+\n+# --description--\n+\n+The divide and conquer paradigm in computer science is a technique for recursively breaking down problems into smaller sub problems. One of the key aspects of this technique is recursion, which happens when a function calls itself repeatedly until a base case is reached. In this lecture, we will take a look at the merge sort algorithm to better understand how the divide and conquer technique works.\n+\n+Let's say we had this list of numbers:\n+\n+```md\n+42 37 53 17\n+```\n+\n+The goal is to sort that list from smallest to largest using the merge sort algorithm. The first step is to divide that list in half:\n+\n+```md\n+42 37 | 53 17\n+```\n+\n+Then we need to look at the left side of the list:\n+\n+```md\n+42 37\n+```\n+\n+We take that sub list and divide in half again until each sub list has only one item in it:\n+\n+```md\n+42 | 37\n+```\n+\n+A list with only one item in it is sorted by default. Next we need to merge each of those one element sub lists into a sorted list:\n+\n+```md\n+37 42\n+```\n+\n+Then we follow the same process for the right side of the original list:\n+\n+```py\n+# right side of original list\n+53 17\n+\n+# divide the list in half\n+53 | 17\n+\n+# merge the lists in sorted order\n+17 53\n+```\n+\n+Now that both halves of the original list are sorted, we merge those two halves together and sort the elements:\n+\n+```markdown\n+17 37 42 53\n+```\n+\n+Here is what the algorithm looks like in code:\n+\n+```py\n+def merge_sort(arr):\n+    if len(arr) <= 1:\n+        return arr\n+\n+    mid = len(arr) // 2\n+    left = merge_sort(arr[:mid])\n+    right = merge_sort(arr[mid:])\n+\n+    sorted_list = []\n+    i = 0\n+    j = 0\n+\n+    while i < len(left) and j < len(right):\n+        if left[i] <= right[j]:\n+            sorted_list.append(left[i])\n+            i += 1\n+        else:\n+            sorted_list.append(right[j])\n+            j += 1\n+\n+    sorted_list.extend(left[i:])\n+    sorted_list.extend(right[j:])\n+\n+    return sorted_list\n+```\n+\n+The time complexity for merge sort would be `O(n log n)` because the list is continuously divided in half (`log n`) and then merged together (`O(n)`). Unlike other sorting algorithms like bubble sort, merge sort is not sorted in place and has a space complexity of `O(n)`.\n+\n+# --questions--\n+\n+## --text--\n+\n+What is the divide and conquer paradigm in computer science?\n+\n+## --answers--\n+\n+A technique for detecting a cycle in function value iterations using just two iterators.\n+\n+### --feedback--\n+\n+Review the beginning of the lecture.\n+\n+---\n+\n+An algorithm for comparing two elements and swapping them from smallest to largest if needed.\n+\n+### --feedback--\n+\n+Review the beginning of the lecture.\n+\n+---\n+\n+A technique for recursively breaking down problems into smaller sub problems.\n+\n+---\n+\n+An algorithm to compute the shortest connecting network for points in a plane.\n+\n+### --feedback--\n+\n+Review the beginning of the lecture.\n+\n+## --video-solution--\n+\n+3\n+\n+## --text--\n+\n+What is the time complexity for the merge sort algorithm?\n+\n+## --answers--\n+\n+`O(n log n)`\n+\n+---\n+\n+`O(log n²)`\n+\n+### --feedback--\n+\n+Review the end of the lecture.\n+\n+---\n+\n+`O(n³ log n)`\n+\n+### --feedback--\n+\n+Review the end of the lecture.\n+\n+---\n+\n+`O(log n³)`\n+\n+### --feedback--\n+\n+Review the end of the lecture.\n+\n+## --video-solution--\n+\n+1\n+\n+## --text--\n+\n+What is the space complexity for the merge sort algorithm?\n+\n+## --answers--\n+\n+`O(n²)`\n+\n+### --feedback--\n+\n+Review the end of the lecture.\n+\n+---\n+\n+`O(1)`\n+\n+### --feedback--\n+\n+Review the end of the lecture.\n+\n+---\n+\n+`O(n log n)`\n+\n+### --feedback--\n+\n+Review the end of the lecture.\n+\n+---\n+\n+`O(n)`\n+\n+## --video-solution--\n+\n+4"
        }
    ],
    "stats": {
        "total": 358,
        "additions": 311,
        "deletions": 47
    }
}