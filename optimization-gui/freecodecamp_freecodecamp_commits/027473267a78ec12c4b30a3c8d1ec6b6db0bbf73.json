{
    "author": "zairahira",
    "message": "feat(curriculum): adding content for async JS review page (#57311)\n\nCo-authored-by: Jessica Wilkins <67210629+jdwilkin4@users.noreply.github.com>",
    "sha": "027473267a78ec12c4b30a3c8d1ec6b6db0bbf73",
    "files": [
        {
            "sha": "4fb8f94ecf603070683526d335ca6613790c0b5d",
            "filename": "client/i18n/locales/english/intro.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/027473267a78ec12c4b30a3c8d1ec6b6db0bbf73/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/027473267a78ec12c4b30a3c8d1ec6b6db0bbf73/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/client%2Fi18n%2Flocales%2Fenglish%2Fintro.json?ref=027473267a78ec12c4b30a3c8d1ec6b6db0bbf73",
            "patch": "@@ -3262,7 +3262,7 @@\n       \"review-asynchronous-javascript\": {\n         \"title\": \"Asynchronous JavaScript Review\",\n         \"intro\": [\n-          \"Review the Asynchronous JavaScript concepts to prepare for the upcoming quiz.\"\n+          \"Review Asynchronous JavaScript concepts to prepare for the upcoming quiz.\"\n         ]\n       },\n       \"quiz-asynchronous-javascript\": {"
        },
        {
            "sha": "a1312ab982ce0656111eb25537b8f68fba460576",
            "filename": "curriculum/challenges/english/25-front-end-development/review-asynchronous-javascript/6723d35bb07d1bd220d0f28d.md",
            "status": "modified",
            "additions": 209,
            "deletions": 0,
            "changes": 209,
            "blob_url": "https://github.com/freeCodeCamp/freeCodeCamp/blob/027473267a78ec12c4b30a3c8d1ec6b6db0bbf73/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Freview-asynchronous-javascript%2F6723d35bb07d1bd220d0f28d.md",
            "raw_url": "https://github.com/freeCodeCamp/freeCodeCamp/raw/027473267a78ec12c4b30a3c8d1ec6b6db0bbf73/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Freview-asynchronous-javascript%2F6723d35bb07d1bd220d0f28d.md",
            "contents_url": "https://api.github.com/repos/freeCodeCamp/freeCodeCamp/contents/curriculum%2Fchallenges%2Fenglish%2F25-front-end-development%2Freview-asynchronous-javascript%2F6723d35bb07d1bd220d0f28d.md?ref=027473267a78ec12c4b30a3c8d1ec6b6db0bbf73",
            "patch": "@@ -9,7 +9,216 @@ dashedName: review-asynchronous-javascript\n \n Review the concepts below to prepare for the upcoming quiz.\n \n+- **Synchronous JavaScript** is executed sequentially and waits for the previous operation to finish before moving on to the next one.\n+- **Asynchronous JavaScript** allows multiple operations to be executed in the background without blocking the main thread.\n+- **Thread** is a sequence of instructions that can be executed independently of the main program flow.\n+- **Callback functions** are functions that are passed as arguments to other functions and are executed after the completion of the operation or as a result of an event.\n \n+## The JavaScript engine and JavaScript runtime\n+\n+- The **JavaScript engine** is a program that executes JavaScript code in a web browser. It works like a converter that takes your code, turns it into instructions that the computer can understand and work accordingly. \n+- V8 is an example of a JavaScript engine developed by Google.\n+- The **JavaScript runtime** is the environment in which JavaScript code is executed. It includes the JavaScript engine which processes and executes the code, and additional features like a web browser or Node.js.\n+\n+## The fetch API\n+\n+- The `fetch` API allows web apps to make network requests, typically to retrieve or send data to the server. It provides a `fetch()` method that you can use to make these requests.\n+- You can retrieve text, images, audio, JSON, and other types of data using the `fetch` API.\n+\n+## HTTP methods for fetch API\n+\n+The `fetch` API supports various HTTP methods to interact with the server. The most common methods are:\n+\n+- **GET**: Used to retrieve data from the server. By default, the `fetch` API uses the `GET` method to retrieve data.\n+\n+```js\n+fetch('https://api.example.com/data')\n+```\n+\n+To use the fetched data, it must be converted to JSON format using the `.json()` method:\n+\n+```js\n+fetch('https://api.example.com/data')\n+  .then(response => response.json())\n+  .then(data => console.log(data))\n+```\n+\n+In this code, the response coming from the fetch API is a promise and the `.then` handler is converting the response to a JSON format.\n+\n+- **POST**: Used to send data to the server. The `POST` method is used to create new resources on the server.\n+\n+```js\n+fetch('https://api.example.com/users', {\n+  method: 'POST',\n+  headers: {\n+    'Content-Type': 'application/json',\n+  },\n+  body: JSON.stringify({\n+    name: 'John Doe',\n+    email: 'john@example.com'\n+  })\n+})\n+```\n+\n+In this example, we're sending a `POST` request to create a new user. We have specified the method as `POST`, set the appropriate headers, and included a body with the data we want to send. The body needs to be a string, so we use `JSON.stringify()` to convert our object to a JSON string.\n+\n+- **PUT**: Used to update data on the server. The `PUT` method is used to update existing resources on the server.\n+\n+```js\n+fetch('https://api.example.com/users/45', {\n+  method: 'PUT',\n+  headers: {\n+    'Content-Type': 'application/json',\n+  },\n+  body: JSON.stringify({\n+    name: 'John Smith',\n+    email: 'john@example.com'\n+  })\n+})\n+```\n+\n+In this example, we are updating the ID `45` that is specified at the end of the URL. We have used the `PUT` method on the code and also specified the data as the body which will be used to update the identified data. \n+\n+- **DELETE**: Used to delete data on the server. The `DELETE` method is used to delete resources on the server.\n+\n+```js\n+fetch('https://api.example.com/users/45', {\n+  method: 'DELETE'\n+})\n+```\n+\n+In this example, we're sending a `DELETE` request to remove a user with the ID `45`.\n+\n+## Promise and promise chaining\n+\n+- **Promises** are objects that represent the eventual completion or failure of an asynchronous operation and its resulting value. The value of the promise is known only when the `async` operation is completed.\n+- Here is an example to create a simple promise:\n+    \n+```js\n+const promise = new Promise((resolve, reject) => {\n+  setTimeout(() => {\n+    resolve('Data received successfully');\n+  }, 2000);\n+});\n+```\n+\n+- The `.then()` method is used in a Promise to specify what should happen when the Promise is fulfilled, while `.catch()` is used to handle any errors that occur.\n+- Here is an example of using `.then()` and `.catch()` with a Promise:\n+\n+```js\n+promise\n+  .then(data => {\n+    console.log(data);\n+  })\n+  .catch(error => {\n+    console.error(error);\n+  });\n+```\n+\n+In the above example, the `.then()` method is used to log the data received from the Promise, while the `.catch()` method is used to log any errors that occur.\n+\n+- **Promise chaining**: One of the powerful features of Promises is that we can chain multiple asynchronous operations together. Each `.then()` can return a new Promise, allowing you to perform a sequence of asynchronous operations one after the other.\n+- Here is an example of Promise chaining:\n+\n+```js\n+fetch('https://api.example.com/data')\n+  .then(response => response.json())\n+  .then(data => {\n+    console.log(data);\n+    return fetch('https://api.example.com/other-data');\n+  })\n+  .then(response => response.json())\n+  .then(otherData => {\n+    console.log(otherData);\n+  })\n+  .catch(error => {\n+    console.error(error);\n+  });\n+```\n+\n+In the above example, we first fetch data from one URL, then fetch data from another URL based on the first response, and finally log the second data received. \n+\n+The `catch` method would handle any errors that occur during the process. This means you don't need to add error handling to each individual step, which can greatly simplify your code.\n+\n+## Using `async/await` to handle promises\n+\n+Async/await makes writing & reading asynchronous code easier which is built on top of Promises.\n+\n+- **async**: The `async` keyword is used to define an asynchronous function. An `async` function returns a Promise, which resolves with the value returned by the `async` function.\n+- **await**: The `await` keyword is used inside an `async` function to pause the execution of the function until the Promise is resolved. It can only be used inside an `async` function.\n+- Here is an example of using `async/await`:\n+\n+```js\n+async function delayedGreeting(name) {\n+  console.log(\"A Messenger entered the chat...\");\n+  await new Promise(resolve => setTimeout(resolve, 2000));\n+  console.log(`Hello, ${name}!`);\n+}\n+\n+delayedGreeting(\"Alice\");\n+console.log(\"First Printed Message!\");\n+```\n+\n+In the above example, the `delayedGreeting` function is an `async` function that pauses for 2 seconds before printing the greeting message. The `await` keyword is used to pause the function execution until the `Promise` is resolved.\n+\n+- One of the biggest advantages of `async/await` is error handling via `try/catch` blocks. Here's an example:\n+\n+```js\n+async function fetchData() {\n+  try {\n+    const response = await fetch('https://api.example.com/data');\n+    const data = await response.json();\n+    console.log(data);\n+  } catch (error) {\n+    console.error(error);\n+  }\n+}\n+\n+fetchData();\n+```\n+\n+In the above example, the `try` block contains the code that might throw an error, and the `catch` block handles the error if it occurs. This makes error handling more straightforward and readable.\n+\n+## The `async` attribute\n+\n+- The `async` attribute tells the browser to download the script file asynchronously while continuing to parse the HTML document. \n+- Once the script is downloaded, the HTML parsing is paused, the script is executed, and then HTML parsing resumes.\n+- You should use `async` for independent scripts where the order of execution doesn't matter\n+\n+## The `defer` attribute\n+\n+- The `defer` attribute also downloads the script asynchronously, but it defers the execution of the script until after the HTML document has been fully parsed. \n+- The `defer` scripts maintain the order of execution as they appear in the HTML document.\n+\n+- It's important to note that both `async` and `defer` attributes are ignored for inline scripts and only work for external script files.\n+\n+- When both `async` and `defer` attributes are present, the `async` attribute takes precedence.\n+\n+## Geolocation API \n+\n+- The Geolocation API provides a way for websites to request the user's location.\n+\n+- The example below demonstrates the API's  `getCurrentPosition()` method which is used to get the user's current location.\n+\n+```js\n+navigator.geolocation.getCurrentPosition(\n+  (position) => {\n+    console.log(\"Latitude: \" + position.coords.latitude);\n+    console.log(\"Longitude: \" + position.coords.longitude);\n+  },\n+  (error) => {\n+    console.log(\"Error: \" + error.message);\n+  }\n+);\n+```\n+\n+In this code, we're calling `getCurrentPosition` and passing it a function which will be called when the position is successfully obtained. \n+\n+The `position` object contains a variety of information, but here we have selected `latitude` and `longitude` only.\n+\n+If there is an issue with getting the `position`, then the error will be logged to the console. \n+\n+- It is important to respect the user's privacy and only request their location when necessary.\n \n # --assignment--\n "
        }
    ],
    "stats": {
        "total": 211,
        "additions": 210,
        "deletions": 1
    }
}