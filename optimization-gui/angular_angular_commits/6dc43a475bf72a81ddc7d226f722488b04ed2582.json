{
    "author": "gkalpak",
    "message": "fix(upgrade): avoid memory leak when removing downgraded components (#39965)\n\nPreviously, due to the way the AngularJS and Angular clean-up processes\ninterfere with each other when removing an AngularJS element that\ncontains a downgraded Angular component, the data associated with the\nhost element of the downgraded component was not removed. This data was\nkept in an internal AngularJS cache, which prevented the element and\ncomponent instance from being garbage-collected, leading to memory\nleaks.\n\nThis commit fixes this by ensuring the element data is explicitly\nremoved when cleaning up a downgraded component.\n\nNOTE:\nThis is essentially the equivalent of #26209 but for downgraded (instead\nof upgraded) components.\n\nFixes #39911\nCloses #39921\n\nPR Close #39965",
    "sha": "6dc43a475bf72a81ddc7d226f722488b04ed2582",
    "files": [
        {
            "sha": "b4a8b94d1286629eebf28434b4a6921710df0778",
            "filename": "packages/upgrade/src/common/src/angular1.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/6dc43a475bf72a81ddc7d226f722488b04ed2582/packages%2Fupgrade%2Fsrc%2Fcommon%2Fsrc%2Fangular1.ts",
            "raw_url": "https://github.com/angular/angular/raw/6dc43a475bf72a81ddc7d226f722488b04ed2582/packages%2Fupgrade%2Fsrc%2Fcommon%2Fsrc%2Fangular1.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fupgrade%2Fsrc%2Fcommon%2Fsrc%2Fangular1.ts?ref=6dc43a475bf72a81ddc7d226f722488b04ed2582",
            "patch": "@@ -126,6 +126,7 @@ export type IAugmentedJQuery = Node[]&{\n   data?: (name: string, value?: any) => any;\n   text?: () => string;\n   inheritedData?: (name: string, value?: any) => any;\n+  children?: () => IAugmentedJQuery;\n   contents?: () => IAugmentedJQuery;\n   parent?: () => IAugmentedJQuery;\n   empty?: () => void;"
        },
        {
            "sha": "5022a58aaca22c086e1ac887c2494f5028bbcbaa",
            "filename": "packages/upgrade/src/common/src/downgrade_component_adapter.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 2,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/6dc43a475bf72a81ddc7d226f722488b04ed2582/packages%2Fupgrade%2Fsrc%2Fcommon%2Fsrc%2Fdowngrade_component_adapter.ts",
            "raw_url": "https://github.com/angular/angular/raw/6dc43a475bf72a81ddc7d226f722488b04ed2582/packages%2Fupgrade%2Fsrc%2Fcommon%2Fsrc%2Fdowngrade_component_adapter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fupgrade%2Fsrc%2Fcommon%2Fsrc%2Fdowngrade_component_adapter.ts?ref=6dc43a475bf72a81ddc7d226f722488b04ed2582",
            "patch": "@@ -8,7 +8,7 @@\n \n import {ApplicationRef, ChangeDetectorRef, ComponentFactory, ComponentRef, EventEmitter, Injector, OnChanges, SimpleChange, SimpleChanges, StaticProvider, Testability, TestabilityRegistry, Type} from '@angular/core';\n \n-import {IAttributes, IAugmentedJQuery, ICompileService, INgModelController, IParseService, IScope} from './angular1';\n+import {element as angularElement, IAttributes, IAugmentedJQuery, ICompileService, INgModelController, IParseService, IScope} from './angular1';\n import {PropertyBinding} from './component_info';\n import {$SCOPE} from './constants';\n import {getTypeName, hookupNgModel, strictEquals} from './util';\n@@ -216,11 +216,38 @@ export class DowngradeComponentAdapter {\n     const destroyComponentRef = this.wrapCallback(() => this.componentRef.destroy());\n     let destroyed = false;\n \n-    this.element.on!('$destroy', () => this.componentScope.$destroy());\n+    this.element.on!('$destroy', () => {\n+      // The `$destroy` event may have been triggered by the `cleanData()` call in the\n+      // `componentScope` `$destroy` handler below. In that case, we don't want to call\n+      // `componentScope.$destroy()` again.\n+      if (!destroyed) this.componentScope.$destroy();\n+    });\n     this.componentScope.$on('$destroy', () => {\n       if (!destroyed) {\n         destroyed = true;\n         testabilityRegistry.unregisterApplication(this.componentRef.location.nativeElement);\n+\n+        // The `componentScope` might be getting destroyed, because an ancestor element is being\n+        // removed/destroyed. If that is the case, jqLite/jQuery would normally invoke `cleanData()`\n+        // on the removed element and all descendants.\n+        //   https://github.com/angular/angular.js/blob/2e72ea13fa98bebf6ed4b5e3c45eaf5f990ed16f/src/jqLite.js#L349-L355\n+        //   https://github.com/jquery/jquery/blob/6984d1747623dbc5e87fd6c261a5b6b1628c107c/src/manipulation.js#L182\n+        //\n+        // Here, however, `destroyComponentRef()` may under some circumstances remove the element\n+        // from the DOM and therefore it will no longer be a descendant of the removed element when\n+        // `cleanData()` is called. This would result in a memory leak, because the element's data\n+        // and event handlers (and all objects directly or indirectly referenced by them) would be\n+        // retained.\n+        //\n+        // To ensure the element is always properly cleaned up, we manually call `cleanData()` on\n+        // this element and its descendants before destroying the `ComponentRef`.\n+        //\n+        // NOTE:\n+        // `cleanData()` also will invoke the AngularJS `$destroy` event on the element:\n+        //   https://github.com/angular/angular.js/blob/2e72ea13fa98bebf6ed4b5e3c45eaf5f990ed16f/src/Angular.js#L1932-L1945\n+        angularElement.cleanData(this.element);\n+        angularElement.cleanData((this.element[0] as Element).querySelectorAll('*'));\n+\n         destroyComponentRef();\n       }\n     });"
        },
        {
            "sha": "3d33cc59be02d70e240b4e6ea993b36f69ab9d7f",
            "filename": "packages/upgrade/src/dynamic/test/upgrade_spec.ts",
            "status": "modified",
            "additions": 35,
            "deletions": 16,
            "changes": 51,
            "blob_url": "https://github.com/angular/angular/blob/6dc43a475bf72a81ddc7d226f722488b04ed2582/packages%2Fupgrade%2Fsrc%2Fdynamic%2Ftest%2Fupgrade_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6dc43a475bf72a81ddc7d226f722488b04ed2582/packages%2Fupgrade%2Fsrc%2Fdynamic%2Ftest%2Fupgrade_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fupgrade%2Fsrc%2Fdynamic%2Ftest%2Fupgrade_spec.ts?ref=6dc43a475bf72a81ddc7d226f722488b04ed2582",
            "patch": "@@ -665,23 +665,16 @@ withEachNg1Version(() => {\n       it('should properly run cleanup when ng1 directive is destroyed', waitForAsync(() => {\n            const adapter: UpgradeAdapter = new UpgradeAdapter(forwardRef(() => Ng2Module));\n            const ng1Module = angular.module_('ng1', []);\n-           const onDestroyed: EventEmitter<string> = new EventEmitter<string>();\n+           let ng2ComponentDestroyed = false;\n \n-           ng1Module.directive('ng1', () => {\n-             return {\n-               template: '<div ng-if=\"!destroyIt\"><ng2></ng2></div>',\n-               controller: function($rootScope: any, $timeout: Function) {\n-                 $timeout(() => {\n-                   $rootScope.destroyIt = true;\n-                 });\n-               }\n-             };\n-           });\n+           ng1Module.directive('ng1', () => ({\n+                                        template: '<div ng-if=\"!destroyIt\"><ng2></ng2></div>',\n+                                      }));\n \n-           @Component({selector: 'ng2', template: 'test'})\n+           @Component({selector: 'ng2', template: '<ul><li>test1</li><li>test2</li></ul>'})\n            class Ng2 {\n              ngOnDestroy() {\n-               onDestroyed.emit('destroyed');\n+               ng2ComponentDestroyed = true;\n              }\n            }\n \n@@ -695,9 +688,35 @@ withEachNg1Version(() => {\n            ng1Module.directive('ng2', adapter.downgradeNg2Component(Ng2));\n            const element = html('<ng1></ng1>');\n            adapter.bootstrap(element, ['ng1']).ready((ref) => {\n-             onDestroyed.subscribe(() => {\n-               ref.dispose();\n-             });\n+             const ng2Element = angular.element(element.querySelector('ng2') as Element);\n+             const ng2Descendants =\n+                 Array.from(element.querySelectorAll('ng2 li')).map(angular.element);\n+             let ng2ElementDestroyed = false;\n+             let ng2DescendantsDestroyed = ng2Descendants.map(() => false);\n+\n+             ng2Element.data!('test', 42);\n+             ng2Descendants.forEach((elem, i) => elem.data!('test', i));\n+             ng2Element.on!('$destroy', () => ng2ElementDestroyed = true);\n+             ng2Descendants.forEach(\n+                 (elem, i) => elem.on!('$destroy', () => ng2DescendantsDestroyed[i] = true));\n+\n+             expect(element.textContent).toBe('test1test2');\n+             expect(ng2Element.data!('test')).toBe(42);\n+             ng2Descendants.forEach((elem, i) => expect(elem.data!('test')).toBe(i));\n+             expect(ng2ElementDestroyed).toBe(false);\n+             expect(ng2DescendantsDestroyed).toEqual([false, false]);\n+             expect(ng2ComponentDestroyed).toBe(false);\n+\n+             ref.ng1RootScope.$apply('destroyIt = true');\n+\n+             expect(element.textContent).toBe('');\n+             expect(ng2Element.data!('test')).toBeUndefined();\n+             ng2Descendants.forEach(elem => expect(elem.data!('test')).toBeUndefined());\n+             expect(ng2ElementDestroyed).toBe(true);\n+             expect(ng2DescendantsDestroyed).toEqual([true, true]);\n+             expect(ng2ComponentDestroyed).toBe(true);\n+\n+             ref.dispose();\n            });\n          }));\n "
        },
        {
            "sha": "ec88d423d158a368e580a414c4ad7fff55a66d20",
            "filename": "packages/upgrade/static/test/integration/downgrade_component_spec.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 3,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/6dc43a475bf72a81ddc7d226f722488b04ed2582/packages%2Fupgrade%2Fstatic%2Ftest%2Fintegration%2Fdowngrade_component_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6dc43a475bf72a81ddc7d226f722488b04ed2582/packages%2Fupgrade%2Fstatic%2Ftest%2Fintegration%2Fdowngrade_component_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fupgrade%2Fstatic%2Ftest%2Fintegration%2Fdowngrade_component_spec.ts?ref=6dc43a475bf72a81ddc7d226f722488b04ed2582",
            "patch": "@@ -536,7 +536,7 @@ withEachNg1Version(() => {\n \n     it('should properly run cleanup when ng1 directive is destroyed', waitForAsync(() => {\n          let destroyed = false;\n-         @Component({selector: 'ng2', template: 'test'})\n+         @Component({selector: 'ng2', template: '<ul><li>test1</li><li>test2</li></ul>'})\n          class Ng2Component implements OnDestroy {\n            ngOnDestroy() {\n              destroyed = true;\n@@ -563,14 +563,35 @@ withEachNg1Version(() => {\n          platformBrowserDynamic().bootstrapModule(Ng2Module).then((ref) => {\n            const adapter = ref.injector.get(UpgradeModule) as UpgradeModule;\n            adapter.bootstrap(element, [ng1Module.name]);\n-           expect(element.textContent).toContain('test');\n+\n+           const ng2Element = angular.element(element.querySelector('ng2') as Element);\n+           const ng2Descendants =\n+               Array.from(element.querySelectorAll('ng2 li')).map(angular.element);\n+           let ng2ElementDestroyed = false;\n+           let ng2DescendantsDestroyed = [false, false];\n+\n+           ng2Element.data!('test', 42);\n+           ng2Descendants.forEach((elem, i) => elem.data!('test', i));\n+           ng2Element.on!('$destroy', () => ng2ElementDestroyed = true);\n+           ng2Descendants.forEach(\n+               (elem, i) => elem.on!('$destroy', () => ng2DescendantsDestroyed[i] = true));\n+\n+           expect(element.textContent).toBe('test1test2');\n            expect(destroyed).toBe(false);\n+           expect(ng2Element.data!('test')).toBe(42);\n+           ng2Descendants.forEach((elem, i) => expect(elem.data!('test')).toBe(i));\n+           expect(ng2ElementDestroyed).toBe(false);\n+           expect(ng2DescendantsDestroyed).toEqual([false, false]);\n \n            const $rootScope = adapter.$injector.get('$rootScope');\n            $rootScope.$apply('destroyIt = true');\n \n-           expect(element.textContent).not.toContain('test');\n+           expect(element.textContent).toBe('');\n            expect(destroyed).toBe(true);\n+           expect(ng2Element.data!('test')).toBeUndefined();\n+           ng2Descendants.forEach(elem => expect(elem.data!('test')).toBeUndefined());\n+           expect(ng2ElementDestroyed).toBe(true);\n+           expect(ng2DescendantsDestroyed).toEqual([true, true]);\n          });\n        }));\n "
        },
        {
            "sha": "cc34ec57b7f5fb97b60f18c8bbf776938548f645",
            "filename": "packages/upgrade/static/test/integration/downgrade_module_spec.ts",
            "status": "modified",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/angular/angular/blob/6dc43a475bf72a81ddc7d226f722488b04ed2582/packages%2Fupgrade%2Fstatic%2Ftest%2Fintegration%2Fdowngrade_module_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6dc43a475bf72a81ddc7d226f722488b04ed2582/packages%2Fupgrade%2Fstatic%2Ftest%2Fintegration%2Fdowngrade_module_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fupgrade%2Fstatic%2Ftest%2Fintegration%2Fdowngrade_module_spec.ts?ref=6dc43a475bf72a81ddc7d226f722488b04ed2582",
            "patch": "@@ -1187,6 +1187,69 @@ withEachNg1Version(() => {\n            });\n          }));\n \n+      it('should properly run cleanup when a downgraded component is destroyed',\n+         waitForAsync(() => {\n+           let destroyed = false;\n+\n+           @Component({selector: 'ng2', template: '<ul><li>test1</li><li>test2</li></ul>'})\n+           class Ng2Component implements OnDestroy {\n+             ngOnDestroy() {\n+               destroyed = true;\n+             }\n+           }\n+\n+           @NgModule({\n+             declarations: [Ng2Component],\n+             entryComponents: [Ng2Component],\n+             imports: [BrowserModule],\n+           })\n+           class Ng2Module {\n+             ngDoBootstrap() {}\n+           }\n+\n+           const bootstrapFn = (extraProviders: StaticProvider[]) =>\n+               platformBrowserDynamic(extraProviders).bootstrapModule(Ng2Module);\n+           const lazyModuleName = downgradeModule<Ng2Module>(bootstrapFn);\n+           const ng1Module =\n+               angular.module_('ng1', [lazyModuleName])\n+                   .directive(\n+                       'ng2', downgradeComponent({component: Ng2Component, propagateDigest}));\n+\n+           const element = html('<div><div ng-if=\"!hideNg2\"><ng2></ng2></div></div>');\n+           const $injector = angular.bootstrap(element, [ng1Module.name]);\n+           const $rootScope = $injector.get($ROOT_SCOPE) as angular.IRootScopeService;\n+\n+           setTimeout(() => {  // Wait for the module to be bootstrapped.\n+             const ng2Element = angular.element(element.querySelector('ng2') as Element);\n+             const ng2Descendants =\n+                 Array.from(element.querySelectorAll('ng2 li')).map(angular.element);\n+             let ng2ElementDestroyed = false;\n+             let ng2DescendantsDestroyed = [false, false];\n+\n+             ng2Element.data!('test', 42);\n+             ng2Descendants.forEach((elem, i) => elem.data!('test', i));\n+             ng2Element.on!('$destroy', () => ng2ElementDestroyed = true);\n+             ng2Descendants.forEach(\n+                 (elem, i) => elem.on!('$destroy', () => ng2DescendantsDestroyed[i] = true));\n+\n+             expect(element.textContent).toBe('test1test2');\n+             expect(destroyed).toBe(false);\n+             expect(ng2Element.data!('test')).toBe(42);\n+             ng2Descendants.forEach((elem, i) => expect(elem.data!('test')).toBe(i));\n+             expect(ng2ElementDestroyed).toBe(false);\n+             expect(ng2DescendantsDestroyed).toEqual([false, false]);\n+\n+             $rootScope.$apply('hideNg2 = true');\n+\n+             expect(element.textContent).toBe('');\n+             expect(destroyed).toBe(true);\n+             expect(ng2Element.data!('test')).toBeUndefined();\n+             ng2Descendants.forEach(elem => expect(elem.data!('test')).toBeUndefined());\n+             expect(ng2ElementDestroyed).toBe(true);\n+             expect(ng2DescendantsDestroyed).toEqual([true, true]);\n+           });\n+         }));\n+\n       it('should only retrieve the Angular zone once (and cache it for later use)',\n          fakeAsync(() => {\n            let count = 0;"
        }
    ],
    "stats": {
        "total": 173,
        "additions": 152,
        "deletions": 21
    }
}