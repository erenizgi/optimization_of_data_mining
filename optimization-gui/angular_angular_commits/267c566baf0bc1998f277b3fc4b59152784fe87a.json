{
    "author": "josephperrott",
    "message": "Revert \"fix(router): fix load interaction of navigation and preload strategies (#40389)\" (#40806)\n\nThis reverts commit e9a19a6152cc742f1617ee696202a7fbd06fff3d.\n\nPR Close #40806",
    "sha": "267c566baf0bc1998f277b3fc4b59152784fe87a",
    "files": [
        {
            "sha": "0520b53e03275f3ab8ade8a176965d17ae70352a",
            "filename": "goldens/size-tracking/aio-payloads.json",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/267c566baf0bc1998f277b3fc4b59152784fe87a/goldens%2Fsize-tracking%2Faio-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/267c566baf0bc1998f277b3fc4b59152784fe87a/goldens%2Fsize-tracking%2Faio-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Faio-payloads.json?ref=267c566baf0bc1998f277b3fc4b59152784fe87a",
            "patch": "@@ -12,7 +12,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 3033,\n-        \"main-es2015\": 448036,\n+        \"main-es2015\": 447514,\n         \"polyfills-es2015\": 52493\n       }\n     }\n@@ -21,9 +21,9 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 3153,\n-        \"main-es2015\": 432647,\n+        \"main-es2015\": 432078,\n         \"polyfills-es2015\": 52493\n       }\n     }\n   }\n-}\n\\ No newline at end of file\n+}"
        },
        {
            "sha": "3a456cfc7164f42c68834c4c20b680e6c1bf519d",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/267c566baf0bc1998f277b3fc4b59152784fe87a/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/267c566baf0bc1998f277b3fc4b59152784fe87a/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=267c566baf0bc1998f277b3fc4b59152784fe87a",
            "patch": "@@ -39,7 +39,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2285,\n-        \"main-es2015\": 241843,\n+        \"main-es2015\": 241202,\n         \"polyfills-es2015\": 36709,\n         \"5-es2015\": 745\n       }\n@@ -66,4 +66,4 @@\n       }\n     }\n   }\n-}\n\\ No newline at end of file\n+}"
        },
        {
            "sha": "98f195099c8ec73982d2dddb68ef09774a207072",
            "filename": "packages/router/src/apply_redirects.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/267c566baf0bc1998f277b3fc4b59152784fe87a/packages%2Frouter%2Fsrc%2Fapply_redirects.ts",
            "raw_url": "https://github.com/angular/angular/raw/267c566baf0bc1998f277b3fc4b59152784fe87a/packages%2Frouter%2Fsrc%2Fapply_redirects.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Fapply_redirects.ts?ref=267c566baf0bc1998f277b3fc4b59152784fe87a",
            "patch": "@@ -280,12 +280,11 @@ class ApplyRedirects {\n       segments: UrlSegment[], outlet: string): Observable<UrlSegmentGroup> {\n     if (route.path === '**') {\n       if (route.loadChildren) {\n-        const loaded$ = route._loadedConfig ? of(route._loadedConfig) :\n-                                              this.configLoader.load(ngModule.injector, route);\n-        return loaded$.pipe(map((cfg: LoadedRouterConfig) => {\n-          route._loadedConfig = cfg;\n-          return new UrlSegmentGroup(segments, {});\n-        }));\n+        return this.configLoader.load(ngModule.injector, route)\n+            .pipe(map((cfg: LoadedRouterConfig) => {\n+              route._loadedConfig = cfg;\n+              return new UrlSegmentGroup(segments, {});\n+            }));\n       }\n \n       return of(new UrlSegmentGroup(segments, {}));"
        },
        {
            "sha": "86af574f02b3a043451d70a49102c2d48eaeadcd",
            "filename": "packages/router/src/config.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/267c566baf0bc1998f277b3fc4b59152784fe87a/packages%2Frouter%2Fsrc%2Fconfig.ts",
            "raw_url": "https://github.com/angular/angular/raw/267c566baf0bc1998f277b3fc4b59152784fe87a/packages%2Frouter%2Fsrc%2Fconfig.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Fconfig.ts?ref=267c566baf0bc1998f277b3fc4b59152784fe87a",
            "patch": "@@ -483,11 +483,6 @@ export interface Route {\n    * @internal\n    */\n   _loadedConfig?: LoadedRouterConfig;\n-  /**\n-   * Filled for routes with `loadChildren` during load\n-   * @internal\n-   */\n-  _loader$?: Observable<LoadedRouterConfig>;\n }\n \n export class LoadedRouterConfig {"
        },
        {
            "sha": "e9d21974eeea8e45fdc79df6b7012c65ac8c6941",
            "filename": "packages/router/src/router_config_loader.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 31,
            "changes": 50,
            "blob_url": "https://github.com/angular/angular/blob/267c566baf0bc1998f277b3fc4b59152784fe87a/packages%2Frouter%2Fsrc%2Frouter_config_loader.ts",
            "raw_url": "https://github.com/angular/angular/raw/267c566baf0bc1998f277b3fc4b59152784fe87a/packages%2Frouter%2Fsrc%2Frouter_config_loader.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter_config_loader.ts?ref=267c566baf0bc1998f277b3fc4b59152784fe87a",
            "patch": "@@ -7,8 +7,8 @@\n  */\n \n import {Compiler, InjectFlags, InjectionToken, Injector, NgModuleFactory, NgModuleFactoryLoader} from '@angular/core';\n-import {ConnectableObservable, from, Observable, of, Subject} from 'rxjs';\n-import {catchError, map, mergeMap, refCount, tap} from 'rxjs/operators';\n+import {from, Observable, of} from 'rxjs';\n+import {map, mergeMap} from 'rxjs/operators';\n \n import {LoadChildren, LoadedRouterConfig, Route} from './config';\n import {flatten, wrapIntoObservable} from './utils/collection';\n@@ -28,39 +28,27 @@ export class RouterConfigLoader {\n       private onLoadEndListener?: (r: Route) => void) {}\n \n   load(parentInjector: Injector, route: Route): Observable<LoadedRouterConfig> {\n-    if (route._loader$) {\n-      return route._loader$;\n-    }\n-\n     if (this.onLoadStartListener) {\n       this.onLoadStartListener(route);\n     }\n+\n     const moduleFactory$ = this.loadModuleFactory(route.loadChildren!);\n-    const loadRunner = moduleFactory$.pipe(\n-        map((factory: NgModuleFactory<any>) => {\n-          if (this.onLoadEndListener) {\n-            this.onLoadEndListener(route);\n-          }\n-          const module = factory.create(parentInjector);\n-          // When loading a module that doesn't provide `RouterModule.forChild()` preloader\n-          // will get stuck in an infinite loop. The child module's Injector will look to\n-          // its parent `Injector` when it doesn't find any ROUTES so it will return routes\n-          // for it's parent module instead.\n-          return new LoadedRouterConfig(\n-              flatten(\n-                  module.injector.get(ROUTES, undefined, InjectFlags.Self | InjectFlags.Optional))\n-                  .map(standardizeConfig),\n-              module);\n-        }),\n-        catchError((err) => {\n-          route._loader$ = undefined;\n-          throw err;\n-        }),\n-    );\n-    // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n-    route._loader$ = new ConnectableObservable(loadRunner, () => new Subject<LoadedRouterConfig>())\n-                         .pipe(refCount());\n-    return route._loader$;\n+\n+    return moduleFactory$.pipe(map((factory: NgModuleFactory<any>) => {\n+      if (this.onLoadEndListener) {\n+        this.onLoadEndListener(route);\n+      }\n+\n+      const module = factory.create(parentInjector);\n+\n+      // When loading a module that doesn't provide `RouterModule.forChild()` preloader will get\n+      // stuck in an infinite loop. The child module's Injector will look to its parent `Injector`\n+      // when it doesn't find any ROUTES so it will return routes for it's parent module instead.\n+      return new LoadedRouterConfig(\n+          flatten(module.injector.get(ROUTES, undefined, InjectFlags.Self | InjectFlags.Optional))\n+              .map(standardizeConfig),\n+          module);\n+    }));\n   }\n \n   private loadModuleFactory(loadChildren: LoadChildren): Observable<NgModuleFactory<any>> {"
        },
        {
            "sha": "81f4e17612126a81a0706c4519a6ea06d2080df9",
            "filename": "packages/router/src/router_preloader.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/267c566baf0bc1998f277b3fc4b59152784fe87a/packages%2Frouter%2Fsrc%2Frouter_preloader.ts",
            "raw_url": "https://github.com/angular/angular/raw/267c566baf0bc1998f277b3fc4b59152784fe87a/packages%2Frouter%2Fsrc%2Frouter_preloader.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter_preloader.ts?ref=267c566baf0bc1998f277b3fc4b59152784fe87a",
            "patch": "@@ -126,8 +126,7 @@ export class RouterPreloader implements OnDestroy {\n \n   private preloadConfig(ngModule: NgModuleRef<any>, route: Route): Observable<void> {\n     return this.preloadingStrategy.preload(route, () => {\n-      const loaded$ = route._loadedConfig ? of(route._loadedConfig) :\n-                                            this.loader.load(ngModule.injector, route);\n+      const loaded$ = this.loader.load(ngModule.injector, route);\n       return loaded$.pipe(mergeMap((config: LoadedRouterConfig) => {\n         route._loadedConfig = config;\n         return this.processRoutes(config.module, config.routes);"
        },
        {
            "sha": "18dcf9718f53140200cc1caa62ab2cbe0b33bcfd",
            "filename": "packages/router/test/apply_redirects.spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 39,
            "changes": 39,
            "blob_url": "https://github.com/angular/angular/blob/267c566baf0bc1998f277b3fc4b59152784fe87a/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/267c566baf0bc1998f277b3fc4b59152784fe87a/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts?ref=267c566baf0bc1998f277b3fc4b59152784fe87a",
            "patch": "@@ -514,45 +514,6 @@ describe('applyRedirects', () => {\n          expect(loaded).toEqual(['root', 'aux']);\n        }));\n \n-    it('should not try to load any matching configuration if previous load completed',\n-       fakeAsync(() => {\n-         const loadedConfig =\n-             new LoadedRouterConfig([{path: 'a', component: ComponentA}], testModule);\n-         let loadCalls = 0;\n-         let loaded: string[] = [];\n-         const loader = {\n-           load: (injector: any, p: Route) => {\n-             loadCalls++;\n-             return of(loadedConfig)\n-                 .pipe(\n-                     delay(100 * loadCalls),\n-                     tap(() => loaded.push(p.loadChildren! as string)),\n-                 );\n-           }\n-         };\n-\n-         const config: Routes = [\n-           {path: '**', loadChildren: 'children'},\n-         ];\n-\n-         applyRedirects(testModule.injector, <any>loader, serializer, tree('xyz/a'), config)\n-             .subscribe();\n-         expect(loadCalls).toBe(1);\n-         tick(50);\n-         expect(loaded).toEqual([]);\n-         applyRedirects(testModule.injector, <any>loader, serializer, tree('xyz/b'), config)\n-             .subscribe();\n-         tick(50);\n-         expect(loaded).toEqual(['children']);\n-         expect(loadCalls).toBe(2);\n-         tick(200);\n-         applyRedirects(testModule.injector, <any>loader, serializer, tree('xyz/c'), config)\n-             .subscribe();\n-         tick(50);\n-         expect(loadCalls).toBe(2);\n-         tick(300);\n-       }));\n-\n     it('loads only the first match when two Routes with the same outlet have the same path', () => {\n       const loadedConfig = new LoadedRouterConfig([{path: '', component: ComponentA}], testModule);\n       let loadCalls = 0;"
        },
        {
            "sha": "db4edfbd3829a38694d0cfe9cb28deaad49d834c",
            "filename": "packages/router/test/router_preloader.spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 310,
            "changes": 311,
            "blob_url": "https://github.com/angular/angular/blob/267c566baf0bc1998f277b3fc4b59152784fe87a/packages%2Frouter%2Ftest%2Frouter_preloader.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/267c566baf0bc1998f277b3fc4b59152784fe87a/packages%2Frouter%2Ftest%2Frouter_preloader.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Frouter_preloader.spec.ts?ref=267c566baf0bc1998f277b3fc4b59152784fe87a",
            "patch": "@@ -6,18 +6,14 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Compiler, Component, Injector, NgModule, NgModuleFactory, NgModuleFactoryLoader, NgModuleRef, Type} from '@angular/core';\n-import {resolveComponentResources} from '@angular/core/src/metadata/resource_loading';\n+import {Compiler, Component, NgModule, NgModuleFactoryLoader, NgModuleRef} from '@angular/core';\n import {fakeAsync, inject, TestBed, tick} from '@angular/core/testing';\n import {PreloadAllModules, PreloadingStrategy, RouterPreloader} from '@angular/router';\n-import {BehaviorSubject, Observable, of, throwError} from 'rxjs';\n-import {catchError, delay, filter, switchMap, take} from 'rxjs/operators';\n \n import {Route, RouteConfigLoadEnd, RouteConfigLoadStart, Router, RouterModule} from '../index';\n import {LoadedRouterConfig} from '../src/config';\n import {RouterTestingModule, SpyNgModuleFactoryLoader} from '../testing';\n \n-\n describe('RouterPreloader', () => {\n   @Component({template: ''})\n   class LazyLoadedCmp {\n@@ -200,311 +196,6 @@ describe('RouterPreloader', () => {\n            })));\n   });\n \n-  describe('should support preloading strategies', () => {\n-    let delayLoadUnPaused: BehaviorSubject<string[]>;\n-    let delayLoadObserver$: Observable<string[]>;\n-    let events: Array<RouteConfigLoadStart|RouteConfigLoadEnd>;\n-\n-    const subLoadChildrenSpy = jasmine.createSpy('submodule');\n-    const lazyLoadChildrenSpy = jasmine.createSpy('lazymodule');\n-\n-    const mockPreloaderFactory = (): PreloadingStrategy => {\n-      class DelayedPreLoad implements PreloadingStrategy {\n-        preload(route: Route, fn: () => Observable<any>): Observable<any> {\n-          const routeName =\n-              route.loadChildren ? (route.loadChildren as jasmine.Spy).and.identity : 'noChildren';\n-          return delayLoadObserver$.pipe(\n-              filter(unpauseList => unpauseList.indexOf(routeName) !== -1),\n-              take(1),\n-              switchMap(() => {\n-                return fn().pipe(catchError(() => of(null)));\n-              }),\n-          );\n-        }\n-      }\n-      return new DelayedPreLoad();\n-    };\n-\n-    @NgModule({\n-      declarations: [LazyLoadedCmp],\n-    })\n-    class SharedModule {\n-    }\n-\n-    @NgModule({\n-      imports: [\n-        SharedModule, RouterModule.forChild([\n-          {path: 'LoadedModule1', component: LazyLoadedCmp},\n-          {path: 'sub', loadChildren: subLoadChildrenSpy}\n-        ])\n-      ]\n-    })\n-    class LoadedModule1 {\n-    }\n-\n-    @NgModule({\n-      imports:\n-          [SharedModule, RouterModule.forChild([{path: 'LoadedModule2', component: LazyLoadedCmp}])]\n-    })\n-    class LoadedModule2 {\n-    }\n-\n-    beforeEach(() => {\n-      delayLoadUnPaused = new BehaviorSubject<string[]>([]);\n-      delayLoadObserver$ = delayLoadUnPaused.asObservable();\n-      subLoadChildrenSpy.calls.reset();\n-      lazyLoadChildrenSpy.calls.reset();\n-      TestBed.configureTestingModule({\n-        imports:\n-            [RouterTestingModule.withRoutes([{path: 'lazy', loadChildren: lazyLoadChildrenSpy}])],\n-        providers: [{provide: PreloadingStrategy, useFactory: mockPreloaderFactory}]\n-      });\n-      events = [];\n-    });\n-\n-    it('without reloading loaded modules', fakeAsync(() => {\n-         const preloader = TestBed.inject(RouterPreloader);\n-         const router = TestBed.inject(Router);\n-         router.events.subscribe(e => {\n-           if (e instanceof RouteConfigLoadEnd || e instanceof RouteConfigLoadStart) {\n-             events.push(e);\n-           }\n-         });\n-         lazyLoadChildrenSpy.and.returnValue(of(LoadedModule1));\n-\n-         // App start activation of preloader\n-         preloader.preload().subscribe((x) => {});\n-         tick();\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(0);\n-\n-         // Initial navigation cause route load\n-         router.navigateByUrl('/lazy/LoadedModule1');\n-         tick();\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-\n-         // Secondary load or navigation should use same loaded object (\n-         //   ie this is a noop as the module should already be loaded)\n-         delayLoadUnPaused.next(['lazymodule']);\n-         tick();\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-         expect(subLoadChildrenSpy).toHaveBeenCalledTimes(0);\n-         expect(events.map(e => e.toString())).toEqual([\n-           'RouteConfigLoadStart(path: lazy)', 'RouteConfigLoadEnd(path: lazy)'\n-         ]);\n-       }));\n-\n-    it('and cope with the loader throwing exceptions during module load but allow retry',\n-       fakeAsync(() => {\n-         const preloader = TestBed.inject(RouterPreloader);\n-         const router = TestBed.inject(Router);\n-         router.events.subscribe(e => {\n-           if (e instanceof RouteConfigLoadEnd || e instanceof RouteConfigLoadStart) {\n-             events.push(e);\n-           }\n-         });\n-\n-         lazyLoadChildrenSpy.and.returnValue(\n-             throwError('Error: Fake module load error (expectedreload)'));\n-         preloader.preload().subscribe((x) => {});\n-         tick();\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(0);\n-\n-         delayLoadUnPaused.next(['lazymodule']);\n-         tick();\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-\n-         lazyLoadChildrenSpy.and.returnValue(of(LoadedModule1));\n-         router.navigateByUrl('/lazy/LoadedModule1').catch(() => {\n-           fail('navigation should not throw');\n-         });\n-         tick();\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(2);\n-         expect(subLoadChildrenSpy).toHaveBeenCalledTimes(0);\n-\n-         expect(events.map(e => e.toString())).toEqual([\n-           'RouteConfigLoadStart(path: lazy)', 'RouteConfigLoadStart(path: lazy)',\n-           'RouteConfigLoadEnd(path: lazy)'\n-         ]);\n-       }));\n-\n-    it('and cope with the loader throwing exceptions but allow retry', fakeAsync(() => {\n-         const preloader = TestBed.inject(RouterPreloader);\n-         const router = TestBed.inject(Router);\n-         router.events.subscribe(e => {\n-           if (e instanceof RouteConfigLoadEnd || e instanceof RouteConfigLoadStart) {\n-             events.push(e);\n-           }\n-         });\n-\n-         lazyLoadChildrenSpy.and.returnValue(\n-             throwError('Error: Fake module load error (expectedreload)'));\n-         preloader.preload().subscribe((x) => {});\n-         tick();\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(0);\n-\n-         router.navigateByUrl('/lazy/LoadedModule1').catch((reason) => {\n-           expect(reason).toEqual('Error: Fake module load error (expectedreload)');\n-         });\n-         tick();\n-\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-         lazyLoadChildrenSpy.and.returnValue(of(LoadedModule1));\n-         router.navigateByUrl('/lazy/LoadedModule1').catch(() => {\n-           fail('navigation should not throw');\n-         });\n-         tick();\n-\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(2);\n-         expect(subLoadChildrenSpy).toHaveBeenCalledTimes(0);\n-         expect(events.map(e => e.toString())).toEqual([\n-           'RouteConfigLoadStart(path: lazy)', 'RouteConfigLoadStart(path: lazy)',\n-           'RouteConfigLoadEnd(path: lazy)'\n-         ]);\n-       }));\n-\n-    it('without autoloading loading submodules', fakeAsync(() => {\n-         const preloader = TestBed.inject(RouterPreloader);\n-         const router = TestBed.inject(Router);\n-         router.events.subscribe(e => {\n-           if (e instanceof RouteConfigLoadEnd || e instanceof RouteConfigLoadStart) {\n-             events.push(e);\n-           }\n-         });\n-\n-         lazyLoadChildrenSpy.and.returnValue(of(LoadedModule1));\n-         subLoadChildrenSpy.and.returnValue(of(LoadedModule2));\n-\n-         preloader.preload().subscribe((x) => {});\n-         tick();\n-         router.navigateByUrl('/lazy/LoadedModule1');\n-         tick();\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-         expect(subLoadChildrenSpy).toHaveBeenCalledTimes(0);\n-         expect(events.map(e => e.toString())).toEqual([\n-           'RouteConfigLoadStart(path: lazy)', 'RouteConfigLoadEnd(path: lazy)'\n-         ]);\n-\n-         // Release submodule to check it does in fact load\n-         delayLoadUnPaused.next(['lazymodule', 'submodule']);\n-         tick();\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-         expect(subLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-         expect(events.map(e => e.toString())).toEqual([\n-           'RouteConfigLoadStart(path: lazy)', 'RouteConfigLoadEnd(path: lazy)',\n-           'RouteConfigLoadStart(path: sub)', 'RouteConfigLoadEnd(path: sub)'\n-         ]);\n-       }));\n-\n-    it('and close the preload obsservable ', fakeAsync(() => {\n-         const preloader = TestBed.inject(RouterPreloader);\n-         const router = TestBed.inject(Router);\n-         router.events.subscribe(e => {\n-           if (e instanceof RouteConfigLoadEnd || e instanceof RouteConfigLoadStart) {\n-             events.push(e);\n-           }\n-         });\n-\n-         lazyLoadChildrenSpy.and.returnValue(of(LoadedModule1));\n-         subLoadChildrenSpy.and.returnValue(of(LoadedModule2));\n-         const preloadSubscription = preloader.preload().subscribe((x) => {});\n-\n-         router.navigateByUrl('/lazy/LoadedModule1');\n-         tick();\n-         delayLoadUnPaused.next(['lazymodule', 'submodule']);\n-         tick();\n-\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-         expect(subLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-         expect(preloadSubscription.closed).toBeTruthy();\n-       }));\n-\n-    it('with overlapping loads from navigation and the preloader', fakeAsync(() => {\n-         const preloader = TestBed.inject(RouterPreloader);\n-         const router = TestBed.inject(Router);\n-         router.events.subscribe(e => {\n-           if (e instanceof RouteConfigLoadEnd || e instanceof RouteConfigLoadStart) {\n-             events.push(e);\n-           }\n-         });\n-\n-         lazyLoadChildrenSpy.and.returnValue(of(LoadedModule1));\n-         subLoadChildrenSpy.and.returnValue(of(LoadedModule2).pipe(delay(5)));\n-         preloader.preload().subscribe((x) => {});\n-         tick();\n-\n-         // Load the out modules at start of test and ensure it and only\n-         // it is loaded\n-         delayLoadUnPaused.next(['lazymodule']);\n-         tick();\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-         expect(events.map(e => e.toString())).toEqual([\n-           'RouteConfigLoadStart(path: lazy)',\n-           'RouteConfigLoadEnd(path: lazy)',\n-         ]);\n-\n-         // Cause the load from router to start (has 5 tick delay)\n-         router.navigateByUrl('/lazy/sub/LoadedModule2');\n-         tick();  // T1\n-         // Cause the load from preloader to start\n-         delayLoadUnPaused.next(['lazymodule', 'submodule']);\n-         tick();  // T2\n-\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-         expect(subLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-         tick(5);  // T2 to T7 enough time for mutiple loads to finish\n-\n-         expect(subLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-         expect(events.map(e => e.toString())).toEqual([\n-           'RouteConfigLoadStart(path: lazy)', 'RouteConfigLoadEnd(path: lazy)',\n-           'RouteConfigLoadStart(path: sub)', 'RouteConfigLoadEnd(path: sub)'\n-         ]);\n-       }));\n-\n-    it('cope with factory fail from broken modules', fakeAsync(() => {\n-         const preloader = TestBed.inject(RouterPreloader);\n-         const router = TestBed.inject(Router);\n-         router.events.subscribe(e => {\n-           if (e instanceof RouteConfigLoadEnd || e instanceof RouteConfigLoadStart) {\n-             events.push(e);\n-           }\n-         });\n-\n-         class BrokenModuleFactory extends NgModuleFactory<any> {\n-           moduleType: Type<any> = LoadedModule1;\n-           constructor() {\n-             super();\n-           }\n-           create(_parentInjector: Injector|null): NgModuleRef<any> {\n-             throw 'Error: Broken module';\n-           }\n-         }\n-\n-         lazyLoadChildrenSpy.and.returnValue(of(new BrokenModuleFactory()));\n-         preloader.preload().subscribe((x) => {});\n-         tick();\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(0);\n-\n-         router.navigateByUrl('/lazy/LoadedModule1').catch((reason) => {\n-           expect(reason).toEqual('Error: Broken module');\n-         });\n-         tick();\n-\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(1);\n-         lazyLoadChildrenSpy.and.returnValue(of(LoadedModule1));\n-         router.navigateByUrl('/lazy/LoadedModule1').catch(() => {\n-           fail('navigation should not throw');\n-         });\n-         tick();\n-\n-         expect(lazyLoadChildrenSpy).toHaveBeenCalledTimes(2);\n-         expect(subLoadChildrenSpy).toHaveBeenCalledTimes(0);\n-         expect(events.map(e => e.toString())).toEqual([\n-           'RouteConfigLoadStart(path: lazy)', 'RouteConfigLoadEnd(path: lazy)',\n-           'RouteConfigLoadStart(path: lazy)', 'RouteConfigLoadEnd(path: lazy)'\n-         ]);\n-       }));\n-  });\n-\n   describe('should ignore errors', () => {\n     @NgModule({\n       declarations: [LazyLoadedCmp],"
        }
    ],
    "stats": {
        "total": 429,
        "additions": 31,
        "deletions": 398
    }
}