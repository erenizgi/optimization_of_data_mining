{
    "author": "JoostK",
    "message": "fix(compiler-cli): use correct module import for types behind a `forwardRef` (#42887)\n\nThe static interpreter assumed that a foreign function expression would\nhave to be imported from the absolute module specifier that was used for\nthe foreign function itself. This assumption does not hold for the\n`forwardRef` foreign function resolver, as that extracts the resolved\nexpression from the function's argument, which is not behind the\nabsolute module import of the `forwardRef` function.\n\nThe prior behavior has worked for the typical usage of `forwardRef`,\nwhen it is contained within the same source file as where the static\nevaluation started. In that case, the resulting reference would\nincorrectly have an absolute module guess of `@angular/core`, but the\nlocal identifier emit strategy was capable of emitting the reference\nwithout generating an import using the absolute module guess.\n\nIn the scenario where the static interpreter would first have to follow\na reference to a different source that contained the `forwardRef` would\nthe compilation fail. In that case, there is no local identifier\navailable such that the absolute module emitter would try to locate the\nimported symbol from `@angular/core`. which fails as the symbol is not\nexported from there.\n\nThis commit fixes the issue by checking whether a foreign expression\noccurs in the same source file as the call expression. If it does, then\nthe absolute module specifier that was used to resolve the call\nexpression is ignored.\n\nFixes #42865\n\nPR Close #42887",
    "sha": "70c3461be38765efedac1e4c5dd1156023a29690",
    "files": [
        {
            "sha": "7102efbcdddb3eda5e72d5541aa01e93c6cdc36c",
            "filename": "packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/70c3461be38765efedac1e4c5dd1156023a29690/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Finterpreter.ts",
            "raw_url": "https://github.com/angular/angular/raw/70c3461be38765efedac1e4c5dd1156023a29690/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Finterpreter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Finterpreter.ts?ref=70c3461be38765efedac1e4c5dd1156023a29690",
            "patch": "@@ -463,13 +463,14 @@ export class StaticInterpreter {\n             node, DynamicValue.fromExternalReference(node.expression, lhs));\n       }\n \n-      // If the function is declared in a different file, resolve the foreign function expression\n-      // using the absolute module name of that file (if any).\n-      if (lhs.bestGuessOwningModule !== null) {\n+      // If the foreign expression occurs in a different file, then assume that the owning module\n+      // of the call expression should also be used for the resolved foreign expression.\n+      if (expr.getSourceFile() !== node.expression.getSourceFile() &&\n+          lhs.bestGuessOwningModule !== null) {\n         context = {\n           ...context,\n           absoluteModuleName: lhs.bestGuessOwningModule.specifier,\n-          resolutionContext: node.getSourceFile().fileName,\n+          resolutionContext: lhs.bestGuessOwningModule.resolutionContext,\n         };\n       }\n "
        },
        {
            "sha": "452b7dd41267751984593bd4a358b39aa2bd0393",
            "filename": "packages/compiler-cli/src/ngtsc/partial_evaluator/test/evaluator_spec.ts",
            "status": "modified",
            "additions": 92,
            "deletions": 2,
            "changes": 94,
            "blob_url": "https://github.com/angular/angular/blob/70c3461be38765efedac1e4c5dd1156023a29690/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Fevaluator_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/70c3461be38765efedac1e4c5dd1156023a29690/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Fevaluator_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Fevaluator_spec.ts?ref=70c3461be38765efedac1e4c5dd1156023a29690",
            "patch": "@@ -14,10 +14,10 @@ import {DependencyTracker} from '../../incremental/api';\n import {Declaration, DeclarationKind, isConcreteDeclaration, KnownDeclaration, SpecialDeclarationKind, TypeScriptReflectionHost} from '../../reflection';\n import {getDeclaration, makeProgram} from '../../testing';\n import {DynamicValue} from '../src/dynamic';\n-import {PartialEvaluator} from '../src/interface';\n+import {ForeignFunctionResolver, PartialEvaluator} from '../src/interface';\n import {EnumValue, ResolvedValue} from '../src/result';\n \n-import {evaluate, firstArgFfr, makeEvaluator, makeExpression, owningModuleOf} from './utils';\n+import {arrowReturnValueFfr, evaluate, firstArgFfr, makeEvaluator, makeExpression, owningModuleOf, returnTypeFfr} from './utils';\n \n runInEachFileSystem(() => {\n   describe('ngtsc metadata', () => {\n@@ -646,6 +646,96 @@ runInEachFileSystem(() => {\n       expect(id.text).toEqual('Target');\n     });\n \n+    it('should not associate an owning module when a FFR-resolved expression is within the originating source file',\n+       () => {\n+         const resolved = evaluate(\n+             `import {forwardRef} from 'forward';\n+              class Foo {}`,\n+             'forwardRef(() => Foo)', [{\n+               name: _('/node_modules/forward/index.d.ts'),\n+               contents: `export declare function forwardRef<T>(fn: () => T): T;`,\n+             }],\n+             arrowReturnValueFfr);\n+         if (!(resolved instanceof Reference)) {\n+           return fail('Expected expression to resolve to a reference');\n+         }\n+         expect((resolved.node as ts.ClassDeclaration).name!.text).toBe('Foo');\n+         expect(resolved.bestGuessOwningModule).toBeNull();\n+       });\n+\n+    it('should not associate an owning module when a FFR-resolved expression is imported using a relative import',\n+       () => {\n+         const resolved = evaluate(\n+             `import {forwardRef} from 'forward';\n+              import {Foo} from './foo';`,\n+             'forwardRef(() => Foo)',\n+             [\n+               {\n+                 name: _('/node_modules/forward/index.d.ts'),\n+                 contents: `export declare function forwardRef<T>(fn: () => T): T;`,\n+               },\n+               {\n+                 name: _('/foo.ts'),\n+                 contents: `export class Foo {}`,\n+               }\n+             ],\n+             arrowReturnValueFfr);\n+         if (!(resolved instanceof Reference)) {\n+           return fail('Expected expression to resolve to a reference');\n+         }\n+         expect((resolved.node as ts.ClassDeclaration).name!.text).toBe('Foo');\n+         expect(resolved.bestGuessOwningModule).toBeNull();\n+       });\n+\n+    it('should associate an owning module when a FFR-resolved expression is imported using an absolute import',\n+       () => {\n+         const {expression, checker} = makeExpression(\n+             `import {forwardRef} from 'forward';\n+              import {Foo} from 'external';`,\n+             `forwardRef(() => Foo)`, [\n+               {\n+                 name: _('/node_modules/forward/index.d.ts'),\n+                 contents: `export declare function forwardRef<T>(fn: () => T): T;`,\n+               },\n+               {\n+                 name: _('/node_modules/external/index.d.ts'),\n+                 contents: `export declare class Foo {}`,\n+               }\n+             ]);\n+         const evaluator = makeEvaluator(checker);\n+         const resolved = evaluator.evaluate(expression, arrowReturnValueFfr);\n+         if (!(resolved instanceof Reference)) {\n+           return fail('Expected expression to resolve to a reference');\n+         }\n+         expect((resolved.node as ts.ClassDeclaration).name!.text).toBe('Foo');\n+         expect(resolved.bestGuessOwningModule).toEqual({\n+           specifier: 'external',\n+           resolutionContext: expression.getSourceFile().fileName,\n+         });\n+       });\n+\n+    it('should associate an owning module when a FFR-resolved expression is within the foreign file',\n+       () => {\n+         const {expression, checker} =\n+             makeExpression(`import {external} from 'external';`, `external()`, [{\n+                              name: _('/node_modules/external/index.d.ts'),\n+                              contents: `\n+                                export declare class Foo {}\n+                                export declare function external(): Foo;\n+                              `\n+                            }]);\n+         const evaluator = makeEvaluator(checker);\n+         const resolved = evaluator.evaluate(expression, returnTypeFfr);\n+         if (!(resolved instanceof Reference)) {\n+           return fail('Expected expression to resolve to a reference');\n+         }\n+         expect((resolved.node as ts.ClassDeclaration).name!.text).toBe('Foo');\n+         expect(resolved.bestGuessOwningModule).toEqual({\n+           specifier: 'external',\n+           resolutionContext: expression.getSourceFile().fileName,\n+         });\n+       });\n+\n     it('should resolve functions with more than one statement to a complex function call', () => {\n       const value = evaluate(`function foo(bar) { const b = bar; return b; }`, 'foo(\"test\")');\n "
        },
        {
            "sha": "1bb6c46d8316b7ba374e7ca727da7b1e78894365",
            "filename": "packages/compiler-cli/src/ngtsc/partial_evaluator/test/utils.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/70c3461be38765efedac1e4c5dd1156023a29690/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/70c3461be38765efedac1e4c5dd1156023a29690/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Futils.ts?ref=70c3461be38765efedac1e4c5dd1156023a29690",
            "patch": "@@ -62,3 +62,14 @@ export function firstArgFfr(\n     args: ReadonlyArray<ts.Expression>): ts.Expression {\n   return args[0];\n }\n+\n+export const arrowReturnValueFfr: ForeignFunctionResolver = (_ref, args) => {\n+  // Extracts the `Foo` from `() => Foo`.\n+  return (args[0] as ts.ArrowFunction).body as ts.Expression;\n+};\n+\n+export const returnTypeFfr: ForeignFunctionResolver = (ref) => {\n+  // Extract the `Foo` from the return type of the `external` function declaration.\n+  return ((ref.node as ts.FunctionDeclaration).type as ts.TypeReferenceNode).typeName as\n+      ts.Identifier;\n+};"
        },
        {
            "sha": "64cd47c6a3a171f146a17490b9ad1acfb5d433b4",
            "filename": "packages/compiler-cli/test/ngtsc/ngtsc_spec.ts",
            "status": "modified",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/angular/angular/blob/70c3461be38765efedac1e4c5dd1156023a29690/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/70c3461be38765efedac1e4c5dd1156023a29690/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts?ref=70c3461be38765efedac1e4c5dd1156023a29690",
            "patch": "@@ -1558,6 +1558,60 @@ function allTests(os: string) {\n       expect(jsContents).toContain('exports: function () { return [BarModule]; }');\n     });\n \n+    it('should use relative import for forward references that were resolved from a relative file',\n+       () => {\n+         env.write('dir.ts', `\n+          import {Directive, forwardRef} from '@angular/core';\n+\n+          export const useFoo = forwardRef(() => Foo);\n+\n+          @Directive({selector: 'foo'})\n+          export class Foo {}\n+          `);\n+         env.write('test.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {useFoo} from './dir';\n+\n+          @NgModule({\n+            declarations: [useFoo],\n+          })\n+          export class FooModule {}\n+        `);\n+\n+         env.driveMain();\n+\n+         const jsContents = env.getContents('test.js');\n+         expect(jsContents).toContain('import * as i1 from \"./dir\";');\n+         expect(jsContents).toContain('declarations: [i1.Foo]');\n+       });\n+\n+    it('should use absolute import for forward references that were resolved from an absolute file',\n+       () => {\n+         env.write('dir.ts', `\n+          import {Directive, forwardRef} from '@angular/core';\n+\n+          export const useFoo = forwardRef(() => Foo);\n+\n+          @Directive({selector: 'foo'})\n+          export class Foo {}\n+          `);\n+         env.write('test.ts', `\n+          import {forwardRef, NgModule} from '@angular/core';\n+          import {useFoo} from 'dir';\n+\n+          @NgModule({\n+            declarations: [useFoo],\n+          })\n+          export class FooModule {}\n+        `);\n+\n+         env.driveMain();\n+\n+         const jsContents = env.getContents('test.js');\n+         expect(jsContents).toContain('import * as i1 from \"dir\";');\n+         expect(jsContents).toContain('declarations: [i1.Foo]');\n+       });\n+\n     it('should compile Pipes without errors', () => {\n       env.write('test.ts', `\n         import {Pipe} from '@angular/core';"
        }
    ],
    "stats": {
        "total": 168,
        "additions": 162,
        "deletions": 6
    }
}