{
    "author": "atscott",
    "message": "fix(language-service): Use last child end span for parent without close tag (#42554)\n\nUnclosed element tags are not assigned an `endSourceSpan` by the parser.\nAs a result, the visitor which determines the target node at a position\nfor the language service was unable to determine that a given position\nwas inside an unclosed parent. This happens because we update the\n`endSourceSpan` of template/element nodes to be the end tag (and there\nis not one for unclosed tags). Consequently, the visitor then cannot\nmatch a position to any child node location.\n\nThis change updates the visitor logic to check if there are any\n`children` of a template/element node and updates the end span to be the\nend span of the last child. This allows our `isWithin` logic to identify\nthat a child position is within the unclosed parent.\n\nAddresses one of the issues found during investigation of https://github.com/angular/vscode-ng-language-service/issues/1399\n\nPR Close #42554",
    "sha": "228beeabd1542941cbfff46ad78d52c1df3d283a",
    "files": [
        {
            "sha": "ea14bfccc6f57377fcaf72cd3a89855d8dc7b458",
            "filename": "packages/language-service/ivy/template_target.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 3,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/228beeabd1542941cbfff46ad78d52c1df3d283a/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "raw_url": "https://github.com/angular/angular/raw/228beeabd1542941cbfff46ad78d52c1df3d283a/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts?ref=228beeabd1542941cbfff46ad78d52c1df3d283a",
            "patch": "@@ -286,7 +286,7 @@ class TemplateTargetVisitor implements t.Visitor {\n \n   visit(node: t.Node) {\n     const {start, end} = getSpanIncludingEndTag(node);\n-    if (!isWithin(this.position, {start, end})) {\n+    if (end !== null && !isWithin(this.position, {start, end})) {\n       return;\n     }\n \n@@ -441,8 +441,16 @@ function getSpanIncludingEndTag(ast: t.Node) {\n   // the end of the closing tag. Otherwise, for situation like\n   // <my-component></my-comp¦onent> where the cursor is in the closing tag\n   // we will not be able to return any information.\n-  if ((ast instanceof t.Element || ast instanceof t.Template) && ast.endSourceSpan) {\n-    result.end = ast.endSourceSpan.end.offset;\n+  if (ast instanceof t.Element || ast instanceof t.Template) {\n+    if (ast.endSourceSpan) {\n+      result.end = ast.endSourceSpan.end.offset;\n+    } else if (ast.children.length > 0) {\n+      // If the AST has children but no end source span, then it is an unclosed element with an end\n+      // that should be the end of the last child.\n+      result.end = getSpanIncludingEndTag(ast.children[ast.children.length - 1]).end;\n+    } else {\n+      // This is likely a self-closing tag with no children so the `sourceSpan.end` is correct.\n+    }\n   }\n   return result;\n }"
        },
        {
            "sha": "b33535ccadec457d6dc3081bf43a9acae7e69f7e",
            "filename": "packages/language-service/ivy/test/legacy/template_target_spec.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/angular/angular/blob/228beeabd1542941cbfff46ad78d52c1df3d283a/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/228beeabd1542941cbfff46ad78d52c1df3d283a/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts?ref=228beeabd1542941cbfff46ad78d52c1df3d283a",
            "patch": "@@ -797,3 +797,39 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n     expect((context as SingleNodeTarget).node).toBeInstanceOf(t.Element);\n   });\n });\n+\n+describe('unclosed elements', () => {\n+  it('should locate children of unclosed elements', () => {\n+    const {errors, nodes, position} = parse(`<div> {{b¦ar}}`);\n+    expect(errors).toBe(null);\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+  });\n+\n+  it('should locate children of outside of unclosed when parent is closed elements', () => {\n+    const {nodes, position} = parse(`<li><div></li> {{b¦ar}}`);\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+  });\n+\n+  it('should locate nodes before unclosed element', () => {\n+    const {nodes, position} = parse(`<li>{{b¦ar}}<div></li>`);\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+  });\n+\n+  it('should be correct for end tag of parent node with unclosed child', () => {\n+    const {nodes, position} = parse(`<li><div><div>{{bar}}</l¦i>`);\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Element);\n+    expect((node as t.Element).name).toBe('li');\n+  });\n+});"
        }
    ],
    "stats": {
        "total": 50,
        "additions": 47,
        "deletions": 3
    }
}