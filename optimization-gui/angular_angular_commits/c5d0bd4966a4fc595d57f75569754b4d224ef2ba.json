{
    "author": "atscott",
    "message": "fix(router): Prevent URL flicker when new navigations cancel ongoing ones (#43496)\n\nThis bit of code is problematic for several reasons:\n1. AngularJS-specific handling should not exist in core router code if it can be avoided.\nIt's not something that should complicated the code long-term\n2. It causes URL flickering (the `replace: /` really does happen and can be observed)\n3. The original intent was likely for the URL to not actually change;\nsince the Router only initially supported 'deferred' navigations, this would _usually_ be the case.\n4. It actually causes observers of URL changes more problems in handling changes\nbecause the router is already about to process another navigation request.\nNotice that when using `'computed'` restoration logic, we do not reset the URL\nbecause it would cause another location change event and conflict with the new navigation.\n5. It only resets the browser URL but does nothing to sync the rest of the internal state of the router.\n6. It makes guards which call `router.navigate()` behave _slightly_ differently\nthan guard which return `UrlTree`. Guards which return `UrlTree` do not reset the\nURL, but instead just trigger a new navigation.\n7. It resets the entire URL rather than just the portion that the\n   `UrlHandlingStrategy` is configured to handle. Theoretically, the\n   Router could be configured to only handle a part of the URL so failed\n   navigations should not reset parts it is not configured to touch.\n   Note that this is actually a problem in other places in the router as\n   well where `resetState` is not called before\n   `resetUrlToCurrentUrlTree`.\n\nAs a nice benefit, when `urlUpdateStrategy` is set to `'eager'`, this\nmakes #17004 possible.\n\nBREAKING CHANGE:\nThe router will no longer replace the browser URL when a new navigation\ncancels an ongoing navigation. This often causes URL flicker and was\nonly in place to support some AngularJS hybrid applications. Hybrid\napplications which rely on the `navigationId` being present on initial\nnavigations that were handled by the Angular router should instead\nsubscribe to `NavigationCancel` events and perform the\n`location.replaceState` themselves to add `navigationId` to the Router\nstate.\nIn addition, tests which assert `urlChanges` on the `SpyLocation` may\nneed to be adjusted to account for the `replaceState` which is no longer\ntriggered.\n\nPR Close #43496",
    "sha": "c5d0bd4966a4fc595d57f75569754b4d224ef2ba",
    "files": [
        {
            "sha": "48dca461cc81c3b589e8728256458bad3a48a3c4",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 21,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/c5d0bd4966a4fc595d57f75569754b4d224ef2ba/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/c5d0bd4966a4fc595d57f75569754b4d224ef2ba/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=c5d0bd4966a4fc595d57f75569754b4d224ef2ba",
            "patch": "@@ -921,27 +921,7 @@ export class Router {\n                        if (!completed && !errored) {\n                          const cancelationReason = `Navigation ID ${\n                              t.id} is not equal to the current navigation id ${this.navigationId}`;\n-                         if (this.canceledNavigationResolution === 'replace') {\n-                           // Must reset to current URL tree here to ensure history.state is set. On\n-                           // a fresh page load, if a new navigation comes in before a successful\n-                           // navigation completes, there will be nothing in\n-                           // history.state.navigationId. This can cause sync problems with\n-                           // AngularJS sync code which looks for a value here in order to determine\n-                           // whether or not to handle a given popstate event or to leave it to the\n-                           // Angular router.\n-                           this.restoreHistory(t);\n-                           this.cancelNavigationTransition(t, cancelationReason);\n-                         } else {\n-                           // We cannot trigger a `location.historyGo` if the\n-                           // cancellation was due to a new navigation before the previous could\n-                           // complete. This is because `location.historyGo` triggers a `popstate`\n-                           // which would also trigger another navigation. Instead, treat this as a\n-                           // redirect and do not reset the state.\n-                           this.cancelNavigationTransition(t, cancelationReason);\n-                           // TODO(atscott): The same problem happens here with a fresh page load\n-                           // and a new navigation before that completes where we won't set a page\n-                           // id.\n-                         }\n+                         this.cancelNavigationTransition(t, cancelationReason);\n                        }\n                        // currentNavigation should always be reset to null here. If navigation was\n                        // successful, lastSuccessfulTransition will have already been set. Therefore"
        },
        {
            "sha": "562058e8a759aa3bf38a97df99d66a313eb9a9f5",
            "filename": "packages/router/test/integration.spec.ts",
            "status": "modified",
            "additions": 46,
            "deletions": 1,
            "changes": 47,
            "blob_url": "https://github.com/angular/angular/blob/c5d0bd4966a4fc595d57f75569754b4d224ef2ba/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c5d0bd4966a4fc595d57f75569754b4d224ef2ba/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fintegration.spec.ts?ref=c5d0bd4966a4fc595d57f75569754b4d224ef2ba",
            "patch": "@@ -1182,9 +1182,10 @@ describe('Integration', () => {\n   describe('duplicate in-flight navigations', () => {\n     @Injectable()\n     class RedirectingGuard {\n+      skipLocationChange = false;\n       constructor(private router: Router) {}\n       canActivate() {\n-        this.router.navigate(['/simple']);\n+        this.router.navigate(['/simple'], {skipLocationChange: this.skipLocationChange});\n         return false;\n       }\n     }\n@@ -1266,6 +1267,50 @@ describe('Integration', () => {\n          advance(fixture);\n          expect(fixture.nativeElement.innerHTML).toContain('simple');\n        }));\n+\n+    it('should not cause URL thrashing', fakeAsync(() => {\n+         const router = TestBed.inject(Router);\n+         const location = TestBed.inject(Location) as unknown as SpyLocation;\n+         const fixture = createRoot(router, RootCmp);\n+\n+         router.resetConfig([\n+           {path: 'home', component: SimpleCmp},\n+           {path: 'blocked', component: BlankCmp, canActivate: [RedirectingGuard]},\n+           {path: 'simple', component: SimpleCmp}\n+         ]);\n+         router.navigateByUrl('/home');\n+         advance(fixture);\n+         location.urlChanges = [];\n+\n+         location.simulateHashChange('/blocked');\n+         advance(fixture);\n+         expect(fixture.nativeElement.innerHTML).toContain('simple');\n+         expect(location.urlChanges).toEqual(['hash: /blocked', '/simple']);\n+       }));\n+\n+    it('can render a 404 page without changing the URL', fakeAsync(() => {\n+         const router = TestBed.inject(Router);\n+         router.urlUpdateStrategy = 'eager';\n+         TestBed.inject(RedirectingGuard).skipLocationChange = true;\n+         const location = TestBed.inject(Location) as unknown as SpyLocation;\n+         const fixture = createRoot(router, RootCmp);\n+\n+         router.resetConfig([\n+           {path: 'home', component: SimpleCmp},\n+           {path: 'blocked', component: BlankCmp, canActivate: [RedirectingGuard]},\n+           {path: 'simple', redirectTo: '404'},\n+           {path: '404', component: SimpleCmp},\n+         ]);\n+         router.navigateByUrl('/home');\n+         advance(fixture);\n+         location.urlChanges = [];\n+\n+         location.simulateHashChange('/blocked');\n+         advance(fixture);\n+         expect(location.path()).toEqual('/blocked');\n+         expect(fixture.nativeElement.innerHTML).toContain('simple');\n+         expect(location.urlChanges).toEqual(['hash: /blocked']);\n+       }));\n   });\n \n   it('should support secondary routes', fakeAsync(inject([Router], (router: Router) => {"
        }
    ],
    "stats": {
        "total": 69,
        "additions": 47,
        "deletions": 22
    }
}