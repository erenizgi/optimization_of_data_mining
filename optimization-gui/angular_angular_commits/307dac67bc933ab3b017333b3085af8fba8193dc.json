{
    "author": "JoostK",
    "message": "fix(core): use correct injector when resolving DI tokens from within a directive provider factory (#42886)\n\nWhen a directive provides a DI token using a factory function and\ninteracting with a standalone injector from within that factory, the\nstandalone injector should not have access to either the directive\ninjector nor the NgModule injector; only the standalone injector should\nbe used.\n\nThis commit ensures that a standalone injector never reaches into the\ndirective-level injection context while resolving DI tokens.\n\nFixes #42651\n\nPR Close #42886",
    "sha": "307dac67bc933ab3b017333b3085af8fba8193dc",
    "files": [
        {
            "sha": "cf0de1081abb5eec1ed03d054dd758e41ee22960",
            "filename": "packages/core/src/di/r3_injector.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/307dac67bc933ab3b017333b3085af8fba8193dc/packages%2Fcore%2Fsrc%2Fdi%2Fr3_injector.ts",
            "raw_url": "https://github.com/angular/angular/raw/307dac67bc933ab3b017333b3085af8fba8193dc/packages%2Fcore%2Fsrc%2Fdi%2Fr3_injector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fdi%2Fr3_injector.ts?ref=307dac67bc933ab3b017333b3085af8fba8193dc",
            "patch": "@@ -17,6 +17,7 @@ import {EMPTY_ARRAY} from '../util/empty';\n import {stringify} from '../util/stringify';\n \n import {resolveForwardRef} from './forward_ref';\n+import {setInjectImplementation} from './inject_switch';\n import {InjectionToken} from './injection_token';\n import {Injector} from './injector';\n import {catchInjectorError, injectArgs, NG_TEMP_TOKEN_PATH, setCurrentInjector, THROW_IF_NOT_FOUND, USE_VALUE, ɵɵinject} from './injector_compatibility';\n@@ -186,6 +187,7 @@ export class R3Injector {\n     this.assertNotDestroyed();\n     // Set the injection context.\n     const previousInjector = setCurrentInjector(this);\n+    const previousInjectImplementation = setInjectImplementation(undefined);\n     try {\n       // Check for the SkipSelf flag.\n       if (!(flags & InjectFlags.SkipSelf)) {\n@@ -234,7 +236,8 @@ export class R3Injector {\n         throw e;\n       }\n     } finally {\n-      // Lastly, clean up the state by restoring the previous injector.\n+      // Lastly, restore the previous injection context.\n+      setInjectImplementation(previousInjectImplementation);\n       setCurrentInjector(previousInjector);\n     }\n   }"
        },
        {
            "sha": "91f49cc416f5b457b2126c61b0f7e31a8f4f9552",
            "filename": "packages/core/test/acceptance/di_spec.ts",
            "status": "modified",
            "additions": 88,
            "deletions": 1,
            "changes": 89,
            "blob_url": "https://github.com/angular/angular/blob/307dac67bc933ab3b017333b3085af8fba8193dc/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/307dac67bc933ab3b017333b3085af8fba8193dc/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts?ref=307dac67bc933ab3b017333b3085af8fba8193dc",
            "patch": "@@ -7,7 +7,7 @@\n  */\n \n import {CommonModule} from '@angular/common';\n-import {Attribute, ChangeDetectorRef, Component, ComponentFactoryResolver, ComponentRef, ContentChild, Directive, ElementRef, EventEmitter, forwardRef, Host, HostBinding, Inject, Injectable, InjectionToken, INJECTOR, Injector, Input, LOCALE_ID, NgModule, NgZone, Optional, Output, Pipe, PipeTransform, Self, SkipSelf, TemplateRef, ViewChild, ViewContainerRef, ViewRef, ɵDEFAULT_LOCALE_ID as DEFAULT_LOCALE_ID} from '@angular/core';\n+import {Attribute, ChangeDetectorRef, Component, ComponentFactoryResolver, ComponentRef, Directive, ElementRef, EventEmitter, forwardRef, Host, HostBinding, Inject, Injectable, InjectionToken, INJECTOR, Injector, Input, LOCALE_ID, NgModule, NgZone, Optional, Output, Pipe, PipeTransform, Self, SkipSelf, TemplateRef, ViewChild, ViewContainerRef, ViewRef, ɵDEFAULT_LOCALE_ID as DEFAULT_LOCALE_ID} from '@angular/core';\n import {ɵINJECTOR_SCOPE} from '@angular/core/src/core';\n import {ViewRef as ViewRefInternal} from '@angular/core/src/render3/view_ref';\n import {TestBed} from '@angular/core/testing';\n@@ -599,6 +599,93 @@ describe('di', () => {\n       expect(() => TestBed.createComponent(MyComp)).toThrowError(/No provider for DirectiveB/);\n     });\n \n+    it('should not have access to the directive injector in a standalone injector from within a directive-level provider factory',\n+       () => {\n+         // https://github.com/angular/angular/issues/42651\n+         class TestA {\n+           constructor(public injector: string) {}\n+         }\n+         class TestB {\n+           constructor(public a: TestA) {}\n+         }\n+\n+         function createTestB() {\n+           // Setup a standalone injector that provides `TestA`, which is resolved from a\n+           // standalone child injector that requests `TestA` as a dependency for `TestB`.\n+           // Although we're inside a directive factory and therefore have access to the\n+           // directive-level injector, `TestA` has to be resolved from the standalone injector.\n+           const parent = Injector.create({\n+             providers: [{provide: TestA, useFactory: () => new TestA('standalone'), deps: []}],\n+             name: 'TestA',\n+           });\n+           const child = Injector.create({\n+             providers: [{provide: TestB, useClass: TestB, deps: [TestA]}],\n+             parent,\n+             name: 'TestB',\n+           });\n+           return child.get(TestB);\n+         }\n+\n+         @Component({\n+           template: '',\n+           providers: [\n+             {provide: TestA, useFactory: () => new TestA('component'), deps: []},\n+             {provide: TestB, useFactory: createTestB},\n+           ],\n+         })\n+         class MyComp {\n+           constructor(public readonly testB: TestB) {}\n+         }\n+\n+         TestBed.configureTestingModule({declarations: [MyComp]});\n+\n+         const cmp = TestBed.createComponent(MyComp);\n+         expect(cmp.componentInstance.testB).toBeInstanceOf(TestB);\n+         expect(cmp.componentInstance.testB.a.injector).toBe('standalone');\n+       });\n+\n+    it('should not have access to the directive injector in a standalone injector from within a directive-level provider factory',\n+       () => {\n+         class TestA {\n+           constructor(public injector: string) {}\n+         }\n+         class TestB {\n+           constructor(public a: TestA|null) {}\n+         }\n+\n+         function createTestB() {\n+           // Setup a standalone injector that provides `TestB` with an optional dependency of\n+           // `TestA`. Since `TestA` is not provided by the standalone injector it should resolve\n+           // to null; both the NgModule providers and the component-level providers should not\n+           // be considered.\n+           const injector = Injector.create({\n+             providers: [{provide: TestB, useClass: TestB, deps: [[TestA, new Optional()]]}],\n+             name: 'TestB',\n+           });\n+           return injector.get(TestB);\n+         }\n+\n+         @Component({\n+           template: '',\n+           providers: [\n+             {provide: TestA, useFactory: () => new TestA('component'), deps: []},\n+             {provide: TestB, useFactory: createTestB},\n+           ],\n+         })\n+         class MyComp {\n+           constructor(public readonly testB: TestB) {}\n+         }\n+\n+         TestBed.configureTestingModule({\n+           declarations: [MyComp],\n+           providers: [{provide: TestA, useFactory: () => new TestA('module'), deps: []}]\n+         });\n+\n+         const cmp = TestBed.createComponent(MyComp);\n+         expect(cmp.componentInstance.testB).toBeInstanceOf(TestB);\n+         expect(cmp.componentInstance.testB.a).toBeNull();\n+       });\n+\n     onlyInIvy('Ivy has different error message for circular dependency')\n         .it('should throw if directives try to inject each other', () => {\n           @Directive({selector: '[dirB]'})"
        },
        {
            "sha": "4ebbb42bb3bc0481a519a532e47a23da4b2afdac",
            "filename": "packages/core/test/bundling/injection/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/307dac67bc933ab3b017333b3085af8fba8193dc/packages%2Fcore%2Ftest%2Fbundling%2Finjection%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/307dac67bc933ab3b017333b3085af8fba8193dc/packages%2Fcore%2Ftest%2Fbundling%2Finjection%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Finjection%2Fbundle.golden_symbols.json?ref=307dac67bc933ab3b017333b3085af8fba8193dc",
            "patch": "@@ -92,6 +92,9 @@\n   {\n     \"name\": \"injectArgs\"\n   },\n+  {\n+    \"name\": \"injectInjectorOnly\"\n+  },\n   {\n     \"name\": \"injectableDefOrInjectorDefFactory\"\n   },\n@@ -110,6 +113,9 @@\n   {\n     \"name\": \"setCurrentInjector\"\n   },\n+  {\n+    \"name\": \"setInjectImplementation\"\n+  },\n   {\n     \"name\": \"stringify\"\n   },"
        }
    ],
    "stats": {
        "total": 100,
        "additions": 98,
        "deletions": 2
    }
}