{
    "author": "SijmenHuizenga",
    "message": "docs: import in-memory-web-api readme (#40203)\n\nIn #37182 the in-memory-web-api module was moved into this repo.\nCopy the reamde into this repo with the following changes:\n * Removed Travis badges\n * Updated github links to point to Angular repo\n * Removed 'running tests' as it is no longer relevant\n\nFixes #40190\n\nPR Close #40203",
    "sha": "14389755e6a427970a8e291389f5f4e276d551e3",
    "files": [
        {
            "sha": "e2eb48b07a75f7b07de10540644e66f009376520",
            "filename": "packages/misc/angular-in-memory-web-api/README.md",
            "status": "added",
            "additions": 388,
            "deletions": 0,
            "changes": 388,
            "blob_url": "https://github.com/angular/angular/blob/14389755e6a427970a8e291389f5f4e276d551e3/packages%2Fmisc%2Fangular-in-memory-web-api%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/14389755e6a427970a8e291389f5f4e276d551e3/packages%2Fmisc%2Fangular-in-memory-web-api%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fmisc%2Fangular-in-memory-web-api%2FREADME.md?ref=14389755e6a427970a8e291389f5f4e276d551e3",
            "patch": "@@ -0,0 +1,388 @@\n+# Angular in-memory-web-api\n+\n+An in-memory web api for Angular demos and tests\n+that emulates CRUD operations over a RESTy API.\n+\n+It intercepts Angular `Http` and `HttpClient` requests that would otherwise go to the remote server and redirects them to an in-memory data store that you control.\n+\n+See [Austin McDaniel's article](https://medium.com/@amcdnl/mocking-with-angular-more-than-just-unit-testing-cbb7908c9fcc) \n+for a quick introduction.\n+\n+_This package used to live [in its own repository](https://github.com/angular/in-memory-web-api)._\n+\n+### _It used to work and now it doesn't :-(_\n+\n+Perhaps you installed a new version of this library? Check the \n+[CHANGELOG.md](https://github.com/angular/angular/blob/master/packages/misc/angular-in-memory-web-api/CHANGELOG.md) \n+for breaking changes that may have affected your app.\n+\n+If that doesn't explain it, create an \n+[issue on github](https://github.com/angular/angular/issues),\n+preferably with a small repro.\n+\n+## Use cases\n+\n+* Demo apps that need to simulate CRUD data persistence operations without a real server.\n+You won't have to build and start a test server.\n+\n+* Whip up prototypes and proofs of concept.\n+\n+* Share examples with the community in a web coding environment such as Plunker or CodePen.\n+Create Angular issues and StackOverflow answers supported by live code.\n+\n+* Simulate operations against data collections that aren't yet implemented on your dev/test server. \n+You can pass requests thru to the dev/test server for collections that are supported.\n+\n+* Write unit test apps that read and write data.\n+Avoid the hassle of intercepting multiple http calls and manufacturing sequences of responses.\n+The in-memory data store resets for each test so there is no cross-test data pollution.\n+\n+* End-to-end tests. If you can toggle the app into test mode\n+using the in-memory web api, you won't disturb the real database.\n+This can be especially useful for CI (continuous integration) builds.\n+\n+\n+>**LIMITATIONS**\n+>\n+>The _in-memory-web-api_ exists primarily to support the \n+[Angular documentation](https://angular.io/docs/ts/latest/ \"Angular documentation web site\").\n+It is not supposed to emulate every possible real world web API and is not intended for production use.\n+>\n+>Most importantly, it is ***always experimental***. \n+We will make breaking changes and we won't feel bad about it \n+because this is a development tool, not a production product. \n+We do try to tell you about such changes in the `CHANGELOG.md`\n+and we fix bugs as fast as we can.\n+\n+## HTTP request handling\n+This in-memory web api service processes an HTTP request and \n+returns an `Observable` of HTTP `Response` object\n+in the manner of a RESTy web api.\n+It natively handles URI patterns in the form `:base/:collectionName/:id?`\n+\n+Examples:\n+```ts\n+  // for requests to an `api` base URL that gets heroes from a 'heroes' collection \n+  GET api/heroes          // all heroes\n+  GET api/heroes/42       // the hero with id=42\n+  GET api/heroes?name=^j  // 'j' is a regex; returns heroes whose name starting with 'j' or 'J'\n+  GET api/heroes.json/42  // ignores the \".json\"\n+```\n+\n+The in-memory web api service processes these requests against a \"database\" - a set of named collections - that you define during setup.\n+\n+## Basic setup\n+\n+<a id=\"createDb\"></a>\n+\n+Create an `InMemoryDataService` class that implements `InMemoryDbService`.\n+\n+At minimum it must implement `createDb` which \n+creates a \"database\" hash whose keys are collection names\n+and whose values are arrays of collection objects to return or update.\n+For example:\n+```ts\n+import { InMemoryDbService } from 'angular-in-memory-web-api';\n+\n+export class InMemHeroService implements InMemoryDbService {\n+  createDb() {\n+    let heroes = [\n+      { id: 1, name: 'Windstorm' },\n+      { id: 2, name: 'Bombasto' },\n+      { id: 3, name: 'Magneta' },\n+      { id: 4, name: 'Tornado' }\n+    ];\n+    return {heroes};\n+  }\n+}\n+```\n+\n+**Notes**\n+\n+* The in-memory web api library _currently_ assumes that every collection has a primary key called `id`.\n+\n+* The `createDb` method can be synchronous or asynchronous.\n+It would have to be asynchronous if you initialized your in-memory database service from a JSON file.\n+Return the database _object_, an _observable_ of that object, or a _promise_ of that object. The tests include an example of all three.\n+\n+* The in-memory web api calls your `InMemoryDbService` data service class's  `createDb` method on two occasions.\n+\n+  1. when it handles the _first_ HTTP request \n+  1. when it receives a `resetdb` [command](#commands).\n+\n+  In the command case, the service passes in a `RequestInfo` object,\n+  enabling the `createDb` logic to adjust its behavior per the client request. See the tests for examples.\n+\n+### Import the in-memory web api module\n+\n+Register your data store service implementation with the `HttpClientInMemoryWebApiModule`\n+in your root `AppModule.imports`\n+calling the `forRoot` static method with this service class and an optional configuration object:\n+```ts\n+import { HttpClientModule } from '@angular/common/http';\n+import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';\n+\n+import { InMemHeroService } from '../app/hero.service';\n+\n+@NgModule({\n+ imports: [\n+   HttpClientModule,\n+   HttpClientInMemoryWebApiModule.forRoot(InMemHeroService),\n+   ...\n+ ],\n+ ...\n+})\n+export class AppModule { ... }\n+```\n+\n+**_Notes_**\n+\n+* Always import the `HttpClientInMemoryWebApiModule` _after_ the `HttpClientModule` \n+to ensure that the in-memory backend provider supersedes the Angular version.\n+\n+* You can setup the in-memory web api within a lazy loaded feature module by calling the `.forFeature` method as you would `.forRoot`.\n+\n+* In production, you want HTTP requests to go to the real server and probably have no need for the _in-memory_ provider.\n+CLI-based apps can exclude the provider in production builds like this:\n+  ```ts\n+  imports: [\n+    HttpClientModule,\n+    environment.production ?\n+      [] : HttpClientInMemoryWebApiModule.forRoot(InMemHeroService)\n+    ...\n+  ]\n+  ```\n+\n+# Examples\n+The [tests](https://github.com/angular/angular/blob/master/packages/misc/angular-in-memory-web-api/test)\n+are a good place to learn how to setup and use this in-memory web api library.\n+\n+See also the example source code in the official Angular.io documentation such as the\n+[HttpClient](https://angular.io/guide/http) guide and the\n+[Tour of Heroes](https://angular.io/tutorial/toh-pt6). \n+\n+# Advanced Features\n+Some features are not readily apparent in the basic usage described above.\n+\n+## Configuration arguments\n+\n+The `InMemoryBackendConfigArgs` defines a set of options. Add them as the second `forRoot` argument:\n+```ts\n+  InMemoryWebApiModule.forRoot(InMemHeroService, { delay: 500 }),\n+```\n+\n+**Read the `InMemoryBackendConfigArgs` interface to learn about these options**.\n+\n+\n+## Request evaluation order\n+This service can evaluate requests in multiple ways depending upon the configuration.\n+Here's how it reasons:\n+1. If it looks like a [command](#commands), process as a command.\n+2. If the [HTTP method is overridden](#method-override), try the override.\n+3. If the resource name (after the api base path) matches one of the configured collections, process that.\n+4. If not but the `Config.passThruUnknownUrl` flag is `true`, try to [pass the request along to a real _XHR_](#passthru).\n+5. Return a 404.\n+\n+See the `handleRequest` method implementation for details.\n+\n+## Default delayed response\n+\n+By default this service adds a 500ms delay \n+to all data requests to simulate round-trip latency.\n+\n+>[Command requests](#commands) have zero added delay as they concern \n+in-memory service configuration and do not emulate real data requests.\n+\n+You can change or eliminate the latency by setting a different `delay` value:\n+```ts\n+  InMemoryWebApiModule.forRoot(InMemHeroService, { delay: 0 }),    // no delay\n+  InMemoryWebApiModule.forRoot(InMemHeroService, { delay: 1500 }), // 1.5 second delay\n+```\n+\n+## Simple query strings\n+Pass custom filters as a regex pattern via query string. \n+The query string defines which property and value to match.\n+\n+Format: `/app/heroes/?propertyName=regexPattern`\n+\n+The following example matches all names that start with the letter 'j' or 'J' in the heroes collection.\n+\n+`/app/heroes/?name=^j`\n+\n+>Search pattern matches are case insensitive by default. \n+Set `config.caseSensitiveSearch = true` if needed.\n+\n+<a id=\"passthru\"></a>\n+## Pass thru to a live server\n+\n+If an existing, running remote server should handle requests for collections \n+that are not in the in-memory database, set `Config.passThruUnknownUrl: true`.\n+Then this service will forward unrecognized requests to the remote server\n+via the Angular default `XHR` backend (it depends on whether your using `Http` or `HttpClient`).\n+\n+<a id=\"commands\"></a>\n+## Commands\n+\n+The client may issue a command request to get configuration state\n+from the in-memory web api service, reconfigure it, \n+or reset the in-memory database.\n+\n+When the last segment of the _api base path_ is \"commands\", the `collectionName` is treated as the _command_.\n+\n+Example URLs:\n+```sh\n+  commands/resetdb   // Reset the \"database\" to its original state\n+  commands/config    // Get or update this service's config object\n+```\n+\n+Usage:\n+```sh\n+  http.post('commands/resetdb', undefined);\n+  http.get('commands/config');\n+  http.post('commands/config', '{\"delay\":1000}');\n+```\n+\n+Command requests do not simulate real remote data access.\n+They ignore the latency delay and respond as quickly as possible.\n+\n+The `resetDb` command\n+calls your `InMemoryDbService` data service's  [`createDb` method](#createDb) with the `RequestInfo` object,\n+enabling the `createDb` logic to adjust its behavior per the client request.\n+\n+In the following example, the client includes a reset option in the command request body:\n+```ts\n+http\n+  // Reset the database collections with the `clear` option\n+  .post('commands/resetDb', { clear: true }))\n+\n+  // when command finishes, get heroes\n+  .concatMap(\n+    ()=> http.get<Data>('api/heroes')\n+        .map(data => data.data as Hero[])\n+  )\n+\n+  // execute the request sequence and \n+  // do something with the heroes\n+  .subscribe(...)\n+```\n+\n+See the tests for other examples.\n+\n+## _parseRequestUrl_\n+\n+The `parseRequestUrl` parses the request URL into a `ParsedRequestUrl` object.\n+`ParsedRequestUrl` is a public interface whose properties guide the in-memory web api\n+as it processes the request.\n+\n+### Default _parseRequestUrl_\n+\n+Default parsing depends upon certain values of `config`: `apiBase`, `host`, and `urlRoot`.\n+Read the source code for the complete story.\n+\n+Configuring the `apiBase` yields the most interesting changes to `parseRequestUrl` behavior:\n+\n+* For `apiBase=undefined` and `url='http://localhost/api/customers/42'`\n+    ```ts\n+    {apiBase: 'api/', collectionName: 'customers', id: '42', ...}\n+    ```\n+\n+*  For `apiBase='some/api/root/'` and `url='http://localhost/some/api/root/customers'`\n+    ```ts\n+    { apiBase: 'some/api/root/', collectionName: 'customers', id: undefined, ... }\n+    ```\n+\n+*  For `apiBase='/'` and `url='http://localhost/customers'`\n+    ```ts\n+    { apiBase: '/', collectionName: 'customers', id: undefined, ... }\n+    ```\n+\n+**The actual api base segment values are ignored**. Only the number of segments matters.\n+The following api base strings are considered identical: 'a/b' ~ 'some/api/' ~ `two/segments'\n+\n+This means that URLs that work with the in-memory web api may be rejected by the real server.\n+\n+### Custom _parseRequestUrl_\n+\n+You can override the default parser by implementing a `parseRequestUrl` method in your `InMemoryDbService`.\n+\n+The service calls your method with two arguments.\n+1. `url` - the request URL string\n+1. `requestInfoUtils` - utility methods in a `RequestInfoUtilities` object, including the default parser.\n+Note that some values have not yet been set as they depend on the outcome of parsing.\n+\n+Your method must either return a `ParsedRequestUrl` object or `null`|`undefined`,\n+in which case the service uses the default parser.\n+In this way you can intercept and parse some URLs and leave the others to the default parser.\n+\n+## Custom _genId_\n+\n+Collection items are presumed to have a primary key property called `id`.\n+\n+You can specify the `id` while adding a new item. \n+The service will blindly use that `id`; it does not check for uniqueness.\n+\n+If you do not specify the `id`, the service generates one via the `genId` method.\n+\n+You can override the default id generator with a method called `genId` in your `InMemoryDbService`.\n+Your method receives the new item's collection and collection name. \n+It should return the generated id.\n+If your generator returns `null`|`undefined`, the service uses the default generator. \n+\n+## _responseInterceptor_\n+\n+You can change the response returned by the service's default HTTP methods.\n+A typical reason to intercept is to add a header that your application is expecting.\n+\n+To intercept responses, add a `responseInterceptor` method to your `InMemoryDbService` class. \n+The service calls your interceptor like this:\n+```ts\n+responseOptions = this.responseInterceptor(responseOptions, requestInfo);\n+```\n+\n+<a id=\"method-override\"></a>\n+## HTTP method interceptors\n+\n+You may have HTTP requests that the in-memory web api can't handle properly.\n+\n+You can override any HTTP method by implementing a method \n+of that name in your `InMemoryDbService`.\n+\n+Your method's name must be the same as the HTTP method name but **all lowercase**.\n+The in-memory web api calls it with a `RequestInfo` object that contains request data and utility methods.\n+\n+For example, if you implemented a `get` method, the web api would be called like this:\n+`yourInMemDbService[\"get\"](requestInfo)`.\n+\n+Your custom HTTP method must return either:\n+\n+* `Observable<Response>` - you handled the request and the response is available from this\n+observable.  It _should be \"cold\"_.\n+\n+* `null`/`undefined` - you decided not to intervene, \n+perhaps because you wish to intercept only certain paths for the given HTTP method.\n+The service continues with its default processing of the HTTP request.\n+\n+The `RequestInfo` is an interface defined in `src/in-mem/interfaces.ts`. \n+Its members include:\n+```ts\n+req: Request;           // the request object from the client\n+collectionName: string; // calculated from the request url\n+collection: any[];      // the corresponding collection (if found)\n+id: any;                // the item `id` (if specified)\n+url: string;            // the url in the request\n+utils: RequestInfoUtilities; // helper functions\n+```\n+The functions in `utils` can help you analyze the request\n+and compose a response.\n+\n+## In-memory Web Api Examples\n+\n+The [test fixtures](https://github.com/angular/angular/tree/master/packages/misc/angular-in-memory-web-api/test/fixtures)\n+demonstrates library usage with tested examples.\n+\n+The `HeroInMemDataService` class (in `test/fixtures/hero-in-mem-data-service.ts`) is a Hero-oriented `InMemoryDbService`\n+such as you might see in an HTTP sample in the Angular documentation.\n+\n+The `HeroInMemDataOverrideService` class (in `test/fixtures/hero-in-mem-data-override-service.ts`)\n+demonstrates a few ways to override methods of the base `HeroInMemDataService`.\n+"
        }
    ],
    "stats": {
        "total": 388,
        "additions": 388,
        "deletions": 0
    }
}