{
    "author": "zarend",
    "message": "fix(compiler-cli): don't crash when we can't resolve a resource (#40660)\n\nProduces a diagnostic when we cannot resolve a component's external style sheet or external template.\n\nThe previous behavior was to throw an exception, which crashed the\nLanguage Service.\n\nfixes angular/vscode-ng-language-service#1079\n\nPR Close #40660",
    "sha": "378da71f276a0278fb0cc120b57a127ff3b587cc",
    "files": [
        {
            "sha": "a723b96758b5071039cc52220ebd75a175ff6d29",
            "filename": "goldens/public-api/compiler-cli/error_code.d.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/378da71f276a0278fb0cc120b57a127ff3b587cc/goldens%2Fpublic-api%2Fcompiler-cli%2Ferror_code.d.ts",
            "raw_url": "https://github.com/angular/angular/raw/378da71f276a0278fb0cc120b57a127ff3b587cc/goldens%2Fpublic-api%2Fcompiler-cli%2Ferror_code.d.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fpublic-api%2Fcompiler-cli%2Ferror_code.d.ts?ref=378da71f276a0278fb0cc120b57a127ff3b587cc",
            "patch": "@@ -14,6 +14,7 @@ export declare enum ErrorCode {\n     UNDECORATED_PROVIDER = 2005,\n     DIRECTIVE_INHERITS_UNDECORATED_CTOR = 2006,\n     UNDECORATED_CLASS_USING_ANGULAR_FEATURES = 2007,\n+    COMPONENT_RESOURCE_NOT_FOUND = 2008,\n     SYMBOL_NOT_EXPORTED = 3001,\n     SYMBOL_EXPORTED_UNDER_DIFFERENT_NAME = 3002,\n     CONFIG_FLAT_MODULE_NO_INDEX = 4001,"
        },
        {
            "sha": "2769b064cd2b7838788da668e54f4d3285616d1d",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 193,
            "deletions": 58,
            "changes": 251,
            "blob_url": "https://github.com/angular/angular/blob/378da71f276a0278fb0cc120b57a127ff3b587cc/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/378da71f276a0278fb0cc120b57a127ff3b587cc/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=378da71f276a0278fb0cc120b57a127ff3b587cc",
            "patch": "@@ -16,7 +16,7 @@ import {DefaultImportRecorder, ModuleResolver, Reference, ReferenceEmitter} from\n import {DependencyTracker} from '../../incremental/api';\n import {IndexingContext} from '../../indexer';\n import {ClassPropertyMapping, ComponentResources, DirectiveMeta, DirectiveTypeCheckMeta, extractDirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry, Resource, ResourceRegistry} from '../../metadata';\n-import {EnumValue, PartialEvaluator} from '../../partial_evaluator';\n+import {EnumValue, PartialEvaluator, ResolvedValue} from '../../partial_evaluator';\n import {ClassDeclaration, DeclarationNode, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n import {ComponentScopeReader, LocalModuleScopeRegistry, TypeCheckScopeRegistry} from '../../scope';\n import {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerFlags, HandlerPrecedence, ResolveResult} from '../../transform';\n@@ -72,9 +72,9 @@ export interface ComponentAnalysisData {\n   resources: ComponentResources;\n \n   /**\n-   * The literal `styleUrls` extracted from the decorator, if present.\n+   * `styleUrls` extracted from the decorator, if present.\n    */\n-  styleUrls: string[]|null;\n+  styleUrls: StyleUrlMeta[]|null;\n \n   /**\n    * Inline stylesheets extracted from the decorator, if present.\n@@ -86,6 +86,31 @@ export interface ComponentAnalysisData {\n \n export type ComponentResolutionData = Pick<R3ComponentMetadata, ComponentMetadataResolvedFields>;\n \n+/**\n+ * The literal style url extracted from the decorator, along with metadata for diagnostics.\n+ */\n+export interface StyleUrlMeta {\n+  url: string;\n+  nodeForError: ts.Node;\n+  source: ResourceTypeForDiagnostics.StylesheetFromTemplate|\n+      ResourceTypeForDiagnostics.StylesheetFromDecorator;\n+}\n+\n+/**\n+ * Information about the origin of a resource in the application code. This is used for creating\n+ * diagnostics, so we can point to the root cause of an error in the application code.\n+ *\n+ * A template resource comes from the `templateUrl` property on the component decorator.\n+ *\n+ * Stylesheets resources can come from either the `styleUrls` property on the component decorator,\n+ * or from inline `style` tags and style links on the external template.\n+ */\n+export const enum ResourceTypeForDiagnostics {\n+  Template,\n+  StylesheetFromTemplate,\n+  StylesheetFromDecorator,\n+}\n+\n /**\n  * `DecoratorHandler` which handles the `@Component` annotation.\n  */\n@@ -157,33 +182,48 @@ export class ComponentDecoratorHandler implements\n     const component = reflectObjectLiteral(meta);\n     const containingFile = node.getSourceFile().fileName;\n \n-    // Convert a styleUrl string into a Promise to preload it.\n-    const resolveStyleUrl = (styleUrl: string): Promise<void> => {\n-      const resourceUrl = this.resourceLoader.resolve(styleUrl, containingFile);\n-      const promise = this.resourceLoader.preload(resourceUrl);\n-      return promise || Promise.resolve();\n-    };\n+    const resolveStyleUrl =\n+        (styleUrl: string, nodeForError: ts.Node,\n+         resourceType: ResourceTypeForDiagnostics): Promise<void>|undefined => {\n+          const resourceUrl =\n+              this._resolveResourceOrThrow(styleUrl, containingFile, nodeForError, resourceType);\n+          return this.resourceLoader.preload(resourceUrl);\n+        };\n \n     // A Promise that waits for the template and all <link>ed styles within it to be preloaded.\n     const templateAndTemplateStyleResources =\n-        this._preloadAndParseTemplate(node, decorator, component, containingFile).then(template => {\n-          if (template === null) {\n-            return undefined;\n-          } else {\n-            return Promise.all(template.styleUrls.map(resolveStyleUrl)).then(() => undefined);\n-          }\n-        });\n+        this._preloadAndParseTemplate(node, decorator, component, containingFile)\n+            .then((template: ParsedTemplateWithSource|null): Promise<void>|undefined => {\n+              if (template === null) {\n+                return undefined;\n+              }\n+\n+              const nodeForError = getTemplateDeclarationNodeForError(template.declaration);\n+              return Promise\n+                  .all(template.styleUrls.map(\n+                      styleUrl => resolveStyleUrl(\n+                          styleUrl, nodeForError,\n+                          ResourceTypeForDiagnostics.StylesheetFromTemplate)))\n+                  .then(() => undefined);\n+            });\n \n     // Extract all the styleUrls in the decorator.\n-    const styleUrls = this._extractStyleUrls(component, []);\n+    const componentStyleUrls = this._extractComponentStyleUrls(component);\n \n-    if (styleUrls === null) {\n+    if (componentStyleUrls === null) {\n       // A fast path exists if there are no styleUrls, to just wait for\n       // templateAndTemplateStyleResources.\n       return templateAndTemplateStyleResources;\n     } else {\n       // Wait for both the template and all styleUrl resources to resolve.\n-      return Promise.all([templateAndTemplateStyleResources, ...styleUrls.map(resolveStyleUrl)])\n+      return Promise\n+          .all([\n+            templateAndTemplateStyleResources,\n+            ...componentStyleUrls.map(\n+                styleUrl => resolveStyleUrl(\n+                    styleUrl.url, styleUrl.nodeForError,\n+                    ResourceTypeForDiagnostics.StylesheetFromDecorator))\n+          ])\n           .then(() => undefined);\n     }\n   }\n@@ -268,41 +308,37 @@ export class ComponentDecoratorHandler implements\n     // Figure out the set of styles. The ordering here is important: external resources (styleUrls)\n     // precede inline styles, and styles defined in the template override styles defined in the\n     // component.\n-    let styles: string[]|null = null;\n+    let styles: string[] = [];\n \n     const styleResources = this._extractStyleResources(component, containingFile);\n-    const styleUrls = this._extractStyleUrls(component, template.styleUrls);\n-    if (styleUrls !== null) {\n-      if (styles === null) {\n-        styles = [];\n-      }\n-      for (const styleUrl of styleUrls) {\n-        const resourceUrl = this.resourceLoader.resolve(styleUrl, containingFile);\n-        const resourceStr = this.resourceLoader.load(resourceUrl);\n-        styles.push(resourceStr);\n-        if (this.depTracker !== null) {\n-          this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));\n-        }\n+    const styleUrls: StyleUrlMeta[] = [\n+      ...this._extractComponentStyleUrls(component), ...this._extractTemplateStyleUrls(template)\n+    ];\n+\n+    for (const styleUrl of styleUrls) {\n+      const resourceType = styleUrl.source === ResourceTypeForDiagnostics.StylesheetFromDecorator ?\n+          ResourceTypeForDiagnostics.StylesheetFromDecorator :\n+          ResourceTypeForDiagnostics.StylesheetFromTemplate;\n+      const resourceUrl = this._resolveResourceOrThrow(\n+          styleUrl.url, containingFile, styleUrl.nodeForError, resourceType);\n+      const resourceStr = this.resourceLoader.load(resourceUrl);\n+\n+      styles.push(resourceStr);\n+      if (this.depTracker !== null) {\n+        this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));\n       }\n     }\n+\n     let inlineStyles: string[]|null = null;\n     if (component.has('styles')) {\n       const litStyles = parseFieldArrayValue(component, 'styles', this.evaluator);\n       if (litStyles !== null) {\n         inlineStyles = [...litStyles];\n-        if (styles === null) {\n-          styles = litStyles;\n-        } else {\n-          styles.push(...litStyles);\n-        }\n+        styles.push(...litStyles);\n       }\n     }\n     if (template.styles.length > 0) {\n-      if (styles === null) {\n-        styles = template.styles;\n-      } else {\n-        styles.push(...template.styles);\n-      }\n+      styles.push(...template.styles);\n     }\n \n     const encapsulation: number =\n@@ -329,7 +365,7 @@ export class ComponentDecoratorHandler implements\n           },\n           encapsulation,\n           interpolation: template.interpolationConfig ?? DEFAULT_INTERPOLATION_CONFIG,\n-          styles: styles || [],\n+          styles,\n \n           // These will be replaced during the compilation step, after all `NgModule`s have been\n           // analyzed and the full compilation scope for the component can be realized.\n@@ -609,7 +645,12 @@ export class ComponentDecoratorHandler implements\n     let styles: string[] = [];\n     if (analysis.styleUrls !== null) {\n       for (const styleUrl of analysis.styleUrls) {\n-        const resolvedStyleUrl = this.resourceLoader.resolve(styleUrl, containingFile);\n+        const resourceType =\n+            styleUrl.source === ResourceTypeForDiagnostics.StylesheetFromDecorator ?\n+            ResourceTypeForDiagnostics.StylesheetFromDecorator :\n+            ResourceTypeForDiagnostics.StylesheetFromTemplate;\n+        const resolvedStyleUrl = this._resolveResourceOrThrow(\n+            styleUrl.url, containingFile, styleUrl.nodeForError, resourceType);\n         const styleText = this.resourceLoader.load(resolvedStyleUrl);\n         styles.push(styleText);\n       }\n@@ -705,20 +746,54 @@ export class ComponentDecoratorHandler implements\n     return resolved;\n   }\n \n-  private _extractStyleUrls(component: Map<string, ts.Expression>, extraUrls: string[]):\n-      string[]|null {\n+  private _extractComponentStyleUrls(\n+      component: Map<string, ts.Expression>,\n+      ): StyleUrlMeta[] {\n     if (!component.has('styleUrls')) {\n-      return extraUrls.length > 0 ? extraUrls : null;\n+      return [];\n     }\n \n-    const styleUrlsExpr = component.get('styleUrls')!;\n-    const styleUrls = this.evaluator.evaluate(styleUrlsExpr);\n-    if (!Array.isArray(styleUrls) || !styleUrls.every(url => typeof url === 'string')) {\n-      throw createValueHasWrongTypeError(\n-          styleUrlsExpr, styleUrls, 'styleUrls must be an array of strings');\n+    return this._extractStyleUrlsFromExpression(component.get('styleUrls')!);\n+  }\n+\n+  private _extractStyleUrlsFromExpression(styleUrlsExpr: ts.Expression): StyleUrlMeta[] {\n+    const styleUrls: StyleUrlMeta[] = [];\n+\n+    if (ts.isArrayLiteralExpression(styleUrlsExpr)) {\n+      for (const styleUrlExpr of styleUrlsExpr.elements) {\n+        if (ts.isSpreadElement(styleUrlExpr)) {\n+          styleUrls.push(...this._extractStyleUrlsFromExpression(styleUrlExpr.expression));\n+        } else {\n+          const styleUrl = this.evaluator.evaluate(styleUrlExpr);\n+\n+          if (typeof styleUrl !== 'string') {\n+            throw createValueHasWrongTypeError(styleUrlExpr, styleUrl, 'styleUrl must be a string');\n+          }\n+\n+          styleUrls.push({\n+            url: styleUrl,\n+            source: ResourceTypeForDiagnostics.StylesheetFromDecorator,\n+            nodeForError: styleUrlExpr,\n+          });\n+        }\n+      }\n+    } else {\n+      const evaluatedStyleUrls = this.evaluator.evaluate(styleUrlsExpr);\n+      if (!isStringArray(evaluatedStyleUrls)) {\n+        throw createValueHasWrongTypeError(\n+            styleUrlsExpr, evaluatedStyleUrls, 'styleUrls must be an array of strings');\n+      }\n+\n+      for (const styleUrl of evaluatedStyleUrls) {\n+        styleUrls.push({\n+          url: styleUrl,\n+          source: ResourceTypeForDiagnostics.StylesheetFromDecorator,\n+          nodeForError: styleUrlsExpr,\n+        });\n+      }\n     }\n-    styleUrls.push(...extraUrls);\n-    return styleUrls as string[];\n+\n+    return styleUrls;\n   }\n \n   private _extractStyleResources(component: Map<string, ts.Expression>, containingFile: string):\n@@ -734,7 +809,9 @@ export class ComponentDecoratorHandler implements\n     const styleUrlsExpr = component.get('styleUrls');\n     if (styleUrlsExpr !== undefined && ts.isArrayLiteralExpression(styleUrlsExpr)) {\n       for (const expression of stringLiteralElements(styleUrlsExpr)) {\n-        const resourceUrl = this.resourceLoader.resolve(expression.text, containingFile);\n+        const resourceUrl = this._resolveResourceOrThrow(\n+            expression.text, containingFile, expression,\n+            ResourceTypeForDiagnostics.StylesheetFromDecorator);\n         styles.add({path: absoluteFrom(resourceUrl), expression});\n       }\n     }\n@@ -751,7 +828,7 @@ export class ComponentDecoratorHandler implements\n \n   private _preloadAndParseTemplate(\n       node: ClassDeclaration, decorator: Decorator, component: Map<string, ts.Expression>,\n-      containingFile: string): Promise<ParsedTemplate|null> {\n+      containingFile: string): Promise<ParsedTemplateWithSource|null> {\n     if (component.has('templateUrl')) {\n       // Extract the templateUrl and preload it.\n       const templateUrlExpr = component.get('templateUrl')!;\n@@ -760,7 +837,8 @@ export class ComponentDecoratorHandler implements\n         throw createValueHasWrongTypeError(\n             templateUrlExpr, templateUrl, 'templateUrl must be a string');\n       }\n-      const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n+      const resourceUrl = this._resolveResourceOrThrow(\n+          templateUrl, containingFile, templateUrlExpr, ResourceTypeForDiagnostics.Template);\n       const templatePromise = this.resourceLoader.preload(resourceUrl);\n \n       // If the preload worked, then actually load and parse the template, and wait for any style\n@@ -936,7 +1014,8 @@ export class ComponentDecoratorHandler implements\n         throw createValueHasWrongTypeError(\n             templateUrlExpr, templateUrl, 'templateUrl must be a string');\n       }\n-      const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n+      const resourceUrl = this._resolveResourceOrThrow(\n+          templateUrl, containingFile, templateUrlExpr, ResourceTypeForDiagnostics.Template);\n \n       return {\n         isInline: false,\n@@ -991,6 +1070,45 @@ export class ComponentDecoratorHandler implements\n \n     this.cycleAnalyzer.recordSyntheticImport(origin, imported);\n   }\n+\n+  /**\n+   * Resolve the url of a resource relative to the file that contains the reference to it.\n+   *\n+   * Throws a FatalDiagnosticError when unable to resolve the file.\n+   */\n+  private _resolveResourceOrThrow(\n+      file: string, basePath: string, nodeForError: ts.Node,\n+      resourceType: ResourceTypeForDiagnostics): string {\n+    try {\n+      return this.resourceLoader.resolve(file, basePath);\n+    } catch (e) {\n+      let errorText: string;\n+      switch (resourceType) {\n+        case ResourceTypeForDiagnostics.Template:\n+          errorText = `Could not find template file '${file}'.`;\n+          break;\n+        case ResourceTypeForDiagnostics.StylesheetFromTemplate:\n+          errorText = `Could not find stylesheet file '${file}' linked from the template.`;\n+          break;\n+        case ResourceTypeForDiagnostics.StylesheetFromDecorator:\n+          errorText = `Could not find stylesheet file '${file}'.`;\n+          break;\n+      }\n+\n+      throw new FatalDiagnosticError(\n+          ErrorCode.COMPONENT_RESOURCE_NOT_FOUND, nodeForError, errorText);\n+    }\n+  }\n+\n+  private _extractTemplateStyleUrls(template: ParsedTemplateWithSource): StyleUrlMeta[] {\n+    if (template.styleUrls === null) {\n+      return [];\n+    }\n+\n+    const nodeForError = getTemplateDeclarationNodeForError(template.declaration);\n+    return template.styleUrls.map(\n+        url => ({url, source: ResourceTypeForDiagnostics.StylesheetFromTemplate, nodeForError}));\n+  }\n }\n \n function getTemplateRange(templateExpr: ts.Expression) {\n@@ -1016,6 +1134,23 @@ function sourceMapUrl(resourceUrl: string): string {\n   }\n }\n \n+/** Determines if the result of an evaluation is a string array. */\n+function isStringArray(resolvedValue: ResolvedValue): resolvedValue is string[] {\n+  return Array.isArray(resolvedValue) && resolvedValue.every(elem => typeof elem === 'string');\n+}\n+\n+/** Determines the node to use for debugging purposes for the given TemplateDeclaration. */\n+function getTemplateDeclarationNodeForError(declaration: TemplateDeclaration): ts.Node {\n+  // TODO(zarend): Change this to if/else when that is compatible with g3. This uses a switch\n+  // because if/else fails to compile on g3. That is because g3 compiles this in non-strict mode\n+  // where type inference does not work correctly.\n+  switch (declaration.isInline) {\n+    case true:\n+      return declaration.expression;\n+    case false:\n+      return declaration.templateUrlExpression;\n+  }\n+}\n \n /**\n  * Information about the template which was extracted during parsing."
        },
        {
            "sha": "d1fed60b829d643d12bdb137e0d80a6d88825d9d",
            "filename": "packages/compiler-cli/src/ngtsc/diagnostics/src/error_code.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/378da71f276a0278fb0cc120b57a127ff3b587cc/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Fsrc%2Ferror_code.ts",
            "raw_url": "https://github.com/angular/angular/raw/378da71f276a0278fb0cc120b57a127ff3b587cc/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Fsrc%2Ferror_code.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Fsrc%2Ferror_code.ts?ref=378da71f276a0278fb0cc120b57a127ff3b587cc",
            "patch": "@@ -44,6 +44,12 @@ export enum ErrorCode {\n    */\n   UNDECORATED_CLASS_USING_ANGULAR_FEATURES = 2007,\n \n+  /**\n+   * Raised when an component cannot resolve an external resource, such as a template or a style\n+   * sheet.\n+   */\n+  COMPONENT_RESOURCE_NOT_FOUND = 2008,\n+\n   SYMBOL_NOT_EXPORTED = 3001,\n   SYMBOL_EXPORTED_UNDER_DIFFERENT_NAME = 3002,\n "
        },
        {
            "sha": "cfe8fb32c2d0a94f79e3a5e7a5ea0543c49a5466",
            "filename": "packages/compiler-cli/test/ngtsc/ngtsc_spec.ts",
            "status": "modified",
            "additions": 65,
            "deletions": 0,
            "changes": 65,
            "blob_url": "https://github.com/angular/angular/blob/378da71f276a0278fb0cc120b57a127ff3b587cc/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/378da71f276a0278fb0cc120b57a127ff3b587cc/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts?ref=378da71f276a0278fb0cc120b57a127ff3b587cc",
            "patch": "@@ -7718,6 +7718,71 @@ export const Foo = Foo__PRE_R3__;\n         });\n       });\n     });\n+\n+    it('reports a COMPONENT_RESOURCE_NOT_FOUND for a component with a templateUrl' +\n+           ' that points to a non-existent file',\n+       () => {\n+         env.write('test.ts', `\n+                  import {Component} from '@angular/core';\n+                  @Component({\n+                    selector: 'test-component',\n+                    templateUrl: './non-existent-file.html'\n+                  })\n+                  class TestComponent {}\n+                `);\n+\n+         const diags = env.driveDiagnostics();\n+\n+         expect(diags.length).toEqual(1);\n+         expect(diags[0].code).toEqual(ngErrorCode(ErrorCode.COMPONENT_RESOURCE_NOT_FOUND));\n+         expect(diags[0].messageText)\n+             .toEqual(`Could not find template file './non-existent-file.html'.`);\n+       });\n+\n+    it(`reports a COMPONENT_RESOURCE_NOT_FOUND when style sheet link in a component's template` +\n+           ` does not exist`,\n+       () => {\n+         env.write('test.ts', `\n+                  import {Component} from '@angular/core';\n+                  @Component({\n+                    selector: 'test-component',\n+                    templateUrl: './test.html'\n+                  })\n+                  class TestComponent {}\n+                `);\n+         env.write('test.html', `\n+                  <link rel=\"stylesheet\" href=\"./non-existent-file.css\">\n+                  `);\n+\n+         const diags = env.driveDiagnostics();\n+\n+         expect(diags.length).toEqual(1);\n+         expect(diags[0].code).toEqual(ngErrorCode(ErrorCode.COMPONENT_RESOURCE_NOT_FOUND));\n+         expect(diags[0].messageText)\n+             .toEqual(\n+                 `Could not find stylesheet file './non-existent-file.css' linked from the template.`);\n+       });\n+\n+    it('reports a COMPONENT_RESOURCE_NOT_FOUND for a component with a style url ' +\n+           'defined in a spread that points to a non-existent file',\n+       () => {\n+         env.write('test.ts', `\n+                  import {Component} from '@angular/core';\n+                  @Component({\n+                    selector: 'test-component',\n+                    template: '',\n+                    styleUrls: [...['./non-existent-file.css']]\n+                  })\n+                  class TestComponent {}\n+                `);\n+\n+         const diags = env.driveDiagnostics();\n+\n+         expect(diags.length).toEqual(1);\n+         expect(diags[0].code).toEqual(ngErrorCode(ErrorCode.COMPONENT_RESOURCE_NOT_FOUND));\n+         expect(diags[0].messageText)\n+             .toEqual(`Could not find stylesheet file './non-existent-file.css'.`);\n+       });\n   });\n \n   function expectTokenAtPosition<T extends ts.Node>("
        }
    ],
    "stats": {
        "total": 323,
        "additions": 265,
        "deletions": 58
    }
}