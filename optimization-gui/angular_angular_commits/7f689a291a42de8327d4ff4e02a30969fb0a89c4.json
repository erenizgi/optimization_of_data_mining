{
    "author": "crisbeto",
    "message": "fix(compiler): incorrectly encapsulating @import containing colons and semicolons (#38716)\n\nAt a high level, the current shadow DOM shim logic works by escaping the content of a CSS rule\n(e.g. `div {color: red;}` becomes `div {%BLOCK%}`), using a regex to parse out things like the\nselector and the rule body, and then re-adding the content after the selector has been modified.\nThe problem is that the regex has to be very broad in order capture all of the different use cases,\nwhich can cause it to match strings suffixed with a semi-colon in some places where it shouldn't,\nlike this URL from Google Fonts `https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap`.\nMost of the time this is fine, because the logic that escapes the rule content to `%BLOCK%` will\nhave converted it to something that won't be matched by the regex. However, it breaks down for rules\nlike `@import` which don't have a body, but can still have quoted content with characters that can\nmatch the regex.\n\nThese changes resolve the issue by making a second pass over the escaped string and replacing all\nof the remaining quoted content with `%QUOTED%` before parsing it with the regex. Once everything\nhas been processed, we make a final pass where we restore the quoted content.\n\nIn a previous iteration of this PR, I went with a shorter approach which narrowed down the\nregex so that it doesn't capture rules without a body. It fixed the issue, but it also ended\nup breaking some of the more contrived unit test cases. I decided not to pursue it further, because\nwe would've ended up with a very long and brittle regex that likely would've broken in even weirder\nways.\n\nFixes #38587.\n\nPR Close #38716",
    "sha": "7f689a291a42de8327d4ff4e02a30969fb0a89c4",
    "files": [
        {
            "sha": "72463ca8174f24249076596cd034061a4c902cb2",
            "filename": "packages/compiler/src/shadow_css.ts",
            "status": "modified",
            "additions": 58,
            "deletions": 41,
            "changes": 99,
            "blob_url": "https://github.com/angular/angular/blob/7f689a291a42de8327d4ff4e02a30969fb0a89c4/packages%2Fcompiler%2Fsrc%2Fshadow_css.ts",
            "raw_url": "https://github.com/angular/angular/raw/7f689a291a42de8327d4ff4e02a30969fb0a89c4/packages%2Fcompiler%2Fsrc%2Fshadow_css.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fshadow_css.ts?ref=7f689a291a42de8327d4ff4e02a30969fb0a89c4",
            "patch": "@@ -555,66 +555,83 @@ function extractCommentsWithHash(input: string): string[] {\n   return input.match(_commentWithHashRe) || [];\n }\n \n-const _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\n-const _curlyRe = /([{}])/g;\n-const OPEN_CURLY = '{';\n-const CLOSE_CURLY = '}';\n const BLOCK_PLACEHOLDER = '%BLOCK%';\n+const QUOTE_PLACEHOLDER = '%QUOTED%';\n+const _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\n+const _quotedRe = /%QUOTED%/g;\n+const CONTENT_PAIRS = new Map([['{', '}']]);\n+const QUOTE_PAIRS = new Map([[`\"`, `\"`], [`'`, `'`]]);\n \n export class CssRule {\n   constructor(public selector: string, public content: string) {}\n }\n \n export function processRules(input: string, ruleCallback: (rule: CssRule) => CssRule): string {\n-  const inputWithEscapedBlocks = escapeBlocks(input);\n+  const inputWithEscapedQuotes = escapeBlocks(input, QUOTE_PAIRS, QUOTE_PLACEHOLDER);\n+  const inputWithEscapedBlocks =\n+      escapeBlocks(inputWithEscapedQuotes.escapedString, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\n   let nextBlockIndex = 0;\n-  return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function(...m: string[]) {\n-    const selector = m[2];\n-    let content = '';\n-    let suffix = m[4];\n-    let contentPrefix = '';\n-    if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n-      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n-      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n-      contentPrefix = '{';\n-    }\n-    const rule = ruleCallback(new CssRule(selector, content));\n-    return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n-  });\n+  let nextQuoteIndex = 0;\n+  return inputWithEscapedBlocks.escapedString\n+      .replace(\n+          _ruleRe,\n+          (...m: string[]) => {\n+            const selector = m[2];\n+            let content = '';\n+            let suffix = m[4];\n+            let contentPrefix = '';\n+            if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n+              content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n+              suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n+              contentPrefix = '{';\n+            }\n+            const rule = ruleCallback(new CssRule(selector, content));\n+            return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n+          })\n+      .replace(_quotedRe, () => inputWithEscapedQuotes.blocks[nextQuoteIndex++]);\n }\n \n class StringWithEscapedBlocks {\n   constructor(public escapedString: string, public blocks: string[]) {}\n }\n \n-function escapeBlocks(input: string): StringWithEscapedBlocks {\n-  const inputParts = input.split(_curlyRe);\n+function escapeBlocks(\n+    input: string, charPairs: Map<string, string>, placeholder: string): StringWithEscapedBlocks {\n   const resultParts: string[] = [];\n   const escapedBlocks: string[] = [];\n-  let bracketCount = 0;\n-  let currentBlockParts: string[] = [];\n-  for (let partIndex = 0; partIndex < inputParts.length; partIndex++) {\n-    const part = inputParts[partIndex];\n-    if (part == CLOSE_CURLY) {\n-      bracketCount--;\n-    }\n-    if (bracketCount > 0) {\n-      currentBlockParts.push(part);\n-    } else {\n-      if (currentBlockParts.length > 0) {\n-        escapedBlocks.push(currentBlockParts.join(''));\n-        resultParts.push(BLOCK_PLACEHOLDER);\n-        currentBlockParts = [];\n+  let openCharCount = 0;\n+  let nonBlockStartIndex = 0;\n+  let blockStartIndex = -1;\n+  let openChar: string|undefined;\n+  let closeChar: string|undefined;\n+  for (let i = 0; i < input.length; i++) {\n+    const char = input[i];\n+    if (char === '\\\\') {\n+      i++;\n+    } else if (char === closeChar) {\n+      openCharCount--;\n+      if (openCharCount === 0) {\n+        escapedBlocks.push(input.substring(blockStartIndex, i));\n+        resultParts.push(placeholder);\n+        nonBlockStartIndex = i;\n+        blockStartIndex = -1;\n+        openChar = closeChar = undefined;\n       }\n-      resultParts.push(part);\n-    }\n-    if (part == OPEN_CURLY) {\n-      bracketCount++;\n+    } else if (char === openChar) {\n+      openCharCount++;\n+    } else if (openCharCount === 0 && charPairs.has(char)) {\n+      openChar = char;\n+      closeChar = charPairs.get(char);\n+      openCharCount = 1;\n+      blockStartIndex = i + 1;\n+      resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\n     }\n   }\n-  if (currentBlockParts.length > 0) {\n-    escapedBlocks.push(currentBlockParts.join(''));\n-    resultParts.push(BLOCK_PLACEHOLDER);\n+  if (blockStartIndex !== -1) {\n+    escapedBlocks.push(input.substring(blockStartIndex));\n+    resultParts.push(placeholder);\n+  } else {\n+    resultParts.push(input.substring(nonBlockStartIndex));\n   }\n   return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n }"
        },
        {
            "sha": "ea9c771972124922f3aee89ef8b093612178d127",
            "filename": "packages/compiler/test/shadow_css_spec.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/7f689a291a42de8327d4ff4e02a30969fb0a89c4/packages%2Fcompiler%2Ftest%2Fshadow_css_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7f689a291a42de8327d4ff4e02a30969fb0a89c4/packages%2Fcompiler%2Ftest%2Fshadow_css_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fshadow_css_spec.ts?ref=7f689a291a42de8327d4ff4e02a30969fb0a89c4",
            "patch": "@@ -283,6 +283,28 @@ import {normalizeCSS} from '@angular/platform-browser/testing/src/browser_util';\n       expect(css).toEqual('@import url(\"a\"); div[contenta] {}');\n     });\n \n+    it('should shim rules with quoted content after @import', () => {\n+      const styleStr = '@import url(\"a\"); div {background-image: url(\"a.jpg\"); color: red;}';\n+      const css = s(styleStr, 'contenta');\n+      expect(css).toEqual(\n+          '@import url(\"a\"); div[contenta] {background-image:url(\"a.jpg\"); color:red;}');\n+    });\n+\n+    it('should pass through @import directives whose URL contains colons and semicolons', () => {\n+      const styleStr =\n+          '@import url(\"https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap\");';\n+      const css = s(styleStr, 'contenta');\n+      expect(css).toEqual(styleStr);\n+    });\n+\n+    it('should shim rules after @import with colons and semicolons', () => {\n+      const styleStr =\n+          '@import url(\"https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap\"); div {}';\n+      const css = s(styleStr, 'contenta');\n+      expect(css).toEqual(\n+          '@import url(\"https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap\"); div[contenta] {}');\n+    });\n+\n     it('should leave calc() unchanged', () => {\n       const styleStr = 'div {height:calc(100% - 55px);}';\n       const css = s(styleStr, 'contenta');\n@@ -312,6 +334,24 @@ import {normalizeCSS} from '@angular/platform-browser/testing/src/browser_util';\n       expect(s('/*# sourceMappingURL=data:x */b {c}/*# sourceURL=xxx */', 'contenta'))\n           .toEqual('b[contenta] {c}/*# sourceMappingURL=data:x *//*# sourceURL=xxx */');\n     });\n+\n+    it('should shim rules with quoted content', () => {\n+      const styleStr = 'div {background-image: url(\"a.jpg\"); color: red;}';\n+      const css = s(styleStr, 'contenta');\n+      expect(css).toEqual('div[contenta] {background-image:url(\"a.jpg\"); color:red;}');\n+    });\n+\n+    it('should shim rules with an escaped quote inside quoted content', () => {\n+      const styleStr = 'div::after { content: \"\\\\\"\" }';\n+      const css = s(styleStr, 'contenta');\n+      expect(css).toEqual('div[contenta]::after { content:\"\\\\\"\"}');\n+    });\n+\n+    it('should shim rules with curly braces inside quoted content', () => {\n+      const styleStr = 'div::after { content: \"{}\" }';\n+      const css = s(styleStr, 'contenta');\n+      expect(css).toEqual('div[contenta]::after { content:\"{}\"}');\n+    });\n   });\n \n   describe('processRules', () => {"
        }
    ],
    "stats": {
        "total": 139,
        "additions": 98,
        "deletions": 41
    }
}