{
    "author": "petebacondarwin",
    "message": "refactor(compiler): move `ParsedTemplate` interface to compiler (#38594)\n\nPreviously this interface was mostly stored in compiler-cli, but it\ncontains some properties that would be useful for compiling the\n\"declare component\" prelink code.\n\nThis commit moves some of the interface over to the compiler\npackage so that it can be referenced there without creating a\ncircular dependency between the compiler and compiler-cli.\n\nPR Close #38594",
    "sha": "687477279b3513f56294c54fe16152d966501044",
    "files": [
        {
            "sha": "9de9616075915420785a27b641d1d9718ff0629c",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 70,
            "changes": 93,
            "blob_url": "https://github.com/angular/angular/blob/687477279b3513f56294c54fe16152d966501044/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/687477279b3513f56294c54fe16152d966501044/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=687477279b3513f56294c54fe16152d966501044",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {compileComponentFromMetadata, ConstantPool, CssSelector, DEFAULT_INTERPOLATION_CONFIG, DomElementSchemaRegistry, Expression, ExternalExpr, Identifiers, InterpolationConfig, LexerRange, makeBindingParser, ParseError, ParseSourceFile, parseTemplate, ParseTemplateOptions, R3ComponentMetadata, R3FactoryTarget, R3TargetBinder, SchemaMetadata, SelectorMatcher, Statement, TmplAstNode, WrappedNodeExpr} from '@angular/compiler';\n+import {compileComponentFromMetadata, ConstantPool, CssSelector, DEFAULT_INTERPOLATION_CONFIG, DomElementSchemaRegistry, Expression, ExternalExpr, Identifiers, InterpolationConfig, LexerRange, makeBindingParser, ParsedTemplate, ParseSourceFile, parseTemplate, R3ComponentMetadata, R3FactoryTarget, R3TargetBinder, SchemaMetadata, SelectorMatcher, Statement, TmplAstNode, WrappedNodeExpr} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {CycleAnalyzer} from '../../cycles';\n@@ -31,7 +31,7 @@ import {createValueHasWrongTypeError, getDirectiveDiagnostics, getProviderDiagno\n import {extractDirectiveMetadata, parseFieldArrayValue} from './directive';\n import {compileNgFactoryDefField} from './factory';\n import {generateSetClassMetadataCall} from './metadata';\n-import {findAngularDecorator, isAngularCoreReference, isExpressionForwardReference, makeDuplicateDeclarationError, readBaseClass, resolveProvidersRequiringFactory, unwrapExpression, wrapFunctionExpressionsInParens} from './util';\n+import {findAngularDecorator, isAngularCoreReference, isExpressionForwardReference, readBaseClass, resolveProvidersRequiringFactory, unwrapExpression, wrapFunctionExpressionsInParens} from './util';\n \n const EMPTY_MAP = new Map<string, Expression>();\n const EMPTY_ARRAY: any[] = [];\n@@ -260,7 +260,7 @@ export class ComponentDecoratorHandler implements\n \n     let diagnostics: ts.Diagnostic[]|undefined = undefined;\n \n-    if (template.errors !== undefined) {\n+    if (template.errors !== null) {\n       // If there are any template parsing errors, convert them to `ts.Diagnostic`s for display.\n       const id = getTemplateId(node);\n       diagnostics = template.errors.map(error => {\n@@ -336,11 +336,11 @@ export class ComponentDecoratorHandler implements\n         meta: {\n           ...metadata,\n           template: {\n-            nodes: template.emitNodes,\n+            nodes: template.nodes,\n             ngContentSelectors: template.ngContentSelectors,\n           },\n           encapsulation,\n-          interpolation: template.interpolation,\n+          interpolation: template.interpolationConfig ?? DEFAULT_INTERPOLATION_CONFIG,\n           styles: styles || [],\n \n           // These will be replaced during the compilation step, after all `NgModule`s have been\n@@ -772,7 +772,7 @@ export class ComponentDecoratorHandler implements\n \n   private _parseTemplate(\n       component: Map<string, ts.Expression>, templateStr: string, templateUrl: string,\n-      templateRange: LexerRange|undefined, escapedString: boolean): ParsedTemplate {\n+      templateRange: LexerRange|undefined, escapedString: boolean): ParsedComponentTemplate {\n     let preserveWhitespaces: boolean = this.defaultPreserveWhitespaces;\n     if (component.has('preserveWhitespaces')) {\n       const expr = component.get('preserveWhitespaces')!;\n@@ -783,7 +783,7 @@ export class ComponentDecoratorHandler implements\n       preserveWhitespaces = value;\n     }\n \n-    let interpolation: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG;\n+    let interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;\n     if (component.has('interpolation')) {\n       const expr = component.get('interpolation')!;\n       const value = this.evaluator.evaluate(expr);\n@@ -792,21 +792,20 @@ export class ComponentDecoratorHandler implements\n         throw createValueHasWrongTypeError(\n             expr, value, 'interpolation must be an array with 2 elements of string type');\n       }\n-      interpolation = InterpolationConfig.fromArray(value as [string, string]);\n+      interpolationConfig = InterpolationConfig.fromArray(value as [string, string]);\n     }\n \n     // We always normalize line endings if the template has been escaped (i.e. is inline).\n     const i18nNormalizeLineEndingsInICUs = escapedString || this.i18nNormalizeLineEndingsInICUs;\n \n-    const {errors, nodes: emitNodes, styleUrls, styles, ngContentSelectors} =\n-        parseTemplate(templateStr, templateUrl, {\n-          preserveWhitespaces,\n-          interpolationConfig: interpolation,\n-          range: templateRange,\n-          escapedString,\n-          enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n-          i18nNormalizeLineEndingsInICUs,\n-        });\n+    const parsedTemplate = parseTemplate(templateStr, templateUrl, {\n+      preserveWhitespaces,\n+      interpolationConfig,\n+      range: templateRange,\n+      escapedString,\n+      enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n+      i18nNormalizeLineEndingsInICUs,\n+    });\n \n     // Unfortunately, the primary parse of the template above may not contain accurate source map\n     // information. If used directly, it would result in incorrect code locations in template\n@@ -823,7 +822,7 @@ export class ComponentDecoratorHandler implements\n \n     const {nodes: diagNodes} = parseTemplate(templateStr, templateUrl, {\n       preserveWhitespaces: true,\n-      interpolationConfig: interpolation,\n+      interpolationConfig,\n       range: templateRange,\n       escapedString,\n       enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n@@ -832,13 +831,8 @@ export class ComponentDecoratorHandler implements\n     });\n \n     return {\n-      interpolation,\n-      emitNodes,\n+      ...parsedTemplate,\n       diagNodes,\n-      styleUrls,\n-      styles,\n-      ngContentSelectors,\n-      errors,\n       template: templateStr,\n       templateUrl,\n       isInline: component.has('template'),\n@@ -905,12 +899,7 @@ function sourceMapUrl(resourceUrl: string): string {\n  * This contains the actual parsed template as well as any metadata collected during its parsing,\n  * some of which might be useful for re-parsing the template with different options.\n  */\n-export interface ParsedTemplate {\n-  /**\n-   * The `InterpolationConfig` specified by the user.\n-   */\n-  interpolation: InterpolationConfig;\n-\n+export interface ParsedComponentTemplate extends ParsedTemplate {\n   /**\n    * A full path to the file which contains the template.\n    *\n@@ -920,22 +909,10 @@ export interface ParsedTemplate {\n   templateUrl: string;\n \n   /**\n-   * The string contents of the template.\n-   *\n-   * This is the \"logical\" template string, after expansion of any escaped characters (for inline\n-   * templates). This may differ from the actual template bytes as they appear in the .ts file.\n-   */\n-  template: string;\n-\n-  /**\n-   * Any errors from parsing the template the first time.\n+   * True if the original template was stored inline;\n+   * False if the template was in an external file.\n    */\n-  errors?: ParseError[]|undefined;\n-\n-  /**\n-   * The template AST, parsed according to the user's specifications.\n-   */\n-  emitNodes: TmplAstNode[];\n+  isInline: boolean;\n \n   /**\n    * The template AST, parsed in a manner which preserves source map information for diagnostics.\n@@ -944,36 +921,12 @@ export interface ParsedTemplate {\n    */\n   diagNodes: TmplAstNode[];\n \n-  /**\n-   *\n-   */\n-\n-  /**\n-   * Any styleUrls extracted from the metadata.\n-   */\n-  styleUrls: string[];\n-\n-  /**\n-   * Any inline styles extracted from the metadata.\n-   */\n-  styles: string[];\n-\n-  /**\n-   * Any ng-content selectors extracted from the template.\n-   */\n-  ngContentSelectors: string[];\n-\n-  /**\n-   * Whether the template was inline.\n-   */\n-  isInline: boolean;\n-\n   /**\n    * The `ParseSourceFile` for the template.\n    */\n   file: ParseSourceFile;\n }\n \n-export interface ParsedTemplateWithSource extends ParsedTemplate {\n+export interface ParsedTemplateWithSource extends ParsedComponentTemplate {\n   sourceMapping: TemplateSourceMapping;\n }"
        },
        {
            "sha": "db8ef3487aee70418cd9f09191310c04a5de42a0",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/687477279b3513f56294c54fe16152d966501044/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/687477279b3513f56294c54fe16152d966501044/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=687477279b3513f56294c54fe16152d966501044",
            "patch": "@@ -79,7 +79,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n       leadingTriviaChars: [],\n     });\n \n-    if (errors !== undefined) {\n+    if (errors !== null) {\n       return {nodes, errors};\n     }\n "
        },
        {
            "sha": "d87a8141e31fd67791011ed50271f939cd4d4109",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/test_utils.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/687477279b3513f56294c54fe16152d966501044/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/687477279b3513f56294c54fe16152d966501044/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts?ref=687477279b3513f56294c54fe16152d966501044",
            "patch": "@@ -354,7 +354,7 @@ export function setup(targets: TypeCheckingTarget[], overrides: {\n         const templateUrl = `${className}.html`;\n         const templateFile = new ParseSourceFile(template, templateUrl);\n         const {nodes, errors} = parseTemplate(template, templateUrl);\n-        if (errors !== undefined) {\n+        if (errors !== null) {\n           throw new Error('Template parse errors: \\n' + errors.join('\\n'));\n         }\n "
        },
        {
            "sha": "06405307adf22f11e1454033b6e4a302a7b56042",
            "filename": "packages/compiler/src/compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/687477279b3513f56294c54fe16152d966501044/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/687477279b3513f56294c54fe16152d966501044/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompiler.ts?ref=687477279b3513f56294c54fe16152d966501044",
            "patch": "@@ -99,7 +99,7 @@ export {Identifiers as R3Identifiers} from './render3/r3_identifiers';\n export {R3DependencyMetadata, R3ResolvedDependencyType, compileFactoryFunction, R3FactoryMetadata, R3FactoryTarget} from './render3/r3_factory';\n export {compileInjector, compileNgModule, R3InjectorMetadata, R3NgModuleMetadata} from './render3/r3_module_compiler';\n export {compilePipeFromMetadata, R3PipeMetadata} from './render3/r3_pipe_compiler';\n-export {makeBindingParser, parseTemplate, ParseTemplateOptions} from './render3/view/template';\n+export {makeBindingParser, ParsedTemplate, parseTemplate, ParseTemplateOptions} from './render3/view/template';\n export {R3Reference} from './render3/util';\n export {compileComponentFromMetadata, compileDirectiveFromMetadata, parseHostBindings, ParsedHostBindings, verifyHostBindings} from './render3/view/compiler';\n export {publishFacade} from './jit_compiler_facade';"
        },
        {
            "sha": "540c0a3e22f6dc6afb7b5fa4515d70d571fdfe27",
            "filename": "packages/compiler/src/jit_compiler_facade.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/687477279b3513f56294c54fe16152d966501044/packages%2Fcompiler%2Fsrc%2Fjit_compiler_facade.ts",
            "raw_url": "https://github.com/angular/angular/raw/687477279b3513f56294c54fe16152d966501044/packages%2Fcompiler%2Fsrc%2Fjit_compiler_facade.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fjit_compiler_facade.ts?ref=687477279b3513f56294c54fe16152d966501044",
            "patch": "@@ -129,7 +129,7 @@ export class CompilerFacadeImpl implements CompilerFacade {\n     const template = parseTemplate(\n         facade.template, sourceMapUrl,\n         {preserveWhitespaces: facade.preserveWhitespaces, interpolationConfig});\n-    if (template.errors !== undefined) {\n+    if (template.errors !== null) {\n       const errors = template.errors.map(err => err.toString()).join(', ');\n       throw new Error(`Errors during JIT compilation of template for ${facade.name}: ${errors}`);\n     }"
        },
        {
            "sha": "3dea5078b0b116af43e0e4090d0e58659d5e1b28",
            "filename": "packages/compiler/src/render3/view/template.ts",
            "status": "modified",
            "additions": 75,
            "deletions": 9,
            "changes": 84,
            "blob_url": "https://github.com/angular/angular/blob/687477279b3513f56294c54fe16152d966501044/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "raw_url": "https://github.com/angular/angular/raw/687477279b3513f56294c54fe16152d966501044/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts?ref=687477279b3513f56294c54fe16152d966501044",
            "patch": "@@ -2025,13 +2025,7 @@ export interface ParseTemplateOptions {\n  * @param options options to modify how the template is parsed\n  */\n export function parseTemplate(\n-    template: string, templateUrl: string, options: ParseTemplateOptions = {}): {\n-  errors?: ParseError[],\n-        nodes: t.Node[],\n-        styleUrls: string[],\n-        styles: string[],\n-        ngContentSelectors: string[]\n-} {\n+    template: string, templateUrl: string, options: ParseTemplateOptions = {}): ParsedTemplate {\n   const {interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat} = options;\n   const bindingParser = makeBindingParser(interpolationConfig);\n   const htmlParser = new HtmlParser();\n@@ -2041,6 +2035,9 @@ export function parseTemplate(\n \n   if (parseResult.errors && parseResult.errors.length > 0) {\n     return {\n+      interpolationConfig,\n+      preserveWhitespaces,\n+      template,\n       errors: parseResult.errors,\n       nodes: [],\n       styleUrls: [],\n@@ -2076,10 +2073,28 @@ export function parseTemplate(\n   const {nodes, errors, styleUrls, styles, ngContentSelectors} =\n       htmlAstToRender3Ast(rootNodes, bindingParser);\n   if (errors && errors.length > 0) {\n-    return {errors, nodes: [], styleUrls: [], styles: [], ngContentSelectors: []};\n+    return {\n+      interpolationConfig,\n+      preserveWhitespaces,\n+      template,\n+      errors,\n+      nodes: [],\n+      styleUrls: [],\n+      styles: [],\n+      ngContentSelectors: []\n+    };\n   }\n \n-  return {nodes, styleUrls, styles, ngContentSelectors};\n+  return {\n+    interpolationConfig,\n+    preserveWhitespaces,\n+    errors: null,\n+    template,\n+    nodes,\n+    styleUrls,\n+    styles,\n+    ngContentSelectors\n+  };\n }\n \n const elementRegistry = new DomElementSchemaRegistry();\n@@ -2196,3 +2211,54 @@ function createClosureModeGuard(): o.BinaryOperatorExpr {\n       .notIdentical(o.literal('undefined', o.STRING_TYPE))\n       .and(o.variable(NG_I18N_CLOSURE_MODE));\n }\n+\n+/**\n+ * Information about the template which was extracted during parsing.\n+ *\n+ * This contains the actual parsed template as well as any metadata collected during its parsing,\n+ * some of which might be useful for re-parsing the template with different options.\n+ */\n+export interface ParsedTemplate {\n+  /**\n+   * Include whitespace nodes in the parsed output.\n+   */\n+  preserveWhitespaces?: boolean;\n+\n+  /**\n+   * How to parse interpolation markers.\n+   */\n+  interpolationConfig?: InterpolationConfig;\n+\n+  /**\n+   * The string contents of the template.\n+   *\n+   * This is the \"logical\" template string, after expansion of any escaped characters (for inline\n+   * templates). This may differ from the actual template bytes as they appear in the .ts file.\n+   */\n+  template: string;\n+\n+  /**\n+   * Any errors from parsing the template the first time.\n+   */\n+  errors: ParseError[]|null;\n+\n+  /**\n+   * The template AST, parsed from the template.\n+   */\n+  nodes: t.Node[];\n+\n+  /**\n+   * Any styleUrls extracted from the metadata.\n+   */\n+  styleUrls: string[];\n+\n+  /**\n+   * Any inline styles extracted from the metadata.\n+   */\n+  styles: string[];\n+\n+  /**\n+   * Any ng-content selectors extracted from the template.\n+   */\n+  ngContentSelectors: string[];\n+}"
        },
        {
            "sha": "43820c7e45e54b29463c73e1de7b97ebf076b723",
            "filename": "packages/language-service/ivy/test/hybrid_visitor_spec.ts",
            "status": "modified",
            "additions": 63,
            "deletions": 63,
            "changes": 126,
            "blob_url": "https://github.com/angular/angular/blob/687477279b3513f56294c54fe16152d966501044/packages%2Flanguage-service%2Fivy%2Ftest%2Fhybrid_visitor_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/687477279b3513f56294c54fe16152d966501044/packages%2Flanguage-service%2Fivy%2Ftest%2Fhybrid_visitor_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fhybrid_visitor_spec.ts?ref=687477279b3513f56294c54fe16152d966501044",
            "patch": "@@ -14,7 +14,7 @@ import {findNodeAtPosition, isExpressionNode, isTemplateNode} from '../hybrid_vi\n \n interface ParseResult {\n   nodes: t.Node[];\n-  errors?: ParseError[];\n+  errors: ParseError[]|null;\n   position: number;\n }\n \n@@ -34,47 +34,47 @@ function parse(template: string): ParseResult {\n describe('findNodeAtPosition for template AST', () => {\n   it('should locate element in opening tag', () => {\n     const {errors, nodes, position} = parse(`<di¦v></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate element in closing tag', () => {\n     const {errors, nodes, position} = parse(`<div></di¦v>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate element when cursor is at the beginning', () => {\n     const {errors, nodes, position} = parse(`<¦div></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate element when cursor is at the end', () => {\n     const {errors, nodes, position} = parse(`<div¦></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate attribute key', () => {\n     const {errors, nodes, position} = parse(`<div cla¦ss=\"foo\"></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate attribute value', () => {\n     const {errors, nodes, position} = parse(`<div class=\"fo¦o\"></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     // TODO: Note that we do not have the ability to detect the RHS (yet)\n@@ -83,39 +83,39 @@ describe('findNodeAtPosition for template AST', () => {\n \n   it('should locate bound attribute key', () => {\n     const {errors, nodes, position} = parse(`<test-cmp [fo¦o]=\"bar\"></test-cmp>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n   });\n \n   it('should locate bound attribute value', () => {\n     const {errors, nodes, position} = parse(`<test-cmp [foo]=\"b¦ar\"></test-cmp>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate bound event key', () => {\n     const {errors, nodes, position} = parse(`<test-cmp (fo¦o)=\"bar()\"></test-cmp>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundEvent);\n   });\n \n   it('should locate bound event value', () => {\n     const {errors, nodes, position} = parse(`<test-cmp (foo)=\"b¦ar()\"></test-cmp>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.MethodCall);\n   });\n \n   it('should locate element children', () => {\n     const {errors, nodes, position} = parse(`<div><sp¦an></span></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n@@ -124,39 +124,39 @@ describe('findNodeAtPosition for template AST', () => {\n \n   it('should locate element reference', () => {\n     const {errors, nodes, position} = parse(`<div #my¦div></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n   });\n \n   it('should locate template text attribute', () => {\n     const {errors, nodes, position} = parse(`<ng-template ng¦If></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate template bound attribute key', () => {\n     const {errors, nodes, position} = parse(`<ng-template [ng¦If]=\"foo\"></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n   });\n \n   it('should locate template bound attribute value', () => {\n     const {errors, nodes, position} = parse(`<ng-template [ngIf]=\"f¦oo\"></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate template bound attribute key in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<ng-template [(f¦oo)]=\"bar\"></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n@@ -165,7 +165,7 @@ describe('findNodeAtPosition for template AST', () => {\n \n   it('should locate template bound attribute value in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<ng-template [(foo)]=\"b¦ar\"></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n@@ -174,30 +174,30 @@ describe('findNodeAtPosition for template AST', () => {\n \n   it('should locate template bound event key', () => {\n     const {errors, nodes, position} = parse(`<ng-template (cl¦ick)=\"foo()\"></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundEvent);\n   });\n \n   it('should locate template bound event value', () => {\n     const {errors, nodes, position} = parse(`<ng-template (click)=\"f¦oo()\"></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(node).toBeInstanceOf(e.MethodCall);\n   });\n \n   it('should locate template attribute key', () => {\n     const {errors, nodes, position} = parse(`<ng-template i¦d=\"foo\"></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate template attribute value', () => {\n     const {errors, nodes, position} = parse(`<ng-template id=\"f¦oo\"></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     // TODO: Note that we do not have the ability to detect the RHS (yet)\n@@ -206,7 +206,7 @@ describe('findNodeAtPosition for template AST', () => {\n \n   it('should locate template reference key via the # notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template #f¦oo></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n@@ -215,7 +215,7 @@ describe('findNodeAtPosition for template AST', () => {\n \n   it('should locate template reference key via the ref- notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template ref-fo¦o></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n@@ -224,7 +224,7 @@ describe('findNodeAtPosition for template AST', () => {\n \n   it('should locate template reference value via the # notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template #foo=\"export¦As\"></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n@@ -234,7 +234,7 @@ describe('findNodeAtPosition for template AST', () => {\n \n   it('should locate template reference value via the ref- notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template ref-foo=\"export¦As\"></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n@@ -244,47 +244,47 @@ describe('findNodeAtPosition for template AST', () => {\n \n   it('should locate template variable key', () => {\n     const {errors, nodes, position} = parse(`<ng-template let-f¦oo=\"bar\"></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n   });\n \n   it('should locate template variable value', () => {\n     const {errors, nodes, position} = parse(`<ng-template let-foo=\"b¦ar\"></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n   });\n \n   it('should locate template children', () => {\n     const {errors, nodes, position} = parse(`<ng-template><d¦iv></div></ng-template>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate ng-content', () => {\n     const {errors, nodes, position} = parse(`<ng-co¦ntent></ng-content>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Content);\n   });\n \n   it('should locate ng-content attribute key', () => {\n     const {errors, nodes, position} = parse('<ng-content cla¦ss=\"red\"></ng-content>');\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate ng-content attribute value', () => {\n     const {errors, nodes, position} = parse('<ng-content class=\"r¦ed\"></ng-content>');\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     // TODO: Note that we do not have the ability to detect the RHS (yet)\n     expect(isTemplateNode(node!)).toBe(true);\n@@ -293,15 +293,15 @@ describe('findNodeAtPosition for template AST', () => {\n \n   it('should not locate implicit receiver', () => {\n     const {errors, nodes, position} = parse(`<div [foo]=\"¦bar\"></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate bound attribute key in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<cmp [(f¦oo)]=\"bar\"></cmp>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n@@ -310,7 +310,7 @@ describe('findNodeAtPosition for template AST', () => {\n \n   it('should locate bound attribute value in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<cmp [(foo)]=\"b¦ar\"></cmp>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n@@ -321,7 +321,7 @@ describe('findNodeAtPosition for template AST', () => {\n describe('findNodeAtPosition for expression AST', () => {\n   it('should not locate implicit receiver', () => {\n     const {errors, nodes, position} = parse(`{{ ¦title }}`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n@@ -330,7 +330,7 @@ describe('findNodeAtPosition for expression AST', () => {\n \n   it('should locate property read', () => {\n     const {errors, nodes, position} = parse(`{{ ti¦tle }}`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n@@ -339,7 +339,7 @@ describe('findNodeAtPosition for expression AST', () => {\n \n   it('should locate safe property read', () => {\n     const {errors, nodes, position} = parse(`{{ foo?¦.bar }}`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.SafePropertyRead);\n@@ -348,39 +348,39 @@ describe('findNodeAtPosition for expression AST', () => {\n \n   it('should locate keyed read', () => {\n     const {errors, nodes, position} = parse(`{{ foo['bar']¦ }}`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.KeyedRead);\n   });\n \n   it('should locate property write', () => {\n     const {errors, nodes, position} = parse(`<div (foo)=\"b¦ar=$event\"></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyWrite);\n   });\n \n   it('should locate keyed write', () => {\n     const {errors, nodes, position} = parse(`<div (foo)=\"bar['baz']¦=$event\"></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.KeyedWrite);\n   });\n \n   it('should locate binary', () => {\n     const {errors, nodes, position} = parse(`{{ 1 +¦ 2 }}`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.Binary);\n   });\n \n   it('should locate binding pipe with an identifier', () => {\n     const {errors, nodes, position} = parse(`{{ title | p¦ }}`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.BindingPipe);\n@@ -391,31 +391,31 @@ describe('findNodeAtPosition for expression AST', () => {\n          // TODO: We are not able to locate pipe if identifier is missing because the\n          // parser throws an error. This case is important for autocomplete.\n          // const {errors, nodes, position} = parse(`{{ title | ¦ }}`);\n-         // expect(errors).toBeUndefined();\n+         // expect(errors).toBe(null);\n          // const node = findNodeAtPosition(nodes, position);\n          // expect(isExpressionNode(node!)).toBe(true);\n          // expect(node).toBeInstanceOf(e.BindingPipe);\n      });\n \n   it('should locate method call', () => {\n     const {errors, nodes, position} = parse(`{{ title.toString(¦) }}`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.MethodCall);\n   });\n \n   it('should locate safe method call', () => {\n     const {errors, nodes, position} = parse(`{{ title?.toString(¦) }}`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.SafeMethodCall);\n   });\n \n   it('should locate literal primitive in interpolation', () => {\n     const {errors, nodes, position} = parse(`{{ title.indexOf('t¦') }}`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralPrimitive);\n@@ -424,7 +424,7 @@ describe('findNodeAtPosition for expression AST', () => {\n \n   it('should locate literal primitive in binding', () => {\n     const {errors, nodes, position} = parse(`<div [id]=\"'t¦'\"></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralPrimitive);\n@@ -433,31 +433,31 @@ describe('findNodeAtPosition for expression AST', () => {\n \n   it('should locate empty expression', () => {\n     const {errors, nodes, position} = parse(`<div [id]=\"¦\"></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.EmptyExpr);\n   });\n \n   it('should locate literal array', () => {\n     const {errors, nodes, position} = parse(`{{ [1, 2,¦ 3] }}`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralArray);\n   });\n \n   it('should locate literal map', () => {\n     const {errors, nodes, position} = parse(`{{ { hello:¦ \"world\" } }}`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralMap);\n   });\n \n   it('should locate conditional', () => {\n     const {errors, nodes, position} = parse(`{{ cond ?¦ true : false }}`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.Conditional);\n@@ -467,15 +467,15 @@ describe('findNodeAtPosition for expression AST', () => {\n describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate template key', () => {\n     const {errors, nodes, position} = parse(`<div *ng¦If=\"foo\"></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n   });\n \n   it('should locate template value', () => {\n     const {errors, nodes, position} = parse(`<div *ngIf=\"f¦oo\"></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n@@ -485,23 +485,23 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n     const {errors, nodes, position} = parse(`<div *ng¦For=\"let item of items\"></div>`);\n     // ngFor is a text attribute because the desugared form is\n     // <ng-template ngFor let-item [ngForOf]=\"items\">\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     // TODO: this is currently wrong because it should point to ngFor text\n     // attribute instead of ngForOf bound attribute\n   });\n \n   it('should locate not let keyword', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"l¦et item of items\"></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     // TODO: this is currently wrong because node is currently pointing to\n     // \"item\". In this case, it should return undefined.\n   });\n \n   it('should locate let variable', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let i¦tem of items\"></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n@@ -510,7 +510,7 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n \n   it('should locate bound attribute key', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item o¦f items\"></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n@@ -519,7 +519,7 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n \n   it('should locate bound attribute value', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item of it¦ems\"></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n@@ -528,7 +528,7 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n \n   it('should locate template children', () => {\n     const {errors, nodes, position} = parse(`<di¦v *ngIf></div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n@@ -540,15 +540,15 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n       <div *ngFor=\"let item of items; let i=index\">\n         {{ i¦ }}\n       </div>`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate LHS of variable declaration', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item of items; let i¦=index\">`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n@@ -558,7 +558,7 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n \n   it('should locate RHS of variable declaration', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item of items; let i=in¦dex\">`);\n-    expect(errors).toBeUndefined();\n+    expect(errors).toBe(null);\n     const node = findNodeAtPosition(nodes, position);\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);"
        }
    ],
    "stats": {
        "total": 311,
        "additions": 165,
        "deletions": 146
    }
}