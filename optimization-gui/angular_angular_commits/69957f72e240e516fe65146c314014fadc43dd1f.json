{
    "author": "ivanwonder",
    "message": "feat(language-service): provide snippets for attribute (#43590)\n\nSupport snippet completions for dom attribute whose value\nis empty. For Example `<div (my¦) />`, the `insertText`\nwill return `(myOutput)=\"$0\"`.\n\nFixes https://github.com/angular/vscode-ng-language-service/issues/521\n\nPR Close #43590",
    "sha": "69957f72e240e516fe65146c314014fadc43dd1f",
    "files": [
        {
            "sha": "631d6854eaf52ada7828985578286f3ce3e4150d",
            "filename": "packages/language-service/ivy/attribute_completions.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 4,
            "changes": 37,
            "blob_url": "https://github.com/angular/angular/blob/69957f72e240e516fe65146c314014fadc43dd1f/packages%2Flanguage-service%2Fivy%2Fattribute_completions.ts",
            "raw_url": "https://github.com/angular/angular/raw/69957f72e240e516fe65146c314014fadc43dd1f/packages%2Flanguage-service%2Fivy%2Fattribute_completions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fattribute_completions.ts?ref=69957f72e240e516fe65146c314014fadc43dd1f",
            "patch": "@@ -370,6 +370,10 @@ export function buildAttributeCompletionTable(\n   return table;\n }\n \n+function buildSnippet(insertSnippet: true|undefined, text: string): string|undefined {\n+  return insertSnippet ? `${text}=\"$1\"` : undefined;\n+}\n+\n /**\n  * Given an `AttributeCompletion`, add any available completions to a `ts.CompletionEntry` array of\n  * results.\n@@ -381,10 +385,15 @@ export function buildAttributeCompletionTable(\n  * is generated. Note that this completion does not have the `[]` property binding sugar as its\n  * implicitly present in a property binding context (we're already completing within an `[attr|]`\n  * expression).\n+ *\n+ * If the `insertSnippet` is `true`, the completion entries should includes the property or event\n+ * binding sugar in some case. For Example `<div (my¦) />`, the `replacementSpan` is `(my)`, and the\n+ * `insertText` is `(myOutput)=\"$0\"`.\n  */\n export function addAttributeCompletionEntries(\n     entries: ts.CompletionEntry[], completion: AttributeCompletion, isAttributeContext: boolean,\n-    isElementContext: boolean, replacementSpan: ts.TextSpan|undefined): void {\n+    isElementContext: boolean, replacementSpan: ts.TextSpan|undefined,\n+    insertSnippet: true|undefined): void {\n   switch (completion.kind) {\n     case AttributeCompletionKind.DirectiveAttribute: {\n       entries.push({\n@@ -403,17 +412,21 @@ export function addAttributeCompletionEntries(\n       entries.push({\n         kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n         name: prefix + completion.attribute,\n+        insertText: buildSnippet(insertSnippet, prefix + completion.attribute),\n+        isSnippet: insertSnippet,\n         sortText: prefix + completion.attribute,\n         replacementSpan,\n       });\n       break;\n     }\n     case AttributeCompletionKind.DirectiveInput: {\n-      if (isAttributeContext) {\n+      if (isAttributeContext || insertSnippet) {\n         // Offer a completion of a property binding.\n         entries.push({\n           kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n           name: `[${completion.propertyName}]`,\n+          insertText: buildSnippet(insertSnippet, `[${completion.propertyName}]`),\n+          isSnippet: insertSnippet,\n           sortText: completion.propertyName,\n           replacementSpan,\n         });\n@@ -422,6 +435,8 @@ export function addAttributeCompletionEntries(\n           entries.push({\n             kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n             name: `[(${completion.propertyName})]`,\n+            insertText: buildSnippet(insertSnippet, `[(${completion.propertyName})]`),\n+            isSnippet: insertSnippet,\n             // This completion should sort after the property binding.\n             sortText: completion.propertyName + '_1',\n             replacementSpan,\n@@ -431,6 +446,8 @@ export function addAttributeCompletionEntries(\n         entries.push({\n           kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n           name: completion.propertyName,\n+          insertText: buildSnippet(insertSnippet, completion.propertyName),\n+          isSnippet: insertSnippet,\n           // This completion should sort after both property binding options (one-way and two-way).\n           sortText: completion.propertyName + '_2',\n           replacementSpan,\n@@ -439,36 +456,44 @@ export function addAttributeCompletionEntries(\n         entries.push({\n           kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n           name: completion.propertyName,\n+          insertText: buildSnippet(insertSnippet, completion.propertyName),\n+          isSnippet: insertSnippet,\n           sortText: completion.propertyName,\n           replacementSpan,\n         });\n       }\n       break;\n     }\n     case AttributeCompletionKind.DirectiveOutput: {\n-      if (isAttributeContext) {\n+      if (isAttributeContext || insertSnippet) {\n         entries.push({\n           kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n           name: `(${completion.eventName})`,\n+          insertText: buildSnippet(insertSnippet, `(${completion.eventName})`),\n+          isSnippet: insertSnippet,\n           sortText: completion.eventName,\n           replacementSpan,\n         });\n       } else {\n         entries.push({\n           kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n           name: completion.eventName,\n+          insertText: buildSnippet(insertSnippet, completion.eventName),\n+          isSnippet: insertSnippet,\n           sortText: completion.eventName,\n           replacementSpan,\n         });\n       }\n       break;\n     }\n     case AttributeCompletionKind.DomAttribute: {\n-      if (isAttributeContext && completion.isAlsoProperty) {\n+      if ((isAttributeContext || insertSnippet) && completion.isAlsoProperty) {\n         // Offer a completion of a property binding to the DOM property.\n         entries.push({\n           kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n           name: `[${completion.attribute}]`,\n+          insertText: buildSnippet(insertSnippet, `[${completion.attribute}]`),\n+          isSnippet: insertSnippet,\n           // In the case of DOM attributes, the property binding should sort after the attribute\n           // binding.\n           sortText: completion.attribute + '_1',\n@@ -482,6 +507,8 @@ export function addAttributeCompletionEntries(\n         entries.push({\n           kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n           name: completion.property,\n+          insertText: buildSnippet(insertSnippet, completion.property),\n+          isSnippet: insertSnippet,\n           sortText: completion.property,\n           replacementSpan,\n         });\n@@ -492,6 +519,8 @@ export function addAttributeCompletionEntries(\n       entries.push({\n         kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n         name: `(${completion.eventName})`,\n+        insertText: buildSnippet(insertSnippet, `(${completion.eventName})`),\n+        isSnippet: insertSnippet,\n         sortText: completion.eventName,\n         replacementSpan,\n       });"
        },
        {
            "sha": "6bf6cee9bfd0cc99df0a3ca3050f02ce953d9266",
            "filename": "packages/language-service/ivy/completions.ts",
            "status": "modified",
            "additions": 49,
            "deletions": 6,
            "changes": 55,
            "blob_url": "https://github.com/angular/angular/blob/69957f72e240e516fe65146c314014fadc43dd1f/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "raw_url": "https://github.com/angular/angular/raw/69957f72e240e516fe65146c314014fadc43dd1f/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompletions.ts?ref=69957f72e240e516fe65146c314014fadc43dd1f",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, BindingPipe, Call, EmptyExpr, ImplicitReceiver, LiteralPrimitive, ParseSourceSpan, PropertyRead, PropertyWrite, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstText, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n+import {AST, ASTWithSource, BindingPipe, Call, EmptyExpr, ImplicitReceiver, LiteralPrimitive, ParseSourceSpan, PropertyRead, PropertyWrite, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstText, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {CompletionKind, DirectiveInScope, SymbolKind, TemplateDeclarationSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import {BoundEvent, TextAttribute} from '@angular/compiler/src/render3/r3_ast';\n@@ -15,7 +15,7 @@ import ts from 'typescript';\n import {addAttributeCompletionEntries, AttributeCompletionKind, buildAttributeCompletionTable, getAttributeCompletionSymbol} from './attribute_completions';\n import {DisplayInfo, DisplayInfoKind, getDirectiveDisplayInfo, getSymbolDisplayInfo, getTsSymbolDisplayInfo, unsafeCastDisplayInfoKindToScriptElementKind} from './display_parts';\n import {TargetContext, TargetNodeKind, TemplateTarget} from './template_target';\n-import {filterAliasImports} from './utils';\n+import {filterAliasImports, isBoundEventWithSyntheticHandler} from './utils';\n \n type PropertyExpressionCompletionBuilder =\n     CompletionBuilder<PropertyRead|PropertyWrite|EmptyExpr|SafePropertyRead|TmplAstBoundEvent>;\n@@ -70,7 +70,7 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n     } else if (this.isElementTagCompletion()) {\n       return this.getElementTagCompletion();\n     } else if (this.isElementAttributeCompletion()) {\n-      return this.getElementAttributeCompletions();\n+      return this.getElementAttributeCompletions(options);\n     } else if (this.isPipeCompletion()) {\n       return this.getPipeCompletions();\n     } else if (this.isLiteralCompletion()) {\n@@ -538,8 +538,10 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n          this.node instanceof TmplAstTextAttribute || this.node instanceof TmplAstBoundEvent);\n   }\n \n-  private getElementAttributeCompletions(this: ElementAttributeCompletionBuilder):\n-      ts.WithMetadata<ts.CompletionInfo>|undefined {\n+  private getElementAttributeCompletions(\n+      this: ElementAttributeCompletionBuilder,\n+      options: ts.GetCompletionsAtPositionOptions|\n+      undefined): ts.WithMetadata<ts.CompletionInfo>|undefined {\n     let element: TmplAstElement|TmplAstTemplate;\n     if (this.node instanceof TmplAstElement) {\n       element = this.node;\n@@ -558,6 +560,45 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       replacementSpan = makeReplacementSpanFromParseSourceSpan(this.node.keySpan);\n     }\n \n+    let insertSnippet: true|undefined;\n+    if (options?.includeCompletionsWithSnippetText && options.includeCompletionsWithInsertText) {\n+      if (this.node instanceof TmplAstBoundEvent && isBoundEventWithSyntheticHandler(this.node)) {\n+        replacementSpan = makeReplacementSpanFromParseSourceSpan(this.node.sourceSpan);\n+        insertSnippet = true;\n+      }\n+\n+      const isBoundAttributeValueEmpty = this.node instanceof TmplAstBoundAttribute &&\n+          (this.node.valueSpan === undefined ||\n+           (this.node.value instanceof ASTWithSource && this.node.value.ast instanceof EmptyExpr));\n+      if (isBoundAttributeValueEmpty) {\n+        replacementSpan = makeReplacementSpanFromParseSourceSpan(this.node.sourceSpan);\n+        insertSnippet = true;\n+      }\n+\n+      if (this.node instanceof TmplAstTextAttribute && this.node.keySpan !== undefined) {\n+        // The `sourceSpan` only includes `ngFor` and the `valueSpan` is always empty even if there\n+        // is something there because we split this up into the desugared AST, `ngFor ngForOf=\"\"`.\n+        const nodeStart = this.node.keySpan.start.getContext(1, 1);\n+        if (nodeStart?.before[0] === '*') {\n+          const nodeEnd = this.node.keySpan.end.getContext(1, 1);\n+          if (nodeEnd?.after[0] !== '=') {\n+            // *ngFor -> *ngFor=\"¦\"\n+            insertSnippet = true;\n+          }\n+        } else {\n+          if (this.node.value === '') {\n+            replacementSpan = makeReplacementSpanFromParseSourceSpan(this.node.sourceSpan);\n+            insertSnippet = true;\n+          }\n+        }\n+      }\n+\n+      if (this.node instanceof TmplAstElement) {\n+        // <div ¦ />\n+        insertSnippet = true;\n+      }\n+    }\n+\n     const attrTable = buildAttributeCompletionTable(\n         this.component, element, this.compiler.getTemplateTypeChecker());\n \n@@ -607,8 +648,10 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       // Is the completion for an element (not an <ng-template>)?\n       const isElementContext =\n           this.node instanceof TmplAstElement || this.nodeParent instanceof TmplAstElement;\n+\n       addAttributeCompletionEntries(\n-          entries, completion, isAttributeContext, isElementContext, replacementSpan);\n+          entries, completion, isAttributeContext, isElementContext, replacementSpan,\n+          insertSnippet);\n     }\n \n     return {"
        },
        {
            "sha": "d5e3f556417923f48244e1ae6524de950c130bc6",
            "filename": "packages/language-service/ivy/template_target.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 16,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/69957f72e240e516fe65146c314014fadc43dd1f/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "raw_url": "https://github.com/angular/angular/raw/69957f72e240e516fe65146c314014fadc43dd1f/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts?ref=69957f72e240e516fe65146c314014fadc43dd1f",
            "patch": "@@ -10,7 +10,7 @@ import {ParseSpan, TmplAstBoundEvent} from '@angular/compiler';\n import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n \n-import {isTemplateNodeWithKeyAndValue, isWithin, isWithinKeyValue} from './utils';\n+import {isBoundEventWithSyntheticHandler, isTemplateNodeWithKeyAndValue, isWithin, isWithinKeyValue} from './utils';\n \n /**\n  * Contextual information for a target position within the template.\n@@ -375,22 +375,10 @@ class TemplateTargetVisitor implements t.Visitor {\n   }\n \n   visitBoundEvent(event: t.BoundEvent) {\n-    // An event binding with no value (e.g. `(event|)`) parses to a `BoundEvent` with a\n-    // `LiteralPrimitive` handler with value `'ERROR'`, as opposed to a property binding with no\n-    // value which has an `EmptyExpr` as its value. This is a synthetic node created by the binding\n-    // parser, and is not suitable to use for Language Service analysis. Skip it.\n-    //\n-    // TODO(alxhub): modify the parser to generate an `EmptyExpr` instead.\n-    let handler: e.AST = event.handler;\n-    if (handler instanceof e.ASTWithSource) {\n-      handler = handler.ast;\n+    if (!isBoundEventWithSyntheticHandler(event)) {\n+      const visitor = new ExpressionVisitor(this.position);\n+      visitor.visit(event.handler, this.path);\n     }\n-    if (handler instanceof e.LiteralPrimitive && handler.value === 'ERROR') {\n-      return;\n-    }\n-\n-    const visitor = new ExpressionVisitor(this.position);\n-    visitor.visit(event.handler, this.path);\n   }\n \n   visitText(text: t.Text) {"
        },
        {
            "sha": "cf5128ad27cd24957429a5d29087498461bde586",
            "filename": "packages/language-service/ivy/test/completions_spec.ts",
            "status": "modified",
            "additions": 245,
            "deletions": 0,
            "changes": 245,
            "blob_url": "https://github.com/angular/angular/blob/69957f72e240e516fe65146c314014fadc43dd1f/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/69957f72e240e516fe65146c314014fadc43dd1f/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts?ref=69957f72e240e516fe65146c314014fadc43dd1f",
            "patch": "@@ -48,6 +48,18 @@ const DIR_WITH_OUTPUT = {\n   `\n };\n \n+const CUSTOM_BUTTON = {\n+  'Button': `\n+    @Directive({\n+      selector: 'button[mat-button]',\n+      inputs: ['color']\n+    })\n+    export class Button {\n+      color!: any;\n+    }\n+  `\n+};\n+\n const DIR_WITH_TWO_WAY_BINDING = {\n   'Dir': `\n     @Directive({\n@@ -875,6 +887,219 @@ describe('completions', () => {\n       expectReplacementText(completions, templateFile.contents, 'title');\n     });\n   });\n+\n+  describe('insert snippet text', () => {\n+    it('should be able to complete for an empty attribute', () => {\n+      const {templateFile} = setup(`<input dir >`, '', DIR_WITH_OUTPUT);\n+      templateFile.moveCursorToText('¦>');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+          ['(myOutput)=\"$1\"']);\n+    });\n+\n+    it('should be able to complete for a partial attribute', () => {\n+      const {templateFile} = setup(`<input dir my>`, '', DIR_WITH_OUTPUT);\n+      templateFile.moveCursorToText('¦>');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+          ['(myOutput)=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, 'my');\n+    });\n+\n+    it('should be able to complete for the event binding with the value is empty', () => {\n+      const {templateFile} = setup(`<input dir ()=\"\">`, '', DIR_WITH_OUTPUT);\n+      templateFile.moveCursorToText('(¦)=\"\">');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+          ['(myOutput)=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '()=\"\"');\n+    });\n+\n+    it('should be able to complete for the event binding', () => {\n+      const {templateFile} = setup(`<input dir ()>`, '', DIR_WITH_OUTPUT);\n+      templateFile.moveCursorToText('(¦)>');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+          ['(myOutput)=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '()');\n+    });\n+\n+    it('should be able to complete for the dom event binding', () => {\n+      const {templateFile} = setup(`<input dir (cli)>`, '', DIR_WITH_OUTPUT);\n+      templateFile.moveCursorToText('(cli¦)>');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+          ['(click)=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '(cli)');\n+    });\n+\n+    it('should be able to complete for the property binding with the value is empty', () => {\n+      const {templateFile} = setup(`<input [my]=\"\">`, '', DIR_WITH_SELECTED_INPUT);\n+      templateFile.moveCursorToText('[my¦]=\"\"');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          ['[myInput]=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '[my]=\"\"');\n+    });\n+\n+    it('should be able to complete for the property binding', () => {\n+      const {templateFile} = setup(`<input [my]>`, '', DIR_WITH_SELECTED_INPUT);\n+      templateFile.moveCursorToText('[my¦]');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          ['[myInput]=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '[my]');\n+    });\n+\n+    it('should be able to complete for the dom property binding', () => {\n+      const {templateFile} = setup(`<input [val]>`, '', DIR_WITH_SELECTED_INPUT);\n+      templateFile.moveCursorToText('[val¦]');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          ['[value]=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '[val]');\n+    });\n+\n+    it('should be able to complete for the two way binding with the value is empty', () => {\n+      const {templateFile} = setup(`<h1 dir [(mod)]=\"\"></h1>`, ``, DIR_WITH_TWO_WAY_BINDING);\n+      templateFile.moveCursorToText('[(mod¦)]=\"\"');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          ['[(model)]=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '[(mod)]=\"\"');\n+    });\n+\n+    it('should be able to complete for the two way binding via', () => {\n+      const {templateFile} = setup(`<h1 dir [(mod)]></h1>`, ``, DIR_WITH_TWO_WAY_BINDING);\n+      templateFile.moveCursorToText('[(mod¦)]');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          ['[(model)]=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '[(mod)]');\n+    });\n+\n+    it('should be able to complete for the structural directive with the value is empty', () => {\n+      const {templateFile} = setup(`<input dir *ngFor=\"\">`, '', NG_FOR_DIR);\n+      templateFile.moveCursorToText('ngFor¦=\"\">');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      // Now here is using the `=` to check the value of the structural directive. If the\n+      // sourceSpan/valueSpan made more sense, it should behave like this `ngFor¦=\"\" -> ngFor=\"¦\"`,\n+      // and enable comments below.\n+      //\n+      // expectContainInsertTextWithSnippet(\n+      //     completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+      //     ['ngFor=\"$1\"']);\n+      // expectReplacementText(completions, templateFile.contents, 'ngFor=\"\"');\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+          ['ngFor']);\n+      expect(completions?.entries[0]).toBeDefined();\n+      expect(completions?.entries[0].isSnippet).toBeUndefined();\n+      expectReplacementText(completions, templateFile.contents, 'ngFor');\n+    });\n+\n+    it('should be able to complete for the structural directive', () => {\n+      const {templateFile} = setup(`<input dir *ngFor>`, '', NG_FOR_DIR);\n+      templateFile.moveCursorToText('ngFor¦>');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+          ['ngFor=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, 'ngFor');\n+    });\n+\n+    it('should not be included in the completion for an attribute with a value', () => {\n+      const {templateFile} = setup(`<input dir myInput=\"1\">`, '', DIR_WITH_SELECTED_INPUT);\n+      templateFile.moveCursorToText('myInput¦=\"1\">');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+          ['myInput']);\n+      expectDoesNotContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+          ['myInput=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, 'myInput');\n+    });\n+\n+    it('should not be included in the completion for a directive attribute without input', () => {\n+      const {templateFile} = setup(`<button mat-></button>`, '', CUSTOM_BUTTON);\n+      templateFile.moveCursorToText('mat-¦>');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+          ['mat-button']);\n+      expectDoesNotContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+          ['mat-button=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, 'mat-');\n+    });\n+  });\n });\n \n function expectContainInsertText(\n@@ -886,6 +1111,26 @@ function expectContainInsertText(\n   }\n }\n \n+function expectContainInsertTextWithSnippet(\n+    completions: ts.CompletionInfo|undefined, kind: ts.ScriptElementKind|DisplayInfoKind,\n+    insertTexts: string[]) {\n+  expect(completions).toBeDefined();\n+  for (const insertText of insertTexts) {\n+    expect(completions!.entries)\n+        .toContain(jasmine.objectContaining({insertText, kind, isSnippet: true} as any));\n+  }\n+}\n+\n+function expectDoesNotContainInsertTextWithSnippet(\n+    completions: ts.CompletionInfo|undefined, kind: ts.ScriptElementKind|DisplayInfoKind,\n+    insertTexts: string[]) {\n+  expect(completions).toBeDefined();\n+  for (const insertText of insertTexts) {\n+    expect(completions!.entries)\n+        .not.toContain(jasmine.objectContaining({insertText, kind, isSnippet: true} as any));\n+  }\n+}\n+\n function expectContain(\n     completions: ts.CompletionInfo|undefined, kind: ts.ScriptElementKind|DisplayInfoKind,\n     names: string[]) {"
        },
        {
            "sha": "2da2af621c5822d13259ae1f6cfe6b72ad401676",
            "filename": "packages/language-service/ivy/utils.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/69957f72e240e516fe65146c314014fadc43dd1f/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/69957f72e240e516fe65146c314014fadc43dd1f/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Futils.ts?ref=69957f72e240e516fe65146c314014fadc43dd1f",
            "patch": "@@ -374,3 +374,20 @@ export function getTemplateLocationFromShimLocation(\n   }\n   return {templateUrl, span};\n }\n+\n+export function isBoundEventWithSyntheticHandler(event: t.BoundEvent): boolean {\n+  // An event binding with no value (e.g. `(event|)`) parses to a `BoundEvent` with a\n+  // `LiteralPrimitive` handler with value `'ERROR'`, as opposed to a property binding with no\n+  // value which has an `EmptyExpr` as its value. This is a synthetic node created by the binding\n+  // parser, and is not suitable to use for Language Service analysis. Skip it.\n+  //\n+  // TODO(alxhub): modify the parser to generate an `EmptyExpr` instead.\n+  let handler: e.AST = event.handler;\n+  if (handler instanceof e.ASTWithSource) {\n+    handler = handler.ast;\n+  }\n+  if (handler instanceof e.LiteralPrimitive && handler.value === 'ERROR') {\n+    return true;\n+  }\n+  return false;\n+}"
        }
    ],
    "stats": {
        "total": 374,
        "additions": 348,
        "deletions": 26
    }
}