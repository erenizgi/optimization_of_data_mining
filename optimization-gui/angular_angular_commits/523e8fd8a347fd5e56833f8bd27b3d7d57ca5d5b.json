{
    "author": "alan-agius4",
    "message": "docs: update Definition of Terms in APF guide (#44060)\n\nSeveral improvements to the Definition of Terms of terms section in the APF guide.\n\nPR Close #44060",
    "sha": "523e8fd8a347fd5e56833f8bd27b3d7d57ca5d5b",
    "files": [
        {
            "sha": "bae0474de7e2b9923bc407064d19fb1c0a6c2868",
            "filename": "aio/content/guide/angular-package-format.md",
            "status": "modified",
            "additions": 51,
            "deletions": 45,
            "changes": 96,
            "blob_url": "https://github.com/angular/angular/blob/523e8fd8a347fd5e56833f8bd27b3d7d57ca5d5b/aio%2Fcontent%2Fguide%2Fangular-package-format.md",
            "raw_url": "https://github.com/angular/angular/raw/523e8fd8a347fd5e56833f8bd27b3d7d57ca5d5b/aio%2Fcontent%2Fguide%2Fangular-package-format.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fangular-package-format.md?ref=523e8fd8a347fd5e56833f8bd27b3d7d57ca5d5b",
            "patch": "@@ -268,48 +268,54 @@ As of APF v10, we recommend adding tslib as a direct dependency of your primary\n \n The following terms are used throughout this document very intentionally. In this section we define all of them to provide additional clarity.\n \n-<style>\n-dt {\n-  font-size: larger;\n-  font-weight: bold;\n-  padding: 16px 0px;\n-}\n-</style>\n-\n-<dl>\n-<dt>Package</dt>\n-<dd>The smallest set of files that are published to NPM and installed together, for example @angular/core. This package includes a manifest called package.json, compiled source code, typescript definition files, source maps, metadata, etc. The package is installed with npm install @angular/core.</dd>\n-<dt>Symbol</dt>\n-<dd>A class, function, constant or variable contained in a module and optionally made visible to the external world via a module export.</dd>\n-<dt>Module</dt>\n-<dd>Short for ECMAScript Modules. A file containing statements that import and export symbols. This is identical to the definition of modules in the ECMAScript spec.</dd>\n-<dt>ESM</dt>\n-<dd>Short for ECMAScript Modules (see above)</dd>\n-<dt>FESM</dt>\n-<dd>Short for Flattened ES Modules and consists of a file format created by flattening all ES Modules accessible from an entry point into a single ES Module.\n-</dd>\n-<dt>Module ID</dt>\n-<dd>The identifier of a module used in the import statements, e.g. `@angular/core`. The ID often maps directly to a path on the filesystem, but this is not always the case due to various module resolution strategies.</dd>\n-<dt>Module Specifier</dt>\n-<dd>A module identifier (see above)</dd>\n-<dt>Module Resolution Strategy</dt>\n-<dd>Algorithm used to convert Module IDs to paths on the filesystem. Node.js has one that is well specified and widely used, TypeScript supports several module resolution strategies, Closure has yet another strategy.</dd>\n-<dt>Module Format</dt>\n-<dd>Specification of the module syntax that covers at minimum the syntax for the importing and exporting from a file. Common module formats are CommonJS (CJS, typically used for Node.js applications) or ECMAScript Modules (ESM). The module format indicates only the packaging of the individual modules, but not the JavaScript language features used to make up the module content. Because of this, the Angular team often uses the language level specifier as a suffix to the module format, e.g. ESM+ES5 specifies that the module is in ESM format and contains code down-leveled to ES5. Other commonly used combos: ESM+ES2015, CJS+ES5, and CJS+ES2015.</dd>\n-<dt>Bundle</dt>\n-<dd>An artifact in the form of a single JS file, produced by a build tool, e.g. WebPack or Rollup, that contains symbols originating in one or more modules. Bundles are a browser-specific workaround that reduce network strain that would be caused if browsers were to start downloading hundreds if not tens of thousands of files. Node.js typically doesn't use bundles. Common bundle formats are UMD and System.register.</dd>\n-<dt>Language Level</dt>\n-<dd>The language of the code (ES5 or ES2015). Independent of the module format.</dd>\n-<dt>Entry Point</dt>\n-<dd>A module intended to be imported by the user. It is referenced by a unique module ID and exports the public API referenced by that module ID. An example is @angular/core or @angular/core/testing. Both entry points exist in the @angular/core package, but they export different symbols. A package can have many entry points.</dd>\n-<dt>Deep Import</dt>\n-<dd>A process of retrieving symbols from modules that are not Entry Points. These module IDs are usually considered to be private APIs that can change over the lifetime of the project or while the bundle for the given package is being created.</dd>\n-<dt>Top-Level Import</dt>\n-<dd>An import coming from an entry point. The available top-level imports are what define the public API and are exposed in “@angular/name” modules, such as @angular/core  or @angular/common.</dd>\n-<dt>Tree-shaking</dt>\n-<dd>The process of identifying and removing code not used by an application - also known as dead code elimination. This is a global optimization performed at the application level using tools like Rollup, Closure Compiler, or Uglify.</dd>\n-<dt>AOT Compiler</dt>\n-<dd>The Ahead of Time Compiler for Angular.</dd>\n-<dt>Flattened Type Definitions</dt>\n-<dd>The bundled TypeScript definitions generated from api-extractor.</dd>\n-</dl>\n\\ No newline at end of file\n+#### Package\n+The smallest set of files that are published to NPM and installed together, for example `@angular/core`. This package includes a manifest called package.json, compiled source code, typescript definition files, source maps, metadata, etc. The package is installed with `npm install @angular/core`.\n+\n+#### Symbol\n+A class, function, constant or variable contained in a module and optionally made visible to the external world via a module export.\n+\n+#### Module\n+Short for ECMAScript Modules. A file containing statements that import and export symbols. This is identical to the definition of modules in the ECMAScript spec.\n+#### ESM\n+Short for ECMAScript Modules (see above).\n+\n+#### FESM\n+Short for Flattened ES Modules and consists of a file format created by flattening all ES Modules accessible from an entry point into a single ES Module.\n+\n+#### Module ID\n+The identifier of a module used in the import statements, e.g. `@angular/core`. The ID often maps directly to a path on the filesystem, but this is not always the case due to various module resolution strategies.\n+\n+#### Module Specifier\n+A module identifier (see above).\n+\n+#### Module Resolution Strategy\n+Algorithm used to convert Module IDs to paths on the filesystem. Node.js has one that is well specified and widely used, TypeScript supports several module resolution strategies, [Closure Compiler](https://developers.google.com/closure/compiler) has yet another strategy.</dd>\n+\n+#### Module Format\n+Specification of the module syntax that covers at minimum the syntax for the importing and exporting from a file. Common module formats are CommonJS (CJS, typically used for Node.js applications) or ECMAScript Modules (ESM). The module format indicates only the packaging of the individual modules, but not the JavaScript language features used to make up the module content. Because of this, the Angular team often uses the language level specifier as a suffix to the module format, e.g. ESM+ES2015 specifies that the module is in ESM format and contains code down-leveled to ES2015.\n+\n+#### Bundle\n+An artifact in the form of a single JS file, produced by a build tool, e.g. [Webpack](https://webpack.js.org/) or [Rollup](https://rollupjs.org/), that contains symbols originating in one or more modules. Bundles are a browser-specific workaround that reduce network strain that would be caused if browsers were to start downloading hundreds if not tens of thousands of files. Node.js typically doesn't use bundles. Common bundle formats are UMD and System.register.\n+\n+#### Language Level\n+The language of the code (ES2015 or ES2020). Independent of the module format.\n+\n+#### Entry Point\n+A module intended to be imported by the user. It is referenced by a unique module ID and exports the public API referenced by that module ID. An example is `@angular/core` or `@angular/core/testing`. Both entry points exist in the `@angular/core` package, but they export different symbols. A package can have many entry points.\n+\n+#### Deep Import\n+A process of retrieving symbols from modules that are not Entry Points. These module IDs are usually considered to be private APIs that can change over the lifetime of the project or while the bundle for the given package is being created.\n+\n+#### Top-Level Import\n+An import coming from an entry point. The available top-level imports are what define the public API and are exposed in “@angular/name” modules, such as `@angular/core` or `@angular/common`.\n+\n+#### Tree-shaking\n+The process of identifying and removing code not used by an application - also known as dead code elimination. This is a global optimization performed at the application level using tools like [Rollup](https://rollupjs.org/), [Closure Compiler](https://developers.google.com/closure/compiler), or [Terser](https://github.com/terser/terser/).\n+\n+#### AOT Compiler\n+The Ahead of Time Compiler for Angular.\n+\n+#### Flattened Type Definitions\n+The bundled TypeScript definitions generated from [API Extractor](https://api-extractor.com/).\n+\n+@reviewed 2021-11-04"
        }
    ],
    "stats": {
        "total": 96,
        "additions": 51,
        "deletions": 45
    }
}