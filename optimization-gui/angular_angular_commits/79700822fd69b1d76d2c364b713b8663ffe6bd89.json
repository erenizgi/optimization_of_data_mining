{
    "author": "atscott",
    "message": "refactor(router): remove unnecessary getTransition function (#43436)\n\nThe getTransition helper function ensures that urlAfterRedirects is assigned for when\nthe router does not process the previous or current URL. In this case, we would set\nthe browserUrlTree to be the urlAfterRedirects, which was initialized to be the browserUrlTree.\nThis is a no-op, so there's no need for the getTransition function at all.\n\nPR Close #43436",
    "sha": "79700822fd69b1d76d2c364b713b8663ffe6bd89",
    "files": [
        {
            "sha": "b6140bec2955e197f0028ebd4fc4cd8ccfbfb435",
            "filename": "packages/router/src/operators/recognize.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/79700822fd69b1d76d2c364b713b8663ffe6bd89/packages%2Frouter%2Fsrc%2Foperators%2Frecognize.ts",
            "raw_url": "https://github.com/angular/angular/raw/79700822fd69b1d76d2c364b713b8663ffe6bd89/packages%2Frouter%2Fsrc%2Foperators%2Frecognize.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Foperators%2Frecognize.ts?ref=79700822fd69b1d76d2c364b713b8663ffe6bd89",
            "patch": "@@ -21,7 +21,7 @@ export function recognize(\n     relativeLinkResolution: 'legacy'|'corrected'): MonoTypeOperatorFunction<NavigationTransition> {\n   return mergeMap(\n       t => recognizeFn(\n-               rootComponentType, config, t.urlAfterRedirects, serializer(t.urlAfterRedirects),\n+               rootComponentType, config, t.urlAfterRedirects!, serializer(t.urlAfterRedirects!),\n                paramsInheritanceStrategy, relativeLinkResolution)\n                .pipe(map(targetSnapshot => ({...t, targetSnapshot}))));\n }"
        },
        {
            "sha": "003315f2fca6cebc2835f1fc490102c039e27a2d",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 37,
            "deletions": 55,
            "changes": 92,
            "blob_url": "https://github.com/angular/angular/blob/79700822fd69b1d76d2c364b713b8663ffe6bd89/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/79700822fd69b1d76d2c364b713b8663ffe6bd89/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=79700822fd69b1d76d2c364b713b8663ffe6bd89",
            "patch": "@@ -305,27 +305,27 @@ export interface Navigation {\n   previousNavigation: Navigation|null;\n }\n \n-export type NavigationTransition = {\n-  id: number,\n-  targetPageId: number,\n-  currentUrlTree: UrlTree,\n-  currentRawUrl: UrlTree,\n-  extractedUrl: UrlTree,\n-  urlAfterRedirects: UrlTree,\n-  rawUrl: UrlTree,\n-  extras: NavigationExtras,\n-  resolve: any,\n-  reject: any,\n-  promise: Promise<boolean>,\n-  source: NavigationTrigger,\n-  restoredState: RestoredState|null,\n-  currentSnapshot: RouterStateSnapshot,\n-  targetSnapshot: RouterStateSnapshot|null,\n-  currentRouterState: RouterState,\n-  targetRouterState: RouterState|null,\n-  guards: Checks,\n-  guardsResult: boolean|UrlTree|null,\n-};\n+export interface NavigationTransition {\n+  id: number;\n+  targetPageId: number;\n+  currentUrlTree: UrlTree;\n+  currentRawUrl: UrlTree;\n+  extractedUrl: UrlTree;\n+  urlAfterRedirects?: UrlTree;\n+  rawUrl: UrlTree;\n+  extras: NavigationExtras;\n+  resolve: any;\n+  reject: any;\n+  promise: Promise<boolean>;\n+  source: NavigationTrigger;\n+  restoredState: RestoredState|null;\n+  currentSnapshot: RouterStateSnapshot;\n+  targetSnapshot: RouterStateSnapshot|null;\n+  currentRouterState: RouterState;\n+  targetRouterState: RouterState|null;\n+  guards: Checks;\n+  guardsResult: boolean|UrlTree|null;\n+}\n \n /**\n  * @internal\n@@ -695,6 +695,7 @@ export class Router {\n                                  this.config),\n \n                              // Update the currentNavigation\n+                             // `urlAfterRedirects` is guaranteed to be set after this point\n                              tap(t => {\n                                this.currentNavigation = {\n                                  ...this.currentNavigation!,\n@@ -713,16 +714,16 @@ export class Router {\n                                if (this.urlUpdateStrategy === 'eager') {\n                                  if (!t.extras.skipLocationChange) {\n                                    const rawUrl = this.urlHandlingStrategy.merge(\n-                                       t.urlAfterRedirects, t.rawUrl);\n+                                       t.urlAfterRedirects!, t.rawUrl);\n                                    this.setBrowserUrl(rawUrl, t);\n                                  }\n-                                 this.browserUrlTree = t.urlAfterRedirects;\n+                                 this.browserUrlTree = t.urlAfterRedirects!;\n                                }\n \n                                // Fire RoutesRecognized\n                                const routesRecognized = new RoutesRecognized(\n                                    t.id, this.serializeUrl(t.extractedUrl),\n-                                   this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot!);\n+                                   this.serializeUrl(t.urlAfterRedirects!), t.targetSnapshot!);\n                                eventsSubject.next(routesRecognized);\n                              }));\n                        } else {\n@@ -752,7 +753,6 @@ export class Router {\n                             * in the browser.\n                             */\n                            this.rawUrlTree = t.rawUrl;\n-                           this.browserUrlTree = t.urlAfterRedirects;\n                            t.resolve(null);\n                            return EMPTY;\n                          }\n@@ -781,7 +781,7 @@ export class Router {\n                      tap(t => {\n                        const guardsStart = new GuardsCheckStart(\n                            t.id, this.serializeUrl(t.extractedUrl),\n-                           this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot!);\n+                           this.serializeUrl(t.urlAfterRedirects!), t.targetSnapshot!);\n                        this.triggerEvent(guardsStart);\n                      }),\n \n@@ -802,7 +802,7 @@ export class Router {\n \n                        const guardsEnd = new GuardsCheckEnd(\n                            t.id, this.serializeUrl(t.extractedUrl),\n-                           this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot!,\n+                           this.serializeUrl(t.urlAfterRedirects!), t.targetSnapshot!,\n                            !!t.guardsResult);\n                        this.triggerEvent(guardsEnd);\n                      }),\n@@ -823,7 +823,7 @@ export class Router {\n                              tap(t => {\n                                const resolveStart = new ResolveStart(\n                                    t.id, this.serializeUrl(t.extractedUrl),\n-                                   this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot!);\n+                                   this.serializeUrl(t.urlAfterRedirects!), t.targetSnapshot!);\n                                this.triggerEvent(resolveStart);\n                              }),\n                              switchMap(t => {\n@@ -847,7 +847,7 @@ export class Router {\n                              tap(t => {\n                                const resolveEnd = new ResolveEnd(\n                                    t.id, this.serializeUrl(t.extractedUrl),\n-                                   this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot!);\n+                                   this.serializeUrl(t.urlAfterRedirects!), t.targetSnapshot!);\n                                this.triggerEvent(resolveEnd);\n                              }));\n                        }\n@@ -884,17 +884,17 @@ export class Router {\n                         URL and the RouterState, as well as updated the browser URL. All this should\n                         happen *before* activating. */\n                      tap((t: NavigationTransition) => {\n-                       this.currentUrlTree = t.urlAfterRedirects;\n+                       this.currentUrlTree = t.urlAfterRedirects!;\n                        this.rawUrlTree =\n-                           this.urlHandlingStrategy.merge(t.urlAfterRedirects, t.rawUrl);\n+                           this.urlHandlingStrategy.merge(t.urlAfterRedirects!, t.rawUrl);\n \n                        (this as {routerState: RouterState}).routerState = t.targetRouterState!;\n \n                        if (this.urlUpdateStrategy === 'deferred') {\n                          if (!t.extras.skipLocationChange) {\n                            this.setBrowserUrl(this.rawUrlTree, t);\n                          }\n-                         this.browserUrlTree = t.urlAfterRedirects;\n+                         this.browserUrlTree = t.urlAfterRedirects!;\n                        }\n                      }),\n \n@@ -1036,24 +1036,8 @@ export class Router {\n     this.routerState.root.component = this.rootComponentType;\n   }\n \n-  private getTransition(): NavigationTransition {\n-    const transition = this.transitions.value;\n-    // TODO(atscott): This comment doesn't make it clear why this value needs to be set. In the case\n-    // described below (where we don't handle previous or current url), the `browserUrlTree` is set\n-    // to the `urlAfterRedirects` value. However, these values *are already the same* because of the\n-    // line below. So it seems that we should be able to remove the line below and the line where\n-    // `browserUrlTree` is updated when we aren't handling any part of the navigation url.\n-    // Run TGP to confirm that this can be done.\n-\n-    // This value needs to be set. Other values such as extractedUrl are set on initial navigation\n-    // but the urlAfterRedirects may not get set if we aren't processing the new URL *and* not\n-    // processing the previous URL.\n-    transition.urlAfterRedirects = this.browserUrlTree;\n-    return transition;\n-  }\n-\n   private setTransition(t: Partial<NavigationTransition>): void {\n-    this.transitions.next({...this.getTransition(), ...t});\n+    this.transitions.next({...this.transitions.value, ...t});\n   }\n \n   /**\n@@ -1389,16 +1373,14 @@ export class Router {\n       return Promise.resolve(false);\n     }\n \n-    // * Imperative navigations (router.navigate) might trigger additional navigations to the same\n-    //   URL via a popstate event and the locationChangeListener. We should skip these duplicate\n-    //   navs. Duplicates may also be triggered by attempts to sync AngularJS and Angular router\n-    //   states.\n+    // * Duplicate navigations may also be triggered by attempts to sync AngularJS and Angular\n+    // router states.\n     // * Imperative navigations can be cancelled by router guards, meaning the URL won't change. If\n     //   the user follows that with a navigation using the back/forward button or manual URL change,\n     //   the destination may be the same as the previous imperative attempt. We should not skip\n     //   these navigations because it's a separate case from the one above -- it's not a duplicate\n     //   navigation.\n-    const lastNavigation = this.getTransition();\n+    const lastNavigation = this.transitions.value;\n     // We don't want to skip duplicate successful navs if they're imperative because\n     // onSameUrlNavigation could be 'reload' (so the duplicate is intended).\n     const browserNavPrecededByRouterNav = isBrowserTriggeredNavigation(source) && lastNavigation &&\n@@ -1408,7 +1390,7 @@ export class Router {\n     // However, if it failed, we should compare to the final result (urlAfterRedirects).\n     const lastNavigationUrl = (lastNavigationSucceeded || this.currentNavigation) ?\n         lastNavigation.rawUrl :\n-        lastNavigation.urlAfterRedirects;\n+        (lastNavigation.urlAfterRedirects ?? this.browserUrlTree);\n     const duplicateNav = lastNavigationUrl.toString() === rawUrl.toString();\n     if (browserNavPrecededByRouterNav && duplicateNav) {\n       return Promise.resolve(true);  // return value is not used"
        },
        {
            "sha": "9095d12dab1aa5057bc1bfec83354c0781a12c3b",
            "filename": "packages/router/test/integration.spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/79700822fd69b1d76d2c364b713b8663ffe6bd89/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/79700822fd69b1d76d2c364b713b8663ffe6bd89/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fintegration.spec.ts?ref=79700822fd69b1d76d2c364b713b8663ffe6bd89",
            "patch": "@@ -314,39 +314,6 @@ describe('Integration', () => {\n        })));\n   });\n \n-\n-  /**\n-   * get/setTransition are private APIs. This test is needed though to guarantee the correct\n-   * values are being used. Related to https://github.com/angular/angular/issues/30340 where\n-   * stale transition data was being used when kicking off a new navigation.\n-   */\n-  describe('get/setTransition', () => {\n-    it('should provide the most recent NavigationTransition',\n-       fakeAsync(inject([Router, Location], (router: Router, location: SpyLocation) => {\n-         router.resetConfig([\n-           {path: '', component: SimpleCmp}, {path: 'a', component: SimpleCmp},\n-           {path: 'b', component: SimpleCmp}\n-         ]);\n-\n-         const fixture = createRoot(router, RootCmp);\n-\n-         const initialTransition = (router as any).getTransition();\n-\n-         // Confirm initial value\n-         expect(initialTransition.urlAfterRedirects.toString()).toBe('/');\n-\n-\n-         router.navigateByUrl('/a', {replaceUrl: true});\n-\n-         tick();\n-\n-         // After a navigation, we should see the URL after redirect\n-         const nextTransition = (router as any).getTransition();\n-         // Confirm initial value\n-         expect(nextTransition.urlAfterRedirects.toString()).toBe('/a');\n-       })));\n-  });\n-\n   describe('navigation warning', () => {\n     const isInAngularZoneFn = NgZone.isInAngularZone;\n     let warnings: string[] = [];"
        }
    ],
    "stats": {
        "total": 127,
        "additions": 38,
        "deletions": 89
    }
}