{
    "author": "kapunahelewong",
    "message": "docs: edit dependency-injection.md (#39255)\n\nPR Close #39255",
    "sha": "93d689ffa8cc11131fc3297bec57b210949132f5",
    "files": [
        {
            "sha": "402c5292ea5d87a0a96b968994075780224f54cc",
            "filename": "aio/content/examples/dependency-injection/src/app/heroes/hero.service.3.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/93d689ffa8cc11131fc3297bec57b210949132f5/aio%2Fcontent%2Fexamples%2Fdependency-injection%2Fsrc%2Fapp%2Fheroes%2Fhero.service.3.ts",
            "raw_url": "https://github.com/angular/angular/raw/93d689ffa8cc11131fc3297bec57b210949132f5/aio%2Fcontent%2Fexamples%2Fdependency-injection%2Fsrc%2Fapp%2Fheroes%2Fhero.service.3.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fexamples%2Fdependency-injection%2Fsrc%2Fapp%2Fheroes%2Fhero.service.3.ts?ref=93d689ffa8cc11131fc3297bec57b210949132f5",
            "patch": "@@ -3,7 +3,7 @@ import { Injectable } from '@angular/core';\n import { HEROES } from './mock-heroes';\n \n @Injectable({\n-  // we declare that this service should be created\n+  // declares that this service should be created\n   // by the root application injector.\n   providedIn: 'root',\n })"
        },
        {
            "sha": "dc3906be6c15822e02dec37670eb62c9a986b40a",
            "filename": "aio/content/guide/dependency-injection-providers.md",
            "status": "modified",
            "additions": 33,
            "deletions": 8,
            "changes": 41,
            "blob_url": "https://github.com/angular/angular/blob/93d689ffa8cc11131fc3297bec57b210949132f5/aio%2Fcontent%2Fguide%2Fdependency-injection-providers.md",
            "raw_url": "https://github.com/angular/angular/raw/93d689ffa8cc11131fc3297bec57b210949132f5/aio%2Fcontent%2Fguide%2Fdependency-injection-providers.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fdependency-injection-providers.md?ref=93d689ffa8cc11131fc3297bec57b210949132f5",
            "patch": "@@ -17,9 +17,33 @@ You can, however, configure an injector with an alternative provider in order to\n \n You can configure an injector with a service class, you can provide a substitute class, an object, or a factory function.\n \n+\n+{@a token}\n+\n+{@a injection-token}\n+\n+## Dependency injection tokens\n+\n+When you configure an [injector](guide/glossary#injector) with a [provider](guide/glossary#provider), you are associating that provider with a [dependency injection token](guide/glossary#di-token), or DI token.\n+The injector allows Angular create a map of any internal dependencies.\n+The DI token acts as a key to that map.\n+\n+The dependency value is an instance, and the class type serves as a lookup key.\n+Here, the injector uses the `HeroService` type as the token for looking up `heroService`.\n+\n+<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"get-hero-service\" header=\"src/app/injector.component.ts\"></code-example>\n+\n+When you define a constructor parameter with the `HeroService` class type, Angular knows to inject the service associated with that `HeroService` class token:\n+\n+<code-example path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\" header=\"src/app/heroes/hero-list.component.ts\">\n+</code-example>\n+\n+Though classes provide many dependency values, the expanded `provide` object lets you associate different kinds of providers with a DI token.\n+\n+\n {@a provide}\n \n-##  Defining providers\n+## Defining providers\n \n The class provider syntax is a shorthand expression that expands into a provider configuration, defined by the [`Provider` interface](api/core/Provider).\n The following example is the class provider syntax for providing a `Logger` class in the `providers` array.\n@@ -34,19 +58,20 @@ Angular expands the `providers` value into a full provider object as follows.\n \n The expanded provider configuration is an object literal with two properties.\n \n-1. The `provide` property holds the [token](guide/dependency-injection#token) that serves as the key for both locating a dependency value and configuring the injector.\n-2. The second property is a provider definition object, which tells the injector how to create the dependency value.\n+* The `provide` property holds the [token](#token)\n+that serves as the key for both locating a dependency value and configuring the injector.\n+\n+* The second property is a provider definition object, which tells the injector how to create the dependency value.\n The provider-definition key can be `useClass`, as in the example.\n It can also be `useExisting`, `useValue`, or `useFactory`.\n Each of these keys provides a different type of dependency, as discussed below.\n \n-\n {@a class-provider}\n \n-## Configuring the injector to use alternative class providers\n+## Specifying an alternative class provider\n \n-To configure the injector to return a different class that provides the same service, you can use the `useClass` property.\n-In this example, the injector returns a `BetterLogger` instance when using the `Logger` token.\n+Different classes can provide the same service.\n+For example, the following code tells the injector to return a `BetterLogger` instance when the component asks for a logger using the `Logger` token.\n \n <code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-4\" >\n </code-example>\n@@ -198,7 +223,7 @@ You inject both `Logger` and `UserService` into the factory provider so the inje\n \n * The `useFactory` field specifies that the provider is a factory function whose implementation is `heroServiceFactory`.\n \n-* The `deps` property is an array of [provider tokens](guide/dependency-injection#token).\n+* The `deps` property is an array of [provider tokens](#token).\n The `Logger` and `UserService` classes serve as tokens for their own class providers.\n The injector resolves these tokens and injects the corresponding services into the matching `heroServiceFactory` factory function parameters.\n "
        },
        {
            "sha": "c66cb9382b31e0e9b4cfb3d5c1e76dba9a45dd61",
            "filename": "aio/content/guide/dependency-injection.md",
            "status": "modified",
            "additions": 36,
            "deletions": 250,
            "changes": 286,
            "blob_url": "https://github.com/angular/angular/blob/93d689ffa8cc11131fc3297bec57b210949132f5/aio%2Fcontent%2Fguide%2Fdependency-injection.md",
            "raw_url": "https://github.com/angular/angular/raw/93d689ffa8cc11131fc3297bec57b210949132f5/aio%2Fcontent%2Fguide%2Fdependency-injection.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fdependency-injection.md?ref=93d689ffa8cc11131fc3297bec57b210949132f5",
            "patch": "@@ -1,217 +1,80 @@\n # Dependency injection in Angular\n \n-Dependency injection (DI), is an important application design pattern.\n-Angular has its own DI framework, which is typically\n-used in the design of Angular applications to increase their efficiency and modularity.\n-\n Dependencies are services or objects that a class needs to perform its function.\n-DI is a coding pattern in which a class asks for dependencies from external sources rather than creating them itself.\n-\n-In Angular, the DI framework provides declared dependencies to a class when that class is instantiated. This guide explains how DI works in Angular, and how you use it to make your apps flexible, efficient, and robust, as well as testable and maintainable.\n-\n-<div class=\"alert is-helpful\">\n-\n- You can run the <live-example></live-example> of the sample app that accompanies this guide.\n-\n-</div>\n-\n-Start by reviewing this simplified version of the _heroes_ feature\n-from the [The Tour of Heroes](tutorial/). This simple version doesn't use DI; we'll walk through converting it to do so.\n-\n-<code-tabs>\n-  <code-pane header=\"src/app/heroes/heroes.component.ts\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" region=\"v1\">\n-  </code-pane>\n-\n-  <code-pane header=\"src/app/heroes/hero-list.component.ts\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\n-  </code-pane>\n-\n-  <code-pane header=\"src/app/heroes/hero.ts\" path=\"dependency-injection/src/app/heroes/hero.ts\">\n-  </code-pane>\n-\n-  <code-pane header=\"src/app/heroes/mock-heroes.ts\" path=\"dependency-injection/src/app/heroes/mock-heroes.ts\">\n-  </code-pane>\n-\n-</code-tabs>\n-\n-`HeroesComponent` is the top-level heroes component.\n-Its only purpose is to display `HeroListComponent`, which displays a list of hero names.\n-\n-This version of the `HeroListComponent` gets heroes from the `HEROES` array, an in-memory collection\n-defined in a separate `mock-heroes` file.\n+Dependency injection, or DI, is a design pattern in which a class requests dependencies from external sources rather than creating them.\n \n-<code-example header=\"src/app/heroes/hero-list.component.ts (class)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\" region=\"class\">\n-</code-example>\n-\n-This approach works for prototyping, but is not robust or maintainable.\n-As soon as you try to test this component or get heroes from a remote server,\n-you have to change the implementation of `HeroesListComponent` and\n-replace every use of the `HEROES` mock data.\n-\n-\n-## Create and register an injectable service\n-\n-The DI framework lets you supply data to a component from an injectable _service_ class, defined in its own file. To demonstrate, we'll create an injectable service class that provides a list of heroes, and register that class as a provider of that service.\n+Angular's DI framework provides dependencies to a class upon instantiation.\n+You can use Angular DI to increase flexibility and modularity in your applications.\n \n <div class=\"alert is-helpful\">\n \n-Having multiple classes in the same file can be confusing. We generally recommend that you define components and services in separate files.\n-\n-If you do combine a component and service in the same file,\n-it is important to define the service first, and then the component. If you define the component before the service, you get a run-time null reference error.\n-\n-It is possible to define the component first with the help of the `forwardRef()` method as explained in this [blog post](https://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html).\n-\n-You can also use forward references to break circular dependencies.\n-See an example in the [DI Cookbook](guide/dependency-injection-in-action#forwardref).\n+See the <live-example></live-example> for a working example containing the code snippets in this guide.\n \n </div>\n \n-### Create an injectable service class\n+## Creating an injectable service\n \n-The [Angular CLI](cli) can generate a new `HeroService` class in the `src/app/heroes` folder with this command.\n+To generate a new `HeroService` class in the `src/app/heroes` folder use the following [Angular CLI](cli) command.\n \n <code-example language=\"sh\" class=\"code-shell\">\n ng generate service heroes/hero\n </code-example>\n \n-The command creates the following `HeroService` skeleton.\n+This command creates the following default `HeroService`.\n \n <code-example path=\"dependency-injection/src/app/heroes/hero.service.0.ts\" header=\"src/app/heroes/hero.service.ts (CLI-generated)\">\n </code-example>\n \n-The `@Injectable()` is an essential ingredient in every Angular service definition. The rest of the class has been written to expose a `getHeroes` method that returns the same mock data as before. (A real app would probably get its data asynchronously from a remote server, but we'll ignore that to focus on the mechanics of injecting the service.)\n+The `@Injectable()` decorator specifies that Angular can use this class in the DI system.\n+The metadata, `providedIn: 'root'`, means that the `HeroService` is visible throughout the application.\n+\n+Next, to get the hero mock data, add a `getHeroes()` method that returns the heroes from `mock.heroes.ts`.\n \n <code-example path=\"dependency-injection/src/app/heroes/hero.service.3.ts\" header=\"src/app/heroes/hero.service.ts\">\n </code-example>\n \n+For clarity and maintainability, it is recommended that you define components and services in separate files.\n \n-{@a injector-config}\n-{@a bootstrap}\n-\n-### Configure an injector with a service provider\n-\n-The class we have created provides a service. The `@Injectable()` decorator marks it as a service\n-that can be injected, but Angular can't actually inject it anywhere until you configure\n-an Angular [dependency injector](guide/glossary#injector) with a [provider](guide/glossary#provider) of that service.\n-\n-The injector is responsible for creating service instances and injecting them into classes like `HeroListComponent`.\n-You rarely create an Angular injector yourself. Angular creates injectors for you as it executes the app, starting with the _root injector_ that it creates during the [bootstrap process](guide/bootstrapping).\n-\n-A provider tells an injector _how to create the service_.\n-You must configure an injector with a provider before that injector can create a service (or provide any other kind of dependency).\n-\n-A provider can be the service class itself, so that the injector can use `new` to create an instance.\n-You might also define more than one class to provide the same service in different ways,\n-and configure different injectors with different providers.\n-\n-<div class=\"alert is-helpful\">\n-\n-Injectors are inherited, which means that if a given injector can't resolve a dependency,\n-it asks the parent injector to resolve it.\n-A component can get services from its own injector,\n-from the injectors of its component ancestors,\n-from the injector of its parent NgModule, or from the `root` injector.\n-\n-* Learn more about the [different kinds of providers](guide/dependency-injection-providers).\n-\n-* Learn more about how the [injector hierarchy](guide/hierarchical-dependency-injection) works.\n+If you do combine a component and service in the same file, it is important to define the service first, and then the component.\n+If you define the component before the service, Angular returns a run-time null reference error.\n \n-</div>\n-\n-You can configure injectors with providers at different levels of your app, by setting a metadata value in one of three places:\n-\n-* In the `@Injectable()` decorator for the service itself.\n-\n-* In the `@NgModule()` decorator for an NgModule.\n-\n-* In the `@Component()` decorator for a component.\n-\n-The `@Injectable()` decorator has the `providedIn` metadata option, where you can specify the provider of the decorated service class with the `root` injector, or with the injector for a specific NgModule.\n-\n-The `@NgModule()` and `@Component()` decorators have the `providers` metadata option, where you can configure providers for NgModule-level or component-level injectors.\n-\n-<div class=\"alert is-helpful\">\n-\n-Components are directives, and the `providers` option is inherited from `@Directive()`. You can also configure providers for directives and pipes at the same level as the component.\n-\n-Learn more about [where to configure providers](guide/hierarchical-dependency-injection).\n-\n-</div>\n \n {@a injector-config}\n {@a bootstrap}\n \n ## Injecting services\n \n-In order for `HeroListComponent` to get heroes from `HeroService`, it needs to ask for `HeroService` to be injected, rather than creating its own `HeroService` instance with `new`.\n+Injecting services results in making them visible to a component.\n \n-You can tell Angular to inject a dependency in a component's constructor by specifying a **constructor parameter with the dependency type**. Here's the `HeroListComponent` constructor, asking for the `HeroService` to be injected.\n+To inject a dependency in a component's `constructor()`, supply a constructor argument with the dependency type.\n+The following example specifies the `HeroService` in the `HeroListComponent` constructor.\n+The type of `heroService` is `HeroService`.\n \n <code-example header=\"src/app/heroes/hero-list.component (constructor signature)\" path=\"dependency-injection/src/app/heroes/hero-list.component.ts\"\n region=\"ctor-signature\">\n </code-example>\n \n-Of course, `HeroListComponent` should do something with the injected `HeroService`.\n-Here's the revised component, making use of the injected service, side-by-side with the previous version for comparison.\n-\n-<code-tabs>\n-  <code-pane header=\"hero-list.component (with DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.2.ts\">\n-  </code-pane>\n-\n-  <code-pane header=\"hero-list.component (without DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\n-  </code-pane>\n-</code-tabs>\n-\n-`HeroService` must be provided in some parent injector. The code in `HeroListComponent` doesn't depend on where `HeroService` comes from.\n-If you decided to provide `HeroService` in `AppModule`, `HeroListComponent` wouldn't change.\n-\n-{@a singleton-services}\n-{@a component-child-injectors}\n-\n-### Injector hierarchy and service instances\n-\n-Services are singletons _within the scope of an injector_. That is, there is at most one instance of a service in a given injector.\n-\n-There is only one root injector for an app. Providing `UserService` at the `root` or `AppModule` level means it is registered with the root injector. There is just one `UserService` instance in the entire app and every class that injects `UserService` gets this service instance _unless_ you configure another provider with a _child injector_.\n-\n-Angular DI has a [hierarchical injection system](guide/hierarchical-dependency-injection), which means that nested injectors can create their own service instances.\n-Angular regularly creates nested injectors. Whenever Angular creates a new instance of a component that has `providers` specified in `@Component()`, it also creates a new _child injector_ for that instance.\n-Similarly, when a new NgModule is lazy-loaded at run time, Angular can create an injector for it with its own providers.\n-\n-Child modules and component injectors are independent of each other, and create their own separate instances of the provided services. When Angular destroys an NgModule or component instance, it also destroys that injector and that injector's service instances.\n-\n-Thanks to [injector inheritance](guide/hierarchical-dependency-injection),\n-you can still inject application-wide services into these components.\n-A component's injector is a child of its parent component's injector, and inherits from all ancestor injectors all the way back to the application's _root_ injector. Angular can inject a service provided by any injector in that lineage.\n-\n-For example, Angular can inject `HeroListComponent` with both the `HeroService` provided in `HeroComponent` and the `UserService` provided in `AppModule`.\n \n-{@a testing-the-component}\n+For more information, see and [Providing dependencies in modules](guide/providers) and [Hierarchical injectors](guide/hierarchical-dependency-injection).\n \n-## Testing components with dependencies\n-\n-Designing a class with dependency injection makes the class easier to test.\n-Listing dependencies as constructor parameters may be all you need to test application parts effectively.\n-\n-For example, you can create a new `HeroListComponent` with a mock service that you can manipulate\n-under test.\n+{@a service-needs-service}\n \n-<code-example path=\"dependency-injection/src/app/test.component.ts\" region=\"spec\" header=\"src/app/test.component.ts\"></code-example>\n+## Using services in other services\n \n-<div class=\"alert is-helpful\">\n+When a service depends on another service, follow the same pattern as injecting into a component.\n+In the following example `HeroService` depends on a `Logger` service to report its activities.\n \n-Learn more in the [Testing](guide/testing) guide.\n+First, import the `Logger` service.\n+Next, inject the `Logger` service in the `HeroService` `constructor()` by specifying `private logger: Logger` within the parentheses.\n \n-</div>\n-\n-{@a service-needs-service}\n+When you create a class whose `constructor()` has parameters, specify the type and metadata about those parameters so that Angular can inject the correct service.\n \n-## Services that need other services\n+Here, the `constructor()` specifies a type of `Logger` and stores the instance of `Logger` in a private field called `logger`.\n \n-Services can have their own dependencies. `HeroService` is very simple and doesn't have any dependencies of its own. Suppose, however, that you want it to report its activities through a logging service. You can apply the same *constructor injection* pattern,\n-adding a constructor that takes a `Logger` parameter.\n \n-Here is the revised `HeroService` that injects `Logger`, side by side with the previous service for comparison.\n+The following code tabs feature the `Logger` service and two versions of `HeroService`.\n+The first version of `HeroService` does not depend on the `Logger` service.\n+The revised second version does depend on `Logger` service.\n \n <code-tabs>\n \n@@ -227,90 +90,13 @@ Here is the revised `HeroService` that injects `Logger`, side by side with the p\n \n </code-tabs>\n \n-The constructor asks for an injected instance of `Logger` and stores it in a private field called `logger`. The `getHeroes()` method logs a message when asked to fetch heroes.\n-\n-Notice that the `Logger` service also has the `@Injectable()` decorator, even though it might not need its own dependencies. In fact, the `@Injectable()` decorator is **required for all services**.\n-\n-When Angular creates a class whose constructor has parameters, it looks for type and injection metadata about those parameters so that it can inject the correct service.\n-If Angular can't find that parameter information, it throws an error.\n-Angular can only find the parameter information _if the class has a decorator of some kind_.\n-The `@Injectable()` decorator is the standard decorator for service classes.\n-\n-<div class=\"alert is-helpful\">\n-\n- The decorator requirement is imposed by TypeScript. TypeScript normally discards parameter type information when it [transpiles](guide/glossary#transpile) the code to JavaScript. TypeScript preserves this information if the class has a decorator and the `emitDecoratorMetadata` compiler option is set `true` in TypeScript's `tsconfig.json` configuration file. The CLI configures `tsconfig.json` with `emitDecoratorMetadata: true`.\n-\n- This means you're responsible for putting `@Injectable()` on your service classes.\n-\n-</div>\n-\n-{@a token}\n-\n-{@a injection-token}\n-\n-### Dependency injection tokens\n-\n-When you configure an injector with a provider, you associate that provider with a [DI token](guide/glossary#di-token).\n-The injector maintains an internal *token-provider* map that it references when\n-asked for a dependency. The token is the key to the map.\n-\n-In simple examples, the dependency value is an *instance*, and\n-the class *type* serves as its own lookup key.\n-Here you get a `HeroService` directly from the injector by supplying the `HeroService` type as the token:\n-\n-<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"get-hero-service\" header=\"src/app/injector.component.ts\"></code-example>\n-\n-The behavior is similar when you write a constructor that requires an injected class-based dependency.\n-When you define a constructor parameter with the `HeroService` class type,\n-Angular knows to inject the service associated with that `HeroService` class token:\n-\n-<code-example path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\" header=\"src/app/heroes/hero-list.component.ts\">\n-</code-example>\n-\n-Many dependency values are provided by classes, but not all. The expanded *provide* object lets you associate different kinds of providers with a DI token.\n-\n-* Learn more about [different kinds of providers](guide/dependency-injection-providers).\n-\n-{@a optional}\n-\n-### Optional dependencies\n-\n-`HeroService` *requires* a logger, but what if it could get by without\n-one?\n-\n-When a component or service declares a dependency, the class constructor takes that dependency as a parameter.\n-You can tell Angular that the dependency is optional by annotating the\n-constructor parameter with `@Optional()`.\n-\n-<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"import-optional\">\n-</code-example>\n-\n-<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-10-ctor\"></code-example>\n-\n-When using `@Optional()`, your code must be prepared for a null value. If you\n-don't register a logger provider anywhere, the injector sets the\n-value of `logger` to null.\n-\n-<div class=\"alert is-helpful\">\n-\n-`@Inject()` and `@Optional()` are _parameter decorators_. They alter the way the DI framework provides a dependency, by annotating the dependency parameter on the constructor of the class that requires the dependency.\n-\n-Learn more about parameter decorators in [Hierarchical Dependency Injectors](guide/hierarchical-dependency-injection).\n-\n-</div>\n-\n-## Summary\n-\n-You learned the basics of Angular dependency injection in this page.\n-You can register various kinds of providers,\n-and you know how to ask for an injected object (such as a service) by\n-adding a parameter to a constructor.\n \n-Dive deeper into the capabilities and advanced feature of the Angular DI system in the following pages:\n+In this example, the `getHeroes()` method uses the `Logger` service by logging a message when fetching heroes.\n \n-* Learn more about nested injectors in\n-[Hierarchical Dependency Injection](guide/hierarchical-dependency-injection).\n+<hr />\n \n-* Learn more about [DI tokens and providers](guide/dependency-injection-providers).\n+## What's next\n \n-* [Dependency Injection in Action](guide/dependency-injection-in-action) is a cookbook for some of the interesting things you can do with DI.\n+* [Dependency providers](guide/dependency-injection-providers)\n+* [DI tokens and providers](guide/dependency-injection-providers)\n+* [Dependency Injection in Action](guide/dependency-injection-in-action)"
        },
        {
            "sha": "2d7b8e1d9404ecd3d6c7fa9801996f6b31e27dd2",
            "filename": "aio/content/guide/providers.md",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/93d689ffa8cc11131fc3297bec57b210949132f5/aio%2Fcontent%2Fguide%2Fproviders.md",
            "raw_url": "https://github.com/angular/angular/raw/93d689ffa8cc11131fc3297bec57b210949132f5/aio%2Fcontent%2Fguide%2Fproviders.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fproviders.md?ref=93d689ffa8cc11131fc3297bec57b210949132f5",
            "patch": "@@ -81,6 +81,22 @@ The router works at the root level so if you put providers in a component, even\n <!-- KW--Make a diagram here -->\n Register a provider with a component when you must limit a service instance to a component and its component tree, that is, its child components. For example, a user editing component, `UserEditorComponent`, that needs a private copy of a caching `UserService` should register the `UserService` with the `UserEditorComponent`. Then each new instance of the `UserEditorComponent` gets its own cached service instance.\n \n+{@a singleton-services}\n+{@a component-child-injectors}\n+\n+## Injector hierarchy and service instances\n+\n+Services are singletons within the scope of an injector, which means there is at most one instance of a service in a given injector.\n+\n+Angular DI has a [hierarchical injection system](guide/hierarchical-dependency-injection), which means that nested injectors can create their own service instances.\n+Whenever Angular creates a new instance of a component that has `providers` specified in `@Component()`, it also creates a new child injector for that instance.\n+Similarly, when a new NgModule is lazy-loaded at run time, Angular can create an injector for it with its own providers.\n+\n+Child modules and component injectors are independent of each other, and create their own separate instances of the provided services. When Angular destroys an NgModule or component instance, it also destroys that injector and that injector's service instances.\n+\n+For more information, see [Hierarchical injectors](guide/hierarchical-dependency-injection).\n+\n+\n \n <hr>\n "
        }
    ],
    "stats": {
        "total": 345,
        "additions": 86,
        "deletions": 259
    }
}