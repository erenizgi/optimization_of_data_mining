{
    "author": "JoostK",
    "message": "perf(compiler-cli): only generate directive declarations when used (#38418)\n\nThe template type-checker would always generate a directive declaration\neven if its type was never used. For example, directives without any\ninput nor output bindings nor exportAs references don't need the\ndirective to be declared, as its type would never be used.\n\nThis commit makes the `TcbOp`s that are responsible for declaring a\ndirective as optional, such that they are only executed when requested\nfrom another operation.\n\nPR Close #38418",
    "sha": "fb8f4b4d721e98a3b0f8163af6411dbab35f775e",
    "files": [
        {
            "sha": "5a5535057c92533f341fd32f455f0b03ff9a2e4c",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 4,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/fb8f4b4d721e98a3b0f8163af6411dbab35f775e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/fb8f4b4d721e98a3b0f8163af6411dbab35f775e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=fb8f4b4d721e98a3b0f8163af6411dbab35f775e",
            "patch": "@@ -355,7 +355,10 @@ class TcbDirectiveTypeOp extends TcbOp {\n   }\n \n   get optional() {\n-    return false;\n+    // The statement generated by this operation is only used to declare the directive's type and\n+    // won't report diagnostics by itself, so the operation is marked as optional to avoid\n+    // generating declarations for directives that don't have any inputs/outputs.\n+    return true;\n   }\n \n   execute(): ts.Identifier {\n@@ -387,7 +390,9 @@ class TcbDirectiveCtorOp extends TcbOp {\n   }\n \n   get optional() {\n-    return false;\n+    // The statement generated by this operation is only used to infer the directive's type and\n+    // won't report diagnostics by itself, so the operation is marked as optional.\n+    return true;\n   }\n \n   execute(): ts.Identifier {\n@@ -452,7 +457,7 @@ class TcbDirectiveInputsOp extends TcbOp {\n   }\n \n   execute(): null {\n-    const dirId = this.scope.resolve(this.node, this.dir);\n+    let dirId: ts.Expression|null = null;\n \n     // TODO(joost): report duplicate properties\n \n@@ -502,6 +507,10 @@ class TcbDirectiveInputsOp extends TcbOp {\n           // (i.e. private/protected/readonly), generate an assignment into a temporary variable\n           // that has the type of the field. This achieves type-checking but circumvents the access\n           // modifiers.\n+          if (dirId === null) {\n+            dirId = this.scope.resolve(this.node, this.dir);\n+          }\n+\n           const id = this.tcb.allocateId();\n           const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);\n           if (!ts.isTypeReferenceNode(dirTypeRef)) {\n@@ -515,6 +524,10 @@ class TcbDirectiveInputsOp extends TcbOp {\n           this.scope.addStatement(temp);\n           target = id;\n         } else {\n+          if (dirId === null) {\n+            dirId = this.scope.resolve(this.node, this.dir);\n+          }\n+\n           // To get errors assign directly to the fields on the instance, using property access\n           // when possible. String literal fields may not be valid JS identifiers so we use\n           // literal element access instead for those cases.\n@@ -718,7 +731,8 @@ class TcbDirectiveOutputsOp extends TcbOp {\n   }\n \n   execute(): null {\n-    const dirId = this.scope.resolve(this.node, this.dir);\n+    let dirId: ts.Expression|null = null;\n+\n \n     // `dir.outputs` is an object map of field names on the directive class to event names.\n     // This is backwards from what's needed to match event handlers - a map of event names to field\n@@ -748,6 +762,9 @@ class TcbDirectiveOutputsOp extends TcbOp {\n         // that has a `subscribe` method that properly carries the `T` into the handler function.\n         const handler = tcbCreateEventHandler(output, this.tcb, this.scope, EventParamType.Infer);\n \n+        if (dirId === null) {\n+          dirId = this.scope.resolve(this.node, this.dir);\n+        }\n         const outputField = ts.createElementAccess(dirId, ts.createStringLiteral(field));\n         const outputHelper =\n             ts.createCall(this.tcb.env.declareOutputHelper(), undefined, [outputField]);"
        },
        {
            "sha": "ab7c6e73aaad044f2c701b18fcf56a304906246c",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_check_block_spec.ts",
            "status": "modified",
            "additions": 80,
            "deletions": 31,
            "changes": 111,
            "blob_url": "https://github.com/angular/angular/blob/fb8f4b4d721e98a3b0f8163af6411dbab35f775e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fb8f4b4d721e98a3b0f8163af6411dbab35f775e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts?ref=fb8f4b4d721e98a3b0f8163af6411dbab35f775e",
            "patch": "@@ -156,8 +156,7 @@ describe('type check blocks', () => {\n         isGeneric: true,\n       }];\n       const block = tcb(TEMPLATE, DIRECTIVES);\n-      expect(block).toContain(\n-          'var _t1 = Dir.ngTypeCtor({ \"color\": (null as any), \"strong\": (null as any), \"enabled\": (null as any) });');\n+      expect(block).not.toContain('Dir.ngTypeCtor');\n       expect(block).toContain('\"blue\"; false; true;');\n     });\n \n@@ -204,9 +203,9 @@ describe('type check blocks', () => {\n       ];\n       expect(tcb(TEMPLATE, DIRECTIVES))\n           .toContain(\n-              'var _t3 = DirA.ngTypeCtor((null!)); ' +\n-              'var _t2 = DirB.ngTypeCtor({ \"inputB\": (_t3) }); ' +\n-              'var _t1 = DirA.ngTypeCtor({ \"inputA\": (_t2) });');\n+              'var _t3 = DirB.ngTypeCtor((null!)); ' +\n+              'var _t2 = DirA.ngTypeCtor({ \"inputA\": (_t3) }); ' +\n+              'var _t1 = DirB.ngTypeCtor({ \"inputB\": (_t2) });');\n     });\n \n     it('should handle empty bindings', () => {\n@@ -247,9 +246,8 @@ describe('type check blocks', () => {\n       }];\n       expect(tcb(TEMPLATE, DIRECTIVES))\n           .toContain(\n-              'var _t1 = Dir.ngTypeCtor({ \"fieldA\": (((ctx).foo)) }); ' +\n-              'var _t2: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n-              '_t2 = (((ctx).foo));');\n+              'var _t1: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n+              '_t1 = (((ctx).foo));');\n     });\n   });\n \n@@ -264,6 +262,58 @@ describe('type check blocks', () => {\n     expect(block).toContain('(ctx).handle(_t1);');\n   });\n \n+  it('should only generate directive declarations that have bindings or are referenced', () => {\n+    const TEMPLATE = `\n+      <div\n+        hasInput [input]=\"value\"\n+        hasOutput (output)=\"handle()\"\n+        hasReference #ref=\"ref\"\n+        noReference\n+        noBindings>{{ref.a}}</div>\n+    `;\n+    const DIRECTIVES: TestDeclaration[] = [\n+      {\n+        type: 'directive',\n+        name: 'HasInput',\n+        selector: '[hasInput]',\n+        inputs: {input: 'input'},\n+      },\n+      {\n+        type: 'directive',\n+        name: 'HasOutput',\n+        selector: '[hasOutput]',\n+        outputs: {output: 'output'},\n+      },\n+      {\n+        type: 'directive',\n+        name: 'HasReference',\n+        selector: '[hasReference]',\n+        exportAs: ['ref'],\n+      },\n+      {\n+        type: 'directive',\n+        name: 'NoReference',\n+        selector: '[noReference]',\n+        exportAs: ['no-ref'],\n+      },\n+      {\n+        type: 'directive',\n+        name: 'NoBindings',\n+        selector: '[noBindings]',\n+        inputs: {unset: 'unset'},\n+      },\n+    ];\n+    const block = tcb(TEMPLATE, DIRECTIVES);\n+    expect(block).toContain('var _t1: HasInput = (null!)');\n+    expect(block).toContain('_t1.input = (((ctx).value));');\n+    expect(block).toContain('var _t2: HasOutput = (null!)');\n+    expect(block).toContain('_t2[\"output\"]');\n+    expect(block).toContain('var _t3: HasReference = (null!)');\n+    expect(block).toContain('(_t3).a');\n+    expect(block).not.toContain('NoBindings');\n+    expect(block).not.toContain('NoReference');\n+  });\n+\n   it('should generate a forward element reference correctly', () => {\n     const TEMPLATE = `\n       {{ i.value }}\n@@ -310,7 +360,7 @@ describe('type check blocks', () => {\n       inputs: {'color': 'color', 'strong': 'strong', 'enabled': 'enabled'},\n     }];\n     const block = tcb(TEMPLATE, DIRECTIVES);\n-    expect(block).toContain('var _t1: Dir = (null!);');\n+    expect(block).not.toContain('var _t1: Dir = (null!);');\n     expect(block).not.toContain('\"color\"');\n     expect(block).not.toContain('\"strong\"');\n     expect(block).not.toContain('\"enabled\"');\n@@ -357,10 +407,10 @@ describe('type check blocks', () => {\n     ];\n     expect(tcb(TEMPLATE, DIRECTIVES))\n         .toContain(\n-            'var _t1: DirA = (null!); ' +\n-            'var _t2: DirB = (null!); ' +\n-            '_t1.inputA = (_t2); ' +\n-            '_t2.inputA = (_t1);');\n+            'var _t1: DirB = (null!); ' +\n+            'var _t2: DirA = (null!); ' +\n+            '_t2.inputA = (_t1); ' +\n+            '_t1.inputA = (_t2);');\n   });\n \n   it('should handle undeclared properties', () => {\n@@ -374,10 +424,9 @@ describe('type check blocks', () => {\n       },\n       undeclaredInputFields: ['fieldA']\n     }];\n-    expect(tcb(TEMPLATE, DIRECTIVES))\n-        .toContain(\n-            'var _t1: Dir = (null!); ' +\n-            '(((ctx).foo)); ');\n+    const block = tcb(TEMPLATE, DIRECTIVES);\n+    expect(block).not.toContain('var _t1: Dir = (null!);');\n+    expect(block).toContain('(((ctx).foo)); ');\n   });\n \n   it('should assign restricted properties to temp variables by default', () => {\n@@ -448,9 +497,9 @@ describe('type check blocks', () => {\n        }];\n        expect(tcb(TEMPLATE, DIRECTIVES))\n            .toContain(\n-               'var _t1: Dir = (null!); ' +\n-               'var _t2: typeof Dir.ngAcceptInputType_field1 = (null!); ' +\n-               '_t1.field2 = _t2 = (((ctx).foo));');\n+               'var _t1: typeof Dir.ngAcceptInputType_field1 = (null!); ' +\n+               'var _t2: Dir = (null!); ' +\n+               '_t2.field2 = _t1 = (((ctx).foo));');\n      });\n \n   it('should handle a single property bound to multiple fields, where one of them is undeclared',\n@@ -483,11 +532,11 @@ describe('type check blocks', () => {\n       },\n       coercedInputFields: ['fieldA'],\n     }];\n-    expect(tcb(TEMPLATE, DIRECTIVES))\n-        .toContain(\n-            'var _t1: Dir = (null!); ' +\n-            'var _t2: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n-            '_t2 = (((ctx).foo));');\n+    const block = tcb(TEMPLATE, DIRECTIVES);\n+    expect(block).not.toContain('var _t1: Dir = (null!);');\n+    expect(block).toContain(\n+        'var _t1: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n+        '_t1 = (((ctx).foo));');\n   });\n \n   it('should use coercion types if declared, even when backing field is not declared', () => {\n@@ -502,11 +551,11 @@ describe('type check blocks', () => {\n       coercedInputFields: ['fieldA'],\n       undeclaredInputFields: ['fieldA'],\n     }];\n-    expect(tcb(TEMPLATE, DIRECTIVES))\n-        .toContain(\n-            'var _t1: Dir = (null!); ' +\n-            'var _t2: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n-            '_t2 = (((ctx).foo));');\n+    const block = tcb(TEMPLATE, DIRECTIVES);\n+    expect(block).not.toContain('var _t1: Dir = (null!);');\n+    expect(block).toContain(\n+        'var _t1: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n+        '_t1 = (((ctx).foo));');\n   });\n \n   it('should handle $any casts', () => {\n@@ -721,7 +770,7 @@ describe('type check blocks', () => {\n         expect(block).toContain('function ($event: any): any { (ctx).foo($event); }');\n         // Note that DOM events are still checked, that is controlled by `checkTypeOfDomEvents`\n         expect(block).toContain(\n-            '_t2.addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n+            '_t1.addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n       });\n     });\n "
        },
        {
            "sha": "c6e148b96136bd6458ebdcedb2a0b8fafad10f7d",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker_spec.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/fb8f4b4d721e98a3b0f8163af6411dbab35f775e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fb8f4b4d721e98a3b0f8163af6411dbab35f775e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts?ref=fb8f4b4d721e98a3b0f8163af6411dbab35f775e",
            "patch": "@@ -276,11 +276,13 @@ runInEachFileSystem(os => {\n                   selector: '[dir]',\n                   file: dirFile,\n                   type: 'directive',\n+                  inputs: {'input': 'input'},\n+                  isGeneric: true,\n                 }]\n               },\n               {\n                 fileName: dirFile,\n-                source: `export class TestDir {}`,\n+                source: `export class TestDir<T> {}`,\n                 templates: {},\n               }\n             ],\n@@ -294,7 +296,7 @@ runInEachFileSystem(os => {\n         const tcbReal = templateTypeChecker.getTypeCheckBlock(cmp)!;\n         expect(tcbReal.getSourceFile().text).not.toContain('TestDir');\n \n-        templateTypeChecker.overrideComponentTemplate(cmp, '<div dir></div>');\n+        templateTypeChecker.overrideComponentTemplate(cmp, '<div dir [input]=\"value\"></div>');\n \n         const tcbOverridden = templateTypeChecker.getTypeCheckBlock(cmp);\n         expect(tcbOverridden).not.toBeNull();"
        }
    ],
    "stats": {
        "total": 142,
        "additions": 105,
        "deletions": 37
    }
}