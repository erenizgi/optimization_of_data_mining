{
    "author": "petebacondarwin",
    "message": "fix(compiler-cli): compute source-mappings for localized strings (#38645)\n\nPreviously, localized strings had very limited or incorrect source-mapping\ninformation available.\n\nNow the i18n AST nodes and related output AST nodes include source-span\ninformation about message-parts and placeholders - including closing tag\nplaceholders.\n\nThis information is then used when generating the final localized string\nASTs to ensure that the correct source-mapping is rendered.\n\nSee #38588 (comment)\n\nPR Close #38645",
    "sha": "7e0b3fd953bb02a0a6fd70df8314367dd70c91a9",
    "files": [
        {
            "sha": "6a24078d3b1866198a5937928c25e4219ea2b193",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/translator.ts",
            "status": "modified",
            "additions": 122,
            "deletions": 103,
            "changes": 225,
            "blob_url": "https://github.com/angular/angular/blob/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts?ref=7e0b3fd953bb02a0a6fd70df8314367dd70c91a9",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ArrayType, AssertNotNull, BinaryOperator, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CastExpr, ClassStmt, CommaExpr, CommentStmt, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, JSDocCommentStmt, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, ThrowStmt, TryCatchStmt, Type, TypeofExpr, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n+import {ArrayType, AssertNotNull, BinaryOperator, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CastExpr, ClassStmt, CommaExpr, CommentStmt, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, JSDocCommentStmt, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, ParseSourceSpan, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, ThrowStmt, TryCatchStmt, Type, TypeofExpr, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n import {LocalizedString, UnaryOperator, UnaryOperatorExpr} from '@angular/compiler/src/output/output_ast';\n import * as ts from 'typescript';\n \n@@ -212,7 +212,7 @@ class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor\n \n   visitReadVarExpr(ast: ReadVarExpr, context: Context): ts.Identifier {\n     const identifier = ts.createIdentifier(ast.name!);\n-    this.setSourceMapRange(identifier, ast);\n+    this.setSourceMapRange(identifier, ast.sourceSpan);\n     return identifier;\n   }\n \n@@ -244,7 +244,7 @@ class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor\n     const call = ts.createCall(\n         ast.name !== null ? ts.createPropertyAccess(target, ast.name) : target, undefined,\n         ast.args.map(arg => arg.visitExpression(this, context)));\n-    this.setSourceMapRange(call, ast);\n+    this.setSourceMapRange(call, ast.sourceSpan);\n     return call;\n   }\n \n@@ -255,7 +255,7 @@ class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor\n     if (ast.pure) {\n       ts.addSyntheticLeadingComment(expr, ts.SyntaxKind.MultiLineCommentTrivia, '@__PURE__', false);\n     }\n-    this.setSourceMapRange(expr, ast);\n+    this.setSourceMapRange(expr, ast.sourceSpan);\n     return expr;\n   }\n \n@@ -274,15 +274,15 @@ class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor\n     } else {\n       expr = ts.createLiteral(ast.value);\n     }\n-    this.setSourceMapRange(expr, ast);\n+    this.setSourceMapRange(expr, ast.sourceSpan);\n     return expr;\n   }\n \n   visitLocalizedString(ast: LocalizedString, context: Context): ts.Expression {\n     const localizedString = this.scriptTarget >= ts.ScriptTarget.ES2015 ?\n-        createLocalizedStringTaggedTemplate(ast, context, this) :\n-        createLocalizedStringFunctionCall(ast, context, this, this.imports);\n-    this.setSourceMapRange(localizedString, ast);\n+        this.createLocalizedStringTaggedTemplate(ast, context) :\n+        this.createLocalizedStringFunctionCall(ast, context);\n+    this.setSourceMapRange(localizedString, ast.sourceSpan);\n     return localizedString;\n   }\n \n@@ -395,7 +395,7 @@ class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor\n   visitLiteralArrayExpr(ast: LiteralArrayExpr, context: Context): ts.ArrayLiteralExpression {\n     const expr =\n         ts.createArrayLiteral(ast.entries.map(expr => expr.visitExpression(this, context)));\n-    this.setSourceMapRange(expr, ast);\n+    this.setSourceMapRange(expr, ast.sourceSpan);\n     return expr;\n   }\n \n@@ -405,7 +405,7 @@ class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor\n             entry.quoted ? ts.createLiteral(entry.key) : ts.createIdentifier(entry.key),\n             entry.value.visitExpression(this, context)));\n     const expr = ts.createObjectLiteral(entries);\n-    this.setSourceMapRange(expr, ast);\n+    this.setSourceMapRange(expr, ast.sourceSpan);\n     return expr;\n   }\n \n@@ -424,9 +424,111 @@ class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor\n     return ts.createTypeOf(ast.expr.visitExpression(this, context));\n   }\n \n-  private setSourceMapRange(expr: ts.Expression, ast: Expression) {\n-    if (ast.sourceSpan) {\n-      const {start, end} = ast.sourceSpan;\n+  /**\n+   * Translate the `LocalizedString` node into a `TaggedTemplateExpression` for ES2015 formatted\n+   * output.\n+   */\n+  private createLocalizedStringTaggedTemplate(ast: LocalizedString, context: Context):\n+      ts.TaggedTemplateExpression {\n+    let template: ts.TemplateLiteral;\n+    const length = ast.messageParts.length;\n+    const metaBlock = ast.serializeI18nHead();\n+    if (length === 1) {\n+      template = ts.createNoSubstitutionTemplateLiteral(metaBlock.cooked, metaBlock.raw);\n+      this.setSourceMapRange(template, ast.getMessagePartSourceSpan(0));\n+    } else {\n+      // Create the head part\n+      const head = ts.createTemplateHead(metaBlock.cooked, metaBlock.raw);\n+      this.setSourceMapRange(head, ast.getMessagePartSourceSpan(0));\n+      const spans: ts.TemplateSpan[] = [];\n+      // Create the middle parts\n+      for (let i = 1; i < length - 1; i++) {\n+        const resolvedExpression = ast.expressions[i - 1].visitExpression(this, context);\n+        this.setSourceMapRange(resolvedExpression, ast.getPlaceholderSourceSpan(i - 1));\n+        const templatePart = ast.serializeI18nTemplatePart(i);\n+        const templateMiddle = createTemplateMiddle(templatePart.cooked, templatePart.raw);\n+        this.setSourceMapRange(templateMiddle, ast.getMessagePartSourceSpan(i));\n+        const templateSpan = ts.createTemplateSpan(resolvedExpression, templateMiddle);\n+        spans.push(templateSpan);\n+      }\n+      // Create the tail part\n+      const resolvedExpression = ast.expressions[length - 2].visitExpression(this, context);\n+      this.setSourceMapRange(resolvedExpression, ast.getPlaceholderSourceSpan(length - 2));\n+      const templatePart = ast.serializeI18nTemplatePart(length - 1);\n+      const templateTail = createTemplateTail(templatePart.cooked, templatePart.raw);\n+      this.setSourceMapRange(templateTail, ast.getMessagePartSourceSpan(length - 1));\n+      spans.push(ts.createTemplateSpan(resolvedExpression, templateTail));\n+      // Put it all together\n+      template = ts.createTemplateExpression(head, spans);\n+    }\n+    const expression = ts.createTaggedTemplate(ts.createIdentifier('$localize'), template);\n+    this.setSourceMapRange(expression, ast.sourceSpan);\n+    return expression;\n+  }\n+\n+  /**\n+   * Translate the `LocalizedString` node into a `$localize` call using the imported\n+   * `__makeTemplateObject` helper for ES5 formatted output.\n+   */\n+  private createLocalizedStringFunctionCall(ast: LocalizedString, context: Context) {\n+    // A `$localize` message consists `messageParts` and `expressions`, which get interleaved\n+    // together. The interleaved pieces look like:\n+    // `[messagePart0, expression0, messagePart1, expression1, messagePart2]`\n+    //\n+    // Note that there is always a message part at the start and end, and so therefore\n+    // `messageParts.length === expressions.length + 1`.\n+    //\n+    // Each message part may be prefixed with \"metadata\", which is wrapped in colons (:) delimiters.\n+    // The metadata is attached to the first and subsequent message parts by calls to\n+    // `serializeI18nHead()` and `serializeI18nTemplatePart()` respectively.\n+\n+    // The first message part (i.e. `ast.messageParts[0]`) is used to initialize `messageParts`\n+    // array.\n+    const messageParts = [ast.serializeI18nHead()];\n+    const expressions: any[] = [];\n+\n+    // The rest of the `ast.messageParts` and each of the expressions are `ast.expressions` pushed\n+    // into the arrays. Note that `ast.messagePart[i]` corresponds to `expressions[i-1]`\n+    for (let i = 1; i < ast.messageParts.length; i++) {\n+      expressions.push(ast.expressions[i - 1].visitExpression(this, context));\n+      messageParts.push(ast.serializeI18nTemplatePart(i));\n+    }\n+\n+    // The resulting downlevelled tagged template string uses a call to the `__makeTemplateObject()`\n+    // helper, so we must ensure it has been imported.\n+    const {moduleImport, symbol} =\n+        this.imports.generateNamedImport('tslib', '__makeTemplateObject');\n+    const __makeTemplateObjectHelper = (moduleImport === null) ?\n+        ts.createIdentifier(symbol) :\n+        ts.createPropertyAccess(ts.createIdentifier(moduleImport), ts.createIdentifier(symbol));\n+\n+    // Generate the call in the form:\n+    // `$localize(__makeTemplateObject(cookedMessageParts, rawMessageParts), ...expressions);`\n+    const cookedLiterals = messageParts.map(\n+        (messagePart, i) =>\n+            this.createLiteral(messagePart.cooked, ast.getMessagePartSourceSpan(i)));\n+    const rawLiterals = messageParts.map(\n+        (messagePart, i) => this.createLiteral(messagePart.raw, ast.getMessagePartSourceSpan(i)));\n+    return ts.createCall(\n+        /* expression */ ts.createIdentifier('$localize'),\n+        /* typeArguments */ undefined,\n+        /* argumentsArray */[\n+          ts.createCall(\n+              /* expression */ __makeTemplateObjectHelper,\n+              /* typeArguments */ undefined,\n+              /* argumentsArray */\n+              [\n+                ts.createArrayLiteral(cookedLiterals),\n+                ts.createArrayLiteral(rawLiterals),\n+              ]),\n+          ...expressions,\n+        ]);\n+  }\n+\n+\n+  private setSourceMapRange(expr: ts.Node, sourceSpan: ParseSourceSpan|null) {\n+    if (sourceSpan) {\n+      const {start, end} = sourceSpan;\n       const {url, content} = start.file;\n       if (url) {\n         if (!this.externalSourceFiles.has(url)) {\n@@ -437,6 +539,12 @@ class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor\n       }\n     }\n   }\n+\n+  private createLiteral(text: string, span: ParseSourceSpan|null) {\n+    const literal = ts.createStringLiteral(text);\n+    this.setSourceMapRange(literal, span);\n+    return literal;\n+  }\n }\n \n export class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n@@ -662,40 +770,6 @@ export class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n   }\n }\n \n-/**\n- * Translate the `LocalizedString` node into a `TaggedTemplateExpression` for ES2015 formatted\n- * output.\n- */\n-function createLocalizedStringTaggedTemplate(\n-    ast: LocalizedString, context: Context, visitor: ExpressionVisitor) {\n-  let template: ts.TemplateLiteral;\n-  const length = ast.messageParts.length;\n-  const metaBlock = ast.serializeI18nHead();\n-  if (length === 1) {\n-    template = ts.createNoSubstitutionTemplateLiteral(metaBlock.cooked, metaBlock.raw);\n-  } else {\n-    // Create the head part\n-    const head = ts.createTemplateHead(metaBlock.cooked, metaBlock.raw);\n-    const spans: ts.TemplateSpan[] = [];\n-    // Create the middle parts\n-    for (let i = 1; i < length - 1; i++) {\n-      const resolvedExpression = ast.expressions[i - 1].visitExpression(visitor, context);\n-      const templatePart = ast.serializeI18nTemplatePart(i);\n-      const templateMiddle = createTemplateMiddle(templatePart.cooked, templatePart.raw);\n-      spans.push(ts.createTemplateSpan(resolvedExpression, templateMiddle));\n-    }\n-    // Create the tail part\n-    const resolvedExpression = ast.expressions[length - 2].visitExpression(visitor, context);\n-    const templatePart = ast.serializeI18nTemplatePart(length - 1);\n-    const templateTail = createTemplateTail(templatePart.cooked, templatePart.raw);\n-    spans.push(ts.createTemplateSpan(resolvedExpression, templateTail));\n-    // Put it all together\n-    template = ts.createTemplateExpression(head, spans);\n-  }\n-  return ts.createTaggedTemplate(ts.createIdentifier('$localize'), template);\n-}\n-\n-\n // HACK: Use this in place of `ts.createTemplateMiddle()`.\n // Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed\n function createTemplateMiddle(cooked: string, raw: string): ts.TemplateMiddle {\n@@ -710,59 +784,4 @@ function createTemplateTail(cooked: string, raw: string): ts.TemplateTail {\n   const node: ts.TemplateLiteralLikeNode = ts.createTemplateHead(cooked, raw);\n   (node.kind as ts.SyntaxKind) = ts.SyntaxKind.TemplateTail;\n   return node as ts.TemplateTail;\n-}\n-\n-/**\n- * Translate the `LocalizedString` node into a `$localize` call using the imported\n- * `__makeTemplateObject` helper for ES5 formatted output.\n- */\n-function createLocalizedStringFunctionCall(\n-    ast: LocalizedString, context: Context, visitor: ExpressionVisitor, imports: ImportManager) {\n-  // A `$localize` message consists `messageParts` and `expressions`, which get interleaved\n-  // together. The interleaved pieces look like:\n-  // `[messagePart0, expression0, messagePart1, expression1, messagePart2]`\n-  //\n-  // Note that there is always a message part at the start and end, and so therefore\n-  // `messageParts.length === expressions.length + 1`.\n-  //\n-  // Each message part may be prefixed with \"metadata\", which is wrapped in colons (:) delimiters.\n-  // The metadata is attached to the first and subsequent message parts by calls to\n-  // `serializeI18nHead()` and `serializeI18nTemplatePart()` respectively.\n-\n-  // The first message part (i.e. `ast.messageParts[0]`) is used to initialize `messageParts` array.\n-  const messageParts = [ast.serializeI18nHead()];\n-  const expressions: any[] = [];\n-\n-  // The rest of the `ast.messageParts` and each of the expressions are `ast.expressions` pushed\n-  // into the arrays. Note that `ast.messagePart[i]` corresponds to `expressions[i-1]`\n-  for (let i = 1; i < ast.messageParts.length; i++) {\n-    expressions.push(ast.expressions[i - 1].visitExpression(visitor, context));\n-    messageParts.push(ast.serializeI18nTemplatePart(i));\n-  }\n-\n-  // The resulting downlevelled tagged template string uses a call to the `__makeTemplateObject()`\n-  // helper, so we must ensure it has been imported.\n-  const {moduleImport, symbol} = imports.generateNamedImport('tslib', '__makeTemplateObject');\n-  const __makeTemplateObjectHelper = (moduleImport === null) ?\n-      ts.createIdentifier(symbol) :\n-      ts.createPropertyAccess(ts.createIdentifier(moduleImport), ts.createIdentifier(symbol));\n-\n-  // Generate the call in the form:\n-  // `$localize(__makeTemplateObject(cookedMessageParts, rawMessageParts), ...expressions);`\n-  return ts.createCall(\n-      /* expression */ ts.createIdentifier('$localize'),\n-      /* typeArguments */ undefined,\n-      /* argumentsArray */[\n-        ts.createCall(\n-            /* expression */ __makeTemplateObjectHelper,\n-            /* typeArguments */ undefined,\n-            /* argumentsArray */\n-            [\n-              ts.createArrayLiteral(\n-                  messageParts.map(messagePart => ts.createStringLiteral(messagePart.cooked))),\n-              ts.createArrayLiteral(\n-                  messageParts.map(messagePart => ts.createStringLiteral(messagePart.raw))),\n-            ]),\n-        ...expressions,\n-      ]);\n-}\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "c830f30f8e48289967d042ff1a5163259816f89e",
            "filename": "packages/compiler-cli/test/ngtsc/template_mapping_spec.ts",
            "status": "modified",
            "additions": 85,
            "deletions": 2,
            "changes": 87,
            "blob_url": "https://github.com/angular/angular/blob/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Ftemplate_mapping_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Ftemplate_mapping_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Ftemplate_mapping_spec.ts?ref=7e0b3fd953bb02a0a6fd70df8314367dd70c91a9",
            "patch": "@@ -24,7 +24,7 @@ runInEachFileSystem((os) => {\n \n     beforeEach(() => {\n       env = NgtscTestEnvironment.setup(testFiles);\n-      env.tsconfig();\n+      env.tsconfig({sourceMap: true, target: 'es2015', enableI18nLegacyMessageIdFormat: false});\n     });\n \n     describe('Inline templates', () => {\n@@ -360,6 +360,90 @@ runInEachFileSystem((os) => {\n         });\n       });\n \n+      describe('$localize', () => {\n+        it('should create simple i18n message source-mapping', () => {\n+          const mappings = compileAndMap(`<div i18n>Hello, World!</div>`);\n+          expect(mappings).toContain({\n+            source: '<div i18n>',\n+            generated: 'i0.ɵɵelementStart(0, \"div\")',\n+            sourceUrl: '../test.ts',\n+          });\n+          expect(mappings).toContain({\n+            source: 'Hello, World!',\n+            generated: '`Hello, World!`',\n+            sourceUrl: '../test.ts',\n+          });\n+        });\n+\n+        it('should create placeholder source-mappings', () => {\n+          const mappings = compileAndMap(`<div i18n>Hello, {{name}}!</div>`);\n+          expect(mappings).toContain({\n+            source: '<div i18n>',\n+            generated: 'i0.ɵɵelementStart(0, \"div\")',\n+            sourceUrl: '../test.ts',\n+          });\n+          expect(mappings).toContain({\n+            source: '</div>',\n+            generated: 'i0.ɵɵelementEnd()',\n+            sourceUrl: '../test.ts',\n+          });\n+          expect(mappings).toContain({\n+            source: 'Hello, ',\n+            generated: '`Hello, ${',\n+            sourceUrl: '../test.ts',\n+          });\n+          expect(mappings).toContain({\n+            source: '{{name}}',\n+            generated: '\"\\\\uFFFD0\\\\uFFFD\"',\n+            sourceUrl: '../test.ts',\n+          });\n+          expect(mappings).toContain({\n+            source: '!',\n+            generated: '}:INTERPOLATION:!`',\n+            sourceUrl: '../test.ts',\n+          });\n+        });\n+\n+        it('should create tag (container) placeholder source-mappings', () => {\n+          const mappings = compileAndMap(`<div i18n>Hello, <b>World</b>!</div>`);\n+          expect(mappings).toContain({\n+            source: '<div i18n>',\n+            generated: 'i0.ɵɵelementStart(0, \"div\")',\n+            sourceUrl: '../test.ts',\n+          });\n+          expect(mappings).toContain({\n+            source: '</div>',\n+            generated: 'i0.ɵɵelementEnd()',\n+            sourceUrl: '../test.ts',\n+          });\n+          expect(mappings).toContain({\n+            source: 'Hello, ',\n+            generated: '`Hello, ${',\n+            sourceUrl: '../test.ts',\n+          });\n+          expect(mappings).toContain({\n+            source: '<b>',\n+            generated: '\"\\\\uFFFD#2\\\\uFFFD\"',\n+            sourceUrl: '../test.ts',\n+          });\n+          expect(mappings).toContain({\n+            source: 'World',\n+            generated: '}:START_BOLD_TEXT:World${',\n+            sourceUrl: '../test.ts',\n+          });\n+          expect(mappings).toContain({\n+            source: '</b>',\n+            generated: '\"\\\\uFFFD/#2\\\\uFFFD\"',\n+            sourceUrl: '../test.ts',\n+          });\n+          expect(mappings).toContain({\n+            source: '!',\n+            generated: '}:CLOSE_BOLD_TEXT:!`',\n+            sourceUrl: '../test.ts',\n+          });\n+        });\n+      });\n+\n       it('should create (simple string) inline template source-mapping', () => {\n         const mappings = compileAndMap('<div>this is a test</div><div>{{ 1 + 2 }}</div>');\n \n@@ -520,7 +604,6 @@ runInEachFileSystem((os) => {\n     function compileAndMap(template: string, templateUrl: string|null = null) {\n       const templateConfig = templateUrl ? `templateUrl: '${templateUrl}'` :\n                                            ('template: `' + template.replace(/`/g, '\\\\`') + '`');\n-      env.tsconfig({sourceMap: true});\n       env.write('test.ts', `\n         import {Component} from '@angular/core';\n "
        },
        {
            "sha": "9bd6259bd30ccf876487b4b9510ca4a46c521ff2",
            "filename": "packages/compiler/src/i18n/i18n_ast.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler%2Fsrc%2Fi18n%2Fi18n_ast.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler%2Fsrc%2Fi18n%2Fi18n_ast.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fi18n%2Fi18n_ast.ts?ref=7e0b3fd953bb02a0a6fd70df8314367dd70c91a9",
            "patch": "@@ -87,7 +87,9 @@ export class TagPlaceholder implements Node {\n   constructor(\n       public tag: string, public attrs: {[k: string]: string}, public startName: string,\n       public closeName: string, public children: Node[], public isVoid: boolean,\n-      public sourceSpan: ParseSourceSpan, public closeSourceSpan: ParseSourceSpan|null) {}\n+      // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)\n+      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan|null,\n+      public endSourceSpan: ParseSourceSpan|null) {}\n \n   visit(visitor: Visitor, context?: any): any {\n     return visitor.visitTagPlaceholder(this, context);\n@@ -152,7 +154,7 @@ export class CloneVisitor implements Visitor {\n     const children = ph.children.map(n => n.visit(this, context));\n     return new TagPlaceholder(\n         ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan,\n-        ph.closeSourceSpan);\n+        ph.startSourceSpan, ph.endSourceSpan);\n   }\n \n   visitPlaceholder(ph: Placeholder, context?: any): Placeholder {"
        },
        {
            "sha": "a7d22a1f8f8515f5c49e4e4c3a02221eea067f3e",
            "filename": "packages/compiler/src/i18n/i18n_parser.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler%2Fsrc%2Fi18n%2Fi18n_parser.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler%2Fsrc%2Fi18n%2Fi18n_parser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fi18n%2Fi18n_parser.ts?ref=7e0b3fd953bb02a0a6fd70df8314367dd70c91a9",
            "patch": "@@ -93,8 +93,8 @@ class _I18nVisitor implements html.Visitor {\n     }\n \n     const node = new i18n.TagPlaceholder(\n-        el.name, attrs, startPhName, closePhName, children, isVoid, el.startSourceSpan,\n-        el.endSourceSpan);\n+        el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan,\n+        el.startSourceSpan, el.endSourceSpan);\n     return context.visitNodeFn(el, node);\n   }\n "
        },
        {
            "sha": "b3fa5895384b86d86e8b118e73decf6299d22bc0",
            "filename": "packages/compiler/src/i18n/message_bundle.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler%2Fsrc%2Fi18n%2Fmessage_bundle.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler%2Fsrc%2Fi18n%2Fmessage_bundle.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fi18n%2Fmessage_bundle.ts?ref=7e0b3fd953bb02a0a6fd70df8314367dd70c91a9",
            "patch": "@@ -95,7 +95,7 @@ class MapPlaceholderNames extends i18n.CloneVisitor {\n     const children = ph.children.map(n => n.visit(this, mapper));\n     return new i18n.TagPlaceholder(\n         ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan,\n-        ph.closeSourceSpan);\n+        ph.startSourceSpan, ph.endSourceSpan);\n   }\n \n   visitPlaceholder(ph: i18n.Placeholder, mapper: PlaceholderMapper): i18n.Placeholder {"
        },
        {
            "sha": "444139ecacb61a3c58f4dbe952614b5fb403a748",
            "filename": "packages/compiler/src/render3/view/i18n/localize_utils.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Flocalize_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Flocalize_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Flocalize_utils.ts?ref=7e0b3fd953bb02a0a6fd70df8314367dd70c91a9",
            "patch": "@@ -48,10 +48,10 @@ class LocalizeSerializerVisitor implements i18n.Visitor {\n   }\n \n   visitTagPlaceholder(ph: i18n.TagPlaceholder, context: o.MessagePiece[]): any {\n-    context.push(this.createPlaceholderPiece(ph.startName, ph.sourceSpan));\n+    context.push(this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan));\n     if (!ph.isVoid) {\n       ph.children.forEach(child => child.visit(this, context));\n-      context.push(this.createPlaceholderPiece(ph.closeName, ph.closeSourceSpan ?? ph.sourceSpan));\n+      context.push(this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));\n     }\n   }\n "
        },
        {
            "sha": "7b2fe3b7b715ee9de0dcae4a13f45a9dca38c3b2",
            "filename": "packages/compiler/test/i18n/serializers/i18n_ast_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler%2Ftest%2Fi18n%2Fserializers%2Fi18n_ast_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e0b3fd953bb02a0a6fd70df8314367dd70c91a9/packages%2Fcompiler%2Ftest%2Fi18n%2Fserializers%2Fi18n_ast_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fi18n%2Fserializers%2Fi18n_ast_spec.ts?ref=7e0b3fd953bb02a0a6fd70df8314367dd70c91a9",
            "patch": "@@ -41,7 +41,7 @@ import {_extractMessages} from '../i18n_parser_spec';\n               new i18n.IcuPlaceholder(null!, '', null!),\n             ],\n             null!);\n-        const tag = new i18n.TagPlaceholder('', {}, '', '', [container], false, null!, null);\n+        const tag = new i18n.TagPlaceholder('', {}, '', '', [container], false, null!, null, null);\n         const icu = new i18n.Icu('', '', {tag}, null!);\n \n         icu.visit(visitor);"
        }
    ],
    "stats": {
        "total": 330,
        "additions": 217,
        "deletions": 113
    }
}