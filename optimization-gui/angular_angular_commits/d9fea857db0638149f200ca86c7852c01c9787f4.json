{
    "author": "sonukapoor",
    "message": "fix(forms): ensure to emit `statusChanges` on subsequent value update/validations (#38354)\n\nThis commit ensures that the `updateValueAndValidity` method takes the\n`asyncValidator` into consideration to emit on the `statusChanges` observables.\nThis is necessary so that any subsequent changes are emitted properly to any\nsubscribers.\n\nCloses #20424\nCloses #14542\n\nBREAKING CHANGE:\n\nPreviously if FormControl, FormGroup and FormArray class instances had async validators\ndefined at initialization time, the status change event was not emitted once async validator\ncompleted. After this change the status event is emitted into the `statusChanges` observable.\nIf your code relies on the old behavior, you can filter/ignore this additional status change\nevent.\n\nPR Close #38354",
    "sha": "d9fea857db0638149f200ca86c7852c01c9787f4",
    "files": [
        {
            "sha": "27faa62494da8d0d46ffc30aa2b8d6d0f4a71b8e",
            "filename": "packages/forms/src/model.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 3,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/d9fea857db0638149f200ca86c7852c01c9787f4/packages%2Fforms%2Fsrc%2Fmodel.ts",
            "raw_url": "https://github.com/angular/angular/raw/d9fea857db0638149f200ca86c7852c01c9787f4/packages%2Fforms%2Fsrc%2Fmodel.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fmodel.ts?ref=d9fea857db0638149f200ca86c7852c01c9787f4",
            "patch": "@@ -1149,8 +1149,15 @@ export class FormControl extends AbstractControl {\n     super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n     this._applyFormState(formState);\n     this._setUpdateStrategy(validatorOrOpts);\n-    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n     this._initObservables();\n+    this.updateValueAndValidity({\n+      onlySelf: true,\n+      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n+      // `VALID` or `INVALID`.\n+      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`\n+      // to `true` to allow that during the control creation process.\n+      emitEvent: !!asyncValidator\n+    });\n   }\n \n   /**\n@@ -1403,7 +1410,13 @@ export class FormGroup extends AbstractControl {\n     this._initObservables();\n     this._setUpdateStrategy(validatorOrOpts);\n     this._setUpControls();\n-    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n+    this.updateValueAndValidity({\n+      onlySelf: true,\n+      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n+      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,\n+      // so we set `emitEvent` to `true` to allow that during the control creation process.\n+      emitEvent: !!asyncValidator\n+    });\n   }\n \n   /**\n@@ -1823,7 +1836,14 @@ export class FormArray extends AbstractControl {\n     this._initObservables();\n     this._setUpdateStrategy(validatorOrOpts);\n     this._setUpControls();\n-    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n+    this.updateValueAndValidity({\n+      onlySelf: true,\n+      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n+      // `VALID` or `INVALID`.\n+      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`\n+      // to `true` to allow that during the control creation process.\n+      emitEvent: !!asyncValidator\n+    });\n   }\n \n   /**"
        },
        {
            "sha": "1660611ed1b29cf3f1a8b3e168640b994219b067",
            "filename": "packages/forms/test/form_group_spec.ts",
            "status": "modified",
            "additions": 385,
            "deletions": 0,
            "changes": 385,
            "blob_url": "https://github.com/angular/angular/blob/d9fea857db0638149f200ca86c7852c01c9787f4/packages%2Fforms%2Ftest%2Fform_group_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d9fea857db0638149f200ca86c7852c01c9787f4/packages%2Fforms%2Ftest%2Fform_group_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Fform_group_spec.ts?ref=d9fea857db0638149f200ca86c7852c01c9787f4",
            "patch": "@@ -1825,6 +1825,391 @@ describe('FormGroup', () => {\n     });\n   });\n \n+  describe('emit `statusChanges` and `valueChanges` with/without async/sync validators', () => {\n+    const attachEventsLogger = (control: AbstractControl, log: string[], controlName?: string) => {\n+      const name = controlName ? ` (${controlName})` : '';\n+      control.statusChanges.subscribe(status => log.push(`status${name}: ${status}`));\n+      control.valueChanges.subscribe(value => log.push(`value${name}: ${JSON.stringify(value)}`));\n+    };\n+\n+    describe('stand alone controls', () => {\n+      it('should run the async validator on stand alone controls and set status to `INVALID`',\n+         fakeAsync(() => {\n+           const logs: string[] = [];\n+           const c =\n+               new FormControl('', null, simpleAsyncValidator({timeout: 0, shouldFail: true}));\n+\n+           attachEventsLogger(c, logs);\n+\n+           expect(logs.length).toBe(0);\n+\n+           tick(1);\n+\n+           c.setValue('new!', {emitEvent: true});\n+\n+           tick(1);\n+\n+           // Note that above `simpleAsyncValidator` is called with `timeout:0`.  When the timeout\n+           // is set to `0`, the function returns `of(error)`, and the function behaves in a\n+           // synchronous manner. Because of this there is no `PENDING` state as seen in the\n+           // `logs`.\n+           expect(logs).toEqual([\n+             'status: INVALID',  // status change emitted as a result of initial async validator run\n+             'value: \"new!\"',    // value change emitted by `setValue`\n+             'status: INVALID'   // async validator run after `setValue` call\n+           ]);\n+         }));\n+\n+      it('should run the async validator on stand alone controls and set status to `VALID`',\n+         fakeAsync(() => {\n+           const logs: string[] = [];\n+           const c = new FormControl('', null, asyncValidator('new!'));\n+\n+           attachEventsLogger(c, logs);\n+\n+           expect(logs.length).toBe(0);\n+\n+           tick(1);\n+\n+           c.setValue('new!', {emitEvent: true});\n+\n+           tick(1);\n+\n+           expect(logs).toEqual([\n+             'status: INVALID',  // status change emitted as a result of initial async validator run\n+             'value: \"new!\"',    // value change emitted by `setValue`\n+             'status: PENDING',  // status change emitted by `setValue`\n+             'status: VALID'     // async validator run after `setValue` call\n+           ]);\n+         }));\n+\n+      it('should run the async validator on stand alone controls, include `PENDING` and set status to `INVALID`',\n+         fakeAsync(() => {\n+           const logs: string[] = [];\n+           const c =\n+               new FormControl('', null, simpleAsyncValidator({timeout: 1, shouldFail: true}));\n+\n+           attachEventsLogger(c, logs);\n+\n+           expect(logs.length).toBe(0);\n+\n+           tick(1);\n+\n+           c.setValue('new!', {emitEvent: true});\n+\n+           tick(1);\n+\n+           expect(logs).toEqual([\n+             'status: INVALID',  // status change emitted as a result of initial async validator run\n+             'value: \"new!\"',    // value change emitted by `setValue`\n+             'status: PENDING',  // status change emitted by `setValue`\n+             'status: INVALID'   // async validator run after `setValue` call\n+           ]);\n+         }));\n+\n+      it('should run setValue before the initial async validator and set status to `VALID`',\n+         fakeAsync(() => {\n+           const logs: string[] = [];\n+           const c = new FormControl('', null, asyncValidator('new!'));\n+\n+           attachEventsLogger(c, logs);\n+\n+           expect(logs.length).toBe(0);\n+\n+           c.setValue('new!', {emitEvent: true});\n+\n+           tick(1);\n+\n+           // The `setValue` call invoked synchronously cancels the initial run of the\n+           // `asyncValidator` (which would cause the control status to be changed to `INVALID`), so\n+           // the log contains only events after calling `setValue`.\n+           expect(logs).toEqual([\n+             'value: \"new!\"',    // value change emitted by `setValue`\n+             'status: PENDING',  // status change emitted by `setValue`\n+             'status: VALID'     // async validator run after `setValue` call\n+           ]);\n+         }));\n+\n+      it('should run setValue before the initial async validator and set status to `INVALID`',\n+         fakeAsync(() => {\n+           const logs: string[] = [];\n+           const c =\n+               new FormControl('', null, simpleAsyncValidator({timeout: 1, shouldFail: true}));\n+\n+           attachEventsLogger(c, logs);\n+\n+           expect(logs.length).toBe(0);\n+\n+           c.setValue('new!', {emitEvent: true});\n+\n+           tick(1);\n+\n+           // The `setValue` call invoked synchronously cancels the initial run of the\n+           // `asyncValidator` (which would cause the control status to be changed to `INVALID`), so\n+           // the log contains only events after calling `setValue`.\n+           expect(logs).toEqual([\n+             'value: \"new!\"',    // value change emitted by `setValue`\n+             'status: PENDING',  // status change emitted by `setValue`\n+             'status: INVALID'   // async validator run after `setValue` call\n+           ]);\n+         }));\n+\n+      it('should cancel initial run of the async validator and not emit anything', fakeAsync(() => {\n+           const logger: string[] = [];\n+           const c =\n+               new FormControl('', null, simpleAsyncValidator({timeout: 1, shouldFail: true}));\n+\n+           attachEventsLogger(c, logger);\n+\n+           expect(logger.length).toBe(0);\n+\n+           c.setValue('new!', {emitEvent: false});\n+\n+           tick(1);\n+\n+           // Because we are calling `setValue` with `emitEvent: false`, nothing is emitted\n+           // and our logger remains empty\n+           expect(logger).toEqual([]);\n+         }));\n+\n+      it('should run the sync validator on stand alone controls and set status to `INVALID`',\n+         fakeAsync(() => {\n+           const logs: string[] = [];\n+           const c = new FormControl('new!', Validators.required);\n+\n+           attachEventsLogger(c, logs);\n+\n+           expect(logs.length).toBe(0);\n+\n+           tick(1);\n+\n+           c.setValue('', {emitEvent: true});\n+\n+           tick(1);\n+\n+           expect(logs).toEqual([\n+             'value: \"\"',       // value change emitted by `setValue`\n+             'status: INVALID'  // status change emitted by `setValue`\n+           ]);\n+         }));\n+\n+      it('should run the sync validator on stand alone controls and set status to `VALID`',\n+         fakeAsync(() => {\n+           const logs: string[] = [];\n+           const c = new FormControl('', Validators.required);\n+\n+           attachEventsLogger(c, logs);\n+\n+           expect(logs.length).toBe(0);\n+\n+           tick(1);\n+\n+           c.setValue('new!', {emitEvent: true});\n+\n+           tick(1);\n+\n+           expect(logs).toEqual([\n+             'value: \"new!\"',  // value change emitted by `setValue`\n+             'status: VALID'   // status change emitted by `setValue`\n+           ]);\n+         }));\n+    });\n+\n+    describe('combination of multiple form controls', () => {\n+      it('should run the async validator on the FormControl added to the FormGroup and set status to `VALID`',\n+         fakeAsync(() => {\n+           const logs: string[] = [];\n+           const c1 = new FormControl('one');\n+           const g1 = new FormGroup({'one': c1});\n+\n+           // Initial state of the controls\n+           expect(currentStateOf([c1, g1])).toEqual([\n+             {errors: null, pending: false, status: 'VALID'},  // Control 1\n+             {errors: null, pending: false, status: 'VALID'},  // Group\n+           ]);\n+\n+           attachEventsLogger(g1, logs, 'g1');\n+\n+           const c2 = new FormControl('new!', null, asyncValidator('new!'));\n+\n+           attachEventsLogger(c2, logs, 'c2');\n+\n+           // Initial state of the new control\n+           expect(currentStateOf([c2])).toEqual([\n+             {errors: null, pending: true, status: 'PENDING'},  // Control 2\n+           ]);\n+\n+           expect(logs.length).toBe(0);\n+\n+           g1.setControl('one', c2);\n+\n+           tick(1);\n+\n+           expect(logs).toEqual([\n+             'value (g1): {\"one\":\"new!\"}',  // value change emitted by `setControl`\n+             'status (g1): PENDING',        // value change emitted by `setControl`\n+             'status (c2): VALID',          // async validator run after `setControl` call\n+             'status (g1): VALID'           // status changed from the `setControl` call\n+           ]);\n+\n+           // Final state of all controls\n+           expect(currentStateOf([g1, c2])).toEqual([\n+             {errors: null, pending: false, status: 'VALID'},  // Group\n+             {errors: null, pending: false, status: 'VALID'},  // Control 2\n+           ]);\n+         }));\n+\n+      it('should run the async validator on the FormControl added to the FormGroup and set status to `INVALID`',\n+         fakeAsync(() => {\n+           const logs: string[] = [];\n+           const c1 = new FormControl('one');\n+           const g1 = new FormGroup({'one': c1});\n+\n+           // Initial state of the controls\n+           expect(currentStateOf([c1, g1])).toEqual([\n+             {errors: null, pending: false, status: 'VALID'},  // Control 1\n+             {errors: null, pending: false, status: 'VALID'},  // Group\n+           ]);\n+\n+           attachEventsLogger(g1, logs, 'g1');\n+\n+           const c2 =\n+               new FormControl('new!', null, simpleAsyncValidator({timeout: 1, shouldFail: true}));\n+\n+           attachEventsLogger(c2, logs, 'c2');\n+\n+           // Initial state of the new control\n+           expect(currentStateOf([c2])).toEqual([\n+             {errors: null, pending: true, status: 'PENDING'},  // Control 2\n+           ]);\n+\n+           expect(logs.length).toBe(0);\n+\n+           g1.setControl('one', c2);\n+\n+           tick(1);\n+\n+           expect(logs).toEqual([\n+             'value (g1): {\"one\":\"new!\"}',\n+             'status (g1): PENDING',  // g1 async validator is invoked after `g1.setControl` call\n+             'status (c2): INVALID',  // c2 async validator trigger at c2 init, completed with the\n+                                      // `INVALID` status\n+             'status (g1): INVALID'   // g1 validator completed with the `INVALID` status\n+           ]);\n+\n+           // Final state of all controls\n+           expect(currentStateOf([g1, c2])).toEqual([\n+             {errors: null, pending: false, status: 'INVALID'},           // Group\n+             {errors: {async: true}, pending: false, status: 'INVALID'},  // Control 2\n+           ]);\n+         }));\n+\n+      it('should run the async validator at `FormControl` and `FormGroup` level and set status to `INVALID`',\n+         fakeAsync(() => {\n+           const logs: string[] = [];\n+           const c1 = new FormControl('one');\n+           const g1 = new FormGroup(\n+               {'one': c1}, null, simpleAsyncValidator({timeout: 1, shouldFail: true}));\n+\n+           // Initial state of the controls\n+           expect(currentStateOf([c1, g1])).toEqual([\n+             {errors: null, pending: false, status: 'VALID'},   // Control 1\n+             {errors: null, pending: true, status: 'PENDING'},  // Group\n+           ]);\n+\n+           attachEventsLogger(g1, logs, 'g1');\n+\n+           const c2 =\n+               new FormControl('new!', null, simpleAsyncValidator({timeout: 1, shouldFail: true}));\n+\n+           attachEventsLogger(c2, logs, 'c2');\n+\n+           // Initial state of the new control\n+           expect(currentStateOf([c2])).toEqual([\n+             {errors: null, pending: true, status: 'PENDING'},  // Control 2\n+           ]);\n+\n+           expect(logs.length).toBe(0);\n+\n+           g1.setControl('one', c2);\n+\n+           tick(1);\n+\n+           expect(logs).toEqual([\n+             'value (g1): {\"one\":\"new!\"}',\n+             'status (g1): PENDING',  // g1 async validator is invoked after `g1.setControl` call\n+             'status (c2): INVALID',  // c2 async validator trigger at c2 init, completed with the\n+                                      // `INVALID` status\n+             'status (g1): PENDING',  // c2 update triggered g1 to re-run validation\n+             'status (g1): INVALID'   // g1 validator completed with the `INVALID` status\n+           ]);\n+\n+           // Final state of all controls\n+           expect(currentStateOf([g1, c2])).toEqual([\n+             {errors: {async: true}, pending: false, status: 'INVALID'},  // Group\n+             {errors: {async: true}, pending: false, status: 'INVALID'},  // Control 2\n+           ]);\n+         }));\n+\n+      it('should run the async validator on a `FormArray` and a `FormControl` and status to `INVALID`',\n+         fakeAsync(() => {\n+           const logs: string[] = [];\n+           const c1 = new FormControl('one');\n+           const g1 = new FormGroup(\n+               {'one': c1}, null, simpleAsyncValidator({timeout: 1, shouldFail: true}));\n+           const fa =\n+               new FormArray([g1], null!, simpleAsyncValidator({timeout: 1, shouldFail: true}));\n+\n+           attachEventsLogger(g1, logs, 'g1');\n+\n+           // Initial state of the controls\n+           expect(currentStateOf([c1, g1, fa])).toEqual([\n+             {errors: null, pending: false, status: 'VALID'},   // Control 1\n+             {errors: null, pending: true, status: 'PENDING'},  // Group\n+             {errors: null, pending: true, status: 'PENDING'},  // FormArray\n+           ]);\n+\n+           attachEventsLogger(fa, logs, 'fa');\n+\n+           const c2 =\n+               new FormControl('new!', null, simpleAsyncValidator({timeout: 1, shouldFail: true}));\n+\n+           attachEventsLogger(c2, logs, 'c2');\n+\n+           // Initial state of the new control\n+           expect(currentStateOf([c2])).toEqual([\n+             {errors: null, pending: true, status: 'PENDING'},  // Control 2\n+           ]);\n+\n+           expect(logs.length).toBe(0);\n+\n+           g1.setControl('one', c2);\n+\n+           tick(1);\n+\n+           expect(logs).toEqual([\n+             'value (g1): {\"one\":\"new!\"}',    // g1's call to `setControl` triggered value update\n+             'status (g1): PENDING',          // g1's call to `setControl` triggered status update\n+             'value (fa): [{\"one\":\"new!\"}]',  // g1 update triggers the `FormArray` value update\n+             'status (fa): PENDING',          // g1 update triggers the `FormArray` status update\n+             'status (c2): INVALID',          // async validator run after `setControl` call\n+             'status (g1): PENDING',          // async validator run after `setControl` call\n+             'status (fa): PENDING',          // async validator run after `setControl` call\n+             'status (g1): INVALID',          // g1 validator completed with the `INVALID` status\n+             'status (fa): PENDING',          // fa validator still running\n+             'status (fa): INVALID'           // fa validator completed with the `INVALID` status\n+           ]);\n+\n+           // Final state of all controls\n+           expect(currentStateOf([g1, fa, c2])).toEqual([\n+             {errors: {async: true}, pending: false, status: 'INVALID'},  // Group\n+             {errors: {async: true}, pending: false, status: 'INVALID'},  // FormArray\n+             {errors: {async: true}, pending: false, status: 'INVALID'},  // Control 2\n+           ]);\n+         }));\n+    });\n+  });\n+\n   describe('pending', () => {\n     let c: FormControl;\n     let g: FormGroup;"
        }
    ],
    "stats": {
        "total": 411,
        "additions": 408,
        "deletions": 3
    }
}