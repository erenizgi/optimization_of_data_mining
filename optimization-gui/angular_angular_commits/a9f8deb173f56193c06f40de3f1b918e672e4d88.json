{
    "author": "atscott",
    "message": "refactor(router): make `recognize` synchronous (#40029)\n\nTo make the tests suite easier to follow, `Recognize#apply` can be made\ninto a synchronous function rather than one that return an `Observable`.\n\nAlso, as a chore, remove as many `any` types as possible.\n\nPR Close #40029",
    "sha": "a9f8deb173f56193c06f40de3f1b918e672e4d88",
    "files": [
        {
            "sha": "0cb2da65ca6b702568277b0b1ffd6be66715b161",
            "filename": "packages/router/src/recognize.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 28,
            "changes": 64,
            "blob_url": "https://github.com/angular/angular/blob/a9f8deb173f56193c06f40de3f1b918e672e4d88/packages%2Frouter%2Fsrc%2Frecognize.ts",
            "raw_url": "https://github.com/angular/angular/raw/a9f8deb173f56193c06f40de3f1b918e672e4d88/packages%2Frouter%2Fsrc%2Frecognize.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frecognize.ts?ref=a9f8deb173f56193c06f40de3f1b918e672e4d88",
            "patch": "@@ -12,54 +12,62 @@ import {Observable, Observer, of} from 'rxjs';\n import {Data, ResolveData, Route, Routes} from './config';\n import {ActivatedRouteSnapshot, inheritedParamsDataResolve, ParamsInheritanceStrategy, RouterStateSnapshot} from './router_state';\n import {defaultUrlMatcher, PRIMARY_OUTLET} from './shared';\n-import {mapChildrenIntoArray, UrlSegment, UrlSegmentGroup, UrlTree} from './url_tree';\n+import {UrlSegment, UrlSegmentGroup, UrlTree} from './url_tree';\n import {forEach, last} from './utils/collection';\n import {getOutlet} from './utils/config';\n import {TreeNode} from './utils/tree';\n \n class NoMatch {}\n \n+function newObservableError(e: unknown): Observable<RouterStateSnapshot> {\n+  // TODO(atscott): This pattern is used throughout the router code and can be `throwError` instead.\n+  return new Observable<RouterStateSnapshot>((obs: Observer<RouterStateSnapshot>) => obs.error(e));\n+}\n+\n export function recognize(\n     rootComponentType: Type<any>|null, config: Routes, urlTree: UrlTree, url: string,\n     paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly',\n     relativeLinkResolution: 'legacy'|'corrected' = 'legacy'): Observable<RouterStateSnapshot> {\n-  return new Recognizer(\n-             rootComponentType, config, urlTree, url, paramsInheritanceStrategy,\n-             relativeLinkResolution)\n-      .recognize();\n+  try {\n+    const result = new Recognizer(\n+                       rootComponentType, config, urlTree, url, paramsInheritanceStrategy,\n+                       relativeLinkResolution)\n+                       .recognize();\n+    if (result === null) {\n+      return newObservableError(new NoMatch());\n+    } else {\n+      return of(result);\n+    }\n+  } catch (e) {\n+    // Catch the potential error from recognize due to duplicate outlet matches and return as an\n+    // `Observable` error instead.\n+    return newObservableError(e);\n+  }\n }\n \n-class Recognizer {\n+export class Recognizer {\n   constructor(\n       private rootComponentType: Type<any>|null, private config: Routes, private urlTree: UrlTree,\n       private url: string, private paramsInheritanceStrategy: ParamsInheritanceStrategy,\n       private relativeLinkResolution: 'legacy'|'corrected') {}\n \n-  recognize(): Observable<RouterStateSnapshot> {\n-    try {\n-      const rootSegmentGroup =\n-          split(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup;\n-\n-      const children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n-      if (children === null) {\n-        return new Observable<RouterStateSnapshot>(\n-            (obs: Observer<RouterStateSnapshot>) => obs.error(new NoMatch()));\n-      }\n+  recognize(): RouterStateSnapshot|null {\n+    const rootSegmentGroup =\n+        split(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup;\n \n-      const root = new ActivatedRouteSnapshot(\n-          [], Object.freeze({}), Object.freeze({...this.urlTree.queryParams}),\n-          this.urlTree.fragment!, {}, PRIMARY_OUTLET, this.rootComponentType, null,\n-          this.urlTree.root, -1, {});\n+    const children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n+    if (children === null) {\n+      return null;\n+    }\n \n-      const rootNode = new TreeNode<ActivatedRouteSnapshot>(root, children);\n-      const routeState = new RouterStateSnapshot(this.url, rootNode);\n-      this.inheritParamsAndData(routeState._root);\n-      return of(routeState);\n+    const root = new ActivatedRouteSnapshot(\n+        [], Object.freeze({}), Object.freeze({...this.urlTree.queryParams}), this.urlTree.fragment!,\n+        {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n \n-    } catch (e) {\n-      return new Observable<RouterStateSnapshot>(\n-          (obs: Observer<RouterStateSnapshot>) => obs.error(e));\n-    }\n+    const rootNode = new TreeNode<ActivatedRouteSnapshot>(root, children);\n+    const routeState = new RouterStateSnapshot(this.url, rootNode);\n+    this.inheritParamsAndData(routeState._root);\n+    return routeState;\n   }\n \n   inheritParamsAndData(routeNode: TreeNode<ActivatedRouteSnapshot>): void {"
        },
        {
            "sha": "e8e1819816f52a561aa4788dd4273cbef4dce7e8",
            "filename": "packages/router/test/recognize.spec.ts",
            "status": "modified",
            "additions": 328,
            "deletions": 406,
            "changes": 734,
            "blob_url": "https://github.com/angular/angular/blob/a9f8deb173f56193c06f40de3f1b918e672e4d88/packages%2Frouter%2Ftest%2Frecognize.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a9f8deb173f56193c06f40de3f1b918e672e4d88/packages%2Frouter%2Ftest%2Frecognize.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Frecognize.spec.ts?ref=a9f8deb173f56193c06f40de3f1b918e672e4d88",
            "patch": "@@ -7,148 +7,133 @@\n  */\n \n import {Routes} from '../src/config';\n-import {recognize} from '../src/recognize';\n+import {Recognizer} from '../src/recognize';\n import {ActivatedRouteSnapshot, RouterStateSnapshot} from '../src/router_state';\n import {Params, PRIMARY_OUTLET} from '../src/shared';\n import {DefaultUrlSerializer, UrlTree} from '../src/url_tree';\n \n describe('recognize', () => {\n   it('should work', () => {\n-    checkRecognize([{path: 'a', component: ComponentA}], 'a', (s: any) => {\n-      checkActivatedRoute(s.root, '', {}, RootComponent);\n-      checkActivatedRoute(s.firstChild(s.root)!, 'a', {}, ComponentA);\n-    });\n+    const s = recognize([{path: 'a', component: ComponentA}], 'a');\n+    checkActivatedRoute(s.root, '', {}, RootComponent);\n+    checkActivatedRoute(s.root.firstChild!, 'a', {}, ComponentA);\n   });\n \n   it('should freeze params object', () => {\n-    checkRecognize([{path: 'a/:id', component: ComponentA}], 'a/10', (s: RouterStateSnapshot) => {\n-      checkActivatedRoute(s.root, '', {}, RootComponent);\n-      const child = (s as any).firstChild(s.root)!;\n-      expect(Object.isFrozen(child.params)).toBeTruthy();\n-    });\n+    const s: RouterStateSnapshot = recognize([{path: 'a/:id', component: ComponentA}], 'a/10');\n+    checkActivatedRoute(s.root, '', {}, RootComponent);\n+    const child = s.root.firstChild!;\n+    expect(Object.isFrozen(child.params)).toBeTruthy();\n   });\n \n   it('should support secondary routes', () => {\n-    checkRecognize(\n+    const s: RouterStateSnapshot = recognize(\n         [\n           {path: 'a', component: ComponentA}, {path: 'b', component: ComponentB, outlet: 'left'},\n           {path: 'c', component: ComponentC, outlet: 'right'}\n         ],\n-        'a(left:b//right:c)', (s: RouterStateSnapshot) => {\n-          const c = (s as any).children(s.root);\n-          checkActivatedRoute(c[0], 'a', {}, ComponentA);\n-          checkActivatedRoute(c[1], 'b', {}, ComponentB, 'left');\n-          checkActivatedRoute(c[2], 'c', {}, ComponentC, 'right');\n-        });\n+        'a(left:b//right:c)');\n+    const c = s.root.children;\n+    checkActivatedRoute(c[0], 'a', {}, ComponentA);\n+    checkActivatedRoute(c[1], 'b', {}, ComponentB, 'left');\n+    checkActivatedRoute(c[2], 'c', {}, ComponentC, 'right');\n   });\n \n   it('should set url segment and index properly', () => {\n     const url = tree('a(left:b//right:c)');\n-    recognize(\n-        RootComponent,\n+    const s = recognize(\n         [\n           {path: 'a', component: ComponentA}, {path: 'b', component: ComponentB, outlet: 'left'},\n           {path: 'c', component: ComponentC, outlet: 'right'}\n         ],\n-        url, 'a(left:b//right:c)')\n-        .subscribe((s: any) => {\n-          expect(s.root._urlSegment).toBe(url.root);\n-          expect(s.root._lastPathIndex).toBe(-1);\n+        'a(left:b//right:c)');\n+    expect(s.root.url.toString()).toEqual(url.root.toString());\n+    expect((s.root as any)._lastPathIndex).toBe(-1);\n \n-          const c = (s as any).children(s.root);\n-          expect(c[0]._urlSegment).toBe((url.root as any).children[PRIMARY_OUTLET]);\n-          expect(c[0]._lastPathIndex).toBe(0);\n+    const c = s.root.children;\n+    expect(c[0].url.toString()).toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+    expect((c[0] as any)._lastPathIndex).toBe(0);\n \n-          expect(c[1]._urlSegment).toBe((url.root as any).children['left']);\n-          expect(c[1]._lastPathIndex).toBe(0);\n+    expect(c[1].url.toString()).toEqual(url.root.children['left'].toString());\n+    expect((c[1] as any)._lastPathIndex).toBe(0);\n \n-          expect(c[2]._urlSegment).toBe((url.root as any).children['right']);\n-          expect(c[2]._lastPathIndex).toBe(0);\n-        });\n+    expect(c[2].url.toString()).toEqual(url.root.children['right'].toString());\n+    expect((c[2] as any)._lastPathIndex).toBe(0);\n   });\n \n   it('should set url segment and index properly (nested case)', () => {\n     const url = tree('a/b/c');\n-    recognize(\n-        RootComponent,\n+    const s = recognize(\n         [\n           {path: 'a/b', component: ComponentA, children: [{path: 'c', component: ComponentC}]},\n         ],\n-        url, 'a/b/c')\n-        .subscribe((s: RouterStateSnapshot) => {\n-          expect((s.root as any)._urlSegment).toBe(url.root);\n-          expect((s.root as any)._lastPathIndex).toBe(-1);\n-\n-          const compA = (s as any).firstChild(s.root)!;\n-          expect(compA._urlSegment).toBe((url.root as any).children[PRIMARY_OUTLET]);\n-          expect(compA._lastPathIndex).toBe(1);\n-\n-          const compC = (s as any).firstChild(<any>compA)!;\n-          expect(compC._urlSegment).toBe((url.root as any).children[PRIMARY_OUTLET]);\n-          expect(compC._lastPathIndex).toBe(2);\n-        });\n+        'a/b/c');\n+    expect((s.root as any)._urlSegment.toString()).toEqual(url.root.toString());\n+    expect((s.root as any)._lastPathIndex).toBe(-1);\n+\n+    const compA = s.root.firstChild!;\n+    expect((compA as any)._urlSegment.toString())\n+        .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+    expect((compA as any)._lastPathIndex).toBe(1);\n+\n+    const compC = compA.firstChild!;\n+    expect((compC as any)._urlSegment.toString())\n+        .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+    expect((compC as any)._lastPathIndex).toBe(2);\n   });\n \n   it('should set url segment and index properly (wildcard)', () => {\n     const url = tree('a/b/c');\n-    recognize(\n-        RootComponent,\n+    const s = recognize(\n         [\n           {path: 'a', component: ComponentA, children: [{path: '**', component: ComponentB}]},\n         ],\n-        url, 'a/b/c')\n-        .subscribe((s: any) => {\n-          expect(s.root._urlSegment).toBe(url.root);\n-          expect(s.root._lastPathIndex).toBe(-1);\n-\n-          const compA = (s as any).firstChild(s.root)!;\n-          expect(compA._urlSegment).toBe((url as any).root.children[PRIMARY_OUTLET]);\n-          expect(compA._lastPathIndex).toBe(0);\n-\n-          const compC = (s as any).firstChild(<any>compA)!;\n-          expect(compC._urlSegment).toBe((url as any).root.children[PRIMARY_OUTLET]);\n-          expect(compC._lastPathIndex).toBe(2);\n-        });\n+        'a/b/c');\n+    expect((s.root as any)._urlSegment.toString()).toEqual(url.root.toString());\n+    expect((s.root as any)._lastPathIndex).toBe(-1);\n+\n+    const compA = s.root.firstChild!;\n+    expect((compA as any)._urlSegment.toString())\n+        .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+    expect((compA as any)._lastPathIndex).toBe(0);\n+\n+    const compC = compA.firstChild!;\n+    expect((compC as any)._urlSegment.toString())\n+        .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+    expect((compC as any)._lastPathIndex).toBe(2);\n   });\n \n   it('should match routes in the depth first order', () => {\n-    checkRecognize(\n+    const s = recognize(\n         [\n           {path: 'a', component: ComponentA, children: [{path: ':id', component: ComponentB}]},\n           {path: 'a/:id', component: ComponentC}\n         ],\n-        'a/paramA', (s: RouterStateSnapshot) => {\n-          checkActivatedRoute(s.root, '', {}, RootComponent);\n-          checkActivatedRoute((s as any).firstChild(s.root)!, 'a', {}, ComponentA);\n-          checkActivatedRoute(\n-              (s as any).firstChild(<any>(s as any).firstChild(s.root))!, 'paramA', {id: 'paramA'},\n-              ComponentB);\n-        });\n-\n-    checkRecognize(\n-        [{path: 'a', component: ComponentA}, {path: 'a/:id', component: ComponentC}], 'a/paramA',\n-        (s: RouterStateSnapshot) => {\n-          checkActivatedRoute(s.root, '', {}, RootComponent);\n-          checkActivatedRoute(\n-              (s as any).firstChild(s.root)!, 'a/paramA', {id: 'paramA'}, ComponentC);\n-        });\n+        'a/paramA');\n+    checkActivatedRoute(s.root, '', {}, RootComponent);\n+    checkActivatedRoute(s.root.firstChild!, 'a', {}, ComponentA);\n+    checkActivatedRoute(s.root.firstChild!.firstChild!, 'paramA', {id: 'paramA'}, ComponentB);\n+\n+    const s2 = recognize(\n+        [{path: 'a', component: ComponentA}, {path: 'a/:id', component: ComponentC}], 'a/paramA');\n+    checkActivatedRoute(s2.root, '', {}, RootComponent);\n+    checkActivatedRoute(s2.root.firstChild!, 'a/paramA', {id: 'paramA'}, ComponentC);\n   });\n \n   it('should use outlet name when matching secondary routes', () => {\n-    checkRecognize(\n+    const s = recognize(\n         [\n           {path: 'a', component: ComponentA}, {path: 'b', component: ComponentB, outlet: 'left'},\n           {path: 'b', component: ComponentC, outlet: 'right'}\n         ],\n-        'a(right:b)', (s: RouterStateSnapshot) => {\n-          const c = (s as any).children(s.root);\n-          checkActivatedRoute(c[0], 'a', {}, ComponentA);\n-          checkActivatedRoute(c[1], 'b', {}, ComponentC, 'right');\n-        });\n+        'a(right:b)');\n+    const c = s.root.children;\n+    checkActivatedRoute(c[0], 'a', {}, ComponentA);\n+    checkActivatedRoute(c[1], 'b', {}, ComponentC, 'right');\n   });\n \n   it('should handle non top-level secondary routes', () => {\n-    checkRecognize(\n+    const s = recognize(\n         [\n           {\n             path: 'a',\n@@ -158,184 +143,156 @@ describe('recognize', () => {\n             ]\n           },\n         ],\n-        'a/(b//left:c)', (s: RouterStateSnapshot) => {\n-          const c = (s as any).children(<any>(s as any).firstChild(s.root));\n-          checkActivatedRoute(c[0], 'b', {}, ComponentB, PRIMARY_OUTLET);\n-          checkActivatedRoute(c[1], 'c', {}, ComponentC, 'left');\n-        });\n+        'a/(b//left:c)');\n+    const c = s.root.firstChild!.children;\n+    checkActivatedRoute(c[0], 'b', {}, ComponentB, PRIMARY_OUTLET);\n+    checkActivatedRoute(c[1], 'c', {}, ComponentC, 'left');\n   });\n \n   it('should sort routes by outlet name', () => {\n-    checkRecognize(\n+    const s = recognize(\n         [\n           {path: 'a', component: ComponentA}, {path: 'c', component: ComponentC, outlet: 'c'},\n           {path: 'b', component: ComponentB, outlet: 'b'}\n         ],\n-        'a(c:c//b:b)', (s: RouterStateSnapshot) => {\n-          const c = (s as any).children(s.root);\n-          checkActivatedRoute(c[0], 'a', {}, ComponentA);\n-          checkActivatedRoute(c[1], 'b', {}, ComponentB, 'b');\n-          checkActivatedRoute(c[2], 'c', {}, ComponentC, 'c');\n-        });\n+        'a(c:c//b:b)');\n+    const c = s.root.children;\n+    checkActivatedRoute(c[0], 'a', {}, ComponentA);\n+    checkActivatedRoute(c[1], 'b', {}, ComponentB, 'b');\n+    checkActivatedRoute(c[2], 'c', {}, ComponentC, 'c');\n   });\n \n   it('should support matrix parameters', () => {\n-    checkRecognize(\n+    const s = recognize(\n         [\n           {path: 'a', component: ComponentA, children: [{path: 'b', component: ComponentB}]},\n           {path: 'c', component: ComponentC, outlet: 'left'}\n         ],\n-        'a;a1=11;a2=22/b;b1=111;b2=222(left:c;c1=1111;c2=2222)', (s: RouterStateSnapshot) => {\n-          const c = (s as any).children(s.root);\n-          checkActivatedRoute(c[0], 'a', {a1: '11', a2: '22'}, ComponentA);\n-          checkActivatedRoute(\n-              (s as any).firstChild(<any>c[0])!, 'b', {b1: '111', b2: '222'}, ComponentB);\n-          checkActivatedRoute(c[1], 'c', {c1: '1111', c2: '2222'}, ComponentC, 'left');\n-        });\n+        'a;a1=11;a2=22/b;b1=111;b2=222(left:c;c1=1111;c2=2222)');\n+    const c = s.root.children;\n+    checkActivatedRoute(c[0], 'a', {a1: '11', a2: '22'}, ComponentA);\n+    checkActivatedRoute(c[0].firstChild!, 'b', {b1: '111', b2: '222'}, ComponentB);\n+    checkActivatedRoute(c[1], 'c', {c1: '1111', c2: '2222'}, ComponentC, 'left');\n   });\n \n   describe('data', () => {\n     it('should set static data', () => {\n-      checkRecognize(\n-          [{path: 'a', data: {one: 1}, component: ComponentA}], 'a', (s: RouterStateSnapshot) => {\n-            const r: ActivatedRouteSnapshot = (s as any).firstChild(s.root)!;\n-            expect(r.data).toEqual({one: 1});\n-          });\n+      const s = recognize([{path: 'a', data: {one: 1}, component: ComponentA}], 'a');\n+      const r: ActivatedRouteSnapshot = s.root.firstChild!;\n+      expect(r.data).toEqual({one: 1});\n     });\n \n     it('should inherit componentless route\\'s data', () => {\n-      checkRecognize(\n+      const s = recognize(\n           [{\n             path: 'a',\n             data: {one: 1},\n             children: [{path: 'b', data: {two: 2}, component: ComponentB}]\n           }],\n-          'a/b', (s: RouterStateSnapshot) => {\n-            const r: ActivatedRouteSnapshot =\n-                (s as any).firstChild(<any>(s as any).firstChild(s.root))!;\n-            expect(r.data).toEqual({one: 1, two: 2});\n-          });\n+          'a/b');\n+      const r: ActivatedRouteSnapshot = s.root.firstChild!.firstChild!;\n+      expect(r.data).toEqual({one: 1, two: 2});\n     });\n \n     it('should not inherit route\\'s data if it has component', () => {\n-      checkRecognize(\n+      const s = recognize(\n           [{\n             path: 'a',\n             component: ComponentA,\n             data: {one: 1},\n             children: [{path: 'b', data: {two: 2}, component: ComponentB}]\n           }],\n-          'a/b', (s: any /* RouterStateSnapshot */) => {\n-            const r: ActivatedRouteSnapshot = s.firstChild(<any>s.firstChild(s.root))!;\n-            expect(r.data).toEqual({two: 2});\n-          });\n+          'a/b');\n+      const r: ActivatedRouteSnapshot = s.root.firstChild!.firstChild!;\n+      expect(r.data).toEqual({two: 2});\n     });\n \n     it('should inherit route\\'s data if paramsInheritanceStrategy is \\'always\\'', () => {\n-      checkRecognize(\n+      const s = recognize(\n           [{\n             path: 'a',\n             component: ComponentA,\n             data: {one: 1},\n             children: [{path: 'b', data: {two: 2}, component: ComponentB}]\n           }],\n-          'a/b', (s: any /* RouterStateSnapshot */) => {\n-            const r: ActivatedRouteSnapshot = s.firstChild(<any>s.firstChild(s.root))!;\n-            expect(r.data).toEqual({one: 1, two: 2});\n-          }, 'always');\n+          'a/b', 'always');\n+      const r: ActivatedRouteSnapshot = s.root.firstChild!.firstChild!;\n+      expect(r.data).toEqual({one: 1, two: 2});\n     });\n \n     it('should set resolved data', () => {\n-      checkRecognize(\n-          [{path: 'a', resolve: {one: 'some-token'}, component: ComponentA}], 'a', (s: any) => {\n-            const r: any = s.firstChild(s.root)!;\n-            expect(r._resolve).toEqual({one: 'some-token'});\n-          });\n+      const s = recognize([{path: 'a', resolve: {one: 'some-token'}, component: ComponentA}], 'a');\n+      const r: any = s.root.firstChild!;\n+      expect(r._resolve).toEqual({one: 'some-token'});\n     });\n   });\n \n   describe('empty path', () => {\n     describe('root', () => {\n       it('should work', () => {\n-        checkRecognize([{path: '', component: ComponentA}], '', (s: RouterStateSnapshot) => {\n-          checkActivatedRoute((s as any).firstChild(s.root)!, '', {}, ComponentA);\n-        });\n+        const s = recognize([{path: '', component: ComponentA}], '');\n+        checkActivatedRoute(s.root.firstChild!, '', {}, ComponentA);\n       });\n \n       it('should match when terminal', () => {\n-        checkRecognize(\n-            [{path: '', pathMatch: 'full', component: ComponentA}], '',\n-            (s: RouterStateSnapshot) => {\n-              checkActivatedRoute((s as any).firstChild(s.root)!, '', {}, ComponentA);\n-            });\n+        const s = recognize([{path: '', pathMatch: 'full', component: ComponentA}], '');\n+        checkActivatedRoute(s.root.firstChild!, '', {}, ComponentA);\n       });\n \n       it('should work (nested case)', () => {\n-        checkRecognize(\n-            [{path: '', component: ComponentA, children: [{path: '', component: ComponentB}]}], '',\n-            (s: RouterStateSnapshot) => {\n-              checkActivatedRoute((s as any).firstChild(s.root)!, '', {}, ComponentA);\n-              checkActivatedRoute(\n-                  (s as any).firstChild(<any>(s as any).firstChild(s.root))!, '', {}, ComponentB);\n-            });\n+        const s = recognize(\n+            [{path: '', component: ComponentA, children: [{path: '', component: ComponentB}]}], '');\n+        checkActivatedRoute(s.root.firstChild!, '', {}, ComponentA);\n+        checkActivatedRoute(s.root.firstChild!.firstChild!, '', {}, ComponentB);\n       });\n \n       it('should set url segment and index properly', () => {\n         const url = tree('') as any;\n-        recognize(\n-            RootComponent,\n-            [{path: '', component: ComponentA, children: [{path: '', component: ComponentB}]}], url,\n-            '')\n-            .forEach((s: any) => {\n-              expect(s.root._urlSegment).toBe(url.root);\n-              expect(s.root._lastPathIndex).toBe(-1);\n-\n-              const c = s.firstChild(s.root)!;\n-              expect(c._urlSegment).toBe(url.root);\n-              expect(c._lastPathIndex).toBe(-1);\n-\n-              const c2 = s.firstChild(<any>s.firstChild(s.root))!;\n-              expect(c2._urlSegment).toBe(url.root);\n-              expect(c2._lastPathIndex).toBe(-1);\n-            });\n+        const s = recognize(\n+            [{path: '', component: ComponentA, children: [{path: '', component: ComponentB}]}], '');\n+        expect((s.root as any)._urlSegment.toString()).toEqual(url.root.toString());\n+        expect((s.root as any)._lastPathIndex).toBe(-1);\n+\n+        const c = s.root.firstChild!;\n+        expect((c as any)._urlSegment.toString()).toEqual(url.root.toString());\n+        expect((c as any)._lastPathIndex).toBe(-1);\n+\n+        const c2 = s.root.firstChild!.firstChild!;\n+        expect((c2 as any)._urlSegment.toString()).toEqual(url.root.toString());\n+        expect((c2 as any)._lastPathIndex).toBe(-1);\n       });\n \n       it('should inherit params', () => {\n-        checkRecognize(\n+        const s = recognize(\n             [{\n               path: 'a',\n               component: ComponentA,\n               children:\n                   [{path: '', component: ComponentB, children: [{path: '', component: ComponentC}]}]\n             }],\n-            '/a;p=1', (s: RouterStateSnapshot) => {\n-              checkActivatedRoute((s as any).firstChild(s.root)!, 'a', {p: '1'}, ComponentA);\n-              checkActivatedRoute(\n-                  (s as any).firstChild((s as any).firstChild(s.root)!)!, '', {p: '1'}, ComponentB);\n-              checkActivatedRoute(\n-                  (s as any).firstChild((s as any).firstChild((s as any).firstChild(s.root)!)!)!,\n-                  '', {p: '1'}, ComponentC);\n-            });\n+            '/a;p=1');\n+        checkActivatedRoute(s.root.firstChild!, 'a', {p: '1'}, ComponentA);\n+        checkActivatedRoute(s.root.firstChild!.firstChild!, '', {p: '1'}, ComponentB);\n+        checkActivatedRoute(s.root.firstChild!.firstChild!.firstChild!, '', {p: '1'}, ComponentC);\n       });\n     });\n \n     describe('aux split is in the middle', () => {\n       it('should match (non-terminal)', () => {\n-        checkRecognize(\n+        const s = recognize(\n             [{\n               path: 'a',\n               component: ComponentA,\n               children: [\n                 {path: 'b', component: ComponentB}, {path: '', component: ComponentC, outlet: 'aux'}\n               ]\n             }],\n-            'a/b', (s: RouterStateSnapshot) => {\n-              checkActivatedRoute((s as any).firstChild(s.root)!, 'a', {}, ComponentA);\n+            'a/b');\n+        checkActivatedRoute(s.root.firstChild!, 'a', {}, ComponentA);\n \n-              const c = (s as any).children((s as any).firstChild(s.root)!);\n-              checkActivatedRoute(c[0], 'b', {}, ComponentB);\n-              checkActivatedRoute(c[1], '', {}, ComponentC, 'aux');\n-            });\n+        const c = s.root.firstChild!.children;\n+        checkActivatedRoute(c[0], 'b', {}, ComponentB);\n+        checkActivatedRoute(c[1], '', {}, ComponentC, 'aux');\n       });\n \n       it('should match (non-terminal) when both primary and secondary and primary has a child',\n@@ -359,20 +316,19 @@ describe('recognize', () => {\n              ]\n            }];\n \n-           checkRecognize(config, 'parent/b', (s: RouterStateSnapshot) => {\n-             checkActivatedRoute(s.root, '', {}, RootComponent);\n-             checkActivatedRoute((s as any).firstChild(s.root)!, 'parent', {}, undefined!);\n+           const s = recognize(config, 'parent/b');\n+           checkActivatedRoute(s.root, '', {}, RootComponent);\n+           checkActivatedRoute(s.root.firstChild!, 'parent', {}, undefined!);\n \n-             const cc = (s as any).children((s as any).firstChild(s.root)!);\n-             checkActivatedRoute(cc[0], '', {}, ComponentA);\n-             checkActivatedRoute(cc[1], '', {}, ComponentD, 'secondary');\n+           const cc = s.root.firstChild!.children;\n+           checkActivatedRoute(cc[0], '', {}, ComponentA);\n+           checkActivatedRoute(cc[1], '', {}, ComponentD, 'secondary');\n \n-             checkActivatedRoute((s as any).firstChild(cc[0])!, 'b', {}, ComponentB);\n-           });\n+           checkActivatedRoute(cc[0].firstChild!, 'b', {}, ComponentB);\n          });\n \n       it('should match (terminal)', () => {\n-        checkRecognize(\n+        const s = recognize(\n             [{\n               path: 'a',\n               component: ComponentA,\n@@ -381,76 +337,77 @@ describe('recognize', () => {\n                 {path: '', pathMatch: 'full', component: ComponentC, outlet: 'aux'}\n               ]\n             }],\n-            'a/b', (s: RouterStateSnapshot) => {\n-              checkActivatedRoute((s as any).firstChild(s.root)!, 'a', {}, ComponentA);\n+            'a/b');\n+        checkActivatedRoute(s.root.firstChild!, 'a', {}, ComponentA);\n \n-              const c = (s as any).children((s as any).firstChild(s.root)!);\n-              expect(c.length).toEqual(1);\n-              checkActivatedRoute(c[0], 'b', {}, ComponentB);\n-            });\n+        const c = s.root.firstChild!.children;\n+        expect(c.length).toEqual(1);\n+        checkActivatedRoute(c[0], 'b', {}, ComponentB);\n       });\n \n       it('should set url segment and index properly', () => {\n         const url = tree('a/b') as any;\n-        recognize(\n-            RootComponent, [{\n+        const s = recognize(\n+            [{\n               path: 'a',\n               component: ComponentA,\n               children: [\n                 {path: 'b', component: ComponentB}, {path: '', component: ComponentC, outlet: 'aux'}\n               ]\n             }],\n-            url, 'a/b')\n-            .forEach((s: any) => {\n-              expect(s.root._urlSegment).toBe(url.root);\n-              expect(s.root._lastPathIndex).toBe(-1);\n-\n-              const a = s.firstChild(s.root)!;\n-              expect(a._urlSegment).toBe(url.root.children[PRIMARY_OUTLET]);\n-              expect(a._lastPathIndex).toBe(0);\n-\n-              const b = s.firstChild(a)!;\n-              expect(b._urlSegment).toBe(url.root.children[PRIMARY_OUTLET]);\n-              expect(b._lastPathIndex).toBe(1);\n-\n-              const c = s.children(a)[1];\n-              expect(c._urlSegment).toBe(url.root.children[PRIMARY_OUTLET]);\n-              expect(c._lastPathIndex).toBe(0);\n-            });\n+            'a/b');\n+        expect((s.root as any)._urlSegment.toString()).toEqual(url.root.toString());\n+        expect((s.root as any)._lastPathIndex).toBe(-1);\n+\n+        const a = s.root.firstChild!;\n+        expect((a as any)._urlSegment.toString())\n+            .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+        expect((a as any)._lastPathIndex).toBe(0);\n+\n+        const b = a.firstChild!;\n+        expect((b as any)._urlSegment.toString())\n+            .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+        expect((b as any)._lastPathIndex).toBe(1);\n+\n+        const c = a.children[1];\n+        expect((c as any)._urlSegment.toString())\n+            .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+        expect((c as any)._lastPathIndex).toBe(0);\n       });\n \n       it('should set url segment and index properly when nested empty-path segments', () => {\n         const url = tree('a') as any;\n-        recognize(\n-            RootComponent, [{\n+        const s = recognize(\n+            [{\n               path: 'a',\n               children:\n                   [{path: '', component: ComponentB, children: [{path: '', component: ComponentC}]}]\n             }],\n-            url, 'a')\n-            .forEach((s: any) => {\n-              expect(s.root._urlSegment).toBe(url.root);\n-              expect(s.root._lastPathIndex).toBe(-1);\n-\n-              const a = s.firstChild(s.root)!;\n-              expect(a._urlSegment).toBe(url.root.children[PRIMARY_OUTLET]);\n-              expect(a._lastPathIndex).toBe(0);\n-\n-              const b = s.firstChild(a)!;\n-              expect(b._urlSegment).toBe(url.root.children[PRIMARY_OUTLET]);\n-              expect(b._lastPathIndex).toBe(0);\n-\n-              const c = s.firstChild(b)!;\n-              expect(c._urlSegment).toBe(url.root.children[PRIMARY_OUTLET]);\n-              expect(c._lastPathIndex).toBe(0);\n-            });\n+            'a');\n+        expect((s.root as any)._urlSegment.toString()).toEqual(url.root.toString());\n+        expect((s.root as any)._lastPathIndex).toBe(-1);\n+\n+        const a = s.root.firstChild!;\n+        expect((a as any)._urlSegment.toString())\n+            .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+        expect((a as any)._lastPathIndex).toBe(0);\n+\n+        const b = a.firstChild!;\n+        expect((b as any)._urlSegment.toString())\n+            .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+        expect((b as any)._lastPathIndex).toBe(0);\n+\n+        const c = b.firstChild!;\n+        expect((c as any)._urlSegment.toString())\n+            .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+        expect((c as any)._lastPathIndex).toBe(0);\n       });\n \n       it('should set url segment and index properly with the \"corrected\" option for nested empty-path segments',\n          () => {\n-           const url = tree('a/b') as any;\n-           recognize(\n-               RootComponent, [{\n+           const url = tree('a/b');\n+           const s = recognize(\n+               [{\n                  path: 'a',\n                  children: [{\n                    path: 'b',\n@@ -462,60 +419,60 @@ describe('recognize', () => {\n                    }]\n                  }]\n                }],\n-               url, 'a/b', 'emptyOnly', 'corrected')\n-               .forEach((s: any) => {\n-                 expect(s.root._urlSegment).toBe(url.root);\n-                 expect(s.root._lastPathIndex).toBe(-1);\n-\n-                 const a = s.firstChild(s.root)!;\n-                 expect(a._urlSegment).toBe(url.root.children[PRIMARY_OUTLET]);\n-                 expect(a._lastPathIndex).toBe(0);\n-\n-                 const b = s.firstChild(a)!;\n-                 expect(b._urlSegment).toBe(url.root.children[PRIMARY_OUTLET]);\n-                 expect(b._lastPathIndex).toBe(1);\n-\n-                 const c = s.firstChild(b)!;\n-                 expect(c._urlSegment).toBe(url.root.children[PRIMARY_OUTLET]);\n-                 expect(c._lastPathIndex).toBe(1);\n-\n-                 const d = s.firstChild(c)!;\n-                 expect(d._urlSegment).toBe(url.root.children[PRIMARY_OUTLET]);\n-                 expect(d._lastPathIndex).toBe(1);\n-               });\n+               'a/b', 'emptyOnly', 'corrected');\n+           expect((s.root as any)._urlSegment.toString()).toEqual(url.root.toString());\n+           expect((s.root as any)._lastPathIndex).toBe(-1);\n+\n+           const a = s.root.firstChild!;\n+           expect((a as any)._urlSegment.toString())\n+               .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+           expect((a as any)._lastPathIndex).toBe(0);\n+\n+           const b = a.firstChild!;\n+           expect((b as any)._urlSegment.toString())\n+               .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+           expect((b as any)._lastPathIndex).toBe(1);\n+\n+           const c = b.firstChild!;\n+           expect((c as any)._urlSegment.toString())\n+               .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+           expect((c as any)._lastPathIndex).toBe(1);\n+\n+           const d = c.firstChild!;\n+           expect((d as any)._urlSegment.toString())\n+               .toEqual(url.root.children[PRIMARY_OUTLET].toString());\n+           expect((d as any)._lastPathIndex).toBe(1);\n          });\n \n       it('should set url segment and index properly when nested empty-path segments (2)', () => {\n         const url = tree('');\n-        recognize(\n-            RootComponent, [{\n+        const s = recognize(\n+            [{\n               path: '',\n               children:\n                   [{path: '', component: ComponentB, children: [{path: '', component: ComponentC}]}]\n             }],\n-            url, '')\n-            .forEach((s: any) => {\n-              expect(s.root._urlSegment).toBe(url.root);\n-              expect(s.root._lastPathIndex).toBe(-1);\n-\n-              const a = (s as any).firstChild(s.root)!;\n-              expect(a._urlSegment).toBe(url.root);\n-              expect(a._lastPathIndex).toBe(-1);\n-\n-              const b = (s as any).firstChild(a)!;\n-              expect(b._urlSegment).toBe(url.root);\n-              expect(b._lastPathIndex).toBe(-1);\n-\n-              const c = (s as any).firstChild(b)!;\n-              expect(c._urlSegment).toBe(url.root);\n-              expect(c._lastPathIndex).toBe(-1);\n-            });\n+            '');\n+        expect((s.root as any)._urlSegment.toString()).toEqual(url.root.toString());\n+        expect((s.root as any)._lastPathIndex).toBe(-1);\n+\n+        const a = s.root.firstChild!;\n+        expect((a as any)._urlSegment.toString()).toEqual(url.root.toString());\n+        expect((a as any)._lastPathIndex).toBe(-1);\n+\n+        const b = a.firstChild!;\n+        expect((b as any)._urlSegment.toString()).toEqual(url.root.toString());\n+        expect((b as any)._lastPathIndex).toBe(-1);\n+\n+        const c = b.firstChild!;\n+        expect((c as any)._urlSegment.toString()).toEqual(url.root.toString());\n+        expect((c as any)._lastPathIndex).toBe(-1);\n       });\n     });\n \n     describe('aux split at the end (no right child)', () => {\n       it('should match (non-terminal)', () => {\n-        checkRecognize(\n+        const s = recognize(\n             [{\n               path: 'a',\n               component: ComponentA,\n@@ -524,17 +481,16 @@ describe('recognize', () => {\n                 {path: '', component: ComponentC, outlet: 'aux'},\n               ]\n             }],\n-            'a', (s: RouterStateSnapshot) => {\n-              checkActivatedRoute((s as any).firstChild(s.root)!, 'a', {}, ComponentA);\n+            'a');\n+        checkActivatedRoute(s.root.firstChild!, 'a', {}, ComponentA);\n \n-              const c = (s as any).children((s as any).firstChild(s.root)!);\n-              checkActivatedRoute(c[0], '', {}, ComponentB);\n-              checkActivatedRoute(c[1], '', {}, ComponentC, 'aux');\n-            });\n+        const c = s.root.firstChild!.children;\n+        checkActivatedRoute(c[0], '', {}, ComponentB);\n+        checkActivatedRoute(c[1], '', {}, ComponentC, 'aux');\n       });\n \n       it('should match (terminal)', () => {\n-        checkRecognize(\n+        const s = recognize(\n             [{\n               path: 'a',\n               component: ComponentA,\n@@ -543,17 +499,16 @@ describe('recognize', () => {\n                 {path: '', pathMatch: 'full', component: ComponentC, outlet: 'aux'},\n               ]\n             }],\n-            'a', (s: RouterStateSnapshot) => {\n-              checkActivatedRoute((s as any).firstChild(s.root)!, 'a', {}, ComponentA);\n+            'a');\n+        checkActivatedRoute(s.root.firstChild!, 'a', {}, ComponentA);\n \n-              const c = (s as any).children((s as any).firstChild(s.root)!);\n-              checkActivatedRoute(c[0], '', {}, ComponentB);\n-              checkActivatedRoute(c[1], '', {}, ComponentC, 'aux');\n-            });\n+        const c = s.root.firstChild!.children;\n+        checkActivatedRoute(c[0], '', {}, ComponentB);\n+        checkActivatedRoute(c[1], '', {}, ComponentC, 'aux');\n       });\n \n       it('should work only only primary outlet', () => {\n-        checkRecognize(\n+        const s = recognize(\n             [{\n               path: 'a',\n               component: ComponentA,\n@@ -562,35 +517,33 @@ describe('recognize', () => {\n                 {path: 'c', component: ComponentC, outlet: 'aux'},\n               ]\n             }],\n-            'a/(aux:c)', (s: RouterStateSnapshot) => {\n-              checkActivatedRoute((s as any).firstChild(s.root)!, 'a', {}, ComponentA);\n+            'a/(aux:c)');\n+        checkActivatedRoute(s.root.firstChild!, 'a', {}, ComponentA);\n \n-              const c = (s as any).children((s as any).firstChild(s.root)!);\n-              checkActivatedRoute(c[0], '', {}, ComponentB);\n-              checkActivatedRoute(c[1], 'c', {}, ComponentC, 'aux');\n-            });\n+        const c = s.root.firstChild!.children;\n+        checkActivatedRoute(c[0], '', {}, ComponentB);\n+        checkActivatedRoute(c[1], 'c', {}, ComponentC, 'aux');\n       });\n \n       it('should work when split is at the root level', () => {\n-        checkRecognize(\n+        const s = recognize(\n             [\n               {path: '', component: ComponentA}, {path: 'b', component: ComponentB},\n               {path: 'c', component: ComponentC, outlet: 'aux'}\n             ],\n-            '(aux:c)', (s: RouterStateSnapshot) => {\n-              checkActivatedRoute(s.root, '', {}, RootComponent);\n-\n-              const children = (s as any).children(s.root);\n-              expect(children.length).toEqual(2);\n-              checkActivatedRoute(children[0], '', {}, ComponentA);\n-              checkActivatedRoute(children[1], 'c', {}, ComponentC, 'aux');\n-            });\n+            '(aux:c)');\n+        checkActivatedRoute(s.root, '', {}, RootComponent);\n+\n+        const children = s.root.children;\n+        expect(children.length).toEqual(2);\n+        checkActivatedRoute(children[0], '', {}, ComponentA);\n+        checkActivatedRoute(children[1], 'c', {}, ComponentC, 'aux');\n       });\n     });\n \n     describe('split at the end (right child)', () => {\n       it('should match (non-terminal)', () => {\n-        checkRecognize(\n+        const s = recognize(\n             [{\n               path: 'a',\n               component: ComponentA,\n@@ -604,49 +557,45 @@ describe('recognize', () => {\n                 },\n               ]\n             }],\n-            'a/(d//aux:e)', (s: RouterStateSnapshot) => {\n-              checkActivatedRoute((s as any).firstChild(s.root)!, 'a', {}, ComponentA);\n-\n-              const c = (s as any).children((s as any).firstChild(s.root)!);\n-              checkActivatedRoute(c[0], '', {}, ComponentB);\n-              checkActivatedRoute((s as any).firstChild(c[0])!, 'd', {}, ComponentD);\n-              checkActivatedRoute(c[1], '', {}, ComponentC, 'aux');\n-              checkActivatedRoute((s as any).firstChild(c[1])!, 'e', {}, ComponentE);\n-            });\n+            'a/(d//aux:e)');\n+        checkActivatedRoute(s.root.firstChild!, 'a', {}, ComponentA);\n+\n+        const c = s.root.firstChild!.children;\n+        checkActivatedRoute(c[0], '', {}, ComponentB);\n+        checkActivatedRoute(c[0].firstChild!, 'd', {}, ComponentD);\n+        checkActivatedRoute(c[1], '', {}, ComponentC, 'aux');\n+        checkActivatedRoute(c[1].firstChild!, 'e', {}, ComponentE);\n       });\n     });\n   });\n \n   describe('wildcards', () => {\n     it('should support simple wildcards', () => {\n-      checkRecognize(\n-          [{path: '**', component: ComponentA}], 'a/b/c/d;a1=11', (s: RouterStateSnapshot) => {\n-            checkActivatedRoute((s as any).firstChild(s.root)!, 'a/b/c/d', {a1: '11'}, ComponentA);\n-          });\n+      const s = recognize([{path: '**', component: ComponentA}], 'a/b/c/d;a1=11');\n+      checkActivatedRoute(s.root.firstChild!, 'a/b/c/d', {a1: '11'}, ComponentA);\n     });\n   });\n \n   describe('componentless routes', () => {\n     it('should work', () => {\n-      checkRecognize(\n+      const s = recognize(\n           [{\n             path: 'p/:id',\n             children: [\n               {path: 'a', component: ComponentA}, {path: 'b', component: ComponentB, outlet: 'aux'}\n             ]\n           }],\n-          'p/11;pp=22/(a;pa=33//aux:b;pb=44)', (s: RouterStateSnapshot) => {\n-            const p = (s as any).firstChild(s.root)!;\n-            checkActivatedRoute(p, 'p/11', {id: '11', pp: '22'}, undefined!);\n-\n-            const c = (s as any).children(p);\n-            checkActivatedRoute(c[0], 'a', {id: '11', pp: '22', pa: '33'}, ComponentA);\n-            checkActivatedRoute(c[1], 'b', {id: '11', pp: '22', pb: '44'}, ComponentB, 'aux');\n-          });\n+          'p/11;pp=22/(a;pa=33//aux:b;pb=44)');\n+      const p = s.root.firstChild!;\n+      checkActivatedRoute(p, 'p/11', {id: '11', pp: '22'}, undefined!);\n+\n+      const c = p.children;\n+      checkActivatedRoute(c[0], 'a', {id: '11', pp: '22', pa: '33'}, ComponentA);\n+      checkActivatedRoute(c[1], 'b', {id: '11', pp: '22', pb: '44'}, ComponentB, 'aux');\n     });\n \n     it('should inherit params until encounters a normal route', () => {\n-      checkRecognize(\n+      const s = recognize(\n           [{\n             path: 'p/:id',\n             children: [{\n@@ -656,23 +605,22 @@ describe('recognize', () => {\n               ]\n             }]\n           }],\n-          'p/11/a/victor/b/c', (s: RouterStateSnapshot) => {\n-            const p = (s as any).firstChild(s.root)!;\n-            checkActivatedRoute(p, 'p/11', {id: '11'}, undefined!);\n+          'p/11/a/victor/b/c');\n+      const p = s.root.firstChild!;\n+      checkActivatedRoute(p, 'p/11', {id: '11'}, undefined!);\n \n-            const a = (s as any).firstChild(p)!;\n-            checkActivatedRoute(a, 'a/victor', {id: '11', name: 'victor'}, undefined!);\n+      const a = p.firstChild!;\n+      checkActivatedRoute(a, 'a/victor', {id: '11', name: 'victor'}, undefined!);\n \n-            const b = (s as any).firstChild(a)!;\n-            checkActivatedRoute(b, 'b', {id: '11', name: 'victor'}, ComponentB);\n+      const b = a.firstChild!;\n+      checkActivatedRoute(b, 'b', {id: '11', name: 'victor'}, ComponentB);\n \n-            const c = (s as any).firstChild(b)!;\n-            checkActivatedRoute(c, 'c', {}, ComponentC);\n-          });\n+      const c = b.firstChild!;\n+      checkActivatedRoute(c, 'c', {}, ComponentC);\n     });\n \n     it('should inherit all params if paramsInheritanceStrategy is \\'always\\'', () => {\n-      checkRecognize(\n+      const s = recognize(\n           [{\n             path: 'p/:id',\n             children: [{\n@@ -682,25 +630,23 @@ describe('recognize', () => {\n               ]\n             }]\n           }],\n-          'p/11/a/victor/b/c', (s: any /* RouterStateSnapshot */) => {\n-            const c = s.firstChild(s.firstChild(s.firstChild(s.firstChild(s.root)!)!)!)!;\n-            checkActivatedRoute(c, 'c', {id: '11', name: 'victor'}, ComponentC);\n-          }, 'always');\n+          'p/11/a/victor/b/c', 'always');\n+      const c = s.root.firstChild!.firstChild!.firstChild!.firstChild!;\n+      checkActivatedRoute(c, 'c', {id: '11', name: 'victor'}, ComponentC);\n     });\n   });\n \n   describe('empty URL leftovers', () => {\n     it('should not throw when no children matching', () => {\n-      checkRecognize(\n+      const s = recognize(\n           [{path: 'a', component: ComponentA, children: [{path: 'b', component: ComponentB}]}],\n-          '/a', (s: RouterStateSnapshot) => {\n-            const a = (s as any).firstChild(s.root);\n-            checkActivatedRoute(a!, 'a', {}, ComponentA);\n-          });\n+          '/a');\n+      const a = s.root.firstChild;\n+      checkActivatedRoute(a!, 'a', {}, ComponentA);\n     });\n \n     it('should not throw when no children matching (aux routes)', () => {\n-      checkRecognize(\n+      const s = recognize(\n           [{\n             path: 'a',\n             component: ComponentA,\n@@ -709,11 +655,10 @@ describe('recognize', () => {\n               {path: '', component: ComponentC, outlet: 'aux'},\n             ]\n           }],\n-          '/a', (s: RouterStateSnapshot) => {\n-            const a = (s as any).firstChild(s.root)!;\n-            checkActivatedRoute(a, 'a', {}, ComponentA);\n-            checkActivatedRoute((a as any).children[0], '', {}, ComponentC, 'aux');\n-          });\n+          '/a');\n+      const a = s.root.firstChild!;\n+      checkActivatedRoute(a, 'a', {}, ComponentA);\n+      checkActivatedRoute(a.children[0], '', {}, ComponentC, 'aux');\n     });\n   });\n \n@@ -727,98 +672,75 @@ describe('recognize', () => {\n         }\n       };\n \n-      checkRecognize(\n+      const s = recognize(\n           [{\n             matcher: matcher,\n             component: ComponentA,\n             children: [{path: 'b', component: ComponentB}]\n           }] as any,\n-          '/a/1;p=99/b', (s: RouterStateSnapshot) => {\n-            const a = (s as any).root.firstChild!;\n-            checkActivatedRoute(a, 'a/1', {id: '1', p: '99'}, ComponentA);\n-            checkActivatedRoute((a as any).firstChild!, 'b', {}, ComponentB);\n-          });\n+          '/a/1;p=99/b');\n+      const a = s.root.firstChild!;\n+      checkActivatedRoute(a, 'a/1', {id: '1', p: '99'}, ComponentA);\n+      checkActivatedRoute(a.firstChild!, 'b', {}, ComponentB);\n     });\n \n     it('should work with terminal route', () => {\n       const matcher = (s: any, g: any, r: any) => s.length === 0 ? ({consumed: s}) : null;\n \n-      checkRecognize([{matcher, component: ComponentA}] as any, '', (s: RouterStateSnapshot) => {\n-        const a = (s as any).root.firstChild!;\n-        checkActivatedRoute(a, '', {}, ComponentA);\n-      });\n+      const s = recognize([{matcher, component: ComponentA}] as any, '');\n+      const a = s.root.firstChild!;\n+      checkActivatedRoute(a, '', {}, ComponentA);\n     });\n \n     it('should work with child terminal route', () => {\n       const matcher = (s: any, g: any, r: any) => s.length === 0 ? ({consumed: s}) : null;\n \n-      checkRecognize(\n+      const s = recognize(\n           [{path: 'a', component: ComponentA, children: [{matcher, component: ComponentB}]}] as any,\n-          'a', (s: RouterStateSnapshot) => {\n-            const a = (s as any).root.firstChild!;\n-            checkActivatedRoute(a, 'a', {}, ComponentA);\n-          });\n+          'a');\n+      const a = s.root.firstChild!;\n+      checkActivatedRoute(a, 'a', {}, ComponentA);\n     });\n   });\n \n   describe('query parameters', () => {\n     it('should support query params', () => {\n       const config = [{path: 'a', component: ComponentA}];\n-      checkRecognize(config, 'a?q=11', (s: RouterStateSnapshot) => {\n-        expect(s.root.queryParams).toEqual({q: '11'});\n-        expect(s.root.queryParamMap.get('q')).toEqual('11');\n-      });\n+      const s = recognize(config, 'a?q=11');\n+      expect(s.root.queryParams).toEqual({q: '11'});\n+      expect(s.root.queryParamMap.get('q')).toEqual('11');\n     });\n \n     it('should freeze query params object', () => {\n-      checkRecognize([{path: 'a', component: ComponentA}], 'a?q=11', (s: RouterStateSnapshot) => {\n-        expect(Object.isFrozen(s.root.queryParams)).toBeTruthy();\n-      });\n+      const s = recognize([{path: 'a', component: ComponentA}], 'a?q=11');\n+      expect(Object.isFrozen(s.root.queryParams)).toBeTruthy();\n     });\n \n     it('should not freeze UrlTree query params', () => {\n       const url = tree('a?q=11');\n-      recognize(RootComponent, [{path: 'a', component: ComponentA}], url, 'a?q=11')\n-          .subscribe((s: RouterStateSnapshot) => {\n-            expect(Object.isFrozen(url.queryParams)).toBe(false);\n-          });\n+      const s = recognize([{path: 'a', component: ComponentA}], 'a?q=11');\n+      expect(Object.isFrozen(url.queryParams)).toBe(false);\n     });\n   });\n \n   describe('fragment', () => {\n     it('should support fragment', () => {\n       const config = [{path: 'a', component: ComponentA}];\n-      checkRecognize(config, 'a#f1', (s: RouterStateSnapshot) => {\n-        expect(s.root.fragment).toEqual('f1');\n-      });\n-    });\n-  });\n-\n-  describe('error handling', () => {\n-    it('should error when two routes with the same outlet name got matched', () => {\n-      recognize(\n-          RootComponent,\n-          [\n-            {path: 'a', component: ComponentA}, {path: 'b', component: ComponentB, outlet: 'aux'},\n-            {path: 'c', component: ComponentC, outlet: 'aux'}\n-          ],\n-          tree('a(aux:b//aux:c)'), 'a(aux:b//aux:c)')\n-          .subscribe((_) => {}, (s: RouterStateSnapshot) => {\n-            expect(s.toString())\n-                .toContain(\n-                    'Two segments cannot have the same outlet name: \\'aux:b\\' and \\'aux:c\\'.');\n-          });\n+      const s = recognize(config, 'a#f1');\n+      expect(s.root.fragment).toEqual('f1');\n     });\n   });\n });\n \n-function checkRecognize(\n-    config: Routes, url: string, callback: any,\n-    paramsInheritanceStrategy?: 'emptyOnly'|'always'): void {\n-  recognize(RootComponent, config, tree(url), url, paramsInheritanceStrategy)\n-      .subscribe(callback, e => {\n-        throw e;\n-      });\n+function recognize(\n+    config: Routes, url: string, paramsInheritanceStrategy: 'emptyOnly'|'always' = 'emptyOnly',\n+    relativeLinkResolution: 'legacy'|'corrected' = 'legacy'): RouterStateSnapshot {\n+  const result =\n+      new Recognizer(\n+          RootComponent, config, tree(url), url, paramsInheritanceStrategy, relativeLinkResolution)\n+          .recognize();\n+  expect(result).not.toBeNull();\n+  return result!;\n }\n \n function checkActivatedRoute("
        }
    ],
    "stats": {
        "total": 798,
        "additions": 364,
        "deletions": 434
    }
}