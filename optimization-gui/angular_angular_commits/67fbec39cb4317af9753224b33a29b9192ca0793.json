{
    "author": "petebacondarwin",
    "message": "refactor(compiler): rename R3ProviderExpression and associated helpers (#44113)\n\nThis interface will be used in other situations so this change renames it to be more general as `MaybeForwardRefExpression`.\n\nPR Close #44113",
    "sha": "67fbec39cb4317af9753224b33a29b9192ca0793",
    "files": [
        {
            "sha": "f4839a779968a611ec449854146bdf4f5afb06c7",
            "filename": "packages/compiler-cli/linker/src/file_linker/partial_linkers/partial_injectable_linker_1.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_injectable_linker_1.ts",
            "raw_url": "https://github.com/angular/angular/raw/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_injectable_linker_1.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_injectable_linker_1.ts?ref=67fbec39cb4317af9753224b33a29b9192ca0793",
            "patch": "@@ -5,7 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {compileInjectable, ConstantPool, createR3ProviderExpression, outputAst as o, R3DeclareInjectableMetadata, R3InjectableMetadata, R3PartialDeclaration} from '@angular/compiler';\n+import {compileInjectable, ConstantPool, createMayBeForwardRefExpression, outputAst as o, R3DeclareInjectableMetadata, R3InjectableMetadata, R3PartialDeclaration} from '@angular/compiler';\n \n import {AstObject} from '../../ast/ast_value';\n import {FatalLinkerError} from '../../fatal_linker_error';\n@@ -44,7 +44,7 @@ export function toR3InjectableMeta<TExpression>(\n     internalType: typeExpr.getOpaque(),\n     typeArgumentCount: 0,\n     providedIn: metaObj.has('providedIn') ? extractForwardRef(metaObj.getValue('providedIn')) :\n-                                            createR3ProviderExpression(o.literal(null), false),\n+                                            createMayBeForwardRefExpression(o.literal(null), false),\n   };\n \n   if (metaObj.has('useClass')) {"
        },
        {
            "sha": "48986e807e2bfc4d1f5e2898729bef5af52a5158",
            "filename": "packages/compiler-cli/linker/src/file_linker/partial_linkers/util.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Futil.ts?ref=67fbec39cb4317af9753224b33a29b9192ca0793",
            "patch": "@@ -5,7 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {createR3ProviderExpression, outputAst as o, R3DeclareDependencyMetadata, R3DependencyMetadata, R3ProviderExpression, R3Reference} from '@angular/compiler';\n+import {createMayBeForwardRefExpression, MaybeForwardRefExpression, outputAst as o, R3DeclareDependencyMetadata, R3DependencyMetadata, R3Reference} from '@angular/compiler';\n \n import {AstObject, AstValue} from '../../ast/ast_value';\n import {FatalLinkerError} from '../../fatal_linker_error';\n@@ -66,9 +66,9 @@ export function getDependency<TExpression>(\n  * If there is no forwardRef call expression then we just return the opaque type.\n  */\n export function extractForwardRef<TExpression>(expr: AstValue<unknown, TExpression>):\n-    R3ProviderExpression<o.WrappedNodeExpr<TExpression>> {\n+    MaybeForwardRefExpression<o.WrappedNodeExpr<TExpression>> {\n   if (!expr.isCallExpression()) {\n-    return createR3ProviderExpression(expr.getOpaque(), /* isForwardRef */ false);\n+    return createMayBeForwardRefExpression(expr.getOpaque(), /* isForwardRef */ false);\n   }\n \n   const callee = expr.getCallee();\n@@ -90,5 +90,5 @@ export function extractForwardRef<TExpression>(expr: AstValue<unknown, TExpressi\n         wrapperFn, 'Unsupported `forwardRef(fn)` call, expected its argument to be a function');\n   }\n \n-  return createR3ProviderExpression(wrapperFn.getFunctionReturnValue().getOpaque(), true);\n+  return createMayBeForwardRefExpression(wrapperFn.getFunctionReturnValue().getOpaque(), true);\n }"
        },
        {
            "sha": "105cebd682715555404c8d3fe23e5639ba47a864",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Finjectable.ts",
            "raw_url": "https://github.com/angular/angular/raw/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Finjectable.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Finjectable.ts?ref=67fbec39cb4317af9753224b33a29b9192ca0793",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {compileClassMetadata, CompileClassMetadataFn, compileDeclareClassMetadata, compileDeclareInjectableFromMetadata, compileInjectable, createR3ProviderExpression, Expression, FactoryTarget, LiteralExpr, R3ClassMetadata, R3CompiledExpression, R3DependencyMetadata, R3InjectableMetadata, R3ProviderExpression, Statement, WrappedNodeExpr} from '@angular/compiler';\n+import {compileClassMetadata, CompileClassMetadataFn, compileDeclareClassMetadata, compileDeclareInjectableFromMetadata, compileInjectable, createMayBeForwardRefExpression, FactoryTarget, LiteralExpr, MaybeForwardRefExpression, R3ClassMetadata, R3CompiledExpression, R3DependencyMetadata, R3InjectableMetadata, WrappedNodeExpr} from '@angular/compiler';\n import ts from 'typescript';\n \n import {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\n@@ -162,7 +162,7 @@ function extractInjectableMetadata(\n       type,\n       typeArgumentCount,\n       internalType,\n-      providedIn: createR3ProviderExpression(new LiteralExpr(null), false),\n+      providedIn: createMayBeForwardRefExpression(new LiteralExpr(null), false),\n     };\n   } else if (decorator.args.length === 1) {\n     const metaNode = decorator.args[0];\n@@ -180,7 +180,7 @@ function extractInjectableMetadata(\n \n     const providedIn = meta.has('providedIn') ?\n         getProviderExpression(meta.get('providedIn')!, reflector) :\n-        createR3ProviderExpression(new LiteralExpr(null), false);\n+        createMayBeForwardRefExpression(new LiteralExpr(null), false);\n \n     let deps: R3DependencyMetadata[]|undefined = undefined;\n     if ((meta.has('useClass') || meta.has('useFactory')) && meta.has('deps')) {\n@@ -220,9 +220,9 @@ function extractInjectableMetadata(\n  * object to indicate whether the value needed unwrapping.\n  */\n function getProviderExpression(\n-    expression: ts.Expression, reflector: ReflectionHost): R3ProviderExpression {\n+    expression: ts.Expression, reflector: ReflectionHost): MaybeForwardRefExpression {\n   const forwardRefValue = tryUnwrapForwardRef(expression, reflector);\n-  return createR3ProviderExpression(\n+  return createMayBeForwardRefExpression(\n       new WrappedNodeExpr(forwardRefValue ?? expression), forwardRefValue !== null);\n }\n "
        },
        {
            "sha": "b38082ab53194b866d2f4365323cfc8d9f57abac",
            "filename": "packages/compiler/src/compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompiler.ts?ref=67fbec39cb4317af9753224b33a29b9192ca0793",
            "patch": "@@ -103,7 +103,7 @@ export {compileNgModule, R3NgModuleMetadata} from './render3/r3_module_compiler'\n export {compileInjector, R3InjectorMetadata} from './render3/r3_injector_compiler';\n export {compilePipeFromMetadata, R3PipeMetadata} from './render3/r3_pipe_compiler';\n export {makeBindingParser, ParsedTemplate, parseTemplate, ParseTemplateOptions} from './render3/view/template';\n-export {R3CompiledExpression, R3Reference, devOnlyGuardedExpression, getSafePropertyAccessString} from './render3/util';\n+export {MaybeForwardRefExpression, R3CompiledExpression, R3Reference, createMayBeForwardRefExpression, devOnlyGuardedExpression, getSafePropertyAccessString} from './render3/util';\n export {compileComponentFromMetadata, compileDirectiveFromMetadata, parseHostBindings, ParsedHostBindings, verifyHostBindings} from './render3/view/compiler';\n export {compileDeclareClassMetadata} from './render3/partial/class_metadata';\n export {compileDeclareComponentFromMetadata, DeclareComponentTemplateInfo} from './render3/partial/component';"
        },
        {
            "sha": "1ec5eef78e0f656d19347ba34bb3668c91746246",
            "filename": "packages/compiler/src/injectable_compiler_2.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 40,
            "changes": 45,
            "blob_url": "https://github.com/angular/angular/blob/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Finjectable_compiler_2.ts",
            "raw_url": "https://github.com/angular/angular/raw/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Finjectable_compiler_2.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Finjectable_compiler_2.ts?ref=67fbec39cb4317af9753224b33a29b9192ca0793",
            "patch": "@@ -7,59 +7,24 @@\n  */\n \n import * as o from './output/output_ast';\n-import {generateForwardRef} from './render3/partial/util';\n import {compileFactoryFunction, FactoryTarget, R3DependencyMetadata, R3FactoryDelegateType, R3FactoryMetadata} from './render3/r3_factory';\n import {Identifiers} from './render3/r3_identifiers';\n-import {R3CompiledExpression, R3Reference, typeWithParameters} from './render3/util';\n+import {generateForwardRef, MaybeForwardRefExpression, R3CompiledExpression, R3Reference, typeWithParameters} from './render3/util';\n import {DefinitionMap} from './render3/view/util';\n \n export interface R3InjectableMetadata {\n   name: string;\n   type: R3Reference;\n   internalType: o.Expression;\n   typeArgumentCount: number;\n-  providedIn: R3ProviderExpression;\n-  useClass?: R3ProviderExpression;\n+  providedIn: MaybeForwardRefExpression;\n+  useClass?: MaybeForwardRefExpression;\n   useFactory?: o.Expression;\n-  useExisting?: R3ProviderExpression;\n-  useValue?: R3ProviderExpression;\n+  useExisting?: MaybeForwardRefExpression;\n+  useValue?: MaybeForwardRefExpression;\n   deps?: R3DependencyMetadata[];\n }\n \n-/**\n- * An expression used when instantiating an injectable.\n- *\n- * This is the type of the `useClass`, `useExisting` and `useValue` properties of\n- * `R3InjectableMetadata` since those can refer to types that may eagerly reference types that have\n- * not yet been defined.\n- */\n-export interface R3ProviderExpression<T extends o.Expression = o.Expression> {\n-  /**\n-   * The expression that is used to instantiate the Injectable.\n-   */\n-  expression: T;\n-  /**\n-   * If true, then the `expression` contains a reference to something that has not yet been\n-   * defined.\n-   *\n-   * This means that the expression must not be eagerly evaluated. Instead it must be wrapped in a\n-   * function closure that will be evaluated lazily to allow the definition of the expression to be\n-   * evaluated first.\n-   *\n-   * In some cases the expression will naturally be placed inside such a function closure, such as\n-   * in a fully compiled factory function. In those case nothing more needs to be done.\n-   *\n-   * But in other cases, such as partial-compilation the expression will be located in top level\n-   * code so will need to be wrapped in a function that is passed to a `forwardRef()` call.\n-   */\n-  isForwardRef: boolean;\n-}\n-\n-export function createR3ProviderExpression<T extends o.Expression>(\n-    expression: T, isForwardRef: boolean): R3ProviderExpression<T> {\n-  return {expression, isForwardRef};\n-}\n-\n export function compileInjectable(\n     meta: R3InjectableMetadata, resolveForwardRefs: boolean): R3CompiledExpression {\n   let result: {expression: o.Expression, statements: o.Statement[]}|null = null;"
        },
        {
            "sha": "7a08d90c48e0a3265e030667bfba731b37ce9778",
            "filename": "packages/compiler/src/jit_compiler_facade.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Fjit_compiler_facade.ts",
            "raw_url": "https://github.com/angular/angular/raw/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Fjit_compiler_facade.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fjit_compiler_facade.ts?ref=67fbec39cb4317af9753224b33a29b9192ca0793",
            "patch": "@@ -10,7 +10,7 @@\n import {CompilerFacade, CoreEnvironment, ExportedCompilerFacade, OpaqueValue, R3ComponentMetadataFacade, R3DeclareComponentFacade, R3DeclareDependencyMetadataFacade, R3DeclareDirectiveFacade, R3DeclareFactoryFacade, R3DeclareInjectableFacade, R3DeclareInjectorFacade, R3DeclareNgModuleFacade, R3DeclarePipeFacade, R3DeclareQueryMetadataFacade, R3DeclareUsedDirectiveFacade, R3DependencyMetadataFacade, R3DirectiveMetadataFacade, R3FactoryDefMetadataFacade, R3InjectableMetadataFacade, R3InjectorMetadataFacade, R3NgModuleMetadataFacade, R3PipeMetadataFacade, R3QueryMetadataFacade, StringMap, StringMapWithRename} from './compiler_facade_interface';\n import {ConstantPool} from './constant_pool';\n import {ChangeDetectionStrategy, HostBinding, HostListener, Input, Output, ViewEncapsulation} from './core';\n-import {compileInjectable, createR3ProviderExpression, R3ProviderExpression} from './injectable_compiler_2';\n+import {compileInjectable} from './injectable_compiler_2';\n import {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './ml_parser/interpolation_config';\n import {DeclareVarStmt, Expression, literal, LiteralExpr, Statement, StmtModifier, WrappedNodeExpr} from './output/output_ast';\n import {JitEvaluator} from './output/output_jit';\n@@ -20,7 +20,7 @@ import {compileInjector, R3InjectorMetadata} from './render3/r3_injector_compile\n import {R3JitReflector} from './render3/r3_jit';\n import {compileNgModule, compileNgModuleDeclarationExpression, R3NgModuleMetadata} from './render3/r3_module_compiler';\n import {compilePipeFromMetadata, R3PipeMetadata} from './render3/r3_pipe_compiler';\n-import {getSafePropertyAccessString, wrapReference} from './render3/util';\n+import {createMayBeForwardRefExpression, getSafePropertyAccessString, MaybeForwardRefExpression, wrapReference} from './render3/util';\n import {DeclarationListEmitMode, R3ComponentMetadata, R3DirectiveMetadata, R3HostMetadata, R3QueryMetadata, R3UsedDirectiveMetadata} from './render3/view/api';\n import {compileComponentFromMetadata, compileDirectiveFromMetadata, ParsedHostBindings, parseHostBindings, verifyHostBindings} from './render3/view/compiler';\n import {makeBindingParser, parseTemplate} from './render3/view/template';\n@@ -477,9 +477,11 @@ type R3DirectiveMetadataFacadeNoPropAndWhitespace =\n  * a `forwardRef()` - either by the application developer or during partial-compilation. Thus we can\n  * set `isForwardRef` to `false`.\n  */\n-function convertToProviderExpression(obj: any, property: string): R3ProviderExpression|undefined {\n+function convertToProviderExpression(obj: any, property: string): MaybeForwardRefExpression|\n+    undefined {\n   if (obj.hasOwnProperty(property)) {\n-    return createR3ProviderExpression(new WrappedNodeExpr(obj[property]), /* isForwardRef */ false);\n+    return createMayBeForwardRefExpression(\n+        new WrappedNodeExpr(obj[property]), /* isForwardRef */ false);\n   } else {\n     return undefined;\n   }\n@@ -493,11 +495,11 @@ function wrapExpression(obj: any, property: string): WrappedNodeExpr<any>|undefi\n   }\n }\n \n-function computeProvidedIn(providedIn: Function|string|null|undefined): R3ProviderExpression {\n+function computeProvidedIn(providedIn: Function|string|null|undefined): MaybeForwardRefExpression {\n   const expression = typeof providedIn === 'function' ? new WrappedNodeExpr(providedIn) :\n                                                         new LiteralExpr(providedIn ?? null);\n   // See `convertToProviderExpression()` for why `isForwardRef` is false.\n-  return createR3ProviderExpression(expression, /* isForwardRef */ false);\n+  return createMayBeForwardRefExpression(expression, /* isForwardRef */ false);\n }\n \n function convertR3DependencyMetadataArray(facades: R3DependencyMetadataFacade[]|null|"
        },
        {
            "sha": "da7b8513edcb4ee39a7827a1913fa6de97e243c0",
            "filename": "packages/compiler/src/render3/partial/component.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Fcomponent.ts?ref=67fbec39cb4317af9753224b33a29b9192ca0793",
            "patch": "@@ -10,15 +10,15 @@ import {DEFAULT_INTERPOLATION_CONFIG} from '../../ml_parser/interpolation_config\n import * as o from '../../output/output_ast';\n import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../parse_util';\n import {Identifiers as R3} from '../r3_identifiers';\n-import {R3CompiledExpression} from '../util';\n+import {generateForwardRef, R3CompiledExpression} from '../util';\n import {DeclarationListEmitMode, R3ComponentMetadata, R3UsedDirectiveMetadata} from '../view/api';\n import {createComponentType} from '../view/compiler';\n import {ParsedTemplate} from '../view/template';\n import {DefinitionMap} from '../view/util';\n \n import {R3DeclareComponentMetadata, R3DeclareUsedDirectiveMetadata} from './api';\n import {createDirectiveDefinitionMap} from './directive';\n-import {generateForwardRef, toOptionalLiteralArray} from './util';\n+import {toOptionalLiteralArray} from './util';\n \n export interface DeclareComponentTemplateInfo {\n   /**"
        },
        {
            "sha": "6f23b583b75321da93e2b1f868832167c148c835",
            "filename": "packages/compiler/src/render3/partial/injectable.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 30,
            "changes": 37,
            "blob_url": "https://github.com/angular/angular/blob/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Finjectable.ts",
            "raw_url": "https://github.com/angular/angular/raw/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Finjectable.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Finjectable.ts?ref=67fbec39cb4317af9753224b33a29b9192ca0793",
            "patch": "@@ -5,14 +5,14 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {createInjectableType, R3InjectableMetadata, R3ProviderExpression} from '../../injectable_compiler_2';\n+import {createInjectableType, R3InjectableMetadata} from '../../injectable_compiler_2';\n import * as o from '../../output/output_ast';\n import {Identifiers as R3} from '../r3_identifiers';\n-import {R3CompiledExpression} from '../util';\n+import {convertFromMaybeForwardRefExpression, R3CompiledExpression} from '../util';\n import {DefinitionMap} from '../view/util';\n \n import {R3DeclareInjectableMetadata} from './api';\n-import {compileDependency, generateForwardRef} from './util';\n+import {compileDependency} from './util';\n \n /**\n  * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n@@ -50,20 +50,20 @@ export function createInjectableDefinitionMap(meta: R3InjectableMetadata):\n \n   // Only generate providedIn property if it has a non-null value\n   if (meta.providedIn !== undefined) {\n-    const providedIn = convertFromProviderExpression(meta.providedIn);\n+    const providedIn = convertFromMaybeForwardRefExpression(meta.providedIn);\n     if ((providedIn as o.LiteralExpr).value !== null) {\n       definitionMap.set('providedIn', providedIn);\n     }\n   }\n \n   if (meta.useClass !== undefined) {\n-    definitionMap.set('useClass', convertFromProviderExpression(meta.useClass));\n+    definitionMap.set('useClass', convertFromMaybeForwardRefExpression(meta.useClass));\n   }\n   if (meta.useExisting !== undefined) {\n-    definitionMap.set('useExisting', convertFromProviderExpression(meta.useExisting));\n+    definitionMap.set('useExisting', convertFromMaybeForwardRefExpression(meta.useExisting));\n   }\n   if (meta.useValue !== undefined) {\n-    definitionMap.set('useValue', convertFromProviderExpression(meta.useValue));\n+    definitionMap.set('useValue', convertFromMaybeForwardRefExpression(meta.useValue));\n   }\n   // Factories do not contain `ForwardRef`s since any types are already wrapped in a function call\n   // so the types will not be eagerly evaluated. Therefore we do not need to process this expression\n@@ -78,26 +78,3 @@ export function createInjectableDefinitionMap(meta: R3InjectableMetadata):\n \n   return definitionMap;\n }\n-\n-/**\n- * Convert an `R3ProviderExpression` to an `Expression`, possibly wrapping its expression in a\n- * `forwardRef()` call.\n- *\n- * If `R3ProviderExpression.isForwardRef` is true then the expression was originally wrapped in a\n- * `forwardRef()` call to prevent the value from being eagerly evaluated in the code.\n- *\n- * Normally, the linker will statically process the code, putting the `expression` inside a factory\n- * function so the `forwardRef()` wrapper is not evaluated before it has been defined. But if the\n- * partial declaration is evaluated by the JIT compiler the `forwardRef()` call is still needed to\n- * prevent eager evaluation of the `expression`.\n- *\n- * So in partial declarations, expressions that could be forward-refs are wrapped in `forwardRef()`\n- * calls, and this is then unwrapped in the linker as necessary.\n- *\n- * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and\n- * `packages/compiler/src/jit_compiler_facade.ts` for more information.\n- */\n-function convertFromProviderExpression({expression, isForwardRef}: R3ProviderExpression):\n-    o.Expression {\n-  return isForwardRef ? generateForwardRef(expression) : expression;\n-}"
        },
        {
            "sha": "4e66feefdc4479d1c2243e21250540c9716c814d",
            "filename": "packages/compiler/src/render3/partial/util.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 12,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Futil.ts?ref=67fbec39cb4317af9753224b33a29b9192ca0793",
            "patch": "@@ -7,7 +7,6 @@\n  */\n import * as o from '../../output/output_ast';\n import {R3DependencyMetadata} from '../r3_factory';\n-import {Identifiers} from '../r3_identifiers';\n import {DefinitionMap} from '../view/util';\n import {R3DeclareDependencyMetadata} from './api';\n \n@@ -84,14 +83,3 @@ export function compileDependency(dep: R3DependencyMetadata): o.LiteralMapExpr {\n   }\n   return depMeta.toLiteralMap();\n }\n-\n-/**\n- * Generate an expression that has the given `expr` wrapped in the following form:\n- *\n- * ```\n- * forwardRef(() => expr)\n- * ```\n- */\n-export function generateForwardRef(expr: o.Expression): o.Expression {\n-  return o.importExpr(Identifiers.forwardRef).callFn([o.fn([], [new o.ReturnStatement(expr)])]);\n-}"
        },
        {
            "sha": "0a2922f53db873abd68e42e9637d298f407ae5e9",
            "filename": "packages/compiler/src/render3/util.ts",
            "status": "modified",
            "additions": 69,
            "deletions": 0,
            "changes": 69,
            "blob_url": "https://github.com/angular/angular/blob/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Frender3%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/67fbec39cb4317af9753224b33a29b9192ca0793/packages%2Fcompiler%2Fsrc%2Frender3%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Futil.ts?ref=67fbec39cb4317af9753224b33a29b9192ca0793",
            "patch": "@@ -8,6 +8,7 @@\n \n import {escapeIdentifier} from '../output/abstract_emitter';\n import * as o from '../output/output_ast';\n+import {Identifiers} from './r3_identifiers';\n \n export function typeWithParameters(type: o.Expression, numParams: number): o.ExpressionType {\n   if (numParams === 0) {\n@@ -79,3 +80,71 @@ export function refsToArray(refs: R3Reference[], shouldForwardDeclare: boolean):\n   const values = o.literalArr(refs.map(ref => ref.value));\n   return shouldForwardDeclare ? o.fn([], [new o.ReturnStatement(values)]) : values;\n }\n+\n+\n+/**\n+ * Describes an expression that may have been wrapped in a `forwardRef()` guard.\n+ *\n+ * This is used when describing expressions that can refer to types that may eagerly reference types\n+ * that have not yet been defined.\n+ */\n+export interface MaybeForwardRefExpression<T extends o.Expression = o.Expression> {\n+  /**\n+   * The unwrapped expression.\n+   */\n+  expression: T;\n+  /**\n+   * If true, then the `expression` contains a reference to something that has not yet been\n+   * defined.\n+   *\n+   * This means that the expression must not be eagerly evaluated. Instead it must be wrapped in a\n+   * function closure that will be evaluated lazily to allow the definition of the expression to be\n+   * evaluated first.\n+   *\n+   * In some cases the expression will naturally be placed inside such a function closure, such as\n+   * in a fully compiled factory function. In those cases nothing more needs to be done.\n+   *\n+   * But in other cases, such as partial-compilation the expression will be located in top level\n+   * code so will need to be wrapped in a function that is passed to a `forwardRef()` call.\n+   */\n+  isForwardRef: boolean;\n+}\n+\n+export function createMayBeForwardRefExpression<T extends o.Expression>(\n+    expression: T, isForwardRef: boolean): MaybeForwardRefExpression<T> {\n+  return {expression, isForwardRef};\n+}\n+\n+/**\n+ * Convert a `MaybeForwardRefExpression` to an `Expression`, possibly wrapping its expression in a\n+ * `forwardRef()` call.\n+ *\n+ * If `MaybeForwardRefExpression.isForwardRef` is true then the expression was originally wrapped in\n+ * a `forwardRef()` call to prevent the value from being eagerly evaluated in the code.\n+ *\n+ * Normally, the linker will statically process the code, putting the `expression` inside a factory\n+ * function so the `forwardRef()` wrapper is not evaluated before it has been defined. But if the\n+ * partial declaration is evaluated by the JIT compiler the `forwardRef()` call is still needed to\n+ * prevent eager evaluation of the `expression`.\n+ *\n+ * So in partial declarations, expressions that could be forward-refs are wrapped in `forwardRef()`\n+ * calls, and this is then unwrapped in the linker as necessary.\n+ *\n+ * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and\n+ * `packages/compiler/src/jit_compiler_facade.ts` for more information.\n+ */\n+export function convertFromMaybeForwardRefExpression(\n+    {expression, isForwardRef}: MaybeForwardRefExpression): o.Expression {\n+  return isForwardRef ? generateForwardRef(expression) : expression;\n+}\n+\n+/**\n+ * Generate an expression that has the given `expr` wrapped in the following form:\n+ *\n+ * ```\n+ * forwardRef(() => expr)\n+ * ```\n+ */\n+export function generateForwardRef(expr: o.Expression): o.Expression {\n+  return o.importExpr(Identifiers.forwardRef).callFn([o.fn([], [new o.ReturnStatement(expr)])]);\n+}"
        }
    ],
    "stats": {
        "total": 205,
        "additions": 103,
        "deletions": 102
    }
}