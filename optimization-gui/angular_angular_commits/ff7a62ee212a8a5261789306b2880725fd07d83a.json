{
    "author": "atscott",
    "message": "refactor(router): Small refactor of createUrlTree and extra tests (#39456)\n\nThis commit has a small refactor of some methods in create_url_tree.ts\nand adds some test cases, including two that will fail at the moment but\nshould pass. A follow-up commit will make use of the refactorings to fix\nthe test with minimal changes.\n\nPR Close #39456",
    "sha": "ff7a62ee212a8a5261789306b2880725fd07d83a",
    "files": [
        {
            "sha": "40f40ecf015971cc9c371c608b01df18528b086a",
            "filename": "packages/core/test/bundling/router/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/ff7a62ee212a8a5261789306b2880725fd07d83a/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/ff7a62ee212a8a5261789306b2880725fd07d83a/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json?ref=ff7a62ee212a8a5261789306b2880725fd07d83a",
            "patch": "@@ -1376,9 +1376,6 @@\n   {\n     \"name\": \"getParentInjectorView\"\n   },\n-  {\n-    \"name\": \"getPath\"\n-  },\n   {\n     \"name\": \"getPathIndexShift\"\n   },\n@@ -1490,6 +1487,9 @@\n   {\n     \"name\": \"isArrayLike\"\n   },\n+  {\n+    \"name\": \"isCommandWithOutlets\"\n+  },\n   {\n     \"name\": \"isComponentDef\"\n   },"
        },
        {
            "sha": "c7fcb3126002c1dcf09d842ef9cf731144ac8acd",
            "filename": "packages/router/src/create_url_tree.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 7,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/ff7a62ee212a8a5261789306b2880725fd07d83a/packages%2Frouter%2Fsrc%2Fcreate_url_tree.ts",
            "raw_url": "https://github.com/angular/angular/raw/ff7a62ee212a8a5261789306b2880725fd07d83a/packages%2Frouter%2Fsrc%2Fcreate_url_tree.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Fcreate_url_tree.ts?ref=ff7a62ee212a8a5261789306b2880725fd07d83a",
            "patch": "@@ -37,6 +37,14 @@ function isMatrixParams(command: any): boolean {\n   return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n }\n \n+/**\n+ * Determines if a given command has an `outlets` map. When we encounter a command\n+ * with an outlets k/v map, we need to apply each outlet individually to the existing segment.\n+ */\n+function isCommandWithOutlets(command: any): command is {outlets: {[key: string]: any}} {\n+  return typeof command === 'object' && command != null && command.outlets;\n+}\n+\n function tree(\n     oldSegmentGroup: UrlSegmentGroup, newSegmentGroup: UrlSegmentGroup, urlTree: UrlTree,\n     queryParams: Params, fragment: string): UrlTree {\n@@ -75,7 +83,7 @@ class Navigation {\n       throw new Error('Root segment cannot have matrix parameters');\n     }\n \n-    const cmdWithOutlet = commands.find(c => typeof c === 'object' && c != null && c.outlets);\n+    const cmdWithOutlet = commands.find(isCommandWithOutlets);\n     if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n       throw new Error('{outlets:{}} has to be the last command');\n     }\n@@ -179,14 +187,14 @@ function createPositionApplyingDoubleDots(\n }\n \n function getPath(command: any): any {\n-  if (typeof command === 'object' && command != null && command.outlets) {\n+  if (isCommandWithOutlets(command)) {\n     return command.outlets[PRIMARY_OUTLET];\n   }\n   return `${command}`;\n }\n \n function getOutlets(commands: any[]): {[k: string]: any[]} {\n-  if (typeof commands[0] === 'object' && commands[0] !== null && commands[0].outlets) {\n+  if (isCommandWithOutlets(commands[0])) {\n     return commands[0].outlets;\n   }\n \n@@ -276,9 +284,9 @@ function createNewSegmentGroup(\n \n   let i = 0;\n   while (i < commands.length) {\n-    if (typeof commands[i] === 'object' && commands[i] !== null &&\n-        commands[i].outlets !== undefined) {\n-      const children = createNewSegmentChildren(commands[i].outlets);\n+    const command = commands[i];\n+    if (isCommandWithOutlets(command)) {\n+      const children = createNewSegmentChildren(command.outlets);\n       return new UrlSegmentGroup(paths, children);\n     }\n \n@@ -290,7 +298,7 @@ function createNewSegmentGroup(\n       continue;\n     }\n \n-    const curr = getPath(commands[i]);\n+    const curr = getPath(command);\n     const next = (i < commands.length - 1) ? commands[i + 1] : null;\n     if (curr && next && isMatrixParams(next)) {\n       paths.push(new UrlSegment(curr, stringify(next)));"
        },
        {
            "sha": "75e25644926272f52f3a35277def511196a50704",
            "filename": "packages/router/test/create_url_tree.spec.ts",
            "status": "modified",
            "additions": 94,
            "deletions": 0,
            "changes": 94,
            "blob_url": "https://github.com/angular/angular/blob/ff7a62ee212a8a5261789306b2880725fd07d83a/packages%2Frouter%2Ftest%2Fcreate_url_tree.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ff7a62ee212a8a5261789306b2880725fd07d83a/packages%2Frouter%2Ftest%2Fcreate_url_tree.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fcreate_url_tree.spec.ts?ref=ff7a62ee212a8a5261789306b2880725fd07d83a",
            "patch": "@@ -112,6 +112,100 @@ describe('createUrlTree', () => {\n     expect(serializer.serialize(t)).toEqual('/a/(b//right:d/11/e)');\n   });\n \n+  describe('', () => {\n+    /**\n+     * In this group of scenarios, imagine a config like:\n+     * {\n+     *   path: 'parent',\n+     *   children: [\n+     *     {\n+     *       path: 'child',\n+     *       component: AnyCmp\n+     *     },\n+     *     {\n+     *       path: 'popup',\n+     *       outlet: 'secondary',\n+     *       component: AnyCmp\n+     *     }\n+     *   ]\n+     * },\n+     * {\n+     *   path: 'other',\n+     *   component: AnyCmp\n+     * },\n+     * {\n+     *   path: 'rootPopup',\n+     *   outlet: 'rootSecondary',\n+     * }\n+     */\n+\n+    it('should support removing secondary outlet with prefix', () => {\n+      const p = serializer.parse('/parent/(child//secondary:popup)');\n+      const t = createRoot(p, ['parent', {outlets: {secondary: null}}]);\n+      // - Segment index 0:\n+      //   * match and keep existing 'parent'\n+      // - Segment index 1:\n+      //   * 'secondary' outlet cleared with `null`\n+      //   * 'primary' outlet not provided in the commands list, so the existing value is kept\n+      expect(serializer.serialize(t)).toEqual('/parent/child');\n+    });\n+\n+    xit('should support updating secondary and primary outlets with prefix', () => {\n+      const p = serializer.parse('/parent/child');\n+      const t = createRoot(p, ['parent', {outlets: {primary: 'child', secondary: 'popup'}}]);\n+      expect(serializer.serialize(t)).toEqual('/parent/(child//secondary:popup)');\n+    });\n+\n+    xit('should support updating two outlets at the same time relative to non-root segment', () => {\n+      const p = serializer.parse('/parent/child');\n+      const t = create(\n+          p.root.children[PRIMARY_OUTLET], 0 /* relativeTo: 'parent' */, p,\n+          [{outlets: {primary: 'child', secondary: 'popup'}}]);\n+      expect(serializer.serialize(t)).toEqual('/parent/(child//secondary:popup)');\n+    });\n+\n+    it('should support adding multiple outlets with prefix', () => {\n+      const p = serializer.parse('');\n+      const t = createRoot(p, ['parent', {outlets: {primary: 'child', secondary: 'popup'}}]);\n+      expect(serializer.serialize(t)).toEqual('/parent/(child//secondary:popup)');\n+    });\n+\n+    it('should support updating clearing primary and secondary with prefix', () => {\n+      const p = serializer.parse('/parent/(child//secondary:popup)');\n+      const t = createRoot(p, ['other']);\n+      // Because we navigate away from the 'parent' route, the children of that route are cleared\n+      // because they are note valid for the 'other' path.\n+      expect(serializer.serialize(t)).toEqual('/other');\n+    });\n+\n+    it('should not clear secondary outlet when at root and prefix is used', () => {\n+      const p = serializer.parse('/other(rootSecondary:rootPopup)');\n+      const t = createRoot(p, ['parent', {outlets: {primary: 'child', rootSecondary: null}}]);\n+      // We prefixed the navigation with 'parent' so we cannot clear the \"rootSecondary\" outlet\n+      // because once the outlets object is consumed, traversal is beyond the root segment.\n+      expect(serializer.serialize(t)).toEqual('/parent/child(rootSecondary:rootPopup)');\n+    });\n+\n+    it('should not clear non-root secondary outlet when command is targeting root', () => {\n+      const p = serializer.parse('/parent/(child//secondary:popup)');\n+      const t = createRoot(p, [{outlets: {secondary: null}}]);\n+      // The start segment index for the command is at 0, but the outlet lives at index 1\n+      // so we cannot clear the outlet from processing segment index 0.\n+      expect(serializer.serialize(t)).toEqual('/parent/(child//secondary:popup)');\n+    });\n+\n+    it('can clear an auxiliary outlet at the correct segment level', () => {\n+      const p = serializer.parse('/parent/(child//secondary:popup)(rootSecondary:rootPopup)');\n+      //                                       ^^^^^^^^^^^^^^^^^^^^^^\n+      // The parens here show that 'child' and 'secondary:popup' appear at the same 'level' in the\n+      // config, i.e. are part of the same children list. You can also imagine an implicit paren\n+      // group around the whole URL to visualize how 'parent' and 'rootSecondary:rootPopup' are also\n+      // defined at the same level.\n+      const t = createRoot(p, ['parent', {outlets: {primary: 'child', secondary: null}}]);\n+      expect(serializer.serialize(t)).toEqual('/parent/child(rootSecondary:rootPopup)');\n+    });\n+  });\n+\n   it('should throw when outlets is not the last command', () => {\n     const p = serializer.parse('/a');\n     expect(() => createRoot(p, ['a', {outlets: {right: ['c']}}, 'c']))"
        }
    ],
    "stats": {
        "total": 122,
        "additions": 112,
        "deletions": 10
    }
}