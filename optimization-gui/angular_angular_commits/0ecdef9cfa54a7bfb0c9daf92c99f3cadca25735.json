{
    "author": "alxhub",
    "message": "refactor(compiler-cli): API to get directives/pipes in scope (#39278)\n\nThis commit introduces two new methods to the TemplateTypeChecker, which\nretrieve the directives and pipes that are \"in scope\" for a given component\ntemplate. The metadata returned by this API is minimal, but enough to power\nautocompletion of selectors and attributes in templates.\n\nPR Close #39278",
    "sha": "0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735",
    "files": [
        {
            "sha": "73be8bef38a99d26ffe4f2c0e2f268af3c94338f",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735",
            "patch": "@@ -10,6 +10,7 @@ import {AST, ParseError, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {GlobalCompletion} from './completion';\n+import {DirectiveInScope, PipeInScope} from './scope';\n import {Symbol} from './symbols';\n \n /**\n@@ -101,6 +102,16 @@ export interface TemplateTypeChecker {\n    */\n   getGlobalCompletions(context: TmplAstTemplate|null, component: ts.ClassDeclaration):\n       GlobalCompletion|null;\n+\n+  /**\n+   * Get basic metadata on the directives which are in scope for the given component.\n+   */\n+  getDirectivesInScope(component: ts.ClassDeclaration): DirectiveInScope[]|null;\n+\n+  /**\n+   * Get basic metadata on the pipes which are in scope for the given component.\n+   */\n+  getPipesInScope(component: ts.ClassDeclaration): PipeInScope[]|null;\n }\n \n /**"
        },
        {
            "sha": "68ab4437fa4699e6ca22520e85ef1ea4a7c8cf1a",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Findex.ts?ref=0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735",
            "patch": "@@ -10,4 +10,5 @@ export * from './api';\n export * from './checker';\n export * from './completion';\n export * from './context';\n+export * from './scope';\n export * from './symbols';"
        },
        {
            "sha": "4395c0934baa32bb1646f5be285b1871f94aa36b",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/scope.ts",
            "status": "added",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/angular/angular/blob/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fscope.ts",
            "raw_url": "https://github.com/angular/angular/raw/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fscope.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fscope.ts?ref=0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735",
            "patch": "@@ -0,0 +1,44 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript';\n+\n+/**\n+ * Metadata on a directive which is available in the scope of a template.\n+ */\n+export interface DirectiveInScope {\n+  /**\n+   * The `ts.Symbol` for the directive class.\n+   */\n+  tsSymbol: ts.Symbol;\n+\n+  /**\n+   * The selector for the directive or component.\n+   */\n+  selector: string;\n+\n+  /**\n+   * `true` if this directive is a component.\n+   */\n+  isComponent: boolean;\n+}\n+\n+/**\n+ * Metadata for a pipe which is available in the scope of a template.\n+ */\n+export interface PipeInScope {\n+  /**\n+   * The `ts.Symbol` for the pipe class.\n+   */\n+  tsSymbol: ts.Symbol;\n+\n+  /**\n+   * Name of the pipe.\n+   */\n+  name: string;\n+}"
        },
        {
            "sha": "b23cc76b0712db7ad0b4de5d8edb3b55f3a01030",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/symbols.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 10,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts",
            "raw_url": "https://github.com/angular/angular/raw/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts?ref=0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735",
            "patch": "@@ -11,6 +11,7 @@ import * as ts from 'typescript';\n \n import {AbsoluteFsPath} from '../../file_system';\n import {ClassDeclaration} from '../../reflection';\n+import {DirectiveInScope} from './scope';\n \n export enum SymbolKind {\n   Input,\n@@ -222,24 +223,15 @@ export interface TemplateSymbol {\n  * A representation of a directive/component whose selector matches a node in a component\n  * template.\n  */\n-export interface DirectiveSymbol {\n+export interface DirectiveSymbol extends DirectiveInScope {\n   kind: SymbolKind.Directive;\n \n   /** The `ts.Type` for the class declaration. */\n   tsType: ts.Type;\n \n-  /** The `ts.Symbol` for the class declaration. */\n-  tsSymbol: ts.Symbol;\n-\n   /** The location in the shim file for the variable that holds the type of the directive. */\n   shimLocation: ShimLocation;\n \n-  /** The selector for the `Directive` / `Component`. */\n-  selector: string|null;\n-\n-  /** `true` if this `DirectiveSymbol` is for a @Component. */\n-  isComponent: boolean;\n-\n   /** The `NgModule` that this directive is declared in or `null` if it could not be determined. */\n   ngModule: ClassDeclaration|null;\n }"
        },
        {
            "sha": "455080750028c020e26088edd84f1dd264e8bccc",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 87,
            "deletions": 2,
            "changes": 89,
            "blob_url": "https://github.com/angular/angular/blob/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735",
            "patch": "@@ -12,11 +12,11 @@ import * as ts from 'typescript';\n import {absoluteFromSourceFile, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\n import {ReferenceEmitter} from '../../imports';\n import {IncrementalBuild} from '../../incremental/api';\n-import {ReflectionHost} from '../../reflection';\n+import {isNamedClassDeclaration, ReflectionHost} from '../../reflection';\n import {ComponentScopeReader} from '../../scope';\n import {isShim} from '../../shims';\n import {getSourceFileOrNull} from '../../util/src/typescript';\n-import {CompletionKind, GlobalCompletion, OptimizeFor, ProgramTypeCheckAdapter, Symbol, TemplateId, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\n+import {CompletionKind, DirectiveInScope, GlobalCompletion, OptimizeFor, PipeInScope, ProgramTypeCheckAdapter, Symbol, TemplateId, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\n import {TemplateDiagnostic} from '../diagnostics';\n \n import {ExpressionIdentifier, findFirstMatchingNode} from './comments';\n@@ -51,6 +51,16 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n    */\n   private symbolBuilderCache = new Map<ts.ClassDeclaration, SymbolBuilder>();\n \n+  /**\n+   * Stores directives and pipes that are in scope for each component.\n+   *\n+   * Unlike the other caches, the scope of a component is not affected by its template, so this\n+   * cache does not need to be invalidate if the template is overridden. It will be destroyed when\n+   * the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is destroyed and\n+   * replaced.\n+   */\n+  private scopeCache = new Map<ts.ClassDeclaration, ScopeData>();\n+\n   private isComplete = false;\n \n   constructor(\n@@ -433,6 +443,73 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     this.symbolBuilderCache.set(component, builder);\n     return builder;\n   }\n+\n+  getDirectivesInScope(component: ts.ClassDeclaration): DirectiveInScope[]|null {\n+    const data = this.getScopeData(component);\n+    if (data === null) {\n+      return null;\n+    }\n+    return data.directives;\n+  }\n+\n+  getPipesInScope(component: ts.ClassDeclaration): PipeInScope[]|null {\n+    const data = this.getScopeData(component);\n+    if (data === null) {\n+      return null;\n+    }\n+    return data.pipes;\n+  }\n+\n+  private getScopeData(component: ts.ClassDeclaration): ScopeData|null {\n+    if (this.scopeCache.has(component)) {\n+      return this.scopeCache.get(component)!;\n+    }\n+\n+    if (!isNamedClassDeclaration(component)) {\n+      throw new Error(`AssertionError: components must have names`);\n+    }\n+\n+    const data: ScopeData = {\n+      directives: [],\n+      pipes: [],\n+    };\n+\n+    const scope = this.componentScopeReader.getScopeForComponent(component);\n+    if (scope === null || scope === 'error') {\n+      return null;\n+    }\n+\n+    const typeChecker = this.typeCheckingStrategy.getProgram().getTypeChecker();\n+    for (const dir of scope.exported.directives) {\n+      if (dir.selector === null) {\n+        // Skip this directive, it can't be added to a template anyway.\n+        continue;\n+      }\n+      const tsSymbol = typeChecker.getSymbolAtLocation(dir.ref.node.name);\n+      if (tsSymbol === undefined) {\n+        continue;\n+      }\n+      data.directives.push({\n+        isComponent: dir.isComponent,\n+        selector: dir.selector,\n+        tsSymbol,\n+      });\n+    }\n+\n+    for (const pipe of scope.exported.pipes) {\n+      const tsSymbol = typeChecker.getSymbolAtLocation(pipe.ref.node.name);\n+      if (tsSymbol === undefined) {\n+        continue;\n+      }\n+      data.pipes.push({\n+        name: pipe.name,\n+        tsSymbol,\n+      });\n+    }\n+\n+    this.scopeCache.set(component, data);\n+    return data;\n+  }\n }\n \n function convertDiagnostic(\n@@ -622,3 +699,11 @@ class SingleShimTypeCheckingHost extends SingleFileTypeCheckingHost {\n     return !this.fileData.shimData.has(shimPath);\n   }\n }\n+\n+/**\n+ * Cached scope information for a component.\n+ */\n+interface ScopeData {\n+  directives: DirectiveInScope[];\n+  pipes: PipeInScope[];\n+}"
        },
        {
            "sha": "91cc032ae41019388b0dac1e1120c80ff796f7dc",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735",
            "patch": "@@ -129,12 +129,14 @@ export class SymbolBuilder {\n           }\n \n           const ngModule = this.getDirectiveModule(symbol.tsSymbol.valueDeclaration);\n-          const selector = meta.selector ?? null;\n+          if (meta.selector === null) {\n+            return null;\n+          }\n           const isComponent = meta.isComponent ?? null;\n           const directiveSymbol: DirectiveSymbol = {\n             ...symbol,\n             tsSymbol: symbol.tsSymbol,\n-            selector,\n+            selector: meta.selector,\n             isComponent,\n             ngModule,\n             kind: SymbolKind.Directive\n@@ -256,7 +258,7 @@ export class SymbolBuilder {\n     // In either case, `_t1[\"index\"]` or `_t1.index`, `node.expression` is _t1.\n     // The retrieved symbol for _t1 will be the variable declaration.\n     const tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.expression);\n-    if (tsSymbol === undefined || tsSymbol.declarations.length === 0) {\n+    if (tsSymbol === undefined || tsSymbol.declarations.length === 0 || selector === null) {\n       return null;\n     }\n "
        },
        {
            "sha": "096875c852d7713a33f7cf7d7478433f052f9bac",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/test_utils.ts",
            "status": "modified",
            "additions": 100,
            "deletions": 19,
            "changes": 119,
            "blob_url": "https://github.com/angular/angular/blob/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts?ref=0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735",
            "patch": "@@ -15,7 +15,7 @@ import {AbsoluteModuleStrategy, LocalIdentifierStrategy, LogicalProjectStrategy,\n import {NOOP_INCREMENTAL_BUILD} from '../../incremental';\n import {ClassPropertyMapping} from '../../metadata';\n import {ClassDeclaration, isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\n-import {ComponentScopeReader, ScopeData} from '../../scope';\n+import {ComponentScopeReader, LocalModuleScope, ScopeData} from '../../scope';\n import {makeProgram} from '../../testing';\n import {getRootDirs} from '../../util/src/typescript';\n import {ProgramTypeCheckAdapter, TemplateTypeChecker, TypeCheckContext} from '../api';\n@@ -355,6 +355,18 @@ export function setup(targets: TypeCheckingTarget[], overrides: {\n   ]);\n   const fullConfig = {...ALL_ENABLED_CONFIG, ...config};\n \n+  // Map out the scope of each target component, which is needed for the ComponentScopeReader.\n+  const scopeMap = new Map<ClassDeclaration, ScopeData>();\n+  for (const target of targets) {\n+    const sf = getSourceFileOrError(program, target.fileName);\n+    const scope = makeScope(program, sf, target.declarations ?? []);\n+\n+    for (const className of Object.keys(target.templates)) {\n+      const classDecl = getClass(sf, className);\n+      scopeMap.set(classDecl, scope);\n+    }\n+  }\n+\n   const checkAdapter = createTypeCheckAdapter((sf, ctx) => {\n     for (const target of targets) {\n       if (getSourceFileOrError(program, target.fileName) !== sf) {\n@@ -405,27 +417,47 @@ export function setup(targets: TypeCheckingTarget[], overrides: {\n     (programStrategy as any).supportsInlineOperations = overrides.inlining;\n   }\n \n-  const fakeScopeReader = {\n+  const fakeScopeReader: ComponentScopeReader = {\n     getRequiresRemoteScope() {\n       return null;\n     },\n-    // If there is a module with [className] + 'Module' in the same source file, returns\n-    // `LocalModuleScope` with the ngModule class and empty arrays for everything else.\n-    getScopeForComponent(clazz: ClassDeclaration) {\n-      try {\n-        const ngModule = getClass(clazz.getSourceFile(), `${clazz.name.getText()}Module`);\n-        const stubScopeData = {directives: [], ngModules: [], pipes: []};\n-        return {\n-          ngModule,\n-          compilation: stubScopeData,\n-          reexports: [],\n-          schemas: [],\n-          exported: stubScopeData\n-        };\n-      } catch (e) {\n-        return null;\n-      }\n-    }\n+    // If there is a module with [className] + 'Module' in the same source file, that will be\n+    // returned as the NgModule for the class.\n+    getScopeForComponent(clazz: ClassDeclaration): LocalModuleScope |\n+        null {\n+          try {\n+            const ngModule = getClass(clazz.getSourceFile(), `${clazz.name.getText()}Module`);\n+\n+            if (!scopeMap.has(clazz)) {\n+              // This class wasn't part of the target set of components with templates, but is\n+              // probably a declaration used in one of them. Return an empty scope.\n+              const emptyScope: ScopeData = {\n+                directives: [],\n+                ngModules: [],\n+                pipes: [],\n+              };\n+              return {\n+                ngModule,\n+                compilation: emptyScope,\n+                reexports: [],\n+                schemas: [],\n+                exported: emptyScope,\n+              };\n+            }\n+            const scope = scopeMap.get(clazz)!;\n+\n+            return {\n+              ngModule,\n+              compilation: scope,\n+              reexports: [],\n+              schemas: [],\n+              exported: scope,\n+            };\n+          } catch (e) {\n+            // No NgModule was found for this class, so it has no scope.\n+            return null;\n+          }\n+        }\n   };\n \n   const templateTypeChecker = new TemplateTypeCheckerImpl(\n@@ -492,6 +524,55 @@ export function getClass(sf: ts.SourceFile, name: string): ClassDeclaration<ts.C\n   throw new Error(`Class ${name} not found in file: ${sf.fileName}: ${sf.text}`);\n }\n \n+/**\n+ * Synthesize `ScopeData` metadata from an array of `TestDeclaration`s.\n+ */\n+function makeScope(program: ts.Program, sf: ts.SourceFile, decls: TestDeclaration[]): ScopeData {\n+  const scope: ScopeData = {\n+    ngModules: [],\n+    directives: [],\n+    pipes: [],\n+  };\n+\n+  for (const decl of decls) {\n+    let declSf = sf;\n+    if (decl.file !== undefined) {\n+      declSf = getSourceFileOrError(program, decl.file);\n+    }\n+    const declClass = getClass(declSf, decl.name);\n+\n+    if (decl.type === 'directive') {\n+      scope.directives.push({\n+        ref: new Reference(declClass),\n+        baseClass: null,\n+        name: decl.name,\n+        selector: decl.selector,\n+        queries: [],\n+        inputs: decl.inputs !== undefined ? ClassPropertyMapping.fromMappedObject(decl.inputs) :\n+                                            ClassPropertyMapping.empty(),\n+        outputs: decl.outputs !== undefined ? ClassPropertyMapping.fromMappedObject(decl.outputs) :\n+                                              ClassPropertyMapping.empty(),\n+        isComponent: decl.isComponent ?? false,\n+        exportAs: decl.exportAs ?? null,\n+        ngTemplateGuards: decl.ngTemplateGuards ?? [],\n+        hasNgTemplateContextGuard: decl.hasNgTemplateContextGuard ?? false,\n+        coercedInputFields: new Set(decl.coercedInputFields ?? []),\n+        restrictedInputFields: new Set(decl.restrictedInputFields ?? []),\n+        stringLiteralInputFields: new Set(decl.stringLiteralInputFields ?? []),\n+        undeclaredInputFields: new Set(decl.undeclaredInputFields ?? []),\n+        isGeneric: decl.isGeneric ?? false,\n+      });\n+    } else if (decl.type === 'pipe') {\n+      scope.pipes.push({\n+        ref: new Reference(declClass),\n+        name: decl.pipeName,\n+      });\n+    }\n+  }\n+\n+  return scope;\n+}\n+\n class FakeEnvironment /* implements Environment */ {\n   constructor(readonly config: TypeCheckingConfig) {}\n "
        },
        {
            "sha": "ba1036320ce96ada28305ed3bcf1c7b76421de1e",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__completion_spec.ts",
            "status": "modified",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/angular/angular/blob/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__completion_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__completion_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__completion_spec.ts?ref=0ecdef9cfa54a7bfb0c9daf92c99f3cadca25735",
            "patch": "@@ -98,6 +98,45 @@ runInEachFileSystem(() => {\n       expect(Array.from(afterReset.templateContext.keys())).toEqual(['foo']);\n     });\n   });\n+\n+  describe('TemplateTypeChecker scopes', () => {\n+    it('should get directives and pipes in scope for a component', () => {\n+      const MAIN_TS = absoluteFrom('/main.ts');\n+      const {program, templateTypeChecker} = setup([{\n+        fileName: MAIN_TS,\n+        templates: {\n+          'SomeCmp': 'Not important',\n+        },\n+        declarations: [\n+          {\n+            type: 'directive',\n+            file: MAIN_TS,\n+            name: 'OtherDir',\n+            selector: 'other-dir',\n+          },\n+          {\n+            type: 'pipe',\n+            file: MAIN_TS,\n+            name: 'OtherPipe',\n+            pipeName: 'otherPipe',\n+          }\n+        ],\n+        source: `\n+            export class SomeCmp {}\n+            export class OtherDir {}\n+            export class OtherPipe {}\n+            export class SomeCmpModule {}\n+          `\n+      }]);\n+      const sf = getSourceFileOrError(program, MAIN_TS);\n+      const SomeCmp = getClass(sf, 'SomeCmp');\n+\n+      const directives = templateTypeChecker.getDirectivesInScope(SomeCmp) ?? [];\n+      const pipes = templateTypeChecker.getPipesInScope(SomeCmp) ?? [];\n+      expect(directives.map(dir => dir.selector)).toEqual(['other-dir']);\n+      expect(pipes.map(pipe => pipe.name)).toEqual(['otherPipe']);\n+    });\n+  });\n });\n \n function setupCompletions("
        }
    ],
    "stats": {
        "total": 323,
        "additions": 289,
        "deletions": 34
    }
}