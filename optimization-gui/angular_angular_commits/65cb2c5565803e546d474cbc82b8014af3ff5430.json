{
    "author": "unknown",
    "message": "fix(core): support `InjectFlags` argument in `NodeInjector.get()` (#41592)\n\nThe `InjectFlags` argument was defined for both `getOrCreateInjectable()` and `Injector`, but was ignored in `NodeInjector`.\nThis PR adds support for getting parent token via `NodeInjector.get()`.\n\nclose #31776\n\nPR Close #41592",
    "sha": "65cb2c5565803e546d474cbc82b8014af3ff5430",
    "files": [
        {
            "sha": "87cea749c2d011c63cc2cfcdfcad3ab01b13aa99",
            "filename": "packages/core/src/render3/di.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/65cb2c5565803e546d474cbc82b8014af3ff5430/packages%2Fcore%2Fsrc%2Frender3%2Fdi.ts",
            "raw_url": "https://github.com/angular/angular/raw/65cb2c5565803e546d474cbc82b8014af3ff5430/packages%2Fcore%2Fsrc%2Frender3%2Fdi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fdi.ts?ref=65cb2c5565803e546d474cbc82b8014af3ff5430",
            "patch": "@@ -688,8 +688,8 @@ export class NodeInjector implements Injector {\n       private _tNode: TElementNode|TContainerNode|TElementContainerNode|null,\n       private _lView: LView) {}\n \n-  get(token: any, notFoundValue?: any): any {\n-    return getOrCreateInjectable(this._tNode, this._lView, token, undefined, notFoundValue);\n+  get(token: any, notFoundValue?: any, flags?: InjectFlags): any {\n+    return getOrCreateInjectable(this._tNode, this._lView, token, flags, notFoundValue);\n   }\n }\n "
        },
        {
            "sha": "77d4dcb9c1fb1cd7283a8f8969e2e32b15a03862",
            "filename": "packages/core/test/acceptance/di_spec.ts",
            "status": "modified",
            "additions": 121,
            "deletions": 1,
            "changes": 122,
            "blob_url": "https://github.com/angular/angular/blob/65cb2c5565803e546d474cbc82b8014af3ff5430/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/65cb2c5565803e546d474cbc82b8014af3ff5430/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts?ref=65cb2c5565803e546d474cbc82b8014af3ff5430",
            "patch": "@@ -7,7 +7,7 @@\n  */\n \n import {CommonModule} from '@angular/common';\n-import {Attribute, ChangeDetectorRef, Component, ComponentFactoryResolver, ComponentRef, Directive, ElementRef, EventEmitter, forwardRef, Host, HostBinding, Inject, Injectable, InjectionToken, INJECTOR, Injector, Input, LOCALE_ID, NgModule, NgZone, Optional, Output, Pipe, PipeTransform, Self, SkipSelf, TemplateRef, ViewChild, ViewContainerRef, ViewRef, ɵDEFAULT_LOCALE_ID as DEFAULT_LOCALE_ID} from '@angular/core';\n+import {Attribute, ChangeDetectorRef, Component, ComponentFactoryResolver, ComponentRef, Directive, ElementRef, EventEmitter, forwardRef, Host, HostBinding, Inject, Injectable, InjectFlags, InjectionToken, INJECTOR, Injector, Input, LOCALE_ID, NgModule, NgZone, Optional, Output, Pipe, PipeTransform, Self, SkipSelf, TemplateRef, ViewChild, ViewContainerRef, ViewRef, ɵDEFAULT_LOCALE_ID as DEFAULT_LOCALE_ID} from '@angular/core';\n import {ɵINJECTOR_SCOPE} from '@angular/core/src/core';\n import {ViewRef as ViewRefInternal} from '@angular/core/src/render3/view_ref';\n import {TestBed} from '@angular/core/testing';\n@@ -2006,6 +2006,126 @@ describe('di', () => {\n              });\n         });\n       });\n+\n+      onlyInIvy('Ivy supports `InjectFlags` in NodeInjector')\n+          .describe('`InjectFlags` support in NodeInjector', () => {\n+            it('should support Optional flag in NodeInjector', () => {\n+              const NON_EXISTING_PROVIDER = new InjectionToken<string>('non-existing');\n+              @Component({template: '...'})\n+              class MyComp {\n+                tokenViaInjector =\n+                    this.injector.get(NON_EXISTING_PROVIDER, null, InjectFlags.Optional);\n+                constructor(\n+                    public injector: Injector,\n+                    @Inject(NON_EXISTING_PROVIDER) @Optional() public tokenViaConstructor: string) {\n+                }\n+              }\n+              TestBed.configureTestingModule({declarations: [MyComp]});\n+              const fixture = TestBed.createComponent(MyComp);\n+              fixture.detectChanges();\n+              expect(fixture.componentInstance.tokenViaInjector).toBe(null);\n+              expect(fixture.componentInstance.tokenViaInjector)\n+                  .toBe(fixture.componentInstance.tokenViaConstructor);\n+            });\n+            it('should support SkipSelf flag in NodeInjector', () => {\n+              const TOKEN = new InjectionToken<string>('token');\n+              @Component({\n+                selector: 'parent',\n+                template: '<child></child>',\n+                providers: [{\n+                  provide: TOKEN,\n+                  useValue: 'PARENT',\n+                }]\n+              })\n+              class ParentComponent {\n+              }\n+\n+              @Component({\n+                selector: 'child',\n+                template: '...',\n+                providers: [{\n+                  provide: TOKEN,\n+                  useValue: 'CHILD',\n+                }]\n+              })\n+              class ChildComponent {\n+                tokenViaInjector = this.injector.get(TOKEN, null, InjectFlags.SkipSelf);\n+                constructor(\n+                    public injector: Injector,\n+                    @Inject(TOKEN) @SkipSelf() public tokenViaConstructor: string) {}\n+              }\n+\n+              TestBed.configureTestingModule({\n+                declarations: [ParentComponent, ChildComponent],\n+              });\n+              const fixture = TestBed.createComponent(ParentComponent);\n+              fixture.detectChanges();\n+\n+              const childComponent =\n+                  fixture.debugElement.query(By.directive(ChildComponent)).componentInstance;\n+              expect(childComponent.tokenViaInjector).toBe('PARENT');\n+              expect(childComponent.tokenViaConstructor).toBe(childComponent.tokenViaInjector);\n+            });\n+            it('should support Host flag in NodeInjector', () => {\n+              const TOKEN = new InjectionToken<string>('token');\n+              @Directive({selector: '[dirString]'})\n+              class DirectiveString {\n+                tokenViaInjector = this.injector.get(TOKEN, null, InjectFlags.Host);\n+                constructor(\n+                    public injector: Injector,\n+                    @Inject(TOKEN) @Host() public tokenViaConstructor: string) {}\n+              }\n+\n+              @Component({\n+                template: '<div dirString></div>',\n+                viewProviders: [{provide: TOKEN, useValue: 'Foo'}]\n+              })\n+              class MyComp {\n+                @ViewChild(DirectiveString) dirString!: DirectiveString;\n+              }\n+\n+              TestBed.configureTestingModule({declarations: [DirectiveString, MyComp]});\n+              const fixture = TestBed.createComponent(MyComp);\n+              fixture.detectChanges();\n+\n+              const dirString = fixture.componentInstance.dirString;\n+              expect(dirString.tokenViaConstructor).toBe('Foo');\n+              expect(dirString.tokenViaConstructor).toBe(dirString.tokenViaInjector!);\n+            });\n+            it('should support multiple flags in NodeInjector', () => {\n+              @Directive({selector: '[dirA]'})\n+              class DirectiveA {\n+              }\n+              @Directive({selector: '[dirB]'})\n+              class DirectiveB {\n+                public tokenSelfViaInjector =\n+                    this.injector.get(DirectiveA, null, InjectFlags.Self|InjectFlags.Optional);\n+                public tokenHostViaInjector =\n+                    this.injector.get(DirectiveA, null, InjectFlags.Host|InjectFlags.Optional);\n+                constructor(\n+                    public injector: Injector,\n+                    @Inject(DirectiveA) @Self() @Optional() public tokenSelfViaConstructor:\n+                        DirectiveA,\n+                    @Inject(DirectiveA) @Host() @Optional() public tokenHostViaConstructor:\n+                        DirectiveA) {}\n+              }\n+\n+              @Component({template: '<div dirB></div>'})\n+              class MyComp {\n+                @ViewChild(DirectiveB) dirB!: DirectiveB;\n+              }\n+\n+              TestBed.configureTestingModule({declarations: [DirectiveB, MyComp]});\n+              const fixture = TestBed.createComponent(MyComp);\n+              fixture.detectChanges();\n+\n+              const dirB = fixture.componentInstance.dirB;\n+              expect(dirB.tokenSelfViaInjector).toBeNull();\n+              expect(dirB.tokenSelfViaInjector).toBe(dirB.tokenSelfViaConstructor);\n+              expect(dirB.tokenHostViaInjector).toBeNull();\n+              expect(dirB.tokenHostViaInjector).toBe(dirB.tokenHostViaConstructor);\n+            });\n+          });\n     });\n   });\n "
        }
    ],
    "stats": {
        "total": 126,
        "additions": 123,
        "deletions": 3
    }
}