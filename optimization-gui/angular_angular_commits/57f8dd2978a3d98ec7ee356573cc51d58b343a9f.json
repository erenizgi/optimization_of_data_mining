{
    "author": "ayazhafiz",
    "message": "test(compiler): add tests for parsing of malformed property reads (#38998)\n\nThe expression parser already has support for recovering on malformed\nproperty reads, but did not have tests describing the recovered ast in\nsuch cases. This commit adds tests to demonstrate such cases; in\nparticular, the recovered ast is a full PropertyRead but with an empty\nproperty name. This is likely the most preferred option, as it does not\nconstrain consumers of the AST to what the property name should look\nlike. Furthermore, we cannot mark the property name as empty in any\nother way (e.g. an EmptyExpr) because the property name, as of present,\nis a string field rather than an AST itself.\n\nNote that tokens past a malformed property read are not preserved in the\nAST (for example in `foo.1234`, `1234` is not preserved in the AST).\nThis is because the extra tokens do not belong to the singular\nexpression created by the property read, and there is not a meaningful\nway to interpret a secondary expression in a single parsed expression.\n\nPart of #38596\n\nPR Close #38998",
    "sha": "57f8dd2978a3d98ec7ee356573cc51d58b343a9f",
    "files": [
        {
            "sha": "91a7de46218f1aa315d50451d7e385fe2ecd6d33",
            "filename": "packages/compiler/test/expression_parser/parser_spec.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/57f8dd2978a3d98ec7ee356573cc51d58b343a9f/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/57f8dd2978a3d98ec7ee356573cc51d58b343a9f/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts?ref=57f8dd2978a3d98ec7ee356573cc51d58b343a9f",
            "patch": "@@ -128,15 +128,22 @@ describe('parser', () => {\n       });\n \n       it('should only allow identifier or keyword as member names', () => {\n-        expectActionError('x.(', 'identifier or keyword');\n-        expectActionError('x. 1234', 'identifier or keyword');\n-        expectActionError('x.\"foo\"', 'identifier or keyword');\n+        checkActionWithError('x.', 'x.', 'identifier or keyword');\n+        checkActionWithError('x.(', 'x.', 'identifier or keyword');\n+        checkActionWithError('x. 1234', 'x.', 'identifier or keyword');\n+        checkActionWithError('x.\"foo\"', 'x.', 'identifier or keyword');\n       });\n \n       it('should parse safe field access', () => {\n         checkAction('a?.a');\n         checkAction('a.a?.a');\n       });\n+\n+      it('should parse incomplete safe field accesses', () => {\n+        checkActionWithError('a?.a.', 'a?.a.', 'identifier or keyword');\n+        checkActionWithError('a.a?.a.', 'a.a?.a.', 'identifier or keyword');\n+        checkActionWithError('a.a?.a?. 1234', 'a.a?.a?.', 'identifier or keyword');\n+      });\n     });\n \n     describe('method calls', () => {\n@@ -1013,8 +1020,7 @@ function expectBindingError(text: string, message: string) {\n }\n \n /**\n- * Check that an malformed action parses to a recovered AST while emitting an\n- * error.\n+ * Check that a malformed action parses to a recovered AST while emitting an error.\n  */\n function checkActionWithError(text: string, expected: string, error: string) {\n   checkAction(text, expected);"
        }
    ],
    "stats": {
        "total": 16,
        "additions": 11,
        "deletions": 5
    }
}