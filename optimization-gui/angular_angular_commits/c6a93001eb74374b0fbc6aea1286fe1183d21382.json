{
    "author": "aahmedayed",
    "message": "fix(common): synchronise location mock behavior with the navigators (#41730)\n\n* Do not emit url pop on Location.go\n* Emit a `popstate` event before each `hashchange` to have the same\nbehavior of the browser.\n* Track the url change in the internal history when calling `simulateHashChange`\n\nThe changes to the router tests reflect the goals of the test.\nGenerally when `Location.go` is used to trigger navigations, it is only\nrelevant for `HashLocationStrategy` and verifying that the Router picks\nup changes from manual URL changes. To do this, we convert those calls\nto `simulateHashChange` instead.\nManual URL bar changes to the path when not using the `HashLocationStrategy`\nwould otherwise trigger a full page refresh so they aren't relevant to\nthese test scenarios which assert correct behavior during the lifetime\nof the router.\n\n[Reference for no `popstate` on `pushState`/`replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event)\n> Note that just calling history.pushState() or history.replaceState() won't\ntrigger a popstate event. The popstate event will be triggered by doing a browser\naction such as a click on the back or forward button (or calling history.back()\nor history.forward() in JavaScript).\n\n[Reference for `popstate` before `hashChange`](https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event#when_popstate_is_sent)\n\n>  When the transition occurs, either due to the user triggering the browser's\n> \"Back\" button or otherwise, the popstate event is near the end of the process to transition to the new location\n...\n> 12. If the value of state changed, the popstate event is sent to the document.\n> 13. Any persisted user state is restored, if the browser chooses to do so.\n> 14. If the original and new entry's shared the same document, but had different fragments in their URLs, send the hashchange event to the window.\n\nBREAKING CHANGE:\n\nThe behavior of the `SpyLocation` used by the `RouterTestingModule` has changed\nto match the behavior of browsers. It no longer emits a 'popstate' event\nwhen `Location.go` is called. In addition, `simulateHashChange` now\ntriggers _both_ a `hashchange` and a `popstate` event.\nTests which use `location.go` and expect the changes to be picked up by\nthe `Router` should likely change to `simulateHashChange` instead.\nEach test is different in what it attempts to assert so there is no\nsingle change that works for all tests. Each test using the `SpyLocation` to\nsimulate browser URL changes should be evaluated on a case-by-case basis.\n\nfixes #27059\n\nPR Close #41730",
    "sha": "c6a93001eb74374b0fbc6aea1286fe1183d21382",
    "files": [
        {
            "sha": "0c6a8e6f8f8e961de791c5f78d9bf73ef7f0c9fd",
            "filename": "packages/common/testing/src/location_mock.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 10,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/c6a93001eb74374b0fbc6aea1286fe1183d21382/packages%2Fcommon%2Ftesting%2Fsrc%2Flocation_mock.ts",
            "raw_url": "https://github.com/angular/angular/raw/c6a93001eb74374b0fbc6aea1286fe1183d21382/packages%2Fcommon%2Ftesting%2Fsrc%2Flocation_mock.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftesting%2Fsrc%2Flocation_mock.ts?ref=c6a93001eb74374b0fbc6aea1286fe1183d21382",
            "patch": "@@ -10,6 +10,8 @@ import {Location, LocationStrategy, PlatformLocation} from '@angular/common';\n import {EventEmitter, Injectable} from '@angular/core';\n import {SubscriptionLike} from 'rxjs';\n \n+import {normalizeQueryParams} from '../../src/location/util';\n+\n /**\n  * A spy for {@link Location} that allows tests to fire simulated location events.\n  *\n@@ -62,9 +64,13 @@ export class SpyLocation implements Location {\n   }\n \n   simulateHashChange(pathname: string) {\n-    // Because we don't prevent the native event, the browser will independently update the path\n-    this.setInitialPath(pathname);\n+    const path = this.prepareExternalUrl(pathname);\n+    this.pushHistory(path, '', null);\n+\n     this.urlChanges.push('hash: ' + pathname);\n+    // the browser will automatically fire popstate event before each `hashchange` event, so we need\n+    // to simulate it.\n+    this._subject.emit({'url': pathname, 'pop': true, 'type': 'popstate'});\n     this._subject.emit({'url': pathname, 'pop': true, 'type': 'hashchange'});\n   }\n \n@@ -78,11 +84,7 @@ export class SpyLocation implements Location {\n   go(path: string, query: string = '', state: any = null) {\n     path = this.prepareExternalUrl(path);\n \n-    if (this._historyIndex > 0) {\n-      this._history.splice(this._historyIndex + 1);\n-    }\n-    this._history.push(new LocationState(path, query, state));\n-    this._historyIndex = this._history.length - 1;\n+    this.pushHistory(path, query, state);\n \n     const locationState = this._history[this._historyIndex - 1];\n     if (locationState.path == path && locationState.query == query) {\n@@ -91,7 +93,7 @@ export class SpyLocation implements Location {\n \n     const url = path + (query.length > 0 ? ('?' + query) : '');\n     this.urlChanges.push(url);\n-    this._subject.emit({'url': url, 'pop': false});\n+    this._notifyUrlChangeListeners(path + normalizeQueryParams(query), state);\n   }\n \n   replaceState(path: string, query: string = '', state: any = null) {\n@@ -108,19 +110,22 @@ export class SpyLocation implements Location {\n \n     const url = path + (query.length > 0 ? ('?' + query) : '');\n     this.urlChanges.push('replace: ' + url);\n+    this._notifyUrlChangeListeners(path + normalizeQueryParams(query), state);\n   }\n \n   forward() {\n     if (this._historyIndex < (this._history.length - 1)) {\n       this._historyIndex++;\n-      this._subject.emit({'url': this.path(), 'state': this.getState(), 'pop': true});\n+      this._subject.emit(\n+          {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n     }\n   }\n \n   back() {\n     if (this._historyIndex > 0) {\n       this._historyIndex--;\n-      this._subject.emit({'url': this.path(), 'state': this.getState(), 'pop': true});\n+      this._subject.emit(\n+          {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n     }\n   }\n \n@@ -157,6 +162,14 @@ export class SpyLocation implements Location {\n   normalize(url: string): string {\n     return null!;\n   }\n+\n+  private pushHistory(path: string, query: string, state: any) {\n+    if (this._historyIndex > 0) {\n+      this._history.splice(this._historyIndex + 1);\n+    }\n+    this._history.push(new LocationState(path, query, state));\n+    this._historyIndex = this._history.length - 1;\n+  }\n }\n \n class LocationState {"
        },
        {
            "sha": "0540288ba6f933b066dfe6f0c31942868414bec2",
            "filename": "packages/router/test/computed_state_restoration.spec.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 154,
            "changes": 158,
            "blob_url": "https://github.com/angular/angular/blob/c6a93001eb74374b0fbc6aea1286fe1183d21382/packages%2Frouter%2Ftest%2Fcomputed_state_restoration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c6a93001eb74374b0fbc6aea1286fe1183d21382/packages%2Frouter%2Ftest%2Fcomputed_state_restoration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fcomputed_state_restoration.spec.ts?ref=c6a93001eb74374b0fbc6aea1286fe1183d21382",
            "patch": "@@ -6,168 +6,18 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {CommonModule, Location, LocationStrategy, PlatformLocation} from '@angular/common';\n+import {CommonModule, Location} from '@angular/common';\n import {SpyLocation} from '@angular/common/testing';\n-import {Component, EventEmitter, Injectable, NgModule} from '@angular/core';\n+import {Component, Injectable, NgModule} from '@angular/core';\n import {ComponentFixture, fakeAsync, TestBed, tick} from '@angular/core/testing';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n import {CanActivate, CanDeactivate, Resolve, Router, RouterModule, UrlTree} from '@angular/router';\n-import {EMPTY, Observable, of, SubscriptionLike} from 'rxjs';\n+import {EMPTY, Observable, of} from 'rxjs';\n \n import {isUrlTree} from '../src/utils/type_guards';\n import {RouterTestingModule} from '../testing';\n \n describe('`restoredState#ɵrouterPageId`', () => {\n-  // TODO: Remove RouterSpyLocation after #38884 is submitted.\n-  class RouterSpyLocation implements Location {\n-    urlChanges: string[] = [];\n-    private _history: LocationState[] = [new LocationState('', '', null)];\n-    private _historyIndex: number = 0;\n-    /** @internal */\n-    _subject: EventEmitter<any> = new EventEmitter();\n-    /** @internal */\n-    _baseHref: string = '';\n-    /** @internal */\n-    _platformStrategy: LocationStrategy = null!;\n-    /** @internal */\n-    _platformLocation: PlatformLocation = null!;\n-    /** @internal */\n-    _urlChangeListeners: ((url: string, state: unknown) => void)[] = [];\n-    /** @internal */\n-    _urlChangeSubscription?: SubscriptionLike;\n-\n-    setInitialPath(url: string) {\n-      this._history[this._historyIndex].path = url;\n-    }\n-\n-    setBaseHref(url: string) {\n-      this._baseHref = url;\n-    }\n-\n-    path(): string {\n-      return this._history[this._historyIndex].path;\n-    }\n-\n-    getState(): unknown {\n-      return this._history[this._historyIndex].state;\n-    }\n-\n-    isCurrentPathEqualTo(path: string, query: string = ''): boolean {\n-      const givenPath = path.endsWith('/') ? path.substring(0, path.length - 1) : path;\n-      const currPath = this.path().endsWith('/') ?\n-          this.path().substring(0, this.path().length - 1) :\n-          this.path();\n-\n-      return currPath == givenPath + (query.length > 0 ? ('?' + query) : '');\n-    }\n-\n-    simulateUrlPop(pathname: string) {\n-      this._subject.emit({'url': pathname, 'pop': true, 'type': 'popstate'});\n-    }\n-\n-    simulateHashChange(pathname: string) {\n-      // Because we don't prevent the native event, the browser will independently update the path\n-      this.setInitialPath(pathname);\n-      this.urlChanges.push('hash: ' + pathname);\n-      this._subject.emit({'url': pathname, 'pop': true, 'type': 'hashchange'});\n-    }\n-\n-    prepareExternalUrl(url: string): string {\n-      if (url.length > 0 && !url.startsWith('/')) {\n-        url = '/' + url;\n-      }\n-      return this._baseHref + url;\n-    }\n-\n-    go(path: string, query: string = '', state: any = null) {\n-      path = this.prepareExternalUrl(path);\n-\n-      if (this._historyIndex > 0) {\n-        this._history.splice(this._historyIndex + 1);\n-      }\n-      this._history.push(new LocationState(path, query, state));\n-      this._historyIndex = this._history.length - 1;\n-\n-      const locationState = this._history[this._historyIndex - 1];\n-      if (locationState.path == path && locationState.query == query) {\n-        return;\n-      }\n-\n-      const url = path + (query.length > 0 ? ('?' + query) : '');\n-      this.urlChanges.push(url);\n-    }\n-\n-    replaceState(path: string, query: string = '', state: any = null) {\n-      path = this.prepareExternalUrl(path);\n-\n-      const history = this._history[this._historyIndex];\n-      if (history.path == path && history.query == query) {\n-        return;\n-      }\n-\n-      history.path = path;\n-      history.query = query;\n-      history.state = state;\n-\n-      const url = path + (query.length > 0 ? ('?' + query) : '');\n-      this.urlChanges.push('replace: ' + url);\n-    }\n-\n-    forward() {\n-      if (this._historyIndex < (this._history.length - 1)) {\n-        this._historyIndex++;\n-        this._subject.emit(\n-            {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n-      }\n-    }\n-\n-    back() {\n-      if (this._historyIndex > 0) {\n-        this._historyIndex--;\n-        this._subject.emit(\n-            {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n-      }\n-    }\n-\n-    historyGo(relativePosition: number = 0): void {\n-      const nextPageIndex = this._historyIndex + relativePosition;\n-      if (nextPageIndex >= 0 && nextPageIndex < this._history.length) {\n-        this._historyIndex = nextPageIndex;\n-        this._subject.emit(\n-            {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n-      }\n-    }\n-\n-    onUrlChange(fn: (url: string, state: unknown) => void) {\n-      this._urlChangeListeners.push(fn);\n-\n-      if (!this._urlChangeSubscription) {\n-        this._urlChangeSubscription = this.subscribe(v => {\n-          this._notifyUrlChangeListeners(v.url, v.state);\n-        });\n-      }\n-    }\n-\n-    /** @internal */\n-    _notifyUrlChangeListeners(url: string = '', state: unknown) {\n-      this._urlChangeListeners.forEach(fn => fn(url, state));\n-    }\n-\n-    subscribe(\n-        onNext: (value: any) => void, onThrow?: ((error: any) => void)|null,\n-        onReturn?: (() => void)|null): SubscriptionLike {\n-      return this._subject.subscribe({next: onNext, error: onThrow, complete: onReturn});\n-    }\n-\n-    normalize(url: string): string {\n-      return null!;\n-    }\n-  }\n-\n-  class LocationState {\n-    constructor(public path: string, public query: string, public state: any) {}\n-  }\n-\n   @Injectable({providedIn: 'root'})\n   class MyCanDeactivateGuard implements CanDeactivate<any> {\n     allow: boolean = true;\n@@ -227,7 +77,7 @@ describe('`restoredState#ɵrouterPageId`', () => {\n       imports: [TestModule],\n       providers: [\n         {provide: 'alwaysFalse', useValue: (a: any) => false},\n-        {provide: Location, useClass: RouterSpyLocation}\n+        {provide: Location, useClass: SpyLocation}\n       ]\n     });\n     const router = TestBed.inject(Router);"
        },
        {
            "sha": "19c82f0a86d5c2cfc9029aa7e79c9dfbd8e2c167",
            "filename": "packages/router/test/integration.spec.ts",
            "status": "modified",
            "additions": 34,
            "deletions": 25,
            "changes": 59,
            "blob_url": "https://github.com/angular/angular/blob/c6a93001eb74374b0fbc6aea1286fe1183d21382/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c6a93001eb74374b0fbc6aea1286fe1183d21382/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fintegration.spec.ts?ref=c6a93001eb74374b0fbc6aea1286fe1183d21382",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {APP_BASE_HREF, CommonModule, Location, LOCATION_INITIALIZED, LocationStrategy, PlatformLocation} from '@angular/common';\n+import {APP_BASE_HREF, CommonModule, HashLocationStrategy, Location, LOCATION_INITIALIZED, LocationStrategy, PlatformLocation} from '@angular/common';\n import {SpyLocation} from '@angular/common/testing';\n import {ChangeDetectionStrategy, Component, EventEmitter, Injectable, NgModule, NgModuleFactoryLoader, NgModuleRef, NgZone, OnDestroy, ViewChild, ɵConsole as Console, ɵNoopNgZone as NoopNgZone} from '@angular/core';\n import {ComponentFixture, fakeAsync, inject, TestBed, tick} from '@angular/core/testing';\n@@ -1061,13 +1061,13 @@ describe('Integration', () => {\n        location.back();\n        advance(fixture);\n        expect(location.path()).toEqual('/team/33/simple');\n-       expect(event!.navigationTrigger).toEqual('hashchange');\n+       expect(event!.navigationTrigger).toEqual('popstate');\n        expect(event!.restoredState!.navigationId).toEqual(simpleNavStart.id);\n \n        location.forward();\n        advance(fixture);\n        expect(location.path()).toEqual('/team/22/user/victor');\n-       expect(event!.navigationTrigger).toEqual('hashchange');\n+       expect(event!.navigationTrigger).toEqual('popstate');\n        expect(event!.restoredState!.navigationId).toEqual(userVictorNavStart.id);\n      })));\n \n@@ -1226,7 +1226,6 @@ describe('Integration', () => {\n          const recordedEvents = [] as Event[];\n          router.events.forEach(e => onlyNavigationStartAndEnd(e) && recordedEvents.push(e));\n \n-         location.simulateUrlPop('/blocked');\n          location.simulateHashChange('/blocked');\n \n          advance(fixture);\n@@ -2634,8 +2633,11 @@ describe('Integration', () => {\n          expect(router.serializeUrl(afterRedirectUrl as any)).toBe('/team/22');\n        })));\n \n-    it('should not break the back button when trigger by location change',\n-       fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+    it('should not break the back button when trigger by location change', fakeAsync(() => {\n+         TestBed.configureTestingModule(\n+             {providers: [{provide: LocationStrategy, useClass: HashLocationStrategy}]});\n+         const router = TestBed.inject(Router);\n+         const location = TestBed.inject(Location) as SpyLocation;\n          const fixture = TestBed.createComponent(RootCmp);\n          advance(fixture);\n          router.resetConfig([\n@@ -2656,16 +2658,15 @@ describe('Integration', () => {\n          expect(location.path()).toEqual('/initial');\n \n          // location change\n-         (<any>location).go('/old/team/33');\n-\n+         location.simulateHashChange('/old/team/33');\n \n          advance(fixture);\n          expect(location.path()).toEqual('/team/33');\n \n          location.back();\n          advance(fixture);\n          expect(location.path()).toEqual('/initial');\n-       })));\n+       }));\n   });\n   describe('guards', () => {\n     describe('CanActivate', () => {\n@@ -2835,16 +2836,20 @@ describe('Integration', () => {\n       describe('should reset the location when cancelling a navigation', () => {\n         beforeEach(() => {\n           TestBed.configureTestingModule({\n-            providers: [{\n-              provide: 'alwaysFalse',\n-              useValue: (a: ActivatedRouteSnapshot, b: RouterStateSnapshot) => {\n-                return false;\n-              }\n-            }]\n+            providers: [\n+              {\n+                provide: 'alwaysFalse',\n+                useValue: (a: ActivatedRouteSnapshot, b: RouterStateSnapshot) => {\n+                  return false;\n+                }\n+              },\n+              {provide: LocationStrategy, useClass: HashLocationStrategy}\n+            ]\n           });\n         });\n \n-        it('works', fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+        it('works',\n+           fakeAsync(inject([Router, Location], (router: Router, location: SpyLocation) => {\n              const fixture = createRoot(router, RootCmp);\n \n              router.resetConfig([\n@@ -2856,7 +2861,7 @@ describe('Integration', () => {\n              advance(fixture);\n              expect(location.path()).toEqual('/one');\n \n-             location.go('/two');\n+             location.simulateHashChange('/two');\n              advance(fixture);\n              expect(location.path()).toEqual('/one');\n            })));\n@@ -5431,12 +5436,16 @@ describe('Integration', () => {\n       }\n \n       beforeEach(() => {\n-        TestBed.configureTestingModule(\n-            {providers: [{provide: UrlHandlingStrategy, useClass: CustomUrlHandlingStrategy}]});\n+        TestBed.configureTestingModule({\n+          providers: [\n+            {provide: UrlHandlingStrategy, useClass: CustomUrlHandlingStrategy},\n+            {provide: LocationStrategy, useClass: HashLocationStrategy}\n+          ]\n+        });\n       });\n \n       it('should work',\n-         fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+         fakeAsync(inject([Router, Location], (router: Router, location: SpyLocation) => {\n            const fixture = createRoot(router, RootCmp);\n \n            router.resetConfig([{\n@@ -5477,14 +5486,14 @@ describe('Integration', () => {\n            events.splice(0);\n \n            // another unsupported URL\n-           location.go('/exclude/two');\n+           location.simulateHashChange('/exclude/two');\n            advance(fixture);\n \n            expect(location.path()).toEqual('/exclude/two');\n            expectEvents(events, []);\n \n            // back to a supported URL\n-           location.go('/include/simple');\n+           location.simulateHashChange('/include/simple');\n            advance(fixture);\n \n            expect(location.path()).toEqual('/include/simple');\n@@ -5499,7 +5508,7 @@ describe('Integration', () => {\n          })));\n \n       it('should handle the case when the router takes only the primary url',\n-         fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+         fakeAsync(inject([Router, Location], (router: Router, location: SpyLocation) => {\n            const fixture = createRoot(router, RootCmp);\n \n            router.resetConfig([{\n@@ -5512,7 +5521,7 @@ describe('Integration', () => {\n            const events: any[] = [];\n            router.events.subscribe(e => e instanceof RouterEvent && events.push(e));\n \n-           location.go('/include/user/kate(aux:excluded)');\n+           location.simulateHashChange('/include/user/kate(aux:excluded)');\n            advance(fixture);\n \n            expect(location.path()).toEqual('/include/user/kate(aux:excluded)');\n@@ -5524,7 +5533,7 @@ describe('Integration', () => {\n            ]);\n            events.splice(0);\n \n-           location.go('/include/user/kate(aux:excluded2)');\n+           location.simulateHashChange('/include/user/kate(aux:excluded2)');\n            advance(fixture);\n            expectEvents(events, []);\n "
        }
    ],
    "stats": {
        "total": 250,
        "additions": 61,
        "deletions": 189
    }
}