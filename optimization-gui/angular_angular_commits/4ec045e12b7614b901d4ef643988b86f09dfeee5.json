{
    "author": "MikeJerred",
    "message": "feat(forms): add `emitEvent` option for AbstractControl-based class methods (#31031)\n\nThis commit adds the `emitEvent` option to the following FormArray and FormGroup methods:\n\n* FormGroup.addControl\n* FormGroup.removeControl\n* FormGroup.setControl\n* FormArray.push\n* FormArray.insert\n* FormArray.removeAt\n* FormArray.setControl\n* FormArray.clear\n\nThis option can be used to prevent an event from being emitted when adding or removing controls.\n\nBREAKING CHANGE:\n\nThe `emitEvent` option was added to the following `FormArray` and `FormGroup` methods:\n\n* FormGroup.addControl\n* FormGroup.removeControl\n* FormGroup.setControl\n* FormArray.push\n* FormArray.insert\n* FormArray.removeAt\n* FormArray.setControl\n* FormArray.clear\n\nIf your app has custom classes that extend `FormArray` or `FormGroup` classes and override the \nabove-mentioned methods, you may need to update your implementation to take the new options into\naccount and make sure that overrides are compatible from a types perspective.\n\nCloses #29662.\nPR Close #31031",
    "sha": "4ec045e12b7614b901d4ef643988b86f09dfeee5",
    "files": [
        {
            "sha": "aed8763bb8d811ad8c0b61b57f03c39622770120",
            "filename": "goldens/public-api/forms/forms.d.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 8,
            "changes": 32,
            "blob_url": "https://github.com/angular/angular/blob/4ec045e12b7614b901d4ef643988b86f09dfeee5/goldens%2Fpublic-api%2Fforms%2Fforms.d.ts",
            "raw_url": "https://github.com/angular/angular/raw/4ec045e12b7614b901d4ef643988b86f09dfeee5/goldens%2Fpublic-api%2Fforms%2Fforms.d.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fpublic-api%2Fforms%2Fforms.d.ts?ref=4ec045e12b7614b901d4ef643988b86f09dfeee5",
            "patch": "@@ -172,20 +172,30 @@ export declare class FormArray extends AbstractControl {\n     get length(): number;\n     constructor(controls: AbstractControl[], validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null);\n     at(index: number): AbstractControl;\n-    clear(): void;\n+    clear(options?: {\n+        emitEvent?: boolean;\n+    }): void;\n     getRawValue(): any[];\n-    insert(index: number, control: AbstractControl): void;\n+    insert(index: number, control: AbstractControl, options?: {\n+        emitEvent?: boolean;\n+    }): void;\n     patchValue(value: any[], options?: {\n         onlySelf?: boolean;\n         emitEvent?: boolean;\n     }): void;\n-    push(control: AbstractControl): void;\n-    removeAt(index: number): void;\n+    push(control: AbstractControl, options?: {\n+        emitEvent?: boolean;\n+    }): void;\n+    removeAt(index: number, options?: {\n+        emitEvent?: boolean;\n+    }): void;\n     reset(value?: any, options?: {\n         onlySelf?: boolean;\n         emitEvent?: boolean;\n     }): void;\n-    setControl(index: number, control: AbstractControl): void;\n+    setControl(index: number, control: AbstractControl, options?: {\n+        emitEvent?: boolean;\n+    }): void;\n     setValue(value: any[], options?: {\n         onlySelf?: boolean;\n         emitEvent?: boolean;\n@@ -272,7 +282,9 @@ export declare class FormGroup extends AbstractControl {\n     constructor(controls: {\n         [key: string]: AbstractControl;\n     }, validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null);\n-    addControl(name: string, control: AbstractControl): void;\n+    addControl(name: string, control: AbstractControl, options?: {\n+        emitEvent?: boolean;\n+    }): void;\n     contains(controlName: string): boolean;\n     getRawValue(): any;\n     patchValue(value: {\n@@ -282,12 +294,16 @@ export declare class FormGroup extends AbstractControl {\n         emitEvent?: boolean;\n     }): void;\n     registerControl(name: string, control: AbstractControl): AbstractControl;\n-    removeControl(name: string): void;\n+    removeControl(name: string, options?: {\n+        emitEvent?: boolean;\n+    }): void;\n     reset(value?: any, options?: {\n         onlySelf?: boolean;\n         emitEvent?: boolean;\n     }): void;\n-    setControl(name: string, control: AbstractControl): void;\n+    setControl(name: string, control: AbstractControl, options?: {\n+        emitEvent?: boolean;\n+    }): void;\n     setValue(value: {\n         [key: string]: any;\n     }, options?: {"
        },
        {
            "sha": "f7b75fda46168739ab1e7895e61b52aac186b246",
            "filename": "packages/forms/src/model.ts",
            "status": "modified",
            "additions": 59,
            "deletions": 16,
            "changes": 75,
            "blob_url": "https://github.com/angular/angular/blob/4ec045e12b7614b901d4ef643988b86f09dfeee5/packages%2Fforms%2Fsrc%2Fmodel.ts",
            "raw_url": "https://github.com/angular/angular/raw/4ec045e12b7614b901d4ef643988b86f09dfeee5/packages%2Fforms%2Fsrc%2Fmodel.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fmodel.ts?ref=4ec045e12b7614b901d4ef643988b86f09dfeee5",
            "patch": "@@ -1450,22 +1450,34 @@ export class FormGroup extends AbstractControl {\n    *\n    * @param name The control name to add to the collection\n    * @param control Provides the control for the given name\n+   * @param options Specifies whether this FormGroup instance should emit events after a new\n+   *     control is added.\n+   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n+   * `valueChanges` observables emit events with the latest status and value when the control is\n+   * added. When false, no events are emitted.\n    */\n-  addControl(name: string, control: AbstractControl): void {\n+  addControl(name: string, control: AbstractControl, options: {emitEvent?: boolean} = {}): void {\n     this.registerControl(name, control);\n-    this.updateValueAndValidity();\n+    this.updateValueAndValidity({emitEvent: options.emitEvent});\n     this._onCollectionChange();\n   }\n \n   /**\n    * Remove a control from this group.\n    *\n+   * This method also updates the value and validity of the control.\n+   *\n    * @param name The control name to remove from the collection\n+   * @param options Specifies whether this FormGroup instance should emit events after a\n+   *     control is removed.\n+   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n+   * `valueChanges` observables emit events with the latest status and value when the control is\n+   * removed. When false, no events are emitted.\n    */\n-  removeControl(name: string): void {\n+  removeControl(name: string, options: {emitEvent?: boolean} = {}): void {\n     if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n     delete (this.controls[name]);\n-    this.updateValueAndValidity();\n+    this.updateValueAndValidity({emitEvent: options.emitEvent});\n     this._onCollectionChange();\n   }\n \n@@ -1474,12 +1486,17 @@ export class FormGroup extends AbstractControl {\n    *\n    * @param name The control name to replace in the collection\n    * @param control Provides the control for the given name\n+   * @param options Specifies whether this FormGroup instance should emit events after an\n+   *     existing control is replaced.\n+   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n+   * `valueChanges` observables emit events with the latest status and value when the control is\n+   * replaced with a new one. When false, no events are emitted.\n    */\n-  setControl(name: string, control: AbstractControl): void {\n+  setControl(name: string, control: AbstractControl, options: {emitEvent?: boolean} = {}): void {\n     if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n     delete (this.controls[name]);\n     if (control) this.registerControl(name, control);\n-    this.updateValueAndValidity();\n+    this.updateValueAndValidity({emitEvent: options.emitEvent});\n     this._onCollectionChange();\n   }\n \n@@ -1876,11 +1893,16 @@ export class FormArray extends AbstractControl {\n    * Insert a new `AbstractControl` at the end of the array.\n    *\n    * @param control Form control to be inserted\n+   * @param options Specifies whether this FormArray instance should emit events after a new\n+   *     control is added.\n+   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n+   * `valueChanges` observables emit events with the latest status and value when the control is\n+   * inserted. When false, no events are emitted.\n    */\n-  push(control: AbstractControl): void {\n+  push(control: AbstractControl, options: {emitEvent?: boolean} = {}): void {\n     this.controls.push(control);\n     this._registerControl(control);\n-    this.updateValueAndValidity();\n+    this.updateValueAndValidity({emitEvent: options.emitEvent});\n     this._onCollectionChange();\n   }\n \n@@ -1889,32 +1911,47 @@ export class FormArray extends AbstractControl {\n    *\n    * @param index Index in the array to insert the control\n    * @param control Form control to be inserted\n+   * @param options Specifies whether this FormArray instance should emit events after a new\n+   *     control is inserted.\n+   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n+   * `valueChanges` observables emit events with the latest status and value when the control is\n+   * inserted. When false, no events are emitted.\n    */\n-  insert(index: number, control: AbstractControl): void {\n+  insert(index: number, control: AbstractControl, options: {emitEvent?: boolean} = {}): void {\n     this.controls.splice(index, 0, control);\n \n     this._registerControl(control);\n-    this.updateValueAndValidity();\n+    this.updateValueAndValidity({emitEvent: options.emitEvent});\n   }\n \n   /**\n    * Remove the control at the given `index` in the array.\n    *\n    * @param index Index in the array to remove the control\n+   * @param options Specifies whether this FormArray instance should emit events after a\n+   *     control is removed.\n+   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n+   * `valueChanges` observables emit events with the latest status and value when the control is\n+   * removed. When false, no events are emitted.\n    */\n-  removeAt(index: number): void {\n+  removeAt(index: number, options: {emitEvent?: boolean} = {}): void {\n     if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n     this.controls.splice(index, 1);\n-    this.updateValueAndValidity();\n+    this.updateValueAndValidity({emitEvent: options.emitEvent});\n   }\n \n   /**\n    * Replace an existing control.\n    *\n    * @param index Index in the array to replace the control\n    * @param control The `AbstractControl` control to replace the existing control\n+   * @param options Specifies whether this FormArray instance should emit events after an\n+   *     existing control is replaced with a new one.\n+   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n+   * `valueChanges` observables emit events with the latest status and value when the control is\n+   * replaced with a new one. When false, no events are emitted.\n    */\n-  setControl(index: number, control: AbstractControl): void {\n+  setControl(index: number, control: AbstractControl, options: {emitEvent?: boolean} = {}): void {\n     if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n     this.controls.splice(index, 1);\n \n@@ -1923,7 +1960,7 @@ export class FormArray extends AbstractControl {\n       this._registerControl(control);\n     }\n \n-    this.updateValueAndValidity();\n+    this.updateValueAndValidity({emitEvent: options.emitEvent});\n     this._onCollectionChange();\n   }\n \n@@ -2095,6 +2132,12 @@ export class FormArray extends AbstractControl {\n   /**\n    * Remove all controls in the `FormArray`.\n    *\n+   * @param options Specifies whether this FormArray instance should emit events after all\n+   *     controls are removed.\n+   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n+   * `valueChanges` observables emit events with the latest status and value when all controls\n+   * in this FormArray instance are removed. When false, no events are emitted.\n+   *\n    * @usageNotes\n    * ### Remove all elements from a FormArray\n    *\n@@ -2122,11 +2165,11 @@ export class FormArray extends AbstractControl {\n    * }\n    * ```\n    */\n-  clear(): void {\n+  clear(options: {emitEvent?: boolean} = {}): void {\n     if (this.controls.length < 1) return;\n     this._forEachChild((control: AbstractControl) => control._registerOnCollectionChange(() => {}));\n     this.controls.splice(0);\n-    this.updateValueAndValidity();\n+    this.updateValueAndValidity({emitEvent: options.emitEvent});\n   }\n \n   /** @internal */"
        },
        {
            "sha": "c810230d1723370017243a76a4a54be734aac03b",
            "filename": "packages/forms/test/form_array_spec.ts",
            "status": "modified",
            "additions": 127,
            "deletions": 57,
            "changes": 184,
            "blob_url": "https://github.com/angular/angular/blob/4ec045e12b7614b901d4ef643988b86f09dfeee5/packages%2Fforms%2Ftest%2Fform_array_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4ec045e12b7614b901d4ef643988b86f09dfeee5/packages%2Fforms%2Ftest%2Fform_array_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Fform_array_spec.ts?ref=4ec045e12b7614b901d4ef643988b86f09dfeee5",
            "patch": "@@ -18,12 +18,14 @@ describe('FormArray', () => {\n   describe('adding/removing', () => {\n     let a: FormArray;\n     let c1: FormControl, c2: FormControl, c3: FormControl;\n+    let logger: string[];\n \n     beforeEach(() => {\n       a = new FormArray([]);\n       c1 = new FormControl(1);\n       c2 = new FormControl(2);\n       c3 = new FormControl(3);\n+      logger = [];\n     });\n \n     it('should support pushing', () => {\n@@ -64,6 +66,100 @@ describe('FormArray', () => {\n \n       expect(a.controls).toEqual([c1, c2, c3]);\n     });\n+\n+    it('should not emit events when calling `FormArray.push` with `emitEvent: false`', () => {\n+      a.valueChanges.subscribe(() => logger.push('value change'));\n+      a.statusChanges.subscribe(() => logger.push('status change'));\n+\n+      a.push(c1, {emitEvent: false});\n+\n+      expect(a.length).toEqual(1);\n+      expect(a.controls).toEqual([c1]);\n+      expect(logger).toEqual([]);\n+    });\n+\n+    it('should not emit events when calling `FormArray.removeAt` with `emitEvent: false`', () => {\n+      a.push(c1);\n+      a.push(c2);\n+      a.push(c3);\n+\n+      a.valueChanges.subscribe(() => logger.push('value change'));\n+      a.statusChanges.subscribe(() => logger.push('status change'));\n+\n+      a.removeAt(1, {emitEvent: false});\n+\n+      expect(a.controls).toEqual([c1, c3]);\n+      expect(logger).toEqual([]);\n+    });\n+\n+    it('should not emit events when calling `FormArray.clear` with `emitEvent: false`', () => {\n+      a.push(c1);\n+      a.push(c2);\n+      a.push(c3);\n+\n+      a.valueChanges.subscribe(() => logger.push('value change'));\n+      a.statusChanges.subscribe(() => logger.push('status change'));\n+\n+      a.clear({emitEvent: false});\n+\n+      expect(a.controls).toEqual([]);\n+      expect(logger).toEqual([]);\n+    });\n+\n+    it('should not emit events when calling `FormArray.insert` with `emitEvent: false`', () => {\n+      a.push(c1);\n+      a.push(c3);\n+\n+      a.valueChanges.subscribe(() => logger.push('value change'));\n+      a.statusChanges.subscribe(() => logger.push('status change'));\n+\n+      a.insert(1, c2, {emitEvent: false});\n+\n+      expect(a.controls).toEqual([c1, c2, c3]);\n+      expect(logger).toEqual([]);\n+    });\n+\n+    it('should not emit events when calling `FormArray.setControl` with `emitEvent: false`', () => {\n+      a.push(c1);\n+      a.push(c3);\n+\n+      a.valueChanges.subscribe(() => logger.push('value change'));\n+      a.statusChanges.subscribe(() => logger.push('status change'));\n+\n+      a.setControl(1, c2, {emitEvent: false});\n+\n+      expect(a.controls).toEqual([c1, c2]);\n+      expect(logger).toEqual([]);\n+    });\n+\n+    it('should not emit status change events when `FormArray.push` is called with `emitEvent: false`',\n+       () => {\n+         // Adding validators to make sure there are no status change event submitted when form\n+         // becomes invalid.\n+         const validatorFn = (value: any) => value.controls.length > 0 ? {controls: true} : null;\n+         const asyncValidatorFn = (value: any) => of(validatorFn(value));\n+         const arr = new FormArray([], validatorFn, asyncValidatorFn);\n+         expect(arr.valid).toBe(true);\n+\n+         arr.statusChanges.subscribe(() => logger.push('status change'));\n+\n+         arr.push(c1, {emitEvent: false});\n+\n+         expect(arr.valid).toBe(false);\n+         expect(logger).toEqual([]);\n+       });\n+\n+    it('should not emit events on the parent when called with `emitEvent: false`', () => {\n+      const form = new FormGroup({child: a});\n+\n+      form.valueChanges.subscribe(() => logger.push('form value change'));\n+      a.valueChanges.subscribe(() => logger.push('array value change'));\n+      form.statusChanges.subscribe(() => logger.push('form status change'));\n+      a.statusChanges.subscribe(() => logger.push('array status change'));\n+\n+      a.push(new FormControl(5), {emitEvent: false});\n+      expect(logger).toEqual([]);\n+    });\n   });\n \n   describe('value', () => {\n@@ -235,23 +331,15 @@ describe('FormArray', () => {\n         expect(logger).toEqual(['control1', 'control2', 'array', 'form']);\n       });\n \n-      it('should not fire an event when explicitly specified', fakeAsync(() => {\n-           form.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           a.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           c.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           c2.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-\n-           a.setValue(['one', 'two'], {emitEvent: false});\n-           tick();\n-         }));\n+      it('should not fire events when called with `emitEvent: false`', () => {\n+        form.valueChanges.subscribe(() => logger.push('form'));\n+        a.valueChanges.subscribe(() => logger.push('array'));\n+        c.valueChanges.subscribe(() => logger.push('control1'));\n+        c2.valueChanges.subscribe(() => logger.push('control2'));\n+\n+        a.setValue(['one', 'two'], {emitEvent: false});\n+        expect(logger).toEqual([]);\n+      });\n \n       it('should emit one statusChange event per control', () => {\n         form.statusChanges.subscribe(() => logger.push('form'));\n@@ -386,23 +474,15 @@ describe('FormArray', () => {\n            expect(logger).toEqual([]);\n          });\n \n-      it('should not fire an event when explicitly specified', fakeAsync(() => {\n-           form.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           a.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           c.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           c2.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-\n-           a.patchValue(['one', 'two'], {emitEvent: false});\n-           tick();\n-         }));\n+      it('should not fire events when called with `emitEvent: false`', () => {\n+        form.valueChanges.subscribe(() => logger.push('form'));\n+        a.valueChanges.subscribe(() => logger.push('array'));\n+        c.valueChanges.subscribe(() => logger.push('control1'));\n+        c2.valueChanges.subscribe(() => logger.push('control2'));\n+\n+        a.patchValue(['one', 'two'], {emitEvent: false});\n+        expect(logger).toEqual([]);\n+      });\n \n       it('should emit one statusChange event per control', () => {\n         form.statusChanges.subscribe(() => logger.push('form'));\n@@ -605,26 +685,16 @@ describe('FormArray', () => {\n         expect(logger).toEqual(['control1', 'control2', 'array', 'form']);\n       });\n \n-      it('should not fire an event when explicitly specified', fakeAsync(() => {\n-           form.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           a.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           c.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           c2.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           c3.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-\n-           a.reset([], {emitEvent: false});\n-           tick();\n-         }));\n+      it('should not fire events when called with `emitEvent: false`', () => {\n+        form.valueChanges.subscribe(() => logger.push('form'));\n+        a.valueChanges.subscribe(() => logger.push('array'));\n+        c.valueChanges.subscribe(() => logger.push('control1'));\n+        c2.valueChanges.subscribe(() => logger.push('control2'));\n+        c3.valueChanges.subscribe(() => logger.push('control3'));\n+\n+        a.reset([], {emitEvent: false});\n+        expect(logger).toEqual([]);\n+      });\n \n       it('should emit one statusChange event per reset control', () => {\n         form.statusChanges.subscribe(() => logger.push('form'));\n@@ -764,7 +834,7 @@ describe('FormArray', () => {\n         expect(logger).toEqual([]);\n       });\n \n-      it('should not emit event when emitEvent = false', () => {\n+      it('should not emit events when called with `emitEvent: false`', () => {\n         c.markAsPending({emitEvent: false});\n         expect(logger).toEqual([]);\n       });\n@@ -1211,7 +1281,7 @@ describe('FormArray', () => {\n         expect(logger).toEqual(['control', 'array', 'form']);\n       });\n \n-      it('should not emit value change events when emitEvent = false', () => {\n+      it('should not emit value change events when called with `emitEvent: false`', () => {\n         c.valueChanges.subscribe(() => logger.push('control'));\n         a.valueChanges.subscribe(() => logger.push('array'));\n         form.valueChanges.subscribe(() => logger.push('form'));\n@@ -1222,7 +1292,7 @@ describe('FormArray', () => {\n         expect(logger).toEqual([]);\n       });\n \n-      it('should not emit status change events when emitEvent = false', () => {\n+      it('should not emit status change events when called with `emitEvent: false`', () => {\n         c.statusChanges.subscribe(() => logger.push('control'));\n         a.statusChanges.subscribe(() => logger.push('array'));\n         form.statusChanges.subscribe(() => logger.push('form'));"
        },
        {
            "sha": "6a8578bef16d7844eb5d2c2fccd2e73f2603e18a",
            "filename": "packages/forms/test/form_group_spec.ts",
            "status": "modified",
            "additions": 99,
            "deletions": 42,
            "changes": 141,
            "blob_url": "https://github.com/angular/angular/blob/4ec045e12b7614b901d4ef643988b86f09dfeee5/packages%2Fforms%2Ftest%2Fform_group_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4ec045e12b7614b901d4ef643988b86f09dfeee5/packages%2Fforms%2Ftest%2Fform_group_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Fform_group_spec.ts?ref=4ec045e12b7614b901d4ef643988b86f09dfeee5",
            "patch": "@@ -126,6 +126,12 @@ describe('FormGroup', () => {\n   });\n \n   describe('adding and removing controls', () => {\n+    let logger: any[];\n+\n+    beforeEach(() => {\n+      logger = [];\n+    });\n+\n     it('should update value and validity when control is added', () => {\n       const g = new FormGroup({'one': new FormControl('1')});\n       expect(g.value).toEqual({'one': '1'});\n@@ -148,6 +154,54 @@ describe('FormGroup', () => {\n       expect(g.value).toEqual({'one': '1'});\n       expect(g.valid).toBe(true);\n     });\n+\n+    it('should not emit events when `FormGroup.addControl` is called with `emitEvent: false`',\n+       () => {\n+         const g = new FormGroup({'one': new FormControl('1')});\n+         expect(g.value).toEqual({'one': '1'});\n+\n+         g.valueChanges.subscribe(() => logger.push('value change'));\n+         g.statusChanges.subscribe(() => logger.push('status change'));\n+\n+         g.addControl('two', new FormControl('2'), {emitEvent: false});\n+\n+         expect(g.value).toEqual({'one': '1', 'two': '2'});\n+         expect(logger).toEqual([]);\n+       });\n+\n+    it('should not emit events when `FormGroup.removeControl` is called with `emitEvent: false`',\n+       () => {\n+         const g = new FormGroup(\n+             {'one': new FormControl('1'), 'two': new FormControl('2', Validators.minLength(10))});\n+         expect(g.value).toEqual({'one': '1', 'two': '2'});\n+         expect(g.valid).toBe(false);\n+\n+         g.valueChanges.subscribe(() => logger.push('value change'));\n+         g.statusChanges.subscribe(() => logger.push('status change'));\n+\n+         g.removeControl('two', {emitEvent: false});\n+\n+         expect(g.value).toEqual({'one': '1'});\n+         expect(g.valid).toBe(true);\n+         expect(logger).toEqual([]);\n+       });\n+\n+    it('should not emit status change events when `FormGroup.addControl` is called with `emitEvent: false`',\n+       () => {\n+         const validatorFn = (value: any) =>\n+             value.controls.invalidCtrl ? {invalidCtrl: true} : null;\n+         const asyncValidatorFn = (value: any) => of(validatorFn(value));\n+         const g = new FormGroup({}, validatorFn, asyncValidatorFn);\n+         expect(g.valid).toBe(true);\n+\n+         g.statusChanges.subscribe(() => logger.push('status change'));\n+\n+         g.addControl('invalidCtrl', new FormControl(''), {emitEvent: false});\n+\n+         expect(g.value).toEqual({'invalidCtrl': ''});\n+         expect(g.valid).toBe(false);\n+         expect(logger).toEqual([]);\n+       });\n   });\n \n   describe('dirty', () => {\n@@ -283,20 +337,15 @@ describe('FormGroup', () => {\n         expect(logger).toEqual(['control1', 'control2', 'group', 'form']);\n       });\n \n-      it('should not fire an event when explicitly specified', fakeAsync(() => {\n-           form.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           g.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           c.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n+      it('should not emit events when `FormGroup.setValue` is called with `emitEvent: false`',\n+         () => {\n+           form.valueChanges.subscribe(() => logger.push('form'));\n+           g.valueChanges.subscribe(() => logger.push('group'));\n+           c.valueChanges.subscribe(() => logger.push('control'));\n \n            g.setValue({'one': 'one', 'two': 'two'}, {emitEvent: false});\n-           tick();\n-         }));\n+           expect(logger).toEqual([]);\n+         });\n \n       it('should emit one statusChange event per control', () => {\n         form.statusChanges.subscribe(() => logger.push('form'));\n@@ -307,6 +356,16 @@ describe('FormGroup', () => {\n         g.setValue({'one': 'one', 'two': 'two'});\n         expect(logger).toEqual(['control1', 'control2', 'group', 'form']);\n       });\n+\n+      it('should not emit events on the parent when called with `emitEvent: false`', () => {\n+        form.valueChanges.subscribe(() => logger.push('form value change'));\n+        g.valueChanges.subscribe(() => logger.push('group value change'));\n+        form.statusChanges.subscribe(() => logger.push('form status change'));\n+        g.statusChanges.subscribe(() => logger.push('group status change'));\n+\n+        g.addControl('three', new FormControl(5), {emitEvent: false});\n+        expect(logger).toEqual([]);\n+      });\n     });\n   });\n \n@@ -444,20 +503,15 @@ describe('FormGroup', () => {\n            expect(logger).toEqual([]);\n          });\n \n-      it('should not fire an event when explicitly specified', fakeAsync(() => {\n-           form.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           g.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           c.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n+      it('should not emit events when `FormGroup.patchValue` is called with `emitEvent: false`',\n+         () => {\n+           form.valueChanges.subscribe(() => logger.push('form'));\n+           g.valueChanges.subscribe(() => logger.push('group'));\n+           c.valueChanges.subscribe(() => logger.push('control'));\n \n            g.patchValue({'one': 'one', 'two': 'two'}, {emitEvent: false});\n-           tick();\n-         }));\n+           expect(logger).toEqual([]);\n+         });\n \n       it('should emit one statusChange event per control', () => {\n         form.statusChanges.subscribe(() => logger.push('form'));\n@@ -659,20 +713,14 @@ describe('FormGroup', () => {\n         expect(logger).toEqual(['control1', 'control2', 'group', 'form']);\n       });\n \n-      it('should not fire an event when explicitly specified', fakeAsync(() => {\n-           form.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           g.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-           c.valueChanges.subscribe((value) => {\n-             throw 'Should not happen';\n-           });\n-\n-           g.reset({}, {emitEvent: false});\n-           tick();\n-         }));\n+      it('should not emit events when `FormGroup.reset` is called with `emitEvent: false`', () => {\n+        form.valueChanges.subscribe(() => logger.push('form'));\n+        g.valueChanges.subscribe(() => logger.push('group'));\n+        c.valueChanges.subscribe(() => logger.push('control'));\n+\n+        g.reset({}, {emitEvent: false});\n+        expect(logger).toEqual([]);\n+      });\n \n       it('should emit one statusChange event per reset control', () => {\n         form.statusChanges.subscribe(() => logger.push('form'));\n@@ -1769,7 +1817,7 @@ describe('FormGroup', () => {\n         expect(logger).toEqual(['control', 'group', 'form']);\n       });\n \n-      it('should not emit value change events when emitEvent = false', () => {\n+      it('should not emit value change events when called with `emitEvent: false`', () => {\n         c.valueChanges.subscribe(() => logger.push('control'));\n         g.valueChanges.subscribe(() => logger.push('group'));\n         form.valueChanges.subscribe(() => logger.push('form'));\n@@ -1780,7 +1828,7 @@ describe('FormGroup', () => {\n         expect(logger).toEqual([]);\n       });\n \n-      it('should not emit status change events when emitEvent = false', () => {\n+      it('should not emit status change events when called with `emitEvent: false`', () => {\n         c.statusChanges.subscribe(() => logger.push('control'));\n         g.statusChanges.subscribe(() => logger.push('group'));\n         form.statusChanges.subscribe(() => logger.push('form'));\n@@ -1818,7 +1866,7 @@ describe('FormGroup', () => {\n       expect(logger).toEqual(['one', 'two', 'nested', 'three', 'form']);\n     });\n \n-    it('should not emit events when turned off', () => {\n+    it('should not emit events when called with `emitEvent: false`', () => {\n       (form as any)._updateTreeValidity({emitEvent: false});\n       expect(logger).toEqual([]);\n     });\n@@ -1864,6 +1912,15 @@ describe('FormGroup', () => {\n       g.setControl('one', c2);\n       expect(logger).toEqual(['change!']);\n     });\n+\n+    it('should not emit event called when `FormGroup.setControl` with `emitEvent: false`', () => {\n+      const logger: string[] = [];\n+      const c2 = new FormControl('new!');\n+      g.valueChanges.subscribe(() => logger.push('value change'));\n+      g.statusChanges.subscribe(() => logger.push('status change'));\n+      g.setControl('one', c2, {emitEvent: false});\n+      expect(logger).toEqual([]);\n+    });\n   });\n \n   describe('emit `statusChanges` and `valueChanges` with/without async/sync validators', () => {\n@@ -2292,7 +2349,7 @@ describe('FormGroup', () => {\n         expect(logger).toEqual([]);\n       });\n \n-      it('should not emit event when emitEvent = false', () => {\n+      it('should not emit event when called with `emitEvent: false`', () => {\n         c.markAsPending({emitEvent: false});\n         expect(logger).toEqual([]);\n       });"
        }
    ],
    "stats": {
        "total": 432,
        "additions": 309,
        "deletions": 123
    }
}