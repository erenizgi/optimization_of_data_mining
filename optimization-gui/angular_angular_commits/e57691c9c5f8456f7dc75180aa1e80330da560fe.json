{
    "author": "atscott",
    "message": "feat(core): Add migration to update empty routerLinks in templates (#43176)\n\nThe previous behavior of `RouterLink` for `null` and `undefined` inputs was to treat\nthe input the same as `[]` or `''`. This creates several unresolvable issues with\ncorrectly disabling the links because `commands = []` does not behave the same\nas disabling a link. Instead, it navigates to the current page, but will also\nclear any fragment and/or query params.\n\nThe new behavior of the `routerLink` input will be to completely disable navigation\nfor `null` and `undefined` inputs. For HTML Anchor elements, this will also mean\nremoving the `href` attribute.\n\nMigration for change in #43087\n\nPR Close #43176",
    "sha": "e57691c9c5f8456f7dc75180aa1e80330da560fe",
    "files": [
        {
            "sha": "66c250a589dfea98d412c1c8107d912c441a2408",
            "filename": "packages/core/schematics/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2FBUILD.bazel?ref=e57691c9c5f8456f7dc75180aa1e80330da560fe",
            "patch": "@@ -23,6 +23,7 @@ pkg_npm(\n         \"//packages/core/schematics/migrations/navigation-extras-omissions\",\n         \"//packages/core/schematics/migrations/relative-link-resolution\",\n         \"//packages/core/schematics/migrations/renderer-to-renderer2\",\n+        \"//packages/core/schematics/migrations/router-link-empty-expression\",\n         \"//packages/core/schematics/migrations/router-preserve-query-params\",\n         \"//packages/core/schematics/migrations/static-queries\",\n         \"//packages/core/schematics/migrations/template-var-assignment\","
        },
        {
            "sha": "fce8147718f5f5696f39add4081324e08eac0462",
            "filename": "packages/core/schematics/migrations.json",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "raw_url": "https://github.com/angular/angular/raw/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations.json?ref=e57691c9c5f8456f7dc75180aa1e80330da560fe",
            "patch": "@@ -99,6 +99,11 @@\n       \"version\": \"12.0.2\",\n       \"description\": \"Automatically migrates shadow-piercing selector from `/deep/` to the recommended alternative `::ng-deep`.\",\n       \"factory\": \"./migrations/deep-shadow-piercing-selector/index\"\n+    },\n+    \"migration-v13-router-link-empty-expression\": {\n+      \"version\": \"13.0.0-beta\",\n+      \"description\": \"Migrates `[routerLink]=\\\"\\\"` in templates to `[routerLink]=\\\"[]\\\"` because these links are likely intented to route to the current page with updated fragment/query params.\",\n+      \"factory\": \"./migrations/router-link-empty-expression/index\"\n     }\n   }\n-}\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "0d5091642f83d8dc817c9f637f40db4931baa0b6",
            "filename": "packages/core/schematics/migrations/router-link-empty-expression/BUILD.bazel",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2FBUILD.bazel?ref=e57691c9c5f8456f7dc75180aa1e80330da560fe",
            "patch": "@@ -0,0 +1,20 @@\n+load(\"//tools:defaults.bzl\", \"ts_library\")\n+\n+ts_library(\n+    name = \"router-link-empty-expression\",\n+    srcs = glob([\"**/*.ts\"]),\n+    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n+    visibility = [\n+        \"//packages/core/schematics:__pkg__\",\n+        \"//packages/core/schematics/migrations/google3:__pkg__\",\n+        \"//packages/core/schematics/test:__pkg__\",\n+    ],\n+    deps = [\n+        \"//packages/compiler\",\n+        \"//packages/core/schematics/utils\",\n+        \"@npm//@angular-devkit/core\",\n+        \"@npm//@angular-devkit/schematics\",\n+        \"@npm//@types/node\",\n+        \"@npm//typescript\",\n+    ],\n+)"
        },
        {
            "sha": "f877a333f436dbdc1f9cb8c208cf6a67c234f79d",
            "filename": "packages/core/schematics/migrations/router-link-empty-expression/README.md",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2FREADME.md?ref=e57691c9c5f8456f7dc75180aa1e80330da560fe",
            "patch": "@@ -0,0 +1,28 @@\n+## RouterLink `null` and `undefined` inputs\n+\n+The previous behavior of `RouterLink` for `null` and `undefined` inputs was to treat\n+the input the same as `[]` or `''`. This creates several unresolvable issues with\n+correctly disabling the links because `commands = []` does not behave the same\n+as disabling a link. Instead, it navigates to the current page, but will also\n+clear any fragment and/or query params.\n+\n+The new behavior of the `routerLink` input will be to completely disable navigation\n+for `null` and `undefined` inputs. For HTML Anchor elements, this will also mean\n+removing the `href` attribute.\n+\n+```html\n+<button [routerLink]=\"\" fragment=\"section_2\">section 2</button>\n+```\n+\n+In the example from above, there is no value provided to the `routerLink` input.\n+This button would previously navigate to the current page and update the fragment to \"section_2\".\n+The updated behavio is to disable this link because the input\n+for `routerLink` is `undefined`.\n+\n+If the intent for the link is to link to the current page rather than disable navigation,\n+the template should be updated to one of the following options:\n+```html\n+<button [routerLink]=\"[]\" fragment=\"section_2\">section 2</button>\n+<button [routerLink]=\"''\" fragment=\"section_2\">section 2</button>\n+<button routerLink fragment=\"section_2\">section 2</button>\n+```\n\\ No newline at end of file"
        },
        {
            "sha": "68aa1cf23e24a6b42be3e0795a83e69a88188a7a",
            "filename": "packages/core/schematics/migrations/router-link-empty-expression/analyze_template.ts",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2Fanalyze_template.ts",
            "raw_url": "https://github.com/angular/angular/raw/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2Fanalyze_template.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2Fanalyze_template.ts?ref=e57691c9c5f8456f7dc75180aa1e80330da560fe",
            "patch": "@@ -0,0 +1,29 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {BoundAttribute, visitAll} from '@angular/compiler/src/render3/r3_ast';\n+\n+import {ResolvedTemplate} from '../../utils/ng_component_template';\n+import {parseHtmlGracefully} from '../../utils/parse_html';\n+\n+import {RouterLinkEmptyExprVisitor} from './angular/html_routerlink_empty_expr_visitor';\n+\n+export function analyzeResolvedTemplate(template: ResolvedTemplate): BoundAttribute[]|null {\n+  const templateNodes = parseHtmlGracefully(template.content, template.filePath);\n+\n+  if (!templateNodes) {\n+    return null;\n+  }\n+\n+  const visitor = new RouterLinkEmptyExprVisitor();\n+\n+  // Analyze the Angular Render3 HTML AST and collect all template variable assignments.\n+  visitAll(visitor, templateNodes);\n+\n+  return visitor.emptyRouterLinkExpressions;\n+}"
        },
        {
            "sha": "bc92940cb8a22bd551d0de9c55de02ad7495ec19",
            "filename": "packages/core/schematics/migrations/router-link-empty-expression/angular/html_routerlink_empty_expr_visitor.ts",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/angular/angular/blob/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2Fangular%2Fhtml_routerlink_empty_expr_visitor.ts",
            "raw_url": "https://github.com/angular/angular/raw/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2Fangular%2Fhtml_routerlink_empty_expr_visitor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2Fangular%2Fhtml_routerlink_empty_expr_visitor.ts?ref=e57691c9c5f8456f7dc75180aa1e80330da560fe",
            "patch": "@@ -0,0 +1,35 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ASTWithSource, EmptyExpr} from '@angular/compiler';\n+import {BoundAttribute, Element, NullVisitor, Template, visitAll} from '@angular/compiler/src/render3/r3_ast';\n+\n+/**\n+ * HTML AST visitor that traverses the Render3 HTML AST in order to find all\n+ * undefined routerLink asssignment ([routerLink]=\"\").\n+ */\n+export class RouterLinkEmptyExprVisitor extends NullVisitor {\n+  readonly emptyRouterLinkExpressions: BoundAttribute[] = [];\n+\n+  override visitElement(element: Element): void {\n+    visitAll(this, element.inputs);\n+    visitAll(this, element.children);\n+  }\n+\n+  override visitTemplate(t: Template): void {\n+    visitAll(this, t.inputs);\n+    visitAll(this, t.children);\n+  }\n+\n+  override visitBoundAttribute(node: BoundAttribute) {\n+    if (node.name === 'routerLink' && node.value instanceof ASTWithSource &&\n+        node.value.ast instanceof EmptyExpr) {\n+      this.emptyRouterLinkExpressions.push(node);\n+    }\n+  }\n+}"
        },
        {
            "sha": "5652644182d253f7b5f82a0671b51d6e52c6c0cd",
            "filename": "packages/core/schematics/migrations/router-link-empty-expression/index.ts",
            "status": "added",
            "additions": 157,
            "deletions": 0,
            "changes": 157,
            "blob_url": "https://github.com/angular/angular/blob/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-link-empty-expression%2Findex.ts?ref=e57691c9c5f8456f7dc75180aa1e80330da560fe",
            "patch": "@@ -0,0 +1,157 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {logging, normalize} from '@angular-devkit/core';\n+import {Rule, SchematicContext, SchematicsException, Tree} from '@angular-devkit/schematics';\n+import {EmptyExpr, TmplAstBoundAttribute} from '@angular/compiler';\n+import {relative} from 'path';\n+\n+import {NgComponentTemplateVisitor, ResolvedTemplate} from '../../utils/ng_component_template';\n+import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n+import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n+\n+import {analyzeResolvedTemplate} from './analyze_template';\n+\n+type Logger = logging.LoggerApi;\n+\n+const README_URL =\n+    'https://github.com/angular/angular/blob/master/packages/core/schematics/migrations/router-link-empty-expression/README.md';\n+\n+interface FixedTemplate {\n+  originalTemplate: ResolvedTemplate;\n+  newContent: string;\n+  emptyRouterlinkExpressions: TmplAstBoundAttribute[];\n+}\n+\n+/** Entry point for the RouterLink empty expression migration. */\n+export default function(): Rule {\n+  return (tree: Tree, context: SchematicContext) => {\n+    const {buildPaths, testPaths} = getProjectTsConfigPaths(tree);\n+    const basePath = process.cwd();\n+\n+    if (!buildPaths.length && !testPaths.length) {\n+      throw new SchematicsException(\n+          'Could not find any tsconfig file. Cannot check templates for empty routerLinks.');\n+    }\n+\n+    for (const tsconfigPath of [...buildPaths, ...testPaths]) {\n+      runEmptyRouterLinkExpressionMigration(tree, tsconfigPath, basePath, context.logger);\n+    }\n+  };\n+}\n+\n+/**\n+ * Runs the routerLink migration, changing routerLink=\"\" to routerLink=\"[]\" and notifying developers\n+ * which templates received updates.\n+ */\n+function runEmptyRouterLinkExpressionMigration(\n+    tree: Tree, tsconfigPath: string, basePath: string, logger: Logger) {\n+  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n+  const typeChecker = program.getTypeChecker();\n+  const templateVisitor = new NgComponentTemplateVisitor(typeChecker);\n+  const sourceFiles =\n+      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n+\n+  // Analyze source files by detecting HTML templates.\n+  sourceFiles.forEach(sourceFile => templateVisitor.visitNode(sourceFile));\n+\n+  const {resolvedTemplates} = templateVisitor;\n+  fixEmptyRouterlinks(resolvedTemplates, tree, logger);\n+}\n+\n+function fixEmptyRouterlinks(resolvedTemplates: ResolvedTemplate[], tree: Tree, logger: Logger) {\n+  const basePath = process.cwd();\n+  const collectedFixes: string[] = [];\n+  const fixesByFile = getFixesByFile(resolvedTemplates);\n+\n+  for (const [absFilePath, fixes] of fixesByFile) {\n+    const treeFilePath = relative(normalize(basePath), normalize(absFilePath));\n+    const originalFileContent = tree.read(treeFilePath)?.toString();\n+    if (originalFileContent === undefined) {\n+      logger.error(\n+          `Failed to read file containing template; cannot apply fixes for empty routerLink expressions in ${\n+              treeFilePath}.`);\n+      continue;\n+    }\n+\n+    const updater = tree.beginUpdate(treeFilePath);\n+    for (const fix of fixes) {\n+      const displayFilePath = normalize(relative(basePath, fix.originalTemplate.filePath));\n+      updater.remove(fix.originalTemplate.start, fix.originalTemplate.content.length);\n+      updater.insertLeft(fix.originalTemplate.start, fix.newContent);\n+\n+      for (const n of fix.emptyRouterlinkExpressions) {\n+        const {line, character} =\n+            fix.originalTemplate.getCharacterAndLineOfPosition(n.sourceSpan.start.offset);\n+        collectedFixes.push(`${displayFilePath}@${line + 1}:${character + 1}`);\n+      }\n+      tree.commitUpdate(updater);\n+    }\n+  }\n+\n+  if (collectedFixes.length > 0) {\n+    logger.info('---- RouterLink empty assignment schematic ----');\n+    logger.info('The behavior of empty/`undefined` inputs for `routerLink` has changed');\n+    logger.info('from linking to the current page to instead completely disable the link.');\n+    logger.info(`Read more about this change here: ${README_URL}`);\n+    logger.info('');\n+    logger.info('The following empty `routerLink` inputs were found and fixed:');\n+    collectedFixes.forEach(fix => logger.warn(`⮑   ${fix}`));\n+  }\n+}\n+\n+/**\n+ * Returns fixes for nodes in templates which contain empty routerLink assignments, grouped by file.\n+ */\n+function getFixesByFile(templates: ResolvedTemplate[]): Map<string, FixedTemplate[]> {\n+  const fixesByFile = new Map<string, FixedTemplate[]>();\n+  for (const template of templates) {\n+    const templateFix = fixEmptyRouterlinksInTemplate(template);\n+    if (templateFix === null) {\n+      continue;\n+    }\n+\n+    const file = template.filePath;\n+    if (fixesByFile.has(file)) {\n+      if (template.inline) {\n+        // External templates may be referenced multiple times in the project\n+        // (e.g. if shared between components), but we only want to record them\n+        // once. On the other hand, an inline template resides in a TS file that\n+        // may contain multiple inline templates.\n+        fixesByFile.get(file)!.push(templateFix);\n+      }\n+    } else {\n+      fixesByFile.set(file, [templateFix]);\n+    }\n+  }\n+\n+  return fixesByFile;\n+}\n+\n+function fixEmptyRouterlinksInTemplate(template: ResolvedTemplate): FixedTemplate|null {\n+  const emptyRouterlinkExpressions = analyzeResolvedTemplate(template);\n+\n+  if (!emptyRouterlinkExpressions) {\n+    return null;\n+  }\n+\n+  // Sort backwards so string replacements do not conflict\n+  emptyRouterlinkExpressions.sort((a, b) => b.value.sourceSpan.start - a.value.sourceSpan.start);\n+  let newContent = template.content;\n+  for (const expr of emptyRouterlinkExpressions) {\n+    if (expr.valueSpan) {\n+      newContent = newContent.substr(0, expr.value.sourceSpan.start) + '[]' +\n+          newContent.substr(expr.value.sourceSpan.start);\n+    } else {\n+      newContent = newContent.substr(0, expr.sourceSpan.end.offset) + '=\"[]\"' +\n+          newContent.substr(expr.sourceSpan.end.offset);\n+    }\n+  }\n+\n+  return {originalTemplate: template, newContent, emptyRouterlinkExpressions};\n+}"
        },
        {
            "sha": "30f0b69f4f984c0b25ebfc64e89f136e8db6b228",
            "filename": "packages/core/schematics/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel?ref=e57691c9c5f8456f7dc75180aa1e80330da560fe",
            "patch": "@@ -21,6 +21,7 @@ ts_library(\n         \"//packages/core/schematics/migrations/navigation-extras-omissions\",\n         \"//packages/core/schematics/migrations/relative-link-resolution\",\n         \"//packages/core/schematics/migrations/renderer-to-renderer2\",\n+        \"//packages/core/schematics/migrations/router-link-empty-expression\",\n         \"//packages/core/schematics/migrations/router-preserve-query-params\",\n         \"//packages/core/schematics/migrations/static-queries\",\n         \"//packages/core/schematics/migrations/template-var-assignment\","
        },
        {
            "sha": "fa011c3c6ff68a687699c4f31097082bd44c48b8",
            "filename": "packages/core/schematics/test/routerlink_empty_expr_migration_spec.ts",
            "status": "added",
            "additions": 202,
            "deletions": 0,
            "changes": 202,
            "blob_url": "https://github.com/angular/angular/blob/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Ftest%2Frouterlink_empty_expr_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e57691c9c5f8456f7dc75180aa1e80330da560fe/packages%2Fcore%2Fschematics%2Ftest%2Frouterlink_empty_expr_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Frouterlink_empty_expr_migration_spec.ts?ref=e57691c9c5f8456f7dc75180aa1e80330da560fe",
            "patch": "@@ -0,0 +1,202 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n+import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n+import {HostTree} from '@angular-devkit/schematics';\n+import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n+import * as shx from 'shelljs';\n+\n+describe('routerlink emptyExpr assignment migration', () => {\n+  let runner: SchematicTestRunner;\n+  let host: TempScopedNodeJsSyncHost;\n+  let tree: UnitTestTree;\n+  let tmpDirPath: string;\n+  let previousWorkingDir: string;\n+  let warnOutput: string[];\n+\n+  beforeEach(() => {\n+    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n+    host = new TempScopedNodeJsSyncHost();\n+    tree = new UnitTestTree(new HostTree(host));\n+\n+    writeFile('/tsconfig.json', JSON.stringify({\n+      compilerOptions: {\n+        lib: ['es2015'],\n+      },\n+    }));\n+    writeFile('/angular.json', JSON.stringify({\n+      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n+    }));\n+\n+    warnOutput = [];\n+    runner.logger.subscribe(logEntry => {\n+      if (logEntry.level === 'warn') {\n+        warnOutput.push(logEntry.message);\n+      }\n+    });\n+\n+    previousWorkingDir = shx.pwd();\n+    tmpDirPath = getSystemPath(host.root);\n+\n+    // Switch into the temporary directory path. This allows us to run\n+    // the schematic against our custom unit test tree.\n+    shx.cd(tmpDirPath);\n+  });\n+\n+  afterEach(() => {\n+    shx.cd(previousWorkingDir);\n+    shx.rm('-r', tmpDirPath);\n+  });\n+\n+  function writeFile(filePath: string, contents: string) {\n+    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n+  }\n+\n+  function runMigration() {\n+    return runner.runSchematicAsync('migration-v13-router-link-empty-expression', {}, tree)\n+        .toPromise();\n+  }\n+\n+  it('should warn for emptyExpr assignment in inline template', async () => {\n+    writeFile('/index.ts', `\n+      import {Component} from '@angular/core';\n+\n+      @Component({\n+        template: '<div [routerLink]=\"\"></div>',\n+      })\n+      export class MyComp {}\n+    `);\n+\n+    await runMigration();\n+    expect(warnOutput.length).toBe(1);\n+    expect(warnOutput[0]).toMatch(/^⮑ {3}index.ts@5:25/);\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(`<div [routerLink]=\"[]\"></div>`);\n+  });\n+\n+  it('should warn for EmptyExpr assignment in external templatae', async () => {\n+    writeFile('/index.ts', `\n+      import {Component} from '@angular/core';\n+\n+      @Component({\n+        templateUrl: './tmpl.html',\n+      })\n+      export class MyComp {}\n+    `);\n+\n+    writeFile('/tmpl.html', `\n+      <div *ngIf=\"somePartner() | async as partner\">\n+        <some-comp [routerLink]=\"\"></some-comp>\n+      </div>\n+    `);\n+\n+    await runMigration();\n+\n+    expect(warnOutput.length).toBe(1);\n+    expect(warnOutput).toMatch(/^⮑ {3}tmpl.html@3:20/);\n+\n+    const content = tree.readContent('/tmpl.html');\n+    expect(content).toContain(`<some-comp [routerLink]=\"[]\"></some-comp>`);\n+  });\n+\n+  it('should warn for `[routerLink]`', async () => {\n+    writeFile('/index.ts', `\n+      import {Component} from '@angular/core';\n+\n+      @Component({\n+        templateUrl: './tmpl.html',\n+      })\n+      export class MyComp {}\n+    `);\n+\n+    writeFile('/tmpl.html', `\n+    <div>\n+      <some-comp [routerLink]></some-comp>\n+    </div>\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/tmpl.html');\n+    expect(content).toContain(`<some-comp [routerLink]=\"[]\"></some-comp>`);\n+  });\n+\n+  it('should work for many instances in a single template', async () => {\n+    writeFile('/index.ts', `\n+      import {Component} from '@angular/core';\n+\n+      @Component({\n+        templateUrl: './tmpl.html',\n+      })\n+      export class MyComp {}\n+    `);\n+\n+    writeFile('/tmpl.html', `\n+        <some-comp1 [routerLink]=\"\"></some-comp1> <some-comp2 [routerLink]=\"\"></some-comp2>\n+        <some-comp3 [routerLink]=\"\"></some-comp3> <some-comp4 [routerLink]=\"\"></some-comp4>\n+    `);\n+\n+    await runMigration();\n+    const content = tree.readContent('/tmpl.html');\n+\n+    expect(content).toContain(\n+        `<some-comp1 [routerLink]=\"[]\"></some-comp1> <some-comp2 [routerLink]=\"[]\"></some-comp2>`);\n+    expect(content).toContain(\n+        `<some-comp3 [routerLink]=\"[]\"></some-comp3> <some-comp4 [routerLink]=\"[]\"></some-comp4>`);\n+  });\n+\n+  it('should work for many references to one template', async () => {\n+    writeFile('/index.ts', `\n+      import {Component} from '@angular/core';\n+\n+      @Component({\n+        templateUrl: './tmpl.html',\n+      })\n+      export class MyComp {}\n+\n+      @Component({\n+        templateUrl: './tmpl.html',\n+      })\n+      export class MyComp2 {}\n+    `);\n+\n+    writeFile('/tmpl.html', `<some-comp1 [routerLink]=\"\"></some-comp1>`);\n+\n+    await runMigration();\n+    const content = tree.readContent('/tmpl.html');\n+\n+    expect(content).toContain(`<some-comp1 [routerLink]=\"[]\"></some-comp1>`);\n+  });\n+\n+  it('does not migrate empty attribute expression because it is equivalent to empty string, not undefined',\n+     async () => {\n+       writeFile('/index.ts', `\n+      import {Component} from '@angular/core';\n+\n+      @Component({\n+        templateUrl: './tmpl.html',\n+      })\n+      export class MyComp {}\n+\n+      @Component({\n+        templateUrl: './tmpl.html',\n+      })\n+      export class MyComp2 {}\n+    `);\n+\n+       const contents = `<some-comp1 routerLink=\"\"></some-comp1>`;\n+       writeFile('/tmpl.html', contents);\n+\n+       await runMigration();\n+       const content = tree.readContent('/tmpl.html');\n+\n+       expect(content).toEqual(contents);\n+     });\n+});"
        }
    ],
    "stats": {
        "total": 480,
        "additions": 479,
        "deletions": 1
    }
}