{
    "author": "gkalpak",
    "message": "fix(service-worker): ensure obsolete caches are always cleaned up (#42622)\n\nPreviously, the SW was only able to clean up caches for app-versions\nfound in the `Driver`'s `versions` map. If (for some reason) the\n`Driver` failed to load a valid stored state (including app-versions)\nand ended up with an [empty `versions` map][1], any obsolete versions\nwould remain in the cache storage. This case was rare but possible.\n\nThis commit makes the cache clean-up logic more robust by ensuring that\nall app-version caches are removed unless they are currently used by the\nSW to serve active clients (with the exception of the latest\napp-version, which is always retained).\n\nFixes #41728\n\n[1]: https://github.com/angular/angular/blob/9de65dbdceac3077881fbc49717f33d0f379e21d/packages/service-worker/worker/src/driver.ts#L515-L529\n\nPR Close #42622",
    "sha": "cc30dc0713d6976426114968caa1be3e782df0d4",
    "files": [
        {
            "sha": "e02c4e1d44a6cbcb70c38c710da5e0af12f8312b",
            "filename": "packages/service-worker/worker/src/app-version.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/cc30dc0713d6976426114968caa1be3e782df0d4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fapp-version.ts",
            "raw_url": "https://github.com/angular/angular/raw/cc30dc0713d6976426114968caa1be3e782df0d4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fapp-version.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fapp-version.ts?ref=cc30dc0713d6976426114968caa1be3e782df0d4",
            "patch": "@@ -284,11 +284,14 @@ export class AppVersion implements UpdateSource {\n   }\n \n   /**\n-   * Erase this application version, by cleaning up all the caches.\n+   * Return a list of the names of all caches used by this version.\n    */\n-  async cleanup(): Promise<void> {\n-    await Promise.all(this.assetGroups.map(group => group.cleanup()));\n-    await Promise.all(this.dataGroups.map(group => group.cleanup()));\n+  async getCacheNames(): Promise<string[]> {\n+    const allGroupCacheNames = await Promise.all([\n+      ...this.assetGroups.map(group => group.getCacheNames()),\n+      ...this.dataGroups.map(group => group.getCacheNames()),\n+    ]);\n+    return ([] as string[]).concat(...allGroupCacheNames);\n   }\n \n   /**"
        },
        {
            "sha": "f3beb8a4213d39f31871e36565429327b00570e1",
            "filename": "packages/service-worker/worker/src/assets.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/cc30dc0713d6976426114968caa1be3e782df0d4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts",
            "raw_url": "https://github.com/angular/angular/raw/cc30dc0713d6976426114968caa1be3e782df0d4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts?ref=cc30dc0713d6976426114968caa1be3e782df0d4",
            "patch": "@@ -9,6 +9,7 @@\n import {Adapter, Context} from './adapter';\n import {CacheState, NormalizedUrl, UpdateCacheStatus, UpdateSource, UrlMetadata} from './api';\n import {Database, Table} from './database';\n+import {CacheTable} from './db-cache';\n import {errorToString, SwCriticalError, SwUnrecoverableStateError} from './error';\n import {IdleScheduler} from './idle';\n import {AssetGroupConfig} from './manifest';\n@@ -100,13 +101,14 @@ export abstract class AssetGroup {\n   abstract initializeFully(updateFrom?: UpdateSource): Promise<void>;\n \n   /**\n-   * Clean up all the cached data for this group.\n+   * Return a list of the names of all caches used by this group.\n    */\n-  async cleanup(): Promise<void> {\n-    await Promise.all([\n-      this.cache.then(cache => this.adapter.caches.delete(cache.name)),\n-      this.metadata.then(metadata => this.db.delete(metadata.name)),\n+  async getCacheNames(): Promise<string[]> {\n+    const [cache, metadata] = await Promise.all([\n+      this.cache,\n+      this.metadata as Promise<CacheTable>,\n     ]);\n+    return [cache.name, metadata.cacheName];\n   }\n \n   /**"
        },
        {
            "sha": "ef41458a3cebf029f866dda346d9c62e1bce5e18",
            "filename": "packages/service-worker/worker/src/data.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/cc30dc0713d6976426114968caa1be3e782df0d4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdata.ts",
            "raw_url": "https://github.com/angular/angular/raw/cc30dc0713d6976426114968caa1be3e782df0d4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdata.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdata.ts?ref=cc30dc0713d6976426114968caa1be3e782df0d4",
            "patch": "@@ -8,6 +8,7 @@\n \n import {Adapter, Context} from './adapter';\n import {Database, Table} from './database';\n+import {CacheTable} from './db-cache';\n import {DebugHandler} from './debug';\n import {DataGroupConfig} from './manifest';\n import {NamedCache} from './named-cache-storage';\n@@ -554,6 +555,17 @@ export class DataGroup {\n       this.lruTable.then(table => this.db.delete(table.name)),\n     ]);\n   }\n+  /**\n+   * Return a list of the names of all caches used by this group.\n+   */\n+  async getCacheNames(): Promise<string[]> {\n+    const [cache, ageTable, lruTable] = await Promise.all([\n+      this.cache,\n+      this.ageTable as Promise<CacheTable>,\n+      this.lruTable as Promise<CacheTable>,\n+    ]);\n+    return [cache.name, ageTable.cacheName, lruTable.cacheName];\n+  }\n \n   /**\n    * Clear the state of the cache for a particular resource."
        },
        {
            "sha": "5ff1f9a678ecd508f9f36b252aa90c2edb678cea",
            "filename": "packages/service-worker/worker/src/db-cache.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/cc30dc0713d6976426114968caa1be3e782df0d4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdb-cache.ts",
            "raw_url": "https://github.com/angular/angular/raw/cc30dc0713d6976426114968caa1be3e782df0d4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdb-cache.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdb-cache.ts?ref=cc30dc0713d6976426114968caa1be3e782df0d4",
            "patch": "@@ -8,6 +8,7 @@\n \n import {Adapter} from './adapter';\n import {Database, NotFound, Table} from './database';\n+import {NamedCache} from './named-cache-storage';\n \n \n /**\n@@ -51,8 +52,10 @@ export class CacheDatabase implements Database {\n  * A `Table` backed by a `Cache`.\n  */\n export class CacheTable implements Table {\n+  cacheName = this.cache.name;\n+\n   constructor(\n-      readonly name: string, private cache: Cache, private adapter: Adapter,\n+      readonly name: string, private cache: NamedCache, private adapter: Adapter,\n       private cacheQueryOptions?: CacheQueryOptions) {}\n \n   private request(key: string): Request {"
        },
        {
            "sha": "cca26ae40888ba7bdea67da93239d1c086a47dc2",
            "filename": "packages/service-worker/worker/src/driver.ts",
            "status": "modified",
            "additions": 51,
            "deletions": 57,
            "changes": 108,
            "blob_url": "https://github.com/angular/angular/blob/cc30dc0713d6976426114968caa1be3e782df0d4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdriver.ts",
            "raw_url": "https://github.com/angular/angular/raw/cc30dc0713d6976426114968caa1be3e782df0d4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdriver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdriver.ts?ref=cc30dc0713d6976426114968caa1be3e782df0d4",
            "patch": "@@ -10,6 +10,7 @@ import {Adapter} from './adapter';\n import {CacheState, Debuggable, DebugIdleState, DebugState, DebugVersion, NormalizedUrl, UpdateCacheStatus, UpdateSource} from './api';\n import {AppVersion} from './app-version';\n import {Database} from './database';\n+import {CacheTable} from './db-cache';\n import {DebugHandler} from './debug';\n import {errorToString} from './error';\n import {IdleScheduler} from './idle';\n@@ -110,6 +111,9 @@ export class Driver implements Debuggable, UpdateSource {\n \n   debugger: DebugHandler;\n \n+  // A promise resolving to the control DB table.\n+  private controlTable = this.db.open('control');\n+\n   constructor(\n       private scope: ServiceWorkerGlobalScope, private adapter: Adapter, private db: Database) {\n     // Set up all the event handlers that the SW needs.\n@@ -517,8 +521,7 @@ export class Driver implements Debuggable, UpdateSource {\n     // the SW has run or the DB state has been wiped or is inconsistent. In that case,\n     // load a fresh copy of the manifest and reset the state from scratch.\n \n-    // Open up the DB table.\n-    const table = await this.db.open('control');\n+    const table = await this.controlTable;\n \n     // Attempt to load the needed state from the DB. If this fails, the catch {} block\n     // will populate these variables with freshly constructed values.\n@@ -568,12 +571,7 @@ export class Driver implements Debuggable, UpdateSource {\n \n     // Schedule cleaning up obsolete caches in the background.\n     this.idle.schedule('init post-load (cleanup)', async () => {\n-      try {\n-        await this.cleanupCaches();\n-      } catch (err) {\n-        // Nothing to do - cleanup failed. Just log it.\n-        this.debugger.log(err, 'cleanupCaches @ init post-load');\n-      }\n+      await this.cleanupCaches();\n     });\n \n     // Initialize the `versions` map by setting each hash to a new `AppVersion` instance\n@@ -901,8 +899,7 @@ export class Driver implements Debuggable, UpdateSource {\n    * Synchronize the existing state to the underlying database.\n    */\n   private async sync(): Promise<void> {\n-    // Open up the DB table.\n-    const table = await this.db.open('control');\n+    const table = await this.controlTable;\n \n     // Construct a serializable map of hashes to manifests.\n     const manifests: ManifestMap = {};\n@@ -931,56 +928,45 @@ export class Driver implements Debuggable, UpdateSource {\n   }\n \n   async cleanupCaches(): Promise<void> {\n-    // Query for all currently active clients, and list the client ids. This may skip\n-    // some clients in the browser back-forward cache, but not much can be done about\n-    // that.\n-    const activeClients: ClientId[] =\n-        (await this.scope.clients.matchAll()).map(client => client.id);\n-\n-    // A simple list of client ids that the SW has kept track of. Subtracting\n-    // activeClients from this list will result in the set of client ids which are\n-    // being tracked but are no longer used in the browser, and thus can be cleaned up.\n-    const knownClients: ClientId[] = Array.from(this.clientVersionMap.keys());\n-\n-    // Remove clients in the clientVersionMap that are no longer active.\n-    knownClients.filter(id => activeClients.indexOf(id) === -1)\n-        .forEach(id => this.clientVersionMap.delete(id));\n-\n-    // Next, determine the set of versions which are still used. All others can be\n-    // removed.\n-    const usedVersions = new Set<string>();\n-    this.clientVersionMap.forEach((version, _) => usedVersions.add(version));\n-\n-    // Collect all obsolete versions by filtering out used versions from the set of all versions.\n-    const obsoleteVersions =\n-        Array.from(this.versions.keys())\n-            .filter(version => !usedVersions.has(version) && version !== this.latestHash);\n-\n-    // Remove all the versions which are no longer used.\n-    await obsoleteVersions.reduce(async (previous, version) => {\n-      // Wait for the other cleanup operations to complete.\n-      await previous;\n-\n-      // Try to get past the failure of one particular version to clean up (this\n-      // shouldn't happen, but handle it just in case).\n-      try {\n-        // Get ahold of the AppVersion for this particular hash.\n-        const instance = this.versions.get(version)!;\n+    try {\n+      // Query for all currently active clients, and list the client IDs. This may skip some clients\n+      // in the browser back-forward cache, but not much can be done about that.\n+      const activeClients =\n+          new Set<ClientId>((await this.scope.clients.matchAll()).map(client => client.id));\n \n-        // Delete it from the canonical map.\n-        this.versions.delete(version);\n+      // A simple list of client IDs that the SW has kept track of. Subtracting `activeClients` from\n+      // this list will result in the set of client IDs which are being tracked but are no longer\n+      // used in the browser, and thus can be cleaned up.\n+      const knownClients: ClientId[] = Array.from(this.clientVersionMap.keys());\n \n-        // Clean it up.\n-        await instance.cleanup();\n-      } catch (err) {\n-        // Oh well? Not much that can be done here. These caches will be removed when\n-        // the SW revs its format version, which happens from time to time.\n-        this.debugger.log(err, `cleanupCaches - cleanup ${version}`);\n-      }\n-    }, Promise.resolve());\n+      // Remove clients in the `clientVersionMap` that are no longer active.\n+      const obsoleteClients = knownClients.filter(id => !activeClients.has(id));\n+      obsoleteClients.forEach(id => this.clientVersionMap.delete(id));\n \n-    // Commit all the changes to the saved state.\n-    await this.sync();\n+      // Next, determine the set of versions which are still used. All others can be removed.\n+      const usedVersions = new Set(this.clientVersionMap.values());\n+\n+      // Collect all obsolete versions by filtering out used versions from the set of all versions.\n+      const obsoleteVersions =\n+          Array.from(this.versions.keys())\n+              .filter(version => !usedVersions.has(version) && version !== this.latestHash);\n+\n+      // Remove all the versions which are no longer used.\n+      obsoleteVersions.forEach(version => this.versions.delete(version));\n+\n+      // Commit all the changes to the saved state.\n+      await this.sync();\n+\n+      // Delete all caches that are no longer needed.\n+      const allCaches = await this.adapter.caches.keys();\n+      const usedCaches = new Set(await this.getCacheNames());\n+      const cachesToDelete = allCaches.filter(name => !usedCaches.has(name));\n+      await Promise.all(cachesToDelete.map(name => this.adapter.caches.delete(name)));\n+    } catch (err) {\n+      // Oh well? Not much that can be done here. These caches will be removed on the next attempt\n+      // or when the SW revs its format version, which happens from time to time.\n+      this.debugger.log(err, 'cleanupCaches');\n+    }\n   }\n \n   /**\n@@ -1150,4 +1136,12 @@ export class Driver implements Debuggable, UpdateSource {\n       });\n     }\n   }\n+\n+  private async getCacheNames(): Promise<string[]> {\n+    const controlTable = await this.controlTable as CacheTable;\n+    const appVersions = Array.from(this.versions.values());\n+    const appVersionCacheNames =\n+        await Promise.all(appVersions.map(version => version.getCacheNames()));\n+    return [controlTable.cacheName].concat(...appVersionCacheNames);\n+  }\n }"
        },
        {
            "sha": "a23109516000638c3768c391ff94304591e6c65f",
            "filename": "packages/service-worker/worker/test/happy_spec.ts",
            "status": "modified",
            "additions": 44,
            "deletions": 4,
            "changes": 48,
            "blob_url": "https://github.com/angular/angular/blob/cc30dc0713d6976426114968caa1be3e782df0d4/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/cc30dc0713d6976426114968caa1be3e782df0d4/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts?ref=cc30dc0713d6976426114968caa1be3e782df0d4",
            "patch": "@@ -698,6 +698,42 @@ describe('Driver', () => {\n     expect(hasOriginalCaches).toEqual(false);\n   });\n \n+  it('cleans up properly when failing to load stored state', async () => {\n+    // Initialize the SW and cache the original app-version.\n+    expect(await makeRequest(scope, '/foo.txt')).toBe('this is foo');\n+    await driver.initialized;\n+\n+    // Update and cache the updated app-version.\n+    scope.updateServerState(serverUpdate);\n+    expect(await driver.checkForUpdate()).toBeTrue();\n+    expect(await makeRequest(scope, '/foo.txt', 'newClient')).toBe('this is foo v2');\n+\n+    // Verify both app-versions are stored in the cache.\n+    let cacheNames = await scope.caches.keys();\n+    let hasOriginalVersion = cacheNames.some(name => name.startsWith(`${manifestHash}:`));\n+    let hasUpdatedVersion = cacheNames.some(name => name.startsWith(`${manifestUpdateHash}:`));\n+    expect(hasOriginalVersion).withContext('Has caches for original version').toBeTrue();\n+    expect(hasUpdatedVersion).withContext('Has caches for updated version').toBeTrue();\n+\n+    // Simulate failing to load the stored state (and thus starting from an empty state).\n+    scope.caches.delete('db:control');\n+    driver = new Driver(scope, scope, new CacheDatabase(scope));\n+\n+    expect(await makeRequest(scope, '/foo.txt')).toBe('this is foo v2');\n+    await driver.initialized;\n+\n+    // Verify that the caches for the obsolete original version are cleaned up.\n+    // await driver.cleanupCaches();\n+    scope.advance(6000);\n+    await driver.idle.empty;\n+\n+    cacheNames = await scope.caches.keys();\n+    hasOriginalVersion = cacheNames.some(name => name.startsWith(`${manifestHash}:`));\n+    hasUpdatedVersion = cacheNames.some(name => name.startsWith(`${manifestUpdateHash}:`));\n+    expect(hasOriginalVersion).withContext('Has caches for original version').toBeFalse();\n+    expect(hasUpdatedVersion).withContext('Has caches for updated version').toBeTrue();\n+  });\n+\n   it('shows notifications for push notifications', async () => {\n     expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');\n     await driver.initialized;\n@@ -1481,6 +1517,7 @@ describe('Driver', () => {\n       // Another 6 seconds.\n       scope.advance(6000);\n       await driver.idle.empty;\n+      await new Promise(resolve => setTimeout(resolve));  // Wait for async operations to complete.\n       serverUpdate.assertSawRequestFor('/unhashed/a.txt');\n \n       // Now the new version of the resource should be served.\n@@ -1817,16 +1854,19 @@ describe('Driver', () => {\n         'ngsuu:active',\n         'not:ngsw:active',\n         'NgSw:StAgEd',\n-        'ngsw:/:active',\n-        'ngsw:/foo/:staged',\n+        'ngsw:/:db:control',\n+        'ngsw:/foo/:active',\n+        'ngsw:/bar/:staged',\n       ];\n       const allCacheNames = oldSwCacheNames.concat(otherCacheNames);\n \n       await Promise.all(allCacheNames.map(name => scope.caches.original.open(name)));\n-      expect(await scope.caches.original.keys()).toEqual(allCacheNames);\n+      expect(await scope.caches.original.keys())\n+          .toEqual(jasmine.arrayWithExactContents(allCacheNames));\n \n       await driver.cleanupOldSwCaches();\n-      expect(await scope.caches.original.keys()).toEqual(otherCacheNames);\n+      expect(await scope.caches.original.keys())\n+          .toEqual(jasmine.arrayWithExactContents(otherCacheNames));\n     });\n \n     it('should delete other caches even if deleting one of them fails', async () => {"
        }
    ],
    "stats": {
        "total": 196,
        "additions": 125,
        "deletions": 71
    }
}