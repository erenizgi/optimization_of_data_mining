{
    "author": "JiaLiPassion",
    "message": "test(zone.js): should invoke XHR task even onload handler throw error. (#41562)\n\nClose #41520.\n\nThis case related to the issue #41522.\n\n```\nZone.root\n  .fork({\n    name: 'xhr',\n    onHasTask(delegate, currentZone, zone, taskState) {\n      console.log('hasMacrotask', taskState.macroTask);\n      return delegate.hasTask(zone, taskState);\n    },\n  })\n  .run(() => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'https://cdnjs.cloudflare.com/ajax/libs/zone.js/0.11.4/zone.min.js');\n    xhr.addEventListener('load', () => {\n      throw new Error();\n    });\n    xhr.send();\n  });\n```\n\nzone.js invoke all `onload` event handlers before change the XHR task's state from\n`scheduled` to `notscheduled`, so if any `onload` listener throw error, the XHR task\nwlll be hang to `scheduled`, and leave the macroTask status in the zone wrongly.\n\nThis has been fixed in the previous commit, this commit add test to verify the case.\n\nPR Close #41562",
    "sha": "c3614662cb0ae5f93eb4d77f97f68fbba3cc360e",
    "files": [
        {
            "sha": "ee370c31dcf69d6c9afbad2cb19c16eb8a729f34",
            "filename": "packages/zone.js/test/browser/XMLHttpRequest.spec.ts",
            "status": "modified",
            "additions": 78,
            "deletions": 0,
            "changes": 78,
            "blob_url": "https://github.com/angular/angular/blob/c3614662cb0ae5f93eb4d77f97f68fbba3cc360e/packages%2Fzone.js%2Ftest%2Fbrowser%2FXMLHttpRequest.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c3614662cb0ae5f93eb4d77f97f68fbba3cc360e/packages%2Fzone.js%2Ftest%2Fbrowser%2FXMLHttpRequest.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Ftest%2Fbrowser%2FXMLHttpRequest.spec.ts?ref=c3614662cb0ae5f93eb4d77f97f68fbba3cc360e",
            "patch": "@@ -103,6 +103,84 @@ describe('XMLHttpRequest', function() {\n     req!.send();\n   });\n \n+  it('should run onload listeners before internal readystatechange', function(done) {\n+    const logs: string[] = [];\n+    const xhrZone = Zone.current.fork({\n+      name: 'xhr',\n+      onInvokeTask: (delegate, curr, target, task, applyThis, applyArgs) => {\n+        logs.push('invokeTask ' + task.source);\n+        return delegate.invokeTask(target, task, applyThis, applyArgs);\n+      }\n+    });\n+\n+    xhrZone.run(function() {\n+      const req = new XMLHttpRequest();\n+      req.onload = function() {\n+        logs.push('onload');\n+        (window as any)[Zone.__symbol__('setTimeout')](() => {\n+          expect(logs).toEqual([\n+            'invokeTask XMLHttpRequest.addEventListener:load', 'onload',\n+            'invokeTask XMLHttpRequest.send'\n+          ])\n+          done();\n+        });\n+      };\n+      req.open('get', '/', true);\n+      req.send();\n+    });\n+  });\n+\n+  it('should invoke xhr task even onload listener throw error', function(done) {\n+    const oriWindowError = window.onerror;\n+    window.onerror = function() {};\n+    try {\n+      const logs: string[] = [];\n+      const xhrZone = Zone.current.fork({\n+        name: 'xhr',\n+        onInvokeTask: (delegate, curr, target, task, applyThis, applyArgs) => {\n+          logs.push('invokeTask ' + task.source);\n+          return delegate.invokeTask(target, task, applyThis, applyArgs);\n+        },\n+        onHasTask: (delegate, curr, target, hasTaskState) => {\n+          if (hasTaskState.change === 'macroTask') {\n+            logs.push('hasTask ' + hasTaskState.macroTask);\n+          }\n+          return delegate.hasTask(target, hasTaskState);\n+        }\n+      });\n+\n+      xhrZone.run(function() {\n+        const req = new XMLHttpRequest();\n+        req.onload = function() {\n+          logs.push('onload');\n+          throw new Error('test');\n+        };\n+        const unhandledRejection = (e: PromiseRejectionEvent) => {\n+          logs.push(e.reason.message);\n+        };\n+        window.addEventListener('unhandledrejection', unhandledRejection);\n+        req.addEventListener('load', () => {\n+          logs.push('onload1');\n+          (window as any)[Zone.__symbol__('setTimeout')](() => {\n+            expect(logs).toEqual([\n+              'hasTask true', 'invokeTask XMLHttpRequest.addEventListener:load', 'onload',\n+              'invokeTask XMLHttpRequest.addEventListener:load', 'onload1',\n+              'invokeTask XMLHttpRequest.send', 'hasTask false',\n+              'invokeTask Window.addEventListener:unhandledrejection', 'test'\n+            ]);\n+            window.removeEventListener('unhandledrejection', unhandledRejection);\n+            window.onerror = oriWindowError;\n+            done();\n+          });\n+        });\n+        req.open('get', '/', true);\n+        req.send();\n+      });\n+    } catch (e: any) {\n+      window.onerror = oriWindowError;\n+    }\n+  });\n+\n   it('should return null when access ontimeout first time without error', function() {\n     let req: XMLHttpRequest = new XMLHttpRequest();\n     expect(req.ontimeout).toBe(null);"
        },
        {
            "sha": "3e7c6f9c2449aa2ef75cadbcff2f6d6b50ef55ca",
            "filename": "packages/zone.js/test/browser/browser.spec.ts",
            "status": "modified",
            "additions": 89,
            "deletions": 72,
            "changes": 161,
            "blob_url": "https://github.com/angular/angular/blob/c3614662cb0ae5f93eb4d77f97f68fbba3cc360e/packages%2Fzone.js%2Ftest%2Fbrowser%2Fbrowser.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c3614662cb0ae5f93eb4d77f97f68fbba3cc360e/packages%2Fzone.js%2Ftest%2Fbrowser%2Fbrowser.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Ftest%2Fbrowser%2Fbrowser.spec.ts?ref=c3614662cb0ae5f93eb4d77f97f68fbba3cc360e",
            "patch": "@@ -2493,92 +2493,109 @@ describe('Zone', function() {\n \n       it('should be able to continue to invoke remaining listeners even some listener throw error',\n          function(done: DoneFn) {\n-           let logs: string[] = [];\n-           const listener1 = function() {\n-             logs.push('listener1');\n-           };\n-           const listener2 = function() {\n-             throw new Error('test1');\n-           };\n-           const listener3 = function() {\n-             throw new Error('test2');\n-           };\n-           const listener4 = {\n-             handleEvent: function() {\n-               logs.push('listener2');\n-             }\n-           };\n+           // override global.onerror to prevent jasmine report error\n+           let oriWindowOnError = window.onerror;\n+           window.onerror = function() {};\n+           try {\n+             let logs: string[] = [];\n+             const listener1 = function() {\n+               logs.push('listener1');\n+             };\n+             const listener2 = function() {\n+               throw new Error('test1');\n+             };\n+             const listener3 = function() {\n+               throw new Error('test2');\n+             };\n+             const listener4 = {\n+               handleEvent: function() {\n+                 logs.push('listener2');\n+               }\n+             };\n \n-           button.addEventListener('click', listener1);\n-           button.addEventListener('click', listener2);\n-           button.addEventListener('click', listener3);\n-           button.addEventListener('click', listener4);\n+             button.addEventListener('click', listener1);\n+             button.addEventListener('click', listener2);\n+             button.addEventListener('click', listener3);\n+             button.addEventListener('click', listener4);\n \n-           const mouseEvent = document.createEvent('MouseEvent');\n-           mouseEvent.initEvent('click', true, true);\n+             const mouseEvent = document.createEvent('MouseEvent');\n+             mouseEvent.initEvent('click', true, true);\n \n-           const unhandledRejection = (e: PromiseRejectionEvent) => {\n-             logs.push(e.reason.message);\n-           };\n-           window.addEventListener('unhandledrejection', unhandledRejection);\n+             const unhandledRejection = (e: PromiseRejectionEvent) => {\n+               logs.push(e.reason.message);\n+             };\n+             window.addEventListener('unhandledrejection', unhandledRejection);\n \n-           button.dispatchEvent(mouseEvent);\n-           expect(logs).toEqual(['listener1', 'listener2']);\n+             button.dispatchEvent(mouseEvent);\n+             expect(logs).toEqual(['listener1', 'listener2']);\n \n-           setTimeout(() => {\n-             expect(logs).toEqual(['listener1', 'listener2', 'test1', 'test2']);\n-             window.removeEventListener('unhandledrejection', unhandledRejection);\n-             done()\n-           });\n+             setTimeout(() => {\n+               expect(logs).toEqual(['listener1', 'listener2', 'test1', 'test2']);\n+               window.removeEventListener('unhandledrejection', unhandledRejection);\n+               window.onerror = oriWindowOnError;\n+               done()\n+             });\n+           } catch (e: any) {\n+             window.onerror = oriWindowOnError;\n+           }\n          });\n \n       it('should be able to continue to invoke remaining listeners even some listener throw error in the different zones',\n          function(done: DoneFn) {\n-           let logs: string[] = [];\n-           const zone1 = Zone.current.fork({\n-             name: 'zone1',\n-             onHandleError: (delegate, curr, target, error) => {\n-               logs.push(error.message);\n-               return false;\n-             }\n-           });\n-           const listener1 = function() {\n-             logs.push('listener1');\n-           };\n-           const listener2 = function() {\n-             throw new Error('test1');\n-           };\n-           const listener3 = function() {\n-             throw new Error('test2');\n-           };\n-           const listener4 = {\n-             handleEvent: function() {\n-               logs.push('listener2');\n-             }\n-           };\n+           // override global.onerror to prevent jasmine report error\n+           let oriWindowOnError = window.onerror;\n+           window.onerror = function() {};\n+           try {\n+             let logs: string[] = [];\n+             const zone1 = Zone.current.fork({\n+               name: 'zone1',\n+               onHandleError: (delegate, curr, target, error) => {\n+                 logs.push(error.message);\n+                 return false;\n+               }\n+             });\n+             const listener1 = function() {\n+               logs.push('listener1');\n+             };\n+             const listener2 = function() {\n+               throw new Error('test1');\n+             };\n+             const listener3 = function() {\n+               throw new Error('test2');\n+             };\n+             const listener4 = {\n+               handleEvent: function() {\n+                 logs.push('listener2');\n+               }\n+             };\n \n-           button.addEventListener('click', listener1);\n-           zone1.run(() => {\n-             button.addEventListener('click', listener2);\n-           });\n-           button.addEventListener('click', listener3);\n-           button.addEventListener('click', listener4);\n+             button.addEventListener('click', listener1);\n+             zone1.run(() => {\n+               button.addEventListener('click', listener2);\n+             });\n+             button.addEventListener('click', listener3);\n+             button.addEventListener('click', listener4);\n \n-           const mouseEvent = document.createEvent('MouseEvent');\n-           mouseEvent.initEvent('click', true, true);\n+             const mouseEvent = document.createEvent('MouseEvent');\n+             mouseEvent.initEvent('click', true, true);\n \n-           const unhandledRejection = (e: PromiseRejectionEvent) => {\n-             logs.push(e.reason.message);\n-           };\n-           window.addEventListener('unhandledrejection', unhandledRejection);\n+             const unhandledRejection = (e: PromiseRejectionEvent) => {\n+               logs.push(e.reason.message);\n+             };\n+             window.addEventListener('unhandledrejection', unhandledRejection);\n \n-           button.dispatchEvent(mouseEvent);\n-           expect(logs).toEqual(['listener1', 'test1', 'listener2']);\n+             button.dispatchEvent(mouseEvent);\n+             expect(logs).toEqual(['listener1', 'test1', 'listener2']);\n \n-           setTimeout(() => {\n-             expect(logs).toEqual(['listener1', 'test1', 'listener2', 'test2']);\n-             done()\n-           });\n+             setTimeout(() => {\n+               expect(logs).toEqual(['listener1', 'test1', 'listener2', 'test2']);\n+               window.removeEventListener('unhandledrejection', unhandledRejection);\n+               window.onerror = oriWindowOnError;\n+               done()\n+             });\n+           } catch (e: any) {\n+             window.onerror = oriWindowOnError;\n+           }\n          });\n     });\n "
        }
    ],
    "stats": {
        "total": 239,
        "additions": 167,
        "deletions": 72
    }
}