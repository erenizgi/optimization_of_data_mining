{
    "author": "atscott",
    "message": "feat(language-service): Add \"find references\" capability to Ivy integrated LS (#39768)\n\nThis commit adds \"find references\" functionality to the Ivy integrated\nlanguage service. The basic approach is as follows:\n\n1. Generate shims for all files to ensure we find references in shims\nthroughout the entire program\n2. Determine if the position for the reference request is within a\ntemplate.\n  * Yes, it is in a template: Find which node in the template AST the\n  position refers to. Then find the position in the shim file for that\n  template node. Pass the shim file and position in the shim file along\n  to step 3.\n  * No, the request for references was made outside a template: Forward\n  the file and position to step 3.\n3. (`getReferencesAtTypescriptPosition`): Call the native TypeScript LS\n`getReferencesAtPosition`. For each reference that is in a shim file, map those\nback to a template location, otherwise return it as-is.\n\nPR Close #39768",
    "sha": "06a782a2e38acb6f5a3433a88be27b47c45445bf",
    "files": [
        {
            "sha": "5d49dd7a8a0e89d2946ee798695cc6a091275223",
            "filename": "packages/compiler-cli/src/ngtsc/testing/fake_common/index.ts",
            "status": "modified",
            "additions": 22,
            "deletions": 4,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftesting%2Ffake_common%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftesting%2Ffake_common%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftesting%2Ffake_common%2Findex.ts?ref=06a782a2e38acb6f5a3433a88be27b47c45445bf",
            "patch": "@@ -11,6 +11,12 @@ import {NgIterable, TemplateRef, ɵɵDirectiveDefWithMeta, ɵɵNgModuleDefWithMe\n export interface NgForOfContext<T, U extends NgIterable<T>> {\n   $implicit: T;\n   ngForOf: U;\n+  odd: boolean;\n+  event: boolean;\n+  first: boolean;\n+  last: boolean;\n+  count: number;\n+  index: number;\n }\n \n export interface TrackByFunction<T> {\n@@ -54,6 +60,19 @@ export declare class NgIf<T = unknown> {\n       ctx is NgIfContext<Exclude<T, false|0|''|null|undefined>>;\n }\n \n+export declare class NgTemplateOutlet {\n+  ngTemplateOutlet: TemplateRef<any>|null;\n+  ngTemplateOutletContext: Object|null;\n+\n+  static ɵdir: ɵɵDirectiveDefWithMeta < NgTemplateOutlet, '[ngTemplateOutlet]', never, {\n+    'ngTemplateOutlet': 'ngTemplateOutlet';\n+    'ngTemplateOutletContext': 'ngTemplateOutletContext';\n+  }\n+  , {}, never > ;\n+  static ngTemplateContextGuard<T>(dir: NgIf<T>, ctx: any):\n+      ctx is NgIfContext<Exclude<T, false|0|''|null|undefined>>;\n+}\n+\n export declare class DatePipe {\n   transform(value: Date|string|number, format?: string, timezone?: string, locale?: string): string\n       |null;\n@@ -65,8 +84,7 @@ export declare class DatePipe {\n }\n \n export declare class CommonModule {\n-  static ɵmod:\n-      ɵɵNgModuleDefWithMeta<CommonModule, [typeof NgForOf, typeof NgIf, typeof DatePipe], never, [\n-        typeof NgForOf, typeof NgIf, typeof DatePipe\n-      ]>;\n+  static ɵmod: ɵɵNgModuleDefWithMeta<\n+      CommonModule, [typeof NgForOf, typeof NgIf, typeof DatePipe, typeof NgTemplateOutlet], never,\n+      [typeof NgForOf, typeof NgIf, typeof DatePipe, typeof NgTemplateOutlet]>;\n }"
        },
        {
            "sha": "25ce5e7c5ee6d6cee1e8e51d4617280d6a064d41",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=06a782a2e38acb6f5a3433a88be27b47c45445bf",
            "patch": "@@ -80,6 +80,13 @@ export interface TemplateTypeChecker {\n    */\n   getDiagnosticsForComponent(component: ts.ClassDeclaration): ts.Diagnostic[];\n \n+  /**\n+   * Ensures shims for the whole program are generated. This type of operation would be required by\n+   * operations like \"find references\" and \"refactor/rename\" because references may appear in type\n+   * check blocks generated from templates anywhere in the program.\n+   */\n+  generateAllTypeCheckBlocks(): void;\n+\n   /**\n    * Retrieve the top-level node representing the TCB for the given component.\n    *"
        },
        {
            "sha": "ca5cb27478a1eb8c16afc1a59ae42fcd7d6a8ee1",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=06a782a2e38acb6f5a3433a88be27b47c45445bf",
            "patch": "@@ -197,6 +197,10 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     return getTemplateMapping(shimSf, positionInShimFile, fileRecord.sourceManager);\n   }\n \n+  generateAllTypeCheckBlocks() {\n+    this.ensureAllShimsForAllFiles();\n+  }\n+\n   /**\n    * Retrieve type-checking diagnostics from the given `ts.SourceFile` using the most recent\n    * type-checking program."
        },
        {
            "sha": "b7d56a00a557dc3e11e0fc58f2c57b8db578a153",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/tcb_util.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftcb_util.ts",
            "raw_url": "https://github.com/angular/angular/raw/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftcb_util.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftcb_util.ts?ref=06a782a2e38acb6f5a3433a88be27b47c45445bf",
            "patch": "@@ -67,6 +67,8 @@ export function getTemplateMapping(\n   if (span === null) {\n     return null;\n   }\n+  // TODO(atscott): Consider adding a context span by walking up from `node` until we get a\n+  // different span.\n   return {sourceLocation, templateSourceMapping: mapping, span};\n }\n "
        },
        {
            "sha": "b1612cf80a7d408152277e1796e5d7ff75d86b59",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=06a782a2e38acb6f5a3433a88be27b47c45445bf",
            "patch": "@@ -10,6 +10,7 @@ import {CompilerOptions, ConfigurationHost, readConfiguration} from '@angular/co\n import {absoluteFromSourceFile, AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n import {TypeCheckShimGenerator} from '@angular/compiler-cli/src/ngtsc/typecheck';\n import {OptimizeFor, TypeCheckingProgramStrategy} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import {ReferenceBuilder} from '@angular/language-service/ivy/references';\n import * as ts from 'typescript/lib/tsserverlibrary';\n \n import {LanguageServiceAdapter, LSParseConfigHost} from './adapters';\n@@ -80,7 +81,6 @@ export class LanguageService {\n   }\n \n   getQuickInfoAtPosition(fileName: string, position: number): ts.QuickInfo|undefined {\n-    const program = this.strategy.getProgram();\n     const compiler = this.compilerFactory.getOrCreateWithChangedFile(fileName);\n     const templateInfo = getTemplateInfoAtPosition(fileName, position, compiler);\n     if (templateInfo === undefined) {\n@@ -97,6 +97,14 @@ export class LanguageService {\n     return results;\n   }\n \n+  getReferencesAtPosition(fileName: string, position: number): ts.ReferenceEntry[]|undefined {\n+    const compiler = this.compilerFactory.getOrCreateWithChangedFile(fileName);\n+    const results =\n+        new ReferenceBuilder(this.strategy, this.tsLS, compiler).get(fileName, position);\n+    this.compilerFactory.registerLastKnownProgram();\n+    return results;\n+  }\n+\n   private watchConfigFile(project: ts.server.Project) {\n     // TODO: Check the case when the project is disposed. An InferredProject\n     // could be disposed when a tsconfig.json is added to the workspace,"
        },
        {
            "sha": "2fc51700234ea9305f3cd9a819b4ee7b890b4939",
            "filename": "packages/language-service/ivy/references.ts",
            "status": "added",
            "additions": 152,
            "deletions": 0,
            "changes": 152,
            "blob_url": "https://github.com/angular/angular/blob/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Freferences.ts",
            "raw_url": "https://github.com/angular/angular/raw/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Freferences.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Freferences.ts?ref=06a782a2e38acb6f5a3433a88be27b47c45445bf",
            "patch": "@@ -0,0 +1,152 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {TmplAstVariable} from '@angular/compiler';\n+import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n+import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n+import {SymbolKind, TemplateTypeChecker, TypeCheckingProgramStrategy} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import * as ts from 'typescript';\n+\n+import {getTargetAtPosition} from './template_target';\n+import {getTemplateInfoAtPosition, isWithin, TemplateInfo, toTextSpan} from './utils';\n+\n+export class ReferenceBuilder {\n+  private readonly ttc = this.compiler.getTemplateTypeChecker();\n+\n+  constructor(\n+      private readonly strategy: TypeCheckingProgramStrategy,\n+      private readonly tsLS: ts.LanguageService, private readonly compiler: NgCompiler) {}\n+\n+  get(filePath: string, position: number): ts.ReferenceEntry[]|undefined {\n+    this.ttc.generateAllTypeCheckBlocks();\n+    const templateInfo = getTemplateInfoAtPosition(filePath, position, this.compiler);\n+    return templateInfo !== undefined ?\n+        this.getReferencesAtTemplatePosition(templateInfo, position) :\n+        this.getReferencesAtTypescriptPosition(filePath, position);\n+  }\n+\n+  private getReferencesAtTemplatePosition({template, component}: TemplateInfo, position: number):\n+      ts.ReferenceEntry[]|undefined {\n+    // Find the AST node in the template at the position.\n+    const positionDetails = getTargetAtPosition(template, position);\n+    if (positionDetails === null) {\n+      return undefined;\n+    }\n+\n+    // Get the information about the TCB at the template position.\n+    const symbol = this.ttc.getSymbolOfNode(positionDetails.node, component);\n+    if (symbol === null) {\n+      return undefined;\n+    }\n+    switch (symbol.kind) {\n+      case SymbolKind.Element:\n+      case SymbolKind.Directive:\n+      case SymbolKind.Template:\n+      case SymbolKind.DomBinding:\n+        // References to elements, templates, and directives will be through template references\n+        // (#ref). They shouldn't be used directly for a Language Service reference request.\n+        //\n+        // Dom bindings aren't currently type-checked (see `checkTypeOfDomBindings`) so they don't\n+        // have a shim location and so we cannot find references for them.\n+        //\n+        // TODO(atscott): Consider finding references for elements that are components as well as\n+        // when the position is on an element attribute that directly maps to a directive.\n+        return undefined;\n+      case SymbolKind.Reference: {\n+        const {shimPath, positionInShimFile} = symbol.referenceVarLocation;\n+        return this.getReferencesAtTypescriptPosition(shimPath, positionInShimFile);\n+      }\n+      case SymbolKind.Variable: {\n+        const {positionInShimFile: initializerPosition, shimPath} = symbol.initializerLocation;\n+        const localVarPosition = symbol.localVarLocation.positionInShimFile;\n+        const templateNode = positionDetails.node;\n+\n+        if ((templateNode instanceof TmplAstVariable)) {\n+          if (templateNode.valueSpan !== undefined && isWithin(position, templateNode.valueSpan)) {\n+            // In the valueSpan of the variable, we want to get the reference of the initializer.\n+            return this.getReferencesAtTypescriptPosition(shimPath, initializerPosition);\n+          } else if (isWithin(position, templateNode.keySpan)) {\n+            // In the keySpan of the variable, we want to get the reference of the local variable.\n+            return this.getReferencesAtTypescriptPosition(shimPath, localVarPosition);\n+          } else {\n+            return undefined;\n+          }\n+        }\n+\n+        // If the templateNode is not the `TmplAstVariable`, it must be a usage of the variable\n+        // somewhere in the template.\n+        return this.getReferencesAtTypescriptPosition(shimPath, localVarPosition);\n+      }\n+      case SymbolKind.Input:\n+      case SymbolKind.Output: {\n+        // TODO(atscott): Determine how to handle when the binding maps to several inputs/outputs\n+        const {shimPath, positionInShimFile} = symbol.bindings[0].shimLocation;\n+        return this.getReferencesAtTypescriptPosition(shimPath, positionInShimFile);\n+      }\n+      case SymbolKind.Expression: {\n+        const {shimPath, positionInShimFile} = symbol.shimLocation;\n+        return this.getReferencesAtTypescriptPosition(shimPath, positionInShimFile);\n+      }\n+    }\n+  }\n+\n+  private getReferencesAtTypescriptPosition(fileName: string, position: number):\n+      ts.ReferenceEntry[]|undefined {\n+    const refs = this.tsLS.getReferencesAtPosition(fileName, position);\n+    if (refs === undefined) {\n+      return undefined;\n+    }\n+\n+    const entries: ts.ReferenceEntry[] = [];\n+    for (const ref of refs) {\n+      // TODO(atscott): Determine if a file is a shim file in a more robust way and make the API\n+      // available in an appropriate location.\n+      if (ref.fileName.endsWith('ngtypecheck.ts')) {\n+        const entry = convertToTemplateReferenceEntry(ref, this.ttc);\n+        if (entry !== null) {\n+          entries.push(entry);\n+        }\n+      } else {\n+        entries.push(ref);\n+      }\n+    }\n+    return entries;\n+  }\n+}\n+\n+function convertToTemplateReferenceEntry(\n+    shimReferenceEntry: ts.ReferenceEntry,\n+    templateTypeChecker: TemplateTypeChecker): ts.ReferenceEntry|null {\n+  // TODO(atscott): Determine how to consistently resolve paths. i.e. with the project serverHost or\n+  // LSParseConfigHost in the adapter. We should have a better defined way to normalize paths.\n+  const mapping = templateTypeChecker.getTemplateMappingAtShimLocation({\n+    shimPath: absoluteFrom(shimReferenceEntry.fileName),\n+    positionInShimFile: shimReferenceEntry.textSpan.start,\n+  });\n+  if (mapping === null) {\n+    return null;\n+  }\n+  const {templateSourceMapping, span} = mapping;\n+\n+  let templateUrl: AbsoluteFsPath;\n+  if (templateSourceMapping.type === 'direct') {\n+    templateUrl = absoluteFromSourceFile(templateSourceMapping.node.getSourceFile());\n+  } else if (templateSourceMapping.type === 'external') {\n+    templateUrl = absoluteFrom(templateSourceMapping.templateUrl);\n+  } else {\n+    // This includes indirect mappings, which are difficult to map directly to the code location.\n+    // Diagnostics similarly return a synthetic template string for this case rather than a real\n+    // location.\n+    return null;\n+  }\n+\n+  return {\n+    ...shimReferenceEntry,\n+    fileName: templateUrl,\n+    textSpan: toTextSpan(span),\n+  };\n+}"
        },
        {
            "sha": "e39180919fd73e6bc8b289022a19666ab24dc422",
            "filename": "packages/language-service/ivy/template_target.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 16,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "raw_url": "https://github.com/angular/angular/raw/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts?ref=06a782a2e38acb6f5a3433a88be27b47c45445bf",
            "patch": "@@ -6,11 +6,10 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AbsoluteSourceSpan, ParseSourceSpan} from '@angular/compiler';\n import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n \n-import {isTemplateNode, isTemplateNodeWithKeyAndValue} from './utils';\n+import {isTemplateNode, isTemplateNodeWithKeyAndValue, isWithin} from './utils';\n \n /**\n  * Contextual information for a target position within the template.\n@@ -238,17 +237,3 @@ function getSpanIncludingEndTag(ast: t.Node) {\n   }\n   return result;\n }\n-\n-function isWithin(position: number, span: AbsoluteSourceSpan|ParseSourceSpan): boolean {\n-  let start: number, end: number;\n-  if (span instanceof ParseSourceSpan) {\n-    start = span.start.offset;\n-    end = span.end.offset;\n-  } else {\n-    start = span.start;\n-    end = span.end;\n-  }\n-  // Note both start and end are inclusive because we want to match conditions\n-  // like ¦start and end¦ where ¦ is the cursor.\n-  return start <= position && position <= end;\n-}"
        },
        {
            "sha": "aa7a1e011be332d67a5c3a7abe2b25df98fdf9ba",
            "filename": "packages/language-service/ivy/test/env.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 4,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Ftest%2Fenv.ts",
            "raw_url": "https://github.com/angular/angular/raw/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Ftest%2Fenv.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fenv.ts?ref=06a782a2e38acb6f5a3433a88be27b47c45445bf",
            "patch": "@@ -46,8 +46,17 @@ function writeTsconfig(\n \n export type TestableOptions = StrictTemplateOptions;\n \n+export interface TemplateOverwriteResult {\n+  cursor: number;\n+  nodes: TmplAstNode[];\n+  component: ts.ClassDeclaration;\n+  text: string;\n+}\n+\n export class LanguageServiceTestEnvironment {\n-  private constructor(private tsLS: ts.LanguageService, readonly ngLS: LanguageService) {}\n+  private constructor(\n+      private tsLS: ts.LanguageService, readonly ngLS: LanguageService,\n+      readonly host: MockServerHost) {}\n \n   static setup(files: TestFile[], options: TestableOptions = {}): LanguageServiceTestEnvironment {\n     const fs = getFileSystem();\n@@ -97,7 +106,7 @@ export class LanguageServiceTestEnvironment {\n     const tsLS = project.getLanguageService();\n \n     const ngLS = new LanguageService(project, tsLS);\n-    return new LanguageServiceTestEnvironment(tsLS, ngLS);\n+    return new LanguageServiceTestEnvironment(tsLS, ngLS, host);\n   }\n \n   getClass(fileName: AbsoluteFsPath, className: string): ts.ClassDeclaration {\n@@ -110,7 +119,7 @@ export class LanguageServiceTestEnvironment {\n   }\n \n   overrideTemplateWithCursor(fileName: AbsoluteFsPath, className: string, contents: string):\n-      {cursor: number, nodes: TmplAstNode[], component: ts.ClassDeclaration, text: string} {\n+      TemplateOverwriteResult {\n     const program = this.tsLS.getProgram();\n     if (program === undefined) {\n       throw new Error(`Expected to get a ts.Program`);\n@@ -206,7 +215,7 @@ function getClassOrError(sf: ts.SourceFile, name: string): ts.ClassDeclaration {\n   throw new Error(`Class ${name} not found in file: ${sf.fileName}: ${sf.text}`);\n }\n \n-function extractCursorInfo(textWithCursor: string): {cursor: number, text: string} {\n+export function extractCursorInfo(textWithCursor: string): {cursor: number, text: string} {\n   const cursor = textWithCursor.indexOf('¦');\n   if (cursor === -1) {\n     throw new Error(`Expected to find cursor symbol '¦'`);"
        },
        {
            "sha": "249f305cb9f277ca39894b5a30d38a7853ca276f",
            "filename": "packages/language-service/ivy/test/references_spec.ts",
            "status": "added",
            "additions": 758,
            "deletions": 0,
            "changes": 758,
            "blob_url": "https://github.com/angular/angular/blob/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Ftest%2Freferences_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Ftest%2Freferences_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Freferences_spec.ts?ref=06a782a2e38acb6f5a3433a88be27b47c45445bf",
            "patch": "@@ -0,0 +1,758 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {absoluteFrom, absoluteFrom as _} from '@angular/compiler-cli/src/ngtsc/file_system';\n+import {initMockFileSystem, TestFile} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+import * as ts from 'typescript/lib/tsserverlibrary';\n+\n+import {extractCursorInfo, LanguageServiceTestEnvironment} from './env';\n+import {getText} from './test_utils';\n+\n+describe('find references', () => {\n+  let env: LanguageServiceTestEnvironment;\n+\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  it('gets component member references from TS file', () => {\n+    const {text, cursor} = extractCursorInfo(`\n+          import {Component} from '@angular/core';\n+\n+          @Component({templateUrl: './app.html'})\n+          export class AppCmp {\n+            myP¦rop!: string;\n+          }`);\n+    const appFile = {name: _('/app.ts'), contents: text};\n+    const templateFile = {name: _('/app.html'), contents: '{{myProp}}'};\n+    createModuleWithDeclarations([appFile], [templateFile]);\n+    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+    expect(refs.length).toBe(2);\n+    assertFileNames(refs, ['app.html', 'app.ts']);\n+    assertTextSpans(refs, ['myProp']);\n+  });\n+\n+  it('gets component member references from TS file and inline template', () => {\n+    const {text, cursor} = extractCursorInfo(`\n+          import {Component} from '@angular/core';\n+\n+          @Component({template: '{{myProp}}'})\n+          export class AppCmp {\n+            myP¦rop!: string;\n+          }`);\n+    const appFile = {name: _('/app.ts'), contents: text};\n+    createModuleWithDeclarations([appFile]);\n+    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+    expect(refs.length).toBe(2);\n+    assertFileNames(refs, ['app.ts']);\n+    assertTextSpans(refs, ['myProp']);\n+  });\n+\n+  it('gets component member references from template', () => {\n+    const appFile = {\n+      name: _('/app.ts'),\n+      contents: `\n+          import {Component} from '@angular/core';\n+\n+          @Component({templateUrl: './app.html'})\n+          export class AppCmp {\n+            myProp = '';\n+          }`,\n+    };\n+    const {text, cursor} = extractCursorInfo('{{myP¦rop}}');\n+    const templateFile = {name: _('/app.html'), contents: text};\n+    createModuleWithDeclarations([appFile], [templateFile]);\n+    const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+    expect(refs.length).toBe(2);\n+    assertFileNames(refs, ['app.html', 'app.ts']);\n+    assertTextSpans(refs, ['myProp']);\n+  });\n+\n+  it('should work for method calls', () => {\n+    const {text, cursor} = extractCursorInfo(`\n+          import {Component} from '@angular/core';\n+\n+          @Component({template: '<div (click)=\"set¦Title(2)\"></div>'})\n+          export class AppCmp {\n+            setTitle(s: number) {}\n+          }`);\n+    const appFile = {name: _('/app.ts'), contents: text};\n+    createModuleWithDeclarations([appFile]);\n+    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+    expect(refs.length).toBe(2);\n+\n+    assertFileNames(refs, ['app.ts']);\n+    assertTextSpans(refs, ['setTitle']);\n+  });\n+\n+  it('should work for method call arguments', () => {\n+    const {text, cursor} = extractCursorInfo(`\n+          import {Component} from '@angular/core';\n+\n+          @Component({template: '<div (click)=\"setTitle(ti¦tle)\"></div>'})\n+          export class AppCmp {\n+            title = '';\n+            setTitle(s: string) {}\n+          }`);\n+    const appFile = {name: _('/app.ts'), contents: text};\n+    createModuleWithDeclarations([appFile]);\n+    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+    expect(refs.length).toBe(2);\n+\n+    assertTextSpans(refs, ['title']);\n+  });\n+\n+  it('should work for property writes', () => {\n+    const appFile = {\n+      name: _('/app.ts'),\n+      contents: `\n+          import {Component} from '@angular/core';\n+\n+          @Component({templateUrl: './app.html' })\n+          export class AppCmp {\n+            title = '';\n+          }`,\n+    };\n+    const templateFileWithCursor = `<div (click)=\"ti¦tle = 'newtitle'\"></div>`;\n+    const {text, cursor} = extractCursorInfo(templateFileWithCursor);\n+    const templateFile = {name: _('/app.html'), contents: text};\n+    createModuleWithDeclarations([appFile], [templateFile]);\n+    const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+    expect(refs.length).toBe(2);\n+\n+    assertFileNames(refs, ['app.ts', 'app.html']);\n+    assertTextSpans(refs, ['title']);\n+  });\n+\n+  it('should work for RHS of property writes', () => {\n+    const {text, cursor} = extractCursorInfo(`\n+          import {Component} from '@angular/core';\n+\n+          @Component({template: '<div (click)=\"title = otherT¦itle\"></div>' })\n+          export class AppCmp {\n+            title = '';\n+            otherTitle = '';\n+          }`);\n+    const appFile = {\n+      name: _('/app.ts'),\n+      contents: text,\n+    };\n+    createModuleWithDeclarations([appFile]);\n+    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+    expect(refs.length).toBe(2);\n+\n+    assertFileNames(refs, ['app.ts']);\n+    assertTextSpans(refs, ['otherTitle']);\n+  });\n+\n+  it('should work for keyed reads', () => {\n+    const {text, cursor} = extractCursorInfo(`\n+          import {Component} from '@angular/core';\n+\n+          @Component({template: '{{hero[\"na¦me\"]}}' })\n+          export class AppCmp {\n+            hero: {name: string} = {name: 'Superman'};\n+          }`);\n+    const appFile = {\n+      name: _('/app.ts'),\n+      contents: text,\n+    };\n+    createModuleWithDeclarations([appFile]);\n+    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+    // 3 references: the type definition, the value assignment, and the read in the template\n+    expect(refs.length).toBe(3);\n+\n+    assertFileNames(refs, ['app.ts']);\n+    // TODO(atscott): investigate if we can make the template keyed read be just the 'name' part.\n+    // The TypeScript implementation specifically adjusts the span to accommodate string literals:\n+    // https://sourcegraph.com/github.com/microsoft/TypeScript@d5779c75d3dd19565b60b9e2960b8aac36d4d635/-/blob/src/services/findAllReferences.ts#L508-512\n+    // One possible solution would be to extend `FullTemplateMapping` to include the matched TCB\n+    // node and then do the same thing that TS does: if the node is a string, adjust the span.\n+    assertTextSpans(refs, ['name', '\"name\"']);\n+  });\n+\n+  it('should work for keyed writes', () => {\n+    const appFile = {\n+      name: _('/app.ts'),\n+      contents: `\n+          import {Component} from '@angular/core';\n+\n+          @Component({templateUrl: './app.html' })\n+          export class AppCmp {\n+            hero: {name: string} = {name: 'Superman'};\n+            batman = 'batman';\n+          }`,\n+    };\n+    const templateFileWithCursor = `<div (click)=\"hero['name'] = bat¦man\"></div>`;\n+    const {text, cursor} = extractCursorInfo(templateFileWithCursor);\n+    const templateFile = {name: _('/app.html'), contents: text};\n+    createModuleWithDeclarations([appFile], [templateFile]);\n+    const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+    expect(refs.length).toBe(2);\n+\n+    assertFileNames(refs, ['app.ts', 'app.html']);\n+    assertTextSpans(refs, ['batman']);\n+  });\n+\n+  describe('references', () => {\n+    it('should work for element references', () => {\n+      const {text, cursor} = extractCursorInfo(`\n+          import {Component} from '@angular/core';\n+\n+          @Component({template: '<input #myInput /> {{ myIn¦put.value }}'})\n+          export class AppCmp {\n+            title = '';\n+          }`);\n+      const appFile = {name: _('/app.ts'), contents: text};\n+      createModuleWithDeclarations([appFile]);\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toBe(2);\n+      assertTextSpans(refs, ['myInput']);\n+\n+      const originalRefs = env.ngLS.getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      // Get the declaration by finding the reference that appears first in the template\n+      originalRefs.sort((a, b) => a.textSpan.start - b.textSpan.start);\n+      expect(originalRefs[0].isDefinition).toBe(true);\n+    });\n+\n+    it('should work for template references', () => {\n+      const templateWithCursor = `\n+              <ng-template #myTemplate >bla</ng-template>\n+              <ng-container [ngTemplateOutlet]=\"myTem¦plate\"></ng-container>`;\n+      const appFile = {\n+        name: _('/app.ts'),\n+        contents: `\n+          import {Component} from '@angular/core';\n+\n+          @Component({templateUrl: './app.html'})\n+          export class AppCmp {\n+            title = '';\n+          }`,\n+      };\n+      const {text, cursor} = extractCursorInfo(templateWithCursor);\n+      const templateFile = {name: _('/app.html'), contents: text};\n+      createModuleWithDeclarations([appFile], [templateFile]);\n+      const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+      expect(refs.length).toBe(2);\n+      assertTextSpans(refs, ['myTemplate']);\n+      assertFileNames(refs, ['app.html']);\n+\n+      const originalRefs = env.ngLS.getReferencesAtPosition(_('/app.html'), cursor)!;\n+      // Get the declaration by finding the reference that appears first in the template\n+      originalRefs.sort((a, b) => a.textSpan.start - b.textSpan.start);\n+      expect(originalRefs[0].isDefinition).toBe(true);\n+    });\n+\n+    describe('directive references', () => {\n+      let appFile: TestFile;\n+      let dirFile: TestFile;\n+\n+      beforeEach(() => {\n+        const dirFileContents = `\n+            import {Directive} from '@angular/core';\n+\n+            @Directive({selector: '[dir]', exportAs: 'myDir'})\n+            export class Dir {\n+              dirValue!: string;\n+              doSomething() {}\n+            }`;\n+        const appFileContents = `\n+            import {Component} from '@angular/core';\n+\n+            @Component({templateUrl: './app.html'})\n+            export class AppCmp {}`;\n+        appFile = {name: _('/app.ts'), contents: appFileContents};\n+        dirFile = {name: _('/dir.ts'), contents: dirFileContents};\n+      });\n+\n+      it('should work for usage of reference in template', () => {\n+        const templateWithCursor = '<div [dir] #dirRef=\"myDir\"></div> {{ dirR¦ef }}';\n+        const {text, cursor} = extractCursorInfo(templateWithCursor);\n+        const templateFile = {name: _('/app.html'), contents: text};\n+        createModuleWithDeclarations([appFile, dirFile], [templateFile]);\n+        const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+        expect(refs.length).toBe(2);\n+        assertFileNames(refs, ['app.html']);\n+        assertTextSpans(refs, ['dirRef']);\n+      });\n+\n+      it('should work for prop reads of directive references', () => {\n+        const fileWithCursor = '<div [dir] #dirRef=\"myDir\"></div> {{ dirRef.dirV¦alue }}';\n+        const {text, cursor} = extractCursorInfo(fileWithCursor);\n+        const templateFile = {name: _('/app.html'), contents: text};\n+        createModuleWithDeclarations([appFile, dirFile], [templateFile]);\n+        const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+        expect(refs.length).toBe(2);\n+        assertFileNames(refs, ['dir.ts', 'app.html']);\n+        assertTextSpans(refs, ['dirValue']);\n+      });\n+\n+      it('should work for safe prop reads', () => {\n+        const fileWithCursor = '<div [dir] #dirRef=\"myDir\"></div> {{ dirRef?.dirV¦alue }}';\n+        const {text, cursor} = extractCursorInfo(fileWithCursor);\n+        const templateFile = {name: _('/app.html'), contents: text};\n+        createModuleWithDeclarations([appFile, dirFile], [templateFile]);\n+        const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+        expect(refs.length).toBe(2);\n+        assertFileNames(refs, ['dir.ts', 'app.html']);\n+        assertTextSpans(refs, ['dirValue']);\n+      });\n+\n+      it('should work for safe method calls', () => {\n+        const fileWithCursor = '<div [dir] #dirRef=\"myDir\"></div> {{ dirRef?.doSometh¦ing() }}';\n+        const {text, cursor} = extractCursorInfo(fileWithCursor);\n+        const templateFile = {name: _('/app.html'), contents: text};\n+        createModuleWithDeclarations([appFile, dirFile], [templateFile]);\n+        const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+        expect(refs.length).toBe(2);\n+        assertFileNames(refs, ['dir.ts', 'app.html']);\n+        assertTextSpans(refs, ['doSomething']);\n+      });\n+    });\n+  });\n+\n+  describe('variables', () => {\n+    it('should work for variable initialized implicitly', () => {\n+      const {text, cursor} = extractCursorInfo(`\n+          import {Component} from '@angular/core';\n+\n+          @Component({template: '<div *ngFor=\"let hero of heroes\">{{her¦o}}</div>'})\n+          export class AppCmp {\n+            heroes: string[] = [];\n+          }`);\n+      const appFile = {name: _('/app.ts'), contents: text};\n+      createModuleWithDeclarations([appFile]);\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toBe(2);\n+      assertFileNames(refs, ['app.ts']);\n+      assertTextSpans(refs, ['hero']);\n+\n+      const originalRefs = env.ngLS.getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      // Get the declaration by finding the reference that appears first in the template\n+      originalRefs.sort((a, b) => a.textSpan.start - b.textSpan.start);\n+      expect(originalRefs[0].isDefinition).toBe(true);\n+    });\n+\n+    it('should work for renamed variables', () => {\n+      const {text, cursor} = extractCursorInfo(`\n+          import {Component} from '@angular/core';\n+\n+          @Component({template: '<div *ngFor=\"let hero of heroes; let iRef = index\">{{iR¦ef}}</div>'})\n+          export class AppCmp {\n+            heroes: string[] = [];\n+          }`);\n+      const appFile = {name: _('/app.ts'), contents: text};\n+      createModuleWithDeclarations([appFile]);\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toBe(2);\n+      assertFileNames(refs, ['app.ts']);\n+      assertTextSpans(refs, ['iRef']);\n+\n+      const originalRefs = env.ngLS.getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      // Get the declaration by finding the reference that appears first in the template\n+      originalRefs.sort((a, b) => a.textSpan.start - b.textSpan.start);\n+      expect(originalRefs[0].isDefinition).toBe(true);\n+    });\n+\n+    it('should work for initializer of variable', () => {\n+      const dirFile = `\n+        import {Directive, Input} from '@angular/core';\n+\n+        export class ExampleContext<T> {\n+          constructor(readonly $implicit: T, readonly identifier: string) {}\n+        }\n+\n+        @Directive({ selector: '[example]' })\n+        export class ExampleDirective<T> {\n+          @Input() set example(v: T) { }\n+          static ngTemplateContextGuard<T>(dir: ExampleDirective<T>, ctx: unknown):\n+            ctx is ExampleContext<T> {\n+            return true;\n+          }\n+        }`;\n+      const fileWithCursor = `\n+        import {Component, NgModule} from '@angular/core';\n+        import {ExampleDirective} from './example-directive';\n+\n+        @Component({template: '<div *example=\"state; let id = identif¦ier\">{{id}}</div>'})\n+        export class AppCmp {\n+          state = {};\n+        }\n+\n+        @NgModule({declarations: [AppCmp, ExampleDirective]})\n+        export class AppModule {}`;\n+      const {text, cursor} = extractCursorInfo(fileWithCursor);\n+      env = LanguageServiceTestEnvironment.setup([\n+        {name: _('/app.ts'), contents: text, isRoot: true},\n+        {name: _('/example-directive.ts'), contents: dirFile},\n+      ]);\n+      env.expectNoSourceDiagnostics();\n+      env.expectNoTemplateDiagnostics(absoluteFrom('/app.ts'), 'AppCmp');\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toBe(2);\n+      assertFileNames(refs, ['app.ts', 'example-directive.ts']);\n+      assertTextSpans(refs, ['identifier']);\n+    });\n+\n+    it('should work for prop reads of variables', () => {\n+      const {text, cursor} = extractCursorInfo(`\n+            import {Component} from '@angular/core';\n+\n+            @Component({template: '<div *ngFor=\"let hero of heroes\">{{hero.na¦me}}</div>'})\n+            export class AppCmp {\n+              heroes: Array<{name: string}> = [];\n+            }`);\n+      const appFile = {name: _('/app.ts'), contents: text};\n+      createModuleWithDeclarations([appFile]);\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toBe(2);\n+      assertFileNames(refs, ['app.ts']);\n+      assertTextSpans(refs, ['name']);\n+    });\n+  });\n+\n+  describe('pipes', () => {\n+    let prefixPipeFile: TestFile;\n+    beforeEach(() => {\n+      const prefixPipe = `\n+        import {Pipe, PipeTransform} from '@angular/core';\n+\n+        @Pipe({ name: 'prefixPipe' })\n+        export class PrefixPipe implements PipeTransform {\n+          transform(value: string, prefix: string): string;\n+          transform(value: number, prefix: number): number;\n+          transform(value: string|number, prefix: string|number): string|number {\n+            return '';\n+          }\n+        }`;\n+      prefixPipeFile = {name: _('/prefix-pipe.ts'), contents: prefixPipe};\n+    });\n+\n+    it('should work for pipe names', () => {\n+      const appContentsWithCursor = `\n+        import {Component} from '@angular/core';\n+\n+        @Component({template: '{{birthday | prefi¦xPipe: \"MM/dd/yy\"}}'})\n+        export class AppCmp {\n+          birthday = '';\n+        }\n+      `;\n+      const {text, cursor} = extractCursorInfo(appContentsWithCursor);\n+      const appFile = {name: _('/app.ts'), contents: text};\n+      createModuleWithDeclarations([appFile, prefixPipeFile]);\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toBe(5);\n+      assertFileNames(refs, ['index.d.ts', 'prefix-pipe.ts', 'app.ts']);\n+      assertTextSpans(refs, ['transform', 'prefixPipe']);\n+    });\n+\n+    it('should work for pipe arguments', () => {\n+      const appContentsWithCursor = `\n+        import {Component} from '@angular/core';\n+\n+        @Component({template: '{{birthday | prefixPipe: pr¦efix}}'})\n+        export class AppCmp {\n+          birthday = '';\n+          prefix = '';\n+        }\n+      `;\n+      const {text, cursor} = extractCursorInfo(appContentsWithCursor);\n+      const appFile = {name: _('/app.ts'), contents: text};\n+      createModuleWithDeclarations([appFile, prefixPipeFile]);\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toBe(2);\n+      assertFileNames(refs, ['app.ts']);\n+      assertTextSpans(refs, ['prefix']);\n+    });\n+  });\n+\n+  describe('inputs', () => {\n+    const dirFileContents = `\n+        import {Directive, Input} from '@angular/core';\n+\n+        @Directive({selector: '[string-model]'})\n+        export class StringModel {\n+          @Input() model!: string;\n+          @Input('alias') aliasedModel!: string;\n+        }`;\n+    it('should work from the template', () => {\n+      const stringModelTestFile = {name: _('/string-model.ts'), contents: dirFileContents};\n+      const {text, cursor} = extractCursorInfo(`\n+        import {Component} from '@angular/core';\n+\n+        @Component({template: '<div string-model [mod¦el]=\"title\"></div>'})\n+        export class AppCmp {\n+          title = 'title';\n+        }`);\n+      const appFile = {name: _('/app.ts'), contents: text};\n+      createModuleWithDeclarations([appFile, stringModelTestFile]);\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toEqual(2);\n+      assertFileNames(refs, ['string-model.ts', 'app.ts']);\n+      assertTextSpans(refs, ['model']);\n+    });\n+\n+    it('should work for text attributes', () => {\n+      const stringModelTestFile = {name: _('/string-model.ts'), contents: dirFileContents};\n+      const {text, cursor} = extractCursorInfo(`\n+        import {Component} from '@angular/core';\n+\n+        @Component({template: '<div string-model mod¦el=\"title\"></div>'})\n+        export class AppCmp {\n+          title = 'title';\n+        }`);\n+      const appFile = {name: _('/app.ts'), contents: text};\n+      createModuleWithDeclarations([appFile, stringModelTestFile]);\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toEqual(2);\n+      assertFileNames(refs, ['string-model.ts', 'app.ts']);\n+      assertTextSpans(refs, ['model']);\n+    });\n+\n+    it('should work from the TS input declaration', () => {\n+      const dirFileWithCursor = `\n+        import {Directive, Input} from '@angular/core';\n+\n+        @Directive({selector: '[string-model]'})\n+        export class StringModel {\n+          @Input() mod¦el!: string;\n+        }`;\n+      const {text, cursor} = extractCursorInfo(dirFileWithCursor);\n+      const stringModelTestFile = {name: _('/string-model.ts'), contents: text};\n+      const appFile = {\n+        name: _('/app.ts'),\n+        contents: `\n+        import {Component} from '@angular/core';\n+\n+        @Component({template: '<div string-model model=\"title\"></div>'})\n+        export class AppCmp {\n+          title = 'title';\n+        }`,\n+      };\n+      createModuleWithDeclarations([appFile, stringModelTestFile]);\n+      const refs = getReferencesAtPosition(_('/string-model.ts'), cursor)!;\n+      expect(refs.length).toEqual(2);\n+      assertFileNames(refs, ['app.ts', 'string-model.ts']);\n+      assertTextSpans(refs, ['model']);\n+    });\n+\n+    it('should work for inputs referenced from some other place', () => {\n+      const otherDirContents = `\n+        import {Directive, Input} from '@angular/core';\n+        import {StringModel} from './string-model';\n+\n+        @Directive({selector: '[other-dir]'})\n+        export class OtherDir {\n+          @Input() stringModelRef!: StringModel;\n+\n+          doSomething() {\n+            console.log(this.stringModelRef.mod¦el);\n+          }\n+        }`;\n+      const {text, cursor} = extractCursorInfo(otherDirContents);\n+      const otherDirFile = {name: _('/other-dir.ts'), contents: text};\n+      const stringModelTestFile = {\n+        name: _('/string-model.ts'),\n+        contents: `\n+        import {Directive, Input} from '@angular/core';\n+\n+        @Directive({selector: '[string-model]'})\n+        export class StringModel {\n+          @Input() model!: string;\n+        }`,\n+      };\n+      const appFile = {\n+        name: _('/app.ts'),\n+        contents: `\n+        import {Component} from '@angular/core';\n+\n+        @Component({template: '<div string-model other-dir model=\"title\"></div>'})\n+        export class AppCmp {\n+          title = 'title';\n+        }`,\n+      };\n+      createModuleWithDeclarations([appFile, stringModelTestFile, otherDirFile]);\n+      const refs = getReferencesAtPosition(_('/other-dir.ts'), cursor)!;\n+      expect(refs.length).toEqual(3);\n+      assertFileNames(refs, ['app.ts', 'string-model.ts', 'other-dir.ts']);\n+      assertTextSpans(refs, ['model']);\n+    });\n+\n+    it('should work with aliases', () => {\n+      const stringModelTestFile = {name: _('/string-model.ts'), contents: dirFileContents};\n+      const {text, cursor} = extractCursorInfo(`\n+        import {Component} from '@angular/core';\n+\n+        @Component({template: '<div string-model [al¦ias]=\"title\"></div>'})\n+        export class AppCmp {\n+          title = 'title';\n+        }`);\n+      const appFile = {name: _('/app.ts'), contents: text};\n+      createModuleWithDeclarations([appFile, stringModelTestFile]);\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toEqual(2);\n+      assertFileNames(refs, ['string-model.ts', 'app.ts']);\n+      assertTextSpans(refs, ['aliasedModel', 'alias']);\n+    });\n+  });\n+\n+  describe('outputs', () => {\n+    const dirFile = `\n+        import {Directive, Output, EventEmitter} from '@angular/core';\n+\n+        @Directive({selector: '[string-model]'})\n+        export class StringModel {\n+          @Output() modelChange = new EventEmitter<string>();\n+          @Output('alias') aliasedModelChange = new EventEmitter<string>();\n+        }`;\n+\n+    function generateAppFile(template: string) {\n+      return `\n+        import {Component, NgModule} from '@angular/core';\n+        import {StringModel} from './string-model';\n+\n+        @Component({template: '${template}'})\n+        export class AppCmp {\n+          setTitle(s: string) {}\n+        }\n+\n+        @NgModule({declarations: [AppCmp, StringModel]})\n+        export class AppModule {}`;\n+    }\n+\n+    it('should work', () => {\n+      const {text, cursor} = extractCursorInfo(\n+          generateAppFile(`<div string-model (mod¦elChange)=\"setTitle($event)\"></div>`));\n+      env = LanguageServiceTestEnvironment.setup([\n+        {name: _('/app.ts'), contents: text, isRoot: true},\n+        {name: _('/string-model.ts'), contents: dirFile},\n+      ]);\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toEqual(2);\n+      assertTextSpans(refs, ['modelChange']);\n+    });\n+\n+    it('should work with aliases', () => {\n+      const {text, cursor} = extractCursorInfo(\n+          generateAppFile(`<div string-model (a¦lias)=\"setTitle($event)\"></div>`));\n+      env = LanguageServiceTestEnvironment.setup([\n+        {name: _('/app.ts'), contents: text, isRoot: true},\n+        {name: _('/string-model.ts'), contents: dirFile},\n+      ]);\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toEqual(2);\n+      assertTextSpans(refs, ['aliasedModelChange', 'alias']);\n+    });\n+  });\n+\n+  describe('directives', () => {\n+    it('works for directive classes', () => {\n+      const {text, cursor} = extractCursorInfo(`\n+      import {Directive} from '@angular/core';\n+\n+      @Directive({selector: '[dir]'})\n+      export class Di¦r {}`);\n+      const appFile = `\n+        import {Component, NgModule} from '@angular/core';\n+        import {Dir} from './dir';\n+\n+        @Component({template: '<div dir></div>'})\n+        export class AppCmp {\n+        }\n+\n+        @NgModule({declarations: [AppCmp, Dir]})\n+        export class AppModule {}\n+      `;\n+      env = LanguageServiceTestEnvironment.setup([\n+        {name: _('/app.ts'), contents: appFile, isRoot: true},\n+        {name: _('/dir.ts'), contents: text},\n+      ]);\n+      const refs = getReferencesAtPosition(_('/dir.ts'), cursor)!;\n+      // 4 references are:  class declaration, template usage, app import and use in declarations\n+      // list.\n+      expect(refs.length).toBe(4);\n+      assertTextSpans(refs, ['<div dir>', 'Dir']);\n+      assertFileNames(refs, ['app.ts', 'dir.ts']);\n+    });\n+  });\n+\n+  function getReferencesAtPosition(fileName: string, position: number) {\n+    env.expectNoSourceDiagnostics();\n+    const result = env.ngLS.getReferencesAtPosition(fileName, position);\n+    return result?.map(humanizeReferenceEntry);\n+  }\n+\n+  function humanizeReferenceEntry(entry: ts.ReferenceEntry): Stringy<ts.DocumentSpan>&\n+      Pick<ts.ReferenceEntry, 'isWriteAccess'|'isDefinition'|'isInString'> {\n+    const fileContents = env.host.readFile(entry.fileName);\n+    if (!fileContents) {\n+      throw new Error('Could not read file ${entry.fileName}');\n+    }\n+    return {\n+      ...entry,\n+      textSpan: getText(fileContents, entry.textSpan),\n+      contextSpan: entry.contextSpan ? getText(fileContents, entry.contextSpan) : undefined,\n+      originalTextSpan: entry.originalTextSpan ? getText(fileContents, entry.originalTextSpan) :\n+                                                 undefined,\n+      originalContextSpan:\n+          entry.originalContextSpan ? getText(fileContents, entry.originalContextSpan) : undefined,\n+    };\n+  }\n+\n+  function getFirstClassDeclaration(declaration: string) {\n+    const matches = declaration.match(/(?:export class )(\\w+)(?:\\s|\\{)/);\n+    if (matches === null || matches.length !== 2) {\n+      throw new Error(`Did not find exactly one exported class in: ${declaration}`);\n+    }\n+    return matches[1].trim();\n+  }\n+\n+  function createModuleWithDeclarations(\n+      filesWithClassDeclarations: TestFile[], externalResourceFiles: TestFile[] = []): void {\n+    const externalClasses =\n+        filesWithClassDeclarations.map(file => getFirstClassDeclaration(file.contents));\n+    const externalImports = filesWithClassDeclarations.map(file => {\n+      const className = getFirstClassDeclaration(file.contents);\n+      const fileName = last(file.name.split('/')).replace('.ts', '');\n+      return `import {${className}} from './${fileName}';`;\n+    });\n+    const contents = `\n+        import {NgModule} from '@angular/core';\n+        import {CommonModule} from '@angular/common';\n+        ${externalImports.join('\\n')}\n+\n+        @NgModule({\n+          declarations: [${externalClasses.join(',')}],\n+          imports: [CommonModule],\n+        })\n+        export class AppModule {}\n+      `;\n+    const moduleFile = {name: _('/app-module.ts'), contents, isRoot: true};\n+    env = LanguageServiceTestEnvironment.setup(\n+        [moduleFile, ...filesWithClassDeclarations, ...externalResourceFiles]);\n+  }\n+});\n+\n+function assertFileNames(refs: Array<{fileName: string}>, expectedFileNames: string[]) {\n+  const actualPaths = refs.map(r => r.fileName);\n+  const actualFileNames = actualPaths.map(p => last(p.split('/')));\n+  expect(new Set(actualFileNames)).toEqual(new Set(expectedFileNames));\n+}\n+\n+function assertTextSpans(refs: Array<{textSpan: string}>, expectedTextSpans: string[]) {\n+  const actualSpans = refs.map(ref => ref.textSpan);\n+  expect(new Set(actualSpans)).toEqual(new Set(expectedTextSpans));\n+}\n+\n+function last<T>(array: T[]): T {\n+  return array[array.length - 1];\n+}\n+\n+type Stringy<T> = {\n+  [P in keyof T]: string;\n+};"
        },
        {
            "sha": "9a96c2bad3b59c39f6dcb23263a796b2cd1c0fe0",
            "filename": "packages/language-service/ivy/test/test_utils.ts",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Ftest_utils.ts?ref=06a782a2e38acb6f5a3433a88be27b47c45445bf",
            "patch": "@@ -0,0 +1,12 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+\n+export function getText(contents: string, textSpan: ts.TextSpan) {\n+  return contents.substr(textSpan.start, textSpan.length);\n+}"
        },
        {
            "sha": "8c28a2db3538b7efdebf6c0d8291375567d6f55b",
            "filename": "packages/language-service/ivy/ts_plugin.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts?ref=06a782a2e38acb6f5a3433a88be27b47c45445bf",
            "patch": "@@ -56,9 +56,9 @@ export function create(info: ts.server.PluginCreateInfo): ts.LanguageService {\n     }\n   }\n \n-  function getReferencesAtPosition(fileName: string, position: number) {\n-    // TODO(atscott): implement references\n-    return undefined;\n+  function getReferencesAtPosition(fileName: string, position: number): ts.ReferenceEntry[]|\n+      undefined {\n+    return ngLS.getReferencesAtPosition(fileName, position);\n   }\n \n   return {"
        },
        {
            "sha": "2aa5d04290f31edcbf7c786d221d2198309f9b0b",
            "filename": "packages/language-service/ivy/utils.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/06a782a2e38acb6f5a3433a88be27b47c45445bf/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Futils.ts?ref=06a782a2e38acb6f5a3433a88be27b47c45445bf",
            "patch": "@@ -306,3 +306,17 @@ export function isTypeScriptFile(fileName: string): boolean {\n export function isExternalTemplate(fileName: string): boolean {\n   return !isTypeScriptFile(fileName);\n }\n+\n+export function isWithin(position: number, span: AbsoluteSourceSpan|ParseSourceSpan): boolean {\n+  let start: number, end: number;\n+  if (span instanceof ParseSourceSpan) {\n+    start = span.start.offset;\n+    end = span.end.offset;\n+  } else {\n+    start = span.start;\n+    end = span.end;\n+  }\n+  // Note both start and end are inclusive because we want to match conditions\n+  // like ¦start and end¦ where ¦ is the cursor.\n+  return start <= position && position <= end;\n+}"
        }
    ],
    "stats": {
        "total": 1025,
        "additions": 997,
        "deletions": 28
    }
}