{
    "author": "AndrewKushnir",
    "message": "fix(forms): clean up connection between FormControl/FormGroup and corresponding directive instances (#39235)\n\nPrior to this commit, removing `FormControlDirective` and `FormGroupName` directive instances didn't clear\nthe callbacks previously registered on FromControl/FormGroup class instances. As a result, these callbacks\nwere executed even after `FormControlDirective` and `FormGroupName` directive instances were destroyed. That was\nalso causing memory leaks since these callbacks also retained references to DOM elements.\n\nThis commit updates the cleanup logic to take care of properly detaching FormControl/FormGroup/FormArray instances\nfrom the view by removing view-specific callback at destroy time.\n\nCloses #20007, #37431, #39590.\n\nPR Close #39235",
    "sha": "a3849611b7e65dd5745e1d182df6d526fddb302c",
    "files": [
        {
            "sha": "251ce95472859bcf2e6c6326a549ffad54e409ab",
            "filename": "goldens/public-api/forms/forms.d.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/a3849611b7e65dd5745e1d182df6d526fddb302c/goldens%2Fpublic-api%2Fforms%2Fforms.d.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3849611b7e65dd5745e1d182df6d526fddb302c/goldens%2Fpublic-api%2Fforms%2Fforms.d.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fpublic-api%2Fforms%2Fforms.d.ts?ref=a3849611b7e65dd5745e1d182df6d526fddb302c",
            "patch": "@@ -237,7 +237,7 @@ export declare class FormControl extends AbstractControl {\n     }): void;\n }\n \n-export declare class FormControlDirective extends NgControl implements OnChanges {\n+export declare class FormControlDirective extends NgControl implements OnChanges, OnDestroy {\n     get control(): FormControl;\n     form: FormControl;\n     set isDisabled(isDisabled: boolean);\n@@ -247,6 +247,7 @@ export declare class FormControlDirective extends NgControl implements OnChanges\n     viewModel: any;\n     constructor(validators: (Validator | ValidatorFn)[], asyncValidators: (AsyncValidator | AsyncValidatorFn)[], valueAccessors: ControlValueAccessor[], _ngModelWarningConfig: string | null);\n     ngOnChanges(changes: SimpleChanges): void;\n+    ngOnDestroy(): void;\n     viewToModelUpdate(newValue: any): void;\n }\n \n@@ -295,7 +296,7 @@ export declare class FormGroup extends AbstractControl {\n     }): void;\n }\n \n-export declare class FormGroupDirective extends ControlContainer implements Form, OnChanges {\n+export declare class FormGroupDirective extends ControlContainer implements Form, OnChanges, OnDestroy {\n     get control(): FormGroup;\n     directives: FormControlName[];\n     form: FormGroup;\n@@ -311,6 +312,7 @@ export declare class FormGroupDirective extends ControlContainer implements Form\n     getFormArray(dir: FormArrayName): FormArray;\n     getFormGroup(dir: FormGroupName): FormGroup;\n     ngOnChanges(changes: SimpleChanges): void;\n+    ngOnDestroy(): void;\n     onReset(): void;\n     onSubmit($event: Event): boolean;\n     removeControl(dir: FormControlName): void;"
        },
        {
            "sha": "a4d53d02c5afadb5d1d907f8d6b649d418d80320",
            "filename": "packages/core/test/bundling/forms/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/a3849611b7e65dd5745e1d182df6d526fddb302c/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/a3849611b7e65dd5745e1d182df6d526fddb302c/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json?ref=a3849611b7e65dd5745e1d182df6d526fddb302c",
            "patch": "@@ -770,6 +770,9 @@\n   {\n     \"name\": \"classIndexOf\"\n   },\n+  {\n+    \"name\": \"cleanUpControl\"\n+  },\n   {\n     \"name\": \"cleanUpValidators\"\n   },"
        },
        {
            "sha": "ba7bace32dd070bc0bf719ef18b3b590406c6677",
            "filename": "packages/forms/src/directives/reactive_directives/form_control_directive.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 3,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/a3849611b7e65dd5745e1d182df6d526fddb302c/packages%2Fforms%2Fsrc%2Fdirectives%2Freactive_directives%2Fform_control_directive.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3849611b7e65dd5745e1d182df6d526fddb302c/packages%2Fforms%2Fsrc%2Fdirectives%2Freactive_directives%2Fform_control_directive.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fdirectives%2Freactive_directives%2Fform_control_directive.ts?ref=a3849611b7e65dd5745e1d182df6d526fddb302c",
            "patch": "@@ -6,14 +6,14 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Directive, EventEmitter, forwardRef, Inject, InjectionToken, Input, OnChanges, Optional, Output, Self, SimpleChanges} from '@angular/core';\n+import {Directive, EventEmitter, forwardRef, Inject, InjectionToken, Input, OnChanges, OnDestroy, Optional, Output, Self, SimpleChanges} from '@angular/core';\n \n import {FormControl} from '../../model';\n import {NG_ASYNC_VALIDATORS, NG_VALIDATORS} from '../../validators';\n import {ControlValueAccessor, NG_VALUE_ACCESSOR} from '../control_value_accessor';\n import {NgControl} from '../ng_control';\n import {ReactiveErrors} from '../reactive_errors';\n-import {_ngModelWarning, isPropertyUpdated, selectValueAccessor, setUpControl} from '../shared';\n+import {_ngModelWarning, cleanUpControl, isPropertyUpdated, selectValueAccessor, setUpControl} from '../shared';\n import {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from '../validators';\n \n \n@@ -51,7 +51,7 @@ export const formControlBinding: any = {\n  * @publicApi\n  */\n @Directive({selector: '[formControl]', providers: [formControlBinding], exportAs: 'ngForm'})\n-export class FormControlDirective extends NgControl implements OnChanges {\n+export class FormControlDirective extends NgControl implements OnChanges, OnDestroy {\n   /**\n    * Internal reference to the view model value.\n    * @nodoc\n@@ -118,6 +118,10 @@ export class FormControlDirective extends NgControl implements OnChanges {\n   /** @nodoc */\n   ngOnChanges(changes: SimpleChanges): void {\n     if (this._isControlChanged(changes)) {\n+      const previousForm = changes['form'].previousValue;\n+      if (previousForm) {\n+        cleanUpControl(previousForm, this, /* validateControlPresenceOnChange */ false);\n+      }\n       setUpControl(this.form, this);\n       if (this.control.disabled && this.valueAccessor!.setDisabledState) {\n         this.valueAccessor!.setDisabledState!(true);\n@@ -133,6 +137,13 @@ export class FormControlDirective extends NgControl implements OnChanges {\n     }\n   }\n \n+  /** @nodoc */\n+  ngOnDestroy() {\n+    if (this.form) {\n+      cleanUpControl(this.form, this, /* validateControlPresenceOnChange */ false);\n+    }\n+  }\n+\n   /**\n    * @description\n    * Returns an array that represents the path from the top-level form to this control."
        },
        {
            "sha": "edf7cceaea82f9ab31ba03d97f5511d14436ea36",
            "filename": "packages/forms/src/directives/reactive_directives/form_group_directive.ts",
            "status": "modified",
            "additions": 64,
            "deletions": 15,
            "changes": 79,
            "blob_url": "https://github.com/angular/angular/blob/a3849611b7e65dd5745e1d182df6d526fddb302c/packages%2Fforms%2Fsrc%2Fdirectives%2Freactive_directives%2Fform_group_directive.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3849611b7e65dd5745e1d182df6d526fddb302c/packages%2Fforms%2Fsrc%2Fdirectives%2Freactive_directives%2Fform_group_directive.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fdirectives%2Freactive_directives%2Fform_group_directive.ts?ref=a3849611b7e65dd5745e1d182df6d526fddb302c",
            "patch": "@@ -6,14 +6,14 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Directive, EventEmitter, forwardRef, Inject, Input, OnChanges, Optional, Output, Self, SimpleChanges} from '@angular/core';\n+import {Directive, EventEmitter, forwardRef, Inject, Input, OnChanges, OnDestroy, Optional, Output, Self, SimpleChanges} from '@angular/core';\n \n import {FormArray, FormControl, FormGroup} from '../../model';\n import {NG_ASYNC_VALIDATORS, NG_VALIDATORS} from '../../validators';\n import {ControlContainer} from '../control_container';\n import {Form} from '../form_interface';\n import {ReactiveErrors} from '../reactive_errors';\n-import {cleanUpControl, cleanUpValidators, removeListItem, setUpControl, setUpFormContainer, setUpValidators, syncPendingControls} from '../shared';\n+import {cleanUpControl, cleanUpFormContainer, cleanUpValidators, removeListItem, setUpControl, setUpFormContainer, setUpValidators, syncPendingControls} from '../shared';\n import {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from '../validators';\n \n import {FormControlName} from './form_control_name';\n@@ -53,7 +53,7 @@ export const formDirectiveProvider: any = {\n   host: {'(submit)': 'onSubmit($event)', '(reset)': 'onReset()'},\n   exportAs: 'ngForm'\n })\n-export class FormGroupDirective extends ControlContainer implements Form, OnChanges {\n+export class FormGroupDirective extends ControlContainer implements Form, OnChanges, OnDestroy {\n   /**\n    * @description\n    * Reports whether the form submission has been triggered.\n@@ -66,6 +66,12 @@ export class FormGroupDirective extends ControlContainer implements Form, OnChan\n    */\n   private _oldForm: FormGroup|undefined;\n \n+  /**\n+   * Callback that should be invoked when controls in FormGroup or FormArray collection change\n+   * (added or removed). This callback triggers corresponding DOM updates.\n+   */\n+  private readonly _onCollectionChange = () => this._updateDomValue();\n+\n   /**\n    * @description\n    * Tracks the list of added `FormControlName` instances\n@@ -104,6 +110,23 @@ export class FormGroupDirective extends ControlContainer implements Form, OnChan\n     }\n   }\n \n+  /** @nodoc */\n+  ngOnDestroy() {\n+    if (this.form) {\n+      cleanUpValidators(this.form, this, /* handleOnValidatorChange */ false);\n+\n+      // Currently the `onCollectionChange` callback is rewritten each time the\n+      // `_registerOnCollectionChange` function is invoked. The implication is that cleanup should\n+      // happen *only* when the `onCollectionChange` callback was set by this directive instance.\n+      // Otherwise it might cause overriding a callback of some other directive instances. We should\n+      // consider updating this logic later to make it similar to how `onChange` callbacks are\n+      // handled, see https://github.com/angular/angular/issues/39732 for additional info.\n+      if (this.form._onCollectionChange === this._onCollectionChange) {\n+        this.form._registerOnCollectionChange(() => {});\n+      }\n+    }\n+  }\n+\n   /**\n    * @description\n    * Returns this directive's instance.\n@@ -161,6 +184,7 @@ export class FormGroupDirective extends ControlContainer implements Form, OnChan\n    * @param dir The `FormControlName` directive instance.\n    */\n   removeControl(dir: FormControlName): void {\n+    cleanUpControl(dir.control || null, dir, /* validateControlPresenceOnChange */ false);\n     removeListItem(this.directives, dir);\n   }\n \n@@ -170,17 +194,18 @@ export class FormGroupDirective extends ControlContainer implements Form, OnChan\n    * @param dir The `FormGroupName` directive instance.\n    */\n   addFormGroup(dir: FormGroupName): void {\n-    const ctrl: any = this.form.get(dir.path);\n-    setUpFormContainer(ctrl, dir);\n-    ctrl.updateValueAndValidity({emitEvent: false});\n+    this._setUpFormContainer(dir);\n   }\n \n   /**\n-   * No-op method to remove the form group.\n+   * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the\n+   * view.\n    *\n    * @param dir The `FormGroupName` directive instance.\n    */\n-  removeFormGroup(dir: FormGroupName): void {}\n+  removeFormGroup(dir: FormGroupName): void {\n+    this._cleanUpFormContainer(dir);\n+  }\n \n   /**\n    * @description\n@@ -193,22 +218,23 @@ export class FormGroupDirective extends ControlContainer implements Form, OnChan\n   }\n \n   /**\n-   * Adds a new `FormArrayName` directive instance to the form.\n+   * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.\n    *\n    * @param dir The `FormArrayName` directive instance.\n    */\n   addFormArray(dir: FormArrayName): void {\n-    const ctrl: any = this.form.get(dir.path);\n-    setUpFormContainer(ctrl, dir);\n-    ctrl.updateValueAndValidity({emitEvent: false});\n+    this._setUpFormContainer(dir);\n   }\n \n   /**\n-   * No-op method to remove the form array.\n+   * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the\n+   * view.\n    *\n    * @param dir The `FormArrayName` directive instance.\n    */\n-  removeFormArray(dir: FormArrayName): void {}\n+  removeFormArray(dir: FormArrayName): void {\n+    this._cleanUpFormContainer(dir);\n+  }\n \n   /**\n    * @description\n@@ -281,8 +307,31 @@ export class FormGroupDirective extends ControlContainer implements Form, OnChan\n     this.form._updateTreeValidity({emitEvent: false});\n   }\n \n+  private _setUpFormContainer(dir: FormArrayName|FormGroupName): void {\n+    const ctrl: any = this.form.get(dir.path);\n+    setUpFormContainer(ctrl, dir);\n+    // NOTE: this operation looks unnecessary in case no new validators were added in\n+    // `setUpFormContainer` call. Consider updating this code to match the logic in\n+    // `_cleanUpFormContainer` function.\n+    ctrl.updateValueAndValidity({emitEvent: false});\n+  }\n+\n+  private _cleanUpFormContainer(dir: FormArrayName|FormGroupName): void {\n+    if (this.form) {\n+      const ctrl: any = this.form.get(dir.path);\n+      if (ctrl) {\n+        const isControlUpdated = cleanUpFormContainer(ctrl, dir);\n+        if (isControlUpdated) {\n+          // Run validity check only in case a control was updated (i.e. view validators were\n+          // removed) as removing view validators might cause validity to change.\n+          ctrl.updateValueAndValidity({emitEvent: false});\n+        }\n+      }\n+    }\n+  }\n+\n   private _updateRegistrations() {\n-    this.form._registerOnCollectionChange(() => this._updateDomValue());\n+    this.form._registerOnCollectionChange(this._onCollectionChange);\n     if (this._oldForm) {\n       this._oldForm._registerOnCollectionChange(() => {});\n     }"
        },
        {
            "sha": "6d4d6441ff89b77725df3b9ba87015d210414768",
            "filename": "packages/forms/src/directives/shared.ts",
            "status": "modified",
            "additions": 57,
            "deletions": 6,
            "changes": 63,
            "blob_url": "https://github.com/angular/angular/blob/a3849611b7e65dd5745e1d182df6d526fddb302c/packages%2Fforms%2Fsrc%2Fdirectives%2Fshared.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3849611b7e65dd5745e1d182df6d526fddb302c/packages%2Fforms%2Fsrc%2Fdirectives%2Fshared.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fdirectives%2Fshared.ts?ref=a3849611b7e65dd5745e1d182df6d526fddb302c",
            "patch": "@@ -30,6 +30,13 @@ export function controlPath(name: string|null, parent: ControlContainer): string\n   return [...parent.path!, name!];\n }\n \n+/**\n+ * Links a Form control and a Form directive by setting up callbacks (such as `onChange`) on both\n+ * instances. This function is typically invoked when form directive is being initialized.\n+ *\n+ * @param control Form control instance that should be linked.\n+ * @param dir Directive that should be linked with a given control.\n+ */\n export function setUpControl(control: FormControl, dir: NgControl): void {\n   if (typeof ngDevMode === 'undefined' || ngDevMode) {\n     if (!control) _throwError(dir, 'Cannot find control with');\n@@ -48,9 +55,22 @@ export function setUpControl(control: FormControl, dir: NgControl): void {\n   setUpDisabledChangeHandler(control, dir);\n }\n \n-export function cleanUpControl(control: FormControl|null, dir: NgControl) {\n+/**\n+ * Reverts configuration performed by the `setUpControl` control function.\n+ * Effectively disconnects form control with a given form directive.\n+ * This function is typically invoked when corresponding form directive is being destroyed.\n+ *\n+ * @param control Form control which should be cleaned up.\n+ * @param dir Directive that should be disconnected from a given control.\n+ * @param validateControlPresenceOnChange Flag that indicates whether onChange handler should\n+ *     contain asserts to verify that it's not called once directive is destroyed. We need this flag\n+ *     to avoid potentially breaking changes caused by better control cleanup introduced in #39235.\n+ */\n+export function cleanUpControl(\n+    control: FormControl|null, dir: NgControl,\n+    validateControlPresenceOnChange: boolean = true): void {\n   const noop = () => {\n-    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n+    if (validateControlPresenceOnChange && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n       _noControlError(dir);\n     }\n   };\n@@ -146,25 +166,35 @@ export function setUpValidators(\n  * @param dir Directive instance that contains validators to be removed.\n  * @param handleOnValidatorChange Flag that determines whether directive validators should also be\n  *     cleaned up to stop handling validator input change (if previously configured to do so).\n+ * @returns true if a control was updated as a result of this action.\n  */\n export function cleanUpValidators(\n     control: AbstractControl|null, dir: AbstractControlDirective,\n-    handleOnValidatorChange: boolean): void {\n+    handleOnValidatorChange: boolean): boolean {\n+  let isControlUpdated = false;\n   if (control !== null) {\n     if (dir.validator !== null) {\n       const validators = getControlValidators(control);\n       if (Array.isArray(validators) && validators.length > 0) {\n         // Filter out directive validator function.\n-        control.setValidators(validators.filter(validator => validator !== dir.validator));\n+        const updatedValidators = validators.filter(validator => validator !== dir.validator);\n+        if (updatedValidators.length !== validators.length) {\n+          isControlUpdated = true;\n+          control.setValidators(updatedValidators);\n+        }\n       }\n     }\n \n     if (dir.asyncValidator !== null) {\n       const asyncValidators = getControlAsyncValidators(control);\n       if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {\n         // Filter out directive async validator function.\n-        control.setAsyncValidators(\n-            asyncValidators.filter(asyncValidator => asyncValidator !== dir.asyncValidator));\n+        const updatedAsyncValidators =\n+            asyncValidators.filter(asyncValidator => asyncValidator !== dir.asyncValidator);\n+        if (updatedAsyncValidators.length !== asyncValidators.length) {\n+          isControlUpdated = true;\n+          control.setAsyncValidators(updatedAsyncValidators);\n+        }\n       }\n     }\n   }\n@@ -175,6 +205,8 @@ export function cleanUpValidators(\n     registerOnValidatorChange<ValidatorFn>(dir._rawValidators, noop);\n     registerOnValidatorChange<AsyncValidatorFn>(dir._rawAsyncValidators, noop);\n   }\n+\n+  return isControlUpdated;\n }\n \n function setUpViewChangePipeline(control: FormControl, dir: NgControl): void {\n@@ -220,13 +252,32 @@ function setUpModelChangePipeline(control: FormControl, dir: NgControl): void {\n   });\n }\n \n+/**\n+ * Links a FormGroup or FormArray instance and corresponding Form directive by setting up validators\n+ * present in the view.\n+ *\n+ * @param control FormGroup or FormArray instance that should be linked.\n+ * @param dir Directive that provides view validators.\n+ */\n export function setUpFormContainer(\n     control: FormGroup|FormArray, dir: AbstractFormGroupDirective|FormArrayName) {\n   if (control == null && (typeof ngDevMode === 'undefined' || ngDevMode))\n     _throwError(dir, 'Cannot find control with');\n   setUpValidators(control, dir, /* handleOnValidatorChange */ false);\n }\n \n+/**\n+ * Reverts the setup performed by the `setUpFormContainer` function.\n+ *\n+ * @param control FormGroup or FormArray instance that should be cleaned up.\n+ * @param dir Directive that provided view validators.\n+ * @returns true if a control was updated as a result of this action.\n+ */\n+export function cleanUpFormContainer(\n+    control: FormGroup|FormArray, dir: AbstractFormGroupDirective|FormArrayName): boolean {\n+  return cleanUpValidators(control, dir, /* handleOnValidatorChange */ false);\n+}\n+\n function _noControlError(dir: NgControl) {\n   return _throwError(dir, 'There is no FormControl instance attached to form control element with');\n }"
        },
        {
            "sha": "72088ec4eee70cdb822309373bdbf590cc0986e6",
            "filename": "packages/forms/test/reactive_integration_spec.ts",
            "status": "modified",
            "additions": 1382,
            "deletions": 63,
            "changes": 1445,
            "blob_url": "https://github.com/angular/angular/blob/a3849611b7e65dd5745e1d182df6d526fddb302c/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3849611b7e65dd5745e1d182df6d526fddb302c/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts?ref=a3849611b7e65dd5745e1d182df6d526fddb302c",
            "patch": "@@ -10,14 +10,82 @@ import {ÉµgetDOM as getDOM} from '@angular/common';\n import {Component, Directive, forwardRef, Input, Type} from '@angular/core';\n import {ComponentFixture, fakeAsync, TestBed, tick} from '@angular/core/testing';\n import {expect} from '@angular/core/testing/src/testing_internal';\n-import {AbstractControl, AsyncValidator, AsyncValidatorFn, COMPOSITION_BUFFER_MODE, FormArray, FormControl, FormControlDirective, FormControlName, FormGroup, FormGroupDirective, FormsModule, NG_ASYNC_VALIDATORS, NG_VALIDATORS, ReactiveFormsModule, Validator, Validators} from '@angular/forms';\n+import {AbstractControl, AsyncValidator, AsyncValidatorFn, COMPOSITION_BUFFER_MODE, ControlValueAccessor, DefaultValueAccessor, FormArray, FormControl, FormControlDirective, FormControlName, FormGroup, FormGroupDirective, FormsModule, NG_ASYNC_VALIDATORS, NG_VALIDATORS, NG_VALUE_ACCESSOR, ReactiveFormsModule, Validator, Validators} from '@angular/forms';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n import {dispatchEvent, sortedClassList} from '@angular/platform-browser/testing/src/browser_util';\n import {merge, NEVER, of, timer} from 'rxjs';\n import {map, tap} from 'rxjs/operators';\n \n import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n \n+// Produces a new @Directive (with a given selector) that represents a validator class.\n+function createValidatorClass(selector: string) {\n+  @Directive({\n+    selector,\n+    providers: [{\n+      provide: NG_VALIDATORS,\n+      useClass: forwardRef(() => CustomValidator),\n+      multi: true,\n+    }]\n+  })\n+  class CustomValidator implements Validator {\n+    validate(control: AbstractControl) {\n+      return null;\n+    }\n+  }\n+  return CustomValidator;\n+}\n+\n+// Produces a new @Directive (with a given selector) that represents an async validator class.\n+function createAsyncValidatorClass(selector: string) {\n+  @Directive({\n+    selector,\n+    providers: [{\n+      provide: NG_ASYNC_VALIDATORS,\n+      useClass: forwardRef(() => CustomValidator),\n+      multi: true,\n+    }]\n+  })\n+  class CustomValidator implements AsyncValidator {\n+    validate(control: AbstractControl) {\n+      return Promise.resolve(null);\n+    }\n+  }\n+  return CustomValidator;\n+}\n+\n+// Produces a new @Directive (with a given selector) that represents a value accessor.\n+function createControlValueAccessor(selector: string) {\n+  @Directive({\n+    selector,\n+    providers: [{\n+      provide: NG_VALUE_ACCESSOR,\n+      useExisting: forwardRef(() => CustomValueAccessor),\n+      multi: true,\n+    }]\n+  })\n+  class CustomValueAccessor implements ControlValueAccessor {\n+    writeValue(value: any) {}\n+    registerOnChange(fn: (value: any) => void) {}\n+    registerOnTouched(fn: any) {}\n+  }\n+  return CustomValueAccessor;\n+}\n+\n+// Pre-create classes for validators.\n+const ViewValidatorA = createValidatorClass('[validators-a]');\n+const ViewValidatorB = createValidatorClass('[validators-b]');\n+const ViewValidatorC = createValidatorClass('[validators-c]');\n+\n+// Pre-create classes for async validators.\n+const AsyncViewValidatorA = createAsyncValidatorClass('[validators-a]');\n+const AsyncViewValidatorB = createAsyncValidatorClass('[validators-b]');\n+const AsyncViewValidatorC = createAsyncValidatorClass('[validators-c]');\n+\n+// Pre-create classes for value accessors.\n+const ValueAccessorA = createControlValueAccessor('[cva-a]');\n+const ValueAccessorB = createControlValueAccessor('[cva-b]');\n+\n {\n   describe('reactive forms integration tests', () => {\n     function initTest<T>(component: Type<T>, ...directives: Type<any>[]): ComponentFixture<T> {\n@@ -2471,6 +2539,10 @@ import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n     });\n \n     describe('cleanup', () => {\n+      // Symbol that indicates to the verification logic that a certain spy was not expected to be\n+      // invoked. This symbol is used by the test helpers below.\n+      const SHOULD_NOT_BE_CALLED = Symbol('SHOULD_NOT_BE_INVOKED');\n+\n       function expectValidatorsToBeCalled(\n           syncValidatorSpy: jasmine.Spy, asyncValidatorSpy: jasmine.Spy,\n           expected: {ctx: any, count: number}) {\n@@ -2482,9 +2554,101 @@ import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n         });\n       }\n \n+      function createValidatorSpy(): jasmine.Spy<jasmine.Func> {\n+        return jasmine.createSpy('asyncValidator').and.returnValue(null);\n+      }\n+      function createAsyncValidatorSpy(): jasmine.Spy<jasmine.Func> {\n+        return jasmine.createSpy('asyncValidator').and.returnValue(Promise.resolve(null));\n+      }\n+\n+      // Sets up a control with validators and value accessors configured for a test.\n+      function addOwnValidatorsAndAttachSpies(control: AbstractControl, fromView: any = {}): void {\n+        const validatorSpy = createValidatorSpy();\n+        const asyncValidatorSpy = createAsyncValidatorSpy();\n+        const valueChangesSpy = jasmine.createSpy('controlValueChangesListener');\n+        const debug: any = {\n+          validatorSpy,\n+          asyncValidatorSpy,\n+          valueChangesSpy,\n+        };\n+        if (fromView.viewValidators) {\n+          const [syncValidatorClass, asyncValidatorClass] = fromView.viewValidators;\n+          debug.viewValidatorSpy = validatorSpyOn(syncValidatorClass);\n+          debug.viewAsyncValidatorSpy = validatorSpyOn(asyncValidatorClass);\n+        }\n+        if (fromView.valueAccessor) {\n+          debug.valueAccessorSpy = spyOn(fromView.valueAccessor.prototype, 'writeValue');\n+        }\n+        (control as any).__debug__ = debug;\n+\n+        control.valueChanges.subscribe(valueChangesSpy);\n+        control.setValidators(validatorSpy);\n+        control.setAsyncValidators(asyncValidatorSpy);\n+      }\n+\n+      // Resets all spies associated with given controls.\n+      function resetSpies(...controls: AbstractControl[]): void {\n+        controls.forEach((control: any) => {\n+          const debug = control.__debug__;\n+          debug.validatorSpy.calls.reset();\n+          debug.asyncValidatorSpy.calls.reset();\n+          debug.valueChangesSpy.calls.reset();\n+          if (debug.viewValidatorSpy) {\n+            debug.viewValidatorSpy.calls.reset();\n+          }\n+          if (debug.viewAsyncValidatorSpy) {\n+            debug.viewAsyncValidatorSpy.calls.reset();\n+          }\n+          if (debug.valueAccessorSpy) {\n+            debug.valueAccessorSpy.calls.reset();\n+          }\n+        });\n+      }\n+\n+      // Verifies whether spy calls match expectations.\n+      function verifySpyCalls(spy: any, expectedContext: any, expectedCallCount?: number) {\n+        if (expectedContext === SHOULD_NOT_BE_CALLED) {\n+          expect(spy).not.toHaveBeenCalled();\n+        } else {\n+          expect(spy).toHaveBeenCalledWith(expectedContext);\n+          if (expectedCallCount !== undefined) {\n+            expect(spy.calls.count()).toBe(expectedCallCount);\n+          }\n+        }\n+      }\n+\n+      // Verify whether all spies attached to a given control match expectations.\n+      function verifySpies(control: AbstractControl, expected: any = {}) {\n+        const debug = (control as any).__debug__;\n+        const viewValidatorCallCount = expected.viewValidatorCallCount ?? 1;\n+        const ownValidatorCallCount = expected.ownValidatorCallCount ?? 1;\n+        const valueAccessorCallCount = expected.valueAccessorCallCount ?? 1;\n+        verifySpyCalls(debug.validatorSpy, expected.ownValidators, ownValidatorCallCount);\n+        verifySpyCalls(debug.asyncValidatorSpy, expected.ownValidators, ownValidatorCallCount);\n+        verifySpyCalls(debug.valueChangesSpy, expected.valueChanges);\n+        if (debug.viewValidatorSpy) {\n+          verifySpyCalls(debug.viewValidatorSpy, expected.viewValidators, viewValidatorCallCount);\n+        }\n+        if (debug.viewAsyncValidatorSpy) {\n+          verifySpyCalls(\n+              debug.viewAsyncValidatorSpy, expected.viewValidators, viewValidatorCallCount);\n+        }\n+        if (debug.valueAccessorSpy) {\n+          verifySpyCalls(debug.valueAccessorSpy, expected.valueAccessor, valueAccessorCallCount);\n+        }\n+      }\n+\n+      // Init a test with a predefined set of validator and value accessor classes.\n+      function initCleanupTest(component: Type<any>) {\n+        const fixture = initTest(\n+            component, ViewValidatorA, AsyncViewValidatorA, ViewValidatorB, AsyncViewValidatorB,\n+            ViewValidatorC, AsyncViewValidatorC, ValueAccessorA, ValueAccessorB);\n+        fixture.detectChanges();\n+        return fixture;\n+      }\n+\n       it('should clean up validators when FormGroup is replaced', () => {\n-        const fixture =\n-            initTest(FormGroupWithValidators, MyCustomValidator, MyCustomAsyncValidator);\n+        const fixture = initTest(FormGroupWithValidators, ViewValidatorA, AsyncViewValidatorA);\n         fixture.detectChanges();\n \n         const newForm = new FormGroup({login: new FormControl('NEW')});\n@@ -2494,8 +2658,8 @@ import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n         fixture.componentInstance.form = newForm;\n         fixture.detectChanges();\n \n-        const validatorSpy = validatorSpyOn(MyCustomValidator);\n-        const asyncValidatorSpy = validatorSpyOn(MyCustomAsyncValidator);\n+        const validatorSpy = validatorSpyOn(ViewValidatorA);\n+        const asyncValidatorSpy = validatorSpyOn(AsyncViewValidatorA);\n \n         // Calling `setValue` for the OLD form should NOT trigger validator calls.\n         oldForm.setValue({login: 'SOME-OLD-VALUE'});\n@@ -2508,15 +2672,14 @@ import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n       });\n \n       it('should clean up validators when FormControl inside FormGroup is replaced', () => {\n-        const fixture =\n-            initTest(FormControlWithValidators, MyCustomValidator, MyCustomAsyncValidator);\n+        const fixture = initTest(FormControlWithValidators, ViewValidatorA, AsyncViewValidatorA);\n         fixture.detectChanges();\n \n         const newControl = new FormControl('NEW')!;\n         const oldControl = fixture.componentInstance.form.get('login')!;\n \n-        const validatorSpy = validatorSpyOn(MyCustomValidator);\n-        const asyncValidatorSpy = validatorSpyOn(MyCustomAsyncValidator);\n+        const validatorSpy = validatorSpyOn(ViewValidatorA);\n+        const asyncValidatorSpy = validatorSpyOn(AsyncViewValidatorA);\n \n         // Update `login` form control with a new `FormControl` instance.\n         fixture.componentInstance.form.removeControl('login');\n@@ -2552,14 +2715,13 @@ import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n          }));\n \n       it('should call validators defined via `set[Async]Validators` after view init', () => {\n-        const fixture =\n-            initTest(FormControlWithValidators, MyCustomValidator, MyCustomAsyncValidator);\n+        const fixture = initTest(FormControlWithValidators, ViewValidatorA, AsyncViewValidatorA);\n         fixture.detectChanges();\n \n         const control = fixture.componentInstance.form.get('login')!;\n \n-        const initialValidatorSpy = validatorSpyOn(MyCustomValidator);\n-        const initialAsyncValidatorSpy = validatorSpyOn(MyCustomAsyncValidator);\n+        const initialValidatorSpy = validatorSpyOn(ViewValidatorA);\n+        const initialAsyncValidatorSpy = validatorSpyOn(AsyncViewValidatorA);\n \n         initialValidatorSpy.calls.reset();\n         initialAsyncValidatorSpy.calls.reset();\n@@ -2597,14 +2759,14 @@ import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n       it('should cleanup validators on a control used for multiple `formControlName` directives',\n          () => {\n            const fixture =\n-               initTest(NgForFormControlWithValidators, MyCustomValidator, MyCustomAsyncValidator);\n+               initTest(NgForFormControlWithValidators, ViewValidatorA, AsyncViewValidatorA);\n            fixture.detectChanges();\n \n            const newControl = new FormControl('b')!;\n            const oldControl = fixture.componentInstance.form.get('login')!;\n \n-           const validatorSpy = validatorSpyOn(MyCustomValidator);\n-           const asyncValidatorSpy = validatorSpyOn(MyCustomAsyncValidator);\n+           const validatorSpy = validatorSpyOn(ViewValidatorA);\n+           const asyncValidatorSpy = validatorSpyOn(AsyncViewValidatorA);\n \n            // Case 1: replace `login` form control with a new `FormControl` instance.\n            fixture.componentInstance.form.removeControl('login');\n@@ -2645,13 +2807,13 @@ import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n          });\n \n       it('should cleanup directive-specific callbacks only', () => {\n-        const fixture = initTest(MultipleFormControls, MyCustomValidator, MyCustomAsyncValidator);\n+        const fixture = initTest(MultipleFormControls, ViewValidatorA, AsyncViewValidatorA);\n         fixture.detectChanges();\n \n         const sharedControl = fixture.componentInstance.control;\n \n-        const validatorSpy = validatorSpyOn(MyCustomValidator);\n-        const asyncValidatorSpy = validatorSpyOn(MyCustomAsyncValidator);\n+        const validatorSpy = validatorSpyOn(ViewValidatorA);\n+        const asyncValidatorSpy = validatorSpyOn(AsyncViewValidatorA);\n \n         sharedControl.setValue('b');\n         fixture.detectChanges();\n@@ -2677,6 +2839,1202 @@ import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n         expect(fixture.nativeElement.querySelector('#login').value).toBe('d');\n         expectValidatorsToBeCalled(validatorSpy, asyncValidatorSpy, {ctx: sharedControl, count: 1});\n       });\n+\n+      it('should clean up callbacks when FormControlDirective is destroyed (simple)', () => {\n+        // Scenario:\n+        // ---------\n+        // [formControl] *ngIf\n+\n+        const control = new FormControl();\n+        addOwnValidatorsAndAttachSpies(control, {\n+          viewValidators: [ViewValidatorA, AsyncViewValidatorA],\n+          valueAccessor: ValueAccessorA,\n+        });\n+\n+        @Component({\n+          selector: 'app',\n+          template: `\n+            <input *ngIf=\"visible\" type=\"text\" [formControl]=\"control\" cva-a validators-a>\n+          `\n+        })\n+        class App {\n+          visible = true;\n+          control = control;\n+        }\n+\n+        const fixture = initCleanupTest(App);\n+\n+        resetSpies(control);\n+\n+        // Case 1: update control value and verify all spies were called.\n+        control.setValue('Initial value');\n+        fixture.detectChanges();\n+\n+        verifySpies(control, {\n+          ownValidators: control,\n+          viewValidators: control,\n+          valueAccessor: 'Initial value',\n+          valueChanges: 'Initial value',\n+        });\n+\n+        // Case 2: hide form control and verify no directive-related callbacks\n+        // (validators, value accessors) were invoked.\n+        fixture.componentInstance.visible = false;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(control);\n+\n+        control.setValue('Updated Value');\n+\n+        // Expectation:\n+        // - FormControlDirective was destroyed and connection to default value accessor and view\n+        //   validators should also be destroyed.\n+        verifySpies(control, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: control,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: 'Updated Value',\n+        });\n+\n+        // Case 3: make the form control visible again and verify all callbacks are correctly\n+        // attached.\n+        fixture.componentInstance.visible = true;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(control);\n+\n+        control.setValue('Updated Value (v2)');\n+\n+        verifySpies(control, {\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Updated Value (v2)',\n+          valueChanges: 'Updated Value (v2)',\n+        });\n+      });\n+\n+      it('should clean up when FormControlDirective is destroyed (multiple instances)', () => {\n+        // Scenario:\n+        // ---------\n+        // [formControl] *ngIf\n+        // [formControl]\n+\n+        const control = new FormControl();\n+        addOwnValidatorsAndAttachSpies(control, {\n+          viewValidators: [ViewValidatorA, AsyncViewValidatorA],\n+          valueAccessor: ValueAccessorA,\n+        });\n+\n+        @Component({\n+          selector: 'app',\n+          template: `\n+            <input type=\"text\" [formControl]=\"control\" cva-a validators-a *ngIf=\"visible\">\n+            <input type=\"text\" [formControl]=\"control\" cva-b>\n+          `\n+        })\n+        class App {\n+          visible = true;\n+          control = control;\n+        }\n+\n+        const fixture = initCleanupTest(App);\n+\n+        // Value accessor for the second <input> without *ngIf.\n+        const valueAccessorBSpy = spyOn(ValueAccessorB.prototype, 'writeValue');\n+\n+        // Reset all spies.\n+        valueAccessorBSpy.calls.reset();\n+        resetSpies(control);\n+\n+        // Case 1: update control value and verify all spies were called.\n+        control.setValue('Initial value');\n+        fixture.detectChanges();\n+\n+        expect(valueAccessorBSpy).toHaveBeenCalledWith('Initial value');\n+        verifySpies(control, {\n+          ownValidators: control,\n+          viewValidators: control,\n+          valueAccessor: 'Initial value',\n+          valueChanges: 'Initial value',\n+        });\n+\n+        // Case 2: hide form control and verify no directive-related callbacks\n+        // (validators, value accessors) were invoked.\n+        fixture.componentInstance.visible = false;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        valueAccessorBSpy.calls.reset();\n+        resetSpies(control);\n+\n+        control.setValue('Updated Value');\n+\n+        // Expectation:\n+        // - FormControlDirective was destroyed and connection to a value accessor and view\n+        //   validators should also be destroyed.\n+        // - Since there is a second instance of the FormControlDirective directive present in the\n+        //   template, we expect to see see calls to value accessor B (since it's applied to\n+        //   that directive instance) and validators applied on a control instance itself (not a\n+        //   part of a view setup).\n+        expect(valueAccessorBSpy).toHaveBeenCalledWith('Updated Value');\n+        verifySpies(control, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: control,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: 'Updated Value',\n+        });\n+      });\n+\n+      it('should clean up callbacks when FormControlName directive is destroyed', () => {\n+        // Scenario:\n+        // ---------\n+        // [formGroup]\n+        //   formControlName *ngIf\n+        //   formControlName\n+\n+        const control = new FormControl();\n+        addOwnValidatorsAndAttachSpies(control, {\n+          viewValidators: [ViewValidatorA, AsyncViewValidatorA],\n+          valueAccessor: ValueAccessorA,\n+        });\n+\n+        @Component({\n+          selector: 'app',\n+          template: `\n+            <div [formGroup]=\"group\">\n+              <input type=\"text\" formControlName=\"control\" cva-a validators-a *ngIf=\"visible\">\n+              <input type=\"text\" formControlName=\"control\" cva-b>\n+            </div>\n+          `\n+        })\n+        class App {\n+          visible = true;\n+          group = new FormGroup({control});\n+        }\n+\n+        const fixture = initCleanupTest(App);\n+\n+        // DefaultValueAccessor will be used for the second <input> where no custom CVA is defined.\n+        const valueAccessorBSpy = spyOn(ValueAccessorB.prototype, 'writeValue');\n+\n+        // Reset all spies.\n+        valueAccessorBSpy.calls.reset();\n+        resetSpies(control);\n+\n+        // Case 1: update control value and verify all spies were called.\n+        control.setValue('Initial value');\n+        fixture.detectChanges();\n+\n+        expect(valueAccessorBSpy).toHaveBeenCalledWith('Initial value');\n+        verifySpies(control, {\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Initial value',\n+          valueChanges: 'Initial value',\n+        });\n+\n+        // Case 2: hide form control and verify no directive-related callbacks\n+        // (validators, value accessors) were invoked.\n+        fixture.componentInstance.visible = false;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        valueAccessorBSpy.calls.reset();\n+        resetSpies(control);\n+\n+        control.setValue('Updated value');\n+\n+        // Expectation:\n+        // - `FormControlName` was destroyed and connection to the value accessor A and\n+        //   validators should also be destroyed.\n+        // - Since there is a second instance of `FormControlName` directive present in the\n+        //   template, we expect to see see calls to the value accessor B (since it's applied to\n+        //   that directive instance) and validators applied on a control instance itself (not a\n+        //   part of a view setup).\n+        expect(valueAccessorBSpy).toHaveBeenCalledWith('Updated value');\n+        verifySpies(control, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: control,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: 'Updated value',\n+        });\n+      });\n+\n+      it('should clean up callbacks when FormGroupDirective is destroyed', () => {\n+        // Scenario:\n+        // ---------\n+        // [formGroup] *ngIf\n+        //   [formControl]\n+\n+        const control = new FormControl();\n+        addOwnValidatorsAndAttachSpies(control, {\n+          viewValidators: [ViewValidatorA, AsyncViewValidatorA],\n+          valueAccessor: ValueAccessorA,\n+        });\n+\n+        const group = new FormGroup({control});\n+        addOwnValidatorsAndAttachSpies(group, {\n+          viewValidators: [ViewValidatorB, AsyncViewValidatorB],\n+        });\n+\n+        @Component({\n+          selector: 'app',\n+          template: `\n+            <ng-container *ngIf=\"visible\">\n+              <div [formGroup]=\"group\" validators-b>\n+                <input type=\"text\" [formControl]=\"control\" cva-a validators-a>\n+              </div>\n+            </ng-container>\n+          `\n+        })\n+        class App {\n+          visible = true;\n+          control = control;\n+          group = group;\n+        }\n+\n+        const fixture = initCleanupTest(App);\n+\n+        resetSpies(group, control);\n+\n+        // Case 1: update control value and verify that all spies were called.\n+        control.setValue('Initial value');\n+        fixture.detectChanges();\n+\n+        verifySpies(control, {\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Initial value',\n+          valueChanges: 'Initial value',\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {control: 'Initial value'},\n+        });\n+\n+\n+        // Case 2: hide form group and verify that no directive-related callbacks\n+        // (validators, value accessors) are invoked when we set control value later.\n+        fixture.componentInstance.visible = false;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(group, control);\n+\n+        control.setValue('Updated value');\n+\n+        // Expectation:\n+        // - `FormGroupDirective` and `FormControlDirective` were destroyed, so connection to value\n+        //   accessor and view validators should also be destroyed.\n+        // - Own validators directly attached to FormGroup and FormControl should still be invoked.\n+        verifySpies(control, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: control,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: 'Updated value',\n+        });\n+        verifySpies(group, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: group,\n+          valueChanges: {control: 'Updated value'},\n+        });\n+\n+        // Case 3: make the form control visible again and verify all callbacks are correctly\n+        // attached and invoked.\n+        fixture.componentInstance.visible = true;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(group, control);\n+\n+        control.setValue('Updated value (v2)');\n+\n+        verifySpies(control, {\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Updated value (v2)',\n+          valueChanges: 'Updated value (v2)',\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {control: 'Updated value (v2)'},\n+        });\n+      });\n+\n+      it('should clean up when FormControl is destroyed (but parent FormGroup exists)', () => {\n+        // Scenario:\n+        // ---------\n+        // [formGroup]\n+        //   [formControl] *ngIf\n+\n+        const control = new FormControl();\n+        addOwnValidatorsAndAttachSpies(control, {\n+          viewValidators: [ViewValidatorA, AsyncViewValidatorA],\n+          valueAccessor: ValueAccessorA,\n+        });\n+\n+        const group = new FormGroup({control});\n+        addOwnValidatorsAndAttachSpies(group, {\n+          viewValidators: [ViewValidatorB, AsyncViewValidatorB],\n+        });\n+\n+        @Component({\n+          selector: 'app',\n+          template: `\n+            <div [formGroup]=\"group\" validators-b>\n+              <input *ngIf=\"visible\" type=\"text\" [formControl]=\"control\" cva-a validators-a>\n+            </div>\n+          `\n+        })\n+        class App {\n+          visible = true;\n+          control = control;\n+          group = group;\n+        }\n+\n+        const fixture = initCleanupTest(App);\n+\n+        resetSpies(group, control);\n+\n+        // Case 1: update control value and verify that all spies were called.\n+        control.setValue('Initial value');\n+        fixture.detectChanges();\n+\n+        verifySpies(control, {\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Initial value',\n+          valueChanges: 'Initial value',\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {control: 'Initial value'},\n+        });\n+\n+\n+        // Case 2: hide form group and verify that no directive-related callbacks\n+        // (validators, value accessors) are invoked when we set control value later.\n+        fixture.componentInstance.visible = false;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(group, control);\n+\n+        group.setValue({control: 'Updated value'});\n+\n+        // Expectation:\n+        // - `FormControlDirective` was destroyed, so connection to value accessor and view\n+        //   validators should also be destroyed.\n+        // - Own validators directly attached to FormGroup and FormControl should still be invoked.\n+        // - `FormGroupDirective` was *not* destroyed, so all view validators should be invoked.\n+        verifySpies(control, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: control,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: 'Updated value',\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {control: 'Updated value'},\n+        });\n+      });\n+\n+      it('should clean up controls produced by *ngFor', () => {\n+        // Scenario:\n+        // ---------\n+        // [formGroup]\n+        //   [formControl] *ngFor\n+\n+        const control = new FormControl();\n+        addOwnValidatorsAndAttachSpies(control, {\n+          viewValidators: [ViewValidatorA, AsyncViewValidatorA],\n+          valueAccessor: ValueAccessorA,\n+        });\n+\n+        const group = new FormGroup({control});\n+        addOwnValidatorsAndAttachSpies(group, {\n+          viewValidators: [ViewValidatorB, AsyncViewValidatorB],\n+        });\n+\n+        @Component({\n+          selector: 'app',\n+          template: `\n+            <div [formGroup]=\"group\" validators-b *ngIf=\"visible\">\n+              <ng-container *ngFor=\"let login of logins\">\n+                <input type=\"radio\" [value]=\"login\" [formControl]=\"control\" cva-a validators-a>\n+              </ng-container>\n+            </div>\n+          `\n+        })\n+        class App {\n+          visible = true;\n+          control = control;\n+          group = group;\n+          logins = ['a', 'b', 'c'];\n+        }\n+\n+        const fixture = initCleanupTest(App);\n+\n+        resetSpies(group, control);\n+\n+        // Case 1: update control value and verify that all spies were called.\n+        control.setValue('Initial value');\n+        fixture.detectChanges();\n+\n+        verifySpies(control, {\n+          viewValidatorCallCount: 3,  // since *ngFor produces 3 [formControl]s\n+          valueAccessorCallCount: 3,  // since *ngFor produces 3 [formControl]s\n+          ownValidatorCallCount: 1,\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Initial value',\n+          valueChanges: 'Initial value',\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {control: 'Initial value'},\n+        });\n+\n+        // Case 2: update the list of logins which would result in cleanups for no longer needed\n+        // (thus destroyed) directives.\n+        fixture.componentInstance.logins = ['c', 'd'];\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(group, control);\n+\n+        control.setValue('Updated value');\n+\n+        verifySpies(control, {\n+          viewValidatorCallCount: 2,  // since now we have 2 items produced by *ngFor\n+          valueAccessorCallCount: 2,  // since now we have 2 items produced by *ngFor\n+          ownValidatorCallCount: 1,\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Updated value',\n+          valueChanges: 'Updated value',\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {control: 'Updated value'},\n+        });\n+\n+        // Case 3: hide form group and verify that no directive-related callbacks\n+        // (validators, value accessors) are invoked when we set control value later.\n+        fixture.componentInstance.visible = false;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(group, control);\n+\n+        control.setValue('Updated value (v2)');\n+\n+        verifySpies(control, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: control,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: 'Updated value (v2)',\n+        });\n+        verifySpies(group, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: group,\n+          valueChanges: {control: 'Updated value (v2)'},\n+        });\n+      });\n+\n+      it('should clean up when FormArrayName is destroyed (but parent FormGroup exists)', () => {\n+        // Scenario:\n+        // ---------\n+        // [formGroup]\n+        //   formArrayName\n+        //     formControlName *ngIf\n+\n+        const control = new FormControl();\n+        addOwnValidatorsAndAttachSpies(control, {\n+          viewValidators: [ViewValidatorA, AsyncViewValidatorA],\n+          valueAccessor: ValueAccessorA,\n+        });\n+\n+        const arr = new FormArray([control]);\n+        addOwnValidatorsAndAttachSpies(arr, {\n+          viewValidators: [ViewValidatorB, AsyncViewValidatorB],\n+        });\n+\n+        const group = new FormGroup({arr});\n+        addOwnValidatorsAndAttachSpies(group, {\n+          viewValidators: [ViewValidatorC, AsyncViewValidatorC],\n+        });\n+\n+        @Component({\n+          selector: 'app',\n+          template: `\n+            <div [formGroup]=\"group\" validators-c>\n+              <ng-container formArrayName=\"arr\" validators-b>\n+                <input *ngIf=\"visible\" type=\"text\" formControlName=\"0\" cva-a validators-a>\n+              </ng-container>\n+            </div>\n+          `\n+        })\n+        class App {\n+          visible = true;\n+          group = group;\n+        }\n+\n+        const fixture = initCleanupTest(App);\n+\n+        resetSpies(group, arr, control);\n+\n+        // Case 1: update control value and verify that all spies were called.\n+        control.setValue('Initial value');\n+        fixture.detectChanges();\n+\n+        verifySpies(control, {\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Initial value',\n+          valueChanges: 'Initial value',\n+        });\n+        verifySpies(arr, {\n+          viewValidators: arr,\n+          ownValidators: arr,\n+          valueChanges: ['Initial value'],\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {arr: ['Initial value']},\n+        });\n+\n+\n+        // Case 2: hide form group and verify that no directive-related callbacks\n+        // (validators, value accessors) are invoked when we set control value later.\n+        fixture.componentInstance.visible = false;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(group, arr, control);\n+\n+        control.setValue('Updated value');\n+\n+        // Expectation:\n+        // - `FormControlDirective` was destroyed, so connection to value accessor and view\n+        //   validators should also be destroyed.\n+        // - Own validators directly attached to FormGroup, FormArray and FormControl should still\n+        //   be invoked.\n+        // - `FormArrayName` was *not* destroyed, so all view validators should be invoked.\n+        verifySpies(control, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: control,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: 'Updated value',\n+        });\n+        verifySpies(arr, {\n+          viewValidators: arr,\n+          ownValidators: arr,\n+          valueChanges: ['Updated value'],\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {arr: ['Updated value']},\n+        });\n+      });\n+\n+      it('should clean up when FormArrayName is destroyed (but parent FormGroup exists)', () => {\n+        // Scenario:\n+        // ---------\n+        // [formGroup]\n+        //   formArrayName *ngIf\n+        //     formControlName\n+\n+        const control = new FormControl();\n+        addOwnValidatorsAndAttachSpies(control, {\n+          viewValidators: [ViewValidatorA, AsyncViewValidatorA],\n+          valueAccessor: ValueAccessorA,\n+        });\n+\n+        const arr = new FormArray([control]);\n+        addOwnValidatorsAndAttachSpies(arr, {\n+          viewValidators: [ViewValidatorB, AsyncViewValidatorB],\n+        });\n+\n+        const group = new FormGroup({arr});\n+        addOwnValidatorsAndAttachSpies(group, {\n+          viewValidators: [ViewValidatorC, AsyncViewValidatorC],\n+        });\n+\n+        @Component({\n+          selector: 'app',\n+          template: `\n+            <div [formGroup]=\"group\" validators-c>\n+              <ng-container *ngIf=\"visible\" formArrayName=\"arr\" validators-b>\n+                <input type=\"text\" formControlName=\"0\" cva-a validators-a>\n+              </ng-container>\n+            </div>\n+          `\n+        })\n+        class App {\n+          visible = true;\n+          group = group;\n+        }\n+\n+        const fixture = initCleanupTest(App);\n+\n+        resetSpies(group, arr, control);\n+\n+        // Case 1: update control value and verify that all spies were called.\n+        control.setValue('Initial value');\n+        fixture.detectChanges();\n+\n+        verifySpies(control, {\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Initial value',\n+          valueChanges: 'Initial value',\n+        });\n+        verifySpies(arr, {\n+          viewValidators: arr,\n+          ownValidators: arr,\n+          valueChanges: ['Initial value'],\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {arr: ['Initial value']},\n+        });\n+\n+\n+        // Case 2: hide form group and verify that no directive-related callbacks\n+        // (validators, value accessors) are invoked when we set control value later.\n+        fixture.componentInstance.visible = false;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(group, arr, control);\n+\n+        control.setValue('Updated value');\n+\n+        // Expectation:\n+        // - `FormArrayName` was destroyed, so connection to view validators should be destroyed.\n+        // - Own validators directly attached to FormGroup, FormArray and FormControl should still\n+        //   be invoked.\n+        verifySpies(control, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: control,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: 'Updated value',\n+        });\n+        verifySpies(arr, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: arr,\n+          valueChanges: ['Updated value'],\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {arr: ['Updated value']},\n+        });\n+\n+        // Case 3: make the form array control available again and verify all callbacks are\n+        // correctly attached and invoked.\n+        fixture.componentInstance.visible = true;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(group, arr, control);\n+\n+        control.setValue('Updated value (v2)');\n+\n+        verifySpies(control, {\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Updated value (v2)',\n+          valueChanges: 'Updated value (v2)',\n+        });\n+        verifySpies(arr, {\n+          viewValidators: arr,\n+          ownValidators: arr,\n+          valueChanges: ['Updated value (v2)'],\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {arr: ['Updated value (v2)']},\n+        });\n+      });\n+\n+      it('should clean up all child controls when FormGroup is destroyed', () => {\n+        // Scenario:\n+        // ---------\n+        // [formGroup] *ngIf\n+        //   formArrayName\n+        //     formControlName\n+\n+        const control = new FormControl();\n+        addOwnValidatorsAndAttachSpies(control, {\n+          viewValidators: [ViewValidatorA, AsyncViewValidatorA],\n+          valueAccessor: ValueAccessorA,\n+        });\n+\n+        const arr = new FormArray([control]);\n+        addOwnValidatorsAndAttachSpies(arr, {\n+          viewValidators: [ViewValidatorB, AsyncViewValidatorB],\n+        });\n+\n+        const group = new FormGroup({arr});\n+        addOwnValidatorsAndAttachSpies(group, {\n+          viewValidators: [ViewValidatorC, AsyncViewValidatorC],\n+        });\n+\n+        @Component({\n+          selector: 'app',\n+          template: `\n+            <div [formGroup]=\"group\" validators-c *ngIf=\"visible\">\n+              <ng-container formArrayName=\"arr\" validators-b>\n+                <input type=\"text\" formControlName=\"0\" cva-a validators-a>\n+              </ng-container>\n+            </div>\n+          `\n+        })\n+        class App {\n+          visible = true;\n+          group = group;\n+        }\n+\n+        const fixture = initCleanupTest(App);\n+\n+        resetSpies(group, arr, control);\n+\n+        // Case 1: update control value and verify that all spies were called.\n+        control.setValue('Initial value');\n+        fixture.detectChanges();\n+\n+        verifySpies(control, {\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Initial value',\n+          valueChanges: 'Initial value',\n+        });\n+        verifySpies(arr, {\n+          viewValidators: arr,\n+          ownValidators: arr,\n+          valueChanges: ['Initial value'],\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {arr: ['Initial value']},\n+        });\n+\n+\n+        // Case 2: hide form group and verify that no directive-related callbacks\n+        // (validators, value accessors) are invoked when we set control value later.\n+        fixture.componentInstance.visible = false;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(group, arr, control);\n+\n+        control.setValue('Updated value');\n+\n+        // Expectation:\n+        // - `FormArrayName` was destroyed, so connection to view validators should be destroyed.\n+        // - Own validators directly attached to FormGroup, FormArray and FormControl should still\n+        //   be invoked.\n+        verifySpies(control, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: control,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: 'Updated value',\n+        });\n+        verifySpies(arr, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: arr,\n+          valueChanges: ['Updated value'],\n+        });\n+        verifySpies(group, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: group,\n+          valueChanges: {arr: ['Updated value']},\n+        });\n+\n+        // Case 3: make the form group available again and verify all callbacks are correctly\n+        // attached and invoked.\n+        fixture.componentInstance.visible = true;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(group, arr, control);\n+\n+        control.setValue('Updated value (v2)');\n+\n+        verifySpies(control, {\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Updated value (v2)',\n+          valueChanges: 'Updated value (v2)',\n+        });\n+        verifySpies(arr, {\n+          viewValidators: arr,\n+          ownValidators: arr,\n+          valueChanges: ['Updated value (v2)'],\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {arr: ['Updated value (v2)']},\n+        });\n+      });\n+\n+      it('should clean up all child controls (with *ngFor) when FormArrayName is destroyed', () => {\n+        // Scenario:\n+        // ---------\n+        // [formGroup]\n+        //   formArrayName *ngIf\n+        //     formControlName *ngFor\n+\n+        const controlA = new FormControl('A');\n+        addOwnValidatorsAndAttachSpies(controlA, {\n+          viewValidators: [ViewValidatorA, AsyncViewValidatorA],\n+          valueAccessor: ValueAccessorA,\n+        });\n+\n+        const controlB = new FormControl('B');\n+        // Note: since ControlA and ControlB share the same set of validators and value accessor, we\n+        // add spies just ones while configuring ControlA (it's not possible to add spies multiple\n+        // times).\n+        addOwnValidatorsAndAttachSpies(controlB, {});\n+\n+        const arr = new FormArray([controlA, controlB]);\n+        addOwnValidatorsAndAttachSpies(arr, {\n+          viewValidators: [ViewValidatorB, AsyncViewValidatorB],\n+        });\n+\n+        const group = new FormGroup({arr});\n+        addOwnValidatorsAndAttachSpies(group, {\n+          viewValidators: [ViewValidatorC, AsyncViewValidatorC],\n+        });\n+\n+        @Component({\n+          selector: 'app',\n+          template: `\n+            <div [formGroup]=\"group\" validators-c>\n+              <ng-container formArrayName=\"arr\" validators-b *ngIf=\"visible\">\n+                <ng-container *ngFor=\"let i of ids\">\n+                  <input type=\"text\" [formControlName]=\"i\" cva-a validators-a>\n+                </ng-container>\n+              </ng-container>\n+            </div>\n+          `\n+        })\n+        class App {\n+          visible = true;\n+          group = group;\n+          ids = [0, 1];\n+        }\n+\n+        const fixture = initCleanupTest(App);\n+\n+        resetSpies(group, arr, controlA, controlB);\n+\n+        // Case 1: update control value and verify that all spies were called.\n+        controlA.setValue('Updated A');\n+        fixture.detectChanges();\n+\n+        verifySpies(controlA, {\n+          viewValidators: controlA,\n+          ownValidators: controlA,\n+          valueAccessor: 'Updated A',\n+          valueChanges: 'Updated A',\n+        });\n+        verifySpies(controlB, {\n+          // ControlB is a sibling to ControlA, so updating ControlA has no effect on ControlB.\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: SHOULD_NOT_BE_CALLED,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: SHOULD_NOT_BE_CALLED,\n+        });\n+        verifySpies(arr, {\n+          viewValidators: arr,\n+          ownValidators: arr,\n+          valueChanges: ['Updated A', 'B'],\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {arr: ['Updated A', 'B']},\n+        });\n+\n+        // Case 2: remove ControlA from the view by updating the list of ids.\n+        // Verify that ControlA is detached from the view, but ControlB still works.\n+        fixture.componentInstance.ids = [1];\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(group, arr, controlA, controlB);\n+\n+        controlA.setValue('Updated A (v2)');\n+\n+        verifySpies(controlA, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: controlA,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: 'Updated A (v2)',\n+        });\n+        verifySpies(controlB, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: SHOULD_NOT_BE_CALLED,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: SHOULD_NOT_BE_CALLED,\n+        });\n+        verifySpies(arr, {\n+          viewValidators: arr,\n+          ownValidators: arr,\n+          valueChanges: ['Updated A (v2)', 'B'],\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {arr: ['Updated A (v2)', 'B']},\n+        });\n+\n+        // Case 3: hide form group and verify that no directive-related callbacks\n+        // (validators, value accessors) are invoked when we set control value later.\n+        fixture.componentInstance.visible = false;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(group, arr, controlA, controlB);\n+\n+        controlB.setValue('Updated B');\n+\n+        // Expectation:\n+        // - `FormArrayName` was destroyed, so connection to view validators should be destroyed.\n+        // - Own validators directly attached to FormGroup, FormArray and FormControl should still\n+        //   be invoked.\n+        verifySpies(controlA, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: SHOULD_NOT_BE_CALLED,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: SHOULD_NOT_BE_CALLED,\n+        });\n+        verifySpies(controlB, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: controlB,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: 'Updated B',\n+        });\n+        verifySpies(arr, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: arr,\n+          valueChanges: ['Updated A (v2)', 'Updated B'],\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {arr: ['Updated A (v2)', 'Updated B']},\n+        });\n+      });\n+\n+      it('should clean up all child controls when FormGroupName is destroyed', () => {\n+        // Scenario:\n+        // ---------\n+        // [formGroup]\n+        //   formGroupName *ngIf\n+        //     formControlName\n+\n+        const control = new FormControl();\n+        addOwnValidatorsAndAttachSpies(control, {\n+          viewValidators: [ViewValidatorA, AsyncViewValidatorA],\n+          valueAccessor: ValueAccessorA,\n+        });\n+\n+        const group = new FormGroup({control});\n+        addOwnValidatorsAndAttachSpies(group, {\n+          viewValidators: [ViewValidatorB, AsyncViewValidatorB],\n+        });\n+\n+        const root = new FormGroup({group});\n+        addOwnValidatorsAndAttachSpies(root, {\n+          viewValidators: [ViewValidatorC, AsyncViewValidatorC],\n+        });\n+\n+        @Component({\n+          selector: 'app',\n+          template: `\n+            <div [formGroup]=\"root\" validators-c>\n+              <ng-container formGroupName=\"group\" validators-b *ngIf=\"visible\">\n+                <input type=\"text\" formControlName=\"control\" cva-a validators-a>\n+              </ng-container>\n+            </div>\n+          `\n+        })\n+        class App {\n+          visible = true;\n+          root = root;\n+        }\n+\n+        const fixture = initCleanupTest(App);\n+\n+        resetSpies(root, group, control);\n+\n+        // Case 1: update control value and verify that all spies were called.\n+        control.setValue('Initial value');\n+        fixture.detectChanges();\n+\n+        verifySpies(control, {\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Initial value',\n+          valueChanges: 'Initial value',\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {control: 'Initial value'},\n+        });\n+        verifySpies(root, {\n+          viewValidators: root,\n+          ownValidators: root,\n+          valueChanges: {group: {control: 'Initial value'}},\n+        });\n+\n+\n+        // Case 2: hide form group and verify that no directive-related callbacks\n+        // (validators, value accessors) are invoked when we set control value later.\n+        fixture.componentInstance.visible = false;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(root, group, control);\n+\n+        control.setValue('Updated value');\n+\n+        // Expectation:\n+        // - `FormGroupName` was destroyed, so connection to view validators should be destroyed.\n+        // - Own validators directly attached to FormGroups and FormControl should still\n+        //   be invoked.\n+        verifySpies(control, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: control,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: 'Updated value',\n+        });\n+        verifySpies(group, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: group,\n+          valueChanges: {control: 'Updated value'},\n+        });\n+        verifySpies(root, {\n+          viewValidators: root,\n+          ownValidators: root,\n+          valueChanges: {group: {control: 'Updated value'}},\n+        });\n+      });\n+\n+      it('should clean up all child controls when FormGroup is destroyed', () => {\n+        // Scenario:\n+        // ---------\n+        // [formGroup] *ngIf\n+        //   formGroupName\n+        //     formControlName\n+\n+        const control = new FormControl();\n+        addOwnValidatorsAndAttachSpies(control, {\n+          viewValidators: [ViewValidatorA, AsyncViewValidatorA],\n+          valueAccessor: ValueAccessorA,\n+        });\n+\n+        const group = new FormGroup({control});\n+        addOwnValidatorsAndAttachSpies(group, {\n+          viewValidators: [ViewValidatorB, AsyncViewValidatorB],\n+        });\n+\n+        const root = new FormGroup({group});\n+        addOwnValidatorsAndAttachSpies(root, {\n+          viewValidators: [ViewValidatorC, AsyncViewValidatorC],\n+        });\n+\n+        @Component({\n+          selector: 'app',\n+          template: `\n+            <div [formGroup]=\"root\" validators-c *ngIf=\"visible\">\n+              <ng-container formGroupName=\"group\" validators-b>\n+                <input type=\"text\" formControlName=\"control\" cva-a validators-a>\n+              </ng-container>\n+            </div>\n+          `\n+        })\n+        class App {\n+          visible = true;\n+          root = root;\n+        }\n+\n+        const fixture = initCleanupTest(App);\n+\n+        resetSpies(root, group, control);\n+\n+        // Case 1: update control value and verify that all spies were called.\n+        control.setValue('Initial value');\n+        fixture.detectChanges();\n+\n+        verifySpies(control, {\n+          viewValidators: control,\n+          ownValidators: control,\n+          valueAccessor: 'Initial value',\n+          valueChanges: 'Initial value',\n+        });\n+        verifySpies(group, {\n+          viewValidators: group,\n+          ownValidators: group,\n+          valueChanges: {control: 'Initial value'},\n+        });\n+        verifySpies(root, {\n+          viewValidators: root,\n+          ownValidators: root,\n+          valueChanges: {group: {control: 'Initial value'}},\n+        });\n+\n+\n+        // Case 2: hide form group and verify that no directive-related callbacks\n+        // (validators, value accessors) are invoked when we set control value later.\n+        fixture.componentInstance.visible = false;\n+        fixture.detectChanges();\n+\n+        // Reset all spies again, prepare for next check.\n+        resetSpies(root, group, control);\n+\n+        control.setValue('Updated value');\n+\n+        // Expectation:\n+        // - `FormGroup` was destroyed, so connection to view validators should be destroyed.\n+        // - Own validators directly attached to FormGroups and FormControl should still\n+        //   be invoked.\n+        verifySpies(control, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: control,\n+          valueAccessor: SHOULD_NOT_BE_CALLED,\n+          valueChanges: 'Updated value',\n+        });\n+        verifySpies(group, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: group,\n+          valueChanges: {control: 'Updated value'},\n+        });\n+        verifySpies(root, {\n+          viewValidators: SHOULD_NOT_BE_CALLED,\n+          ownValidators: root,\n+          valueChanges: {group: {control: 'Updated value'}},\n+        });\n+      });\n     });\n   });\n }\n@@ -2914,7 +4272,7 @@ class UniqLoginWrapper {\n @Component({\n   selector: 'form-group-with-validators',\n   template: `\n-    <div [formGroup]=\"form\" my-custom-validator my-custom-async-validator>\n+    <div [formGroup]=\"form\" validators-a>\n       <input type=\"text\" formControlName=\"login\">\n     </div>\n   `\n@@ -2946,7 +4304,7 @@ class FormControlWithAsyncValidatorFn {\n   selector: 'form-control-with-validators',\n   template: `\n     <div [formGroup]=\"form\">\n-      <input type=\"text\" formControlName=\"login\" my-custom-validator my-custom-async-validator>\n+      <input type=\"text\" formControlName=\"login\" validators-a>\n     </div>\n   `\n })\n@@ -2958,21 +4316,10 @@ class FormControlWithValidators {\n   selector: 'ngfor-form-controls-with-validators',\n   template: `\n     <div [formGroup]=\"formA\">\n-      <input\n-        type=\"radio\"\n-        formControlName=\"login\"\n-        my-custom-validator\n-        my-custom-async-validator\n-      />\n+      <input type=\"radio\" formControlName=\"login\" validators-a>\n     </div>\n     <div [formGroup]=\"formB\">\n-      <input\n-        id=\"login\"\n-        type=\"text\"\n-        formControlName=\"login\"\n-        my-custom-validator\n-        my-custom-async-validator\n-      />\n+      <input type=\"text\" formControlName=\"login\" validators-a id=\"login\">\n     </div>\n   `\n })\n@@ -2987,40 +4334,12 @@ class MultipleFormControls {\n   template: `\n     <div [formGroup]=\"form\">\n       <ng-container *ngFor=\"let login of logins\">\n-        <input type=\"radio\" formControlName=\"login\" [value]=\"login\" my-custom-validator my-custom-async-validator>\n+        <input type=\"radio\" formControlName=\"login\" [value]=\"login\" validators-a>\n       </ng-container>\n     </div>\n   `\n })\n class NgForFormControlWithValidators {\n   form = new FormGroup({login: new FormControl('a')});\n   logins = ['a', 'b', 'c'];\n-}\n-\n-@Directive({\n-  selector: '[my-custom-validator]',\n-  providers: [{\n-    provide: NG_VALIDATORS,\n-    useClass: forwardRef(() => MyCustomValidator),\n-    multi: true,\n-  }]\n-})\n-class MyCustomValidator implements Validator {\n-  validate(control: AbstractControl) {\n-    return null;\n-  }\n-}\n-\n-@Directive({\n-  selector: '[my-custom-async-validator]',\n-  providers: [{\n-    provide: NG_ASYNC_VALIDATORS,\n-    useClass: forwardRef(() => MyCustomAsyncValidator),\n-    multi: true,\n-  }]\n-})\n-class MyCustomAsyncValidator implements AsyncValidator {\n-  validate(control: AbstractControl) {\n-    return Promise.resolve(null);\n-  }\n }\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 1613,
        "additions": 1524,
        "deletions": 89
    }
}