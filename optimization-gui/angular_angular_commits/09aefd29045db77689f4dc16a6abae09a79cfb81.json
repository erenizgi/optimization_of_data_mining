{
    "author": "zarend",
    "message": "fix(compiler-cli): add `useInlining` option to type check config (#41043)\n\nThis commit fixes the behavior when creating a type constructor for a directive when the following\nconditions are met.\n1. The directive has bound generic parameters.\n2. Inlining is not available. (This happens for language service compiles).\n\nPreviously, we would throw an error saying 'Inlining is not supported in this environment.' The\ncompiler would stop type checking, and the developer could lose out on getting errors after the\ncompiler gives up.\n\nThis commit adds a useInlineTypeConstructors to the type check config. When set to false, we use\n`any` type for bound generic parameters to avoid crashing. When set to true, we inline the type\nconstructor when inlining is required.\n\nAddresses #40963\n\nPR Close #41043",
    "sha": "09aefd29045db77689f4dc16a6abae09a79cfb81",
    "files": [
        {
            "sha": "d483243aad945a0a34e9a951048644952a48e142",
            "filename": "packages/compiler-cli/src/ngtsc/core/src/compiler.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts?ref=09aefd29045db77689f4dc16a6abae09a79cfb81",
            "patch": "@@ -658,6 +658,8 @@ export class NgCompiler {\n     // is not disabled when `strictTemplates` is enabled.\n     const strictTemplates = !!this.options.strictTemplates;\n \n+    const useInlineTypeConstructors = this.typeCheckingProgramStrategy.supportsInlineOperations;\n+\n     // First select a type-checking configuration, based on whether full template type-checking is\n     // requested.\n     let typeCheckingConfig: TypeCheckingConfig;\n@@ -689,6 +691,7 @@ export class NgCompiler {\n         useContextGenericType: strictTemplates,\n         strictLiteralTypes: true,\n         enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n+        useInlineTypeConstructors,\n       };\n     } else {\n       typeCheckingConfig = {\n@@ -713,6 +716,7 @@ export class NgCompiler {\n         useContextGenericType: false,\n         strictLiteralTypes: false,\n         enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n+        useInlineTypeConstructors,\n       };\n     }\n "
        },
        {
            "sha": "81b8c998e9a1c13ad9ac361d423e9ec0b810c426",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/api.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts?ref=09aefd29045db77689f4dc16a6abae09a79cfb81",
            "patch": "@@ -260,6 +260,21 @@ export interface TypeCheckingConfig {\n    * literals are cast to `any` when declared.\n    */\n   strictLiteralTypes: boolean;\n+\n+  /**\n+   * Whether to use inline type constructors.\n+   *\n+   * If this is `true`, create inline type constructors when required. For example, if a type\n+   * constructor's parameters has private types, it cannot be created normally, so we inline it in\n+   * the directives definition file.\n+   *\n+   * If false, do not create inline type constructors. Fall back to using `any` type for\n+   * constructors that normally require inlining.\n+   *\n+   * This option requires the environment to support inlining. If the environment does not support\n+   * inlining, this must be set to `false`.\n+   */\n+  useInlineTypeConstructors: boolean;\n }\n \n "
        },
        {
            "sha": "42bc6b79e93d490a805c5d693ecf21a2b11021cd",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/context.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 21,
            "changes": 39,
            "blob_url": "https://github.com/angular/angular/blob/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "raw_url": "https://github.com/angular/angular/raw/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts?ref=09aefd29045db77689f4dc16a6abae09a79cfb81",
            "patch": "@@ -179,7 +179,12 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n       private compilerHost: Pick<ts.CompilerHost, 'getCanonicalFileName'>,\n       private componentMappingStrategy: ComponentToShimMappingStrategy,\n       private refEmitter: ReferenceEmitter, private reflector: ReflectionHost,\n-      private host: TypeCheckingHost, private inlining: InliningMode) {}\n+      private host: TypeCheckingHost, private inlining: InliningMode) {\n+    if (inlining === InliningMode.Error && config.useInlineTypeConstructors) {\n+      // We cannot use inlining for type checking since this environment does not support it.\n+      throw new Error(`AssertionError: invalid inlining configuration.`);\n+    }\n+  }\n \n   /**\n    * A `Map` of `ts.SourceFile`s that the context has seen to the operations (additions of methods\n@@ -219,23 +224,21 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n           ...this.getTemplateDiagnostics(parseErrors, templateId, sourceMapping));\n     }\n \n-    // Accumulate a list of any directives which could not have type constructors generated due to\n-    // unsupported inlining operations.\n-    let missingInlines: ClassDeclaration[] = [];\n-\n     const boundTarget = binder.bind({template});\n \n-    // Get all of the directives used in the template and record type constructors for all of them.\n-    for (const dir of boundTarget.getUsedDirectives()) {\n-      const dirRef = dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n-      const dirNode = dirRef.node;\n+    if (this.inlining === InliningMode.InlineOps) {\n+      // Get all of the directives used in the template and record inline type constructors when\n+      // required.\n+      for (const dir of boundTarget.getUsedDirectives()) {\n+        const dirRef = dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n+        const dirNode = dirRef.node;\n \n-      if (dir.isGeneric && requiresInlineTypeCtor(dirNode, this.reflector)) {\n-        if (this.inlining === InliningMode.Error) {\n-          missingInlines.push(dirNode);\n+        if (!dir.isGeneric || !requiresInlineTypeCtor(dirNode, this.reflector)) {\n+          // inlining not required\n           continue;\n         }\n-        // Add a type constructor operation for the directive.\n+\n+        // Add an inline type constructor operation for the directive.\n         this.addInlineTypeCtor(fileData, dirNode.getSourceFile(), dirRef, {\n           fnName: 'ngTypeCtor',\n           // The constructor should have a body if the directive comes from a .ts file, but not if\n@@ -262,18 +265,12 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n \n     // If inlining is not supported, but is required for either the TCB or one of its directive\n     // dependencies, then exit here with an error.\n-    if (this.inlining === InliningMode.Error && (tcbRequiresInline || missingInlines.length > 0)) {\n+    if (this.inlining === InliningMode.Error && tcbRequiresInline) {\n       // This template cannot be supported because the underlying strategy does not support inlining\n       // and inlining would be required.\n \n       // Record diagnostics to indicate the issues with this template.\n-      if (tcbRequiresInline) {\n-        shimData.oobRecorder.requiresInlineTcb(templateId, ref.node);\n-      }\n-\n-      if (missingInlines.length > 0) {\n-        shimData.oobRecorder.requiresInlineTypeConstructors(templateId, ref.node, missingInlines);\n-      }\n+      shimData.oobRecorder.requiresInlineTcb(templateId, ref.node);\n \n       // Checking this template would be unsupported, so don't try.\n       return;"
        },
        {
            "sha": "2d2fdb734de20be406f8b95fae596cba4f3439a1",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/environment.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "raw_url": "https://github.com/angular/angular/raw/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts?ref=09aefd29045db77689f4dc16a6abae09a79cfb81",
            "patch": "@@ -43,7 +43,7 @@ export class Environment {\n \n   constructor(\n       readonly config: TypeCheckingConfig, protected importManager: ImportManager,\n-      private refEmitter: ReferenceEmitter, private reflector: ReflectionHost,\n+      private refEmitter: ReferenceEmitter, readonly reflector: ReflectionHost,\n       protected contextFile: ts.SourceFile) {}\n \n   /**"
        },
        {
            "sha": "6a6a6abdad938f01fbd96f3f209a33007122da29",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 89,
            "deletions": 16,
            "changes": 105,
            "blob_url": "https://github.com/angular/angular/blob/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=09aefd29045db77689f4dc16a6abae09a79cfb81",
            "patch": "@@ -11,7 +11,7 @@ import * as ts from 'typescript';\n \n import {Reference} from '../../imports';\n import {ClassPropertyName} from '../../metadata';\n-import {ClassDeclaration} from '../../reflection';\n+import {ClassDeclaration, ReflectionHost} from '../../reflection';\n import {TemplateId, TypeCheckableDirectiveMeta, TypeCheckBlockMetadata} from '../api';\n \n import {addExpressionIdentifier, ExpressionIdentifier, markIgnoreDiagnostics} from './comments';\n@@ -21,7 +21,8 @@ import {Environment} from './environment';\n import {astToTypescript, NULL_AS_ANY} from './expression';\n import {OutOfBandDiagnosticRecorder} from './oob';\n import {ExpressionSemanticVisitor} from './template_semantics';\n-import {tsCallMethod, tsCastToAny, tsCreateElement, tsCreateTypeQueryForCoercedInput, tsCreateVariable, tsDeclareVariable} from './ts_util';\n+import {checkIfGenericTypesAreUnbound, tsCallMethod, tsCastToAny, tsCreateElement, tsCreateTypeQueryForCoercedInput, tsCreateVariable, tsDeclareVariable} from './ts_util';\n+import {requiresInlineTypeCtor} from './type_constructor';\n \n /**\n  * Given a `ts.ClassDeclaration` for a component, and metadata regarding that component, compose a\n@@ -357,18 +358,13 @@ class TcbTextInterpolationOp extends TcbOp {\n }\n \n /**\n- * A `TcbOp` which constructs an instance of a directive _without_ setting any of its inputs. Inputs\n- * are later set in the `TcbDirectiveInputsOp`. Type checking was found to be faster when done in\n- * this way as opposed to `TcbDirectiveCtorOp` which is only necessary when the directive is\n- * generic.\n- *\n- * Executing this operation returns a reference to the directive instance variable with its inferred\n- * type.\n+ * A `TcbOp` which constructs an instance of a directive. For generic directives, generic\n+ * parameters are set to `any` type.\n  */\n-class TcbDirectiveTypeOp extends TcbOp {\n+abstract class TcbDirectiveTypeOpBase extends TcbOp {\n   constructor(\n-      private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n-      private dir: TypeCheckableDirectiveMeta) {\n+      protected tcb: Context, protected scope: Scope,\n+      protected node: TmplAstTemplate|TmplAstElement, protected dir: TypeCheckableDirectiveMeta) {\n     super();\n   }\n \n@@ -380,16 +376,74 @@ class TcbDirectiveTypeOp extends TcbOp {\n   }\n \n   execute(): ts.Identifier {\n-    const id = this.tcb.allocateId();\n+    const dirRef = this.dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n+\n+    const rawType = this.tcb.env.referenceType(this.dir.ref);\n+\n+    let type: ts.TypeNode;\n+    if (this.dir.isGeneric === false || dirRef.node.typeParameters === undefined) {\n+      type = rawType;\n+    } else {\n+      if (!ts.isTypeReferenceNode(rawType)) {\n+        throw new Error(\n+            `Expected TypeReferenceNode when referencing the type for ${this.dir.ref.debugName}`);\n+      }\n+      const typeArguments = dirRef.node.typeParameters.map(\n+          () => ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n+      type = ts.factory.createTypeReferenceNode(rawType.typeName, typeArguments);\n+    }\n \n-    const type = this.tcb.env.referenceType(this.dir.ref);\n+    const id = this.tcb.allocateId();\n     addExpressionIdentifier(type, ExpressionIdentifier.DIRECTIVE);\n     addParseSpanInfo(type, this.node.startSourceSpan || this.node.sourceSpan);\n     this.scope.addStatement(tsDeclareVariable(id, type));\n     return id;\n   }\n }\n \n+/**\n+ * A `TcbOp` which constructs an instance of a non-generic directive _without_ setting any of its\n+ * inputs. Inputs  are later set in the `TcbDirectiveInputsOp`. Type checking was found to be\n+ * faster when done in this way as opposed to `TcbDirectiveCtorOp` which is only necessary when the\n+ * directive is generic.\n+ *\n+ * Executing this operation returns a reference to the directive instance variable with its inferred\n+ * type.\n+ */\n+class TcbNonGenericDirectiveTypeOp extends TcbDirectiveTypeOpBase {\n+  /**\n+   * Creates a variable declaration for this op's directive of the argument type. Returns the id of\n+   * the newly created variable.\n+   */\n+  execute(): ts.Identifier {\n+    const dirRef = this.dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n+    if (this.dir.isGeneric) {\n+      throw new Error(`Assertion Error: expected ${dirRef.debugName} not to be generic.`);\n+    }\n+    return super.execute();\n+  }\n+}\n+\n+/**\n+ * A `TcbOp` which constructs an instance of a generic directive with its generic parameters set\n+ * to `any` type. This op is like `TcbDirectiveTypeOp`, except that generic parameters are set to\n+ * `any` type. This is used for situations where we want to avoid inlining.\n+ *\n+ * Executing this operation returns a reference to the directive instance variable with its generic\n+ * type parameters set to `any`.\n+ */\n+class TcbGenericDirectiveTypeWithAnyParamsOp extends TcbDirectiveTypeOpBase {\n+  execute(): ts.Identifier {\n+    const dirRef = this.dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n+    if (dirRef.node.typeParameters === undefined) {\n+      throw new Error(`Assertion Error: expected typeParameters when creating a declaration for ${\n+          dirRef.debugName}`);\n+    }\n+\n+    return super.execute();\n+  }\n+}\n+\n /**\n  * A `TcbOp` which creates a variable for a local ref in a template.\n  * The initializer for the variable is the variable expression for the directive, template, or\n@@ -1383,8 +1437,27 @@ class Scope {\n \n     const dirMap = new Map<TypeCheckableDirectiveMeta, number>();\n     for (const dir of directives) {\n-      const directiveOp = dir.isGeneric ? new TcbDirectiveCtorOp(this.tcb, this, node, dir) :\n-                                          new TcbDirectiveTypeOp(this.tcb, this, node, dir);\n+      let directiveOp: TcbOp;\n+      const host = this.tcb.env.reflector;\n+      const dirRef = dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n+\n+      if (!dir.isGeneric) {\n+        // The most common case is that when a directive is not generic, we use the normal\n+        // `TcbNonDirectiveTypeOp`.\n+        directiveOp = new TcbNonGenericDirectiveTypeOp(this.tcb, this, node, dir);\n+      } else if (\n+          !requiresInlineTypeCtor(dirRef.node, host) ||\n+          this.tcb.env.config.useInlineTypeConstructors) {\n+        // For generic directives, we use a type constructor to infer types. If a directive requires\n+        // an inline type constructor, then inlining must be available to use the\n+        // `TcbDirectiveCtorOp`. If not we, we fallback to using `any` – see below.\n+        directiveOp = new TcbDirectiveCtorOp(this.tcb, this, node, dir);\n+      } else {\n+        // If inlining is not available, then we give up on infering the generic params, and use\n+        // `any` type for the directive's generic parameters.\n+        directiveOp = new TcbGenericDirectiveTypeWithAnyParamsOp(this.tcb, this, node, dir);\n+      }\n+\n       const dirIndex = this.opQueue.push(directiveOp) - 1;\n       dirMap.set(dir, dirIndex);\n "
        },
        {
            "sha": "e3935db0153f8b4832375d49b629d07e7ee2ea2f",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/test_utils.ts",
            "status": "modified",
            "additions": 46,
            "deletions": 19,
            "changes": 65,
            "blob_url": "https://github.com/angular/angular/blob/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts?ref=09aefd29045db77689f4dc16a6abae09a79cfb81",
            "patch": "@@ -166,7 +166,7 @@ export function ngForTypeCheckTarget(): TypeCheckingTarget {\n   };\n }\n \n-export const ALL_ENABLED_CONFIG: TypeCheckingConfig = {\n+export const ALL_ENABLED_CONFIG: Readonly<TypeCheckingConfig> = {\n   applyTemplateContextGuards: true,\n   checkQueries: false,\n   checkTemplateBodies: true,\n@@ -188,37 +188,55 @@ export const ALL_ENABLED_CONFIG: TypeCheckingConfig = {\n   useContextGenericType: true,\n   strictLiteralTypes: true,\n   enableTemplateTypeChecker: false,\n+  useInlineTypeConstructors: true\n };\n \n // Remove 'ref' from TypeCheckableDirectiveMeta and add a 'selector' instead.\n-export type TestDirective = Partial<Pick<\n+export interface TestDirective extends Partial<Pick<\n     TypeCheckableDirectiveMeta,\n     Exclude<\n         keyof TypeCheckableDirectiveMeta,\n         'ref'|'coercedInputFields'|'restrictedInputFields'|'stringLiteralInputFields'|\n-        'undeclaredInputFields'|'inputs'|'outputs'>>>&{\n-  selector: string, name: string, file?: AbsoluteFsPath, type: 'directive',\n-      inputs?: {[fieldName: string]: string}, outputs?: {[fieldName: string]: string},\n-      coercedInputFields?: string[], restrictedInputFields?: string[],\n-      stringLiteralInputFields?: string[], undeclaredInputFields?: string[], isGeneric?: boolean;\n-};\n+        'undeclaredInputFields'|'inputs'|'outputs'>>> {\n+  selector: string;\n+  name: string;\n+  file?: AbsoluteFsPath;\n+  type: 'directive';\n+  inputs?: {[fieldName: string]: string};\n+  outputs?: {[fieldName: string]: string};\n+  coercedInputFields?: string[];\n+  restrictedInputFields?: string[];\n+  stringLiteralInputFields?: string[];\n+  undeclaredInputFields?: string[];\n+  isGeneric?: boolean;\n+  code?: string;\n+}\n \n-export type TestPipe = {\n-  name: string,\n-  file?: AbsoluteFsPath, pipeName: string, type: 'pipe',\n-};\n+export interface TestPipe {\n+  name: string;\n+  file?: AbsoluteFsPath;\n+  pipeName: string;\n+  type: 'pipe';\n+  code?: string;\n+}\n \n export type TestDeclaration = TestDirective|TestPipe;\n \n export function tcb(\n-    template: string, declarations: TestDeclaration[] = [], config?: TypeCheckingConfig,\n+    template: string, declarations: TestDeclaration[] = [], config?: Partial<TypeCheckingConfig>,\n     options?: {emitSpans?: boolean}): string {\n-  const classes = ['Test', ...declarations.map(decl => decl.name)];\n-  const code = classes.map(name => `export class ${name}<T extends string> {}`).join('\\n');\n+  const codeLines = [`export class Test<T extends string> {}`];\n \n+  for (const decl of declarations) {\n+    if (decl.code !== undefined) {\n+      codeLines.push(decl.code);\n+    } else {\n+      codeLines.push(`export class ${decl.name}<T extends string> {}`);\n+    }\n+  }\n   const rootFilePath = absoluteFrom('/synthetic.ts');\n   const {program, host} = makeProgram([\n-    {name: rootFilePath, contents: code, isRoot: true},\n+    {name: rootFilePath, contents: codeLines.join('\\n'), isRoot: true},\n   ]);\n \n   const sf = getSourceFileOrError(program, rootFilePath);\n@@ -233,7 +251,7 @@ export function tcb(\n   const id = 'tcb' as TemplateId;\n   const meta: TypeCheckBlockMetadata = {id, boundTarget, pipes, schemas: []};\n \n-  config = config || {\n+  const fullConfig: TypeCheckingConfig = {\n     applyTemplateContextGuards: true,\n     checkQueries: false,\n     checkTypeOfInputBindings: true,\n@@ -253,6 +271,8 @@ export function tcb(\n     useContextGenericType: true,\n     strictLiteralTypes: true,\n     enableTemplateTypeChecker: false,\n+    useInlineTypeConstructors: true,\n+    ...config\n   };\n   options = options || {\n     emitSpans: false,\n@@ -265,7 +285,7 @@ export function tcb(\n   const refEmmiter: ReferenceEmitter = new ReferenceEmitter(\n       [new LocalIdentifierStrategy(), new RelativePathStrategy(reflectionHost)]);\n \n-  const env = new TypeCheckFile(fileName, config, refEmmiter, reflectionHost, host);\n+  const env = new TypeCheckFile(fileName, fullConfig, refEmmiter, reflectionHost, host);\n \n   const ref = new Reference(clazz);\n \n@@ -373,7 +393,14 @@ export function setup(targets: TypeCheckingTarget[], overrides: {\n         program, checker, moduleResolver, new TypeScriptReflectionHost(checker)),\n     new LogicalProjectStrategy(reflectionHost, logicalFs),\n   ]);\n-  const fullConfig = {...ALL_ENABLED_CONFIG, ...config};\n+\n+  const fullConfig = {\n+    ...ALL_ENABLED_CONFIG,\n+    useInlineTypeConstructors: overrides.inlining !== undefined ?\n+        overrides.inlining :\n+        ALL_ENABLED_CONFIG.useInlineTypeConstructors,\n+    ...config\n+  };\n \n   // Map out the scope of each target component, which is needed for the ComponentScopeReader.\n   const scopeMap = new Map<ClassDeclaration, ScopeData>();"
        },
        {
            "sha": "5f06d3a3581b5b9c5de0e70bb74f98ff5f721f12",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_check_block_spec.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/angular/angular/blob/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts?ref=09aefd29045db77689f4dc16a6abae09a79cfb81",
            "patch": "@@ -745,6 +745,7 @@ describe('type check blocks', () => {\n       useContextGenericType: true,\n       strictLiteralTypes: true,\n       enableTemplateTypeChecker: false,\n+      useInlineTypeConstructors: true\n     };\n \n     describe('config.applyTemplateContextGuards', () => {\n@@ -1077,4 +1078,35 @@ describe('type check blocks', () => {\n       });\n     });\n   });\n+\n+  it('should use `any` type for type constructors with bound generic params ' +\n+         'when `useInlineTypeConstructors` is `false`',\n+     () => {\n+       const template = `\n+    <div dir\n+      [inputA]='foo'\n+      [inputB]='bar'\n+      ></div>\n+    `;\n+       const declarations: TestDeclaration[] = [{\n+         code: `\n+           interface PrivateInterface{};\n+           export class Dir<T extends PrivateInterface, U extends string> {};\n+        `,\n+         type: 'directive',\n+         name: 'Dir',\n+         selector: '[dir]',\n+         inputs: {\n+           inputA: 'inputA',\n+           inputB: 'inputB',\n+         },\n+         isGeneric: true\n+       }];\n+\n+       const renderedTcb = tcb(template, declarations, {useInlineTypeConstructors: false});\n+\n+       expect(renderedTcb).toContain(`var _t1: i0.Dir<any, any> = null!;`);\n+       expect(renderedTcb).toContain(`_t1.inputA = (((ctx).foo));`);\n+       expect(renderedTcb).toContain(`_t1.inputB = (((ctx).bar));`);\n+     });\n });"
        },
        {
            "sha": "f08ad4b72e6adda71c8ec26cdb960dae034fe901",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=09aefd29045db77689f4dc16a6abae09a79cfb81",
            "patch": "@@ -1587,6 +1587,8 @@ function assertDomBindingSymbol(tSymbol: Symbol): asserts tSymbol is DomBindingS\n }\n \n export function setup(targets: TypeCheckingTarget[], config?: Partial<TypeCheckingConfig>) {\n-  return baseTestSetup(\n-      targets, {inlining: false, config: {...config, enableTemplateTypeChecker: true}});\n+  return baseTestSetup(targets, {\n+    inlining: false,\n+    config: {...config, enableTemplateTypeChecker: true, useInlineTypeConstructors: false}\n+  });\n }"
        },
        {
            "sha": "3774e4f9eeeea81644152b32201c8b9723d10221",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 42,
            "changes": 43,
            "blob_url": "https://github.com/angular/angular/blob/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts?ref=09aefd29045db77689f4dc16a6abae09a79cfb81",
            "patch": "@@ -168,49 +168,8 @@ runInEachFileSystem(() => {\n         expect(diags.length).toBe(1);\n         expect(diags[0].code).toBe(ngErrorCode(ErrorCode.INLINE_TCB_REQUIRED));\n       });\n-\n-      it('should produce errors for components that require type constructor inlining', () => {\n-        const fileName = absoluteFrom('/main.ts');\n-        const dirFile = absoluteFrom('/dir.ts');\n-        const {program, templateTypeChecker} = setup(\n-            [\n-              {\n-                fileName,\n-                source: `export class Cmp {}`,\n-                templates: {'Cmp': '<div dir></div>'},\n-                declarations: [{\n-                  name: 'TestDir',\n-                  selector: '[dir]',\n-                  file: dirFile,\n-                  type: 'directive',\n-                  isGeneric: true,\n-                }]\n-              },\n-              {\n-                fileName: dirFile,\n-                source: `\n-                // A non-exported interface used as a type bound for a generic directive causes\n-                // an inline type constructor to be required.\n-                interface NotExported {}\n-                export class TestDir<T extends NotExported> {}`,\n-                templates: {},\n-              }\n-            ],\n-            {inlining: false});\n-        const sf = getSourceFileOrError(program, fileName);\n-        const diags = templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram);\n-        expect(diags.length).toBe(1);\n-        expect(diags[0].code).toBe(ngErrorCode(ErrorCode.INLINE_TYPE_CTOR_REQUIRED));\n-\n-        // The relatedInformation of the diagnostic should point to the directive which required\n-        // the inline type constructor.\n-        const dirSf = getSourceFileOrError(program, dirFile);\n-        expect(diags[0].relatedInformation).not.toBeUndefined();\n-        expect(diags[0].relatedInformation!.length).toBe(1);\n-        expect(diags[0].relatedInformation![0].file).not.toBeUndefined();\n-        expect(absoluteFromSourceFile(diags[0].relatedInformation![0].file!)).toBe(dirSf.fileName);\n-      });\n     });\n+\n     describe('getTemplateOfComponent()', () => {\n       it('should provide access to a component\\'s real template', () => {\n         const fileName = absoluteFrom('/main.ts');"
        },
        {
            "sha": "11b610cf171db7b9423052e34fd6f9c85106e5db",
            "filename": "packages/language-service/ivy/test/quick_info_spec.ts",
            "status": "modified",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/angular/angular/blob/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/09aefd29045db77689f4dc16a6abae09a79cfb81/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts?ref=09aefd29045db77689f4dc16a6abae09a79cfb81",
            "patch": "@@ -479,6 +479,49 @@ describe('quick info', () => {\n     });\n   });\n \n+  describe('generics', () => {\n+    beforeEach(() => {\n+      initMockFileSystem('Native');\n+      env = LanguageServiceTestEnv.setup();\n+    });\n+\n+    it('should get quick info for the generic input of a directive that normally requires inlining',\n+       () => {\n+         // When compiling normally, we would have to inline the type constructor of `GenericDir`\n+         // because its generic type parameter references `PrivateInterface`, which is not exported.\n+         project = env.addProject('test', {\n+           'app.ts': `\n+          import {Directive, Component, Input, NgModule} from '@angular/core';\n+\n+          interface PrivateInterface {}\n+\n+          @Directive({\n+            selector: '[dir]'\n+          })export class GenericDir <T extends PrivateInterface>{\n+            @Input('input') input: T = null!;\n+          }\n+\n+          @Component({\n+            selector: 'some-cmp',\n+            templateUrl: './app.html'\n+          })export class SomeCmp{}\n+\n+          @NgModule({\n+            declarations: [GenericDir, SomeCmp],\n+          })export class AppModule{}\n+        `,\n+           'app.html': ``,\n+         });\n+\n+         expectQuickInfo({\n+           templateOverride: `<div dir [inp¦ut]='{value: 42}'></div>`,\n+           expectedSpanText: 'input',\n+           expectedDisplayString: '(property) GenericDir<any>.input: any'\n+         });\n+       });\n+  });\n+\n+\n   describe('non-strict compiler options', () => {\n     beforeEach(() => {\n       initMockFileSystem('Native');\n@@ -512,6 +555,7 @@ describe('quick info', () => {\n     });\n   });\n \n+\n   function expectQuickInfo(\n       {templateOverride, expectedSpanText, expectedDisplayString}:\n           {templateOverride: string, expectedSpanText: string, expectedDisplayString: string}):"
        }
    ],
    "stats": {
        "total": 355,
        "additions": 254,
        "deletions": 101
    }
}