{
    "author": "petebacondarwin",
    "message": "fix(compiler-cli): do not duplicate repeated source-files in rendered source-maps (#40237)\n\nWhen a source-map/source-file tree has nodes that refer to the same file, the\nflattened source-map rendering was those files multiple times, rather than\nconsolidating them into a single source-map source.\n\nPR Close #40237",
    "sha": "3158858059ac8e56b6b793dd5f9ff47207a0b884",
    "files": [
        {
            "sha": "843ed87db3c6645b8761fae4ec639f40b78963c3",
            "filename": "packages/compiler-cli/src/ngtsc/sourcemaps/src/source_file.ts",
            "status": "modified",
            "additions": 107,
            "deletions": 26,
            "changes": 133,
            "blob_url": "https://github.com/angular/angular/blob/3158858059ac8e56b6b793dd5f9ff47207a0b884/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fsource_file.ts",
            "raw_url": "https://github.com/angular/angular/raw/3158858059ac8e56b6b793dd5f9ff47207a0b884/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fsource_file.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fsource_file.ts?ref=3158858059ac8e56b6b793dd5f9ff47207a0b884",
            "patch": "@@ -50,21 +50,27 @@ export class SourceFile {\n    * Render the raw source map generated from the flattened mappings.\n    */\n   renderFlattenedSourceMap(): RawSourceMap {\n-    const sources: SourceFile[] = [];\n-    const names: string[] = [];\n-\n+    const sources = new IndexedMap<string, string>();\n+    const names = new IndexedSet<string>();\n     const mappings: SourceMapMappings = [];\n+    const sourcePathDir = this.fs.dirname(this.sourcePath);\n+    // Computing the relative path can be expensive, and we are likely to have the same path for\n+    // many (if not all!) mappings.\n+    const relativeSourcePathCache =\n+        new Cache<string, string>(input => this.fs.relative(sourcePathDir, input));\n \n     for (const mapping of this.flattenedMappings) {\n-      const sourceIndex = findIndexOrAdd(sources, mapping.originalSource);\n+      const sourceIndex = sources.set(\n+          relativeSourcePathCache.get(mapping.originalSource.sourcePath),\n+          mapping.originalSource.contents);\n       const mappingArray: SourceMapSegment = [\n         mapping.generatedSegment.column,\n         sourceIndex,\n         mapping.originalSegment.line,\n         mapping.originalSegment.column,\n       ];\n       if (mapping.name !== undefined) {\n-        const nameIndex = findIndexOrAdd(names, mapping.name);\n+        const nameIndex = names.add(mapping.name);\n         mappingArray.push(nameIndex);\n       }\n \n@@ -77,14 +83,13 @@ export class SourceFile {\n       mappings[line].push(mappingArray);\n     }\n \n-    const sourcePathDir = this.fs.dirname(this.sourcePath);\n     const sourceMap: RawSourceMap = {\n       version: 3,\n       file: this.fs.relative(sourcePathDir, this.sourcePath),\n-      sources: sources.map(sf => this.fs.relative(sourcePathDir, sf.sourcePath)),\n-      names,\n+      sources: sources.keys,\n+      names: names.values,\n       mappings: encode(mappings),\n-      sourcesContent: sources.map(sf => sf.contents),\n+      sourcesContent: sources.values,\n     };\n     return sourceMap;\n   }\n@@ -259,23 +264,6 @@ export interface Mapping {\n   readonly name?: string;\n }\n \n-/**\n- * Find the index of `item` in the `items` array.\n- * If it is not found, then push `item` to the end of the array and return its new index.\n- *\n- * @param items the collection in which to look for `item`.\n- * @param item the item to look for.\n- * @returns the index of the `item` in the `items` array.\n- */\n-function findIndexOrAdd<T>(items: T[], item: T): number {\n-  const itemIndex = items.indexOf(item);\n-  if (itemIndex > -1) {\n-    return itemIndex;\n-  } else {\n-    items.push(item);\n-    return items.length - 1;\n-  }\n-}\n \n \n /**\n@@ -448,3 +436,96 @@ export function computeStartOfLinePositions(str: string) {\n function computeLineLengths(str: string): number[] {\n   return (str.split(/\\n/)).map(s => s.length);\n }\n+\n+/**\n+ * A collection of mappings between `keys` and `values` stored in the order in which the keys are\n+ * first seen.\n+ *\n+ * The difference between this and a standard `Map` is that when you add a key-value pair the index\n+ * of the `key` is returned.\n+ */\n+class IndexedMap<K, V> {\n+  private map = new Map<K, number>();\n+\n+  /**\n+   * An array of keys added to this map.\n+   *\n+   * This array is guaranteed to be in the order of the first time the key was added to the map.\n+   */\n+  readonly keys: K[] = [];\n+\n+  /**\n+   * An array of values added to this map.\n+   *\n+   * This array is guaranteed to be in the order of the first time the associated key was added to\n+   * the map.\n+   */\n+  readonly values: V[] = [];\n+\n+  /**\n+   * Associate the `value` with the `key` and return the index of the key in the collection.\n+   *\n+   * If the `key` already exists then the `value` is not set and the index of that `key` is\n+   * returned; otherwise the `key` and `value` are stored and the index of the new `key` is\n+   * returned.\n+   *\n+   * @param key the key to associated with the `value`.\n+   * @param value the value to associated with the `key`.\n+   * @returns the index of the `key` in the `keys` array.\n+   */\n+  set(key: K, value: V): number {\n+    if (this.map.has(key)) {\n+      return this.map.get(key)!;\n+    }\n+    const index = this.values.push(value) - 1;\n+    this.keys.push(key);\n+    this.map.set(key, index);\n+    return index;\n+  }\n+}\n+\n+/**\n+ * A collection of `values` stored in the order in which they were added.\n+ *\n+ * The difference between this and a standard `Set` is that when you add a value the index of that\n+ * item is returned.\n+ */\n+class IndexedSet<V> {\n+  private map = new Map<V, number>();\n+\n+  /**\n+   * An array of values added to this set.\n+   * This array is guaranteed to be in the order of the first time the value was added to the set.\n+   */\n+  readonly values: V[] = [];\n+\n+  /**\n+   * Add the `value` to the `values` array, if it doesn't already exist; returning the index of the\n+   * `value` in the `values` array.\n+   *\n+   * If the `value` already exists then the index of that `value` is returned, otherwise the new\n+   * `value` is stored and the new index returned.\n+   *\n+   * @param value the value to add to the set.\n+   * @returns the index of the `value` in the `values` array.\n+   */\n+  add(value: V): number {\n+    if (this.map.has(value)) {\n+      return this.map.get(value)!;\n+    }\n+    const index = this.values.push(value) - 1;\n+    this.map.set(value, index);\n+    return index;\n+  }\n+}\n+\n+class Cache<Input, Cached> {\n+  private map = new Map<Input, Cached>();\n+  constructor(private computeFn: (input: Input) => Cached) {}\n+  get(input: Input): Cached {\n+    if (!this.map.has(input)) {\n+      this.map.set(input, this.computeFn(input));\n+    }\n+    return this.map.get(input)!;\n+  }\n+}"
        },
        {
            "sha": "1b57f4c7d5f8726b509dc68c1aa15207cbcfb5d5",
            "filename": "packages/compiler-cli/src/ngtsc/sourcemaps/test/source_file_spec.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/angular/angular/blob/3158858059ac8e56b6b793dd5f9ff47207a0b884/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Ftest%2Fsource_file_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/3158858059ac8e56b6b793dd5f9ff47207a0b884/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Ftest%2Fsource_file_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Ftest%2Fsource_file_spec.ts?ref=3158858059ac8e56b6b793dd5f9ff47207a0b884",
            "patch": "@@ -522,6 +522,42 @@ runInEachFileSystem(() => {\n           expect(aTocSourceMap.sourcesContent).toEqual(['abcdef']);\n           expect(aTocSourceMap.mappings).toEqual(aToBSourceMap.mappings);\n         });\n+\n+        it('should consolidate source-files with the same relative path', () => {\n+          const cSource1 = new SourceFile(_('/foo/src/lib/c.js'), 'bcd123e', null, false, [], fs);\n+          const cSource2 = new SourceFile(_('/foo/src/lib/c.js'), 'bcd123e', null, false, [], fs);\n+\n+          const bToCSourceMap: RawSourceMap = {\n+            mappings: encode([[[1, 0, 0, 0], [4, 0, 0, 3], [4, 0, 0, 6], [5, 0, 0, 7]]]),\n+            names: [],\n+            sources: ['c.js'],\n+            version: 3\n+          };\n+          const bSource = new SourceFile(\n+              _('/foo/src/lib/b.js'), 'abcdef', bToCSourceMap, false, [cSource1], fs);\n+\n+          const aToBCSourceMap: RawSourceMap = {\n+            mappings:\n+                encode([[[0, 0, 0, 0], [2, 0, 0, 3], [4, 0, 0, 2], [5, 0, 0, 5], [6, 1, 0, 3]]]),\n+            names: [],\n+            sources: ['lib/b.js', 'lib/c.js'],\n+            version: 3\n+          };\n+          const aSource = new SourceFile(\n+              _('/foo/src/a.js'), 'abdecf123', aToBCSourceMap, false, [bSource, cSource2], fs);\n+\n+          const aTocSourceMap = aSource.renderFlattenedSourceMap();\n+          expect(aTocSourceMap.version).toEqual(3);\n+          expect(aTocSourceMap.file).toEqual('a.js');\n+          expect(aTocSourceMap.names).toEqual([]);\n+          expect(aTocSourceMap.sourceRoot).toBeUndefined();\n+          expect(aTocSourceMap.sources).toEqual(['lib/c.js']);\n+          expect(aTocSourceMap.sourcesContent).toEqual(['bcd123e']);\n+          expect(aTocSourceMap.mappings).toEqual(encode([[\n+            [1, 0, 0, 0], [2, 0, 0, 2], [3, 0, 0, 3], [3, 0, 0, 6], [4, 0, 0, 1], [5, 0, 0, 7],\n+            [6, 0, 0, 3]\n+          ]]));\n+        });\n       });\n \n       describe('getOriginalLocation()', () => {"
        }
    ],
    "stats": {
        "total": 169,
        "additions": 143,
        "deletions": 26
    }
}