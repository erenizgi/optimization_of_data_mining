{
    "author": "josephperrott",
    "message": "refactor(dev-infra): update commit message validation to return validation result (#38703)\n\nPreviously, the validateCommitMessage function ran validation and logged the results.\nThe validateCommitMessage function now returns an object containing the validation\nresults and the cli action functions are instead responsible for logging the results.\n\nThis is being done as a prefactor for a change which allows for commit message\nhook validation to be either a blocking error or a warning.\n\nPR Close #38703",
    "sha": "f9421184ef509393bed8fad4f9724c511504bafa",
    "files": [
        {
            "sha": "830d33ab2d77ca2763376e7da98077036bda6329",
            "filename": "dev-infra/commit-message/validate-file.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 4,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/f9421184ef509393bed8fad4f9724c511504bafa/dev-infra%2Fcommit-message%2Fvalidate-file.ts",
            "raw_url": "https://github.com/angular/angular/raw/f9421184ef509393bed8fad4f9724c511504bafa/dev-infra%2Fcommit-message%2Fvalidate-file.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcommit-message%2Fvalidate-file.ts?ref=f9421184ef509393bed8fad4f9724c511504bafa",
            "patch": "@@ -9,19 +9,25 @@ import {readFileSync} from 'fs';\n import {resolve} from 'path';\n \n import {getRepoBaseDir} from '../utils/config';\n-import {info} from '../utils/console';\n+import {error, green, info, red} from '../utils/console';\n \n import {deleteCommitMessageDraft, saveCommitMessageDraft} from './commit-message-draft';\n-import {validateCommitMessage} from './validate';\n+import {printValidationErrors, validateCommitMessage} from './validate';\n \n /** Validate commit message at the provided file path. */\n export function validateFile(filePath: string) {\n   const commitMessage = readFileSync(resolve(getRepoBaseDir(), filePath), 'utf8');\n-  if (validateCommitMessage(commitMessage)) {\n-    info('√  Valid commit message');\n+  const {valid, errors} = validateCommitMessage(commitMessage);\n+  if (valid) {\n+    info(`${green('√')}  Valid commit message`);\n     deleteCommitMessageDraft(filePath);\n     return;\n   }\n+\n+  error(`${red('✘')}  Invalid commit message`);\n+  printValidationErrors(errors);\n+  error('Aborting commit attempt due to invalid commit message.');\n+\n   // On all invalid commit messages, the commit message should be saved as a draft to be\n   // restored on the next commit attempt.\n   saveCommitMessageDraft(filePath, commitMessage);"
        },
        {
            "sha": "a6fa8d4e0b5f8b22d088a21b5c9bbe079a7b511c",
            "filename": "dev-infra/commit-message/validate-range.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 6,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/f9421184ef509393bed8fad4f9724c511504bafa/dev-infra%2Fcommit-message%2Fvalidate-range.ts",
            "raw_url": "https://github.com/angular/angular/raw/f9421184ef509393bed8fad4f9724c511504bafa/dev-infra%2Fcommit-message%2Fvalidate-range.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcommit-message%2Fvalidate-range.ts?ref=f9421184ef509393bed8fad4f9724c511504bafa",
            "patch": "@@ -5,11 +5,11 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {info} from '../utils/console';\n+import {error, info} from '../utils/console';\n import {exec} from '../utils/shelljs';\n \n import {parseCommitMessage} from './parse';\n-import {validateCommitMessage, ValidateCommitMessageOptions} from './validate';\n+import {printValidationErrors, validateCommitMessage, ValidateCommitMessageOptions} from './validate';\n \n // Whether the provided commit is a fixup commit.\n const isNonFixup = (m: string) => !parseCommitMessage(m).isFixup;\n@@ -19,11 +19,20 @@ const extractCommitHeader = (m: string) => parseCommitMessage(m).header;\n \n /** Validate all commits in a provided git commit range. */\n export function validateCommitRange(range: string) {\n-  // A random value is used as a string to allow for a definite split point in the git log result.\n+  /**\n+   * A random value is used as a string to allow for a definite split point in the git log result.\n+   */\n   const randomValueSeparator = `${Math.random()}`;\n-  // Custom git log format that provides the commit header and body, separated as expected with\n-  // the custom separator as the trailing value.\n+  /**\n+   * Custom git log format that provides the commit header and body, separated as expected with the\n+   * custom separator as the trailing value.\n+   */\n   const gitLogFormat = `%s%n%n%b${randomValueSeparator}`;\n+  /**\n+   * A list of tuples containing a commit header string and the list of error messages for the\n+   * commit.\n+   */\n+  const errors: [commitHeader: string, errors: string[]][] = [];\n \n   // Retrieve the commits in the provided range.\n   const result = exec(`git log --reverse --format=${gitLogFormat} ${range}`);\n@@ -45,12 +54,22 @@ export function validateCommitRange(range: string) {\n           undefined :\n           commits.slice(0, i).filter(isNonFixup).map(extractCommitHeader)\n     };\n-    return validateCommitMessage(m, options);\n+    const {valid, errors: localErrors, commit} = validateCommitMessage(m, options);\n+    if (localErrors.length) {\n+      errors.push([commit.header, localErrors]);\n+    }\n+    return valid;\n   });\n \n   if (allCommitsInRangeValid) {\n     info('√  All commit messages in range valid.');\n   } else {\n+    error('✘  Invalid commit message');\n+    errors.forEach(([header, validationErrors]) => {\n+      error.group(header);\n+      printValidationErrors(validationErrors);\n+      error.groupEnd();\n+    });\n     // Exit with a non-zero exit code if invalid commit messages have\n     // been discovered.\n     process.exit(1);"
        },
        {
            "sha": "24fb996698c26f70587c25695d819ecd6aead79f",
            "filename": "dev-infra/commit-message/validate.spec.ts",
            "status": "modified",
            "additions": 109,
            "deletions": 112,
            "changes": 221,
            "blob_url": "https://github.com/angular/angular/blob/f9421184ef509393bed8fad4f9724c511504bafa/dev-infra%2Fcommit-message%2Fvalidate.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f9421184ef509393bed8fad4f9724c511504bafa/dev-infra%2Fcommit-message%2Fvalidate.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcommit-message%2Fvalidate.spec.ts?ref=f9421184ef509393bed8fad4f9724c511504bafa",
            "patch": "@@ -8,7 +8,7 @@\n \n // Imports\n import * as validateConfig from './config';\n-import {validateCommitMessage} from './validate';\n+import {validateCommitMessage, ValidateCommitMessageResult} from './validate';\n \n type CommitMessageConfig = validateConfig.CommitMessageConfig;\n \n@@ -31,44 +31,35 @@ const SCOPES = config.commitMessage.scopes.join(', ');\n const INVALID = false;\n const VALID = true;\n \n+function expectValidationResult(\n+    validationResult: ValidateCommitMessageResult, valid: boolean, errors: string[] = []) {\n+  expect(validationResult).toEqual(jasmine.objectContaining({valid, errors}));\n+}\n+\n // TODO(josephperrott): Clean up tests to test script rather than for\n // specific commit messages we want to use.\n describe('validate-commit-message.js', () => {\n-  let lastError: string = '';\n-\n   beforeEach(() => {\n-    lastError = '';\n-\n-    spyOn(console, 'error').and.callFake((msg: string) => lastError = msg);\n     spyOn(validateConfig, 'getCommitMessageConfig')\n         .and.returnValue(config as ReturnType<typeof validateConfig.getCommitMessageConfig>);\n   });\n \n   describe('validateMessage()', () => {\n     it('should be valid', () => {\n-      expect(validateCommitMessage('feat(packaging): something')).toBe(VALID);\n-      expect(lastError).toBe('');\n-\n-      expect(validateCommitMessage('fix(packaging): something')).toBe(VALID);\n-      expect(lastError).toBe('');\n-\n-      expect(validateCommitMessage('fixup! fix(packaging): something')).toBe(VALID);\n-      expect(lastError).toBe('');\n-\n-      expect(validateCommitMessage('squash! fix(packaging): something')).toBe(VALID);\n-      expect(lastError).toBe('');\n-\n-      expect(validateCommitMessage('Revert: \"fix(packaging): something\"')).toBe(VALID);\n-      expect(lastError).toBe('');\n+      expectValidationResult(validateCommitMessage('feat(packaging): something'), VALID);\n+      expectValidationResult(validateCommitMessage('fix(packaging): something'), VALID);\n+      expectValidationResult(validateCommitMessage('fixup! fix(packaging): something'), VALID);\n+      expectValidationResult(validateCommitMessage('squash! fix(packaging): something'), VALID);\n+      expectValidationResult(validateCommitMessage('Revert: \"fix(packaging): something\"'), VALID);\n     });\n \n     it('should validate max length', () => {\n       const msg =\n           'fix(compiler): something super mega extra giga tera long, maybe even longer and longer and longer and longer and longer and longer...';\n \n-      expect(validateCommitMessage(msg)).toBe(INVALID);\n-      expect(lastError).toContain(`The commit message header is longer than ${\n-          config.commitMessage.maxLineLength} characters`);\n+      expectValidationResult(validateCommitMessage(msg), INVALID, [\n+        `The commit message header is longer than ${config.commitMessage.maxLineLength} characters`\n+      ]);\n     });\n \n     it('should skip max length limit for URLs', () => {\n@@ -77,156 +68,159 @@ describe('validate-commit-message.js', () => {\n           'limit. For more details see the following super long URL:\\n\\n' +\n           'https://github.com/angular/components/commit/e2ace018ddfad10608e0e32932c43dcfef4095d7#diff-9879d6db96fd29134fc802214163b95a';\n \n-      expect(validateCommitMessage(msg)).toBe(VALID);\n+      expectValidationResult(validateCommitMessage(msg), VALID);\n     });\n \n     it('should validate \"<type>(<scope>): <subject>\" format', () => {\n       const msg = 'not correct format';\n \n-      expect(validateCommitMessage(msg)).toBe(INVALID);\n-      expect(lastError).toContain(`The commit message header does not match the expected format.`);\n+      expectValidationResult(\n+          validateCommitMessage(msg), INVALID,\n+          [`The commit message header does not match the expected format.`]);\n     });\n \n     it('should fail when type is invalid', () => {\n       const msg = 'weird(core): something';\n \n-      expect(validateCommitMessage(msg)).toBe(INVALID);\n-      expect(lastError).toContain(`'weird' is not an allowed type.\\n => TYPES: ${TYPES}`);\n+      expectValidationResult(\n+          validateCommitMessage(msg), INVALID,\n+          [`'weird' is not an allowed type.\\n => TYPES: ${TYPES}`]);\n     });\n \n     it('should fail when scope is invalid', () => {\n       const errorMessageFor = (scope: string, header: string) =>\n           `'${scope}' is not an allowed scope.\\n => SCOPES: ${SCOPES}`;\n \n-      expect(validateCommitMessage('fix(Compiler): something')).toBe(INVALID);\n-      expect(lastError).toContain(errorMessageFor('Compiler', 'fix(Compiler): something'));\n+      expectValidationResult(\n+          validateCommitMessage('fix(Compiler): something'), INVALID,\n+          [errorMessageFor('Compiler', 'fix(Compiler): something')]);\n \n-      expect(validateCommitMessage('feat(bah): something')).toBe(INVALID);\n-      expect(lastError).toContain(errorMessageFor('bah', 'feat(bah): something'));\n+      expectValidationResult(\n+          validateCommitMessage('feat(bah): something'), INVALID,\n+          [errorMessageFor('bah', 'feat(bah): something')]);\n \n-      expect(validateCommitMessage('fix(webworker): something')).toBe(INVALID);\n-      expect(lastError).toContain(errorMessageFor('webworker', 'fix(webworker): something'));\n+      expectValidationResult(\n+          validateCommitMessage('fix(webworker): something'), INVALID,\n+          [errorMessageFor('webworker', 'fix(webworker): something')]);\n \n-      expect(validateCommitMessage('refactor(security): something')).toBe(INVALID);\n-      expect(lastError).toContain(errorMessageFor('security', 'refactor(security): something'));\n+      expectValidationResult(\n+          validateCommitMessage('refactor(security): something'), INVALID,\n+          [errorMessageFor('security', 'refactor(security): something')]);\n \n-      expect(validateCommitMessage('refactor(docs): something')).toBe(INVALID);\n-      expect(lastError).toContain(errorMessageFor('docs', 'refactor(docs): something'));\n+      expectValidationResult(\n+          validateCommitMessage('refactor(docs): something'), INVALID,\n+          [errorMessageFor('docs', 'refactor(docs): something')]);\n \n-      expect(validateCommitMessage('feat(angular): something')).toBe(INVALID);\n-      expect(lastError).toContain(errorMessageFor('angular', 'feat(angular): something'));\n+      expectValidationResult(\n+          validateCommitMessage('feat(angular): something'), INVALID,\n+          [errorMessageFor('angular', 'feat(angular): something')]);\n     });\n \n     it('should allow empty scope', () => {\n-      expect(validateCommitMessage('build: blablabla')).toBe(VALID);\n-      expect(lastError).toBe('');\n+      expectValidationResult(validateCommitMessage('build: blablabla'), VALID);\n     });\n \n     // We do not want to allow WIP. It is OK to fail the PR build in this case to show that there is\n     // work still to be done (i.e. fixing the commit message).\n     it('should not allow \"WIP: ...\" syntax', () => {\n       const msg = 'WIP: fix: something';\n \n-      expect(validateCommitMessage(msg)).toBe(INVALID);\n-      expect(lastError).toContain(`'WIP' is not an allowed type.\\n => TYPES: ${TYPES}`);\n+      expectValidationResult(\n+          validateCommitMessage(msg), INVALID,\n+          [`'WIP' is not an allowed type.\\n => TYPES: ${TYPES}`]);\n     });\n \n     describe('(revert)', () => {\n       it('should allow valid \"revert: ...\" syntaxes', () => {\n-        expect(validateCommitMessage('revert: anything')).toBe(VALID);\n-        expect(lastError).toBe('');\n-\n-        expect(validateCommitMessage('Revert: \"anything\"')).toBe(VALID);\n-        expect(lastError).toBe('');\n-\n-        expect(validateCommitMessage('revert anything')).toBe(VALID);\n-        expect(lastError).toBe('');\n-\n-        expect(validateCommitMessage('rEvErT anything')).toBe(VALID);\n-        expect(lastError).toBe('');\n+        expectValidationResult(validateCommitMessage('revert: anything'), VALID);\n+        expectValidationResult(validateCommitMessage('Revert: \"anything\"'), VALID);\n+        expectValidationResult(validateCommitMessage('revert anything'), VALID);\n+        expectValidationResult(validateCommitMessage('rEvErT anything'), VALID);\n       });\n \n       it('should not allow \"revert(scope): ...\" syntax', () => {\n         const msg = 'revert(compiler): reduce generated code payload size by 65%';\n \n-        expect(validateCommitMessage(msg)).toBe(INVALID);\n-        expect(lastError).toContain(`'revert' is not an allowed type.\\n => TYPES: ${TYPES}`);\n+        expectValidationResult(\n+            validateCommitMessage(msg), INVALID,\n+            [`'revert' is not an allowed type.\\n => TYPES: ${TYPES}`]);\n       });\n \n       // https://github.com/angular/angular/issues/23479\n       it('should allow typical Angular messages generated by git', () => {\n         const msg =\n             'Revert \"fix(compiler): Pretty print object instead of [Object object] (#22689)\" (#23442)';\n \n-        expect(validateCommitMessage(msg)).toBe(VALID);\n-        expect(lastError).toBe('');\n+        expectValidationResult(validateCommitMessage(msg), VALID);\n       });\n     });\n \n     describe('(squash)', () => {\n       describe('without `disallowSquash`', () => {\n         it('should return commits as valid', () => {\n-          expect(validateCommitMessage('squash! feat(core): add feature')).toBe(VALID);\n-          expect(validateCommitMessage('squash! fix: a bug')).toBe(VALID);\n-          expect(validateCommitMessage('squash! fix a typo')).toBe(VALID);\n+          expectValidationResult(validateCommitMessage('squash! feat(core): add feature'), VALID);\n+          expectValidationResult(validateCommitMessage('squash! fix: a bug'), VALID);\n+          expectValidationResult(validateCommitMessage('squash! fix a typo'), VALID);\n         });\n       });\n \n       describe('with `disallowSquash`', () => {\n         it('should fail', () => {\n-          expect(validateCommitMessage('fix(core): something', {disallowSquash: true})).toBe(VALID);\n-          expect(validateCommitMessage('squash! fix(core): something', {\n-            disallowSquash: true\n-          })).toBe(INVALID);\n-          expect(lastError).toContain(\n-              'The commit must be manually squashed into the target commit');\n+          expectValidationResult(\n+              validateCommitMessage('fix(core): something', {disallowSquash: true}), VALID);\n+          expectValidationResult(\n+              validateCommitMessage('squash! fix(core): something', {disallowSquash: true}),\n+              INVALID, ['The commit must be manually squashed into the target commit']);\n         });\n       });\n     });\n \n     describe('(fixup)', () => {\n       describe('without `nonFixupCommitHeaders`', () => {\n         it('should return commits as valid', () => {\n-          expect(validateCommitMessage('fixup! feat(core): add feature')).toBe(VALID);\n-          expect(validateCommitMessage('fixup! fix: a bug')).toBe(VALID);\n-          expect(validateCommitMessage('fixup! fixup! fix: a bug')).toBe(VALID);\n+          expectValidationResult(validateCommitMessage('fixup! feat(core): add feature'), VALID);\n+          expectValidationResult(validateCommitMessage('fixup! fix: a bug'), VALID);\n+          expectValidationResult(validateCommitMessage('fixup! fixup! fix: a bug'), VALID);\n         });\n       });\n \n       describe('with `nonFixupCommitHeaders`', () => {\n         it('should check that the fixup commit matches a non-fixup one', () => {\n           const msg = 'fixup! foo';\n \n-          expect(validateCommitMessage(\n-                     msg, {disallowSquash: false, nonFixupCommitHeaders: ['foo', 'bar', 'baz']}))\n-              .toBe(VALID);\n-          expect(validateCommitMessage(\n-                     msg, {disallowSquash: false, nonFixupCommitHeaders: ['bar', 'baz', 'foo']}))\n-              .toBe(VALID);\n-          expect(validateCommitMessage(\n-                     msg, {disallowSquash: false, nonFixupCommitHeaders: ['baz', 'foo', 'bar']}))\n-              .toBe(VALID);\n-\n-          expect(validateCommitMessage(\n-                     msg, {disallowSquash: false, nonFixupCommitHeaders: ['qux', 'quux', 'quuux']}))\n-              .toBe(INVALID);\n-          expect(lastError).toContain(\n-              'Unable to find match for fixup commit among prior commits: \\n' +\n-              '      qux\\n' +\n-              '      quux\\n' +\n-              '      quuux');\n+          expectValidationResult(\n+              validateCommitMessage(\n+                  msg, {disallowSquash: false, nonFixupCommitHeaders: ['foo', 'bar', 'baz']}),\n+              VALID);\n+          expectValidationResult(\n+              validateCommitMessage(\n+                  msg, {disallowSquash: false, nonFixupCommitHeaders: ['bar', 'baz', 'foo']}),\n+              VALID);\n+          expectValidationResult(\n+              validateCommitMessage(\n+                  msg, {disallowSquash: false, nonFixupCommitHeaders: ['baz', 'foo', 'bar']}),\n+              VALID);\n+\n+          expectValidationResult(\n+              validateCommitMessage(\n+                  msg, {disallowSquash: false, nonFixupCommitHeaders: ['qux', 'quux', 'quuux']}),\n+              INVALID,\n+              ['Unable to find match for fixup commit among prior commits: \\n' +\n+               '      qux\\n' +\n+               '      quux\\n' +\n+               '      quuux']);\n         });\n \n         it('should fail if `nonFixupCommitHeaders` is empty', () => {\n-          expect(validateCommitMessage('refactor(core): make reactive', {\n-            disallowSquash: false,\n-            nonFixupCommitHeaders: []\n-          })).toBe(VALID);\n-          expect(validateCommitMessage(\n-                     'fixup! foo', {disallowSquash: false, nonFixupCommitHeaders: []}))\n-              .toBe(INVALID);\n-          expect(lastError).toContain(\n-              `Unable to find match for fixup commit among prior commits: -`);\n+          expectValidationResult(\n+              validateCommitMessage(\n+                  'refactor(core): make reactive',\n+                  {disallowSquash: false, nonFixupCommitHeaders: []}),\n+              VALID);\n+          expectValidationResult(\n+              validateCommitMessage(\n+                  'fixup! foo', {disallowSquash: false, nonFixupCommitHeaders: []}),\n+              INVALID, [`Unable to find match for fixup commit among prior commits: -`]);\n         });\n       });\n     });\n@@ -246,24 +240,27 @@ describe('validate-commit-message.js', () => {\n       });\n \n       it('should fail validation if the body is shorter than `minBodyLength`', () => {\n-        expect(validateCommitMessage(\n-                   'fix(core): something\\n\\n Explanation of the motivation behind this change'))\n-            .toBe(VALID);\n-        expect(validateCommitMessage('fix(core): something\\n\\n too short')).toBe(INVALID);\n-        expect(lastError).toContain(\n-            'The commit message body does not meet the minimum length of 30 characters');\n-        expect(validateCommitMessage('fix(core): something')).toBe(INVALID);\n-        expect(lastError).toContain(\n-            'The commit message body does not meet the minimum length of 30 characters');\n+        expectValidationResult(\n+            validateCommitMessage(\n+                'fix(core): something\\n\\n Explanation of the motivation behind this change'),\n+            VALID);\n+        expectValidationResult(\n+            validateCommitMessage('fix(core): something\\n\\n too short'), INVALID,\n+            ['The commit message body does not meet the minimum length of 30 characters']);\n+        expectValidationResult(validateCommitMessage('fix(core): something'), INVALID, [\n+\n+          'The commit message body does not meet the minimum length of 30 characters'\n+        ]);\n       });\n \n       it('should pass validation if the body is shorter than `minBodyLength` but the commit type is in the `minBodyLengthTypeExclusions` list',\n          () => {\n-           expect(validateCommitMessage('docs: just fixing a typo')).toBe(VALID);\n-           expect(validateCommitMessage('docs(core): just fixing a typo')).toBe(VALID);\n-           expect(validateCommitMessage(\n-                      'docs(core): just fixing a typo\\n\\nThis was just a silly typo.'))\n-               .toBe(VALID);\n+           expectValidationResult(validateCommitMessage('docs: just fixing a typo'), VALID);\n+           expectValidationResult(validateCommitMessage('docs(core): just fixing a typo'), VALID);\n+           expectValidationResult(\n+               validateCommitMessage(\n+                   'docs(core): just fixing a typo\\n\\nThis was just a silly typo.'),\n+               VALID);\n          });\n     });\n   });"
        },
        {
            "sha": "e66679b2b983e7818003fa23f9b6ec3d5d390f3b",
            "filename": "dev-infra/commit-message/validate.ts",
            "status": "modified",
            "additions": 113,
            "deletions": 99,
            "changes": 212,
            "blob_url": "https://github.com/angular/angular/blob/f9421184ef509393bed8fad4f9724c511504bafa/dev-infra%2Fcommit-message%2Fvalidate.ts",
            "raw_url": "https://github.com/angular/angular/raw/f9421184ef509393bed8fad4f9724c511504bafa/dev-infra%2Fcommit-message%2Fvalidate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcommit-message%2Fvalidate.ts?ref=f9421184ef509393bed8fad4f9724c511504bafa",
            "patch": "@@ -8,141 +8,155 @@\n import {error} from '../utils/console';\n \n import {COMMIT_TYPES, getCommitMessageConfig, ScopeRequirement} from './config';\n-import {parseCommitMessage} from './parse';\n+import {parseCommitMessage, ParsedCommitMessage} from './parse';\n \n /** Options for commit message validation. */\n export interface ValidateCommitMessageOptions {\n   disallowSquash?: boolean;\n   nonFixupCommitHeaders?: string[];\n }\n \n+/** The result of a commit message validation check. */\n+export interface ValidateCommitMessageResult {\n+  valid: boolean;\n+  errors: string[];\n+  commit: ParsedCommitMessage;\n+}\n+\n /** Regex matching a URL for an entire commit body line. */\n const COMMIT_BODY_URL_LINE_RE = /^https?:\\/\\/.*$/;\n \n /** Validate a commit message against using the local repo's config. */\n export function validateCommitMessage(\n-    commitMsg: string, options: ValidateCommitMessageOptions = {}) {\n-  function printError(errorMessage: string) {\n-    error(\n-        `INVALID COMMIT MSG: \\n` +\n-        `${'─'.repeat(40)}\\n` +\n-        `${commitMsg}\\n` +\n-        `${'─'.repeat(40)}\\n` +\n-        `ERROR: \\n` +\n-        `  ${errorMessage}` +\n-        `\\n\\n` +\n-        `The expected format for a commit is: \\n` +\n-        `<type>(<scope>): <subject>\\n\\n<body>`);\n-  }\n-\n+    commitMsg: string, options: ValidateCommitMessageOptions = {}): ValidateCommitMessageResult {\n   const config = getCommitMessageConfig().commitMessage;\n   const commit = parseCommitMessage(commitMsg);\n+  const errors: string[] = [];\n \n-  ////////////////////////////////////\n-  // Checking revert, squash, fixup //\n-  ////////////////////////////////////\n+  /** Perform the validation checks against the parsed commit. */\n+  function validateCommitAndCollectErrors() {\n+    // TODO(josephperrott): Remove early return calls when commit message errors are found\n \n-  // All revert commits are considered valid.\n-  if (commit.isRevert) {\n-    return true;\n-  }\n+    ////////////////////////////////////\n+    // Checking revert, squash, fixup //\n+    ////////////////////////////////////\n+\n+    // All revert commits are considered valid.\n+    if (commit.isRevert) {\n+      return true;\n+    }\n+\n+    // All squashes are considered valid, as the commit will be squashed into another in\n+    // the git history anyway, unless the options provided to not allow squash commits.\n+    if (commit.isSquash) {\n+      if (options.disallowSquash) {\n+        errors.push('The commit must be manually squashed into the target commit');\n+        return false;\n+      }\n+      return true;\n+    }\n \n-  // All squashes are considered valid, as the commit will be squashed into another in\n-  // the git history anyway, unless the options provided to not allow squash commits.\n-  if (commit.isSquash) {\n-    if (options.disallowSquash) {\n-      printError('The commit must be manually squashed into the target commit');\n+    // Fixups commits are considered valid, unless nonFixupCommitHeaders are provided to check\n+    // against. If `nonFixupCommitHeaders` is not empty, we check whether there is a corresponding\n+    // non-fixup commit (i.e. a commit whose header is identical to this commit's header after\n+    // stripping the `fixup! ` prefix), otherwise we assume this verification will happen in another\n+    // check.\n+    if (commit.isFixup) {\n+      if (options.nonFixupCommitHeaders && !options.nonFixupCommitHeaders.includes(commit.header)) {\n+        errors.push(\n+            'Unable to find match for fixup commit among prior commits: ' +\n+            (options.nonFixupCommitHeaders.map(x => `\\n      ${x}`).join('') || '-'));\n+        return false;\n+      }\n+\n+      return true;\n+    }\n+\n+    ////////////////////////////\n+    // Checking commit header //\n+    ////////////////////////////\n+    if (commit.header.length > config.maxLineLength) {\n+      errors.push(`The commit message header is longer than ${config.maxLineLength} characters`);\n       return false;\n     }\n-    return true;\n-  }\n \n-  // Fixups commits are considered valid, unless nonFixupCommitHeaders are provided to check\n-  // against. If `nonFixupCommitHeaders` is not empty, we check whether there is a corresponding\n-  // non-fixup commit (i.e. a commit whose header is identical to this commit's header after\n-  // stripping the `fixup! ` prefix), otherwise we assume this verification will happen in another\n-  // check.\n-  if (commit.isFixup) {\n-    if (options.nonFixupCommitHeaders && !options.nonFixupCommitHeaders.includes(commit.header)) {\n-      printError(\n-          'Unable to find match for fixup commit among prior commits: ' +\n-          (options.nonFixupCommitHeaders.map(x => `\\n      ${x}`).join('') || '-'));\n+    if (!commit.type) {\n+      errors.push(`The commit message header does not match the expected format.`);\n       return false;\n     }\n \n-    return true;\n-  }\n+    if (COMMIT_TYPES[commit.type] === undefined) {\n+      errors.push(`'${commit.type}' is not an allowed type.\\n => TYPES: ${\n+          Object.keys(COMMIT_TYPES).join(', ')}`);\n+      return false;\n+    }\n \n-  ////////////////////////////\n-  // Checking commit header //\n-  ////////////////////////////\n-  if (commit.header.length > config.maxLineLength) {\n-    printError(`The commit message header is longer than ${config.maxLineLength} characters`);\n-    return false;\n-  }\n+    /** The scope requirement level for the provided type of the commit message. */\n+    const scopeRequirementForType = COMMIT_TYPES[commit.type].scope;\n \n-  if (!commit.type) {\n-    printError(`The commit message header does not match the expected format.`);\n-    return false;\n-  }\n+    if (scopeRequirementForType === ScopeRequirement.Forbidden && commit.scope) {\n+      errors.push(`Scopes are forbidden for commits with type '${commit.type}', but a scope of '${\n+          commit.scope}' was provided.`);\n+      return false;\n+    }\n \n+    if (scopeRequirementForType === ScopeRequirement.Required && !commit.scope) {\n+      errors.push(\n+          `Scopes are required for commits with type '${commit.type}', but no scope was provided.`);\n+      return false;\n+    }\n \n+    if (commit.scope && !config.scopes.includes(commit.scope)) {\n+      errors.push(\n+          `'${commit.scope}' is not an allowed scope.\\n => SCOPES: ${config.scopes.join(', ')}`);\n+      return false;\n+    }\n \n-  if (COMMIT_TYPES[commit.type] === undefined) {\n-    printError(`'${commit.type}' is not an allowed type.\\n => TYPES: ${\n-        Object.keys(COMMIT_TYPES).join(', ')}`);\n-    return false;\n-  }\n+    // Commits with the type of `release` do not require a commit body.\n+    if (commit.type === 'release') {\n+      return true;\n+    }\n \n-  /** The scope requirement level for the provided type of the commit message. */\n-  const scopeRequirementForType = COMMIT_TYPES[commit.type].scope;\n+    //////////////////////////\n+    // Checking commit body //\n+    //////////////////////////\n \n-  if (scopeRequirementForType === ScopeRequirement.Forbidden && commit.scope) {\n-    printError(`Scopes are forbidden for commits with type '${commit.type}', but a scope of '${\n-        commit.scope}' was provided.`);\n-    return false;\n-  }\n+    if (!config.minBodyLengthTypeExcludes?.includes(commit.type) &&\n+        commit.bodyWithoutLinking.trim().length < config.minBodyLength) {\n+      errors.push(`The commit message body does not meet the minimum length of ${\n+          config.minBodyLength} characters`);\n+      return false;\n+    }\n \n-  if (scopeRequirementForType === ScopeRequirement.Required && !commit.scope) {\n-    printError(\n-        `Scopes are required for commits with type '${commit.type}', but no scope was provided.`);\n-    return false;\n-  }\n+    const bodyByLine = commit.body.split('\\n');\n+    const lineExceedsMaxLength = bodyByLine.some(line => {\n+      // Check if any line exceeds the max line length limit. The limit is ignored for\n+      // lines that just contain an URL (as these usually cannot be wrapped or shortened).\n+      return line.length > config.maxLineLength && !COMMIT_BODY_URL_LINE_RE.test(line);\n+    });\n \n-  if (commit.scope && !config.scopes.includes(commit.scope)) {\n-    printError(\n-        `'${commit.scope}' is not an allowed scope.\\n => SCOPES: ${config.scopes.join(', ')}`);\n-    return false;\n-  }\n+    if (lineExceedsMaxLength) {\n+      errors.push(\n+          `The commit message body contains lines greater than ${config.maxLineLength} characters`);\n+      return false;\n+    }\n \n-  // Commits with the type of `release` do not require a commit body.\n-  if (commit.type === 'release') {\n     return true;\n   }\n \n-  //////////////////////////\n-  // Checking commit body //\n-  //////////////////////////\n-\n-  if (!config.minBodyLengthTypeExcludes?.includes(commit.type) &&\n-      commit.bodyWithoutLinking.trim().length < config.minBodyLength) {\n-    printError(`The commit message body does not meet the minimum length of ${\n-        config.minBodyLength} characters`);\n-    return false;\n-  }\n+  return {valid: validateCommitAndCollectErrors(), errors, commit};\n+}\n \n-  const bodyByLine = commit.body.split('\\n');\n-  const lineExceedsMaxLength = bodyByLine.some(line => {\n-    // Check if any line exceeds the max line length limit. The limit is ignored for\n-    // lines that just contain an URL (as these usually cannot be wrapped or shortened).\n-    return line.length > config.maxLineLength && !COMMIT_BODY_URL_LINE_RE.test(line);\n-  });\n-\n-  if (lineExceedsMaxLength) {\n-    printError(\n-        `The commit message body contains lines greater than ${config.maxLineLength} characters`);\n-    return false;\n-  }\n \n-  return true;\n+/** Print the error messages from the commit message validation to the console. */\n+export function printValidationErrors(errors: string[], print = error) {\n+  print.group(`Error${errors.length === 1 ? '' : 's'}:`);\n+  errors.forEach(line => print(line));\n+  print.groupEnd();\n+  print();\n+  print('The expected format for a commit is: ');\n+  print('<type>(<scope>): <summary>');\n+  print();\n+  print('<body>');\n+  print();\n }"
        }
    ],
    "stats": {
        "total": 478,
        "additions": 257,
        "deletions": 221
    }
}