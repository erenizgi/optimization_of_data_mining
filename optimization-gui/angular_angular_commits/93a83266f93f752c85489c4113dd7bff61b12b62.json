{
    "author": "alxhub",
    "message": "feat(language-service): autocompletion within expression contexts (#39727)\n\nThis commit adds support to the Language Service for autocompletion within\nexpression contexts. Specifically, this is auto completion of property reads\nand method calls, both in normal and safe-navigational forms.\n\nPR Close #39727",
    "sha": "93a83266f93f752c85489c4113dd7bff61b12b62",
    "files": [
        {
            "sha": "4603bd1739881441064a7c6289b308b0a8154943",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/93a83266f93f752c85489c4113dd7bff61b12b62/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/93a83266f93f752c85489c4113dd7bff61b12b62/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=93a83266f93f752c85489c4113dd7bff61b12b62",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, ParseError, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n+import {AST, MethodCall, ParseError, PropertyRead, SafeMethodCall, SafePropertyRead, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n import {AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n import * as ts from 'typescript';\n \n@@ -124,6 +124,15 @@ export interface TemplateTypeChecker {\n   getGlobalCompletions(context: TmplAstTemplate|null, component: ts.ClassDeclaration):\n       GlobalCompletion|null;\n \n+\n+  /**\n+   * For the given expression node, retrieve a `ShimLocation` that can be used to perform\n+   * autocompletion at that point in the expression, if such a location exists.\n+   */\n+  getExpressionCompletionLocation(\n+      expr: PropertyRead|SafePropertyRead|MethodCall|SafeMethodCall,\n+      component: ts.ClassDeclaration): ShimLocation|null;\n+\n   /**\n    * Get basic metadata on the directives which are in scope for the given component.\n    */"
        },
        {
            "sha": "0badb22070cef1165e2bad05c64f27cc506dd6f7",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/93a83266f93f752c85489c4113dd7bff61b12b62/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/93a83266f93f752c85489c4113dd7bff61b12b62/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=93a83266f93f752c85489c4113dd7bff61b12b62",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, ParseError, parseTemplate, TmplAstNode, TmplAstTemplate,} from '@angular/compiler';\n+import {AST, MethodCall, ParseError, parseTemplate, PropertyRead, SafeMethodCall, SafePropertyRead, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\n@@ -285,6 +285,16 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     return engine.getGlobalCompletions(context);\n   }\n \n+  getExpressionCompletionLocation(\n+      ast: PropertyRead|SafePropertyRead|MethodCall|SafeMethodCall,\n+      component: ts.ClassDeclaration): ShimLocation|null {\n+    const engine = this.getOrCreateCompletionEngine(component);\n+    if (engine === null) {\n+      return null;\n+    }\n+    return engine.getExpressionCompletionLocation(ast);\n+  }\n+\n   private getOrCreateCompletionEngine(component: ts.ClassDeclaration): CompletionEngine|null {\n     if (this.completionCache.has(component)) {\n       return this.completionCache.get(component)!;"
        },
        {
            "sha": "6157a663d758b581562214745b1eb1fffd33d83c",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/completion.ts",
            "status": "modified",
            "additions": 53,
            "deletions": 1,
            "changes": 54,
            "blob_url": "https://github.com/angular/angular/blob/93a83266f93f752c85489c4113dd7bff61b12b62/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcompletion.ts",
            "raw_url": "https://github.com/angular/angular/raw/93a83266f93f752c85489c4113dd7bff61b12b62/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcompletion.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcompletion.ts?ref=93a83266f93f752c85489c4113dd7bff61b12b62",
            "patch": "@@ -7,10 +7,11 @@\n  */\n \n import {TmplAstReference, TmplAstTemplate} from '@angular/compiler';\n+import {MethodCall, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead} from '@angular/compiler/src/compiler';\n import * as ts from 'typescript';\n \n import {AbsoluteFsPath} from '../../file_system';\n-import {CompletionKind, GlobalCompletion, ReferenceCompletion, VariableCompletion} from '../api';\n+import {CompletionKind, GlobalCompletion, ReferenceCompletion, ShimLocation, VariableCompletion} from '../api';\n \n import {ExpressionIdentifier, findFirstMatchingNode} from './comments';\n import {TemplateData} from './context';\n@@ -28,6 +29,9 @@ export class CompletionEngine {\n    */\n   private globalCompletionCache = new Map<TmplAstTemplate|null, GlobalCompletion>();\n \n+  private expressionCompletionCache =\n+      new Map<PropertyRead|SafePropertyRead|MethodCall|SafeMethodCall, ShimLocation>();\n+\n   constructor(private tcb: ts.Node, private data: TemplateData, private shimPath: AbsoluteFsPath) {}\n \n   /**\n@@ -79,4 +83,52 @@ export class CompletionEngine {\n     this.globalCompletionCache.set(context, completion);\n     return completion;\n   }\n+\n+  getExpressionCompletionLocation(expr: PropertyRead|PropertyWrite|MethodCall|\n+                                  SafeMethodCall): ShimLocation|null {\n+    if (this.expressionCompletionCache.has(expr)) {\n+      return this.expressionCompletionCache.get(expr)!;\n+    }\n+\n+    // Completion works inside property reads and method calls.\n+    let tsExpr: ts.PropertyAccessExpression|null = null;\n+    if (expr instanceof PropertyRead || expr instanceof MethodCall ||\n+        expr instanceof PropertyWrite) {\n+      // Non-safe navigation operations are trivial: `foo.bar` or `foo.bar()`\n+      tsExpr = findFirstMatchingNode(this.tcb, {\n+        filter: ts.isPropertyAccessExpression,\n+        withSpan: expr.nameSpan,\n+      });\n+    } else if (expr instanceof SafePropertyRead || expr instanceof SafeMethodCall) {\n+      // Safe navigation operations are a little more complex, and involve a ternary. Completion\n+      // happens in the \"true\" case of the ternary.\n+      const ternaryExpr = findFirstMatchingNode(this.tcb, {\n+        filter: ts.isParenthesizedExpression,\n+        withSpan: expr.sourceSpan,\n+      });\n+      if (ternaryExpr === null || !ts.isConditionalExpression(ternaryExpr.expression)) {\n+        return null;\n+      }\n+      const whenTrue = ternaryExpr.expression.whenTrue;\n+\n+      if (expr instanceof SafePropertyRead && ts.isPropertyAccessExpression(whenTrue)) {\n+        tsExpr = whenTrue;\n+      } else if (\n+          expr instanceof SafeMethodCall && ts.isCallExpression(whenTrue) &&\n+          ts.isPropertyAccessExpression(whenTrue.expression)) {\n+        tsExpr = whenTrue.expression;\n+      }\n+    }\n+\n+    if (tsExpr === null) {\n+      return null;\n+    }\n+\n+    const res: ShimLocation = {\n+      shimPath: this.shimPath,\n+      positionInShimFile: tsExpr.name.getEnd(),\n+    };\n+    this.expressionCompletionCache.set(expr, res);\n+    return res;\n+  }\n }"
        },
        {
            "sha": "62299420aaabf63659abae265c087b61affefaa4",
            "filename": "packages/language-service/ivy/completions.ts",
            "status": "modified",
            "additions": 61,
            "deletions": 15,
            "changes": 76,
            "blob_url": "https://github.com/angular/angular/blob/93a83266f93f752c85489c4113dd7bff61b12b62/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "raw_url": "https://github.com/angular/angular/raw/93a83266f93f752c85489c4113dd7bff61b12b62/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompletions.ts?ref=93a83266f93f752c85489c4113dd7bff61b12b62",
            "patch": "@@ -6,16 +6,18 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, EmptyExpr, ImplicitReceiver, LiteralPrimitive, MethodCall, PropertyRead, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n+import {AST, EmptyExpr, ImplicitReceiver, LiteralPrimitive, MethodCall, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {CompletionKind, TemplateDeclarationSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import {BoundEvent} from '@angular/compiler/src/render3/r3_ast';\n import * as ts from 'typescript';\n \n import {DisplayInfoKind, getDisplayInfo, unsafeCastDisplayInfoKindToScriptElementKind} from './display_parts';\n+import {filterAliasImports} from './utils';\n \n type PropertyExpressionCompletionBuilder =\n-    CompletionBuilder<PropertyRead|MethodCall|EmptyExpr|LiteralPrimitive>;\n+    CompletionBuilder<PropertyRead|PropertyWrite|MethodCall|EmptyExpr|SafePropertyRead|\n+                      SafeMethodCall>;\n \n /**\n  * Performs autocompletion operations on a given node in the template.\n@@ -84,7 +86,8 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n   private isPropertyExpressionCompletion(this: CompletionBuilder<TmplAstNode|AST>):\n       this is PropertyExpressionCompletionBuilder {\n     return this.node instanceof PropertyRead || this.node instanceof MethodCall ||\n-        this.node instanceof EmptyExpr ||\n+        this.node instanceof SafePropertyRead || this.node instanceof SafeMethodCall ||\n+        this.node instanceof PropertyWrite || this.node instanceof EmptyExpr ||\n         isBrokenEmptyBoundEventExpression(this.node, this.nodeParent);\n   }\n \n@@ -100,8 +103,30 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n         this.node.receiver instanceof ImplicitReceiver) {\n       return this.getGlobalPropertyExpressionCompletion(options);\n     } else {\n-      // TODO(alxhub): implement completion of non-global expressions.\n-      return undefined;\n+      const location = this.compiler.getTemplateTypeChecker().getExpressionCompletionLocation(\n+          this.node, this.component);\n+      if (location === null) {\n+        return undefined;\n+      }\n+      const tsResults = this.tsLS.getCompletionsAtPosition(\n+          location.shimPath, location.positionInShimFile, options);\n+      if (tsResults === undefined) {\n+        return undefined;\n+      }\n+\n+      const replacementSpan = makeReplacementSpan(this.node);\n+\n+      let ngResults: ts.CompletionEntry[] = [];\n+      for (const result of tsResults.entries) {\n+        ngResults.push({\n+          ...result,\n+          replacementSpan,\n+        });\n+      }\n+      return {\n+        ...tsResults,\n+        entries: ngResults,\n+      };\n     }\n   }\n \n@@ -112,15 +137,26 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       this: PropertyExpressionCompletionBuilder, entryName: string,\n       formatOptions: ts.FormatCodeOptions|ts.FormatCodeSettings|undefined,\n       preferences: ts.UserPreferences|undefined): ts.CompletionEntryDetails|undefined {\n+    let details: ts.CompletionEntryDetails|undefined = undefined;\n     if (this.node instanceof EmptyExpr ||\n         isBrokenEmptyBoundEventExpression(this.node, this.nodeParent) ||\n         this.node.receiver instanceof ImplicitReceiver) {\n-      return this.getGlobalPropertyExpressionCompletionDetails(\n-          entryName, formatOptions, preferences);\n+      details =\n+          this.getGlobalPropertyExpressionCompletionDetails(entryName, formatOptions, preferences);\n     } else {\n-      // TODO(alxhub): implement completion of non-global expressions.\n-      return undefined;\n+      const location = this.compiler.getTemplateTypeChecker().getExpressionCompletionLocation(\n+          this.node, this.component);\n+      if (location === null) {\n+        return undefined;\n+      }\n+      details = this.tsLS.getCompletionEntryDetails(\n+          location.shimPath, location.positionInShimFile, entryName, formatOptions,\n+          /* source */ undefined, preferences);\n+    }\n+    if (details !== undefined) {\n+      details.displayParts = filterAliasImports(details.displayParts);\n     }\n+    return details;\n   }\n \n   /**\n@@ -132,8 +168,13 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n         this.node.receiver instanceof ImplicitReceiver) {\n       return this.getGlobalPropertyExpressionCompletionSymbol(name);\n     } else {\n-      // TODO(alxhub): implement completion of non-global expressions.\n-      return undefined;\n+      const location = this.compiler.getTemplateTypeChecker().getExpressionCompletionLocation(\n+          this.node, this.component);\n+      if (location === null) {\n+        return undefined;\n+      }\n+      return this.tsLS.getCompletionEntrySymbol(\n+          location.shimPath, location.positionInShimFile, name, /* source */ undefined);\n     }\n   }\n \n@@ -154,10 +195,7 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n     let replacementSpan: ts.TextSpan|undefined = undefined;\n     // Non-empty nodes get replaced with the completion.\n     if (!(this.node instanceof EmptyExpr || this.node instanceof LiteralPrimitive)) {\n-      replacementSpan = {\n-        start: this.node.nameSpan.start,\n-        length: this.node.nameSpan.end - this.node.nameSpan.start,\n-      };\n+      replacementSpan = makeReplacementSpan(this.node);\n     }\n \n     // Merge TS completion results with results from the template scope.\n@@ -285,3 +323,11 @@ function isBrokenEmptyBoundEventExpression(\n   return node instanceof LiteralPrimitive && parent !== null && parent instanceof BoundEvent &&\n       node.value === 'ERROR';\n }\n+\n+function makeReplacementSpan(node: PropertyRead|PropertyWrite|MethodCall|SafePropertyRead|\n+                             SafeMethodCall): ts.TextSpan {\n+  return {\n+    start: node.nameSpan.start,\n+    length: node.nameSpan.end - node.nameSpan.start,\n+  };\n+}"
        },
        {
            "sha": "b318f581ebb9e7a2f8f986a336a91c2cfb602423",
            "filename": "packages/language-service/ivy/test/completions_spec.ts",
            "status": "modified",
            "additions": 103,
            "deletions": 1,
            "changes": 104,
            "blob_url": "https://github.com/angular/angular/blob/93a83266f93f752c85489c4113dd7bff61b12b62/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/93a83266f93f752c85489c4113dd7bff61b12b62/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts?ref=93a83266f93f752c85489c4113dd7bff61b12b62",
            "patch": "@@ -106,6 +106,98 @@ describe('completions', () => {\n       expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title']);\n     });\n   });\n+\n+  describe('in an expression scope', () => {\n+    it('should return completions in a property access expression', () => {\n+      const {ngLS, fileName, cursor} =\n+          setup(`{{name.f¦}}`, `name!: {first: string; last: string;};`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        last: ts.ScriptElementKind.memberVariableElement,\n+      });\n+    });\n+\n+    it('should return completions in an empty property access expression', () => {\n+      const {ngLS, fileName, cursor} =\n+          setup(`{{name.¦}}`, `name!: {first: string; last: string;};`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        last: ts.ScriptElementKind.memberVariableElement,\n+      });\n+    });\n+\n+    it('should return completions in a property write expression', () => {\n+      const {ngLS, fileName, cursor} = setup(\n+          `<button (click)=\"name.fi¦ = 'test\"></button>`, `name!: {first: string; last: string;};`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        last: ts.ScriptElementKind.memberVariableElement,\n+      });\n+    });\n+\n+    it('should return completions in a method call expression', () => {\n+      const {ngLS, fileName, cursor} =\n+          setup(`{{name.f¦()}}`, `name!: {first: string; full(): string;};`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        full: ts.ScriptElementKind.memberFunctionElement,\n+      });\n+    });\n+\n+    it('should return completions in an empty method call expression', () => {\n+      const {ngLS, fileName, cursor} =\n+          setup(`{{name.¦()}}`, `name!: {first: string; full(): string;};`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        full: ts.ScriptElementKind.memberFunctionElement,\n+      });\n+    });\n+\n+    it('should return completions in a safe property navigation context', () => {\n+      const {ngLS, fileName, cursor} =\n+          setup(`{{name?.f¦}}`, `name?: {first: string; last: string;};`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        last: ts.ScriptElementKind.memberVariableElement,\n+      });\n+    });\n+\n+    it('should return completions in an empty safe property navigation context', () => {\n+      const {ngLS, fileName, cursor} =\n+          setup(`{{name?.¦}}`, `name?: {first: string; last: string;};`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        last: ts.ScriptElementKind.memberVariableElement,\n+      });\n+    });\n+\n+    it('should return completions in a safe method call context', () => {\n+      const {ngLS, fileName, cursor} =\n+          setup(`{{name?.f¦()}}`, `name!: {first: string; full(): string;};`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        full: ts.ScriptElementKind.memberFunctionElement,\n+      });\n+    });\n+\n+    it('should return completions in an empty safe method call context', () => {\n+      const {ngLS, fileName, cursor} =\n+          setup(`{{name?.¦()}}`, `name!: {first: string; full(): string;};`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        full: ts.ScriptElementKind.memberFunctionElement,\n+      });\n+    });\n+  });\n });\n \n function expectContain(\n@@ -117,6 +209,16 @@ function expectContain(\n   }\n }\n \n+function expectAll(\n+    completions: ts.CompletionInfo|undefined,\n+    contains: {[name: string]: ts.ScriptElementKind|DisplayInfoKind}): void {\n+  expect(completions).toBeDefined();\n+  for (const [name, kind] of Object.entries(contains)) {\n+    expect(completions!.entries).toContain(jasmine.objectContaining({name, kind} as any));\n+  }\n+  expect(completions!.entries.length).toEqual(Object.keys(contains).length);\n+}\n+\n function toText(displayParts?: ts.SymbolDisplayPart[]): string {\n   return (displayParts ?? []).map(p => p.text).join('');\n }\n@@ -166,4 +268,4 @@ function setup(templateWithCursor: string, classContents: string): {\n     nodes,\n     cursor,\n   };\n-}\n\\ No newline at end of file\n+}"
        }
    ],
    "stats": {
        "total": 257,
        "additions": 238,
        "deletions": 19
    }
}