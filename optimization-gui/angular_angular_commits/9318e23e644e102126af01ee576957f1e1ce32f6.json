{
    "author": "petebacondarwin",
    "message": "perf(ngcc): use `EntryPointManifest` to speed up noop `ProgramBaseEntryPointFinder` (#37665)\n\nPreviously the `ProgramBasedEntryPointFinder` was parsing all the\nentry-points referenced by the program for dependencies even if all the\nentry-points had been processed already.\n\nNow this entry-point finder will re-use the `EntryPointManifest` to load\nthe entry-point dependencies when possible which avoids having to parse\nthem all again, on every invocation of ngcc.\n\nPreviously the `EntryPointManifest` was only used in the\n`DirectoryWalkerEntryPointFinder`, which also contained the logic for\ncomputing the contents of the manifest. This logic has been factored out\ninto an `EntryPointCollector` class. Both the `ProgramBasedEntryPointFinder`\nand `DirectoryWalkerEntryPointFinder` now use the `EntryPointManifest` and\nthe `EntryPointCollector`.\n\nThe result of this change is that there is a small cost on the first run of\nngcc to compute and store the manifest - the processing takes 102% of the\nprocessing time before this PR. But on subsequent runs there is a\nsignificant benefit on subsequent runs - the processing takes around 50%\nof the processing time before this PR.\n\nPR Close #37665",
    "sha": "9318e23e644e102126af01ee576957f1e1ce32f6",
    "files": [
        {
            "sha": "cd368582de7d2ffb618ef117c35510770189621c",
            "filename": "packages/compiler-cli/ngcc/src/entry_point_finder/directory_walker_entry_point_finder.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 138,
            "changes": 147,
            "blob_url": "https://github.com/angular/angular/blob/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Fdirectory_walker_entry_point_finder.ts",
            "raw_url": "https://github.com/angular/angular/raw/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Fdirectory_walker_entry_point_finder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Fdirectory_walker_entry_point_finder.ts?ref=9318e23e644e102126af01ee576957f1e1ce32f6",
            "patch": "@@ -5,16 +5,14 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {AbsoluteFsPath, FileSystem, PathSegment} from '../../../src/ngtsc/file_system';\n+import {AbsoluteFsPath} from '../../../src/ngtsc/file_system';\n import {Logger} from '../../../src/ngtsc/logging';\n import {EntryPointWithDependencies} from '../dependencies/dependency_host';\n import {DependencyResolver, SortedEntryPointsInfo} from '../dependencies/dependency_resolver';\n-import {NgccConfiguration} from '../packages/configuration';\n-import {getEntryPointInfo, IGNORED_ENTRY_POINT, INCOMPATIBLE_ENTRY_POINT, isEntryPoint, NO_ENTRY_POINT} from '../packages/entry_point';\n import {EntryPointManifest} from '../packages/entry_point_manifest';\n import {PathMappings} from '../path_mappings';\n-import {NGCC_DIRECTORY} from '../writing/new_entry_point_file_writer';\n \n+import {EntryPointCollector} from './entry_point_collector';\n import {EntryPointFinder} from './interface';\n import {getBasePaths, trackDuration} from './utils';\n \n@@ -25,9 +23,11 @@ import {getBasePaths, trackDuration} from './utils';\n export class DirectoryWalkerEntryPointFinder implements EntryPointFinder {\n   private basePaths = getBasePaths(this.logger, this.sourceDirectory, this.pathMappings);\n   constructor(\n-      private fs: FileSystem, private config: NgccConfiguration, private logger: Logger,\n-      private resolver: DependencyResolver, private entryPointManifest: EntryPointManifest,\n-      private sourceDirectory: AbsoluteFsPath, private pathMappings: PathMappings|undefined) {}\n+      private logger: Logger, private resolver: DependencyResolver,\n+      private entryPointCollector: EntryPointCollector,\n+      private entryPointManifest: EntryPointManifest, private sourceDirectory: AbsoluteFsPath,\n+      private pathMappings: PathMappings|undefined) {}\n+\n   /**\n    * Search the `sourceDirectory`, and sub-directories, using `pathMappings` as necessary, to find\n    * all package entry-points.\n@@ -45,145 +45,16 @@ export class DirectoryWalkerEntryPointFinder implements EntryPointFinder {\n   /**\n    * Search the `basePath` for possible Angular packages and entry-points.\n    *\n-   * @param basePath The path at which to start the search\n+   * @param basePath The path at which to start the search.\n    * @returns an array of `EntryPoint`s that were found within `basePath`.\n    */\n   walkBasePathForPackages(basePath: AbsoluteFsPath): EntryPointWithDependencies[] {\n     this.logger.debug(\n         `No manifest found for ${basePath} so walking the directories for entry-points.`);\n     const entryPoints = trackDuration(\n-        () => this.walkDirectoryForPackages(basePath),\n+        () => this.entryPointCollector.walkDirectoryForPackages(basePath),\n         duration => this.logger.debug(`Walking ${basePath} for entry-points took ${duration}s.`));\n     this.entryPointManifest.writeEntryPointManifest(basePath, entryPoints);\n     return entryPoints;\n   }\n-\n-  /**\n-   * Look for Angular packages that need to be compiled, starting at the source directory.\n-   * The function will recurse into directories that start with `@...`, e.g. `@angular/...`.\n-   *\n-   * @param sourceDirectory An absolute path to the root directory where searching begins.\n-   * @returns an array of `EntryPoint`s that were found within `sourceDirectory`.\n-   */\n-  walkDirectoryForPackages(sourceDirectory: AbsoluteFsPath): EntryPointWithDependencies[] {\n-    // Try to get a primary entry point from this directory\n-    const primaryEntryPoint =\n-        getEntryPointInfo(this.fs, this.config, this.logger, sourceDirectory, sourceDirectory);\n-\n-    // If there is an entry-point but it is not compatible with ngcc (it has a bad package.json or\n-    // invalid typings) then exit. It is unlikely that such an entry point has a dependency on an\n-    // Angular library.\n-    if (primaryEntryPoint === INCOMPATIBLE_ENTRY_POINT) {\n-      return [];\n-    }\n-\n-    const entryPoints: EntryPointWithDependencies[] = [];\n-    if (primaryEntryPoint !== NO_ENTRY_POINT) {\n-      if (primaryEntryPoint !== IGNORED_ENTRY_POINT) {\n-        entryPoints.push(this.resolver.getEntryPointWithDependencies(primaryEntryPoint));\n-      }\n-      this.collectSecondaryEntryPoints(\n-          entryPoints, sourceDirectory, sourceDirectory, this.fs.readdir(sourceDirectory));\n-\n-      // Also check for any nested node_modules in this package but only if at least one of the\n-      // entry-points was compiled by Angular.\n-      if (entryPoints.some(e => e.entryPoint.compiledByAngular)) {\n-        const nestedNodeModulesPath = this.fs.join(sourceDirectory, 'node_modules');\n-        if (this.fs.exists(nestedNodeModulesPath)) {\n-          entryPoints.push(...this.walkDirectoryForPackages(nestedNodeModulesPath));\n-        }\n-      }\n-\n-      return entryPoints;\n-    }\n-\n-    // The `sourceDirectory` was not a package (i.e. there was no package.json)\n-    // So search its sub-directories for Angular packages and entry-points\n-    for (const path of this.fs.readdir(sourceDirectory)) {\n-      if (isIgnorablePath(path)) {\n-        // Ignore hidden files, node_modules and ngcc directory\n-        continue;\n-      }\n-\n-      const absolutePath = this.fs.resolve(sourceDirectory, path);\n-      const stat = this.fs.lstat(absolutePath);\n-      if (stat.isSymbolicLink() || !stat.isDirectory()) {\n-        // Ignore symbolic links and non-directories\n-        continue;\n-      }\n-\n-      entryPoints.push(...this.walkDirectoryForPackages(this.fs.join(sourceDirectory, path)));\n-    }\n-\n-    return entryPoints;\n-  }\n-\n-  /**\n-   * Search the `directory` looking for any secondary entry-points for a package, adding any that\n-   * are found to the `entryPoints` array.\n-   *\n-   * @param entryPoints An array where we will add any entry-points found in this directory\n-   * @param packagePath The absolute path to the package that may contain entry-points\n-   * @param directory The current directory being searched\n-   * @param paths The paths contained in the current `directory`.\n-   */\n-  private collectSecondaryEntryPoints(\n-      entryPoints: EntryPointWithDependencies[], packagePath: AbsoluteFsPath,\n-      directory: AbsoluteFsPath, paths: PathSegment[]): void {\n-    for (const path of paths) {\n-      if (isIgnorablePath(path)) {\n-        // Ignore hidden files, node_modules and ngcc directory\n-        continue;\n-      }\n-\n-      const absolutePath = this.fs.resolve(directory, path);\n-      const stat = this.fs.lstat(absolutePath);\n-      if (stat.isSymbolicLink()) {\n-        // Ignore symbolic links\n-        continue;\n-      }\n-\n-      const isDirectory = stat.isDirectory();\n-      if (!path.endsWith('.js') && !isDirectory) {\n-        // Ignore files that do not end in `.js`\n-        continue;\n-      }\n-\n-      // If the path is a JS file then strip its extension and see if we can match an\n-      // entry-point (even if it is an ignored one).\n-      const possibleEntryPointPath = isDirectory ? absolutePath : stripJsExtension(absolutePath);\n-      const subEntryPoint =\n-          getEntryPointInfo(this.fs, this.config, this.logger, packagePath, possibleEntryPointPath);\n-      if (isEntryPoint(subEntryPoint)) {\n-        entryPoints.push(this.resolver.getEntryPointWithDependencies(subEntryPoint));\n-      }\n-\n-      if (!isDirectory) {\n-        // This path is not a directory so we are done.\n-        continue;\n-      }\n-\n-      // If not an entry-point itself, this directory may contain entry-points of its own.\n-      const canContainEntryPoints =\n-          subEntryPoint === NO_ENTRY_POINT || subEntryPoint === INCOMPATIBLE_ENTRY_POINT;\n-      const childPaths = this.fs.readdir(absolutePath);\n-      if (canContainEntryPoints &&\n-          childPaths.some(\n-              childPath => childPath.endsWith('.js') &&\n-                  this.fs.stat(this.fs.resolve(absolutePath, childPath)).isFile())) {\n-        // We do not consider non-entry-point directories that contain JS files as they are very\n-        // unlikely to be containers for sub-entry-points.\n-        continue;\n-      }\n-      this.collectSecondaryEntryPoints(entryPoints, packagePath, absolutePath, childPaths);\n-    }\n-  }\n-}\n-\n-function stripJsExtension<T extends string>(filePath: T): T {\n-  return filePath.replace(/\\.js$/, '') as T;\n-}\n-\n-function isIgnorablePath(path: PathSegment): boolean {\n-  return path.startsWith('.') || path === 'node_modules' || path === NGCC_DIRECTORY;\n }"
        },
        {
            "sha": "638c9f9249b3027be661ae0a678ebf032d906f9c",
            "filename": "packages/compiler-cli/ngcc/src/entry_point_finder/entry_point_collector.ts",
            "status": "added",
            "additions": 154,
            "deletions": 0,
            "changes": 154,
            "blob_url": "https://github.com/angular/angular/blob/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Fentry_point_collector.ts",
            "raw_url": "https://github.com/angular/angular/raw/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Fentry_point_collector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Fentry_point_collector.ts?ref=9318e23e644e102126af01ee576957f1e1ce32f6",
            "patch": "@@ -0,0 +1,154 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {AbsoluteFsPath, FileSystem, PathSegment} from '../../../src/ngtsc/file_system';\n+import {Logger} from '../../../src/ngtsc/logging';\n+\n+import {EntryPointWithDependencies} from '../dependencies/dependency_host';\n+import {DependencyResolver} from '../dependencies/dependency_resolver';\n+import {NgccConfiguration} from '../packages/configuration';\n+import {getEntryPointInfo, IGNORED_ENTRY_POINT, INCOMPATIBLE_ENTRY_POINT, isEntryPoint, NO_ENTRY_POINT} from '../packages/entry_point';\n+import {NGCC_DIRECTORY} from '../writing/new_entry_point_file_writer';\n+\n+/**\n+ * A class that traverses a file-tree, starting at a given path, looking for all entry-points,\n+ * also capturing the dependencies of each entry-point that is found.\n+ */\n+export class EntryPointCollector {\n+  constructor(\n+      private fs: FileSystem, private config: NgccConfiguration, private logger: Logger,\n+      private resolver: DependencyResolver) {}\n+\n+  /**\n+   * Look for Angular packages that need to be compiled, starting at the source directory.\n+   * The function will recurse into directories that start with `@...`, e.g. `@angular/...`.\n+   *\n+   * @param sourceDirectory An absolute path to the root directory where searching begins.\n+   * @returns an array of `EntryPoint`s that were found within `sourceDirectory`.\n+   */\n+  walkDirectoryForPackages(sourceDirectory: AbsoluteFsPath): EntryPointWithDependencies[] {\n+    // Try to get a primary entry point from this directory\n+    const primaryEntryPoint =\n+        getEntryPointInfo(this.fs, this.config, this.logger, sourceDirectory, sourceDirectory);\n+\n+    // If there is an entry-point but it is not compatible with ngcc (it has a bad package.json or\n+    // invalid typings) then exit. It is unlikely that such an entry point has a dependency on an\n+    // Angular library.\n+    if (primaryEntryPoint === INCOMPATIBLE_ENTRY_POINT) {\n+      return [];\n+    }\n+\n+    const entryPoints: EntryPointWithDependencies[] = [];\n+    if (primaryEntryPoint !== NO_ENTRY_POINT) {\n+      if (primaryEntryPoint !== IGNORED_ENTRY_POINT) {\n+        entryPoints.push(this.resolver.getEntryPointWithDependencies(primaryEntryPoint));\n+      }\n+      this.collectSecondaryEntryPoints(\n+          entryPoints, sourceDirectory, sourceDirectory, this.fs.readdir(sourceDirectory));\n+\n+      // Also check for any nested node_modules in this package but only if at least one of the\n+      // entry-points was compiled by Angular.\n+      if (entryPoints.some(e => e.entryPoint.compiledByAngular)) {\n+        const nestedNodeModulesPath = this.fs.join(sourceDirectory, 'node_modules');\n+        if (this.fs.exists(nestedNodeModulesPath)) {\n+          entryPoints.push(...this.walkDirectoryForPackages(nestedNodeModulesPath));\n+        }\n+      }\n+\n+      return entryPoints;\n+    }\n+\n+    // The `sourceDirectory` was not a package (i.e. there was no package.json)\n+    // So search its sub-directories for Angular packages and entry-points\n+    for (const path of this.fs.readdir(sourceDirectory)) {\n+      if (isIgnorablePath(path)) {\n+        // Ignore hidden files, node_modules and ngcc directory\n+        continue;\n+      }\n+\n+      const absolutePath = this.fs.resolve(sourceDirectory, path);\n+      const stat = this.fs.lstat(absolutePath);\n+      if (stat.isSymbolicLink() || !stat.isDirectory()) {\n+        // Ignore symbolic links and non-directories\n+        continue;\n+      }\n+\n+      entryPoints.push(...this.walkDirectoryForPackages(this.fs.join(sourceDirectory, path)));\n+    }\n+\n+    return entryPoints;\n+  }\n+\n+  /**\n+   * Search the `directory` looking for any secondary entry-points for a package, adding any that\n+   * are found to the `entryPoints` array.\n+   *\n+   * @param entryPoints An array where we will add any entry-points found in this directory.\n+   * @param packagePath The absolute path to the package that may contain entry-points.\n+   * @param directory The current directory being searched.\n+   * @param paths The paths contained in the current `directory`.\n+   */\n+  private collectSecondaryEntryPoints(\n+      entryPoints: EntryPointWithDependencies[], packagePath: AbsoluteFsPath,\n+      directory: AbsoluteFsPath, paths: PathSegment[]): void {\n+    for (const path of paths) {\n+      if (isIgnorablePath(path)) {\n+        // Ignore hidden files, node_modules and ngcc directory\n+        continue;\n+      }\n+\n+      const absolutePath = this.fs.resolve(directory, path);\n+      const stat = this.fs.lstat(absolutePath);\n+      if (stat.isSymbolicLink()) {\n+        // Ignore symbolic links\n+        continue;\n+      }\n+\n+      const isDirectory = stat.isDirectory();\n+      if (!path.endsWith('.js') && !isDirectory) {\n+        // Ignore files that do not end in `.js`\n+        continue;\n+      }\n+\n+      // If the path is a JS file then strip its extension and see if we can match an\n+      // entry-point (even if it is an ignored one).\n+      const possibleEntryPointPath = isDirectory ? absolutePath : stripJsExtension(absolutePath);\n+      const subEntryPoint =\n+          getEntryPointInfo(this.fs, this.config, this.logger, packagePath, possibleEntryPointPath);\n+      if (isEntryPoint(subEntryPoint)) {\n+        entryPoints.push(this.resolver.getEntryPointWithDependencies(subEntryPoint));\n+      }\n+\n+      if (!isDirectory) {\n+        // This path is not a directory so we are done.\n+        continue;\n+      }\n+\n+      // If not an entry-point itself, this directory may contain entry-points of its own.\n+      const canContainEntryPoints =\n+          subEntryPoint === NO_ENTRY_POINT || subEntryPoint === INCOMPATIBLE_ENTRY_POINT;\n+      const childPaths = this.fs.readdir(absolutePath);\n+      if (canContainEntryPoints &&\n+          childPaths.some(\n+              childPath => childPath.endsWith('.js') &&\n+                  this.fs.stat(this.fs.resolve(absolutePath, childPath)).isFile())) {\n+        // We do not consider non-entry-point directories that contain JS files as they are very\n+        // unlikely to be containers for sub-entry-points.\n+        continue;\n+      }\n+      this.collectSecondaryEntryPoints(entryPoints, packagePath, absolutePath, childPaths);\n+    }\n+  }\n+}\n+\n+function stripJsExtension<T extends string>(filePath: T): T {\n+  return filePath.replace(/\\.js$/, '') as T;\n+}\n+\n+function isIgnorablePath(path: PathSegment): boolean {\n+  return path.startsWith('.') || path === 'node_modules' || path === NGCC_DIRECTORY;\n+}"
        },
        {
            "sha": "35bf766afa30c78c8a400f2cfdec04fb1728d347",
            "filename": "packages/compiler-cli/ngcc/src/entry_point_finder/program_based_entry_point_finder.ts",
            "status": "modified",
            "additions": 74,
            "deletions": 4,
            "changes": 78,
            "blob_url": "https://github.com/angular/angular/blob/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Fprogram_based_entry_point_finder.ts",
            "raw_url": "https://github.com/angular/angular/raw/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Fprogram_based_entry_point_finder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Fprogram_based_entry_point_finder.ts?ref=9318e23e644e102126af01ee576957f1e1ce32f6",
            "patch": "@@ -9,14 +9,17 @@ import {AbsoluteFsPath, FileSystem} from '../../../src/ngtsc/file_system';\n import {Logger} from '../../../src/ngtsc/logging';\n import {ParsedConfiguration} from '../../../src/perform_compile';\n \n-import {createDependencyInfo} from '../dependencies/dependency_host';\n+import {createDependencyInfo, EntryPointWithDependencies} from '../dependencies/dependency_host';\n import {DependencyResolver} from '../dependencies/dependency_resolver';\n import {EsmDependencyHost} from '../dependencies/esm_dependency_host';\n import {ModuleResolver} from '../dependencies/module_resolver';\n import {NgccConfiguration} from '../packages/configuration';\n+import {EntryPointManifest} from '../packages/entry_point_manifest';\n import {getPathMappingsFromTsConfig} from '../path_mappings';\n \n+import {EntryPointCollector} from './entry_point_collector';\n import {TracingEntryPointFinder} from './tracing_entry_point_finder';\n+import {trackDuration} from './utils';\n \n /**\n  * An EntryPointFinder that starts from the files in the program defined by the given tsconfig.json\n@@ -26,14 +29,21 @@ import {TracingEntryPointFinder} from './tracing_entry_point_finder';\n  * and is used primarily by the CLI integration.\n  */\n export class ProgramBasedEntryPointFinder extends TracingEntryPointFinder {\n+  private entryPointsWithDependencies: Map<AbsoluteFsPath, EntryPointWithDependencies>|null = null;\n+\n   constructor(\n       fs: FileSystem, config: NgccConfiguration, logger: Logger, resolver: DependencyResolver,\n-      basePath: AbsoluteFsPath, private tsConfig: ParsedConfiguration,\n-      projectPath: AbsoluteFsPath) {\n+      private entryPointCollector: EntryPointCollector,\n+      private entryPointManifest: EntryPointManifest, basePath: AbsoluteFsPath,\n+      private tsConfig: ParsedConfiguration, projectPath: AbsoluteFsPath) {\n     super(\n         fs, config, logger, resolver, basePath, getPathMappingsFromTsConfig(tsConfig, projectPath));\n   }\n \n+  /**\n+   * Return an array containing the external import paths that were extracted from the source-files\n+   * of the program defined by the tsconfig.json.\n+   */\n   protected getInitialEntryPointPaths(): AbsoluteFsPath[] {\n     const moduleResolver = new ModuleResolver(this.fs, this.pathMappings, ['', '.ts', '/index.ts']);\n     const host = new EsmDependencyHost(this.fs, moduleResolver);\n@@ -48,4 +58,64 @@ export class ProgramBasedEntryPointFinder extends TracingEntryPointFinder {\n     });\n     return Array.from(dependencies.dependencies);\n   }\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * For the given `entryPointPath`, compute, or retrieve, the entry-point information, including\n+   * paths to other entry-points that this entry-point depends upon.\n+   *\n+   * In this entry-point finder, we use the `EntryPointManifest` to avoid computing each\n+   * entry-point's dependencies in the case that this had been done previously.\n+   *\n+   * @param entryPointPath the path to the entry-point whose information and dependencies are to be\n+   *     retrieved or computed.\n+   *\n+   * @returns the entry-point and its dependencies or `null` if the entry-point is not compiled by\n+   *     Angular or cannot be determined.\n+   */\n+  protected getEntryPointWithDeps(entryPointPath: AbsoluteFsPath): EntryPointWithDependencies|null {\n+    const entryPoints = this.findOrLoadEntryPoints();\n+    if (!entryPoints.has(entryPointPath)) {\n+      return null;\n+    }\n+    const entryPointWithDeps = entryPoints.get(entryPointPath)!;\n+    if (!entryPointWithDeps.entryPoint.compiledByAngular) {\n+      return null;\n+    }\n+    return entryPointWithDeps;\n+  }\n+\n+  /**\n+   * Walk the base paths looking for entry-points or load this information from an entry-point\n+   * manifest, if available.\n+   */\n+  private findOrLoadEntryPoints(): Map<AbsoluteFsPath, EntryPointWithDependencies> {\n+    if (this.entryPointsWithDependencies === null) {\n+      const entryPointsWithDependencies = this.entryPointsWithDependencies =\n+          new Map<AbsoluteFsPath, EntryPointWithDependencies>();\n+      for (const basePath of this.getBasePaths()) {\n+        const entryPoints = this.entryPointManifest.readEntryPointsUsingManifest(basePath) ||\n+            this.walkBasePathForPackages(basePath);\n+        for (const e of entryPoints) {\n+          entryPointsWithDependencies.set(e.entryPoint.path, e);\n+        }\n+      }\n+    }\n+    return this.entryPointsWithDependencies;\n+  }\n+\n+  /**\n+   * Search the `basePath` for possible Angular packages and entry-points.\n+   *\n+   * @param basePath The path at which to start the search.\n+   * @returns an array of `EntryPoint`s that were found within `basePath`.\n+   */\n+  walkBasePathForPackages(basePath: AbsoluteFsPath): EntryPointWithDependencies[] {\n+    this.logger.debug(\n+        `No manifest found for ${basePath} so walking the directories for entry-points.`);\n+    const entryPoints = trackDuration(\n+        () => this.entryPointCollector.walkDirectoryForPackages(basePath),\n+        duration => this.logger.debug(`Walking ${basePath} for entry-points took ${duration}s.`));\n+    this.entryPointManifest.writeEntryPointManifest(basePath, entryPoints);\n+    return entryPoints;\n+  }\n+}"
        },
        {
            "sha": "d39f65d78c3684ff162c590325ff83f33745b695",
            "filename": "packages/compiler-cli/ngcc/src/entry_point_finder/targeted_entry_point_finder.ts",
            "status": "modified",
            "additions": 172,
            "deletions": 6,
            "changes": 178,
            "blob_url": "https://github.com/angular/angular/blob/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Ftargeted_entry_point_finder.ts",
            "raw_url": "https://github.com/angular/angular/raw/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Ftargeted_entry_point_finder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Ftargeted_entry_point_finder.ts?ref=9318e23e644e102126af01ee576957f1e1ce32f6",
            "patch": "@@ -5,12 +5,13 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {AbsoluteFsPath, FileSystem} from '../../../src/ngtsc/file_system';\n+import {AbsoluteFsPath, FileSystem, join, PathSegment, relative, relativeFrom} from '../../../src/ngtsc/file_system';\n import {Logger} from '../../../src/ngtsc/logging';\n+import {EntryPointWithDependencies} from '../dependencies/dependency_host';\n import {DependencyResolver, SortedEntryPointsInfo} from '../dependencies/dependency_resolver';\n import {hasBeenProcessed} from '../packages/build_marker';\n import {NgccConfiguration} from '../packages/configuration';\n-import {EntryPointJsonProperty} from '../packages/entry_point';\n+import {EntryPointJsonProperty, getEntryPointInfo, isEntryPoint} from '../packages/entry_point';\n import {PathMappings} from '../path_mappings';\n \n import {TracingEntryPointFinder} from './tracing_entry_point_finder';\n@@ -30,6 +31,10 @@ export class TargetedEntryPointFinder extends TracingEntryPointFinder {\n     super(fs, config, logger, resolver, basePath, pathMappings);\n   }\n \n+  /**\n+   * Search for Angular entry-points that can be reached from the entry-point specified by the given\n+   * `targetPath`.\n+   */\n   findEntryPoints(): SortedEntryPointsInfo {\n     const entryPoints = super.findEntryPoints();\n \n@@ -43,17 +48,25 @@ export class TargetedEntryPointFinder extends TracingEntryPointFinder {\n     return entryPoints;\n   }\n \n+  /**\n+   * Determine whether the entry-point at the given `targetPath` needs to be processed.\n+   *\n+   * @param propertiesToConsider the package.json properties that should be considered for\n+   *     processing.\n+   * @param compileAllFormats true if all formats need to be processed, or false if it is enough for\n+   *     one of the formats covered by the `propertiesToConsider` is processed.\n+   */\n   targetNeedsProcessingOrCleaning(\n       propertiesToConsider: EntryPointJsonProperty[], compileAllFormats: boolean): boolean {\n-    const entryPoint = this.getEntryPoint(this.targetPath);\n-    if (entryPoint === null || !entryPoint.compiledByAngular) {\n+    const entryPointWithDeps = this.getEntryPointWithDeps(this.targetPath);\n+    if (entryPointWithDeps === null) {\n       return false;\n     }\n \n     for (const property of propertiesToConsider) {\n-      if (entryPoint.packageJson[property]) {\n+      if (entryPointWithDeps.entryPoint.packageJson[property]) {\n         // Here is a property that should be processed.\n-        if (!hasBeenProcessed(entryPoint.packageJson, property)) {\n+        if (!hasBeenProcessed(entryPointWithDeps.entryPoint.packageJson, property)) {\n           return true;\n         }\n         if (!compileAllFormats) {\n@@ -67,7 +80,160 @@ export class TargetedEntryPointFinder extends TracingEntryPointFinder {\n     return false;\n   }\n \n+  /**\n+   * Return an array containing the `targetPath` from which to start the trace.\n+   */\n   protected getInitialEntryPointPaths(): AbsoluteFsPath[] {\n     return [this.targetPath];\n   }\n+\n+  /**\n+   * For the given `entryPointPath`, compute, or retrieve, the entry-point information, including\n+   * paths to other entry-points that this entry-point depends upon.\n+   *\n+   * @param entryPointPath the path to the entry-point whose information and dependencies are to be\n+   *     retrieved or computed.\n+   *\n+   * @returns the entry-point and its dependencies or `null` if the entry-point is not compiled by\n+   *     Angular or cannot be determined.\n+   */\n+  protected getEntryPointWithDeps(entryPointPath: AbsoluteFsPath): EntryPointWithDependencies|null {\n+    const packagePath = this.computePackagePath(entryPointPath);\n+    const entryPoint =\n+        getEntryPointInfo(this.fs, this.config, this.logger, packagePath, entryPointPath);\n+    if (!isEntryPoint(entryPoint) || !entryPoint.compiledByAngular) {\n+      return null;\n+    }\n+    return this.resolver.getEntryPointWithDependencies(entryPoint);\n+  }\n+\n+  /**\n+   * Compute the path to the package that contains the given entry-point.\n+   *\n+   * In this entry-point finder it is not trivial to find the containing package, since it is\n+   * possible that this entry-point is not directly below the directory containing the package.\n+   * Moreover, the import path could be affected by path-mapping.\n+   *\n+   * @param entryPointPath the path to the entry-point, whose package path we want to compute.\n+   */\n+  private computePackagePath(entryPointPath: AbsoluteFsPath): AbsoluteFsPath {\n+    // First try the main basePath, to avoid having to compute the other basePaths from the paths\n+    // mappings, which can be computationally intensive.\n+    if (entryPointPath.startsWith(this.basePath)) {\n+      const packagePath = this.computePackagePathFromContainingPath(entryPointPath, this.basePath);\n+      if (packagePath !== null) {\n+        return packagePath;\n+      }\n+    }\n+\n+    // The main `basePath` didn't work out so now we try the `basePaths` computed from the paths\n+    // mappings in `tsconfig.json`.\n+    for (const basePath of this.getBasePaths()) {\n+      if (entryPointPath.startsWith(basePath)) {\n+        const packagePath = this.computePackagePathFromContainingPath(entryPointPath, basePath);\n+        if (packagePath !== null) {\n+          return packagePath;\n+        }\n+        // If we got here then we couldn't find a `packagePath` for the current `basePath`.\n+        // Since `basePath`s are guaranteed not to be a sub-directory of each other then no other\n+        // `basePath` will match either.\n+        break;\n+      }\n+    }\n+\n+    // Finally, if we couldn't find a `packagePath` using `basePaths` then try to find the nearest\n+    // `node_modules` that contains the `entryPointPath`, if there is one, and use it as a\n+    // `basePath`.\n+    return this.computePackagePathFromNearestNodeModules(entryPointPath);\n+  }\n+\n+\n+  /**\n+   * Search down to the `entryPointPath` from the `containingPath` for the first `package.json` that\n+   * we come to. This is the path to the entry-point's containing package. For example if\n+   * `containingPath` is `/a/b/c` and `entryPointPath` is `/a/b/c/d/e` and there exists\n+   * `/a/b/c/d/package.json` and `/a/b/c/d/e/package.json`, then we will return `/a/b/c/d`.\n+   *\n+   * To account for nested `node_modules` we actually start the search at the last `node_modules` in\n+   * the `entryPointPath` that is below the `containingPath`. E.g. if `containingPath` is `/a/b/c`\n+   * and `entryPointPath` is `/a/b/c/d/node_modules/x/y/z`, we start the search at\n+   * `/a/b/c/d/node_modules`.\n+   */\n+  private computePackagePathFromContainingPath(\n+      entryPointPath: AbsoluteFsPath, containingPath: AbsoluteFsPath): AbsoluteFsPath|null {\n+    let packagePath = containingPath;\n+    const segments = this.splitPath(relative(containingPath, entryPointPath));\n+    let nodeModulesIndex = segments.lastIndexOf(relativeFrom('node_modules'));\n+\n+    // If there are no `node_modules` in the relative path between the `basePath` and the\n+    // `entryPointPath` then just try the `basePath` as the `packagePath`.\n+    // (This can be the case with path-mapped entry-points.)\n+    if (nodeModulesIndex === -1) {\n+      if (this.fs.exists(join(packagePath, 'package.json'))) {\n+        return packagePath;\n+      }\n+    }\n+\n+    // Start the search at the deepest nested `node_modules` folder that is below the `basePath`\n+    // but above the `entryPointPath`, if there are any.\n+    while (nodeModulesIndex >= 0) {\n+      packagePath = join(packagePath, segments.shift()!);\n+      nodeModulesIndex--;\n+    }\n+\n+    // Note that we start at the folder below the current candidate `packagePath` because the\n+    // initial candidate `packagePath` is either a `node_modules` folder or the `basePath` with\n+    // no `package.json`.\n+    for (const segment of segments) {\n+      packagePath = join(packagePath, segment);\n+      if (this.fs.exists(join(packagePath, 'package.json'))) {\n+        return packagePath;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Search up the directory tree from the `entryPointPath` looking for a `node_modules` directory\n+   * that we can use as a potential starting point for computing the package path.\n+   */\n+  private computePackagePathFromNearestNodeModules(entryPointPath: AbsoluteFsPath): AbsoluteFsPath {\n+    let packagePath = entryPointPath;\n+    let scopedPackagePath = packagePath;\n+    let containerPath = this.fs.dirname(packagePath);\n+    while (!this.fs.isRoot(containerPath) && !containerPath.endsWith('node_modules')) {\n+      scopedPackagePath = packagePath;\n+      packagePath = containerPath;\n+      containerPath = this.fs.dirname(containerPath);\n+    }\n+\n+    if (this.fs.exists(join(packagePath, 'package.json'))) {\n+      // The directory directly below `node_modules` is a package - use it\n+      return packagePath;\n+    } else if (\n+        this.fs.basename(packagePath).startsWith('@') &&\n+        this.fs.exists(join(scopedPackagePath, 'package.json'))) {\n+      // The directory directly below the `node_modules` is a scope and the directory directly\n+      // below that is a scoped package - use it\n+      return scopedPackagePath;\n+    } else {\n+      // If we get here then none of the `basePaths` contained the `entryPointPath` and the\n+      // `entryPointPath` contains no `node_modules` that contains a package or a scoped\n+      // package. All we can do is assume that this entry-point is a primary entry-point to a\n+      // package.\n+      return entryPointPath;\n+    }\n+  }\n+\n+  /**\n+   * Split the given `path` into path segments using an FS independent algorithm.\n+   */\n+  private splitPath(path: PathSegment) {\n+    const segments = [];\n+    while (path !== '.') {\n+      segments.unshift(this.fs.basename(path));\n+      path = this.fs.dirname(path);\n+    }\n+    return segments;\n+  }\n }"
        },
        {
            "sha": "578b184247c20182a641b938dd06b9b5e977d066",
            "filename": "packages/compiler-cli/ngcc/src/entry_point_finder/tracing_entry_point_finder.ts",
            "status": "modified",
            "additions": 46,
            "deletions": 152,
            "changes": 198,
            "blob_url": "https://github.com/angular/angular/blob/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Ftracing_entry_point_finder.ts",
            "raw_url": "https://github.com/angular/angular/raw/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Ftracing_entry_point_finder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Ftracing_entry_point_finder.ts?ref=9318e23e644e102126af01ee576957f1e1ce32f6",
            "patch": "@@ -5,13 +5,12 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {AbsoluteFsPath, FileSystem, join, PathSegment, relative, relativeFrom} from '../../../src/ngtsc/file_system';\n+import {AbsoluteFsPath, FileSystem} from '../../../src/ngtsc/file_system';\n import {Logger} from '../../../src/ngtsc/logging';\n \n import {EntryPointWithDependencies} from '../dependencies/dependency_host';\n import {DependencyResolver, SortedEntryPointsInfo} from '../dependencies/dependency_resolver';\n import {NgccConfiguration} from '../packages/configuration';\n-import {EntryPoint, getEntryPointInfo, isEntryPoint} from '../packages/entry_point';\n import {PathMappings} from '../path_mappings';\n \n import {EntryPointFinder} from './interface';\n@@ -21,184 +20,79 @@ import {getBasePaths} from './utils';\n  * An EntryPointFinder that starts from a set of initial files and only returns entry-points that\n  * are dependencies of these files.\n  *\n- * This is faster than searching the entire file-system for all the entry-points,\n- * and is used primarily by the CLI integration.\n+ * This is faster than processing all entry-points in the entire file-system, and is used primarily\n+ * by the CLI integration.\n  *\n  * There are two concrete implementations of this class.\n  *\n- * * `TargetEntryPointFinder` - is given a single entry-point as the initial entry-point\n- * * `ProgramBasedEntryPointFinder` - computes the initial entry-points from program files given by\n- * a `tsconfig.json` file.\n+ * * `TargetEntryPointFinder` - is given a single entry-point as the initial entry-point. This can\n+ *   be used in the synchronous CLI integration where the build tool has identified an external\n+ *   import to one of the source files being built.\n+ * * `ProgramBasedEntryPointFinder` - computes the initial entry-points from the source files\n+ *   computed from a `tsconfig.json` file. This can be used in the asynchronous CLI integration\n+ *   where the `tsconfig.json` to be used to do the build is known.\n  */\n export abstract class TracingEntryPointFinder implements EntryPointFinder {\n-  protected unprocessedPaths: AbsoluteFsPath[] = [];\n-  protected unsortedEntryPoints = new Map<AbsoluteFsPath, EntryPointWithDependencies>();\n   private basePaths: AbsoluteFsPath[]|null = null;\n \n   constructor(\n       protected fs: FileSystem, protected config: NgccConfiguration, protected logger: Logger,\n       protected resolver: DependencyResolver, protected basePath: AbsoluteFsPath,\n       protected pathMappings: PathMappings|undefined) {}\n \n-  protected getBasePaths() {\n-    if (this.basePaths === null) {\n-      this.basePaths = getBasePaths(this.logger, this.basePath, this.pathMappings);\n-    }\n-    return this.basePaths;\n-  }\n-\n+  /**\n+   * Search for Angular package entry-points.\n+   */\n   findEntryPoints(): SortedEntryPointsInfo {\n-    this.unprocessedPaths = this.getInitialEntryPointPaths();\n-    while (this.unprocessedPaths.length > 0) {\n-      this.processNextPath();\n-    }\n-    return this.resolver.sortEntryPointsByDependency(Array.from(this.unsortedEntryPoints.values()));\n-  }\n-\n-  protected abstract getInitialEntryPointPaths(): AbsoluteFsPath[];\n-\n-  protected getEntryPoint(entryPointPath: AbsoluteFsPath): EntryPoint|null {\n-    const packagePath = this.computePackagePath(entryPointPath);\n-    const entryPoint =\n-        getEntryPointInfo(this.fs, this.config, this.logger, packagePath, entryPointPath);\n-\n-    return isEntryPoint(entryPoint) ? entryPoint : null;\n-  }\n-\n-  private processNextPath(): void {\n-    const path = this.unprocessedPaths.shift()!;\n-    const entryPoint = this.getEntryPoint(path);\n-    if (entryPoint === null || !entryPoint.compiledByAngular) {\n-      return;\n-    }\n-    const entryPointWithDeps = this.resolver.getEntryPointWithDependencies(entryPoint);\n-    this.unsortedEntryPoints.set(entryPoint.path, entryPointWithDeps);\n-    entryPointWithDeps.depInfo.dependencies.forEach(dep => {\n-      if (!this.unsortedEntryPoints.has(dep)) {\n-        this.unprocessedPaths.push(dep);\n+    const unsortedEntryPoints = new Map<AbsoluteFsPath, EntryPointWithDependencies>();\n+    const unprocessedPaths = this.getInitialEntryPointPaths();\n+    while (unprocessedPaths.length > 0) {\n+      const path = unprocessedPaths.shift()!;\n+      const entryPointWithDeps = this.getEntryPointWithDeps(path);\n+      if (entryPointWithDeps === null) {\n+        continue;\n       }\n-    });\n-  }\n-\n-  private computePackagePath(entryPointPath: AbsoluteFsPath): AbsoluteFsPath {\n-    // First try the main basePath, to avoid having to compute the other basePaths from the paths\n-    // mappings, which can be computationally intensive.\n-    if (entryPointPath.startsWith(this.basePath)) {\n-      const packagePath = this.computePackagePathFromContainingPath(entryPointPath, this.basePath);\n-      if (packagePath !== null) {\n-        return packagePath;\n-      }\n-    }\n-\n-    // The main `basePath` didn't work out so now we try the `basePaths` computed from the paths\n-    // mappings in `tsconfig.json`.\n-    for (const basePath of this.getBasePaths()) {\n-      if (entryPointPath.startsWith(basePath)) {\n-        const packagePath = this.computePackagePathFromContainingPath(entryPointPath, basePath);\n-        if (packagePath !== null) {\n-          return packagePath;\n+      unsortedEntryPoints.set(entryPointWithDeps.entryPoint.path, entryPointWithDeps);\n+      entryPointWithDeps.depInfo.dependencies.forEach(dep => {\n+        if (!unsortedEntryPoints.has(dep)) {\n+          unprocessedPaths.push(dep);\n         }\n-        // If we got here then we couldn't find a `packagePath` for the current `basePath`.\n-        // Since `basePath`s are guaranteed not to be a sub-directory of each other then no other\n-        // `basePath` will match either.\n-        break;\n-      }\n+      });\n     }\n-\n-    // Finally, if we couldn't find a `packagePath` using `basePaths` then try to find the nearest\n-    // `node_modules` that contains the `entryPointPath`, if there is one, and use it as a\n-    // `basePath`.\n-    return this.computePackagePathFromNearestNodeModules(entryPointPath);\n+    return this.resolver.sortEntryPointsByDependency(Array.from(unsortedEntryPoints.values()));\n   }\n \n \n   /**\n-   * Search down to the `entryPointPath` from the `containingPath` for the first `package.json` that\n-   * we come to. This is the path to the entry-point's containing package. For example if\n-   * `containingPath` is `/a/b/c` and `entryPointPath` is `/a/b/c/d/e` and there exists\n-   * `/a/b/c/d/package.json` and `/a/b/c/d/e/package.json`, then we will return `/a/b/c/d`.\n-   *\n-   * To account for nested `node_modules` we actually start the search at the last `node_modules` in\n-   * the `entryPointPath` that is below the `containingPath`. E.g. if `containingPath` is `/a/b/c`\n-   * and `entryPointPath` is `/a/b/c/d/node_modules/x/y/z`, we start the search at\n-   * `/a/b/c/d/node_modules`.\n+   * Return an array of entry-point paths from which to start the trace.\n    */\n-  private computePackagePathFromContainingPath(\n-      entryPointPath: AbsoluteFsPath, containingPath: AbsoluteFsPath): AbsoluteFsPath|null {\n-    let packagePath = containingPath;\n-    const segments = this.splitPath(relative(containingPath, entryPointPath));\n-    let nodeModulesIndex = segments.lastIndexOf(relativeFrom('node_modules'));\n-\n-    // If there are no `node_modules` in the relative path between the `basePath` and the\n-    // `entryPointPath` then just try the `basePath` as the `packagePath`.\n-    // (This can be the case with path-mapped entry-points.)\n-    if (nodeModulesIndex === -1) {\n-      if (this.fs.exists(join(packagePath, 'package.json'))) {\n-        return packagePath;\n-      }\n-    }\n-\n-    // Start the search at the deepest nested `node_modules` folder that is below the `basePath`\n-    // but above the `entryPointPath`, if there are any.\n-    while (nodeModulesIndex >= 0) {\n-      packagePath = join(packagePath, segments.shift()!);\n-      nodeModulesIndex--;\n-    }\n-\n-    // Note that we start at the folder below the current candidate `packagePath` because the\n-    // initial candidate `packagePath` is either a `node_modules` folder or the `basePath` with\n-    // no `package.json`.\n-    for (const segment of segments) {\n-      packagePath = join(packagePath, segment);\n-      if (this.fs.exists(join(packagePath, 'package.json'))) {\n-        return packagePath;\n-      }\n-    }\n-    return null;\n-  }\n+  protected abstract getInitialEntryPointPaths(): AbsoluteFsPath[];\n \n   /**\n-   * Search up the directory tree from the `entryPointPath` looking for a `node_modules` directory\n-   * that we can use as a potential starting point for computing the package path.\n+   * For the given `entryPointPath`, compute, or retrieve, the entry-point information, including\n+   * paths to other entry-points that this entry-point depends upon.\n+   *\n+   * @param entryPointPath the path to the entry-point whose information and dependencies are to be\n+   *     retrieved or computed.\n+   *\n+   * @returns the entry-point and its dependencies or `null` if the entry-point is not compiled by\n+   *     Angular or cannot be determined.\n    */\n-  private computePackagePathFromNearestNodeModules(entryPointPath: AbsoluteFsPath): AbsoluteFsPath {\n-    let packagePath = entryPointPath;\n-    let scopedPackagePath = packagePath;\n-    let containerPath = this.fs.dirname(packagePath);\n-    while (!this.fs.isRoot(containerPath) && !containerPath.endsWith('node_modules')) {\n-      scopedPackagePath = packagePath;\n-      packagePath = containerPath;\n-      containerPath = this.fs.dirname(containerPath);\n-    }\n+  protected abstract getEntryPointWithDeps(entryPointPath: AbsoluteFsPath):\n+      EntryPointWithDependencies|null;\n \n-    if (this.fs.exists(join(packagePath, 'package.json'))) {\n-      // The directory directly below `node_modules` is a package - use it\n-      return packagePath;\n-    } else if (\n-        this.fs.basename(packagePath).startsWith('@') &&\n-        this.fs.exists(join(scopedPackagePath, 'package.json'))) {\n-      // The directory directly below the `node_modules` is a scope and the directory directly\n-      // below that is a scoped package - use it\n-      return scopedPackagePath;\n-    } else {\n-      // If we get here then none of the `basePaths` contained the `entryPointPath` and the\n-      // `entryPointPath` contains no `node_modules` that contains a package or a scoped\n-      // package. All we can do is assume that this entry-point is a primary entry-point to a\n-      // package.\n-      return entryPointPath;\n-    }\n-  }\n \n   /**\n-   * Split the given `path` into path segments using an FS independent algorithm.\n-   * @param path The path to split.\n+   * Parse the path-mappings to compute the base-paths that need to be considered when finding\n+   * entry-points.\n+   *\n+   * This processing can be time-consuming if the path-mappings are complex or extensive.\n+   * So the result is cached locally once computed.\n    */\n-  private splitPath(path: PathSegment) {\n-    const segments = [];\n-    while (path !== '.') {\n-      segments.unshift(this.fs.basename(path));\n-      path = this.fs.dirname(path);\n+  protected getBasePaths() {\n+    if (this.basePaths === null) {\n+      this.basePaths = getBasePaths(this.logger, this.basePath, this.pathMappings);\n     }\n-    return segments;\n+    return this.basePaths;\n   }\n }"
        },
        {
            "sha": "37099f1e98d7e9844c04218b8f3550a0d5077ff3",
            "filename": "packages/compiler-cli/ngcc/src/entry_point_finder/utils.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Futils.ts?ref=9318e23e644e102126af01ee576957f1e1ce32f6",
            "patch": "@@ -82,8 +82,8 @@ function extractPathPrefix(path: string) {\n /**\n  * Run a task and track how long it takes.\n  *\n- * @param task The task whose duration we are tracking\n- * @param log The function to call with the duration of the task\n+ * @param task The task whose duration we are tracking.\n+ * @param log The function to call with the duration of the task.\n  * @returns The result of calling `task`.\n  */\n export function trackDuration<T = void>(task: () => T extends Promise<unknown>? never : T,\n@@ -136,7 +136,7 @@ function addPath(root: Node, path: AbsoluteFsPath): void {\n }\n \n /**\n- * Flatten the tree of nodes back into an array of absolute paths\n+ * Flatten the tree of nodes back into an array of absolute paths.\n  */\n function flattenTree(root: Node): AbsoluteFsPath[] {\n   const paths: AbsoluteFsPath[] = [];"
        },
        {
            "sha": "d87bd556cd096b7685beef0b6f8473374367a249",
            "filename": "packages/compiler-cli/ngcc/src/main.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fmain.ts",
            "raw_url": "https://github.com/angular/angular/raw/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fmain.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fmain.ts?ref=9318e23e644e102126af01ee576957f1e1ce32f6",
            "patch": "@@ -21,6 +21,7 @@ import {EsmDependencyHost} from './dependencies/esm_dependency_host';\n import {ModuleResolver} from './dependencies/module_resolver';\n import {UmdDependencyHost} from './dependencies/umd_dependency_host';\n import {DirectoryWalkerEntryPointFinder} from './entry_point_finder/directory_walker_entry_point_finder';\n+import {EntryPointCollector} from './entry_point_finder/entry_point_collector';\n import {EntryPointFinder} from './entry_point_finder/interface';\n import {ProgramBasedEntryPointFinder} from './entry_point_finder/program_based_entry_point_finder';\n import {TargetedEntryPointFinder} from './entry_point_finder/targeted_entry_point_finder';\n@@ -203,10 +204,15 @@ function getEntryPointFinder(\n   if (absoluteTargetEntryPointPath !== null) {\n     return new TargetedEntryPointFinder(\n         fs, config, logger, resolver, basePath, pathMappings, absoluteTargetEntryPointPath);\n-  } else if (tsConfig !== null) {\n-    return new ProgramBasedEntryPointFinder(\n-        fs, config, logger, resolver, basePath, tsConfig, projectPath);\n+  } else {\n+    const entryPointCollector = new EntryPointCollector(fs, config, logger, resolver);\n+    if (tsConfig !== null) {\n+      return new ProgramBasedEntryPointFinder(\n+          fs, config, logger, resolver, entryPointCollector, entryPointManifest, basePath, tsConfig,\n+          projectPath);\n+    } else {\n+      return new DirectoryWalkerEntryPointFinder(\n+          logger, resolver, entryPointCollector, entryPointManifest, basePath, pathMappings);\n+    }\n   }\n-  return new DirectoryWalkerEntryPointFinder(\n-      fs, config, logger, resolver, entryPointManifest, basePath, pathMappings);\n }"
        },
        {
            "sha": "a3ecc66be6f2385564d11f8bff94ec72d048ef99",
            "filename": "packages/compiler-cli/ngcc/test/entry_point_finder/directory_walker_entry_point_finder_spec.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 22,
            "changes": 47,
            "blob_url": "https://github.com/angular/angular/blob/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fentry_point_finder%2Fdirectory_walker_entry_point_finder_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fentry_point_finder%2Fdirectory_walker_entry_point_finder_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fentry_point_finder%2Fdirectory_walker_entry_point_finder_spec.ts?ref=9318e23e644e102126af01ee576957f1e1ce32f6",
            "patch": "@@ -14,6 +14,7 @@ import {DtsDependencyHost} from '../../src/dependencies/dts_dependency_host';\n import {EsmDependencyHost} from '../../src/dependencies/esm_dependency_host';\n import {ModuleResolver} from '../../src/dependencies/module_resolver';\n import {DirectoryWalkerEntryPointFinder} from '../../src/entry_point_finder/directory_walker_entry_point_finder';\n+import {EntryPointCollector} from '../../src/entry_point_finder/entry_point_collector';\n import {NgccConfiguration, ProcessedNgccPackageConfig} from '../../src/packages/configuration';\n import {EntryPoint} from '../../src/packages/entry_point';\n import {EntryPointManifest, EntryPointManifestFile} from '../../src/packages/entry_point_manifest';\n@@ -25,6 +26,7 @@ runInEachFileSystem(() => {\n     let resolver: DependencyResolver;\n     let logger: MockLogger;\n     let config: NgccConfiguration;\n+    let collector: EntryPointCollector;\n     let manifest: EntryPointManifest;\n     let _Abs: typeof absoluteFrom;\n \n@@ -37,6 +39,7 @@ runInEachFileSystem(() => {\n       config = new NgccConfiguration(fs, _Abs('/'));\n       resolver = new DependencyResolver(fs, logger, config, {esm2015: srcHost}, dtsHost);\n       manifest = new EntryPointManifest(fs, config, logger);\n+      collector = new EntryPointCollector(fs, config, logger, resolver);\n     });\n \n     describe('findEntryPoints()', () => {\n@@ -50,7 +53,7 @@ runInEachFileSystem(() => {\n           ...createPackage(fs.resolve(basePath, 'common'), 'testing', ['common']),\n         ]);\n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, basePath, undefined);\n+            logger, resolver, collector, manifest, basePath, undefined);\n         const {entryPoints} = finder.findEntryPoints();\n         expect(dumpEntryPointPaths(basePath, entryPoints)).toEqual([\n           ['common', 'common'],\n@@ -71,7 +74,7 @@ runInEachFileSystem(() => {\n           ...createPackage(fs.resolve(basePath, '@angular/common'), 'testing', ['@angular/common']),\n         ]);\n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, basePath, undefined);\n+            logger, resolver, collector, manifest, basePath, undefined);\n         const {entryPoints} = finder.findEntryPoints();\n         expect(dumpEntryPointPaths(basePath, entryPoints)).toEqual([\n           ['@angular/common', '@angular/common'],\n@@ -84,7 +87,7 @@ runInEachFileSystem(() => {\n       it('should return an empty array if there are no packages', () => {\n         fs.ensureDir(_Abs('/no_packages/node_modules/should_not_be_found'));\n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, _Abs('/no_packages/node_modules'), undefined);\n+            logger, resolver, collector, manifest, _Abs('/no_packages/node_modules'), undefined);\n         const {entryPoints} = finder.findEntryPoints();\n         expect(entryPoints).toEqual([]);\n       });\n@@ -97,7 +100,7 @@ runInEachFileSystem(() => {\n           },\n         ]);\n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, _Abs('/no_valid_entry_points/node_modules'),\n+            logger, resolver, collector, manifest, _Abs('/no_valid_entry_points/node_modules'),\n             undefined);\n         const {entryPoints} = finder.findEntryPoints();\n         expect(entryPoints).toEqual([]);\n@@ -106,7 +109,7 @@ runInEachFileSystem(() => {\n       it('should not include ignored entry-points', () => {\n         const basePath = _Abs('/project/node_modules');\n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, basePath, undefined);\n+            logger, resolver, collector, manifest, basePath, undefined);\n \n         loadTestFiles(createPackage(basePath, 'some-package'));\n         spyOn(config, 'getPackageConfig')\n@@ -124,7 +127,7 @@ runInEachFileSystem(() => {\n       it('should look for sub-entry-points even if a containing entry-point is ignored', () => {\n         const basePath = _Abs('/project/node_modules');\n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, basePath, undefined);\n+            logger, resolver, collector, manifest, basePath, undefined);\n \n         loadTestFiles([\n           ...createPackage(basePath, 'some-package'),\n@@ -161,7 +164,7 @@ runInEachFileSystem(() => {\n            spyOn(manifest, 'readEntryPointsUsingManifest').and.callThrough();\n            spyOn(manifest, 'writeEntryPointManifest').and.callThrough();\n            const finder = new DirectoryWalkerEntryPointFinder(\n-               fs, config, logger, resolver, manifest, basePath, undefined);\n+               logger, resolver, collector, manifest, basePath, undefined);\n            finder.findEntryPoints();\n            expect(manifest.readEntryPointsUsingManifest).toHaveBeenCalled();\n            expect(manifest.writeEntryPointManifest).toHaveBeenCalled();\n@@ -182,7 +185,7 @@ runInEachFileSystem(() => {\n         spyOn(manifest, 'readEntryPointsUsingManifest').and.callThrough();\n         spyOn(manifest, 'writeEntryPointManifest').and.callThrough();\n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, basePath, undefined);\n+            logger, resolver, collector, manifest, basePath, undefined);\n         finder.findEntryPoints();\n         expect(manifest.readEntryPointsUsingManifest).toHaveBeenCalled();\n         expect(manifest.writeEntryPointManifest).toHaveBeenCalled();\n@@ -200,7 +203,7 @@ runInEachFileSystem(() => {\n           {name: _Abs('/sub_entry_points/yarn.lock'), contents: 'MOCK LOCK FILE'},\n         ]);\n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, basePath, undefined);\n+            logger, resolver, collector, manifest, basePath, undefined);\n \n         // Prime the manifest by calling findEntryPoints() once.\n         finder.findEntryPoints();\n@@ -229,8 +232,7 @@ runInEachFileSystem(() => {\n           ...createPackage(_Abs('/dotted_folders/node_modules/'), '.common'),\n         ]);\n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, _Abs('/dotted_folders/node_modules'),\n-            undefined);\n+            logger, resolver, collector, manifest, _Abs('/dotted_folders/node_modules'), undefined);\n         const {entryPoints} = finder.findEntryPoints();\n         expect(entryPoints).toEqual([]);\n       });\n@@ -241,7 +243,7 @@ runInEachFileSystem(() => {\n             _Abs('/external/node_modules/common'), _Abs('/symlinked_folders/node_modules/common'));\n         loadTestFiles(createPackage(_Abs('/external/node_modules'), 'common'));\n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, _Abs('/symlinked_folders/node_modules'),\n+            logger, resolver, collector, manifest, _Abs('/symlinked_folders/node_modules'),\n             undefined);\n         const {entryPoints} = finder.findEntryPoints();\n         expect(entryPoints).toEqual([]);\n@@ -253,7 +255,7 @@ runInEachFileSystem(() => {\n           ...createPackage(_Abs('/nested_node_modules/node_modules/outer/node_modules'), 'inner'),\n         ]);\n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, _Abs('/nested_node_modules/node_modules'),\n+            logger, resolver, collector, manifest, _Abs('/nested_node_modules/node_modules'),\n             undefined);\n         const {entryPoints} = finder.findEntryPoints();\n         // Note that the `inner` entry-point is not part of the `outer` package\n@@ -272,9 +274,9 @@ runInEachFileSystem(() => {\n         ]);\n \n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, _Abs('/nested_node_modules/node_modules'),\n+            logger, resolver, collector, manifest, _Abs('/nested_node_modules/node_modules'),\n             undefined);\n-        const spy = spyOn(finder, 'walkDirectoryForPackages').and.callThrough();\n+        const spy = spyOn(collector, 'walkDirectoryForPackages').and.callThrough();\n         const {entryPoints} = finder.findEntryPoints();\n         expect(spy.calls.allArgs()).toEqual([\n           [_Abs(basePath)],\n@@ -295,8 +297,8 @@ runInEachFileSystem(() => {\n         ]);\n \n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, basePath, undefined);\n-        const spy = spyOn(finder, 'walkDirectoryForPackages').and.callThrough();\n+            logger, resolver, collector, manifest, basePath, undefined);\n+        const spy = spyOn(collector, 'walkDirectoryForPackages').and.callThrough();\n         const {entryPoints} = finder.findEntryPoints();\n         expect(spy.calls.allArgs()).toEqual([\n           [_Abs(basePath)],\n@@ -319,8 +321,8 @@ runInEachFileSystem(() => {\n         ]);\n \n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, basePath, undefined);\n-        const spy = spyOn(finder, 'walkDirectoryForPackages').and.callThrough();\n+            logger, resolver, collector, manifest, basePath, undefined);\n+        const spy = spyOn(collector, 'walkDirectoryForPackages').and.callThrough();\n         const {entryPoints} = finder.findEntryPoints();\n         expect(spy.calls.allArgs()).toEqual([\n           [_Abs(basePath)],\n@@ -339,7 +341,7 @@ runInEachFileSystem(() => {\n              ...createPackage(fs.resolve(basePath, 'package/container'), 'entry-point-1'),\n            ]);\n            const finder = new DirectoryWalkerEntryPointFinder(\n-               fs, config, logger, resolver, manifest, basePath, undefined);\n+               logger, resolver, collector, manifest, basePath, undefined);\n            const {entryPoints} = finder.findEntryPoints();\n            expect(dumpEntryPointPaths(basePath, entryPoints)).toEqual([\n              ['package', 'package'],\n@@ -367,8 +369,9 @@ runInEachFileSystem(() => {\n         const srcHost = new EsmDependencyHost(fs, new ModuleResolver(fs, pathMappings));\n         const dtsHost = new DtsDependencyHost(fs, pathMappings);\n         resolver = new DependencyResolver(fs, logger, config, {esm2015: srcHost}, dtsHost);\n+        collector = new EntryPointCollector(fs, config, logger, resolver);\n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, basePath, pathMappings);\n+            logger, resolver, collector, manifest, basePath, pathMappings);\n         const {entryPoints} = finder.findEntryPoints();\n         expect(dumpEntryPointPaths(basePath, entryPoints)).toEqual([\n           ['pkg1', 'pkg1'],\n@@ -396,7 +399,7 @@ runInEachFileSystem(() => {\n         const dtsHost = new DtsDependencyHost(fs, pathMappings);\n         resolver = new DependencyResolver(fs, logger, config, {esm2015: srcHost}, dtsHost);\n         const finder = new DirectoryWalkerEntryPointFinder(\n-            fs, config, logger, resolver, manifest, basePath, pathMappings);\n+            logger, resolver, collector, manifest, basePath, pathMappings);\n         const {entryPoints} = finder.findEntryPoints();\n         expect(dumpEntryPointPaths(basePath, entryPoints)).toEqual([\n           ['test', 'test'],"
        },
        {
            "sha": "d48d7cf7035f36e5862a4abc23e73d5f2ee25794",
            "filename": "packages/compiler-cli/ngcc/test/entry_point_finder/program_based_entry_point_finder_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fentry_point_finder%2Fprogram_based_entry_point_finder_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9318e23e644e102126af01ee576957f1e1ce32f6/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fentry_point_finder%2Fprogram_based_entry_point_finder_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fentry_point_finder%2Fprogram_based_entry_point_finder_spec.ts?ref=9318e23e644e102126af01ee576957f1e1ce32f6",
            "patch": "@@ -15,6 +15,7 @@ import {DependencyResolver} from '../../src/dependencies/dependency_resolver';\n import {DtsDependencyHost} from '../../src/dependencies/dts_dependency_host';\n import {EsmDependencyHost} from '../../src/dependencies/esm_dependency_host';\n import {ModuleResolver} from '../../src/dependencies/module_resolver';\n+import {EntryPointCollector} from '../../src/entry_point_finder/entry_point_collector';\n import {ProgramBasedEntryPointFinder} from '../../src/entry_point_finder/program_based_entry_point_finder';\n import {NgccConfiguration} from '../../src/packages/configuration';\n import {EntryPoint} from '../../src/packages/entry_point';\n@@ -68,9 +69,10 @@ runInEachFileSystem(() => {\n         const dtsHost = new DtsDependencyHost(fs);\n         const config = new NgccConfiguration(fs, projectPath);\n         const resolver = new DependencyResolver(fs, logger, config, {esm2015: srcHost}, dtsHost);\n+        const collector = new EntryPointCollector(fs, config, logger, resolver);\n         const manifest = new EntryPointManifest(fs, config, logger);\n         return new ProgramBasedEntryPointFinder(\n-            fs, config, logger, resolver, basePath, tsConfig, projectPath);\n+            fs, config, logger, resolver, collector, manifest, basePath, tsConfig, projectPath);\n       }\n \n       function createProgram(projectPath: AbsoluteFsPath): TestFile[] {"
        }
    ],
    "stats": {
        "total": 828,
        "additions": 497,
        "deletions": 331
    }
}