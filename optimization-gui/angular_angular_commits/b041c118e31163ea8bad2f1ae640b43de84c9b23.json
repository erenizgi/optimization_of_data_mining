{
    "author": "devversion",
    "message": "refactor(dev-infra): expose version for determined release trains (#38656)\n\nPreviously, the logic for determing the active release trains did not\nreturn the resolved version of a release train. With the publish script\nbeing created, we need this information and can just pass it through,\nso that we do not need to fetch and parse the package.json of given\nbranches multiple times.\n\nPR Close #38656",
    "sha": "b041c118e31163ea8bad2f1ae640b43de84c9b23",
    "files": [
        {
            "sha": "8cab89bc8fd366eaf2b117018390a2dfd0514523",
            "filename": "dev-infra/pr/merge/defaults/branches.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 29,
            "changes": 59,
            "blob_url": "https://github.com/angular/angular/blob/b041c118e31163ea8bad2f1ae640b43de84c9b23/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Fbranches.ts",
            "raw_url": "https://github.com/angular/angular/raw/b041c118e31163ea8bad2f1ae640b43de84c9b23/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Fbranches.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Fbranches.ts?ref=b041c118e31163ea8bad2f1ae640b43de84c9b23",
            "patch": "@@ -17,13 +17,6 @@ export interface GithubRepo {\n   owner: string;\n   /** Name of the repository. */\n   repo: string;\n-  /**\n-   * NPM package representing this repository. Angular repositories usually contain\n-   * multiple packages in a monorepo scheme, but packages commonly are released with\n-   * the same versions. This means that a single package can be used for querying\n-   * NPM about previously published versions (e.g. to determine active LTS versions).\n-   * */\n-  npmPackageName: string;\n }\n \n /** Type describing a version-branch. */\n@@ -38,6 +31,14 @@ export interface VersionBranch {\n   parsed: semver.SemVer;\n }\n \n+/** Type describing a release-train. */\n+export interface ReleaseTrain {\n+  /** Name of the branch for this release-train. */\n+  branchName: string;\n+  /** Current latest version for this release train. */\n+  version: semver.SemVer;\n+}\n+\n /** Branch name for the `next` branch. */\n export const nextBranchName = 'master';\n \n@@ -51,13 +52,10 @@ const releaseTrainBranchNameRegex = /(\\d+)\\.(\\d+)\\.x/;\n  */\n export async function fetchActiveReleaseTrainBranches(\n     repo: GithubRepo, nextVersion: semver.SemVer): Promise<{\n-  /**\n-   * Name of the currently active release-candidate branch. Null if no\n-   * feature-freeze/release-candidate is currently active.\n-   */\n-  releaseCandidateBranch: string | null,\n-  /** Name of the latest non-prerelease version branch (i.e. the patch branch). */\n-  latestVersionBranch: string\n+  /** Release-train currently in active release-candidate/feature-freeze phase. */\n+  releaseCandidate: ReleaseTrain | null,\n+  /** Latest non-prerelease release train (i.e. for the patch branch). */\n+  latest: ReleaseTrain\n }> {\n   const majorVersionsToConsider: number[] = [];\n   let expectedReleaseCandidateMajor: number;\n@@ -90,16 +88,16 @@ export async function fetchActiveReleaseTrainBranches(\n   // Collect all version-branches that should be considered for the latest version-branch,\n   // or the feature-freeze/release-candidate.\n   const branches = (await getBranchesForMajorVersions(repo, majorVersionsToConsider));\n-  const {latestVersionBranch, releaseCandidateBranch} =\n-      await findActiveVersionBranches(repo, nextVersion, branches, expectedReleaseCandidateMajor);\n+  const {latest, releaseCandidate} = await findActiveReleaseTrainsFromVersionBranches(\n+      repo, nextVersion, branches, expectedReleaseCandidateMajor);\n \n-  if (latestVersionBranch === null) {\n+  if (latest === null) {\n     throw Error(\n         `Unable to determine the latest release-train. The following branches ` +\n-        `have been considered: [${branches.join(', ')}]`);\n+        `have been considered: [${branches.map(b => b.name).join(', ')}]`);\n   }\n \n-  return {releaseCandidateBranch, latestVersionBranch};\n+  return {releaseCandidate, latest};\n }\n \n /** Gets the version of a given branch by reading the `package.json` upstream. */\n@@ -159,19 +157,20 @@ export async function getBranchesForMajorVersions(\n   return branches.sort((a, b) => semver.rcompare(a.parsed, b.parsed));\n }\n \n-export async function findActiveVersionBranches(\n+/** Finds the currently active release trains from the specified version branches. */\n+export async function findActiveReleaseTrainsFromVersionBranches(\n     repo: GithubRepo, nextVersion: semver.SemVer, branches: VersionBranch[],\n     expectedReleaseCandidateMajor: number): Promise<{\n-  latestVersionBranch: string | null,\n-  releaseCandidateBranch: string | null,\n+  latest: ReleaseTrain | null,\n+  releaseCandidate: ReleaseTrain | null,\n }> {\n   // Version representing the release-train currently in the next phase. Note that we ignore\n   // patch and pre-release segments in order to be able to compare the next release train to\n   // other release trains from version branches (which follow the `N.N.x` pattern).\n   const nextReleaseTrainVersion = semver.parse(`${nextVersion.major}.${nextVersion.minor}.0`)!;\n \n-  let latestVersionBranch: string|null = null;\n-  let releaseCandidateBranch: string|null = null;\n+  let latest: ReleaseTrain|null = null;\n+  let releaseCandidate: ReleaseTrain|null = null;\n \n   // Iterate through the captured branches and find the latest non-prerelease branch and a\n   // potential release candidate branch. From the collected branches we iterate descending\n@@ -200,24 +199,26 @@ export async function findActiveVersionBranches(\n     }\n \n     const version = await getVersionOfBranch(repo, name);\n+    const releaseTrain: ReleaseTrain = {branchName: name, version};\n     const isPrerelease = version.prerelease[0] === 'rc' || version.prerelease[0] === 'next';\n+\n     if (isPrerelease) {\n-      if (releaseCandidateBranch !== null) {\n+      if (releaseCandidate !== null) {\n         throw Error(\n             `Unable to determine latest release-train. Found two consecutive ` +\n             `branches in feature-freeze/release-candidate phase. Did not expect both \"${name}\" ` +\n-            `and \"${releaseCandidateBranch}\" to be in feature-freeze/release-candidate mode.`);\n+            `and \"${releaseCandidate.branchName}\" to be in feature-freeze/release-candidate mode.`);\n       } else if (version.major !== expectedReleaseCandidateMajor) {\n         throw Error(\n             `Discovered unexpected old feature-freeze/release-candidate branch. Expected no ` +\n             `version-branch in feature-freeze/release-candidate mode for v${version.major}.`);\n       }\n-      releaseCandidateBranch = name;\n+      releaseCandidate = releaseTrain;\n     } else {\n-      latestVersionBranch = name;\n+      latest = releaseTrain;\n       break;\n     }\n   }\n \n-  return {releaseCandidateBranch, latestVersionBranch};\n+  return {releaseCandidate, latest};\n }"
        },
        {
            "sha": "2ee896336fbd2c71b300a65f00d4baf5ada17a33",
            "filename": "dev-infra/pr/merge/defaults/labels.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 15,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/b041c118e31163ea8bad2f1ae640b43de84c9b23/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Flabels.ts",
            "raw_url": "https://github.com/angular/angular/raw/b041c118e31163ea8bad2f1ae640b43de84c9b23/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Flabels.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Flabels.ts?ref=b041c118e31163ea8bad2f1ae640b43de84c9b23",
            "patch": "@@ -22,11 +22,10 @@ import {assertActiveLtsBranch} from './lts-branch';\n  */\n export async function getDefaultTargetLabelConfiguration(\n     api: GithubClient, github: GithubConfig, npmPackageName: string): Promise<TargetLabel[]> {\n-  const repo: GithubRepo = {owner: github.owner, repo: github.name, api, npmPackageName};\n+  const repo: GithubRepo = {owner: github.owner, repo: github.name, api};\n   const nextVersion = await getVersionOfBranch(repo, nextBranchName);\n   const hasNextMajorTrain = nextVersion.minor === 0;\n-  const {latestVersionBranch, releaseCandidateBranch} =\n-      await fetchActiveReleaseTrainBranches(repo, nextVersion);\n+  const {latest, releaseCandidate} = await fetchActiveReleaseTrainBranches(repo, nextVersion);\n \n   return [\n     {\n@@ -59,15 +58,15 @@ export async function getDefaultTargetLabelConfiguration(\n         // and is also labeled with `target: patch`, then we merge it directly into the\n         // branch without doing any cherry-picking. This is useful if a PR could not be\n         // applied cleanly, and a separate PR for the patch branch has been created.\n-        if (githubTargetBranch === latestVersionBranch) {\n-          return [latestVersionBranch];\n+        if (githubTargetBranch === latest.branchName) {\n+          return [latest.branchName];\n         }\n         // Otherwise, patch changes are always merged into the next and patch branch.\n-        const branches = [nextBranchName, latestVersionBranch];\n+        const branches = [nextBranchName, latest.branchName];\n         // Additionally, if there is a release-candidate/feature-freeze release-train\n         // currently active, also merge the PR into that version-branch.\n-        if (releaseCandidateBranch !== null) {\n-          branches.push(releaseCandidateBranch);\n+        if (releaseCandidate !== null) {\n+          branches.push(releaseCandidate.branchName);\n         }\n         return branches;\n       }\n@@ -77,7 +76,7 @@ export async function getDefaultTargetLabelConfiguration(\n       branches: githubTargetBranch => {\n         // The `target: rc` label cannot be applied if there is no active feature-freeze\n         // or release-candidate release train.\n-        if (releaseCandidateBranch === null) {\n+        if (releaseCandidate === null) {\n           throw new InvalidTargetLabelError(\n               `No active feature-freeze/release-candidate branch. ` +\n               `Unable to merge pull request using \"target: rc\" label.`);\n@@ -86,11 +85,11 @@ export async function getDefaultTargetLabelConfiguration(\n         // directly through the Github UI and has the `target: rc` label applied, merge it\n         // only into the release candidate branch. This is useful if a PR did not apply cleanly\n         // into the release-candidate/feature-freeze branch, and a separate PR has been created.\n-        if (githubTargetBranch === releaseCandidateBranch) {\n-          return [releaseCandidateBranch];\n+        if (githubTargetBranch === releaseCandidate.branchName) {\n+          return [releaseCandidate.branchName];\n         }\n         // Otherwise, merge into the next and active release-candidate/feature-freeze branch.\n-        return [nextBranchName, releaseCandidateBranch];\n+        return [nextBranchName, releaseCandidate.branchName];\n       },\n     },\n     {\n@@ -105,18 +104,18 @@ export async function getDefaultTargetLabelConfiguration(\n               `PR cannot be merged as it does not target a long-term support ` +\n               `branch: \"${githubTargetBranch}\"`);\n         }\n-        if (githubTargetBranch === latestVersionBranch) {\n+        if (githubTargetBranch === latest.branchName) {\n           throw new InvalidTargetBranchError(\n               `PR cannot be merged with \"target: lts\" into patch branch. ` +\n               `Consider changing the label to \"target: patch\" if this is intentional.`);\n         }\n-        if (githubTargetBranch === releaseCandidateBranch && releaseCandidateBranch !== null) {\n+        if (releaseCandidate !== null && githubTargetBranch === releaseCandidate.branchName) {\n           throw new InvalidTargetBranchError(\n               `PR cannot be merged with \"target: lts\" into feature-freeze/release-candidate ` +\n               `branch. Consider changing the label to \"target: rc\" if this is intentional.`);\n         }\n         // Assert that the selected branch is an active LTS branch.\n-        await assertActiveLtsBranch(repo, githubTargetBranch);\n+        await assertActiveLtsBranch(repo, npmPackageName, githubTargetBranch);\n         return [githubTargetBranch];\n       },\n     },"
        },
        {
            "sha": "a259b28b8a2d8e65bf7c6564be5b13944cadf7a3",
            "filename": "dev-infra/pr/merge/defaults/lts-branch.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 4,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/b041c118e31163ea8bad2f1ae640b43de84c9b23/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Flts-branch.ts",
            "raw_url": "https://github.com/angular/angular/raw/b041c118e31163ea8bad2f1ae640b43de84c9b23/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Flts-branch.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Flts-branch.ts?ref=b041c118e31163ea8bad2f1ae640b43de84c9b23",
            "patch": "@@ -28,12 +28,21 @@ const majorActiveTermSupportDuration = 12;\n \n /**\n  * Asserts that the given branch corresponds to an active LTS version-branch that can receive\n- * backported fixes. Throws an error if LTS expired or an invalid branch is selected.\n- */\n-export async function assertActiveLtsBranch(repo: GithubRepo, branchName: string) {\n+ * backport fixes. Throws an error if LTS expired or an invalid branch is selected.\n+ *\n+ * @param repo Github repository for which the given branch exists.\n+ * @param representativeNpmPackage NPM package representing the given repository. Angular\n+ *   repositories usually contain multiple packages in a monorepo scheme, but packages commonly\n+ *   are released with the same versions. This means that a single package can be used for querying\n+ *   NPM about previously published versions (e.g. to determine active LTS versions). The package\n+ *   name is used to check if the given branch is containing an active LTS version.\n+ * @param branchName Branch that is checked to be an active LTS version-branch.\n+ * */\n+export async function assertActiveLtsBranch(\n+    repo: GithubRepo, representativeNpmPackage: string, branchName: string) {\n   const version = await getVersionOfBranch(repo, branchName);\n   const {'dist-tags': distTags, time} =\n-      await (await fetch(`https://registry.npmjs.org/${repo.npmPackageName}`)).json();\n+      await (await fetch(`https://registry.npmjs.org/${representativeNpmPackage}`)).json();\n \n   // LTS versions should be tagged in NPM in the following format: `v{major}-lts`.\n   const ltsVersion = semver.parse(distTags[`v${version.major}-lts`]);"
        }
    ],
    "stats": {
        "total": 105,
        "additions": 57,
        "deletions": 48
    }
}