{
    "author": "atscott",
    "message": "fix(language-service): shorthand syntax with variables (#40239)\n\nThis commit fixes an issue in the ivy native language service\nthat caused the logic that finds a target node given a template\nposition to throw away the results. This happened because the\nsource span of a variable node in the shorthand structural\ndirective syntax (i.e. `*ngIf=`) included the entire binding.\n\nThe result was that we would add the variable node to the path and then\nlater detect that the cursor was outside the key and value spans and\nthrow away the whole result. In general, we do this because we do not\nwant to show information when the cursor is between a key/value\n(`inputA=¦\"123\"`). However, when using the shorthand syntax, we run into\nthe situation where we can match an `AttributeBinding` as well as the\nvaariable in `*ngIf=\"som¦eValue as myLocalVar\"`. This commit updates the\nvisitor to retain enough information in the visit path to throw away\ninvalid targets but keep valid ones if there were multiple results on a\n`t.Element` or `t.Template`.\n\nPR Close #40239",
    "sha": "12cb39c1a415d912233b4ef77685b13d6d7c762a",
    "files": [
        {
            "sha": "eff933a3d4add84c57f7a276dc6122657e30e1b0",
            "filename": "packages/language-service/ivy/template_target.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 18,
            "changes": 51,
            "blob_url": "https://github.com/angular/angular/blob/12cb39c1a415d912233b4ef77685b13d6d7c762a/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "raw_url": "https://github.com/angular/angular/raw/12cb39c1a415d912233b4ef77685b13d6d7c762a/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts?ref=12cb39c1a415d912233b4ef77685b13d6d7c762a",
            "patch": "@@ -6,11 +6,11 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {TmplAstBoundEvent} from '@angular/compiler';\n+import {ParseSpan, TmplAstBoundEvent} from '@angular/compiler';\n import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n \n-import {isTemplateNode, isTemplateNodeWithKeyAndValue, isWithin} from './utils';\n+import {isTemplateNode, isTemplateNodeWithKeyAndValue, isWithin, isWithinKeyValue} from './utils';\n \n /**\n  * Contextual information for a target position within the template.\n@@ -105,6 +105,12 @@ export interface AttributeInValueContext {\n   node: t.TextAttribute|t.BoundAttribute|t.BoundEvent;\n }\n \n+/**\n+ * This special marker is added to the path when the cursor is within the sourceSpan but not the key\n+ * or value span of a node with key/value spans.\n+ */\n+const OUTSIDE_K_V_MARKER = new e.AST(new ParseSpan(-1, -1), new e.AbsoluteSourceSpan(-1, -1));\n+\n /**\n  * Return the template AST node or expression AST node that most accurately\n  * represents the node at the specified cursor `position`.\n@@ -119,20 +125,6 @@ export function getTargetAtPosition(template: t.Node[], position: number): Templ\n   }\n \n   const candidate = path[path.length - 1];\n-  if (isTemplateNodeWithKeyAndValue(candidate)) {\n-    let {keySpan, valueSpan} = candidate;\n-    if (valueSpan === undefined && candidate instanceof TmplAstBoundEvent) {\n-      valueSpan = candidate.handlerSpan;\n-    }\n-    const isWithinKeyValue =\n-        isWithin(position, keySpan) || (valueSpan && isWithin(position, valueSpan));\n-    if (!isWithinKeyValue) {\n-      // If cursor is within source span but not within key span or value span,\n-      // do not return the node.\n-      return null;\n-    }\n-  }\n-\n   // Walk up the result nodes to find the nearest `t.Template` which contains the targeted node.\n   let context: t.Template|null = null;\n   for (let i = path.length - 2; i >= 0; i--) {\n@@ -212,7 +204,22 @@ class TemplateTargetVisitor implements t.Visitor {\n   static visitTemplate(template: t.Node[], position: number): Array<t.Node|e.AST> {\n     const visitor = new TemplateTargetVisitor(position);\n     visitor.visitAll(template);\n-    return visitor.path;\n+    const {path} = visitor;\n+\n+    const strictPath = path.filter(v => v !== OUTSIDE_K_V_MARKER);\n+    const candidate = strictPath[strictPath.length - 1];\n+    const matchedASourceSpanButNotAKvSpan = path.some(v => v === OUTSIDE_K_V_MARKER);\n+    if (matchedASourceSpanButNotAKvSpan &&\n+        (candidate instanceof t.Template || candidate instanceof t.Element)) {\n+      // Template nodes with key and value spans are always defined on a `t.Template` or\n+      // `t.Element`. If we found a node on a template with a `sourceSpan` that includes the cursor,\n+      // it is possible that we are outside the k/v spans (i.e. in-between them). If this is the\n+      // case and we do not have any other candidate matches on the `t.Element` or `t.Template`, we\n+      // want to return no results. Otherwise, the `t.Element`/`t.Template` result is incorrect for\n+      // that cursor position.\n+      return [];\n+    }\n+    return strictPath;\n   }\n \n   // Position must be absolute in the source file.\n@@ -229,7 +236,15 @@ class TemplateTargetVisitor implements t.Visitor {\n       return;\n     }\n     const {start, end} = getSpanIncludingEndTag(node);\n-    if (isWithin(this.position, {start, end})) {\n+    if (!isWithin(this.position, {start, end})) {\n+      return;\n+    }\n+\n+    if (isTemplateNodeWithKeyAndValue(node) && !isWithinKeyValue(this.position, node)) {\n+      // If cursor is within source span but not within key span or value span,\n+      // do not return the node.\n+      this.path.push(OUTSIDE_K_V_MARKER);\n+    } else {\n       this.path.push(node);\n       node.visit(this);\n     }"
        },
        {
            "sha": "047cf508c3325f79bcd61ad957c3362dfa5c2964",
            "filename": "packages/language-service/ivy/test/legacy/template_target_spec.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/12cb39c1a415d912233b4ef77685b13d6d7c762a/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/12cb39c1a415d912233b4ef77685b13d6d7c762a/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts?ref=12cb39c1a415d912233b4ef77685b13d6d7c762a",
            "patch": "@@ -598,6 +598,15 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n+  it('should locate property read next to variable in structural directive syntax', () => {\n+    const {errors, nodes, position} = parse(`<div *ngIf=\"fo¦o as bar\"></div>`);\n+    expect(errors).toBe(null);\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+  });\n+\n   it('should locate text attribute', () => {\n     const {errors, nodes, position} = parse(`<div *ng¦For=\"let item of items\"></div>`);\n     // ngFor is a text attribute because the desugared form is"
        },
        {
            "sha": "7c67840c3cd95217cc8d009dc4ca39d9d5c1ca31",
            "filename": "packages/language-service/ivy/utils.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/12cb39c1a415d912233b4ef77685b13d6d7c762a/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/12cb39c1a415d912233b4ef77685b13d6d7c762a/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Futils.ts?ref=12cb39c1a415d912233b4ef77685b13d6d7c762a",
            "patch": "@@ -5,7 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {AbsoluteSourceSpan, CssSelector, ParseSourceSpan, SelectorMatcher} from '@angular/compiler';\n+import {AbsoluteSourceSpan, CssSelector, ParseSourceSpan, SelectorMatcher, TmplAstBoundEvent} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {isExternalResource} from '@angular/compiler-cli/src/ngtsc/metadata';\n import {DeclarationNode} from '@angular/compiler-cli/src/ngtsc/reflection';\n@@ -54,6 +54,16 @@ export function isTemplateNodeWithKeyAndValue(node: t.Node|e.AST): node is NodeW\n   return isTemplateNode(node) && node.hasOwnProperty('keySpan');\n }\n \n+export function isWithinKeyValue(position: number, node: NodeWithKeyAndValue): boolean {\n+  let {keySpan, valueSpan} = node;\n+  if (valueSpan === undefined && node instanceof TmplAstBoundEvent) {\n+    valueSpan = node.handlerSpan;\n+  }\n+  const isWithinKeyValue =\n+      isWithin(position, keySpan) || !!(valueSpan && isWithin(position, valueSpan));\n+  return isWithinKeyValue;\n+}\n+\n export function isTemplateNode(node: t.Node|e.AST): node is t.Node {\n   // Template node implements the Node interface so we cannot use instanceof.\n   return node.sourceSpan instanceof ParseSourceSpan;"
        }
    ],
    "stats": {
        "total": 72,
        "additions": 53,
        "deletions": 19
    }
}