{
    "author": "mhevery",
    "message": "refactor(core): add human readable `debug` for i18n (#38154)\n\nI18n code breaks up internationalization into opCodes which are then stored\nin arrays. To make it easier to debug the codebase this PR adds `debug`\nproperty to the arrays which presents the data in human readable format.\n\nPR Close #38154",
    "sha": "3821dc5f6c2e63cd08eac5cf4f898d3f8081af94",
    "files": [
        {
            "sha": "52acd55885a7f31d9f5bf61dac4fe0e64890e4e1",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=3821dc5f6c2e63cd08eac5cf4f898d3f8081af94",
            "patch": "@@ -62,7 +62,7 @@\n         \"bundle\": \"TODO(i): we should define ngDevMode to false in Closure, but --define only works in the global scope.\",\n         \"bundle\": \"TODO(i): (FW-2164) TS 3.9 new class shape seems to have broken Closure in big ways. The size went from 169991 to 252338\",\n         \"bundle\": \"TODO(i): after removal of tsickle from ngc-wrapped / ng_package, we had to switch to SIMPLE optimizations which increased the size from 252338 to 1198917, see PR#37221 and PR#37317 for more info\",\n-        \"bundle\": 1209659\n+        \"bundle\": 1212027\n       }\n     }\n   }"
        },
        {
            "sha": "77da44afd2005ae90c98d5bf0df7ef23654a5b7f",
            "filename": "packages/core/src/render3/i18n.ts",
            "status": "modified",
            "additions": 31,
            "deletions": 12,
            "changes": 43,
            "blob_url": "https://github.com/angular/angular/blob/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Fi18n.ts",
            "raw_url": "https://github.com/angular/angular/raw/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Fi18n.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n.ts?ref=3821dc5f6c2e63cd08eac5cf4f898d3f8081af94",
            "patch": "@@ -6,6 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n import '../util/ng_i18n_closure_mode';\n+import '../util/ng_dev_mode';\n \n import {DEFAULT_LOCALE_ID, getPluralCase} from '../i18n/localization';\n import {getTemplateContent, SRCSET_ATTRS, URI_ATTRS, VALID_ATTRS, VALID_ELEMENTS} from '../sanitization/html_sanitizer';\n@@ -16,8 +17,8 @@ import {assertDataInRange, assertDefined, assertEqual} from '../util/assert';\n \n import {bindingUpdated} from './bindings';\n import {attachPatchData} from './context_discovery';\n+import {i18nMutateOpCodesToString, i18nUpdateOpCodesToString} from './i18n_debug';\n import {setDelayProjection} from './instructions/all';\n-import {attachI18nOpCodesDebug} from './instructions/lview_debug';\n import {allocExpando, elementAttributeInternal, elementPropertyInternal, getOrCreateTNode, setInputsForProperty, setNgReflectProperties, textBindingInternal} from './instructions/shared';\n import {LContainer, NATIVE} from './interfaces/container';\n import {getDocument} from './interfaces/document';\n@@ -29,6 +30,7 @@ import {isLContainer} from './interfaces/type_checks';\n import {HEADER_OFFSET, LView, RENDERER, T_HOST, TVIEW, TView} from './interfaces/view';\n import {appendChild, applyProjection, createTextNode, nativeRemoveNode} from './node_manipulation';\n import {getBindingIndex, getIsParent, getLView, getPreviousOrParentTNode, getTView, nextBindingIndex, setIsNotParent, setPreviousOrParentTNode} from './state';\n+import {attachDebugGetter} from './util/debug_utils';\n import {renderStringify} from './util/misc_utils';\n import {getNativeByIndex, getNativeByTNode, getTNode, load} from './util/view_utils';\n \n@@ -267,6 +269,9 @@ function generateBindingUpdateOpCodes(\n     str: string, destinationNode: number, attrName?: string,\n     sanitizeFn: SanitizerFn|null = null): I18nUpdateOpCodes {\n   const updateOpCodes: I18nUpdateOpCodes = [null, null];  // Alloc space for mask and size\n+  if (ngDevMode) {\n+    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n+  }\n   const textParts = str.split(BINDING_REGEXP);\n   let mask = 0;\n \n@@ -395,6 +400,9 @@ function i18nStartFirstPass(\n   let parentIndexPointer = 0;\n   parentIndexStack[parentIndexPointer] = parentIndex;\n   const createOpCodes: I18nMutateOpCodes = [];\n+  if (ngDevMode) {\n+    attachDebugGetter(createOpCodes, i18nMutateOpCodesToString);\n+  }\n   // If the previous node wasn't the direct parent then we have a translation without top level\n   // element and we need to keep a reference of the previous element if there is one. We should also\n   // keep track whether an element was a parent node or not, so that the logic that consumes\n@@ -411,6 +419,9 @@ function i18nStartFirstPass(\n     createOpCodes.push(previousTNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Select);\n   }\n   const updateOpCodes: I18nUpdateOpCodes = [];\n+  if (ngDevMode) {\n+    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n+  }\n   const icuExpressions: TIcu[] = [];\n \n   if (message === '' && isRootTemplateMessage(subTemplateIndex)) {\n@@ -507,10 +518,6 @@ function i18nStartFirstPass(\n     allocExpando(tView, lView, i18nVarsCount);\n   }\n \n-  ngDevMode &&\n-      attachI18nOpCodesDebug(\n-          createOpCodes, updateOpCodes, icuExpressions.length ? icuExpressions : null, lView);\n-\n   // NOTE: local var needed to properly assert the type of `TI18n`.\n   const tI18n: TI18n = {\n     vars: i18nVarsCount,\n@@ -780,7 +787,7 @@ function readCreateOpCodes(\n       visitedNodes.push(textNodeIndex);\n       setIsNotParent();\n     } else if (typeof opCode == 'number') {\n-      switch (opCode & I18nMutateOpCode.MASK_OPCODE) {\n+      switch (opCode & I18nMutateOpCode.MASK_INSTRUCTION) {\n         case I18nMutateOpCode.AppendChild:\n           const destinationNodeIndex = opCode >>> I18nMutateOpCode.SHIFT_PARENT;\n           let destinationTNode: TNode;\n@@ -799,9 +806,10 @@ function readCreateOpCodes(\n               appendI18nNode(tView, currentTNode!, destinationTNode, previousTNode, lView);\n           break;\n         case I18nMutateOpCode.Select:\n-          // Negative indicies indicate that a given TNode is a sibling node, not a parent node\n+          // Negative indices indicate that a given TNode is a sibling node, not a parent node\n           // (see `i18nStartFirstPass` for additional information).\n           const isParent = opCode >= 0;\n+          // FIXME(misko): This SHIFT_REF looks suspect as it does not have mask.\n           const nodeIndex = (isParent ? opCode : ~opCode) >>> I18nMutateOpCode.SHIFT_REF;\n           visitedNodes.push(nodeIndex);\n           previousTNode = currentTNode;\n@@ -890,7 +898,6 @@ function readUpdateOpCodes(\n           value += opCode;\n         } else if (typeof opCode == 'number') {\n           if (opCode < 0) {\n-            // It's a binding index whose value is negative\n             value += renderStringify(lView[bindingsStartIndex - opCode]);\n           } else {\n             const nodeIndex = opCode >>> I18nUpdateOpCode.SHIFT_REF;\n@@ -909,6 +916,7 @@ function readUpdateOpCodes(\n                 textBindingInternal(lView, nodeIndex, value);\n                 break;\n               case I18nUpdateOpCode.IcuSwitch:\n+                // FIXME(misko): Pull to a new function `icuSwitchCase`\n                 tIcuIndex = updateOpCodes[++j] as number;\n                 tIcu = icus![tIcuIndex];\n                 icuTNode = getTNode(tView, nodeIndex) as TIcuContainerNode;\n@@ -917,7 +925,7 @@ function readUpdateOpCodes(\n                   const removeCodes = tIcu.remove[icuTNode.activeCaseIndex];\n                   for (let k = 0; k < removeCodes.length; k++) {\n                     const removeOpCode = removeCodes[k] as number;\n-                    switch (removeOpCode & I18nMutateOpCode.MASK_OPCODE) {\n+                    switch (removeOpCode & I18nMutateOpCode.MASK_INSTRUCTION) {\n                       case I18nMutateOpCode.Remove:\n                         const nodeIndex = removeOpCode >>> I18nMutateOpCode.SHIFT_REF;\n                         // Remove DOM element, but do *not* mark TNode as detached, since we are\n@@ -951,6 +959,7 @@ function readUpdateOpCodes(\n                 }\n                 break;\n               case I18nUpdateOpCode.IcuUpdate:\n+                // FIXME(misko): Pull to a new function `icuUpdateCase`\n                 tIcuIndex = updateOpCodes[++j] as number;\n                 tIcu = icus![tIcuIndex];\n                 icuTNode = getTNode(tView, nodeIndex) as TIcuContainerNode;\n@@ -1044,6 +1053,9 @@ function i18nAttributesFirstPass(lView: LView, tView: TView, index: number, valu\n   const previousElement = getPreviousOrParentTNode();\n   const previousElementIndex = previousElement.index - HEADER_OFFSET;\n   const updateOpCodes: I18nUpdateOpCodes = [];\n+  if (ngDevMode) {\n+    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n+  }\n   for (let i = 0; i < values.length; i += 2) {\n     const attrName = values[i];\n     const message = values[i + 1];\n@@ -1180,9 +1192,9 @@ function getCaseIndex(icuExpression: TIcu, bindingValue: string): number {\n function icuStart(\n     tIcus: TIcu[], icuExpression: IcuExpression, startIndex: number,\n     expandoStartIndex: number): void {\n-  const createCodes = [];\n-  const removeCodes = [];\n-  const updateCodes = [];\n+  const createCodes: I18nMutateOpCodes[] = [];\n+  const removeCodes: I18nMutateOpCodes[] = [];\n+  const updateCodes: I18nUpdateOpCodes[] = [];\n   const vars = [];\n   const childIcus: number[][] = [];\n   for (let i = 0; i < icuExpression.values.length; i++) {\n@@ -1240,6 +1252,11 @@ function parseIcuCase(\n   }\n   const wrapper = getTemplateContent(inertBodyElement!) as Element || inertBodyElement;\n   const opCodes: IcuCase = {vars: 0, childIcus: [], create: [], remove: [], update: []};\n+  if (ngDevMode) {\n+    attachDebugGetter(opCodes.create, i18nMutateOpCodesToString);\n+    attachDebugGetter(opCodes.remove, i18nMutateOpCodesToString);\n+    attachDebugGetter(opCodes.update, i18nUpdateOpCodesToString);\n+  }\n   parseNodes(wrapper.firstChild, opCodes, parentIndex, nestedIcus, tIcus, expandoStartIndex);\n   return opCodes;\n }\n@@ -1364,13 +1381,15 @@ function parseNodes(\n           3,                                 // skip 3 opCodes if not changed\n           -1 - nestedIcu.mainBinding,\n           nestedIcuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch,\n+          // FIXME(misko): Index should be part of the opcode\n           nestTIcuIndex,\n           mask,  // mask of all the bindings of this ICU expression\n           2,     // skip 2 opCodes if not changed\n           nestedIcuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate,\n           nestTIcuIndex);\n       icuCase.remove.push(\n           nestTIcuIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.RemoveNestedIcu,\n+          // FIXME(misko): Index should be part of the opcode\n           nestedIcuNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove);\n     }\n   }"
        },
        {
            "sha": "da0cbe7fcbf387621df37e0b314533f3fb3d4895",
            "filename": "packages/core/src/render3/i18n_debug.ts",
            "status": "added",
            "additions": 187,
            "deletions": 0,
            "changes": 187,
            "blob_url": "https://github.com/angular/angular/blob/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Fi18n_debug.ts",
            "raw_url": "https://github.com/angular/angular/raw/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Fi18n_debug.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n_debug.ts?ref=3821dc5f6c2e63cd08eac5cf4f898d3f8081af94",
            "patch": "@@ -0,0 +1,187 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {assertNumber, assertString} from '../util/assert';\n+\n+import {COMMENT_MARKER, ELEMENT_MARKER, getInstructionFromI18nMutateOpCode, getParentFromI18nMutateOpCode, getRefFromI18nMutateOpCode, I18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes} from './interfaces/i18n';\n+\n+/**\n+ * Converts `I18nUpdateOpCodes` array into a human readable format.\n+ *\n+ * This function is attached to the `I18nUpdateOpCodes.debug` property if `ngDevMode` is enabled.\n+ * This function provides a human readable view of the opcodes. This is useful when debugging the\n+ * application as well as writing more readable tests.\n+ *\n+ * @param this `I18nUpdateOpCodes` if attached as a method.\n+ * @param opcodes `I18nUpdateOpCodes` if invoked as a function.\n+ */\n+export function i18nUpdateOpCodesToString(\n+    this: I18nUpdateOpCodes|void, opcodes?: I18nUpdateOpCodes): string[] {\n+  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n+  let lines: string[] = [];\n+\n+  function consumeOpCode(value: number): string {\n+    const ref = value >>> I18nUpdateOpCode.SHIFT_REF;\n+    const opCode = value & I18nUpdateOpCode.MASK_OPCODE;\n+    switch (opCode) {\n+      case I18nUpdateOpCode.Text:\n+        return `(lView[${ref}] as Text).textContent = $$$`;\n+      case I18nUpdateOpCode.Attr:\n+        const attrName = parser.consumeString();\n+        const sanitizationFn = parser.consumeFunction();\n+        const value = sanitizationFn ? `(${sanitizationFn})($$$)` : '$$$';\n+        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value})`;\n+      case I18nUpdateOpCode.IcuSwitch:\n+        return `icuSwitchCase(lView[${ref}] as Comment, ${parser.consumeNumber()}, $$$)`;\n+      case I18nUpdateOpCode.IcuUpdate:\n+        return `icuUpdateCase(lView[${ref}] as Comment, ${parser.consumeNumber()})`;\n+    }\n+    throw new Error('unexpected OpCode');\n+  }\n+\n+\n+  while (parser.hasMore()) {\n+    let mask = parser.consumeNumber();\n+    let size = parser.consumeNumber();\n+    const end = parser.i + size;\n+    const statements: string[] = [];\n+    let statement = '';\n+    while (parser.i < end) {\n+      let value = parser.consumeNumberOrString();\n+      if (typeof value === 'string') {\n+        statement += value;\n+      } else if (value < 0) {\n+        // Negative numbers are ref indexes\n+        statement += '${lView[' + (0 - value) + ']}';\n+      } else {\n+        // Positive numbers are operations.\n+        const opCodeText = consumeOpCode(value);\n+        statements.push(opCodeText.replace('$$$', '`' + statement + '`') + ';');\n+        statement = '';\n+      }\n+    }\n+    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(' ')} }`);\n+  }\n+  return lines;\n+}\n+\n+/**\n+ * Converts `I18nMutableOpCodes` array into a human readable format.\n+ *\n+ * This function is attached to the `I18nMutableOpCodes.debug` if `ngDevMode` is enabled. This\n+ * function provides a human readable view of the opcodes. This is useful when debugging the\n+ * application as well as writing more readable tests.\n+ *\n+ * @param this `I18nMutableOpCodes` if attached as a method.\n+ * @param opcodes `I18nMutableOpCodes` if invoked as a function.\n+ */\n+export function i18nMutateOpCodesToString(\n+    this: I18nMutateOpCodes|void, opcodes?: I18nMutateOpCodes): string[] {\n+  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n+  let lines: string[] = [];\n+\n+  function consumeOpCode(opCode: number): string {\n+    const parent = getParentFromI18nMutateOpCode(opCode);\n+    const ref = getRefFromI18nMutateOpCode(opCode);\n+    switch (getInstructionFromI18nMutateOpCode(opCode)) {\n+      case I18nMutateOpCode.Select:\n+        lastRef = ref;\n+        return '';\n+      case I18nMutateOpCode.AppendChild:\n+        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;\n+      case I18nMutateOpCode.Remove:\n+        return `(lView[${parent}] as Element).remove(lView[${ref}])`;\n+      case I18nMutateOpCode.Attr:\n+        return `(lView[${ref}] as Element).setAttribute(\"${parser.consumeString()}\", \"${\n+            parser.consumeString()}\")`;\n+      case I18nMutateOpCode.ElementEnd:\n+        return `setPreviousOrParentTNode(tView.data[${ref}] as TNode)`;\n+      case I18nMutateOpCode.RemoveNestedIcu:\n+        // FIXME(misko): refactor to have a real method in i18n.ts.\n+        return `removeNestedICU(${ref})`;\n+    }\n+    throw new Error('Unexpected OpCode');\n+  }\n+\n+  let lastRef = -1;\n+  while (parser.hasMore()) {\n+    let value = parser.consumeNumberStringOrMarker();\n+    if (value === COMMENT_MARKER) {\n+      const text = parser.consumeString();\n+      lastRef = parser.consumeNumber();\n+      lines.push(`lView[${lastRef}] = document.createComment(\"${text}\")`);\n+    } else if (value === ELEMENT_MARKER) {\n+      const text = parser.consumeString();\n+      lastRef = parser.consumeNumber();\n+      lines.push(`lView[${lastRef}] = document.createElement(\"${text}\")`);\n+    } else if (typeof value === 'string') {\n+      lastRef = parser.consumeNumber();\n+      lines.push(`lView[${lastRef}] = document.createTextNode(\"${value}\")`);\n+    } else if (typeof value === 'number') {\n+      const line = consumeOpCode(value);\n+      line && lines.push(line);\n+    } else {\n+      throw new Error('Unexpected value');\n+    }\n+  }\n+\n+  return lines;\n+}\n+\n+\n+class OpCodeParser {\n+  i: number = 0;\n+  codes: any[];\n+\n+  constructor(codes: any[]) {\n+    this.codes = codes;\n+  }\n+\n+  hasMore() {\n+    return this.i < this.codes.length;\n+  }\n+\n+  consumeNumber(): number {\n+    let value = this.codes[this.i++];\n+    assertNumber(value, 'expecting number in OpCode');\n+    return value;\n+  }\n+\n+  consumeString(): string {\n+    let value = this.codes[this.i++];\n+    assertString(value, 'expecting string in OpCode');\n+    return value;\n+  }\n+\n+  consumeFunction(): Function|null {\n+    let value = this.codes[this.i++];\n+    if (value === null || typeof value === 'function') {\n+      return value;\n+    }\n+    throw new Error('expecting function in OpCode');\n+  }\n+\n+  consumeNumberOrString(): number|string {\n+    let value = this.codes[this.i++];\n+    if (typeof value === 'string') {\n+      return value;\n+    }\n+    assertNumber(value, 'expecting number or string in OpCode');\n+    return value;\n+  }\n+\n+  consumeNumberStringOrMarker(): number|string|COMMENT_MARKER|ELEMENT_MARKER {\n+    let value = this.codes[this.i++];\n+    if (typeof value === 'string' || typeof value === 'number' || value == COMMENT_MARKER ||\n+        value == ELEMENT_MARKER) {\n+      return value;\n+    }\n+    assertNumber(value, 'expecting number, string, COMMENT_MARKER or ELEMENT_MARKER in OpCode');\n+    return value;\n+  }\n+}"
        },
        {
            "sha": "50c592d28c0bb499035b7aad64866c411f185bde",
            "filename": "packages/core/src/render3/instructions/lview_debug.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 203,
            "changes": 203,
            "blob_url": "https://github.com/angular/angular/blob/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Flview_debug.ts",
            "raw_url": "https://github.com/angular/angular/raw/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Flview_debug.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Flview_debug.ts?ref=3821dc5f6c2e63cd08eac5cf4f898d3f8081af94",
            "patch": "@@ -550,206 +550,3 @@ export function readLViewValue(value: any): LView|null {\n   }\n   return null;\n }\n-\n-export class I18NDebugItem {\n-  [key: string]: any;\n-\n-  get tNode() {\n-    return getTNode(this._lView[TVIEW], this.nodeIndex);\n-  }\n-\n-  constructor(\n-      public __raw_opCode: any, private _lView: LView, public nodeIndex: number,\n-      public type: string) {}\n-}\n-\n-/**\n- * Turns a list of \"Create\" & \"Update\" OpCodes into a human-readable list of operations for\n- * debugging purposes.\n- * @param mutateOpCodes mutation opCodes to read\n- * @param updateOpCodes update opCodes to read\n- * @param icus list of ICU expressions\n- * @param lView The view the opCodes are acting on\n- */\n-export function attachI18nOpCodesDebug(\n-    mutateOpCodes: I18nMutateOpCodes, updateOpCodes: I18nUpdateOpCodes, icus: TIcu[]|null,\n-    lView: LView) {\n-  attachDebugObject(mutateOpCodes, new I18nMutateOpCodesDebug(mutateOpCodes, lView));\n-  attachDebugObject(updateOpCodes, new I18nUpdateOpCodesDebug(updateOpCodes, icus, lView));\n-\n-  if (icus) {\n-    icus.forEach(icu => {\n-      icu.create.forEach(icuCase => {\n-        attachDebugObject(icuCase, new I18nMutateOpCodesDebug(icuCase, lView));\n-      });\n-      icu.update.forEach(icuCase => {\n-        attachDebugObject(icuCase, new I18nUpdateOpCodesDebug(icuCase, icus, lView));\n-      });\n-    });\n-  }\n-}\n-\n-export class I18nMutateOpCodesDebug implements I18nOpCodesDebug {\n-  constructor(private readonly __raw_opCodes: I18nMutateOpCodes, private readonly __lView: LView) {}\n-\n-  /**\n-   * A list of operation information about how the OpCodes will act on the view.\n-   */\n-  get operations() {\n-    const {__lView, __raw_opCodes} = this;\n-    const results: any[] = [];\n-\n-    for (let i = 0; i < __raw_opCodes.length; i++) {\n-      const opCode = __raw_opCodes[i];\n-      let result: any;\n-      if (typeof opCode === 'string') {\n-        result = {\n-          __raw_opCode: opCode,\n-          type: 'Create Text Node',\n-          nodeIndex: __raw_opCodes[++i],\n-          text: opCode,\n-        };\n-      }\n-\n-      if (typeof opCode === 'number') {\n-        switch (opCode & I18nMutateOpCode.MASK_OPCODE) {\n-          case I18nMutateOpCode.AppendChild:\n-            const destinationNodeIndex = opCode >>> I18nMutateOpCode.SHIFT_PARENT;\n-            result = new I18NDebugItem(opCode, __lView, destinationNodeIndex, 'AppendChild');\n-            break;\n-          case I18nMutateOpCode.Select:\n-            const nodeIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n-            result = new I18NDebugItem(opCode, __lView, nodeIndex, 'Select');\n-            break;\n-          case I18nMutateOpCode.ElementEnd:\n-            let elementIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n-            result = new I18NDebugItem(opCode, __lView, elementIndex, 'ElementEnd');\n-            break;\n-          case I18nMutateOpCode.Attr:\n-            elementIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n-            result = new I18NDebugItem(opCode, __lView, elementIndex, 'Attr');\n-            result['attrName'] = __raw_opCodes[++i];\n-            result['attrValue'] = __raw_opCodes[++i];\n-            break;\n-        }\n-      }\n-\n-      if (!result) {\n-        switch (opCode) {\n-          case COMMENT_MARKER:\n-            result = {\n-              __raw_opCode: opCode,\n-              type: 'COMMENT_MARKER',\n-              commentValue: __raw_opCodes[++i],\n-              nodeIndex: __raw_opCodes[++i],\n-            };\n-            break;\n-          case ELEMENT_MARKER:\n-            result = {\n-              __raw_opCode: opCode,\n-              type: 'ELEMENT_MARKER',\n-            };\n-            break;\n-        }\n-      }\n-\n-      if (!result) {\n-        result = {\n-          __raw_opCode: opCode,\n-          type: 'Unknown Op Code',\n-          code: opCode,\n-        };\n-      }\n-\n-      results.push(result);\n-    }\n-\n-    return results;\n-  }\n-}\n-\n-export class I18nUpdateOpCodesDebug implements I18nOpCodesDebug {\n-  constructor(\n-      private readonly __raw_opCodes: I18nUpdateOpCodes, private readonly icus: TIcu[]|null,\n-      private readonly __lView: LView) {}\n-\n-  /**\n-   * A list of operation information about how the OpCodes will act on the view.\n-   */\n-  get operations() {\n-    const {__lView, __raw_opCodes, icus} = this;\n-    const results: any[] = [];\n-\n-    for (let i = 0; i < __raw_opCodes.length; i++) {\n-      // bit code to check if we should apply the next update\n-      const checkBit = __raw_opCodes[i] as number;\n-      // Number of opCodes to skip until next set of update codes\n-      const skipCodes = __raw_opCodes[++i] as number;\n-      let value = '';\n-      for (let j = i + 1; j <= (i + skipCodes); j++) {\n-        const opCode = __raw_opCodes[j];\n-        if (typeof opCode === 'string') {\n-          value += opCode;\n-        } else if (typeof opCode == 'number') {\n-          if (opCode < 0) {\n-            // It's a binding index whose value is negative\n-            // We cannot know the value of the binding so we only show the index\n-            value += `�${- opCode - 1}�`;\n-          } else {\n-            const nodeIndex = opCode >>> I18nUpdateOpCode.SHIFT_REF;\n-            let tIcuIndex: number;\n-            let tIcu: TIcu;\n-            switch (opCode & I18nUpdateOpCode.MASK_OPCODE) {\n-              case I18nUpdateOpCode.Attr:\n-                const attrName = __raw_opCodes[++j] as string;\n-                const sanitizeFn = __raw_opCodes[++j];\n-                results.push({\n-                  __raw_opCode: opCode,\n-                  checkBit,\n-                  type: 'Attr',\n-                  attrValue: value,\n-                  attrName,\n-                  sanitizeFn,\n-                });\n-                break;\n-              case I18nUpdateOpCode.Text:\n-                results.push({\n-                  __raw_opCode: opCode,\n-                  checkBit,\n-                  type: 'Text',\n-                  nodeIndex,\n-                  text: value,\n-                });\n-                break;\n-              case I18nUpdateOpCode.IcuSwitch:\n-                tIcuIndex = __raw_opCodes[++j] as number;\n-                tIcu = icus![tIcuIndex];\n-                let result = new I18NDebugItem(opCode, __lView, nodeIndex, 'IcuSwitch');\n-                result['tIcuIndex'] = tIcuIndex;\n-                result['checkBit'] = checkBit;\n-                result['mainBinding'] = value;\n-                result['tIcu'] = tIcu;\n-                results.push(result);\n-                break;\n-              case I18nUpdateOpCode.IcuUpdate:\n-                tIcuIndex = __raw_opCodes[++j] as number;\n-                tIcu = icus![tIcuIndex];\n-                result = new I18NDebugItem(opCode, __lView, nodeIndex, 'IcuUpdate');\n-                result['tIcuIndex'] = tIcuIndex;\n-                result['checkBit'] = checkBit;\n-                result['tIcu'] = tIcu;\n-                results.push(result);\n-                break;\n-            }\n-          }\n-        }\n-      }\n-      i += skipCodes;\n-    }\n-    return results;\n-  }\n-}\n-\n-export interface I18nOpCodesDebug {\n-  operations: any[];\n-}"
        },
        {
            "sha": "e648853793918103f3d1a754dd34fa2c08492e9e",
            "filename": "packages/core/src/render3/instructions/shared.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fshared.ts",
            "raw_url": "https://github.com/angular/angular/raw/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fshared.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fshared.ts?ref=3821dc5f6c2e63cd08eac5cf4f898d3f8081af94",
            "patch": "@@ -236,6 +236,13 @@ export function getOrCreateTNode(\n   const tNode = tView.data[adjustedIndex] as TNode ||\n       createTNodeAtIndex(tView, tHostNode, adjustedIndex, type, name, attrs);\n   setPreviousOrParentTNode(tNode, true);\n+  if (ngDevMode) {\n+    // For performance reasons it is important that the tNode retains the same shape during runtime.\n+    // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n+    // prevent class transitions.\n+    // FIXME(misko): re-enable this once i18n code is compliant with this.\n+    // Object.seal(tNode);\n+  }\n   return tNode as TElementNode & TViewNode & TContainerNode & TElementContainerNode &\n       TProjectionNode & TIcuContainerNode;\n }"
        },
        {
            "sha": "f379ed9125ae740dd7db23b41eb47af52eec60aa",
            "filename": "packages/core/src/render3/interfaces/i18n.ts",
            "status": "modified",
            "additions": 87,
            "deletions": 60,
            "changes": 147,
            "blob_url": "https://github.com/angular/angular/blob/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fi18n.ts",
            "raw_url": "https://github.com/angular/angular/raw/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fi18n.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fi18n.ts?ref=3821dc5f6c2e63cd08eac5cf4f898d3f8081af94",
            "patch": "@@ -6,18 +6,31 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+import {SanitizerFn} from './sanitization';\n+\n /**\n  * `I18nMutateOpCode` defines OpCodes for `I18nMutateOpCodes` array.\n  *\n+ * OpCodes are efficient operations which can be applied to the DOM to update it. (For example to\n+ * update to a new ICU case requires that we clean up previous elements and create new ones.)\n+ *\n  * OpCodes contain three parts:\n- *  1) Parent node index offset.\n- *  2) Reference node index offset.\n- *  3) The OpCode to execute.\n+ *  1) Parent node index offset. (p)\n+ *  2) Reference node index offset. (r)\n+ *  3) The instruction to execute. (i)\n+ *\n+ * pppp pppp pppp pppp rrrr rrrr rrrr riii\n+ * 3322 2222 2222 1111 1111 1110 0000 0000\n+ * 1098 7654 3210 9876 5432 1098 7654 3210\n+ *\n+ * ```\n+ * var parent = lView[opCode >>> SHIFT_PARENT];\n+ * var refNode = lView[((opCode & MASK_REF) >>> SHIFT_REF)];\n+ * var instruction = opCode & MASK_OPCODE;\n+ * ```\n  *\n  * See: `I18nCreateOpCodes` for example of usage.\n  */\n-import {SanitizerFn} from './sanitization';\n-\n export const enum I18nMutateOpCode {\n   /**\n    * Stores shift amount for bits 17-3 that contain reference index.\n@@ -30,36 +43,61 @@ export const enum I18nMutateOpCode {\n   /**\n    * Mask for OpCode\n    */\n-  MASK_OPCODE = 0b111,\n+  MASK_INSTRUCTION = 0b111,\n \n   /**\n-   * OpCode to select a node. (next OpCode will contain the operation.)\n+   * Mask for the Reference node (bits 16-3)\n+   */\n+  // FIXME(misko): Why is this not used?\n+  MASK_REF = 0b11111111111111000,\n+  //           11111110000000000\n+  //           65432109876543210\n+\n+  /**\n+   * Instruction to select a node. (next OpCode will contain the operation.)\n    */\n   Select = 0b000,\n+\n   /**\n-   * OpCode to append the current node to `PARENT`.\n+   * Instruction to append the current node to `PARENT`.\n    */\n   AppendChild = 0b001,\n+\n   /**\n-   * OpCode to remove the `REF` node from `PARENT`.\n+   * Instruction to remove the `REF` node from `PARENT`.\n    */\n   Remove = 0b011,\n+\n   /**\n-   * OpCode to set the attribute of a node.\n+   * Instruction to set the attribute of a node.\n    */\n   Attr = 0b100,\n+\n   /**\n-   * OpCode to simulate elementEnd()\n+   * Instruction to simulate elementEnd()\n    */\n   ElementEnd = 0b101,\n+\n   /**\n-   * OpCode to read the remove OpCodes for the nested ICU\n+   * Instruction to removed the nested ICU.\n    */\n   RemoveNestedIcu = 0b110,\n }\n \n+export function getParentFromI18nMutateOpCode(mergedCode: number): number {\n+  return mergedCode >>> I18nMutateOpCode.SHIFT_PARENT;\n+}\n+\n+export function getRefFromI18nMutateOpCode(mergedCode: number): number {\n+  return (mergedCode & I18nMutateOpCode.MASK_REF) >>> I18nMutateOpCode.SHIFT_REF;\n+}\n+\n+export function getInstructionFromI18nMutateOpCode(mergedCode: number): number {\n+  return mergedCode & I18nMutateOpCode.MASK_INSTRUCTION;\n+}\n+\n /**\n- * Marks that the next string is for element.\n+ * Marks that the next string is an element name.\n  *\n  * See `I18nMutateOpCodes` documentation.\n  */\n@@ -71,7 +109,7 @@ export interface ELEMENT_MARKER {\n }\n \n /**\n- * Marks that the next string is for comment.\n+ * Marks that the next string is comment text.\n  *\n  * See `I18nMutateOpCodes` documentation.\n  */\n@@ -83,6 +121,18 @@ export interface COMMENT_MARKER {\n   marker: 'comment';\n }\n \n+export interface I18nDebug {\n+  /**\n+   * Human readable representation of the OpCode arrays.\n+   *\n+   * NOTE: This property only exists if `ngDevMode` is set to `true` and it is not present in\n+   * production. Its presence is purely to help debug issue in development, and should not be relied\n+   * on in production application.\n+   */\n+  debug?: string[];\n+}\n+\n+\n /**\n  * Array storing OpCode for dynamically creating `i18n` blocks.\n  *\n@@ -92,50 +142,27 @@ export interface COMMENT_MARKER {\n  *   // For adding text nodes\n  *   // ---------------------\n  *   // Equivalent to:\n- *   //   const node = lView[index++] = document.createTextNode('abc');\n- *   //   lView[1].insertBefore(node, lView[2]);\n- *   'abc', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n- *\n- *   // Equivalent to:\n- *   //   const node = lView[index++] = document.createTextNode('xyz');\n- *   //   lView[1].appendChild(node);\n- *   'xyz', 1 << SHIFT_PARENT | AppendChild,\n+ *   //   lView[1].appendChild(lView[0] = document.createTextNode('xyz'));\n+ *   'xyz', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n  *\n  *   // For adding element nodes\n  *   // ---------------------\n  *   // Equivalent to:\n- *   //   const node = lView[index++] = document.createElement('div');\n- *   //   lView[1].insertBefore(node, lView[2]);\n- *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n- *\n- *   // Equivalent to:\n- *   //   const node = lView[index++] = document.createElement('div');\n- *   //   lView[1].appendChild(node);\n- *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | AppendChild,\n+ *   //   lView[1].appendChild(lView[0] = document.createElement('div'));\n+ *   ELEMENT_MARKER, 'div', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n  *\n  *   // For adding comment nodes\n  *   // ---------------------\n  *   // Equivalent to:\n- *   //   const node = lView[index++] = document.createComment('');\n- *   //   lView[1].insertBefore(node, lView[2]);\n- *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n- *\n- *   // Equivalent to:\n- *   //   const node = lView[index++] = document.createComment('');\n- *   //   lView[1].appendChild(node);\n- *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | AppendChild,\n+ *   //   lView[1].appendChild(lView[0] = document.createComment(''));\n+ *   COMMENT_MARKER, '', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n  *\n  *   // For moving existing nodes to a different location\n  *   // --------------------------------------------------\n  *   // Equivalent to:\n  *   //   const node = lView[1];\n- *   //   lView[2].insertBefore(node, lView[3]);\n- *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 3 << SHIFT_REF | InsertBefore,\n- *\n- *   // Equivalent to:\n- *   //   const node = lView[1];\n  *   //   lView[2].appendChild(node);\n- *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | AppendChild,\n+ *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n  *\n  *   // For removing existing nodes\n  *   // --------------------------------------------------\n@@ -147,18 +174,14 @@ export interface COMMENT_MARKER {\n  *   // --------------------------------------------------\n  *   //   const node = lView[1];\n  *   //   node.setAttribute('attr', 'value');\n- *   1 << SHIFT_REF | Select, 'attr', 'value'\n- *            // NOTE: Select followed by two string (vs select followed by OpCode)\n+ *   1 << SHIFT_REF | Attr, 'attr', 'value'\n  * ];\n  * ```\n- * NOTE:\n- *   - `index` is initial location where the extra nodes should be stored in the EXPANDO section of\n- * `LVIewData`.\n  *\n  * See: `applyI18nCreateOpCodes`;\n  */\n-export interface I18nMutateOpCodes extends Array<number|string|ELEMENT_MARKER|COMMENT_MARKER|null> {\n-}\n+export interface I18nMutateOpCodes extends Array<number|string|ELEMENT_MARKER|COMMENT_MARKER|null>,\n+                                           I18nDebug {}\n \n export const enum I18nUpdateOpCode {\n   /**\n@@ -171,19 +194,19 @@ export const enum I18nUpdateOpCode {\n   MASK_OPCODE = 0b11,\n \n   /**\n-   * OpCode to update a text node.\n+   * Instruction to update a text node.\n    */\n   Text = 0b00,\n   /**\n-   * OpCode to update a attribute of a node.\n+   * Instruction to update a attribute of a node.\n    */\n   Attr = 0b01,\n   /**\n-   * OpCode to switch the current ICU case.\n+   * Instruction to switch the current ICU case.\n    */\n   IcuSwitch = 0b10,\n   /**\n-   * OpCode to update the current ICU case.\n+   * Instruction to update the current ICU case.\n    */\n   IcuUpdate = 0b11,\n }\n@@ -197,6 +220,10 @@ export const enum I18nUpdateOpCode {\n  * higher.) The OpCodes then compare its own change mask against the expression change mask to\n  * determine if the OpCodes should execute.\n  *\n+ * NOTE: 32nd bit is special as it says 32nd or higher. This way if we have more than 32 bindings\n+ * the code still works, but with lower efficiency. (it is unlikely that a translation would have\n+ * more than 32 bindings.)\n+ *\n  * These OpCodes can be used by both the i18n block as well as ICU sub-block.\n  *\n  * ## Example\n@@ -220,8 +247,8 @@ export const enum I18nUpdateOpCode {\n  *   // The following OpCodes represent: `<div i18n-title=\"pre{{exp1}}in{{exp2}}post\">`\n  *   // If `changeMask & 0b11`\n  *   //        has changed then execute update OpCodes.\n- *   //        has NOT changed then skip `7` values and start processing next OpCodes.\n- *   0b11, 7,\n+ *   //        has NOT changed then skip `8` values and start processing next OpCodes.\n+ *   0b11, 8,\n  *   // Concatenate `newValue = 'pre'+lView[bindIndex-4]+'in'+lView[bindIndex-3]+'post';`.\n  *   'pre', -4, 'in', -3, 'post',\n  *   // Update attribute: `elementAttribute(1, 'title', sanitizerFn(newValue));`\n@@ -240,8 +267,8 @@ export const enum I18nUpdateOpCode {\n  *   // The following OpCodes represent: `<div i18n>{exp4, plural, ... }\">`\n  *   // If `changeMask & 0b1000`\n  *   //        has changed then execute update OpCodes.\n- *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n- *   0b1000, 4,\n+ *   //        has NOT changed then skip `2` values and start processing next OpCodes.\n+ *   0b1000, 2,\n  *   // Concatenate `newValue = lView[bindIndex -1];`.\n  *   -1,\n  *   // Switch ICU: `icuSwitchCase(lView[1], 0, newValue);`\n@@ -256,7 +283,7 @@ export const enum I18nUpdateOpCode {\n  * ```\n  *\n  */\n-export interface I18nUpdateOpCodes extends Array<string|number|SanitizerFn|null> {}\n+export interface I18nUpdateOpCodes extends Array<string|number|SanitizerFn|null>, I18nDebug {}\n \n /**\n  * Store information for the i18n translation block."
        },
        {
            "sha": "e78ca97129ae1ceb5c06c69b95705ca22d388223",
            "filename": "packages/core/src/render3/interfaces/node.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fnode.ts",
            "raw_url": "https://github.com/angular/angular/raw/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fnode.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fnode.ts?ref=3821dc5f6c2e63cd08eac5cf4f898d3f8081af94",
            "patch": "@@ -701,7 +701,9 @@ export interface TIcuContainerNode extends TNode {\n   /**\n    * Indicates the current active case for an ICU expression.\n    * It is null when there is no active case.\n+   *\n    */\n+  // FIXME(misko): This is at a wrong location as activeCase is `LView` (not `TView`) concern\n   activeCaseIndex: number|null;\n }\n "
        },
        {
            "sha": "518b0738f6d9e1b67930b2c5a6945c7509aa07c8",
            "filename": "packages/core/src/render3/util/debug_utils.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 2,
            "changes": 35,
            "blob_url": "https://github.com/angular/angular/blob/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Futil%2Fdebug_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Fsrc%2Frender3%2Futil%2Fdebug_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Futil%2Fdebug_utils.ts?ref=3821dc5f6c2e63cd08eac5cf4f898d3f8081af94",
            "patch": "@@ -5,6 +5,37 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-export function attachDebugObject(obj: any, debug: any) {\n-  Object.defineProperty(obj, 'debug', {value: debug, enumerable: false});\n+\n+/**\n+ * Patch a `debug` property on top of the existing object.\n+ *\n+ * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n+ *\n+ * @param obj Object to patch\n+ * @param debug Value to patch\n+ */\n+export function attachDebugObject(obj: any, debug: any): void {\n+  if (ngDevMode) {\n+    Object.defineProperty(obj, 'debug', {value: debug, enumerable: false});\n+  } else {\n+    throw new Error(\n+        'This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n+  }\n+}\n+\n+/**\n+ * Patch a `debug` property getter on top of the existing object.\n+ *\n+ * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n+ *\n+ * @param obj Object to patch\n+ * @param debugGetter Getter returning a value to patch\n+ */\n+export function attachDebugGetter(obj: any, debugGetter: () => any): void {\n+  if (ngDevMode) {\n+    Object.defineProperty(obj, 'debug', {get: debugGetter, enumerable: false});\n+  } else {\n+    throw new Error(\n+        'This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n+  }\n }"
        },
        {
            "sha": "50c1abd43d310398d25cc4df94683fe8abec06b3",
            "filename": "packages/core/test/render3/i18n_debug_spec.ts",
            "status": "added",
            "additions": 140,
            "deletions": 0,
            "changes": 140,
            "blob_url": "https://github.com/angular/angular/blob/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Ftest%2Frender3%2Fi18n_debug_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Ftest%2Frender3%2Fi18n_debug_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fi18n_debug_spec.ts?ref=3821dc5f6c2e63cd08eac5cf4f898d3f8081af94",
            "patch": "@@ -0,0 +1,140 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {i18nMutateOpCodesToString, i18nUpdateOpCodesToString} from '@angular/core/src/render3/i18n_debug';\n+import {COMMENT_MARKER, ELEMENT_MARKER, I18nMutateOpCode, I18nUpdateOpCode} from '@angular/core/src/render3/interfaces/i18n';\n+\n+describe('i18n debug', () => {\n+  describe('i18nUpdateOpCodesToString', () => {\n+    it('should print nothing', () => {\n+      expect(i18nUpdateOpCodesToString([])).toEqual([]);\n+    });\n+\n+    it('should print text opCode', () => {\n+      expect(i18nUpdateOpCodesToString([\n+        0b11,\n+        4,\n+        'pre ',\n+        -4,\n+        ' post',\n+        1 << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Text,\n+      ]))\n+          .toEqual(\n+              ['if (mask & 0b11) { (lView[1] as Text).textContent = `pre ${lView[4]} post`; }']);\n+    });\n+\n+    it('should print Attribute opCode', () => {\n+      expect(i18nUpdateOpCodesToString([\n+        0b01,    8,\n+        'pre ',  -4,\n+        ' in ',  -3,\n+        ' post', 1 << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Attr,\n+        'title', null,\n+        0b10,    8,\n+        'pre ',  -4,\n+        ' in ',  -3,\n+        ' post', 1 << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Attr,\n+        'title', (v) => v,\n+      ]))\n+          .toEqual([\n+            'if (mask & 0b1) { (lView[1] as Element).setAttribute(\\'title\\', `pre ${lView[4]} in ${lView[3]} post`); }',\n+            'if (mask & 0b10) { (lView[1] as Element).setAttribute(\\'title\\', (function (v) { return v; })(`pre ${lView[4]} in ${lView[3]} post`)); }'\n+          ]);\n+    });\n+\n+    it('should print icuSwitch opCode', () => {\n+      expect(i18nUpdateOpCodesToString([\n+        0b100, 2, -5, 12 << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch,\n+        2  // FIXME(misko): Should be part of IcuSwitch\n+      ])).toEqual(['if (mask & 0b100) { icuSwitchCase(lView[12] as Comment, 2, `${lView[5]}`); }']);\n+    });\n+\n+    it('should print icuUpdate opCode', () => {\n+      expect(i18nUpdateOpCodesToString([\n+        0b1000, 2, 13 << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate,\n+        3  // FIXME(misko): should be part of IcuUpdate\n+      ])).toEqual(['if (mask & 0b1000) { icuUpdateCase(lView[13] as Comment, 3); }']);\n+    });\n+  });\n+\n+  describe('i18nMutateOpCodesToString', () => {\n+    it('should print nothing', () => {\n+      expect(i18nMutateOpCodesToString([])).toEqual([]);\n+    });\n+\n+    it('should print Move', () => {\n+      expect(i18nMutateOpCodesToString([\n+        1 << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Select,\n+        2 << I18nMutateOpCode.SHIFT_PARENT | 0 << I18nMutateOpCode.SHIFT_REF |\n+            I18nMutateOpCode.AppendChild,\n+      ])).toEqual(['(lView[2] as Element).appendChild(lView[1])']);\n+    });\n+\n+    it('should print text AppendChild', () => {\n+      expect(i18nMutateOpCodesToString([\n+        'xyz', 0,\n+        1 << I18nMutateOpCode.SHIFT_PARENT | 0 << I18nMutateOpCode.SHIFT_REF |\n+            I18nMutateOpCode.AppendChild\n+      ]))\n+          .toEqual([\n+            'lView[0] = document.createTextNode(\"xyz\")',\n+            '(lView[1] as Element).appendChild(lView[0])'\n+          ]);\n+    });\n+\n+\n+    it('should print element AppendChild', () => {\n+      expect(i18nMutateOpCodesToString([\n+        ELEMENT_MARKER, 'xyz', 0,\n+        1 << I18nMutateOpCode.SHIFT_PARENT | 0 << I18nMutateOpCode.SHIFT_REF |\n+            I18nMutateOpCode.AppendChild\n+      ]))\n+          .toEqual([\n+            'lView[0] = document.createElement(\"xyz\")',\n+            '(lView[1] as Element).appendChild(lView[0])'\n+          ]);\n+    });\n+\n+    it('should print comment AppendChild', () => {\n+      expect(i18nMutateOpCodesToString([\n+        COMMENT_MARKER, 'xyz', 0,\n+        1 << I18nMutateOpCode.SHIFT_PARENT | 0 << I18nMutateOpCode.SHIFT_REF |\n+            I18nMutateOpCode.AppendChild\n+      ]))\n+          .toEqual([\n+            'lView[0] = document.createComment(\"xyz\")',\n+            '(lView[1] as Element).appendChild(lView[0])'\n+          ]);\n+    });\n+\n+    it('should print Remove', () => {\n+      expect(i18nMutateOpCodesToString([\n+        2 << I18nMutateOpCode.SHIFT_PARENT | 0 << I18nMutateOpCode.SHIFT_REF |\n+        I18nMutateOpCode.Remove\n+      ])).toEqual(['(lView[2] as Element).remove(lView[0])']);\n+    });\n+\n+    it('should print Attr', () => {\n+      expect(i18nMutateOpCodesToString([\n+        1 << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Attr, 'attr', 'value'\n+      ])).toEqual(['(lView[1] as Element).setAttribute(\"attr\", \"value\")']);\n+    });\n+\n+    it('should print ElementEnd', () => {\n+      expect(i18nMutateOpCodesToString([\n+        1 << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.ElementEnd,\n+      ])).toEqual(['setPreviousOrParentTNode(tView.data[1] as TNode)']);\n+    });\n+\n+    it('should print RemoveNestedIcu', () => {\n+      expect(i18nMutateOpCodesToString([\n+        1 << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.RemoveNestedIcu,\n+      ])).toEqual(['removeNestedICU(1)']);\n+    });\n+  });\n+});"
        },
        {
            "sha": "6d464848451909866ec966022cbcde016d5ca081",
            "filename": "packages/core/test/render3/i18n_spec.ts",
            "status": "modified",
            "additions": 180,
            "deletions": 354,
            "changes": 534,
            "blob_url": "https://github.com/angular/angular/blob/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Ftest%2Frender3%2Fi18n_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Ftest%2Frender3%2Fi18n_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fi18n_spec.ts?ref=3821dc5f6c2e63cd08eac5cf4f898d3f8081af94",
            "patch": "@@ -9,10 +9,11 @@\n import {noop} from '../../../compiler/src/render3/view/util';\n import {getTranslationForTemplate, ɵɵi18nAttributes, ɵɵi18nPostprocess, ɵɵi18nStart} from '../../src/render3/i18n';\n import {setDelayProjection, ɵɵelementEnd, ɵɵelementStart} from '../../src/render3/instructions/all';\n-import {COMMENT_MARKER, ELEMENT_MARKER, I18nMutateOpCode, I18nUpdateOpCode, I18nUpdateOpCodes, TI18n} from '../../src/render3/interfaces/i18n';\n+import {I18nUpdateOpCodes, TI18n, TIcu} from '../../src/render3/interfaces/i18n';\n import {HEADER_OFFSET, LView, TVIEW} from '../../src/render3/interfaces/view';\n import {getNativeByIndex} from '../../src/render3/util/view_utils';\n import {TemplateFixture} from './render_util';\n+import {debugMatch} from './utils';\n \n describe('Runtime i18n', () => {\n   afterEach(() => {\n@@ -72,25 +73,15 @@ describe('Runtime i18n', () => {\n       const nbConsts = 1;\n       const index = 0;\n       const opCodes = getOpCodes(() => {\n-        ɵɵi18nStart(index, MSG_DIV);\n-      }, null, nbConsts, index);\n-\n-      // Check debug\n-      const debugOps = (opCodes as any).create.debug!.operations;\n-      expect(debugOps[0].__raw_opCode).toBe('simple text');\n-      expect(debugOps[0].type).toBe('Create Text Node');\n-      expect(debugOps[0].nodeIndex).toBe(1);\n-      expect(debugOps[0].text).toBe('simple text');\n-      expect(debugOps[1].__raw_opCode).toBe(1);\n-      expect(debugOps[1].type).toBe('AppendChild');\n-      expect(debugOps[1].nodeIndex).toBe(0);\n+                        ɵɵi18nStart(index, MSG_DIV);\n+                      }, null, nbConsts, index) as TI18n;\n \n       expect(opCodes).toEqual({\n         vars: 1,\n-        create: [\n-          'simple text', nbConsts,\n-          index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild\n-        ],\n+        create: debugMatch([\n+          'lView[1] = document.createTextNode(\"simple text\")',\n+          '(lView[0] as Element).appendChild(lView[1])'\n+        ]),\n         update: [],\n         icus: null\n       });\n@@ -102,37 +93,28 @@ describe('Runtime i18n', () => {\n       // 3 consts for the 2 divs and 1 span + 1 const for `i18nStart` = 4 consts\n       const nbConsts = 4;\n       const index = 1;\n-      const elementIndex = 2;\n-      const elementIndex2 = 3;\n       const opCodes = getOpCodes(() => {\n         ɵɵi18nStart(index, MSG_DIV);\n       }, null, nbConsts, index);\n \n       expect(opCodes).toEqual({\n         vars: 5,\n-        create: [\n-          'Hello ',\n-          nbConsts,\n-          index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          elementIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Select,\n-          index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          'world',\n-          nbConsts + 1,\n-          elementIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          elementIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.ElementEnd,\n-          ' and ',\n-          nbConsts + 2,\n-          index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          elementIndex2 << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Select,\n-          index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          'universe',\n-          nbConsts + 3,\n-          elementIndex2 << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          elementIndex2 << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.ElementEnd,\n-          '!',\n-          nbConsts + 4,\n-          index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-        ],\n+        create: debugMatch([\n+          'lView[4] = document.createTextNode(\"Hello \")',\n+          '(lView[1] as Element).appendChild(lView[4])',\n+          '(lView[1] as Element).appendChild(lView[2])',\n+          'lView[5] = document.createTextNode(\"world\")',\n+          '(lView[2] as Element).appendChild(lView[5])',\n+          'setPreviousOrParentTNode(tView.data[2] as TNode)',\n+          'lView[6] = document.createTextNode(\" and \")',\n+          '(lView[1] as Element).appendChild(lView[6])',\n+          '(lView[1] as Element).appendChild(lView[3])',\n+          'lView[7] = document.createTextNode(\"universe\")',\n+          '(lView[3] as Element).appendChild(lView[7])',\n+          'setPreviousOrParentTNode(tView.data[3] as TNode)',\n+          'lView[8] = document.createTextNode(\"!\")',\n+          '(lView[1] as Element).appendChild(lView[8])',\n+        ]),\n         update: [],\n         icus: null\n       });\n@@ -146,21 +128,18 @@ describe('Runtime i18n', () => {\n         ɵɵi18nStart(index, MSG_DIV);\n       }, null, nbConsts, index);\n \n-      expect((opCodes as any).update.debug.operations).toEqual([\n-        {__raw_opCode: 8, checkBit: 1, type: 'Text', nodeIndex: 2, text: 'Hello �0�!'}\n+      expect((opCodes as any).update.debug).toEqual([\n+        'if (mask & 0b1) { (lView[2] as Text).textContent = `Hello ${lView[1]}!`; }'\n       ]);\n \n       expect(opCodes).toEqual({\n         vars: 1,\n-        create:\n-            ['', nbConsts, index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild],\n-        update: [\n-          0b1,  // bindings mask\n-          4,    // if no update, skip 4\n-          'Hello ',\n-          -1,  // binding index\n-          '!', (index + 1) << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Text\n-        ],\n+        create: debugMatch([\n+          'lView[2] = document.createTextNode(\"\")',\n+          '(lView[1] as Element).appendChild(lView[2])',\n+        ]),\n+        update: debugMatch(\n+            ['if (mask & 0b1) { (lView[2] as Text).textContent = `Hello ${lView[1]}!`; }']),\n         icus: null\n       });\n     });\n@@ -175,14 +154,12 @@ describe('Runtime i18n', () => {\n \n       expect(opCodes).toEqual({\n         vars: 1,\n-        create:\n-            ['', nbConsts, index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild],\n-        update: [\n-          0b11,  // bindings mask\n-          8,     // if no update, skip 8\n-          'Hello ', -1, ' and ', -2, ', again ', -1, '!',\n-          (index + 1) << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Text\n-        ],\n+        create: debugMatch([\n+          'lView[2] = document.createTextNode(\"\")', '(lView[1] as Element).appendChild(lView[2])'\n+        ]),\n+        update: debugMatch([\n+          'if (mask & 0b11) { (lView[2] as Text).textContent = `Hello ${lView[1]} and ${lView[2]}, again ${lView[1]}!`; }'\n+        ]),\n         icus: null\n       });\n     });\n@@ -211,22 +188,14 @@ describe('Runtime i18n', () => {\n \n       expect(opCodes).toEqual({\n         vars: 2,\n-        create: [\n-          '',\n-          nbConsts,\n-          index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          ~rootTemplate << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Select,\n-          index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          '!',\n-          nbConsts + 1,\n-          index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-        ],\n-        update: [\n-          0b1,  //  bindings mask\n-          3,    // if no update, skip 3\n-          -1,   // binding index\n-          ' is rendered as: ', firstTextNode << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Text\n-        ],\n+        create: debugMatch([\n+          'lView[3] = document.createTextNode(\"\")', '(lView[1] as Element).appendChild(lView[3])',\n+          '(lView[1] as Element).appendChild(lView[16381])',\n+          'lView[4] = document.createTextNode(\"!\")', '(lView[1] as Element).appendChild(lView[4])'\n+        ]),\n+        update: debugMatch([\n+          'if (mask & 0b1) { (lView[3] as Text).textContent = `${lView[1]} is rendered as: `; }'\n+        ]),\n         icus: null\n       });\n \n@@ -243,19 +212,15 @@ describe('Runtime i18n', () => {\n \n       expect(opCodes).toEqual({\n         vars: 2,\n-        create: [\n-          spanElement << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Select,\n-          index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          'before',\n-          nbConsts,\n-          spanElement << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          ~bElementSubTemplate << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Select,\n-          spanElement << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          'after',\n-          nbConsts + 1,\n-          spanElement << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          spanElement << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.ElementEnd,\n-        ],\n+        create: debugMatch([\n+          '(lView[0] as Element).appendChild(lView[1])',\n+          'lView[3] = document.createTextNode(\"before\")',\n+          '(lView[1] as Element).appendChild(lView[3])',\n+          '(lView[1] as Element).appendChild(lView[16381])',\n+          'lView[4] = document.createTextNode(\"after\")',\n+          '(lView[1] as Element).appendChild(lView[4])',\n+          'setPreviousOrParentTNode(tView.data[1] as TNode)'\n+        ]),\n         update: [],\n         icus: null\n       });\n@@ -272,14 +237,12 @@ describe('Runtime i18n', () => {\n \n       expect(opCodes).toEqual({\n         vars: 1,\n-        create: [\n-          bElement << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Select,\n-          index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          'middle',\n-          nbConsts,\n-          bElement << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-          bElement << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.ElementEnd,\n-        ],\n+        create: debugMatch([\n+          '(lView[0] as Element).appendChild(lView[1])',\n+          'lView[2] = document.createTextNode(\"middle\")',\n+          '(lView[1] as Element).appendChild(lView[2])',\n+          'setPreviousOrParentTNode(tView.data[1] as TNode)'\n+        ]),\n         update: [],\n         icus: null\n       });\n@@ -294,179 +257,76 @@ describe('Runtime i18n', () => {\n       const nbConsts = 1;\n       const index = 0;\n       const opCodes = getOpCodes(() => {\n-        ɵɵi18nStart(index, MSG_DIV);\n-      }, null, nbConsts, index);\n-      const tIcuIndex = 0;\n-      const icuCommentNodeIndex = index + 1;\n-      const firstTextNodeIndex = index + 2;\n-      const bElementNodeIndex = index + 3;\n-      const iElementNodeIndex = index + 3;\n-      const spanElementNodeIndex = index + 3;\n-      const innerTextNode = index + 4;\n-      const lastTextNode = index + 5;\n-\n-      const debugOps = (opCodes as any).update.debug.operations;\n-      expect(debugOps[0].__raw_opCode).toBe(6);\n-      expect(debugOps[0].checkBit).toBe(1);\n-      expect(debugOps[0].type).toBe('IcuSwitch');\n-      expect(debugOps[0].nodeIndex).toBe(1);\n-      expect(debugOps[0].tIcuIndex).toBe(0);\n-      expect(debugOps[0].mainBinding).toBe('�0�');\n-\n-      expect(debugOps[1].__raw_opCode).toBe(7);\n-      expect(debugOps[1].checkBit).toBe(3);\n-      expect(debugOps[1].type).toBe('IcuUpdate');\n-      expect(debugOps[1].nodeIndex).toBe(1);\n-      expect(debugOps[1].tIcuIndex).toBe(0);\n-\n-      const icuDebugOps = (opCodes as any).icus[0].create[0].debug.operations;\n-      let op: any;\n-      let i = 0;\n-\n-      op = icuDebugOps[i++];\n-      expect(op.__raw_opCode).toBe('no ');\n-      expect(op.type).toBe('Create Text Node');\n-      expect(op.nodeIndex).toBe(2);\n-      expect(op.text).toBe('no ');\n-\n-      op = icuDebugOps[i++];\n-      expect(op.__raw_opCode).toBe(131073);\n-      expect(op.type).toBe('AppendChild');\n-      expect(op.nodeIndex).toBe(1);\n-\n-      op = icuDebugOps[i++];\n-      expect(op.__raw_opCode).toEqual({marker: 'element'});\n-      expect(op.type).toBe('ELEMENT_MARKER');\n-\n-      op = icuDebugOps[i++];\n-      expect(op.__raw_opCode).toBe('b');\n-      expect(op.type).toBe('Create Text Node');\n-      expect(op.nodeIndex).toBe(3);\n-      expect(op.text).toBe('b');\n-\n-      op = icuDebugOps[i++];\n-      expect(op.__raw_opCode).toBe(131073);\n-      expect(op.type).toBe('AppendChild');\n-      expect(op.nodeIndex).toBe(1);\n-\n-      op = icuDebugOps[i++];\n-      expect(op.__raw_opCode).toBe(28);\n-      expect(op.type).toBe('Attr');\n-      expect(op.nodeIndex).toBe(3);\n-      expect(op.attrName).toBe('title');\n-      expect(op.attrValue).toBe('none');\n-\n-      op = icuDebugOps[i++];\n-      expect(op.__raw_opCode).toBe('emails');\n-      expect(op.type).toBe('Create Text Node');\n-      expect(op.nodeIndex).toBe(4);\n-      expect(op.text).toBe('emails');\n-\n-      op = icuDebugOps[i++];\n-      expect(op.__raw_opCode).toBe(393217);\n-      expect(op.type).toBe('AppendChild');\n-      expect(op.nodeIndex).toBe(3);\n-\n-      op = icuDebugOps[i++];\n-      expect(op.__raw_opCode).toBe('!');\n-      expect(op.type).toBe('Create Text Node');\n-      expect(op.nodeIndex).toBe(5);\n-      expect(op.text).toBe('!');\n-\n-      op = icuDebugOps[i++];\n-      expect(op.__raw_opCode).toBe(131073);\n-      expect(op.type).toBe('AppendChild');\n-      expect(op.nodeIndex).toBe(1);\n+                        ɵɵi18nStart(index, MSG_DIV);\n+                      }, null, nbConsts, index) as TI18n;\n \n       expect(opCodes).toEqual({\n         vars: 5,\n-        create: [\n-          COMMENT_MARKER, 'ICU 1', icuCommentNodeIndex,\n-          index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild\n-        ],\n-        update: [\n-          0b1,  // mask for ICU main binding\n-          3,    // skip 3 if not changed\n-          -1,   // icu main binding\n-          icuCommentNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch, tIcuIndex,\n-          0b11,  // mask for all ICU bindings\n-          2,     // skip 2 if not changed\n-          icuCommentNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate, tIcuIndex\n-        ],\n-        icus: [{\n+        update: debugMatch([\n+          'if (mask & 0b1) { icuSwitchCase(lView[1] as Comment, 0, `${lView[1]}`); }',\n+          'if (mask & 0b11) { icuUpdateCase(lView[1] as Comment, 0); }',\n+        ]),\n+        create: debugMatch([\n+          'lView[1] = document.createComment(\"ICU 1\")',\n+          '(lView[0] as Element).appendChild(lView[1])',\n+        ]),\n+        icus: [<TIcu>{\n           type: 1,\n           vars: [4, 3, 3],\n           childIcus: [[], [], []],\n           cases: ['0', '1', 'other'],\n           create: [\n-            [\n-              'no ',\n-              firstTextNodeIndex,\n-              icuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-              ELEMENT_MARKER,\n-              'b',\n-              bElementNodeIndex,\n-              icuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-              bElementNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Attr,\n-              'title',\n-              'none',\n-              'emails',\n-              innerTextNode,\n-              bElementNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-              '!',\n-              lastTextNode,\n-              icuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-            ],\n-            [\n-              'one ', firstTextNodeIndex,\n-              icuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-              ELEMENT_MARKER, 'i', iElementNodeIndex,\n-              icuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-              'email', innerTextNode,\n-              iElementNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild\n-            ],\n-            [\n-              '', firstTextNodeIndex,\n-              icuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-              ELEMENT_MARKER, 'span', spanElementNodeIndex,\n-              icuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-              'emails', innerTextNode,\n-              spanElementNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild\n-            ]\n+            debugMatch([\n+              'lView[2] = document.createTextNode(\"no \")',\n+              '(lView[1] as Element).appendChild(lView[2])',\n+              'lView[3] = document.createElement(\"b\")',\n+              '(lView[1] as Element).appendChild(lView[3])',\n+              '(lView[3] as Element).setAttribute(\"title\", \"none\")',\n+              'lView[4] = document.createTextNode(\"emails\")',\n+              '(lView[3] as Element).appendChild(lView[4])',\n+              'lView[5] = document.createTextNode(\"!\")',\n+              '(lView[1] as Element).appendChild(lView[5])'\n+            ]),\n+            debugMatch([\n+              'lView[2] = document.createTextNode(\"one \")',\n+              '(lView[1] as Element).appendChild(lView[2])',\n+              'lView[3] = document.createElement(\"i\")',\n+              '(lView[1] as Element).appendChild(lView[3])',\n+              'lView[4] = document.createTextNode(\"email\")',\n+              '(lView[3] as Element).appendChild(lView[4])'\n+            ]),\n+            debugMatch([\n+              'lView[2] = document.createTextNode(\"\")',\n+              '(lView[1] as Element).appendChild(lView[2])',\n+              'lView[3] = document.createElement(\"span\")',\n+              '(lView[1] as Element).appendChild(lView[3])',\n+              'lView[4] = document.createTextNode(\"emails\")',\n+              '(lView[3] as Element).appendChild(lView[4])'\n+            ])\n           ],\n           remove: [\n-            [\n-              firstTextNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove,\n-              innerTextNode << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove,\n-              bElementNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove,\n-              lastTextNode << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove,\n-            ],\n-            [\n-              firstTextNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove,\n-              innerTextNode << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove,\n-              iElementNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove,\n-            ],\n-            [\n-              firstTextNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove,\n-              innerTextNode << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove,\n-              spanElementNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove,\n-            ]\n+            debugMatch([\n+              '(lView[0] as Element).remove(lView[2])',\n+              '(lView[0] as Element).remove(lView[4])',\n+              '(lView[0] as Element).remove(lView[3])',\n+              '(lView[0] as Element).remove(lView[5])',\n+            ]),\n+            debugMatch([\n+              '(lView[0] as Element).remove(lView[2])',\n+              '(lView[0] as Element).remove(lView[4])',\n+              '(lView[0] as Element).remove(lView[3])',\n+            ]),\n+            debugMatch([\n+              '(lView[0] as Element).remove(lView[2])',\n+              '(lView[0] as Element).remove(lView[4])',\n+              '(lView[0] as Element).remove(lView[3])',\n+            ])\n           ],\n           update: [\n-            [], [],\n-            [\n-              0b1,  // mask for the first binding\n-              3,    // skip 3 if not changed\n-              -1,   // binding index\n-              ' ',  // text string to concatenate to the binding value\n-              firstTextNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Text,\n-              0b10,  // mask for the title attribute binding\n-              4,     // skip 4 if not changed\n-              -2,    // binding index\n-              bElementNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Attr,\n-              'title',  // attribute name\n-              null      // sanitize function\n-            ]\n+            debugMatch([]), debugMatch([]), debugMatch([\n+              'if (mask & 0b1) { (lView[2] as Text).textContent = `${lView[1]} `; }',\n+              'if (mask & 0b10) { (lView[3] as Element).setAttribute(\\'title\\', `${lView[2]}`); }'\n+            ])\n           ]\n         }]\n       });\n@@ -496,97 +356,78 @@ describe('Runtime i18n', () => {\n \n       expect(opCodes).toEqual({\n         vars: 6,\n-        create: [\n-          COMMENT_MARKER, 'ICU 1', icuCommentNodeIndex,\n-          index << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild\n-        ],\n-        update: [\n-          0b1,  // mask for ICU main binding\n-          3,    // skip 3 if not changed\n-          -1,   // icu main binding\n-          icuCommentNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch, tIcuIndex,\n-          0b11,  // mask for all ICU bindings\n-          2,     // skip 2 if not changed\n-          icuCommentNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate, tIcuIndex\n-        ],\n+        create: debugMatch([\n+          'lView[1] = document.createComment(\"ICU 1\")',\n+          '(lView[0] as Element).appendChild(lView[1])'\n+        ]),\n+        update: debugMatch([\n+          'if (mask & 0b1) { icuSwitchCase(lView[1] as Comment, 1, `${lView[1]}`); }',\n+          'if (mask & 0b11) { icuUpdateCase(lView[1] as Comment, 1); }'\n+        ]),\n         icus: [\n           {\n             type: 0,\n             vars: [1, 1, 1],\n             childIcus: [[], [], []],\n             cases: ['cat', 'dog', 'other'],\n             create: [\n-              [\n-                'cats', nestedTextNodeIndex,\n-                nestedIcuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT |\n-                    I18nMutateOpCode.AppendChild\n-              ],\n-              [\n-                'dogs', nestedTextNodeIndex,\n-                nestedIcuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT |\n-                    I18nMutateOpCode.AppendChild\n-              ],\n-              [\n-                'animals', nestedTextNodeIndex,\n-                nestedIcuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT |\n-                    I18nMutateOpCode.AppendChild\n-              ]\n+              debugMatch([\n+                'lView[5] = document.createTextNode(\"cats\")',\n+                '(lView[3] as Element).appendChild(lView[5])'\n+              ]),\n+              debugMatch([\n+                'lView[5] = document.createTextNode(\"dogs\")',\n+                '(lView[3] as Element).appendChild(lView[5])'\n+              ]),\n+              debugMatch([\n+                'lView[5] = document.createTextNode(\"animals\")',\n+                '(lView[3] as Element).appendChild(lView[5])'\n+              ]),\n             ],\n             remove: [\n-              [nestedTextNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove],\n-              [nestedTextNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove],\n-              [nestedTextNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove]\n+              debugMatch(['(lView[0] as Element).remove(lView[5])']),\n+              debugMatch(['(lView[0] as Element).remove(lView[5])']),\n+              debugMatch(['(lView[0] as Element).remove(lView[5])'])\n             ],\n-            update: [[], [], []]\n+            update: [\n+              debugMatch([]),\n+              debugMatch([]),\n+              debugMatch([]),\n+            ]\n           },\n           {\n             type: 1,\n             vars: [1, 4],\n             childIcus: [[], [0]],\n             cases: ['0', 'other'],\n             create: [\n-              [\n-                'zero', firstTextNodeIndex,\n-                icuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild\n-              ],\n-              [\n-                '', firstTextNodeIndex,\n-                icuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-                COMMENT_MARKER, 'nested ICU 0', nestedIcuCommentNodeIndex,\n-                icuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild,\n-                '!', lastTextNodeIndex,\n-                icuCommentNodeIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild\n-              ]\n+              debugMatch([\n+                'lView[2] = document.createTextNode(\"zero\")',\n+                '(lView[1] as Element).appendChild(lView[2])'\n+              ]),\n+              debugMatch([\n+                'lView[2] = document.createTextNode(\"\")',\n+                '(lView[1] as Element).appendChild(lView[2])',\n+                'lView[3] = document.createComment(\"nested ICU 0\")',\n+                '(lView[1] as Element).appendChild(lView[3])',\n+                'lView[4] = document.createTextNode(\"!\")',\n+                '(lView[1] as Element).appendChild(lView[4])'\n+              ]),\n             ],\n             remove: [\n-              [firstTextNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove],\n-              [\n-                firstTextNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove,\n-                lastTextNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove,\n-                0 << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.RemoveNestedIcu,\n-                nestedIcuCommentNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove,\n-              ]\n+              debugMatch(['(lView[0] as Element).remove(lView[2])']),\n+              debugMatch([\n+                '(lView[0] as Element).remove(lView[2])', '(lView[0] as Element).remove(lView[4])',\n+                'removeNestedICU(0)', '(lView[0] as Element).remove(lView[3])'\n+              ]),\n             ],\n             update: [\n-              [],\n-              [\n-                0b1,  // mask for ICU main binding\n-                3,    // skip 3 if not changed\n-                -1,   // binding index\n-                ' ',  // text string to concatenate to the binding value\n-                firstTextNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Text,\n-                0b10,  // mask for inner ICU main binding\n-                3,     // skip 3 if not changed\n-                -2,    // inner ICU main binding\n-                nestedIcuCommentNodeIndex << I18nUpdateOpCode.SHIFT_REF |\n-                    I18nUpdateOpCode.IcuSwitch,\n-                nestedTIcuIndex,\n-                0b10,  // mask for all inner ICU bindings\n-                2,     // skip 2 if not changed\n-                nestedIcuCommentNodeIndex << I18nUpdateOpCode.SHIFT_REF |\n-                    I18nUpdateOpCode.IcuUpdate,\n-                nestedTIcuIndex\n-              ]\n+              debugMatch([]),\n+              debugMatch([\n+                'if (mask & 0b1) { (lView[2] as Text).textContent = `${lView[1]} `; }',\n+                'if (mask & 0b10) { icuSwitchCase(lView[3] as Comment, 0, `${lView[2]}`); }',\n+                'if (mask & 0b10) { icuUpdateCase(lView[3] as Comment, 0); }'\n+              ]),\n             ]\n           }\n         ]\n@@ -623,13 +464,9 @@ describe('Runtime i18n', () => {\n         ɵɵi18nAttributes(index, MSG_div_attr);\n       }, null, nbConsts, index);\n \n-      expect(opCodes).toEqual([\n-        0b1,  // bindings mask\n-        6,    // if no update, skip 4\n-        'Hello ',\n-        -1,  // binding index\n-        '!', (index - 1) << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Attr, 'title', null\n-      ]);\n+      expect(opCodes).toEqual(debugMatch([\n+        'if (mask & 0b1) { (lView[0] as Element).setAttribute(\\'title\\', `Hello ${lView[1]}!`); }'\n+      ]));\n     });\n \n     it('for multiple bindings', () => {\n@@ -641,12 +478,9 @@ describe('Runtime i18n', () => {\n         ɵɵi18nAttributes(index, MSG_div_attr);\n       }, null, nbConsts, index);\n \n-      expect(opCodes).toEqual([\n-        0b11,  // bindings mask\n-        10,    // size\n-        'Hello ', -1, ' and ', -2, ', again ', -1, '!',\n-        (index - 1) << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Attr, 'title', null\n-      ]);\n+      expect(opCodes).toEqual(debugMatch([\n+        'if (mask & 0b11) { (lView[0] as Element).setAttribute(\\'title\\', `Hello ${lView[1]} and ${lView[2]}, again ${lView[1]}!`); }'\n+      ]));\n     });\n \n     it('for multiple attributes', () => {\n@@ -658,18 +492,10 @@ describe('Runtime i18n', () => {\n         ɵɵi18nAttributes(index, MSG_div_attr);\n       }, null, nbConsts, index);\n \n-      expect(opCodes).toEqual([\n-        0b1,  // bindings mask\n-        6,    // if no update, skip 4\n-        'Hello ',\n-        -1,  // binding index\n-        '!', (index - 1) << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Attr, 'title', null,\n-        0b1,  // bindings mask\n-        6,    // if no update, skip 4\n-        'Hello ',\n-        -1,  // binding index\n-        '!', (index - 1) << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Attr, 'aria-label', null\n-      ]);\n+      expect(opCodes).toEqual(debugMatch([\n+        'if (mask & 0b1) { (lView[0] as Element).setAttribute(\\'title\\', `Hello ${lView[1]}!`); }',\n+        'if (mask & 0b1) { (lView[0] as Element).setAttribute(\\'aria-label\\', `Hello ${lView[1]}!`); }'\n+      ]));\n     });\n   });\n "
        },
        {
            "sha": "988b54b1963e6c31ff7fd9094c0bbafce6b829ce",
            "filename": "packages/core/test/render3/utils.ts",
            "status": "added",
            "additions": 73,
            "deletions": 0,
            "changes": 73,
            "blob_url": "https://github.com/angular/angular/blob/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Ftest%2Frender3%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/3821dc5f6c2e63cd08eac5cf4f898d3f8081af94/packages%2Fcore%2Ftest%2Frender3%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Futils.ts?ref=3821dc5f6c2e63cd08eac5cf4f898d3f8081af94",
            "patch": "@@ -0,0 +1,73 @@\n+\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/** Template string function that can be used to strip indentation from a given string literal. */\n+export function dedent(strings: TemplateStringsArray, ...values: any[]) {\n+  let joinedString = '';\n+  for (let i = 0; i < values.length; i++) {\n+    joinedString += `${strings[i]}${values[i]}`;\n+  }\n+  joinedString += strings[strings.length - 1];\n+  const lines = joinedString.split('\\n');\n+  while (isBlank(lines[0])) {\n+    lines.shift();\n+  }\n+  while (isBlank(lines[lines.length - 1])) {\n+    lines.pop();\n+  }\n+  let minWhitespacePrefix = lines.reduce(\n+      (min, line) => Math.min(min, numOfWhiteSpaceLeadingChars(line)), Number.MAX_SAFE_INTEGER);\n+  return lines.map((line) => line.substring(minWhitespacePrefix)).join('\\n');\n+}\n+\n+/**\n+ * Tests to see if the line is blank.\n+ *\n+ * A blank line is such which contains only whitespace.\n+ * @param text string to test for blank-ness.\n+ */\n+function isBlank(text: string): boolean {\n+  return /^\\s*$/.test(text);\n+}\n+\n+/**\n+ * Returns number of whitespace leading characters.\n+ *\n+ * @param text\n+ */\n+function numOfWhiteSpaceLeadingChars(text: string): number {\n+  return text.match(/^\\s*/)![0].length;\n+}\n+\n+\n+/**\n+ * Jasmine AsymmetricMatcher which can be used to assert `.debug` properties.\n+ *\n+ * ```\n+ * expect(obj).toEqual({\n+ *   create: debugMatch('someValue')\n+ * })\n+ * ```\n+ *\n+ * In the above example it will assert that `obj.create.debug === 'someValue'`.\n+ *\n+ * @param expected Expected value.\n+ */\n+export function debugMatch<T>(expected: T): any {\n+  const matcher = function() {};\n+  let actual: any = null;\n+\n+  matcher.asymmetricMatch = function(objectWithDebug: any) {\n+    return jasmine.matchersUtil.equals(actual = objectWithDebug.debug, expected);\n+  };\n+  matcher.jasmineToString = function() {\n+    return `<${JSON.stringify(actual)} != ${JSON.stringify(expected)}>`;\n+  };\n+  return matcher;\n+}"
        }
    ],
    "stats": {
        "total": 1373,
        "additions": 741,
        "deletions": 632
    }
}