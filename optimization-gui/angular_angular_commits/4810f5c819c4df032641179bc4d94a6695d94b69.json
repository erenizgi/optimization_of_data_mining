{
    "author": "petebacondarwin",
    "message": "ci: remove old compliance tests (#41556)\n\nNow that we can run the new compliance tests on Windows,\nwe can delete the old ones, simplifying and speeding up our CI.\n\nPR Close #41556",
    "sha": "4810f5c819c4df032641179bc4d94a6695d94b69",
    "files": [
        {
            "sha": "3635c4b97f5ca3da99b4cd0c0ce7111214101cb8",
            "filename": "packages/compiler-cli/test/compliance_old/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 36,
            "changes": 36,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2FBUILD.bazel?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,36 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"jasmine_node_test\", \"ts_library\")\n-\n-ts_library(\n-    name = \"test_lib\",\n-    testonly = True,\n-    srcs = glob(\n-        [\"**/*.ts\"],\n-    ),\n-    visibility = [\n-        \":__subpackages__\",\n-    ],\n-    deps = [\n-        \"//packages:types\",\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli\",\n-        \"//packages/compiler-cli/src/ngtsc/file_system\",\n-        \"//packages/compiler-cli/test/compliance_old/mock_compile\",\n-        \"//packages/compiler/test:test_utils\",\n-        \"@npm//typescript\",\n-    ],\n-)\n-\n-jasmine_node_test(\n-    name = \"compliance_old\",\n-    bootstrap = [\"//tools/testing:node_no_angular_es5\"],\n-    data = [\n-        \"//packages/compiler-cli/src/ngtsc/testing/fake_core:npm_package\",\n-    ],\n-    shard_count = 2,\n-    tags = [\n-        \"ivy-only\",\n-    ],\n-    deps = [\n-        \":test_lib\",\n-    ],\n-)"
        },
        {
            "sha": "c383188ac1110562b0b99023d620e8b2cc071b8a",
            "filename": "packages/compiler-cli/test/compliance_old/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2FREADME.md?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,5 +0,0 @@\n-Tests in this directory should be run with:\n-\n-```\n-yarn bazel test --config=ivy  packages/compiler-cli/test/compliance:compliance\n-```\n\\ No newline at end of file"
        },
        {
            "sha": "9cd4bf7687fe8d49c87941baaa2178d026da4bb5",
            "filename": "packages/compiler-cli/test/compliance_old/mock_compile/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fmock_compile%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fmock_compile%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fmock_compile%2FBUILD.bazel?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,19 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"mock_compile\",\n-    testonly = True,\n-    srcs = [\"index.ts\"],\n-    visibility = [\n-        \"//packages/compiler-cli/test/compliance_old:__subpackages__\",\n-    ],\n-    deps = [\n-        \"//packages:types\",\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli\",\n-        \"//packages/compiler-cli/src/ngtsc/core:api\",\n-        \"//packages/compiler-cli/src/ngtsc/file_system\",\n-        \"//packages/compiler/test:test_utils\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "95c50391ead619b431becae6d9c8120f59daf79c",
            "filename": "packages/compiler-cli/test/compliance_old/mock_compile/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 249,
            "changes": 249,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fmock_compile%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fmock_compile%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fmock_compile%2Findex.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,249 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {escapeRegExp} from '@angular/compiler/src/util';\n-import {arrayToMockDir, MockCompilerHost, MockData, MockDirectory, toMockFileArray} from '@angular/compiler/test/aot/test_util';\n-import * as ts from 'typescript';\n-\n-import {NgCompilerOptions} from '../../../src/ngtsc/core/api';\n-import {NodeJSFileSystem, setFileSystem} from '../../../src/ngtsc/file_system';\n-import {NgtscProgram} from '../../../src/ngtsc/program';\n-\n-const IDENTIFIER = /[A-Za-z_$ɵ][A-Za-z0-9_$]*/;\n-const OPERATOR =\n-    /!|\\?|%|\\*|\\/|\\^|&&?|\\|\\|?|\\(|\\)|\\{|\\}|\\[|\\]|:|;|<=?|>=?|={1,3}|!==?|=>|\\+\\+?|--?|@|,|\\.|\\.\\.\\.|`|\\\\'/;\n-const STRING = /'(\\\\'|[^'])*'|\"(\\\\\"|[^\"])*\"/;\n-const BACKTICK_STRING = /\\\\`(([\\s\\S]*?)(\\$\\{[^}]*?\\})?)*?[^\\\\]\\\\`/;\n-const BACKTICK_INTERPOLATION = /(\\$\\{[^}]*\\})/;\n-const NUMBER = /\\d+/;\n-\n-const ELLIPSIS = '…';\n-const TOKEN = new RegExp(\n-    `\\\\s*((${IDENTIFIER.source})|(${BACKTICK_STRING.source})|(${OPERATOR.source})|(${\n-        STRING.source})|${NUMBER.source}|${ELLIPSIS})\\\\s*`,\n-    'y');\n-\n-type Piece = string|RegExp;\n-\n-const SKIP = /(?:.|\\n|\\r)*/;\n-\n-const ERROR_CONTEXT_WIDTH = 30;\n-// Transform the expected output to set of tokens\n-function tokenize(text: string): Piece[] {\n-  // TOKEN.lastIndex is stateful so we cache the `lastIndex` and restore it at the end of the call.\n-  const lastIndex = TOKEN.lastIndex;\n-  TOKEN.lastIndex = 0;\n-\n-  let match: RegExpMatchArray|null;\n-  let tokenizedTextEnd = 0;\n-  const pieces: Piece[] = [];\n-\n-  while ((match = TOKEN.exec(text)) !== null) {\n-    const [fullMatch, token] = match;\n-    if (token === 'IDENT') {\n-      pieces.push(IDENTIFIER);\n-    } else if (token === ELLIPSIS) {\n-      pieces.push(SKIP);\n-    } else if (match = BACKTICK_STRING.exec(token)) {\n-      pieces.push(...tokenizeBackTickString(token));\n-    } else {\n-      pieces.push(token);\n-    }\n-    tokenizedTextEnd += fullMatch.length;\n-  }\n-\n-  if (pieces.length === 0 || tokenizedTextEnd < text.length) {\n-    // The new token that could not be found is located after the\n-    // last tokenized character.\n-    const from = tokenizedTextEnd;\n-    const to = from + ERROR_CONTEXT_WIDTH;\n-    throw Error(\n-        `Invalid test, no token found for \"${text[tokenizedTextEnd]}\" ` +\n-        `(context = '${text.substr(from, to)}...'`);\n-  }\n-  // Reset the lastIndex in case we are in a recursive `tokenize()` call.\n-  TOKEN.lastIndex = lastIndex;\n-\n-  return pieces;\n-}\n-\n-/**\n- * Back-ticks are escaped as \"\\`\" so we must strip the backslashes.\n- * Also the string will likely contain interpolations and if an interpolation holds an\n- * identifier we will need to match that later. So tokenize the interpolation too!\n- */\n-function tokenizeBackTickString(str: string): Piece[] {\n-  const pieces: Piece[] = ['`'];\n-  // Unescape backticks that are inside the backtick string\n-  // (we had to double escape them in the test string so they didn't look like string markers)\n-  str = str.replace(/\\\\\\\\\\\\`/g, '\\\\`');\n-  const backTickPieces = str.slice(2, -2).split(BACKTICK_INTERPOLATION);\n-  backTickPieces.forEach((backTickPiece) => {\n-    if (BACKTICK_INTERPOLATION.test(backTickPiece)) {\n-      // An interpolation so tokenize this expression\n-      pieces.push(...tokenize(backTickPiece));\n-    } else {\n-      // Not an interpolation so just add it as a piece\n-      pieces.push(backTickPiece);\n-    }\n-  });\n-  pieces.push('`');\n-  return pieces;\n-}\n-\n-export function expectEmit(\n-    source: string, expected: string, description: string,\n-    assertIdentifiers?: {[name: string]: RegExp}) {\n-  // turns `// ...` into `…`\n-  // remove `// TODO` comment lines\n-  expected = expected.replace(/\\/\\/\\s*\\.\\.\\./g, ELLIPSIS).replace(/\\/\\/\\s*TODO.*?\\n/g, '');\n-\n-  const pieces = tokenize(expected);\n-  const {regexp, groups} = buildMatcher(pieces);\n-  const matches = source.match(regexp);\n-  if (matches === null) {\n-    let last: number = 0;\n-    for (let i = 1; i < pieces.length; i++) {\n-      const {regexp} = buildMatcher(pieces.slice(0, i));\n-      const m = source.match(regexp);\n-      const expectedPiece = pieces[i - 1] == IDENTIFIER ? '<IDENT>' : pieces[i - 1];\n-      if (!m) {\n-        // display at most `contextLength` characters of the line preceding the error location\n-        const contextLength = 50;\n-        const fullContext = source.substring(source.lastIndexOf('\\n', last) + 1, last);\n-        const context = fullContext.length > contextLength ?\n-            `...${fullContext.substr(-contextLength)}` :\n-            fullContext;\n-        fail(`${description}: Failed to find \"${expectedPiece}\" after \"${context}\" in:\\n'${\n-            source.substr(0, last)}[<---HERE expected \"${expectedPiece}\"]${source.substr(last)}'`);\n-        return;\n-      } else {\n-        last = (m.index || 0) + m[0].length;\n-      }\n-    }\n-    fail(\n-        `Test helper failure: Expected expression failed but the reporting logic could not find where it failed in: ${\n-            source}`);\n-  } else {\n-    if (assertIdentifiers) {\n-      // It might be possible to add the constraints in the original regexp (see `buildMatcher`)\n-      // by transforming the assertion regexps when using anchoring, grouping, back references,\n-      // flags, ...\n-      //\n-      // Checking identifiers after they have matched allows for a simple and flexible\n-      // implementation.\n-      // The overall performance are not impacted when `assertIdentifiers` is empty.\n-      const ids = Object.keys(assertIdentifiers);\n-      for (let i = 0; i < ids.length; i++) {\n-        const id = ids[i];\n-        if (groups.has(id)) {\n-          const name = matches[groups.get(id) as number];\n-          const regexp = assertIdentifiers[id];\n-          if (!regexp.test(name)) {\n-            throw Error(`${description}: The matching identifier \"${id}\" is \"${\n-                name}\" which doesn't match ${regexp}`);\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-const IDENT_LIKE = /^[a-z][A-Z]/;\n-const MATCHING_IDENT = /^\\$.*\\$$/;\n-\n-/*\n- * Builds a regexp that matches the given `pieces`\n- *\n- * It returns:\n- * - the `regexp` to be used to match the generated code,\n- * - the `groups` which maps `$...$` identifier to their position in the regexp matches.\n- */\n-function buildMatcher(pieces: (string|RegExp)[]): {regexp: RegExp, groups: Map<string, number>} {\n-  const results: string[] = [];\n-  let first = true;\n-  let group = 0;\n-\n-  const groups = new Map<string, number>();\n-  for (const piece of pieces) {\n-    if (!first)\n-      results.push(`\\\\s${typeof piece === 'string' && IDENT_LIKE.test(piece) ? '+' : '*'}`);\n-    first = false;\n-    if (typeof piece === 'string') {\n-      if (MATCHING_IDENT.test(piece)) {\n-        const matchGroup = groups.get(piece);\n-        if (!matchGroup) {\n-          results.push('(' + IDENTIFIER.source + ')');\n-          const newGroup = ++group;\n-          groups.set(piece, newGroup);\n-        } else {\n-          results.push(`\\\\${matchGroup}`);\n-        }\n-      } else {\n-        results.push(escapeRegExp(piece));\n-      }\n-    } else {\n-      results.push('(?:' + piece.source + ')');\n-    }\n-  }\n-  return {\n-    regexp: new RegExp(results.join('')),\n-    groups,\n-  };\n-}\n-\n-export function compileFiles(\n-    data: MockDirectory, angularFiles: MockData, options: NgCompilerOptions = {}): {\n-  fileName: string; source: string,\n-}[] {\n-  setFileSystem(new NodeJSFileSystem());\n-  const testFiles = toMockFileArray(data);\n-  const scripts = testFiles.map(entry => entry.fileName);\n-  const angularFilesArray = toMockFileArray(angularFiles);\n-  const files = arrayToMockDir([...testFiles, ...angularFilesArray]);\n-  const mockCompilerHost = new MockCompilerHost(scripts, files);\n-\n-  const program = new NgtscProgram(\n-      scripts, {\n-        target: ts.ScriptTarget.ES2015,\n-        module: ts.ModuleKind.ES2015,\n-        moduleResolution: ts.ModuleResolutionKind.NodeJs,\n-        enableI18nLegacyMessageIdFormat: false,\n-        ...options,\n-      },\n-      mockCompilerHost);\n-  program.emit();\n-  return scripts.map(script => {\n-    const fileName = script.replace(/\\.ts$/, '.js');\n-    const source = mockCompilerHost.readFile(fileName);\n-    return {fileName, source};\n-  });\n-}\n-\n-function doCompile(data: MockDirectory, angularFiles: MockData, options: NgCompilerOptions = {}): {\n-  source: string,\n-} {\n-  const scripts = compileFiles(data, angularFiles, options);\n-  const source = scripts.map(script => script.source).join('\\n');\n-\n-  return {source};\n-}\n-\n-export type CompileFn = typeof doCompile;\n-\n-/**\n- * The actual compile function that will be used to compile the test code.\n- * This can be updated by a test bootstrap script to provide an alternative compile function.\n- */\n-export let compile: CompileFn = doCompile;\n-\n-/**\n- * Update the `compile` exported function to use a new implementation.\n- */\n-export function setCompileFn(compileFn: CompileFn) {\n-  compile = compileFn;\n-}"
        },
        {
            "sha": "ba8cf564b5eb087b6525cbd7729be743b6475cc0",
            "filename": "packages/compiler-cli/test/compliance_old/mock_compiler_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 245,
            "changes": 245,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fmock_compiler_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fmock_compiler_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fmock_compiler_spec.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,245 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-\n-import {setup} from '@angular/compiler/test/aot/test_util';\n-import {compile, expectEmit} from './mock_compile';\n-\n-describe('mock_compiler', () => {\n-  // This produces a MockDirectory of the file needed to compile an Angular application.\n-  // This setup is performed in a beforeAll which populates the map returned.\n-  const angularFiles = setup({\n-    compileAngular: false,\n-    compileFakeCore: true,\n-    compileAnimations: false,\n-  });\n-\n-  describe('compiling', () => {\n-    // To use compile you need to supply the files in a MockDirectory that can be merged\n-    // with a set of \"environment\" files such as the angular files.\n-    it('should be able to compile a simple application', () => {\n-      const files = {\n-        app: {\n-          'hello.component.ts': `\n-            import {Component, Input} from '@angular/core';\n-\n-            @Component({template: 'Hello {{name}}!'})\n-            export class HelloComponent {\n-              @Input() name: string = 'world';\n-            }\n-          `,\n-          'hello.module.ts': `\n-            import {NgModule} from '@angular/core';\n-            import {HelloComponent} from './hello.component';\n-\n-            @NgModule({declarations: [HelloComponent]})\n-            export class HelloModule {}\n-          `\n-        }\n-      };\n-      const result = compile(files, angularFiles);\n-\n-      // result.source contains just the emitted factory declarations regardless of the original\n-      // module.\n-      expect(result.source).toContain('Hello');\n-    });\n-  });\n-\n-  describe('expecting emitted output', () => {\n-    it('should be able to find a simple expression in the output', () => {\n-      const files = {\n-        app: {\n-          'hello.component.ts': `\n-            import {Component, Input} from '@angular/core';\n-\n-            @Component({template: 'Hello {{name}}! Your name as {{name.length}} characters'})\n-            export class HelloComponent {\n-              @Input() name: string = 'world';\n-            }\n-          `,\n-          'hello.module.ts': `\n-            import {NgModule} from '@angular/core';\n-            import {HelloComponent} from './hello.component';\n-\n-            @NgModule({declarations: [HelloComponent]})\n-            export class HelloModule {}\n-          `\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-\n-      // The expression can expected directly.\n-      expectEmit(result.source, 'name.length', 'name length expression not found');\n-\n-      // Whitespace is not significant\n-      expectEmit(\n-          result.source, 'name   \\n\\n   .  \\n    length',\n-          'name length expression not found (whitespace)');\n-    });\n-\n-    it('should throw if the expected output contains unknown characters', () => {\n-      const files = {\n-        app: {\n-          'test.ts': `ɵsayHello();`,\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-\n-      expect(() => {\n-        expectEmit(result.source, `ΔsayHello();`, 'Output does not match.');\n-      }).toThrowError(/Invalid test, no token found for \"Δ\"/);\n-    });\n-\n-    it('should be able to properly handle string literals with escaped quote', () => {\n-      const files = {\n-        app: {\n-          'test.ts': String.raw`const identifier = \"\\\"quoted\\\"\";`,\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-\n-      expect(() => {\n-        expectEmit(result.source, String.raw`const $a$ = \"\\\"quoted\\\"\";`, 'Output does not match.');\n-      }).not.toThrow();\n-    });\n-  });\n-\n-  it('should be able to skip untested regions (… and // ...)', () => {\n-    const files = {\n-      app: {\n-        'hello.component.ts': `\n-          import {Component, Input} from '@angular/core';\n-\n-          @Component({template: 'Hello {{name}}! Your name as {{name.length}} characters'})\n-          export class HelloComponent {\n-            @Input() name: string = 'world';\n-          }\n-        `,\n-        'hello.module.ts': `\n-          import {NgModule} from '@angular/core';\n-          import {HelloComponent} from './hello.component';\n-\n-          @NgModule({declarations: [HelloComponent]})\n-          export class HelloModule {}\n-        `\n-      }\n-    };\n-\n-    const result = compile(files, angularFiles);\n-\n-    // The special character … means anything can be generated between the two sections allowing\n-    // skipping sections of the output that are not under test. The ellipsis unicode char (…) is\n-    // used instead of '...' because '...' is legal JavaScript (the spread operator) and might\n-    // need to be tested. `// ...` could also be used in place of `…`.\n-    expectEmit(result.source, 'ctx.name … ctx.name.length', 'could not find correct length access');\n-    expectEmit(\n-        result.source, 'ctx.name // ... ctx.name.length', 'could not find correct length access');\n-  });\n-\n-  it('should be able to skip TODO comments (// TODO)', () => {\n-    const files = {\n-      app: {\n-        'hello.component.ts': `\n-          import {Component, Input} from '@angular/core';\n-\n-          @Component({template: 'Hello!'})\n-          export class HelloComponent { }\n-        `,\n-        'hello.module.ts': `\n-          import {NgModule} from '@angular/core';\n-          import {HelloComponent} from './hello.component';\n-\n-          @NgModule({declarations: [HelloComponent]})\n-          export class HelloModule {}\n-        `\n-      }\n-    };\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(\n-        result.source, `\n-    // TODO: this comment should not be taken into account\n-    $r3$.ɵɵtext(0, \"Hello!\");\n-    // TODO: this comment should not be taken into account\n-    `,\n-        'todo comments should be ignored');\n-  });\n-\n-\n-  it('should be able to enforce consistent identifiers', () => {\n-    const files = {\n-      app: {\n-        'hello.component.ts': `\n-          import {Component, Input} from '@angular/core';\n-\n-          @Component({template: 'Hello {{name}}! Your name as {{name.length}} characters'})\n-          export class HelloComponent {\n-            @Input() name: string = 'world';\n-          }\n-        `,\n-        'hello.module.ts': `\n-          import {NgModule} from '@angular/core';\n-          import {HelloComponent} from './hello.component';\n-\n-          @NgModule({declarations: [HelloComponent]})\n-          export class HelloModule {}\n-        `\n-      }\n-    };\n-\n-    const result = compile(files, angularFiles);\n-\n-    // IDENT can be used a wild card for any identifier\n-    expectEmit(result.source, 'IDENT.name', 'could not find context access');\n-\n-    // $<ident>$ can be used as a wild-card but all the content matched by the identifiers must\n-    // match each other.\n-    // This is useful if the code generator is free to invent a name but should use the name\n-    // consistently.\n-    expectEmit(\n-        result.source, '$ctx$.$name$ … $ctx$.$name$.length',\n-        'could not find correct length access');\n-  });\n-\n-  it('should be able to enforce that identifiers match a regexp', () => {\n-    const files = {\n-      app: {\n-        'hello.component.ts': `\n-          import {Component, Input} from '@angular/core';\n-\n-          @Component({template: 'Hello {{name}}! Your name as {{name.length}} characters'})\n-          export class HelloComponent {\n-            @Input() name: string = 'world';\n-          }\n-        `,\n-        'hello.module.ts': `\n-          import {NgModule} from '@angular/core';\n-          import {HelloComponent} from './hello.component';\n-\n-          @NgModule({declarations: [HelloComponent]})\n-          export class HelloModule {}\n-        `\n-      }\n-    };\n-\n-    const result = compile(files, angularFiles);\n-\n-    // Pass: `$n$` ends with `ME` in the generated code\n-    expectEmit(result.source, '$ctx$.$n$ … $ctx$.$n$.length', 'Match names', {'$n$': /ME$/i});\n-\n-    // Fail: `$n$` does not match `/(not)_(\\1)/` in the generated code\n-    expect(() => {\n-      expectEmit(\n-          result.source, '$ctx$.$n$ … $ctx$.$n$.length', 'Match names', {'$n$': /(not)_(\\1)/});\n-    }).toThrowError(/\"\\$n\\$\" is \"name\" which doesn't match \\/\\(not\\)_\\(\\\\1\\)\\//);\n-  });\n-});"
        },
        {
            "sha": "3953c78dc90f351ef4a4fc2e6f36071c6c718aaf",
            "filename": "packages/compiler-cli/test/compliance_old/prelink/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 41,
            "changes": 41,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fprelink%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fprelink%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fprelink%2FBUILD.bazel?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,41 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"jasmine_node_test\", \"ts_library\")\n-\n-ts_library(\n-    name = \"prelink_bootstrap\",\n-    testonly = True,\n-    srcs = [\"bootstrap.ts\"],\n-    deps = [\n-        \"//packages:types\",\n-        \"//packages/compiler-cli/linker\",\n-        \"//packages/compiler-cli/linker/babel\",\n-        \"//packages/compiler-cli/src/ngtsc/file_system/testing\",\n-        \"//packages/compiler-cli/src/ngtsc/logging/testing\",\n-        \"//packages/compiler-cli/test/compliance_old/mock_compile\",\n-        \"@npm//@babel/core\",\n-        \"@npm//@babel/generator\",\n-        \"@npm//@babel/template\",\n-        \"@npm//@babel/types\",\n-        \"@npm//@types/babel__core\",\n-        \"@npm//@types/babel__generator\",\n-        \"@npm//@types/babel__template\",\n-        \"@npm//typescript\",\n-    ],\n-)\n-\n-jasmine_node_test(\n-    name = \"prelink\",\n-    bootstrap = [\n-        \"//tools/testing:node_no_angular_es5\",\n-        \":prelink_bootstrap_es5\",\n-    ],\n-    data = [\n-        \"//packages/compiler-cli/src/ngtsc/testing/fake_core:npm_package\",\n-    ],\n-    shard_count = 4,\n-    tags = [\n-        \"ivy-only\",\n-    ],\n-    deps = [\n-        \"//packages/compiler-cli/test/compliance_old:test_lib\",\n-    ],\n-)"
        },
        {
            "sha": "3830156273e4fcd72e8a3a2abf6946c93c5a5519",
            "filename": "packages/compiler-cli/test/compliance_old/prelink/bootstrap.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 79,
            "changes": 79,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fprelink%2Fbootstrap.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fprelink%2Fbootstrap.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fprelink%2Fbootstrap.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,79 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {PluginObj, transformSync} from '@babel/core';\n-import * as ts from 'typescript';\n-\n-import {needsLinking} from '../../../linker';\n-import {createEs2015LinkerPlugin} from '../../../linker/babel';\n-import {MockFileSystemNative} from '../../../src/ngtsc/file_system/testing';\n-import {MockLogger} from '../../../src/ngtsc/logging/testing';\n-import {compileFiles, CompileFn, setCompileFn} from '../mock_compile';\n-\n-/**\n- * A function to compile the given code in two steps:\n- *\n- * - first compile the code in partial mode\n- * - then compile the partially compiled code using the linker\n- *\n- * This should produce the same output as the full AOT compilation\n- */\n-const linkedCompile: CompileFn = (data, angularFiles, options) => {\n-  if (options !== undefined && options.target !== undefined &&\n-      options.target < ts.ScriptTarget.ES2015) {\n-    pending('ES5 is not supported in the partial compilation tests');\n-    throw new Error('ES5 is not supported in the partial compilation tests');\n-  }\n-\n-  const compiledFiles = compileFiles(data, angularFiles, {...options, compilationMode: 'partial'});\n-  const fileSystem = new MockFileSystemNative();\n-  const logger = new MockLogger();\n-  const linkerPlugin = createEs2015LinkerPlugin({\n-    fileSystem,\n-    logger,\n-    // enableI18nLegacyMessageIdFormat defaults to false in `compileFiles`.\n-    enableI18nLegacyMessageIdFormat: false,\n-    ...options,\n-  });\n-\n-  const source =\n-      compiledFiles\n-          .map(file => applyLinker({path: file.fileName, source: file.source}, linkerPlugin))\n-          .join('\\n');\n-\n-  return {source};\n-};\n-\n-/**\n- * Runs the provided code through the Babel linker plugin, if the file has the .js extension.\n- *\n- * @param file The absolute file path and its source to be transformed using the linker.\n- * @param linkerPlugin The linker plugin to apply.\n- * @returns The file's source content, which has been transformed using the linker if necessary.\n- */\n-function applyLinker(file: {path: string; source: string}, linkerPlugin: PluginObj): string {\n-  if (!file.path.endsWith('.js') || !needsLinking(file.path, file.source)) {\n-    return file.source;\n-  }\n-  const result = transformSync(file.source, {\n-    filename: file.path,\n-    plugins: [linkerPlugin],\n-    parserOpts: {sourceType: 'unambiguous'},\n-  });\n-  if (result === null) {\n-    throw fail('Babel transform did not have output');\n-  }\n-  if (result.code == null) {\n-    throw fail('Babel transform result does not have any code');\n-  }\n-  return result.code;\n-}\n-\n-// Update the function that will do the compiling with this specialised version that\n-// runs the prelink and postlink parts of AOT compilation, to check it produces the\n-// same result as a normal full AOT compile.\n-setCompileFn(linkedCompile);"
        },
        {
            "sha": "8b99bf37ada22173c166669dce8f8b5812e3a272",
            "filename": "packages/compiler-cli/test/compliance_old/r3_compiler_compliance_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 3356,
            "changes": 3356,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_compiler_compliance_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_compiler_compliance_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_compiler_compliance_spec.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d"
        },
        {
            "sha": "206f4ff1b4e0b9ce492918f4260d09f03c440bb4",
            "filename": "packages/compiler-cli/test/compliance_old/r3_view_compiler_binding_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 1503,
            "changes": 1503,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_binding_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_binding_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_binding_spec.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,1503 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {AttributeMarker} from '@angular/compiler/src/core';\n-import {MockDirectory, setup} from '@angular/compiler/test/aot/test_util';\n-import {compile, expectEmit} from './mock_compile';\n-\n-describe('compiler compliance: bindings', () => {\n-  const angularFiles = setup({\n-    compileAngular: false,\n-    compileFakeCore: true,\n-    compileAnimations: false,\n-  });\n-\n-  describe('text bindings', () => {\n-    it('should generate interpolation instruction', () => {\n-      const files: MockDirectory = {\n-        app: {\n-          'example.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-          @Component({\n-            selector: 'my-component',\n-            template: \\`\n-              <div>Hello {{ name }}</div>\\`\n-          })\n-          export class MyComponent {\n-            name = 'World';\n-          }\n-          @NgModule({declarations: [MyComponent]})\n-          export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const template = `\n-      template:function MyComponent_Template(rf, $ctx$){\n-        if (rf & 1) {\n-          $i0$.ɵɵelementStart(0, \"div\");\n-          $i0$.ɵɵtext(1);\n-          $i0$.ɵɵelementEnd();\n-        }\n-        if (rf & 2) {\n-          $r3$.ɵɵadvance(1);\n-          $i0$.ɵɵtextInterpolate1(\"Hello \", $ctx$.name, \"\");\n-        }\n-      }`;\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect interpolated text binding');\n-    });\n-  });\n-\n-  describe('property bindings', () => {\n-    it('should generate bind instruction', () => {\n-      const files: MockDirectory = {\n-        app: {\n-          'example.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-\n-          @Component({\n-            selector: 'my-app',\n-            template: '<a [title]=\"title\"></a>'\n-          })\n-          export class MyComponent {\n-            title = 'Hello World';\n-          }\n-\n-          @NgModule({declarations: [MyComponent]})\n-          export class MyModule {}`\n-        }\n-      };\n-\n-      const template = `\n-      …\n-      consts: [[${AttributeMarker.Bindings}, \"title\"]],\n-      template:function MyComponent_Template(rf, $ctx$){\n-        if (rf & 1) {\n-          $i0$.ɵɵelement(0, \"a\", 0);\n-        }\n-        if (rf & 2) {\n-          $i0$.ɵɵproperty(\"title\", $ctx$.title);\n-        }\n-      }`;\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect property binding');\n-    });\n-\n-    it('should generate interpolation instruction for {{...}} bindings', () => {\n-      const files: MockDirectory = {\n-        app: {\n-          'example.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-          @Component({\n-            selector: 'my-component',\n-            template: \\`\n-              <a title=\"Hello {{name}}\"></a>\\`\n-          })\n-          export class MyComponent {\n-            name = 'World';\n-          }\n-          @NgModule({declarations: [MyComponent]})\n-          export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const template = `\n-      …\n-      consts: [[${AttributeMarker.Bindings}, \"title\"]],\n-      template:function MyComponent_Template(rf, $ctx$){\n-        if (rf & 1) {\n-          $i0$.ɵɵelement(0, \"a\", 0);\n-        }\n-        if (rf & 2) {\n-          $i0$.ɵɵpropertyInterpolate1(\"title\", \"Hello \", $ctx$.name, \"\");\n-        }\n-      }`;\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect interpolated property binding');\n-    });\n-\n-    it('should ignore empty bindings', () => {\n-      const files: MockDirectory = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-            @Component({\n-              selector: 'test',\n-              template: '<div [someProp]></div>'\n-            })\n-            class FooCmp {}\n-          `\n-        }\n-      };\n-      const result = compile(files, angularFiles);\n-      expect(result.source).not.toContain('i0.ɵɵproperty');\n-    });\n-\n-    it('should not remap property names whose names do not correspond to their attribute names',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`\n-                  <label [for]=\"forValue\"></label>\\`\n-              })\n-              export class MyComponent {\n-                forValue = 'some-input';\n-              }\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-           }\n-         };\n-\n-         const template = `\n-      consts: [[${AttributeMarker.Bindings}, \"for\"]]\n-\n-      // ...\n-\n-      function MyComponent_Template(rf, ctx) {\n-        if (rf & 1) {\n-            $i0$.ɵɵelement(0, \"label\", 0);\n-        }\n-        if (rf & 2) {\n-            $i0$.ɵɵproperty(\"for\", ctx.forValue);\n-        }\n-      }`;\n-\n-         const result = compile(files, angularFiles);\n-\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-\n-    it('should emit temporary evaluation within the binding expression for in-order execution',\n-       () => {\n-         // https://github.com/angular/angular/issues/37194\n-         // Verifies that temporary expressions used for expressions with potential side-effects in\n-         // the LHS of a safe navigation access are emitted within the binding expression itself, to\n-         // ensure that these temporaries are evaluated during the evaluation of the binding. This\n-         // is important for when the LHS contains a pipe, as pipe evaluation depends on the current\n-         // binding index.\n-         const files = {\n-           app: {\n-             'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: '<button [title]=\"myTitle\" [id]=\"(auth()?.identity() | async)?.id\" [tabindex]=\"1\"></button>'\n-            })\n-            export class MyComponent {\n-              myTitle = 'hello';\n-              auth?: () => { identity(): any; };\n-            }`\n-           }\n-         };\n-\n-         const result = compile(files, angularFiles);\n-         const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              let $tmp0$ = null;\n-              $r3$.ɵɵproperty(\"title\", ctx.myTitle)(\"id\", ($tmp0$ = $r3$.ɵɵpipeBind1(1, 3, ($tmp0$ = ctx.auth()) == null ? null : $tmp0$.identity())) == null ? null : $tmp0$.id)(\"tabindex\", 1);\n-            }\n-          }\n-        `;\n-\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-\n-    it('should chain multiple property bindings into a single instruction', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: '<button [title]=\"myTitle\" [id]=\"buttonId\" [tabindex]=\"1\"></button>'\n-            })\n-            export class MyComponent {\n-              myTitle = 'hello';\n-              buttonId = 'special-button';\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵproperty(\"title\", ctx.myTitle)(\"id\", ctx.buttonId)(\"tabindex\", 1);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain property bindings in the presence of other bindings', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: '<button [title]=\"1\" [attr.id]=\"2\" [tabindex]=\"3\" aria-label=\"{{1 + 3}}\"></button>'\n-            })\n-            export class MyComponent {}`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵpropertyInterpolate(\"aria-label\", 1 + 3);\n-              $r3$.ɵɵproperty(\"title\", 1)(\"tabindex\", 3);\n-              $r3$.ɵɵattribute(\"id\", 2);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should not add interpolated properties to the property instruction chain', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: '<button [title]=\"1\" [id]=\"2\" tabindex=\"{{0 + 3}}\" aria-label=\"hello-{{1 + 3}}-{{2 + 3}}\"></button>'\n-            })\n-            export class MyComponent {}`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵpropertyInterpolate(\"tabindex\", 0 + 3);\n-              $r3$.ɵɵpropertyInterpolate2(\"aria-label\", \"hello-\", 1 + 3, \"-\", 2 + 3, \"\");\n-              $r3$.ɵɵproperty(\"title\", 1)(\"id\", 2);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain synthetic property bindings together with regular property bindings', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <button\n-                  [title]=\"myTitle\"\n-                  [@expand]=\"expansionState\"\n-                  [tabindex]=\"1\"\n-                  [@fade]=\"'out'\"></button>\n-                \\`\n-            })\n-            export class MyComponent {\n-              expansionState = 'expanded';\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵproperty(\"title\", ctx.myTitle)(\"@expand\", ctx.expansionState)(\"tabindex\", 1)(\"@fade\", \"out\");\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain multiple property bindings on an ng-template', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: '<ng-template [title]=\"myTitle\" [id]=\"buttonId\" [tabindex]=\"1\"></ng-template>'\n-            })\n-            export class MyComponent {\n-              myTitle = 'hello';\n-              buttonId = 'custom-id';\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵproperty(\"title\", ctx.myTitle)(\"id\", ctx.buttonId)(\"tabindex\", 1);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain multiple property bindings when there are multiple elements', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <button [title]=\"myTitle\" [id]=\"buttonId\" [tabindex]=\"1\"></button>\n-                <span [id]=\"1\" [title]=\"'hello'\" [someProp]=\"1 + 2\"></span>\n-                <custom-element [prop]=\"'one'\" [otherProp]=\"2\"></custom-element>\n-              \\`\n-            })\n-            export class MyComponent {\n-              myTitle = 'hello';\n-              buttonId = 'special-button';\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵproperty(\"title\", ctx.myTitle)(\"id\", ctx.buttonId)(\"tabindex\", 1);\n-              $r3$.ɵɵadvance(1);\n-              $r3$.ɵɵproperty(\"id\", 1)(\"title\", \"hello\")(\"someProp\", 1 + 2);\n-              $r3$.ɵɵadvance(1);\n-              $r3$.ɵɵproperty(\"prop\", \"one\")(\"otherProp\", 2);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain multiple property bindings when there are child elements', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <button [title]=\"myTitle\" [id]=\"buttonId\" [tabindex]=\"1\">\n-                  <span [id]=\"1\" [title]=\"'hello'\" [someProp]=\"1 + 2\"></span>\n-                </button>\\`\n-            })\n-            export class MyComponent {\n-              myTitle = 'hello';\n-              buttonId = 'special-button';\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵproperty(\"title\", ctx.myTitle)(\"id\", ctx.buttonId)(\"tabindex\", 1);\n-              $r3$.ɵɵadvance(1);\n-              $r3$.ɵɵproperty(\"id\", 1)(\"title\", \"hello\")(\"someProp\", 1 + 2);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-  });\n-\n-  describe('attribute bindings', () => {\n-    it('should chain multiple attribute bindings into a single instruction', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <button [attr.title]=\"myTitle\" attr.id=\"{{buttonId}}\" [attr.tabindex]=\"1\"></button>\n-              \\`\n-            })\n-            export class MyComponent {\n-              myTitle = 'hello';\n-              buttonId = 'special-button';\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵattribute(\"title\", ctx.myTitle)(\"id\", ctx.buttonId)(\"tabindex\", 1);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain multiple single-interpolation attribute bindings into one instruction', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <button attr.title=\"{{myTitle}}\" attr.id=\"{{buttonId}}\" attr.tabindex=\"{{1}}\"></button>\n-              \\`\n-            })\n-            export class MyComponent {\n-              myTitle = 'hello';\n-              buttonId = 'special-button';\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵattribute(\"title\", ctx.myTitle)(\"id\", ctx.buttonId)(\"tabindex\", 1);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain attribute bindings in the presence of other bindings', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <button [attr.title]=\"1\" [id]=\"2\" [attr.tabindex]=\"3\" attr.aria-label=\"prefix-{{1 + 3}}\">\n-                </button>\n-              \\`\n-            })\n-            export class MyComponent {}`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵattributeInterpolate1(\"aria-label\", \"prefix-\", 1 + 3, \"\");\n-              $r3$.ɵɵproperty(\"id\", 2);\n-              $r3$.ɵɵattribute(\"title\", 1)(\"tabindex\", 3);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should not add interpolated attributes to the attribute instruction chain', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <button\n-                  [attr.title]=\"1\"\n-                  [attr.id]=\"2\"\n-                  attr.tabindex=\"prefix-{{0 + 3}}\"\n-                  attr.aria-label=\"hello-{{1 + 3}}-{{2 + 3}}\"></button>\\`\n-            })\n-            export class MyComponent {}`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵattributeInterpolate1(\"tabindex\", \"prefix-\", 0 + 3, \"\");\n-              $r3$.ɵɵattributeInterpolate2(\"aria-label\", \"hello-\", 1 + 3, \"-\", 2 + 3, \"\");\n-              $r3$.ɵɵattribute(\"title\", 1)(\"id\", 2);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain multiple attribute bindings when there are multiple elements', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <button [attr.title]=\"myTitle\" [attr.id]=\"buttonId\" [attr.tabindex]=\"1\"></button>\n-                <span [attr.id]=\"1\" [attr.title]=\"'hello'\" [attr.some-attr]=\"1 + 2\"></span>\n-                <custom-element [attr.some-attr]=\"'one'\" [attr.some-other-attr]=\"2\"></custom-element>\n-              \\`\n-            })\n-            export class MyComponent {\n-              myTitle = 'hello';\n-              buttonId = 'special-button';\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵattribute(\"title\", ctx.myTitle)(\"id\", ctx.buttonId)(\"tabindex\", 1);\n-              $r3$.ɵɵadvance(1);\n-              $r3$.ɵɵattribute(\"id\", 1)(\"title\", \"hello\")(\"some-attr\", 1 + 2);\n-              $r3$.ɵɵadvance(1);\n-              $r3$.ɵɵattribute(\"some-attr\", \"one\")(\"some-other-attr\", 2);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain multiple attribute bindings when there are child elements', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <button [attr.title]=\"myTitle\" [attr.id]=\"buttonId\" [attr.tabindex]=\"1\">\n-                  <span [attr.id]=\"1\" [attr.title]=\"'hello'\" [attr.some-attr]=\"1 + 2\"></span>\n-                </button>\\`\n-            })\n-            export class MyComponent {\n-              myTitle = 'hello';\n-              buttonId = 'special-button';\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵattribute(\"title\", ctx.myTitle)(\"id\", ctx.buttonId)(\"tabindex\", 1);\n-              $r3$.ɵɵadvance(1);\n-              $r3$.ɵɵattribute(\"id\", 1)(\"title\", \"hello\")(\"some-attr\", 1 + 2);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should exclude attribute bindings from the attributes array', () => {\n-      const files: MockDirectory = {\n-        app: {\n-          'example.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-\n-          @Component({\n-            selector: 'my-app',\n-            template: \\`<a\n-              target=\"_blank\"\n-              [title]=\"1\"\n-              [attr.foo]=\"'one'\"\n-              (customEvent)=\"doThings()\"\n-              [attr.bar]=\"'two'\"\n-              [id]=\"2\"\n-              aria-label=\"link\"\n-              [attr.baz]=\"three\"></a>\\`\n-          })\n-          export class MyComponent {\n-            doThings() {}\n-          }\n-\n-          @NgModule({declarations: [MyComponent]})\n-          export class MyModule {}`\n-        }\n-      };\n-\n-      const template = `\n-        consts: [[\"target\", \"_blank\", \"aria-label\", \"link\", ${\n-          AttributeMarker.Bindings}, \"title\", \"id\", \"customEvent\"]],\n-        …\n-      `;\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect attribute array');\n-    });\n-  });\n-\n-  describe('host bindings', () => {\n-    it('should support host bindings', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Directive, HostBinding, NgModule} from '@angular/core';\n-\n-            @Directive({selector: '[hostBindingDir]'})\n-            export class HostBindingDir {\n-              @HostBinding('id') dirId = 'some id';\n-            }\n-\n-            @NgModule({declarations: [HostBindingDir]})\n-            export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const HostBindingDirDeclaration = `\n-      HostBindingDir.ɵdir = /*@__PURE__*/ $r3$.ɵɵdefineDirective({\n-        type: HostBindingDir,\n-        selectors: [[\"\", \"hostBindingDir\", \"\"]],\n-          hostVars: 1,\n-          hostBindings: function HostBindingDir_HostBindings(rf, ctx) {\n-            if (rf & 2) {\n-              $r3$.ɵɵhostProperty(\"id\", ctx.dirId);\n-            }\n-          }\n-        });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      const source = result.source;\n-\n-      expectEmit(source, HostBindingDirDeclaration, 'Invalid host binding code');\n-    });\n-\n-    it('should support host bindings with temporary expressions', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Directive, NgModule} from '@angular/core';\n-\n-            @Directive({\n-              selector: '[hostBindingDir]',\n-              host: {'[id]': 'getData()?.id'}\n-            })\n-            export class HostBindingDir {\n-              getData?: () => { id: number };\n-            }\n-\n-            @NgModule({declarations: [HostBindingDir]})\n-            export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const HostBindingDirDeclaration = `\n-      HostBindingDir.ɵdir = /*@__PURE__*/ $r3$.ɵɵdefineDirective({\n-        type: HostBindingDir,\n-        selectors: [[\"\", \"hostBindingDir\", \"\"]],\n-          hostVars: 1,\n-          hostBindings: function HostBindingDir_HostBindings(rf, ctx) {\n-            if (rf & 2) {\n-              let $tmp0$ = null;\n-              $r3$.ɵɵhostProperty(\"id\", ($tmp0$ = ctx.getData()) == null ? null : $tmp0$.id);\n-            }\n-          }\n-        });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      const source = result.source;\n-\n-      expectEmit(source, HostBindingDirDeclaration, 'Invalid host binding code');\n-    });\n-\n-    it('should support host bindings with pure functions', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component, NgModule} from '@angular/core';\n-\n-            @Component({\n-              selector: 'host-binding-comp',\n-              host: {\n-                '[id]': '[\"red\", id]'\n-              },\n-              template: ''\n-            })\n-            export class HostBindingComp {\n-              id = 'some id';\n-            }\n-\n-            @NgModule({declarations: [HostBindingComp]})\n-            export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const HostBindingCompDeclaration = `\n-        const $ff$ = function ($v$) { return [\"red\", $v$]; };\n-        …\n-        HostBindingComp.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-          type: HostBindingComp,\n-          selectors: [[\"host-binding-comp\"]],\n-          hostVars: 3,\n-          hostBindings: function HostBindingComp_HostBindings(rf, ctx) {\n-            if (rf & 2) {\n-              $r3$.ɵɵhostProperty(\"id\", $r3$.ɵɵpureFunction1(1, $ff$, ctx.id));\n-            }\n-          },\n-          decls: 0,\n-          vars: 0,\n-          template: function HostBindingComp_Template(rf, ctx) {},\n-          encapsulation: 2\n-        });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      const source = result.source;\n-\n-      expectEmit(source, HostBindingCompDeclaration, 'Invalid host binding code');\n-    });\n-\n-    it('should support host attribute bindings', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Directive, NgModule} from '@angular/core';\n-\n-            @Directive({\n-              selector: '[hostAttributeDir]',\n-              host: {\n-                '[attr.required]': 'required'\n-              }\n-            })\n-            export class HostAttributeDir {\n-              required = true;\n-            }\n-\n-            @NgModule({declarations: [HostAttributeDir]})\n-            export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const HostAttributeDirDeclaration = `\n-        HostAttributeDir.ɵdir = /*@__PURE__*/ $r3$.ɵɵdefineDirective({\n-          type: HostAttributeDir,\n-          selectors: [[\"\", \"hostAttributeDir\", \"\"]],\n-          hostVars: 1,\n-          hostBindings: function HostAttributeDir_HostBindings(rf, ctx) {\n-            if (rf & 2) {\n-              $r3$.ɵɵattribute(\"required\", ctx.required);\n-            }\n-          }\n-        });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      const source = result.source;\n-\n-      expectEmit(source, HostAttributeDirDeclaration, 'Invalid host attribute code');\n-    });\n-\n-    it('should support host attributes', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Directive, NgModule} from '@angular/core';\n-\n-            @Directive({\n-              selector: '[hostAttributeDir]',\n-              host: {\n-                'aria-label': 'label'\n-              }\n-            })\n-            export class HostAttributeDir {\n-            }\n-\n-            @NgModule({declarations: [HostAttributeDir]})\n-            export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const HostAttributeDirDeclaration = `\n-        HostAttributeDir.ɵdir = /*@__PURE__*/ $r3$.ɵɵdefineDirective({\n-          type: HostAttributeDir,\n-          selectors: [[\"\", \"hostAttributeDir\", \"\"]],\n-          hostAttrs: [\"aria-label\", \"label\"]\n-        });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      const source = result.source;\n-\n-      expectEmit(source, HostAttributeDirDeclaration, 'Invalid host attribute code');\n-    });\n-\n-    it('should support host attributes together with host classes and styles', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component, Directive, NgModule} from '@angular/core';\n-\n-            @Component({\n-              selector: 'my-host-attribute-component',\n-              template: \"...\",\n-              host: {\n-                'title': 'hello there from component',\n-                'style': 'opacity:1'\n-              }\n-            })\n-            export class HostAttributeComp {\n-            }\n-\n-            @Directive({\n-              selector: '[hostAttributeDir]',\n-              host: {\n-                'style': 'width: 200px; height: 500px',\n-                '[style.opacity]': \"true\",\n-                'class': 'one two',\n-                '[class.three]': \"true\",\n-                'title': 'hello there from directive',\n-              }\n-            })\n-            export class HostAttributeDir {\n-            }\n-\n-            @NgModule({declarations: [HostAttributeComp, HostAttributeDir]})\n-            export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const CompAndDirDeclaration = `\n-        HostAttributeComp.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-          type: HostAttributeComp,\n-          selectors: [[\"my-host-attribute-component\"]],\n-          hostAttrs: [\"title\", \"hello there from component\", ${\n-          AttributeMarker.Styles}, \"opacity\", \"1\"],\n-        …\n-        HostAttributeDir.ɵdir = /*@__PURE__*/ $r3$.ɵɵdefineDirective({\n-          type: HostAttributeDir,\n-          selectors: [[\"\", \"hostAttributeDir\", \"\"]],\n-          hostAttrs: [\"title\", \"hello there from directive\", ${\n-          AttributeMarker.Classes}, \"one\", \"two\", ${\n-          AttributeMarker.Styles}, \"width\", \"200px\", \"height\", \"500px\"],\n-          hostVars: 4,\n-          hostBindings: function HostAttributeDir_HostBindings(rf, ctx) {\n-            …\n-          }\n-    `;\n-\n-      const result = compile(files, angularFiles);\n-      const source = result.source;\n-      expectEmit(source, CompAndDirDeclaration, 'Invalid host attribute code');\n-    });\n-\n-    it('should chain multiple host property bindings into a single instruction', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Directive} from '@angular/core';\n-\n-            @Directive({\n-              selector: '[my-dir]',\n-              host: {\n-                '[title]': 'myTitle',\n-                '[tabindex]': '1',\n-                '[id]': 'myId'\n-              }\n-            })\n-            export class MyDirective {\n-              myTitle = 'hello';\n-              myId = 'special-directive';\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          hostBindings: function MyDirective_HostBindings(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵhostProperty(\"title\", ctx.myTitle)(\"tabindex\", 1)(\"id\", ctx.myId);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain both host properties in the decorator and on the class', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Directive, HostBinding} from '@angular/core';\n-\n-            @Directive({\n-              selector: '[my-dir]',\n-              host: {\n-                '[tabindex]': '1'\n-              }\n-            })\n-            export class MyDirective {\n-              @HostBinding('title')\n-              myTitle = 'hello';\n-\n-              @HostBinding('id')\n-              myId = 'special-directive';\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          hostBindings: function MyDirective_HostBindings(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵhostProperty(\"tabindex\", 1)(\"title\", ctx.myTitle)(\"id\", ctx.myId);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain multiple host property bindings in the presence of other bindings', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Directive} from '@angular/core';\n-\n-            @Directive({\n-              selector: '[my-dir]',\n-              host: {\n-                '[title]': '\"my title\"',\n-                '[attr.tabindex]': '1',\n-                '[id]': '\"my-id\"'\n-              }\n-            })\n-            export class MyDirective {}`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          hostBindings: function MyDirective_HostBindings(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵhostProperty(\"title\", \"my title\")(\"id\", \"my-id\");\n-              $r3$.ɵɵattribute(\"tabindex\", 1);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain multiple synthetic properties into a single instruction call', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Directive} from '@angular/core';\n-\n-            @Directive({\n-              selector: '[my-dir]',\n-              host: {\n-                '[@expand]': 'expandedState',\n-                '[@fadeOut]': 'true',\n-                '[@shrink]': 'isSmall'\n-              }\n-            })\n-            export class MyDirective {\n-              expandedState = 'collapsed';\n-              isSmall = true;\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-        …\n-        hostBindings: function MyDirective_HostBindings(rf, ctx) {\n-          …\n-          if (rf & 2) {\n-            $r3$.ɵɵsyntheticHostProperty(\"@expand\", ctx.expandedState)(\"@fadeOut\", true)(\"@shrink\", ctx.isSmall);\n-          }\n-        }\n-      `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain multiple host attribute bindings into a single instruction', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Directive} from '@angular/core';\n-\n-            @Directive({\n-              selector: '[my-dir]',\n-              host: {\n-                '[attr.title]': 'myTitle',\n-                '[attr.tabindex]': '1',\n-                '[attr.id]': 'myId'\n-              }\n-            })\n-            export class MyDirective {\n-              myTitle = 'hello';\n-              myId = 'special-directive';\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          hostBindings: function MyDirective_HostBindings(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵattribute(\"title\", ctx.myTitle)(\"tabindex\", 1)(\"id\", ctx.myId);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain both host attributes in the decorator and on the class', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Directive, HostBinding} from '@angular/core';\n-\n-            @Directive({\n-              selector: '[my-dir]',\n-              host: {\n-                '[attr.tabindex]': '1'\n-              }\n-            })\n-            export class MyDirective {\n-              @HostBinding('attr.title')\n-              myTitle = 'hello';\n-\n-              @HostBinding('attr.id')\n-              myId = 'special-directive';\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          hostBindings: function MyDirective_HostBindings(rf, ctx) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵattribute(\"tabindex\", 1)(\"title\", ctx.myTitle)(\"id\", ctx.myId);\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain multiple host attribute bindings in the presence of other bindings', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Directive} from '@angular/core';\n-\n-            @Directive({\n-              selector: '[my-dir]',\n-              host: {\n-                '[attr.title]': '\"my title\"',\n-                '[tabindex]': '1',\n-                '[attr.id]': '\"my-id\"'\n-              }\n-            })\n-            export class MyDirective {}`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-            …\n-            hostBindings: function MyDirective_HostBindings(rf, ctx) {\n-              …\n-              if (rf & 2) {\n-                $r3$.ɵɵhostProperty(\"tabindex\", 1);\n-                $r3$.ɵɵattribute(\"title\", \"my title\")(\"id\", \"my-id\");\n-              }\n-            }\n-          `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain multiple host listeners into a single instruction', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Directive, HostListener} from '@angular/core';\n-\n-            @Directive({\n-              selector: '[my-dir]',\n-              host: {\n-                '(mousedown)': 'mousedown()',\n-                '(mouseup)': 'mouseup()',\n-              }\n-            })\n-            export class MyDirective {\n-              mousedown() {}\n-              mouseup() {}\n-\n-              @HostListener('click')\n-              click() {}\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          hostBindings: function MyDirective_HostBindings(rf, ctx) {\n-            if (rf & 1) {\n-              $r3$.ɵɵlistener(\"mousedown\", function MyDirective_mousedown_HostBindingHandler() { return ctx.mousedown(); })(\"mouseup\", function MyDirective_mouseup_HostBindingHandler() { return ctx.mouseup(); })(\"click\", function MyDirective_click_HostBindingHandler() { return ctx.click(); });\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain multiple synthetic host listeners into a single instruction', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component, HostListener} from '@angular/core';\n-\n-            @Component({\n-              selector: 'my-comp',\n-              template: '',\n-              host: {\n-                '(@animation.done)': 'done()',\n-              }\n-            })\n-            export class MyComponent {\n-              @HostListener('@animation.start')\n-              start() {}\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-          …\n-          hostBindings: function MyComponent_HostBindings(rf, ctx) {\n-            if (rf & 1) {\n-              $r3$.ɵɵsyntheticHostListener(\"@animation.done\", function MyComponent_animation_animation_done_HostBindingHandler() { return ctx.done(); })(\"@animation.start\", function MyComponent_animation_animation_start_HostBindingHandler() { return ctx.start(); });\n-            }\n-          }\n-        `;\n-\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain multiple regular and synthetic host listeners into two instructions', () => {\n-      const files = {\n-        app: {\n-          'example.ts': `\n-            import {Component, HostListener} from '@angular/core';\n-\n-            @Component({\n-              selector: 'my-comp',\n-              template: '',\n-              host: {\n-                '(mousedown)': 'mousedown()',\n-                '(@animation.done)': 'done()',\n-                '(mouseup)': 'mouseup()',\n-              }\n-            })\n-            export class MyComponent {\n-              @HostListener('@animation.start')\n-              start() {}\n-\n-              @HostListener('click')\n-              click() {}\n-            }`\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      const template = `\n-        …\n-        hostBindings: function MyComponent_HostBindings(rf, ctx) {\n-          if (rf & 1) {\n-            $r3$.ɵɵsyntheticHostListener(\"@animation.done\", function MyComponent_animation_animation_done_HostBindingHandler() { return ctx.done(); })(\"@animation.start\", function MyComponent_animation_animation_start_HostBindingHandler() { return ctx.start(); });\n-            $r3$.ɵɵlistener(\"mousedown\", function MyComponent_mousedown_HostBindingHandler() { return ctx.mousedown(); })(\"mouseup\", function MyComponent_mouseup_HostBindingHandler() { return ctx.mouseup(); })(\"click\", function MyComponent_click_HostBindingHandler() { return ctx.click(); });\n-          }\n-        }\n-      `;\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-  });\n-\n-  describe('non bindable behavior', () => {\n-    const getAppFiles = (template: string = ''): MockDirectory => ({\n-      app: {\n-        'example.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-\n-          @Component({\n-            selector: 'my-app',\n-            template: \\`${template}\\`\n-          })\n-          export class MyComponent {\n-            name = 'John Doe';\n-          }\n-\n-          @NgModule({declarations: [MyComponent]})\n-          export class MyModule {}`\n-      }\n-    });\n-\n-    it('should generate the proper update instructions for interpolated properties', () => {\n-      const files: MockDirectory = getAppFiles(`\n-        <div title=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g{{seven}}h{{eight}}i{{nine}}j\"></div>\n-        <div title=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g{{seven}}h{{eight}}i\"></div>\n-        <div title=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g{{seven}}h\"></div>\n-        <div title=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g\"></div>\n-        <div title=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f\"></div>\n-        <div title=\"a{{one}}b{{two}}c{{three}}d{{four}}e\"></div>\n-        <div title=\"a{{one}}b{{two}}c{{three}}d\"></div>\n-        <div title=\"a{{one}}b{{two}}c\"></div>\n-        <div title=\"a{{one}}b\"></div>\n-        <div title=\"{{one}}\"></div>\n-      `);\n-\n-      const template = `\n-      …\n-        if (rf & 2) {\n-          i0.ɵɵpropertyInterpolateV(\"title\", [\"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\", ctx.seven, \"h\", ctx.eight, \"i\", ctx.nine, \"j\"]);\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵpropertyInterpolate8(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\", ctx.seven, \"h\", ctx.eight, \"i\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵpropertyInterpolate7(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\", ctx.seven, \"h\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵpropertyInterpolate6(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵpropertyInterpolate5(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵpropertyInterpolate4(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵpropertyInterpolate3(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵpropertyInterpolate2(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵpropertyInterpolate1(\"title\", \"a\", ctx.one, \"b\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵpropertyInterpolate(\"title\", ctx.one);\n-      }\n-      …\n-      `;\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect handling of interpolated properties');\n-    });\n-\n-\n-    it('should generate the proper update instructions for interpolated attributes', () => {\n-      const files: MockDirectory = getAppFiles(`\n-        <div attr.title=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g{{seven}}h{{eight}}i{{nine}}j\"></div>\n-        <div attr.title=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g{{seven}}h{{eight}}i\"></div>\n-        <div attr.title=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g{{seven}}h\"></div>\n-        <div attr.title=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g\"></div>\n-        <div attr.title=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f\"></div>\n-        <div attr.title=\"a{{one}}b{{two}}c{{three}}d{{four}}e\"></div>\n-        <div attr.title=\"a{{one}}b{{two}}c{{three}}d\"></div>\n-        <div attr.title=\"a{{one}}b{{two}}c\"></div>\n-        <div attr.title=\"a{{one}}b\"></div>\n-        <div attr.title=\"{{one}}\"></div>\n-      `);\n-\n-      const template = `\n-      …\n-        if (rf & 2) {\n-          i0.ɵɵattributeInterpolateV(\"title\", [\"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\", ctx.seven, \"h\", ctx.eight, \"i\", ctx.nine, \"j\"]);\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵattributeInterpolate8(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\", ctx.seven, \"h\", ctx.eight, \"i\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵattributeInterpolate7(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\", ctx.seven, \"h\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵattributeInterpolate6(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵattributeInterpolate5(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵattributeInterpolate4(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵattributeInterpolate3(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵattributeInterpolate2(\"title\", \"a\", ctx.one, \"b\", ctx.two, \"c\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵattributeInterpolate1(\"title\", \"a\", ctx.one, \"b\");\n-          i0.ɵɵadvance(1);\n-          i0.ɵɵattribute(\"title\", ctx.one);\n-      }\n-      …\n-      `;\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect handling of interpolated properties');\n-    });\n-\n-    it('should keep local ref for host element', () => {\n-      const files: MockDirectory = getAppFiles(`\n-        <b ngNonBindable #myRef id=\"my-id\">\n-          <i>Hello {{ name }}!</i>\n-        </b>\n-        {{ myRef.id }}\n-      `);\n-\n-      const template = `\n-        …\n-        consts: [[\"id\", \"my-id\"], [\"myRef\", \"\"]],\n-        template:function MyComponent_Template(rf, $ctx$){\n-          if (rf & 1) {\n-            $i0$.ɵɵelementStart(0, \"b\", 0, 1);\n-            $i0$.ɵɵdisableBindings();\n-            $i0$.ɵɵelementStart(2, \"i\");\n-            $i0$.ɵɵtext(3, \"Hello {{ name }}!\");\n-            $i0$.ɵɵelementEnd();\n-            $i0$.ɵɵenableBindings();\n-            $i0$.ɵɵelementEnd();\n-            $i0$.ɵɵtext(4);\n-          }\n-          if (rf & 2) {\n-            const $_r0$ = $i0$.ɵɵreference(1);\n-            $r3$.ɵɵadvance(4);\n-            $i0$.ɵɵtextInterpolate1(\" \", $_r0$.id, \" \");\n-          }\n-        }\n-      `;\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect handling of local refs for host element');\n-    });\n-\n-    it('should not have local refs for nested elements', () => {\n-      const files: MockDirectory = getAppFiles(`\n-       <div ngNonBindable>\n-         <input value=\"one\" #myInput> {{ myInput.value }}\n-       </div>\n-      `);\n-\n-      const template = `\n-        …\n-        consts: [[\"value\", \"one\", \"#myInput\", \"\"]],\n-        template:function MyComponent_Template(rf, $ctx$){\n-          if (rf & 1) {\n-            $i0$.ɵɵelementStart(0, \"div\");\n-            $i0$.ɵɵdisableBindings();\n-            $i0$.ɵɵelement(1, \"input\", 0);\n-            $i0$.ɵɵtext(2, \" {{ myInput.value }} \");\n-            $i0$.ɵɵenableBindings();\n-            $i0$.ɵɵelementEnd();\n-        }\n-      `;\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect handling of local refs for nested elements');\n-    });\n-\n-    it('should not process property bindings and listeners', () => {\n-      const files: MockDirectory = getAppFiles(`\n-        <div ngNonBindable>\n-          <div [id]=\"my-id\" (click)=\"onclick\"></div>\n-        </div>\n-      `);\n-\n-      const template = `\n-        …\n-        consts: [[\"[id]\", \"my-id\", \"(click)\", \"onclick\"]],\n-        template:function MyComponent_Template(rf, $ctx$){\n-          if (rf & 1) {\n-            $i0$.ɵɵelementStart(0, \"div\");\n-            $i0$.ɵɵdisableBindings();\n-            $i0$.ɵɵelement(1, \"div\", 0);\n-            $i0$.ɵɵenableBindings();\n-            $i0$.ɵɵelementEnd();\n-        }\n-      `;\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect handling of property bindings and listeners');\n-    });\n-\n-    it('should not generate extra instructions for elements with no children', () => {\n-      const files: MockDirectory = getAppFiles(`\n-        <div ngNonBindable></div>\n-      `);\n-\n-      const template = `\n-        template:function MyComponent_Template(rf, $ctx$){\n-          if (rf & 1) {\n-            $i0$.ɵɵelement(0, \"div\");\n-          }\n-        }\n-      `;\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect handling of elements with no children');\n-    });\n-  });\n-});"
        },
        {
            "sha": "91820d3953088a86d15d436c9d99b14d34a05642",
            "filename": "packages/compiler-cli/test/compliance_old/r3_view_compiler_di_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 398,
            "changes": 398,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_di_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_di_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_di_spec.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,398 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {MockDirectory, setup} from '@angular/compiler/test/aot/test_util';\n-import {compile, expectEmit} from './mock_compile';\n-\n-describe('compiler compliance: dependency injection', () => {\n-  const angularFiles = setup({\n-    compileAngular: false,\n-    compileFakeCore: true,\n-    compileAnimations: false,\n-  });\n-\n-  it('should create factory methods', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule, Injectable, Attribute, Host, SkipSelf, Self, Optional} from '@angular/core';\n-\n-              @Injectable()\n-              export class MyService {}\n-\n-              function dynamicAttrName() {\n-                return 'the-attr';\n-              }\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`\\`\n-              })\n-              export class MyComponent {\n-                constructor(\n-                  @Attribute('name') name:string,\n-                  @Attribute(dynamicAttrName()) other: string,\n-                  s1: MyService,\n-                  @Host() s2: MyService,\n-                  @Self() s4: MyService,\n-                  @SkipSelf() s3: MyService,\n-                  @Optional() s5: MyService,\n-                  @Self() @Optional() s6: MyService,\n-                ) {}\n-              }\n-\n-              @NgModule({declarations: [MyComponent], providers: [MyService]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const factory = `\n-      MyComponent.ɵfac = function MyComponent_Factory(t) {\n-        return new (t || MyComponent)(\n-          $r3$.ɵɵinjectAttribute('name'),\n-          $r3$.ɵɵinjectAttribute(dynamicAttrName()),\n-          $r3$.ɵɵdirectiveInject(MyService),\n-          $r3$.ɵɵdirectiveInject(MyService, 1),\n-          $r3$.ɵɵdirectiveInject(MyService, 2),\n-          $r3$.ɵɵdirectiveInject(MyService, 4),\n-          $r3$.ɵɵdirectiveInject(MyService, 8),\n-          $r3$.ɵɵdirectiveInject(MyService, 10)\n-        );\n-      }`;\n-\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, factory, 'Incorrect factory');\n-  });\n-\n-  it('should create a factory definition for an injectable', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Injectable} from '@angular/core';\n-\n-          class MyDependency {}\n-\n-          @Injectable()\n-          export class MyService {\n-            constructor(dep: MyDependency) {}\n-          }\n-        `\n-      }\n-    };\n-\n-    const factory = `\n-      MyService.ɵfac = function MyService_Factory(t) {\n-        return new (t || MyService)($r3$.ɵɵinject(MyDependency));\n-      }`;\n-\n-    const def = `\n-      MyService.ɵprov = /*@__PURE__*/ $r3$.ɵɵdefineInjectable({\n-        token: MyService,\n-        factory: MyService.ɵfac\n-      });\n-    `;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, factory, 'Incorrect factory definition');\n-    expectEmit(result.source, def, 'Incorrect injectable definition');\n-  });\n-\n-  it('should create a factory definition for an injectable with an overloaded constructor', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Injectable, Optional} from '@angular/core';\n-\n-          class MyDependency {}\n-          class MyOptionalDependency {}\n-\n-          @Injectable()\n-          export class MyService {\n-            constructor(dep: MyDependency);\n-            constructor(dep: MyDependency, @Optional() optionalDep?: MyOptionalDependency) {}\n-          }\n-        `\n-      }\n-    };\n-\n-    const factory = `\n-      MyService.ɵfac = function MyService_Factory(t) {\n-        return new (t || MyService)($r3$.ɵɵinject(MyDependency), $r3$.ɵɵinject(MyOptionalDependency, 8));\n-      }`;\n-\n-    const def = `\n-      MyService.ɵprov = /*@__PURE__*/ $r3$.ɵɵdefineInjectable({\n-        token: MyService,\n-        factory: MyService.ɵfac\n-      });\n-    `;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, factory, 'Incorrect factory definition');\n-    expectEmit(result.source, def, 'Incorrect injectable definition');\n-  });\n-\n-  it('should create a single factory def if the class has more than one decorator', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Injectable, Pipe} from '@angular/core';\n-\n-          @Injectable()\n-          @Pipe({name: 'my-pipe'})\n-          export class MyPipe {\n-          }\n-        `\n-      }\n-    };\n-\n-    const result = compile(files, angularFiles).source;\n-    const matches = result.match(/MyPipe\\.ɵfac = function MyPipe_Factory/g);\n-    expect(matches ? matches.length : 0).toBe(1);\n-  });\n-\n-  it('should delegate directly to the alternate factory when setting `useFactory` without `deps`',\n-     () => {\n-       const files = {\n-         app: {\n-           'spec.ts': `\n-              import {Injectable} from '@angular/core';\n-\n-              class MyAlternateService {}\n-\n-              function alternateFactory() {\n-                return new MyAlternateService();\n-              }\n-\n-              @Injectable({\n-                useFactory: alternateFactory\n-              })\n-              export class MyService {\n-              }\n-            `\n-         }\n-       };\n-\n-       const def = `\n-          MyService.ɵprov = /*@__PURE__*/ $r3$.ɵɵdefineInjectable({\n-            token: MyService,\n-            factory: function() {\n-              return alternateFactory();\n-            }\n-          });\n-        `;\n-\n-       const result = compile(files, angularFiles);\n-       expectEmit(result.source, def, 'Incorrect injectable definition');\n-     });\n-\n-  it('should not delegate directly to the alternate factory when setting `useFactory` with `deps`',\n-     () => {\n-       const files = {\n-         app: {\n-           'spec.ts': `\n-              import {Injectable} from '@angular/core';\n-\n-              class SomeDep {}\n-              class MyAlternateService {}\n-\n-              @Injectable({\n-                useFactory: () => new MyAlternateFactory(),\n-                deps: [SomeDep]\n-              })\n-              export class MyService {\n-              }\n-            `\n-         }\n-       };\n-\n-       const def = `\n-          MyService.ɵprov = /*@__PURE__*/ $r3$.ɵɵdefineInjectable({\n-            token: MyService,\n-            factory: function MyService_Factory(t) {\n-              let r = null;\n-              if (t) {\n-                r = new t();\n-              } else {\n-                r = (() => new MyAlternateFactory())($r3$.ɵɵinject(SomeDep));\n-              }\n-              return r;\n-            }\n-          });\n-        `;\n-\n-       const result = compile(files, angularFiles);\n-       expectEmit(result.source, def, 'Incorrect injectable definition');\n-     });\n-\n-  it('should delegate directly to the alternate class factory when setting `useClass` without `deps`',\n-     () => {\n-       const files = {\n-         app: {\n-           'spec.ts': `\n-              import {Injectable} from '@angular/core';\n-\n-              @Injectable()\n-              class MyAlternateService {}\n-\n-              @Injectable({\n-                useClass: MyAlternateService\n-              })\n-              export class MyService {\n-              }\n-            `\n-         }\n-       };\n-\n-       const factory = `\n-          MyService.ɵprov = /*@__PURE__*/ $r3$.ɵɵdefineInjectable({\n-            token: MyService,\n-            factory: function(t) {\n-              return MyAlternateService.ɵfac(t);\n-            }\n-          });\n-        `;\n-\n-       const result = compile(files, angularFiles);\n-       expectEmit(result.source, factory, 'Incorrect factory definition');\n-     });\n-\n-  it('should not delegate directly to the alternate class when setting `useClass` with `deps`',\n-     () => {\n-       const files = {\n-         app: {\n-           'spec.ts': `\n-            import {Injectable} from '@angular/core';\n-\n-            class SomeDep {}\n-\n-            @Injectable()\n-            class MyAlternateService {}\n-\n-            @Injectable({\n-              useClass: MyAlternateService,\n-              deps: [SomeDep]\n-            })\n-            export class MyService {\n-            }\n-          `\n-         }\n-       };\n-\n-       const factory = `\n-          MyService.ɵprov = /*@__PURE__*/ $r3$.ɵɵdefineInjectable({\n-            token: MyService,\n-            factory: function MyService_Factory(t) {\n-              let r = null;\n-              if (t) {\n-                r = new t();\n-              } else {\n-                r = new MyAlternateService($r3$.ɵɵinject(SomeDep));\n-              }\n-              return r;\n-            }\n-          });\n-        `;\n-\n-       const result = compile(files, angularFiles);\n-       expectEmit(result.source, factory, 'Incorrect factory definition');\n-     });\n-\n-  it('should unwrap forward refs when delegating to a different class', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-            import {Injectable, forwardRef} from '@angular/core';\n-\n-            @Injectable({providedIn: 'root', useClass: forwardRef(() => SomeProviderImpl)})\n-            abstract class SomeProvider {\n-            }\n-\n-            @Injectable()\n-            class SomeProviderImpl extends SomeProvider {\n-            }\n-          `\n-      }\n-    };\n-\n-    const factory = `\n-      SomeProvider.ɵprov = /*@__PURE__*/ $r3$.ɵɵdefineInjectable({\n-        token: SomeProvider,\n-        factory: function(t) {\n-          return SomeProviderImpl.ɵfac(t);\n-        },\n-        providedIn: 'root'\n-      });\n-    `;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, factory, 'Incorrect factory definition');\n-  });\n-\n-  it('should have the pipe factory take precedence over the injectable factory, if a class has multiple decorators',\n-     () => {\n-       const files = {\n-         app: {\n-           'spec.ts': `\n-            import {Component, NgModule, Pipe, PipeTransform, Injectable} from '@angular/core';\n-\n-            @Injectable()\n-            class Service {}\n-\n-            @Injectable()\n-            @Pipe({name: 'myPipe'})\n-            export class MyPipe implements PipeTransform {\n-              constructor(service: Service) {}\n-              transform(value: any, ...args: any[]) { return value; }\n-            }\n-\n-            @Pipe({name: 'myOtherPipe'})\n-            @Injectable()\n-            export class MyOtherPipe implements PipeTransform {\n-              constructor(service: Service) {}\n-              transform(value: any, ...args: any[]) { return value; }\n-            }\n-\n-            @Component({\n-              selector: 'my-app',\n-              template: '{{0 | myPipe | myOtherPipe}}'\n-            })\n-            export class MyApp {}\n-\n-            @NgModule({declarations: [MyPipe, MyOtherPipe, MyApp], declarations: [Service]})\n-            export class MyModule {}\n-          `\n-         }\n-       };\n-\n-       const result = compile(files, angularFiles);\n-       const source = result.source;\n-\n-       // The prov definition must be last so MyPipe.fac is defined\n-       const MyPipeDefs = `\n-        MyPipe.ɵfac = function MyPipe_Factory(t) { return new (t || MyPipe)(i0.ɵɵdirectiveInject(Service, 16)); };\n-        MyPipe.ɵpipe = /*@__PURE__*/ i0.ɵɵdefinePipe({ name: \"myPipe\", type: MyPipe, pure: true });\n-        MyPipe.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: MyPipe, factory: MyPipe.ɵfac });\n-      `;\n-\n-       // The prov definition must be last so MyOtherPipe.fac is defined\n-       const MyOtherPipeDefs = `\n-        MyOtherPipe.ɵfac = function MyOtherPipe_Factory(t) { return new (t || MyOtherPipe)($r3$.ɵɵdirectiveInject(Service, 16)); };\n-        MyOtherPipe.ɵpipe = /*@__PURE__*/ i0.ɵɵdefinePipe({ name: \"myOtherPipe\", type: MyOtherPipe, pure: true });\n-        MyOtherPipe.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: MyOtherPipe, factory: MyOtherPipe.ɵfac });\n-      `;\n-\n-       expectEmit(source, MyPipeDefs, 'Invalid pipe factory function');\n-       expectEmit(source, MyOtherPipeDefs, 'Invalid pipe factory function');\n-       expect(source.match(/MyPipe\\.ɵfac =/g)!.length).toBe(1);\n-       expect(source.match(/MyOtherPipe\\.ɵfac =/g)!.length).toBe(1);\n-     });\n-});"
        },
        {
            "sha": "e5019a9aed99e27f42193c2037548107682b562c",
            "filename": "packages/compiler-cli/test/compliance_old/r3_view_compiler_directives_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 410,
            "changes": 410,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_directives_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_directives_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_directives_spec.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,410 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {AttributeMarker} from '@angular/compiler/src/core';\n-import {setup} from '@angular/compiler/test/aot/test_util';\n-import {compile, expectEmit} from './mock_compile';\n-\n-describe('compiler compliance: directives', () => {\n-  const angularFiles = setup({\n-    compileAngular: false,\n-    compileAnimations: false,\n-    compileFakeCore: true,\n-  });\n-\n-  describe('matching', () => {\n-    it('should not match directives on i18n attribute', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                import {Component, Directive, NgModule} from '@angular/core';\n-\n-                @Directive({selector: '[i18n]'})\n-                export class I18nDirective {}\n-\n-                @Component({selector: 'my-component', template: '<div i18n></div>'})\n-                export class MyComponent {}\n-\n-                @NgModule({declarations: [I18nDirective, MyComponent]})\n-                export class MyModule{}`\n-        }\n-      };\n-\n-      // MyComponent definition should be:\n-      const MyComponentDefinition = `\n-            MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-                type: MyComponent,\n-                selectors: [[\"my-component\"]],\n-                decls: 1,\n-                vars: 0,\n-                template: function MyComponent_Template(rf, ctx) {\n-                    if (rf & 1) {\n-                        $r3$.ɵɵelement(0, \"div\");\n-                    }\n-                },\n-                encapsulation: 2\n-            });\n-        `;\n-\n-      const MyComponentFactory = `\n-        MyComponent.ɵfac = function MyComponent_Factory(t) { return new (t || MyComponent)(); };\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      const source = result.source;\n-\n-      expectEmit(source, MyComponentDefinition, 'Incorrect ChildComponent.ɵcmp');\n-      expectEmit(source, MyComponentFactory, 'Incorrect ChildComponent.ɵfac');\n-    });\n-\n-    it('should not match directives on i18n-prefixed attributes', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                import {Component, Directive, NgModule} from '@angular/core';\n-\n-                @Directive({selector: '[i18n]'})\n-                export class I18nDirective {}\n-\n-                @Directive({selector: '[i18n-foo]'})\n-                export class I18nFooDirective {}\n-\n-                @Directive({selector: '[foo]'})\n-                export class FooDirective {}\n-\n-                @Component({selector: 'my-component', template: '<div i18n-foo></div>'})\n-                export class MyComponent {}\n-\n-                @NgModule({declarations: [I18nDirective, I18nFooDirective, FooDirective, MyComponent]})\n-                export class MyModule{}`\n-        }\n-      };\n-\n-      // MyComponent definition should be:\n-      const MyComponentDefinition = `\n-            MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-                type: MyComponent,\n-                selectors: [[\"my-component\"]],\n-                decls: 1,\n-                vars: 0,\n-                template: function MyComponent_Template(rf, ctx) {\n-                    if (rf & 1) {\n-                        $r3$.ɵɵelement(0, \"div\");\n-                    }\n-                },\n-                encapsulation: 2\n-            });\n-        `;\n-\n-      const MyComponentFactory = `\n-        MyComponent.ɵfac = function MyComponent_Factory(t) { return new (t || MyComponent)(); };\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      const source = result.source;\n-\n-      expectEmit(source, MyComponentDefinition, 'Incorrect ChildComponent.ɵcmp');\n-      expectEmit(source, MyComponentFactory, 'Incorrect ChildComponent.ɵfac');\n-    });\n-\n-    it('should match directives on property bindings', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component, Directive, Input, NgModule} from '@angular/core';\n-\n-            @Directive({selector: '[someDirective]'})\n-            export class SomeDirective {\n-                @Input() someDirective;\n-            }\n-\n-            @Component({selector: 'my-component', template: '<div [someDirective]=\"true\"></div>'})\n-            export class MyComponent {}\n-\n-            @NgModule({declarations: [SomeDirective, MyComponent]})\n-            export class MyModule{}\n-          `\n-        }\n-      };\n-\n-\n-      // MyComponent definition should be:\n-      const MyComponentDefinition = `\n-          …\n-          MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-              …\n-              consts: [[${AttributeMarker.Bindings}, \"someDirective\"]],\n-              template: function MyComponent_Template(rf, ctx) {\n-                  if (rf & 1) {\n-                      $r3$.ɵɵelement(0, \"div\", 0);\n-                  }\n-                  if (rf & 2) {\n-                      $r3$.ɵɵproperty(\"someDirective\", true);\n-                  }\n-              },\n-              …\n-              directives: [SomeDirective],\n-              encapsulation: 2\n-          });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      const source = result.source;\n-\n-      expectEmit(source, MyComponentDefinition, 'Incorrect ChildComponent.ɵcmp');\n-    });\n-\n-    it('should match directives on ng-templates', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component, Directive, NgModule, TemplateRef} from '@angular/core';\n-\n-            @Directive({\n-                selector: 'ng-template[directiveA]'\n-            })\n-            export class DirectiveA {\n-                constructor(public templateRef: TemplateRef<any>) {}\n-            }\n-\n-            @Component({\n-              selector: 'my-component',\n-              template: \\`\n-                <ng-template directiveA>Some content</ng-template>\n-              \\`\n-            })\n-            export class MyComponent {}\n-\n-            @NgModule({declarations: [DirectiveA, MyComponent]})\n-            export class MyModule{}\n-          `\n-        }\n-      };\n-\n-      const MyComponentDefinition = `\n-        …\n-        function MyComponent_ng_template_0_Template(rf, ctx) {\n-          if (rf & 1) {\n-            $r3$.ɵɵtext(0, \"Some content\");\n-          }\n-        }\n-        …\n-        MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-          …\n-          consts: [[\"directiveA\", \"\"]],\n-          template: function MyComponent_Template(rf, ctx) {\n-            if (rf & 1) {\n-              $r3$.ɵɵtemplate(0, MyComponent_ng_template_0_Template, 1, 0, \"ng-template\", 0);\n-            }\n-          },\n-          …\n-          directives: [DirectiveA],\n-          …\n-        });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, MyComponentDefinition, 'Incorrect ChildComponent.ɵcmp');\n-    });\n-\n-    it('should match directives on ng-container', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-              import {Component, Directive, NgModule, TemplateRef} from '@angular/core';\n-\n-              @Directive({\n-                  selector: 'ng-container[directiveA]'\n-              })\n-              export class DirectiveA {\n-                  constructor(public templateRef: TemplateRef<any>) {}\n-              }\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`\n-                  <ng-container *ngIf=\"showing\" directiveA>Some content</ng-container>\n-                \\`\n-              })\n-              export class MyComponent {}\n-\n-              @NgModule({declarations: [DirectiveA, MyComponent]})\n-              export class MyModule{}\n-            `\n-        }\n-      };\n-\n-      const MyComponentDefinition = `\n-        …\n-        function MyComponent_ng_container_0_Template(rf, ctx) {\n-          if (rf & 1) {\n-            $r3$.ɵɵelementContainerStart(0, 1);\n-            $r3$.ɵɵtext(1, \"Some content\");\n-            $r3$.ɵɵelementContainerEnd();\n-          }\n-        }\n-        …\n-        MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-          …\n-          consts: [[\"directiveA\", \"\", ${AttributeMarker.Template}, \"ngIf\"], [\"directiveA\", \"\"]],\n-          template: function MyComponent_Template(rf, ctx) {\n-            if (rf & 1) {\n-              $r3$.ɵɵtemplate(0, MyComponent_ng_container_0_Template, 2, 0, \"ng-container\", 0);\n-            }\n-            if (rf & 2) {\n-              $r3$.ɵɵproperty(\"ngIf\", ctx.showing);\n-            }\n-          },\n-          …\n-          directives: [DirectiveA],\n-          …\n-        });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, MyComponentDefinition, 'Incorrect ChildComponent.ɵcmp');\n-    });\n-\n-    it('should match directives on ng-template bindings', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component, Directive, Input, NgModule} from '@angular/core';\n-\n-            @Directive({selector: '[someDirective]'})\n-            export class SomeDirective {\n-                @Input() someDirective;\n-            }\n-\n-            @Component({selector: 'my-component', template: '<ng-template [someDirective]=\"true\"></ng-template>'})\n-            export class MyComponent {}\n-\n-            @NgModule({declarations: [SomeDirective, MyComponent]})\n-            export class MyModule{}\n-          `\n-        }\n-      };\n-\n-\n-      // MyComponent definition should be:\n-      const MyComponentDefinition = `\n-        …\n-        MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-            …\n-            consts: [[${AttributeMarker.Bindings}, \"someDirective\"]],\n-            template: function MyComponent_Template(rf, ctx) {\n-                if (rf & 1) {\n-                    $r3$.ɵɵtemplate(0, MyComponent_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n-                }\n-                if (rf & 2) {\n-                    $r3$.ɵɵproperty(\"someDirective\", true);\n-                }\n-            },\n-            …\n-            directives: [SomeDirective],\n-            encapsulation: 2\n-        });\n-    `;\n-\n-      const result = compile(files, angularFiles);\n-      const source = result.source;\n-\n-      expectEmit(source, MyComponentDefinition, 'Incorrect ChildComponent.ɵcmp');\n-    });\n-\n-    it('should match structural directives', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component, Directive, Input, NgModule} from '@angular/core';\n-\n-            @Directive({selector: '[someDirective]'})\n-            export class SomeDirective {\n-                @Input() someDirective;\n-            }\n-\n-            @Component({selector: 'my-component', template: '<div *someDirective></div>'})\n-            export class MyComponent {}\n-\n-            @NgModule({declarations: [SomeDirective, MyComponent]})\n-            export class MyModule{}\n-          `\n-        }\n-      };\n-\n-      // MyComponent definition should be:\n-      const MyComponentDefinition = `\n-          …\n-          MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-              …\n-              consts: [[${AttributeMarker.Template}, \"someDirective\"]],\n-              template: function MyComponent_Template(rf, ctx) {\n-                  if (rf & 1) {\n-                      $r3$.ɵɵtemplate(0, MyComponent_div_0_Template, 1, 0, \"div\", 0);\n-                  }\n-              },\n-              …\n-              directives: [SomeDirective],\n-              encapsulation: 2\n-          });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      const source = result.source;\n-\n-      expectEmit(source, MyComponentDefinition, 'Incorrect ChildComponent.ɵcmp');\n-    });\n-\n-    it('should match directives on element outputs', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component, Directive, Output, EventEmitter, NgModule} from '@angular/core';\n-\n-            @Directive({selector: '[someDirective]'})\n-            export class SomeDirective {\n-                @Output() someDirective = new EventEmitter();\n-            }\n-\n-            @Component({selector: 'my-component', template: '<div (someDirective)=\"noop()\"></div>'})\n-            export class MyComponent {\n-                noop() {}\n-            }\n-\n-            @NgModule({declarations: [SomeDirective, MyComponent]})\n-            export class MyModule{}\n-          `\n-        }\n-      };\n-\n-\n-      // MyComponent definition should be:\n-      const MyComponentDefinition = `\n-        …\n-        MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-            …\n-            consts: [[${AttributeMarker.Bindings}, \"someDirective\"]],\n-            template: function MyComponent_Template(rf, ctx) {\n-                if (rf & 1) {\n-                    $r3$.ɵɵelementStart(0, \"div\", 0);\n-                    $r3$.ɵɵlistener(\"someDirective\", function MyComponent_Template_div_someDirective_0_listener() { return ctx.noop(); });\n-                    $r3$.ɵɵelementEnd();\n-                }\n-            },\n-            …\n-            directives: [SomeDirective],\n-            encapsulation: 2\n-        });\n-    `;\n-\n-      const result = compile(files, angularFiles);\n-      const source = result.source;\n-\n-      expectEmit(source, MyComponentDefinition, 'Incorrect ChildComponent.ɵcmp');\n-    });\n-  });\n-});"
        },
        {
            "sha": "f0cf9ac3a560b12d3628218f56c0c164a3ca2d9f",
            "filename": "packages/compiler-cli/test/compliance_old/r3_view_compiler_i18n_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 3446,
            "changes": 3446,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_i18n_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_i18n_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_i18n_spec.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d"
        },
        {
            "sha": "8c629385827996b0767dd1f61279d7c0f5791cad",
            "filename": "packages/compiler-cli/test/compliance_old/r3_view_compiler_input_outputs_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 88,
            "changes": 88,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_input_outputs_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_input_outputs_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_input_outputs_spec.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,88 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {MockDirectory, setup} from '@angular/compiler/test/aot/test_util';\n-import {compile, expectEmit} from './mock_compile';\n-\n-describe('compiler compliance: listen()', () => {\n-  const angularFiles = setup({\n-    compileAngular: false,\n-    compileFakeCore: true,\n-    compileAnimations: false,\n-  });\n-\n-  it('should declare inputs/outputs', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, Directive, NgModule, Input, Output} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`\\`\n-              })\n-              export class MyComponent {\n-                @Input() componentInput;\n-                @Input('renamedComponentInput') originalComponentInput;\n-\n-                @Output() componentOutput;\n-                @Output('renamedComponentOutput') originalComponentOutput;\n-              }\n-\n-              @Directive({\n-                selector: '[my-directive]',\n-              })\n-              export class MyDirective {\n-                @Input() directiveInput;\n-                @Input('renamedDirectiveInput') originalDirectiveInput;\n-\n-                @Output() directiveOutput;\n-                @Output('renamedDirectiveOutput') originalDirectiveOutput;\n-              }\n-\n-              @NgModule({declarations: [MyComponent, MyDirective]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const componentDef = `\n-      MyComponent.ɵcmp = /*@__PURE__*/ IDENT.ɵɵdefineComponent({\n-          …\n-          inputs:{\n-            componentInput: \"componentInput\",\n-            originalComponentInput: [\"renamedComponentInput\", \"originalComponentInput\"]\n-          },\n-          outputs: {\n-            componentOutput: \"componentOutput\",\n-            originalComponentOutput: \"renamedComponentOutput\"\n-          }\n-          …\n-        });`;\n-\n-    const directiveDef = `\n-      MyDirective.ɵdir = /*@__PURE__*/ IDENT.ɵɵdefineDirective({\n-        …\n-        inputs:{\n-          directiveInput: \"directiveInput\",\n-          originalDirectiveInput: [\"renamedDirectiveInput\", \"originalDirectiveInput\"]\n-        },\n-        outputs: {\n-          directiveOutput: \"directiveOutput\",\n-          originalDirectiveOutput: \"renamedDirectiveOutput\"\n-        }\n-        …\n-      });`;\n-\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, componentDef, 'Incorrect component definition');\n-    expectEmit(result.source, directiveDef, 'Incorrect directive definition');\n-  });\n-});"
        },
        {
            "sha": "ae160dbdb7ee33f938163c461a71b5225e08dbf6",
            "filename": "packages/compiler-cli/test/compliance_old/r3_view_compiler_listener_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 583,
            "changes": 583,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_listener_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_listener_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_listener_spec.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,583 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {AttributeMarker} from '@angular/compiler/src/core';\n-import {setup} from '@angular/compiler/test/aot/test_util';\n-import {compile, expectEmit} from './mock_compile';\n-\n-/* These tests are codified version of the tests in compiler_canonical_spec.ts. Every\n- * test in compiler_canonical_spec.ts should have a corresponding test here.\n- */\n-describe('compiler compliance: listen()', () => {\n-  const angularFiles = setup({\n-    compileAngular: false,\n-    compileFakeCore: true,\n-    compileAnimations: false,\n-  });\n-\n-  it('should create listener instruction on element', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`<div (click)=\"onClick($event); 1 == 2\"></div>\\`\n-              })\n-              export class MyComponent {\n-                onClick(event: any) {}\n-              }\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    // The template should look like this (where IDENT is a wild card for an identifier):\n-    const template = `\n-        …\n-        consts: [[${AttributeMarker.Bindings}, \"click\"]],\n-        template: function MyComponent_Template(rf, ctx) {\n-          if (rf & 1) {\n-            $r3$.ɵɵelementStart(0, \"div\", 0);\n-            $r3$.ɵɵlistener(\"click\", function MyComponent_Template_div_click_0_listener($event) {\n-              ctx.onClick($event);\n-              return 1 == 2;\n-            });\n-            $r3$.ɵɵelementEnd();\n-          }\n-        }\n-        `;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should create listener instruction on other components', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-app',\n-                template: \\`<div>My App</div>\\`\n-              })\n-              export class MyApp {}\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`<my-app (click)=\"onClick($event);\"></my-app>\\`\n-              })\n-              export class MyComponent {\n-                onClick(event: any) {}\n-              }\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const template = `\n-        …\n-        consts: [[${AttributeMarker.Bindings}, \"click\"]],\n-        template: function MyComponent_Template(rf, ctx) {\n-          if (rf & 1) {\n-            $r3$.ɵɵelementStart(0, \"my-app\", 0);\n-            $r3$.ɵɵlistener(\"click\", function MyComponent_Template_my_app_click_0_listener($event) {\n-              return ctx.onClick($event);\n-            });\n-            $r3$.ɵɵelementEnd();\n-          }\n-        }\n-        `;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should create multiple listener instructions that share a view snapshot', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`\n-                  <div *ngIf=\"showing\">\n-                    <div (click)=\"onClick(foo)\"></div>\n-                    <button (click)=\"onClick2(bar)\"></button>\n-                  </div>\n-\n-                \\`\n-              })\n-              export class MyComponent {\n-                onClick(name: any) {}\n-                onClick2(name: any) {}\n-              }\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const template = `\n-        function MyComponent_div_0_Template(rf, ctx) {\n-          if (rf & 1) {\n-            const $s$ = $r3$.ɵɵgetCurrentView();\n-            $r3$.ɵɵelementStart(0, \"div\");\n-            $r3$.ɵɵelementStart(1, \"div\", 1);\n-            $r3$.ɵɵlistener(\"click\", function MyComponent_div_0_Template_div_click_1_listener() {\n-              $r3$.ɵɵrestoreView($s$);\n-              const $comp$ = $r3$.ɵɵnextContext();\n-              return $comp$.onClick($comp$.foo);\n-            });\n-            $r3$.ɵɵelementEnd();\n-            $r3$.ɵɵelementStart(2, \"button\", 1);\n-            $r3$.ɵɵlistener(\"click\", function MyComponent_div_0_Template_button_click_2_listener() {\n-              $r3$.ɵɵrestoreView($s$);\n-              const $comp2$ = $r3$.ɵɵnextContext();\n-              return $comp2$.onClick2($comp2$.bar);\n-            });\n-            $r3$.ɵɵelementEnd();\n-            $r3$.ɵɵelementEnd();\n-          }\n-        }\n-        // ...\n-        consts: [[${AttributeMarker.Template}, \"ngIf\"], [${AttributeMarker.Bindings}, \"click\"]],\n-        template: function MyComponent_Template(rf, ctx) {\n-          if (rf & 1) {\n-            $r3$.ɵɵtemplate(0, MyComponent_div_0_Template, 3, 0, \"div\", 0);\n-          }\n-          if (rf & 2) {\n-            $i0$.ɵɵproperty(\"ngIf\", ctx.showing);\n-          }\n-        }\n-        `;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('local refs in listeners defined before the local refs', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-            import {Component, NgModule} from '@angular/core';\n-\n-            @Component({\n-              selector: 'my-component',\n-              template: \\`\n-                <button (click)=\"onClick(user.value)\">Save</button>\n-                <input #user>\n-              \\`\n-            })\n-            export class MyComponent {}\n-\n-            @NgModule({declarations: [MyComponent]})\n-            export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const MyComponentDefinition = `\n-        …\n-        MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-          type: MyComponent,\n-          selectors: [[\"my-component\"]],\n-          decls: 4,\n-          vars: 0,\n-          consts: [[${AttributeMarker.Bindings}, \"click\"], [\"user\", \"\"]],\n-          template:  function MyComponent_Template(rf, ctx) {\n-            if (rf & 1) {\n-              const $s$ = $r3$.ɵɵgetCurrentView();\n-              $r3$.ɵɵelementStart(0, \"button\", 0);\n-                $r3$.ɵɵlistener(\"click\", function MyComponent_Template_button_click_0_listener() {\n-                   $r3$.ɵɵrestoreView($s$);\n-                   const $user$ = $r3$.ɵɵreference(3);\n-                   return ctx.onClick($user$.value);\n-                });\n-                $r3$.ɵɵtext(1, \"Save\");\n-              $r3$.ɵɵelementEnd();\n-              $r3$.ɵɵelement(2, \"input\", null, 1);\n-            }\n-          },\n-          encapsulation: 2\n-        });\n-      `;\n-\n-    const MyComponentFactory = `\n-      MyComponent.ɵfac = function MyComponent_Factory(t) { return new (t || MyComponent)(); };\n-    `;\n-\n-    const result = compile(files, angularFiles);\n-    const source = result.source;\n-\n-    expectEmit(source, MyComponentDefinition, 'Incorrect MyComponent.ɵcmp');\n-    expectEmit(source, MyComponentFactory, 'Incorrect MyComponent.ɵfac');\n-  });\n-\n-  it('should chain multiple listeners on the same element', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-            import {Component, NgModule} from '@angular/core';\n-\n-            @Component({\n-              selector: 'my-component',\n-              template: \\`<div (click)=\"click()\" (change)=\"change()\"></div>\\`\n-            })\n-            export class MyComponent {\n-            }\n-\n-            @NgModule({declarations: [MyComponent]})\n-            export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const template = `\n-        …\n-        consts: [[${AttributeMarker.Bindings}, \"click\", \"change\"]],\n-        template: function MyComponent_Template(rf, ctx) {\n-          if (rf & 1) {\n-            $r3$.ɵɵelementStart(0, \"div\", 0);\n-            $r3$.ɵɵlistener(\"click\", function MyComponent_Template_div_click_0_listener() {\n-              return ctx.click();\n-            })(\"change\", function MyComponent_Template_div_change_0_listener() {\n-              return ctx.change();\n-            });\n-            $r3$.ɵɵelementEnd();\n-          }\n-        }\n-        `;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should chain multiple listeners across elements', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-            import {Component, NgModule} from '@angular/core';\n-\n-            @Component({\n-              selector: 'my-component',\n-              template: \\`\n-                <div (click)=\"click()\" (change)=\"change()\"></div>\n-                <some-comp (update)=\"update()\" (delete)=\"delete()\"></some-comp>\n-              \\`\n-            })\n-            export class MyComponent {\n-            }\n-\n-            @NgModule({declarations: [MyComponent]})\n-            export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const template = `\n-        …\n-        consts: [[${AttributeMarker.Bindings}, \"click\", \"change\"], [${\n-        AttributeMarker.Bindings}, \"update\", \"delete\"]],\n-        template: function MyComponent_Template(rf, ctx) {\n-          if (rf & 1) {\n-            $r3$.ɵɵelementStart(0, \"div\", 0);\n-            $r3$.ɵɵlistener(\"click\", function MyComponent_Template_div_click_0_listener() { return ctx.click(); })(\"change\", function MyComponent_Template_div_change_0_listener() { return ctx.change(); });\n-            $r3$.ɵɵelementEnd();\n-            $r3$.ɵɵelementStart(1, \"some-comp\", 1);\n-            $r3$.ɵɵlistener(\"update\", function MyComponent_Template_some_comp_update_1_listener() { return ctx.update(); })(\"delete\", function MyComponent_Template_some_comp_delete_1_listener() { return ctx.delete(); });\n-            $r3$.ɵɵelementEnd();\n-          }\n-        }\n-        `;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should chain multiple listeners on the same template', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-            import {Component, NgModule} from '@angular/core';\n-\n-            @Component({\n-              selector: 'my-component',\n-              template: \\`<ng-template (click)=\"click()\" (change)=\"change()\"></ng-template>\\`\n-            })\n-            export class MyComponent {\n-            }\n-\n-            @NgModule({declarations: [MyComponent]})\n-            export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const template = `\n-        …\n-        consts: [[${AttributeMarker.Bindings}, \"click\", \"change\"]],\n-        template: function MyComponent_Template(rf, ctx) {\n-          if (rf & 1) {\n-            $r3$.ɵɵtemplate(0, MyComponent_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n-            $r3$.ɵɵlistener(\"click\", function MyComponent_Template_ng_template_click_0_listener() { return ctx.click(); })(\"change\", function MyComponent_Template_ng_template_change_0_listener() { return ctx.change(); });\n-          }\n-        }\n-        `;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should not generate the $event argument if it is not being used in a template', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Component} from '@angular/core';\n-\n-          @Component({\n-            template: \\`<div (click)=\"onClick();\"></div>\\`\n-          })\n-          export class MyComponent {\n-            onClick() {}\n-          }\n-        `\n-      }\n-    };\n-\n-    const template = `\n-      …\n-      consts: [[${AttributeMarker.Bindings}, \"click\"]],\n-      template: function MyComponent_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $r3$.ɵɵelementStart(0, \"div\", 0);\n-          $r3$.ɵɵlistener(\"click\", function MyComponent_Template_div_click_0_listener() {\n-            return ctx.onClick();\n-          });\n-          $r3$.ɵɵelementEnd();\n-        }\n-      }\n-    `;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should not generate the $event argument if it is not being used in a host listener', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Component, HostListener} from '@angular/core';\n-\n-          @Component({\n-            template: '',\n-            host: {\n-              '(mousedown)': 'mousedown()'\n-            }\n-          })\n-          export class MyComponent {\n-            mousedown() {}\n-\n-            @HostListener('click')\n-            click() {}\n-          }\n-        `\n-      }\n-    };\n-\n-    const template = `\n-      …\n-      hostBindings: function MyComponent_HostBindings(rf, ctx) {\n-        if (rf & 1) {\n-          i0.ɵɵlistener(\"mousedown\", function MyComponent_mousedown_HostBindingHandler() {\n-            return ctx.mousedown();\n-          })(\"click\", function MyComponent_click_HostBindingHandler() {\n-            return ctx.click();\n-          });\n-        }\n-      }\n-    `;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, template, 'Incorrect host bindings');\n-  });\n-\n-  it('should generate the $event argument if it is being used in a host listener', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Directive, HostListener} from '@angular/core';\n-\n-          @Directive()\n-          export class MyComponent {\n-            @HostListener('click', ['$event.target'])\n-            click(t: EventTarget) {}\n-          }\n-        `\n-      }\n-    };\n-\n-    const template = `\n-      …\n-      hostBindings: function MyComponent_HostBindings(rf, ctx) {\n-        if (rf & 1) {\n-          i0.ɵɵlistener(\"click\", function MyComponent_click_HostBindingHandler($event) {\n-              return ctx.click($event.target);\n-          });\n-        }\n-      }\n-    `;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, template, 'Incorrect host bindings');\n-  });\n-\n-  it('should assume $event is referring to the event variable in a listener by default', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Component} from '@angular/core';\n-\n-          @Component({\n-            template: '<div (click)=\"c($event)\"></div>'\n-          })\n-          class Comp {\n-            c(event: MouseEvent) {}\n-          }\n-        `\n-      }\n-    };\n-\n-    const template = `\n-      …\n-      i0.ɵɵlistener(\"click\", function Comp_Template_div_click_0_listener($event) { return ctx.c($event); });\n-    `;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, template, 'Incorrect event listener');\n-  });\n-\n-  it('should preserve accesses to $event if it is done through `this` in a listener', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Component} from '@angular/core';\n-\n-          @Component({\n-            template: '<div (click)=\"c(this.$event)\"></div>'\n-          })\n-          class Comp {\n-            $event = {};\n-            c(value: {}) {}\n-          }\n-        `\n-      }\n-    };\n-\n-    const template = `\n-      …\n-      i0.ɵɵlistener(\"click\", function Comp_Template_div_click_0_listener() { return ctx.c(ctx.$event); });\n-    `;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, template, 'Incorrect event listener');\n-  });\n-\n-  it('should not assume that $event is referring to an event object inside a property', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Component} from '@angular/core';\n-\n-          @Component({\n-            template: '<div [event]=\"$event\"></div>'\n-          })\n-          class Comp {\n-            $event = 1;\n-          }\n-        `\n-      }\n-    };\n-\n-    const template = `\n-      …\n-      i0.ɵɵproperty(\"event\", ctx.$event);\n-    `;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, template, 'Incorrect property binding');\n-  });\n-\n-  it('should assume $event is referring to the event variable in a listener by default inside a host binding',\n-     () => {\n-       const files = {\n-         app: {\n-           'spec.ts': `\n-              import {Directive} from '@angular/core';\n-\n-              @Directive({\n-                host: {\n-                  '(click)': 'c($event)'\n-                }\n-              })\n-              class Dir {\n-                c(event: MouseEvent) {}\n-              }\n-            `\n-         }\n-       };\n-\n-       const template = `\n-      …\n-      i0.ɵɵlistener(\"click\", function Dir_click_HostBindingHandler($event) { return ctx.c($event); });\n-    `;\n-\n-       const result = compile(files, angularFiles);\n-       expectEmit(result.source, template, 'Incorrect event listener');\n-     });\n-\n-  it('should preserve accesses to $event if it is done through `this` in a listener inside a host binding',\n-     () => {\n-       const files = {\n-         app: {\n-           'spec.ts': `\n-              import {Directive} from '@angular/core';\n-\n-              @Directive({\n-                host: {\n-                  '(click)': 'c(this.$event)'\n-                }\n-              })\n-              class Dir {\n-                $event = {};\n-                c(value: {}) {}\n-              }\n-            `\n-         }\n-       };\n-\n-       const template = `\n-      …\n-      i0.ɵɵlistener(\"click\", function Dir_click_HostBindingHandler() { return ctx.c(ctx.$event); });\n-    `;\n-\n-       const result = compile(files, angularFiles);\n-       expectEmit(result.source, template, 'Incorrect event listener');\n-     });\n-});"
        },
        {
            "sha": "f14e0ffe97ae99fd9967eda54d40248be98b026c",
            "filename": "packages/compiler-cli/test/compliance_old/r3_view_compiler_providers_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 162,
            "changes": 162,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_providers_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_providers_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_providers_spec.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,162 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {setup} from '@angular/compiler/test/aot/test_util';\n-import {compile, expectEmit} from './mock_compile';\n-\n-describe('compiler compliance: providers', () => {\n-  const angularFiles = setup({\n-    compileAngular: false,\n-    compileFakeCore: true,\n-    compileAnimations: false,\n-  });\n-\n-  it('should emit the ProvidersFeature feature when providers and viewProviders', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              abstract class Greeter { abstract greet(): string; }\n-\n-              class GreeterEN implements Greeter {\n-                greet() { return 'Hi'; }\n-              }\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: '<div></div>',\n-                providers: [GreeterEN, {provide: Greeter, useClass: GreeterEN}],\n-                viewProviders: [GreeterEN]\n-              })\n-              export class MyComponent {\n-              }\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(\n-        result.source,\n-        'features: [i0.ɵɵProvidersFeature([GreeterEN, {provide: Greeter, useClass: GreeterEN}], [GreeterEN])],',\n-        'Incorrect features');\n-  });\n-\n-  it('should emit the ProvidersFeature feature when providers only', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              abstract class Greeter { abstract greet(): string; }\n-\n-              class GreeterEN implements Greeter {\n-                greet() { return 'Hi'; }\n-              }\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: '<div></div>',\n-                providers: [GreeterEN, {provide: Greeter, useClass: GreeterEN}]\n-              })\n-              export class MyComponent {\n-              }\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(\n-        result.source,\n-        'features: [i0.ɵɵProvidersFeature([GreeterEN, {provide: Greeter, useClass: GreeterEN}])],',\n-        'Incorrect features');\n-  });\n-\n-  it('should emit the ProvidersFeature feature when viewProviders only', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              abstract class Greeter { abstract greet(): string; }\n-\n-              class GreeterEN implements Greeter {\n-                greet() { return 'Hi'; }\n-              }\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: '<div></div>',\n-                viewProviders: [GreeterEN]\n-              })\n-              export class MyComponent {\n-              }\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(\n-        result.source, 'features: [i0.ɵɵProvidersFeature([], [GreeterEN])],', 'Incorrect features');\n-  });\n-\n-  it('should not emit the ProvidersFeature feature when no providers', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              abstract class Greeter { abstract greet(): string; }\n-\n-              class GreeterEN implements Greeter {\n-                greet() { return 'Hi'; }\n-              }\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: '<div></div>'\n-              })\n-              export class MyComponent {\n-              }\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(\n-        result.source, `\n-        export class MyComponent {\n-        }\n-        MyComponent.ɵfac = function MyComponent_Factory(t) { return new (t || MyComponent)(); };\n-        MyComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({\n-          type: MyComponent,\n-          selectors: [[\"my-component\"]],\n-          decls: 1,\n-          vars: 0,\n-          template: function MyComponent_Template(rf, ctx) {\n-            if (rf & 1) {\n-              i0.ɵɵelement(0, \"div\");\n-            }\n-          },\n-          encapsulation: 2\n-        });`,\n-        'Incorrect features');\n-  });\n-});"
        },
        {
            "sha": "bdfbd1762d920594f0b62b0a29670423026ecdd8",
            "filename": "packages/compiler-cli/test/compliance_old/r3_view_compiler_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 247,
            "changes": 247,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_spec.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,247 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {MockDirectory, setup} from '@angular/compiler/test/aot/test_util';\n-import {compile, expectEmit} from './mock_compile';\n-\n-describe('r3_view_compiler', () => {\n-  const angularFiles = setup({\n-    compileAngular: false,\n-    compileFakeCore: true,\n-    compileAnimations: false,\n-  });\n-\n-  describe('hello world', () => {\n-    it('should be able to generate the hello world component', () => {\n-      const files: MockDirectory = {\n-        app: {\n-          'hello.ts': `\n-           import {Component, NgModule} from '@angular/core';\n-\n-           @Component({\n-             selector: 'hello-world',\n-             template: 'Hello, world!'\n-           })\n-           export class HelloWorldComponent {\n-\n-           }\n-\n-           @NgModule({\n-             declarations: [HelloWorldComponent]\n-           })\n-           export class HelloWorldModule {}\n-        `\n-        }\n-      };\n-      compile(files, angularFiles);\n-    });\n-  });\n-\n-  it('should be able to generate the example', () => {\n-    const files: MockDirectory = {\n-      app: {\n-        'example.ts': `\n-        import {Component, OnInit, OnDestroy, ElementRef, Input, NgModule} from '@angular/core';\n-\n-        @Component({\n-          selector: 'my-app',\n-          template: '<todo [data]=\"list\"></todo>'\n-        })\n-        export class MyApp implements OnInit {\n-\n-          list: any[] = [];\n-\n-          constructor(public elementRef: ElementRef) {}\n-\n-          ngOnInit(): void {\n-          }\n-        }\n-\n-        @Component({\n-          selector: 'todo',\n-          template: '<ul class=\"list\" [title]=\"myTitle\"><li *ngFor=\"let item of data\">{{data}}</li></ul>'\n-        })\n-        export class TodoComponent implements OnInit, OnDestroy {\n-\n-          @Input()\n-          data: any[] = [];\n-\n-          myTitle: string;\n-\n-          constructor(public elementRef: ElementRef) {}\n-\n-          ngOnInit(): void {}\n-\n-          ngOnDestroy(): void {}\n-        }\n-\n-        @NgModule({\n-          declarations: [TodoComponent, MyApp],\n-        })\n-        export class TodoModule{}\n-        `\n-      }\n-    };\n-    const result = compile(files, angularFiles);\n-    expect(result.source).toContain('@angular/core');\n-  });\n-\n-  describe('interpolations', () => {\n-    // Regression #21927\n-    it('should generate a correct call to textInterpolateV with more than 8 interpolations', () => {\n-      const files: MockDirectory = {\n-        app: {\n-          'example.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-\n-          @Component({\n-            selector: 'my-app',\n-            template: ' {{list[0]}} {{list[1]}} {{list[2]}} {{list[3]}} {{list[4]}} {{list[5]}} {{list[6]}} {{list[7]}} {{list[8]}} '\n-          })\n-          export class MyApp {\n-            list: any[] = [];\n-          }\n-\n-          @NgModule({declarations: [MyApp]})\n-          export class MyModule {}`\n-        }\n-      };\n-\n-      const bV_call = `\n-      …\n-      function MyApp_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵtext(0);\n-        }\n-        if (rf & 2) {\n-          $i0$.ɵɵtextInterpolateV([\" \", ctx.list[0], \" \", ctx.list[1], \" \", ctx.list[2], \" \", ctx.list[3], \" \", ctx.list[4], \" \", ctx.list[5], \" \", ctx.list[6], \" \", ctx.list[7], \" \", ctx.list[8], \" \"]);\n-        }\n-      }\n-      …\n-      `;\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, bV_call, 'Incorrect bV call');\n-    });\n-  });\n-\n-  describe('animations', () => {\n-    it('should not register any @attr attributes as static attributes', () => {\n-      const files: MockDirectory = {\n-        app: {\n-          'example.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-\n-          @Component({\n-            selector: 'my-app',\n-            template: '<div @attr [@binding]=\"exp\"></div>'\n-          })\n-          export class MyApp {\n-          }\n-\n-          @NgModule({declarations: [MyApp]})\n-          export class MyModule {}`\n-        }\n-      };\n-\n-      const template = `\n-      template: function MyApp_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵelement(0, \"div\");\n-        }\n-        if (rf & 2) {\n-          $i0$.ɵɵproperty(\"@attr\", …)(\"@binding\", …);\n-        }\n-      }`;\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect initialization attributes');\n-    });\n-\n-    it('should dedup multiple [@event] listeners', () => {\n-      const files: MockDirectory = {\n-        app: {\n-          'example.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-\n-          @Component({\n-            selector: 'my-app',\n-            template: '<div (@mySelector.start)=\"false\" (@mySelector.done)=\"false\" [@mySelector]=\"0\"></div>'\n-          })\n-          export class MyApp {\n-          }\n-\n-          @NgModule({declarations: [MyApp]})\n-          export class MyModule {}`\n-        }\n-      };\n-\n-      const template = `\n-      template: function MyApp_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵelementStart(0, \"div\");\n-          …\n-          $i0$.ɵɵproperty(\"@mySelector\", …);\n-        }\n-      }`;\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect initialization attributes');\n-    });\n-  });\n-\n-  describe('$any', () => {\n-    it('should strip out $any wrappers', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: '<div [tabIndex]=\"$any(10)\"></div>'\n-            })\n-            class Comp {\n-            }\n-          `\n-        }\n-      };\n-\n-      const template = `\n-        …\n-        i0.ɵɵproperty(\"tabIndex\", 10);\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should preserve $any if it is accessed through `this`', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: '<div [tabIndex]=\"this.$any(null)\"></div>'\n-            })\n-            class Comp {\n-              $any(value: null): any {\n-                return value as any;\n-              }\n-            }\n-          `\n-        }\n-      };\n-\n-      const template = `\n-        …\n-        i0.ɵɵproperty(\"tabIndex\", ctx.$any(null));\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-  });\n-});"
        },
        {
            "sha": "a28ea3f2b4f001cf99b39eabaed710d5c1d94ee5",
            "filename": "packages/compiler-cli/test/compliance_old/r3_view_compiler_styling_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 2099,
            "changes": 2099,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_styling_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_styling_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_styling_spec.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,2099 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AttributeMarker} from '@angular/compiler/src/core';\n-import {setup} from '@angular/compiler/test/aot/test_util';\n-import {compile, expectEmit} from './mock_compile';\n-\n-describe('compiler compliance: styling', () => {\n-  const angularFiles = setup({\n-    compileAngular: false,\n-    compileFakeCore: true,\n-    compileAnimations: false,\n-  });\n-\n-  describe('@Component.styles', () => {\n-    it('should pass in the component metadata styles into the component definition and shim them using style encapsulation',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: \"my-component\",\n-                  styles: [\"div.foo { color: red; }\", \":host p:nth-child(even) { --webkit-transition: 1s linear all; }\"],\n-                  template: \"...\"\n-                })\n-                export class MyComponent {\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-           }\n-         };\n-\n-         const template =\n-             'styles: [\"div.foo[_ngcontent-%COMP%] { color: red; }\", \"[_nghost-%COMP%]   p[_ngcontent-%COMP%]:nth-child(even) { --webkit-transition: 1s linear all; }\"]';\n-         const result = compile(files, angularFiles);\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-\n-    it('should pass in styles, but skip shimming the styles if the view encapsulation signals not to',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-                import {Component, NgModule, ViewEncapsulation} from '@angular/core';\n-\n-                @Component({\n-                  selector: \"my-component\",\n-                  encapsulation: ViewEncapsulation.None,\n-                  styles: [\"div.tall { height: 123px; }\", \":host.small p { height:5px; }\"],\n-                  template: \"...\"\n-                })\n-                export class MyComponent {\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-           }\n-         };\n-\n-         const template = 'div.tall { height: 123px; }\", \":host.small p { height:5px; }';\n-         const result = compile(files, angularFiles);\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-\n-    it('should pass in the component metadata styles into the component definition but skip shimming when style encapsulation is set to shadow dom',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-                import {Component, NgModule, ViewEncapsulation} from '@angular/core';\n-\n-                @Component({\n-                  encapsulation: ViewEncapsulation.ShadowDom,\n-                  selector: \"my-component\",\n-                  styles: [\"div.cool { color: blue; }\", \":host.nice p { color: gold; }\"],\n-                  template: \"...\"\n-                })\n-                export class MyComponent {\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-           }\n-         };\n-\n-         const template = `\n-         MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-           …\n-           styles: [\"div.cool { color: blue; }\", \":host.nice p { color: gold; }\"],\n-           encapsulation: 3\n-         })\n-         `;\n-         const result = compile(files, angularFiles);\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-  });\n-\n-  describe('@Component.animations', () => {\n-    it('should pass in the component metadata animations into the component definition', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: \"my-component\",\n-                  animations: [{name: 'foo123'}, {name: 'trigger123'}],\n-                  template: \"\"\n-                })\n-                export class MyComponent {\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-        }\n-      };\n-\n-      const template = `\n-        MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-          type: MyComponent,\n-          selectors:[[\"my-component\"]],\n-          decls: 0,\n-          vars: 0,\n-          template:  function MyComponent_Template(rf, $ctx$) {\n-          },\n-          encapsulation: 2,\n-          data: {\n-            animation: [{name: 'foo123'}, {name: 'trigger123'}]\n-          }\n-        });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should include animations even if the provided array is empty', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: \"my-component\",\n-                  animations: [],\n-                  template: \"\"\n-                })\n-                export class MyComponent {\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-        }\n-      };\n-\n-      const template = `\n-        MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-          type: MyComponent,\n-          selectors:[[\"my-component\"]],\n-          decls: 0,\n-          vars: 0,\n-          template:  function MyComponent_Template(rf, $ctx$) {\n-          },\n-          encapsulation: 2,\n-          data: {\n-            animation: []\n-          }\n-        });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should generate any animation triggers into the component template', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: \"my-component\",\n-                  template: \\`\n-                    <div [@foo]='exp'></div>\n-                    <div @bar></div>\n-                    <div [@baz]></div>\\`,\n-                })\n-                export class MyComponent {\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-        }\n-      };\n-\n-      const template = `\n-        …\n-        MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-          …\n-          decls: 3,\n-          vars: 3,\n-          template:  function MyComponent_Template(rf, $ctx$) {\n-            if (rf & 1) {\n-              $r3$.ɵɵelement(0, \"div\");\n-              $r3$.ɵɵelement(1, \"div\");\n-              $r3$.ɵɵelement(2, \"div\");\n-            }\n-            if (rf & 2) {\n-              $r3$.ɵɵproperty(\"@foo\", ctx.exp);\n-              $r3$.ɵɵadvance(1);\n-              $r3$.ɵɵproperty(\"@bar\", undefined);\n-              $r3$.ɵɵadvance(1);\n-              $r3$.ɵɵproperty(\"@baz\", undefined);\n-            }\n-          },\n-          encapsulation: 2\n-        });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should generate animation listeners', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component, NgModule} from '@angular/core';\n-\n-            @Component({\n-              selector: 'my-cmp',\n-              template: \\`\n-                <div [@myAnimation]=\"exp\"\n-                  (@myAnimation.start)=\"onStart($event)\"\n-                  (@myAnimation.done)=\"onDone($event)\"></div>\n-              \\`,\n-              animations: [trigger(\n-                   'myAnimation',\n-                   [transition(\n-                       '* => state',\n-                       [style({'opacity': '0'}), animate(500, style({'opacity': '1'}))])])],\n-            })\n-            class MyComponent {\n-              exp: any;\n-              startEvent: any;\n-              doneEvent: any;\n-              onStart(event: any) { this.startEvent = event; }\n-              onDone(event: any) { this.doneEvent = event; }\n-            }\n-\n-            @NgModule({declarations: [MyComponent]})\n-            export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const template = `\n-        …\n-        MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-          …\n-          decls: 1,\n-          vars: 1,\n-          template: function MyComponent_Template(rf, ctx) {\n-            if (rf & 1) {\n-              $r3$.ɵɵelementStart(0, \"div\");\n-              $r3$.ɵɵlistener(\"@myAnimation.start\", function MyComponent_Template_div_animation_myAnimation_start_0_listener($event) { return ctx.onStart($event); })(\"@myAnimation.done\", function MyComponent_Template_div_animation_myAnimation_done_0_listener($event) { return ctx.onDone($event); });\n-              $r3$.ɵɵelementEnd();\n-            } if (rf & 2) {\n-              $r3$.ɵɵproperty(\"@myAnimation\", ctx.exp);\n-            }\n-          },\n-          encapsulation: 2,\n-          …\n-        });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should generate animation host binding and listener code for directives', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Directive, Component, NgModule} from '@angular/core';\n-\n-            @Directive({\n-              selector: '[my-anim-dir]',\n-              animations: [\n-                {name: 'myAnim'}\n-              ],\n-              host: {\n-                '[@myAnim]': 'myAnimState',\n-                '(@myAnim.start)': 'onStart()',\n-                '(@myAnim.done)': 'onDone()'\n-              }\n-            })\n-            class MyAnimDir {\n-              onStart() {}\n-              onDone() {}\n-              myAnimState = '123';\n-            }\n-\n-            @Component({\n-              selector: 'my-cmp',\n-              template: \\`\n-                <div my-anim-dir></div>\n-              \\`\n-            })\n-            class MyComponent {\n-            }\n-\n-            @NgModule({declarations: [MyComponent, MyAnimDir]})\n-            export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const template = `\n-        MyAnimDir.ɵdir = /*@__PURE__*/ $r3$.ɵɵdefineDirective({\n-          …\n-          hostVars: 1,\n-          hostBindings: function MyAnimDir_HostBindings(rf, ctx) {\n-            if (rf & 1) {\n-              $r3$.ɵɵsyntheticHostListener(\"@myAnim.start\", function MyAnimDir_animation_myAnim_start_HostBindingHandler() { return ctx.onStart(); })(\"@myAnim.done\", function MyAnimDir_animation_myAnim_done_HostBindingHandler() { return ctx.onDone(); });\n-            }\n-            if (rf & 2) {\n-              $r3$.ɵɵsyntheticHostProperty(\"@myAnim\", ctx.myAnimState);\n-            }\n-          }\n-          …\n-        });\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-  });\n-\n-  describe('[style] and [style.prop]', () => {\n-    it('should create style instructions on the element', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: \\`<div [style]=\"myStyleExp\"></div>\\`\n-                })\n-                export class MyComponent {\n-                  myStyleExp = [{color:'red'}, {color:'blue', duration:1000}]\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-        }\n-      };\n-\n-      const template = `\n-          template: function MyComponent_Template(rf, $ctx$) {\n-            if (rf & 1) {\n-              $r3$.ɵɵelement(0, \"div\");\n-            }\n-            if (rf & 2) {\n-              $r3$.ɵɵstyleMap($ctx$.myStyleExp);\n-            }\n-          }\n-          `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should correctly count the total slots required when style/class bindings include interpolation',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component-with-interpolation',\n-                  template: \\`\n-                    <div class=\"foo foo-{{ fooId }}\"></div>\n-                  \\`\n-                })\n-                export class MyComponentWithInterpolation {\n-                  fooId = '123';\n-                }\n-\n-                @Component({\n-                  selector: 'my-component-with-muchos-interpolation',\n-                  template: \\`\n-                    <div class=\"foo foo-{{ fooId }}-{{ fooUsername }}\"></div>\n-                  \\`\n-                })\n-                export class MyComponentWithMuchosInterpolation {\n-                  fooId = '123';\n-                  fooUsername = 'superfoo';\n-                }\n-\n-                @Component({\n-                  selector: 'my-component-without-interpolation',\n-                  template: \\`\n-                    <div [class]=\"exp\"></div>\n-                  \\`\n-                })\n-                export class MyComponentWithoutInterpolation {\n-                  exp = 'bar';\n-                }\n-\n-                @NgModule({declarations: [MyComponentWithInterpolation, MyComponentWithMuchosInterpolation, MyComponentWithoutInterpolation]})\n-                export class MyModule {}\n-            `\n-           }\n-         };\n-\n-         const template = `\n-        …\n-          decls: 1,\n-          vars: 3,\n-          template: function MyComponentWithInterpolation_Template(rf, $ctx$) {\n-            if (rf & 1) {\n-              $r3$.ɵɵelement(0, \"div\");\n-            }\n-            if (rf & 2) {\n-              $r3$.ɵɵclassMapInterpolate1(\"foo foo-\", $ctx$.fooId, \"\");\n-            }\n-          }\n-        …\n-          decls: 1,\n-          vars: 4,\n-          template: function MyComponentWithMuchosInterpolation_Template(rf, $ctx$) {\n-            if (rf & 1) {\n-              $r3$.ɵɵelement(0, \"div\");\n-            }\n-            if (rf & 2) {\n-              $r3$.ɵɵclassMapInterpolate2(\"foo foo-\", $ctx$.fooId, \"-\", $ctx$.fooUsername, \"\");\n-            }\n-          }\n-        …\n-          decls: 1,\n-          vars: 2,\n-          template: function MyComponentWithoutInterpolation_Template(rf, $ctx$) {\n-            if (rf & 1) {\n-              $r3$.ɵɵelement(0, \"div\");\n-            }\n-            if (rf & 2) {\n-              $r3$.ɵɵclassMap($ctx$.exp);\n-            }\n-          }\n-          `;\n-\n-         const result = compile(files, angularFiles);\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-\n-    it('should place initial, multi, singular and application followed by attribute style instructions in the template code in that order',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: \\`<div style=\"opacity:1\"\n-                                   [attr.style]=\"'border-width: 10px'\"\n-                                   [style.width]=\"myWidth\"\n-                                   [style]=\"myStyleExp\"\n-                                   [style.height]=\"myHeight\"></div>\\`\n-                })\n-                export class MyComponent {\n-                  myStyleExp = [{color:'red'}, {color:'blue', duration:1000}]\n-                  myWidth = '100px';\n-                  myHeight = '100px';\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-           }\n-         };\n-\n-         const template = `\n-          …\n-          MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-              type: MyComponent,\n-              selectors:[[\"my-component\"]],\n-              decls: 1,\n-              vars: 7,\n-              consts: [[${AttributeMarker.Styles}, \"opacity\", \"1\"]],\n-              template:  function MyComponent_Template(rf, $ctx$) {\n-                if (rf & 1) {\n-                  $r3$.ɵɵelement(0, \"div\", 0);\n-                }\n-                if (rf & 2) {\n-                  $r3$.ɵɵstyleMap($ctx$.myStyleExp);\n-                  $r3$.ɵɵstyleProp(\"width\", $ctx$.myWidth)(\"height\", $ctx$.myHeight);\n-                  $r3$.ɵɵattribute(\"style\", \"border-width: 10px\", $r3$.ɵɵsanitizeStyle);\n-                }\n-              },\n-              encapsulation: 2\n-            });\n-        `;\n-\n-         const result = compile(files, angularFiles);\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-\n-    it('should assign a sanitizer instance to the element style allocation instruction if any url-based properties are detected',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: \\`<div [style.background-image]=\"myImage\">\\`\n-                })\n-                export class MyComponent {\n-                  myImage = 'url(foo.jpg)';\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-           }\n-         };\n-\n-         const template = `\n-          MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-            type: MyComponent,\n-            selectors: [[\"my-component\"]],\n-            decls: 1,\n-            vars: 2,\n-            template:  function MyComponent_Template(rf, ctx) {\n-              if (rf & 1) {\n-                $r3$.ɵɵelement(0, \"div\");\n-              }\n-              if (rf & 2) {\n-                $r3$.ɵɵstyleProp(\"background-image\", ctx.myImage);\n-              }\n-            },\n-            encapsulation: 2\n-          });\n-        `;\n-\n-         const result = compile(files, angularFiles);\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-\n-    it('should support [style.foo.suffix] style bindings with a suffix', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-             import {Component, NgModule} from '@angular/core';\n-\n-             @Component({\n-               selector: 'my-component',\n-               template: \\`<div [style.font-size.px]=\"12\">\\`\n-             })\n-             export class MyComponent {\n-             }\n-\n-             @NgModule({declarations: [MyComponent]})\n-             export class MyModule {}\n-         `\n-        }\n-      };\n-\n-      const template = `\n-          template:  function MyComponent_Template(rf, ctx) {\n-            if (rf & 1) {\n-              $r3$.ɵɵelement(0, \"div\");\n-            }\n-            if (rf & 2) {\n-              $r3$.ɵɵstyleProp(\"font-size\", 12, \"px\");\n-            }\n-          }\n-     `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should not create instructions for empty style bindings', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component, NgModule} from '@angular/core';\n-\n-            @Component({\n-              selector: 'my-component',\n-              template: \\`<div [style.color]></div>\\`\n-            })\n-            export class MyComponent {\n-            }\n-\n-            @NgModule({declarations: [MyComponent]})\n-            export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      expect(result.source).not.toContain('styling');\n-    });\n-  });\n-\n-  describe('[class]', () => {\n-    it('should create class styling instructions on the element', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: \\`<div [class]=\"myClassExp\"></div>\\`\n-                })\n-                export class MyComponent {\n-                  myClassExp = {'foo':true}\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-        }\n-      };\n-\n-      const template = `\n-          template: function MyComponent_Template(rf, $ctx$) {\n-            if (rf & 1) {\n-              $r3$.ɵɵelement(0, \"div\");\n-            }\n-            if (rf & 2) {\n-              $r3$.ɵɵclassMap($ctx$.myClassExp);\n-            }\n-          }\n-          `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should place initial, multi, singular and application followed by attribute class instructions in the template code in that order',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: \\`<div class=\"grape\"\n-                                   [attr.class]=\"'banana'\"\n-                                   [class.apple]=\"yesToApple\"\n-                                   [class]=\"myClassExp\"\n-                                   [class.orange]=\"yesToOrange\"></div>\\`\n-                })\n-                export class MyComponent {\n-                  myClassExp = {a:true, b:true};\n-                  yesToApple = true;\n-                  yesToOrange = true;\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-           }\n-         };\n-\n-         const template = `\n-          …\n-          MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-              type: MyComponent,\n-              selectors:[[\"my-component\"]],\n-              decls: 1,\n-              vars: 7,\n-              consts: [[${AttributeMarker.Classes}, \"grape\"]],\n-              template:  function MyComponent_Template(rf, $ctx$) {\n-                if (rf & 1) {\n-                  $r3$.ɵɵelement(0, \"div\", 0);\n-                }\n-                if (rf & 2) {\n-                  $r3$.ɵɵclassMap($ctx$.myClassExp);\n-                  $r3$.ɵɵclassProp(\"apple\", $ctx$.yesToApple)(\"orange\", $ctx$.yesToOrange);\n-                  $r3$.ɵɵattribute(\"class\", \"banana\");\n-                }\n-              },\n-              encapsulation: 2\n-            });\n-        `;\n-\n-         const result = compile(files, angularFiles);\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-\n-    it('should not generate the styling apply instruction if there are only static style/class attributes',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: \\`<div class=\"    foo  \"\n-                                   style=\"width:100px\"\n-                                   [attr.class]=\"'round'\"\n-                                   [attr.style]=\"'height:100px'\"></div>\\`\n-                })\n-                export class MyComponent {}\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-           }\n-         };\n-\n-         const template = `\n-          …\n-          MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-              type: MyComponent,\n-              selectors:[[\"my-component\"]],\n-              decls: 1,\n-              vars: 2,\n-              consts: [[${AttributeMarker.Classes}, \"foo\", ${\n-             AttributeMarker.Styles}, \"width\", \"100px\"]],\n-              template:  function MyComponent_Template(rf, $ctx$) {\n-                if (rf & 1) {\n-                  $r3$.ɵɵelement(0, \"div\", 0);\n-                }\n-                if (rf & 2) {\n-                  $r3$.ɵɵattribute(\"class\", \"round\")(\"style\", \"height:100px\", $r3$.ɵɵsanitizeStyle);\n-                }\n-              },\n-              encapsulation: 2\n-            });\n-        `;\n-\n-         const result = compile(files, angularFiles);\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-\n-    it('should not create instructions for empty class bindings', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component, NgModule} from '@angular/core';\n-\n-            @Component({\n-              selector: 'my-component',\n-              template: \\`<div [class.is-open]></div>\\`\n-            })\n-            export class MyComponent {\n-            }\n-\n-            @NgModule({declarations: [MyComponent]})\n-            export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const result = compile(files, angularFiles);\n-      expect(result.source).not.toContain('styling');\n-    });\n-  });\n-\n-  describe('[style] mixed with [class]', () => {\n-    it('should split [style] and [class] bindings into a separate instructions', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: \\`<div [style]=\"myStyleExp\" [class]=\"myClassExp\"></div>\\`\n-                })\n-                export class MyComponent {\n-                  myStyleExp = [{color:'red'}, {color:'blue', duration:1000}]\n-                  myClassExp = 'foo bar apple';\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-        }\n-      };\n-\n-      const template = `\n-          template: function MyComponent_Template(rf, $ctx$) {\n-            if (rf & 1) {\n-              $r3$.ɵɵelement(0, \"div\");\n-            }\n-            if (rf & 2) {\n-              $r3$.ɵɵstyleMap($ctx$.myStyleExp);\n-              $r3$.ɵɵclassMap($ctx$.myClassExp);\n-            }\n-          }\n-          `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should stamp out pipe definitions in the creation block if used by styling bindings',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: \\`<div [style]=\"myStyleExp | stylePipe\" [class]=\"myClassExp | classPipe\"></div>\\`\n-                })\n-                export class MyComponent {\n-                  myStyleExp = [{color:'red'}, {color:'blue', duration:1000}]\n-                  myClassExp = 'foo bar apple';\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-           }\n-         };\n-\n-         const template = `\n-          template: function MyComponent_Template(rf, $ctx$) {\n-            if (rf & 1) {\n-              $r3$.ɵɵelementStart(0, \"div\");\n-              $r3$.ɵɵpipe(1, \"stylePipe\");\n-              $r3$.ɵɵpipe(2, \"classPipe\");\n-              $r3$.ɵɵelementEnd();\n-            }\n-            if (rf & 2) {\n-              $r3$.ɵɵstyleMap($r3$.ɵɵpipeBind1(1, 4, $ctx$.myStyleExp));\n-              $r3$.ɵɵclassMap($r3$.ɵɵpipeBind1(2, 6, $ctx$.myClassExp));\n-            }\n-          }\n-          `;\n-\n-         const result = compile(files, angularFiles);\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-\n-    it('should properly offset multiple style pipe references for styling bindings', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: \\`\n-                    <div [class]=\"{}\"\n-                         [class.foo]=\"fooExp | pipe:2000\"\n-                         [style]=\"myStyleExp | pipe:1000\"\n-                         [style.bar]=\"barExp | pipe:3000\"\n-                         [style.baz]=\"bazExp | pipe:4000\">\n-                         {{ item }}</div>\\`\n-                })\n-                export class MyComponent {\n-                  myStyleExp = {};\n-                  fooExp = 'foo';\n-                  barExp = 'bar';\n-                  bazExp = 'baz';\n-                  items = [1,2,3];\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-        }\n-      };\n-\n-      const template = `\n-          template: function MyComponent_Template(rf, $ctx$) {\n-            if (rf & 1) {\n-              $r3$.ɵɵelementStart(0, \"div\");\n-              $r3$.ɵɵpipe(1, \"pipe\");\n-              $r3$.ɵɵpipe(2, \"pipe\");\n-              $r3$.ɵɵpipe(3, \"pipe\");\n-              $r3$.ɵɵpipe(4, \"pipe\");\n-              $r3$.ɵɵtext(5);\n-              $r3$.ɵɵelementEnd();\n-            }\n-            if (rf & 2) {\n-              $r3$.ɵɵstyleMap($r3$.ɵɵpipeBind2(1, 11, $ctx$.myStyleExp, 1000));\n-              $r3$.ɵɵclassMap($r3$.ɵɵpureFunction0(23, _c0));\n-              $r3$.ɵɵstyleProp(\"bar\", $r3$.ɵɵpipeBind2(2, 14, $ctx$.barExp, 3000))(\"baz\", $r3$.ɵɵpipeBind2(3, 17, $ctx$.bazExp, 4000));\n-              $r3$.ɵɵclassProp(\"foo\", $r3$.ɵɵpipeBind2(4, 20, $ctx$.fooExp, 2000));\n-              $r3$.ɵɵadvance(5);\n-             $r3$.ɵɵtextInterpolate1(\" \", $ctx$.item, \"\");\n-            }\n-          }\n-          `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should always generate select() statements before any styling instructions', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: \\`\n-                    <div [style.width]=\"w1\"></div>\n-                    <div [style.height]=\"h1\"></div>\n-                    <div [class.active]=\"a1\"></div>\n-                    <div [class.removed]=\"r1\"></div>\n-                  \\`\n-                })\n-                export class MyComponent {\n-                  w1 = '100px';\n-                  h1 = '100px';\n-                  a1 = true;\n-                  r1 = true;\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-        }\n-      };\n-\n-      const template = `\n-          …\n-          template: function MyComponent_Template(rf, $ctx$) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵstyleProp(\"width\", $ctx$.w1);\n-              $r3$.ɵɵadvance(1);\n-              $r3$.ɵɵstyleProp(\"height\", $ctx$.h1);\n-              $r3$.ɵɵadvance(1);\n-              $r3$.ɵɵclassProp(\"active\", $ctx$.a1);\n-              $r3$.ɵɵadvance(1);\n-              $r3$.ɵɵclassProp(\"removed\", $ctx$.r1);\n-            }\n-          }\n-          `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-  });\n-\n-  describe('@Component host styles/classes', () => {\n-    it('should generate style/class instructions for a host component creation definition', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                import {Component, NgModule, HostBinding} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: '',\n-                  host: {\n-                    'style': 'width:200px; height:500px',\n-                    'class': 'foo baz'\n-                  }\n-                })\n-                export class MyComponent {\n-                  @HostBinding('style')\n-                  myStyle = {width:'100px'};\n-\n-                  @HostBinding('class')\n-                  myClass = {bar:false};\n-\n-                  @HostBinding('style.color')\n-                  myColorProp = 'red';\n-\n-                  @HostBinding('class.foo')\n-                  myFooClass = 'red';\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-        }\n-      };\n-\n-      const template = `\n-          hostAttrs: [${AttributeMarker.Classes}, \"foo\", \"baz\", ${\n-          AttributeMarker.Styles}, \"width\", \"200px\", \"height\", \"500px\"],\n-          hostVars: 8,\n-          hostBindings: function MyComponent_HostBindings(rf, ctx) {\n-            if (rf & 2) {\n-              $r3$.ɵɵstyleMap(ctx.myStyle);\n-              $r3$.ɵɵclassMap(ctx.myClass);\n-              $r3$.ɵɵstyleProp(\"color\", ctx.myColorProp);\n-              $r3$.ɵɵclassProp(\"foo\", ctx.myFooClass);\n-            }\n-          },\n-          decls: 0,\n-          vars: 0,\n-          `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should generate style/class instructions for multiple host binding definitions', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                import {Component, NgModule, HostBinding} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: '',\n-                  host: {\n-                    '[style.height.pt]': 'myHeightProp',\n-                    '[class.bar]': 'myBarClass'\n-                  }\n-                })\n-                export class MyComponent {\n-                  myHeightProp = 20;\n-                  myBarClass = true;\n-\n-                  @HostBinding('style')\n-                  myStyle = {};\n-\n-                  @HostBinding('style.width')\n-                  myWidthProp = '500px';\n-\n-                  @HostBinding('class.foo')\n-                  myFooClass = true;\n-\n-                  @HostBinding('class')\n-                  myClasses = {a:true, b:true};\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-        }\n-      };\n-\n-      const template = `\n-          hostVars: 12,\n-          hostBindings: function MyComponent_HostBindings(rf, ctx) {\n-            if (rf & 2) {\n-              $r3$.ɵɵstyleMap(ctx.myStyle);\n-              $r3$.ɵɵclassMap(ctx.myClasses);\n-              $r3$.ɵɵstyleProp(\"height\", ctx.myHeightProp, \"pt\")(\"width\", ctx.myWidthProp);\n-              $r3$.ɵɵclassProp(\"bar\", ctx.myBarClass)(\"foo\", ctx.myFooClass);\n-            }\n-          },\n-          decls: 0,\n-          vars: 0,\n-          `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should generate override instructions for only single-level styling bindings when !important is present',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-                import {Component, NgModule, HostBinding} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: \\`\n-                    <div [style!important]=\"myStyleExp\"\n-                         [class!important]=\"myClassExp\"\n-                         [style.height!important]=\"myHeightExp\"\n-                         [class.bar!important]=\"myBarClassExp\"></div>\n-                  \\`,\n-                  host: {\n-                    '[style!important]': 'myStyleExp',\n-                    '[class!important]': 'myClassExp'\n-                  }\n-                })\n-                export class MyComponent {\n-                  @HostBinding('class.foo!important')\n-                  myFooClassExp = true;\n-\n-                  @HostBinding('style.width!important')\n-                  myWidthExp = '100px';\n-\n-                  myBarClassExp = true;\n-                  myHeightExp = '200px';\n-                }\n-\n-                @NgModule({declarations: [MyComponent]})\n-                export class MyModule {}\n-            `\n-           }\n-         };\n-\n-         const template = `\n-            function MyComponent_Template(rf, ctx) {\n-              if (rf & 1) {\n-                $r3$.ɵɵelement(0, \"div\");\n-              }\n-              if (rf & 2) {\n-                $r3$.ɵɵstyleMap(ctx.myStyleExp);\n-                $r3$.ɵɵclassMap(ctx.myClassExp);\n-                $r3$.ɵɵstyleProp(\"height\", ctx.myHeightExp);\n-                $r3$.ɵɵclassProp(\"bar\", ctx.myBarClassExp);\n-              }\n-            },\n-          `;\n-\n-         const hostBindings = `\n-            hostVars: 8,\n-            hostBindings: function MyComponent_HostBindings(rf, ctx) {\n-              if (rf & 2) {\n-                $r3$.ɵɵstyleMap(ctx.myStyleExp);\n-                $r3$.ɵɵclassMap(ctx.myClassExp);\n-                $r3$.ɵɵstyleProp(\"width\", ctx.myWidthExp);\n-                $r3$.ɵɵclassProp(\"foo\", ctx.myFooClassExp);\n-              }\n-            },\n-          `;\n-\n-         const result = compile(files, angularFiles);\n-         expectEmit(result.source, hostBindings, 'Incorrect template');\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-\n-    it('should support class interpolation', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                  import {Component, NgModule, HostBinding} from '@angular/core';\n-\n-                  @Component({\n-                    selector: 'my-component',\n-                    template: \\`\n-                      <div class=\"A{{p1}}B\"></div>\n-                      <div class=\"A{{p1}}B{{p2}}C\"></div>\n-                      <div class=\"A{{p1}}B{{p2}}C{{p3}}D\"></div>\n-                      <div class=\"A{{p1}}B{{p2}}C{{p3}}D{{p4}}E\"></div>\n-                      <div class=\"A{{p1}}B{{p2}}C{{p3}}D{{p4}}E{{p5}}F\"></div>\n-                      <div class=\"A{{p1}}B{{p2}}C{{p3}}D{{p4}}E{{p5}}F{{p6}}G\"></div>\n-                      <div class=\"A{{p1}}B{{p2}}C{{p3}}D{{p4}}E{{p5}}F{{p6}}G{{p7}}H\"></div>\n-                      <div class=\"A{{p1}}B{{p2}}C{{p3}}D{{p4}}E{{p5}}F{{p6}}G{{p7}}H{{p8}}I\"></div>\n-                      <div class=\"A{{p1}}B{{p2}}C{{p3}}D{{p4}}E{{p5}}F{{p6}}G{{p7}}H{{p8}}I{{p9}}J\"></div>\n-                    \\`,\n-                  })\n-                  export class MyComponent {\n-                    p1 = 100;\n-                    p2 = 100;\n-                    p3 = 100;\n-                    p4 = 100;\n-                    p5 = 100;\n-                    p6 = 100;\n-                    p6 = 100;\n-                    p7 = 100;\n-                    p8 = 100;\n-                    p9 = 100;\n-                  }\n-\n-                  @NgModule({declarations: [MyComponent]})\n-                  export class MyModule {}\n-              `\n-        }\n-      };\n-\n-      const template = `\n-              function MyComponent_Template(rf, ctx) {\n-                if (rf & 1) {\n-                  …\n-                }\n-                if (rf & 2) {\n-                  $r3$.ɵɵclassMapInterpolate1(\"A\", ctx.p1, \"B\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵclassMapInterpolate2(\"A\", ctx.p1, \"B\", ctx.p2, \"C\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵclassMapInterpolate3(\"A\", ctx.p1, \"B\", ctx.p2, \"C\", ctx.p3, \"D\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵclassMapInterpolate4(\"A\", ctx.p1, \"B\", ctx.p2, \"C\", ctx.p3, \"D\", ctx.p4, \"E\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵclassMapInterpolate5(\"A\", ctx.p1, \"B\", ctx.p2, \"C\", ctx.p3, \"D\", ctx.p4, \"E\", ctx.p5, \"F\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵclassMapInterpolate6(\"A\", ctx.p1, \"B\", ctx.p2, \"C\", ctx.p3, \"D\", ctx.p4, \"E\", ctx.p5, \"F\", ctx.p6, \"G\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵclassMapInterpolate7(\"A\", ctx.p1, \"B\", ctx.p2, \"C\", ctx.p3, \"D\", ctx.p4, \"E\", ctx.p5, \"F\", ctx.p6, \"G\", ctx.p7, \"H\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵclassMapInterpolate8(\"A\", ctx.p1, \"B\", ctx.p2, \"C\", ctx.p3, \"D\", ctx.p4, \"E\", ctx.p5, \"F\", ctx.p6, \"G\", ctx.p7, \"H\", ctx.p8, \"I\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵclassMapInterpolateV([\"A\", ctx.p1, \"B\", ctx.p2, \"C\", ctx.p3, \"D\", ctx.p4, \"E\", ctx.p5, \"F\", ctx.p6, \"G\", ctx.p7, \"H\", ctx.p8, \"I\", ctx.p9, \"J\"]);\n-                }\n-              },\n-            `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should support style interpolation', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-                  import {Component, NgModule, HostBinding} from '@angular/core';\n-\n-                  @Component({\n-                    selector: 'my-component',\n-                    template: \\`\n-                      <div style=\"p1:{{p1}};\"></div>\n-                      <div style=\"p1:{{p1}};p2:{{p2}};\"></div>\n-                      <div style=\"p1:{{p1}};p2:{{p2}};p3:{{p3}};\"></div>\n-                      <div style=\"p1:{{p1}};p2:{{p2}};p3:{{p3}};p4:{{p4}};\"></div>\n-                      <div style=\"p1:{{p1}};p2:{{p2}};p3:{{p3}};p4:{{p4}};p5:{{p5}};\"></div>\n-                      <div style=\"p1:{{p1}};p2:{{p2}};p3:{{p3}};p4:{{p4}};p5:{{p5}};p6:{{p6}};\"></div>\n-                      <div style=\"p1:{{p1}};p2:{{p2}};p3:{{p3}};p4:{{p4}};p5:{{p5}};p6:{{p6}};p7:{{p7}};\"></div>\n-                      <div style=\"p1:{{p1}};p2:{{p2}};p3:{{p3}};p4:{{p4}};p5:{{p5}};p6:{{p6}};p7:{{p7}};p8:{{p8}};\"></div>\n-                      <div style=\"p1:{{p1}};p2:{{p2}};p3:{{p3}};p4:{{p4}};p5:{{p5}};p6:{{p6}};p7:{{p7}};p8:{{p8}};p9:{{p9}};\"></div>\n-                    \\`,\n-                  })\n-                  export class MyComponent {\n-                    p1 = 100;\n-                    p2 = 100;\n-                    p3 = 100;\n-                    p4 = 100;\n-                    p5 = 100;\n-                    p6 = 100;\n-                    p6 = 100;\n-                    p7 = 100;\n-                    p8 = 100;\n-                    p9 = 100;\n-                  }\n-\n-                  @NgModule({declarations: [MyComponent]})\n-                  export class MyModule {}\n-              `\n-        }\n-      };\n-\n-      const template = `\n-              function MyComponent_Template(rf, ctx) {\n-                if (rf & 1) {\n-                  …\n-                }\n-                if (rf & 2) {\n-                  $r3$.ɵɵstyleMapInterpolate1(\"p1:\", ctx.p1, \";\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵstyleMapInterpolate2(\"p1:\", ctx.p1, \";p2:\", ctx.p2, \";\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵstyleMapInterpolate3(\"p1:\", ctx.p1, \";p2:\", ctx.p2, \";p3:\", ctx.p3, \";\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵstyleMapInterpolate4(\"p1:\", ctx.p1, \";p2:\", ctx.p2, \";p3:\", ctx.p3, \";p4:\", ctx.p4, \";\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵstyleMapInterpolate5(\"p1:\", ctx.p1, \";p2:\", ctx.p2, \";p3:\", ctx.p3, \";p4:\", ctx.p4, \";p5:\", ctx.p5, \";\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵstyleMapInterpolate6(\"p1:\", ctx.p1, \";p2:\", ctx.p2, \";p3:\", ctx.p3, \";p4:\", ctx.p4, \";p5:\", ctx.p5, \";p6:\", ctx.p6, \";\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵstyleMapInterpolate7(\"p1:\", ctx.p1, \";p2:\", ctx.p2, \";p3:\", ctx.p3, \";p4:\", ctx.p4, \";p5:\", ctx.p5, \";p6:\", ctx.p6, \";p7:\", ctx.p7, \";\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵstyleMapInterpolate8(\"p1:\", ctx.p1, \";p2:\", ctx.p2, \";p3:\", ctx.p3, \";p4:\", ctx.p4, \";p5:\", ctx.p5, \";p6:\", ctx.p6, \";p7:\", ctx.p7, \";p8:\", ctx.p8, \";\");\n-                  $r3$.ɵɵadvance(1);\n-                  $r3$.ɵɵstyleMapInterpolateV([\"p1:\", ctx.p1, \";p2:\", ctx.p2, \";p3:\", ctx.p3, \";p4:\", ctx.p4, \";p5:\", ctx.p5, \";p6:\", ctx.p6, \";p7:\", ctx.p7, \";p8:\", ctx.p8, \";p9:\", ctx.p9, \";\"]);\n-                }\n-              },\n-            `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should generate styling instructions for multiple directives that contain host binding definitions',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-                import {Directive, Component, NgModule, HostBinding} from '@angular/core';\n-\n-                @Directive({selector: '[myClassDir]'})\n-                export class ClassDirective {\n-                  @HostBinding('class')\n-                  myClassMap = {red: true};\n-                }\n-\n-                @Directive({selector: '[myWidthDir]'})\n-                export class WidthDirective {\n-                  @HostBinding('style.width')\n-                  myWidth = 200;\n-\n-                  @HostBinding('class.foo')\n-                  myFooClass = true;\n-                }\n-\n-                @Directive({selector: '[myHeightDir]'})\n-                export class HeightDirective {\n-                  @HostBinding('style.height')\n-                  myHeight = 200;\n-\n-                  @HostBinding('class.bar')\n-                  myBarClass = true;\n-                }\n-\n-                @Component({\n-                  selector: 'my-component',\n-                  template: '<div myWidthDir myHeightDir myClassDir></div>',\n-                })\n-                export class MyComponent {\n-                }\n-\n-                @NgModule({declarations: [MyComponent, WidthDirective, HeightDirective, ClassDirective]})\n-                export class MyModule {}\n-            `\n-           }\n-         };\n-\n-         // NOTE: IF YOU ARE CHANGING THIS COMPILER SPEC, YOU MAY NEED TO CHANGE THE DIRECTIVE\n-         // DEF THAT'S HARD-CODED IN `ng_class.ts`.\n-         const template = `\n-          …\n-          hostVars: 2,\n-          hostBindings: function ClassDirective_HostBindings(rf, ctx) {\n-            if (rf & 2) {\n-              $r3$.ɵɵclassMap(ctx.myClassMap);\n-            }\n-          }\n-          …\n-          hostVars: 4,\n-          hostBindings: function WidthDirective_HostBindings(rf, ctx) {\n-            if (rf & 2) {\n-              $r3$.ɵɵstyleProp(\"width\", ctx.myWidth);\n-              $r3$.ɵɵclassProp(\"foo\", ctx.myFooClass);\n-            }\n-          }\n-          …\n-          hostVars: 4,\n-          hostBindings: function HeightDirective_HostBindings(rf, ctx) {\n-            if (rf & 2) {\n-              $r3$.ɵɵstyleProp(\"height\", ctx.myHeight);\n-              $r3$.ɵɵclassProp(\"bar\", ctx.myBarClass);\n-            }\n-          }\n-          …\n-          `;\n-\n-         const result = compile(files, angularFiles);\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-  });\n-\n-  describe('interpolations', () => {\n-    it('should generate the proper update instructions for interpolated classes', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <div class=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g{{seven}}h{{eight}}i{{nine}}j\"></div>\n-                <div class=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g{{seven}}h{{eight}}i\"></div>\n-                <div class=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g{{seven}}h\"></div>\n-                <div class=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g\"></div>\n-                <div class=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f\"></div>\n-                <div class=\"a{{one}}b{{two}}c{{three}}d{{four}}e\"></div>\n-                <div class=\"a{{one}}b{{two}}c{{three}}d\"></div>\n-                <div class=\"a{{one}}b{{two}}c\"></div>\n-                <div class=\"a{{one}}b\"></div>\n-                <div class=\"{{one}}\"></div>\n-              \\`\n-            })\n-            export class MyComponent {\n-            }\n-          `\n-        }\n-      };\n-\n-      const template = `\n-      …\n-        if (rf & 2) {\n-          $r3$.ɵɵclassMapInterpolateV([\"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\", ctx.seven, \"h\", ctx.eight, \"i\", ctx.nine, \"j\"]);\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵclassMapInterpolate8(\"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\", ctx.seven, \"h\", ctx.eight, \"i\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵclassMapInterpolate7(\"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\", ctx.seven, \"h\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵclassMapInterpolate6(\"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵclassMapInterpolate5(\"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵclassMapInterpolate4(\"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵclassMapInterpolate3(\"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵclassMapInterpolate2(\"a\", ctx.one, \"b\", ctx.two, \"c\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵclassMapInterpolate1(\"a\", ctx.one, \"b\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵclassMap(ctx.one);\n-      }\n-      …\n-      `;\n-      const result = compile(files, angularFiles);\n-\n-      expectEmit(result.source, template, 'Incorrect handling of interpolated classes');\n-    });\n-\n-    it('should throw for interpolations inside individual class bindings', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: '<div class.something=\"{{isEnabled}}\"></div>'\n-            })\n-            export class MyComponent {\n-            }\n-          `\n-        }\n-      };\n-\n-      expect(() => compile(files, angularFiles)).toThrowError(/Unexpected interpolation/);\n-    });\n-\n-    it('should generate the proper update instructions for interpolated style properties', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <div style.color=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g{{seven}}h{{eight}}i{{nine}}j\"></div>\n-                <div style.color=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g{{seven}}h{{eight}}i\"></div>\n-                <div style.color=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g{{seven}}h\"></div>\n-                <div style.color=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f{{six}}g\"></div>\n-                <div style.color=\"a{{one}}b{{two}}c{{three}}d{{four}}e{{five}}f\"></div>\n-                <div style.color=\"a{{one}}b{{two}}c{{three}}d{{four}}e\"></div>\n-                <div style.color=\"a{{one}}b{{two}}c{{three}}d\"></div>\n-                <div style.color=\"a{{one}}b{{two}}c\"></div>\n-                <div style.color=\"a{{one}}b\"></div>\n-                <div style.color=\"{{one}}\"></div>\n-              \\`\n-            })\n-            export class MyComponent {\n-            }\n-          `\n-        }\n-      };\n-\n-      const template = `\n-      …\n-        if (rf & 2) {\n-          $r3$.ɵɵstylePropInterpolateV(\"color\", [\"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\", ctx.seven, \"h\", ctx.eight, \"i\", ctx.nine, \"j\"]);\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵstylePropInterpolate8(\"color\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\", ctx.seven, \"h\", ctx.eight, \"i\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵstylePropInterpolate7(\"color\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\", ctx.seven, \"h\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵstylePropInterpolate6(\"color\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\", ctx.six, \"g\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵstylePropInterpolate5(\"color\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\", ctx.five, \"f\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵstylePropInterpolate4(\"color\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\", ctx.four, \"e\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵstylePropInterpolate3(\"color\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵstylePropInterpolate2(\"color\", \"a\", ctx.one, \"b\", ctx.two, \"c\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵstylePropInterpolate1(\"color\", \"a\", ctx.one, \"b\");\n-          $r3$.ɵɵadvance(1);\n-          $r3$.ɵɵstyleProp(\"color\", ctx.one);\n-      }\n-      …\n-      `;\n-      const result = compile(files, angularFiles);\n-\n-      expectEmit(result.source, template, 'Incorrect handling of interpolated style properties');\n-    });\n-\n-    it('should generate update instructions for interpolated style properties with a suffix',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <div style.width.px=\"a{{one}}b{{two}}c\"></div>\n-              \\`\n-            })\n-            export class MyComponent {\n-            }\n-          `\n-           }\n-         };\n-\n-         const template = `\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵstylePropInterpolate2(\"width\", \"a\", ctx.one, \"b\", ctx.two, \"c\", \"px\");\n-            }\n-            …\n-          `;\n-         const result = compile(files, angularFiles);\n-\n-         expectEmit(result.source, template, 'Incorrect handling of interpolated style properties');\n-       });\n-\n-    it('should generate update instructions for interpolated style properties with a sanitizer',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <div style.background=\"url({{ myUrl1 }})\"\n-                     style.borderImage=\"url({{ myUrl2 }}) {{ myRepeat }} auto\"\n-                     style.boxShadow=\"{{ myBoxX }} {{ myBoxY }} {{ myBoxWidth }} black\"></div>\n-              \\`\n-            })\n-            export class MyComponent {\n-              myUrl1 = '...';\n-              myUrl2 = '...';\n-              myBoxX = '0px';\n-              myBoxY = '0px';\n-              myBoxWidth = '100px';\n-              myRepeat = 'no-repeat';\n-            }\n-          `\n-           }\n-         };\n-\n-         const template = `\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵstylePropInterpolate1(\"background\", \"url(\", ctx.myUrl1, \")\");\n-              $r3$.ɵɵstylePropInterpolate2(\"border-image\", \"url(\", ctx.myUrl2, \") \", ctx.myRepeat, \" auto\");\n-              $r3$.ɵɵstylePropInterpolate3(\"box-shadow\", \"\", ctx.myBoxX, \" \", ctx.myBoxY, \" \", ctx.myBoxWidth, \" black\");\n-            }\n-            …\n-          `;\n-         const result = compile(files, angularFiles);\n-\n-         expectEmit(result.source, template, 'Incorrect handling of interpolated style properties');\n-       });\n-\n-    it('should generate update instructions for interpolated style properties with !important',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-            import {Component} from '@angular/core';\n-\n-            @Component({\n-              template: \\`\n-                <div style.width!important=\"a{{one}}b{{two}}c\"></div>\n-              \\`\n-            })\n-            export class MyComponent {\n-            }\n-          `\n-           }\n-         };\n-\n-         const template = `\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵstylePropInterpolate2(\"width\", \"a\", ctx.one, \"b\", ctx.two, \"c\");\n-            }\n-            …\n-          `;\n-         const result = compile(files, angularFiles);\n-\n-         expectEmit(result.source, template, 'Incorrect handling of interpolated style properties');\n-       });\n-  });\n-\n-  describe('instruction chaining', () => {\n-    it('should chain classProp instruction calls', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-             import {Component} from '@angular/core';\n-\n-             @Component({\n-               template: \\`<div [class.apple]=\"yesToApple\"\n-                                [class.orange]=\"yesToOrange\"\n-                                [class.tomato]=\"yesToTomato\"></div>\\`\n-             })\n-             export class MyComponent {\n-               yesToApple = true;\n-               yesToOrange = true;\n-               tesToTomato = false;\n-             }\n-         `\n-        }\n-      };\n-\n-      const template = `\n-       …\n-       MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-        …\n-        template: function MyComponent_Template(rf, $ctx$) {\n-          …\n-          if (rf & 2) {\n-            $r3$.ɵɵclassProp(\"apple\", $ctx$.yesToApple)(\"orange\", $ctx$.yesToOrange)(\"tomato\", $ctx$.yesToTomato);\n-          }\n-        },\n-        encapsulation: 2\n-      });\n-     `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain styleProp instruction calls', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-             import {Component} from '@angular/core';\n-\n-             @Component({\n-               template: \\`<div [style.color]=\"color\"\n-                                [style.border]=\"border\"\n-                                [style.transition]=\"transition\"></div>\\`\n-             })\n-             export class MyComponent {\n-               color = 'red';\n-               border = '1px solid purple';\n-               transition = 'all 1337ms ease';\n-             }\n-         `\n-        }\n-      };\n-\n-      const template = `\n-       …\n-       MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-        …\n-        template: function MyComponent_Template(rf, $ctx$) {\n-          …\n-          if (rf & 2) {\n-            $r3$.ɵɵstyleProp(\"color\", $ctx$.color)(\"border\", $ctx$.border)(\"transition\", $ctx$.transition);\n-          }\n-        },\n-        encapsulation: 2\n-      });\n-     `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain mixed styleProp and classProp calls', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-             import {Component} from '@angular/core';\n-\n-             @Component({\n-               template: \\`<div\n-                                [class.apple]=\"yesToApple\"\n-                                [style.color]=\"color\"\n-                                [class.orange]=\"yesToOrange\"\n-                                [style.border]=\"border\"\n-                                [class.tomato]=\"yesToTomato\"\n-                                [style.transition]=\"transition\"></div>\\`\n-             })\n-             export class MyComponent {\n-               color = 'red';\n-               border = '1px solid purple';\n-               transition = 'all 1337ms ease';\n-               yesToApple = true;\n-               yesToOrange = true;\n-               tesToTomato = false;\n-             }\n-         `\n-        }\n-      };\n-\n-      const template = `\n-       …\n-       MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-        …\n-        template: function MyComponent_Template(rf, $ctx$) {\n-          …\n-          if (rf & 2) {\n-            $r3$.ɵɵstyleProp(\"color\", $ctx$.color)(\"border\", $ctx$.border)(\"transition\", $ctx$.transition);\n-            $r3$.ɵɵclassProp(\"apple\", $ctx$.yesToApple)(\"orange\", $ctx$.yesToOrange)(\"tomato\", $ctx$.yesToTomato);\n-          }\n-        },\n-        encapsulation: 2\n-      });\n-     `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain style interpolations of the same kind', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-             import {Component} from '@angular/core';\n-\n-             @Component({\n-               template: \\`<div\n-                                style.color=\"a{{one}}b\"\n-                                style.border=\"a{{one}}b\"\n-                                style.transition=\"a{{one}}b\"></div>\\`\n-             })\n-             export class MyComponent {\n-             }\n-         `\n-        }\n-      };\n-\n-      const template = `\n-       …\n-       MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-        …\n-        template: function MyComponent_Template(rf, $ctx$) {\n-          …\n-          if (rf & 2) {\n-            $r3$.ɵɵstylePropInterpolate1(\"color\", \"a\", ctx.one, \"b\")(\"border\", \"a\", ctx.one, \"b\")(\"transition\", \"a\", ctx.one, \"b\");\n-          }\n-        },\n-        encapsulation: 2\n-      });\n-     `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should chain style interpolations of multiple kinds', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-             import {Component} from '@angular/core';\n-\n-             @Component({\n-               template: \\`<div\n-                                style.color=\"a{{one}}b\"\n-                                style.border=\"a{{one}}b\"\n-                                style.transition=\"a{{one}}b{{two}}c\"\n-                                style.width=\"a{{one}}b{{two}}c\"\n-                                style.height=\"a{{one}}b{{two}}c{{three}}d\"\n-                                style.top=\"a{{one}}b{{two}}c{{three}}d\"></div>\\`\n-             })\n-             export class MyComponent {\n-             }\n-         `\n-        }\n-      };\n-\n-      const template = `\n-       …\n-       MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-        …\n-        template: function MyComponent_Template(rf, $ctx$) {\n-          …\n-          if (rf & 2) {\n-            $r3$.ɵɵstylePropInterpolate1(\"color\", \"a\", ctx.one, \"b\")(\"border\", \"a\", ctx.one, \"b\");\n-            $r3$.ɵɵstylePropInterpolate2(\"transition\", \"a\", ctx.one, \"b\", ctx.two, \"c\")(\"width\", \"a\", ctx.one, \"b\", ctx.two, \"c\");\n-            $r3$.ɵɵstylePropInterpolate3(\"height\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\")(\"top\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\");\n-          }\n-        },\n-        encapsulation: 2\n-      });\n-     `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-\n-    it('should break into multiple chains if there are other styling instructions in between',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-                  import {Component} from '@angular/core';\n-\n-                  @Component({\n-                    template: \\`<div\n-                                      style.color=\"a{{one}}b\"\n-                                      style.border=\"a{{one}}b\"\n-                                      [class.apple]=\"yesToApple\"\n-                                      [style.transition]=\"transition\"\n-                                      [class.orange]=\"yesToOrange\"\n-                                      [style.width]=\"width\"\n-                                      style.height=\"a{{one}}b\"\n-                                      style.top=\"a{{one}}b\"></div>\\`\n-                  })\n-                  export class MyComponent {\n-                    transition = 'all 1337ms ease';\n-                    width = '42px';\n-                    yesToApple = true;\n-                    yesToOrange = true;\n-                  }\n-              `\n-           }\n-         };\n-\n-         const template = `\n-            …\n-            MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-              …\n-              template: function MyComponent_Template(rf, $ctx$) {\n-                …\n-                if (rf & 2) {\n-                  $r3$.ɵɵstylePropInterpolate1(\"color\", \"a\", ctx.one, \"b\")(\"border\", \"a\", ctx.one, \"b\");\n-                  $r3$.ɵɵstyleProp(\"transition\", ctx.transition)(\"width\", ctx.width);\n-                  $r3$.ɵɵstylePropInterpolate1(\"height\", \"a\", ctx.one, \"b\")(\"top\", \"a\", ctx.one, \"b\");\n-                  $r3$.ɵɵclassProp(\"apple\", ctx.yesToApple)(\"orange\", ctx.yesToOrange);\n-                }\n-              },\n-              encapsulation: 2\n-            });\n-          `;\n-\n-         const result = compile(files, angularFiles);\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-\n-    it('should break into multiple chains if there are other styling interpolation instructions in between',\n-       () => {\n-         const files = {\n-           app: {\n-             'spec.ts': `\n-                  import {Component} from '@angular/core';\n-\n-                  @Component({\n-                    template: \\`<div\n-                                      style.color=\"a{{one}}b\"\n-                                      style.border=\"a{{one}}b\"\n-                                      style.transition=\"a{{one}}b{{two}}c\"\n-                                      style.width=\"a{{one}}b{{two}}c{{three}}d\"\n-                                      style.height=\"a{{one}}b\"\n-                                      style.top=\"a{{one}}b\"></div>\\`\n-                  })\n-                  export class MyComponent {\n-                    transition = 'all 1337ms ease';\n-                    width = '42px';\n-                  }\n-              `\n-           }\n-         };\n-\n-         const template = `\n-            …\n-            MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-              …\n-              template: function MyComponent_Template(rf, $ctx$) {\n-                …\n-                if (rf & 2) {\n-                  $r3$.ɵɵstylePropInterpolate1(\"color\", \"a\", ctx.one, \"b\")(\"border\", \"a\", ctx.one, \"b\");\n-                  $r3$.ɵɵstylePropInterpolate2(\"transition\", \"a\", ctx.one, \"b\", ctx.two, \"c\");\n-                  $r3$.ɵɵstylePropInterpolate3(\"width\", \"a\", ctx.one, \"b\", ctx.two, \"c\", ctx.three, \"d\");\n-                  $r3$.ɵɵstylePropInterpolate1(\"height\", \"a\", ctx.one, \"b\")(\"top\", \"a\", ctx.one, \"b\");\n-                }\n-              },\n-              encapsulation: 2\n-            });\n-          `;\n-\n-         const result = compile(files, angularFiles);\n-         expectEmit(result.source, template, 'Incorrect template');\n-       });\n-\n-    it('should chain styling instructions inside host bindings', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component, HostBinding} from '@angular/core';\n-\n-            @Component({\n-              template: '',\n-              host: {\n-                '[class.apple]': 'yesToApple',\n-                '[style.color]': 'color',\n-                '[class.tomato]': 'yesToTomato',\n-                '[style.transition]': 'transition'\n-              }\n-            })\n-            export class MyComponent {\n-              color = 'red';\n-              transition = 'all 1337ms ease';\n-              yesToApple = true;\n-              tesToTomato = false;\n-\n-              @HostBinding('style.border')\n-              border = '1px solid purple';\n-\n-              @HostBinding('class.orange')\n-              yesToOrange = true;\n-            }\n-           `\n-        }\n-      };\n-\n-      const template = `\n-         …\n-         MyComponent.ɵcmp = /*@__PURE__*/ $r3$.ɵɵdefineComponent({\n-          …\n-          hostBindings: function MyComponent_HostBindings(rf, $ctx$) {\n-            …\n-            if (rf & 2) {\n-              $r3$.ɵɵstyleProp(\"color\", $ctx$.color)(\"transition\", $ctx$.transition)(\"border\", $ctx$.border);\n-              $r3$.ɵɵclassProp(\"apple\", $ctx$.yesToApple)(\"tomato\", $ctx$.yesToTomato)(\"orange\", $ctx$.yesToOrange);\n-            }\n-          },\n-          …\n-        });\n-       `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-  });\n-\n-  it('should count only non-style and non-class host bindings on Components', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Component, NgModule, HostBinding} from '@angular/core';\n-\n-          @Component({\n-            selector: 'my-component',\n-            template: '',\n-            host: {\n-              'style': 'width:200px; height:500px',\n-              'class': 'foo baz',\n-              'title': 'foo title'\n-            }\n-          })\n-          export class MyComponent {\n-            @HostBinding('style')\n-            myStyle = {width:'100px'};\n-\n-            @HostBinding('class')\n-            myClass = {bar:false};\n-\n-            @HostBinding('id')\n-            id = 'some id';\n-\n-            @HostBinding('title')\n-            title = 'some title';\n-\n-            @Input('name')\n-            name = '';\n-          }\n-\n-          @NgModule({declarations: [MyComponent]})\n-          export class MyModule {}\n-        `\n-      }\n-    };\n-\n-    const template = `\n-      hostAttrs: [\"title\", \"foo title\", ${AttributeMarker.Classes}, \"foo\", \"baz\", ${\n-        AttributeMarker.Styles}, \"width\", \"200px\", \"height\", \"500px\"],\n-      hostVars: 6,\n-      hostBindings: function MyComponent_HostBindings(rf, ctx) {\n-        if (rf & 2) {\n-          $r3$.ɵɵhostProperty(\"id\", ctx.id)(\"title\", ctx.title);\n-          $r3$.ɵɵstyleMap(ctx.myStyle);\n-          $r3$.ɵɵclassMap(ctx.myClass);\n-        }\n-      }\n-    `;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should count only non-style and non-class host bindings on Directives', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Directive, Component, NgModule, HostBinding} from '@angular/core';\n-\n-          @Directive({selector: '[myWidthDir]'})\n-          export class WidthDirective {\n-            @HostBinding('style.width')\n-            myWidth = 200;\n-\n-            @HostBinding('class.foo')\n-            myFooClass = true;\n-\n-            @HostBinding('id')\n-            id = 'some id';\n-\n-            @HostBinding('title')\n-            title = 'some title';\n-          }\n-        `\n-      }\n-    };\n-\n-    const template = `\n-    hostVars: 6,\n-    hostBindings: function WidthDirective_HostBindings(rf, ctx) {\n-        if (rf & 2) {\n-          $r3$.ɵɵhostProperty(\"id\", ctx.id)(\"title\", ctx.title);\n-          $r3$.ɵɵstyleProp(\"width\", ctx.myWidth);\n-          $r3$.ɵɵclassProp(\"foo\", ctx.myFooClass);\n-        }\n-      }\n-    `;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  describe('new styling refactor', () => {\n-    it('should generate the correct amount of host bindings when styling is present', () => {\n-      const files = {\n-        app: {\n-          'spec.ts': `\n-            import {Component, Directive, NgModule} from '@angular/core';\n-\n-            @Directive({\n-              selector: '[my-dir]',\n-              host: {\n-                '[title]': 'title',\n-                '[class.foo]': 'foo',\n-                '[@anim]': \\`{\n-                  value: _animValue,\n-                  params: {\n-                    param1: _animParam1,\n-                    param2: _animParam2\n-                  }\n-                }\\`\n-              }\n-            })\n-            export class MyDir {\n-              title = '';\n-              foo = true;\n-              _animValue = null;\n-              _animParam1 = null;\n-              _animParam2 = null;\n-            }\n-\n-            @Component({\n-              selector: 'my-app',\n-              template: \\`\n-                <div my-dir></div>\n-              \\`\n-            })\n-            export class MyAppComp {}\n-\n-            @NgModule({declarations: [MyAppComp, MyDir]})\n-            export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const template = `\n-          hostVars: 10,\n-          hostBindings: function MyDir_HostBindings(rf, ctx) {\n-            if (rf & 2) {\n-              $r3$.ɵɵhostProperty(\"title\", ctx.title);\n-              $r3$.ɵɵsyntheticHostProperty(\"@anim\",\n-                $r3$.ɵɵpureFunction2(7, _c1, ctx._animValue,\n-                $r3$.ɵɵpureFunction2(4, _c0, ctx._animParam1, ctx._animParam2)));\n-              $r3$.ɵɵclassProp(\"foo\", ctx.foo);\n-            }\n-          }\n-      `;\n-\n-      const result = compile(files, angularFiles);\n-      expectEmit(result.source, template, 'Incorrect template');\n-    });\n-  });\n-});"
        },
        {
            "sha": "26fd0703e4b542632dca123c320cb9c141861ad5",
            "filename": "packages/compiler-cli/test/compliance_old/r3_view_compiler_template_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 874,
            "changes": 874,
            "blob_url": "https://github.com/angular/angular/blob/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_template_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e16d234709eedd808ca9a11a7943a464905fe94d/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_template_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance_old%2Fr3_view_compiler_template_spec.ts?ref=e16d234709eedd808ca9a11a7943a464905fe94d",
            "patch": "@@ -1,874 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {AttributeMarker} from '@angular/compiler/src/core';\n-import {setup} from '@angular/compiler/test/aot/test_util';\n-import {compile, expectEmit} from './mock_compile';\n-\n-describe('compiler compliance: template', () => {\n-  const angularFiles = setup({\n-    compileAngular: false,\n-    compileFakeCore: true,\n-    compileAnimations: false,\n-  });\n-\n-  it('should correctly bind to context in nested template', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`\n-                  <ul *ngFor=\"let outer of items\">\n-                    <li *ngFor=\"let middle of outer.items\">\n-                      <div *ngFor=\"let inner of items\"\n-                           (click)=\"onClick(outer, middle, inner)\"\n-                           [title]=\"format(outer, middle, inner, component)\"\n-                           >\n-                        {{format(outer, middle, inner, component)}}\n-                      </div>\n-                    </li>\n-                  </ul>\\`\n-              })\n-              export class MyComponent {\n-                component = this;\n-                format(outer: any, middle: any, inner: any) { }\n-                onClick(outer: any, middle: any, inner: any) { }\n-              }\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    // The template should look like this (where IDENT is a wild card for an identifier):\n-    const template = `\n-      function MyComponent_ul_0_li_1_div_1_Template(rf, ctx) {\n-        if (rf & 1) {\n-          const $s$ = $i0$.ɵɵgetCurrentView();\n-          $i0$.ɵɵelementStart(0, \"div\", 2);\n-          $i0$.ɵɵlistener(\"click\", function MyComponent_ul_0_li_1_div_1_Template_div_click_0_listener(){\n-            const $sr$ = $i0$.ɵɵrestoreView($s$);\n-            const $inner$ = $sr$.$implicit;\n-            const $middle$ = $i0$.ɵɵnextContext().$implicit;\n-            const $outer$ = $i0$.ɵɵnextContext().$implicit;\n-            const $myComp$ = $i0$.ɵɵnextContext();\n-            return $myComp$.onClick($outer$, $middle$, $inner$);\n-          });\n-          $i0$.ɵɵtext(1);\n-          $i0$.ɵɵelementEnd();\n-        }\n-\n-        if (rf & 2) {\n-          const $inner1$ = ctx.$implicit;\n-          const $middle1$ = $i0$.ɵɵnextContext().$implicit;\n-          const $outer1$ = $i0$.ɵɵnextContext().$implicit;\n-          const $myComp1$ = $i0$.ɵɵnextContext();\n-          $i0$.ɵɵproperty(\"title\", $myComp1$.format($outer1$, $middle1$, $inner1$, $myComp1$.component));\n-          $r3$.ɵɵadvance(1);\n-          $i0$.ɵɵtextInterpolate1(\" \", $myComp1$.format($outer1$, $middle1$, $inner1$, $myComp1$.component), \" \");\n-        }\n-      }\n-\n-      function MyComponent_ul_0_li_1_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵelementStart(0, \"li\");\n-          $i0$.ɵɵtemplate(1, MyComponent_ul_0_li_1_div_1_Template, 2, 2, \"div\", 1);\n-          $i0$.ɵɵelementEnd();\n-        }\n-        if (rf & 2) {\n-          const $myComp2$ = $i0$.ɵɵnextContext(2);\n-          $r3$.ɵɵadvance(1);\n-          $i0$.ɵɵproperty(\"ngForOf\", $myComp2$.items);\n-        }\n-      }\n-\n-      function MyComponent_ul_0_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵelementStart(0, \"ul\");\n-          $i0$.ɵɵtemplate(1, MyComponent_ul_0_li_1_Template, 2, 1, \"li\", 0);\n-          $i0$.ɵɵelementEnd();\n-        }\n-        if (rf & 2) {\n-          const $outer2$ = ctx.$implicit;\n-          $r3$.ɵɵadvance(1);\n-          $i0$.ɵɵproperty(\"ngForOf\", $outer2$.items);\n-        }\n-      }\n-      // ...\n-      consts: [[${AttributeMarker.Template}, \"ngFor\", \"ngForOf\"], [${\n-        AttributeMarker.Bindings}, \"title\", \"click\", ${\n-        AttributeMarker.Template}, \"ngFor\", \"ngForOf\"], [${\n-        AttributeMarker.Bindings}, \"title\", \"click\"]],\n-      template:function MyComponent_Template(rf, ctx){\n-        if (rf & 1) {\n-          $i0$.ɵɵtemplate(0, MyComponent_ul_0_Template, 2, 1, \"ul\", 0);\n-        }\n-        if (rf & 2) {\n-          $i0$.ɵɵproperty(\"ngForOf\", ctx.items);\n-        }\n-      }`;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should correctly bind to context in nested template with many bindings', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`\n-                  <div *ngFor=\"let d of _data; let i = index\" (click)=\"_handleClick(d, i)\"></div>\n-                \\`\n-              })\n-              export class MyComponent {\n-                _data = [1,2,3];\n-                _handleClick(d: any, i: any) {}\n-              }\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const template = `\n-        function MyComponent_div_0_Template(rf, ctx) {\n-          if (rf & 1) {\n-            const $s$ = $r3$.ɵɵgetCurrentView();\n-            $r3$.ɵɵelementStart(0, \"div\", 1);\n-            $r3$.ɵɵlistener(\"click\", function MyComponent_div_0_Template_div_click_0_listener() {\n-              const $sr$ = $r3$.ɵɵrestoreView($s$);\n-              const $d$ = $sr$.$implicit;\n-              const $i$ = $sr$.index;\n-              const $comp$ = $r3$.ɵɵnextContext();\n-              return $comp$._handleClick($d$, $i$);\n-            });\n-            $r3$.ɵɵelementEnd();\n-          }\n-        }\n-        // ...\n-        consts: [[${AttributeMarker.Bindings}, \"click\", ${\n-        AttributeMarker.Template}, \"ngFor\", \"ngForOf\"], [${AttributeMarker.Bindings}, \"click\"]],\n-        template: function MyComponent_Template(rf, ctx) {\n-          if (rf & 1) {\n-            $r3$.ɵɵtemplate(0, MyComponent_div_0_Template, 1, 0, \"div\", 0);\n-          }\n-          if (rf & 2) {\n-            $r3$.ɵɵproperty(\"ngForOf\", ctx._data);\n-          }\n-        }\n-        `;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should correctly bind to implicit receiver in template', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-\n-          @Component({\n-            selector: 'my-component',\n-            template: \\`\n-              <div *ngIf=\"true\" (click)=\"greet(this)\"></div>\n-              <div *ngIf=\"true\" [id]=\"this\"></div>\n-            \\`\n-          })\n-          export class MyComponent {\n-            greet(val: any) {}\n-          }\n-\n-          @NgModule({declarations: [MyComponent]})\n-          export class MyModule {}\n-        `\n-      }\n-    };\n-\n-    const template = `\n-      function MyComponent_div_0_Template(rf, ctx) {\n-        if (rf & 1) {\n-          const $_r2$ = i0.ɵɵgetCurrentView();\n-          $r3$.ɵɵelementStart(0, \"div\", 2);\n-          $r3$.ɵɵlistener(\"click\", function MyComponent_div_0_Template_div_click_0_listener() {\n-            i0.ɵɵrestoreView($_r2$);\n-            const $ctx_r1$ = i0.ɵɵnextContext();\n-            return $ctx_r1$.greet($ctx_r1$);\n-          });\n-          $r3$.ɵɵelementEnd();\n-        }\n-      }\n-      // ...\n-      function MyComponent_div_1_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $r3$.ɵɵelement(0, \"div\", 3);\n-        } if (rf & 2) {\n-          const $ctx_0$ = i0.ɵɵnextContext();\n-          $r3$.ɵɵproperty(\"id\", $ctx_0$);\n-        }\n-      }\n-    `;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should support ngFor context variables', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`\n-                    <span *ngFor=\"let item of items; index as i\">\n-                      {{ i }} - {{ item }}\n-                    </span>\\`\n-              })\n-              export class MyComponent {}\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const template = `\n-      function MyComponent_span_0_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵelementStart(0, \"span\");\n-          $i0$.ɵɵtext(1);\n-          $i0$.ɵɵelementEnd();\n-        }\n-        if (rf & 2) {\n-          const $item$ = ctx.$implicit;\n-          const $i$ = ctx.index;\n-          $r3$.ɵɵadvance(1);\n-          $i0$.ɵɵtextInterpolate2(\" \", $i$, \" - \", $item$, \" \");\n-        }\n-      }\n-      // ...\n-      consts: [[${AttributeMarker.Template}, \"ngFor\", \"ngForOf\"]],\n-      template:function MyComponent_Template(rf, ctx){\n-        if (rf & 1) {\n-          $i0$.ɵɵtemplate(0, MyComponent_span_0_Template, 2, 2, \"span\", 0);\n-        }\n-        if (rf & 2) {\n-          $i0$.ɵɵproperty(\"ngForOf\", ctx.items);\n-        }\n-      }`;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should support ngFor context variables in parent views', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`\n-                  <div *ngFor=\"let item of items; index as i\">\n-                      <span *ngIf=\"showing\">\n-                        {{ i }} - {{ item }}\n-                      </span>\n-                  </div>\\`\n-              })\n-              export class MyComponent {}\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const template = `\n-      function MyComponent_div_0_span_1_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵelementStart(0, \"span\");\n-          $i0$.ɵɵtext(1);\n-          $i0$.ɵɵelementEnd();\n-        }\n-        if (rf & 2) {\n-          const $div$ = $i0$.ɵɵnextContext();\n-          const $i$ = $div$.index;\n-          const $item$ = $div$.$implicit;\n-          $r3$.ɵɵadvance(1);\n-          $i0$.ɵɵtextInterpolate2(\" \", $i$, \" - \", $item$, \" \");\n-        }\n-      }\n-\n-      function MyComponent_div_0_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵelementStart(0, \"div\");\n-          $i0$.ɵɵtemplate(1, MyComponent_div_0_span_1_Template, 2, 2, \"span\", 1);\n-          $i0$.ɵɵelementEnd();\n-        }\n-        if (rf & 2) {\n-          const $app$ = $i0$.ɵɵnextContext();\n-          $r3$.ɵɵadvance(1);\n-          $i0$.ɵɵproperty(\"ngIf\", $app$.showing);\n-        }\n-      }\n-\n-      // ...\n-      consts: [[${AttributeMarker.Template}, \"ngFor\", \"ngForOf\"], [${\n-        AttributeMarker.Template}, \"ngIf\"]],\n-      template:function MyComponent_Template(rf, ctx){\n-        if (rf & 1) {\n-          $i0$.ɵɵtemplate(0, MyComponent_div_0_Template, 2, 1, \"div\", 0);\n-        }\n-        if (rf & 2) {\n-          $i0$.ɵɵproperty(\"ngForOf\", ctx.items);\n-        }\n-      }`;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should correctly skip contexts as needed', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`\n-                  <div *ngFor=\"let outer of items\">\n-                    <div *ngFor=\"let middle of outer.items\">\n-                      <div *ngFor=\"let inner of middle.items\">\n-                        {{ middle.value }} - {{ name }}\n-                      </div>\n-                    </div>\n-                  </div>\\`\n-              })\n-              export class MyComponent {}\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    // The template should look like this (where IDENT is a wild card for an identifier):\n-    const template = `\n-      function MyComponent_div_0_div_1_div_1_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵelementStart(0, \"div\");\n-          $i0$.ɵɵtext(1);\n-          $i0$.ɵɵelementEnd();\n-        }\n-        if (rf & 2) {\n-          const $middle$ = $i0$.ɵɵnextContext().$implicit;\n-          const $myComp$ = $i0$.ɵɵnextContext(2);\n-          $r3$.ɵɵadvance(1);\n-          $i0$.ɵɵtextInterpolate2(\" \", $middle$.value, \" - \", $myComp$.name, \" \");\n-        }\n-      }\n-\n-      function MyComponent_div_0_div_1_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵelementStart(0, \"div\");\n-          $i0$.ɵɵtemplate(1, MyComponent_div_0_div_1_div_1_Template, 2, 2, \"div\", 0);\n-          $i0$.ɵɵelementEnd();\n-        }\n-        if (rf & 2) {\n-          const $middle$ = ctx.$implicit;\n-          $r3$.ɵɵadvance(1);\n-          $i0$.ɵɵproperty(\"ngForOf\", $middle$.items);\n-        }\n-      }\n-\n-      function MyComponent_div_0_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵelementStart(0, \"div\");\n-          $i0$.ɵɵtemplate(1, MyComponent_div_0_div_1_Template, 2, 1, \"div\", 0);\n-          $i0$.ɵɵelementEnd();\n-        }\n-        if (rf & 2) {\n-          const $outer$ = ctx.$implicit;\n-          $r3$.ɵɵadvance(1);\n-          $i0$.ɵɵproperty(\"ngForOf\", $outer$.items);\n-        }\n-      }\n-      // ...\n-      consts: [[${AttributeMarker.Template}, \"ngFor\", \"ngForOf\"]],\n-      template:function MyComponent_Template(rf, ctx){\n-        if (rf & 1) {\n-          $i0$.ɵɵtemplate(0, MyComponent_div_0_Template, 2, 1, \"div\", 0);\n-        }\n-        if (rf & 2) {\n-          $i0$.ɵɵproperty(\"ngForOf\", ctx.items);\n-        }\n-      }`;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should support <ng-template>', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`\n-                  <ng-template [boundAttr]=\"b\" attr=\"l\">\n-                    some-content\n-                  </ng-template>\\`\n-              })\n-              export class MyComponent {}\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const template = `\n-      function MyComponent_ng_template_0_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵtext(0, \" some-content \");\n-        }\n-      }\n-\n-      // ...\n-\n-      consts: [[\"attr\", \"l\", ${AttributeMarker.Bindings}, \"boundAttr\"]],\n-      template: function MyComponent_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵtemplate(0, MyComponent_ng_template_0_Template, 1, 0, \"ng-template\", 0);\n-        }\n-        if (rf & 2) {\n-          $i0$.ɵɵproperty(\"boundAttr\", ctx.b);\n-        }\n-      }`;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should support local refs on <ng-template>', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: '<ng-template #foo>some-content</ng-template>',\n-              })\n-              export class MyComponent {}\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const template = `\n-      function MyComponent_ng_template_0_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵtext(0, \"some-content\");\n-        }\n-      }\n-\n-      // ...\n-      consts: [[\"foo\", \"\"]],\n-      template: function MyComponent_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵtemplate(0, MyComponent_ng_template_0_Template, 1, 0, \"ng-template\", null, 0, $i0$.ɵɵtemplateRefExtractor);\n-        }\n-      }`;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should support directive outputs on <ng-template>', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: '<ng-template (outDirective)=\"$event.doSth()\"></ng-template>',\n-              })\n-              export class MyComponent {}\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const template = `\n-      function MyComponent_ng_template_0_Template(rf, ctx) { }\n-\n-      // ...\n-\n-      consts: [[${AttributeMarker.Bindings}, \"outDirective\"]],\n-      template: function MyComponent_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵtemplate(0, MyComponent_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n-          $i0$.ɵɵlistener(\"outDirective\", function MyComponent_Template_ng_template_outDirective_0_listener($event) { return $event.doSth(); });\n-        }\n-      }`;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should allow directive inputs as an interpolated prop on <ng-template>', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Component, Directive, Input} from '@angular/core';\n-\n-          @Directive({selector: '[dir]'})\n-          class WithInput {\n-            @Input() dir: string = '';\n-          }\n-\n-          @Component({\n-            selector: 'my-app',\n-            template: '<ng-template dir=\"{{ message }}\"></ng-template>',\n-          })\n-          export class TestComp {\n-            message = 'Hello';\n-          }\n-        `\n-      }\n-    };\n-    const result = compile(files, angularFiles);\n-    const expectedTemplate = `\n-      consts: [[${AttributeMarker.Bindings}, \"dir\"]],\n-      template: function TestComp_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵtemplate(0, $TestComp_ng_template_0_Template$, 0, 0, \"ng-template\", 0);\n-        }\n-        if (rf & 2) {\n-          $i0$.ɵɵpropertyInterpolate(\"dir\", ctx.message);\n-        }\n-      },\n-    `;\n-    expectEmit(result.source, expectedTemplate, 'Incorrect template');\n-  });\n-\n-  it('should allow directive inputs as an interpolated prop on <ng-template> (with structural directives)',\n-     () => {\n-       const files = {\n-         app: {\n-           'spec.ts': `\n-              import {Component, Directive, Input} from '@angular/core';\n-\n-              @Directive({selector: '[dir]'})\n-              class WithInput {\n-                @Input() dir: string = '';\n-              }\n-\n-              @Component({\n-                selector: 'my-app',\n-                template: '<ng-template *ngIf=\"true\" dir=\"{{ message }}\"></ng-template>',\n-              })\n-              export class TestComp {\n-                message = 'Hello';\n-              }\n-            `\n-         }\n-       };\n-       const result = compile(files, angularFiles);\n-\n-       // Expect that `ɵɵpropertyInterpolate` is generated in the inner template function.\n-       const expectedInnerTemplate = `\n-          function $TestComp_0_Template$(rf, ctx) {\n-            if (rf & 1) {\n-              $i0$.ɵɵtemplate(0, $TestComp_0_ng_template_0_Template$, 0, 0, \"ng-template\", 1);\n-            }\n-            if (rf & 2) {\n-              const $ctx_r0$ = i0.ɵɵnextContext();\n-              $i0$.ɵɵpropertyInterpolate(\"dir\", $ctx_r0$.message);\n-            }\n-          }\n-        `;\n-       expectEmit(result.source, expectedInnerTemplate, 'Incorrect template');\n-\n-       // Main template should just contain *ngIf property.\n-       const expectedMainTemplate = `\n-          consts: [[4, \"ngIf\"], [3, \"dir\"]],\n-          template: function TestComp_Template(rf, ctx) {\n-            if (rf & 1) {\n-              $i0$.ɵɵtemplate(0, $TestComp_0_Template$, 1, 1, undefined, 0);\n-            }\n-            if (rf & 2) {\n-              $i0$.ɵɵproperty(\"ngIf\", true);\n-            }\n-          },\n-        `;\n-       expectEmit(result.source, expectedMainTemplate, 'Incorrect template');\n-     });\n-\n-  it('should create unique template function names even for similar nested template structures',\n-     () => {\n-       const files = {\n-         app: {\n-           'spec1.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-\n-          @Component({\n-            selector: 'a-component',\n-            template: \\`\n-              <div *ngFor=\"let item of items\">\n-                <p *ngIf=\"item < 10\">less than 10</p>\n-                <p *ngIf=\"item < 10\">less than 10</p>\n-              </div>\n-              <div *ngFor=\"let item of items\">\n-                <p *ngIf=\"item > 10\">more than 10</p>\n-              </div>\n-            \\`,\n-          })\n-          export class AComponent {\n-            items = [4, 2];\n-          }\n-\n-          @NgModule({declarations: [AComponent]})\n-          export class AModule {}\n-        `,\n-           'spec2.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-\n-          @Component({\n-            selector: 'b-component',\n-            template: \\`\n-              <div *ngFor=\"let item of items\">\n-                <ng-container *ngFor=\"let subitem of item.subitems\">\n-                  <p *ngIf=\"subitem < 10\">less than 10</p>\n-                  <p *ngIf=\"subitem < 10\">less than 10</p>\n-                </ng-container>\n-                <ng-container *ngFor=\"let subitem of item.subitems\">\n-                  <p *ngIf=\"subitem < 10\">less than 10</p>\n-                </ng-container>\n-              </div>\n-              <div *ngFor=\"let item of items\">\n-                <ng-container *ngFor=\"let subitem of item.subitems\">\n-                  <p *ngIf=\"subitem > 10\">more than 10</p>\n-                </ng-container>\n-              </div>\n-            \\`,\n-          })\n-          export class BComponent {\n-            items = [\n-              {subitems: [1, 3]},\n-              {subitems: [3, 7]},\n-            ];\n-          }\n-\n-          @NgModule({declarations: [BComponent]})\n-          export class BModule {}\n-        `,\n-         },\n-       };\n-\n-       const result = compile(files, angularFiles);\n-\n-       const allTemplateFunctionsNames = (result.source.match(/function ([^\\s(]+)/g) || [])\n-                                             .map(x => x.slice(9))\n-                                             .filter(x => x.includes('Template'))\n-                                             .sort();\n-       const uniqueTemplateFunctionNames = Array.from(new Set(allTemplateFunctionsNames));\n-\n-       // Expected template function:\n-       // - 5 for AComponent's template.\n-       // - 9 for BComponent's template.\n-       // - 2 for the two components.\n-       expect(allTemplateFunctionsNames.length).toBe(5 + 9 + 2);\n-       expect(allTemplateFunctionsNames).toEqual(uniqueTemplateFunctionNames);\n-     });\n-\n-  it('should create unique template function names for ng-content templates', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-\n-          @Component({\n-            selector: 'a-component',\n-            template: \\`\n-              <ng-content *ngIf=\"show\"></ng-content>\n-            \\`,\n-          })\n-          export class AComponent {\n-            show = true;\n-          }\n-\n-          @Component({\n-            selector: 'b-component',\n-            template: \\`\n-              <ng-content *ngIf=\"show\"></ng-content>\n-            \\`,\n-          })\n-          export class BComponent {\n-            show = true;\n-          }\n-\n-          @NgModule({declarations: [AComponent, BComponent]})\n-          export class AModule {}\n-        `\n-      },\n-    };\n-\n-    const result = compile(files, angularFiles);\n-\n-    const allTemplateFunctionsNames = (result.source.match(/function ([^\\s(]+)/g) || [])\n-                                          .map(x => x.slice(9))\n-                                          .filter(x => x.includes('Template'))\n-                                          .sort();\n-    const uniqueTemplateFunctionNames = Array.from(new Set(allTemplateFunctionsNames));\n-\n-    // Expected template function:\n-    // - 1 for AComponent's template.\n-    // - 1 for BComponent's template.\n-    // - 2 for the two components.\n-    expect(allTemplateFunctionsNames.length).toBe(1 + 1 + 2);\n-    expect(allTemplateFunctionsNames).toEqual(uniqueTemplateFunctionNames);\n-  });\n-\n-  it('should create unique listener function names even for similar nested template structures',\n-     () => {\n-       const files = {\n-         app: {\n-           'spec.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-\n-          @Component({\n-            selector: 'my-component',\n-            template: \\`\n-              <div *ngFor=\"let item of items\">\n-                <p (click)=\"$event\">{{ item }}</p>\n-                <p (click)=\"$event\">{{ item }}</p>\n-              </div>\n-              <div *ngFor=\"let item of items\">\n-                <p (click)=\"$event\">{{ item }}</p>\n-              </div>\n-            \\`,\n-          })\n-          export class MyComponent {\n-            items = [4, 2];\n-          }\n-\n-          @NgModule({declarations: [MyComponent]})\n-          export class MyModule {}\n-        `,\n-         },\n-       };\n-\n-       const result = compile(files, angularFiles);\n-\n-       const allListenerFunctionsNames = (result.source.match(/function ([^\\s(]+)/g) || [])\n-                                             .map(x => x.slice(9))\n-                                             .filter(x => x.includes('listener'))\n-                                             .sort();\n-       const uniqueListenerFunctionNames = Array.from(new Set(allListenerFunctionsNames));\n-\n-       expect(allListenerFunctionsNames.length).toBe(3);\n-       expect(allListenerFunctionsNames).toEqual(uniqueListenerFunctionNames);\n-     });\n-\n-  it('should support pipes in template bindings', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-              import {Component, NgModule} from '@angular/core';\n-\n-              @Component({\n-                selector: 'my-component',\n-                template: \\`\n-                  <div *ngIf=\"val | pipe\"></div>\\`\n-              })\n-              export class MyComponent {}\n-\n-              @NgModule({declarations: [MyComponent]})\n-              export class MyModule {}\n-          `\n-      }\n-    };\n-\n-    const template = `\n-      function MyComponent_div_0_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵelement(0, \"div\");\n-        }\n-      }\n-\n-      // ...\n-      consts: [[${AttributeMarker.Template}, \"ngIf\"]],\n-      template: function MyComponent_Template(rf, ctx) {\n-        if (rf & 1) {\n-          $i0$.ɵɵtemplate(0, MyComponent_div_0_Template, 1, 0, \"div\", 0);\n-          $i0$.ɵɵpipe(1, \"pipe\");\n-        } if (rf & 2) {\n-          $i0$.ɵɵproperty(\"ngIf\", $i0$.ɵɵpipeBind1(1, 1, ctx.val));\n-        }\n-      }`;\n-\n-    const result = compile(files, angularFiles);\n-\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-\n-  it('should safely nest ternary operations', () => {\n-    const files = {\n-      app: {\n-        'spec.ts': `\n-            import {Component, NgModule} from '@angular/core';\n-\n-            @Component({\n-              selector: 'my-component',\n-              template: \\`\n-                {{a?.b ? 1 : 2 }}\\`\n-            })\n-            export class MyComponent {}\n-\n-            @NgModule({declarations: [MyComponent]})\n-            export class MyModule {}\n-        `\n-      }\n-    };\n-\n-    const template = `i0.ɵɵtextInterpolate1(\" \", (ctx.a == null ? null : ctx.a.b) ? 1 : 2, \"\")`;\n-\n-    const result = compile(files, angularFiles);\n-    expectEmit(result.source, template, 'Incorrect template');\n-  });\n-});"
        }
    ],
    "stats": {
        "total": 13840,
        "additions": 0,
        "deletions": 13840
    }
}