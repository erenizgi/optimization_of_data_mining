{
    "author": "bjarkler",
    "message": "feat(core): create a Trusted Types policy for JIT compiler (#39210)\n\nIntroduce a Trusted Types policy for use by Angular's JIT compiler named\nangular#unsafe-jit. As the compiler turns arbitrary untrusted strings\ninto executable code at runtime, using Angular's main Trusted Types\npolicy does not seem appropriate, unless it can be ensured that the\nprovided strings are indeed trusted. Until then, this JIT policy can be\nallowed by applications that rely on the JIT compiler but want to\nenforce Trusted Types, knowing that a compromise of the JIT compiler can\nlead to arbitrary script execution. In particular, this is required for\nenabling Trusted Types in Angular unit tests, since they make use of the\nJIT compiler.\n\nAlso export the internal Trusted Types definitions from the core package\nso that they can be used in the compiler package.\n\nPR Close #39210",
    "sha": "6570292672607264c669069e0fe8a52e2d223d1f",
    "files": [
        {
            "sha": "242f7105c793868a02676ea5967f98e71a8faba6",
            "filename": "packages/compiler/src/output/output_jit_trusted_types.ts",
            "status": "added",
            "additions": 135,
            "deletions": 0,
            "changes": 135,
            "blob_url": "https://github.com/angular/angular/blob/6570292672607264c669069e0fe8a52e2d223d1f/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_jit_trusted_types.ts",
            "raw_url": "https://github.com/angular/angular/raw/6570292672607264c669069e0fe8a52e2d223d1f/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_jit_trusted_types.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_jit_trusted_types.ts?ref=6570292672607264c669069e0fe8a52e2d223d1f",
            "patch": "@@ -0,0 +1,135 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/**\n+ * @fileoverview\n+ * A module to facilitate use of a Trusted Types policy within the JIT\n+ * compiler. It lazily constructs the Trusted Types policy, providing helper\n+ * utilities for promoting strings to Trusted Types. When Trusted Types are not\n+ * available, strings are used as a fallback.\n+ * @security All use of this module is security-sensitive and should go through\n+ * security review.\n+ */\n+\n+import {global} from '../util';\n+\n+/**\n+ * While Angular only uses Trusted Types internally for the time being,\n+ * references to Trusted Types could leak into our core.d.ts, which would force\n+ * anyone compiling against @angular/core to provide the @types/trusted-types\n+ * package in their compilation unit.\n+ *\n+ * Until https://github.com/microsoft/TypeScript/issues/30024 is resolved, we\n+ * will keep Angular's public API surface free of references to Trusted Types.\n+ * For internal and semi-private APIs that need to reference Trusted Types, the\n+ * minimal type definitions for the Trusted Types API provided by this module\n+ * should be used instead.\n+ *\n+ * Adapted from\n+ * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/trusted-types/index.d.ts\n+ * but restricted to the API surface used within Angular.\n+ */\n+\n+export type TrustedScript = {\n+  __brand__: 'TrustedScript'\n+};\n+\n+export interface TrustedTypePolicyFactory {\n+  createPolicy(policyName: string, policyOptions: {\n+    createScript?: (input: string) => string,\n+  }): TrustedTypePolicy;\n+}\n+\n+export interface TrustedTypePolicy {\n+  createScript(input: string): TrustedScript;\n+}\n+\n+\n+/**\n+ * The Trusted Types policy, or null if Trusted Types are not\n+ * enabled/supported, or undefined if the policy has not been created yet.\n+ */\n+let policy: TrustedTypePolicy|null|undefined;\n+\n+/**\n+ * Returns the Trusted Types policy, or null if Trusted Types are not\n+ * enabled/supported. The first call to this function will create the policy.\n+ */\n+function getPolicy(): TrustedTypePolicy|null {\n+  if (policy === undefined) {\n+    policy = null;\n+    if (global.trustedTypes) {\n+      try {\n+        policy =\n+            (global.trustedTypes as TrustedTypePolicyFactory).createPolicy('angular#unsafe-jit', {\n+              createScript: (s: string) => s,\n+            });\n+      } catch {\n+        // trustedTypes.createPolicy throws if called with a name that is\n+        // already registered, even in report-only mode. Until the API changes,\n+        // catch the error not to break the applications functionally. In such\n+        // cases, the code will fall back to using strings.\n+      }\n+    }\n+  }\n+  return policy;\n+}\n+\n+/**\n+ * Unsafely promote a string to a TrustedScript, falling back to strings when\n+ * Trusted Types are not available.\n+ * @security In particular, it must be assured that the provided string will\n+ * never cause an XSS vulnerability if used in a context that will be\n+ * interpreted and executed as a script by a browser, e.g. when calling eval.\n+ */\n+function trustedScriptFromString(script: string): TrustedScript|string {\n+  return getPolicy()?.createScript(script) || script;\n+}\n+\n+/**\n+ * Unsafely call the Function constructor with the given string arguments. It\n+ * is only available in development mode, and should be stripped out of\n+ * production code.\n+ * @security This is a security-sensitive function; any use of this function\n+ * must go through security review. In particular, it must be assured that it\n+ * is only called from the JIT compiler, as use in other code can lead to XSS\n+ * vulnerabilities.\n+ */\n+export function newTrustedFunctionForJIT(...args: string[]): Function {\n+  if (!global.trustedTypes) {\n+    // In environments that don't support Trusted Types, fall back to the most\n+    // straightforward implementation:\n+    return new Function(...args);\n+  }\n+\n+  // Chrome currently does not support passing TrustedScript to the Function\n+  // constructor. The following implements the workaround proposed on the page\n+  // below, where the Chromium bug is also referenced:\n+  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n+  const fnArgs = args.slice(0, -1).join(',');\n+  const fnBody = args.pop()!.toString();\n+  const body = `(function anonymous(${fnArgs}\n+) { ${fnBody}\n+})`;\n+\n+  // Using eval directly confuses the compiler and prevents this module from\n+  // being stripped out of JS binaries even if not used. The global['eval']\n+  // indirection fixes that.\n+  const fn = global['eval'](trustedScriptFromString(body) as string) as Function;\n+\n+  // To completely mimic the behavior of calling \"new Function\", two more\n+  // things need to happen:\n+  // 1. Stringifying the resulting function should return its source code\n+  fn.toString = () => body;\n+  // 2. When calling the resulting function, `this` should refer to `global`\n+  return fn.bind(global);\n+\n+  // When Trusted Types support in Function constructors is widely available,\n+  // the implementation of this function can be simplified to:\n+  // return new Function(...args.map(a => trustedScriptFromString(a)));\n+}"
        }
    ],
    "stats": {
        "total": 135,
        "additions": 135,
        "deletions": 0
    }
}