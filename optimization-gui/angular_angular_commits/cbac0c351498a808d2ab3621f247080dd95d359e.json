{
    "author": "atscott",
    "message": "docs: Add documentation and TODOs for cleanup (#43391)\n\n* Document `currentUrlTree`, `browserUrlTree`, and `rawUrlTree`\n* Add a couple `TODO` comments to investigate changes based on understanding\n\nPR Close #43391",
    "sha": "cbac0c351498a808d2ab3621f247080dd95d359e",
    "files": [
        {
            "sha": "e5c190ea112cf4666e182c6cd4769c5aaa332e7f",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 58,
            "deletions": 1,
            "changes": 59,
            "blob_url": "https://github.com/angular/angular/blob/cbac0c351498a808d2ab3621f247080dd95d359e/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/cbac0c351498a808d2ab3621f247080dd95d359e/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=cbac0c351498a808d2ab3621f247080dd95d359e",
            "patch": "@@ -387,8 +387,42 @@ export const subsetMatchOptions: IsActiveMatchOptions = {\n  */\n @Injectable()\n export class Router {\n+  /**\n+   * Represents the activated `UrlTree` that the `Router` is configured to handle (through\n+   * `UrlHandlingStrategy`). That is, after we find the route config tree that we're going to\n+   * activate, run guards, and are just about to activate the route, we set the currentUrlTree.\n+   *\n+   * This should match the `browserUrlTree` when a navigation succeeds. If the\n+   * `UrlHandlingStrategy.shouldProcessUrl` is `false`, only the `browserUrlTree` is updated.\n+   */\n   private currentUrlTree: UrlTree;\n+  /**\n+   * Meant to represent the entire browser url after a successful navigation. In the life of a\n+   * navigation transition:\n+   * 1. The rawUrl represents the full URL that's being navigated to\n+   * 2. We apply redirects, which might only apply to _part_ of the URL (due to\n+   * `UrlHandlingStrategy`).\n+   * 3. Right before activation (because we assume activation will succeed), we update the\n+   * rawUrlTree to be a combination of the urlAfterRedirects (again, this might only apply to part\n+   * of the initial url) and the rawUrl of the transition (which was the original navigation url in\n+   * its full form).\n+   */\n   private rawUrlTree: UrlTree;\n+  /**\n+   * Meant to represent the part of the browser url that the `Router` is set up to handle (via the\n+   * `UrlHandlingStrategy`). This value is updated immediately after the browser url is updated (or\n+   * the browser url update is skipped via `skipLocationChange`). With that, note that\n+   * `browserUrlTree` _may not_ reflect the actual browser URL for two reasons:\n+   *\n+   * 1. `UrlHandlingStrategy` only handles part of the URL\n+   * 2. `skipLocationChange` does not update the browser url.\n+   *\n+   * So to reiterate, `browserUrlTree` only represents the Router's internal understanding of the\n+   * current route, either before guards with `urlUpdateStrategy === 'eager'` or right before\n+   * activation with `'deferred'`.\n+   *\n+   * This should match the `currentUrlTree` when the navigation succeeds.\n+   */\n   private browserUrlTree: UrlTree;\n   private readonly transitions: BehaviorSubject<NavigationTransition>;\n   private navigations: Observable<NavigationTransition>;\n@@ -618,13 +652,22 @@ export class Router {\n                      switchMap(t => {\n                        const urlTransition = !this.navigated ||\n                            t.extractedUrl.toString() !== this.browserUrlTree.toString();\n+                       /* || this.browserUrlTree.toString() !== this.currentUrlTree.toString() */\n+                       // TODO(atscott): Run TGP to see if the above change can be made. There are\n+                       // situations where a navigation is canceled _after_ browserUrlTree is\n+                       // updated. For example, urlUpdateStrategy === 'eager': if a new\n+                       // navigation happens (i.e. in a guard), this would cause the router to\n+                       // be in an invalid state of tracking.\n                        const processCurrentUrl =\n                            (this.onSameUrlNavigation === 'reload' ? true : urlTransition) &&\n                            this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl);\n \n                        // If the source of the navigation is from a browser event, the URL is\n                        // already updated. We already need to sync the internal state.\n                        if (isBrowserTriggeredNavigation(t.source)) {\n+                         // TODO(atscott): this should be `t.extractedUrl`. The `browserUrlTree`\n+                         // should only be the part of the URL that is handled by the router. In\n+                         // addition, this should only be done if we process the current url.\n                          this.browserUrlTree = t.rawUrl;\n                        }\n \n@@ -669,6 +712,13 @@ export class Router {\n                                if (this.urlUpdateStrategy === 'eager') {\n                                  if (!t.extras.skipLocationChange) {\n                                    this.setBrowserUrl(t.urlAfterRedirects, t);\n+                                   // TODO(atscott): The above line is incorrect. It sets the url to\n+                                   // only the part that is handled by the router. It should merge\n+                                   // that with the rawUrl so the url includes segments not handled\n+                                   // by the router:\n+                                   //  const rawUrl = this.urlHandlingStrategy.merge(\n+                                   //      t.urlAfterRedirects, t.rawUrl);\n+                                   //  this.setBrowserUrl(rawUrl, t);\n                                  }\n                                  this.browserUrlTree = t.urlAfterRedirects;\n                                }\n@@ -840,7 +890,7 @@ export class Router {\n                      tap((t: NavigationTransition) => {\n                        this.currentUrlTree = t.urlAfterRedirects;\n                        this.rawUrlTree =\n-                           this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl);\n+                           this.urlHandlingStrategy.merge(t.urlAfterRedirects, t.rawUrl);\n \n                        (this as {routerState: RouterState}).routerState = t.targetRouterState!;\n \n@@ -992,6 +1042,13 @@ export class Router {\n \n   private getTransition(): NavigationTransition {\n     const transition = this.transitions.value;\n+    // TODO(atscott): This comment doesn't make it clear why this value needs to be set. In the case\n+    // described below (where we don't handle previous or current url), the `browserUrlTree` is set\n+    // to the `urlAfterRedirects` value. However, these values *are already the same* because of the\n+    // line below. So it seems that we should be able to remove the line below and the line where\n+    // `browserUrlTree` is updated when we aren't handling any part of the navigation url.\n+    // Run TGP to confirm that this can be done.\n+\n     // This value needs to be set. Other values such as extractedUrl are set on initial navigation\n     // but the urlAfterRedirects may not get set if we aren't processing the new URL *and* not\n     // processing the previous URL."
        }
    ],
    "stats": {
        "total": 59,
        "additions": 58,
        "deletions": 1
    }
}