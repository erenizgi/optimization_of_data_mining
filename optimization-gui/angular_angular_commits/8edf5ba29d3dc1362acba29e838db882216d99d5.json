{
    "author": "JoostK",
    "message": "refactor(compiler): remove unused parser methods (#38126)\n\nThese methods are no longer used so they can safely be removed.\n\nPR Close #38126",
    "sha": "8edf5ba29d3dc1362acba29e838db882216d99d5",
    "files": [
        {
            "sha": "003404a06d3c0dc61687e832e4556ba612f960dc",
            "filename": "packages/compiler/src/ml_parser/parser.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 44,
            "changes": 44,
            "blob_url": "https://github.com/angular/angular/blob/8edf5ba29d3dc1362acba29e838db882216d99d5/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/8edf5ba29d3dc1362acba29e838db882216d99d5/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts?ref=8edf5ba29d3dc1362acba29e838db882216d99d5",
            "patch": "@@ -337,25 +337,6 @@ class _TreeBuilder {\n     return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n   }\n \n-  /**\n-   * Returns the parent in the DOM and the container.\n-   *\n-   * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n-   */\n-  private _getParentElementSkippingContainers():\n-      {parent: html.Element|null, container: html.Element|null} {\n-    let container: html.Element|null = null;\n-\n-    for (let i = this._elementStack.length - 1; i >= 0; i--) {\n-      if (!isNgContainer(this._elementStack[i].name)) {\n-        return {parent: this._elementStack[i], container};\n-      }\n-      container = this._elementStack[i];\n-    }\n-\n-    return {parent: null, container};\n-  }\n-\n   private _addToParent(node: html.Node) {\n     const parent = this._getParentElement();\n     if (parent != null) {\n@@ -365,31 +346,6 @@ class _TreeBuilder {\n     }\n   }\n \n-  /**\n-   * Insert a node between the parent and the container.\n-   * When no container is given, the node is appended as a child of the parent.\n-   * Also updates the element stack accordingly.\n-   *\n-   * @internal\n-   */\n-  private _insertBeforeContainer(\n-      parent: html.Element, container: html.Element|null, node: html.Element) {\n-    if (!container) {\n-      this._addToParent(node);\n-      this._elementStack.push(node);\n-    } else {\n-      if (parent) {\n-        // replace the container with the new node in the children\n-        const index = parent.children.indexOf(container);\n-        parent.children[index] = node;\n-      } else {\n-        this.rootNodes.push(node);\n-      }\n-      node.children.push(container);\n-      this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n-    }\n-  }\n-\n   private _getElementFullName(prefix: string, localName: string, parentElement: html.Element|null):\n       string {\n     if (prefix === '') {"
        }
    ],
    "stats": {
        "total": 44,
        "additions": 0,
        "deletions": 44
    }
}