{
    "author": "alxhub",
    "message": "feat(language-service): implement autocompletion for global properties (Ivy) (#39250)\n\nThis commit adds support in the Ivy Language Service for autocompletion in a\nglobal context - e.g. a {{foo|}} completion.\n\nSupport is added both for the primary function `getCompletionsAtPosition` as\nwell as the detail functions `getCompletionEntryDetails` and\n`getCompletionEntrySymbol`. These latter operations are not used yet as an\nupstream change to the extension is required to advertise and support this\ncapability.\n\nPR Close #39250",
    "sha": "28a0bcb424e4d64df0238986e34ed11adeeea866",
    "files": [
        {
            "sha": "f04bc887d8a9fe7104632afdbb51849e8e42e027",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=28a0bcb424e4d64df0238986e34ed11adeeea866",
            "patch": "@@ -50,7 +50,7 @@ export interface TemplateTypeChecker {\n    * is not valid. If the template cannot be parsed correctly, no override will occur.\n    */\n   overrideComponentTemplate(component: ts.ClassDeclaration, template: string):\n-      {nodes: TmplAstNode[], errors?: ParseError[]};\n+      {nodes: TmplAstNode[], errors: ParseError[]|null};\n \n   /**\n    * Get all `ts.Diagnostic`s currently available for the given `ts.SourceFile`."
        },
        {
            "sha": "5f8bcd7b8be280802b9ba6f33c95df331112a8e7",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/symbols.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts",
            "raw_url": "https://github.com/angular/angular/raw/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts?ref=28a0bcb424e4d64df0238986e34ed11adeeea866",
            "patch": "@@ -32,6 +32,11 @@ export enum SymbolKind {\n export type Symbol = InputBindingSymbol|OutputBindingSymbol|ElementSymbol|ReferenceSymbol|\n     VariableSymbol|ExpressionSymbol|DirectiveSymbol|TemplateSymbol|DomBindingSymbol;\n \n+/**\n+ * A `Symbol` which declares a new named entity in the template scope.\n+ */\n+export type TemplateDeclarationSymbol = ReferenceSymbol|VariableSymbol;\n+\n /** Information about where a `ts.Node` can be found in the type check block shim file. */\n export interface ShimLocation {\n   /**"
        },
        {
            "sha": "69f4066c22c1bcc893c36b3a39646440394353a2",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=28a0bcb424e4d64df0238986e34ed11adeeea866",
            "patch": "@@ -138,16 +138,12 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n   }\n \n   overrideComponentTemplate(component: ts.ClassDeclaration, template: string):\n-      {nodes: TmplAstNode[], errors?: ParseError[]} {\n+      {nodes: TmplAstNode[], errors: ParseError[]|null} {\n     const {nodes, errors} = parseTemplate(template, 'override.html', {\n       preserveWhitespaces: true,\n       leadingTriviaChars: [],\n     });\n \n-    if (errors !== null) {\n-      return {nodes, errors};\n-    }\n-\n     const filePath = absoluteFromSourceFile(component.getSourceFile());\n \n     const fileRecord = this.getFileData(filePath);\n@@ -169,7 +165,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     this.completionCache.delete(component);\n     this.symbolBuilderCache.delete(component);\n \n-    return {nodes};\n+    return {nodes, errors};\n   }\n \n   isTrackedTypeCheckFile(filePath: AbsoluteFsPath): boolean {"
        },
        {
            "sha": "c3cb1ef04c2ddfdb83741219524f76f5278f0cfc",
            "filename": "packages/language-service/ivy/completions.ts",
            "status": "added",
            "additions": 287,
            "deletions": 0,
            "changes": 287,
            "blob_url": "https://github.com/angular/angular/blob/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "raw_url": "https://github.com/angular/angular/raw/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompletions.ts?ref=28a0bcb424e4d64df0238986e34ed11adeeea866",
            "patch": "@@ -0,0 +1,287 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {AST, EmptyExpr, ImplicitReceiver, LiteralPrimitive, MethodCall, PropertyRead, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n+import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n+import {CompletionKind, TemplateDeclarationSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import {BoundEvent} from '@angular/compiler/src/render3/r3_ast';\n+import * as ts from 'typescript';\n+\n+import {DisplayInfoKind, getDisplayInfo, unsafeCastDisplayInfoKindToScriptElementKind} from './display_parts';\n+\n+type PropertyExpressionCompletionBuilder =\n+    CompletionBuilder<PropertyRead|MethodCall|EmptyExpr|LiteralPrimitive>;\n+\n+/**\n+ * Performs autocompletion operations on a given node in the template.\n+ *\n+ * This class acts as a closure around all of the context required to perform the 3 autocompletion\n+ * operations (completions, get details, and get symbol) at a specific node.\n+ *\n+ * The generic `N` type for the template node is narrowed internally for certain operations, as the\n+ * compiler operations required to implement completion may be different for different node types.\n+ *\n+ * @param N type of the template node in question, narrowed accordingly.\n+ */\n+export class CompletionBuilder<N extends TmplAstNode|AST> {\n+  private readonly typeChecker = this.compiler.getNextProgram().getTypeChecker();\n+  private readonly templateTypeChecker = this.compiler.getTemplateTypeChecker();\n+\n+  constructor(\n+      private readonly tsLS: ts.LanguageService, private readonly compiler: NgCompiler,\n+      private readonly component: ts.ClassDeclaration, private readonly node: N,\n+      private readonly nodeParent: TmplAstNode|AST|null,\n+      private readonly context: TmplAstTemplate|null) {}\n+\n+  /**\n+   * Analogue for `ts.LanguageService.getCompletionsAtPosition`.\n+   */\n+  getCompletionsAtPosition(options: ts.GetCompletionsAtPositionOptions|\n+                           undefined): ts.WithMetadata<ts.CompletionInfo>|undefined {\n+    if (this.isPropertyExpressionCompletion()) {\n+      return this.getPropertyExpressionCompletion(options);\n+    } else {\n+      return undefined;\n+    }\n+  }\n+\n+  /**\n+   * Analogue for `ts.LanguageService.getCompletionEntryDetails`.\n+   */\n+  getCompletionEntryDetails(\n+      entryName: string, formatOptions: ts.FormatCodeOptions|ts.FormatCodeSettings|undefined,\n+      preferences: ts.UserPreferences|undefined): ts.CompletionEntryDetails|undefined {\n+    if (this.isPropertyExpressionCompletion()) {\n+      return this.getPropertyExpressionCompletionDetails(entryName, formatOptions, preferences);\n+    } else {\n+      return undefined;\n+    }\n+  }\n+\n+  /**\n+   * Analogue for `ts.LanguageService.getCompletionEntrySymbol`.\n+   */\n+  getCompletionEntrySymbol(name: string): ts.Symbol|undefined {\n+    if (this.isPropertyExpressionCompletion()) {\n+      return this.getPropertyExpressionCompletionSymbol(name);\n+    } else {\n+      return undefined;\n+    }\n+  }\n+\n+  /**\n+   * Determine if the current node is the completion of a property expression, and narrow the type\n+   * of `this.node` if so.\n+   *\n+   * This narrowing gives access to additional methods related to completion of property\n+   * expressions.\n+   */\n+  private isPropertyExpressionCompletion(this: CompletionBuilder<TmplAstNode|AST>):\n+      this is PropertyExpressionCompletionBuilder {\n+    return this.node instanceof PropertyRead || this.node instanceof MethodCall ||\n+        this.node instanceof EmptyExpr ||\n+        isBrokenEmptyBoundEventExpression(this.node, this.nodeParent);\n+  }\n+\n+  /**\n+   * Get completions for property expressions.\n+   */\n+  private getPropertyExpressionCompletion(\n+      this: PropertyExpressionCompletionBuilder,\n+      options: ts.GetCompletionsAtPositionOptions|\n+      undefined): ts.WithMetadata<ts.CompletionInfo>|undefined {\n+    if (this.node instanceof EmptyExpr ||\n+        isBrokenEmptyBoundEventExpression(this.node, this.nodeParent) ||\n+        this.node.receiver instanceof ImplicitReceiver) {\n+      return this.getGlobalPropertyExpressionCompletion(options);\n+    } else {\n+      // TODO(alxhub): implement completion of non-global expressions.\n+      return undefined;\n+    }\n+  }\n+\n+  /**\n+   * Get the details of a specific completion for a property expression.\n+   */\n+  private getPropertyExpressionCompletionDetails(\n+      this: PropertyExpressionCompletionBuilder, entryName: string,\n+      formatOptions: ts.FormatCodeOptions|ts.FormatCodeSettings|undefined,\n+      preferences: ts.UserPreferences|undefined): ts.CompletionEntryDetails|undefined {\n+    if (this.node instanceof EmptyExpr ||\n+        isBrokenEmptyBoundEventExpression(this.node, this.nodeParent) ||\n+        this.node.receiver instanceof ImplicitReceiver) {\n+      return this.getGlobalPropertyExpressionCompletionDetails(\n+          entryName, formatOptions, preferences);\n+    } else {\n+      // TODO(alxhub): implement completion of non-global expressions.\n+      return undefined;\n+    }\n+  }\n+\n+  /**\n+   * Get the `ts.Symbol` for a specific completion for a property expression.\n+   */\n+  private getPropertyExpressionCompletionSymbol(\n+      this: PropertyExpressionCompletionBuilder, name: string): ts.Symbol|undefined {\n+    if (this.node instanceof EmptyExpr || this.node instanceof LiteralPrimitive ||\n+        this.node.receiver instanceof ImplicitReceiver) {\n+      return this.getGlobalPropertyExpressionCompletionSymbol(name);\n+    } else {\n+      // TODO(alxhub): implement completion of non-global expressions.\n+      return undefined;\n+    }\n+  }\n+\n+  /**\n+   * Get completions for a property expression in a global context (e.g. `{{y|}}`).\n+   */\n+  private getGlobalPropertyExpressionCompletion(\n+      this: PropertyExpressionCompletionBuilder,\n+      options: ts.GetCompletionsAtPositionOptions|\n+      undefined): ts.WithMetadata<ts.CompletionInfo>|undefined {\n+    const completions = this.templateTypeChecker.getGlobalCompletions(this.context, this.component);\n+    if (completions === null) {\n+      return undefined;\n+    }\n+\n+    const {componentContext, templateContext} = completions;\n+\n+    let replacementSpan: ts.TextSpan|undefined = undefined;\n+    // Non-empty nodes get replaced with the completion.\n+    if (!(this.node instanceof EmptyExpr || this.node instanceof LiteralPrimitive)) {\n+      replacementSpan = {\n+        start: this.node.nameSpan.start,\n+        length: this.node.nameSpan.end - this.node.nameSpan.start,\n+      };\n+    }\n+\n+    // Merge TS completion results with results from the template scope.\n+    let entries: ts.CompletionEntry[] = [];\n+    const tsLsCompletions = this.tsLS.getCompletionsAtPosition(\n+        componentContext.shimPath, componentContext.positionInShimFile, options);\n+    if (tsLsCompletions !== undefined) {\n+      for (const tsCompletion of tsLsCompletions.entries) {\n+        // Skip completions that are shadowed by a template entity definition.\n+        if (templateContext.has(tsCompletion.name)) {\n+          continue;\n+        }\n+        entries.push({\n+          ...tsCompletion,\n+          // Substitute the TS completion's `replacementSpan` (which uses offsets within the TCB)\n+          // with the `replacementSpan` within the template source.\n+          replacementSpan,\n+        });\n+      }\n+    }\n+\n+    for (const [name, entity] of templateContext) {\n+      entries.push({\n+        name,\n+        sortText: name,\n+        replacementSpan,\n+        kindModifiers: ts.ScriptElementKindModifier.none,\n+        kind: unsafeCastDisplayInfoKindToScriptElementKind(\n+            entity.kind === CompletionKind.Reference ? DisplayInfoKind.REFERENCE :\n+                                                       DisplayInfoKind.VARIABLE),\n+      });\n+    }\n+\n+    return {\n+      entries,\n+      // Although this completion is \"global\" in the sense of an Angular expression (there is no\n+      // explicit receiver), it is not \"global\" in a TypeScript sense since Angular expressions have\n+      // the component as an implicit receiver.\n+      isGlobalCompletion: false,\n+      isMemberCompletion: true,\n+      isNewIdentifierLocation: false,\n+    };\n+  }\n+\n+  /**\n+   * Get the details of a specific completion for a property expression in a global context (e.g.\n+   * `{{y|}}`).\n+   */\n+  private getGlobalPropertyExpressionCompletionDetails(\n+      this: PropertyExpressionCompletionBuilder, entryName: string,\n+      formatOptions: ts.FormatCodeOptions|ts.FormatCodeSettings|undefined,\n+      preferences: ts.UserPreferences|undefined): ts.CompletionEntryDetails|undefined {\n+    const completions = this.templateTypeChecker.getGlobalCompletions(this.context, this.component);\n+    if (completions === null) {\n+      return undefined;\n+    }\n+    const {componentContext, templateContext} = completions;\n+\n+    if (templateContext.has(entryName)) {\n+      const entry = templateContext.get(entryName)!;\n+      // Entries that reference a symbol in the template context refer either to local references or\n+      // variables.\n+      const symbol = this.templateTypeChecker.getSymbolOfNode(entry.node, this.component) as\n+              TemplateDeclarationSymbol |\n+          null;\n+      if (symbol === null) {\n+        return undefined;\n+      }\n+\n+      const {kind, displayParts, documentation} =\n+          getDisplayInfo(this.tsLS, this.typeChecker, symbol);\n+      return {\n+        kind: unsafeCastDisplayInfoKindToScriptElementKind(kind),\n+        name: entryName,\n+        kindModifiers: ts.ScriptElementKindModifier.none,\n+        displayParts,\n+        documentation,\n+      };\n+    } else {\n+      return this.tsLS.getCompletionEntryDetails(\n+          componentContext.shimPath, componentContext.positionInShimFile, entryName, formatOptions,\n+          /* source */ undefined, preferences);\n+    }\n+  }\n+\n+  /**\n+   * Get the `ts.Symbol` of a specific completion for a property expression in a global context\n+   * (e.g.\n+   * `{{y|}}`).\n+   */\n+  private getGlobalPropertyExpressionCompletionSymbol(\n+      this: PropertyExpressionCompletionBuilder, entryName: string): ts.Symbol|undefined {\n+    const completions = this.templateTypeChecker.getGlobalCompletions(this.context, this.component);\n+    if (completions === null) {\n+      return undefined;\n+    }\n+    const {componentContext, templateContext} = completions;\n+    if (templateContext.has(entryName)) {\n+      const node: TmplAstReference|TmplAstVariable = templateContext.get(entryName)!.node;\n+      const symbol = this.templateTypeChecker.getSymbolOfNode(node, this.component) as\n+              TemplateDeclarationSymbol |\n+          null;\n+      if (symbol === null || symbol.tsSymbol === null) {\n+        return undefined;\n+      }\n+      return symbol.tsSymbol;\n+    } else {\n+      return this.tsLS.getCompletionEntrySymbol(\n+          componentContext.shimPath, componentContext.positionInShimFile, entryName,\n+          /* source */ undefined);\n+    }\n+  }\n+}\n+\n+/**\n+ * Checks whether the given `node` is (most likely) a synthetic node created by the template parser\n+ * for an empty event binding `(event)=\"\"`.\n+ *\n+ * When parsing such an expression, a synthetic `LiteralPrimitive` node is generated for the\n+ * `BoundEvent`'s handler with the literal text value 'ERROR'. Detecting this case is crucial to\n+ * supporting completions within empty event bindings.\n+ */\n+function isBrokenEmptyBoundEventExpression(\n+    node: TmplAstNode|AST, parent: TmplAstNode|AST|null): node is LiteralPrimitive {\n+  return node instanceof LiteralPrimitive && parent !== null && parent instanceof BoundEvent &&\n+      node.value === 'ERROR';\n+}"
        },
        {
            "sha": "665607c9d065615677fe6385e9aa82e891ffcc29",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 54,
            "deletions": 1,
            "changes": 55,
            "blob_url": "https://github.com/angular/angular/blob/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=28a0bcb424e4d64df0238986e34ed11adeeea866",
            "patch": "@@ -6,17 +6,19 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+import {AST, TmplAstNode} from '@angular/compiler';\n import {CompilerOptions, ConfigurationHost, readConfiguration} from '@angular/compiler-cli';\n import {absoluteFromSourceFile, AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n import {TypeCheckShimGenerator} from '@angular/compiler-cli/src/ngtsc/typecheck';\n import {OptimizeFor, TypeCheckingProgramStrategy} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n-import {ReferenceBuilder} from '@angular/language-service/ivy/references';\n import * as ts from 'typescript/lib/tsserverlibrary';\n \n import {LanguageServiceAdapter, LSParseConfigHost} from './adapters';\n import {CompilerFactory} from './compiler_factory';\n+import {CompletionBuilder} from './completions';\n import {DefinitionBuilder} from './definitions';\n import {QuickInfoBuilder} from './quick_info';\n+import {ReferenceBuilder} from './references';\n import {getTargetAtPosition} from './template_target';\n import {getTemplateInfoAtPosition, isTypeScriptFile} from './utils';\n \n@@ -105,6 +107,57 @@ export class LanguageService {\n     return results;\n   }\n \n+  private getCompletionBuilder(fileName: string, position: number):\n+      CompletionBuilder<TmplAstNode|AST>|null {\n+    const compiler = this.compilerFactory.getOrCreateWithChangedFile(fileName);\n+    const templateInfo = getTemplateInfoAtPosition(fileName, position, compiler);\n+    if (templateInfo === undefined) {\n+      return null;\n+    }\n+    const positionDetails = getTargetAtPosition(templateInfo.template, position);\n+    if (positionDetails === null) {\n+      return null;\n+    }\n+    return new CompletionBuilder(\n+        this.tsLS, compiler, templateInfo.component, positionDetails.node, positionDetails.parent,\n+        positionDetails.context);\n+  }\n+\n+  getCompletionsAtPosition(\n+      fileName: string, position: number, options: ts.GetCompletionsAtPositionOptions|undefined):\n+      ts.WithMetadata<ts.CompletionInfo>|undefined {\n+    const builder = this.getCompletionBuilder(fileName, position);\n+    if (builder === null) {\n+      return undefined;\n+    }\n+    const result = builder.getCompletionsAtPosition(options);\n+    this.compilerFactory.registerLastKnownProgram();\n+    return result;\n+  }\n+\n+  getCompletionEntryDetails(\n+      fileName: string, position: number, entryName: string,\n+      formatOptions: ts.FormatCodeOptions|ts.FormatCodeSettings|undefined,\n+      preferences: ts.UserPreferences|undefined): ts.CompletionEntryDetails|undefined {\n+    const builder = this.getCompletionBuilder(fileName, position);\n+    if (builder === null) {\n+      return undefined;\n+    }\n+    const result = builder.getCompletionEntryDetails(entryName, formatOptions, preferences);\n+    this.compilerFactory.registerLastKnownProgram();\n+    return result;\n+  }\n+\n+  getCompletionEntrySymbol(fileName: string, position: number, name: string): ts.Symbol|undefined {\n+    const builder = this.getCompletionBuilder(fileName, position);\n+    if (builder === null) {\n+      return undefined;\n+    }\n+    const result = builder.getCompletionEntrySymbol(name);\n+    this.compilerFactory.registerLastKnownProgram();\n+    return result;\n+  }\n+\n   private watchConfigFile(project: ts.server.Project) {\n     // TODO: Check the case when the project is disposed. An InferredProject\n     // could be disposed when a tsconfig.json is added to the workspace,"
        },
        {
            "sha": "b4c3923ed8409041cc8e0f84de576fbba0e50d0b",
            "filename": "packages/language-service/ivy/test/completions_spec.ts",
            "status": "added",
            "additions": 169,
            "deletions": 0,
            "changes": 169,
            "blob_url": "https://github.com/angular/angular/blob/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts?ref=28a0bcb424e4d64df0238986e34ed11adeeea866",
            "patch": "@@ -0,0 +1,169 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {TmplAstNode} from '@angular/compiler';\n+import {absoluteFrom, AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+import * as ts from 'typescript';\n+import {DisplayInfoKind} from '../display_parts';\n+import {LanguageService} from '../language_service';\n+\n+import {LanguageServiceTestEnvironment} from './env';\n+\n+describe('completions', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('in the global scope', () => {\n+    it('should be able to complete an interpolation', () => {\n+      const {ngLS, fileName, cursor} = setup('{{ti¦}}', `title!: string; hero!: number;`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title', 'hero']);\n+    });\n+\n+    it('should be able to complete an empty interpolation', () => {\n+      const {ngLS, fileName, cursor} = setup('{{ ¦ }}', `title!: string; hero!: number;`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title', 'hero']);\n+    });\n+\n+    it('should be able to complete a property binding', () => {\n+      const {ngLS, fileName, cursor} =\n+          setup('<h1 [model]=\"ti¦\"></h1>', `title!: string; hero!: number;`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title', 'hero']);\n+    });\n+\n+    it('should be able to complete an empty property binding', () => {\n+      const {ngLS, fileName, cursor} =\n+          setup('<h1 [model]=\"¦\"></h1>', `title!: string; hero!: number;`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title', 'hero']);\n+    });\n+\n+    it('should be able to retrieve details for completions', () => {\n+      const {ngLS, fileName, cursor} = setup('{{ti¦}}', `\n+        /** This is the title of the 'AppCmp' Component. */\n+        title!: string;\n+        /** This comment should not appear in the output of this test. */\n+        hero!: number;\n+      `);\n+      const details = ngLS.getCompletionEntryDetails(\n+          fileName, cursor, 'title', /* formatOptions */ undefined,\n+          /* preferences */ undefined)!;\n+      expect(details).toBeDefined();\n+      expect(toText(details.displayParts)).toEqual('(property) AppCmp.title: string');\n+      expect(toText(details.documentation))\n+          .toEqual('This is the title of the \\'AppCmp\\' Component.');\n+    });\n+\n+    it('should return reference completions when available', () => {\n+      const {ngLS, fileName, cursor} = setup(`<div #todo></div>{{t¦}}`, `title!: string;`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title']);\n+      expectContain(completions, DisplayInfoKind.REFERENCE, ['todo']);\n+    });\n+\n+    it('should return variable completions when available', () => {\n+      const {ngLS, fileName, cursor} = setup(\n+          `<div *ngFor=\"let hero of heroes\">\n+            {{h¦}}\n+          </div>\n+        `,\n+          `heroes!: {name: string}[];`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['heroes']);\n+      expectContain(completions, DisplayInfoKind.VARIABLE, ['hero']);\n+    });\n+\n+    it('should return completions inside an event binding', () => {\n+      const {ngLS, fileName, cursor} = setup(`<button (click)='t¦'></button>`, `title!: string;`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title']);\n+    });\n+\n+    it('should return completions inside an empty event binding', () => {\n+      const {ngLS, fileName, cursor} = setup(`<button (click)='¦'></button>`, `title!: string;`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title']);\n+    });\n+\n+    it('should return completions inside the RHS of a two-way binding', () => {\n+      const {ngLS, fileName, cursor} = setup(`<h1 [(model)]=\"t¦\"></h1>`, `title!: string;`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title']);\n+    });\n+\n+    it('should return completions inside an empty RHS of a two-way binding', () => {\n+      const {ngLS, fileName, cursor} = setup(`<h1 [(model)]=\"¦\"></h1>`, `title!: string;`);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title']);\n+    });\n+  });\n+});\n+\n+function expectContain(\n+    completions: ts.CompletionInfo|undefined, kind: ts.ScriptElementKind|DisplayInfoKind,\n+    names: string[]) {\n+  expect(completions).toBeDefined();\n+  for (const name of names) {\n+    expect(completions!.entries).toContain(jasmine.objectContaining({name, kind} as any));\n+  }\n+}\n+\n+function toText(displayParts?: ts.SymbolDisplayPart[]): string {\n+  return (displayParts ?? []).map(p => p.text).join('');\n+}\n+\n+function setup(templateWithCursor: string, classContents: string): {\n+  env: LanguageServiceTestEnvironment,\n+  fileName: AbsoluteFsPath,\n+  AppCmp: ts.ClassDeclaration,\n+  ngLS: LanguageService,\n+  cursor: number,\n+  nodes: TmplAstNode[],\n+} {\n+  const codePath = absoluteFrom('/test.ts');\n+  const templatePath = absoluteFrom('/test.html');\n+  const env = LanguageServiceTestEnvironment.setup([\n+    {\n+      name: codePath,\n+      contents: `\n+        import {Component, NgModule} from '@angular/core';\n+\n+        @Component({\n+          templateUrl: './test.html',\n+          selector: 'app-cmp',\n+        })\n+        export class AppCmp {\n+          ${classContents}\n+        }\n+        \n+        @NgModule({\n+          declarations: [AppCmp],\n+        })\n+        export class AppModule {}\n+        `,\n+      isRoot: true,\n+    },\n+    {\n+      name: templatePath,\n+      contents: 'Placeholder template',\n+    }\n+  ]);\n+  const {nodes, cursor} = env.overrideTemplateWithCursor(codePath, 'AppCmp', templateWithCursor);\n+  return {\n+    env,\n+    fileName: templatePath,\n+    AppCmp: env.getClass(codePath, 'AppCmp'),\n+    ngLS: env.ngLS,\n+    nodes,\n+    cursor,\n+  };\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "c21a04da47c60a1d8dc4034ec6dfc0507a8fc322",
            "filename": "packages/language-service/ivy/ts_plugin.ts",
            "status": "modified",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/angular/angular/blob/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/28a0bcb424e4d64df0238986e34ed11adeeea866/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts?ref=28a0bcb424e4d64df0238986e34ed11adeeea866",
            "patch": "@@ -68,6 +68,45 @@ export function create(info: ts.server.PluginCreateInfo): ts.LanguageService {\n     return undefined;\n   }\n \n+  function getCompletionsAtPosition(\n+      fileName: string, position: number,\n+      options: ts.GetCompletionsAtPositionOptions): ts.WithMetadata<ts.CompletionInfo>|undefined {\n+    if (angularOnly) {\n+      return ngLS.getCompletionsAtPosition(fileName, position, options);\n+    } else {\n+      // If TS could answer the query, then return that result. Otherwise, return from Angular LS.\n+      return tsLS.getCompletionsAtPosition(fileName, position, options) ??\n+          ngLS.getCompletionsAtPosition(fileName, position, options);\n+    }\n+  }\n+\n+  function getCompletionEntryDetails(\n+      fileName: string, position: number, entryName: string,\n+      formatOptions: ts.FormatCodeOptions|ts.FormatCodeSettings|undefined, source: string|undefined,\n+      preferences: ts.UserPreferences|undefined): ts.CompletionEntryDetails|undefined {\n+    if (angularOnly) {\n+      return ngLS.getCompletionEntryDetails(\n+          fileName, position, entryName, formatOptions, preferences);\n+    } else {\n+      // If TS could answer the query, then return that result. Otherwise, return from Angular LS.\n+      return tsLS.getCompletionEntryDetails(\n+                 fileName, position, entryName, formatOptions, source, preferences) ??\n+          ngLS.getCompletionEntryDetails(fileName, position, entryName, formatOptions, preferences);\n+    }\n+  }\n+\n+  function getCompletionEntrySymbol(\n+      fileName: string, position: number, name: string, source: string|undefined): ts.Symbol|\n+      undefined {\n+    if (angularOnly) {\n+      return ngLS.getCompletionEntrySymbol(fileName, position, name);\n+    } else {\n+      // If TS could answer the query, then return that result. Otherwise, return from Angular LS.\n+      return tsLS.getCompletionEntrySymbol(fileName, position, name, source) ??\n+          ngLS.getCompletionEntrySymbol(fileName, position, name);\n+    }\n+  }\n+\n   return {\n     ...tsLS,\n     getSemanticDiagnostics,\n@@ -76,5 +115,8 @@ export function create(info: ts.server.PluginCreateInfo): ts.LanguageService {\n     getDefinitionAndBoundSpan,\n     getReferencesAtPosition,\n     findRenameLocations,\n+    getCompletionsAtPosition,\n+    getCompletionEntryDetails,\n+    getCompletionEntrySymbol,\n   };\n }"
        }
    ],
    "stats": {
        "total": 568,
        "additions": 560,
        "deletions": 8
    }
}