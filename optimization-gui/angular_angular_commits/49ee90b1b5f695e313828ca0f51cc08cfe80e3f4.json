{
    "author": "pmartijena",
    "message": "docs: fix typo in architecture.md guide (#38853)\n\nPR Close #38853",
    "sha": "49ee90b1b5f695e313828ca0f51cc08cfe80e3f4",
    "files": [
        {
            "sha": "68cabad86ba7b4be13a05804961b85819517360d",
            "filename": "packages/compiler/design/architecture.md",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/49ee90b1b5f695e313828ca0f51cc08cfe80e3f4/packages%2Fcompiler%2Fdesign%2Farchitecture.md",
            "raw_url": "https://github.com/angular/angular/raw/49ee90b1b5f695e313828ca0f51cc08cfe80e3f4/packages%2Fcompiler%2Fdesign%2Farchitecture.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fdesign%2Farchitecture.md?ref=49ee90b1b5f695e313828ca0f51cc08cfe80e3f4",
            "patch": "@@ -23,7 +23,7 @@ Existing Angular libraries exist on NPM today and are distributed in the Angular\n \n We will produce two compiler entry-points, `ngtsc` and `ngcc`.\n \n-`ngtsc` will be an Typescript-to-Javascript transpiler that reifies Angular decorators into static properties. It is a minimal wrapper around `tsc` which includes a set of Angular transforms. While Ivy is experimental, `ngc` operates as `ngtsc` when the `angularCompilerOption` `enableIvy` flag is set to `true` in the `tsconfig.json` file for the project.\n+`ngtsc` will be a Typescript-to-Javascript transpiler that reifies Angular decorators into static properties. It is a minimal wrapper around `tsc` which includes a set of Angular transforms. While Ivy is experimental, `ngc` operates as `ngtsc` when the `angularCompilerOption` `enableIvy` flag is set to `true` in the `tsconfig.json` file for the project.\n \n `ngcc` (which stands for Angular compatibility compiler) is designed to process code coming from NPM and produce the equivalent Ivy version, as if the code was compiled with `ngtsc`. It will operate given a `node_modules` directory and a set of packages to compile, and will produce an equivalent directory from which the Ivy equivalents of those modules can be read. `ngcc` is a separate script entry point to `@angular/compiler-cli`.\n \n@@ -49,7 +49,7 @@ export class GreetComponent {\n }\n ```\n \n-will normally be translated this into something like,\n+will normally be translated into something like this:\n \n ```js\n const tslib_1 = require(\"tslib\");\n@@ -137,7 +137,7 @@ The overall architecure of TypeScript is:\n \n The parse step is a traditional recursive descent parser, augmented to support incremental parsing, that emits an abstract syntax tree (AST).\n \n-The type-checker construct a symbol table and then performs type analysis of every expression in the file, reporting errors it finds. This process not extended or modified by `ngtsc`.\n+The type-checker construct a symbol table and then performs type analysis of every expression in the file, reporting errors it finds. This process is not extended or modified by `ngtsc`.\n \n The transform step is a set of AST to AST transformations that perform various tasks such as, removing type declarations, lowering module and class declarations to ES5, converting `async` methods to state-machines, etc.\n \n@@ -276,7 +276,7 @@ Given a selector scope, a dependency list is formed by producing the set of type\n \n ##### Finding a components module.\n \n-A component's module can be found by using the TypeScript language service's `findReferences`. If one of the references is to a class declaration with an `@NgModule` annotation, process the class as described above to produce the selector scope. If the class is the declaration list of the `@NgModule` then use the scope produce for that module.\n+A component's module can be found by using the TypeScript language service's `findReferences`. If one of the references is to a class declaration with an `@NgModule` annotation, process the class as described above to produce the selector scope. If the class is the declaration list of the `@NgModule` then use the scope produced for that module.\n \n When processing the `@NgModule` class, the type references can be found using the program's `checker` `getSymbolAtLocation` (potentially calling `getAliasedSymbol` if it is an alias symbol, `SymbolFlags.Alias`) and then using `Symbol`'s `declarations` field to get the list of declarations nodes (there should only be one for a `class`, there can be several for an `interface`).\n "
        }
    ],
    "stats": {
        "total": 8,
        "additions": 4,
        "deletions": 4
    }
}