{
    "author": "devversion",
    "message": "build: replace validate import ESM/CJS interop rule with dev-infra shipped rule (#44238)\n\nThe import ESM/CJS interop lint rule has been ported to the shared\ndev-infra package, so we can remove the local version here.\n\nPR Close #44238",
    "sha": "6add6a097d1b5680e5833bea70906bfededd956b",
    "files": [
        {
            "sha": "ab14b11f68d9005b0ef16d492f10972cfe39443c",
            "filename": "tools/tslint/validateImportForEsmCjsInteropRule.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 103,
            "changes": 103,
            "blob_url": "https://github.com/angular/angular/blob/0cd524b1480247a27cc1b46803473ac644910eba/tools%2Ftslint%2FvalidateImportForEsmCjsInteropRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/0cd524b1480247a27cc1b46803473ac644910eba/tools%2Ftslint%2FvalidateImportForEsmCjsInteropRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/tools%2Ftslint%2FvalidateImportForEsmCjsInteropRule.ts?ref=0cd524b1480247a27cc1b46803473ac644910eba",
            "patch": "@@ -1,103 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {RuleFailure, WalkContext} from 'tslint/lib';\n-import {AbstractRule} from 'tslint/lib/rules';\n-import ts from 'typescript';\n-\n-// TODO(devversion): move this rule into dev-infra.\n-\n-const noNamedExportsError =\n-    'Named import is not allowed. The module does not expose named exports when ' +\n-    'imported in an ES module. Use a default import instead.';\n-\n-const noDefaultExportError =\n-    'Default import is not allowed. The module does not expose a default export at ' +\n-    'runtime. Use a named import instead.';\n-\n-interface RuleOptions {\n-  /**\n-   * List of modules without any named exports that NodeJS can statically detect when the\n-   * CommonJS module is imported from ESM. Node only exposes named exports which are\n-   * statically discoverable: https://nodejs.org/api/esm.html#esm_import_statements.\n-   */\n-  noNamedExports?: string[];\n-  /**\n-   * List of modules which appear to have named exports in the typings but do\n-   * not have any at runtime due to NodeJS not being able to discover these\n-   * through static analysis: https://nodejs.org/api/esm.html#esm_import_statements.\n-   * */\n-  noDefaultExport?: string[];\n-  /**\n-   * List of modules which are always incompatible. The rule allows for a custom\n-   * message to be provided when it discovers an import to such a module.\n-   */\n-  incompatibleModules?: Record<string, string>;\n-}\n-\n-/**\n- * Rule that blocks named imports from being used for certain configured module\n- * specifiers. This is helpful for enforcing an ESM-compatible interop with CommonJS\n- * modules which do not expose named bindings at runtime.\n- *\n- * For example, consider the `typescript` module. It does not statically expose named\n- * exports even though the type definition suggests it. An import like the following\n- * will break at runtime when the `typescript` CommonJS module is imported inside an ESM.\n- *\n- * ```\n- * import * as ts from 'typescript';\n- * console.log(ts.SyntaxKind.CallExpression); // `SyntaxKind is undefined`.\n- * ```\n- *\n- * More details here: https://nodejs.org/api/esm.html#esm_import_statements.\n- */\n-export class Rule extends AbstractRule {\n-  override apply(sourceFile: ts.SourceFile): RuleFailure[] {\n-    const options = this.getOptions().ruleArguments[0];\n-    return this.applyWithFunction(sourceFile, (ctx) => visitNode(sourceFile, ctx, options));\n-  }\n-}\n-\n-function visitNode(node: ts.Node, ctx: WalkContext, options: RuleOptions) {\n-  if (options.incompatibleModules && ts.isImportDeclaration(node)) {\n-    const specifier = node.moduleSpecifier as ts.StringLiteral;\n-    const failureMsg = options.incompatibleModules[specifier.text];\n-\n-    if (failureMsg !== undefined) {\n-      ctx.addFailureAtNode(node, failureMsg);\n-      return;\n-    }\n-  }\n-\n-  if (options.noNamedExports && isNamedImportToDisallowedModule(node, options.noNamedExports)) {\n-    ctx.addFailureAtNode(node, noNamedExportsError);\n-  }\n-\n-  if (options.noDefaultExport && isDefaultImportToDisallowedModule(node, options.noDefaultExport)) {\n-    ctx.addFailureAtNode(node, noDefaultExportError);\n-  }\n-\n-  ts.forEachChild(node, (node) => visitNode(node, ctx, options));\n-}\n-\n-function isNamedImportToDisallowedModule(node: ts.Node, disallowed: string[]): boolean {\n-  if (!ts.isImportDeclaration(node) || node.importClause === undefined) {\n-    return false;\n-  }\n-  const specifier = node.moduleSpecifier as ts.StringLiteral;\n-  return !!node.importClause.namedBindings && disallowed.includes(specifier.text);\n-}\n-\n-function isDefaultImportToDisallowedModule(node: ts.Node, disallowed: string[]) {\n-  if (!ts.isImportDeclaration(node) || node.importClause === undefined) {\n-    return false;\n-  }\n-  const specifier = node.moduleSpecifier as ts.StringLiteral;\n-\n-  return node.importClause.name !== undefined && disallowed.includes(specifier.text);\n-}"
        }
    ],
    "stats": {
        "total": 103,
        "additions": 0,
        "deletions": 103
    }
}