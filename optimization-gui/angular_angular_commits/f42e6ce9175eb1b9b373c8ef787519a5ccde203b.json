{
    "author": "JoostK",
    "message": "perf(compiler-cli): only generate type-check code for referenced DOM elements (#38418)\n\nThe template type-checker would generate a statement with a call\nexpression for all DOM elements in a template of the form:\n\n```\nconst _t1 = document.createElement(\"div\");\n```\n\nProfiling has shown that this is a particularly expensive call to\nperform type inference on, as TypeScript needs to perform signature\nselection of `Document.createElement` and resolve the exact type from\nthe `HTMLElementTagNameMap`. However, it can be observed that the\nstatement by itself does not contribute anything to the type-checking\nresult if `_t1` is not actually used anywhere, which is only rarely the\ncase---it requires that the element is referenced by its name from\nsomewhere else in the template. Consequently, the type-checker can skip\ngenerating this statement altogether for most DOM elements.\n\nThe effect of this optimization is significant in several phases:\n1. Less type-check code to generate\n2. Less type-check code to emit and parse again\n3. No expensive type inference to perform for the call expression\n\nThe effect on phase 3 is the most significant here, as type-checking is\nnot currently incremental in the sense that only phases 1 and 2 can\nbe reused from a prior compilation. The actual type-checking of all\ntemplates in phase 3 needs to be repeated on each incremental\ncompilation, so any performance gains we achieve here are very\nbeneficial.\n\nPR Close #38418",
    "sha": "f42e6ce9175eb1b9b373c8ef787519a5ccde203b",
    "files": [
        {
            "sha": "ab2124605233eee0cc09a4ad228d814d228e305e",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 77,
            "deletions": 5,
            "changes": 82,
            "blob_url": "https://github.com/angular/angular/blob/f42e6ce9175eb1b9b373c8ef787519a5ccde203b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/f42e6ce9175eb1b9b373c8ef787519a5ccde203b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=f42e6ce9175eb1b9b373c8ef787519a5ccde203b",
            "patch": "@@ -99,6 +99,13 @@ export function generateTypeCheckBlock(\n  * `ts.Expression` which can be used to reference the operation's result.\n  */\n abstract class TcbOp {\n+  /**\n+   * Set to true if this operation can be considered optional. Optional operations are only executed\n+   * when depended upon by other operations, otherwise they are disregarded. This allows for less\n+   * code to generate, parse and type-check, overall positively contributing to performance.\n+   */\n+  abstract readonly optional: boolean;\n+\n   abstract execute(): ts.Expression|null;\n \n   /**\n@@ -125,6 +132,13 @@ class TcbElementOp extends TcbOp {\n     super();\n   }\n \n+  get optional() {\n+    // The statement generated by this operation is only used for type-inference of the DOM\n+    // element's type and won't report diagnostics by itself, so the operation is marked as optional\n+    // to avoid generating statements for DOM elements that are never referenced.\n+    return true;\n+  }\n+\n   execute(): ts.Identifier {\n     const id = this.tcb.allocateId();\n     // Add the declaration of the element using document.createElement.\n@@ -148,6 +162,10 @@ class TcbVariableOp extends TcbOp {\n     super();\n   }\n \n+  get optional() {\n+    return false;\n+  }\n+\n   execute(): ts.Identifier {\n     // Look for a context variable for the template.\n     const ctx = this.scope.resolve(this.template);\n@@ -176,6 +194,10 @@ class TcbTemplateContextOp extends TcbOp {\n     super();\n   }\n \n+  get optional() {\n+    return false;\n+  }\n+\n   execute(): ts.Identifier {\n     // Allocate a template ctx variable and declare it with an 'any' type. The type of this variable\n     // may be narrowed as a result of template guard conditions.\n@@ -198,6 +220,10 @@ class TcbTemplateBodyOp extends TcbOp {\n     super();\n   }\n \n+  get optional() {\n+    return false;\n+  }\n+\n   execute(): null {\n     // An `if` will be constructed, within which the template's children will be type checked. The\n     // `if` is used for two reasons: it creates a new syntactic scope, isolating variables declared\n@@ -301,6 +327,10 @@ class TcbTextInterpolationOp extends TcbOp {\n     super();\n   }\n \n+  get optional() {\n+    return false;\n+  }\n+\n   execute(): null {\n     const expr = tcbExpression(this.binding.value, this.tcb, this.scope);\n     this.scope.addStatement(ts.createExpressionStatement(expr));\n@@ -324,6 +354,10 @@ class TcbDirectiveTypeOp extends TcbOp {\n     super();\n   }\n \n+  get optional() {\n+    return false;\n+  }\n+\n   execute(): ts.Identifier {\n     const id = this.tcb.allocateId();\n \n@@ -352,6 +386,10 @@ class TcbDirectiveCtorOp extends TcbOp {\n     super();\n   }\n \n+  get optional() {\n+    return false;\n+  }\n+\n   execute(): ts.Identifier {\n     const id = this.tcb.allocateId();\n \n@@ -409,6 +447,10 @@ class TcbDirectiveInputsOp extends TcbOp {\n     super();\n   }\n \n+  get optional() {\n+    return false;\n+  }\n+\n   execute(): null {\n     const dirId = this.scope.resolve(this.node, this.dir);\n \n@@ -514,6 +556,10 @@ class TcbDirectiveCtorCircularFallbackOp extends TcbOp {\n     super();\n   }\n \n+  get optional() {\n+    return false;\n+  }\n+\n   execute(): ts.Identifier {\n     const id = this.tcb.allocateId();\n     const typeCtor = this.tcb.env.typeCtorFor(this.dir);\n@@ -541,6 +587,10 @@ class TcbDomSchemaCheckerOp extends TcbOp {\n     super();\n   }\n \n+  get optional() {\n+    return false;\n+  }\n+\n   execute(): ts.Expression|null {\n     if (this.checkElement) {\n       this.tcb.domSchemaChecker.checkElement(this.tcb.id, this.element, this.tcb.schemas);\n@@ -597,10 +647,14 @@ class TcbUnclaimedInputsOp extends TcbOp {\n     super();\n   }\n \n+  get optional() {\n+    return false;\n+  }\n+\n   execute(): null {\n     // `this.inputs` contains only those bindings not matched by any directive. These bindings go to\n     // the element itself.\n-    const elId = this.scope.resolve(this.element);\n+    let elId: ts.Expression|null = null;\n \n     // TODO(alxhub): this could be more efficient.\n     for (const binding of this.element.inputs) {\n@@ -622,6 +676,9 @@ class TcbUnclaimedInputsOp extends TcbOp {\n \n       if (this.tcb.env.config.checkTypeOfDomBindings && binding.type === BindingType.Property) {\n         if (binding.name !== 'style' && binding.name !== 'class') {\n+          if (elId === null) {\n+            elId = this.scope.resolve(this.element);\n+          }\n           // A direct binding to a property.\n           const propertyName = ATTR_TO_PROP[binding.name] || binding.name;\n           const prop = ts.createElementAccess(elId, ts.createStringLiteral(propertyName));\n@@ -656,6 +713,10 @@ class TcbDirectiveOutputsOp extends TcbOp {\n     super();\n   }\n \n+  get optional() {\n+    return false;\n+  }\n+\n   execute(): null {\n     const dirId = this.scope.resolve(this.node, this.dir);\n \n@@ -723,8 +784,12 @@ class TcbUnclaimedOutputsOp extends TcbOp {\n     super();\n   }\n \n+  get optional() {\n+    return false;\n+  }\n+\n   execute(): null {\n-    const elId = this.scope.resolve(this.element);\n+    let elId: ts.Expression|null = null;\n \n     // TODO(alxhub): this could be more efficient.\n     for (const output of this.element.outputs) {\n@@ -749,6 +814,9 @@ class TcbUnclaimedOutputsOp extends TcbOp {\n         // base `Event` type.\n         const handler = tcbCreateEventHandler(output, this.tcb, this.scope, EventParamType.Infer);\n \n+        if (elId === null) {\n+          elId = this.scope.resolve(this.element);\n+        }\n         const call = ts.createCall(\n             /* expression */ ts.createPropertyAccess(elId, 'addEventListener'),\n             /* typeArguments */ undefined,\n@@ -965,7 +1033,7 @@ class Scope {\n    */\n   render(): ts.Statement[] {\n     for (let i = 0; i < this.opQueue.length; i++) {\n-      this.executeOp(i);\n+      this.executeOp(i, /* skipOptional */ true);\n     }\n     return this.statements;\n   }\n@@ -1031,7 +1099,7 @@ class Scope {\n    * Like `executeOp`, but assert that the operation actually returned `ts.Expression`.\n    */\n   private resolveOp(opIndex: number): ts.Expression {\n-    const res = this.executeOp(opIndex);\n+    const res = this.executeOp(opIndex, /* skipOptional */ false);\n     if (res === null) {\n       throw new Error(`Error resolving operation, got null`);\n     }\n@@ -1045,12 +1113,16 @@ class Scope {\n    * and also protects against a circular dependency from the operation to itself by temporarily\n    * setting the operation's result to a special expression.\n    */\n-  private executeOp(opIndex: number): ts.Expression|null {\n+  private executeOp(opIndex: number, skipOptional: boolean): ts.Expression|null {\n     const op = this.opQueue[opIndex];\n     if (!(op instanceof TcbOp)) {\n       return op;\n     }\n \n+    if (skipOptional && op.optional) {\n+      return null;\n+    }\n+\n     // Set the result of the operation in the queue to its circular fallback. If executing this\n     // operation results in a circular dependency, this will prevent an infinite loop and allow for\n     // the resolution of such cycles."
        },
        {
            "sha": "c15b1bc60843e24e429472358de8c58f7784bf1c",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/span_comments_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/f42e6ce9175eb1b9b373c8ef787519a5ccde203b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fspan_comments_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f42e6ce9175eb1b9b373c8ef787519a5ccde203b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fspan_comments_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fspan_comments_spec.ts?ref=f42e6ce9175eb1b9b373c8ef787519a5ccde203b",
            "patch": "@@ -158,7 +158,7 @@ describe('type check blocks diagnostics', () => {\n         }];\n         const TEMPLATE = `<my-cmp #a></my-cmp>{{ a || a }}`;\n         expect(tcbWithSpans(TEMPLATE, DIRECTIVES))\n-            .toContain('((_t2 /*23,24*/) || (_t2 /*28,29*/) /*23,29*/);');\n+            .toContain('((_t1 /*23,24*/) || (_t1 /*28,29*/) /*23,29*/);');\n       });\n     });\n   });"
        },
        {
            "sha": "27cb1ac6e3e202a3469c94ba01b14ae7ae34b006",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_check_block_spec.ts",
            "status": "modified",
            "additions": 74,
            "deletions": 66,
            "changes": 140,
            "blob_url": "https://github.com/angular/angular/blob/f42e6ce9175eb1b9b373c8ef787519a5ccde203b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f42e6ce9175eb1b9b373c8ef787519a5ccde203b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts?ref=f42e6ce9175eb1b9b373c8ef787519a5ccde203b",
            "patch": "@@ -55,7 +55,7 @@ describe('type check blocks', () => {\n       selector: '[dir]',\n       inputs: {inputA: 'inputA'},\n     }];\n-    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('_t2: DirA = (null!); _t2.inputA = (\"value\");');\n+    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('_t1: DirA = (null!); _t1.inputA = (\"value\");');\n   });\n \n   it('should handle multiple bindings to the same property', () => {\n@@ -67,8 +67,8 @@ describe('type check blocks', () => {\n       inputs: {inputA: 'inputA'},\n     }];\n     const block = tcb(TEMPLATE, DIRECTIVES);\n-    expect(block).toContain('_t2.inputA = (1);');\n-    expect(block).toContain('_t2.inputA = (2);');\n+    expect(block).toContain('_t1.inputA = (1);');\n+    expect(block).toContain('_t1.inputA = (2);');\n   });\n \n   it('should handle empty bindings', () => {\n@@ -79,7 +79,7 @@ describe('type check blocks', () => {\n       selector: '[dir-a]',\n       inputs: {inputA: 'inputA'},\n     }];\n-    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('_t2.inputA = (undefined);');\n+    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('_t1.inputA = (undefined);');\n   });\n \n   it('should handle bindings without value', () => {\n@@ -90,7 +90,7 @@ describe('type check blocks', () => {\n       selector: '[dir-a]',\n       inputs: {inputA: 'inputA'},\n     }];\n-    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('_t2.inputA = (undefined);');\n+    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('_t1.inputA = (undefined);');\n   });\n \n   it('should handle implicit vars on ng-template', () => {\n@@ -124,7 +124,7 @@ describe('type check blocks', () => {\n       }];\n       expect(tcb(TEMPLATE, DIRECTIVES))\n           .toContain(\n-              'var _t2 = Dir.ngTypeCtor({ \"fieldA\": (((ctx).foo)), \"fieldB\": (null as any) });');\n+              'var _t1 = Dir.ngTypeCtor({ \"fieldA\": (((ctx).foo)), \"fieldB\": (null as any) });');\n     });\n \n     it('should handle multiple bindings to the same property', () => {\n@@ -157,7 +157,7 @@ describe('type check blocks', () => {\n       }];\n       const block = tcb(TEMPLATE, DIRECTIVES);\n       expect(block).toContain(\n-          'var _t2 = Dir.ngTypeCtor({ \"color\": (null as any), \"strong\": (null as any), \"enabled\": (null as any) });');\n+          'var _t1 = Dir.ngTypeCtor({ \"color\": (null as any), \"strong\": (null as any), \"enabled\": (null as any) });');\n       expect(block).toContain('\"blue\"; false; true;');\n     });\n \n@@ -175,8 +175,8 @@ describe('type check blocks', () => {\n       }];\n       expect(tcb(TEMPLATE, DIRECTIVES))\n           .toContain(\n-              'var _t3 = Dir.ngTypeCtor((null!)); ' +\n-              'var _t2 = Dir.ngTypeCtor({ \"input\": (_t3) });');\n+              'var _t2 = Dir.ngTypeCtor((null!)); ' +\n+              'var _t1 = Dir.ngTypeCtor({ \"input\": (_t2) });');\n     });\n \n     it('should generate circular references between two directives correctly', () => {\n@@ -204,9 +204,9 @@ describe('type check blocks', () => {\n       ];\n       expect(tcb(TEMPLATE, DIRECTIVES))\n           .toContain(\n-              'var _t4 = DirA.ngTypeCtor((null!)); ' +\n-              'var _t3 = DirB.ngTypeCtor({ \"inputB\": (_t4) }); ' +\n-              'var _t2 = DirA.ngTypeCtor({ \"inputA\": (_t3) });');\n+              'var _t3 = DirA.ngTypeCtor((null!)); ' +\n+              'var _t2 = DirB.ngTypeCtor({ \"inputB\": (_t3) }); ' +\n+              'var _t1 = DirA.ngTypeCtor({ \"inputA\": (_t2) });');\n     });\n \n     it('should handle empty bindings', () => {\n@@ -247,12 +247,23 @@ describe('type check blocks', () => {\n       }];\n       expect(tcb(TEMPLATE, DIRECTIVES))\n           .toContain(\n-              'var _t2 = Dir.ngTypeCtor({ \"fieldA\": (((ctx).foo)) }); ' +\n-              'var _t3: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n-              '_t3 = (((ctx).foo));');\n+              'var _t1 = Dir.ngTypeCtor({ \"fieldA\": (((ctx).foo)) }); ' +\n+              'var _t2: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n+              '_t2 = (((ctx).foo));');\n     });\n   });\n \n+  it('should only generate code for DOM elements that are actually referenced', () => {\n+    const TEMPLATE = `\n+      <div></div>\n+      <button #me (click)=\"handle(me)\"></button>\n+    `;\n+    const block = tcb(TEMPLATE);\n+    expect(block).not.toContain('\"div\"');\n+    expect(block).toContain('var _t1 = document.createElement(\"button\");');\n+    expect(block).toContain('(ctx).handle(_t1);');\n+  });\n+\n   it('should generate a forward element reference correctly', () => {\n     const TEMPLATE = `\n       {{ i.value }}\n@@ -273,9 +284,7 @@ describe('type check blocks', () => {\n       selector: '[dir]',\n       exportAs: ['dir'],\n     }];\n-    expect(tcb(TEMPLATE, DIRECTIVES))\n-        .toContain(\n-            'var _t1: Dir = (null!); \"\" + ((_t1).value); var _t2 = document.createElement(\"div\");');\n+    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('var _t1: Dir = (null!); \"\" + ((_t1).value);');\n   });\n \n   it('should handle style and class bindings specially', () => {\n@@ -301,7 +310,7 @@ describe('type check blocks', () => {\n       inputs: {'color': 'color', 'strong': 'strong', 'enabled': 'enabled'},\n     }];\n     const block = tcb(TEMPLATE, DIRECTIVES);\n-    expect(block).toContain('var _t2: Dir = (null!);');\n+    expect(block).toContain('var _t1: Dir = (null!);');\n     expect(block).not.toContain('\"color\"');\n     expect(block).not.toContain('\"strong\"');\n     expect(block).not.toContain('\"enabled\"');\n@@ -321,8 +330,8 @@ describe('type check blocks', () => {\n     }];\n     expect(tcb(TEMPLATE, DIRECTIVES))\n         .toContain(\n-            'var _t2: Dir = (null!); ' +\n-            '_t2.input = (_t2);');\n+            'var _t1: Dir = (null!); ' +\n+            '_t1.input = (_t1);');\n   });\n \n   it('should generate circular references between two directives correctly', () => {\n@@ -348,11 +357,10 @@ describe('type check blocks', () => {\n     ];\n     expect(tcb(TEMPLATE, DIRECTIVES))\n         .toContain(\n-            'var _t2: DirA = (null!); ' +\n-            'var _t3: DirB = (null!); ' +\n-            '_t2.inputA = (_t3); ' +\n-            'var _t4 = document.createElement(\"div\"); ' +\n-            '_t3.inputA = (_t2);');\n+            'var _t1: DirA = (null!); ' +\n+            'var _t2: DirB = (null!); ' +\n+            '_t1.inputA = (_t2); ' +\n+            '_t2.inputA = (_t1);');\n   });\n \n   it('should handle undeclared properties', () => {\n@@ -368,7 +376,7 @@ describe('type check blocks', () => {\n     }];\n     expect(tcb(TEMPLATE, DIRECTIVES))\n         .toContain(\n-            'var _t2: Dir = (null!); ' +\n+            'var _t1: Dir = (null!); ' +\n             '(((ctx).foo)); ');\n   });\n \n@@ -385,9 +393,9 @@ describe('type check blocks', () => {\n     }];\n     expect(tcb(TEMPLATE, DIRECTIVES))\n         .toContain(\n-            'var _t2: Dir = (null!); ' +\n-            'var _t3: typeof _t2[\"fieldA\"] = (null!); ' +\n-            '_t3 = (((ctx).foo)); ');\n+            'var _t1: Dir = (null!); ' +\n+            'var _t2: typeof _t1[\"fieldA\"] = (null!); ' +\n+            '_t2 = (((ctx).foo)); ');\n   });\n \n   it('should assign properties via element access for field names that are not JS identifiers',\n@@ -404,8 +412,8 @@ describe('type check blocks', () => {\n        }];\n        const block = tcb(TEMPLATE, DIRECTIVES);\n        expect(block).toContain(\n-           'var _t2: Dir = (null!); ' +\n-           '_t2[\"some-input.xs\"] = (((ctx).foo)); ');\n+           'var _t1: Dir = (null!); ' +\n+           '_t1[\"some-input.xs\"] = (((ctx).foo)); ');\n      });\n \n   it('should handle a single property bound to multiple fields', () => {\n@@ -421,8 +429,8 @@ describe('type check blocks', () => {\n     }];\n     expect(tcb(TEMPLATE, DIRECTIVES))\n         .toContain(\n-            'var _t2: Dir = (null!); ' +\n-            '_t2.field2 = _t2.field1 = (((ctx).foo));');\n+            'var _t1: Dir = (null!); ' +\n+            '_t1.field2 = _t1.field1 = (((ctx).foo));');\n   });\n \n   it('should handle a single property bound to multiple fields, where one of them is coerced',\n@@ -440,9 +448,9 @@ describe('type check blocks', () => {\n        }];\n        expect(tcb(TEMPLATE, DIRECTIVES))\n            .toContain(\n-               'var _t2: Dir = (null!); ' +\n-               'var _t3: typeof Dir.ngAcceptInputType_field1 = (null!); ' +\n-               '_t2.field2 = _t3 = (((ctx).foo));');\n+               'var _t1: Dir = (null!); ' +\n+               'var _t2: typeof Dir.ngAcceptInputType_field1 = (null!); ' +\n+               '_t1.field2 = _t2 = (((ctx).foo));');\n      });\n \n   it('should handle a single property bound to multiple fields, where one of them is undeclared',\n@@ -460,8 +468,8 @@ describe('type check blocks', () => {\n        }];\n        expect(tcb(TEMPLATE, DIRECTIVES))\n            .toContain(\n-               'var _t2: Dir = (null!); ' +\n-               '_t2.field2 = (((ctx).foo));');\n+               'var _t1: Dir = (null!); ' +\n+               '_t1.field2 = (((ctx).foo));');\n      });\n \n   it('should use coercion types if declared', () => {\n@@ -477,9 +485,9 @@ describe('type check blocks', () => {\n     }];\n     expect(tcb(TEMPLATE, DIRECTIVES))\n         .toContain(\n-            'var _t2: Dir = (null!); ' +\n-            'var _t3: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n-            '_t3 = (((ctx).foo));');\n+            'var _t1: Dir = (null!); ' +\n+            'var _t2: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n+            '_t2 = (((ctx).foo));');\n   });\n \n   it('should use coercion types if declared, even when backing field is not declared', () => {\n@@ -496,9 +504,9 @@ describe('type check blocks', () => {\n     }];\n     expect(tcb(TEMPLATE, DIRECTIVES))\n         .toContain(\n-            'var _t2: Dir = (null!); ' +\n-            'var _t3: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n-            '_t3 = (((ctx).foo));');\n+            'var _t1: Dir = (null!); ' +\n+            'var _t2: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n+            '_t2 = (((ctx).foo));');\n   });\n \n   it('should handle $any casts', () => {\n@@ -561,7 +569,7 @@ describe('type check blocks', () => {\n       const TEMPLATE = `<div dir (dirOutput)=\"foo($event)\"></div>`;\n       const block = tcb(TEMPLATE, DIRECTIVES);\n       expect(block).toContain(\n-          '_outputHelper(_t2[\"outputField\"]).subscribe(function ($event): any { (ctx).foo($event); });');\n+          '_outputHelper(_t1[\"outputField\"]).subscribe(function ($event): any { (ctx).foo($event); });');\n     });\n \n     it('should emit a listener function with AnimationEvent for animation events', () => {\n@@ -658,14 +666,14 @@ describe('type check blocks', () => {\n \n       it('should include null and undefined when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain('_t2.dirInput = (((ctx).a));');\n+        expect(block).toContain('_t1.dirInput = (((ctx).a));');\n         expect(block).toContain('((ctx).b);');\n       });\n       it('should use the non-null assertion operator when disabled', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, strictNullInputBindings: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('_t2.dirInput = (((ctx).a)!);');\n+        expect(block).toContain('_t1.dirInput = (((ctx).a)!);');\n         expect(block).toContain('((ctx).b)!;');\n       });\n     });\n@@ -674,7 +682,7 @@ describe('type check blocks', () => {\n       it('should check types of bindings when enabled', () => {\n         const TEMPLATE = `<div dir [dirInput]=\"a\" [nonDirInput]=\"b\"></div>`;\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain('_t2.dirInput = (((ctx).a));');\n+        expect(block).toContain('_t1.dirInput = (((ctx).a));');\n         expect(block).toContain('((ctx).b);');\n       });\n \n@@ -683,7 +691,7 @@ describe('type check blocks', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfInputBindings: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('_t2.dirInput = ((((ctx).a) as any));');\n+        expect(block).toContain('_t1.dirInput = ((((ctx).a) as any));');\n         expect(block).toContain('(((ctx).b) as any);');\n       });\n \n@@ -692,7 +700,7 @@ describe('type check blocks', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfInputBindings: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('_t2.dirInput = ((((((ctx).a)) === (((ctx).b))) as any));');\n+        expect(block).toContain('_t1.dirInput = ((((((ctx).a)) === (((ctx).b))) as any));');\n       });\n     });\n \n@@ -702,9 +710,9 @@ describe('type check blocks', () => {\n       it('should check types of directive outputs when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n         expect(block).toContain(\n-            '_outputHelper(_t2[\"outputField\"]).subscribe(function ($event): any { (ctx).foo($event); });');\n+            '_outputHelper(_t1[\"outputField\"]).subscribe(function ($event): any { (ctx).foo($event); });');\n         expect(block).toContain(\n-            '_t1.addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n+            '_t2.addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n       });\n       it('should not check types of directive outputs when disabled', () => {\n         const DISABLED_CONFIG:\n@@ -713,7 +721,7 @@ describe('type check blocks', () => {\n         expect(block).toContain('function ($event: any): any { (ctx).foo($event); }');\n         // Note that DOM events are still checked, that is controlled by `checkTypeOfDomEvents`\n         expect(block).toContain(\n-            '_t1.addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n+            '_t2.addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n       });\n     });\n \n@@ -739,17 +747,17 @@ describe('type check blocks', () => {\n       it('should check types of DOM events when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n         expect(block).toContain(\n-            '_outputHelper(_t2[\"outputField\"]).subscribe(function ($event): any { (ctx).foo($event); });');\n+            '_outputHelper(_t1[\"outputField\"]).subscribe(function ($event): any { (ctx).foo($event); });');\n         expect(block).toContain(\n-            '_t1.addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n+            '_t2.addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n       });\n       it('should not check types of DOM events when disabled', () => {\n         const DISABLED_CONFIG: TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfDomEvents: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n         // Note that directive outputs are still checked, that is controlled by\n         // `checkTypeOfOutputEvents`\n         expect(block).toContain(\n-            '_outputHelper(_t2[\"outputField\"]).subscribe(function ($event): any { (ctx).foo($event); });');\n+            '_outputHelper(_t1[\"outputField\"]).subscribe(function ($event): any { (ctx).foo($event); });');\n         expect(block).toContain('function ($event: any): any { (ctx).foo($event); }');\n       });\n     });\n@@ -785,7 +793,7 @@ describe('type check blocks', () => {\n \n       it('should trace references to a directive when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain('(_t2).value');\n+        expect(block).toContain('(_t1).value');\n       });\n \n       it('should trace references to an <ng-template> when enabled', () => {\n@@ -812,17 +820,17 @@ describe('type check blocks', () => {\n \n       it('should assign string value to the input when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain('_t2.disabled = (\"\");');\n-        expect(block).toContain('_t2.cols = (\"3\");');\n-        expect(block).toContain('_t2.rows = (2);');\n+        expect(block).toContain('_t1.disabled = (\"\");');\n+        expect(block).toContain('_t1.cols = (\"3\");');\n+        expect(block).toContain('_t1.rows = (2);');\n       });\n \n       it('should use any for attributes but still check bound attributes when disabled', () => {\n         const DISABLED_CONFIG: TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfAttributes: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n         expect(block).not.toContain('\"disabled\"');\n         expect(block).not.toContain('\"cols\"');\n-        expect(block).toContain('_t2.rows = (2);');\n+        expect(block).toContain('_t1.rows = (2);');\n       });\n     });\n \n@@ -912,8 +920,8 @@ describe('type check blocks', () => {\n                TypeCheckingConfig = {...BASE_CONFIG, honorAccessModifiersForInputBindings: true};\n            const block = tcb(TEMPLATE, DIRECTIVES, enableChecks);\n            expect(block).toContain(\n-               'var _t2: Dir = (null!); ' +\n-               '_t2[\"some-input.xs\"] = (((ctx).foo)); ');\n+               'var _t1: Dir = (null!); ' +\n+               '_t1[\"some-input.xs\"] = (((ctx).foo)); ');\n          });\n \n       it('should assign restricted properties via property access', () => {\n@@ -930,8 +938,8 @@ describe('type check blocks', () => {\n             TypeCheckingConfig = {...BASE_CONFIG, honorAccessModifiersForInputBindings: true};\n         const block = tcb(TEMPLATE, DIRECTIVES, enableChecks);\n         expect(block).toContain(\n-            'var _t2: Dir = (null!); ' +\n-            '_t2.fieldA = (((ctx).foo)); ');\n+            'var _t1: Dir = (null!); ' +\n+            '_t1.fieldA = (((ctx).foo)); ');\n       });\n     });\n   });"
        },
        {
            "sha": "e2a14bce688b32e834bc1bb2736a6bf99d4f3cc6",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker_spec.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/f42e6ce9175eb1b9b373c8ef787519a5ccde203b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f42e6ce9175eb1b9b373c8ef787519a5ccde203b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts?ref=f42e6ce9175eb1b9b373c8ef787519a5ccde203b",
            "patch": "@@ -66,15 +66,15 @@ runInEachFileSystem(os => {\n       const file1 = absoluteFrom('/file1.ts');\n       const file2 = absoluteFrom('/file2.ts');\n       const {program, templateTypeChecker, programStrategy} = setup([\n-        {fileName: file1, templates: {'Cmp1': '<div></div>'}},\n+        {fileName: file1, templates: {'Cmp1': '<div>{{value}}</div>'}},\n         {fileName: file2, templates: {'Cmp2': '<span></span>'}}\n       ]);\n \n       const cmp1 = getClass(getSourceFileOrError(program, file1), 'Cmp1');\n       const block = templateTypeChecker.getTypeCheckBlock(cmp1);\n       expect(block).not.toBeNull();\n       expect(block!.getText()).toMatch(/: i[0-9]\\.Cmp1/);\n-      expect(block!.getText()).toContain(`document.createElement(\"div\")`);\n+      expect(block!.getText()).toContain(`value`);\n     });\n \n     it('should clear old inlines when necessary', () => {\n@@ -223,43 +223,43 @@ runInEachFileSystem(os => {\n         const fileName = absoluteFrom('/main.ts');\n         const {program, templateTypeChecker} = setup([{\n           fileName,\n-          templates: {'Cmp': '<div></div>'},\n+          templates: {'Cmp': '<div>{{original}}</div>'},\n         }]);\n \n         const sf = getSourceFileOrError(program, fileName);\n         const cmp = getClass(sf, 'Cmp');\n \n         const tcbReal = templateTypeChecker.getTypeCheckBlock(cmp)!;\n-        expect(tcbReal.getText()).toContain('div');\n+        expect(tcbReal.getText()).toContain('original');\n \n-        templateTypeChecker.overrideComponentTemplate(cmp, '<span></span>');\n+        templateTypeChecker.overrideComponentTemplate(cmp, '<div>{{override}}</div>');\n         const tcbOverridden = templateTypeChecker.getTypeCheckBlock(cmp);\n         expect(tcbOverridden).not.toBeNull();\n-        expect(tcbOverridden!.getText()).not.toContain('div');\n-        expect(tcbOverridden!.getText()).toContain('span');\n+        expect(tcbOverridden!.getText()).not.toContain('original');\n+        expect(tcbOverridden!.getText()).toContain('override');\n       });\n \n       it('should clear overrides on request', () => {\n         const fileName = absoluteFrom('/main.ts');\n         const {program, templateTypeChecker} = setup([{\n           fileName,\n-          templates: {'Cmp': '<div></div>'},\n+          templates: {'Cmp': '<div>{{original}}</div>'},\n         }]);\n \n         const sf = getSourceFileOrError(program, fileName);\n         const cmp = getClass(sf, 'Cmp');\n \n-        templateTypeChecker.overrideComponentTemplate(cmp, '<span></span>');\n+        templateTypeChecker.overrideComponentTemplate(cmp, '<div>{{override}}</div>');\n         const tcbOverridden = templateTypeChecker.getTypeCheckBlock(cmp)!;\n-        expect(tcbOverridden.getText()).not.toContain('div');\n-        expect(tcbOverridden.getText()).toContain('span');\n+        expect(tcbOverridden.getText()).not.toContain('original');\n+        expect(tcbOverridden.getText()).toContain('override');\n \n         templateTypeChecker.resetOverrides();\n \n-        // The template should be back to the original, which has <div> and not <span>.\n+        // The template should be back to the original.\n         const tcbReal = templateTypeChecker.getTypeCheckBlock(cmp)!;\n-        expect(tcbReal.getText()).toContain('div');\n-        expect(tcbReal.getText()).not.toContain('span');\n+        expect(tcbReal.getText()).toContain('original');\n+        expect(tcbReal.getText()).not.toContain('override');\n       });\n \n       it('should override a template and make use of previously unused directives', () => {"
        }
    ],
    "stats": {
        "total": 252,
        "additions": 166,
        "deletions": 86
    }
}