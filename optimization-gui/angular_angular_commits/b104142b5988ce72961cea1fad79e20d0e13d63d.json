{
    "author": "TeriGlover",
    "message": "docs: Edits to remove jargon (#43052)\n\nPR Close #43052",
    "sha": "b104142b5988ce72961cea1fad79e20d0e13d63d",
    "files": [
        {
            "sha": "e01071c926ae464a6ceee647bfdf352c2830067b",
            "filename": "aio/content/guide/creating-libraries.md",
            "status": "modified",
            "additions": 17,
            "deletions": 17,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/b104142b5988ce72961cea1fad79e20d0e13d63d/aio%2Fcontent%2Fguide%2Fcreating-libraries.md",
            "raw_url": "https://github.com/angular/angular/raw/b104142b5988ce72961cea1fad79e20d0e13d63d/aio%2Fcontent%2Fguide%2Fcreating-libraries.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fcreating-libraries.md?ref=b104142b5988ce72961cea1fad79e20d0e13d63d",
            "patch": "@@ -1,6 +1,6 @@\n ï»¿# Creating libraries\n \n-This page provides a conceptual overview of how you can create and publish new libraries to extend Angular functionality.\n+This page provides a conceptual overview of how to create and publish new libraries to extend Angular functionality.\n \n If you find that you need to solve the same problem in more than one application (or want to share your solution with other developers), you have a candidate for a library.\n A simple example might be a button that sends users to your company website, that would be included in all applications that your company builds.\n@@ -31,7 +31,7 @@ The `ng generate` command creates the `projects/my-lib` folder in your workspace\n \n      For more details on how a library project is structured, refer to the [Library project files](guide/file-structure#library-project-files) section of the [Project File Structure guide](guide/file-structure).\n \n-     You can use the monorepo model to use the same workspace for multiple projects.\n+     Use the monorepo model to use the same workspace for multiple projects.\n      See [Setting up for a multi-project workspace](guide/file-structure#multiple-projects).\n \n </div>\n@@ -52,7 +52,7 @@ When you generate a new library, the workspace configuration file, `angular.json\n         ...\n </code-example>\n \n-You can build, test, and lint the project with CLI commands:\n+Build, test, and lint the project with CLI commands:\n \n <code-example language=\"bash\">\n  ng build my-lib --configuration development\n@@ -89,7 +89,7 @@ Here are some things to consider in migrating application functionality to a lib\n \n * Consider how you provide services to client applications.\n \n-   * Services should declare their own providers, rather than declaring providers in the NgModule or a component. Declaring a provider makes that service *tree-shakable*. This practice allows the compiler to leave the service out of the bundle if it never gets injected into the application that imports the library. For more about this, see [Tree-shakable providers](guide/architecture-services#providing-services).\n+   * Services should declare their own providers, rather than declaring providers in the NgModule or a component. Declaring a provider makes that service *tree-shakable*. This practice lets the compiler leave the service out of the bundle if it never gets injected into the application that imports the library. For more about this, see [Tree-shakable providers](guide/architecture-services#providing-services).\n \n    * If you register global service providers or share providers across multiple NgModules, use the [`forRoot()` and `forChild()` design patterns](guide/singleton-services) provided by the [RouterModule](api/router/RouterModule).\n \n@@ -105,7 +105,7 @@ This package can also include [schematics](guide/glossary#schematic) that provid\n A schematic that is packaged with a library can, for example, provide the Angular CLI with the information it needs to generate a component that configures and uses a particular feature, or set of features, defined in that library.\n One example of this is [Angular Material's navigation schematic](https://material.angular.io/guide/schematics#navigation-schematic) which configures the CDK's [BreakpointObserver](https://material.angular.io/cdk/layout/overview#breakpointobserver) and uses it with Material's [MatSideNav](https://material.angular.io/components/sidenav/overview) and [MatToolbar](https://material.angular.io/components/toolbar/overview) components.\n \n-You can create and include the following kinds of schematics:\n+Create and include the following kinds of schematics:\n \n * Include an installation schematic so that `ng add` can add your library to a project.\n \n@@ -118,7 +118,7 @@ For example, you could define a schematic to create a dropdown that is pre-popul\n If you want a dropdown that would contain different passed-in values each time, your library could define a schematic to create it with a given configuration. Developers could then use `ng generate` to configure an instance for their own application.\n \n Suppose you want to read a configuration file and then generate a form based on that configuration.\n-If that form will need additional customization by the developer who is using your library, it might work best as a schematic.\n+If that form needs additional customization by the developer who is using your library, it might work best as a schematic.\n However, if the form will always be the same and not need much customization by developers, then you could create a dynamic component that takes the configuration and generates the form.\n In general, the more complex the customization, the more useful the schematic approach.\n \n@@ -150,15 +150,15 @@ npm publish\n ## Managing assets in a library\n \n Starting with version 9.x of the [ng-packagr](https://github.com/ng-packagr/ng-packagr/blob/master/README.md) tool, you can configure the tool to automatically copy assets into your library package as part of the build process.\n-You can use this feature when your library needs to publish optional theming files, Sass mixins, or documentation (like a changelog).\n+Use this feature when your library needs to publish optional theming files, Sass mixins, or documentation (like a changelog).\n \n * Learn how to [copy assets into your library as part of the build](https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md).\n \n * Learn more about how to use the tool to [embed assets in CSS](https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md).\n \n ## Linked libraries\n \n-While working on a published library, you can use [npm link](https://docs.npmjs.com/cli/link) to avoid reinstalling the library on every build.\n+While working on a published library, use [npm link](https://docs.npmjs.com/cli/link) to avoid reinstalling the library on every build.\n \n The library must be rebuilt on every change.\n When linking a library, make sure that the build step runs in watch mode, and that the library's `package.json` configuration points at the correct entry points.\n@@ -171,10 +171,10 @@ This ensures that when modules ask for Angular, they all get the exact same modu\n If a library lists `@angular/core` in `dependencies` instead of `peerDependencies`, it might get a different Angular module instead, which would cause your application to break.\n \n While developing a library, you must install all peer dependencies through `devDependencies` to ensure that the library compiles properly.\n-A linked library will then have its own set of Angular libraries that it uses for building, located in its `node_modules` folder.\n+A linked library then has its own set of Angular libraries that it uses for building, located in its `node_modules` folder.\n However, this can cause problems while building or running your application.\n \n-To get around this problem you can use TypeScript path mapping to tell TypeScript that it should load some modules from a specific location.\n+To get around this problem use TypeScript path mapping to tell TypeScript that it should load some modules from a specific location.\n List all the peer dependencies that your library uses in the workspace TypeScript configuration file `./tsconfig.json`, and point them at the local copy in the application's `node_modules` folder.\n \n ```\n@@ -196,7 +196,7 @@ This mapping ensures that your library always loads the local copies of the modu\n \n ## Using your own library in apps\n \n-You don't have to publish your library to the npm package manager in order to use it in your own applications, but you do have to build it first.\n+You don't have to publish your library to the npm package manager to use it in your own applications, but you do have to build it first.\n \n To use your own library in an app:\n \n@@ -213,7 +213,7 @@ To use your own library in an app:\n ### Building and rebuilding your library\n \n The build step is important if you haven't published your library as an npm package and then installed the package back into your application from npm.\n-For instance, if you clone your git repository and run `npm install`, your editor will show the `my-lib` imports as missing if you haven't yet built your library.\n+For instance, if you clone your git repository and run `npm install`, your editor shows the `my-lib` imports as missing if you haven't yet built your library.\n \n <div class=\"alert is-helpful\">\n \n@@ -256,7 +256,7 @@ TypeScript path mappings should *not* point to the library source `.ts` files.\n \n ## Building libraries with Ivy\n \n-There are three distribution formats that you can use when publishing a library:\n+There are three distribution formats to use when publishing a library:\n \n * View Engine _(deprecated)_&mdash;legacy format, slated for removal in Angular version 13.\n   Only use this format if you must support View Engine applications.\n@@ -296,7 +296,7 @@ Enable partial-Ivy compilation by replacing `\"enableIvy\": false` with `\"compilat\n \n For publishing to npm use the partial-Ivy format as it is stable between patch versions of Angular.\n \n-Avoid compiling libraries with full-Ivy code if you are publishing to npm because the generated Ivy instructions are not part of Angular's public API, and so may change between patch versions.\n+Avoid compiling libraries with full-Ivy code if you are publishing to npm because the generated Ivy instructions are not part of Angular's public API, and so might change between patch versions.\n \n Partial-Ivy code is not backward compatible with View Engine.\n If you use the library in a View Engine application, you must compile the library into the View Engine format by setting `\"enableIvy\": false` in the `tsconfig.json` file.\n@@ -335,11 +335,11 @@ If you've never published a package in npm before, you must create a user accoun\n \n An application installs many Angular libraries from npm into its `node_modules` directory.\n However, the code in these libraries cannot be bundled directly along with the built application as it is not fully compiled.\n-To finish compilation, you can use the Angular linker.\n+To finish compilation, use the Angular linker.\n \n For applications that don't use the Angular CLI, the linker is available as a Babel plugin.\n-You can use the Babel plugin using the module `@angular/compiler-cli/linker/babel` to incorporate into your builds.\n-For example, you can integrate the plugin into a custom Webpack build by registering the linker as a plugin for `babel-loader`.\n+Use the Babel plugin using the module `@angular/compiler-cli/linker/babel` to incorporate into your builds.\n+For example, integrate the plugin into a custom Webpack build by registering the linker as a plugin for `babel-loader`.\n \n Previously, if you ran `yarn install` or `npm install` you had to re-run `ngcc`.\n Now, libraries only need to be processed by the linker a single time, regardless of other npm operations."
        },
        {
            "sha": "0f55009e0efed93c3aa7342fcef323a197b555d4",
            "filename": "aio/content/guide/libraries.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/b104142b5988ce72961cea1fad79e20d0e13d63d/aio%2Fcontent%2Fguide%2Flibraries.md",
            "raw_url": "https://github.com/angular/angular/raw/b104142b5988ce72961cea1fad79e20d0e13d63d/aio%2Fcontent%2Fguide%2Flibraries.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Flibraries.md?ref=b104142b5988ce72961cea1fad79e20d0e13d63d",
            "patch": "@@ -32,6 +32,6 @@ This complexity can pay off, however, when the library is being used in multiple\n <div class=\"alert is-helpful\">\n \n Note that libraries are intended to be used by Angular applications.\n-To add Angular functionality to non-Angular web applications, you can use [Angular custom elements](guide/elements).\n+To add Angular functionality to non-Angular web applications, use [Angular custom elements](guide/elements).\n \n </div>"
        },
        {
            "sha": "2f160e6f479f7dd054ebc0b2c7b3975b57ca89d8",
            "filename": "aio/content/guide/using-libraries.md",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/b104142b5988ce72961cea1fad79e20d0e13d63d/aio%2Fcontent%2Fguide%2Fusing-libraries.md",
            "raw_url": "https://github.com/angular/angular/raw/b104142b5988ce72961cea1fad79e20d0e13d63d/aio%2Fcontent%2Fguide%2Fusing-libraries.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fusing-libraries.md?ref=b104142b5988ce72961cea1fad79e20d0e13d63d",
            "patch": "@@ -6,7 +6,7 @@ See the [Angular Resources](resources) page for links to the most popular ones.\n ## Installing libraries\n \n Libraries are published as [npm packages](guide/npm-packages), usually together with schematics that integrate them with the Angular CLI.\n-To integrate reusable library code into an application, you need to install the package and import the provided functionality where you will use it. For most published Angular libraries, you can use the Angular CLI `ng add <lib_name>` command.\n+To integrate reusable library code into an application, you need to install the package and import the provided functionality where you will use it. For most published Angular libraries, use the Angular CLI `ng add <lib_name>` command.\n \n The `ng add` command uses a package manager such as [npm](https://www.npmjs.com/) or [yarn](https://yarnpkg.com/) to install the library package, and invokes schematics that are included in the package to other scaffolding within the project code, such as adding import statements, fonts, and themes.\n \n@@ -15,7 +15,7 @@ For an example, see the [Angular Material](https://material.angular.io/) documen\n \n ### Library typings\n \n-Library packages often include typings in `.d.ts` files; see examples in `node_modules/@angular/material`. If your library's package does not include typings and your IDE complains, you may need to install the library's associated `@types/<lib_name>` package.\n+Library packages often include typings in `.d.ts` files; see examples in `node_modules/@angular/material`. If your library's package does not include typings and your IDE complains, you might need to install the library's associated `@types/<lib_name>` package.\n \n For example, suppose you have a library named `d3`:\n "
        }
    ],
    "stats": {
        "total": 40,
        "additions": 20,
        "deletions": 20
    }
}