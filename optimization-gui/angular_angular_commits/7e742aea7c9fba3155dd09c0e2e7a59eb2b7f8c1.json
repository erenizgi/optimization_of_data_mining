{
    "author": "petebacondarwin",
    "message": "refactor(compiler-cli): linker - add Babel plugin, FileLinker and initial PartialLinkers (#39116)\n\nThis commit adds the basic building blocks for linking partial declarations.\nIn particular it provides a generic `FileLinker` class that delegates to\na set of (not yet implemented) `PartialLinker` classes.\n\nThe Babel plugin makes use of this `FileLinker` providing concrete classes\nfor `AstHost` and `AstFactory` that work with Babel AST. It can be created\nwith the following code:\n\n```ts\nconst plugin = createEs2015LinkerPlugin({ /* options */ });\n```\n\nPR Close #39116",
    "sha": "7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
    "files": [
        {
            "sha": "0c9fb1309d46968a84e50d0684f3d63aac1a79d1",
            "filename": "packages/compiler-cli/linker/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2FBUILD.bazel?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -8,11 +8,8 @@ ts_library(\n         \"src/**/*.ts\",\n     ]),\n     deps = [\n+        \"//packages/compiler\",\n         \"//packages/compiler-cli/src/ngtsc/translator\",\n-        \"@npm//@babel/core\",\n-        \"@npm//@babel/types\",\n-        \"@npm//@types/babel__core\",\n-        \"@npm//@types/babel__traverse\",\n         \"@npm//typescript\",\n     ],\n )"
        },
        {
            "sha": "d063084c3b3f354fd09e0407d5c44c0f9b0339a1",
            "filename": "packages/compiler-cli/linker/README.md",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2FREADME.md?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,18 @@\n+# Angular Linker\n+\n+This package contains a `FileLinker` and supporting code to be able to \"link\" partial declarations of components, directives, etc in libraries to produce the full definitions.\n+\n+The partial declaration format allows library packages to be published to npm without exposing the underlying Ivy instructions.\n+\n+The tooling here allows application build tools (e.g. CLI) to produce fully compiled components, directives, etc at the point when the application is bundled.\n+These linked files can be cached outside `node_modules` so it does not suffer from problems of mutating packages in `node_modules`.\n+\n+Generally this tooling will be wrapped in a transpiler specific plugin, such as the provided [Babel plugin](./babel).\n+\n+## Unit Testing\n+\n+The unit tests are built and run using Bazel:\n+\n+```bash\n+yarn bazel test //packages/compiler-cli/linker/test\n+```"
        },
        {
            "sha": "b5a15beef37b3eee817b9c3497affc803ebb916c",
            "filename": "packages/compiler-cli/linker/babel/BUILD.bazel",
            "status": "added",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fbabel%2FBUILD.bazel?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,19 @@\n+load(\"//tools:defaults.bzl\", \"ts_library\")\n+\n+package(default_visibility = [\"//visibility:public\"])\n+\n+ts_library(\n+    name = \"babel\",\n+    srcs = [\"index.ts\"] + glob([\n+        \"src/**/*.ts\",\n+    ]),\n+    deps = [\n+        \"//packages/compiler\",\n+        \"//packages/compiler-cli/linker\",\n+        \"//packages/compiler-cli/src/ngtsc/translator\",\n+        \"@npm//@babel/core\",\n+        \"@npm//@babel/types\",\n+        \"@npm//@types/babel__core\",\n+        \"@npm//@types/babel__traverse\",\n+    ],\n+)"
        },
        {
            "sha": "374cc55d078cffba29215d2aec8aba881d7f791c",
            "filename": "packages/compiler-cli/linker/babel/README.md",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fbabel%2FREADME.md?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,12 @@\n+# Angular linker - Babel plugin\n+\n+This package contains a Babel plugin that can be used to find and link partially compiled declarations in library source code.\n+See the [linker package README](../README.md) for more information.\n+\n+## Unit Testing\n+\n+The unit tests are built and run using Bazel:\n+\n+```bash\n+yarn bazel test //packages/compiler-cli/linker/babel/test\n+```"
        },
        {
            "sha": "cf9450bf4bfaa736ca0a2c7d5056ac8de96d7930",
            "filename": "packages/compiler-cli/linker/babel/index.ts",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Findex.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,8 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+export {createEs2015LinkerPlugin} from './src/es2015_linker_plugin';\n\\ No newline at end of file"
        },
        {
            "sha": "811f8a9bac091d202069830900a9a5807f44cf88",
            "filename": "packages/compiler-cli/linker/babel/src/ast/babel_ast_factory.ts",
            "status": "renamed",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Fsrc%2Fast%2Fbabel_ast_factory.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Fsrc%2Fast%2Fbabel_ast_factory.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Fsrc%2Fast%2Fbabel_ast_factory.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -7,8 +7,8 @@\n  */\n import * as t from '@babel/types';\n \n+import {assert} from '../../../../linker';\n import {AstFactory, BinaryOperator, LeadingComment, ObjectLiteralProperty, SourceMapRange, TemplateLiteral, VariableDeclarationType} from '../../../../src/ngtsc/translator';\n-import {assert} from '../utils';\n \n /**\n  * A Babel flavored implementation of the AstFactory.",
            "previous_filename": "packages/compiler-cli/linker/src/ast/babel/babel_ast_factory.ts"
        },
        {
            "sha": "4e826d80281b8680be1cbdd99f74adfdc9539a54",
            "filename": "packages/compiler-cli/linker/babel/src/ast/babel_ast_host.ts",
            "status": "renamed",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Fsrc%2Fast%2Fbabel_ast_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Fsrc%2Fast%2Fbabel_ast_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Fsrc%2Fast%2Fbabel_ast_host.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -8,9 +8,7 @@\n \n import * as t from '@babel/types';\n \n-import {FatalLinkerError} from '../../fatal_linker_error';\n-import {AstHost, Range} from '../ast_host';\n-import {assert} from '../utils';\n+import {assert, AstHost, FatalLinkerError, Range} from '../../../../linker';\n \n /**\n  * This implementation of `AstHost` is able to get information from Babel AST nodes.",
            "previous_filename": "packages/compiler-cli/linker/src/ast/babel/babel_ast_host.ts"
        },
        {
            "sha": "5eb9d0cee31e4e79804a99d4091d8fac7fc949f8",
            "filename": "packages/compiler-cli/linker/babel/src/babel_declaration_scope.ts",
            "status": "added",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Fsrc%2Fbabel_declaration_scope.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Fsrc%2Fbabel_declaration_scope.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Fsrc%2Fbabel_declaration_scope.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,67 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {NodePath, Scope} from '@babel/traverse';\n+import * as t from '@babel/types';\n+\n+import {DeclarationScope} from '../../../linker';\n+\n+export type ConstantScopePath = NodePath<t.Function|t.Program>;\n+\n+/**\n+ * This class represents the lexical scope of a partial declaration in Babel source code.\n+ *\n+ * Its only responsibility is to compute a reference object for the scope of shared constant\n+ * statements that will be generated during partial linking.\n+ */\n+export class BabelDeclarationScope implements DeclarationScope<ConstantScopePath, t.Expression> {\n+  /**\n+   * Construct a new `BabelDeclarationScope`.\n+   *\n+   * @param declarationScope the Babel scope containing the declaration call expression.\n+   */\n+  constructor(private declarationScope: Scope) {}\n+\n+  /**\n+   * Compute the Babel `NodePath` that can be used to reference the lexical scope where any\n+   * shared constant statements would be inserted.\n+   *\n+   * There will only be a shared constant scope if the expression is in an ECMAScript module, or a\n+   * UMD module. Otherwise `null` is returned to indicate that constant statements must be emitted\n+   * locally to the generated linked definition, to avoid polluting the global scope.\n+   *\n+   * @param expression the expression that points to the Angular core framework import.\n+   */\n+  getConstantScopeRef(expression: t.Expression): ConstantScopePath|null {\n+    // If the expression is of the form `a.b.c` then we want to get the far LHS (e.g. `a`).\n+    let bindingExpression = expression;\n+    while (t.isMemberExpression(bindingExpression)) {\n+      bindingExpression = bindingExpression.object;\n+    }\n+\n+    if (!t.isIdentifier(bindingExpression)) {\n+      return null;\n+    }\n+\n+    // The binding of the expression is where this identifier was declared.\n+    // This could be a variable declaration, an import namespace or a function parameter.\n+    const binding = this.declarationScope.getBinding(bindingExpression.name);\n+    if (binding === undefined) {\n+      return null;\n+    }\n+\n+    // We only support shared constant statements if the binding was in a UMD module (i.e. declared\n+    // within a `t.Function`) or an ECMASCript module (i.e. declared at the top level of a\n+    // `t.Program` that is marked as a module).\n+    const path = binding.scope.path;\n+    if (!path.isFunctionParent() && !(path.isProgram() && path.node.sourceType === 'module')) {\n+      return null;\n+    }\n+\n+    return path;\n+  }\n+}"
        },
        {
            "sha": "b13be8e4073fc9bb6fee341ede1966d399992acd",
            "filename": "packages/compiler-cli/linker/babel/src/es2015_linker_plugin.ts",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Fsrc%2Fes2015_linker_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Fsrc%2Fes2015_linker_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Fsrc%2Fes2015_linker_plugin.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,167 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {PluginObj} from '@babel/core';\n+import {NodePath} from '@babel/traverse';\n+import * as t from '@babel/types';\n+\n+import {FileLinker, isFatalLinkerError, LinkerEnvironment, LinkerOptions} from '../../../linker';\n+\n+import {BabelAstFactory} from './ast/babel_ast_factory';\n+import {BabelAstHost} from './ast/babel_ast_host';\n+import {BabelDeclarationScope, ConstantScopePath} from './babel_declaration_scope';\n+\n+/**\n+ * Create a Babel plugin that visits the program, identifying and linking partial declarations.\n+ *\n+ * The plugin delegates most of its work to a generic `FileLinker` for each file (`t.Program` in\n+ * Babel) that is visited.\n+ */\n+export function createEs2015LinkerPlugin(options: Partial<LinkerOptions> = {}): PluginObj {\n+  let fileLinker: FileLinker<ConstantScopePath, t.Statement, t.Expression>|null = null;\n+\n+  const linkerEnvironment = LinkerEnvironment.create<t.Statement, t.Expression>(\n+      new BabelAstHost(), new BabelAstFactory(), options);\n+\n+  return {\n+    visitor: {\n+      Program: {\n+\n+        /**\n+         * Create a new `FileLinker` as we enter each file (`t.Program` in Babel).\n+         */\n+        enter(path: NodePath<t.Program>): void {\n+          assertNull(fileLinker);\n+          const file: BabelFile = path.hub.file;\n+          fileLinker = new FileLinker(linkerEnvironment, file.opts.filename ?? '', file.code);\n+        },\n+\n+        /**\n+         * On exiting the file, insert any shared constant statements that were generated during\n+         * linking of the partial declarations.\n+         */\n+        exit(): void {\n+          assertNotNull(fileLinker);\n+          for (const {constantScope, statements} of fileLinker.getConstantStatements()) {\n+            insertStatements(constantScope, statements);\n+          }\n+          fileLinker = null;\n+        }\n+      },\n+\n+      /**\n+       * Test each call expression to see if it is a partial declaration; it if is then replace it\n+       * with the results of linking the declaration.\n+       */\n+      CallExpression(call: NodePath<t.CallExpression>): void {\n+        try {\n+          assertNotNull(fileLinker);\n+\n+          const callee = call.node.callee;\n+          if (!t.isExpression(callee)) {\n+            return;\n+          }\n+          const calleeName = linkerEnvironment.host.getSymbolName(callee);\n+          if (calleeName === null) {\n+            return;\n+          }\n+          const args = call.node.arguments;\n+          if (!fileLinker.isPartialDeclaration(calleeName) || !isExpressionArray(args)) {\n+            return;\n+          }\n+\n+          const declarationScope = new BabelDeclarationScope(call.scope);\n+          const replacement = fileLinker.linkPartialDeclaration(calleeName, args, declarationScope);\n+\n+          call.replaceWith(replacement);\n+        } catch (e) {\n+          const node = isFatalLinkerError(e) ? e.node as t.Node : call.node;\n+          throw buildCodeFrameError(call.hub.file, e.message, node);\n+        }\n+      }\n+    }\n+  };\n+}\n+\n+/**\n+ * Insert the `statements` at the location defined by `path`.\n+ *\n+ * The actual insertion strategy depends upon the type of the `path`.\n+ */\n+function insertStatements(path: ConstantScopePath, statements: t.Statement[]): void {\n+  if (path.isFunction()) {\n+    insertIntoFunction(path, statements);\n+  } else if (path.isProgram()) {\n+    insertIntoProgram(path, statements);\n+  }\n+}\n+\n+/**\n+ * Insert the `statements` at the top of the body of the `fn` function.\n+ */\n+function insertIntoFunction(fn: NodePath<t.Function>, statements: t.Statement[]): void {\n+  const body = fn.get('body');\n+  body.unshiftContainer('body', statements);\n+}\n+\n+/**\n+ * Insert the `statements` at the top of the `program`, below any import statements.\n+ */\n+function insertIntoProgram(program: NodePath<t.Program>, statements: t.Statement[]): void {\n+  const body = program.get('body');\n+  const importStatements = body.filter(statement => statement.isImportDeclaration());\n+  if (importStatements.length === 0) {\n+    program.unshiftContainer('body', statements);\n+  } else {\n+    importStatements[importStatements.length - 1].insertAfter(statements);\n+  }\n+}\n+\n+/**\n+ * Return true if all the `nodes` are Babel expressions.\n+ */\n+function isExpressionArray(nodes: t.Node[]): nodes is t.Expression[] {\n+  return nodes.every(node => t.isExpression(node));\n+}\n+\n+/**\n+ * Assert that the given `obj` is `null`.\n+ */\n+function assertNull<T>(obj: T|null): asserts obj is null {\n+  if (obj !== null) {\n+    throw new Error('BUG - expected `obj` to be null');\n+  }\n+}\n+\n+/**\n+ * Assert that the given `obj` is not `null`.\n+ */\n+function assertNotNull<T>(obj: T|null): asserts obj is T {\n+  if (obj === null) {\n+    throw new Error('BUG - expected `obj` not to be null');\n+  }\n+}\n+\n+/**\n+ * Create a string representation of an error that includes the code frame of the `node`.\n+ */\n+function buildCodeFrameError(file: BabelFile, message: string, node: t.Node): string {\n+  const filename = file.opts.filename || '(unknown file)';\n+  const error = file.buildCodeFrameError(node, message);\n+  return `${filename}: ${error.message}`;\n+}\n+\n+/**\n+ * This interface is making up for the fact that the Babel typings for `NodePath.hub.file` are\n+ * lacking.\n+ */\n+interface BabelFile {\n+  code: string;\n+  opts: {filename?: string;};\n+\n+  buildCodeFrameError(node: t.Node, message: string): Error;\n+}"
        },
        {
            "sha": "f2a426de889f12a266f6d7b744494f775132d9b6",
            "filename": "packages/compiler-cli/linker/babel/test/BUILD.bazel",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2FBUILD.bazel?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,36 @@\n+load(\"//tools:defaults.bzl\", \"jasmine_node_test\", \"ts_library\")\n+\n+package(default_visibility = [\"//visibility:public\"])\n+\n+ts_library(\n+    name = \"test_lib\",\n+    testonly = True,\n+    srcs = glob([\n+        \"**/*.ts\",\n+    ]),\n+    deps = [\n+        \"//packages:types\",\n+        \"//packages/compiler\",\n+        \"//packages/compiler-cli/linker\",\n+        \"//packages/compiler-cli/linker/babel\",\n+        \"//packages/compiler-cli/src/ngtsc/translator\",\n+        \"@npm//@babel/core\",\n+        \"@npm//@babel/generator\",\n+        \"@npm//@babel/parser\",\n+        \"@npm//@babel/template\",\n+        \"@npm//@babel/traverse\",\n+        \"@npm//@babel/types\",\n+        \"@npm//@types/babel__core\",\n+        \"@npm//@types/babel__generator\",\n+        \"@npm//@types/babel__template\",\n+        \"@npm//@types/babel__traverse\",\n+    ],\n+)\n+\n+jasmine_node_test(\n+    name = \"test\",\n+    bootstrap = [\"//tools/testing:node_no_angular_es5\"],\n+    deps = [\n+        \":test_lib\",\n+    ],\n+)"
        },
        {
            "sha": "c1f874d7f6fec76f33c64fecea6fad363e126e9b",
            "filename": "packages/compiler-cli/linker/babel/test/ast/babel_ast_factory_spec.ts",
            "status": "renamed",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2Fast%2Fbabel_ast_factory_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2Fast%2Fbabel_ast_factory_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2Fast%2Fbabel_ast_factory_spec.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -10,7 +10,7 @@ import generate from '@babel/generator';\n import {expression, statement} from '@babel/template';\n import * as t from '@babel/types';\n \n-import {BabelAstFactory} from '../../../src/ast/babel/babel_ast_factory';\n+import {BabelAstFactory} from '../../src/ast/babel_ast_factory';\n \n describe('BabelAstFactory', () => {\n   let factory: BabelAstFactory;",
            "previous_filename": "packages/compiler-cli/linker/test/ast/babel/babel_ast_factory_spec.ts"
        },
        {
            "sha": "746f6cd3aed1d53dde29b9d8cdf42ab42c4b3b41",
            "filename": "packages/compiler-cli/linker/babel/test/ast/babel_ast_host_spec.ts",
            "status": "renamed",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2Fast%2Fbabel_ast_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2Fast%2Fbabel_ast_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2Fast%2Fbabel_ast_host_spec.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -8,7 +8,7 @@\n import * as t from '@babel/types';\n import template from '@babel/template';\n import {parse} from '@babel/parser';\n-import {BabelAstHost} from '../../../src/ast/babel/babel_ast_host';\n+import {BabelAstHost} from '../../src/ast/babel_ast_host';\n \n describe('BabelAstHost', () => {\n   let host: BabelAstHost;",
            "previous_filename": "packages/compiler-cli/linker/test/ast/babel/babel_ast_host_spec.ts"
        },
        {
            "sha": "b4c5545f610ea18d2c76f3ebea08097c327b3728",
            "filename": "packages/compiler-cli/linker/babel/test/babel_declaration_scope_spec.ts",
            "status": "added",
            "additions": 116,
            "deletions": 0,
            "changes": 116,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2Fbabel_declaration_scope_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2Fbabel_declaration_scope_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2Fbabel_declaration_scope_spec.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,116 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {parse} from '@babel/parser';\n+import traverse, {NodePath} from '@babel/traverse';\n+import * as t from '@babel/types';\n+import {BabelDeclarationScope} from '../src/babel_declaration_scope';\n+\n+\n+describe('BabelDeclarationScope', () => {\n+  describe('getConstantScopeRef()', () => {\n+    it('should return a path to the ES module where the expression was imported', () => {\n+      const ast = parse(\n+          [\n+            'import * as core from \\'@angular/core\\';',\n+            'function foo() {',\n+            '  var TEST = core;',\n+            '}',\n+          ].join('\\n'),\n+          {sourceType: 'module'});\n+      const nodePath = findVarDeclaration(ast, 'TEST');\n+      const scope = new BabelDeclarationScope(nodePath.scope);\n+      const constantScope = scope.getConstantScopeRef(nodePath.get('init').node);\n+      expect(constantScope).not.toBe(null);\n+      expect(constantScope!.node).toBe(ast.program);\n+    });\n+\n+    it('should return a path to the ES Module where the expression is declared', () => {\n+      const ast = parse(\n+          [\n+            'var core;',\n+            'export function foo() {',\n+            '  var TEST = core;',\n+            '}',\n+          ].join('\\n'),\n+          {sourceType: 'module'});\n+      const nodePath = findVarDeclaration(ast, 'TEST');\n+      const scope = new BabelDeclarationScope(nodePath.scope);\n+      const constantScope = scope.getConstantScopeRef(nodePath.get('init').node);\n+      expect(constantScope).not.toBe(null);\n+      expect(constantScope!.node).toBe(ast.program);\n+    });\n+\n+    it('should return null if the file is not an ES module', () => {\n+      const ast = parse(\n+          [\n+            'var core;',\n+            'function foo() {',\n+            '  var TEST = core;',\n+            '}',\n+          ].join('\\n'),\n+          {sourceType: 'script'});\n+      const nodePath = findVarDeclaration(ast, 'TEST');\n+      const scope = new BabelDeclarationScope(nodePath.scope);\n+      const constantScope = scope.getConstantScopeRef(nodePath.get('init').node);\n+      expect(constantScope).toBe(null);\n+    });\n+\n+    it('should return the IIFE factory function where the expression is a parameter', () => {\n+      const ast = parse(\n+          [\n+            'var core;',\n+            '(function(core) {',\n+            '  var BLOCK = \\'block\\';',\n+            '  function foo() {',\n+            '    var TEST = core;',\n+            '  }',\n+            '})(core);',\n+          ].join('\\n'),\n+          {sourceType: 'script'});\n+      const nodePath = findVarDeclaration(ast, 'TEST');\n+      const fnPath = findFirstFunction(ast);\n+      const scope = new BabelDeclarationScope(nodePath.scope);\n+      const constantScope = scope.getConstantScopeRef(nodePath.get('init').node);\n+      expect(constantScope).not.toBe(null);\n+      expect(constantScope!.isFunction()).toBe(true);\n+      expect(constantScope!.node).toEqual(fnPath.node);\n+    });\n+  });\n+});\n+\n+function findVarDeclaration(\n+    file: t.File, varName: string): NodePath<t.VariableDeclarator&{init: t.Expression}> {\n+  let varDecl: NodePath<t.VariableDeclarator>|undefined = undefined;\n+  traverse(file, {\n+    VariableDeclarator: (path) => {\n+      const id = path.get('id');\n+      if (id.isIdentifier() && id.node.name === varName && path.get('init') !== null) {\n+        varDecl = path;\n+        path.stop();\n+      }\n+    }\n+  });\n+  if (varDecl === undefined) {\n+    throw new Error(`TEST BUG: expected to find variable declaration for ${varName}.`);\n+  }\n+  return varDecl;\n+}\n+\n+function findFirstFunction(file: t.File): NodePath<t.Function> {\n+  let fn: NodePath<t.Function>|undefined = undefined;\n+  traverse(file, {\n+    Function: (path) => {\n+      fn = path;\n+      path.stop();\n+    }\n+  });\n+  if (fn === undefined) {\n+    throw new Error(`TEST BUG: expected to find a function.`);\n+  }\n+  return fn;\n+}"
        },
        {
            "sha": "1f492df846c7b5cbb0dfcccd92edd28cfbb66769",
            "filename": "packages/compiler-cli/linker/babel/test/es2015_linker_plugin_spec.ts",
            "status": "added",
            "additions": 256,
            "deletions": 0,
            "changes": 256,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2Fes2015_linker_plugin_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2Fes2015_linker_plugin_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fbabel%2Ftest%2Fes2015_linker_plugin_spec.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,256 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as o from '@angular/compiler/src/output/output_ast';\n+import {NodePath, PluginObj, transformSync} from '@babel/core';\n+import generate from '@babel/generator';\n+import * as t from '@babel/types';\n+\n+import {FileLinker} from '../../../linker';\n+import {PartialDirectiveLinkerVersion1} from '../../src/file_linker/partial_linkers/partial_directive_linker_1';\n+import {createEs2015LinkerPlugin} from '../src/es2015_linker_plugin';\n+\n+describe('createEs2015LinkerPlugin()', () => {\n+  it('should return a Babel plugin visitor that handles Program (enter/exit) and CallExpression nodes',\n+     () => {\n+       const plugin = createEs2015LinkerPlugin();\n+       expect(plugin.visitor).toEqual({\n+         Program: {\n+           enter: jasmine.any(Function),\n+           exit: jasmine.any(Function),\n+         },\n+         CallExpression: jasmine.any(Function),\n+       });\n+     });\n+\n+  it('should return a Babel plugin that calls FileLinker.isPartialDeclaration() on each call expression',\n+     () => {\n+       const isPartialDeclarationSpy = spyOn(FileLinker.prototype, 'isPartialDeclaration');\n+\n+       transformSync(\n+           [\n+             'var core;', `fn1()`, 'fn2({prop: () => fn3({})});', `x.method(() => fn4());`,\n+             'spread(...x);'\n+           ].join('\\n'),\n+           {\n+             plugins: [createEs2015LinkerPlugin()],\n+             filename: '/test.js',\n+             parserOpts: {sourceType: 'unambiguous'},\n+           });\n+       expect(isPartialDeclarationSpy.calls.allArgs()).toEqual([\n+         ['fn1'],\n+         ['fn2'],\n+         ['fn3'],\n+         ['method'],\n+         ['fn4'],\n+         ['spread'],\n+       ]);\n+     });\n+\n+  it('should return a Babel plugin that calls FileLinker.linkPartialDeclaration() on each matching declaration',\n+     () => {\n+       const linkSpy = spyOn(FileLinker.prototype, 'linkPartialDeclaration')\n+                           .and.returnValue(t.identifier('REPLACEMENT'));\n+\n+       transformSync(\n+           [\n+             'var core;',\n+             `$ngDeclareDirective({version: 1, ngImport: core, x: 1});`,\n+             `$ngDeclareComponent({version: 1, ngImport: core, foo: () => $ngDeclareDirective({version: 1, ngImport: core, x: 2})});`,\n+             `x.qux(() => $ngDeclareDirective({version: 1, ngImport: core, x: 3}));`,\n+             'spread(...x);',\n+           ].join('\\n'),\n+           {\n+             plugins: [createEs2015LinkerPlugin()],\n+             filename: '/test.js',\n+             parserOpts: {sourceType: 'unambiguous'},\n+           });\n+\n+       expect(humanizeLinkerCalls(linkSpy.calls)).toEqual([\n+         ['$ngDeclareDirective', '{version:1,ngImport:core,x:1}'],\n+         [\n+           '$ngDeclareComponent',\n+           '{version:1,ngImport:core,foo:()=>$ngDeclareDirective({version:1,ngImport:core,x:2})}'\n+         ],\n+         // Note we do not process `x:2` declaration since it is nested within another declaration\n+         ['$ngDeclareDirective', '{version:1,ngImport:core,x:3}']\n+       ]);\n+     });\n+\n+  it('should return a Babel plugin that replaces call expressions with the return value from FileLinker.linkPartialDeclaration()',\n+     () => {\n+       let replaceCount = 0;\n+       spyOn(FileLinker.prototype, 'linkPartialDeclaration')\n+           .and.callFake(() => t.identifier('REPLACEMENT_' + ++replaceCount));\n+       const result = transformSync(\n+           [\n+             'var core;',\n+             '$ngDeclareDirective({version: 1, ngImport: core});',\n+             '$ngDeclareDirective({version: 1, ngImport: core, foo: () => bar({})});',\n+             'x.qux();',\n+             'spread(...x);',\n+           ].join('\\n'),\n+           {\n+             plugins: [createEs2015LinkerPlugin()],\n+             filename: '/test.js',\n+             parserOpts: {sourceType: 'unambiguous'},\n+             generatorOpts: {compact: true},\n+           });\n+       expect(result!.code).toEqual('var core;REPLACEMENT_1;REPLACEMENT_2;x.qux();spread(...x);');\n+     });\n+\n+  it('should return a Babel plugin that adds shared statements after any imports', () => {\n+    spyOnLinkPartialDeclarationWithConstants(o.literal('REPLACEMENT'));\n+    const result = transformSync(\n+        [\n+          'import * as core from \\'some-module\\';',\n+          'import {id} from \\'other-module\\';',\n+          `$ngDeclareDirective({version: 1, ngImport: core})`,\n+          `$ngDeclareDirective({version: 1, ngImport: core})`,\n+          `$ngDeclareDirective({version: 1, ngImport: core})`,\n+        ].join('\\n'),\n+        {\n+          plugins: [createEs2015LinkerPlugin()],\n+          filename: '/test.js',\n+          parserOpts: {sourceType: 'unambiguous'},\n+          generatorOpts: {compact: true},\n+        });\n+    expect(result!.code)\n+        .toEqual(\n+            'import*as core from\\'some-module\\';import{id}from\\'other-module\\';const _c0=[1];const _c1=[2];const _c2=[3];\"REPLACEMENT\";\"REPLACEMENT\";\"REPLACEMENT\";');\n+  });\n+\n+  it('should return a Babel plugin that adds shared statements at the start of the program if it is an ECMAScript Module and there are no imports',\n+     () => {\n+       spyOnLinkPartialDeclarationWithConstants(o.literal('REPLACEMENT'));\n+       const result = transformSync(\n+           [\n+             'var core;',\n+             `$ngDeclareDirective({version: 1, ngImport: core})`,\n+             `$ngDeclareDirective({version: 1, ngImport: core})`,\n+             `$ngDeclareDirective({version: 1, ngImport: core})`,\n+           ].join('\\n'),\n+           {\n+             plugins: [createEs2015LinkerPlugin()],\n+             filename: '/test.js',\n+             // We declare the file as a module because this cannot be inferred from the source\n+             parserOpts: {sourceType: 'module'},\n+             generatorOpts: {compact: true},\n+           });\n+       expect(result!.code)\n+           .toEqual(\n+               'const _c0=[1];const _c1=[2];const _c2=[3];var core;\"REPLACEMENT\";\"REPLACEMENT\";\"REPLACEMENT\";');\n+     });\n+\n+  it('should return a Babel plugin that adds shared statements at the start of the function body if the ngImport is from a function parameter',\n+     () => {\n+       spyOnLinkPartialDeclarationWithConstants(o.literal('REPLACEMENT'));\n+       const result = transformSync(\n+           [\n+             'function run(core) {', `  $ngDeclareDirective({version: 1, ngImport: core})`,\n+             `  $ngDeclareDirective({version: 1, ngImport: core})`,\n+             `  $ngDeclareDirective({version: 1, ngImport: core})`, '}'\n+           ].join('\\n'),\n+           {\n+             plugins: [createEs2015LinkerPlugin()],\n+             filename: '/test.js',\n+             parserOpts: {sourceType: 'unambiguous'},\n+             generatorOpts: {compact: true},\n+           });\n+       expect(result!.code)\n+           .toEqual(\n+               'function run(core){const _c0=[1];const _c1=[2];const _c2=[3];\"REPLACEMENT\";\"REPLACEMENT\";\"REPLACEMENT\";}');\n+     });\n+\n+  it('should return a Babel plugin that adds shared statements into an IIFE if no scope could not be derived for the ngImport',\n+     () => {\n+       spyOnLinkPartialDeclarationWithConstants(o.literal('REPLACEMENT'));\n+       const result = transformSync(\n+           [\n+             'function run() {',\n+             `  $ngDeclareDirective({version: 1, ngImport: core})`,\n+             `  $ngDeclareDirective({version: 1, ngImport: core})`,\n+             `  $ngDeclareDirective({version: 1, ngImport: core})`,\n+             '}',\n+           ].join('\\n'),\n+           {\n+             plugins: [createEs2015LinkerPlugin()],\n+             filename: '/test.js',\n+             parserOpts: {sourceType: 'unambiguous'},\n+             generatorOpts: {compact: true},\n+           });\n+       expect(result!.code).toEqual([\n+         `function run(){`,\n+         `(function(){const _c0=[1];return\"REPLACEMENT\";})();`,\n+         `(function(){const _c0=[2];return\"REPLACEMENT\";})();`,\n+         `(function(){const _c0=[3];return\"REPLACEMENT\";})();`,\n+         `}`,\n+       ].join(''));\n+     });\n+\n+  it('should still execute other plugins that match AST nodes inside the result of the replacement',\n+     () => {\n+       spyOnLinkPartialDeclarationWithConstants(o.fn([], [], null, null, 'FOO'));\n+       const result = transformSync(\n+           [\n+             `$ngDeclareDirective({version: 1, ngImport: core}); FOO;`,\n+           ].join('\\n'),\n+           {\n+             plugins: [\n+               createEs2015LinkerPlugin(),\n+               createIdentifierMapperPlugin('FOO', 'BAR'),\n+               createIdentifierMapperPlugin('_c0', 'x1'),\n+             ],\n+             filename: '/test.js',\n+             parserOpts: {sourceType: 'module'},\n+             generatorOpts: {compact: true},\n+           });\n+       expect(result!.code).toEqual([\n+         `(function(){const x1=[1];return function BAR(){};})();BAR;`,\n+       ].join(''));\n+     });\n+});\n+\n+/**\n+ * Convert the arguments of the spied-on `calls` into a human readable array.\n+ */\n+function humanizeLinkerCalls(\n+    calls: jasmine.Calls<typeof FileLinker.prototype.linkPartialDeclaration>) {\n+  return calls.all().map(({args: [fn, args]}) => [fn, generate(args[0], {compact: true}).code]);\n+}\n+\n+/**\n+ * Spy on the `PartialDirectiveLinkerVersion1.linkPartialDeclaration()` method, triggering\n+ * shared constants to be created.\n+ */\n+function spyOnLinkPartialDeclarationWithConstants(replacement: o.Expression) {\n+  let callCount = 0;\n+  spyOn(PartialDirectiveLinkerVersion1.prototype, 'linkPartialDeclaration')\n+      .and.callFake(((sourceUrl, code, constantPool) => {\n+                      const constArray = o.literalArr([o.literal(++callCount)]);\n+                      // We have to add the constant twice or it will not create a shared statement\n+                      constantPool.getConstLiteral(constArray);\n+                      constantPool.getConstLiteral(constArray);\n+                      return replacement;\n+                    }) as typeof PartialDirectiveLinkerVersion1.prototype.linkPartialDeclaration);\n+}\n+\n+/**\n+ * A simple Babel plugin that will replace all identifiers that match `<src>` with identifiers\n+ * called `<dest>`.\n+ */\n+function createIdentifierMapperPlugin(src: string, dest: string): PluginObj {\n+  return {\n+    visitor: {\n+      Identifier(path: NodePath<t.Identifier>) {\n+        if (path.node.name === src) {\n+          path.replaceWith(t.identifier(dest));\n+        }\n+      }\n+    },\n+  };\n+}"
        },
        {
            "sha": "96256b7b43851347bd1b5f425904cdce78dd6fed",
            "filename": "packages/compiler-cli/linker/index.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Findex.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -5,3 +5,10 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n+export {AstHost, Range} from './src/ast/ast_host';\n+export {assert} from './src/ast/utils';\n+export {FatalLinkerError, isFatalLinkerError} from './src/fatal_linker_error';\n+export {DeclarationScope} from './src/file_linker/declaration_scope';\n+export {FileLinker} from './src/file_linker/file_linker';\n+export {LinkerEnvironment} from './src/file_linker/linker_environment';\n+export {LinkerOptions} from './src/file_linker/linker_options';"
        },
        {
            "sha": "2275c61aef8149e48ddcf3f508c6d80b821c8e4b",
            "filename": "packages/compiler-cli/linker/src/ast/ast_value.ts",
            "status": "added",
            "additions": 240,
            "deletions": 0,
            "changes": 240,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fast_value.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fast_value.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fast_value.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,240 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as o from '@angular/compiler';\n+import {FatalLinkerError} from '../fatal_linker_error';\n+import {AstHost, Range} from './ast_host';\n+\n+/**\n+ * This helper class wraps an object expression along with an `AstHost` object, exposing helper\n+ * methods that make it easier to extract the properties of the object.\n+ */\n+export class AstObject<TExpression> {\n+  /**\n+   * Create a new `AstObject` from the given `expression` and `host`.\n+   */\n+  static parse<TExpression>(expression: TExpression, host: AstHost<TExpression>):\n+      AstObject<TExpression> {\n+    const obj = host.parseObjectLiteral(expression);\n+    return new AstObject<TExpression>(expression, obj, host);\n+  }\n+\n+  private constructor(\n+      readonly expression: TExpression, private obj: Map<string, TExpression>,\n+      private host: AstHost<TExpression>) {}\n+\n+  /**\n+   * Returns true if the object has a property called `propertyName`.\n+   */\n+  has(propertyName: string): boolean {\n+    return this.obj.has(propertyName);\n+  }\n+\n+  /**\n+   * Returns the number value of the property called `propertyName`.\n+   *\n+   * Throws an error if there is no such property or the property is not a number.\n+   */\n+  getNumber(propertyName: string): number {\n+    return this.host.parseNumericLiteral(this.getRequiredProperty(propertyName));\n+  }\n+\n+  /**\n+   * Returns the string value of the property called `propertyName`.\n+   *\n+   * Throws an error if there is no such property or the property is not a string.\n+   */\n+  getString(propertyName: string): string {\n+    return this.host.parseStringLiteral(this.getRequiredProperty(propertyName));\n+  }\n+\n+  /**\n+   * Returns the boolean value of the property called `propertyName`.\n+   *\n+   * Throws an error if there is no such property or the property is not a boolean.\n+   */\n+  getBoolean(propertyName: string): boolean {\n+    return this.host.parseBooleanLiteral(this.getRequiredProperty(propertyName));\n+  }\n+\n+  /**\n+   * Returns the nested `AstObject` parsed from the property called `propertyName`.\n+   *\n+   * Throws an error if there is no such property or the property is not an object.\n+   */\n+  getObject(propertyName: string): AstObject<TExpression> {\n+    const expr = this.getRequiredProperty(propertyName);\n+    const obj = this.host.parseObjectLiteral(expr);\n+    return new AstObject(expr, obj, this.host);\n+  }\n+\n+  /**\n+   * Returns an array of `AstValue` objects parsed from the property called `propertyName`.\n+   *\n+   * Throws an error if there is no such property or the property is not an array.\n+   */\n+  getArray(propertyName: string): AstValue<TExpression>[] {\n+    const arr = this.host.parseArrayLiteral(this.getRequiredProperty(propertyName));\n+    return arr.map(entry => new AstValue(entry, this.host));\n+  }\n+\n+  /**\n+   * Returns a `WrappedNodeExpr` object that wraps the expression at the property called\n+   * `propertyName`.\n+   *\n+   * Throws an error if there is no such property.\n+   */\n+  getOpaque(propertyName: string): o.WrappedNodeExpr<TExpression> {\n+    return new o.WrappedNodeExpr(this.getRequiredProperty(propertyName));\n+  }\n+\n+  /**\n+   * Returns the raw `TExpression` value of the property called `propertyName`.\n+   *\n+   * Throws an error if there is no such property.\n+   */\n+  getNode(propertyName: string): TExpression {\n+    return this.getRequiredProperty(propertyName);\n+  }\n+\n+  /**\n+   * Returns an `AstValue` that wraps the value of the property called `propertyName`.\n+   *\n+   * Throws an error if there is no such property.\n+   */\n+  getValue(propertyName: string): AstValue<TExpression> {\n+    return new AstValue(this.getRequiredProperty(propertyName), this.host);\n+  }\n+\n+  /**\n+   * Converts the AstObject to a raw JavaScript object, mapping each property value (as an\n+   * `AstValue`) to the generic type (`T`) via the `mapper` function.\n+   */\n+  toLiteral<T>(mapper: (value: AstValue<TExpression>) => T): {[key: string]: T} {\n+    const result: {[key: string]: T} = {};\n+    for (const [key, expression] of this.obj) {\n+      result[key] = mapper(new AstValue(expression, this.host));\n+    }\n+    return result;\n+  }\n+\n+  private getRequiredProperty(propertyName: string): TExpression {\n+    if (!this.obj.has(propertyName)) {\n+      throw new FatalLinkerError(\n+          this.expression, `Expected property '${propertyName}' to be present.`);\n+    }\n+    return this.obj.get(propertyName)!;\n+  }\n+}\n+\n+/**\n+ * This helper class wraps an `expression`, exposing methods that use the `host` to give\n+ * access to the underlying value of the wrapped expression.\n+ */\n+export class AstValue<TExpression> {\n+  constructor(private expression: TExpression, private host: AstHost<TExpression>) {}\n+\n+  /**\n+   * Is this value a number?\n+   */\n+  isNumber(): boolean {\n+    return this.host.isNumericLiteral(this.expression);\n+  }\n+\n+  /**\n+   * Parse the number from this value, or error if it is not a number.\n+   */\n+  getNumber(): number {\n+    return this.host.parseNumericLiteral(this.expression);\n+  }\n+\n+  /**\n+   * Is this value a string?\n+   */\n+  isString(): boolean {\n+    return this.host.isStringLiteral(this.expression);\n+  }\n+\n+  /**\n+   * Parse the string from this value, or error if it is not a string.\n+   */\n+  getString(): string {\n+    return this.host.parseStringLiteral(this.expression);\n+  }\n+\n+  /**\n+   * Is this value a boolean?\n+   */\n+  isBoolean(): boolean {\n+    return this.host.isBooleanLiteral(this.expression);\n+  }\n+\n+  /**\n+   * Parse the boolean from this value, or error if it is not a boolean.\n+   */\n+  getBoolean(): boolean {\n+    return this.host.parseBooleanLiteral(this.expression);\n+  }\n+\n+  /**\n+   * Is this value an object literal?\n+   */\n+  isObject(): boolean {\n+    return this.host.isObjectLiteral(this.expression);\n+  }\n+\n+  /**\n+   * Parse this value into an `AstObject`, or error if it is not an object literal.\n+   */\n+  getObject(): AstObject<TExpression> {\n+    return AstObject.parse(this.expression, this.host);\n+  }\n+\n+  /**\n+   * Is this value an array literal?\n+   */\n+  isArray(): boolean {\n+    return this.host.isArrayLiteral(this.expression);\n+  }\n+\n+  /**\n+   * Parse this value into an array of `AstValue` objects, or error if it is not an array literal.\n+   */\n+  getArray(): AstValue<TExpression>[] {\n+    const arr = this.host.parseArrayLiteral(this.expression);\n+    return arr.map(entry => new AstValue(entry, this.host));\n+  }\n+\n+  /**\n+   * Is this value a function expression?\n+   */\n+  isFunction(): boolean {\n+    return this.host.isFunctionExpression(this.expression);\n+  }\n+\n+  /**\n+   * Extract the return value as an `AstValue` from this value as a function expression, or error if\n+   * it is not a function expression.\n+   */\n+  getFunctionReturnValue(): AstValue<TExpression> {\n+    return new AstValue(this.host.parseReturnValue(this.expression), this.host);\n+  }\n+\n+  /**\n+   * Return the `TExpression` of this value wrapped in a `WrappedNodeExpr`.\n+   */\n+  getOpaque(): o.WrappedNodeExpr<TExpression> {\n+    return new o.WrappedNodeExpr(this.expression);\n+  }\n+\n+  /**\n+   * Get the range of the location of this value in the original source.\n+   */\n+  getRange(): Range {\n+    return this.host.getRange(this.expression);\n+  }\n+}"
        },
        {
            "sha": "49bf52f3f35762460da9fd320c3d513072afa142",
            "filename": "packages/compiler-cli/linker/src/fatal_linker_error.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffatal_linker_error.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffatal_linker_error.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffatal_linker_error.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -10,7 +10,7 @@\n  * An unrecoverable error during linking.\n  */\n export class FatalLinkerError extends Error {\n-  private readonly type = 'FatalLinkerError';\n+  readonly type = 'FatalLinkerError';\n \n   /**\n    * Create a new FatalLinkerError."
        },
        {
            "sha": "a543bc3b874d3d58c8c58226ef87c48b4d58a1a1",
            "filename": "packages/compiler-cli/linker/src/file_linker/declaration_scope.ts",
            "status": "added",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fdeclaration_scope.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fdeclaration_scope.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fdeclaration_scope.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,45 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/**\n+ * This interface represents the lexical scope of a partial declaration in the source code.\n+ *\n+ * For example, if you had the following code:\n+ *\n+ * ```\n+ * function foo() {\n+ *   function bar () {\n+ *     $ngDeclareDirective({...});\n+ *   }\n+ * }\n+ * ```\n+ *\n+ * The `DeclarationScope` of the `$ngDeclareDirective()` call is the body of the `bar()` function.\n+ *\n+ * The `FileLinker` uses this object to identify the lexical scope of any constant statements that\n+ * might be generated by the linking process (i.e. where the `ConstantPool` lives for a set of\n+ * partial linkers).\n+ */\n+export interface DeclarationScope<TSharedConstantScope, TExpression> {\n+  /**\n+   * Get a `TSharedConstantScope` object that can be used to reference the lexical scope where any\n+   * shared constant statements would be inserted.\n+   *\n+   * This object is generic because different AST implementations will need different\n+   * `TConstantScope` types to be able to insert shared constant statements. For example in Babel\n+   * this would be a `NodePath` object; in TS it would just be a `Node` object.\n+   *\n+   * If it is not possible to find such a shared scope, then constant statements will be wrapped up\n+   * with their generated linked definition expression, in the form of an IIFE.\n+   *\n+   * @param expression the expression that points to the Angular core framework import.\n+   * @returns a reference to a reference object for where the shared constant statements will be\n+   *     inserted, or `null` if it is not possible to have a shared scope.\n+   */\n+  getConstantScopeRef(expression: TExpression): TSharedConstantScope|null;\n+}"
        },
        {
            "sha": "75f47067cef4838562a164d33962ebee4503b6f9",
            "filename": "packages/compiler-cli/linker/src/file_linker/emit_scopes/emit_scope.ts",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Femit_scopes%2Femit_scope.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Femit_scopes%2Femit_scope.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Femit_scopes%2Femit_scope.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,48 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {ConstantPool} from '@angular/compiler';\n+import * as o from '@angular/compiler/src/output/output_ast';\n+import {LinkerImportGenerator} from '../../linker_import_generator';\n+import {LinkerEnvironment} from '../linker_environment';\n+\n+/**\n+ * This class represents (from the point of view of the `FileLinker`) the scope in which\n+ * statements and expressions related to a linked partial declaration will be emitted.\n+ *\n+ * It holds a copy of a `ConstantPool` that is used to capture any constant statements that need to\n+ * be emitted in this context.\n+ *\n+ * This implementation will emit the definition and the constant statements separately.\n+ */\n+export class EmitScope<TStatement, TExpression> {\n+  readonly constantPool = new ConstantPool();\n+\n+  constructor(\n+      protected readonly ngImport: TExpression,\n+      protected readonly linkerEnvironment: LinkerEnvironment<TStatement, TExpression>) {}\n+\n+  /**\n+   * Translate the given Output AST definition expression into a generic `TExpression`.\n+   *\n+   * Use a `LinkerImportGenerator` to handle any imports in the definition.\n+   */\n+  translateDefinition(definition: o.Expression): TExpression {\n+    return this.linkerEnvironment.translator.translateExpression(\n+        definition, new LinkerImportGenerator(this.ngImport));\n+  }\n+\n+  /**\n+   * Return any constant statements that are shared between all uses of this `EmitScope`.\n+   */\n+  getConstantStatements(): TStatement[] {\n+    const {translator} = this.linkerEnvironment;\n+    const importGenerator = new LinkerImportGenerator(this.ngImport);\n+    return this.constantPool.statements.map(\n+        statement => translator.translateStatement(statement, importGenerator));\n+  }\n+}"
        },
        {
            "sha": "18d0982d2ddabd80f3de2f7b77f0a6ccdef57e4e",
            "filename": "packages/compiler-cli/linker/src/file_linker/emit_scopes/iife_emit_scope.ts",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Femit_scopes%2Fiife_emit_scope.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Femit_scopes%2Fiife_emit_scope.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Femit_scopes%2Fiife_emit_scope.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,40 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as o from '@angular/compiler/src/output/output_ast';\n+import {EmitScope} from './emit_scope';\n+\n+/**\n+ * This class is a specialization of the `EmitScope` class that is designed for the situation where\n+ * there is no clear shared scope for constant statements. In this case they are bundled with the\n+ * translated definition inside an IIFE.\n+ */\n+export class IifeEmitScope<TStatement, TExpression> extends EmitScope<TStatement, TExpression> {\n+  /**\n+   * Translate the given Output AST definition expression into a generic `TExpression`.\n+   *\n+   * Wraps the output from `EmitScope.translateDefinition()` and `EmitScope.getConstantStatements()`\n+   * in an IIFE.\n+   */\n+  translateDefinition(definition: o.Expression): TExpression {\n+    const {factory} = this.linkerEnvironment;\n+    const constantStatements = super.getConstantStatements();\n+\n+    const returnStatement = factory.createReturnStatement(super.translateDefinition(definition));\n+    const body = factory.createBlock([...constantStatements, returnStatement]);\n+    const fn = factory.createFunctionExpression(/* name */ null, /* args */[], body);\n+    return factory.createCallExpression(fn, /* args */[], /* pure */ false);\n+  }\n+\n+  /**\n+   * It is not valid to call this method, since there will be no shared constant statements - they\n+   * are already emitted in the IIFE alongside the translated definition.\n+   */\n+  getConstantStatements(): TStatement[] {\n+    throw new Error('BUG - IifeEmitScope should not expose any constant statements');\n+  }\n+}"
        },
        {
            "sha": "2b541fa372168c0252c187a453de539927f7d5a0",
            "filename": "packages/compiler-cli/linker/src/file_linker/file_linker.ts",
            "status": "added",
            "additions": 94,
            "deletions": 0,
            "changes": 94,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Ffile_linker.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Ffile_linker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Ffile_linker.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,94 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {AstObject} from '../ast/ast_value';\n+import {DeclarationScope} from './declaration_scope';\n+import {EmitScope} from './emit_scopes/emit_scope';\n+import {IifeEmitScope} from './emit_scopes/iife_emit_scope';\n+import {LinkerEnvironment} from './linker_environment';\n+import {PartialLinkerSelector} from './partial_linkers/partial_linker_selector';\n+\n+export const NO_STATEMENTS: Readonly<any[]> = [] as const;\n+\n+/**\n+ * This class is responsible for linking all the partial declarations found in a single file.\n+ */\n+export class FileLinker<TConstantScope, TStatement, TExpression> {\n+  private linkerSelector = new PartialLinkerSelector<TStatement, TExpression>();\n+  private emitScopes = new Map<TConstantScope, EmitScope<TStatement, TExpression>>();\n+\n+  constructor(\n+      private linkerEnvironment: LinkerEnvironment<TStatement, TExpression>,\n+      private sourceUrl: string, readonly code: string) {}\n+\n+  /**\n+   * Return true if the given callee name matches a partial declaration that can be linked.\n+   */\n+  isPartialDeclaration(calleeName: string): boolean {\n+    return this.linkerSelector.supportsDeclaration(calleeName);\n+  }\n+\n+  /**\n+   * Link the metadata extracted from the args of a call to a partial declaration function.\n+   *\n+   * The `declarationScope` is used to determine the scope and strategy of emission of the linked\n+   * definition and any shared constant statements.\n+   *\n+   * @param declarationFn the name of the function used to declare the partial declaration - e.g.\n+   *     `$ngDeclareDirective`.\n+   * @param args the arguments passed to the declaration function.\n+   * @param declarationScope the scope that contains this call to the declaration function.\n+   */\n+  linkPartialDeclaration(\n+      declarationFn: string, args: TExpression[],\n+      declarationScope: DeclarationScope<TConstantScope, TExpression>): TExpression {\n+    if (args.length !== 1) {\n+      throw new Error(\n+          `Invalid function call: It should have only a single object literal argument, but contained ${\n+              args.length}.`);\n+    }\n+\n+    const metaObj = AstObject.parse(args[0], this.linkerEnvironment.host);\n+    const ngImport = metaObj.getNode('ngImport');\n+    const emitScope = this.getEmitScope(ngImport, declarationScope);\n+\n+    const version = metaObj.getNumber('version');\n+    const linker = this.linkerSelector.getLinker(declarationFn, version);\n+    const definition =\n+        linker.linkPartialDeclaration(this.sourceUrl, this.code, emitScope.constantPool, metaObj);\n+\n+    return emitScope.translateDefinition(definition);\n+  }\n+\n+  /**\n+   * Return all the shared constant statements and their associated constant scope references, so\n+   * that they can be inserted into the source code.\n+   */\n+  getConstantStatements(): {constantScope: TConstantScope, statements: TStatement[]}[] {\n+    const results: {constantScope: TConstantScope, statements: TStatement[]}[] = [];\n+    for (const [constantScope, emitScope] of this.emitScopes.entries()) {\n+      const statements = emitScope.getConstantStatements();\n+      results.push({constantScope, statements});\n+    }\n+    return results;\n+  }\n+\n+  private getEmitScope(\n+      ngImport: TExpression, declarationScope: DeclarationScope<TConstantScope, TExpression>):\n+      EmitScope<TStatement, TExpression> {\n+    const constantScope = declarationScope.getConstantScopeRef(ngImport);\n+    if (constantScope === null) {\n+      // There is no constant scope so we will emit extra statements into the definition IIFE.\n+      return new IifeEmitScope(ngImport, this.linkerEnvironment);\n+    }\n+\n+    if (!this.emitScopes.has(constantScope)) {\n+      this.emitScopes.set(constantScope, new EmitScope(ngImport, this.linkerEnvironment));\n+    }\n+    return this.emitScopes.get(constantScope)!;\n+  }\n+}"
        },
        {
            "sha": "c8024dc8a1325d39cb9b98f0cc3ee6d249a1157d",
            "filename": "packages/compiler-cli/linker/src/file_linker/linker_environment.ts",
            "status": "added",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Flinker_environment.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Flinker_environment.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Flinker_environment.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,25 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {AstFactory} from '@angular/compiler-cli/src/ngtsc/translator';\n+\n+import {AstHost} from '../ast/ast_host';\n+import {DEFAULT_LINKER_OPTIONS, LinkerOptions} from './linker_options';\n+import {Translator} from './translator';\n+\n+export class LinkerEnvironment<TStatement, TExpression> {\n+  readonly translator = new Translator<TStatement, TExpression>(this.factory);\n+  private constructor(\n+      readonly host: AstHost<TExpression>, readonly factory: AstFactory<TStatement, TExpression>,\n+      readonly options: LinkerOptions) {}\n+\n+  static create<TStatement, TExpression>(\n+      host: AstHost<TExpression>, factory: AstFactory<TStatement, TExpression>,\n+      options: Partial<LinkerOptions>): LinkerEnvironment<TStatement, TExpression> {\n+    return new LinkerEnvironment(host, factory, {...DEFAULT_LINKER_OPTIONS, ...options});\n+  }\n+}"
        },
        {
            "sha": "d76de5b57760e1451a0aeb2b44f3b0cd71616b93",
            "filename": "packages/compiler-cli/linker/src/file_linker/linker_options.ts",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Flinker_options.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Flinker_options.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Flinker_options.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,31 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/**\n+ * Options to configure the linking behavior.\n+ */\n+export interface LinkerOptions {\n+  /**\n+   * Whether to generate legacy i18n message ids.\n+   * The default is `true`.\n+   */\n+  enableI18nLegacyMessageIdFormat: boolean;\n+  /**\n+   * Whether to convert all line-endings in ICU expressions to `\\n` characters.\n+   * The default is `false`.\n+   */\n+  i18nNormalizeLineEndingsInICUs: boolean;\n+}\n+\n+/**\n+ * The default linker options to use if properties are not provided.\n+ */\n+export const DEFAULT_LINKER_OPTIONS: LinkerOptions = {\n+  enableI18nLegacyMessageIdFormat: true,\n+  i18nNormalizeLineEndingsInICUs: false,\n+};"
        },
        {
            "sha": "1c7bcde2428f97b4fa9559f67b8368cc7e1fc917",
            "filename": "packages/compiler-cli/linker/src/file_linker/partial_linkers/partial_component_linker_1.ts",
            "status": "added",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_component_linker_1.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_component_linker_1.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_component_linker_1.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,25 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {ConstantPool} from '@angular/compiler';\n+import * as o from '@angular/compiler/src/output/output_ast';\n+\n+import {AstObject} from '../../ast/ast_value';\n+\n+import {PartialLinker} from './partial_linker';\n+\n+/**\n+ * A `PartialLinker` that is designed to process `$ngDeclareComponent()` call expressions.\n+ */\n+export class PartialComponentLinkerVersion1<TStatement, TExpression> implements\n+    PartialLinker<TStatement, TExpression> {\n+  linkPartialDeclaration(\n+      sourceUrl: string, code: string, constantPool: ConstantPool,\n+      metaObj: AstObject<TExpression>): o.Expression {\n+    throw new Error('Not implemented.');\n+  }\n+}"
        },
        {
            "sha": "bd3e8b80a9d003cc7f295bda638d42d61572975b",
            "filename": "packages/compiler-cli/linker/src/file_linker/partial_linkers/partial_directive_linker_1.ts",
            "status": "added",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_directive_linker_1.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_directive_linker_1.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_directive_linker_1.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,25 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {ConstantPool} from '@angular/compiler';\n+import * as o from '@angular/compiler/src/output/output_ast';\n+\n+import {AstObject} from '../../ast/ast_value';\n+\n+import {PartialLinker} from './partial_linker';\n+\n+/**\n+ * A `PartialLinker` that is designed to process `$ngDeclareDirective()` call expressions.\n+ */\n+export class PartialDirectiveLinkerVersion1<TStatement, TExpression> implements\n+    PartialLinker<TStatement, TExpression> {\n+  linkPartialDeclaration(\n+      sourceUrl: string, code: string, constantPool: ConstantPool,\n+      metaObj: AstObject<TExpression>): o.Expression {\n+    throw new Error('Not implemented.');\n+  }\n+}"
        },
        {
            "sha": "cc5031f165f5c78c063ba02c26717c5cddbd6fba",
            "filename": "packages/compiler-cli/linker/src/file_linker/partial_linkers/partial_linker.ts",
            "status": "added",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_linker.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_linker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_linker.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,22 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {ConstantPool} from '@angular/compiler';\n+import * as o from '@angular/compiler/src/output/output_ast';\n+import {AstObject} from '../../ast/ast_value';\n+\n+/**\n+ * An interface for classes that can link partial declarations into full definitions.\n+ */\n+export interface PartialLinker<TStatement, TExpression> {\n+  /**\n+   * Link the partial declaration `metaObj` information to generate a full definition expression.\n+   */\n+  linkPartialDeclaration(\n+      sourceUrl: string, code: string, constantPool: ConstantPool,\n+      metaObj: AstObject<TExpression>): o.Expression;\n+}"
        },
        {
            "sha": "ba6ffe6aa2f3aec13bb4a3e647667d5f6d294875",
            "filename": "packages/compiler-cli/linker/src/file_linker/partial_linkers/partial_linker_selector.ts",
            "status": "added",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_linker_selector.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_linker_selector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_linker_selector.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,44 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {PartialComponentLinkerVersion1} from './partial_component_linker_1';\n+import {PartialDirectiveLinkerVersion1} from './partial_directive_linker_1';\n+import {PartialLinker} from './partial_linker';\n+\n+export class PartialLinkerSelector<TStatement, TExpression> {\n+  private linkers: Record<string, Record<number, PartialLinker<TStatement, TExpression>>> = {\n+    '$ngDeclareDirective': {\n+      1: new PartialDirectiveLinkerVersion1(),\n+    },\n+    '$ngDeclareComponent': {\n+      1: new PartialComponentLinkerVersion1(),\n+    },\n+  };\n+\n+  /**\n+   * Returns true if there are `PartialLinker` classes that can handle functions with this name.\n+   */\n+  supportsDeclaration(functionName: string): boolean {\n+    return this.linkers[functionName] !== undefined;\n+  }\n+\n+  /**\n+   * Returns the `PartialLinker` that can handle functions with the given name and version.\n+   * Throws an error if there is none.\n+   */\n+  getLinker(functionName: string, version: number): PartialLinker<TStatement, TExpression> {\n+    const versions = this.linkers[functionName];\n+    if (versions === undefined) {\n+      throw new Error(`Unknown partial declaration function ${functionName}.`);\n+    }\n+    const linker = versions[version];\n+    if (linker === undefined) {\n+      throw new Error(`Unsupported partial declaration version ${version} for ${functionName}.`);\n+    }\n+    return linker;\n+  }\n+}"
        },
        {
            "sha": "7e55f297dcbb16f373f2cf7e430c095a716f5f53",
            "filename": "packages/compiler-cli/linker/src/file_linker/translator.ts",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Ftranslator.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Ftranslator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Ftranslator.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,39 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as o from '@angular/compiler';\n+import {AstFactory, Context, ExpressionTranslatorVisitor, ImportGenerator, TranslatorOptions} from '@angular/compiler-cli/src/ngtsc/translator';\n+\n+/**\n+ * Generic translator helper class, which exposes methods for translating expressions and\n+ * statements.\n+ */\n+export class Translator<TStatement, TExpression> {\n+  constructor(private factory: AstFactory<TStatement, TExpression>) {}\n+\n+  /**\n+   * Translate the given output AST in the context of an expression.\n+   */\n+  translateExpression(\n+      expression: o.Expression, imports: ImportGenerator<TExpression>,\n+      options: TranslatorOptions<TExpression> = {}): TExpression {\n+    return expression.visitExpression(\n+        new ExpressionTranslatorVisitor<TStatement, TExpression>(this.factory, imports, options),\n+        new Context(false));\n+  }\n+\n+  /**\n+   * Translate the given output AST in the context of a statement.\n+   */\n+  translateStatement(\n+      statement: o.Statement, imports: ImportGenerator<TExpression>,\n+      options: TranslatorOptions<TExpression> = {}): TStatement {\n+    return statement.visitStatement(\n+        new ExpressionTranslatorVisitor<TStatement, TExpression>(this.factory, imports, options),\n+        new Context(true));\n+  }\n+}"
        },
        {
            "sha": "d3c4b923250b5b80772e27b32080d6af932099d4",
            "filename": "packages/compiler-cli/linker/src/linker_import_generator.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Flinker_import_generator.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Flinker_import_generator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Flinker_import_generator.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -5,8 +5,8 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-\n import {ImportGenerator, NamedImport} from '../../src/ngtsc/translator';\n+import {FatalLinkerError} from './fatal_linker_error';\n \n /**\n  * A class that is used to generate imports when translating from Angular Output AST to an AST to\n@@ -31,7 +31,8 @@ export class LinkerImportGenerator<TExpression> implements ImportGenerator<TExpr\n \n   private assertModuleName(moduleName: string): void {\n     if (moduleName !== '@angular/core') {\n-      throw new Error(`Unable to import from anything other than '@angular/core'`);\n+      throw new FatalLinkerError(\n+          this.ngImport, `Unable to import from anything other than '@angular/core'`);\n     }\n   }\n }"
        },
        {
            "sha": "5a3008dcc076a557ccd6ba3ee0fa1d7b37b29edb",
            "filename": "packages/compiler-cli/linker/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 8,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2FBUILD.bazel?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -12,14 +12,7 @@ ts_library(\n         \"//packages:types\",\n         \"//packages/compiler\",\n         \"//packages/compiler-cli/linker\",\n-        \"@npm//@babel/core\",\n-        \"@npm//@babel/generator\",\n-        \"@npm//@babel/parser\",\n-        \"@npm//@babel/template\",\n-        \"@npm//@babel/types\",\n-        \"@npm//@types/babel__core\",\n-        \"@npm//@types/babel__generator\",\n-        \"@npm//@types/babel__template\",\n+        \"//packages/compiler-cli/src/ngtsc/translator\",\n         \"@npm//typescript\",\n     ],\n )"
        },
        {
            "sha": "711b996cfc17f25b1e2db8bae9ca9e6f72bbeb57",
            "filename": "packages/compiler-cli/linker/test/ast/ast_value_spec.ts",
            "status": "added",
            "additions": 318,
            "deletions": 0,
            "changes": 318,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Fast_value_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Fast_value_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Fast_value_spec.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,318 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {WrappedNodeExpr} from '@angular/compiler';\n+import {TypeScriptAstFactory} from '@angular/compiler-cli/src/ngtsc/translator';\n+import * as ts from 'typescript';\n+\n+import {AstObject, AstValue} from '../../src/ast/ast_value';\n+import {TypeScriptAstHost} from '../../src/ast/typescript/typescript_ast_host';\n+\n+const host = new TypeScriptAstHost();\n+const factory = new TypeScriptAstFactory();\n+const nestedObj = factory.createObjectLiteral([\n+  {propertyName: 'x', quoted: false, value: factory.createLiteral(42)},\n+  {propertyName: 'y', quoted: false, value: factory.createLiteral('X')},\n+]);\n+const nestedArray =\n+    factory.createArrayLiteral([factory.createLiteral(1), factory.createLiteral(2)]);\n+const obj = AstObject.parse(\n+    factory.createObjectLiteral([\n+      {propertyName: 'a', quoted: false, value: factory.createLiteral(42)},\n+      {propertyName: 'b', quoted: false, value: factory.createLiteral('X')},\n+      {propertyName: 'c', quoted: false, value: factory.createLiteral(true)},\n+      {propertyName: 'd', quoted: false, value: nestedObj},\n+      {propertyName: 'e', quoted: false, value: nestedArray},\n+    ]),\n+    host);\n+\n+describe('AstObject', () => {\n+  describe('has()', () => {\n+    it('should return true if the property exists on the object', () => {\n+      expect(obj.has('a')).toBe(true);\n+      expect(obj.has('b')).toBe(true);\n+      expect(obj.has('z')).toBe(false);\n+    });\n+  });\n+\n+  describe('getNumber()', () => {\n+    it('should return the number value of the property', () => {\n+      expect(obj.getNumber('a')).toEqual(42);\n+    });\n+\n+    it('should throw an error if the property is not a number', () => {\n+      expect(() => obj.getNumber('b'))\n+          .toThrowError('Unsupported syntax, expected a numeric literal.');\n+    });\n+  });\n+\n+  describe('getString()', () => {\n+    it('should return the string value of the property', () => {\n+      expect(obj.getString('b')).toEqual('X');\n+    });\n+\n+    it('should throw an error if the property is not a string', () => {\n+      expect(() => obj.getString('a'))\n+          .toThrowError('Unsupported syntax, expected a string literal.');\n+    });\n+  });\n+\n+  describe('getBoolean()', () => {\n+    it('should return the boolean value of the property', () => {\n+      expect(obj.getBoolean('c')).toEqual(true);\n+    });\n+\n+    it('should throw an error if the property is not a boolean', () => {\n+      expect(() => obj.getBoolean('b'))\n+          .toThrowError('Unsupported syntax, expected a boolean literal.');\n+    });\n+  });\n+\n+  describe('getObject()', () => {\n+    it('should return an AstObject instance parsed from the value of the property', () => {\n+      expect(obj.getObject('d')).toEqual(AstObject.parse(nestedObj, host));\n+    });\n+\n+    it('should throw an error if the property is not an object expression', () => {\n+      expect(() => obj.getObject('b'))\n+          .toThrowError('Unsupported syntax, expected an object literal.');\n+    });\n+  });\n+\n+  describe('getArray()', () => {\n+    it('should return an array of AstValue instances of parsed from the value of the property',\n+       () => {\n+         expect(obj.getArray('e')).toEqual([\n+           new AstValue(factory.createLiteral(1), host),\n+           new AstValue(factory.createLiteral(2), host)\n+         ]);\n+       });\n+\n+    it('should throw an error if the property is not an array of expressions', () => {\n+      expect(() => obj.getArray('b'))\n+          .toThrowError('Unsupported syntax, expected an array literal.');\n+    });\n+  });\n+\n+  describe('getOpaque()', () => {\n+    it('should return the expression value of the property wrapped in a `WrappedNodeExpr`', () => {\n+      expect(obj.getOpaque('d')).toEqual(jasmine.any(WrappedNodeExpr));\n+      expect(obj.getOpaque('d').node).toEqual(obj.getNode('d'));\n+    });\n+\n+    it('should throw an error if the property does not exist', () => {\n+      expect(() => obj.getOpaque('x')).toThrowError('Expected property \\'x\\' to be present.');\n+    });\n+  });\n+\n+  describe('getNode()', () => {\n+    it('should return the original expression value of the property', () => {\n+      expect(obj.getNode('a')).toEqual(factory.createLiteral(42));\n+    });\n+\n+    it('should throw an error if the property does not exist', () => {\n+      expect(() => obj.getNode('x')).toThrowError('Expected property \\'x\\' to be present.');\n+    });\n+  });\n+\n+  describe('getValue()', () => {\n+    it('should return the expression value of the property wrapped in an `AstValue`', () => {\n+      expect(obj.getValue('a')).toEqual(jasmine.any(AstValue));\n+      expect(obj.getValue('a').getNumber()).toEqual(42);\n+    });\n+\n+    it('should throw an error if the property does not exist', () => {\n+      expect(() => obj.getValue('x')).toThrowError('Expected property \\'x\\' to be present.');\n+    });\n+  });\n+\n+  describe('toLiteral()', () => {\n+    it('should convert the AstObject to a raw object with each property mapped', () => {\n+      expect(obj.toLiteral(value => value.getOpaque())).toEqual({\n+        a: obj.getOpaque('a'),\n+        b: obj.getOpaque('b'),\n+        c: obj.getOpaque('c'),\n+        d: obj.getOpaque('d'),\n+        e: obj.getOpaque('e'),\n+      });\n+    });\n+  });\n+});\n+\n+describe('AstValue', () => {\n+  describe('isNumber', () => {\n+    it('should return true if the value is a number', () => {\n+      expect(new AstValue(factory.createLiteral(42), host).isNumber()).toEqual(true);\n+    });\n+\n+    it('should return false if the value is not a number', () => {\n+      expect(new AstValue(factory.createLiteral('a'), host).isNumber()).toEqual(false);\n+    });\n+  });\n+\n+  describe('getNumber', () => {\n+    it('should return the number value of the AstValue', () => {\n+      expect(new AstValue(factory.createLiteral(42), host).getNumber()).toEqual(42);\n+    });\n+\n+    it('should throw an error if the property is not a number', () => {\n+      expect(() => new AstValue(factory.createLiteral('a'), host).getNumber())\n+          .toThrowError('Unsupported syntax, expected a numeric literal.');\n+    });\n+  });\n+\n+  describe('isString', () => {\n+    it('should return true if the value is a string', () => {\n+      expect(new AstValue(factory.createLiteral('a'), host).isString()).toEqual(true);\n+    });\n+\n+    it('should return false if the value is not a string', () => {\n+      expect(new AstValue(factory.createLiteral(42), host).isString()).toEqual(false);\n+    });\n+  });\n+\n+  describe('getString', () => {\n+    it('should return the string value of the AstValue', () => {\n+      expect(new AstValue(factory.createLiteral('X'), host).getString()).toEqual('X');\n+    });\n+\n+    it('should throw an error if the property is not a string', () => {\n+      expect(() => new AstValue(factory.createLiteral(42), host).getString())\n+          .toThrowError('Unsupported syntax, expected a string literal.');\n+    });\n+  });\n+\n+  describe('isBoolean', () => {\n+    it('should return true if the value is a boolean', () => {\n+      expect(new AstValue(factory.createLiteral(true), host).isBoolean()).toEqual(true);\n+    });\n+\n+    it('should return false if the value is not a boolean', () => {\n+      expect(new AstValue(factory.createLiteral(42), host).isBoolean()).toEqual(false);\n+    });\n+  });\n+\n+  describe('getBoolean', () => {\n+    it('should return the boolean value of the AstValue', () => {\n+      expect(new AstValue(factory.createLiteral(true), host).getBoolean()).toEqual(true);\n+    });\n+\n+    it('should throw an error if the property is not a boolean', () => {\n+      expect(() => new AstValue(factory.createLiteral(42), host).getBoolean())\n+          .toThrowError('Unsupported syntax, expected a boolean literal.');\n+    });\n+  });\n+\n+  describe('isObject', () => {\n+    it('should return true if the value is an object literal', () => {\n+      expect(new AstValue(nestedObj, host).isObject()).toEqual(true);\n+    });\n+\n+    it('should return false if the value is not an object literal', () => {\n+      expect(new AstValue(factory.createLiteral(42), host).isObject()).toEqual(false);\n+    });\n+  });\n+\n+  describe('getObject', () => {\n+    it('should return the AstObject value of the AstValue', () => {\n+      expect(new AstValue(nestedObj, host).getObject()).toEqual(AstObject.parse(nestedObj, host));\n+    });\n+\n+    it('should throw an error if the property is not an object literal', () => {\n+      expect(() => new AstValue(factory.createLiteral(42), host).getObject())\n+          .toThrowError('Unsupported syntax, expected an object literal.');\n+    });\n+  });\n+\n+  describe('isArray', () => {\n+    it('should return true if the value is an array literal', () => {\n+      expect(new AstValue(nestedArray, host).isArray()).toEqual(true);\n+    });\n+\n+    it('should return false if the value is not an object literal', () => {\n+      expect(new AstValue(factory.createLiteral(42), host).isArray()).toEqual(false);\n+    });\n+  });\n+\n+  describe('getArray', () => {\n+    it('should return an array of AstValue objects from the AstValue', () => {\n+      expect(new AstValue(nestedArray, host).getArray()).toEqual([\n+        new AstValue(factory.createLiteral(1), host),\n+        new AstValue(factory.createLiteral(2), host),\n+      ]);\n+    });\n+\n+    it('should throw an error if the property is not an array', () => {\n+      expect(() => new AstValue(factory.createLiteral(42), host).getArray())\n+          .toThrowError('Unsupported syntax, expected an array literal.');\n+    });\n+  });\n+\n+  describe('isFunction', () => {\n+    it('should return true if the value is a function expression', () => {\n+      const funcExpr = factory.createFunctionExpression(\n+          'foo', [],\n+          factory.createBlock([factory.createReturnStatement(factory.createLiteral(42))]));\n+      expect(new AstValue(funcExpr, host).isFunction()).toEqual(true);\n+    });\n+\n+    it('should return false if the value is not a function expression', () => {\n+      expect(new AstValue(factory.createLiteral(42), host).isFunction()).toEqual(false);\n+    });\n+  });\n+\n+  describe('getFunctionReturnValue', () => {\n+    it('should return the \"return value\" of the function expression', () => {\n+      const funcExpr = factory.createFunctionExpression(\n+          'foo', [],\n+          factory.createBlock([factory.createReturnStatement(factory.createLiteral(42))]));\n+      expect(new AstValue(funcExpr, host).getFunctionReturnValue())\n+          .toEqual(new AstValue(factory.createLiteral(42), host));\n+    });\n+\n+    it('should throw an error if the property is not a function expression', () => {\n+      expect(() => new AstValue(factory.createLiteral(42), host).getFunctionReturnValue())\n+          .toThrowError('Unsupported syntax, expected a function.');\n+    });\n+\n+    it('should throw an error if the property is a function expression with no return value',\n+       () => {\n+         const funcExpr = factory.createFunctionExpression(\n+             'foo', [], factory.createBlock([factory.createExpressionStatement(\n+                            factory.createLiteral('do nothing'))]));\n+         expect(() => new AstValue(funcExpr, host).getFunctionReturnValue())\n+             .toThrowError(\n+                 'Unsupported syntax, expected a function body with a single return statement.');\n+       });\n+  });\n+\n+  describe('getOpaque()', () => {\n+    it('should return the value wrapped in a `WrappedNodeExpr`', () => {\n+      expect(new AstValue(factory.createLiteral(42), host).getOpaque())\n+          .toEqual(jasmine.any(WrappedNodeExpr));\n+      expect(new AstValue(factory.createLiteral(42), host).getOpaque().node)\n+          .toEqual(factory.createLiteral(42));\n+    });\n+  });\n+\n+  describe('getRange()', () => {\n+    it('should return the source range of the AST node', () => {\n+      const file = ts.createSourceFile(\n+          'test.ts', '// preamble\\nx = \\'moo\\';', ts.ScriptTarget.ES2015,\n+          /* setParentNodes */ true);\n+\n+      // Grab the `'moo'` string literal from the generated AST\n+      const stmt = file.statements[0] as ts.ExpressionStatement;\n+      const mooString =\n+          (stmt.expression as ts.AssignmentExpression<ts.Token<ts.SyntaxKind.EqualsToken>>).right;\n+\n+      // Check that this string literal has the expected range.\n+      expect(new AstValue(mooString, host).getRange())\n+          .toEqual({startLine: 1, startCol: 4, startPos: 16, endPos: 21});\n+    });\n+  });\n+});"
        },
        {
            "sha": "3484f3978d32a6838d862257a37854a4bd9b2989",
            "filename": "packages/compiler-cli/linker/test/file_linker/emit_scopes/emit_scope_spec.ts",
            "status": "added",
            "additions": 77,
            "deletions": 0,
            "changes": 77,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Femit_scopes%2Femit_scope_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Femit_scopes%2Femit_scope_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Femit_scopes%2Femit_scope_spec.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,77 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as o from '@angular/compiler/src/output/output_ast';\n+import * as ts from 'typescript';\n+\n+import {TypeScriptAstFactory} from '../../../../src/ngtsc/translator';\n+import {TypeScriptAstHost} from '../../../src/ast/typescript/typescript_ast_host';\n+import {EmitScope} from '../../../src/file_linker/emit_scopes/emit_scope';\n+import {LinkerEnvironment} from '../../../src/file_linker/linker_environment';\n+import {DEFAULT_LINKER_OPTIONS} from '../../../src/file_linker/linker_options';\n+import {generate} from '../helpers';\n+\n+describe('EmitScope', () => {\n+  describe('translateDefinition()', () => {\n+    it('should translate the given output AST into a TExpression', () => {\n+      const factory = new TypeScriptAstFactory();\n+      const linkerEnvironment = LinkerEnvironment.create<ts.Statement, ts.Expression>(\n+          new TypeScriptAstHost(), factory, DEFAULT_LINKER_OPTIONS);\n+      const ngImport = factory.createIdentifier('core');\n+      const emitScope = new EmitScope<ts.Statement, ts.Expression>(ngImport, linkerEnvironment);\n+\n+      const def = emitScope.translateDefinition(o.fn([], [], null, null, 'foo'));\n+      expect(generate(def)).toEqual('function foo() { }');\n+    });\n+\n+    it('should use the `ngImport` idenfifier for imports when translating', () => {\n+      const factory = new TypeScriptAstFactory();\n+      const linkerEnvironment = LinkerEnvironment.create<ts.Statement, ts.Expression>(\n+          new TypeScriptAstHost(), factory, DEFAULT_LINKER_OPTIONS);\n+      const ngImport = factory.createIdentifier('core');\n+      const emitScope = new EmitScope<ts.Statement, ts.Expression>(ngImport, linkerEnvironment);\n+\n+      const coreImportRef = new o.ExternalReference('@angular/core', 'foo');\n+      const def = emitScope.translateDefinition(o.importExpr(coreImportRef).callMethod('bar', []));\n+      expect(generate(def)).toEqual('core.foo.bar()');\n+    });\n+\n+    it('should not emit any shared constants in the replacement expression', () => {\n+      const factory = new TypeScriptAstFactory();\n+      const linkerEnvironment = LinkerEnvironment.create<ts.Statement, ts.Expression>(\n+          new TypeScriptAstHost(), factory, DEFAULT_LINKER_OPTIONS);\n+      const ngImport = factory.createIdentifier('core');\n+      const emitScope = new EmitScope<ts.Statement, ts.Expression>(ngImport, linkerEnvironment);\n+\n+      const constArray = o.literalArr([o.literal('CONST')]);\n+      // We have to add the constant twice or it will not create a shared statement\n+      emitScope.constantPool.getConstLiteral(constArray);\n+      emitScope.constantPool.getConstLiteral(constArray);\n+\n+      const def = emitScope.translateDefinition(o.fn([], [], null, null, 'foo'));\n+      expect(generate(def)).toEqual('function foo() { }');\n+    });\n+  });\n+\n+  describe('getConstantStatements()', () => {\n+    it('should return any constant statements that were added to the `constantPool`', () => {\n+      const factory = new TypeScriptAstFactory();\n+      const linkerEnvironment = LinkerEnvironment.create<ts.Statement, ts.Expression>(\n+          new TypeScriptAstHost(), factory, DEFAULT_LINKER_OPTIONS);\n+      const ngImport = factory.createIdentifier('core');\n+      const emitScope = new EmitScope<ts.Statement, ts.Expression>(ngImport, linkerEnvironment);\n+\n+      const constArray = o.literalArr([o.literal('CONST')]);\n+      // We have to add the constant twice or it will not create a shared statement\n+      emitScope.constantPool.getConstLiteral(constArray);\n+      emitScope.constantPool.getConstLiteral(constArray);\n+\n+      const statements = emitScope.getConstantStatements();\n+      expect(statements.map(generate)).toEqual(['const _c0 = [\"CONST\"];']);\n+    });\n+  });\n+});"
        },
        {
            "sha": "b4d12f8269a4ee356d542133503eb3ccd5200ac7",
            "filename": "packages/compiler-cli/linker/test/file_linker/emit_scopes/iief_emit_scope_spec.ts",
            "status": "added",
            "additions": 71,
            "deletions": 0,
            "changes": 71,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Femit_scopes%2Fiief_emit_scope_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Femit_scopes%2Fiief_emit_scope_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Femit_scopes%2Fiief_emit_scope_spec.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,71 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as o from '@angular/compiler/src/output/output_ast';\n+import * as ts from 'typescript';\n+\n+import {TypeScriptAstFactory} from '../../../../src/ngtsc/translator';\n+import {TypeScriptAstHost} from '../../../src/ast/typescript/typescript_ast_host';\n+import {IifeEmitScope} from '../../../src/file_linker/emit_scopes/iife_emit_scope';\n+import {LinkerEnvironment} from '../../../src/file_linker/linker_environment';\n+import {DEFAULT_LINKER_OPTIONS} from '../../../src/file_linker/linker_options';\n+import {generate} from '../helpers';\n+\n+describe('IifeEmitScope', () => {\n+  describe('translateDefinition()', () => {\n+    it('should translate the given output AST into a TExpression, wrapped in an IIFE', () => {\n+      const factory = new TypeScriptAstFactory();\n+      const linkerEnvironment = LinkerEnvironment.create<ts.Statement, ts.Expression>(\n+          new TypeScriptAstHost(), factory, DEFAULT_LINKER_OPTIONS);\n+      const ngImport = factory.createIdentifier('core');\n+      const emitScope = new IifeEmitScope<ts.Statement, ts.Expression>(ngImport, linkerEnvironment);\n+\n+      const def = emitScope.translateDefinition(o.fn([], [], null, null, 'foo'));\n+      expect(generate(def)).toEqual('function () { return function foo() { }; }()');\n+    });\n+\n+    it('should use the `ngImport` idenfifier for imports when translating', () => {\n+      const factory = new TypeScriptAstFactory();\n+      const linkerEnvironment = LinkerEnvironment.create<ts.Statement, ts.Expression>(\n+          new TypeScriptAstHost(), factory, DEFAULT_LINKER_OPTIONS);\n+      const ngImport = factory.createIdentifier('core');\n+      const emitScope = new IifeEmitScope<ts.Statement, ts.Expression>(ngImport, linkerEnvironment);\n+\n+      const coreImportRef = new o.ExternalReference('@angular/core', 'foo');\n+      const def = emitScope.translateDefinition(o.importExpr(coreImportRef).callMethod('bar', []));\n+      expect(generate(def)).toEqual('function () { return core.foo.bar(); }()');\n+    });\n+\n+    it('should emit any shared constants in the replacement expression IIFE', () => {\n+      const factory = new TypeScriptAstFactory();\n+      const linkerEnvironment = LinkerEnvironment.create<ts.Statement, ts.Expression>(\n+          new TypeScriptAstHost(), factory, DEFAULT_LINKER_OPTIONS);\n+      const ngImport = factory.createIdentifier('core');\n+      const emitScope = new IifeEmitScope<ts.Statement, ts.Expression>(ngImport, linkerEnvironment);\n+\n+      const constArray = o.literalArr([o.literal('CONST')]);\n+      // We have to add the constant twice or it will not create a shared statement\n+      emitScope.constantPool.getConstLiteral(constArray);\n+      emitScope.constantPool.getConstLiteral(constArray);\n+\n+      const def = emitScope.translateDefinition(o.fn([], [], null, null, 'foo'));\n+      expect(generate(def))\n+          .toEqual('function () { const _c0 = [\"CONST\"]; return function foo() { }; }()');\n+    });\n+  });\n+\n+  describe('getConstantStatements()', () => {\n+    it('should throw an error', () => {\n+      const factory = new TypeScriptAstFactory();\n+      const linkerEnvironment = LinkerEnvironment.create<ts.Statement, ts.Expression>(\n+          new TypeScriptAstHost(), factory, DEFAULT_LINKER_OPTIONS);\n+      const ngImport = factory.createIdentifier('core');\n+      const emitScope = new IifeEmitScope<ts.Statement, ts.Expression>(ngImport, linkerEnvironment);\n+      expect(() => emitScope.getConstantStatements()).toThrowError();\n+    });\n+  });\n+});"
        },
        {
            "sha": "68eeee4ddf86586929fcc8403f9ea7caf4c72607",
            "filename": "packages/compiler-cli/linker/test/file_linker/file_linker_spec.ts",
            "status": "added",
            "additions": 191,
            "deletions": 0,
            "changes": 191,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Ffile_linker_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Ffile_linker_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Ffile_linker_spec.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,191 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as o from '@angular/compiler/src/output/output_ast';\n+import * as ts from 'typescript';\n+\n+import {TypeScriptAstFactory} from '../../../src/ngtsc/translator';\n+import {AstHost} from '../../src/ast/ast_host';\n+import {TypeScriptAstHost} from '../../src/ast/typescript/typescript_ast_host';\n+import {DeclarationScope} from '../../src/file_linker/declaration_scope';\n+import {FileLinker} from '../../src/file_linker/file_linker';\n+import {LinkerEnvironment} from '../../src/file_linker/linker_environment';\n+import {DEFAULT_LINKER_OPTIONS} from '../../src/file_linker/linker_options';\n+import {PartialDirectiveLinkerVersion1} from '../../src/file_linker/partial_linkers/partial_directive_linker_1';\n+import {generate} from './helpers';\n+\n+describe('FileLinker', () => {\n+  let factory: TypeScriptAstFactory;\n+  beforeEach(() => factory = new TypeScriptAstFactory());\n+\n+  describe('isPartialDeclaration()', () => {\n+    it('should return true if the callee is recognized', () => {\n+      const {fileLinker} = createFileLinker();\n+      expect(fileLinker.isPartialDeclaration('$ngDeclareDirective')).toBe(true);\n+      expect(fileLinker.isPartialDeclaration('$ngDeclareComponent')).toBe(true);\n+    });\n+\n+    it('should return false if the callee is not recognized', () => {\n+      const {fileLinker} = createFileLinker();\n+      expect(fileLinker.isPartialDeclaration('$foo')).toBe(false);\n+    });\n+  });\n+\n+  describe('linkPartialDeclaration()', () => {\n+    it('should throw an error if the function name is not recognised', () => {\n+      const {fileLinker} = createFileLinker();\n+      const version = factory.createLiteral(1);\n+      const ngImport = factory.createIdentifier('core');\n+      const declarationArg = factory.createObjectLiteral([\n+        {propertyName: 'version', quoted: false, value: version},\n+        {propertyName: 'ngImport', quoted: false, value: ngImport},\n+      ]);\n+      expect(\n+          () => fileLinker.linkPartialDeclaration(\n+              'foo', [declarationArg], new MockDeclarationScope()))\n+          .toThrowError('Unknown partial declaration function foo.');\n+    });\n+\n+    it('should throw an error if the metadata object does not have a `version` property', () => {\n+      const {fileLinker} = createFileLinker();\n+      const ngImport = factory.createIdentifier('core');\n+      const declarationArg = factory.createObjectLiteral([\n+        {propertyName: 'ngImport', quoted: false, value: ngImport},\n+      ]);\n+      expect(\n+          () => fileLinker.linkPartialDeclaration(\n+              '$ngDeclareDirective', [declarationArg], new MockDeclarationScope()))\n+          .toThrowError(`Expected property 'version' to be present.`);\n+    });\n+\n+    it('should throw an error if the metadata object does not have a `ngImport` property', () => {\n+      const {fileLinker} = createFileLinker();\n+      const ngImport = factory.createIdentifier('core');\n+      const declarationArg = factory.createObjectLiteral([\n+        {propertyName: 'version', quoted: false, value: ngImport},\n+      ]);\n+      expect(\n+          () => fileLinker.linkPartialDeclaration(\n+              '$ngDeclareDirective', [declarationArg], new MockDeclarationScope()))\n+          .toThrowError(`Expected property 'ngImport' to be present.`);\n+    });\n+\n+    it('should call `linkPartialDeclaration()` on the appropriate partial compiler', () => {\n+      const {fileLinker} = createFileLinker();\n+      const compileSpy = spyOn(PartialDirectiveLinkerVersion1.prototype, 'linkPartialDeclaration')\n+                             .and.returnValue(o.literal('compilation result'));\n+\n+      const ngImport = factory.createIdentifier('core');\n+      const version = factory.createLiteral(1);\n+      const declarationArg = factory.createObjectLiteral([\n+        {propertyName: 'ngImport', quoted: false, value: ngImport},\n+        {propertyName: 'version', quoted: false, value: version},\n+      ]);\n+\n+      const compilationResult = fileLinker.linkPartialDeclaration(\n+          '$ngDeclareDirective', [declarationArg], new MockDeclarationScope());\n+\n+      expect(compilationResult).toEqual(factory.createLiteral('compilation result'));\n+      expect(compileSpy).toHaveBeenCalled();\n+      expect(compileSpy.calls.mostRecent().args[3].getNode('ngImport')).toBe(ngImport);\n+    });\n+  });\n+\n+  describe('getConstantStatements()', () => {\n+    it('should capture shared constant values', () => {\n+      const {fileLinker} = createFileLinker();\n+      spyOnLinkPartialDeclarationWithConstants(o.literal('REPLACEMENT'));\n+\n+      // Here we use the `core` idenfifier for `ngImport` to trigger the use of a shared scope for\n+      // constant statements.\n+      const declarationArg = factory.createObjectLiteral([\n+        {propertyName: 'ngImport', quoted: false, value: factory.createIdentifier('core')},\n+        {propertyName: 'version', quoted: false, value: factory.createLiteral(1)},\n+      ]);\n+\n+      const replacement = fileLinker.linkPartialDeclaration(\n+          '$ngDeclareDirective', [declarationArg], new MockDeclarationScope());\n+      expect(generate(replacement)).toEqual('\"REPLACEMENT\"');\n+\n+      const results = fileLinker.getConstantStatements();\n+      expect(results.length).toEqual(1);\n+      const {constantScope, statements} = results[0];\n+      expect(constantScope).toBe(MockConstantScopeRef.singleton);\n+      expect(statements.map(generate)).toEqual(['const _c0 = [1];']);\n+    });\n+\n+    it('should be no shared constant statements to capture when they are emitted into the replacement IIFE',\n+       () => {\n+         const {fileLinker} = createFileLinker();\n+         spyOnLinkPartialDeclarationWithConstants(o.literal('REPLACEMENT'));\n+\n+         // Here we use a string literal `\"not-a-module\"` for `ngImport` to cause constant\n+         // statements to be emitted in an IIFE rather than added to the shared constant scope.\n+         const declarationArg = factory.createObjectLiteral([\n+           {propertyName: 'ngImport', quoted: false, value: factory.createLiteral('not-a-module')},\n+           {propertyName: 'version', quoted: false, value: factory.createLiteral(1)},\n+         ]);\n+\n+         const replacement = fileLinker.linkPartialDeclaration(\n+             '$ngDeclareDirective', [declarationArg], new MockDeclarationScope());\n+         expect(generate(replacement))\n+             .toEqual('function () { const _c0 = [1]; return \"REPLACEMENT\"; }()');\n+\n+         const results = fileLinker.getConstantStatements();\n+         expect(results.length).toEqual(0);\n+       });\n+  });\n+\n+  function createFileLinker(): {\n+    host: AstHost<ts.Expression>,\n+    fileLinker: FileLinker<MockConstantScopeRef, ts.Statement, ts.Expression>\n+  } {\n+    const linkerEnvironment = LinkerEnvironment.create<ts.Statement, ts.Expression>(\n+        new TypeScriptAstHost(), new TypeScriptAstFactory(), DEFAULT_LINKER_OPTIONS);\n+    const fileLinker = new FileLinker<MockConstantScopeRef, ts.Statement, ts.Expression>(\n+        linkerEnvironment, 'test.js', '// test code');\n+    return {host: linkerEnvironment.host, fileLinker};\n+  }\n+});\n+\n+\n+/**\n+ * This mock implementation of `DeclarationScope` will return a singleton instance of\n+ * `MockConstantScopeRef` if the expression is an identifier, or `null` otherwise.\n+ *\n+ * This way we can simulate whether the constants will be shared or inlined into an IIFE.\n+ */\n+class MockDeclarationScope implements DeclarationScope<MockConstantScopeRef, ts.Expression> {\n+  getConstantScopeRef(expression: ts.Expression): MockConstantScopeRef|null {\n+    if (ts.isIdentifier(expression)) {\n+      return MockConstantScopeRef.singleton;\n+    } else {\n+      return null;\n+    }\n+  }\n+}\n+\n+class MockConstantScopeRef {\n+  private constructor() {}\n+  static singleton = new MockDeclarationScope();\n+}\n+\n+/**\n+ * Spy on the `PartialDirectiveLinkerVersion1.linkPartialDeclaration()` method, triggering\n+ * shared constants to be created.\n+ */\n+function spyOnLinkPartialDeclarationWithConstants(replacement: o.Expression) {\n+  let callCount = 0;\n+  spyOn(PartialDirectiveLinkerVersion1.prototype, 'linkPartialDeclaration')\n+      .and.callFake(((sourceUrl, code, constantPool) => {\n+                      const constArray = o.literalArr([o.literal(++callCount)]);\n+                      // We have to add the constant twice or it will not create a shared statement\n+                      constantPool.getConstLiteral(constArray);\n+                      constantPool.getConstLiteral(constArray);\n+                      return replacement;\n+                    }) as typeof PartialDirectiveLinkerVersion1.prototype.linkPartialDeclaration);\n+}"
        },
        {
            "sha": "5faa908ce788a03c9491a4f2ec54067783ae4518",
            "filename": "packages/compiler-cli/linker/test/file_linker/helpers.ts",
            "status": "added",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Fhelpers.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Fhelpers.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Fhelpers.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,17 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as ts from 'typescript';\n+\n+/**\n+ * A simple helper to render a TS Node as a string.\n+ */\n+export function generate(node: ts.Node): string {\n+  const printer = ts.createPrinter({newLine: ts.NewLineKind.LineFeed});\n+  const sf = ts.createSourceFile('test.ts', '', ts.ScriptTarget.ES2015, true);\n+  return printer.printNode(ts.EmitHint.Unspecified, node, sf);\n+}"
        },
        {
            "sha": "c04b92e2d9628fac82703d375254aaf3c6018c9d",
            "filename": "packages/compiler-cli/linker/test/file_linker/partial_linkers/partial_linker_selector_spec.ts",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Fpartial_linkers%2Fpartial_linker_selector_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Fpartial_linkers%2Fpartial_linker_selector_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Fpartial_linkers%2Fpartial_linker_selector_spec.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,41 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {PartialComponentLinkerVersion1} from '../../../src/file_linker/partial_linkers/partial_component_linker_1';\n+import {PartialDirectiveLinkerVersion1} from '../../../src/file_linker/partial_linkers/partial_directive_linker_1';\n+import {PartialLinkerSelector} from '../../../src/file_linker/partial_linkers/partial_linker_selector';\n+\n+describe('PartialLinkerSelector', () => {\n+  describe('supportsDeclaration()', () => {\n+    it('should return true if there is at least one linker that matches the given function name',\n+       () => {\n+         const selector = new PartialLinkerSelector();\n+         expect(selector.supportsDeclaration('$ngDeclareDirective')).toBe(true);\n+         expect(selector.supportsDeclaration('$ngDeclareComponent')).toBe(true);\n+         expect(selector.supportsDeclaration('$foo')).toBe(false);\n+       });\n+  });\n+\n+  describe('getLinker()', () => {\n+    it('should return the linker that matches the name and version number', () => {\n+      const selector = new PartialLinkerSelector();\n+      expect(selector.getLinker('$ngDeclareDirective', 1))\n+          .toBeInstanceOf(PartialDirectiveLinkerVersion1);\n+      expect(selector.getLinker('$ngDeclareComponent', 1))\n+          .toBeInstanceOf(PartialComponentLinkerVersion1);\n+    });\n+\n+    it('should throw an error if there is no linker that matches the given name or version', () => {\n+      const selector = new PartialLinkerSelector();\n+      expect(() => selector.getLinker('$foo', 1))\n+          .toThrowError('Unknown partial declaration function $foo.');\n+      expect(() => selector.getLinker('$ngDeclareDirective', 2))\n+          .toThrowError('Unsupported partial declaration version 2 for $ngDeclareDirective.');\n+    });\n+  });\n+});"
        },
        {
            "sha": "31d0401f0b2e40225464e3b6c913dd7aef70cf32",
            "filename": "packages/compiler-cli/linker/test/file_linker/translator_spec.ts",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Ftranslator_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Ftranslator_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Ftranslator_spec.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -0,0 +1,47 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as o from '@angular/compiler';\n+import {ImportGenerator, NamedImport, TypeScriptAstFactory} from '@angular/compiler-cli/src/ngtsc/translator';\n+import * as ts from 'typescript';\n+\n+import {Translator} from '../../src/file_linker/translator';\n+import {generate} from './helpers';\n+\n+describe('Translator', () => {\n+  let factory: TypeScriptAstFactory;\n+  beforeEach(() => factory = new TypeScriptAstFactory());\n+\n+  describe('translateExpression()', () => {\n+    it('should generate expression specific output', () => {\n+      const translator = new Translator<ts.Statement, ts.Expression>(factory);\n+      const outputAst = new o.WriteVarExpr('foo', new o.LiteralExpr(42));\n+      const translated = translator.translateExpression(outputAst, new MockImportGenerator());\n+      expect(generate(translated)).toEqual('(foo = 42)');\n+    });\n+  });\n+\n+  describe('translateStatement()', () => {\n+    it('should generate statement specific output', () => {\n+      const translator = new Translator<ts.Statement, ts.Expression>(factory);\n+      const outputAst = new o.ExpressionStatement(new o.WriteVarExpr('foo', new o.LiteralExpr(42)));\n+      const translated = translator.translateStatement(outputAst, new MockImportGenerator());\n+      expect(generate(translated)).toEqual('foo = 42;');\n+    });\n+  });\n+  class MockImportGenerator implements ImportGenerator<ts.Expression> {\n+    generateNamespaceImport(moduleName: string): ts.Expression {\n+      return factory.createLiteral(moduleName);\n+    }\n+    generateNamedImport(moduleName: string, originalSymbol: string): NamedImport<ts.Expression> {\n+      return {\n+        moduleImport: factory.createLiteral(moduleName),\n+        symbol: originalSymbol,\n+      };\n+    }\n+  }\n+});"
        },
        {
            "sha": "3202ada682d09a8aee5c8bead66bc57d01320940",
            "filename": "packages/compiler-cli/linker/test/linker_import_generator_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Flinker_import_generator_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Flinker%2Ftest%2Flinker_import_generator_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Flinker_import_generator_spec.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -8,7 +8,7 @@\n import {LinkerImportGenerator} from '../src/linker_import_generator';\n \n const ngImport = {\n-  type: 'ngImport'\n+  ngImport: true\n };\n \n describe('LinkerImportGenerator<TExpression>', () => {"
        },
        {
            "sha": "8c0dfef49f728b9935109e95fee1da2e538067e0",
            "filename": "packages/compiler-cli/src/ngtsc/translator/index.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts?ref=7e742aea7c9fba3155dd09c0e2e7a59eb2b7f8c1",
            "patch": "@@ -8,8 +8,9 @@\n \n export {AstFactory, BinaryOperator, LeadingComment, ObjectLiteralProperty, SourceMapLocation, SourceMapRange, TemplateElement, TemplateLiteral, UnaryOperator, VariableDeclarationType} from './src/api/ast_factory';\n export {Import, ImportGenerator, NamedImport} from './src/api/import_generator';\n+export {Context} from './src/context';\n export {ImportManager} from './src/import_manager';\n-export {RecordWrappedNodeExprFn} from './src/translator';\n+export {ExpressionTranslatorVisitor, RecordWrappedNodeExprFn, TranslatorOptions} from './src/translator';\n export {translateType} from './src/type_translator';\n export {attachComments, TypeScriptAstFactory} from './src/typescript_ast_factory';\n export {translateExpression, translateStatement} from './src/typescript_translator';"
        }
    ],
    "stats": {
        "total": 2182,
        "additions": 2159,
        "deletions": 23
    }
}