{
    "author": "dgp1130",
    "message": "fix(compiler-cli): handle nullable expressions correctly in the nullish coalescing extended template diagnostic (#43572)\n\nRefs #42966.\n\nPreviously, checking a template with the syntax:\n\n```html\n<div>{{ foo() ?? 'test' }}</div>\n```\n\nWhere `foo()` returns a nullable value:\n\n```typescript\n@Component(/* ... */)\nclass TestCmp {\n  foo: (): string | null => null;\n}\n```\n\nWould always log a nullish coalescing not nullable warning. This is because [`getSymbolOfNode(node.left)`](https://github.com/angular/angular/blob/fe691935091aaf7090864c8111a15f7cc7e53b6c/packages/compiler-cli/src/ngtsc/typecheck/extended/checks/nullish_coalescing_not_nullable/index.ts#L30) would return the [symbol of the function (`foo`)](https://github.com/angular/angular/blob/fe691935091aaf7090864c8111a15f7cc7e53b6c/packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts#L536-L538) rather than the symbol of its returned value (`foo()`). Fixed this by getting the symbol for the whole expression's span, rather than just the function receiver.\n\nAlso made some minor refactorings to `template_symbol_builder` to make a similar change to safe method calls. This behavior was originally for the language service in order to handle quick info, as the user highlighting a function name would actually apply to the entire expression. This is no longer true as the language service will correctly request the type from the function rather than the `Call` expression, so these hacks are not necessary anymore. This broke two existing test cases of exactly this behavior which were easily updated. Also added a test to the language service to confirm that it is not broken by this change.\n\nPR Close #43572",
    "sha": "263feba5c2d56e8433068718d1fdcbc3b2ae144c",
    "files": [
        {
            "sha": "3606e60e9432c2ad5fcbdde9346499c1ae1b6140",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/extended/test/checks/nullish_coalescing_not_nullable/nullish_coalescing_not_nullable_spec.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 20,
            "changes": 44,
            "blob_url": "https://github.com/angular/angular/blob/263feba5c2d56e8433068718d1fdcbc3b2ae144c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fextended%2Ftest%2Fchecks%2Fnullish_coalescing_not_nullable%2Fnullish_coalescing_not_nullable_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/263feba5c2d56e8433068718d1fdcbc3b2ae144c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fextended%2Ftest%2Fchecks%2Fnullish_coalescing_not_nullable%2Fnullish_coalescing_not_nullable_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fextended%2Ftest%2Fchecks%2Fnullish_coalescing_not_nullable%2Fnullish_coalescing_not_nullable_spec.ts?ref=263feba5c2d56e8433068718d1fdcbc3b2ae144c",
            "patch": "@@ -133,25 +133,29 @@ runInEachFileSystem(() => {\n       expect(diags.length).toBe(0);\n     });\n \n-    it('does not blow up when there is no symbol for the LHS of the operator', () => {\n-      const fileName = absoluteFrom('/main.ts');\n-      const {program, templateTypeChecker} = setup([\n-        {\n-          fileName,\n-          templates: {\n-            'TestCmp': `{{ (123 | doesNotExist) ?? 'invalid date' }}`,\n-          },\n-          source: `\n-            export class TestCmp { var1: string | undefined = \"text\"; }\n-          `,\n-        },\n-      ]);\n-      const sf = getSourceFileOrError(program, fileName);\n-      const component = getClass(sf, 'TestCmp');\n-      const extendedTemplateChecker = new ExtendedTemplateCheckerImpl(\n-          templateTypeChecker, program.getTypeChecker(), [new NullishCoalescingNotNullableCheck()]);\n-      const diags = extendedTemplateChecker.getDiagnosticsForComponent(component);\n-      expect(diags.length).toBe(0);\n-    });\n+    it('should not produce nullish coalescing warning when the left side is a nullable expression',\n+       () => {\n+         const fileName = absoluteFrom('/main.ts');\n+         const {program, templateTypeChecker} = setup([\n+           {\n+             fileName,\n+             templates: {\n+               'TestCmp': `{{ func() ?? 'foo' }}`,\n+             },\n+             source: `\n+               export class TestCmp {\n+                 func: (): string | null => null;\n+               }\n+             `,\n+           },\n+         ]);\n+         const sf = getSourceFileOrError(program, fileName);\n+         const component = getClass(sf, 'TestCmp');\n+         const extendedTemplateChecker = new ExtendedTemplateCheckerImpl(\n+             templateTypeChecker, program.getTypeChecker(),\n+             [new NullishCoalescingNotNullableCheck()]);\n+         const diags = extendedTemplateChecker.getDiagnosticsForComponent(component);\n+         expect(diags.length).toBe(0);\n+       });\n   });\n });"
        },
        {
            "sha": "5c0b763a72d4be7a49caac35dfe54c9871d485ae",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 8,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/263feba5c2d56e8433068718d1fdcbc3b2ae144c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/263feba5c2d56e8433068718d1fdcbc3b2ae144c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=263feba5c2d56e8433068718d1fdcbc3b2ae144c",
            "patch": "@@ -499,8 +499,6 @@ export class SymbolBuilder {\n     // AST so there is no way to retrieve a `Symbol` for just the `name` via a specific node.\n     if (expression instanceof PropertyWrite) {\n       withSpan = expression.nameSpan;\n-    } else if (expression instanceof Call && expression.receiver instanceof PropertyRead) {\n-      withSpan = expression.receiver.nameSpan;\n     }\n \n     let node: ts.Node|null = null;\n@@ -530,12 +528,8 @@ export class SymbolBuilder {\n     // - If our expression is a pipe binding (\"a | test:b:c\"), we want the Symbol for the\n     // `transform` on the pipe.\n     // - Otherwise, we retrieve the symbol for the node itself with no special considerations\n-    if ((expression instanceof SafePropertyRead ||\n-         (expression instanceof Call && expression.receiver instanceof SafePropertyRead)) &&\n-        ts.isConditionalExpression(node)) {\n-      const whenTrueSymbol = (expression instanceof Call && ts.isCallExpression(node.whenTrue)) ?\n-          this.getSymbolOfTsNode(node.whenTrue.expression) :\n-          this.getSymbolOfTsNode(node.whenTrue);\n+    if (expression instanceof SafePropertyRead && ts.isConditionalExpression(node)) {\n+      const whenTrueSymbol = this.getSymbolOfTsNode(node.whenTrue);\n       if (whenTrueSymbol === null) {\n         return null;\n       }"
        },
        {
            "sha": "6b0356d4149732b05cd4862f0208f4f868af97f0",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 14,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/263feba5c2d56e8433068718d1fdcbc3b2ae144c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/263feba5c2d56e8433068718d1fdcbc3b2ae144c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=263feba5c2d56e8433068718d1fdcbc3b2ae144c",
            "patch": "@@ -467,13 +467,10 @@ runInEachFileSystem(() => {\n           const safeMethodCall = nodes[2].inputs[0].value as ASTWithSource;\n           const methodCallSymbol = templateTypeChecker.getSymbolOfNode(safeMethodCall, cmp)!;\n           assertExpressionSymbol(methodCallSymbol);\n-          expect(program.getTypeChecker().symbolToString(methodCallSymbol.tsSymbol!))\n-              .toEqual('speak');\n-          expect((methodCallSymbol.tsSymbol!.declarations![0] as ts.PropertyDeclaration)\n-                     .parent.name!.getText())\n-              .toEqual('Person');\n+          // Note that the symbol returned is for the return value of the safe method call.\n+          expect(methodCallSymbol.tsSymbol).toBeNull();\n           expect(program.getTypeChecker().typeToString(methodCallSymbol.tsType))\n-              .toEqual('string | undefined');\n+              .toBe('string | undefined');\n         });\n \n         it('safe keyed reads', () => {\n@@ -869,14 +866,9 @@ runInEachFileSystem(() => {\n         const node = getAstElements(templateTypeChecker, cmp)[0];\n         const callSymbol = templateTypeChecker.getSymbolOfNode(node.inputs[0].value, cmp)!;\n         assertExpressionSymbol(callSymbol);\n-        // Note that the symbol returned is for the method name of the Call. The AST\n-        // does not support specific designation for the name so we assume that's what\n-        // is wanted in this case. We don't support retrieving a symbol for the whole\n-        // call expression and if you want to get a symbol for the args, you can\n-        // use the AST of the args in the `Call`.\n-        expect(program.getTypeChecker().symbolToString(callSymbol.tsSymbol!)).toEqual('toString');\n-        expect(program.getTypeChecker().typeToString(callSymbol.tsType))\n-            .toEqual('(v: any) => string');\n+        // Note that the symbol returned is for the return value of the Call.\n+        expect(callSymbol.tsSymbol).toBeNull();\n+        expect(program.getTypeChecker().typeToString(callSymbol.tsType)).toBe('string');\n       });\n     });\n "
        },
        {
            "sha": "28f19207615122476e68f883135eb18384350774",
            "filename": "packages/language-service/ivy/test/quick_info_spec.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 1,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/263feba5c2d56e8433068718d1fdcbc3b2ae144c/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/263feba5c2d56e8433068718d1fdcbc3b2ae144c/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts?ref=263feba5c2d56e8433068718d1fdcbc3b2ae144c",
            "patch": "@@ -9,7 +9,7 @@\n import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n \n import * as ts from 'typescript/lib/tsserverlibrary';\n-import {LanguageServiceTestEnv, Project} from '../testing';\n+import {createModuleAndProjectWithDeclarations, LanguageServiceTestEnv, Project} from '../testing';\n \n function quickInfoSkeleton(): {[fileName: string]: string} {\n   return {\n@@ -443,6 +443,25 @@ describe('quick info', () => {\n         });\n       });\n \n+      it('should work for safe method calls', () => {\n+        const files = {\n+          'app.ts': `import {Component} from '@angular/core';\n+            @Component({template: '<div (click)=\"something?.myFunc()\"></div>'})\n+            export class AppCmp {\n+              something!: {\n+                /** Documentation for myFunc. */\n+                myFunc(): void\n+              };\n+            }`,\n+        };\n+        const project = createModuleAndProjectWithDeclarations(env, 'test_project', files);\n+        const appFile = project.openFile('app.ts');\n+        appFile.moveCursorToText('something?.myF¦unc()');\n+        const info = appFile.getQuickInfoAtPosition()!;\n+        expect(toText(info.displayParts)).toEqual('(method) myFunc(): void');\n+        expect(toText(info.documentation)).toEqual('Documentation for myFunc.');\n+      });\n+\n       it('should work for accessed properties in writes', () => {\n         expectQuickInfo({\n           templateOverride: `<div (click)=\"hero.i¦d = 2\"></div>`,"
        }
    ],
    "stats": {
        "total": 95,
        "additions": 52,
        "deletions": 43
    }
}