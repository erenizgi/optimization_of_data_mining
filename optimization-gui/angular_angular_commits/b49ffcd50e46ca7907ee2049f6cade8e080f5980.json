{
    "author": "crisbeto",
    "message": "feat(core): allow for injector to be specified when creating an embedded view (#44666)\n\nAdds support for passing in an optional injector when creating an embedded view through `ViewContainerRef.createEmbeddedView` and `TemplateRef.createEmbeddedView`. The injector allows for the DI behavior to be customized within the specific template.\n\nFixes #14935.\n\nPR Close #44666",
    "sha": "b49ffcd50e46ca7907ee2049f6cade8e080f5980",
    "files": [
        {
            "sha": "387bfbd03b89cf30f470638146727aa1b779d66c",
            "filename": "goldens/public-api/core/core.md",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/b49ffcd50e46ca7907ee2049f6cade8e080f5980/goldens%2Fpublic-api%2Fcore%2Fcore.md",
            "raw_url": "https://github.com/angular/angular/raw/b49ffcd50e46ca7907ee2049f6cade8e080f5980/goldens%2Fpublic-api%2Fcore%2Fcore.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fpublic-api%2Fcore%2Fcore.md?ref=b49ffcd50e46ca7907ee2049f6cade8e080f5980",
            "patch": "@@ -1237,7 +1237,7 @@ export type StaticProvider = ValueProvider | ExistingProvider | StaticClassProvi\n \n // @public\n export abstract class TemplateRef<C> {\n-    abstract createEmbeddedView(context: C): EmbeddedViewRef<C>;\n+    abstract createEmbeddedView(context: C, injector?: Injector): EmbeddedViewRef<C>;\n     abstract readonly elementRef: ElementRef;\n }\n \n@@ -1383,6 +1383,10 @@ export abstract class ViewContainerRef {\n     }): ComponentRef<C>;\n     // @deprecated\n     abstract createComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector, projectableNodes?: any[][], ngModuleRef?: NgModuleRef<any>): ComponentRef<C>;\n+    abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, options?: {\n+        index?: number;\n+        injector?: Injector;\n+    }): EmbeddedViewRef<C>;\n     abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>;\n     abstract detach(index?: number): ViewRef | null;\n     abstract get element(): ElementRef;"
        },
        {
            "sha": "aae7da7e6ff0d59254949e51431a2ba694111bfc",
            "filename": "packages/core/src/linker/template_ref.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 4,
            "changes": 24,
            "blob_url": "https://github.com/angular/angular/blob/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Fsrc%2Flinker%2Ftemplate_ref.ts",
            "raw_url": "https://github.com/angular/angular/raw/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Fsrc%2Flinker%2Ftemplate_ref.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Flinker%2Ftemplate_ref.ts?ref=b49ffcd50e46ca7907ee2049f6cade8e080f5980",
            "patch": "@@ -6,10 +6,12 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+import {Injector} from '../di/injector';\n import {assertLContainer} from '../render3/assert';\n+import {ChainedInjector} from '../render3/chained_injector';\n import {createLView, renderView} from '../render3/instructions/shared';\n import {TContainerNode, TNode, TNodeType} from '../render3/interfaces/node';\n-import {DECLARATION_LCONTAINER, LView, LViewFlags, QUERIES, TView} from '../render3/interfaces/view';\n+import {DECLARATION_LCONTAINER, INJECTOR, LView, LViewFlags, QUERIES, TView} from '../render3/interfaces/view';\n import {getCurrentTNode, getLView} from '../render3/state';\n import {ViewRef as R3_ViewRef} from '../render3/view_ref';\n import {assertDefined} from '../util/assert';\n@@ -55,9 +57,10 @@ export abstract class TemplateRef<C> {\n    * and attaches it to the view container.\n    * @param context The data-binding context of the embedded view, as declared\n    * in the `<ng-template>` usage.\n+   * @param injector Injector to be used within the embedded view.\n    * @returns The new embedded view object.\n    */\n-  abstract createEmbeddedView(context: C): EmbeddedViewRef<C>;\n+  abstract createEmbeddedView(context: C, injector?: Injector): EmbeddedViewRef<C>;\n \n   /**\n    * @internal\n@@ -77,11 +80,12 @@ const R3TemplateRef = class TemplateRef<T> extends ViewEngineTemplateRef<T> {\n     super();\n   }\n \n-  override createEmbeddedView(context: T): EmbeddedViewRef<T> {\n+  override createEmbeddedView(context: T, injector?: Injector): EmbeddedViewRef<T> {\n     const embeddedTView = this._declarationTContainer.tViews as TView;\n     const embeddedLView = createLView(\n         this._declarationLView, embeddedTView, context, LViewFlags.CheckAlways, null,\n-        embeddedTView.declTNode, null, null, null, null);\n+        embeddedTView.declTNode, null, null, null,\n+        createEmbeddedViewInjector(injector, this._declarationLView[INJECTOR]));\n \n     const declarationLContainer = this._declarationLView[this._declarationTContainer.index];\n     ngDevMode && assertLContainer(declarationLContainer);\n@@ -98,6 +102,18 @@ const R3TemplateRef = class TemplateRef<T> extends ViewEngineTemplateRef<T> {\n   }\n };\n \n+function createEmbeddedViewInjector(\n+    embeddedViewInjector: Injector|undefined, declarationViewInjector: Injector|null): Injector|\n+    null {\n+  if (!embeddedViewInjector) {\n+    return null;\n+  }\n+\n+  return declarationViewInjector ?\n+      new ChainedInjector(embeddedViewInjector, declarationViewInjector) :\n+      embeddedViewInjector;\n+}\n+\n /**\n  * Creates a TemplateRef given a node.\n  *"
        },
        {
            "sha": "45bb73d1e1d564f97fe4610c70b841ff7d6ef7be",
            "filename": "packages/core/src/linker/view_container_ref.ts",
            "status": "modified",
            "additions": 38,
            "deletions": 2,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Fsrc%2Flinker%2Fview_container_ref.ts",
            "raw_url": "https://github.com/angular/angular/raw/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Fsrc%2Flinker%2Fview_container_ref.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Flinker%2Fview_container_ref.ts?ref=b49ffcd50e46ca7907ee2049f6cade8e080f5980",
            "patch": "@@ -90,6 +90,24 @@ export abstract class ViewContainerRef {\n    */\n   abstract get length(): number;\n \n+  /**\n+   * Instantiates an embedded view and inserts it\n+   * into this container.\n+   * @param templateRef The HTML template that defines the view.\n+   * @param context The data-binding context of the embedded view, as declared\n+   * in the `<ng-template>` usage.\n+   * @param options Extra configuration for the created view. Includes:\n+   *  * index: The 0-based index at which to insert the new view into this container.\n+   *           If not specified, appends the new view as the last entry.\n+   *  * injector: Injector to be used within the embedded view.\n+   *\n+   * @returns The `ViewRef` instance for the newly created view.\n+   */\n+  abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, options?: {\n+    index?: number,\n+    injector?: Injector\n+  }): EmbeddedViewRef<C>;\n+\n   /**\n    * Instantiates an embedded view and inserts it\n    * into this container.\n@@ -258,9 +276,27 @@ const R3ViewContainerRef = class ViewContainerRef extends VE_ViewContainerRef {\n     return this._lContainer.length - CONTAINER_HEADER_OFFSET;\n   }\n \n+  override createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, options?: {\n+    index?: number,\n+    injector?: Injector\n+  }): EmbeddedViewRef<C>;\n   override createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number):\n-      EmbeddedViewRef<C> {\n-    const viewRef = templateRef.createEmbeddedView(context || <any>{});\n+      EmbeddedViewRef<C>;\n+  override createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, indexOrOptions?: number|{\n+    index?: number,\n+    injector?: Injector\n+  }): EmbeddedViewRef<C> {\n+    let index: number|undefined;\n+    let injector: Injector|undefined;\n+\n+    if (typeof indexOrOptions === 'number') {\n+      index = indexOrOptions;\n+    } else if (indexOrOptions != null) {\n+      index = indexOrOptions.index;\n+      injector = indexOrOptions.injector;\n+    }\n+\n+    const viewRef = templateRef.createEmbeddedView(context || <any>{}, injector);\n     this.insert(viewRef, index);\n     return viewRef;\n   }"
        },
        {
            "sha": "7a1b841156b76b826ad3057ed08b882c1360ebee",
            "filename": "packages/core/src/render3/chained_injector.ts",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/angular/angular/blob/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Fsrc%2Frender3%2Fchained_injector.ts",
            "raw_url": "https://github.com/angular/angular/raw/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Fsrc%2Frender3%2Fchained_injector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fchained_injector.ts?ref=b49ffcd50e46ca7907ee2049f6cade8e080f5980",
            "patch": "@@ -0,0 +1,36 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Injector} from '../di/injector';\n+import {InjectFlags} from '../di/interface/injector';\n+import {ProviderToken} from '../di/provider_token';\n+import {NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR} from '../view/provider_flags';\n+\n+/**\n+ * Injector that looks up a value using a specific injector, before falling back to the module\n+ * injector. Used primarily when creating components or embedded views dynamically.\n+ */\n+export class ChainedInjector implements Injector {\n+  constructor(private injector: Injector, private parentInjector: Injector) {}\n+\n+  get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T {\n+    const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as T, flags);\n+\n+    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||\n+        notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n+      // Return the value from the root element injector when\n+      // - it provides it\n+      //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n+      // - the module injector should not be checked\n+      //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n+      return value;\n+    }\n+\n+    return this.parentInjector.get(token, notFoundValue, flags);\n+  }\n+}"
        },
        {
            "sha": "488a46f0e381ff31467d3124123da46593e4e6ea",
            "filename": "packages/core/src/render3/component_ref.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 26,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Fsrc%2Frender3%2Fcomponent_ref.ts",
            "raw_url": "https://github.com/angular/angular/raw/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Fsrc%2Frender3%2Fcomponent_ref.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fcomponent_ref.ts?ref=b49ffcd50e46ca7907ee2049f6cade8e080f5980",
            "patch": "@@ -9,8 +9,6 @@\n import {ChangeDetectorRef as ViewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\n import {InjectionToken} from '../di/injection_token';\n import {Injector} from '../di/injector';\n-import {InjectFlags} from '../di/interface/injector';\n-import {ProviderToken} from '../di/provider_token';\n import {Type} from '../interface/type';\n import {ComponentFactory as viewEngine_ComponentFactory, ComponentRef as viewEngine_ComponentRef} from '../linker/component_factory';\n import {ComponentFactoryResolver as viewEngine_ComponentFactoryResolver} from '../linker/component_factory_resolver';\n@@ -19,8 +17,9 @@ import {NgModuleRef as viewEngine_NgModuleRef} from '../linker/ng_module_factory\n import {RendererFactory2} from '../render/api';\n import {Sanitizer} from '../sanitization/sanitizer';\n import {VERSION} from '../version';\n-import {NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR} from '../view/provider_flags';\n+\n import {assertComponentType} from './assert';\n+import {ChainedInjector} from './chained_injector';\n import {createRootComponent, createRootComponentView, createRootContext, LifecycleHooksFeature} from './component';\n import {getComponentDef} from './definition';\n import {NodeInjector} from './di';\n@@ -79,26 +78,6 @@ export const SCHEDULER = new InjectionToken<((fn: () => void) => void)>('SCHEDUL\n   factory: () => defaultScheduler,\n });\n \n-function createChainedInjector(rootViewInjector: Injector, moduleInjector: Injector): Injector {\n-  return {\n-    get: <T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T => {\n-      const value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as T, flags);\n-\n-      if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||\n-          notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n-        // Return the value from the root element injector when\n-        // - it provides it\n-        //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n-        // - the module injector should not be checked\n-        //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n-        return value;\n-      }\n-\n-      return moduleInjector.get(token, notFoundValue, flags);\n-    }\n-  };\n-}\n-\n /**\n  * Render3 implementation of {@link viewEngine_ComponentFactory}.\n  */\n@@ -135,11 +114,11 @@ export class ComponentFactory<T> extends viewEngine_ComponentFactory<T> {\n       ngModule?: viewEngine_NgModuleRef<any>|undefined): viewEngine_ComponentRef<T> {\n     ngModule = ngModule || this.ngModule;\n \n-    const rootViewInjector =\n-        ngModule ? createChainedInjector(injector, ngModule.injector) : injector;\n+    const rootViewInjector = ngModule ? new ChainedInjector(injector, ngModule.injector) : injector;\n \n     const rendererFactory =\n-        rootViewInjector.get(RendererFactory2, domRendererFactory3) as RendererFactory3;\n+        rootViewInjector.get(RendererFactory2, domRendererFactory3 as RendererFactory2) as\n+        RendererFactory3;\n     const sanitizer = rootViewInjector.get(Sanitizer, null);\n \n     const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);"
        },
        {
            "sha": "e4a7255ac76cfbe1c71c1d51b0d301fe02115800",
            "filename": "packages/core/src/render3/interfaces/injector.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Finjector.ts",
            "raw_url": "https://github.com/angular/angular/raw/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Finjector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Finjector.ts?ref=b49ffcd50e46ca7907ee2049f6cade8e080f5980",
            "patch": "@@ -48,7 +48,7 @@ import {LView, TData} from './view';\n  * index + 7: cumulative bloom filter\n  * index + 8: cumulative bloom filter\n  * index + TNODE: TNode associated with this `NodeInjector`\n- *                `canst tNode = tView.data[index + NodeInjectorOffset.TNODE]`\n+ *                `const tNode = tView.data[index + NodeInjectorOffset.TNODE]`\n  * ```\n  */\n export const enum NodeInjectorOffset {"
        },
        {
            "sha": "4450a874536d80180dc8dec767d5275715e3f836",
            "filename": "packages/core/test/acceptance/di_spec.ts",
            "status": "modified",
            "additions": 599,
            "deletions": 0,
            "changes": 599,
            "blob_url": "https://github.com/angular/angular/blob/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts?ref=b49ffcd50e46ca7907ee2049f6cade8e080f5980",
            "patch": "@@ -3546,4 +3546,603 @@ describe('di', () => {\n     TestBed.configureTestingModule({declarations: [App]});\n     expect(() => TestBed.createComponent(App)).toThrowError(/NullInjectorError/);\n   });\n+\n+  describe('injector when creating embedded view', () => {\n+    const token = new InjectionToken<string>('greeting');\n+\n+    @Directive({selector: 'menu-trigger'})\n+    class MenuTrigger {\n+      @Input('triggerFor') menu!: TemplateRef<unknown>;\n+\n+      constructor(private viewContainerRef: ViewContainerRef) {}\n+\n+      open(injector: Injector|undefined) {\n+        this.viewContainerRef.createEmbeddedView(this.menu, undefined, {injector});\n+      }\n+    }\n+\n+    it('should be able to provide an injection token through a custom injector', () => {\n+      @Directive({selector: 'menu'})\n+      class Menu {\n+        constructor(@Inject(token) public tokenValue: string) {}\n+      }\n+\n+      @Component({\n+        template: `\n+          <menu-trigger [triggerFor]=\"menuTemplate\"></menu-trigger>\n+          <ng-template #menuTemplate>\n+            <menu></menu>\n+          </ng-template>\n+      `\n+      })\n+      class App {\n+        @ViewChild(MenuTrigger) trigger!: MenuTrigger;\n+        @ViewChild(Menu) menu!: Menu;\n+      }\n+\n+      TestBed.configureTestingModule({declarations: [App, MenuTrigger, Menu]});\n+      const injector = Injector.create({providers: [{provide: token, useValue: 'hello'}]});\n+      const fixture = TestBed.createComponent(App);\n+      fixture.detectChanges();\n+\n+      fixture.componentInstance.trigger.open(injector);\n+      fixture.detectChanges();\n+\n+      expect(fixture.componentInstance.menu.tokenValue).toBe('hello');\n+    });\n+\n+    it('should be able to provide an injection token to a nested template through a custom injector',\n+       () => {\n+         @Directive({selector: 'menu'})\n+         class Menu {\n+           constructor(@Inject(token) public tokenValue: string) {}\n+         }\n+\n+         @Component({\n+           template: `\n+            <menu-trigger #outerTrigger [triggerFor]=\"outerTemplate\"></menu-trigger>\n+            <ng-template #outerTemplate>\n+              <menu></menu>\n+\n+              <menu-trigger #innerTrigger [triggerFor]=\"innerTemplate\"></menu-trigger>\n+              <ng-template #innerTemplate>\n+                <menu #innerMenu></menu>\n+              </ng-template>\n+            </ng-template>\n+          `\n+         })\n+         class App {\n+           @ViewChild('outerTrigger', {read: MenuTrigger}) outerTrigger!: MenuTrigger;\n+           @ViewChild('innerTrigger', {read: MenuTrigger}) innerTrigger!: MenuTrigger;\n+           @ViewChild('innerMenu', {read: Menu}) innerMenu!: Menu;\n+         }\n+\n+         TestBed.configureTestingModule({declarations: [App, MenuTrigger, Menu]});\n+         const fixture = TestBed.createComponent(App);\n+         fixture.detectChanges();\n+\n+         fixture.componentInstance.outerTrigger.open(\n+             Injector.create({providers: [{provide: token, useValue: 'hello'}]}));\n+         fixture.detectChanges();\n+\n+         fixture.componentInstance.innerTrigger.open(undefined);\n+         fixture.detectChanges();\n+\n+         expect(fixture.componentInstance.innerMenu.tokenValue).toBe('hello');\n+       });\n+\n+    it('should be able to resolve a token from a custom grandparent injector if the token is not provided in the parent',\n+       () => {\n+         @Directive({selector: 'menu'})\n+         class Menu {\n+           constructor(@Inject(token) public tokenValue: string) {}\n+         }\n+\n+         @Component({\n+           template: `\n+            <menu-trigger #grandparentTrigger [triggerFor]=\"grandparentTemplate\"></menu-trigger>\n+            <ng-template #grandparentTemplate>\n+              <menu></menu>\n+\n+              <menu-trigger #parentTrigger [triggerFor]=\"parentTemplate\"></menu-trigger>\n+              <ng-template #parentTemplate>\n+                <menu></menu>\n+\n+                <menu-trigger #childTrigger [triggerFor]=\"childTemplate\"></menu-trigger>\n+                <ng-template #childTemplate>\n+                  <menu #childMenu></menu>\n+                </ng-template>\n+              </ng-template>\n+            </ng-template>\n+          `\n+         })\n+         class App {\n+           @ViewChild('grandparentTrigger', {read: MenuTrigger}) grandparentTrigger!: MenuTrigger;\n+           @ViewChild('parentTrigger', {read: MenuTrigger}) parentTrigger!: MenuTrigger;\n+           @ViewChild('childTrigger', {read: MenuTrigger}) childTrigger!: MenuTrigger;\n+           @ViewChild('childMenu', {read: Menu}) childMenu!: Menu;\n+         }\n+\n+         TestBed.configureTestingModule({declarations: [App, MenuTrigger, Menu]});\n+         const fixture = TestBed.createComponent(App);\n+         fixture.detectChanges();\n+\n+         fixture.componentInstance.grandparentTrigger.open(\n+             Injector.create({providers: [{provide: token, useValue: 'hello'}]}));\n+         fixture.detectChanges();\n+\n+         fixture.componentInstance.parentTrigger.open(Injector.create({providers: []}));\n+         fixture.detectChanges();\n+\n+         fixture.componentInstance.childTrigger.open(undefined);\n+         fixture.detectChanges();\n+\n+         expect(fixture.componentInstance.childMenu.tokenValue).toBe('hello');\n+       });\n+\n+    it('should resolve value from node injector if it is lower than embedded view injector', () => {\n+      @Directive({selector: 'menu'})\n+      class Menu {\n+        constructor(@Inject(token) public tokenValue: string) {}\n+      }\n+\n+      @Component({\n+        selector: 'wrapper',\n+        providers: [{provide: token, useValue: 'hello from wrapper'}],\n+        template: `\n+          <menu-trigger [triggerFor]=\"menuTemplate\"></menu-trigger>\n+          <ng-template #menuTemplate>\n+            <menu></menu>\n+          </ng-template>\n+        `\n+      })\n+      class Wrapper {\n+        @ViewChild(MenuTrigger) trigger!: MenuTrigger;\n+        @ViewChild(Menu) menu!: Menu;\n+      }\n+\n+      @Component({\n+        template: `\n+          <menu-trigger [triggerFor]=\"menuTemplate\"></menu-trigger>\n+          <ng-template #menuTemplate>\n+            <wrapper></wrapper>\n+          </ng-template>\n+        `\n+      })\n+      class App {\n+        @ViewChild(MenuTrigger) trigger!: MenuTrigger;\n+        @ViewChild(Wrapper) wrapper!: Wrapper;\n+      }\n+\n+      TestBed.configureTestingModule({declarations: [App, MenuTrigger, Menu, Wrapper]});\n+      const fixture = TestBed.createComponent(App);\n+      fixture.detectChanges();\n+\n+      fixture.componentInstance.trigger.open(\n+          Injector.create({providers: [{provide: token, useValue: 'hello from injector'}]}));\n+      fixture.detectChanges();\n+\n+      fixture.componentInstance.wrapper.trigger.open(undefined);\n+      fixture.detectChanges();\n+\n+      expect(fixture.componentInstance.wrapper.menu.tokenValue).toBe('hello from wrapper');\n+    });\n+\n+    it('should be able to inject a value provided at the module level', () => {\n+      @Directive({selector: 'menu'})\n+      class Menu {\n+        constructor(@Inject(token) public tokenValue: string) {}\n+      }\n+\n+      @Component({\n+        template: `\n+          <menu-trigger [triggerFor]=\"menuTemplate\"></menu-trigger>\n+          <ng-template #menuTemplate>\n+            <menu></menu>\n+          </ng-template>\n+      `\n+      })\n+      class App {\n+        @ViewChild(MenuTrigger) trigger!: MenuTrigger;\n+        @ViewChild(Menu) menu!: Menu;\n+      }\n+\n+      @NgModule({\n+        declarations: [App, MenuTrigger, Menu],\n+        exports: [App, MenuTrigger, Menu],\n+        providers: [{provide: token, useValue: 'hello'}]\n+      })\n+      class Module {\n+      }\n+\n+      TestBed.configureTestingModule({imports: [Module]});\n+      const injector = Injector.create({providers: []});\n+      const fixture = TestBed.createComponent(App);\n+      fixture.detectChanges();\n+\n+      fixture.componentInstance.trigger.open(injector);\n+      fixture.detectChanges();\n+\n+      expect(fixture.componentInstance.menu.tokenValue).toBe('hello');\n+    });\n+\n+    it('should have value from custom injector take precedence over module injector', () => {\n+      @Directive({selector: 'menu'})\n+      class Menu {\n+        constructor(@Inject(token) public tokenValue: string) {}\n+      }\n+\n+      @Component({\n+        template: `\n+          <menu-trigger [triggerFor]=\"menuTemplate\"></menu-trigger>\n+          <ng-template #menuTemplate>\n+            <menu></menu>\n+          </ng-template>\n+      `\n+      })\n+      class App {\n+        @ViewChild(MenuTrigger) trigger!: MenuTrigger;\n+        @ViewChild(Menu) menu!: Menu;\n+      }\n+\n+      @NgModule({\n+        declarations: [App, MenuTrigger, Menu],\n+        exports: [App, MenuTrigger, Menu],\n+        providers: [{provide: token, useValue: 'hello from module'}]\n+      })\n+      class Module {\n+      }\n+\n+      TestBed.configureTestingModule({imports: [Module]});\n+      const injector =\n+          Injector.create({providers: [{provide: token, useValue: 'hello from injector'}]});\n+      const fixture = TestBed.createComponent(App);\n+      fixture.detectChanges();\n+\n+      fixture.componentInstance.trigger.open(injector);\n+      fixture.detectChanges();\n+\n+      expect(fixture.componentInstance.menu.tokenValue).toBe('hello from injector');\n+    });\n+\n+    it('should be able to inject built-in tokens when a custom injector is provided', () => {\n+      @Directive({selector: 'menu'})\n+      class Menu {\n+        constructor(public elementRef: ElementRef, public changeDetectorRef: ChangeDetectorRef) {}\n+      }\n+\n+      @Component({\n+        template: `\n+          <menu-trigger [triggerFor]=\"menuTemplate\"></menu-trigger>\n+          <ng-template #menuTemplate>\n+            <menu></menu>\n+          </ng-template>\n+      `\n+      })\n+      class App {\n+        @ViewChild(MenuTrigger) trigger!: MenuTrigger;\n+        @ViewChild(Menu) menu!: Menu;\n+      }\n+\n+      TestBed.configureTestingModule({declarations: [App, MenuTrigger, Menu]});\n+      const injector = Injector.create({providers: []});\n+      const fixture = TestBed.createComponent(App);\n+      fixture.detectChanges();\n+\n+      fixture.componentInstance.trigger.open(injector);\n+      fixture.detectChanges();\n+\n+      expect(fixture.componentInstance.menu.elementRef.nativeElement)\n+          .toBe(fixture.nativeElement.querySelector('menu'));\n+      expect(fixture.componentInstance.menu.changeDetectorRef).toBeTruthy();\n+    });\n+\n+    it('should have value from parent component injector take precedence over module injector',\n+       () => {\n+         @Directive({selector: 'menu'})\n+         class Menu {\n+           constructor(@Inject(token) public tokenValue: string) {}\n+         }\n+\n+         @Component({\n+           template: `\n+            <menu-trigger [triggerFor]=\"menuTemplate\"></menu-trigger>\n+            <ng-template #menuTemplate>\n+              <menu></menu>\n+            </ng-template>\n+          `,\n+           providers: [{provide: token, useValue: 'hello from parent'}]\n+         })\n+         class App {\n+           @ViewChild(MenuTrigger) trigger!: MenuTrigger;\n+           @ViewChild(Menu) menu!: Menu;\n+         }\n+\n+         @NgModule({\n+           declarations: [App, MenuTrigger, Menu],\n+           exports: [App, MenuTrigger, Menu],\n+           providers: [{provide: token, useValue: 'hello from module'}]\n+         })\n+         class Module {\n+         }\n+\n+         TestBed.configureTestingModule({imports: [Module]});\n+         const injector = Injector.create({providers: []});\n+         const fixture = TestBed.createComponent(App);\n+         fixture.detectChanges();\n+\n+         fixture.componentInstance.trigger.open(injector);\n+         fixture.detectChanges();\n+\n+         expect(fixture.componentInstance.menu.tokenValue).toBe('hello from parent');\n+       });\n+\n+    it('should be able to inject an injectable with dependencies', () => {\n+      @Injectable()\n+      class Greeter {\n+        constructor(@Inject(token) private tokenValue: string) {}\n+\n+        greet() {\n+          return `hello from ${this.tokenValue}`;\n+        }\n+      }\n+\n+      @Directive({selector: 'menu'})\n+      class Menu {\n+        constructor(public greeter: Greeter) {}\n+      }\n+\n+      @Component({\n+        template: `\n+          <menu-trigger [triggerFor]=\"menuTemplate\"></menu-trigger>\n+          <ng-template #menuTemplate>\n+            <menu></menu>\n+          </ng-template>\n+      `\n+      })\n+      class App {\n+        @ViewChild(MenuTrigger) trigger!: MenuTrigger;\n+        @ViewChild(Menu) menu!: Menu;\n+      }\n+\n+      @NgModule({\n+        declarations: [App, MenuTrigger, Menu],\n+        exports: [App, MenuTrigger, Menu],\n+        providers: [{provide: token, useValue: 'module'}]\n+      })\n+      class Module {\n+      }\n+\n+      TestBed.configureTestingModule({imports: [Module]});\n+      const injector = Injector.create({\n+        providers: [\n+          {provide: Greeter, useClass: Greeter},\n+          {provide: token, useValue: 'injector'},\n+        ]\n+      });\n+      const fixture = TestBed.createComponent(App);\n+      fixture.detectChanges();\n+\n+      fixture.componentInstance.trigger.open(injector);\n+      fixture.detectChanges();\n+\n+      expect(fixture.componentInstance.menu.greeter.greet()).toBe('hello from injector');\n+    });\n+\n+    it('should be able to inject a value from a grandparent component when a custom injector is provided',\n+       () => {\n+         @Directive({selector: 'menu'})\n+         class Menu {\n+           constructor(@Inject(token) public tokenValue: string) {}\n+         }\n+\n+         @Component({\n+           selector: 'parent',\n+           template: `\n+            <menu-trigger [triggerFor]=\"menuTemplate\"></menu-trigger>\n+            <ng-template #menuTemplate>\n+              <menu></menu>\n+            </ng-template>\n+           `\n+         })\n+         class Parent {\n+           @ViewChild(MenuTrigger) trigger!: MenuTrigger;\n+           @ViewChild(Menu) menu!: Menu;\n+         }\n+\n+         @Component({\n+           template: '<parent></parent>',\n+           providers: [{provide: token, useValue: 'hello from grandparent'}]\n+         })\n+         class GrandParent {\n+           @ViewChild(Parent) parent!: Parent;\n+         }\n+\n+         TestBed.configureTestingModule({declarations: [GrandParent, Parent, MenuTrigger, Menu]});\n+         const injector = Injector.create({providers: []});\n+         const fixture = TestBed.createComponent(GrandParent);\n+         fixture.detectChanges();\n+\n+         fixture.componentInstance.parent.trigger.open(injector);\n+         fixture.detectChanges();\n+\n+         expect(fixture.componentInstance.parent.menu.tokenValue).toBe('hello from grandparent');\n+       });\n+\n+    it('should be able to use a custom injector when created through TemplateRef', () => {\n+      let injectedValue: string|undefined;\n+\n+      @Directive({selector: 'menu'})\n+      class Menu {\n+        constructor(@Inject(token) tokenValue: string) {\n+          injectedValue = tokenValue;\n+        }\n+      }\n+\n+      @Component({\n+        template: `\n+          <ng-template>\n+            <menu></menu>\n+          </ng-template>\n+        `\n+      })\n+      class App {\n+        @ViewChild(TemplateRef) template!: TemplateRef<unknown>;\n+      }\n+\n+      @NgModule({\n+        declarations: [App, Menu],\n+        exports: [App, Menu],\n+        providers: [{provide: token, useValue: 'hello from module'}]\n+      })\n+      class Module {\n+      }\n+\n+      TestBed.configureTestingModule({imports: [Module]});\n+      const injector =\n+          Injector.create({providers: [{provide: token, useValue: 'hello from injector'}]});\n+      const fixture = TestBed.createComponent(App);\n+      fixture.detectChanges();\n+\n+      fixture.componentInstance.template.createEmbeddedView({}, injector);\n+      fixture.detectChanges();\n+\n+      expect(injectedValue).toBe('hello from injector');\n+    });\n+\n+    it('should use a custom injector when the view is created outside of the declaration view',\n+       () => {\n+         const declarerToken = new InjectionToken<string>('declarerToken');\n+         const creatorToken = new InjectionToken<string>('creatorToken');\n+\n+         @Directive({selector: 'menu'})\n+         class Menu {\n+           constructor(\n+               @Inject(token) public tokenValue: string,\n+               @Optional() @Inject(declarerToken) public declarerTokenValue: string,\n+               @Optional() @Inject(creatorToken) public creatorTokenValue: string) {}\n+         }\n+\n+         @Component({\n+           selector: 'declarer',\n+           template: '<ng-template><menu></menu></ng-template>',\n+           providers: [{provide: declarerToken, useValue: 'hello from declarer'}]\n+         })\n+         class Declarer {\n+           @ViewChild(Menu) menu!: Menu;\n+           @ViewChild(TemplateRef) template!: TemplateRef<unknown>;\n+         }\n+\n+         @Component({\n+           selector: 'creator',\n+           template: '<menu-trigger></menu-trigger>',\n+           providers: [{provide: creatorToken, useValue: 'hello from creator'}]\n+         })\n+         class Creator {\n+           @ViewChild(MenuTrigger) trigger!: MenuTrigger;\n+         }\n+\n+         @Component({\n+           template: `\n+              <declarer></declarer>\n+              <creator></creator>\n+            `\n+         })\n+         class App {\n+           @ViewChild(Declarer) declarer!: Declarer;\n+           @ViewChild(Creator) creator!: Creator;\n+         }\n+\n+         TestBed.configureTestingModule(\n+             {declarations: [App, MenuTrigger, Menu, Declarer, Creator]});\n+         const injector = Injector.create({providers: [{provide: token, useValue: 'hello'}]});\n+         const fixture = TestBed.createComponent(App);\n+         fixture.detectChanges();\n+         const {declarer, creator} = fixture.componentInstance;\n+\n+         creator.trigger.menu = declarer.template;\n+         creator.trigger.open(injector);\n+         fixture.detectChanges();\n+\n+         expect(declarer.menu.tokenValue).toBe('hello');\n+         expect(declarer.menu.declarerTokenValue).toBe('hello from declarer');\n+         expect(declarer.menu.creatorTokenValue).toBeNull();\n+       });\n+\n+    it('should behave consistently with `createComponent` when token is shadowed in node injector',\n+       () => {\n+         @Directive({selector: 'trigger'})\n+         class Trigger {\n+           constructor(public viewContainerRef: ViewContainerRef) {}\n+         }\n+\n+         @Directive({selector: 'overlay'})\n+         class Overlay {\n+           constructor(@Inject(token) public tokenValue: string) {}\n+         }\n+\n+         @Component({\n+           selector: 'overlay-host',\n+           template: '<overlay></overlay>',\n+           providers: [{provide: token, useValue: 'hello from parent'}],\n+         })\n+         class OverlayHost {\n+           @ViewChild(Overlay) overlay!: Overlay;\n+         }\n+\n+         @Component({\n+           selector: 'wrapper',\n+           template: '<ng-content></ng-content>',\n+           providers: [{provide: token, useValue: 'hello from parent'}],\n+         })\n+         class Wrapper {\n+         }\n+\n+         @Component({\n+           template: `\n+              <trigger></trigger>\n+\n+              <wrapper>\n+                <ng-template #template>\n+                  <overlay></overlay>\n+                </ng-template>\n+              </wrapper>\n+            `\n+         })\n+         class App {\n+           @ViewChild(Trigger) trigger!: Trigger;\n+           @ViewChild('template', {read: TemplateRef}) template!: TemplateRef<any>;\n+           @ViewChild(Overlay) overlayInTemplate!: Overlay;\n+\n+           openFromTemplate(injector: Injector) {\n+             this.trigger.viewContainerRef.createEmbeddedView(this.template, null, {injector});\n+           }\n+\n+           openFromComponent(injector: Injector) {\n+             return this.trigger.viewContainerRef.createComponent(OverlayHost, {injector});\n+           }\n+         }\n+\n+         TestBed.configureTestingModule(\n+             {declarations: [App, Trigger, Overlay, OverlayHost, Wrapper]});\n+         const fixture = TestBed.createComponent(App);\n+         fixture.detectChanges();\n+         const providers = [{provide: token, useValue: 'hello from custom injector'}];\n+\n+         fixture.componentInstance.openFromTemplate(Injector.create({providers}));\n+         fixture.detectChanges();\n+\n+         const componentRef =\n+             fixture.componentInstance.openFromComponent(Injector.create({providers}));\n+         fixture.detectChanges();\n+\n+         // The node injector is expected to take precedence over the provided injector, despite\n+         // technically being higher in the tree, because the custom one is provided as a module\n+         // injector. This is consistent with how `createComponent` has always worked and avoids\n+         // ambiguity as to whether the provided injector should be in the declaration or insertion\n+         // node injector tree.\n+         expect(fixture.componentInstance.overlayInTemplate.tokenValue).toBe('hello from parent');\n+         expect(componentRef.instance.overlay.tokenValue).toBe('hello from parent');\n+       });\n+  });\n });"
        },
        {
            "sha": "81664ac20b5b904c72578bff8987d113c758b33c",
            "filename": "packages/core/test/bundling/forms_reactive/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Ftest%2Fbundling%2Fforms_reactive%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Ftest%2Fbundling%2Fforms_reactive%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fforms_reactive%2Fbundle.golden_symbols.json?ref=b49ffcd50e46ca7907ee2049f6cade8e080f5980",
            "patch": "@@ -77,6 +77,9 @@\n   {\n     \"name\": \"COMPOSITION_BUFFER_MODE\"\n   },\n+  {\n+    \"name\": \"ChainedInjector\"\n+  },\n   {\n     \"name\": \"ChangeDetectionStrategy\"\n   },"
        },
        {
            "sha": "d0ae40574d889308aecc5dd00fa36f6c8cecb659",
            "filename": "packages/core/test/bundling/forms_template_driven/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Ftest%2Fbundling%2Fforms_template_driven%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Ftest%2Fbundling%2Fforms_template_driven%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fforms_template_driven%2Fbundle.golden_symbols.json?ref=b49ffcd50e46ca7907ee2049f6cade8e080f5980",
            "patch": "@@ -77,6 +77,9 @@\n   {\n     \"name\": \"COMPOSITION_BUFFER_MODE\"\n   },\n+  {\n+    \"name\": \"ChainedInjector\"\n+  },\n   {\n     \"name\": \"ChangeDetectionStrategy\"\n   },"
        },
        {
            "sha": "788d072262c71ac653df050358805a33e4dc4a39",
            "filename": "packages/core/test/bundling/router/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json?ref=b49ffcd50e46ca7907ee2049f6cade8e080f5980",
            "patch": "@@ -92,6 +92,9 @@\n   {\n     \"name\": \"CatchSubscriber\"\n   },\n+  {\n+    \"name\": \"ChainedInjector\"\n+  },\n   {\n     \"name\": \"ChangeDetectionStrategy\"\n   },"
        },
        {
            "sha": "a530f251dedad3817e67ad40cc541a6e5139a790",
            "filename": "packages/core/test/bundling/todo/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Ftest%2Fbundling%2Ftodo%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/b49ffcd50e46ca7907ee2049f6cade8e080f5980/packages%2Fcore%2Ftest%2Fbundling%2Ftodo%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Ftodo%2Fbundle.golden_symbols.json?ref=b49ffcd50e46ca7907ee2049f6cade8e080f5980",
            "patch": "@@ -2,6 +2,9 @@\n   {\n     \"name\": \"CLEAN_PROMISE\"\n   },\n+  {\n+    \"name\": \"ChainedInjector\"\n+  },\n   {\n     \"name\": \"ChangeDetectionStrategy\"\n   },"
        }
    ],
    "stats": {
        "total": 750,
        "additions": 716,
        "deletions": 34
    }
}