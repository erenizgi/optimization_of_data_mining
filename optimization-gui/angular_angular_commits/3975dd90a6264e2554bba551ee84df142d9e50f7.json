{
    "author": "atscott",
    "message": "feat(language-service): Add getDefinitionAndBoundSpan (go to definition) (#39101)\n\nThis commit adds the implementation for providing \"go to definition\"\nfunctionality in the Ivy Language Service.\n\nPR Close #39101",
    "sha": "3975dd90a6264e2554bba551ee84df142d9e50f7",
    "files": [
        {
            "sha": "edd736a617563b86761da483d602135493fcfd0e",
            "filename": "packages/language-service/ivy/definitions.ts",
            "status": "added",
            "additions": 107,
            "deletions": 0,
            "changes": 107,
            "blob_url": "https://github.com/angular/angular/blob/3975dd90a6264e2554bba551ee84df142d9e50f7/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "raw_url": "https://github.com/angular/angular/raw/3975dd90a6264e2554bba551ee84df142d9e50f7/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts?ref=3975dd90a6264e2554bba551ee84df142d9e50f7",
            "patch": "@@ -0,0 +1,107 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {AST, TmplAstNode} from '@angular/compiler';\n+import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n+import {ShimLocation, Symbol, SymbolKind} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import * as ts from 'typescript';\n+\n+import {findNodeAtPosition} from './hybrid_visitor';\n+import {getTemplateInfoAtPosition, getTextSpanOfNode, isDollarEvent, toTextSpan} from './utils';\n+\n+export class DefinitionBuilder {\n+  constructor(private readonly tsLS: ts.LanguageService, private readonly compiler: NgCompiler) {}\n+\n+  // TODO(atscott): getTypeDefinitionAtPosition\n+\n+  getDefinitionAndBoundSpan(fileName: string, position: number): ts.DefinitionInfoAndBoundSpan\n+      |undefined {\n+    const templateInfo = getTemplateInfoAtPosition(fileName, position, this.compiler);\n+    if (templateInfo === undefined) {\n+      return undefined;\n+    }\n+    const {template, component} = templateInfo;\n+\n+    const node = findNodeAtPosition(template, position);\n+    // The `$event` of event handlers would point to the $event parameter in the shim file, as in\n+    // `_outputHelper(_t3[\"x\"]).subscribe(function ($event): any { $event }) ;`\n+    // If we wanted to return something for this, it would be more appropriate for something like\n+    // `getTypeDefinition`.\n+    if (node === undefined || isDollarEvent(node)) {\n+      return undefined;\n+    }\n+\n+    const symbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(node, component);\n+    if (symbol === null) {\n+      return undefined;\n+    }\n+\n+    const definitions = this.getDefinitionsForSymbol(symbol, node);\n+    return {definitions, textSpan: getTextSpanOfNode(node)};\n+  }\n+\n+  private getDefinitionsForSymbol(symbol: Symbol, node: TmplAstNode|AST):\n+      readonly ts.DefinitionInfo[]|undefined {\n+    switch (symbol.kind) {\n+      case SymbolKind.Directive:\n+      case SymbolKind.Element:\n+      case SymbolKind.Template:\n+      case SymbolKind.DomBinding:\n+        // `Template` and `Element` types should not return anything because their \"definitions\" are\n+        // the template locations themselves. Instead, `getTypeDefinitionAtPosition` should return\n+        // the directive class / native element interface. `Directive` would have similar reasoning,\n+        // though the `TemplateTypeChecker` only returns it as a list on `DomBinding`, `Element`, or\n+        // `Template` so it's really only here for switch case completeness (it wouldn't ever appear\n+        // here).\n+        //\n+        // `DomBinding` also does not return anything because the value assignment is internal to\n+        // the TCB. Again, `getTypeDefinitionAtPosition` could return a possible directive the\n+        // attribute binds to or the property in the native interface.\n+        return [];\n+      case SymbolKind.Input:\n+      case SymbolKind.Output:\n+        return this.getDefinitionsForSymbols(symbol.bindings);\n+      case SymbolKind.Variable:\n+      case SymbolKind.Reference: {\n+        const definitions: ts.DefinitionInfo[] = [];\n+        if (symbol.declaration !== node) {\n+          definitions.push({\n+            name: symbol.declaration.name,\n+            containerName: '',\n+            containerKind: ts.ScriptElementKind.unknown,\n+            kind: ts.ScriptElementKind.variableElement,\n+            textSpan: getTextSpanOfNode(symbol.declaration),\n+            contextSpan: toTextSpan(symbol.declaration.sourceSpan),\n+            fileName: symbol.declaration.sourceSpan.start.file.url,\n+          });\n+        }\n+        if (symbol.kind === SymbolKind.Variable) {\n+          definitions.push(...this.getDefinitionInfos(symbol.shimLocation));\n+        }\n+        return definitions;\n+      }\n+      case SymbolKind.Expression: {\n+        const {shimLocation} = symbol;\n+        return this.getDefinitionInfos(shimLocation);\n+      }\n+    }\n+  }\n+\n+  private getDefinitionsForSymbols(symbols: {shimLocation: ShimLocation}[]) {\n+    const definitions: ts.DefinitionInfo[] = [];\n+    for (const {shimLocation} of symbols) {\n+      definitions.push(...this.getDefinitionInfos(shimLocation));\n+    }\n+    return definitions;\n+  }\n+\n+  private getDefinitionInfos({shimPath, positionInShimFile}: ShimLocation):\n+      readonly ts.DefinitionInfo[] {\n+    return this.tsLS.getDefinitionAtPosition(shimPath, positionInShimFile) ?? [];\n+  }\n+}"
        },
        {
            "sha": "ba7ceb7c2da63e77b7988185021552ded7f87319",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/3975dd90a6264e2554bba551ee84df142d9e50f7/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/3975dd90a6264e2554bba551ee84df142d9e50f7/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=3975dd90a6264e2554bba551ee84df142d9e50f7",
            "patch": "@@ -16,6 +16,7 @@ import {TypeCheckShimGenerator} from '@angular/compiler-cli/src/ngtsc/typecheck'\n import {OptimizeFor, TypeCheckingProgramStrategy} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript/lib/tsserverlibrary';\n \n+import {DefinitionBuilder} from './definitions';\n import {QuickInfoBuilder} from './quick_info';\n \n export class LanguageService {\n@@ -47,6 +48,13 @@ export class LanguageService {\n     throw new Error('Ivy LS currently does not support external template');\n   }\n \n+  getDefinitionAndBoundSpan(fileName: string, position: number): ts.DefinitionInfoAndBoundSpan\n+      |undefined {\n+    const program = this.strategy.getProgram();\n+    const compiler = this.createCompiler(program);\n+    return new DefinitionBuilder(this.tsLS, compiler).getDefinitionAndBoundSpan(fileName, position);\n+  }\n+\n   getQuickInfoAtPosition(fileName: string, position: number): ts.QuickInfo|undefined {\n     const program = this.strategy.getProgram();\n     const compiler = this.createCompiler(program);"
        },
        {
            "sha": "7dc8afe88c67cd8cb95ff20e22ecf6f6e68d4393",
            "filename": "packages/language-service/ivy/test/definitions_spec.ts",
            "status": "added",
            "additions": 420,
            "deletions": 0,
            "changes": 420,
            "blob_url": "https://github.com/angular/angular/blob/3975dd90a6264e2554bba551ee84df142d9e50f7/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/3975dd90a6264e2554bba551ee84df142d9e50f7/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts?ref=3975dd90a6264e2554bba551ee84df142d9e50f7",
            "patch": "@@ -0,0 +1,420 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript/lib/tsserverlibrary';\n+\n+import {LanguageService} from '../language_service';\n+\n+import {APP_COMPONENT, setup} from './mock_host';\n+\n+describe('definitions', () => {\n+  const {project, service, tsLS} = setup();\n+  const ngLS = new LanguageService(project, tsLS);\n+\n+  beforeEach(() => {\n+    service.reset();\n+  });\n+\n+  describe('elements', () => {\n+    it('should return nothing for native elements', () => {\n+      const {position} = service.overwriteInlineTemplate(APP_COMPONENT, `<butt¦on></button>`);\n+      const definitionAndBoundSpan = ngLS.getDefinitionAndBoundSpan(APP_COMPONENT, position);\n+      // The \"definition\" is this location itself so we should return nothing.\n+      // getTypeDefinitionAtPosition would return the HTMLButtonElement interface.\n+      expect(definitionAndBoundSpan!.definitions).toEqual([]);\n+    });\n+  });\n+\n+  describe('templates', () => {\n+    it('should return no definitions for ng-templates', () => {\n+      const {position} =\n+          service.overwriteInlineTemplate(APP_COMPONENT, `<ng-templ¦ate></ng-template>`);\n+      const definitionAndBoundSpan = ngLS.getDefinitionAndBoundSpan(APP_COMPONENT, position);\n+      expect(definitionAndBoundSpan!.definitions).toEqual([]);\n+    });\n+  });\n+\n+  describe('directives', () => {\n+    it('should work for directives', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div string-model¦></div>`,\n+        expectedSpanText: 'string-model',\n+      });\n+      expect(definitions).toEqual([]);\n+    });\n+\n+    it('should work for components', () => {\n+      const templateOverride = `\n+          <t¦est-comp>\n+            <div>some stuff in the middle</div>\n+          </test-comp>`;\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride,\n+        expectedSpanText: templateOverride.replace('¦', '').trim(),\n+      });\n+      expect(definitions).toEqual([]);\n+    });\n+\n+    it('should not return anything for structural directives where the key does not map to a binding',\n+       () => {\n+         const definitions = getDefinitionsAndAssertBoundSpan({\n+           templateOverride: `<div *¦ngFor=\"let item of heroes\"></div>`,\n+           expectedSpanText: 'ngFor',\n+         });\n+         expect(definitions).toEqual([]);\n+       });\n+\n+    it('should return binding for structural directive where key maps to a binding', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div *ng¦If=\"anyValue\"></div>`,\n+        expectedSpanText: 'ngIf',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('ngIf');\n+      expect(def.contextSpan).toEqual('set ngIf(condition: T);');\n+    });\n+\n+    it('should work for directives with compound selectors', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<ng-template ngF¦or let-item [ngForOf]=\"items\">{{item}}</ng-template>`,\n+        expectedSpanText: 'ngFor',\n+      });\n+      expect(definitions).toEqual([]);\n+    });\n+  });\n+\n+  describe('bindings', () => {\n+    describe('inputs', () => {\n+      it('should work for input providers', () => {\n+        const definitions = getDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<test-comp [tcN¦ame]=\"name\"></test-comp>`,\n+          expectedSpanText: 'tcName',\n+        });\n+        expect(definitions!.length).toEqual(1);\n+\n+        const [def] = definitions;\n+        expect(def.textSpan).toEqual('name');\n+        expect(def.contextSpan).toEqual(`@Input('tcName') name = 'test';`);\n+      });\n+\n+      it('should work for structural directive inputs ngForTrackBy', () => {\n+        const definitions = getDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<div *ngFor=\"let item of heroes; tr¦ackBy: test;\"></div>`,\n+          expectedSpanText: 'trackBy',\n+        });\n+        expect(definitions!.length).toEqual(2);\n+\n+        const [setterDef, getterDef] = definitions;\n+        expect(setterDef.fileName).toContain('ng_for_of.d.ts');\n+        expect(setterDef.textSpan).toEqual('ngForTrackBy');\n+        expect(setterDef.contextSpan).toEqual('set ngForTrackBy(fn: TrackByFunction<T>);');\n+        expect(getterDef.textSpan).toEqual('ngForTrackBy');\n+        expect(getterDef.contextSpan).toEqual('get ngForTrackBy(): TrackByFunction<T>;');\n+      });\n+\n+      it('should work for structural directive inputs ngForOf', () => {\n+        const definitions = getDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<div *ngFor=\"let item o¦f heroes\"></div>`,\n+          expectedSpanText: 'of',\n+        });\n+        expect(definitions!.length).toEqual(1);\n+\n+        const [def] = definitions;\n+        expect(def.textSpan).toEqual('ngForOf');\n+        expect(def.contextSpan)\n+            .toEqual('set ngForOf(ngForOf: U & NgIterable<T> | undefined | null);');\n+      });\n+\n+      it('should work for two-way binding providers', () => {\n+        const definitions = getDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<test-comp string-model [(mo¦del)]=\"title\"></test-comp>`,\n+          expectedSpanText: 'model',\n+        });\n+        // TODO(atscott): This should really return 2 definitions, 1 for the input and 1 for the\n+        // output.\n+        //  The TemplateTypeChecker also only returns the first match in the TCB for a given\n+        //  sourceSpan so even if we also requested the TmplAstBoundEvent, we'd still get back the\n+        //  symbol for the\n+        //  @Input because the input appears first in the TCB and they have the same sourceSpan.\n+        expect(definitions!.length).toEqual(1);\n+\n+        const [def] = definitions;\n+        expect(def.textSpan).toEqual('model');\n+        expect(def.contextSpan).toEqual(`@Input() model: string = 'model';`);\n+      });\n+    });\n+\n+    describe('outputs', () => {\n+      it('should work for event providers', () => {\n+        const definitions = getDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<test-comp (te¦st)=\"myClick($event)\"></test-comp>`,\n+          expectedSpanText: '(test)=\"myClick($event)\"',\n+        });\n+        expect(definitions!.length).toEqual(1);\n+\n+        const [def] = definitions;\n+        expect(def.textSpan).toEqual('testEvent');\n+        expect(def.contextSpan).toEqual('@Output(\\'test\\') testEvent = new EventEmitter();');\n+      });\n+\n+      it('should return nothing for $event from EventEmitter', () => {\n+        const {position} = service.overwriteInlineTemplate(\n+            APP_COMPONENT, `<div string-model (modelChange)=\"myClick($e¦vent)\"></div>`);\n+        const definitionAndBoundSpan = ngLS.getDefinitionAndBoundSpan(APP_COMPONENT, position);\n+        expect(definitionAndBoundSpan).toBeUndefined();\n+      });\n+    });\n+  });\n+\n+  describe('references', () => {\n+    it('should work for element reference declarations', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div #cha¦rt></div>{{chart}}`,\n+        expectedSpanText: '#chart',\n+      });\n+      // We're already at the definition, so nothing is returned\n+      expect(definitions).toEqual([]);\n+    });\n+\n+    it('should work for element reference uses', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div #chart></div>{{char¦t}}`,\n+        expectedSpanText: 'chart',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [varDef] = definitions;\n+      expect(varDef.textSpan).toEqual('#chart');\n+    });\n+  });\n+\n+  describe('variables', () => {\n+    it('should work for array members', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div *ngFor=\"let hero of heroes\">{{her¦o}}</div>`,\n+        expectedSpanText: 'hero',\n+      });\n+      expect(definitions!.length).toEqual(2);\n+\n+      const [templateDeclarationDef, contextDef] = definitions;\n+      expect(templateDeclarationDef.textSpan).toEqual('hero');\n+      // `$implicit` is from the `NgForOfContext`:\n+      // https://github.com/angular/angular/blob/89c5255b8ca59eed27ede9e1fad69857ab0c6f4f/packages/common/src/directives/ng_for_of.ts#L15\n+      expect(contextDef.textSpan).toEqual('$implicit');\n+      expect(contextDef.contextSpan).toContain('$implicit: T;');\n+    });\n+  });\n+\n+  describe('pipes', () => {\n+    it('should work for pipes', () => {\n+      const templateOverride = `<p>The hero's birthday is {{birthday | da¦te: \"MM/dd/yy\"}}</p>`;\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride,\n+        expectedSpanText: 'date',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('transform');\n+      expect(def.contextSpan).toContain('transform(value: Date | string | number, ');\n+    });\n+  });\n+\n+  describe('expressions', () => {\n+    it('should find members in a text interpolation', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div>{{ tit¦le }}</div>`,\n+        expectedSpanText: 'title',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('title');\n+      expect(def.contextSpan).toEqual(`title = 'Tour of Heroes';`);\n+    });\n+\n+    it('should work for accessed property reads', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div>{{title.len¦gth}}</div>`,\n+        expectedSpanText: 'length',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('length');\n+      expect(def.contextSpan).toEqual('readonly length: number;');\n+    });\n+\n+    it('should find members in an attribute interpolation', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div string-model model=\"{{tit¦le}}\"></div>`,\n+        expectedSpanText: 'title',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('title');\n+      expect(def.contextSpan).toEqual(`title = 'Tour of Heroes';`);\n+    });\n+\n+    it('should find members of input binding', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<test-comp [tcName]=\"ti¦tle\"></test-comp>`,\n+        expectedSpanText: 'title',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('title');\n+      expect(def.contextSpan).toEqual(`title = 'Tour of Heroes';`);\n+    });\n+\n+    it('should find members of event binding', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<test-comp (test)=\"ti¦tle=$event\"></test-comp>`,\n+        expectedSpanText: 'title',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('title');\n+      expect(def.contextSpan).toEqual(`title = 'Tour of Heroes';`);\n+    });\n+\n+    it('should work for method calls', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div (click)=\"setT¦itle('title')\"></div>`,\n+        expectedSpanText: 'setTitle',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('setTitle');\n+      expect(def.contextSpan).toContain('setTitle(newTitle: string)');\n+    });\n+\n+    it('should work for accessed properties in writes', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div (click)=\"hero.i¦d = 2\"></div>`,\n+        expectedSpanText: 'id',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('id');\n+      expect(def.contextSpan).toEqual('id: number;');\n+    });\n+\n+    it('should work for method call arguments', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div (click)=\"setTitle(hero.nam¦e)\"></div>`,\n+        expectedSpanText: 'name',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('name');\n+      expect(def.contextSpan).toEqual('name: string;');\n+    });\n+\n+    it('should find members of two-way binding', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<input [(ngModel)]=\"ti¦tle\" />`,\n+        expectedSpanText: 'title',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('title');\n+      expect(def.contextSpan).toEqual(`title = 'Tour of Heroes';`);\n+    });\n+\n+    it('should find members in a structural directive', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div *ngIf=\"anyV¦alue\"></div>`,\n+        expectedSpanText: 'anyValue',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('anyValue');\n+      expect(def.contextSpan).toEqual('anyValue: any;');\n+    });\n+\n+    it('should work for variables in structural directives', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div *ngFor=\"let item of heroes as her¦oes2; trackBy: test;\"></div>`,\n+        expectedSpanText: 'heroes2',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('ngForOf');\n+      expect(def.contextSpan).toEqual('ngForOf: U;');\n+    });\n+\n+    it('should work for uses of members in structural directives', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div *ngFor=\"let item of heroes as heroes2\">{{her¦oes2}}</div>`,\n+        expectedSpanText: 'heroes2',\n+      });\n+      expect(definitions!.length).toEqual(2);\n+\n+      const [def, contextDef] = definitions;\n+      expect(def.textSpan).toEqual('heroes2');\n+      expect(def.contextSpan).toEqual('of heroes as heroes2');\n+      expect(contextDef.textSpan).toEqual('ngForOf');\n+      expect(contextDef.contextSpan).toEqual('ngForOf: U;');\n+    });\n+\n+    it('should work for members in structural directives', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div *ngFor=\"let item of her¦oes; trackBy: test;\"></div>`,\n+        expectedSpanText: 'heroes',\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('heroes');\n+      expect(def.contextSpan).toEqual('heroes: Hero[] = [this.hero];');\n+    });\n+\n+    it('should return nothing for the $any() cast function', () => {\n+      const {position} =\n+          service.overwriteInlineTemplate(APP_COMPONENT, `<div>{{$an¦y(title)}}</div>`);\n+      const definitionAndBoundSpan = ngLS.getDefinitionAndBoundSpan(APP_COMPONENT, position);\n+      expect(definitionAndBoundSpan).toBeUndefined();\n+    });\n+  });\n+\n+  function getDefinitionsAndAssertBoundSpan(\n+      {templateOverride, expectedSpanText}: {templateOverride: string, expectedSpanText: string}):\n+      Array<{textSpan: string, contextSpan: string | undefined, fileName: string}> {\n+    const {position, text} = service.overwriteInlineTemplate(APP_COMPONENT, templateOverride);\n+    const definitionAndBoundSpan = ngLS.getDefinitionAndBoundSpan(APP_COMPONENT, position);\n+    expect(definitionAndBoundSpan).toBeTruthy();\n+    const {textSpan, definitions} = definitionAndBoundSpan!;\n+    expect(text.substring(textSpan.start, textSpan.start + textSpan.length))\n+        .toEqual(expectedSpanText);\n+    expect(definitions).toBeTruthy();\n+    return definitions!.map(d => humanizeDefinitionInfo(d));\n+  }\n+\n+  function humanizeDefinitionInfo(def: ts.DefinitionInfo) {\n+    const snapshot = service.getScriptInfo(def.fileName).getSnapshot();\n+    return {\n+      fileName: def.fileName,\n+      textSpan: snapshot.getText(def.textSpan.start, def.textSpan.start + def.textSpan.length),\n+      contextSpan: def.contextSpan ?\n+          snapshot.getText(def.contextSpan.start, def.contextSpan.start + def.contextSpan.length) :\n+          undefined,\n+    };\n+  }\n+});"
        },
        {
            "sha": "8a238431ea40c261bac695d95f855bb2f476680c",
            "filename": "packages/language-service/ivy/ts_plugin.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/3975dd90a6264e2554bba551ee84df142d9e50f7/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/3975dd90a6264e2554bba551ee84df142d9e50f7/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts?ref=3975dd90a6264e2554bba551ee84df142d9e50f7",
            "patch": "@@ -38,10 +38,22 @@ export function create(info: ts.server.PluginCreateInfo): ts.LanguageService {\n     }\n   }\n \n+  function getDefinitionAndBoundSpan(\n+      fileName: string, position: number): ts.DefinitionInfoAndBoundSpan|undefined {\n+    if (angularOnly) {\n+      return ngLS.getDefinitionAndBoundSpan(fileName, position);\n+    } else {\n+      // If TS could answer the query, then return that result. Otherwise, return from Angular LS.\n+      return tsLS.getDefinitionAndBoundSpan(fileName, position) ??\n+          ngLS.getDefinitionAndBoundSpan(fileName, position);\n+    }\n+  }\n+\n   return {\n     ...tsLS,\n     getSemanticDiagnostics,\n     getTypeDefinitionAtPosition,\n     getQuickInfoAtPosition,\n+    getDefinitionAndBoundSpan,\n   };\n }"
        },
        {
            "sha": "b7c9bdc0ef6062e66d157f019e5dc396b42d6a07",
            "filename": "packages/language-service/ivy/utils.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/3975dd90a6264e2554bba551ee84df142d9e50f7/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/3975dd90a6264e2554bba551ee84df142d9e50f7/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Futils.ts?ref=3975dd90a6264e2554bba551ee84df142d9e50f7",
            "patch": "@@ -226,3 +226,8 @@ export function filterAliasImports(displayParts: ts.SymbolDisplayPart[]): ts.Sym\n     return !aliasNameFollowedByDot && !dotPrecededByAlias;\n   });\n }\n+\n+export function isDollarEvent(n: t.Node|e.AST): n is e.PropertyRead {\n+  return n instanceof e.PropertyRead && n.name === '$event' &&\n+      n.receiver instanceof e.ImplicitReceiver;\n+}"
        }
    ],
    "stats": {
        "total": 552,
        "additions": 552,
        "deletions": 0
    }
}