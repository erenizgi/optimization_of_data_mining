{
    "author": "atscott",
    "message": "refactor(compiler): simplify visitor logic for attributes (#38899)\n\nThe logic for computing identifiers, specifically for bound attributes\ncan be simplified by using the value span of the binding rather than the\nsource span.\n\nPR Close #38899",
    "sha": "0c0c54d615f448c59d5cb9e98a375d098301a94b",
    "files": [
        {
            "sha": "e8ec2507edc4f3cfdedc21392d0394d2a7d56cb7",
            "filename": "packages/compiler-cli/src/ngtsc/indexer/src/template.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 25,
            "changes": 36,
            "blob_url": "https://github.com/angular/angular/blob/0c0c54d615f448c59d5cb9e98a375d098301a94b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Fsrc%2Ftemplate.ts",
            "raw_url": "https://github.com/angular/angular/raw/0c0c54d615f448c59d5cb9e98a375d098301a94b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Fsrc%2Ftemplate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Fsrc%2Ftemplate.ts?ref=0c0c54d615f448c59d5cb9e98a375d098301a94b",
            "patch": "@@ -97,15 +97,12 @@ class ExpressionVisitor extends RecursiveAstVisitor {\n       return;\n     }\n \n-    // Get the location of the identifier of real interest.\n-    // The compiler's expression parser records the location of some expressions in a manner not\n-    // useful to the indexer. For example, a `MethodCall` `foo(a, b)` will record the span of the\n-    // entire method call, but the indexer is interested only in the method identifier.\n-    const localExpression = this.expressionStr.substr(ast.span.start);\n-    if (!localExpression.includes(ast.name)) {\n-      throw new Error(`Impossible state: \"${ast.name}\" not found in \"${localExpression}\"`);\n+    // The source span of the requested AST starts at a location that is offset from the expression.\n+    const identifierStart = ast.sourceSpan.start - this.absoluteOffset;\n+    if (!this.expressionStr.substring(identifierStart).startsWith(ast.name)) {\n+      throw new Error(`Impossible state: \"${ast.name}\" not found in \"${\n+          this.expressionStr}\" at location ${identifierStart}`);\n     }\n-    const identifierStart = ast.span.start + localExpression.indexOf(ast.name);\n \n     // Join the relative position of the expression within a node with the absolute position\n     // of the node to get the absolute position of the expression in the source code.\n@@ -191,25 +188,14 @@ class TemplateVisitor extends TmplAstRecursiveVisitor {\n     this.visitAll(template.references);\n   }\n   visitBoundAttribute(attribute: TmplAstBoundAttribute) {\n-    // A BoundAttribute's value (the parent AST) may have subexpressions (children ASTs) that have\n-    // recorded spans extending past the recorded span of the parent. The most common example of\n-    // this is with `*ngFor`.\n-    // To resolve this, use the information on the BoundAttribute Template AST, which is always\n-    // correct, to determine locations of identifiers in the expression.\n-    //\n-    // TODO(ayazhafiz): Remove this when https://github.com/angular/angular/pull/31813 lands.\n-    const attributeSrc = attribute.sourceSpan.toString();\n-    const attributeAbsolutePosition = attribute.sourceSpan.start.offset;\n-\n-    // Skip the bytes of the attribute name so that there are no collisions between the attribute\n-    // name and expression identifier names later.\n-    const nameSkipOffet = attributeSrc.indexOf(attribute.name) + attribute.name.length;\n-    const expressionSrc = attributeSrc.substring(nameSkipOffet);\n-    const expressionAbsolutePosition = attributeAbsolutePosition + nameSkipOffet;\n+    // If the bound attribute has no value, it cannot have any identifiers in the value expression.\n+    if (attribute.valueSpan === undefined) {\n+      return;\n+    }\n \n     const identifiers = ExpressionVisitor.getIdentifiers(\n-        attribute.value, expressionSrc, expressionAbsolutePosition, this.boundTemplate,\n-        this.targetToIdentifier.bind(this));\n+        attribute.value, attribute.valueSpan.toString(), attribute.valueSpan.start.offset,\n+        this.boundTemplate, this.targetToIdentifier.bind(this));\n     identifiers.forEach(id => this.identifiers.add(id));\n   }\n   visitBoundEvent(attribute: TmplAstBoundEvent) {"
        },
        {
            "sha": "b7c0ff1153802d5e17e9fab68ab30228c2671114",
            "filename": "packages/compiler-cli/src/ngtsc/indexer/test/template_spec.ts",
            "status": "modified",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/angular/angular/blob/0c0c54d615f448c59d5cb9e98a375d098301a94b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Ftest%2Ftemplate_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/0c0c54d615f448c59d5cb9e98a375d098301a94b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Ftest%2Ftemplate_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Ftest%2Ftemplate_spec.ts?ref=0c0c54d615f448c59d5cb9e98a375d098301a94b",
            "patch": "@@ -124,6 +124,20 @@ runInEachFileSystem(() => {\n         });\n       });\n \n+      it('should handle bound attributes with no value', () => {\n+        const template = '<div [bar]></div>';\n+        const refs = getTemplateIdentifiers(bind(template));\n+\n+        const refArr = Array.from(refs);\n+        expect(refArr).toEqual([{\n+          name: 'div',\n+          kind: IdentifierKind.Element,\n+          span: new AbsoluteSourceSpan(1, 4),\n+          attributes: new Set(),\n+          usedDirectives: new Set(),\n+        }]);\n+      });\n+\n       it('should discover variables in bound attributes', () => {\n         const template = '<div #div [value]=\"div.innerText\"></div>';\n         const refs = getTemplateIdentifiers(bind(template));\n@@ -189,6 +203,33 @@ runInEachFileSystem(() => {\n           target: null,\n         });\n       });\n+\n+      it('should discover properties in template expressions and resist collisions', () => {\n+        const template = '<div *ngFor=\"let foo of (foos ? foos : foos)\"></div>';\n+        const refs = getTemplateIdentifiers(bind(template));\n+\n+        const refArr = Array.from(refs);\n+        expect(refArr).toEqual(jasmine.arrayContaining([\n+          {\n+            name: 'foos',\n+            kind: IdentifierKind.Property,\n+            span: new AbsoluteSourceSpan(25, 29),\n+            target: null,\n+          },\n+          {\n+            name: 'foos',\n+            kind: IdentifierKind.Property,\n+            span: new AbsoluteSourceSpan(32, 36),\n+            target: null,\n+          },\n+          {\n+            name: 'foos',\n+            kind: IdentifierKind.Property,\n+            span: new AbsoluteSourceSpan(39, 43),\n+            target: null,\n+          },\n+        ]));\n+      });\n     });\n \n     describe('generates identifiers for PropertyWrites', () => {"
        }
    ],
    "stats": {
        "total": 77,
        "additions": 52,
        "deletions": 25
    }
}