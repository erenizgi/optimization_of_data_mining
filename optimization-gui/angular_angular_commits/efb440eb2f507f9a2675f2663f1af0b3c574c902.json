{
    "author": "aahmedayed",
    "message": "refactor(router): compute correct history restoration when navigation is cancelled (#38884)\n\nWe can’t determine whether the user actually meant the `back` or\nthe `forward` using the popstate event (triggered by a browser\nback/forward)\nso we instead need to store information on the state and compute the\ndistance the user is traveling withing the browser history.\nSo by using the `History#go` method,\nwe can bring the user back to the page where he is supposed to be after\nperforming the action.\n\nimplementation for #13586\n\nPR Close #38884",
    "sha": "efb440eb2f507f9a2675f2663f1af0b3c574c902",
    "files": [
        {
            "sha": "6fccdecb4bb26c388338acee86469a0751f25db1",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/efb440eb2f507f9a2675f2663f1af0b3c574c902/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/efb440eb2f507f9a2675f2663f1af0b3c574c902/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=efb440eb2f507f9a2675f2663f1af0b3c574c902",
            "patch": "@@ -38,10 +38,10 @@\n   \"cli-hello-world-lazy\": {\n     \"master\": {\n       \"uncompressed\": {\n-        \"runtime-es2015\": 2850,\n-        \"main-es2015\": 295741,\n-        \"polyfills-es2015\": 36975,\n-        \"src_app_lazy_lazy_module_ts-es2015\": 825\n+        \"runtime-es2015\": 2854,\n+        \"main-es2015\": 296436,\n+        \"polyfills-es2015\": 37064,\n+        \"src_app_lazy_lazy_module_ts-es2015\": 822\n       }\n     }\n   },"
        },
        {
            "sha": "a6b7d52d5455df1b7f7b46996cf41e8ccd53ca32",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 109,
            "deletions": 29,
            "changes": 138,
            "blob_url": "https://github.com/angular/angular/blob/efb440eb2f507f9a2675f2663f1af0b3c574c902/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/efb440eb2f507f9a2675f2663f1af0b3c574c902/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=efb440eb2f507f9a2675f2663f1af0b3c574c902",
            "patch": "@@ -233,7 +233,12 @@ function defaultMalformedUriErrorHandler(\n }\n \n export type RestoredState = {\n-  [k: string]: any; navigationId: number;\n+  [k: string]: any,\n+  // TODO(#27607): Remove `navigationId` and `ɵrouterPageId` and move to `ng` or `ɵ` namespace.\n+  navigationId: number,\n+  // The `ɵ` prefix is there to reduce the chance of colliding with any existing user properties on\n+  // the history state.\n+  ɵrouterPageId?: number,\n };\n \n /**\n@@ -303,6 +308,7 @@ export interface Navigation {\n \n export type NavigationTransition = {\n   id: number,\n+  targetPageId: number,\n   currentUrlTree: UrlTree,\n   currentRawUrl: UrlTree,\n   extractedUrl: UrlTree,\n@@ -409,6 +415,12 @@ export class Router {\n    */\n   private lastLocationChangeInfo: LocationChangeInfo|null = null;\n   private navigationId: number = 0;\n+\n+  /**\n+   * The id of the currently active page in the router.\n+   * Updated to the transition's target id on a successful navigation.\n+   */\n+  private currentPageId: number = 0;\n   private configLoader: RouterConfigLoader;\n   private ngModule: NgModuleRef<any>;\n   private console: Console;\n@@ -509,6 +521,25 @@ export class Router {\n    */\n   relativeLinkResolution: 'legacy'|'corrected' = 'corrected';\n \n+  /**\n+   * Configures how the Router attempts to restore state when a navigation is cancelled.\n+   *\n+   * 'replace' - Always uses `location.replaceState` to set the browser state to the state of the\n+   * router before the navigation started.\n+   *\n+   * 'computed' - Will always return to the same state that corresponds to the actual Angular route\n+   * when the navigation gets cancelled right after triggering a `popstate` event.\n+   *\n+   * The default value is `replace`\n+   *\n+   * @internal\n+   */\n+  // TODO(atscott): Determine how/when/if to make this public API\n+  // This shouldn’t be an option at all but may need to be in order to allow migration without a\n+  // breaking change. We need to determine if it should be made into public api (or if we forgo\n+  // the option and release as a breaking change bug fix in a major version).\n+  canceledNavigationResolution: 'replace'|'computed' = 'replace';\n+\n   /**\n    * Creates the router service.\n    */\n@@ -535,6 +566,7 @@ export class Router {\n \n     this.transitions = new BehaviorSubject<NavigationTransition>({\n       id: 0,\n+      targetPageId: 0,\n       currentUrlTree: this.currentUrlTree,\n       currentRawUrl: this.currentUrlTree,\n       extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),\n@@ -634,9 +666,7 @@ export class Router {\n                              tap(t => {\n                                if (this.urlUpdateStrategy === 'eager') {\n                                  if (!t.extras.skipLocationChange) {\n-                                   this.setBrowserUrl(\n-                                       t.urlAfterRedirects, !!t.extras.replaceUrl, t.id,\n-                                       t.extras.state);\n+                                   this.setBrowserUrl(t.urlAfterRedirects, t);\n                                  }\n                                  this.browserUrlTree = t.urlAfterRedirects;\n                                }\n@@ -731,11 +761,7 @@ export class Router {\n \n                      filter(t => {\n                        if (!t.guardsResult) {\n-                         this.resetUrlToCurrentUrlTree();\n-                         const navCancel =\n-                             new NavigationCancel(t.id, this.serializeUrl(t.extractedUrl), '');\n-                         eventsSubject.next(navCancel);\n-                         t.resolve(false);\n+                         this.cancelNavigationTransition(t, '');\n                          return false;\n                        }\n                        return true;\n@@ -760,11 +786,9 @@ export class Router {\n                                      next: () => dataResolved = true,\n                                      complete: () => {\n                                        if (!dataResolved) {\n-                                         const navCancel = new NavigationCancel(\n-                                             t.id, this.serializeUrl(t.extractedUrl),\n+                                         this.cancelNavigationTransition(\n+                                             t,\n                                              `At least one route resolver didn't emit any value.`);\n-                                         eventsSubject.next(navCancel);\n-                                         t.resolve(false);\n                                        }\n                                      }\n                                    }),\n@@ -818,8 +842,7 @@ export class Router {\n \n                        if (this.urlUpdateStrategy === 'deferred') {\n                          if (!t.extras.skipLocationChange) {\n-                           this.setBrowserUrl(\n-                               this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state);\n+                           this.setBrowserUrl(this.rawUrlTree, t);\n                          }\n                          this.browserUrlTree = t.urlAfterRedirects;\n                        }\n@@ -853,13 +876,10 @@ export class Router {\n                          // sync code which looks for a value here in order to determine whether or\n                          // not to handle a given popstate event or to leave it to the Angular\n                          // router.\n-                         this.resetUrlToCurrentUrlTree();\n-                         const navCancel = new NavigationCancel(\n-                             t.id, this.serializeUrl(t.extractedUrl),\n+                         this.cancelNavigationTransition(\n+                             t,\n                              `Navigation ID ${t.id} is not equal to the current navigation id ${\n                                  this.navigationId}`);\n-                         eventsSubject.next(navCancel);\n-                         t.resolve(false);\n                        }\n                        // currentNavigation should always be reset to null here. If navigation was\n                        // successful, lastSuccessfulTransition will have already been set. Therefore\n@@ -982,6 +1002,7 @@ export class Router {\n             if (state) {\n               const stateCopy = {...state} as Partial<RestoredState>;\n               delete stateCopy.navigationId;\n+              delete stateCopy.ɵrouterPageId;\n               if (Object.keys(stateCopy).length !== 0) {\n                 extras.state = stateCopy;\n               }\n@@ -1192,7 +1213,15 @@ export class Router {\n     const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n     const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n \n-    return this.scheduleNavigation(mergedTree, 'imperative', null, extras);\n+    let restoredState: RestoredState|null = null;\n+    if (this.canceledNavigationResolution === 'computed') {\n+      const isInitialPage = this.currentPageId === 0;\n+      if (isInitialPage || extras.skipLocationChange || extras.replaceUrl) {\n+        restoredState = this.location.getState() as RestoredState | null;\n+      }\n+    }\n+\n+    return this.scheduleNavigation(mergedTree, 'imperative', restoredState, extras);\n   }\n \n   /**\n@@ -1297,6 +1326,7 @@ export class Router {\n         t => {\n           this.navigated = true;\n           this.lastSuccessfulId = t.id;\n+          this.currentPageId = t.targetPageId;\n           (this.events as Subject<Event>)\n               .next(new NavigationEnd(\n                   t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree)));\n@@ -1356,8 +1386,23 @@ export class Router {\n     }\n \n     const id = ++this.navigationId;\n+    let targetPageId: number;\n+    if (this.canceledNavigationResolution === 'computed') {\n+      // If the `ɵrouterPageId` exist in the state then `targetpageId` should have the value of\n+      // `ɵrouterPageId`\n+      if (restoredState && restoredState.ɵrouterPageId) {\n+        targetPageId = restoredState.ɵrouterPageId;\n+      } else {\n+        targetPageId = this.currentPageId + 1;\n+      }\n+    } else {\n+      // This is unused when `canceledNavigationResolution` is not computed.\n+      targetPageId = 0;\n+    }\n+\n     this.setTransition({\n       id,\n+      targetPageId,\n       source,\n       restoredState,\n       currentUrlTree: this.currentUrlTree,\n@@ -1378,15 +1423,13 @@ export class Router {\n     });\n   }\n \n-  private setBrowserUrl(\n-      url: UrlTree, replaceUrl: boolean, id: number, state?: {[key: string]: any}) {\n+  private setBrowserUrl(url: UrlTree, t: NavigationTransition) {\n     const path = this.urlSerializer.serialize(url);\n-    state = state || {};\n-    if (this.location.isCurrentPathEqualTo(path) || replaceUrl) {\n-      // TODO(jasonaden): Remove first `navigationId` and rely on `ng` namespace.\n-      this.location.replaceState(path, '', {...state, navigationId: id});\n+    const state = {...t.extras.state, ...this.generateNgRouterState(t.id, t.targetPageId)};\n+    if (this.location.isCurrentPathEqualTo(path) || !!t.extras.replaceUrl) {\n+      this.location.replaceState(path, '', state);\n     } else {\n-      this.location.go(path, '', {...state, navigationId: id});\n+      this.location.go(path, '', state);\n     }\n   }\n \n@@ -1399,7 +1442,44 @@ export class Router {\n \n   private resetUrlToCurrentUrlTree(): void {\n     this.location.replaceState(\n-        this.urlSerializer.serialize(this.rawUrlTree), '', {navigationId: this.lastSuccessfulId});\n+        this.urlSerializer.serialize(this.rawUrlTree), '',\n+        this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));\n+  }\n+\n+  /**\n+   * Responsible for handling the cancellation of a navigation:\n+   * - performs the necessary rollback action to restore the browser URL to the\n+   * state before the transition\n+   * - triggers the `NavigationCancel` event\n+   * - resolves the transition promise with `false`\n+   */\n+  private cancelNavigationTransition(t: NavigationTransition, reason: string) {\n+    if (this.canceledNavigationResolution === 'computed') {\n+      // The navigator change the location before triggered the browser event,\n+      // so we need to go back to the current url if the navigation is canceled.\n+      // Also, when navigation gets cancelled while using url update strategy eager, then we need to\n+      // go back. Because, when `urlUpdateSrategy` is `eager`; `setBrowserUrl` method is called\n+      // before any verification.\n+      if (t.source === 'popstate' || this.urlUpdateStrategy === 'eager') {\n+        const targetPagePosition = this.currentPageId - t.targetPageId;\n+        this.location.historyGo(targetPagePosition);\n+      } else {\n+        // If update is not 'eager' and the transition navigation source isn't 'popstate', then the\n+        // navigation was cancelled before any browser url change so nothing needs to be restored.\n+      }\n+    } else {\n+      this.resetUrlToCurrentUrlTree();\n+    }\n+    const navCancel = new NavigationCancel(t.id, this.serializeUrl(t.extractedUrl), reason);\n+    this.triggerEvent(navCancel);\n+    t.resolve(false);\n+  }\n+\n+  private generateNgRouterState(navigationId: number, routerPageId?: number) {\n+    if (this.canceledNavigationResolution === 'computed') {\n+      return {navigationId, ɵrouterPageId: routerPageId};\n+    }\n+    return {navigationId};\n   }\n }\n "
        },
        {
            "sha": "9336085b15738de1e72302ae775431287d8870fb",
            "filename": "packages/router/test/integration.spec.ts",
            "status": "modified",
            "additions": 443,
            "deletions": 179,
            "changes": 622,
            "blob_url": "https://github.com/angular/angular/blob/efb440eb2f507f9a2675f2663f1af0b3c574c902/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/efb440eb2f507f9a2675f2663f1af0b3c574c902/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fintegration.spec.ts?ref=efb440eb2f507f9a2675f2663f1af0b3c574c902",
            "patch": "@@ -6,14 +6,14 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {CommonModule, Location} from '@angular/common';\n+import {CommonModule, Location, LocationStrategy, PlatformLocation} from '@angular/common';\n import {SpyLocation} from '@angular/common/testing';\n-import {ChangeDetectionStrategy, Component, Injectable, NgModule, NgModuleFactoryLoader, NgModuleRef, NgZone, OnDestroy, ViewChild, ɵConsole as Console, ɵNoopNgZone as NoopNgZone} from '@angular/core';\n+import {ChangeDetectionStrategy, Component, EventEmitter, Injectable, NgModule, NgModuleFactoryLoader, NgModuleRef, NgZone, OnDestroy, ViewChild, ɵConsole as Console, ɵNoopNgZone as NoopNgZone} from '@angular/core';\n import {ComponentFixture, fakeAsync, inject, TestBed, tick} from '@angular/core/testing';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n import {ActivatedRoute, ActivatedRouteSnapshot, ActivationEnd, ActivationStart, CanActivate, CanDeactivate, ChildActivationEnd, ChildActivationStart, DefaultUrlSerializer, DetachedRouteHandle, Event, GuardsCheckEnd, GuardsCheckStart, Navigation, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, ParamMap, Params, PreloadAllModules, PreloadingStrategy, PRIMARY_OUTLET, Resolve, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, Router, RouteReuseStrategy, RouterEvent, RouterLink, RouterLinkWithHref, RouterModule, RouterPreloader, RouterStateSnapshot, RoutesRecognized, RunGuardsAndResolvers, UrlHandlingStrategy, UrlSegmentGroup, UrlSerializer, UrlTree} from '@angular/router';\n-import {EMPTY, Observable, Observer, of, Subscription} from 'rxjs';\n+import {EMPTY, Observable, Observer, of, Subscription, SubscriptionLike} from 'rxjs';\n import {delay, filter, first, map, mapTo, tap} from 'rxjs/operators';\n \n import {forEach} from '../src/utils/collection';\n@@ -446,10 +446,10 @@ describe('Integration', () => {\n \n       @Component({\n         template: `\n-        <router-outlet (deactivate)=\"logDeactivate('primary')\"></router-outlet>\n-        <router-outlet name=\"first\" (deactivate)=\"logDeactivate('first')\"></router-outlet>\n-        <router-outlet name=\"second\" (deactivate)=\"logDeactivate('second')\"></router-outlet>\n-        `\n+         <router-outlet (deactivate)=\"logDeactivate('primary')\"></router-outlet>\n+         <router-outlet name=\"first\" (deactivate)=\"logDeactivate('first')\"></router-outlet>\n+         <router-outlet name=\"second\" (deactivate)=\"logDeactivate('second')\"></router-outlet>\n+         `\n       })\n       class NamedOutletHost {\n         logDeactivate(route: string) {\n@@ -1000,7 +1000,7 @@ describe('Integration', () => {\n          expect(fixture.nativeElement).toHaveText('team 33 [ , right:  ]');\n        })));\n \n-    it('should should set `state` with urlUpdateStrategy=\"eagar\"',\n+    it('should set `state` with urlUpdateStrategy=\"eagar\"',\n        fakeAsync(inject([Router, Location], (router: Router, location: SpyLocation) => {\n          router.urlUpdateStrategy = 'eager';\n          router.resetConfig([\n@@ -2289,11 +2289,11 @@ describe('Integration', () => {\n          @Component({\n            selector: 'someCmp',\n            template: `<router-outlet></router-outlet>\n-               <a [routerLink]=\"null\">Link</a>\n-               <button [routerLink]=\"null\">Button</button>\n-               <a [routerLink]=\"undefined\">Link</a>\n-               <button [routerLink]=\"undefined\">Button</button>\n-               `\n+                <a [routerLink]=\"null\">Link</a>\n+                <button [routerLink]=\"null\">Button</button>\n+                <a [routerLink]=\"undefined\">Link</a>\n+                <button [routerLink]=\"undefined\">Button</button>\n+                `\n          })\n          class CmpWithLink {\n          }\n@@ -2661,7 +2661,426 @@ describe('Integration', () => {\n          expect(location.path()).toEqual('/initial');\n        })));\n   });\n+  describe('`restoredState#ɵrouterPageId`', () => {\n+    // TODO: Remove RouterSpyLocation after #38884 is submitted.\n+    class RouterSpyLocation implements Location {\n+      urlChanges: string[] = [];\n+      private _history: LocationState[] = [new LocationState('', '', null)];\n+      private _historyIndex: number = 0;\n+      /** @internal */\n+      _subject: EventEmitter<any> = new EventEmitter();\n+      /** @internal */\n+      _baseHref: string = '';\n+      /** @internal */\n+      _platformStrategy: LocationStrategy = null!;\n+      /** @internal */\n+      _platformLocation: PlatformLocation = null!;\n+      /** @internal */\n+      _urlChangeListeners: ((url: string, state: unknown) => void)[] = [];\n+      /** @internal */\n+      _urlChangeSubscription?: SubscriptionLike;\n+\n+      setInitialPath(url: string) {\n+        this._history[this._historyIndex].path = url;\n+      }\n+\n+      setBaseHref(url: string) {\n+        this._baseHref = url;\n+      }\n+\n+      path(): string {\n+        return this._history[this._historyIndex].path;\n+      }\n+\n+      getState(): unknown {\n+        return this._history[this._historyIndex].state;\n+      }\n+\n+      isCurrentPathEqualTo(path: string, query: string = ''): boolean {\n+        const givenPath = path.endsWith('/') ? path.substring(0, path.length - 1) : path;\n+        const currPath = this.path().endsWith('/') ?\n+            this.path().substring(0, this.path().length - 1) :\n+            this.path();\n+\n+        return currPath == givenPath + (query.length > 0 ? ('?' + query) : '');\n+      }\n+\n+      simulateUrlPop(pathname: string) {\n+        this._subject.emit({'url': pathname, 'pop': true, 'type': 'popstate'});\n+      }\n+\n+      simulateHashChange(pathname: string) {\n+        // Because we don't prevent the native event, the browser will independently update the path\n+        this.setInitialPath(pathname);\n+        this.urlChanges.push('hash: ' + pathname);\n+        this._subject.emit({'url': pathname, 'pop': true, 'type': 'hashchange'});\n+      }\n+\n+      prepareExternalUrl(url: string): string {\n+        if (url.length > 0 && !url.startsWith('/')) {\n+          url = '/' + url;\n+        }\n+        return this._baseHref + url;\n+      }\n+\n+      go(path: string, query: string = '', state: any = null) {\n+        path = this.prepareExternalUrl(path);\n+\n+        if (this._historyIndex > 0) {\n+          this._history.splice(this._historyIndex + 1);\n+        }\n+        this._history.push(new LocationState(path, query, state));\n+        this._historyIndex = this._history.length - 1;\n+\n+        const locationState = this._history[this._historyIndex - 1];\n+        if (locationState.path == path && locationState.query == query) {\n+          return;\n+        }\n+\n+        const url = path + (query.length > 0 ? ('?' + query) : '');\n+        this.urlChanges.push(url);\n+        this._subject.emit({'url': url, 'pop': false});\n+      }\n+\n+      replaceState(path: string, query: string = '', state: any = null) {\n+        path = this.prepareExternalUrl(path);\n+\n+        const history = this._history[this._historyIndex];\n+        if (history.path == path && history.query == query) {\n+          return;\n+        }\n+\n+        history.path = path;\n+        history.query = query;\n+        history.state = state;\n+\n+        const url = path + (query.length > 0 ? ('?' + query) : '');\n+        this.urlChanges.push('replace: ' + url);\n+      }\n+\n+      forward() {\n+        if (this._historyIndex < (this._history.length - 1)) {\n+          this._historyIndex++;\n+          this._subject.emit(\n+              {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n+        }\n+      }\n+\n+      back() {\n+        if (this._historyIndex > 0) {\n+          this._historyIndex--;\n+          this._subject.emit(\n+              {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n+        }\n+      }\n+\n+      historyGo(relativePosition: number = 0): void {\n+        const nextPageIndex = this._historyIndex + relativePosition;\n+        if (nextPageIndex >= 0 && nextPageIndex < this._history.length) {\n+          this._historyIndex = nextPageIndex;\n+          this._subject.emit(\n+              {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n+        }\n+      }\n+\n+      onUrlChange(fn: (url: string, state: unknown) => void) {\n+        this._urlChangeListeners.push(fn);\n+\n+        if (!this._urlChangeSubscription) {\n+          this._urlChangeSubscription = this.subscribe(v => {\n+            this._notifyUrlChangeListeners(v.url, v.state);\n+          });\n+        }\n+      }\n+\n+      /** @internal */\n+      _notifyUrlChangeListeners(url: string = '', state: unknown) {\n+        this._urlChangeListeners.forEach(fn => fn(url, state));\n+      }\n+\n+      subscribe(\n+          onNext: (value: any) => void, onThrow?: ((error: any) => void)|null,\n+          onReturn?: (() => void)|null): SubscriptionLike {\n+        return this._subject.subscribe({next: onNext, error: onThrow, complete: onReturn});\n+      }\n+\n+      normalize(url: string): string {\n+        return null!;\n+      }\n+    }\n+\n+    class LocationState {\n+      constructor(public path: string, public query: string, public state: any) {}\n+    }\n+\n+    @Injectable({providedIn: 'root'})\n+    class MyCanDeactivateGuard implements CanDeactivate<any> {\n+      allow: boolean = true;\n+      canDeactivate(): boolean {\n+        return this.allow;\n+      }\n+    }\n+\n+    @Injectable({providedIn: 'root'})\n+    class MyCanActivateGuard implements CanActivate {\n+      allow: boolean = true;\n+      canActivate(): boolean {\n+        return this.allow;\n+      }\n+    }\n+    @Injectable({providedIn: 'root'})\n+    class MyResolve implements Resolve<Observable<any>> {\n+      myresolve: Observable<any> = of(2);\n+      resolve(): Observable<any> {\n+        return this.myresolve;\n+      }\n+    }\n+\n+    @NgModule(\n+        {imports: [RouterModule.forChild([{path: '', component: BlankCmp}])]},\n+        )\n+    class LoadedModule {\n+    }\n+\n+    let fixture: ComponentFixture<unknown>;\n+\n+    beforeEach(fakeAsync(() => {\n+      TestBed.configureTestingModule({\n+        imports: [TestModule],\n+        providers: [\n+          {provide: 'alwaysFalse', useValue: (a: any) => false},\n+          {provide: Location, useClass: RouterSpyLocation}\n+        ]\n+      });\n+      const router = TestBed.inject(Router);\n+      (router as any).canceledNavigationResolution = 'computed';\n+      const location = TestBed.inject(Location);\n+      fixture = createRoot(router, SimpleCmp);\n+      router.resetConfig([\n+        {\n+          path: 'first',\n+          component: SimpleCmp,\n+          canDeactivate: [MyCanDeactivateGuard],\n+          canActivate: [MyCanActivateGuard],\n+          resolve: [MyResolve]\n+        },\n+        {\n+          path: 'second',\n+          component: SimpleCmp,\n+          canDeactivate: [MyCanDeactivateGuard],\n+          canActivate: [MyCanActivateGuard],\n+          resolve: [MyResolve]\n+        },\n+        {\n+          path: 'third',\n+          component: SimpleCmp,\n+          canDeactivate: [MyCanDeactivateGuard],\n+          canActivate: [MyCanActivateGuard],\n+          resolve: [MyResolve]\n+        },\n+        {path: 'loaded', loadChildren: () => of(LoadedModule), canLoad: ['alwaysFalse']}\n+      ]);\n+      router.navigateByUrl('/first');\n+      advance(fixture);\n+\n+      router.navigateByUrl('/second');\n+      advance(fixture);\n+\n+      router.navigateByUrl('/third');\n+      advance(fixture);\n+\n+      location.back();\n+      advance(fixture);\n+    }));\n+\n+    it('should work when CanActivate returns false', fakeAsync(() => {\n+         const location = TestBed.inject(Location);\n+         const router = TestBed.inject(Router);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+         TestBed.inject(MyCanActivateGuard).allow = false;\n+         location.back();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+         TestBed.inject(MyCanActivateGuard).allow = true;\n+         location.back();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/first');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+         TestBed.inject(MyCanActivateGuard).allow = false;\n+         location.forward();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/first');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+         router.navigateByUrl('/second');\n+         advance(fixture);\n+         expect(location.path()).toEqual('/first');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+       }));\n+\n+\n+    it('should work when CanDeactivate returns false', fakeAsync(() => {\n+         const location = TestBed.inject(Location);\n+         const router = TestBed.inject(Router);\n+\n+         TestBed.inject(MyCanDeactivateGuard).allow = false;\n+         location.back();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+         location.forward();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+         router.navigateByUrl('third');\n+         advance(fixture);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+\n+         TestBed.inject(MyCanDeactivateGuard).allow = true;\n+         location.forward();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/third');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 4}));\n+       }));\n+\n+    it('should work when using `NavigationExtras.skipLocationChange`', fakeAsync(() => {\n+         const location = TestBed.inject(Location);\n+         const router = TestBed.inject(Router);\n+\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n \n+         router.navigateByUrl('/first', {skipLocationChange: true});\n+         advance(fixture);\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+         router.navigateByUrl('/third');\n+         advance(fixture);\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 4}));\n+\n+         location.back();\n+         advance(fixture);\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+       }));\n+\n+    it('should work when using `NavigationExtras.replaceUrl`', fakeAsync(() => {\n+         const location = TestBed.inject(Location);\n+         const router = TestBed.inject(Router);\n+\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+         router.navigateByUrl('/first', {replaceUrl: true});\n+         advance(fixture);\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.path()).toEqual('/first');\n+       }));\n+\n+    it('should work when CanLoad returns false', fakeAsync(() => {\n+         const location = TestBed.inject(Location);\n+         const router = TestBed.inject(Router);\n+\n+         router.navigateByUrl('/loaded');\n+         advance(fixture);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+       }));\n+\n+    it('should work when resolve empty', fakeAsync(() => {\n+         const location = TestBed.inject(Location);\n+         const router = TestBed.inject(Router);\n+\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+         TestBed.inject(MyResolve).myresolve = EMPTY;\n+\n+         location.back();\n+         advance(fixture);\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.path()).toEqual('/second');\n+\n+         TestBed.inject(MyResolve).myresolve = of(2);\n+\n+         location.back();\n+         advance(fixture);\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+         expect(location.path()).toEqual('/first');\n+\n+         TestBed.inject(MyResolve).myresolve = EMPTY;\n+\n+         // We should cancel the navigation to `/third` when myresolve is empty\n+         router.navigateByUrl('/third');\n+         advance(fixture);\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+         expect(location.path()).toEqual('/first');\n+\n+         location.historyGo(2);\n+         advance(fixture);\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+         expect(location.path()).toEqual('/first');\n+\n+         TestBed.inject(MyResolve).myresolve = of(2);\n+         location.historyGo(2);\n+         advance(fixture);\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 4}));\n+         expect(location.path()).toEqual('/third');\n+\n+         TestBed.inject(MyResolve).myresolve = EMPTY;\n+         location.historyGo(-2);\n+         advance(fixture);\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 4}));\n+         expect(location.path()).toEqual('/third');\n+       }));\n+\n+\n+    it('should work when an error occured during navigation', fakeAsync(() => {\n+         const location = TestBed.inject(Location);\n+         const router = TestBed.inject(Router);\n+\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+\n+         router.navigateByUrl('/invalid').catch(() => null);\n+         advance(fixture);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+         location.back();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/first');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+       }));\n+\n+    it('should work when urlUpdateStrategy=\"eagar\"', fakeAsync(() => {\n+         const location = TestBed.inject(Location) as SpyLocation;\n+         const router = TestBed.inject(Router);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         router.urlUpdateStrategy = 'eager';\n+\n+         TestBed.inject(MyCanActivateGuard).allow = false;\n+         router.navigateByUrl('/first');\n+         advance(fixture);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+         location.back();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+       }));\n+  });\n   describe('guards', () => {\n     describe('CanActivate', () => {\n       describe('should not activate a route when CanActivate returns false', () => {\n@@ -2886,161 +3305,6 @@ describe('Integration', () => {\n            })));\n       });\n \n-      describe('should not break the history', () => {\n-        @Injectable({providedIn: 'root'})\n-        class MyGuard implements CanDeactivate<any> {\n-          allow: boolean = true;\n-          canDeactivate(): boolean {\n-            return this.allow;\n-          }\n-        }\n-\n-        @Component({selector: 'parent', template: '<router-outlet></router-outlet>'})\n-        class Parent {\n-        }\n-\n-        @Component({selector: 'home', template: 'home'})\n-        class Home {\n-        }\n-\n-        @Component({selector: 'child1', template: 'child1'})\n-        class Child1 {\n-        }\n-\n-        @Component({selector: 'child2', template: 'child2'})\n-        class Child2 {\n-        }\n-\n-        @Component({selector: 'child3', template: 'child3'})\n-        class Child3 {\n-        }\n-\n-        @Component({selector: 'child4', template: 'child4'})\n-        class Child4 {\n-        }\n-\n-        @Component({selector: 'child5', template: 'child5'})\n-        class Child5 {\n-        }\n-\n-        @NgModule({\n-          declarations: [Parent, Home, Child1, Child2, Child3, Child4, Child5],\n-          entryComponents: [Child1, Child2, Child3, Child4, Child5],\n-          imports: [RouterModule]\n-        })\n-        class TestModule {\n-        }\n-\n-        let fixture: ComponentFixture<unknown>;\n-\n-        beforeEach(fakeAsync(() => {\n-          TestBed.configureTestingModule({imports: [TestModule]});\n-          const router = TestBed.get(Router);\n-          const location = TestBed.get(Location);\n-          fixture = createRoot(router, Parent);\n-\n-          router.resetConfig([\n-            {path: '', component: Home},\n-            {path: 'first', component: Child1},\n-            {path: 'second', component: Child2},\n-            {path: 'third', component: Child3, canDeactivate: [MyGuard]},\n-            {path: 'fourth', component: Child4},\n-            {path: 'fifth', component: Child5},\n-          ]);\n-\n-          // Create a navigation history of pages 1-5, and go back to 3 so that there is both\n-          // back and forward history.\n-          router.navigateByUrl('/first');\n-          advance(fixture);\n-          router.navigateByUrl('/second');\n-          advance(fixture);\n-          router.navigateByUrl('/third');\n-          advance(fixture);\n-          router.navigateByUrl('/fourth');\n-          advance(fixture);\n-          router.navigateByUrl('/fifth');\n-          advance(fixture);\n-          location.back();\n-          advance(fixture);\n-          location.back();\n-          advance(fixture);\n-        }));\n-\n-        // TODO(https://github.com/angular/angular/issues/13586)\n-        // A fix to this requires much more design\n-        xit('when navigate back using Back button', fakeAsync(() => {\n-              const location = TestBed.get(Location);\n-              expect(location.path()).toEqual('/third');\n-\n-              TestBed.get(MyGuard).allow = false;\n-              location.back();\n-              advance(fixture);\n-              expect(location.path()).toEqual('/third');\n-              expect(fixture.nativeElement).toHaveText('child3');\n-\n-              TestBed.get(MyGuard).allow = true;\n-              location.back();\n-              advance(fixture);\n-              expect(location.path()).toEqual('/second');\n-              expect(fixture.nativeElement).toHaveText('child2');\n-            }));\n-\n-        it('when navigate back imperatively', fakeAsync(() => {\n-             const router = TestBed.get(Router);\n-             const location = TestBed.get(Location);\n-             expect(location.path()).toEqual('/third');\n-\n-             TestBed.get(MyGuard).allow = false;\n-             router.navigateByUrl('/second');\n-             advance(fixture);\n-             expect(location.path()).toEqual('/third');\n-             expect(fixture.nativeElement).toHaveText('child3');\n-\n-             TestBed.get(MyGuard).allow = true;\n-             location.back();\n-             advance(fixture);\n-             expect(location.path()).toEqual('/second');\n-             expect(fixture.nativeElement).toHaveText('child2');\n-           }));\n-\n-        // TODO(https://github.com/angular/angular/issues/13586)\n-        // A fix to this requires much more design\n-        xit('when navigate back using Foward button', fakeAsync(() => {\n-              const location = TestBed.get(Location);\n-              expect(location.path()).toEqual('/third');\n-\n-              TestBed.get(MyGuard).allow = false;\n-              location.forward();\n-              advance(fixture);\n-              expect(location.path()).toEqual('/third');\n-              expect(fixture.nativeElement).toHaveText('child3');\n-\n-              TestBed.get(MyGuard).allow = true;\n-              location.forward();\n-              advance(fixture);\n-              expect(location.path()).toEqual('/fourth');\n-              expect(fixture.nativeElement).toHaveText('child4');\n-            }));\n-\n-        it('when navigate forward imperatively', fakeAsync(() => {\n-             const router = TestBed.get(Router);\n-             const location = TestBed.get(Location);\n-             expect(location.path()).toEqual('/third');\n-\n-             TestBed.get(MyGuard).allow = false;\n-             router.navigateByUrl('/fourth');\n-             advance(fixture);\n-             expect(location.path()).toEqual('/third');\n-             expect(fixture.nativeElement).toHaveText('child3');\n-\n-             TestBed.get(MyGuard).allow = true;\n-             location.forward();\n-             advance(fixture);\n-             expect(location.path()).toEqual('/fourth');\n-             expect(fixture.nativeElement).toHaveText('child4');\n-           }));\n-      });\n-\n       describe('should redirect when guard returns UrlTree', () => {\n         beforeEach(() => TestBed.configureTestingModule({\n           providers: [\n@@ -4754,10 +5018,10 @@ describe('Integration', () => {\n     it('should expose an isActive property', fakeAsync(() => {\n          @Component({\n            template: `<a routerLink=\"/team\" routerLinkActive #rla=\"routerLinkActive\"></a>\n-              <p>{{rla.isActive}}</p>\n-              <span *ngIf=\"rla.isActive\"></span>\n-              <span [ngClass]=\"{'highlight': rla.isActive}\"></span>\n-              <router-outlet></router-outlet>`\n+               <p>{{rla.isActive}}</p>\n+               <span *ngIf=\"rla.isActive\"></span>\n+               <span [ngClass]=\"{'highlight': rla.isActive}\"></span>\n+               <router-outlet></router-outlet>`\n          })\n          class ComponentWithRouterLink {\n          }\n@@ -5664,8 +5928,8 @@ describe('Integration', () => {\n            selector: 'link-cmp',\n            template:\n                `<a [relativeTo]=\"route.parent\" [routerLink]=\"[{outlets: {'secondary': null}}]\">link</a>\n-           <button [relativeTo]=\"route.parent\" [routerLink]=\"[{outlets: {'secondary': null}}]\">link</button>\n-           `\n+            <button [relativeTo]=\"route.parent\" [routerLink]=\"[{outlets: {'secondary': null}}]\">link</button>\n+            `\n          })\n          class RelativeLinkCmp {\n            @ViewChild(RouterLink) buttonLink!: RouterLink;\n@@ -6032,8 +6296,8 @@ class AbsoluteLinkCmp {\n   selector: 'link-cmp',\n   template:\n       `<router-outlet></router-outlet><a routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{exact: exact}\" [routerLink]=\"['./']\">link</a>\n-<button routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{exact: exact}\" [routerLink]=\"['./']\">button</button>\n-`\n+ <button routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{exact: exact}\" [routerLink]=\"['./']\">button</button>\n+ `\n })\n class DummyLinkCmp {\n   private exact: boolean;\n@@ -6195,9 +6459,9 @@ class OutletInNgIf {\n @Component({\n   selector: 'link-cmp',\n   template: `<router-outlet></router-outlet>\n-             <div id=\"link-parent\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{exact: exact}\">\n-               <div ngClass=\"{one: 'true'}\"><a [routerLink]=\"['./']\">link</a></div>\n-             </div>`\n+              <div id=\"link-parent\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{exact: exact}\">\n+                <div ngClass=\"{one: 'true'}\"><a [routerLink]=\"['./']\">link</a></div>\n+              </div>`\n })\n class DummyLinkWithParentCmp {\n   private exact: boolean;"
        }
    ],
    "stats": {
        "total": 768,
        "additions": 556,
        "deletions": 212
    }
}