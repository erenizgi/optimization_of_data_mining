{
    "author": "petebacondarwin",
    "message": "refactor(compiler): use `DefinitionMap` and remove `mapToMapExpression()` (#41080)\n\nBy consistently using the `DefinitionMap` class there is no longer\nany need for the `mapToMapExpression()` function.\n\nPR Close #41080",
    "sha": "28a7fba29a6b224562bf0acd373dd6307f429c1d",
    "files": [
        {
            "sha": "2ba1b243b3a818235d68a78af798f65fbcc716db",
            "filename": "packages/compiler/src/injectable_compiler_2.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 4,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/28a7fba29a6b224562bf0acd373dd6307f429c1d/packages%2Fcompiler%2Fsrc%2Finjectable_compiler_2.ts",
            "raw_url": "https://github.com/angular/angular/raw/28a7fba29a6b224562bf0acd373dd6307f429c1d/packages%2Fcompiler%2Fsrc%2Finjectable_compiler_2.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Finjectable_compiler_2.ts?ref=28a7fba29a6b224562bf0acd373dd6307f429c1d",
            "patch": "@@ -9,7 +9,8 @@\n import {Identifiers} from './identifiers';\n import * as o from './output/output_ast';\n import {compileFactoryFunction, R3DependencyMetadata, R3FactoryDelegateType, R3FactoryMetadata, R3FactoryTarget} from './render3/r3_factory';\n-import {mapToMapExpression, R3Reference, typeWithParameters} from './render3/util';\n+import {R3Reference, typeWithParameters} from './render3/util';\n+import {DefinitionMap} from './render3/view/util';\n \n export interface InjectableDef {\n   expression: o.Expression;\n@@ -106,15 +107,18 @@ export function compileInjectable(meta: R3InjectableMetadata): InjectableDef {\n \n   const token = meta.internalType;\n \n-  const injectableProps: {[key: string]: o.Expression} = {token, factory: result.factory};\n+  const injectableProps =\n+      new DefinitionMap<{token: o.Expression, factory: o.Expression, providedIn: o.Expression}>();\n+  injectableProps.set('token', token);\n+  injectableProps.set('factory', result.factory);\n \n   // Only generate providedIn property if it has a non-null value\n   if ((meta.providedIn as o.LiteralExpr).value !== null) {\n-    injectableProps.providedIn = meta.providedIn;\n+    injectableProps.set('providedIn', meta.providedIn);\n   }\n \n   const expression = o.importExpr(Identifiers.ɵɵdefineInjectable)\n-                         .callFn([mapToMapExpression(injectableProps)], undefined, true);\n+                         .callFn([injectableProps.toLiteralMap()], undefined, true);\n   const type = new o.ExpressionType(o.importExpr(\n       Identifiers.InjectableDef, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n "
        },
        {
            "sha": "3ffbb554eaf03fe7e169432c3ea8da7b97438905",
            "filename": "packages/compiler/src/render3/r3_module_compiler.ts",
            "status": "modified",
            "additions": 59,
            "deletions": 32,
            "changes": 91,
            "blob_url": "https://github.com/angular/angular/blob/28a7fba29a6b224562bf0acd373dd6307f429c1d/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_module_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/28a7fba29a6b224562bf0acd373dd6307f429c1d/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_module_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_module_compiler.ts?ref=28a7fba29a6b224562bf0acd373dd6307f429c1d",
            "patch": "@@ -8,9 +8,9 @@\n \n import * as o from '../output/output_ast';\n \n-import {R3DependencyMetadata, R3FactoryFn} from './r3_factory';\n import {Identifiers as R3} from './r3_identifiers';\n-import {jitOnlyGuardedExpression, mapToMapExpression, R3Reference} from './util';\n+import {jitOnlyGuardedExpression, R3Reference} from './util';\n+import {DefinitionMap} from './view/util';\n \n export interface R3NgModuleDef {\n   expression: o.Expression;\n@@ -86,6 +86,43 @@ export interface R3NgModuleMetadata {\n   id: o.Expression|null;\n }\n \n+/**\n+ * The shape of the object literal that is passed to the `ɵɵdefineNgModule()` call.\n+ */\n+interface R3NgModuleDefMap {\n+  /**\n+   * An expression representing the module type being compiled.\n+   */\n+  type: o.Expression;\n+  /**\n+   * An expression evaluating to an array of expressions representing the bootstrap components\n+   * specified by the module.\n+   */\n+  bootstrap?: o.Expression;\n+  /**\n+   * An expression evaluating to an array of expressions representing the directives and pipes\n+   * declared by the module.\n+   */\n+  declarations?: o.Expression;\n+  /**\n+   * An expression evaluating to an array of expressions representing the imports of the module.\n+   */\n+  imports?: o.Expression;\n+  /**\n+   * An expression evaluating to an array of expressions representing the exports of the module.\n+   */\n+  exports?: o.Expression;\n+  /**\n+   * A literal array expression containing the schemas that declare elements to be allowed in the\n+   * NgModule.\n+   */\n+  schemas?: o.LiteralArrayExpr;\n+  /**\n+   * An expression evaluating to the unique ID of an NgModule.\n+   * */\n+  id?: o.Expression;\n+}\n+\n /**\n  * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n  */\n@@ -104,34 +141,27 @@ export function compileNgModule(meta: R3NgModuleMetadata): R3NgModuleDef {\n   } = meta;\n \n   const additionalStatements: o.Statement[] = [];\n-  const definitionMap = {type: internalType} as {\n-    type: o.Expression,\n-    bootstrap: o.Expression,\n-    declarations: o.Expression,\n-    imports: o.Expression,\n-    exports: o.Expression,\n-    schemas: o.LiteralArrayExpr,\n-    id: o.Expression\n-  };\n+  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n+  definitionMap.set('type', internalType);\n \n   // Only generate the keys in the metadata if the arrays have values.\n   if (bootstrap.length) {\n-    definitionMap.bootstrap = refsToArray(bootstrap, containsForwardDecls);\n+    definitionMap.set('bootstrap', refsToArray(bootstrap, containsForwardDecls));\n   }\n \n   // If requested to emit scope information inline, pass the declarations, imports and exports to\n   // the `ɵɵdefineNgModule` call. The JIT compilation uses this.\n   if (emitInline) {\n     if (declarations.length) {\n-      definitionMap.declarations = refsToArray(declarations, containsForwardDecls);\n+      definitionMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n     }\n \n     if (imports.length) {\n-      definitionMap.imports = refsToArray(imports, containsForwardDecls);\n+      definitionMap.set('imports', refsToArray(imports, containsForwardDecls));\n     }\n \n     if (exports.length) {\n-      definitionMap.exports = refsToArray(exports, containsForwardDecls);\n+      definitionMap.set('exports', refsToArray(exports, containsForwardDecls));\n     }\n   }\n \n@@ -145,15 +175,15 @@ export function compileNgModule(meta: R3NgModuleMetadata): R3NgModuleDef {\n   }\n \n   if (schemas && schemas.length) {\n-    definitionMap.schemas = o.literalArr(schemas.map(ref => ref.value));\n+    definitionMap.set('schemas', o.literalArr(schemas.map(ref => ref.value)));\n   }\n \n   if (id) {\n-    definitionMap.id = id;\n+    definitionMap.set('id', id);\n   }\n \n   const expression =\n-      o.importExpr(R3.defineNgModule).callFn([mapToMapExpression(definitionMap)], undefined, true);\n+      o.importExpr(R3.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\n   const type = new o.ExpressionType(o.importExpr(R3.NgModuleDefWithMeta, [\n     new o.ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports),\n     tupleTypeOf(exports)\n@@ -172,32 +202,29 @@ export function compileNgModule(meta: R3NgModuleMetadata): R3NgModuleDef {\n function generateSetNgModuleScopeCall(meta: R3NgModuleMetadata): o.Statement|null {\n   const {adjacentType: moduleType, declarations, imports, exports, containsForwardDecls} = meta;\n \n-  const scopeMap = {} as {\n-    declarations: o.Expression,\n-    imports: o.Expression,\n-    exports: o.Expression,\n-  };\n+  const scopeMap = new DefinitionMap<\n+      {declarations: o.Expression, imports: o.Expression, exports: o.Expression}>();\n \n   if (declarations.length) {\n-    scopeMap.declarations = refsToArray(declarations, containsForwardDecls);\n+    scopeMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n   }\n \n   if (imports.length) {\n-    scopeMap.imports = refsToArray(imports, containsForwardDecls);\n+    scopeMap.set('imports', refsToArray(imports, containsForwardDecls));\n   }\n \n   if (exports.length) {\n-    scopeMap.exports = refsToArray(exports, containsForwardDecls);\n+    scopeMap.set('exports', refsToArray(exports, containsForwardDecls));\n   }\n \n-  if (Object.keys(scopeMap).length === 0) {\n+  if (Object.keys(scopeMap.values).length === 0) {\n     return null;\n   }\n \n   // setNgModuleScope(...)\n   const fnCall = new o.InvokeFunctionExpr(\n       /* fn */ o.importExpr(R3.setNgModuleScope),\n-      /* args */[moduleType, mapToMapExpression(scopeMap)]);\n+      /* args */[moduleType, scopeMap.toLiteralMap()]);\n \n   // (ngJitMode guard) && setNgModuleScope(...)\n   const guardedCall = jitOnlyGuardedExpression(fnCall);\n@@ -229,18 +256,18 @@ export interface R3InjectorMetadata {\n }\n \n export function compileInjector(meta: R3InjectorMetadata): R3InjectorDef {\n-  const definitionMap: Record<string, o.Expression> = {};\n+  const definitionMap = new DefinitionMap<{providers: o.Expression, imports: o.Expression}>();\n \n   if (meta.providers !== null) {\n-    definitionMap.providers = meta.providers;\n+    definitionMap.set('providers', meta.providers);\n   }\n \n   if (meta.imports.length > 0) {\n-    definitionMap.imports = o.literalArr(meta.imports);\n+    definitionMap.set('imports', o.literalArr(meta.imports));\n   }\n \n   const expression =\n-      o.importExpr(R3.defineInjector).callFn([mapToMapExpression(definitionMap)], undefined, true);\n+      o.importExpr(R3.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);\n   const type =\n       new o.ExpressionType(o.importExpr(R3.InjectorDef, [new o.ExpressionType(meta.type.type)]));\n   return {expression, type};"
        },
        {
            "sha": "89b1b47d7a5f2e8e5ae23853973313d6450b664c",
            "filename": "packages/compiler/src/render3/util.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 15,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/28a7fba29a6b224562bf0acd373dd6307f429c1d/packages%2Fcompiler%2Fsrc%2Frender3%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/28a7fba29a6b224562bf0acd373dd6307f429c1d/packages%2Fcompiler%2Fsrc%2Frender3%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Futil.ts?ref=28a7fba29a6b224562bf0acd373dd6307f429c1d",
            "patch": "@@ -11,21 +11,6 @@ import {escapeIdentifier} from '../output/abstract_emitter';\n import * as o from '../output/output_ast';\n import {OutputContext} from '../util';\n \n-/**\n- * Convert an object map with `Expression` values into a `LiteralMapExpr`.\n- */\n-export function mapToMapExpression(map: {[key: string]: o.Expression|undefined}): o.LiteralMapExpr {\n-  const result = Object.keys(map).map(\n-      key => ({\n-        key,\n-        // The assertion here is because really TypeScript doesn't allow us to express that if the\n-        // key is present, it will have a value, but this is true in reality.\n-        value: map[key]!,\n-        quoted: false,\n-      }));\n-  return o.literalMap(result);\n-}\n-\n /**\n  * Convert metadata into an `Expression` in the given `OutputContext`.\n  *"
        }
    ],
    "stats": {
        "total": 118,
        "additions": 67,
        "deletions": 51
    }
}