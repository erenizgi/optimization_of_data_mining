{
    "author": "atscott",
    "message": "refactor(language-service): Add type to `TemplateTarget` that can indicate multi-node targets (#40185)\n\nThe current template target implementation only allows a way to\nrepresent the template position as targeting a single node in the\ntemplate AST. However, there is at least one case (banana-in-a-box)\nwhere a given template position refers to two template targets.\n\nThis commit expands the contexts that the `TemplateTarget` can return to\ninclude support for the banana-in-a-box syntax, which has two logically\ntargetted AST nodes given a position within the `keySpan` of the\nbinding.\n\nPR Close #40185",
    "sha": "a893187d51494ac8ec41b700359e372f11c2092a",
    "files": [
        {
            "sha": "c1b61d7da402cdc652048ff75b2fa1e8a1dbffd4",
            "filename": "packages/language-service/ivy/definitions.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/a893187d51494ac8ec41b700359e372f11c2092a/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "raw_url": "https://github.com/angular/angular/raw/a893187d51494ac8ec41b700359e372f11c2092a/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts?ref=a893187d51494ac8ec41b700359e372f11c2092a",
            "patch": "@@ -12,7 +12,7 @@ import {isExternalResource} from '@angular/compiler-cli/src/ngtsc/metadata';\n import {DirectiveSymbol, DomBindingSymbol, ElementSymbol, ShimLocation, Symbol, SymbolKind, TemplateSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript';\n \n-import {getTargetAtPosition} from './template_target';\n+import {getTargetAtPosition, TargetNodeKind} from './template_target';\n import {findTightestNode, getParentClassDeclaration} from './ts_utils';\n import {flatMap, getDirectiveMatchesForAttribute, getDirectiveMatchesForElementTag, getTemplateInfoAtPosition, getTextSpanOfNode, isDollarEvent, isTypeScriptFile, TemplateInfo, toTextSpan} from './utils';\n \n@@ -226,14 +226,16 @@ export class DefinitionBuilder {\n     if (target === null) {\n       return undefined;\n     }\n-    const {nodeInContext, parent} = target;\n+    const {context, parent} = target;\n \n-    const symbol =\n-        this.compiler.getTemplateTypeChecker().getSymbolOfNode(nodeInContext.node, component);\n+    const node =\n+        context.kind === TargetNodeKind.TwoWayBindingContext ? context.nodes[0] : context.node;\n+\n+    const symbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(node, component);\n     if (symbol === null) {\n       return undefined;\n     }\n-    return {node: nodeInContext.node, parent, symbol};\n+    return {node, parent, symbol};\n   }\n }\n "
        },
        {
            "sha": "3771192c4f87c400a1774f43f6a13fa91e465ab4",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 8,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/a893187d51494ac8ec41b700359e372f11c2092a/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/a893187d51494ac8ec41b700359e372f11c2092a/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=a893187d51494ac8ec41b700359e372f11c2092a",
            "patch": "@@ -19,7 +19,7 @@ import {CompletionBuilder, CompletionNodeContext} from './completions';\n import {DefinitionBuilder} from './definitions';\n import {QuickInfoBuilder} from './quick_info';\n import {ReferenceBuilder} from './references';\n-import {getTargetAtPosition, TargetNode, TargetNodeKind} from './template_target';\n+import {getTargetAtPosition, TargetContext, TargetNodeKind} from './template_target';\n import {getTemplateInfoAtPosition, isTypeScriptFile} from './utils';\n \n export class LanguageService {\n@@ -104,10 +104,11 @@ export class LanguageService {\n     if (positionDetails === null) {\n       return undefined;\n     }\n-    const results =\n-        new QuickInfoBuilder(\n-            this.tsLS, compiler, templateInfo.component, positionDetails.nodeInContext.node)\n-            .get();\n+\n+    const node = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?\n+        positionDetails.context.nodes[0] :\n+        positionDetails.context.node;\n+    const results = new QuickInfoBuilder(this.tsLS, compiler, templateInfo.component, node).get();\n     this.compilerFactory.registerLastKnownProgram();\n     return results;\n   }\n@@ -131,9 +132,13 @@ export class LanguageService {\n     if (positionDetails === null) {\n       return null;\n     }\n+\n+    const node = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?\n+        positionDetails.context.nodes[0] :\n+        positionDetails.context.node;\n     return new CompletionBuilder(\n-        this.tsLS, compiler, templateInfo.component, positionDetails.nodeInContext.node,\n-        nodeContextFromTarget(positionDetails.nodeInContext), positionDetails.parent,\n+        this.tsLS, compiler, templateInfo.component, node,\n+        nodeContextFromTarget(positionDetails.context), positionDetails.parent,\n         positionDetails.template);\n   }\n \n@@ -260,7 +265,7 @@ function getOrCreateTypeCheckScriptInfo(\n   return scriptInfo;\n }\n \n-function nodeContextFromTarget(target: TargetNode): CompletionNodeContext {\n+function nodeContextFromTarget(target: TargetContext): CompletionNodeContext {\n   switch (target.kind) {\n     case TargetNodeKind.ElementInTagContext:\n       return CompletionNodeContext.ElementTag;"
        },
        {
            "sha": "81ba73a9c5706c3d6fdb7c3e7909fc1292dd8f0c",
            "filename": "packages/language-service/ivy/references.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/a893187d51494ac8ec41b700359e372f11c2092a/packages%2Flanguage-service%2Fivy%2Freferences.ts",
            "raw_url": "https://github.com/angular/angular/raw/a893187d51494ac8ec41b700359e372f11c2092a/packages%2Flanguage-service%2Fivy%2Freferences.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Freferences.ts?ref=a893187d51494ac8ec41b700359e372f11c2092a",
            "patch": "@@ -12,7 +12,7 @@ import {DirectiveSymbol, SymbolKind, TemplateTypeChecker, TypeCheckingProgramStr\n import {ExpressionIdentifier, hasExpressionIdentifier} from '@angular/compiler-cli/src/ngtsc/typecheck/src/comments';\n import * as ts from 'typescript';\n \n-import {getTargetAtPosition} from './template_target';\n+import {getTargetAtPosition, TargetNodeKind} from './template_target';\n import {findTightestNode} from './ts_utils';\n import {getDirectiveMatchesForAttribute, getDirectiveMatchesForElementTag, getTemplateInfoAtPosition, isWithin, TemplateInfo, toTextSpan} from './utils';\n \n@@ -39,7 +39,9 @@ export class ReferenceBuilder {\n       return undefined;\n     }\n \n-    const node = positionDetails.nodeInContext.node;\n+    const node = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?\n+        positionDetails.context.nodes[0] :\n+        positionDetails.context.node;\n \n     // Get the information about the TCB at the template position.\n     const symbol = this.ttc.getSymbolOfNode(node, component);\n@@ -74,13 +76,12 @@ export class ReferenceBuilder {\n       case SymbolKind.Variable: {\n         const {positionInShimFile: initializerPosition, shimPath} = symbol.initializerLocation;\n         const localVarPosition = symbol.localVarLocation.positionInShimFile;\n-        const templateNode = positionDetails.nodeInContext.node;\n \n-        if ((templateNode instanceof TmplAstVariable)) {\n-          if (templateNode.valueSpan !== undefined && isWithin(position, templateNode.valueSpan)) {\n+        if ((node instanceof TmplAstVariable)) {\n+          if (node.valueSpan !== undefined && isWithin(position, node.valueSpan)) {\n             // In the valueSpan of the variable, we want to get the reference of the initializer.\n             return this.getReferencesAtTypescriptPosition(shimPath, initializerPosition);\n-          } else if (isWithin(position, templateNode.keySpan)) {\n+          } else if (isWithin(position, node.keySpan)) {\n             // In the keySpan of the variable, we want to get the reference of the local variable.\n             return this.getReferencesAtTypescriptPosition(shimPath, localVarPosition);\n           } else {"
        },
        {
            "sha": "6c94a2b544c176b1ad00ac6b2b5d2c854847197f",
            "filename": "packages/language-service/ivy/template_target.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 9,
            "changes": 39,
            "blob_url": "https://github.com/angular/angular/blob/a893187d51494ac8ec41b700359e372f11c2092a/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "raw_url": "https://github.com/angular/angular/raw/a893187d51494ac8ec41b700359e372f11c2092a/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts?ref=a893187d51494ac8ec41b700359e372f11c2092a",
            "patch": "@@ -10,7 +10,7 @@ import {ParseSpan, TmplAstBoundEvent} from '@angular/compiler';\n import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n \n-import {isTemplateNode, isTemplateNodeWithKeyAndValue, isWithin, isWithinKeyValue} from './utils';\n+import {isTemplateNodeWithKeyAndValue, isWithin, isWithinKeyValue} from './utils';\n \n /**\n  * Contextual information for a target position within the template.\n@@ -22,9 +22,9 @@ export interface TemplateTarget {\n   position: number;\n \n   /**\n-   * The template node (or AST expression) closest to the search position.\n+   * The template (or AST expression) node or nodes closest to the search position.\n    */\n-  nodeInContext: TargetNode;\n+  context: TargetContext;\n \n   /**\n    * The `t.Template` which contains the found node or expression (or `null` if in the root\n@@ -39,15 +39,26 @@ export interface TemplateTarget {\n }\n \n /**\n- * A node targeted at a given position in the template, including potential contextual information\n- * about the specific aspect of the node being referenced.\n+ * A node or nodes targeted at a given position in the template, including potential contextual\n+ * information about the specific aspect of the node being referenced.\n  *\n  * Some nodes have multiple interior contexts. For example, `t.Element` nodes have both a tag name\n  * as well as a body, and a given position definitively points to one or the other. `TargetNode`\n  * captures the node itself, as well as this additional contextual disambiguation.\n  */\n-export type TargetNode = RawExpression|RawTemplateNode|ElementInBodyContext|ElementInTagContext|\n-    AttributeInKeyContext|AttributeInValueContext;\n+export type TargetContext = SingleNodeTarget|MultiNodeTarget;\n+\n+/** Contexts which logically target only a single node in the template AST. */\n+export type SingleNodeTarget = RawExpression|RawTemplateNode|ElementInBodyContext|\n+    ElementInTagContext|AttributeInKeyContext|AttributeInValueContext;\n+\n+/**\n+ * Contexts which logically target multiple nodes in the template AST, which cannot be\n+ * disambiguated given a single position because they are all equally relavent. For example, in the\n+ * banana-in-a-box syntax `[(ngModel)]=\"formValues.person\"`, the position in the template for the\n+ * key `ngModel` refers to both the bound event `ngModelChange` and the input `ngModel`.\n+ */\n+export type MultiNodeTarget = TwoWayBindingContext;\n \n /**\n  * Differentiates the various kinds of `TargetNode`s.\n@@ -59,6 +70,7 @@ export enum TargetNodeKind {\n   ElementInBodyContext,\n   AttributeInKeyContext,\n   AttributeInValueContext,\n+  TwoWayBindingContext,\n }\n \n /**\n@@ -105,6 +117,15 @@ export interface AttributeInValueContext {\n   node: t.TextAttribute|t.BoundAttribute|t.BoundEvent;\n }\n \n+/**\n+ * A `t.BoundAttribute` and `t.BoundEvent` pair that are targeted, where the given position is\n+ * within the key span of both.\n+ */\n+export interface TwoWayBindingContext {\n+  kind: TargetNodeKind.TwoWayBindingContext;\n+  nodes: [t.BoundAttribute, t.BoundEvent];\n+}\n+\n /**\n  * This special marker is added to the path when the cursor is within the sourceSpan but not the key\n  * or value span of a node with key/value spans.\n@@ -141,7 +162,7 @@ export function getTargetAtPosition(template: t.Node[], position: number): Templ\n   }\n \n   // Given the candidate node, determine the full targeted context.\n-  let nodeInContext: TargetNode;\n+  let nodeInContext: TargetContext;\n   if (candidate instanceof e.AST) {\n     nodeInContext = {\n       kind: TargetNodeKind.RawExpression,\n@@ -188,7 +209,7 @@ export function getTargetAtPosition(template: t.Node[], position: number): Templ\n     };\n   }\n \n-  return {position, nodeInContext, template: context, parent};\n+  return {position, context: nodeInContext, template: context, parent};\n }\n \n /**"
        },
        {
            "sha": "52e58a790341d8659841bdb57d00a31e0ff952aa",
            "filename": "packages/language-service/ivy/test/legacy/template_target_spec.ts",
            "status": "modified",
            "additions": 147,
            "deletions": 147,
            "changes": 294,
            "blob_url": "https://github.com/angular/angular/blob/a893187d51494ac8ec41b700359e372f11c2092a/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a893187d51494ac8ec41b700359e372f11c2092a/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts?ref=a893187d51494ac8ec41b700359e372f11c2092a",
            "patch": "@@ -10,7 +10,7 @@ import {ParseError, parseTemplate} from '@angular/compiler';\n import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n \n-import {getTargetAtPosition, TargetNodeKind} from '../../template_target';\n+import {getTargetAtPosition, SingleNodeTarget, TargetNodeKind} from '../../template_target';\n import {isExpressionNode, isTemplateNode} from '../../utils';\n \n interface ParseResult {\n@@ -36,53 +36,53 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate element in opening tag', () => {\n     const {errors, nodes, position} = parse(`<di¦v></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate element in closing tag', () => {\n     const {errors, nodes, position} = parse(`<div></di¦v>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate element when cursor is at the beginning', () => {\n     const {errors, nodes, position} = parse(`<¦div></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate element when cursor is at the end', () => {\n     const {errors, nodes, position} = parse(`<div¦></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate attribute key', () => {\n     const {errors, nodes, position} = parse(`<div cla¦ss=\"foo\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate attribute value', () => {\n     const {errors, nodes, position} = parse(`<div class=\"fo¦o\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     // TODO: Note that we do not have the ability to detect the RHS (yet)\n     expect(node).toBeInstanceOf(t.TextAttribute);\n@@ -91,17 +91,17 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate bound attribute key', () => {\n     const {errors, nodes, position} = parse(`<test-cmp [fo¦o]=\"bar\"></test-cmp>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n   });\n \n   it('should locate bound attribute value', () => {\n     const {errors, nodes, position} = parse(`<test-cmp [foo]=\"b¦ar\"></test-cmp>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n@@ -116,26 +116,26 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate bound event key', () => {\n     const {errors, nodes, position} = parse(`<test-cmp (fo¦o)=\"bar()\"></test-cmp>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundEvent);\n   });\n \n   it('should locate bound event value', () => {\n     const {errors, nodes, position} = parse(`<test-cmp (foo)=\"b¦ar()\"></test-cmp>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.MethodCall);\n   });\n \n   it('should locate element children', () => {\n     const {errors, nodes, position} = parse(`<div><sp¦an></span></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n     expect((node as t.Element).name).toBe('span');\n@@ -144,44 +144,44 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate element reference', () => {\n     const {errors, nodes, position} = parse(`<div #my¦div></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n   });\n \n   it('should locate template text attribute', () => {\n     const {errors, nodes, position} = parse(`<ng-template ng¦If></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate template bound attribute key', () => {\n     const {errors, nodes, position} = parse(`<ng-template [ng¦If]=\"foo\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n   });\n \n   it('should locate template bound attribute value', () => {\n     const {errors, nodes, position} = parse(`<ng-template [ngIf]=\"f¦oo\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate template bound attribute key in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<ng-template [(f¦oo)]=\"bar\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('foo');\n@@ -190,8 +190,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template bound attribute value in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<ng-template [(foo)]=\"b¦ar\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('bar');\n@@ -200,34 +200,34 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template bound event key', () => {\n     const {errors, nodes, position} = parse(`<ng-template (cl¦ick)=\"foo()\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundEvent);\n   });\n \n   it('should locate template bound event value', () => {\n     const {errors, nodes, position} = parse(`<ng-template (click)=\"f¦oo()\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(node).toBeInstanceOf(e.MethodCall);\n   });\n \n   it('should locate template attribute key', () => {\n     const {errors, nodes, position} = parse(`<ng-template i¦d=\"foo\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate template attribute value', () => {\n     const {errors, nodes, position} = parse(`<ng-template id=\"f¦oo\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     // TODO: Note that we do not have the ability to detect the RHS (yet)\n     expect(node).toBeInstanceOf(t.TextAttribute);\n@@ -236,8 +236,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template reference key via the # notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template #f¦oo></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n     expect((node as t.Reference).name).toBe('foo');\n@@ -246,8 +246,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template reference key via the ref- notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template ref-fo¦o></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n     expect((node as t.Reference).name).toBe('foo');\n@@ -256,8 +256,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template reference value via the # notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template #foo=\"export¦As\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n     expect((node as t.Reference).value).toBe('exportAs');\n@@ -267,8 +267,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template reference value via the ref- notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template ref-foo=\"export¦As\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n     expect((node as t.Reference).value).toBe('exportAs');\n@@ -278,53 +278,53 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template variable key', () => {\n     const {errors, nodes, position} = parse(`<ng-template let-f¦oo=\"bar\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n   });\n \n   it('should locate template variable value', () => {\n     const {errors, nodes, position} = parse(`<ng-template let-foo=\"b¦ar\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n   });\n \n   it('should locate template children', () => {\n     const {errors, nodes, position} = parse(`<ng-template><d¦iv></div></ng-template>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate ng-content', () => {\n     const {errors, nodes, position} = parse(`<ng-co¦ntent></ng-content>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Content);\n   });\n \n   it('should locate ng-content attribute key', () => {\n     const {errors, nodes, position} = parse('<ng-content cla¦ss=\"red\"></ng-content>');\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate ng-content attribute value', () => {\n     const {errors, nodes, position} = parse('<ng-content class=\"r¦ed\"></ng-content>');\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     // TODO: Note that we do not have the ability to detect the RHS (yet)\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n@@ -333,17 +333,17 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should not locate implicit receiver', () => {\n     const {errors, nodes, position} = parse(`<div [foo]=\"¦bar\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate bound attribute key in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<cmp [(f¦oo)]=\"bar\"></cmp>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('foo');\n@@ -352,8 +352,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate bound attribute value in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<cmp [(foo)]=\"b¦ar\"></cmp>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('bar');\n@@ -362,8 +362,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate switch value in ICUs', () => {\n     const {errors, nodes, position} = parse(`<span i18n>{sw¦itch, plural, other {text}}\"></span>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('switch');\n@@ -373,8 +373,8 @@ describe('getTargetAtPosition for template AST', () => {\n     const {errors, nodes, position} = parse(\n         `<span i18n>{expr, plural, other { {ne¦sted, plural, =1 { {{nestedInterpolation}} }} }}\"></span>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('nested');\n@@ -384,8 +384,8 @@ describe('getTargetAtPosition for template AST', () => {\n     const {errors, nodes, position} =\n         parse(`<span i18n>{expr, plural, other { {{ i¦nterpolation }} }}\"></span>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('interpolation');\n@@ -395,8 +395,8 @@ describe('getTargetAtPosition for template AST', () => {\n     const {errors, nodes, position} = parse(\n         `<span i18n>{expr, plural, other { {nested, plural, =1 { {{n¦estedInterpolation}} }} }}\"></span>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('nestedInterpolation');\n@@ -407,8 +407,8 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should not locate implicit receiver', () => {\n     const {errors, nodes, position} = parse(`{{ ¦title }}`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('title');\n@@ -417,8 +417,8 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should locate property read', () => {\n     const {errors, nodes, position} = parse(`{{ ti¦tle }}`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('title');\n@@ -427,8 +427,8 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should locate safe property read', () => {\n     const {errors, nodes, position} = parse(`{{ foo?¦.bar }}`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.SafePropertyRead);\n     expect((node as e.SafePropertyRead).name).toBe('bar');\n@@ -437,44 +437,44 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should locate keyed read', () => {\n     const {errors, nodes, position} = parse(`{{ foo['bar']¦ }}`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.KeyedRead);\n   });\n \n   it('should locate property write', () => {\n     const {errors, nodes, position} = parse(`<div (foo)=\"b¦ar=$event\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyWrite);\n   });\n \n   it('should locate keyed write', () => {\n     const {errors, nodes, position} = parse(`<div (foo)=\"bar['baz']¦=$event\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.KeyedWrite);\n   });\n \n   it('should locate binary', () => {\n     const {errors, nodes, position} = parse(`{{ 1 +¦ 2 }}`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.Binary);\n   });\n \n   it('should locate binding pipe with an identifier', () => {\n     const {errors, nodes, position} = parse(`{{ title | p¦ }}`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.BindingPipe);\n   });\n@@ -485,8 +485,8 @@ describe('getTargetAtPosition for expression AST', () => {\n     expect(errors![0].toString())\n         .toContain(\n             'Unexpected end of input, expected identifier or keyword at the end of the expression');\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     // TODO: We want this to be a BindingPipe.\n     expect(node).toBeInstanceOf(e.Interpolation);\n@@ -498,7 +498,7 @@ describe('getTargetAtPosition for expression AST', () => {\n          // parser throws an error. This case is important for autocomplete.\n          // const {errors, nodes, position} = parse(`{{ title | ¦ }}`);\n          // expect(errors).toBe(null);\n-         // const {nodeInContext} = findNodeAtPosition(nodes, position)!;\n+         // const {context} = findNodeAtPosition(nodes, position)!;\n          // expect(isExpressionNode(node!)).toBe(true);\n          // expect(node).toBeInstanceOf(e.BindingPipe);\n      });\n@@ -507,26 +507,26 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should locate method call', () => {\n     const {errors, nodes, position} = parse(`{{ title.toString(¦) }}`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.MethodCall);\n   });\n \n   it('should locate safe method call', () => {\n     const {errors, nodes, position} = parse(`{{ title?.toString(¦) }}`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.SafeMethodCall);\n   });\n \n   it('should locate literal primitive in interpolation', () => {\n     const {errors, nodes, position} = parse(`{{ title.indexOf('t¦') }}`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralPrimitive);\n     expect((node as e.LiteralPrimitive).value).toBe('t');\n@@ -535,8 +535,8 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should locate literal primitive in binding', () => {\n     const {errors, nodes, position} = parse(`<div [id]=\"'t¦'\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralPrimitive);\n     expect((node as e.LiteralPrimitive).value).toBe('t');\n@@ -545,35 +545,35 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should locate empty expression', () => {\n     const {errors, nodes, position} = parse(`<div [id]=\"¦\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.EmptyExpr);\n   });\n \n   it('should locate literal array', () => {\n     const {errors, nodes, position} = parse(`{{ [1, 2,¦ 3] }}`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralArray);\n   });\n \n   it('should locate literal map', () => {\n     const {errors, nodes, position} = parse(`{{ { hello:¦ \"world\" } }}`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralMap);\n   });\n \n   it('should locate conditional', () => {\n     const {errors, nodes, position} = parse(`{{ cond ?¦ true : false }}`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.Conditional);\n   });\n@@ -583,26 +583,26 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate template key', () => {\n     const {errors, nodes, position} = parse(`<div *ng¦If=\"foo\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n   });\n \n   it('should locate template value', () => {\n     const {errors, nodes, position} = parse(`<div *ngIf=\"f¦oo\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate property read next to variable in structural directive syntax', () => {\n     const {errors, nodes, position} = parse(`<div *ngIf=\"fo¦o as bar\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n@@ -612,8 +612,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n     // ngFor is a text attribute because the desugared form is\n     // <ng-template ngFor let-item [ngForOf]=\"items\">\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBeTrue();\n     expect(node).toBeInstanceOf(t.TextAttribute);\n     expect((node as t.TextAttribute).name).toBe('ngFor');\n@@ -629,8 +629,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate let variable', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let i¦tem of items\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n     expect((node as t.Variable).name).toBe('item');\n@@ -639,8 +639,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate bound attribute key', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item o¦f items\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('ngForOf');\n@@ -649,8 +649,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate bound attribute key when cursor is at the start', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item ¦of items\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const node = nodeInContext.node;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const node = (context as SingleNodeTarget).node;\n     expect(isTemplateNode(node)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('ngForOf');\n@@ -660,8 +660,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n     const {errors, nodes, position} =\n         parse(`<div *ngFor=\"let item of items; trac¦kBy: trackByFn\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('ngForTrackBy');\n@@ -674,8 +674,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n     const {errors, nodes, position} =\n         parse(`<div *ngFor=\"let item o¦f items; trackBy: trackByFn\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('ngForOf');\n@@ -684,8 +684,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate bound attribute value', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item of it¦ems\"></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('items');\n@@ -694,12 +694,12 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate template children', () => {\n     const {errors, nodes, position} = parse(`<di¦v *ngIf></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext, template: context} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context, template} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n     expect((node as t.Element).name).toBe('div');\n-    expect(context).toBeInstanceOf(t.Template);\n+    expect(template).toBeInstanceOf(t.Template);\n   });\n \n   it('should locate property read of variable declared within template', () => {\n@@ -708,17 +708,17 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n         {{ i¦ }}\n       </div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate LHS of variable declaration', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item of items; let i¦=index\">`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n     // TODO: Currently there is no way to distinguish LHS from RHS\n@@ -728,8 +728,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate RHS of variable declaration', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item of items; let i=in¦dex\">`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    const {node} = nodeInContext;\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = context as SingleNodeTarget;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n     // TODO: Currently there is no way to distinguish LHS from RHS\n@@ -739,16 +739,16 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate an element in its tag context', () => {\n     const {errors, nodes, position} = parse(`<div¦ attr></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    expect(nodeInContext.kind).toBe(TargetNodeKind.ElementInTagContext);\n-    expect(nodeInContext.node).toBeInstanceOf(t.Element);\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    expect(context.kind).toBe(TargetNodeKind.ElementInTagContext);\n+    expect((context as SingleNodeTarget).node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate an element in its body context', () => {\n     const {errors, nodes, position} = parse(`<div ¦ attr></div>`);\n     expect(errors).toBe(null);\n-    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n-    expect(nodeInContext.kind).toBe(TargetNodeKind.ElementInBodyContext);\n-    expect(nodeInContext.node).toBeInstanceOf(t.Element);\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    expect(context.kind).toBe(TargetNodeKind.ElementInBodyContext);\n+    expect((context as SingleNodeTarget).node).toBeInstanceOf(t.Element);\n   });\n });"
        }
    ],
    "stats": {
        "total": 379,
        "additions": 204,
        "deletions": 175
    }
}