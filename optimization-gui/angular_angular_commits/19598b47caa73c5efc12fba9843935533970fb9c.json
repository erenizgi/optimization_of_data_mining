{
    "author": "atscott",
    "message": "feat(compiler-cli): add ability to get symbol of reference or variable (#38618)\n\nAdds `TemplateTypeChecker` operation to retrieve the `Symbol` of a\n`TmplAstVariable` or `TmplAstReference` in a template.\n\nSometimes we need to traverse an intermediate variable declaration to arrive at\nthe correct `ts.Symbol`. For example, loop variables are declared using an intermediate:\n```\n<div *ngFor=\"let user of users\">\n  {{user.name}}\n</div>\n```\nGetting the symbol of user here (from the expression) is tricky, because the TCB looks like:\n\n```\nvar _t0 = ...; // type of NgForOf\nvar _t1: any; // context of embedded view for NgForOf structural directive\nif (NgForOf.ngTemplateContextGuard(_t0, _t1)) {\n  // _t1 is now NgForOfContext<...>\n  var _t2 = _t1.$implicit; // let user = '$implicit'\n  _t2.name; // user.name expression\n}\n```\nJust getting the `ts.Expression` for the `AST` node `PropRead(ImplicitReceiver, 'user')`\nvia the sourcemaps will yield the `_t2` expression.  This function recognizes that `_t2`\nis a variable declared locally in the TCB, and actually fetch the `ts.Symbol` of its initializer.\n\nThese special handlings show the versatility of the `Symbol`\ninterface defined in the API. With this, when we encounter a template variable,\nwe can provide the declaration node, as well as specific information\nabout the variable instance, such as the `ts.Type` and `ts.Symbol`.\n\nPR Close #38618",
    "sha": "19598b47caa73c5efc12fba9843935533970fb9c",
    "files": [
        {
            "sha": "1996140dca067a80925c46b9648b3786628dd0d0",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "modified",
            "additions": 67,
            "deletions": 3,
            "changes": 70,
            "blob_url": "https://github.com/angular/angular/blob/19598b47caa73c5efc12fba9843935533970fb9c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/19598b47caa73c5efc12fba9843935533970fb9c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=19598b47caa73c5efc12fba9843935533970fb9c",
            "patch": "@@ -6,12 +6,12 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AbsoluteSourceSpan, AST, ASTWithSource, BindingPipe, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n+import {AbsoluteSourceSpan, AST, ASTWithSource, BindingPipe, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {AbsoluteFsPath} from '../../file_system';\n import {isAssignment} from '../../util/src/typescript';\n-import {DirectiveSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, Symbol, SymbolKind, TemplateSymbol, TsNodeSymbolInfo} from '../api';\n+import {DirectiveSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, ReferenceSymbol, Symbol, SymbolKind, TemplateSymbol, TsNodeSymbolInfo, VariableSymbol} from '../api';\n \n import {ExpressionIdentifier, findAllMatchingNodes, findFirstMatchingNode, hasExpressionIdentifier} from './comments';\n import {TemplateData} from './context';\n@@ -28,6 +28,7 @@ export class SymbolBuilder {\n       private readonly typeCheckBlock: ts.Node, private readonly templateData: TemplateData) {}\n \n   getSymbol(node: TmplAstTemplate|TmplAstElement): TemplateSymbol|ElementSymbol|null;\n+  getSymbol(node: TmplAstReference|TmplAstVariable): ReferenceSymbol|VariableSymbol|null;\n   getSymbol(node: AST|TmplAstNode): Symbol|null;\n   getSymbol(node: AST|TmplAstNode): Symbol|null {\n     if (node instanceof TmplAstBoundAttribute) {\n@@ -40,6 +41,10 @@ export class SymbolBuilder {\n       return this.getSymbolOfElement(node);\n     } else if (node instanceof TmplAstTemplate) {\n       return this.getSymbolOfAstTemplate(node);\n+    } else if (node instanceof TmplAstVariable) {\n+      return this.getSymbolOfVariable(node);\n+    } else if (node instanceof TmplAstReference) {\n+      return this.getSymbolOfReference(node);\n     } else if (node instanceof AST) {\n       return this.getSymbolOfTemplateExpression(node);\n     }\n@@ -226,11 +231,70 @@ export class SymbolBuilder {\n     };\n   }\n \n-  private getSymbolOfTemplateExpression(expression: AST): ExpressionSymbol|null {\n+  private getSymbolOfVariable(variable: TmplAstVariable): VariableSymbol|null {\n+    const node = findFirstMatchingNode(\n+        this.typeCheckBlock, {withSpan: variable.sourceSpan, filter: ts.isVariableDeclaration});\n+    if (node === null) {\n+      return null;\n+    }\n+\n+    const expressionSymbol = this.getSymbolOfVariableDeclaration(node);\n+    if (expressionSymbol === null) {\n+      return null;\n+    }\n+\n+    return {...expressionSymbol, kind: SymbolKind.Variable, declaration: variable};\n+  }\n+\n+  private getSymbolOfReference(ref: TmplAstReference): ReferenceSymbol|null {\n+    const target = this.templateData.boundTarget.getReferenceTarget(ref);\n+    // Find the node for the reference declaration, i.e. `var _t2 = _t1;`\n+    let node = findFirstMatchingNode(\n+        this.typeCheckBlock, {withSpan: ref.sourceSpan, filter: ts.isVariableDeclaration});\n+    if (node === null || target === null || node.initializer === undefined) {\n+      return null;\n+    }\n+\n+    // TODO(atscott): Shim location will need to be adjusted\n+    const symbol = this.getSymbolOfTsNode(node.name);\n+    if (symbol === null || symbol.tsSymbol === null) {\n+      return null;\n+    }\n+\n+    if (target instanceof TmplAstTemplate || target instanceof TmplAstElement) {\n+      return {\n+        ...symbol,\n+        tsSymbol: symbol.tsSymbol,\n+        kind: SymbolKind.Reference,\n+        target,\n+        declaration: ref,\n+      };\n+    } else {\n+      if (!ts.isClassDeclaration(target.directive.ref.node)) {\n+        return null;\n+      }\n+\n+      return {\n+        ...symbol,\n+        kind: SymbolKind.Reference,\n+        tsSymbol: symbol.tsSymbol,\n+        declaration: ref,\n+        target: target.directive.ref.node,\n+      };\n+    }\n+  }\n+\n+  private getSymbolOfTemplateExpression(expression: AST): VariableSymbol|ReferenceSymbol\n+      |ExpressionSymbol|null {\n     if (expression instanceof ASTWithSource) {\n       expression = expression.ast;\n     }\n \n+    const expressionTarget = this.templateData.boundTarget.getExpressionTarget(expression);\n+    if (expressionTarget !== null) {\n+      return this.getSymbol(expressionTarget);\n+    }\n+\n     let node = findFirstMatchingNode(\n         this.typeCheckBlock,\n         {withSpan: expression.sourceSpan, filter: (n: ts.Node): n is ts.Node => true});"
        },
        {
            "sha": "2daf890ba02ee131fc3ceb3aa9048c0289b02256",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 185,
            "deletions": 2,
            "changes": 187,
            "blob_url": "https://github.com/angular/angular/blob/19598b47caa73c5efc12fba9843935533970fb9c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/19598b47caa73c5efc12fba9843935533970fb9c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=19598b47caa73c5efc12fba9843935533970fb9c",
            "patch": "@@ -6,13 +6,13 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ASTWithSource, Binary, BindingPipe, Conditional, Interpolation, PropertyRead, TmplAstBoundAttribute, TmplAstBoundText, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n+import {ASTWithSource, Binary, BindingPipe, Conditional, Interpolation, PropertyRead, TmplAstBoundAttribute, TmplAstBoundText, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {absoluteFrom, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n import {ClassDeclaration} from '../../reflection';\n-import {DirectiveSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, Symbol, SymbolKind, TemplateSymbol, TemplateTypeChecker, TypeCheckingConfig} from '../api';\n+import {DirectiveSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, ReferenceSymbol, Symbol, SymbolKind, TemplateSymbol, TemplateTypeChecker, TypeCheckingConfig, VariableSymbol} from '../api';\n \n import {getClass, ngForDeclaration, ngForTypeCheckTarget, setup as baseTestSetup, TypeCheckingTarget} from './test_utils';\n \n@@ -79,6 +79,59 @@ runInEachFileSystem(() => {\n           templateNode = getAstTemplates(templateTypeChecker, cmp)[0];\n         });\n \n+        it('should get symbol for variables at the declaration', () => {\n+          const symbol = templateTypeChecker.getSymbolOfNode(templateNode.variables[0], cmp)!;\n+          assertVariableSymbol(symbol);\n+          expect(program.getTypeChecker().typeToString(symbol.tsType!)).toEqual('any');\n+          expect(symbol.declaration.name).toEqual('contextFoo');\n+        });\n+\n+        it('should get symbol for variables when used', () => {\n+          const symbol = templateTypeChecker.getSymbolOfNode(\n+              (templateNode.children[0] as TmplAstTemplate).inputs[0].value, cmp)!;\n+          assertVariableSymbol(symbol);\n+          expect(program.getTypeChecker().typeToString(symbol.tsType!)).toEqual('any');\n+          expect(symbol.declaration.name).toEqual('contextFoo');\n+        });\n+\n+        it('should get a symbol for local ref which refers to a directive', () => {\n+          const symbol = templateTypeChecker.getSymbolOfNode(templateNode.references[1], cmp)!;\n+          assertReferenceSymbol(symbol);\n+          assertDirectiveReference(symbol);\n+        });\n+\n+        it('should get a symbol for usage local ref which refers to a directive', () => {\n+          const symbol = templateTypeChecker.getSymbolOfNode(\n+              (templateNode.children[0] as TmplAstTemplate).inputs[2].value, cmp)!;\n+          assertReferenceSymbol(symbol);\n+          assertDirectiveReference(symbol);\n+        });\n+\n+        function assertDirectiveReference(symbol: ReferenceSymbol) {\n+          expect(program.getTypeChecker().typeToString(symbol.tsType)).toEqual('TestDir');\n+          expect((symbol.target as ts.ClassDeclaration).name!.getText()).toEqual('TestDir');\n+          expect(symbol.declaration.name).toEqual('ref1');\n+        }\n+\n+        it('should get a symbol for local ref which refers to the template', () => {\n+          const symbol = templateTypeChecker.getSymbolOfNode(templateNode.references[0], cmp)!;\n+          assertReferenceSymbol(symbol);\n+          assertTemplateReference(symbol);\n+        });\n+\n+        it('should get a symbol for usage local ref which refers to a template', () => {\n+          const symbol = templateTypeChecker.getSymbolOfNode(\n+              (templateNode.children[0] as TmplAstTemplate).inputs[1].value, cmp)!;\n+          assertReferenceSymbol(symbol);\n+          assertTemplateReference(symbol);\n+        });\n+\n+        function assertTemplateReference(symbol: ReferenceSymbol) {\n+          expect(program.getTypeChecker().typeToString(symbol.tsType)).toEqual('TemplateRef<any>');\n+          expect((symbol.target as TmplAstTemplate).tagName).toEqual('ng-template');\n+          expect(symbol.declaration.name).toEqual('ref0');\n+        }\n+\n         it('should get symbol for the template itself', () => {\n           const symbol = templateTypeChecker.getSymbolOfNode(templateNode, cmp)!;\n           assertTemplateSymbol(symbol);\n@@ -150,7 +203,46 @@ runInEachFileSystem(() => {\n              expect(program.getTypeChecker().symbolToString(streetSymbol.tsSymbol!))\n                  .toEqual('streetNumber');\n              expect(program.getTypeChecker().typeToString(streetSymbol.tsType)).toEqual('number');\n+\n+             const userSymbol = templateTypeChecker.getSymbolOfNode(namePropRead.receiver, cmp)!;\n+             expectUserSymbol(userSymbol);\n            });\n+\n+        it('finds symbols for variables', () => {\n+          const userVar = templateNode.variables.find(v => v.name === 'user')!;\n+          const userSymbol = templateTypeChecker.getSymbolOfNode(userVar, cmp)!;\n+          expectUserSymbol(userSymbol);\n+\n+          const iVar = templateNode.variables.find(v => v.name === 'i')!;\n+          const iSymbol = templateTypeChecker.getSymbolOfNode(iVar, cmp)!;\n+          expectIndexSymbol(iSymbol);\n+        });\n+\n+        it('finds symbol when using a template variable', () => {\n+          const innerElementNodes =\n+              onlyAstElements((templateNode.children[0] as TmplAstElement).children);\n+          const indexSymbol =\n+              templateTypeChecker.getSymbolOfNode(innerElementNodes[0].inputs[0].value, cmp)!;\n+          expectIndexSymbol(indexSymbol);\n+        });\n+\n+        function expectUserSymbol(userSymbol: Symbol) {\n+          assertVariableSymbol(userSymbol);\n+          expect(userSymbol.tsSymbol!.escapedName).toContain('$implicit');\n+          expect(userSymbol.tsSymbol!.declarations[0].parent!.getText())\n+              .toContain('NgForOfContext');\n+          expect(program.getTypeChecker().typeToString(userSymbol.tsType!)).toEqual('User');\n+          expect((userSymbol).declaration).toEqual(templateNode.variables[0]);\n+        }\n+\n+        function expectIndexSymbol(indexSymbol: Symbol) {\n+          assertVariableSymbol(indexSymbol);\n+          expect(indexSymbol.tsSymbol!.escapedName).toContain('index');\n+          expect(indexSymbol.tsSymbol!.declarations[0].parent!.getText())\n+              .toContain('NgForOfContext');\n+          expect(program.getTypeChecker().typeToString(indexSymbol.tsType!)).toEqual('number');\n+          expect((indexSymbol).declaration).toEqual(templateNode.variables[1]);\n+        }\n       });\n     });\n \n@@ -364,6 +456,89 @@ runInEachFileSystem(() => {\n         expect(program.getTypeChecker().typeToString(bSymbol.tsType)).toEqual('number');\n       });\n \n+      it('should get symbol for local reference of an Element', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const {templateTypeChecker, program} = setup([\n+          {\n+            fileName,\n+            templates: {\n+              'Cmp': `\n+                  <input #myRef>\n+                  <div [input]=\"myRef\"></div>`\n+            },\n+          },\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+        const nodes = getAstElements(templateTypeChecker, cmp);\n+\n+        const refSymbol = templateTypeChecker.getSymbolOfNode(nodes[0].references[0], cmp)!;\n+        assertReferenceSymbol(refSymbol);\n+        expect((refSymbol.target as TmplAstElement).name).toEqual('input');\n+        expect((refSymbol.declaration as TmplAstReference).name).toEqual('myRef');\n+\n+        const myRefUsage = templateTypeChecker.getSymbolOfNode(nodes[1].inputs[0].value, cmp)!;\n+        assertReferenceSymbol(myRefUsage);\n+        expect((myRefUsage.target as TmplAstElement).name).toEqual('input');\n+        expect((myRefUsage.declaration as TmplAstReference).name).toEqual('myRef');\n+      });\n+\n+      it('should get symbols for references which refer to directives', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const templateString = `\n+        <div dir #myDir1=\"dir\"></div>\n+        <div dir #myDir2=\"dir\"></div>\n+        <div [inputA]=\"myDir1.dirValue\" [inputB]=\"myDir1\"></div>\n+        <div [inputA]=\"myDir2.dirValue\" [inputB]=\"myDir2\"></div>`;\n+        const {templateTypeChecker, program} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': templateString},\n+            declarations: [{\n+              name: 'TestDir',\n+              selector: '[dir]',\n+              file: dirFile,\n+              type: 'directive',\n+              exportAs: ['dir'],\n+            }]\n+          },\n+          {\n+            fileName: dirFile,\n+            source: `export class TestDir { dirValue = 'helloWorld' }`,\n+            templates: {}\n+          }\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+        const nodes = getAstElements(templateTypeChecker, cmp);\n+\n+        const ref1Declaration = templateTypeChecker.getSymbolOfNode(nodes[0].references[0], cmp)!;\n+        assertReferenceSymbol(ref1Declaration);\n+        expect((ref1Declaration.target as ts.ClassDeclaration).name!.getText()).toEqual('TestDir');\n+        expect((ref1Declaration.declaration as TmplAstReference).name).toEqual('myDir1');\n+\n+        const ref2Declaration = templateTypeChecker.getSymbolOfNode(nodes[1].references[0], cmp)!;\n+        assertReferenceSymbol(ref2Declaration);\n+        expect((ref2Declaration.target as ts.ClassDeclaration).name!.getText()).toEqual('TestDir');\n+        expect((ref2Declaration.declaration as TmplAstReference).name).toEqual('myDir2');\n+\n+        const dirValueSymbol = templateTypeChecker.getSymbolOfNode(nodes[2].inputs[0].value, cmp)!;\n+        assertExpressionSymbol(dirValueSymbol);\n+        expect(program.getTypeChecker().symbolToString(dirValueSymbol.tsSymbol!)).toBe('dirValue');\n+        expect(program.getTypeChecker().typeToString(dirValueSymbol.tsType)).toEqual('string');\n+\n+        const dir1Symbol = templateTypeChecker.getSymbolOfNode(nodes[2].inputs[1].value, cmp)!;\n+        assertReferenceSymbol(dir1Symbol);\n+        expect((dir1Symbol.target as ts.ClassDeclaration).name!.getText()).toEqual('TestDir');\n+        expect((dir1Symbol.declaration as TmplAstReference).name).toEqual('myDir1');\n+\n+        const dir2Symbol = templateTypeChecker.getSymbolOfNode(nodes[3].inputs[1].value, cmp)!;\n+        assertReferenceSymbol(dir2Symbol);\n+        expect((dir2Symbol.target as ts.ClassDeclaration).name!.getText()).toEqual('TestDir');\n+        expect((dir2Symbol.declaration as TmplAstReference).name).toEqual('myDir2');\n+      });\n+\n       describe('literals', () => {\n         let templateTypeChecker: TemplateTypeChecker;\n         let cmp: ClassDeclaration<ts.ClassDeclaration>;\n@@ -1061,10 +1236,18 @@ function assertOutputBindingSymbol(tSymbol: Symbol): asserts tSymbol is OutputBi\n   expect(tSymbol.kind).toEqual(SymbolKind.Output);\n }\n \n+function assertVariableSymbol(tSymbol: Symbol): asserts tSymbol is VariableSymbol {\n+  expect(tSymbol.kind).toEqual(SymbolKind.Variable);\n+}\n+\n function assertTemplateSymbol(tSymbol: Symbol): asserts tSymbol is TemplateSymbol {\n   expect(tSymbol.kind).toEqual(SymbolKind.Template);\n }\n \n+function assertReferenceSymbol(tSymbol: Symbol): asserts tSymbol is ReferenceSymbol {\n+  expect(tSymbol.kind).toEqual(SymbolKind.Reference);\n+}\n+\n function assertExpressionSymbol(tSymbol: Symbol): asserts tSymbol is ExpressionSymbol {\n   expect(tSymbol.kind).toEqual(SymbolKind.Expression);\n }"
        }
    ],
    "stats": {
        "total": 257,
        "additions": 252,
        "deletions": 5
    }
}