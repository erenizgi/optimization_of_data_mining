{
    "author": "kapunahelewong",
    "message": "docs: edit di providers doc (#39403)\n\nEdits copy and removes tokens and treeshaking\nsections to reduce content duplication and keep\ninfo focused. Moves provideParent() from di-navtree\nto di providers.\n\nPR Close #39403",
    "sha": "156f9f30ae13b84d71f3373b476b4e6cf66fe83a",
    "files": [
        {
            "sha": "5b1e770297c05f15e1eaa562050952ee28b0a859",
            "filename": "aio/content/examples/dependency-injection/src/app/providers.component.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fexamples%2Fdependency-injection%2Fsrc%2Fapp%2Fproviders.component.ts",
            "raw_url": "https://github.com/angular/angular/raw/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fexamples%2Fdependency-injection%2Fsrc%2Fapp%2Fproviders.component.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fexamples%2Fdependency-injection%2Fsrc%2Fapp%2Fproviders.component.ts?ref=156f9f30ae13b84d71f3373b476b4e6cf66fe83a",
            "patch": "@@ -205,7 +205,7 @@ export class Provider8Component {\n   template,\n   /*\n    // #docregion providers-9-interface\n-   // FAIL! Can't use interface as provider token\n+   // Can't use interface as provider token\n    [{ provide: AppConfig, useValue: HERO_DI_CONFIG })]\n    // #enddocregion providers-9-interface\n    */\n@@ -217,7 +217,7 @@ export class Provider9Component implements OnInit {\n   log: string;\n   /*\n    // #docregion provider-9-ctor-interface\n-   // FAIL! Can't inject using the interface as the parameter type\n+   // Can't inject using the interface as the parameter type\n    constructor(private config: AppConfig){ }\n    // #enddocregion provider-9-ctor-interface\n    */"
        },
        {
            "sha": "ac71ccca3f63602120a86e8cd940a85686fc349c",
            "filename": "aio/content/guide/architecture-services.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Farchitecture-services.md",
            "raw_url": "https://github.com/angular/angular/raw/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Farchitecture-services.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Farchitecture-services.md?ref=156f9f30ae13b84d71f3373b476b4e6cf66fe83a",
            "patch": "@@ -93,7 +93,7 @@ or in the `@NgModule()` or `@Component()` metadata\n    When you provide the service at the root level, Angular creates a single, shared instance of `HeroService`\n    and injects it into any class that asks for it.\n    Registering the provider in the `@Injectable()` metadata also allows Angular to optimize an app\n-   by removing the service from the compiled app if it isn't used.\n+   by removing the service from the compiled app if it isn't used, a process known as *tree-shaking*.\n \n * When you register a provider with a [specific NgModule](guide/architecture-modules), the same instance of a service is available to all components in that NgModule. To register at this level, use the `providers` property of the `@NgModule()` decorator.\n "
        },
        {
            "sha": "ff7b7b7b5d8cc380b59b006fc80742a880c1ac45",
            "filename": "aio/content/guide/creating-libraries.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Fcreating-libraries.md",
            "raw_url": "https://github.com/angular/angular/raw/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Fcreating-libraries.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fcreating-libraries.md?ref=156f9f30ae13b84d71f3373b476b4e6cf66fe83a",
            "patch": "@@ -79,7 +79,7 @@ Here are some things to consider in migrating application functionality to a lib\n \n * Consider how you provide services to client applications.\n \n-   * Services should declare their own providers (rather than declaring providers in the NgModule or a component), so that they are *tree-shakable*. This allows the compiler to leave the service out of the bundle if it never gets injected into the application that imports the library. For more about this, see [Tree-shakable providers](guide/dependency-injection-providers#tree-shakable-providers).\n+   * Services should declare their own providers, rather than declaring providers in the NgModule or a component. Declaring a provider makes that service *tree-shakable*. This practice allows the compiler to leave the service out of the bundle if it never gets injected into the application that imports the library. For more about this, see [Tree-shakable providers](guide/architecture-services#providing-services).\n \n    * If you register global service providers or share providers across multiple NgModules, use the [`forRoot()` and `forChild()` design patterns](guide/singleton-services) provided by the [RouterModule](api/router/RouterModule).\n "
        },
        {
            "sha": "e7c2a9035312e1049df2d7d0890e0a772d863af1",
            "filename": "aio/content/guide/dependency-injection-in-action.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Fdependency-injection-in-action.md",
            "raw_url": "https://github.com/angular/angular/raw/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Fdependency-injection-in-action.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fdependency-injection-in-action.md?ref=156f9f30ae13b84d71f3373b476b4e6cf66fe83a",
            "patch": "@@ -447,7 +447,7 @@ But they did neither.\n \n When you use a class this way, it's called a *class interface*.\n \n-As mentioned in [DI Providers](guide/dependency-injection-providers#interface-not-valid-token),\n+As mentioned in [DI Providers](guide/dependency-injection-providers#di-and-interfaces),\n an interface is not a valid DI token because it is a TypeScript artifact that doesn't exist at run time.\n Use this abstract class interface to get the strong typing of an interface,\n and also use it as a provider token in the way you would a normal class."
        },
        {
            "sha": "7f6b0032c834c0dc1286b0c6e1434e3c6a96e14b",
            "filename": "aio/content/guide/dependency-injection-providers.md",
            "status": "modified",
            "additions": 99,
            "deletions": 236,
            "changes": 335,
            "blob_url": "https://github.com/angular/angular/blob/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Fdependency-injection-providers.md",
            "raw_url": "https://github.com/angular/angular/raw/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Fdependency-injection-providers.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fdependency-injection-providers.md?ref=156f9f30ae13b84d71f3373b476b4e6cf66fe83a",
            "patch": "@@ -1,235 +1,210 @@\n # Dependency providers\n \n-A dependency [provider](guide/glossary#provider) configures an injector\n-with a [DI token](guide/glossary#di-token),\n-which that injector uses to provide the concrete, runtime version of a dependency value.\n-The injector relies on the provider configuration to create instances of the dependencies\n-that it injects into components, directives, pipes, and other services.\n+By configuring providers, you can make services available to the parts of your application that need them.\n \n-You must configure an injector with a provider, or it won't know how to create the dependency.\n-The most obvious way for an injector to create an instance of a service class is with the class itself.\n-If you specify the service class itself as the provider token, the default behavior is for the injector to instantiate that class with `new`.\n+A dependency [provider](guide/glossary#provider) configures an injector with a [DI token](guide/glossary#di-token), which that injector uses to provide the runtime version of a dependency value.\n \n-In the following typical example, the `Logger` class itself provides a `Logger` instance.\n+## Specifying a provider token\n+\n+If you specify the service class as the provider token, the default behavior is for the injector to instantiate that class with `new`.\n+\n+In the following example, the `Logger` class provides a `Logger` instance.\n \n <code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\n </code-example>\n \n-You can, however, configure an injector with an alternative provider,\n-in order to deliver some other object that provides the needed logging functionality.\n-For instance:\n-* You can provide a substitute class.\n-\n-* You can provide a logger-like object.\n+You can, however, configure an injector with an alternative provider in order to deliver some other object that provides the needed logging functionality.\n \n-* Your provider can call a logger factory function.\n+You can configure an injector with a service class, you can provide a substitute class, an object, or a factory function.\n \n {@a provide}\n \n-## The `Provider` object literal\n+##  Defining providers\n \n-The class-provider syntax is a shorthand expression that expands\n-into a provider configuration, defined by the [`Provider` interface](api/core/Provider).\n-The following code snippets shows how a class that is given as the `providers` value is expanded into a full provider object.\n+The class provider syntax is a shorthand expression that expands into a provider configuration, defined by the [`Provider` interface](api/core/Provider).\n+The following example is the class provider syntax for providing a `Logger` class in the `providers` array.\n \n <code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\n </code-example>\n \n+Angular expands the `providers` value into a full provider object as follows.\n+\n <code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-3\" >\n </code-example>\n \n The expanded provider configuration is an object literal with two properties.\n \n-* The `provide` property holds the [token](guide/dependency-injection#token)\n-that serves as the key for both locating a dependency value and configuring the injector.\n-\n-* The second property is a provider definition object, which tells the injector how to create the dependency value.\n+1. The `provide` property holds the [token](guide/dependency-injection#token) that serves as the key for both locating a dependency value and configuring the injector.\n+2. The second property is a provider definition object, which tells the injector how to create the dependency value.\n The provider-definition key can be `useClass`, as in the example.\n It can also be `useExisting`, `useValue`, or `useFactory`.\n Each of these keys provides a different type of dependency, as discussed below.\n \n \n {@a class-provider}\n \n-## Alternative class providers\n+## Configuring the injector to use alternative class providers\n \n-Different classes can provide the same service.\n-For example, the following code tells the injector\n-to return a `BetterLogger` instance when the component asks for a logger\n-using the `Logger` token.\n+To configure the injector to return a different class that provides the same service, you can use the `useClass` property.\n+In this example, the injector returns a `BetterLogger` instance when using the `Logger` token.\n \n <code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-4\" >\n </code-example>\n \n {@a class-provider-dependencies}\n \n-### Class providers with dependencies\n+### Configuring class providers with dependencies\n+\n+If the alternative class providers have their own dependencies, specify both providers in the `providers` metadata property of the parent module or component.\n \n-Another class, `EvenBetterLogger`, might display the user name in the log message.\n+<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-5\"></code-example>\n+\n+In this example, `EvenBetterLogger` displays the user name in the log message.\n This logger gets the user from an injected `UserService` instance.\n \n <code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"EvenBetterLogger\"></code-example>\n \n-The injector needs providers for both this new logging service and its dependent `UserService`. Configure this alternative logger with the `useClass` provider-definition key, like `BetterLogger`. The following array specifies both providers in the `providers` metadata option of the parent module or component.\n-\n-<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-5\"></code-example>\n+The injector needs providers for both this new logging service and its dependent `UserService`.\n \n {@a aliased-class-providers}\n \n-### Aliased class providers\n+### Aliasing class providers\n \n-Suppose an old component depends upon the `OldLogger` class.\n-`OldLogger` has the same interface as `NewLogger`, but for some reason\n-you can't update the old component to use it.\n+To alias a class provider, specify the alias and the class provider in the `providers` array with the `useExisting` property.\n \n-When the old component logs a message with `OldLogger`,\n-you want the singleton instance of `NewLogger` to handle it instead.\n-In this case, the dependency injector should inject that singleton instance\n-when a component asks for either the new or the old logger.\n-`OldLogger` should be an *alias* for `NewLogger`.\n+In the following example, the injector injects the singleton instance of `NewLogger` when the component asks for either the new or the old logger.\n+In this way, `OldLogger` is an alias for `NewLogger`.\n \n-If you try to alias `OldLogger` to `NewLogger` with `useClass`, you end up with two different `NewLogger` instances in your app.\n+<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6b\"></code-example>\n \n-<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6a\"></code-example>\n+Be sure you don't alias `OldLogger` to `NewLogger` with `useClass`, as this creates two different `NewLogger` instances.\n \n-To make sure there is only one instance of `NewLogger`, alias `OldLogger` with the `useExisting` option.\n \n-<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6b\"></code-example>\n+{@a provideparent}\n \n-{@a value-provider}\n \n-## Value providers\n+## Aliasing a class interface\n \n-Sometimes it's easier to provide a ready-made object rather than ask the injector to create it from a class.\n-To inject an object you have already created,\n-configure the injector with the `useValue` option\n+Generally, writing variations of the same parent alias provider uses [forwardRef](guide/dependency-injection-in-action#forwardref) as follows.\n \n-The following code defines a variable that creates such an object to play the logger role.\n+<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\"></code-example>\n \n-<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"silent-logger\"></code-example>\n+To streamline your code, you can extract that logic into a helper function using the `provideParent()` helper function.\n \n-The following provider object uses the `useValue` key to associate the variable with the `Logger` token.\n+<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"provide-the-parent\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\"></code-example>\n \n-<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-7\"></code-example>\n+Now you can add a parent provider to your components that's easier to read and understand.\n \n-{@a non-class-dependencies}\n+<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alice-providers\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\"></code-example>\n \n-### Non-class dependencies\n \n-Not all dependencies are classes.\n-Sometimes you want to inject a string, function, or object.\n+### Aliasing multiple class interfaces\n \n-Apps often define configuration objects with lots of small facts,\n-like the title of the application or the address of a web API endpoint.\n-These configuration objects aren't always instances of a class.\n-They can be object literals, as shown in the following example.\n+To alias multiple parent types, each with its own class interface token, configure `provideParent()` to accept more arguments.\n \n-<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"config\" header=\"src/app/app.config.ts (excerpt)\"></code-example>\n+Here's a revised version that defaults to `parent` but also accepts an optional second parameter for a different parent class interface.\n \n-{@a interface-not-valid-token}\n+<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"provide-parent\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\"></code-example>\n \n-**TypeScript interfaces are not valid tokens**\n+Next, to use `provideParent()` with a different parent type, provide a second argument, here `DifferentParent`.\n \n-The `HERO_DI_CONFIG` constant conforms to the `AppConfig` interface.\n-Unfortunately, you cannot use a TypeScript interface as a token.\n-In TypeScript, an interface is a design-time artifact, and doesn't have a runtime representation (token) that the DI framework can use.\n+<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"beth-providers\" header=\"dependency-injection-in-action/src/app/parent-finder.component.ts\"></code-example>\n \n-<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9-interface\"></code-example>\n \n-<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-9-ctor-interface\"></code-example>\n+{@a value-provider}\n \n-<div class=\"alert is-helpful\">\n+## Injecting an object\n \n-This might seem strange if you're used to dependency injection in strongly typed languages where an interface is the preferred dependency lookup key.\n-However, JavaScript, doesn't have interfaces, so when TypeScript is transpiled to JavaScript, the interface disappears.\n-There is no interface type information left for Angular to find at runtime.\n+To inject an object, configure the injector with the `useValue` option.\n+The following provider object uses the `useValue` key to associate the variable with the `Logger` token.\n+\n+<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-7\"></code-example>\n+\n+In this example, `SilentLogger` is an object that fulfills the logger role.\n+\n+<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"silent-logger\"></code-example>\n+\n+\n+{@a non-class-dependencies}\n+\n+### Injecting a configuration object\n \n-</div>\n+A common use case for object literals is a configuration object.\n+The following configuration object includes the title of the application and the address of a web API endpoint.\n \n-One alternative is to provide and inject the configuration object in an NgModule like `AppModule`.\n+<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"config\" header=\"src/app/app.config.ts (excerpt)\"></code-example>\n+\n+To provide and inject the configuration object, specify the object in the `@NgModule()` `providers` array.\n \n <code-example path=\"dependency-injection/src/app/app.module.ts\" region=\"providers\" header=\"src/app/app.module.ts (providers)\"></code-example>\n \n-Another solution to choosing a provider token for non-class dependencies is\n-to define and use an `InjectionToken` object.\n-The following example shows how to define such a token.\n+{@a injectiontoken}\n+\n+### Using an `InjectionToken` object\n+\n+You can define and use an `InjectionToken` object for choosing a provider token for non-class dependencies.\n+The following example defines a token, `APP_CONFIG` of the type `InjectionToken`.\n \n <code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"token\" header=\"src/app/app.config.ts\"></code-example>\n \n-The type parameter, while optional, conveys the dependency's type to developers and tooling.\n-The token description is another developer aid.\n+The optional type parameter, `app.config`, and the token description, `<AppConfig>` specify the token's purpose.\n \n-Register the dependency provider using the `InjectionToken` object:\n+Next, register the dependency provider in the component using the `InjectionToken` object of `APP_CONFIG`.\n \n-<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9\"></code-example>\n+<code-example path=\"dependency-injection/src/app/providers.component.ts\" header=\"src/app/providers.component.ts\" region=\"providers-9\"></code-example>\n \n-Now you can inject the configuration object into any constructor that needs it, with\n-the help of an `@Inject()` parameter decorator.\n+Now you can inject the configuration object into the constructor with `@Inject()` parameter decorator.\n \n <code-example path=\"dependency-injection/src/app/app.component.2.ts\" region=\"ctor\" header=\"src/app/app.component.ts\"></code-example>\n \n-<div class=\"alert is-helpful\">\n+{@a di-and-interfaces}\n \n-Although the `AppConfig` interface plays no role in dependency injection,\n-it supports typing of the configuration object within the class.\n+#### Interfaces and dependency injection\n \n-</div>\n+Though the TypeScript `AppConfig` interface supports typing within the class, the `AppConfig` interface plays no role in dependency injection.\n+In TypeScript, an interface is a design-time artifact, and doesn't have a runtime representation, or token, that the DI framework can use.\n \n+When the transpiler changes TypeScript to JavaScript, the interface disappears because JavaScript doesn't have interfaces.\n \n-{@a factory-provider}\n-{@a factory-providers}\n+Since there is no interface for Angular to find at runtime, the interface cannot be a token, nor can you inject it.\n \n-## Factory providers\n+<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9-interface\"></code-example>\n \n-Sometimes you need to create a dependent value dynamically,\n-based on information you won't have until run time.\n-For example, you might need information that changes repeatedly in the course of the browser session.\n-Also, your injectable service might not have independent access to the source of the information.\n+<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-9-ctor-interface\"></code-example>\n \n-In cases like this you can use a *factory provider*.\n-Factory providers can also be useful when creating an instance of a dependency from\n-a third-party library that wasn't designed to work with DI.\n \n-For example, suppose `HeroService` must hide *secret* heroes from normal users.\n-Only authorized users should see secret heroes.\n+{@a factory-provider}\n+{@a factory-providers}\n+\n+## Using factory providers\n \n-Like  `EvenBetterLogger`, `HeroService` needs to know if the user is authorized to see secret heroes.\n-That authorization can change during the course of a single application session,\n-as when you log in a different user.\n+To create a changeable, dependent value based on information unavailable before run time, you can use a factory provider.\n \n-Imagine that you don't want to inject `UserService` directly into `HeroService`, because you don't want to complicate that service with security-sensitive information.\n-`HeroService` won't have direct access to the user information to decide\n-who is authorized and who isn't.\n+In the following example, only authorized users should see secret heroes in the `HeroService`.\n+Authorization can change during the course of a single application session, as when a different user logs in .\n \n-To resolve this, give the `HeroService` constructor a boolean flag to control display of secret heroes.\n+To keep security-sensitive information in `UserService` and out of `HeroService`, give the `HeroService` constructor a boolean flag to control display of secret heroes.\n \n <code-example path=\"dependency-injection/src/app/heroes/hero.service.ts\" region=\"internals\" header=\"src/app/heroes/hero.service.ts (excerpt)\"></code-example>\n \n-You can inject `Logger`, but you can't inject the  `isAuthorized` flag. Instead, you can use a factory provider to create a new logger instance for `HeroService`.\n-\n-A factory provider needs a factory function.\n+To implement the `isAuthorized` flag, use a factory provider to create a new logger instance for `HeroService`.\n \n <code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"factory\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\"></code-example>\n \n-Although `HeroService` has no access to `UserService`, the factory function does.\n-You inject both `Logger` and `UserService` into the factory provider\n-and let the injector pass them along to the factory function.\n+The factory function has access to `UserService`.\n+You inject both `Logger` and `UserService` into the factory provider so the injector can pass them along to the factory function.\n \n <code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"provider\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\"></code-example>\n \n-* The `useFactory` field tells Angular that the provider is a factory function whose implementation is `heroServiceFactory`.\n+* The `useFactory` field specifies that the provider is a factory function whose implementation is `heroServiceFactory`.\n \n * The `deps` property is an array of [provider tokens](guide/dependency-injection#token).\n The `Logger` and `UserService` classes serve as tokens for their own class providers.\n-The injector resolves these tokens and injects the corresponding services into the matching factory function parameters.\n+The injector resolves these tokens and injects the corresponding services into the matching `heroServiceFactory` factory function parameters.\n \n-Notice that you captured the factory provider in an exported variable, `heroServiceProvider`.\n-This extra step makes the factory provider reusable.\n-You can configure a provider of `HeroService` with this variable wherever you need it.\n-In this sample, you need it only in `HeroesComponent`,\n-where `heroServiceProvider` replaces `HeroService` in the metadata `providers` array.\n+Capturing the factory provider in the exported variable, `heroServiceProvider`, makes the factory provider reusable.\n \n-The following shows the new and the old implementations side-by-side.\n+The following side-by-side example shows how `heroServiceProvider` replaces `HeroService` in the `providers` array.\n \n <code-tabs>\n \n@@ -241,115 +216,3 @@ The following shows the new and the old implementations side-by-side.\n \n </code-tabs>\n \n-## Predefined tokens and multiple providers\n-\n-Angular provides a number of built-in injection-token constants that you can use to customize the behavior of\n-various systems.\n-\n-For example, you can use the following built-in tokens as hooks into the frameworkâ€™s bootstrapping and initialization process.\n-A provider object can associate any of these injection tokens with one or more callback functions that take app-specific initialization actions.\n-\n-* [PLATFORM_INITIALIZER](api/core/PLATFORM_INITIALIZER): Callback is invoked when a platform is initialized.\n-\n-* [APP_BOOTSTRAP_LISTENER](api/core/APP_BOOTSTRAP_LISTENER): Callback is invoked for each component that is bootstrapped. The handler function receives the ComponentRef instance of the bootstrapped component.\n-\n-* [APP_INITIALIZER](api/core/APP_INITIALIZER): Callback is invoked before an app is initialized. All registered initializers can optionally return a Promise. All initializer functions that return Promises must be resolved before the application is bootstrapped. If one of the initializers fails to resolves, the application is not bootstrapped.\n-\n-The provider object can have a third option, `multi: true`, which you can use with `APP_INITIALIZER`\n-to register multiple handlers for the provide event.\n-\n-For example, when bootstrapping an application, you can register many initializers using the same token.\n-\n-```\n-export const APP_TOKENS = [\n- { provide: PLATFORM_INITIALIZER, useFactory: platformInitialized, multi: true },\n- { provide: APP_INITIALIZER, useFactory: delayBootstrapping, multi: true },\n- { provide: APP_BOOTSTRAP_LISTENER, useFactory: appBootstrapped, multi: true },\n-];\n-```\n-\n-Multiple providers can be associated with a single token in other areas as well.\n-For example, you can register a custom form validator using the built-in [NG_VALIDATORS](api/forms/NG_VALIDATORS) token,\n-and provide multiple instances of a given validator provider by using the `multi: true` property in the provider object.\n-Angular adds your custom validators to the existing collection.\n-\n-The Router also makes use of multiple providers associated with a single token.\n-When you provide multiple sets of routes using [RouterModule.forRoot](api/router/RouterModule#forroot)\n-and [RouterModule.forChild](api/router/RouterModule#forchild) in a single module,\n-the [ROUTES](api/router/ROUTES) token combines all the different provided sets of routes into a single value.\n-\n-<div class=\"alert is-helpful\">\n-\n-Search for [Constants in API documentation](api?type=const) to find more built-in tokens.\n-\n-</div>\n-\n-<div class=\"alert is-helpful\">\n-\n-Note that the reference to the array returned for a `multi` provider is shared between all the\n-places where the token is injected. We recommend avoiding mutations of the array (especially for\n-predefined tokens) as it may lead to unexpected behavior in other parts of the app that inject\n-the same token. You can prevent the value from being mutated by setting its type to `ReadonlyArray`.\n-\n-</div>\n-\n-You can use `ReadonlyArray` to type your `multi` provider, so TypeScript triggers an error in case\n-of unwanted array mutations:\n-\n-```\n-constructor(@Inject(MULTI_PROVIDER) multiProvider: ReadonlyArray<MultiProvider>) {\n-}\n-```\n-\n-{@a tree-shakable-provider}\n-{@a tree-shakable-providers}\n-\n-## Tree-shakable providers\n-\n-Tree shaking refers to a compiler option that removes code from the final bundle if the app doesn't reference that code.\n-When providers are tree-shakable, the Angular compiler removes the associated\n-services from the final output when it determines that your application doesn't use those services.\n-This significantly reduces the size of your bundles.\n-\n-<div class=\"alert is-helpful\">\n-\n-Ideally, if an application isn't injecting a service, Angular shouldn't include it in the final output.\n-However, Angular has to be able to identify at build time whether the app will require the service or not.\n-Because it's always possible to inject a service directly using `injector.get(Service)`,\n-Angular can't identify all of the places in your code where this injection could happen,\n-so it has no choice but to include the service in the injector.\n-Thus, services in the NgModule `providers` array or at component level are not tree-shakable.\n-\n-</div>\n-\n-The following example of non-tree-shakable providers in Angular configures a service provider for the injector of an NgModule.\n-\n-<code-example path=\"dependency-injection/src/app/tree-shaking/service-and-module.ts\"  header=\"src/app/tree-shaking/service-and-modules.ts\"></code-example>\n-\n-You can then import this module into your application module\n-to make the service available for injection in your app,\n-as in the following example.\n-\n-<code-example path=\"dependency-injection/src/app/tree-shaking/app.module.ts\"  header=\"src/app/tree-shaking/app.modules.ts\"></code-example>\n-\n-When `ngc` runs, it compiles `AppModule` into a module factory, which contains definitions for all the providers declared in all the modules it includes. At runtime, this factory becomes an injector that instantiates these services.\n-\n-Tree-shaking doesn't work here because Angular can't decide to exclude one chunk of code (the provider definition for the service within the module factory) based on whether another chunk of code (the service class) is used. To make services tree-shakable, the information about how to construct an instance of the service (the provider definition) needs to be a part of the service class itself.\n-\n-### Creating tree-shakable providers\n-\n-You can make a provider tree-shakable by specifying it in the `@Injectable()` decorator on the service itself, rather than in the metadata for the NgModule or component that depends on the service.\n-\n-The following example shows the tree-shakable equivalent to the `ServiceModule` example above.\n-\n-<code-example path=\"dependency-injection/src/app/tree-shaking/service.ts\"  header=\"src/app/tree-shaking/service.ts\"></code-example>\n-\n-The service can be instantiated by configuring a factory function, as in the following example.\n-\n-<code-example path=\"dependency-injection/src/app/tree-shaking/service.0.ts\"  header=\"src/app/tree-shaking/service.0.ts\"></code-example>\n-\n-<div class=\"alert is-helpful\">\n-\n-To override a tree-shakable provider, configure the injector of a specific NgModule or component with another provider, using the `providers: []` array syntax of the `@NgModule()` or `@Component()` decorator.\n-\n-</div>"
        },
        {
            "sha": "f1bde65a95af30541e2ce05163e49701e24b73d4",
            "filename": "aio/content/guide/hierarchical-dependency-injection.md",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Fhierarchical-dependency-injection.md",
            "raw_url": "https://github.com/angular/angular/raw/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Fhierarchical-dependency-injection.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fhierarchical-dependency-injection.md?ref=156f9f30ae13b84d71f3373b476b4e6cf66fe83a",
            "patch": "@@ -40,8 +40,8 @@ using and results in smaller bundle sizes.\n Tree-shaking is especially useful for a library\n because the application which uses the library may not have\n a need to inject it. Read more\n-about [tree-shakable providers](guide/dependency-injection-providers#tree-shakable-providers)\n-in [DI Providers](guide/dependency-injection-providers).\n+about [tree-shakable providers](guide/architecture-services#providing-services)\n+in [Introduction to services and dependency injection](guide/architecture-services).\n \n </div>\n "
        },
        {
            "sha": "cbaecee5ff10da6cb15db7d0a03d625c3789a982",
            "filename": "aio/content/guide/lightweight-injection-tokens.md",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Flightweight-injection-tokens.md",
            "raw_url": "https://github.com/angular/angular/raw/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Flightweight-injection-tokens.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Flightweight-injection-tokens.md?ref=156f9f30ae13b84d71f3373b476b4e6cf66fe83a",
            "patch": "@@ -3,7 +3,7 @@\n This page provides a conceptual overview of a dependency injection technique that is recommended for library developers.\n Designing your library with *lightweight injection tokens* helps optimize the bundle size of client applications that use your library.\n \n-You can manage the dependency structure among your components and injectable services to optimize bundle size by using [tree-shakable providers](guide/dependency-injection-providers#tree-shakable-providers).\n+You can manage the dependency structure among your components and injectable services to optimize bundle size by using [tree-shakable providers](guide/architecture-services#introduction-to-services-and-dependency-injection).\n This normally ensures that if a provided component or service is never actually used by the app, the compiler can eliminate its code from the bundle.\n \n However, due to the way Angular stores injection tokens, it is possible that such an unused component or service can end up in the bundle anyway.\n@@ -89,7 +89,7 @@ These effectively change `constructor(@Optional() other: OtherComponent)` to `co\n \n <div class=\"alert is helpful\">\n \n-For all services, a library should use [tree-shakable providers](guide/dependency-injection-providers#tree-shakable-providers), providing dependencies at the root level rather than in component constructors.\n+For all services, a library should use [tree-shakable providers](guide/architecture-services#introduction-to-services-and-dependency-injection), providing dependencies at the root level rather than in component constructors.\n \n </div>\n "
        },
        {
            "sha": "a246b3b1ea58644d68e60d6d443aca8cc9a9aca0",
            "filename": "aio/content/guide/providers.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Fproviders.md",
            "raw_url": "https://github.com/angular/angular/raw/156f9f30ae13b84d71f3373b476b4e6cf66fe83a/aio%2Fcontent%2Fguide%2Fproviders.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fproviders.md?ref=156f9f30ae13b84d71f3373b476b4e6cf66fe83a",
            "patch": "@@ -89,5 +89,5 @@ Register a provider with a component when you must limit a service instance to a\n You may also be interested in:\n * [Singleton Services](guide/singleton-services), which elaborates on the concepts covered on this page.\n * [Lazy Loading Modules](guide/lazy-loading-ngmodules).\n-* [Tree-shakable Providers](guide/dependency-injection-providers#tree-shakable-providers).\n+* [Dependency providers](guide/dependency-injection-providers).\n * [NgModule FAQ](guide/ngmodule-faq)."
        }
    ],
    "stats": {
        "total": 355,
        "additions": 109,
        "deletions": 246
    }
}