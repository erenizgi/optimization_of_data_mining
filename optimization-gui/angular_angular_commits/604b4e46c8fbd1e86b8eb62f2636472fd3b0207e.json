{
    "author": "JoostK",
    "message": "perf(compiler): optimize computation of i18n message ids (#39694)\n\nMessage ID computation makes extensive use of big integer\nmultiplications in order to translate the message's fingerprint into\na numerical representation. In large compilations with heavy use of i18n\nthis was showing up high in profiler sessions.\n\nThere are two factors contributing to the bottleneck:\n\n1. a suboptimal big integer representation using strings, which requires\nrepeated allocation and conversion from a character to numeric digits\nand back.\n2. repeated computation of the necessary base-256 exponents and their\nmultiplication factors.\n\nThe first bottleneck is addressed using a representation that uses an\narray of individual digits. This avoids repeated conversion and\nallocation overhead is also greatly reduced, as adding two big integers\ncan now be done in-place with virtually no memory allocations.\n\nThe second point is addressed by a memoized exponentiation pool to\noptimize the multiplication of a base-256 exponent.\n\nAs an additional optimization are the two 32-bit words now converted to\ndecimal per word, instead of going through an intermediate byte buffer\nand doing the decimal conversion per byte.\n\nThe results of these optimizations depend a lot on the number of i18n\nmessages for which a message should be computed. Benchmarks have shown\nthat computing message IDs is now ~6x faster for 1,000 messages, ~14x\nfaster for 10,000 messages, and ~24x faster for 100,000 messages.\n\nPR Close #39694",
    "sha": "604b4e46c8fbd1e86b8eb62f2636472fd3b0207e",
    "files": [
        {
            "sha": "1dc2edf8afc88e93f2b739832827f9c35416a1be",
            "filename": "packages/compiler/src/i18n/big_integer.ts",
            "status": "added",
            "additions": 196,
            "deletions": 0,
            "changes": 196,
            "blob_url": "https://github.com/angular/angular/blob/604b4e46c8fbd1e86b8eb62f2636472fd3b0207e/packages%2Fcompiler%2Fsrc%2Fi18n%2Fbig_integer.ts",
            "raw_url": "https://github.com/angular/angular/raw/604b4e46c8fbd1e86b8eb62f2636472fd3b0207e/packages%2Fcompiler%2Fsrc%2Fi18n%2Fbig_integer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fi18n%2Fbig_integer.ts?ref=604b4e46c8fbd1e86b8eb62f2636472fd3b0207e",
            "patch": "@@ -0,0 +1,196 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/**\n+ * Represents a big integer using a buffer of its individual digits, with the least significant\n+ * digit stored at the beginning of the array (little endian).\n+ *\n+ * For performance reasons, each instance is mutable. The addition operation can be done in-place\n+ * to reduce memory pressure of allocation for the digits array.\n+ */\n+export class BigInteger {\n+  static zero(): BigInteger {\n+    return new BigInteger([0]);\n+  }\n+\n+  static one(): BigInteger {\n+    return new BigInteger([1]);\n+  }\n+\n+  /**\n+   * Creates a big integer using its individual digits in little endian storage.\n+   */\n+  private constructor(private readonly digits: number[]) {}\n+\n+  /**\n+   * Creates a clone of this instance.\n+   */\n+  clone(): BigInteger {\n+    return new BigInteger(this.digits.slice());\n+  }\n+\n+  /**\n+   * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate\n+   * `this` but instead returns a new instance, unlike `addToSelf`.\n+   */\n+  add(other: BigInteger): BigInteger {\n+    const result = this.clone();\n+    result.addToSelf(other);\n+    return result;\n+  }\n+\n+  /**\n+   * Adds `other` to the instance itself, thereby mutating its value.\n+   */\n+  addToSelf(other: BigInteger): void {\n+    const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);\n+    let carry = 0;\n+    for (let i = 0; i < maxNrOfDigits; i++) {\n+      let digitSum = carry;\n+      if (i < this.digits.length) {\n+        digitSum += this.digits[i];\n+      }\n+      if (i < other.digits.length) {\n+        digitSum += other.digits[i];\n+      }\n+\n+      if (digitSum >= 10) {\n+        this.digits[i] = digitSum - 10;\n+        carry = 1;\n+      } else {\n+        this.digits[i] = digitSum;\n+        carry = 0;\n+      }\n+    }\n+\n+    // Apply a remaining carry if needed.\n+    if (carry > 0) {\n+      this.digits[maxNrOfDigits] = 1;\n+    }\n+  }\n+\n+  /**\n+   * Builds the decimal string representation of the big integer. As this is stored in\n+   * little endian, the digits are concatenated in reverse order.\n+   */\n+  toString(): string {\n+    let res = '';\n+    for (let i = this.digits.length - 1; i >= 0; i--) {\n+      res += this.digits[i];\n+    }\n+    return res;\n+  }\n+}\n+\n+/**\n+ * Represents a big integer which is optimized for multiplication operations, as its power-of-twos\n+ * are memoized. See `multiplyBy()` for details on the multiplication algorithm.\n+ */\n+export class BigIntForMultiplication {\n+  /**\n+   * Stores all memoized power-of-twos, where each index represents `this.number * 2^index`.\n+   */\n+  private readonly powerOfTwos: BigInteger[];\n+\n+  constructor(value: BigInteger) {\n+    this.powerOfTwos = [value];\n+  }\n+\n+  /**\n+   * Returns the big integer itself.\n+   */\n+  getValue(): BigInteger {\n+    return this.powerOfTwos[0];\n+  }\n+\n+  /**\n+   * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The\n+   * value for `b` is represented by a storage model that is optimized for this computation.\n+   *\n+   * This operation is implemented in N(log2(num)) by continuous halving of the number, where the\n+   * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is\n+   * used as exponent into the power-of-two multiplication of `b`.\n+   *\n+   * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the\n+   * algorithm unrolls into the following iterations:\n+   *\n+   *  Iteration | num        | LSB  | b * 2^iter | Add? | product\n+   * -----------|------------|------|------------|------|--------\n+   *  0         | 0b00101010 | 0    | 1337       | No   | 0\n+   *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674\n+   *  2         | 0b00001010 | 0    | 5348       | No   | 2674\n+   *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370\n+   *  4         | 0b00000010 | 0    | 21392      | No   | 13370\n+   *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154\n+   *  6         | 0b00000000 | 0    | 85568      | No   | 56154\n+   *\n+   * The computed product of 56154 is indeed the correct result.\n+   *\n+   * The `BigIntForMultiplication` representation for a big integer provides memoized access to the\n+   * power-of-two values to reduce the workload in computing those values.\n+   */\n+  multiplyBy(num: number): BigInteger {\n+    const product = BigInteger.zero();\n+    this.multiplyByAndAddTo(num, product);\n+    return product;\n+  }\n+\n+  /**\n+   * See `multiplyBy()` for details. This function allows for the computed product to be added\n+   * directly to the provided result big integer.\n+   */\n+  multiplyByAndAddTo(num: number, result: BigInteger): void {\n+    for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {\n+      if (num & 1) {\n+        const value = this.getMultipliedByPowerOfTwo(exponent);\n+        result.addToSelf(value);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Computes and memoizes the big integer value for `this.number * 2^exponent`.\n+   */\n+  private getMultipliedByPowerOfTwo(exponent: number): BigInteger {\n+    // Compute the powers up until the requested exponent, where each value is computed from its\n+    // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.\n+    // added to itself) to reach `this.number * 2^exponent`.\n+    for (let i = this.powerOfTwos.length; i <= exponent; i++) {\n+      const previousPower = this.powerOfTwos[i - 1];\n+      this.powerOfTwos[i] = previousPower.add(previousPower);\n+    }\n+    return this.powerOfTwos[exponent];\n+  }\n+}\n+\n+/**\n+ * Represents an exponentiation operation for the provided base, of which exponents are computed and\n+ * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for\n+ * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix\n+ * representation that is lazily computed upon request.\n+ */\n+export class BigIntExponentiation {\n+  private readonly exponents = [new BigIntForMultiplication(BigInteger.one())];\n+\n+  constructor(private readonly base: number) {}\n+\n+  /**\n+   * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for\n+   * further multiplication operations.\n+   */\n+  toThePowerOf(exponent: number): BigIntForMultiplication {\n+    // Compute the results up until the requested exponent, where every value is computed from its\n+    // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`\n+    // to reach `this.base^exponent`.\n+    for (let i = this.exponents.length; i <= exponent; i++) {\n+      const value = this.exponents[i - 1].multiplyBy(this.base);\n+      this.exponents[i] = new BigIntForMultiplication(value);\n+    }\n+    return this.exponents[exponent];\n+  }\n+}"
        },
        {
            "sha": "cd58fab27a2a9f695273a25cb0bcfad3f9147fb8",
            "filename": "packages/compiler/src/i18n/digest.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 37,
            "changes": 63,
            "blob_url": "https://github.com/angular/angular/blob/604b4e46c8fbd1e86b8eb62f2636472fd3b0207e/packages%2Fcompiler%2Fsrc%2Fi18n%2Fdigest.ts",
            "raw_url": "https://github.com/angular/angular/raw/604b4e46c8fbd1e86b8eb62f2636472fd3b0207e/packages%2Fcompiler%2Fsrc%2Fi18n%2Fdigest.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fi18n%2Fdigest.ts?ref=604b4e46c8fbd1e86b8eb62f2636472fd3b0207e",
            "patch": "@@ -7,6 +7,7 @@\n  */\n \n import {newArray, utf8Encode} from '../util';\n+import {BigIntExponentiation} from './big_integer';\n \n import * as i18n from './i18n_ast';\n \n@@ -197,7 +198,7 @@ export function computeMsgId(msg: string, meaning: string = ''): string {\n   const hi = msgFingerprint[0];\n   const lo = msgFingerprint[1];\n \n-  return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));\n+  return wordsToDecimalString(hi & 0x7fffffff, lo);\n }\n \n function hash32(str: string, c: number): number {\n@@ -334,43 +335,31 @@ function byteStringToHexString(str: string): string {\n   return hex.toLowerCase();\n }\n \n-// based on http://www.danvk.org/hex2dec.html (JS can not handle more than 56b)\n-function byteStringToDecString(str: string): string {\n-  let decimal = '';\n-  let toThePower = '1';\n-\n-  for (let i = str.length - 1; i >= 0; i--) {\n-    decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));\n-    toThePower = numberTimesBigInt(256, toThePower);\n-  }\n-\n-  return decimal.split('').reverse().join('');\n-}\n+/**\n+ * Create a shared exponentiation pool for base-256 computations. This shared pool provides memoized\n+ * power-of-256 results with memoized power-of-two computations for efficient multiplication.\n+ *\n+ * For our purposes, this can be safely stored as a global without memory concerns. The reason is\n+ * that we encode two words, so only need the 0th (for the low word) and 4th (for the high word)\n+ * exponent.\n+ */\n+const base256 = new BigIntExponentiation(256);\n \n-// x and y decimal, lowest significant digit first\n-function addBigInt(x: string, y: string): string {\n-  let sum = '';\n-  const len = Math.max(x.length, y.length);\n-  for (let i = 0, carry = 0; i < len || carry; i++) {\n-    const tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);\n-    if (tmpSum >= 10) {\n-      carry = 1;\n-      sum += tmpSum - 10;\n-    } else {\n-      carry = 0;\n-      sum += tmpSum;\n-    }\n-  }\n+/**\n+ * Represents two 32-bit words as a single decimal number. This requires a big integer storage\n+ * model as JS numbers are not accurate enough to represent the 64-bit number.\n+ *\n+ * Based on http://www.danvk.org/hex2dec.html\n+ */\n+function wordsToDecimalString(hi: number, lo: number): string {\n+  // Encode the four bytes in lo in the lower digits of the decimal number.\n+  // Note: the multiplication results in lo itself but represented by a big integer using its\n+  // decimal digits.\n+  const decimal = base256.toThePowerOf(0).multiplyBy(lo);\n \n-  return sum;\n-}\n+  // Encode the four bytes in hi above the four lo bytes. lo is a maximum of (2^8)^4, which is why\n+  // this multiplication factor is applied.\n+  base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);\n \n-function numberTimesBigInt(num: number, b: string): string {\n-  let product = '';\n-  let bToThePower = b;\n-  for (; num !== 0; num = num >>> 1) {\n-    if (num & 1) product = addBigInt(product, bToThePower);\n-    bToThePower = addBigInt(bToThePower, bToThePower);\n-  }\n-  return product;\n+  return decimal.toString();\n }"
        },
        {
            "sha": "8af58100db0d58b5703efeb2a3839568081f5775",
            "filename": "packages/compiler/test/i18n/big_integer_spec.ts",
            "status": "added",
            "additions": 207,
            "deletions": 0,
            "changes": 207,
            "blob_url": "https://github.com/angular/angular/blob/604b4e46c8fbd1e86b8eb62f2636472fd3b0207e/packages%2Fcompiler%2Ftest%2Fi18n%2Fbig_integer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/604b4e46c8fbd1e86b8eb62f2636472fd3b0207e/packages%2Fcompiler%2Ftest%2Fi18n%2Fbig_integer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fi18n%2Fbig_integer_spec.ts?ref=604b4e46c8fbd1e86b8eb62f2636472fd3b0207e",
            "patch": "@@ -0,0 +1,207 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {BigInteger, BigIntExponentiation, BigIntForMultiplication} from '../../src/i18n/big_integer';\n+\n+describe('big integers', () => {\n+  describe('add', () => {\n+    it('should add two integers', () => {\n+      const a = createBigInteger(42);\n+      const b = createBigInteger(1337);\n+\n+      expect(a.add(b).toString()).toEqual('1379');\n+    });\n+\n+    it('should add two integers with a carry', () => {\n+      const a = createBigInteger(8);\n+      const b = createBigInteger(995);\n+\n+      expect(a.add(b).toString()).toEqual('1003');\n+    });\n+\n+    it('should add two integers beyond the maximum supported JS integer', () => {\n+      const b31 = createBigInteger(1 << 31);\n+\n+      const b32 = b31.add(b31);\n+      const b33 = b32.add(b32);\n+      const b34 = b33.add(b33);\n+      const b35 = b34.add(b34);\n+      const b36 = b35.add(b35);\n+      const b37 = b36.add(b36);\n+      const b38 = b37.add(b37);\n+      const b39 = b38.add(b38);\n+      const b40 = b39.add(b39);\n+      const b41 = b40.add(b40);\n+      const b42 = b41.add(b41);\n+      const b43 = b42.add(b42);\n+      const b44 = b43.add(b43);\n+      const b45 = b44.add(b44);\n+      const b46 = b45.add(b45);\n+      const b47 = b46.add(b46);\n+      const b48 = b47.add(b47);\n+      const b49 = b48.add(b48);\n+      const b50 = b49.add(b49);\n+      const b51 = b50.add(b50);\n+      const b52 = b51.add(b51);\n+      const b53 = b52.add(b52);\n+      const b54 = b53.add(b53);\n+      const b55 = b54.add(b54);\n+      const b56 = b55.add(b55);\n+      const b57 = b56.add(b56);\n+      const b58 = b57.add(b57);\n+      const b59 = b58.add(b58);\n+      const b60 = b59.add(b59);\n+      const b61 = b60.add(b60);\n+      const b62 = b61.add(b61);\n+      const b63 = b62.add(b62);\n+      const b64 = b63.add(b63);\n+      const b65 = b64.add(b64);\n+\n+      expect(b32.toString()).toEqual('4294967296');\n+      expect(b33.toString()).toEqual('8589934592');\n+      expect(b34.toString()).toEqual('17179869184');\n+      expect(b35.toString()).toEqual('34359738368');\n+      expect(b36.toString()).toEqual('68719476736');\n+      expect(b37.toString()).toEqual('137438953472');\n+      expect(b38.toString()).toEqual('274877906944');\n+      expect(b39.toString()).toEqual('549755813888');\n+      expect(b40.toString()).toEqual('1099511627776');\n+      expect(b41.toString()).toEqual('2199023255552');\n+      expect(b42.toString()).toEqual('4398046511104');\n+      expect(b43.toString()).toEqual('8796093022208');\n+      expect(b44.toString()).toEqual('17592186044416');\n+      expect(b45.toString()).toEqual('35184372088832');\n+      expect(b46.toString()).toEqual('70368744177664');\n+      expect(b47.toString()).toEqual('140737488355328');\n+      expect(b48.toString()).toEqual('281474976710656');\n+      expect(b49.toString()).toEqual('562949953421312');\n+      expect(b50.toString()).toEqual('1125899906842624');\n+      expect(b51.toString()).toEqual('2251799813685248');\n+      expect(b52.toString()).toEqual('4503599627370496');\n+      expect(b53.toString()).toEqual('9007199254740992');\n+      expect(b54.toString()).toEqual('18014398509481984');\n+\n+      // From here onwards would the result be inaccurate with JavaScript numbers.\n+      expect(b55.toString()).toEqual('36028797018963968');\n+      expect(b56.toString()).toEqual('72057594037927936');\n+      expect(b57.toString()).toEqual('144115188075855872');\n+      expect(b58.toString()).toEqual('288230376151711744');\n+      expect(b59.toString()).toEqual('576460752303423488');\n+      expect(b60.toString()).toEqual('1152921504606846976');\n+      expect(b61.toString()).toEqual('2305843009213693952');\n+      expect(b62.toString()).toEqual('4611686018427387904');\n+      expect(b63.toString()).toEqual('9223372036854775808');\n+      expect(b64.toString()).toEqual('18446744073709551616');\n+      expect(b65.toString()).toEqual('36893488147419103232');\n+    });\n+\n+    it('should not mutate the big integer instances', () => {\n+      const a = createBigInteger(42);\n+      const b = createBigInteger(1337);\n+\n+      a.add(b);\n+\n+      expect(a.toString()).toEqual('42');\n+      expect(b.toString()).toEqual('1337');\n+    });\n+  });\n+\n+  describe('addToSelf', () => {\n+    it('should add two integers into the left operand', () => {\n+      const a = createBigInteger(42);\n+      const b = createBigInteger(1337);\n+\n+      a.addToSelf(b);\n+\n+      expect(a.toString()).toEqual('1379');\n+    });\n+\n+    it('should not mutate the right operand', () => {\n+      const a = createBigInteger(42);\n+      const b = createBigInteger(1337);\n+\n+      a.addToSelf(b);\n+\n+      expect(a.toString()).toEqual('1379');\n+      expect(b.toString()).toEqual('1337');\n+    });\n+  });\n+\n+  describe('multiplication', () => {\n+    it('should be correct for 0', () => {\n+      const a = new BigIntForMultiplication(createBigInteger(0));\n+      expect(a.multiplyBy(0).toString()).toEqual('0');\n+      expect(a.multiplyBy(1).toString()).toEqual('0');\n+      expect(a.multiplyBy(42).toString()).toEqual('0');\n+      expect(a.multiplyBy(1 << 31).toString()).toEqual('0');\n+      expect(a.multiplyBy((1 << 31) - 1).toString()).toEqual('0');\n+    });\n+\n+    it('should be correct for 1337', () => {\n+      const a = new BigIntForMultiplication(createBigInteger(1337));\n+      expect(a.multiplyBy(0).toString()).toEqual('0');\n+      expect(a.multiplyBy(1).toString()).toEqual('1337');\n+      expect(a.multiplyBy(8).toString()).toEqual('10696');\n+      expect(a.multiplyBy(42).toString()).toEqual('56154');\n+      expect(a.multiplyBy(1 << 31).toString()).toEqual('2871185637376');\n+      expect(a.multiplyBy((1 << 31) - 1).toString()).toEqual('2871185636039');\n+    });\n+\n+    it('should multiply and add to an existing big integer', () => {\n+      const a = new BigIntForMultiplication(createBigInteger(1337));\n+      const result = createBigInteger(1_000_000);\n+      a.multiplyByAndAddTo(42, result);\n+      expect(result.toString()).toEqual('1056154');\n+    });\n+  });\n+\n+  describe('exponentiation', () => {\n+    it('should be correct for base-0', () => {\n+      const base32 = new BigIntExponentiation(0);\n+      expect(base32.toThePowerOf(0).getValue().toString()).toEqual('1');\n+      expect(base32.toThePowerOf(1).getValue().toString()).toEqual('0');\n+      expect(base32.toThePowerOf(2).getValue().toString()).toEqual('0');\n+      expect(base32.toThePowerOf(3).getValue().toString()).toEqual('0');\n+      expect(base32.toThePowerOf(8).getValue().toString()).toEqual('0');\n+      expect(base32.toThePowerOf(12).getValue().toString()).toEqual('0');\n+    });\n+\n+    it('should be correct for base-1', () => {\n+      const base32 = new BigIntExponentiation(1);\n+      expect(base32.toThePowerOf(0).getValue().toString()).toEqual('1');\n+      expect(base32.toThePowerOf(1).getValue().toString()).toEqual('1');\n+      expect(base32.toThePowerOf(2).getValue().toString()).toEqual('1');\n+      expect(base32.toThePowerOf(3).getValue().toString()).toEqual('1');\n+      expect(base32.toThePowerOf(8).getValue().toString()).toEqual('1');\n+      expect(base32.toThePowerOf(12).getValue().toString()).toEqual('1');\n+    });\n+\n+    it('should be correct for base-42', () => {\n+      const base32 = new BigIntExponentiation(42);\n+      expect(base32.toThePowerOf(0).getValue().toString()).toEqual('1');\n+      expect(base32.toThePowerOf(1).getValue().toString()).toEqual('42');\n+      expect(base32.toThePowerOf(2).getValue().toString()).toEqual('1764');\n+      expect(base32.toThePowerOf(3).getValue().toString()).toEqual('74088');\n+      expect(base32.toThePowerOf(8).getValue().toString()).toEqual('9682651996416');\n+      expect(base32.toThePowerOf(12).getValue().toString()).toEqual('30129469486639681536');\n+    });\n+\n+    it('should cache the exponents', () => {\n+      const base32 = new BigIntExponentiation(32);\n+\n+      const a = base32.toThePowerOf(4);\n+      const b = base32.toThePowerOf(4);\n+\n+      expect(a).toBe(b);\n+    });\n+  });\n+\n+  function createBigInteger(value: number): BigInteger {\n+    return new BigIntForMultiplication(BigInteger.one()).multiplyBy(value);\n+  }\n+});"
        }
    ],
    "stats": {
        "total": 466,
        "additions": 429,
        "deletions": 37
    }
}