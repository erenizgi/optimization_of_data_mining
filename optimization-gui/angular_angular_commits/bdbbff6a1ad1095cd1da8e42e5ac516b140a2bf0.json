{
    "author": "kapunahelewong",
    "message": "docs: break testing doc into multiple docs (#37957)\n\nThis commit breaks up the testing document into nine total documents, with each document focusing on an existing section of the current testing documentation. There are no content changes.\n\nPR Close #37957",
    "sha": "bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0",
    "files": [
        {
            "sha": "43774920b4f82dd747d38d56fd3f0d4b802e3a2b",
            "filename": ".pullapprove.yml",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/.pullapprove.yml",
            "raw_url": "https://github.com/angular/angular/raw/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/.pullapprove.yml",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/.pullapprove.yml?ref=bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0",
            "patch": "@@ -612,6 +612,14 @@ groups:\n         contains_any_globs(files.exclude('packages/compiler-cli/**'), [\n           '**/testing/**',\n           'aio/content/guide/testing.md',\n+          'aio/content/guide/test-debugging.md',\n+          'aio/content/guide/testing-attribute-directives.md',\n+          'aio/content/guide/testing-code-coverage.md',\n+          'aio/content/guide/testing-components-basics.md',\n+          'aio/content/guide/testing-components-scenarios.md',\n+          'aio/content/guide/testing-pipes.md',\n+          'aio/content/guide/testing-services.md',\n+          'aio/content/guide/testing-utility-apis.md',\n           'aio/content/examples/testing/**',\n           'aio/content/images/guide/testing/**'\n           ])"
        },
        {
            "sha": "331ed45943d9807a0b482ddcbd8a703115ed06f0",
            "filename": "aio/content/guide/test-debugging.md",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftest-debugging.md",
            "raw_url": "https://github.com/angular/angular/raw/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftest-debugging.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Ftest-debugging.md?ref=bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0",
            "patch": "@@ -0,0 +1,28 @@\n+# Debugging tests\n+\n+If your tests aren't working as you expect them to, you can inspect and debug them in the browser.\n+\n+<div class=\"alert is-helpful\">\n+\n+  For the sample app that the testing guides describe, see the <live-example embedded-style noDownload>sample app</live-example>.\n+\n+  For the tests features in the testing guides, see <live-example stackblitz=\"specs\" noDownload>tests</live-example>.\n+\n+</div>\n+\n+\n+Debug specs in the browser in the same way that you debug an application.\n+\n+1. Reveal the Karma browser window. See [Set up testing](guide/testing#set-up-testing) if you need help with this step.\n+1. Click the **DEBUG** button; it opens a new browser tab and re-runs the tests.\n+1. Open the browser's “Developer Tools” (`Ctrl-Shift-I` on Windows; `Command-Option-I` in macOS).\n+1. Pick the \"sources\" section.\n+1. Open the `1st.spec.ts` test file (Control/Command-P, then start typing the name of the file).\n+1. Set a breakpoint in the test.\n+1. Refresh the browser, and it stops at the breakpoint.\n+\n+<div class=\"lightbox\">\n+  <img src='generated/images/guide/testing/karma-1st-spec-debug.png' alt=\"Karma debugging\">\n+</div>\n+\n+<hr>"
        },
        {
            "sha": "3c704da745ec4906133294556d847335eadec5ad",
            "filename": "aio/content/guide/testing-attribute-directives.md",
            "status": "added",
            "additions": 78,
            "deletions": 0,
            "changes": 78,
            "blob_url": "https://github.com/angular/angular/blob/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-attribute-directives.md",
            "raw_url": "https://github.com/angular/angular/raw/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-attribute-directives.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Ftesting-attribute-directives.md?ref=bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0",
            "patch": "@@ -0,0 +1,78 @@\n+\n+{@a attribute-directive}\n+\n+# Testing Attribute Directives\n+\n+An _attribute directive_ modifies the behavior of an element, component or another directive.\n+Its name reflects the way the directive is applied: as an attribute on a host element.\n+\n+<div class=\"alert is-helpful\">\n+\n+  For the sample app that the testing guides describe, see the <live-example embedded-style noDownload>sample app</live-example>.\n+\n+  For the tests features in the testing guides, see <live-example stackblitz=\"specs\" noDownload>tests</live-example>.\n+\n+</div>\n+\n+## Testing the `HighlightDirective`\n+\n+The sample application's `HighlightDirective` sets the background color of an element\n+based on either a data bound color or a default color (lightgray).\n+It also sets a custom property of the element (`customProperty`) to `true`\n+for no reason other than to show that it can.\n+\n+<code-example path=\"testing/src/app/shared/highlight.directive.ts\" header=\"app/shared/highlight.directive.ts\"></code-example>\n+\n+It's used throughout the application, perhaps most simply in the `AboutComponent`:\n+\n+<code-example path=\"testing/src/app/about/about.component.ts\" header=\"app/about/about.component.ts\"></code-example>\n+\n+Testing the specific use of the `HighlightDirective` within the `AboutComponent` requires only the techniques explored in the [\"Nested component tests\"](guide/testing-components-scenarios#nested-component-tests) section of [Component testing scenarios](guide/testing-components-scenarios).\n+\n+<code-example path=\"testing/src/app/about/about.component.spec.ts\" region=\"tests\" header=\"app/about/about.component.spec.ts\"></code-example>\n+\n+However, testing a single use case is unlikely to explore the full range of a directive's capabilities.\n+Finding and testing all components that use the directive is tedious, brittle, and almost as unlikely to afford full coverage.\n+\n+_Class-only tests_ might be helpful,\n+but attribute directives like this one tend to manipulate the DOM.\n+Isolated unit tests don't touch the DOM and, therefore,\n+do not inspire confidence in the directive's efficacy.\n+\n+A better solution is to create an artificial test component that demonstrates all ways to apply the directive.\n+\n+<code-example path=\"testing/src/app/shared/highlight.directive.spec.ts\" region=\"test-component\" header=\"app/shared/highlight.directive.spec.ts (TestComponent)\"></code-example>\n+\n+<div class=\"lightbox\">\n+  <img src='generated/images/guide/testing/highlight-directive-spec.png' alt=\"HighlightDirective spec in action\">\n+</div>\n+\n+<div class=\"alert is-helpful\">\n+\n+The `<input>` case binds the `HighlightDirective` to the name of a color value in the input box.\n+The initial value is the word \"cyan\" which should be the background color of the input box.\n+\n+</div>\n+\n+Here are some tests of this component:\n+\n+<code-example path=\"testing/src/app/shared/highlight.directive.spec.ts\" region=\"selected-tests\" header=\"app/shared/highlight.directive.spec.ts (selected tests)\"></code-example>\n+\n+A few techniques are noteworthy:\n+\n+- The `By.directive` predicate is a great way to get the elements that have this directive _when their element types are unknown_.\n+\n+- The <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/:not\">`:not` pseudo-class</a>\n+  in `By.css('h2:not([highlight])')` helps find `<h2>` elements that _do not_ have the directive.\n+  `By.css('*:not([highlight])')` finds _any_ element that does not have the directive.\n+\n+- `DebugElement.styles` affords access to element styles even in the absence of a real browser, thanks to the `DebugElement` abstraction.\n+  But feel free to exploit the `nativeElement` when that seems easier or more clear than the abstraction.\n+\n+- Angular adds a directive to the injector of the element to which it is applied.\n+  The test for the default color uses the injector of the second `<h2>` to get its `HighlightDirective` instance\n+  and its `defaultColor`.\n+\n+- `DebugElement.properties` affords access to the artificial custom property that is set by the directive.\n+\n+<hr>"
        },
        {
            "sha": "d115544d4628cc9aea08496fd912cd01e892aed2",
            "filename": "aio/content/guide/testing-code-coverage.md",
            "status": "added",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/angular/angular/blob/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-code-coverage.md",
            "raw_url": "https://github.com/angular/angular/raw/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-code-coverage.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Ftesting-code-coverage.md?ref=bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0",
            "patch": "@@ -0,0 +1,57 @@\n+{@a code-coverage}\n+\n+# Find out how much code you're testing\n+\n+The CLI can run unit tests and create code coverage reports.\n+Code coverage reports show you any parts of your code base that may not be properly tested by your unit tests.\n+\n+<div class=\"alert is-helpful\">\n+\n+  For the sample app that the testing guides describe, see the <live-example embedded-style noDownload>sample app</live-example>.\n+\n+  For the tests features in the testing guides, see <live-example stackblitz=\"specs\" noDownload>tests</live-example>.\n+\n+</div>\n+\n+\n+To generate a coverage report run the following command in the root of your project.\n+\n+<code-example language=\"sh\" class=\"code-shell\">\n+  ng test --no-watch --code-coverage\n+</code-example>\n+\n+When the tests are complete, the command creates a new `/coverage` folder in the project. Open the `index.html` file to see a report with your source code and code coverage values.\n+\n+If you want to create code-coverage reports every time you test, you can set the following option in the CLI configuration file, `angular.json`:\n+\n+```\n+  \"test\": {\n+    \"options\": {\n+      \"codeCoverage\": true\n+    }\n+  }\n+```\n+\n+## Code coverage enforcement\n+\n+The code coverage percentages let you estimate how much of your code is tested.\n+If your team decides on a set minimum amount to be unit tested, you can enforce this minimum with the Angular CLI.\n+\n+For example, suppose you want the code base to have a minimum of 80% code coverage.\n+To enable this, open the [Karma](https://karma-runner.github.io) test platform configuration file, `karma.conf.js`, and add the following in the `coverageIstanbulReporter:` key.\n+\n+```\n+coverageIstanbulReporter: {\n+  reports: [ 'html', 'lcovonly' ],\n+  fixWebpackSourcePaths: true,\n+  thresholds: {\n+    statements: 80,\n+    lines: 80,\n+    branches: 80,\n+    functions: 80\n+  }\n+}\n+```\n+\n+The `thresholds` property causes the tool to enforce a minimum of 80% code coverage when the unit tests are run in the project.\n+"
        },
        {
            "sha": "03fcb3c53b91ea5d9fa923abe448d691a06a2540",
            "filename": "aio/content/guide/testing-components-basics.md",
            "status": "added",
            "additions": 380,
            "deletions": 0,
            "changes": 380,
            "blob_url": "https://github.com/angular/angular/blob/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-components-basics.md",
            "raw_url": "https://github.com/angular/angular/raw/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-components-basics.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Ftesting-components-basics.md?ref=bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0",
            "patch": "@@ -0,0 +1,380 @@\n+# Basics of testing components\n+\n+A component, unlike all other parts of an Angular application,\n+combines an HTML template and a TypeScript class.\n+The component truly is the template and the class _working together_. To adequately test a component, you should test that they work together\n+as intended.\n+\n+Such tests require creating the component's host element in the browser DOM,\n+as Angular does, and investigating the component class's interaction with\n+the DOM as described by its template.\n+\n+The Angular `TestBed` facilitates this kind of testing as you'll see in the sections below.\n+But in many cases, _testing the component class alone_, without DOM involvement,\n+can validate much of the component's behavior in an easier, more obvious way.\n+\n+<div class=\"alert is-helpful\">\n+\n+  For the sample app that the testing guides describe, see the <live-example embedded-style noDownload>sample app</live-example>.\n+\n+  For the tests features in the testing guides, see <live-example stackblitz=\"specs\" noDownload>tests</live-example>.\n+\n+</div>\n+\n+\n+{@a component-class-testing}\n+\n+## Component class testing\n+\n+Test a component class on its own as you would test a service class.\n+\n+Component class testing should be kept very clean and simple.\n+It should test only a single unit.\n+At first glance, you should be able to understand\n+what the test is testing.\n+\n+Consider this `LightswitchComponent` which toggles a light on and off\n+(represented by an on-screen message) when the user clicks the button.\n+\n+<code-example\n+  path=\"testing/src/app/demo/demo.ts\"\n+  region=\"LightswitchComp\"\n+  header=\"app/demo/demo.ts (LightswitchComp)\"></code-example>\n+\n+You might decide only to test that the `clicked()` method\n+toggles the light's _on/off_ state and sets the message appropriately.\n+\n+This component class has no dependencies. To test these types of classes, follow the same steps as you would for a service that has no dependencies:\n+\n+1. Create a component using the new keyword.\n+2. Poke at its API.\n+3. Assert expectations on its public state.\n+\n+<code-example\n+  path=\"testing/src/app/demo/demo.spec.ts\"\n+  region=\"Lightswitch\"\n+  header=\"app/demo/demo.spec.ts (Lightswitch tests)\"></code-example>\n+\n+Here is the `DashboardHeroComponent` from the _Tour of Heroes_ tutorial.\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard-hero.component.ts\"\n+  region=\"class\"\n+  header=\"app/dashboard/dashboard-hero.component.ts (component)\"></code-example>\n+\n+It appears within the template of a parent component,\n+which binds a _hero_ to the `@Input` property and\n+listens for an event raised through the _selected_ `@Output` property.\n+\n+You can test that the class code works without creating the `DashboardHeroComponent`\n+or its parent component.\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\"\n+  region=\"class-only\"\n+  header=\"app/dashboard/dashboard-hero.component.spec.ts (class tests)\"></code-example>\n+\n+When a component has dependencies, you may wish to use the `TestBed` to both\n+create the component and its dependencies.\n+\n+The following `WelcomeComponent` depends on the `UserService` to know the name of the user to greet.\n+\n+<code-example\n+  path=\"testing/src/app/welcome/welcome.component.ts\"\n+  region=\"class\"\n+  header=\"app/welcome/welcome.component.ts\"></code-example>\n+\n+You might start by creating a mock of the `UserService` that meets the minimum needs of this component.\n+\n+<code-example\n+  path=\"testing/src/app/welcome/welcome.component.spec.ts\"\n+  region=\"mock-user-service\"\n+  header=\"app/welcome/welcome.component.spec.ts (MockUserService)\"></code-example>\n+\n+Then provide and inject _both the_ **component** _and the service_ in the `TestBed` configuration.\n+\n+<code-example\n+  path=\"testing/src/app/welcome/welcome.component.spec.ts\"\n+  region=\"class-only-before-each\"\n+  header=\"app/welcome/welcome.component.spec.ts (class-only setup)\"></code-example>\n+\n+Then exercise the component class, remembering to call the [lifecycle hook methods](guide/lifecycle-hooks) as Angular does when running the app.\n+\n+<code-example\n+  path=\"testing/src/app/welcome/welcome.component.spec.ts\"\n+  region=\"class-only-tests\"\n+  header=\"app/welcome/welcome.component.spec.ts (class-only tests)\"></code-example>\n+\n+## Component DOM testing\n+\n+Testing the component _class_ is as easy as [testing a service](guide/testing-services).\n+\n+But a component is more than just its class.\n+A component interacts with the DOM and with other components.\n+The _class-only_ tests can tell you about class behavior.\n+They cannot tell you if the component is going to render properly,\n+respond to user input and gestures, or integrate with its parent and child components.\n+\n+None of the _class-only_ tests above can answer key questions about how the\n+components actually behave on screen.\n+\n+- Is `Lightswitch.clicked()` bound to anything such that the user can invoke it?\n+- Is the `Lightswitch.message` displayed?\n+- Can the user actually select the hero displayed by `DashboardHeroComponent`?\n+- Is the hero name displayed as expected (i.e, in uppercase)?\n+- Is the welcome message displayed by the template of `WelcomeComponent`?\n+\n+These may not be troubling questions for the simple components illustrated above.\n+But many components have complex interactions with the DOM elements\n+described in their templates, causing HTML to appear and disappear as\n+the component state changes.\n+\n+To answer these kinds of questions, you have to create the DOM elements associated\n+with the components, you must examine the DOM to confirm that component state\n+displays properly at the appropriate times, and you must simulate user interaction\n+with the screen to determine whether those interactions cause the component to\n+behave as expected.\n+\n+To write these kinds of test, you'll use additional features of the `TestBed`\n+as well as other testing helpers.\n+\n+### CLI-generated tests\n+\n+The CLI creates an initial test file for you by default when you ask it to\n+generate a new component.\n+\n+For example, the following CLI command generates a `BannerComponent` in the `app/banner` folder (with inline template and styles):\n+\n+<code-example language=\"sh\" class=\"code-shell\">\n+ng generate component banner --inline-template --inline-style --module app\n+</code-example>\n+\n+It also generates an initial test file for the component, `banner-external.component.spec.ts`, that looks like this:\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"v1\"\n+  header=\"app/banner/banner-external.component.spec.ts (initial)\"></code-example>\n+\n+<div class=\"alert is-helpful\">\n+\n+Because `compileComponents` is asynchronous, it uses\n+the [`async`](api/core/testing/async) utility\n+function imported from `@angular/core/testing`.\n+\n+Please refer to the [async](guide/testing-components-scenarios#async) section for more details.\n+\n+</div>\n+\n+### Reduce the setup\n+\n+Only the last three lines of this file actually test the component\n+and all they do is assert that Angular can create the component.\n+\n+The rest of the file is boilerplate setup code anticipating more advanced tests that _might_ become necessary if the component evolves into something substantial.\n+\n+You'll learn about these advanced test features below.\n+For now, you can radically reduce this test file to a more manageable size:\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"v2\"\n+  header=\"app/banner/banner-initial.component.spec.ts (minimal)\"></code-example>\n+\n+In this example, the metadata object passed to `TestBed.configureTestingModule`\n+simply declares `BannerComponent`, the component to test.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"configureTestingModule\">\n+</code-example>\n+\n+<div class=\"alert is-helpful\">\n+\n+There's no need to declare or import anything else.\n+The default test module is pre-configured with\n+something like the `BrowserModule` from `@angular/platform-browser`.\n+\n+Later you'll call `TestBed.configureTestingModule()` with\n+imports, providers, and more declarations to suit your testing needs.\n+Optional `override` methods can further fine-tune aspects of the configuration.\n+\n+</div>\n+\n+{@a create-component}\n+\n+### _createComponent()_\n+\n+After configuring `TestBed`, you call its `createComponent()` method.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"createComponent\">\n+</code-example>\n+\n+`TestBed.createComponent()` creates an instance of the `BannerComponent`,\n+adds a corresponding element to the test-runner DOM,\n+and returns a [`ComponentFixture`](#component-fixture).\n+\n+<div class=\"alert is-important\">\n+\n+Do not re-configure `TestBed` after calling `createComponent`.\n+\n+The `createComponent` method freezes the current `TestBed` definition,\n+closing it to further configuration.\n+\n+You cannot call any more `TestBed` configuration methods, not `configureTestingModule()`,\n+nor `get()`, nor any of the `override...` methods.\n+If you try, `TestBed` throws an error.\n+\n+</div>\n+\n+{@a component-fixture}\n+\n+### _ComponentFixture_\n+\n+The [ComponentFixture](api/core/testing/ComponentFixture) is a test harness for interacting with the created component and its corresponding element.\n+\n+Access the component instance through the fixture and confirm it exists with a Jasmine expectation:\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"componentInstance\">\n+</code-example>\n+\n+### _beforeEach()_\n+\n+You will add more tests as this component evolves.\n+Rather than duplicate the `TestBed` configuration for each test,\n+you refactor to pull the setup into a Jasmine `beforeEach()` and some supporting variables:\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"v3\"\n+ ></code-example>\n+\n+Now add a test that gets the component's element from `fixture.nativeElement` and\n+looks for the expected text.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"v4-test-2\">\n+</code-example>\n+\n+{@a native-element}\n+\n+### _nativeElement_\n+\n+The value of `ComponentFixture.nativeElement` has the `any` type.\n+Later you'll encounter the `DebugElement.nativeElement` and it too has the `any` type.\n+\n+Angular can't know at compile time what kind of HTML element the `nativeElement` is or\n+if it even is an HTML element.\n+The app might be running on a _non-browser platform_, such as the server or a\n+[Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API),\n+where the element may have a diminished API or not exist at all.\n+\n+The tests in this guide are designed to run in a browser so a\n+`nativeElement` value will always be an `HTMLElement` or\n+one of its derived classes.\n+\n+Knowing that it is an `HTMLElement` of some sort, you can use\n+the standard HTML `querySelector` to dive deeper into the element tree.\n+\n+Here's another test that calls `HTMLElement.querySelector` to get the paragraph element and look for the banner text:\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"v4-test-3\">\n+</code-example>\n+\n+{@a debug-element}\n+\n+### _DebugElement_\n+\n+The Angular _fixture_ provides the component's element directly through the `fixture.nativeElement`.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"nativeElement\">\n+</code-example>\n+\n+This is actually a convenience method, implemented as `fixture.debugElement.nativeElement`.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"debugElement-nativeElement\">\n+</code-example>\n+\n+There's a good reason for this circuitous path to the element.\n+\n+The properties of the `nativeElement` depend upon the runtime environment.\n+You could be running these tests on a _non-browser_ platform that doesn't have a DOM or\n+whose DOM-emulation doesn't support the full `HTMLElement` API.\n+\n+Angular relies on the `DebugElement` abstraction to work safely across _all supported platforms_.\n+Instead of creating an HTML element tree, Angular creates a `DebugElement` tree that wraps the _native elements_ for the runtime platform.\n+The `nativeElement` property unwraps the `DebugElement` and returns the platform-specific element object.\n+\n+Because the sample tests for this guide are designed to run only in a browser,\n+a `nativeElement` in these tests is always an `HTMLElement`\n+whose familiar methods and properties you can explore within a test.\n+\n+Here's the previous test, re-implemented with `fixture.debugElement.nativeElement`:\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"v4-test-4\">\n+</code-example>\n+\n+The `DebugElement` has other methods and properties that\n+are useful in tests, as you'll see elsewhere in this guide.\n+\n+You import the `DebugElement` symbol from the Angular core library.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"import-debug-element\">\n+</code-example>\n+\n+{@a by-css}\n+### _By.css()_\n+\n+Although the tests in this guide all run in the browser,\n+some apps might run on a different platform at least some of the time.\n+\n+For example, the component might render first on the server as part of a strategy to make the application launch faster on poorly connected devices. The server-side renderer might not support the full HTML element API.\n+If it doesn't support `querySelector`, the previous test could fail.\n+\n+The `DebugElement` offers query methods that work for all supported platforms.\n+These query methods take a _predicate_ function that returns `true` when a node in the `DebugElement` tree matches the selection criteria.\n+\n+You create a _predicate_ with the help of a `By` class imported from a\n+library for the runtime platform. Here's the `By` import for the browser platform:\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"import-by\">\n+</code-example>\n+\n+The following example re-implements the previous test with\n+`DebugElement.query()` and the browser's `By.css` method.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-initial.component.spec.ts\"\n+  region=\"v4-test-5\">\n+</code-example>\n+\n+Some noteworthy observations:\n+\n+- The `By.css()` static method selects `DebugElement` nodes\n+  with a [standard CSS selector](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors 'CSS selectors').\n+- The query returns a `DebugElement` for the paragraph.\n+- You must unwrap that result to get the paragraph element.\n+\n+When you're filtering by CSS selector and only testing properties of a browser's _native element_, the `By.css` approach may be overkill.\n+\n+It's often easier and more clear to filter with a standard `HTMLElement` method\n+such as `querySelector()` or `querySelectorAll()`,\n+as you'll see in the next set of tests.\n+"
        },
        {
            "sha": "5f94cdef45d917afd4f4fc7c222390a2d53b169c",
            "filename": "aio/content/guide/testing-components-scenarios.md",
            "status": "added",
            "additions": 1826,
            "deletions": 0,
            "changes": 1826,
            "blob_url": "https://github.com/angular/angular/blob/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-components-scenarios.md",
            "raw_url": "https://github.com/angular/angular/raw/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-components-scenarios.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Ftesting-components-scenarios.md?ref=bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0",
            "patch": "@@ -0,0 +1,1826 @@\n+# Component testing scenarios\n+\n+This guide explores common component testing use cases.\n+\n+<div class=\"alert is-helpful\">\n+\n+  For the sample app that the testing guides describe, see the <live-example embedded-style noDownload>sample app</live-example>.\n+\n+  For the tests features in the testing guides, see <live-example stackblitz=\"specs\" noDownload>tests</live-example>.\n+\n+</div>\n+\n+## Component binding\n+\n+In the example app, the `BannerComponent` presents static title text in the HTML template.\n+\n+After a few changes, the `BannerComponent` presents a dynamic title by binding to\n+the component's `title` property like this.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner.component.ts\"\n+  region=\"component\"\n+  header=\"app/banner/banner.component.ts\"></code-example>\n+\n+As minimal as this is, you decide to add a test to confirm that component\n+actually displays the right content where you think it should.\n+\n+#### Query for the _&lt;h1&gt;_\n+\n+You'll write a sequence of tests that inspect the value of the `<h1>` element\n+that wraps the _title_ property interpolation binding.\n+\n+You update the `beforeEach` to find that element with a standard HTML `querySelector`\n+and assign it to the `h1` variable.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner.component.spec.ts\"\n+  region=\"setup\"\n+  header=\"app/banner/banner.component.spec.ts (setup)\"></code-example>\n+\n+{@a detect-changes}\n+\n+#### _createComponent()_ does not bind data\n+\n+For your first test you'd like to see that the screen displays the default `title`.\n+Your instinct is to write a test that immediately inspects the `<h1>` like this:\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner.component.spec.ts\"\n+  region=\"expect-h1-default-v1\">\n+</code-example>\n+\n+_That test fails_ with the message:\n+\n+```javascript\n+expected '' to contain 'Test Tour of Heroes'.\n+```\n+\n+Binding happens when Angular performs **change detection**.\n+\n+In production, change detection kicks in automatically\n+when Angular creates a component or the user enters a keystroke or\n+an asynchronous activity (e.g., AJAX) completes.\n+\n+The `TestBed.createComponent` does _not_ trigger change detection; a fact confirmed in the revised test:\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"test-w-o-detect-changes\"></code-example>\n+\n+#### _detectChanges()_\n+\n+You must tell the `TestBed` to perform data binding by calling `fixture.detectChanges()`.\n+Only then does the `<h1>` have the expected title.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner.component.spec.ts\"\n+  region=\"expect-h1-default\">\n+</code-example>\n+\n+Delayed change detection is intentional and useful.\n+It gives the tester an opportunity to inspect and change the state of\n+the component _before Angular initiates data binding and calls [lifecycle hooks](guide/lifecycle-hooks)_.\n+\n+Here's another test that changes the component's `title` property _before_ calling `fixture.detectChanges()`.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner.component.spec.ts\"\n+  region=\"after-change\">\n+</code-example>\n+\n+{@a auto-detect-changes}\n+\n+#### Automatic change detection\n+\n+The `BannerComponent` tests frequently call `detectChanges`.\n+Some testers prefer that the Angular test environment run change detection automatically.\n+\n+That's possible by configuring the `TestBed` with the `ComponentFixtureAutoDetect` provider.\n+First import it from the testing utility library:\n+\n+<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"import-ComponentFixtureAutoDetect\" header=\"app/banner/banner.component.detect-changes.spec.ts (import)\"></code-example>\n+\n+Then add it to the `providers` array of the testing module configuration:\n+\n+<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect\" header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect)\"></code-example>\n+\n+Here are three tests that illustrate how automatic change detection works.\n+\n+<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect-tests\" header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect Tests)\"></code-example>\n+\n+The first test shows the benefit of automatic change detection.\n+\n+The second and third test reveal an important limitation.\n+The Angular testing environment does _not_ know that the test changed the component's `title`.\n+The `ComponentFixtureAutoDetect` service responds to _asynchronous activities_ such as promise resolution, timers, and DOM events.\n+But a direct, synchronous update of the component property is invisible.\n+The test must call `fixture.detectChanges()` manually to trigger another cycle of change detection.\n+\n+<div class=\"alert is-helpful\">\n+\n+Rather than wonder when the test fixture will or won't perform change detection,\n+the samples in this guide _always call_ `detectChanges()` _explicitly_.\n+There is no harm in calling `detectChanges()` more often than is strictly necessary.\n+\n+</div>\n+\n+<hr>\n+\n+{@a dispatch-event}\n+\n+#### Change an input value with _dispatchEvent()_\n+\n+To simulate user input, you can find the input element and set its `value` property.\n+\n+You will call `fixture.detectChanges()` to trigger Angular's change detection.\n+But there is an essential, intermediate step.\n+\n+Angular doesn't know that you set the input element's `value` property.\n+It won't read that property until you raise the element's `input` event by calling `dispatchEvent()`.\n+_Then_ you call `detectChanges()`.\n+\n+The following example demonstrates the proper sequence.\n+\n+<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"title-case-pipe\" header=\"app/hero/hero-detail.component.spec.ts (pipe test)\"></code-example>\n+\n+<hr>\n+\n+## Component with external files\n+\n+The `BannerComponent` above is defined with an _inline template_ and _inline css_, specified in the `@Component.template` and `@Component.styles` properties respectively.\n+\n+Many components specify _external templates_ and _external css_ with the\n+`@Component.templateUrl` and `@Component.styleUrls` properties respectively,\n+as the following variant of `BannerComponent` does.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-external.component.ts\"\n+  region=\"metadata\"\n+  header=\"app/banner/banner-external.component.ts (metadata)\"></code-example>\n+\n+This syntax tells the Angular compiler to read the external files during component compilation.\n+\n+That's not a problem when you run the CLI `ng test` command because it\n+_compiles the app before running the tests_.\n+\n+However, if you run the tests in a **non-CLI environment**,\n+tests of this component may fail.\n+For example, if you run the `BannerComponent` tests in a web coding environment such as [plunker](https://plnkr.co/), you'll see a message like this one:\n+\n+<code-example language=\"sh\" class=\"code-shell\" hideCopy>\n+Error: This test module uses the component BannerComponent\n+which is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\n+Please call \"TestBed.compileComponents\" before your test.\n+</code-example>\n+\n+You get this test failure message when the runtime environment\n+compiles the source code _during the tests themselves_.\n+\n+To correct the problem, call `compileComponents()` as explained [below](#compile-components).\n+\n+{@a component-with-dependency}\n+\n+## Component with a dependency\n+\n+Components often have service dependencies.\n+\n+The `WelcomeComponent` displays a welcome message to the logged in user.\n+It knows who the user is based on a property of the injected `UserService`:\n+\n+<code-example path=\"testing/src/app/welcome/welcome.component.ts\" header=\"app/welcome/welcome.component.ts\"></code-example>\n+\n+The `WelcomeComponent` has decision logic that interacts with the service, logic that makes this component worth testing.\n+Here's the testing module configuration for the spec file, `app/welcome/welcome.component.spec.ts`:\n+\n+<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"config-test-module\" header=\"app/welcome/welcome.component.spec.ts\"></code-example>\n+\n+This time, in addition to declaring the _component-under-test_,\n+the configuration adds a `UserService` provider to the `providers` list.\n+But not the real `UserService`.\n+\n+{@a service-test-doubles}\n+\n+#### Provide service test doubles\n+\n+A _component-under-test_ doesn't have to be injected with real services.\n+In fact, it is usually better if they are test doubles (stubs, fakes, spies, or mocks).\n+The purpose of the spec is to test the component, not the service,\n+and real services can be trouble.\n+\n+Injecting the real `UserService` could be a nightmare.\n+The real service might ask the user for login credentials and\n+attempt to reach an authentication server.\n+These behaviors can be hard to intercept.\n+It is far easier and safer to create and register a test double in place of the real `UserService`.\n+\n+This particular test suite supplies a minimal mock of the `UserService` that satisfies the needs of the `WelcomeComponent` and its tests:\n+\n+<code-example\n+  path=\"testing/src/app/welcome/welcome.component.spec.ts\"\n+  region=\"user-service-stub\"\n+  header=\"app/welcome/welcome.component.spec.ts\"></code-example>\n+\n+{@a get-injected-service}\n+\n+#### Get injected services\n+\n+The tests need access to the (stub) `UserService` injected into the `WelcomeComponent`.\n+\n+Angular has a hierarchical injection system.\n+There can be injectors at multiple levels, from the root injector created by the `TestBed`\n+down through the component tree.\n+\n+The safest way to get the injected service, the way that **_always works_**,\n+is to **get it from the injector of the _component-under-test_**.\n+The component injector is a property of the fixture's `DebugElement`.\n+\n+<code-example\n+  path=\"testing/src/app/welcome/welcome.component.spec.ts\"\n+  region=\"injected-service\"\n+  header=\"WelcomeComponent's injector\">\n+</code-example>\n+\n+{@a testbed-inject}\n+\n+#### _TestBed.inject()_\n+\n+You _may_ also be able to get the service from the root injector via `TestBed.inject()`.\n+This is easier to remember and less verbose.\n+But it only works when Angular injects the component with the service instance in the test's root injector.\n+\n+In this test suite, the _only_ provider of `UserService` is the root testing module,\n+so it is safe to call `TestBed.inject()` as follows:\n+\n+<code-example\n+  path=\"testing/src/app/welcome/welcome.component.spec.ts\"\n+  region=\"inject-from-testbed\"\n+  header=\"TestBed injector\">\n+</code-example>\n+\n+<div class=\"alert is-helpful\">\n+\n+For a use case in which `TestBed.inject()` does not work,\n+see the [_Override component providers_](#component-override) section that\n+explains when and why you must get the service from the component's injector instead.\n+\n+</div>\n+\n+{@a welcome-spec-setup}\n+\n+#### Final setup and tests\n+\n+Here's the complete `beforeEach()`, using `TestBed.inject()`:\n+\n+<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"setup\" header=\"app/welcome/welcome.component.spec.ts\"></code-example>\n+\n+And here are some tests:\n+\n+<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"tests\" header=\"app/welcome/welcome.component.spec.ts\"></code-example>\n+\n+The first is a sanity test; it confirms that the stubbed `UserService` is called and working.\n+\n+<div class=\"alert is-helpful\">\n+\n+The second parameter to the Jasmine matcher (e.g., `'expected name'`) is an optional failure label.\n+If the expectation fails, Jasmine appends this label to the expectation failure message.\n+In a spec with multiple expectations, it can help clarify what went wrong and which expectation failed.\n+\n+</div>\n+\n+The remaining tests confirm the logic of the component when the service returns different values.\n+The second test validates the effect of changing the user name.\n+The third test checks that the component displays the proper message when there is no logged-in user.\n+\n+<hr>\n+\n+{@a component-with-async-service}\n+\n+## Component with async service\n+\n+In this sample, the `AboutComponent` template hosts a `TwainComponent`.\n+The `TwainComponent` displays Mark Twain quotes.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.ts\"\n+  region=\"template\"\n+  header=\"app/twain/twain.component.ts (template)\"></code-example>\n+\n+Note that the value of the component's `quote` property passes through an `AsyncPipe`.\n+That means the property returns either a `Promise` or an `Observable`.\n+\n+In this example, the `TwainComponent.getQuote()` method tells you that\n+the `quote` property returns an `Observable`.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.ts\"\n+  region=\"get-quote\"\n+  header=\"app/twain/twain.component.ts (getQuote)\"></code-example>\n+\n+The `TwainComponent` gets quotes from an injected `TwainService`.\n+The component starts the returned `Observable` with a placeholder value (`'...'`),\n+before the service can return its first quote.\n+\n+The `catchError` intercepts service errors, prepares an error message,\n+and returns the placeholder value on the success channel.\n+It must wait a tick to set the `errorMessage`\n+in order to avoid updating that message twice in the same change detection cycle.\n+\n+These are all features you'll want to test.\n+\n+#### Testing with a spy\n+\n+When testing a component, only the service's public API should matter.\n+In general, tests themselves should not make calls to remote servers.\n+They should emulate such calls. The setup in this `app/twain/twain.component.spec.ts` shows one way to do that:\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.spec.ts\"\n+  region=\"setup\"\n+  header=\"app/twain/twain.component.spec.ts (setup)\"></code-example>\n+\n+{@a service-spy}\n+\n+Focus on the spy.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.spec.ts\"\n+  region=\"spy\">\n+</code-example>\n+\n+The spy is designed such that any call to `getQuote` receives an observable with a test quote.\n+Unlike the real `getQuote()` method, this spy bypasses the server\n+and returns a synchronous observable whose value is available immediately.\n+\n+You can write many useful tests with this spy, even though its `Observable` is synchronous.\n+\n+{@a sync-tests}\n+\n+#### Synchronous tests\n+\n+A key advantage of a synchronous `Observable` is that\n+you can often turn asynchronous processes into synchronous tests.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.spec.ts\"\n+  region=\"sync-test\">\n+</code-example>\n+\n+Because the spy result returns synchronously, the `getQuote()` method updates\n+the message on screen immediately _after_\n+the first change detection cycle during which Angular calls `ngOnInit`.\n+\n+You're not so lucky when testing the error path.\n+Although the service spy will return an error synchronously,\n+the component method calls `setTimeout()`.\n+The test must wait at least one full turn of the JavaScript engine before the\n+value becomes available. The test must become _asynchronous_.\n+\n+{@a fake-async}\n+\n+#### Async test with _fakeAsync()_\n+\n+To use `fakeAsync()` functionality, you must import `zone.js/dist/zone-testing` in your test setup file.\n+If you created your project with the Angular CLI, `zone-testing` is already imported in `src/test.ts`.\n+\n+The following test confirms the expected behavior when the service returns an `ErrorObservable`.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.spec.ts\"\n+  region=\"error-test\">\n+</code-example>\n+\n+Note that the `it()` function receives an argument of the following form.\n+\n+```javascript\n+fakeAsync(() => { /* test body */ })\n+```\n+\n+The `fakeAsync()` function enables a linear coding style by running the test body in a special `fakeAsync test zone`.\n+The test body appears to be synchronous.\n+There is no nested syntax (like a `Promise.then()`) to disrupt the flow of control.\n+\n+<div class=\"alert is-helpful\">\n+\n+Limitation: The `fakeAsync()` function won't work if the test body makes an `XMLHttpRequest` (XHR) call.\n+XHR calls within a test are rare, but if you need to call XHR, see [`async()`](#async), below.\n+\n+</div>\n+\n+{@a tick}\n+\n+#### The _tick()_ function\n+\n+You do have to call [tick()](api/core/testing/tick) to advance the (virtual) clock.\n+\n+Calling [tick()](api/core/testing/tick) simulates the passage of time until all pending asynchronous activities finish.\n+In this case, it waits for the error handler's `setTimeout()`.\n+\n+The [tick()](api/core/testing/tick) function accepts milliseconds and tickOptions as parameters, the millisecond (defaults to 0 if not provided) parameter represents how much the virtual clock advances. For example, if you have a `setTimeout(fn, 100)` in a `fakeAsync()` test, you need to use tick(100) to trigger the fn callback. The tickOptions is an optional parameter with a property called `processNewMacroTasksSynchronously` (defaults to true) represents whether to invoke new generated macro tasks when ticking.\n+\n+<code-example\n+  path=\"testing/src/app/demo/async-helper.spec.ts\"\n+  region=\"fake-async-test-tick\">\n+</code-example>\n+\n+The [tick()](api/core/testing/tick) function is one of the Angular testing utilities that you import with `TestBed`.\n+It's a companion to `fakeAsync()` and you can only call it within a `fakeAsync()` body.\n+\n+#### tickOptions\n+\n+<code-example\n+  path=\"testing/src/app/demo/async-helper.spec.ts\"\n+  region=\"fake-async-test-tick-new-macro-task-sync\">\n+</code-example>\n+\n+In this example, we have a new macro task (nested setTimeout), by default, when we `tick`, the setTimeout `outside` and `nested` will both be triggered.\n+\n+<code-example\n+  path=\"testing/src/app/demo/async-helper.spec.ts\"\n+  region=\"fake-async-test-tick-new-macro-task-async\">\n+</code-example>\n+\n+And in some case, we don't want to trigger the new macro task when ticking, we can use `tick(milliseconds, {processNewMacroTasksSynchronously: false})` to not invoke new macro task.\n+\n+#### Comparing dates inside fakeAsync()\n+\n+`fakeAsync()` simulates passage of time, which allows you to calculate the difference between dates inside `fakeAsync()`.\n+\n+<code-example\n+  path=\"testing/src/app/demo/async-helper.spec.ts\"\n+  region=\"fake-async-test-date\">\n+</code-example>\n+\n+#### jasmine.clock with fakeAsync()\n+\n+Jasmine also provides a `clock` feature to mock dates. Angular automatically runs tests that are run after\n+`jasmine.clock().install()` is called inside a `fakeAsync()` method until `jasmine.clock().uninstall()` is called. `fakeAsync()` is not needed and throws an error if nested.\n+\n+By default, this feature is disabled. To enable it, set a global flag before importing `zone-testing`.\n+\n+If you use the Angular CLI, configure this flag in `src/test.ts`.\n+\n+```\n+(window as any)['__zone_symbol__fakeAsyncPatchLock'] = true;\n+import 'zone.js/dist/zone-testing';\n+```\n+\n+<code-example\n+  path=\"testing/src/app/demo/async-helper.spec.ts\"\n+  region=\"fake-async-test-clock\">\n+</code-example>\n+\n+#### Using the RxJS scheduler inside fakeAsync()\n+\n+You can also use RxJS scheduler in `fakeAsync()` just like using `setTimeout()` or `setInterval()`, but you need to import `zone.js/dist/zone-patch-rxjs-fake-async` to patch RxJS scheduler.\n+<code-example\n+  path=\"testing/src/app/demo/async-helper.spec.ts\"\n+  region=\"fake-async-test-rxjs\">\n+</code-example>\n+\n+#### Support more macroTasks\n+\n+By default, `fakeAsync()` supports the following macro tasks.\n+\n+- `setTimeout`\n+- `setInterval`\n+- `requestAnimationFrame`\n+- `webkitRequestAnimationFrame`\n+- `mozRequestAnimationFrame`\n+\n+If you run other macro tasks such as `HTMLCanvasElement.toBlob()`, an _\"Unknown macroTask scheduled in fake async test\"_ error will be thrown.\n+\n+<code-tabs>\n+  <code-pane\n+    header=\"src/app/shared/canvas.component.spec.ts (failing)\"\n+    path=\"testing/src/app/shared/canvas.component.spec.ts\"\n+    region=\"without-toBlob-macrotask\">\n+  </code-pane>\n+  <code-pane\n+    header=\"src/app/shared/canvas.component.ts\"\n+    path=\"testing/src/app/shared/canvas.component.ts\"\n+    region=\"main\">\n+  </code-pane>\n+</code-tabs>\n+\n+If you want to support such a case, you need to define the macro task you want to support in `beforeEach()`.\n+For example:\n+\n+<code-example\n+  header=\"src/app/shared/canvas.component.spec.ts (excerpt)\"\n+  path=\"testing/src/app/shared/canvas.component.spec.ts\"\n+  region=\"enable-toBlob-macrotask\">\n+</code-example>\n+\n+Note that in order to make the `<canvas>` element Zone.js-aware in your app, you need to import the `zone-patch-canvas` patch (either in `polyfills.ts` or in the specific file that uses `<canvas>`):\n+\n+<code-example\n+  header=\"src/polyfills.ts or src/app/shared/canvas.component.ts\"\n+  path=\"testing/src/app/shared/canvas.component.ts\"\n+  region=\"import-canvas-patch\">\n+</code-example>\n+\n+\n+#### Async observables\n+\n+You might be satisfied with the test coverage of these tests.\n+\n+However, you might be troubled by the fact that the real service doesn't quite behave this way.\n+The real service sends requests to a remote server.\n+A server takes time to respond and the response certainly won't be available immediately\n+as in the previous two tests.\n+\n+Your tests will reflect the real world more faithfully if you return an _asynchronous_ observable\n+from the `getQuote()` spy like this.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.spec.ts\"\n+  region=\"async-setup\">\n+</code-example>\n+\n+#### Async observable helpers\n+\n+The async observable was produced by an `asyncData` helper.\n+The `asyncData` helper is a utility function that you'll have to write yourself, or you can copy this one from the sample code.\n+\n+<code-example\n+  path=\"testing/src/testing/async-observable-helpers.ts\"\n+  region=\"async-data\"\n+  header=\"testing/async-observable-helpers.ts\">\n+</code-example>\n+\n+This helper's observable emits the `data` value in the next turn of the JavaScript engine.\n+\n+The [RxJS `defer()` operator](http://reactivex.io/documentation/operators/defer.html) returns an observable.\n+It takes a factory function that returns either a promise or an observable.\n+When something subscribes to _defer_'s observable,\n+it adds the subscriber to a new observable created with that factory.\n+\n+The `defer()` operator transforms the `Promise.resolve()` into a new observable that,\n+like `HttpClient`, emits once and completes.\n+Subscribers are unsubscribed after they receive the data value.\n+\n+There's a similar helper for producing an async error.\n+\n+<code-example\n+  path=\"testing/src/testing/async-observable-helpers.ts\"\n+  region=\"async-error\">\n+</code-example>\n+\n+#### More async tests\n+\n+Now that the `getQuote()` spy is returning async observables,\n+most of your tests will have to be async as well.\n+\n+Here's a `fakeAsync()` test that demonstrates the data flow you'd expect\n+in the real world.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.spec.ts\"\n+  region=\"fake-async-test\">\n+</code-example>\n+\n+Notice that the quote element displays the placeholder value (`'...'`) after `ngOnInit()`.\n+The first quote hasn't arrived yet.\n+\n+To flush the first quote from the observable, you call [tick()](api/core/testing/tick).\n+Then call `detectChanges()` to tell Angular to update the screen.\n+\n+Then you can assert that the quote element displays the expected text.\n+\n+{@a async}\n+\n+#### Async test with _async()_\n+\n+To use `async()` functionality, you must import `zone.js/dist/zone-testing` in your test setup file.\n+If you created your project with the Angular CLI, `zone-testing` is already imported in `src/test.ts`.\n+\n+The `fakeAsync()` utility function has a few limitations.\n+In particular, it won't work if the test body makes an `XMLHttpRequest` (XHR) call.\n+XHR calls within a test are rare so you can generally stick with [`fakeAsync()`](#fake-async).\n+But if you ever do need to call `XMLHttpRequest`, you'll want to know about `async()`.\n+\n+<div class=\"alert is-helpful\">\n+\n+The `TestBed.compileComponents()` method (see [below](#compile-components)) calls `XHR`\n+to read external template and css files during \"just-in-time\" compilation.\n+Write tests that call `compileComponents()` with the `async()` utility.\n+\n+</div>\n+\n+Here's the previous `fakeAsync()` test, re-written with the `async()` utility.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.spec.ts\"\n+  region=\"async-test\">\n+</code-example>\n+\n+The `async()` utility hides some asynchronous boilerplate by arranging for the tester's code\n+to run in a special _async test zone_.\n+You don't need to pass Jasmine's `done()` into the test and call `done()` because it is `undefined` in promise or observable callbacks.\n+\n+But the test's asynchronous nature is revealed by the call to `fixture.whenStable()`,\n+which breaks the linear flow of control.\n+\n+When using an `intervalTimer()` such as `setInterval()` in `async()`, remember to cancel the timer with `clearInterval()` after the test, otherwise the `async()` never ends.\n+\n+{@a when-stable}\n+\n+#### _whenStable_\n+\n+The test must wait for the `getQuote()` observable to emit the next quote.\n+Instead of calling [tick()](api/core/testing/tick), it calls `fixture.whenStable()`.\n+\n+The `fixture.whenStable()` returns a promise that resolves when the JavaScript engine's\n+task queue becomes empty.\n+In this example, the task queue becomes empty when the observable emits the first quote.\n+\n+The test resumes within the promise callback, which calls `detectChanges()` to\n+update the quote element with the expected text.\n+\n+{@a jasmine-done}\n+\n+#### Jasmine _done()_\n+\n+While the `async()` and `fakeAsync()` functions greatly\n+simplify Angular asynchronous testing,\n+you can still fall back to the traditional technique\n+and pass `it` a function that takes a\n+[`done` callback](https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support).\n+\n+You can't call `done()` in `async()` or `fakeAsync()` functions, because the `done parameter`\n+is `undefined`.\n+\n+Now you are responsible for chaining promises, handling errors, and calling `done()` at the appropriate moments.\n+\n+Writing test functions with `done()`, is more cumbersome than `async()`and `fakeAsync()`, but it is occasionally necessary when code involves the `intervalTimer()` like `setInterval`.\n+\n+Here are two more versions of the previous test, written with `done()`.\n+The first one subscribes to the `Observable` exposed to the template by the component's `quote` property.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.spec.ts\"\n+  region=\"quote-done-test\"></code-example>\n+\n+The RxJS `last()` operator emits the observable's last value before completing, which will be the test quote.\n+The `subscribe` callback calls `detectChanges()` to\n+update the quote element with the test quote, in the same manner as the earlier tests.\n+\n+In some tests, you're more interested in how an injected service method was called and what values it returned,\n+than what appears on screen.\n+\n+A service spy, such as the `qetQuote()` spy of the fake `TwainService`,\n+can give you that information and make assertions about the state of the view.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.spec.ts\"\n+  region=\"spy-done-test\"></code-example>\n+\n+<hr>\n+\n+{@a marble-testing}\n+## Component marble tests\n+\n+The previous `TwainComponent` tests simulated an asynchronous observable response\n+from the `TwainService` with the `asyncData` and `asyncError` utilities.\n+\n+These are short, simple functions that you can write yourself.\n+Unfortunately, they're too simple for many common scenarios.\n+An observable often emits multiple times, perhaps after a significant delay.\n+A component may coordinate multiple observables\n+with overlapping sequences of values and errors.\n+\n+**RxJS marble testing** is a great way to test observable scenarios,\n+both simple and complex.\n+You've likely seen the [marble diagrams](http://rxmarbles.com/)\n+that illustrate how observables work.\n+Marble testing uses a similar marble language to\n+specify the observable streams and expectations in your tests.\n+\n+The following examples revisit two of the `TwainComponent` tests\n+with marble testing.\n+\n+Start by installing the `jasmine-marbles` npm package.\n+Then import the symbols you need.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.marbles.spec.ts\"\n+  region=\"import-marbles\"\n+  header=\"app/twain/twain.component.marbles.spec.ts (import marbles)\"></code-example>\n+\n+Here's the complete test for getting a quote:\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.marbles.spec.ts\"\n+  region=\"get-quote-test\"></code-example>\n+\n+Notice that the Jasmine test is synchronous. There's no `fakeAsync()`.\n+Marble testing uses a test scheduler to simulate the passage of time\n+in a synchronous test.\n+\n+The beauty of marble testing is in the visual definition of the observable streams.\n+This test defines a [_cold_ observable](#cold-observable) that waits\n+three [frames](#marble-frame) (`---`),\n+emits a value (`x`), and completes (`|`).\n+In the second argument you map the value marker (`x`) to the emitted value (`testQuote`).\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.marbles.spec.ts\"\n+  region=\"test-quote-marbles\"></code-example>\n+\n+The marble library constructs the corresponding observable, which the\n+test sets as the `getQuote` spy's return value.\n+\n+When you're ready to activate the marble observables,\n+you tell the `TestScheduler` to _flush_ its queue of prepared tasks like this.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.marbles.spec.ts\"\n+  region=\"test-scheduler-flush\"></code-example>\n+\n+This step serves a purpose analogous to [tick()](api/core/testing/tick) and `whenStable()` in the\n+earlier `fakeAsync()` and `async()` examples.\n+The balance of the test is the same as those examples.\n+\n+#### Marble error testing\n+\n+Here's the marble testing version of the `getQuote()` error test.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.marbles.spec.ts\"\n+  region=\"error-test\"></code-example>\n+\n+It's still an async test, calling `fakeAsync()` and [tick()](api/core/testing/tick), because the component itself\n+calls `setTimeout()` when processing errors.\n+\n+Look at the marble observable definition.\n+\n+<code-example\n+  path=\"testing/src/app/twain/twain.component.marbles.spec.ts\"\n+  region=\"error-marbles\"></code-example>\n+\n+This is a _cold_ observable that waits three frames and then emits an error,\n+The hash (`#`) indicates the timing of the error that is specified in the third argument.\n+The second argument is null because the observable never emits a value.\n+\n+#### Learn about marble testing\n+\n+{@a marble-frame}\n+A _marble frame_ is a virtual unit of testing time.\n+Each symbol (`-`, `x`, `|`, `#`) marks the passing of one frame.\n+\n+{@a cold-observable}\n+A _cold_ observable doesn't produce values until you subscribe to it.\n+Most of your application observables are cold.\n+All [_HttpClient_](guide/http) methods return cold observables.\n+\n+A _hot_ observable is already producing values _before_ you subscribe to it.\n+The [_Router.events_](api/router/Router#events) observable,\n+which reports router activity, is a _hot_ observable.\n+\n+RxJS marble testing is a rich subject, beyond the scope of this guide.\n+Learn about it on the web, starting with the\n+[official documentation](https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md).\n+\n+<hr>\n+\n+{@a component-with-input-output}\n+\n+## Component with inputs and outputs\n+\n+A component with inputs and outputs typically appears inside the view template of a host component.\n+The host uses a property binding to set the input property and an event binding to\n+listen to events raised by the output property.\n+\n+The testing goal is to verify that such bindings work as expected.\n+The tests should set input values and listen for output events.\n+\n+The `DashboardHeroComponent` is a tiny example of a component in this role.\n+It displays an individual hero provided by the `DashboardComponent`.\n+Clicking that hero tells the `DashboardComponent` that the user has selected the hero.\n+\n+The `DashboardHeroComponent` is embedded in the `DashboardComponent` template like this:\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard.component.html\"\n+  region=\"dashboard-hero\"\n+  header=\"app/dashboard/dashboard.component.html (excerpt)\"></code-example>\n+\n+The `DashboardHeroComponent` appears in an `*ngFor` repeater, which sets each component's `hero` input property\n+to the looping value and listens for the component's `selected` event.\n+\n+Here's the component's full definition:\n+\n+{@a dashboard-hero-component}\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard-hero.component.ts\"\n+  region=\"component\"\n+  header=\"app/dashboard/dashboard-hero.component.ts (component)\"></code-example>\n+\n+While testing a component this simple has little intrinsic value, it's worth knowing how.\n+You can use one of these approaches:\n+\n+- Test it as used by `DashboardComponent`.\n+- Test it as a stand-alone component.\n+- Test it as used by a substitute for `DashboardComponent`.\n+\n+A quick look at the `DashboardComponent` constructor discourages the first approach:\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard.component.ts\"\n+  region=\"ctor\"\n+  header=\"app/dashboard/dashboard.component.ts (constructor)\"></code-example>\n+\n+The `DashboardComponent` depends on the Angular router and the `HeroService`.\n+You'd probably have to replace them both with test doubles, which is a lot of work.\n+The router seems particularly challenging.\n+\n+<div class=\"alert is-helpful\">\n+\n+The [discussion below](#routing-component) covers testing components that require the router.\n+\n+</div>\n+\n+The immediate goal is to test the `DashboardHeroComponent`, not the `DashboardComponent`,\n+so, try the second and third options.\n+\n+{@a dashboard-standalone}\n+\n+#### Test _DashboardHeroComponent_ stand-alone\n+\n+Here's the meat of the spec file setup.\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\"\n+  region=\"setup\"\n+  header=\"app/dashboard/dashboard-hero.component.spec.ts (setup)\"></code-example>\n+\n+Note how the setup code assigns a test hero (`expectedHero`) to the component's `hero` property,\n+emulating the way the `DashboardComponent` would set it\n+via the property binding in its repeater.\n+\n+The following test verifies that the hero name is propagated to the template via a binding.\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\"\n+  region=\"name-test\">\n+</code-example>\n+\n+Because the [template](#dashboard-hero-component) passes the hero name through the Angular `UpperCasePipe`,\n+the test must match the element value with the upper-cased name.\n+\n+<div class=\"alert is-helpful\">\n+\n+This small test demonstrates how Angular tests can verify a component's visual\n+representation&mdash;something not possible with\n+[component class tests](guide/testing-components-basics#component-class-testing)&mdash;at\n+low cost and without resorting to much slower and more complicated end-to-end tests.\n+\n+</div>\n+\n+#### Clicking\n+\n+Clicking the hero should raise a `selected` event that\n+the host component (`DashboardComponent` presumably) can hear:\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\"\n+  region=\"click-test\">\n+</code-example>\n+\n+The component's `selected` property returns an `EventEmitter`,\n+which looks like an RxJS synchronous `Observable` to consumers.\n+The test subscribes to it _explicitly_ just as the host component does _implicitly_.\n+\n+If the component behaves as expected, clicking the hero's element\n+should tell the component's `selected` property to emit the `hero` object.\n+\n+The test detects that event through its subscription to `selected`.\n+\n+{@a trigger-event-handler}\n+\n+#### _triggerEventHandler_\n+\n+The `heroDe` in the previous test is a `DebugElement` that represents the hero `<div>`.\n+\n+It has Angular properties and methods that abstract interaction with the native element.\n+This test calls the `DebugElement.triggerEventHandler` with the \"click\" event name.\n+The \"click\" event binding responds by calling `DashboardHeroComponent.click()`.\n+\n+The Angular `DebugElement.triggerEventHandler` can raise _any data-bound event_ by its _event name_.\n+The second parameter is the event object passed to the handler.\n+\n+The test triggered a \"click\" event with a `null` event object.\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"trigger-event-handler\">\n+</code-example>\n+\n+The test assumes (correctly in this case) that the runtime\n+event handler&mdash;the component's `click()` method&mdash;doesn't\n+care about the event object.\n+\n+<div class=\"alert is-helpful\">\n+\n+Other handlers are less forgiving. For example, the `RouterLink`\n+directive expects an object with a `button` property\n+that identifies which mouse button (if any) was pressed during the click.\n+The `RouterLink` directive throws an error if the event object is missing.\n+\n+</div>\n+\n+#### Click the element\n+\n+The following test alternative calls the native element's own `click()` method,\n+which is perfectly fine for _this component_.\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\"\n+  region=\"click-test-2\">\n+</code-example>\n+\n+{@a click-helper}\n+\n+#### _click()_ helper\n+\n+Clicking a button, an anchor, or an arbitrary HTML element is a common test task.\n+\n+Make that consistent and easy by encapsulating the _click-triggering_ process\n+in a helper such as the `click()` function below:\n+\n+<code-example\n+  path=\"testing/src/testing/index.ts\"\n+  region=\"click-event\"\n+  header=\"testing/index.ts (click helper)\"></code-example>\n+\n+The first parameter is the _element-to-click_. If you wish, you can pass a\n+custom event object as the second parameter. The default is a (partial)\n+<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\">left-button mouse event object</a>\n+accepted by many handlers including the `RouterLink` directive.\n+\n+<div class=\"alert is-important\">\n+\n+The `click()` helper function is **not** one of the Angular testing utilities.\n+It's a function defined in _this guide's sample code_.\n+All of the sample tests use it.\n+If you like it, add it to your own collection of helpers.\n+\n+</div>\n+\n+Here's the previous test, rewritten using the click helper.\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\"\n+  region=\"click-test-3\"\n+  header=\"app/dashboard/dashboard-hero.component.spec.ts (test with click helper)\">\n+</code-example>\n+\n+<hr>\n+\n+{@a component-inside-test-host}\n+\n+## Component inside a test host\n+\n+The previous tests played the role of the host `DashboardComponent` themselves.\n+But does the `DashboardHeroComponent` work correctly when properly data-bound to a host component?\n+\n+You could test with the actual `DashboardComponent`.\n+But doing so could require a lot of setup,\n+especially when its template features an `*ngFor` repeater,\n+other components, layout HTML, additional bindings,\n+a constructor that injects multiple services,\n+and it starts interacting with those services right away.\n+\n+Imagine the effort to disable these distractions, just to prove a point\n+that can be made satisfactorily with a _test host_ like this one:\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\"\n+  region=\"test-host\"\n+  header=\"app/dashboard/dashboard-hero.component.spec.ts (test host)\"\n+ ></code-example>\n+\n+This test host binds to `DashboardHeroComponent` as the `DashboardComponent` would\n+but without the noise of the `Router`, the `HeroService`, or the `*ngFor` repeater.\n+\n+The test host sets the component's `hero` input property with its test hero.\n+It binds the component's `selected` event with its `onSelected` handler,\n+which records the emitted hero in its `selectedHero` property.\n+\n+Later, the tests will be able to easily check `selectedHero` to verify that the\n+`DashboardHeroComponent.selected` event emitted the expected hero.\n+\n+The setup for the _test-host_ tests is similar to the setup for the stand-alone tests:\n+\n+<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-setup\" header=\"app/dashboard/dashboard-hero.component.spec.ts (test host setup)\"></code-example>\n+\n+This testing module configuration shows three important differences:\n+\n+1. It _declares_ both the `DashboardHeroComponent` and the `TestHostComponent`.\n+1. It _creates_ the `TestHostComponent` instead of the `DashboardHeroComponent`.\n+1. The `TestHostComponent` sets the `DashboardHeroComponent.hero` with a binding.\n+\n+The `createComponent` returns a `fixture` that holds an instance of `TestHostComponent` instead of an instance of `DashboardHeroComponent`.\n+\n+Creating the `TestHostComponent` has the side-effect of creating a `DashboardHeroComponent`\n+because the latter appears within the template of the former.\n+The query for the hero element (`heroEl`) still finds it in the test DOM,\n+albeit at greater depth in the element tree than before.\n+\n+The tests themselves are almost identical to the stand-alone version:\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\"\n+  region=\"test-host-tests\"\n+  header=\"app/dashboard/dashboard-hero.component.spec.ts (test-host)\"></code-example>\n+\n+Only the selected event test differs. It confirms that the selected `DashboardHeroComponent` hero\n+really does find its way up through the event binding to the host component.\n+\n+<hr>\n+\n+{@a routing-component}\n+\n+## Routing component\n+\n+A _routing component_ is a component that tells the `Router` to navigate to another component.\n+The `DashboardComponent` is a _routing component_ because the user can\n+navigate to the `HeroDetailComponent` by clicking on one of the _hero buttons_ on the dashboard.\n+\n+Routing is pretty complicated.\n+Testing the `DashboardComponent` seemed daunting in part because it involves the `Router`,\n+which it injects together with the `HeroService`.\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard.component.ts\"\n+  region=\"ctor\"\n+  header=\"app/dashboard/dashboard.component.ts (constructor)\"></code-example>\n+\n+Mocking the `HeroService` with a spy is a [familiar story](#component-with-async-service).\n+But the `Router` has a complicated API and is entwined with other services and application preconditions. Might it be difficult to mock?\n+\n+Fortunately, not in this case because the `DashboardComponent` isn't doing much with the `Router`\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard.component.ts\"\n+  region=\"goto-detail\"\n+  header=\"app/dashboard/dashboard.component.ts (goToDetail)\">\n+</code-example>\n+\n+This is often the case with _routing components_.\n+As a rule you test the component, not the router,\n+and care only if the component navigates with the right address under the given conditions.\n+\n+Providing a router spy for _this component_ test suite happens to be as easy\n+as providing a `HeroService` spy.\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard.component.spec.ts\"\n+  region=\"router-spy\"\n+  header=\"app/dashboard/dashboard.component.spec.ts (spies)\"></code-example>\n+\n+The following test clicks the displayed hero and confirms that\n+`Router.navigateByUrl` is called with the expected url.\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard.component.spec.ts\"\n+  region=\"navigate-test\"\n+  header=\"app/dashboard/dashboard.component.spec.ts (navigate test)\"></code-example>\n+\n+{@a routed-component-w-param}\n+\n+## Routed components\n+\n+A _routed component_ is the destination of a `Router` navigation.\n+It can be trickier to test, especially when the route to the component _includes parameters_.\n+The `HeroDetailComponent` is a _routed component_ that is the destination of such a route.\n+\n+When a user clicks a _Dashboard_ hero, the `DashboardComponent` tells the `Router`\n+to navigate to `heroes/:id`.\n+The `:id` is a route parameter whose value is the `id` of the hero to edit.\n+\n+The `Router` matches that URL to a route to the `HeroDetailComponent`.\n+It creates an `ActivatedRoute` object with the routing information and\n+injects it into a new instance of the `HeroDetailComponent`.\n+\n+Here's the `HeroDetailComponent` constructor:\n+\n+<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ctor\" header=\"app/hero/hero-detail.component.ts (constructor)\"></code-example>\n+\n+The `HeroDetail` component needs the `id` parameter so it can fetch\n+the corresponding hero via the `HeroDetailService`.\n+The component has to get the `id` from the `ActivatedRoute.paramMap` property\n+which is an `Observable`.\n+\n+It can't just reference the `id` property of the `ActivatedRoute.paramMap`.\n+The component has to _subscribe_ to the `ActivatedRoute.paramMap` observable and be prepared\n+for the `id` to change during its lifetime.\n+\n+<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ng-on-init\" header=\"app/hero/hero-detail.component.ts (ngOnInit)\"></code-example>\n+\n+<div class=\"alert is-helpful\">\n+\n+The [ActivatedRoute in action](guide/router#activated-route-in-action) section of the [Router](guide/router) guide covers `ActivatedRoute.paramMap` in more detail.\n+\n+</div>\n+\n+Tests can explore how the `HeroDetailComponent` responds to different `id` parameter values\n+by manipulating the `ActivatedRoute` injected into the component's constructor.\n+\n+You know how to spy on the `Router` and a data service.\n+\n+You'll take a different approach with `ActivatedRoute` because\n+\n+- `paramMap` returns an `Observable` that can emit more than one value\n+  during a test.\n+- You need the router helper function, `convertToParamMap()`, to create a `ParamMap`.\n+- Other _routed component_ tests need a test double for `ActivatedRoute`.\n+\n+These differences argue for a re-usable stub class.\n+\n+#### _ActivatedRouteStub_\n+\n+The following `ActivatedRouteStub` class serves as a test double for `ActivatedRoute`.\n+\n+<code-example\n+  path=\"testing/src/testing/activated-route-stub.ts\"\n+  region=\"activated-route-stub\"\n+  header=\"testing/activated-route-stub.ts (ActivatedRouteStub)\"></code-example>\n+\n+Consider placing such helpers in a `testing` folder sibling to the `app` folder.\n+This sample puts `ActivatedRouteStub` in `testing/activated-route-stub.ts`.\n+\n+<div class=\"alert is-helpful\">\n+\n+Consider writing a more capable version of this stub class with\n+the [_marble testing library_](#marble-testing).\n+\n+</div>\n+\n+{@a tests-w-test-double}\n+\n+#### Testing with _ActivatedRouteStub_\n+\n+Here's a test demonstrating the component's behavior when the observed `id` refers to an existing hero:\n+\n+<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-good-id\" header=\"app/hero/hero-detail.component.spec.ts (existing id)\"></code-example>\n+\n+<div class=\"alert is-helpful\">\n+\n+The `createComponent()` method and `page` object are discussed [below](#page-object).\n+Rely on your intuition for now.\n+\n+</div>\n+\n+When the `id` cannot be found, the component should re-route to the `HeroListComponent`.\n+\n+The test suite setup provided the same router spy [described above](#routing-component) which spies on the router without actually navigating.\n+\n+This test expects the component to try to navigate to the `HeroListComponent`.\n+\n+<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-bad-id\" header=\"app/hero/hero-detail.component.spec.ts (bad id)\"></code-example>\n+\n+While this app doesn't have a route to the `HeroDetailComponent` that omits the `id` parameter, it might add such a route someday.\n+The component should do something reasonable when there is no `id`.\n+\n+In this implementation, the component should create and display a new hero.\n+New heroes have `id=0` and a blank `name`. This test confirms that the component behaves as expected:\n+\n+<code-example\n+  path=\"testing/src/app/hero/hero-detail.component.spec.ts\"\n+  region=\"route-no-id\"\n+  header=\"app/hero/hero-detail.component.spec.ts (no id)\"></code-example>\n+\n+<hr>\n+\n+## Nested component tests\n+\n+Component templates often have nested components, whose templates\n+may contain more components.\n+\n+The component tree can be very deep and, most of the time, the nested components\n+play no role in testing the component at the top of the tree.\n+\n+The `AppComponent`, for example, displays a navigation bar with anchors and their `RouterLink` directives.\n+\n+<code-example\n+  path=\"testing/src/app/app.component.html\"\n+  header=\"app/app.component.html\"></code-example>\n+\n+While the `AppComponent` _class_ is empty,\n+you may want to write unit tests to confirm that the links are wired properly\n+to the `RouterLink` directives, perhaps for the reasons [explained below](#why-stubbed-routerlink-tests).\n+\n+To validate the links, you don't need the `Router` to navigate and you don't\n+need the `<router-outlet>` to mark where the `Router` inserts _routed components_.\n+\n+The `BannerComponent` and `WelcomeComponent`\n+(indicated by `<app-banner>` and `<app-welcome>`) are also irrelevant.\n+\n+Yet any test that creates the `AppComponent` in the DOM will also create instances of\n+these three components and, if you let that happen,\n+you'll have to configure the `TestBed` to create them.\n+\n+If you neglect to declare them, the Angular compiler won't recognize the\n+`<app-banner>`, `<app-welcome>`, and `<router-outlet>` tags in the `AppComponent` template\n+and will throw an error.\n+\n+If you declare the real components, you'll also have to declare _their_ nested components\n+and provide for _all_ services injected in _any_ component in the tree.\n+\n+That's too much effort just to answer a few simple questions about links.\n+\n+This section describes two techniques for minimizing the setup.\n+Use them, alone or in combination, to stay focused on the testing the primary component.\n+\n+{@a stub-component}\n+\n+##### Stubbing unneeded components\n+\n+In the first technique, you create and declare stub versions of the components\n+and directive that play little or no role in the tests.\n+\n+<code-example\n+  path=\"testing/src/app/app.component.spec.ts\"\n+  region=\"component-stubs\"\n+  header=\"app/app.component.spec.ts (stub declaration)\"></code-example>\n+\n+The stub selectors match the selectors for the corresponding real components.\n+But their templates and classes are empty.\n+\n+Then declare them in the `TestBed` configuration next to the\n+components, directives, and pipes that need to be real.\n+\n+<code-example\n+  path=\"testing/src/app/app.component.spec.ts\"\n+  region=\"testbed-stubs\"\n+  header=\"app/app.component.spec.ts (TestBed stubs)\"></code-example>\n+\n+The `AppComponent` is the test subject, so of course you declare the real version.\n+\n+The `RouterLinkDirectiveStub`, [described later](#routerlink), is a test version\n+of the real `RouterLink` that helps with the link tests.\n+\n+The rest are stubs.\n+\n+{@a no-errors-schema}\n+\n+#### _NO_ERRORS_SCHEMA_\n+\n+In the second approach, add `NO_ERRORS_SCHEMA` to the `TestBed.schemas` metadata.\n+\n+<code-example\n+  path=\"testing/src/app/app.component.spec.ts\"\n+  region=\"no-errors-schema\"\n+  header=\"app/app.component.spec.ts (NO_ERRORS_SCHEMA)\"></code-example>\n+\n+The `NO_ERRORS_SCHEMA` tells the Angular compiler to ignore unrecognized elements and attributes.\n+\n+The compiler will recognize the `<app-root>` element and the `routerLink` attribute\n+because you declared a corresponding `AppComponent` and `RouterLinkDirectiveStub`\n+in the `TestBed` configuration.\n+\n+But the compiler won't throw an error when it encounters `<app-banner>`, `<app-welcome>`, or `<router-outlet>`.\n+It simply renders them as empty tags and the browser ignores them.\n+\n+You no longer need the stub components.\n+\n+#### Use both techniques together\n+\n+These are techniques for _Shallow Component Testing_ ,\n+so-named because they reduce the visual surface of the component to just those elements\n+in the component's template that matter for tests.\n+\n+The `NO_ERRORS_SCHEMA` approach is the easier of the two but don't overuse it.\n+\n+The `NO_ERRORS_SCHEMA` also prevents the compiler from telling you about the missing\n+components and attributes that you omitted inadvertently or misspelled.\n+You could waste hours chasing phantom bugs that the compiler would have caught in an instant.\n+\n+The _stub component_ approach has another advantage.\n+While the stubs in _this_ example were empty,\n+you could give them stripped-down templates and classes if your tests\n+need to interact with them in some way.\n+\n+In practice you will combine the two techniques in the same setup,\n+as seen in this example.\n+\n+<code-example\n+  path=\"testing/src/app/app.component.spec.ts\"\n+  region=\"mixed-setup\"\n+  header=\"app/app.component.spec.ts (mixed setup)\"></code-example>\n+\n+The Angular compiler creates the `BannerComponentStub` for the `<app-banner>` element\n+and applies the `RouterLinkStubDirective` to the anchors with the `routerLink` attribute,\n+but it ignores the `<app-welcome>` and `<router-outlet>` tags.\n+\n+<hr>\n+\n+{@a routerlink}\n+## Components with _RouterLink_\n+\n+The real `RouterLinkDirective` is quite complicated and entangled with other components\n+and directives of the `RouterModule`.\n+It requires challenging setup to mock and use in tests.\n+\n+The `RouterLinkDirectiveStub` in this sample code replaces the real directive\n+with an alternative version designed to validate the kind of anchor tag wiring\n+seen in the `AppComponent` template.\n+\n+<code-example\n+  path=\"testing/src/testing/router-link-directive-stub.ts\"\n+  region=\"router-link\"\n+  header=\"testing/router-link-directive-stub.ts (RouterLinkDirectiveStub)\"></code-example>\n+\n+The URL bound to the `[routerLink]` attribute flows in to the directive's `linkParams` property.\n+\n+The `HostListener` wires the click event of the host element\n+(the `<a>` anchor elements in `AppComponent`) to the stub directive's `onClick` method.\n+\n+Clicking the anchor should trigger the `onClick()` method,\n+which sets the stub's telltale `navigatedTo` property.\n+Tests inspect `navigatedTo` to confirm that clicking the anchor\n+set the expected route definition.\n+\n+<div class=\"alert is-helpful\">\n+\n+Whether the router is configured properly to navigate with that route definition is a\n+question for a separate set of tests.\n+\n+</div>\n+\n+{@a by-directive}\n+{@a inject-directive}\n+\n+#### _By.directive_ and injected directives\n+\n+A little more setup triggers the initial data binding and gets references to the navigation links:\n+\n+<code-example\n+  path=\"testing/src/app/app.component.spec.ts\"\n+  region=\"test-setup\"\n+  header=\"app/app.component.spec.ts (test setup)\"></code-example>\n+\n+Three points of special interest:\n+\n+1.  You can locate the anchor elements with an attached directive using `By.directive`.\n+\n+1.  The query returns `DebugElement` wrappers around the matching elements.\n+\n+1.  Each `DebugElement` exposes a dependency injector with the\n+    specific instance of the directive attached to that element.\n+\n+The `AppComponent` links to validate are as follows:\n+\n+<code-example\n+  path=\"testing/src/app/app.component.html\"\n+  region=\"links\"\n+  header=\"app/app.component.html (navigation links)\"></code-example>\n+\n+{@a app-component-tests}\n+\n+Here are some tests that confirm those links are wired to the `routerLink` directives\n+as expected:\n+\n+<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"tests\" header=\"app/app.component.spec.ts (selected tests)\"></code-example>\n+\n+<div class=\"alert is-helpful\">\n+\n+The \"click\" test _in this example_ is misleading.\n+It tests the `RouterLinkDirectiveStub` rather than the _component_.\n+This is a common failing of directive stubs.\n+\n+It has a legitimate purpose in this guide.\n+It demonstrates how to find a `RouterLink` element, click it, and inspect a result,\n+without engaging the full router machinery.\n+This is a skill you may need to test a more sophisticated component, one that changes the display,\n+re-calculates parameters, or re-arranges navigation options when the user clicks the link.\n+\n+</div>\n+\n+{@a why-stubbed-routerlink-tests}\n+\n+#### What good are these tests?\n+\n+Stubbed `RouterLink` tests can confirm that a component with links and an outlet is setup properly,\n+that the component has the links it should have, and that they are all pointing in the expected direction.\n+These tests do not concern whether the app will succeed in navigating to the target component when the user clicks a link.\n+\n+Stubbing the RouterLink and RouterOutlet is the best option for such limited testing goals.\n+Relying on the real router would make them brittle.\n+They could fail for reasons unrelated to the component.\n+For example, a navigation guard could prevent an unauthorized user from visiting the `HeroListComponent`.\n+That's not the fault of the `AppComponent` and no change to that component could cure the failed test.\n+\n+A _different_ battery of tests can explore whether the application navigates as expected\n+in the presence of conditions that influence guards such as whether the user is authenticated and authorized.\n+\n+<div class=\"alert is-helpful\">\n+\n+A future guide update will explain how to write such\n+tests with the `RouterTestingModule`.\n+\n+</div>\n+\n+<hr>\n+\n+{@a page-object}\n+\n+## Use a _page_ object\n+\n+The `HeroDetailComponent` is a simple view with a title, two hero fields, and two buttons.\n+\n+<div class=\"lightbox\">\n+  <img src='generated/images/guide/testing/hero-detail.component.png' alt=\"HeroDetailComponent in action\">\n+</div>\n+\n+But there's plenty of template complexity even in this simple form.\n+\n+<code-example\n+  path=\"testing/src/app/hero/hero-detail.component.html\" header=\"app/hero/hero-detail.component.html\"></code-example>\n+\n+Tests that exercise the component need ...\n+\n+- to wait until a hero arrives before elements appear in the DOM.\n+- a reference to the title text.\n+- a reference to the name input box to inspect and set it.\n+- references to the two buttons so they can click them.\n+- spies for some of the component and router methods.\n+\n+Even a small form such as this one can produce a mess of tortured conditional setup and CSS element selection.\n+\n+Tame the complexity with a `Page` class that handles access to component properties\n+and encapsulates the logic that sets them.\n+\n+Here is such a `Page` class for the `hero-detail.component.spec.ts`\n+\n+<code-example\n+  path=\"testing/src/app/hero/hero-detail.component.spec.ts\"\n+  region=\"page\"\n+  header=\"app/hero/hero-detail.component.spec.ts (Page)\"></code-example>\n+\n+Now the important hooks for component manipulation and inspection are neatly organized and accessible from an instance of `Page`.\n+\n+A `createComponent` method creates a `page` object and fills in the blanks once the `hero` arrives.\n+\n+<code-example\n+  path=\"testing/src/app/hero/hero-detail.component.spec.ts\"\n+  region=\"create-component\"\n+  header=\"app/hero/hero-detail.component.spec.ts (createComponent)\"></code-example>\n+\n+The [_HeroDetailComponent_ tests](#tests-w-test-double) in an earlier section demonstrate how `createComponent` and `page`\n+keep the tests short and _on message_.\n+There are no distractions: no waiting for promises to resolve and no searching the DOM for element values to compare.\n+\n+Here are a few more `HeroDetailComponent` tests to reinforce the point.\n+\n+<code-example\n+  path=\"testing/src/app/hero/hero-detail.component.spec.ts\"\n+  region=\"selected-tests\"\n+  header=\"app/hero/hero-detail.component.spec.ts (selected tests)\"></code-example>\n+\n+<hr>\n+\n+{@a compile-components}\n+## Calling _compileComponents()_\n+\n+<div class=\"alert is-helpful\">\n+\n+You can ignore this section if you _only_ run tests with the CLI `ng test` command\n+because the CLI compiles the application before running the tests.\n+\n+</div>\n+\n+If you run tests in a **non-CLI environment**, the tests may fail with a message like this one:\n+\n+<code-example language=\"sh\" class=\"code-shell\" hideCopy>\n+Error: This test module uses the component BannerComponent\n+which is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\n+Please call \"TestBed.compileComponents\" before your test.\n+</code-example>\n+\n+The root of the problem is at least one of the components involved in the test\n+specifies an external template or CSS file as\n+the following version of the `BannerComponent` does.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-external.component.ts\"\n+  header=\"app/banner/banner-external.component.ts (external template & css)\"></code-example>\n+\n+The test fails when the `TestBed` tries to create the component.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner.component.spec.ts\"\n+  region=\"configure-and-create\"\n+  header=\"app/banner/banner.component.spec.ts (setup that fails)\"\n+  avoid></code-example>\n+\n+Recall that the app hasn't been compiled.\n+So when you call `createComponent()`, the `TestBed` compiles implicitly.\n+\n+That's not a problem when the source code is in memory.\n+But the `BannerComponent` requires external files\n+that the compiler must read from the file system,\n+an inherently _asynchronous_ operation.\n+\n+If the `TestBed` were allowed to continue, the tests would run and fail mysteriously\n+before the compiler could finished.\n+\n+The preemptive error message tells you to compile explicitly with `compileComponents()`.\n+\n+#### _compileComponents()_ is async\n+\n+You must call `compileComponents()` within an asynchronous test function.\n+\n+<div class=\"alert is-critical\">\n+\n+If you neglect to make the test function async\n+(e.g., forget to use `async()` as described below),\n+you'll see this error message\n+\n+<code-example language=\"sh\" class=\"code-shell\" hideCopy>\n+Error: ViewDestroyedError: Attempt to use a destroyed view\n+</code-example>\n+\n+</div>\n+\n+A typical approach is to divide the setup logic into two separate `beforeEach()` functions:\n+\n+1.  An async `beforeEach()` that compiles the components\n+1.  A synchronous `beforeEach()` that performs the remaining setup.\n+\n+To follow this pattern, import the `async()` helper with the other testing symbols.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-external.component.spec.ts\"\n+  region=\"import-async\">\n+</code-example>\n+\n+#### The async _beforeEach_\n+\n+Write the first async `beforeEach` like this.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-external.component.spec.ts\"\n+  region=\"async-before-each\"\n+  header=\"app/banner/banner-external.component.spec.ts (async beforeEach)\"></code-example>\n+\n+The `async()` helper function takes a parameterless function with the body of the setup.\n+\n+The `TestBed.configureTestingModule()` method returns the `TestBed` class so you can chain\n+calls to other `TestBed` static methods such as `compileComponents()`.\n+\n+In this example, the `BannerComponent` is the only component to compile.\n+Other examples configure the testing module with multiple components\n+and may import application modules that hold yet more components.\n+Any of them could be require external files.\n+\n+The `TestBed.compileComponents` method asynchronously compiles all components configured in the testing module.\n+\n+<div class=\"alert is-important\">\n+\n+Do not re-configure the `TestBed` after calling `compileComponents()`.\n+\n+</div>\n+\n+Calling `compileComponents()` closes the current `TestBed` instance to further configuration.\n+You cannot call any more `TestBed` configuration methods, not `configureTestingModule()`\n+nor any of the `override...` methods. The `TestBed` throws an error if you try.\n+\n+Make `compileComponents()` the last step\n+before calling `TestBed.createComponent()`.\n+\n+#### The synchronous _beforeEach_\n+\n+The second, synchronous `beforeEach()` contains the remaining setup steps,\n+which include creating the component and querying for elements to inspect.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-external.component.spec.ts\"\n+  region=\"sync-before-each\"\n+  header=\"app/banner/banner-external.component.spec.ts (synchronous beforeEach)\"></code-example>\n+\n+You can count on the test runner to wait for the first asynchronous `beforeEach` to finish before calling the second.\n+\n+#### Consolidated setup\n+\n+You can consolidate the two `beforeEach()` functions into a single, async `beforeEach()`.\n+\n+The `compileComponents()` method returns a promise so you can perform the\n+synchronous setup tasks _after_ compilation by moving the synchronous code\n+into a `then(...)` callback.\n+\n+<code-example\n+  path=\"testing/src/app/banner/banner-external.component.spec.ts\"\n+  region=\"one-before-each\"\n+  header=\"app/banner/banner-external.component.spec.ts (one beforeEach)\"></code-example>\n+\n+#### _compileComponents()_ is harmless\n+\n+There's no harm in calling `compileComponents()` when it's not required.\n+\n+The component test file generated by the CLI calls `compileComponents()`\n+even though it is never required when running `ng test`.\n+\n+The tests in this guide only call `compileComponents` when necessary.\n+\n+<hr>\n+\n+{@a import-module}\n+\n+## Setup with module imports\n+\n+Earlier component tests configured the testing module with a few `declarations` like this:\n+\n+<code-example\n+  path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\"\n+  region=\"config-testbed\"\n+  header=\"app/dashboard/dashboard-hero.component.spec.ts (configure TestBed)\">\n+</code-example>\n+\n+The `DashboardComponent` is simple. It needs no help.\n+But more complex components often depend on other components, directives, pipes, and providers\n+and these must be added to the testing module too.\n+\n+Fortunately, the `TestBed.configureTestingModule` parameter parallels\n+the metadata passed to the `@NgModule` decorator\n+which means you can also specify `providers` and `imports`.\n+\n+The `HeroDetailComponent` requires a lot of help despite its small size and simple construction.\n+In addition to the support it receives from the default testing module `CommonModule`, it needs:\n+\n+- `NgModel` and friends in the `FormsModule` to enable two-way data binding.\n+- The `TitleCasePipe` from the `shared` folder.\n+- Router services (which these tests are stubbing).\n+- Hero data access services (also stubbed).\n+\n+One approach is to configure the testing module from the individual pieces as in this example:\n+\n+<code-example\n+  path=\"testing/src/app/hero/hero-detail.component.spec.ts\"\n+  region=\"setup-forms-module\"\n+  header=\"app/hero/hero-detail.component.spec.ts (FormsModule setup)\"></code-example>\n+\n+<div class=\"alert is-helpful\">\n+\n+Notice that the `beforeEach()` is asynchronous and calls `TestBed.compileComponents`\n+because the `HeroDetailComponent` has an external template and css file.\n+\n+As explained in [_Calling compileComponents()_](#compile-components) above,\n+these tests could be run in a non-CLI environment\n+where Angular would have to compile them in the browser.\n+\n+</div>\n+\n+#### Import a shared module\n+\n+Because many app components need the `FormsModule` and the `TitleCasePipe`, the developer created\n+a `SharedModule` to combine these and other frequently requested parts.\n+\n+The test configuration can use the `SharedModule` too as seen in this alternative setup:\n+\n+<code-example\n+  path=\"testing/src/app/hero/hero-detail.component.spec.ts\"\n+  region=\"setup-shared-module\"\n+  header=\"app/hero/hero-detail.component.spec.ts (SharedModule setup)\"></code-example>\n+\n+It's a bit tighter and smaller, with fewer import statements (not shown).\n+\n+{@a feature-module-import}\n+\n+#### Import a feature module\n+\n+The `HeroDetailComponent` is part of the `HeroModule` [Feature Module](guide/feature-modules) that aggregates more of the interdependent pieces\n+including the `SharedModule`.\n+Try a test configuration that imports the `HeroModule` like this one:\n+\n+<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-hero-module\" header=\"app/hero/hero-detail.component.spec.ts (HeroModule setup)\"></code-example>\n+\n+That's _really_ crisp. Only the _test doubles_ in the `providers` remain. Even the `HeroDetailComponent` declaration is gone.\n+\n+In fact, if you try to declare it, Angular will throw an error because\n+`HeroDetailComponent` is declared in both the `HeroModule` and the `DynamicTestModule`\n+created by the `TestBed`.\n+\n+<div class=\"alert is-helpful\">\n+\n+Importing the component's feature module can be the easiest way to configure tests\n+when there are many mutual dependencies within the module and\n+the module is small, as feature modules tend to be.\n+\n+</div>\n+\n+<hr>\n+\n+{@a component-override}\n+\n+## Override component providers\n+\n+The `HeroDetailComponent` provides its own `HeroDetailService`.\n+\n+<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"prototype\" header=\"app/hero/hero-detail.component.ts (prototype)\"></code-example>\n+\n+It's not possible to stub the component's `HeroDetailService` in the `providers` of the `TestBed.configureTestingModule`.\n+Those are providers for the _testing module_, not the component. They prepare the dependency injector at the _fixture level_.\n+\n+Angular creates the component with its _own_ injector, which is a _child_ of the fixture injector.\n+It registers the component's providers (the `HeroDetailService` in this case) with the child injector.\n+\n+A test cannot get to child injector services from the fixture injector.\n+And `TestBed.configureTestingModule` can't configure them either.\n+\n+Angular has been creating new instances of the real `HeroDetailService` all along!\n+\n+<div class=\"alert is-helpful\">\n+\n+These tests could fail or timeout if the `HeroDetailService` made its own XHR calls to a remote server.\n+There might not be a remote server to call.\n+\n+Fortunately, the `HeroDetailService` delegates responsibility for remote data access to an injected `HeroService`.\n+\n+<code-example path=\"testing/src/app/hero/hero-detail.service.ts\" region=\"prototype\" header=\"app/hero/hero-detail.service.ts (prototype)\"></code-example>\n+\n+The [previous test configuration](#feature-module-import) replaces the real `HeroService` with a `TestHeroService`\n+that intercepts server requests and fakes their responses.\n+\n+</div>\n+\n+What if you aren't so lucky. What if faking the `HeroService` is hard?\n+What if `HeroDetailService` makes its own server requests?\n+\n+The `TestBed.overrideComponent` method can replace the component's `providers` with easy-to-manage _test doubles_\n+as seen in the following setup variation:\n+\n+<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-override\" header=\"app/hero/hero-detail.component.spec.ts (Override setup)\"></code-example>\n+\n+Notice that `TestBed.configureTestingModule` no longer provides a (fake) `HeroService` because it's [not needed](#spy-stub).\n+\n+{@a override-component-method}\n+\n+#### The _overrideComponent_ method\n+\n+Focus on the `overrideComponent` method.\n+\n+<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-component-method\" header=\"app/hero/hero-detail.component.spec.ts (overrideComponent)\"></code-example>\n+\n+It takes two arguments: the component type to override (`HeroDetailComponent`) and an override metadata object.\n+The [override metadata object](guide/testing-utility-apis#metadata-override-object) is a generic defined as follows:\n+\n+<code-example language=\"javascript\">\n+  type MetadataOverride&lt;T&gt; = {\n+    add?: Partial&lt;T&gt;;\n+    remove?: Partial&lt;T&gt;;\n+    set?: Partial&lt;T&gt;;\n+  };\n+</code-example>\n+\n+A metadata override object can either add-and-remove elements in metadata properties or completely reset those properties.\n+This example resets the component's `providers` metadata.\n+\n+The type parameter, `T`, is the kind of metadata you'd pass to the `@Component` decorator:\n+\n+<code-example language=\"javascript\">\n+  selector?: string;\n+  template?: string;\n+  templateUrl?: string;\n+  providers?: any[];\n+  ...\n+</code-example>\n+\n+{@a spy-stub}\n+\n+#### Provide a _spy stub_ (_HeroDetailServiceSpy_)\n+\n+This example completely replaces the component's `providers` array with a new array containing a `HeroDetailServiceSpy`.\n+\n+The `HeroDetailServiceSpy` is a stubbed version of the real `HeroDetailService`\n+that fakes all necessary features of that service.\n+It neither injects nor delegates to the lower level `HeroService`\n+so there's no need to provide a test double for that.\n+\n+The related `HeroDetailComponent` tests will assert that methods of the `HeroDetailService`\n+were called by spying on the service methods.\n+Accordingly, the stub implements its methods as spies:\n+\n+<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"hds-spy\" header=\"app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy)\"></code-example>\n+\n+{@a override-tests}\n+\n+#### The override tests\n+\n+Now the tests can control the component's hero directly by manipulating the spy-stub's `testHero`\n+and confirm that service methods were called.\n+\n+<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-tests\" header=\"app/hero/hero-detail.component.spec.ts (override tests)\"></code-example>\n+\n+{@a more-overrides}\n+\n+#### More overrides\n+\n+The `TestBed.overrideComponent` method can be called multiple times for the same or different components.\n+The `TestBed` offers similar `overrideDirective`, `overrideModule`, and `overridePipe` methods\n+for digging into and replacing parts of these other classes.\n+\n+Explore the options and combinations on your own.\n+\n+<hr>"
        },
        {
            "sha": "90ca07988a68f9a8b17667937e198a47519546fd",
            "filename": "aio/content/guide/testing-pipes.md",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/angular/angular/blob/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-pipes.md",
            "raw_url": "https://github.com/angular/angular/raw/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-pipes.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Ftesting-pipes.md?ref=bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0",
            "patch": "@@ -0,0 +1,41 @@\n+# Testing Pipes\n+\n+You can test [pipes](guide/pipes) without the Angular testing utilities.\n+\n+<div class=\"alert is-helpful\">\n+\n+  For the sample app that the testing guides describe, see the <live-example embedded-style noDownload>sample app</live-example>.\n+\n+  For the tests features in the testing guides, see <live-example stackblitz=\"specs\" noDownload>tests</live-example>.\n+\n+</div>\n+\n+## Testing the `TitleCasePipe`\n+\n+A pipe class has one method, `transform`, that manipulates the input\n+value into a transformed output value.\n+The `transform` implementation rarely interacts with the DOM.\n+Most pipes have no dependence on Angular other than the `@Pipe`\n+metadata and an interface.\n+\n+Consider a `TitleCasePipe` that capitalizes the first letter of each word.\n+Here's an implementation with a regular expression.\n+\n+<code-example path=\"testing/src/app/shared/title-case.pipe.ts\" header=\"app/shared/title-case.pipe.ts\"></code-example>\n+\n+Anything that uses a regular expression is worth testing thoroughly.\n+Use simple Jasmine to explore the expected cases and the edge cases.\n+\n+<code-example path=\"testing/src/app/shared/title-case.pipe.spec.ts\" region=\"excerpt\" header=\"app/shared/title-case.pipe.spec.ts\"></code-example>\n+\n+{@a write-tests}\n+\n+## Writing DOM tests to support a pipe test\n+\n+These are tests of the pipe _in isolation_.\n+They can't tell if the `TitleCasePipe` is working properly as applied in the application components.\n+\n+Consider adding component tests such as this one:\n+\n+<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"title-case-pipe\" header=\"app/hero/hero-detail.component.spec.ts (pipe test)\"></code-example>\n+"
        },
        {
            "sha": "797cd8e7e3520987da73d6d61af92b92c3e39cd6",
            "filename": "aio/content/guide/testing-services.md",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/angular/angular/blob/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-services.md",
            "raw_url": "https://github.com/angular/angular/raw/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-services.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Ftesting-services.md?ref=bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0",
            "patch": "@@ -0,0 +1,199 @@\n+# Testing services\n+\n+\n+To check that your services are working as you intend, you can write tests specifically for them.\n+\n+<div class=\"alert is-helpful\">\n+\n+  For the sample app that the testing guides describe, see the <live-example embedded-style noDownload>sample app</live-example>.\n+\n+  For the tests features in the testing guides, see <live-example stackblitz=\"specs\" noDownload>tests</live-example>.\n+\n+</div>\n+\n+\n+Services are often the easiest files to unit test.\n+Here are some synchronous and asynchronous unit tests of the `ValueService`\n+written without assistance from Angular testing utilities.\n+\n+<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"ValueService\" header=\"app/demo/demo.spec.ts\"></code-example>\n+\n+{@a services-with-dependencies}\n+\n+## Services with dependencies\n+\n+Services often depend on other services that Angular injects into the constructor.\n+In many cases, it's easy to create and _inject_ these dependencies by hand while\n+calling the service's constructor.\n+\n+The `MasterService` is a simple example:\n+\n+<code-example path=\"testing/src/app/demo/demo.ts\" region=\"MasterService\" header=\"app/demo/demo.ts\"></code-example>\n+\n+`MasterService` delegates its only method, `getValue`, to the injected `ValueService`.\n+\n+Here are several ways to test it.\n+\n+<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"MasterService\" header=\"app/demo/demo.spec.ts\"></code-example>\n+\n+The first test creates a `ValueService` with `new` and passes it to the `MasterService` constructor.\n+\n+However, injecting the real service rarely works well as most dependent services are difficult to create and control.\n+\n+Instead you can mock the dependency, use a dummy value, or create a\n+[spy](https://jasmine.github.io/2.0/introduction.html#section-Spies)\n+on the pertinent service method.\n+\n+<div class=\"alert is-helpful\">\n+\n+Prefer spies as they are usually the easiest way to mock services.\n+\n+</div>\n+\n+These standard testing techniques are great for unit testing services in isolation.\n+\n+However, you almost always inject services into application classes using Angular\n+dependency injection and you should have tests that reflect that usage pattern.\n+Angular testing utilities make it easy to investigate how injected services behave.\n+\n+## Testing services with the _TestBed_\n+\n+Your app relies on Angular [dependency injection (DI)](guide/dependency-injection)\n+to create services.\n+When a service has a dependent service, DI finds or creates that dependent service.\n+And if that dependent service has its own dependencies, DI finds-or-creates them as well.\n+\n+As service _consumer_, you don't worry about any of this.\n+You don't worry about the order of constructor arguments or how they're created.\n+\n+As a service _tester_, you must at least think about the first level of service dependencies\n+but you _can_ let Angular DI do the service creation and deal with constructor argument order\n+when you use the `TestBed` testing utility to provide and create services.\n+\n+{@a testbed}\n+\n+## Angular _TestBed_\n+\n+The `TestBed` is the most important of the Angular testing utilities.\n+The `TestBed` creates a dynamically-constructed Angular _test_ module that emulates\n+an Angular [@NgModule](guide/ngmodules).\n+\n+The `TestBed.configureTestingModule()` method takes a metadata object that can have most of the properties of an [@NgModule](guide/ngmodules).\n+\n+To test a service, you set the `providers` metadata property with an\n+array of the services that you'll test or mock.\n+\n+<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-before-each\" header=\"app/demo/demo.testbed.spec.ts (provide ValueService in beforeEach)\"></code-example>\n+\n+Then inject it inside a test by calling `TestBed.inject()` with the service class as the argument.\n+\n+<div class=\"alert is-helpful\">\n+\n+**Note:** `TestBed.get()` was deprecated as of Angular version 9.\n+To help minimize breaking changes, Angular introduces a new function called `TestBed.inject()`, which you should use instead.\n+For information on the removal of `TestBed.get()`,\n+see its entry in the [Deprecations index](guide/deprecations#index).\n+\n+</div>\n+\n+<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-it\"></code-example>\n+\n+Or inside the `beforeEach()` if you prefer to inject the service as part of your setup.\n+\n+<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-before-each\"> </code-example>\n+\n+When testing a service with a dependency, provide the mock in the `providers` array.\n+\n+In the following example, the mock is a spy object.\n+\n+<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-before-each\"></code-example>\n+\n+The test consumes that spy in the same way it did earlier.\n+\n+<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-it\">\n+</code-example>\n+\n+{@a no-before-each}\n+\n+## Testing without _beforeEach()_\n+\n+Most test suites in this guide call `beforeEach()` to set the preconditions for each `it()` test\n+and rely on the `TestBed` to create classes and inject services.\n+\n+There's another school of testing that never calls `beforeEach()` and prefers to create classes explicitly rather than use the `TestBed`.\n+\n+Here's how you might rewrite one of the `MasterService` tests in that style.\n+\n+Begin by putting re-usable, preparatory code in a _setup_ function instead of `beforeEach()`.\n+\n+<code-example\n+  path=\"testing/src/app/demo/demo.spec.ts\"\n+  region=\"no-before-each-setup\"\n+  header=\"app/demo/demo.spec.ts (setup)\"></code-example>\n+\n+The `setup()` function returns an object literal\n+with the variables, such as `masterService`, that a test might reference.\n+You don't define _semi-global_ variables (e.g., `let masterService: MasterService`)\n+in the body of the `describe()`.\n+\n+Then each test invokes `setup()` in its first line, before continuing\n+with steps that manipulate the test subject and assert expectations.\n+\n+<code-example\n+  path=\"testing/src/app/demo/demo.spec.ts\"\n+  region=\"no-before-each-test\"></code-example>\n+\n+Notice how the test uses\n+[_destructuring assignment_](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\n+to extract the setup variables that it needs.\n+\n+<code-example\n+  path=\"testing/src/app/demo/demo.spec.ts\"\n+  region=\"no-before-each-setup-call\">\n+</code-example>\n+\n+Many developers feel this approach is cleaner and more explicit than the\n+traditional `beforeEach()` style.\n+\n+Although this testing guide follows the traditional style and\n+the default [CLI schematics](https://github.com/angular/angular-cli)\n+generate test files with `beforeEach()` and `TestBed`,\n+feel free to adopt _this alternative approach_ in your own projects.\n+\n+## Testing HTTP services\n+\n+Data services that make HTTP calls to remote servers typically inject and delegate\n+to the Angular [`HttpClient`](guide/http) service for XHR calls.\n+\n+You can test a data service with an injected `HttpClient` spy as you would\n+test any service with a dependency.\n+<code-example\n+  path=\"testing/src/app/model/hero.service.spec.ts\"\n+  region=\"test-with-spies\"\n+  header=\"app/model/hero.service.spec.ts (tests with spies)\">\n+</code-example>\n+\n+<div class=\"alert is-important\">\n+\n+The `HeroService` methods return `Observables`. You must\n+_subscribe_ to an observable to (a) cause it to execute and (b)\n+assert that the method succeeds or fails.\n+\n+The `subscribe()` method takes a success (`next`) and fail (`error`) callback.\n+Make sure you provide _both_ callbacks so that you capture errors.\n+Neglecting to do so produces an asynchronous uncaught observable error that\n+the test runner will likely attribute to a completely different test.\n+\n+</div>\n+\n+## _HttpClientTestingModule_\n+\n+Extended interactions between a data service and the `HttpClient` can be complex\n+and difficult to mock with spies.\n+\n+The `HttpClientTestingModule` can make these testing scenarios more manageable.\n+\n+While the _code sample_ accompanying this guide demonstrates `HttpClientTestingModule`,\n+this page defers to the [Http guide](guide/http#testing-http-requests),\n+which covers testing with the `HttpClientTestingModule` in detail.\n+"
        },
        {
            "sha": "8152d75acffa21e95cfc103e00dfa000c24a85ba",
            "filename": "aio/content/guide/testing-utility-apis.md",
            "status": "added",
            "additions": 794,
            "deletions": 0,
            "changes": 794,
            "blob_url": "https://github.com/angular/angular/blob/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-utility-apis.md",
            "raw_url": "https://github.com/angular/angular/raw/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting-utility-apis.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Ftesting-utility-apis.md?ref=bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0",
            "patch": "@@ -0,0 +1,794 @@\n+# Testing Utility APIs\n+\n+This page describes the most useful Angular testing features.\n+\n+The Angular testing utilities include the `TestBed`, the `ComponentFixture`, and a handful of functions that control the test environment.\n+The [_TestBed_](#testbed-api-summary) and [_ComponentFixture_](#component-fixture-api-summary) classes are covered separately.\n+\n+Here's a summary of the stand-alone functions, in order of likely utility:\n+\n+<table>\n+  <tr>\n+    <th>\n+      Function\n+    </th>\n+    <th>\n+      Description\n+    </th>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>async</code>\n+    </td>\n+\n+    <td>\n+\n+      Runs the body of a test (`it`) or setup (`beforeEach`) function within a special _async test zone_.\n+      See [discussion above](guide/testing-components-scenarios#async).\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>fakeAsync</code>\n+    </td>\n+\n+    <td>\n+\n+      Runs the body of a test (`it`) within a special _fakeAsync test zone_, enabling\n+      a linear control flow coding style. See [discussion above](guide/testing-components-scenarios#fake-async).\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>tick</code>\n+    </td>\n+\n+    <td>\n+\n+      Simulates the passage of time and the completion of pending asynchronous activities\n+      by flushing both _timer_ and _micro-task_ queues within the _fakeAsync test zone_.\n+\n+      <div class=\"alert is-helpful\">\n+\n+      The curious, dedicated reader might enjoy this lengthy blog post,\n+      [\"_Tasks, microtasks, queues and schedules_\"](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/).\n+\n+      </div>\n+\n+      Accepts an optional argument that moves the virtual clock forward\n+      by the specified number of milliseconds,\n+      clearing asynchronous activities scheduled within that timeframe.\n+      See [discussion above](guide/testing-components-scenarios#tick).\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+       <code>inject</code>\n+    </td>\n+\n+    <td>\n+\n+      Injects one or more services from the current `TestBed` injector into a test function.\n+      It cannot inject a service provided by the component itself.\n+      See discussion of the [debugElement.injector](guide/testing-components-scenarios#get-injected-services).\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>discardPeriodicTasks</code>\n+    </td>\n+\n+    <td>\n+\n+      When a `fakeAsync()` test ends with pending timer event _tasks_ (queued `setTimeOut` and `setInterval` callbacks),\n+      the test fails with a clear error message.\n+\n+      In general, a test should end with no queued tasks.\n+      When pending timer tasks are expected, call `discardPeriodicTasks` to flush the _task_ queue\n+      and avoid the error.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>flushMicrotasks</code>\n+    </td>\n+\n+    <td>\n+\n+      When a `fakeAsync()` test ends with pending _micro-tasks_ such as unresolved promises,\n+      the test fails with a clear error message.\n+\n+      In general, a test should wait for micro-tasks to finish.\n+      When pending microtasks are expected, call `flushMicrotasks` to flush the  _micro-task_ queue\n+      and avoid the error.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>ComponentFixtureAutoDetect</code>\n+    </td>\n+\n+    <td>\n+\n+      A provider token for a service that turns on [automatic change detection](guide/testing-components-scenarios#automatic-change-detection).\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>getTestBed</code>\n+    </td>\n+\n+    <td>\n+\n+      Gets the current instance of the `TestBed`.\n+      Usually unnecessary because the static class methods of the `TestBed` class are typically sufficient.\n+      The `TestBed` instance exposes a few rarely used members that are not available as\n+      static methods.\n+\n+    </td>\n+  </tr>\n+</table>\n+\n+<hr>\n+\n+{@a testbed-class-summary}\n+\n+## _TestBed_ class summary\n+\n+The `TestBed` class is one of the principal Angular testing utilities.\n+Its API is quite large and can be overwhelming until you've explored it,\n+a little at a time. Read the early part of this guide first\n+to get the basics before trying to absorb the full API.\n+\n+The module definition passed to `configureTestingModule`\n+is a subset of the `@NgModule` metadata properties.\n+\n+<code-example language=\"javascript\">\n+  type TestModuleMetadata = {\n+    providers?: any[];\n+    declarations?: any[];\n+    imports?: any[];\n+    schemas?: Array&lt;SchemaMetadata | any[]&gt;;\n+  };\n+</code-example>\n+\n+{@a metadata-override-object}\n+\n+Each override method takes a `MetadataOverride<T>` where `T` is the kind of metadata\n+appropriate to the method, that is, the parameter of an `@NgModule`,\n+`@Component`, `@Directive`, or `@Pipe`.\n+\n+<code-example language=\"javascript\">\n+  type MetadataOverride&lt;T&gt; = {\n+    add?: Partial&lt;T&gt;;\n+    remove?: Partial&lt;T&gt;;\n+    set?: Partial&lt;T&gt;;\n+  };\n+</code-example>\n+\n+{@a testbed-methods}\n+{@a testbed-api-summary}\n+\n+The `TestBed` API consists of static class methods that either update or reference a _global_ instance of the `TestBed`.\n+\n+Internally, all static methods cover methods of the current runtime `TestBed` instance,\n+which is also returned by the `getTestBed()` function.\n+\n+Call `TestBed` methods _within_ a `beforeEach()` to ensure a fresh start before each individual test.\n+\n+Here are the most important static methods, in order of likely utility.\n+\n+<table>\n+  <tr>\n+    <th>\n+      Methods\n+    </th>\n+    <th>\n+      Description\n+    </th>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>configureTestingModule</code>\n+    </td>\n+\n+    <td>\n+\n+      The testing shims (`karma-test-shim`, `browser-test-shim`)\n+      establish the [initial test environment](guide/testing) and a default testing module.\n+      The default testing module is configured with basic declaratives and some Angular service substitutes that every tester needs.\n+\n+      Call `configureTestingModule` to refine the testing module configuration for a particular set of tests\n+      by adding and removing imports, declarations (of components, directives, and pipes), and providers.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>compileComponents</code>\n+    </td>\n+\n+    <td>\n+\n+      Compile the testing module asynchronously after you've finished configuring it.\n+      You **must** call this method if _any_ of the testing module components have a `templateUrl`\n+      or `styleUrls` because fetching component template and style files is necessarily asynchronous.\n+      See [above](guide/testing-components-scenarios#compile-components).\n+\n+      After calling `compileComponents`, the `TestBed` configuration is frozen for the duration of the current spec.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>createComponent<T></code>\n+    </td>\n+\n+    <td>\n+\n+      Create an instance of a component of type `T` based on the current `TestBed` configuration.\n+      After calling `compileComponent`, the `TestBed` configuration is frozen for the duration of the current spec.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>overrideModule</code>\n+    </td>\n+    <td>\n+\n+      Replace metadata for the given `NgModule`. Recall that modules can import other modules.\n+      The `overrideModule` method can reach deeply into the current testing module to\n+      modify one of these inner modules.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>overrideComponent</code>\n+    </td>\n+\n+    <td>\n+\n+      Replace metadata for the given component class, which could be nested deeply\n+      within an inner module.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>overrideDirective</code>\n+    </td>\n+\n+    <td>\n+\n+      Replace metadata for the given directive class, which could be nested deeply\n+      within an inner module.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>overridePipe</code>\n+    </td>\n+    <td>\n+\n+      Replace metadata for the given pipe class, which could be nested deeply\n+      within an inner module.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      {@a testbed-inject}\n+      <code>inject</code>\n+    </td>\n+\n+    <td>\n+\n+      Retrieve a service from the current `TestBed` injector.\n+\n+      The `inject` function is often adequate for this purpose.\n+      But `inject` throws an error if it can't provide the service.\n+\n+      What if the service is optional?\n+\n+      The `TestBed.inject()` method takes an optional second parameter,\n+      the object to return if Angular can't find the provider\n+      (`null` in this example):\n+\n+      <code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"testbed-get-w-null\" header=\"app/demo/demo.testbed.spec.ts\"></code-example>\n+\n+      After calling `TestBed.inject`, the `TestBed` configuration is frozen for the duration of the current spec.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      {@a testbed-initTestEnvironment}\n+      <code>initTestEnvironment</code>\n+    </td>\n+    <td>\n+\n+      Initialize the testing environment for the entire test run.\n+\n+      The testing shims (`karma-test-shim`, `browser-test-shim`) call it for you\n+      so there is rarely a reason for you to call it yourself.\n+\n+      You may call this method _exactly once_. If you must change\n+      this default in the middle of your test run, call `resetTestEnvironment` first.\n+\n+      Specify the Angular compiler factory, a `PlatformRef`, and a default Angular testing module.\n+      Alternatives for non-browser platforms are available in the general form\n+      `@angular/platform-<platform_name>/testing/<platform_name>`.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>resetTestEnvironment</code>\n+    </td>\n+    <td>\n+\n+      Reset the initial test environment, including the default testing module.\n+\n+    </td>\n+  </tr>\n+</table>\n+\n+A few of the `TestBed` instance methods are not covered by static `TestBed` _class_ methods.\n+These are rarely needed.\n+\n+{@a component-fixture-api-summary}\n+\n+## The _ComponentFixture_\n+\n+The `TestBed.createComponent<T>`\n+creates an instance of the component `T`\n+and returns a strongly typed `ComponentFixture` for that component.\n+\n+The `ComponentFixture` properties and methods provide access to the component,\n+its DOM representation, and aspects of its Angular environment.\n+\n+{@a component-fixture-properties}\n+\n+### _ComponentFixture_ properties\n+\n+Here are the most important properties for testers, in order of likely utility.\n+\n+<table>\n+  <tr>\n+    <th>\n+      Properties\n+    </th>\n+    <th>\n+      Description\n+    </th>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>componentInstance</code>\n+    </td>\n+\n+    <td>\n+\n+      The instance of the component class created by `TestBed.createComponent`.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>debugElement</code>\n+    </td>\n+\n+    <td>\n+\n+      The `DebugElement` associated with the root element of the component.\n+\n+      The `debugElement` provides insight into the component and its DOM element during test and debugging.\n+      It's a critical property for testers. The most interesting members are covered [below](#debug-element-details).\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>nativeElement</code>\n+    </td>\n+\n+    <td>\n+\n+      The native DOM element at the root of the component.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>changeDetectorRef</code>\n+    </td>\n+\n+    <td>\n+\n+      The `ChangeDetectorRef` for the component.\n+\n+      The `ChangeDetectorRef` is most valuable when testing a\n+      component that has the `ChangeDetectionStrategy.OnPush` method\n+      or the component's change detection is under your programmatic control.\n+\n+    </td>\n+  </tr>\n+</table>\n+\n+{@a component-fixture-methods}\n+\n+### _ComponentFixture_ methods\n+\n+The _fixture_ methods cause Angular to perform certain tasks on the component tree.\n+Call these method to trigger Angular behavior in response to simulated user action.\n+\n+Here are the most useful methods for testers.\n+\n+<table>\n+  <tr>\n+    <th>\n+      Methods\n+    </th>\n+    <th>\n+      Description\n+    </th>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>detectChanges</code>\n+    </td>\n+\n+    <td>\n+\n+      Trigger a change detection cycle for the component.\n+\n+      Call it to initialize the component (it calls `ngOnInit`) and after your\n+      test code, change the component's data bound property values.\n+      Angular can't see that you've changed `personComponent.name` and won't update the `name`\n+      binding until you call `detectChanges`.\n+\n+      Runs `checkNoChanges` afterwards to confirm that there are no circular updates unless\n+      called as `detectChanges(false)`;\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>autoDetectChanges</code>\n+    </td>\n+\n+    <td>\n+\n+      Set this to `true` when you want the fixture to detect changes automatically.\n+\n+      When autodetect is `true`, the test fixture calls `detectChanges` immediately\n+      after creating the component. Then it listens for pertinent zone events\n+      and calls `detectChanges` accordingly.\n+      When your test code modifies component property values directly,\n+      you probably still have to call `fixture.detectChanges` to trigger data binding updates.\n+\n+      The default is `false`. Testers who prefer fine control over test behavior\n+      tend to keep it `false`.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>checkNoChanges</code>\n+    </td>\n+\n+    <td>\n+\n+      Do a change detection run to make sure there are no pending changes.\n+      Throws an exceptions if there are.\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>isStable</code>\n+    </td>\n+\n+    <td>\n+\n+      If the fixture is currently _stable_, returns `true`.\n+      If there are async tasks that have not completed, returns `false`.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>whenStable</code>\n+    </td>\n+\n+    <td>\n+\n+      Returns a promise that resolves when the fixture is stable.\n+\n+      To resume testing after completion of asynchronous activity or\n+      asynchronous change detection, hook that promise.\n+      See [above](guide/testing-components-scenarios#when-stable).\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>destroy</code>\n+    </td>\n+\n+    <td>\n+\n+      Trigger component destruction.\n+\n+    </td>\n+  </tr>\n+</table>\n+\n+{@a debug-element-details}\n+\n+#### _DebugElement_\n+\n+The `DebugElement` provides crucial insights into the component's DOM representation.\n+\n+From the test root component's `DebugElement` returned by `fixture.debugElement`,\n+you can walk (and query) the fixture's entire element and component subtrees.\n+\n+Here are the most useful `DebugElement` members for testers, in approximate order of utility:\n+\n+<table>\n+  <tr>\n+    <th>\n+      Member\n+    </th>\n+    <th>\n+      Description\n+    </th>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>nativeElement</code>\n+    </td>\n+\n+    <td>\n+\n+      The corresponding DOM element in the browser (null for WebWorkers).\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>query</code>\n+    </td>\n+\n+    <td>\n+\n+      Calling `query(predicate: Predicate<DebugElement>)` returns the first `DebugElement`\n+      that matches the [predicate](#query-predicate) at any depth in the subtree.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>queryAll</code>\n+    </td>\n+\n+    <td>\n+\n+      Calling `queryAll(predicate: Predicate<DebugElement>)` returns all `DebugElements`\n+      that matches the [predicate](#query-predicate) at any depth in subtree.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>injector</code>\n+    </td>\n+\n+    <td>\n+\n+      The host dependency injector.\n+      For example, the root element's component instance injector.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>componentInstance</code>\n+    </td>\n+\n+    <td>\n+\n+      The element's own component instance, if it has one.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>context</code>\n+    </td>\n+\n+    <td>\n+\n+      An object that provides parent context for this element.\n+      Often an ancestor component instance that governs this element.\n+\n+      When an element is repeated within `*ngFor`, the context is an `NgForRow` whose `$implicit`\n+      property is the value of the row instance value.\n+      For example, the `hero` in `*ngFor=\"let hero of heroes\"`.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>children</code>\n+    </td>\n+\n+    <td>\n+\n+      The immediate `DebugElement` children. Walk the tree by descending through `children`.\n+\n+      <div class=\"alert is-helpful\">\n+\n+      `DebugElement` also has `childNodes`, a list of `DebugNode` objects.\n+      `DebugElement` derives from `DebugNode` objects and there are often\n+      more nodes than elements. Testers can usually ignore plain nodes.\n+\n+      </div>\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>parent</code>\n+    </td>\n+    <td>\n+\n+      The `DebugElement` parent. Null if this is the root element.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>name</code>\n+    </td>\n+\n+    <td>\n+\n+      The element tag name, if it is an element.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>triggerEventHandler</code>\n+    </td>\n+    <td>\n+\n+      Triggers the event by its name if there is a corresponding listener\n+      in the element's `listeners` collection.\n+      The second parameter is the _event object_ expected by the handler.\n+      See [above](guide/testing-components-scenarios#trigger-event-handler).\n+\n+      If the event lacks a listener or there's some other problem,\n+      consider calling `nativeElement.dispatchEvent(eventObject)`.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>listeners</code>\n+    </td>\n+\n+    <td>\n+\n+      The callbacks attached to the component's `@Output` properties and/or the element's event properties.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>providerTokens</code>\n+    </td>\n+\n+    <td>\n+\n+      This component's injector lookup tokens.\n+      Includes the component itself plus the tokens that the component lists in its `providers` metadata.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>source</code>\n+    </td>\n+\n+    <td>\n+\n+      Where to find this element in the source component template.\n+\n+    </td>\n+  </tr>\n+\n+  <tr>\n+    <td style=\"vertical-align: top\">\n+      <code>references</code>\n+    </td>\n+\n+    <td>\n+\n+      Dictionary of objects associated with template local variables (e.g. `#foo`),\n+      keyed by the local variable name.\n+\n+    </td>\n+  </tr>\n+</table>\n+\n+{@a query-predicate}\n+\n+The `DebugElement.query(predicate)` and `DebugElement.queryAll(predicate)` methods take a\n+predicate that filters the source element's subtree for matching `DebugElement`.\n+\n+The predicate is any method that takes a `DebugElement` and returns a _truthy_ value.\n+The following example finds all `DebugElements` with a reference to a template local variable named \"content\":\n+\n+<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"custom-predicate\" header=\"app/demo/demo.testbed.spec.ts\"></code-example>\n+\n+The Angular `By` class has three static methods for common predicates:\n+\n+- `By.all` - return all elements.\n+- `By.css(selector)` - return elements with matching CSS selectors.\n+- `By.directive(directive)` - return elements that Angular matched to an instance of the directive class.\n+\n+<code-example path=\"testing/src/app/hero/hero-list.component.spec.ts\" region=\"by\" header=\"app/hero/hero-list.component.spec.ts\"></code-example>\n+\n+<hr>\n+"
        },
        {
            "sha": "557571acba7e65d894be9653e856b9f4db6e73e0",
            "filename": "aio/content/guide/testing.md",
            "status": "modified",
            "additions": 67,
            "deletions": 3416,
            "changes": 3483,
            "blob_url": "https://github.com/angular/angular/blob/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting.md",
            "raw_url": "https://github.com/angular/angular/raw/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Ftesting.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Ftesting.md?ref=bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0"
        },
        {
            "sha": "284076e42f264b497d7c733c26b39dd24a66123a",
            "filename": "aio/content/guide/upgrade-setup.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Fupgrade-setup.md",
            "raw_url": "https://github.com/angular/angular/raw/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fguide%2Fupgrade-setup.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fupgrade-setup.md?ref=bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0",
            "patch": "@@ -308,7 +308,7 @@ So when IE is refreshed (manually or automatically by `ng serve`), sometimes the\n \n ## Appendix: Test using `fakeAsync()/async()`\n \n-If you use the `fakeAsync()/async()` helper function to run unit tests (for details, read the [Testing guide](guide/testing#async-test-with-fakeasync)), you need to import `zone.js/dist/zone-testing` in your test setup file.\n+If you use the `fakeAsync()/async()` helper function to run unit tests (for details, read the [Testing guide](guide/testing-components-scenarios#fake-async)), you need to import `zone.js/dist/zone-testing` in your test setup file.\n \n <div class=\"alert is-important\">\n If you create project with `Angular/CLI`, it is already imported in `src/test.ts`."
        },
        {
            "sha": "7e883dc73a7dbb89fe7038a80eee2b17f03cecac",
            "filename": "aio/content/navigation.json",
            "status": "modified",
            "additions": 58,
            "deletions": 12,
            "changes": 70,
            "blob_url": "https://github.com/angular/angular/blob/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fnavigation.json",
            "raw_url": "https://github.com/angular/angular/raw/bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0/aio%2Fcontent%2Fnavigation.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fnavigation.json?ref=bdbbff6a1ad1095cd1da8e42e5ac516b140a2bf0",
            "patch": "@@ -526,28 +526,74 @@\n               \"url\": \"guide/angular-compiler-options\",\n               \"title\": \"Angular Compiler Options\",\n               \"tooltip\": \"Configuring AOT compilation.\"\n-           },\n-           {\n+            },\n+            {\n               \"url\": \"guide/aot-metadata-errors\",\n               \"title\": \"AOT Metadata Errors\",\n               \"tooltip\": \"Troubleshooting AOT compilation.\"\n-           },\n-           {\n-            \"url\": \"guide/template-typecheck\",\n-            \"title\": \"Template Type-checking\",\n-            \"tooltip\": \"Template type-checking in Angular.\"\n-         }\n-        ]\n-      },\n+            },\n+            {\n+              \"url\": \"guide/template-typecheck\",\n+              \"title\": \"Template Type-checking\",\n+              \"tooltip\": \"Template type-checking in Angular.\"\n+            }\n+          ]\n+        },\n         {\n           \"url\": \"guide/build\",\n           \"title\": \"Building & Serving\",\n           \"tooltip\": \"Building and serving Angular apps.\"\n         },\n         {\n-          \"url\": \"guide/testing\",\n           \"title\": \"Testing\",\n-          \"tooltip\": \"Techniques and practices for testing an Angular app.\"\n+          \"tooltip\": \"Testing your Angular apps.\",\n+          \"children\": [\n+            {\n+              \"url\": \"guide/testing\",\n+              \"title\": \"Intro to Testing\",\n+              \"tooltip\": \"Introduction to testing an Angular app.\"\n+            },\n+            {\n+              \"url\": \"guide/testing-code-coverage\",\n+              \"title\": \"Code Coverage\",\n+              \"tooltip\": \"Determine how much of your code is tested.\"\n+            },\n+            {\n+              \"url\": \"guide/testing-services\",\n+              \"title\": \"Testing Services\",\n+              \"tooltip\": \"How to test services.\"\n+            },\n+            {\n+              \"url\": \"guide/testing-components-basics\",\n+              \"title\": \"Basics of Testing Components\",\n+              \"tooltip\": \"The fundamentals of how to test components.\"\n+            },\n+            {\n+              \"url\": \"guide/testing-components-scenarios\",\n+              \"title\": \"Component Testing Scenarios\",\n+              \"tooltip\": \"Use cases for testing components.\"\n+            },\n+            {\n+              \"url\": \"guide/testing-attribute-directives\",\n+              \"title\": \"Testing Attribute Directives\",\n+              \"tooltip\": \"How to test attribute directives.\"\n+            },\n+            {\n+              \"url\": \"guide/testing-pipes\",\n+              \"title\": \"Testing Pipes\",\n+              \"tooltip\": \"Writing tests for pipes.\"\n+            },\n+            {\n+              \"url\": \"guide/test-debugging\",\n+              \"title\": \"Debugging Tests\",\n+              \"tooltip\": \"How to debug tests.\"\n+            },\n+            {\n+              \"url\": \"guide/testing-utility-apis\",\n+              \"title\": \"Testing Utility APIs\",\n+              \"tooltip\": \"Features of the Angular testing utilities.\"\n+            }\n+          ]\n         },\n         {\n           \"url\": \"guide/deployment\","
        }
    ],
    "stats": {
        "total": 6966,
        "additions": 3537,
        "deletions": 3429
    }
}