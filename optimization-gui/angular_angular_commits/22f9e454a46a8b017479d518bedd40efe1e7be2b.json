{
    "author": "JiaLiPassion",
    "message": "fix(core): NgZone coaleascing options should trigger onStable correctly (#40540)\n\nfix https://github.com/angular/components/issues/21674\n\nWhen setting `ngZoneRunCoalescing` to true, `onStable` is not emitted correctly.\nThe reason is before this commit, the code looks like this\n\n```\n// Application code call `ngZone.run()`\nngZone.run(() => {}); // step 1\n\n// Inside NgZone, in the OnInvoke hook, NgZone try to delay the checkStable()\n\nfunction delayChangeDetectionForEvents(zone: NgZonePrivate) {\n  if (zone.lastRequestAnimationFrameId !== -1) { // step 9\n    return;\n  }\n  zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(global, () => { // step 2\n    if (!zone.fakeTopEventTask) {\n      zone.fakeTopEventTask = Zone.root.scheduleEventTask('fakeTopEventTask', () => {\n        zone.lastRequestAnimationFrameId = -1; // step 3\n        updateMicroTaskStatus(zone); // step 4\n        checkStable(zone); // step 6\n      }, undefined, () => {}, () => {});\n    }\n    zone.fakeTopEventTask.invoke();\n  });\n  updateMicroTaskStatus(zone);\n}\n\nfunction updateMicroTaskStatus(zone: NgZonePrivate, ignoreCheckRAFId = false) {\n  if (zone._hasPendingMicrotasks ||\n      ((zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) &&\n       zone.lastRequestAnimationFrameId !== -1)) { // step 5\n    zone.hasPendingMicrotasks = true;\n  } else {\n    zone.hasPendingMicrotasks = false;\n  }\n}\n\nfunction checkStable(zone: NgZonePrivate) {\n  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) { // step 7\n    try {\n      zone._nesting++;\n      zone.onMicrotaskEmpty.emit(null);\n    ...\n}\n\n// application ref subscribe onMicroTaskEmpty\nngZone.onMicroTaskEmpty.subscribe(() => {\n  ngZone.run(() => { // step 8\n    tick();\n  });\n});\n\n```\n\nAnd the process is:\n1. step 1: application call ngZone.run()\n2. step 2: NgZone delay the checkStable() call in a requestAnimationFrame, and also set\nzone.lastRequestAnimationFrameId\n3. step 3: Inside the requestAnimationFrame callback, reset zone.lastRequestAnimationFrameId first\n4. step 4: update microTask status\n5, step 5: if zone.lastRequestAnimationFrameId is -1, that means no microTask pending.\n6. step 6: checkStable and trigger onMicrotaskEmpty emitter.\n7. step 7: ApplicationRef subscribed onMicrotaskEmpty, so it will call another `ngZone.run()` to process\ntick()\n8. step 8: And this new `ngZone.run()` will try to check `zone.lastRequestAnimationFrameId` in `step 9`\nwhen trying to delay the checkStable(), and since the zone.lastRequestAnimationFrameId is already reset\nto -1 in step 3, so this ngZone.run() will run into step 2 again.\n9. And become a infinite loop..., so onStable is never emit\n\nIn this commit, the `zone.lastRequestAnimationFrameId` reset is moved after `checkStable()` call.\n\nPR Close #40540",
    "sha": "22f9e454a46a8b017479d518bedd40efe1e7be2b",
    "files": [
        {
            "sha": "33152592cb38b531d847fde4c3b1bcb81fb6c964",
            "filename": "packages/core/src/zone/ng_zone.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 2,
            "changes": 32,
            "blob_url": "https://github.com/angular/angular/blob/22f9e454a46a8b017479d518bedd40efe1e7be2b/packages%2Fcore%2Fsrc%2Fzone%2Fng_zone.ts",
            "raw_url": "https://github.com/angular/angular/raw/22f9e454a46a8b017479d518bedd40efe1e7be2b/packages%2Fcore%2Fsrc%2Fzone%2Fng_zone.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fzone%2Fng_zone.ts?ref=22f9e454a46a8b017479d518bedd40efe1e7be2b",
            "patch": "@@ -148,6 +148,7 @@ export class NgZone {\n         !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;\n     self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;\n     self.lastRequestAnimationFrameId = -1;\n+    self.isCheckStableRunning = false;\n     self.nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;\n     forkInnerZoneWithAngularBehavior(self);\n   }\n@@ -243,6 +244,17 @@ interface NgZonePrivate extends NgZone {\n   hasPendingMacrotasks: boolean;\n   hasPendingMicrotasks: boolean;\n   lastRequestAnimationFrameId: number;\n+  /**\n+   * A flag to indicate if NgZone is currently inside\n+   * checkStable and to prevent re-entry. The flag is\n+   * needed because it is possible to invoke the change\n+   * detection from within change detection leading to\n+   * incorrect behavior.\n+   *\n+   * For detail, please refer here,\n+   * https://github.com/angular/angular/pull/40540\n+   */\n+  isCheckStableRunning: boolean;\n   isStable: boolean;\n   /**\n    * Optionally specify coalescing event change detections or not.\n@@ -291,7 +303,9 @@ interface NgZonePrivate extends NgZone {\n }\n \n function checkStable(zone: NgZonePrivate) {\n-  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\n+  if (!zone.isCheckStableRunning && zone._nesting == 0 && !zone.hasPendingMicrotasks &&\n+      !zone.isStable) {\n+    zone.isCheckStableRunning = true;\n     try {\n       zone._nesting++;\n       zone.onMicrotaskEmpty.emit(null);\n@@ -304,12 +318,26 @@ function checkStable(zone: NgZonePrivate) {\n           zone.isStable = true;\n         }\n       }\n+      zone.isCheckStableRunning = false;\n     }\n   }\n }\n \n function delayChangeDetectionForEvents(zone: NgZonePrivate) {\n-  if (zone.lastRequestAnimationFrameId !== -1) {\n+  /**\n+   * We also need to check isCheckStableRunning here\n+   * Consider the following case with shouldCoalesceRunChangeDetection = true\n+   *\n+   * ngZone.run(() => {});\n+   * ngZone.run(() => {});\n+   *\n+   * We want the two `ngZone.run()` only trigger one change detection\n+   * when shouldCoalesceRunChangeDetection is true.\n+   * And because in this case, change detection run in async way(requestAnimationFrame),\n+   * so we also need to check the isCheckStableRunning here to prevent multiple\n+   * change detections.\n+   */\n+  if (zone.isCheckStableRunning || zone.lastRequestAnimationFrameId !== -1) {\n     return;\n   }\n   zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(global, () => {"
        },
        {
            "sha": "dd9b6cc5ad9555be2e9d5dabce2998d93086db01",
            "filename": "packages/core/test/zone/ng_zone_spec.ts",
            "status": "modified",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/angular/angular/blob/22f9e454a46a8b017479d518bedd40efe1e7be2b/packages%2Fcore%2Ftest%2Fzone%2Fng_zone_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/22f9e454a46a8b017479d518bedd40efe1e7be2b/packages%2Fcore%2Ftest%2Fzone%2Fng_zone_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fzone%2Fng_zone_spec.ts?ref=22f9e454a46a8b017479d518bedd40efe1e7be2b",
            "patch": "@@ -982,6 +982,7 @@ function commonTests() {\n \n     describe('shouldCoalesceEventChangeDetection = true, shouldCoalesceRunChangeDetection = false', () => {\n       let nativeRequestAnimationFrame: (fn: FrameRequestCallback) => void;\n+      let nativeSetTimeout: any = (global as any)[Zone.__symbol__('setTimeout')];\n       if (!(global as any).requestAnimationFrame) {\n         nativeRequestAnimationFrame = function(fn: Function) {\n           (global as any)[Zone.__symbol__('setTimeout')](fn, 16);\n@@ -1042,6 +1043,32 @@ function commonTests() {\n            });\n          });\n \n+      it('should only emit onMicroTaskEmpty once within the same event loop for ngZone.run in onMicrotaskEmpty subscription',\n+         (done: DoneFn) => {\n+           const tasks: Task[] = [];\n+           coalesceZone.onMicrotaskEmpty.subscribe(() => {\n+             coalesceZone.run(() => {});\n+           });\n+           coalesceZone.run(() => {\n+             tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n+               logs.push('eventTask1');\n+             }, undefined, () => {}));\n+           });\n+           coalesceZone.run(() => {\n+             tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n+               logs.push('eventTask2');\n+             }, undefined, () => {}));\n+           });\n+           tasks.forEach(t => t.invoke());\n+           expect(logs).toEqual(['microTask empty', 'microTask empty', 'eventTask1', 'eventTask2']);\n+           nativeSetTimeout(() => {\n+             expect(logs).toEqual([\n+               'microTask empty', 'microTask empty', 'eventTask1', 'eventTask2', 'microTask empty'\n+             ]);\n+             done();\n+           }, 100);\n+         });\n+\n       it('should emit onMicroTaskEmpty once within the same event loop for not only event tasks, but event tasks are before other tasks',\n          (done: DoneFn) => {\n            const tasks: Task[] = [];\n@@ -1094,6 +1121,7 @@ function commonTests() {\n \n     describe('shouldCoalesceRunChangeDetection = true', () => {\n       let nativeRequestAnimationFrame: (fn: FrameRequestCallback) => void;\n+      let nativeSetTimeout: any = (global as any)[Zone.__symbol__('setTimeout')];\n       if (!(global as any).requestAnimationFrame) {\n         nativeRequestAnimationFrame = function(fn: Function) {\n           (global as any)[Zone.__symbol__('setTimeout')](fn, 16);\n@@ -1139,6 +1167,20 @@ function commonTests() {\n            });\n          });\n \n+      it('should only emit onMicroTaskEmpty once within the same event loop for ngZone.run in onMicrotaskEmpty subscription',\n+         (done: DoneFn) => {\n+           coalesceZone.onMicrotaskEmpty.subscribe(() => {\n+             coalesceZone.run(() => {});\n+           });\n+           coalesceZone.run(() => {});\n+           coalesceZone.run(() => {});\n+           expect(logs).toEqual([]);\n+           nativeSetTimeout(() => {\n+             expect(logs).toEqual(['microTask empty']);\n+             done();\n+           }, 100);\n+         });\n+\n       it('should only emit onMicroTaskEmpty once within the same event loop for multiple tasks',\n          (done: DoneFn) => {\n            const tasks: Task[] = [];"
        }
    ],
    "stats": {
        "total": 74,
        "additions": 72,
        "deletions": 2
    }
}