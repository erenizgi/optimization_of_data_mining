{
    "author": "atscott",
    "message": "feat(router): Add more find-tuned control in `routerLinkActiveOptions` (#40303)\n\nThis commit adds more configurability to the `Router#isActive` method\nand `RouterLinkActive#routerLinkActiveOptions`.\nIt allows tuning individual match options for query params and the url\ntree, which were either both partial or both exact matches in the past.\nAdditionally, it also allows matching against the fragment and matrix\nparameters.\n\nfixes #13205\n\nBREAKING CHANGE:\nThe type of the `RouterLinkActive.routerLinkActiveOptions` input was\nexpanded to allow more fine-tuned control. Code that previously read\nthis property may need to be updated to account for the new type.\n\nPR Close #40303",
    "sha": "6c05c80f19bc84189cc1d2f2e029f6f13d60dc18",
    "files": [
        {
            "sha": "b1aada813d773edd26ad85815659fd4db0159dc3",
            "filename": "goldens/public-api/router/router.d.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/goldens%2Fpublic-api%2Frouter%2Frouter.d.ts",
            "raw_url": "https://github.com/angular/angular/raw/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/goldens%2Fpublic-api%2Frouter%2Frouter.d.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fpublic-api%2Frouter%2Frouter.d.ts?ref=6c05c80f19bc84189cc1d2f2e029f6f13d60dc18",
            "patch": "@@ -158,6 +158,13 @@ export declare class GuardsCheckStart extends RouterEvent {\n \n export declare type InitialNavigation = 'disabled' | 'enabled' | 'enabledBlocking' | 'enabledNonBlocking';\n \n+export declare interface IsActiveMatchOptions {\n+    fragment: 'exact' | 'ignored';\n+    matrixParams: 'exact' | 'subset' | 'ignored';\n+    paths: 'exact' | 'subset';\n+    queryParams: 'exact' | 'subset' | 'ignored';\n+}\n+\n export declare type LoadChildren = LoadChildrenCallback | DeprecatedLoadChildren;\n \n export declare type LoadChildrenCallback = () => Type<any> | NgModuleFactory<any> | Observable<Type<any>> | Promise<NgModuleFactory<any> | Type<any> | any>;\n@@ -345,7 +352,8 @@ export declare class Router {\n     dispose(): void;\n     getCurrentNavigation(): Navigation | null;\n     initialNavigation(): void;\n-    isActive(url: string | UrlTree, exact: boolean): boolean;\n+    /** @deprecated */ isActive(url: string | UrlTree, exact: boolean): boolean;\n+    isActive(url: string | UrlTree, matchOptions: IsActiveMatchOptions): boolean;\n     navigate(commands: any[], extras?: NavigationExtras): Promise<boolean>;\n     navigateByUrl(url: string | UrlTree, extras?: NavigationBehaviorOptions): Promise<boolean>;\n     ngOnDestroy(): void;\n@@ -400,7 +408,7 @@ export declare class RouterLinkActive implements OnChanges, OnDestroy, AfterCont\n     set routerLinkActive(data: string[] | string);\n     routerLinkActiveOptions: {\n         exact: boolean;\n-    };\n+    } | IsActiveMatchOptions;\n     constructor(router: Router, element: ElementRef, renderer: Renderer2, cdr: ChangeDetectorRef, link?: RouterLink | undefined, linkWithHref?: RouterLinkWithHref | undefined);\n     ngAfterContentInit(): void;\n     ngOnChanges(changes: SimpleChanges): void;"
        },
        {
            "sha": "a7fbd11db8d31e64aac37badf5fb3f83745a50d4",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=6c05c80f19bc84189cc1d2f2e029f6f13d60dc18",
            "patch": "@@ -39,7 +39,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2285,\n-        \"main-es2015\": 241843,\n+        \"main-es2015\": 242531,\n         \"polyfills-es2015\": 36709,\n         \"5-es2015\": 745\n       }\n@@ -49,7 +49,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2289,\n-        \"main-es2015\": 217591,\n+        \"main-es2015\": 218317,\n         \"polyfills-es2015\": 36723,\n         \"5-es2015\": 781\n       }"
        },
        {
            "sha": "9ea3c3a10fdb9b46737ccf52b8d3aa629723adf4",
            "filename": "packages/core/test/bundling/router/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json?ref=6c05c80f19bc84189cc1d2f2e029f6f13d60dc18",
            "patch": "@@ -1199,6 +1199,9 @@\n   {\n     \"name\": \"equalPath\"\n   },\n+  {\n+    \"name\": \"exactMatchOptions\"\n+  },\n   {\n     \"name\": \"executeCheckHooks\"\n   },\n@@ -1661,6 +1664,9 @@\n   {\n     \"name\": \"materializeViewResults\"\n   },\n+  {\n+    \"name\": \"matrixParamsMatch\"\n+  },\n   {\n     \"name\": \"maybeUnwrapFn\"\n   },\n@@ -1754,6 +1760,12 @@\n   {\n     \"name\": \"optionsReducer\"\n   },\n+  {\n+    \"name\": \"paramCompareMap\"\n+  },\n+  {\n+    \"name\": \"pathCompareMap\"\n+  },\n   {\n     \"name\": \"pipeFromArray\"\n   },\n@@ -1949,6 +1961,9 @@\n   {\n     \"name\": \"subscribeToResult\"\n   },\n+  {\n+    \"name\": \"subsetMatchOptions\"\n+  },\n   {\n     \"name\": \"supportsState\"\n   },"
        },
        {
            "sha": "8617cb2e2c52b9f2960d58a55b9e3732455b367e",
            "filename": "packages/router/src/directives/router_link_active.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 4,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/packages%2Frouter%2Fsrc%2Fdirectives%2Frouter_link_active.ts",
            "raw_url": "https://github.com/angular/angular/raw/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/packages%2Frouter%2Fsrc%2Fdirectives%2Frouter_link_active.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Fdirectives%2Frouter_link_active.ts?ref=6c05c80f19bc84189cc1d2f2e029f6f13d60dc18",
            "patch": "@@ -12,6 +12,7 @@ import {mergeAll} from 'rxjs/operators';\n \n import {Event, NavigationEnd} from '../events';\n import {Router} from '../router';\n+import {IsActiveMatchOptions} from '../url_tree';\n \n import {RouterLink, RouterLinkWithHref} from './router_link';\n \n@@ -89,7 +90,15 @@ export class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit\n   private linkInputChangesSubscription?: Subscription;\n   public readonly isActive: boolean = false;\n \n-  @Input() routerLinkActiveOptions: {exact: boolean} = {exact: false};\n+  /**\n+   * Options to configure how to determine if the router link is active.\n+   *\n+   * These options are passed to the `Router.isActive()` function.\n+   *\n+   * @see Router.isActive\n+   */\n+  @Input() routerLinkActiveOptions: {exact: boolean}|IsActiveMatchOptions = {exact: false};\n+\n \n   constructor(\n       private router: Router, private element: ElementRef, private renderer: Renderer2,\n@@ -159,8 +168,11 @@ export class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit\n   }\n \n   private isLinkActive(router: Router): (link: (RouterLink|RouterLinkWithHref)) => boolean {\n-    return (link: RouterLink|RouterLinkWithHref) =>\n-               router.isActive(link.urlTree, this.routerLinkActiveOptions.exact);\n+    const options = 'paths' in this.routerLinkActiveOptions ?\n+        this.routerLinkActiveOptions :\n+        // While the types should disallow `undefined` here, it's possible without strict inputs\n+        (this.routerLinkActiveOptions.exact || false);\n+    return (link: RouterLink|RouterLinkWithHref) => router.isActive(link.urlTree, options);\n   }\n \n   private hasActiveLinks(): boolean {\n@@ -169,4 +181,4 @@ export class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit\n         this.linkWithHref && isActiveCheckFn(this.linkWithHref) ||\n         this.links.some(isActiveCheckFn) || this.linksWithHrefs.some(isActiveCheckFn);\n   }\n-}\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "cc47eb1cf1b612086d1f680a39bf73d1e4e5aab4",
            "filename": "packages/router/src/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/packages%2Frouter%2Fsrc%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/packages%2Frouter%2Fsrc%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Findex.ts?ref=6c05c80f19bc84189cc1d2f2e029f6f13d60dc18",
            "patch": "@@ -22,7 +22,7 @@ export {NoPreloading, PreloadAllModules, PreloadingStrategy, RouterPreloader} fr\n export {ActivatedRoute, ActivatedRouteSnapshot, RouterState, RouterStateSnapshot} from './router_state';\n export {convertToParamMap, ParamMap, Params, PRIMARY_OUTLET} from './shared';\n export {UrlHandlingStrategy} from './url_handling_strategy';\n-export {DefaultUrlSerializer, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\n+export {DefaultUrlSerializer, IsActiveMatchOptions, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\n export {VERSION} from './version';\n \n export * from './private_export';"
        },
        {
            "sha": "666128964629161b0549e8f2e30bc090bab1f4eb",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 53,
            "deletions": 5,
            "changes": 58,
            "blob_url": "https://github.com/angular/angular/blob/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=6c05c80f19bc84189cc1d2f2e029f6f13d60dc18",
            "patch": "@@ -27,7 +27,7 @@ import {ChildrenOutletContexts} from './router_outlet_context';\n import {ActivatedRoute, createEmptyState, RouterState, RouterStateSnapshot} from './router_state';\n import {isNavigationCancelingError, navigationCancelingError, Params} from './shared';\n import {DefaultUrlHandlingStrategy, UrlHandlingStrategy} from './url_handling_strategy';\n-import {containsTree, createEmptyUrlTree, UrlSerializer, UrlTree} from './url_tree';\n+import {containsTree, createEmptyUrlTree, IsActiveMatchOptions, UrlSerializer, UrlTree} from './url_tree';\n import {standardizeConfig, validateConfig} from './utils/config';\n import {Checks, getAllRouteGuards} from './utils/preactivation';\n import {isUrlTree} from './utils/type_guards';\n@@ -356,6 +356,29 @@ type LocationChangeInfo = {\n   transitionId: number\n };\n \n+/**\n+ * The equivalent `IsActiveUrlTreeOptions` options for `Router.isActive` is called with `false`\n+ * (exact = true).\n+ */\n+export const exactMatchOptions: IsActiveMatchOptions = {\n+  paths: 'exact',\n+  fragment: 'ignored',\n+  matrixParams: 'ignored',\n+  queryParams: 'exact'\n+};\n+\n+/**\n+ * The equivalent `IsActiveUrlTreeOptions` options for `Router.isActive` is called with `false`\n+ * (exact = false).\n+ */\n+export const subsetMatchOptions: IsActiveMatchOptions = {\n+  paths: 'subset',\n+  fragment: 'ignored',\n+  matrixParams: 'ignored',\n+  queryParams: 'subset'\n+};\n+\n+\n /**\n  * @description\n  *\n@@ -1213,14 +1236,39 @@ export class Router {\n     return urlTree;\n   }\n \n-  /** Returns whether the url is activated */\n-  isActive(url: string|UrlTree, exact: boolean): boolean {\n+  /**\n+   * Returns whether the url is activated.\n+   *\n+   * @deprecated\n+   * Use `IsActiveUrlTreeOptions` instead.\n+   *\n+   * - The equivalent `IsActiveUrlTreeOptions` for `true` is\n+   * `{paths: 'exact', queryParams: 'exact', fragment: 'ignored', matrixParams: 'ignored'}`.\n+   * - The equivalent for `false` is\n+   * `{paths: 'subset', queryParams: 'subset', fragment: 'ignored', matrixParams: 'ignored'}`.\n+   */\n+  isActive(url: string|UrlTree, exact: boolean): boolean;\n+  /**\n+   * Returns whether the url is activated.\n+   */\n+  isActive(url: string|UrlTree, matchOptions: IsActiveMatchOptions): boolean;\n+  /** @internal */\n+  isActive(url: string|UrlTree, matchOptions: boolean|IsActiveMatchOptions): boolean;\n+  isActive(url: string|UrlTree, matchOptions: boolean|IsActiveMatchOptions): boolean {\n+    let options: IsActiveMatchOptions;\n+    if (matchOptions === true) {\n+      options = {...exactMatchOptions};\n+    } else if (matchOptions === false) {\n+      options = {...subsetMatchOptions};\n+    } else {\n+      options = matchOptions;\n+    }\n     if (isUrlTree(url)) {\n-      return containsTree(this.currentUrlTree, url, exact);\n+      return containsTree(this.currentUrlTree, url, options);\n     }\n \n     const urlTree = this.parseUrl(url);\n-    return containsTree(this.currentUrlTree, urlTree, exact);\n+    return containsTree(this.currentUrlTree, urlTree, options);\n   }\n \n   private removeEmptyProps(params: Params): Params {"
        },
        {
            "sha": "f1f8f1b7424b5c366b28b060273f796517891aee",
            "filename": "packages/router/src/url_tree.ts",
            "status": "modified",
            "additions": 100,
            "deletions": 16,
            "changes": 116,
            "blob_url": "https://github.com/angular/angular/blob/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/packages%2Frouter%2Fsrc%2Furl_tree.ts",
            "raw_url": "https://github.com/angular/angular/raw/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/packages%2Frouter%2Fsrc%2Furl_tree.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Furl_tree.ts?ref=6c05c80f19bc84189cc1d2f2e029f6f13d60dc18",
            "patch": "@@ -13,65 +13,149 @@ export function createEmptyUrlTree() {\n   return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n }\n \n-export function containsTree(container: UrlTree, containee: UrlTree, exact: boolean): boolean {\n-  if (exact) {\n-    return equalQueryParams(container.queryParams, containee.queryParams) &&\n-        equalSegmentGroups(container.root, containee.root);\n-  }\n+/**\n+ * A set of options which specify how to determine if a `UrlTree` is active, given the `UrlTree`\n+ * for the current router state.\n+ *\n+ * @publicApi\n+ * @see Router.isActive\n+ */\n+export interface IsActiveMatchOptions {\n+  /**\n+   * Defines the strategy for comparing the matrix parameters of two `UrlTree`s.\n+   *\n+   * The matrix parameter matching is dependent on the strategy for matching the\n+   * segments. That is, if the `paths` option is set to `'subset'`, only\n+   * the matrix parameters of the matching segments will be compared.\n+   *\n+   * - `'exact'`: Requires that matching segments also have exact matrix parameter\n+   * matches.\n+   * - `'subset'`: The matching segments in the router's active `UrlTree` may contain\n+   * extra matrix parameters, but those that exist in the `UrlTree` in question must match.\n+   * - `'ignored'`: When comparing `UrlTree`s, matrix params will be ignored.\n+   */\n+  matrixParams: 'exact'|'subset'|'ignored';\n+  /**\n+   * Defines the strategy for comparing the query parameters of two `UrlTree`s.\n+   *\n+   * - `'exact'`: the query parameters must match exactly.\n+   * - `'subset'`: the active `UrlTree` may contain extra parameters,\n+   * but must match the key and value of any that exist in the `UrlTree` in question.\n+   * - `'ignored'`: When comparing `UrlTree`s, query params will be ignored.\n+   */\n+  queryParams: 'exact'|'subset'|'ignored';\n+  /**\n+   * Defines the strategy for comparing the `UrlSegment`s of the `UrlTree`s.\n+   *\n+   * - `'exact'`: all segments in each `UrlTree` must match.\n+   * - `'subset'`: a `UrlTree` will be determined to be active if it\n+   * is a subtree of the active route. That is, the active route may contain extra\n+   * segments, but must at least have all the segements of the `UrlTree` in question.\n+   */\n+  paths: 'exact'|'subset';\n+  /**\n+   * - 'exact'`: indicates that the `UrlTree` fragments must be equal.\n+   * - `'ignored'`: the fragments will not be compared when determining if a\n+   * `UrlTree` is active.\n+   */\n+  fragment: 'exact'|'ignored';\n+}\n \n-  return containsQueryParams(container.queryParams, containee.queryParams) &&\n-      containsSegmentGroup(container.root, containee.root);\n+type ParamMatchOptions = 'exact'|'subset'|'ignored';\n+\n+type PathCompareFn =\n+    (container: UrlSegmentGroup, containee: UrlSegmentGroup, matrixParams: ParamMatchOptions) =>\n+        boolean;\n+type ParamCompareFn = (container: Params, containee: Params) => boolean;\n+\n+const pathCompareMap: Record<IsActiveMatchOptions['paths'], PathCompareFn> = {\n+  'exact': equalSegmentGroups,\n+  'subset': containsSegmentGroup,\n+};\n+const paramCompareMap: Record<ParamMatchOptions, ParamCompareFn> = {\n+  'exact': equalParams,\n+  'subset': containsParams,\n+  'ignored': () => true,\n+};\n+\n+export function containsTree(\n+    container: UrlTree, containee: UrlTree, options: IsActiveMatchOptions): boolean {\n+  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) &&\n+      paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) &&\n+      !(options.fragment === 'exact' && container.fragment !== containee.fragment);\n }\n \n-function equalQueryParams(container: Params, containee: Params): boolean {\n+function equalParams(container: Params, containee: Params): boolean {\n   // TODO: This does not handle array params correctly.\n   return shallowEqual(container, containee);\n }\n \n-function equalSegmentGroups(container: UrlSegmentGroup, containee: UrlSegmentGroup): boolean {\n+function equalSegmentGroups(\n+    container: UrlSegmentGroup, containee: UrlSegmentGroup,\n+    matrixParams: ParamMatchOptions): boolean {\n   if (!equalPath(container.segments, containee.segments)) return false;\n+  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n+    return false;\n+  }\n   if (container.numberOfChildren !== containee.numberOfChildren) return false;\n   for (const c in containee.children) {\n     if (!container.children[c]) return false;\n-    if (!equalSegmentGroups(container.children[c], containee.children[c])) return false;\n+    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams))\n+      return false;\n   }\n   return true;\n }\n \n-function containsQueryParams(container: Params, containee: Params): boolean {\n+function containsParams(container: Params, containee: Params): boolean {\n   return Object.keys(containee).length <= Object.keys(container).length &&\n       Object.keys(containee).every(key => equalArraysOrString(container[key], containee[key]));\n }\n \n-function containsSegmentGroup(container: UrlSegmentGroup, containee: UrlSegmentGroup): boolean {\n-  return containsSegmentGroupHelper(container, containee, containee.segments);\n+function containsSegmentGroup(\n+    container: UrlSegmentGroup, containee: UrlSegmentGroup,\n+    matrixParams: ParamMatchOptions): boolean {\n+  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n }\n \n function containsSegmentGroupHelper(\n-    container: UrlSegmentGroup, containee: UrlSegmentGroup, containeePaths: UrlSegment[]): boolean {\n+    container: UrlSegmentGroup, containee: UrlSegmentGroup, containeePaths: UrlSegment[],\n+    matrixParams: ParamMatchOptions): boolean {\n   if (container.segments.length > containeePaths.length) {\n     const current = container.segments.slice(0, containeePaths.length);\n     if (!equalPath(current, containeePaths)) return false;\n     if (containee.hasChildren()) return false;\n+    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;\n     return true;\n \n   } else if (container.segments.length === containeePaths.length) {\n     if (!equalPath(container.segments, containeePaths)) return false;\n+    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;\n     for (const c in containee.children) {\n       if (!container.children[c]) return false;\n-      if (!containsSegmentGroup(container.children[c], containee.children[c])) return false;\n+      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n+        return false;\n+      }\n     }\n     return true;\n \n   } else {\n     const current = containeePaths.slice(0, container.segments.length);\n     const next = containeePaths.slice(container.segments.length);\n     if (!equalPath(container.segments, current)) return false;\n+    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;\n     if (!container.children[PRIMARY_OUTLET]) return false;\n-    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n+    return containsSegmentGroupHelper(\n+        container.children[PRIMARY_OUTLET], containee, next, matrixParams);\n   }\n }\n \n+function matrixParamsMatch(\n+    containerPaths: UrlSegment[], containeePaths: UrlSegment[], options: ParamMatchOptions) {\n+  return containeePaths.every((containeeSegment, i) => {\n+    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n+  });\n+}\n+\n /**\n  * @description\n  *"
        },
        {
            "sha": "8adc90c2d7aefcf6780c5bb8ede884777ef768f8",
            "filename": "packages/router/test/url_tree.spec.ts",
            "status": "modified",
            "additions": 127,
            "deletions": 28,
            "changes": 155,
            "blob_url": "https://github.com/angular/angular/blob/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/packages%2Frouter%2Ftest%2Furl_tree.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6c05c80f19bc84189cc1d2f2e029f6f13d60dc18/packages%2Frouter%2Ftest%2Furl_tree.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Furl_tree.spec.ts?ref=6c05c80f19bc84189cc1d2f2e029f6f13d60dc18",
            "patch": "@@ -6,6 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+import {exactMatchOptions, subsetMatchOptions} from '../src/router';\n import {containsTree, DefaultUrlSerializer} from '../src/url_tree';\n \n describe('UrlTree', () => {\n@@ -33,166 +34,264 @@ describe('UrlTree', () => {\n         const url = '/one/(one//left:three)(right:four)';\n         const t1 = serializer.parse(url);\n         const t2 = serializer.parse(url);\n-        expect(containsTree(t1, t2, true)).toBe(true);\n-        expect(containsTree(t2, t1, true)).toBe(true);\n+        expect(containsTree(t1, t2, exactMatchOptions)).toBe(true);\n+        expect(containsTree(t2, t1, exactMatchOptions)).toBe(true);\n       });\n \n       it('should return true when queryParams are the same', () => {\n         const t1 = serializer.parse('/one/two?test=1&page=5');\n         const t2 = serializer.parse('/one/two?test=1&page=5');\n-        expect(containsTree(t1, t2, true)).toBe(true);\n+        expect(containsTree(t1, t2, exactMatchOptions)).toBe(true);\n       });\n \n       it('should return true when queryParams are the same but with diffrent order', () => {\n         const t1 = serializer.parse('/one/two?test=1&page=5');\n         const t2 = serializer.parse('/one/two?page=5&test=1');\n-        expect(containsTree(t1, t2, true)).toBe(true);\n+        expect(containsTree(t1, t2, exactMatchOptions)).toBe(true);\n       });\n \n       it('should return true when queryParams contains array params that are the same', () => {\n         const t1 = serializer.parse('/one/two?test=a&test=b&pages=5&pages=6');\n         const t2 = serializer.parse('/one/two?test=a&test=b&pages=5&pages=6');\n-        expect(containsTree(t1, t2, true)).toBe(true);\n+        expect(containsTree(t1, t2, exactMatchOptions)).toBe(true);\n       });\n \n       it('should return false when queryParams contains array params but are not the same', () => {\n         const t1 = serializer.parse('/one/two?test=a&test=b&pages=5&pages=6');\n         const t2 = serializer.parse('/one/two?test=a&test=b&pages=5&pages=7');\n-        expect(containsTree(t1, t2, false)).toBe(false);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(false);\n       });\n \n       it('should return false when queryParams are not the same', () => {\n         const t1 = serializer.parse('/one/two?test=1&page=5');\n         const t2 = serializer.parse('/one/two?test=1');\n-        expect(containsTree(t1, t2, true)).toBe(false);\n+        expect(containsTree(t1, t2, exactMatchOptions)).toBe(false);\n       });\n \n       it('should return false when queryParams are not the same', () => {\n         const t1 = serializer.parse('/one/two?test=4&test=4&test=2');\n         const t2 = serializer.parse('/one/two?test=4&test=3&test=2');\n-        expect(containsTree(t1, t2, false)).toBe(false);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(false);\n       });\n \n       it('should return true when queryParams are the same in different order', () => {\n         const t1 = serializer.parse('/one/two?test=4&test=3&test=2');\n         const t2 = serializer.parse('/one/two?test=2&test=3&test=4');\n-        expect(containsTree(t1, t2, false)).toBe(true);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(true);\n       });\n \n       it('should return true when queryParams are the same in different order', () => {\n         const t1 = serializer.parse('/one/two?test=4&test=4&test=1');\n         const t2 = serializer.parse('/one/two?test=1&test=4&test=4');\n-        expect(containsTree(t1, t2, false)).toBe(true);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(true);\n       });\n \n       it('should return false when containee is missing queryParams', () => {\n         const t1 = serializer.parse('/one/two?page=5');\n         const t2 = serializer.parse('/one/two');\n-        expect(containsTree(t1, t2, true)).toBe(false);\n+        expect(containsTree(t1, t2, exactMatchOptions)).toBe(false);\n       });\n \n       it('should return false when paths are not the same', () => {\n         const t1 = serializer.parse('/one/two(right:three)');\n         const t2 = serializer.parse('/one/two2(right:three)');\n-        expect(containsTree(t1, t2, true)).toBe(false);\n+        expect(containsTree(t1, t2, exactMatchOptions)).toBe(false);\n       });\n \n       it('should return false when container has an extra child', () => {\n         const t1 = serializer.parse('/one/two(right:three)');\n         const t2 = serializer.parse('/one/two');\n-        expect(containsTree(t1, t2, true)).toBe(false);\n+        expect(containsTree(t1, t2, exactMatchOptions)).toBe(false);\n       });\n \n       it('should return false when containee has an extra child', () => {\n         const t1 = serializer.parse('/one/two');\n         const t2 = serializer.parse('/one/two(right:three)');\n-        expect(containsTree(t1, t2, true)).toBe(false);\n+        expect(containsTree(t1, t2, exactMatchOptions)).toBe(false);\n       });\n     });\n \n     describe('exact = false', () => {\n       it('should return true when containee is missing a segment', () => {\n         const t1 = serializer.parse('/one/(two//left:three)(right:four)');\n         const t2 = serializer.parse('/one/(two//left:three)');\n-        expect(containsTree(t1, t2, false)).toBe(true);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(true);\n       });\n \n       it('should return true when containee is missing some paths', () => {\n         const t1 = serializer.parse('/one/two/three');\n         const t2 = serializer.parse('/one/two');\n-        expect(containsTree(t1, t2, false)).toBe(true);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(true);\n       });\n \n       it('should return true container has its paths split into multiple segments', () => {\n         const t1 = serializer.parse('/one/(two//left:three)');\n         const t2 = serializer.parse('/one/two');\n-        expect(containsTree(t1, t2, false)).toBe(true);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(true);\n       });\n \n       it('should return false when containee has extra segments', () => {\n         const t1 = serializer.parse('/one/two');\n         const t2 = serializer.parse('/one/(two//left:three)');\n-        expect(containsTree(t1, t2, false)).toBe(false);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(false);\n       });\n \n       it('should return false containee has segments that the container does not have', () => {\n         const t1 = serializer.parse('/one/(two//left:three)');\n         const t2 = serializer.parse('/one/(two//right:four)');\n-        expect(containsTree(t1, t2, false)).toBe(false);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(false);\n       });\n \n       it('should return false when containee has extra paths', () => {\n         const t1 = serializer.parse('/one');\n         const t2 = serializer.parse('/one/two');\n-        expect(containsTree(t1, t2, false)).toBe(false);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(false);\n       });\n \n       it('should return true when queryParams are the same', () => {\n         const t1 = serializer.parse('/one/two?test=1&page=5');\n         const t2 = serializer.parse('/one/two?test=1&page=5');\n-        expect(containsTree(t1, t2, false)).toBe(true);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(true);\n       });\n \n       it('should return true when container contains containees queryParams', () => {\n         const t1 = serializer.parse('/one/two?test=1&u=5');\n         const t2 = serializer.parse('/one/two?u=5');\n-        expect(containsTree(t1, t2, false)).toBe(true);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(true);\n       });\n \n       it('should return true when containee does not have queryParams', () => {\n         const t1 = serializer.parse('/one/two?page=5');\n         const t2 = serializer.parse('/one/two');\n-        expect(containsTree(t1, t2, false)).toBe(true);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(true);\n       });\n \n       it('should return false when containee has but container does not have queryParams', () => {\n         const t1 = serializer.parse('/one/two');\n         const t2 = serializer.parse('/one/two?page=1');\n-        expect(containsTree(t1, t2, false)).toBe(false);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(false);\n       });\n \n       it('should return true when container has array params but containee does not have', () => {\n         const t1 = serializer.parse('/one/two?test=a&test=b&pages=5&pages=6');\n         const t2 = serializer.parse('/one/two?test=a&test=b');\n-        expect(containsTree(t1, t2, false)).toBe(true);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(true);\n       });\n \n       it('should return false when containee has array params but container does not have', () => {\n         const t1 = serializer.parse('/one/two?test=a&test=b');\n         const t2 = serializer.parse('/one/two?test=a&test=b&pages=5&pages=6');\n-        expect(containsTree(t1, t2, false)).toBe(false);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(false);\n       });\n \n       it('should return false when containee has different queryParams', () => {\n         const t1 = serializer.parse('/one/two?page=5');\n         const t2 = serializer.parse('/one/two?test=1');\n-        expect(containsTree(t1, t2, false)).toBe(false);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(false);\n       });\n \n       it('should return false when containee has more queryParams than container', () => {\n         const t1 = serializer.parse('/one/two?page=5');\n         const t2 = serializer.parse('/one/two?page=5&test=1');\n-        expect(containsTree(t1, t2, false)).toBe(false);\n+        expect(containsTree(t1, t2, subsetMatchOptions)).toBe(false);\n+      });\n+    });\n+\n+    describe('ignored query params', () => {\n+      it('should return true when queryParams differ but are ignored', () => {\n+        const t1 = serializer.parse('/?test=1&page=2');\n+        const t2 = serializer.parse('/?test=3&page=4&x=y');\n+        expect(containsTree(t1, t2, {...exactMatchOptions, queryParams: 'ignored'})).toBe(true);\n+      });\n+    });\n+\n+    describe('fragment', () => {\n+      it('should return false when fragments differ but options require exact match', () => {\n+        const t1 = serializer.parse('/#fragment1');\n+        const t2 = serializer.parse('/#fragment2');\n+        expect(containsTree(t1, t2, {...exactMatchOptions, fragment: 'exact'})).toBe(false);\n+      });\n+\n+      it('should return true when fragments differ but options ignore the fragment', () => {\n+        const t1 = serializer.parse('/#fragment1');\n+        const t2 = serializer.parse('/#fragment2');\n+        expect(containsTree(t1, t2, {...exactMatchOptions, fragment: 'ignored'})).toBe(true);\n+      });\n+    });\n+\n+    describe('matrix params', () => {\n+      describe('ignored', () => {\n+        it('returns true when matrix params differ but are ignored', () => {\n+          const t1 = serializer.parse('/a;id=15;foo=foo');\n+          const t2 = serializer.parse('/a;abc=123');\n+          expect(containsTree(t1, t2, {...exactMatchOptions, matrixParams: 'ignored'})).toBe(true);\n+        });\n+      });\n+\n+      describe('exact match', () => {\n+        const matrixParams = 'exact';\n+\n+        it('returns true when matrix params match', () => {\n+          const t1 = serializer.parse('/a;id=15;foo=foo');\n+          const t2 = serializer.parse('/a;id=15;foo=foo');\n+          expect(containsTree(t1, t2, {...exactMatchOptions, matrixParams})).toBe(true);\n+        });\n+\n+        it('returns false when matrix params differ', () => {\n+          const t1 = serializer.parse('/a;id=15;foo=foo');\n+          const t2 = serializer.parse('/a;abc=123');\n+          expect(containsTree(t1, t2, {...exactMatchOptions, matrixParams})).toBe(false);\n+        });\n+\n+        it('returns true when matrix params match on the subset of the matched url tree', () => {\n+          const t1 = serializer.parse('/a;id=15;foo=bar/c');\n+          const t2 = serializer.parse('/a;id=15;foo=bar');\n+          expect(containsTree(t1, t2, {...subsetMatchOptions, matrixParams})).toBe(true);\n+        });\n+\n+        it('should return true when matrix params match on subset of urlTree match ' +\n+               'with container paths split into multiple segments',\n+           () => {\n+             const t1 = serializer.parse('/one;a=1/(two;b=2//left:three)');\n+             const t2 = serializer.parse('/one;a=1/two;b=2');\n+             expect(containsTree(t1, t2, {...subsetMatchOptions, matrixParams})).toBe(true);\n+           });\n+      });\n+\n+      describe('subset match', () => {\n+        const matrixParams = 'subset';\n+\n+        it('returns true when matrix params match', () => {\n+          const t1 = serializer.parse('/a;id=15;foo=foo');\n+          const t2 = serializer.parse('/a;id=15;foo=foo');\n+          expect(containsTree(t1, t2, {...exactMatchOptions, matrixParams})).toBe(true);\n+        });\n+\n+        it('returns true when container has extra matrix params', () => {\n+          const t1 = serializer.parse('/a;id=15;foo=foo');\n+          const t2 = serializer.parse('/a;id=15');\n+          expect(containsTree(t1, t2, {...exactMatchOptions, matrixParams})).toBe(true);\n+        });\n+\n+        it('returns false when matrix params differ', () => {\n+          const t1 = serializer.parse('/a;id=15;foo=foo');\n+          const t2 = serializer.parse('/a;abc=123');\n+          expect(containsTree(t1, t2, {...exactMatchOptions, matrixParams})).toBe(false);\n+        });\n+\n+        it('returns true when matrix params match on the subset of the matched url tree', () => {\n+          const t1 = serializer.parse('/a;id=15;foo=bar/c');\n+          const t2 = serializer.parse('/a;id=15;foo=bar');\n+          expect(containsTree(t1, t2, {...subsetMatchOptions, matrixParams})).toBe(true);\n+        });\n+\n+        it('should return true when matrix params match on subset of urlTree match ' +\n+               'with container paths split into multiple segments',\n+           () => {\n+             const t1 = serializer.parse('/one;a=1/(two;b=2//left:three)');\n+             const t2 = serializer.parse('/one;a=1/two');\n+             expect(containsTree(t1, t2, {...subsetMatchOptions, matrixParams})).toBe(true);\n+           });\n       });\n     });\n   });"
        }
    ],
    "stats": {
        "total": 382,
        "additions": 324,
        "deletions": 58
    }
}