{
    "author": "petebacondarwin",
    "message": "refactor(localize): add placeholder locations in extracted messages (#38536)\n\nSome translation file formats would like to be able to render the\ntext of placeholders taken from the original source files. This commit\nadds this information to the extracted messages so that it can be\nused in translation file serializers.\n\nPR Close #38536",
    "sha": "db3a21b382e564b285a62ffdb120955a8d3f0d94",
    "files": [
        {
            "sha": "9c4efee6aef8791031a71bc656c388028e3906b5",
            "filename": "packages/localize/src/tools/src/extract/source_files/es2015_extract_plugin.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Fextract%2Fsource_files%2Fes2015_extract_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Fextract%2Fsource_files%2Fes2015_extract_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Fextract%2Fsource_files%2Fes2015_extract_plugin.ts?ref=db3a21b382e564b285a62ffdb120955a8d3f0d94",
            "patch": "@@ -9,7 +9,7 @@ import {ɵParsedMessage, ɵparseMessage} from '@angular/localize';\n import {NodePath, PluginObj} from '@babel/core';\n import {TaggedTemplateExpression} from '@babel/types';\n \n-import {getLocation, isGlobalIdentifier, isNamedIdentifier, unwrapMessagePartsFromTemplateLiteral} from '../../source_file_utils';\n+import {getLocation, isGlobalIdentifier, isNamedIdentifier, unwrapExpressionsFromTemplateLiteral, unwrapMessagePartsFromTemplateLiteral} from '../../source_file_utils';\n \n export function makeEs2015ExtractPlugin(\n     messages: ɵParsedMessage[], localizeName = '$localize'): PluginObj {\n@@ -18,9 +18,14 @@ export function makeEs2015ExtractPlugin(\n       TaggedTemplateExpression(path: NodePath<TaggedTemplateExpression>) {\n         const tag = path.get('tag');\n         if (isNamedIdentifier(tag, localizeName) && isGlobalIdentifier(tag)) {\n-          const messageParts = unwrapMessagePartsFromTemplateLiteral(path.node.quasi.quasis);\n-          const location = getLocation(path.get('quasi'));\n-          const message = ɵparseMessage(messageParts, path.node.quasi.expressions, location);\n+          const quasiPath = path.get('quasi');\n+          const [messageParts, messagePartLocations] =\n+              unwrapMessagePartsFromTemplateLiteral(quasiPath.get('quasis'));\n+          const [expressions, expressionLocations] =\n+              unwrapExpressionsFromTemplateLiteral(quasiPath);\n+          const location = getLocation(quasiPath);\n+          const message = ɵparseMessage(\n+              messageParts, expressions, location, messagePartLocations, expressionLocations);\n           messages.push(message);\n         }\n       }"
        },
        {
            "sha": "1814114c9c0a196b09820a6dff6fa7a03d3565d1",
            "filename": "packages/localize/src/tools/src/extract/source_files/es5_extract_plugin.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Fextract%2Fsource_files%2Fes5_extract_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Fextract%2Fsource_files%2Fes5_extract_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Fextract%2Fsource_files%2Fes5_extract_plugin.ts?ref=db3a21b382e564b285a62ffdb120955a8d3f0d94",
            "patch": "@@ -18,10 +18,12 @@ export function makeEs5ExtractPlugin(\n       CallExpression(callPath: NodePath<CallExpression>) {\n         const calleePath = callPath.get('callee');\n         if (isNamedIdentifier(calleePath, localizeName) && isGlobalIdentifier(calleePath)) {\n-          const messageParts = unwrapMessagePartsFromLocalizeCall(callPath);\n-          const expressions = unwrapSubstitutionsFromLocalizeCall(callPath.node);\n-          const location = getLocation(callPath);\n-          const message = ɵparseMessage(messageParts, expressions, location);\n+          const [messageParts, messagePartLocations] = unwrapMessagePartsFromLocalizeCall(callPath);\n+          const [expressions, expressionLocations] = unwrapSubstitutionsFromLocalizeCall(callPath);\n+          const [messagePartsArg, expressionsArg] = callPath.get('arguments');\n+          const location = getLocation(messagePartsArg, expressionsArg);\n+          const message = ɵparseMessage(\n+              messageParts, expressions, location, messagePartLocations, expressionLocations);\n           messages.push(message);\n         }\n       }"
        },
        {
            "sha": "07d7618b5c6fcc369555fad0ca6f088483ffae3f",
            "filename": "packages/localize/src/tools/src/source_file_utils.ts",
            "status": "modified",
            "additions": 44,
            "deletions": 24,
            "changes": 68,
            "blob_url": "https://github.com/angular/angular/blob/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Fsource_file_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Fsource_file_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Fsource_file_utils.ts?ref=db3a21b382e564b285a62ffdb120955a8d3f0d94",
            "patch": "@@ -67,7 +67,7 @@ export function buildLocalizeReplacement(\n  * @param call The AST node of the call to process.\n  */\n export function unwrapMessagePartsFromLocalizeCall(call: NodePath<t.CallExpression>):\n-    TemplateStringsArray {\n+    [TemplateStringsArray, (ɵSourceLocation | undefined)[]] {\n   let cooked = call.get('arguments')[0];\n \n   if (cooked === undefined) {\n@@ -137,34 +137,44 @@ export function unwrapMessagePartsFromLocalizeCall(call: NodePath<t.CallExpressi\n     raw = arg2 !== undefined ? arg2 : cooked;\n   }\n \n-  const cookedStrings = unwrapStringLiteralArray(cooked.node);\n-  const rawStrings = unwrapStringLiteralArray(raw.node);\n-  return ɵmakeTemplateObject(cookedStrings, rawStrings);\n+  const [cookedStrings] = unwrapStringLiteralArray(cooked);\n+  const [rawStrings, rawLocations] = unwrapStringLiteralArray(raw);\n+  return [ɵmakeTemplateObject(cookedStrings, rawStrings), rawLocations];\n }\n \n \n-export function unwrapSubstitutionsFromLocalizeCall(call: t.CallExpression): t.Expression[] {\n-  const expressions = call.arguments.splice(1);\n+export function unwrapSubstitutionsFromLocalizeCall(call: NodePath<t.CallExpression>):\n+    [t.Expression[], (ɵSourceLocation | undefined)[]] {\n+  const expressions = call.get('arguments').splice(1);\n   if (!isArrayOfExpressions(expressions)) {\n-    const badExpression = expressions.find(expression => !t.isExpression(expression))!;\n+    const badExpression = expressions.find(expression => !expression.isExpression())!;\n     throw new BabelParseError(\n-        badExpression,\n+        badExpression.node,\n         'Invalid substitutions for `$localize` (expected all substitution arguments to be expressions).');\n   }\n-  return expressions;\n+  return [\n+    expressions.map(path => path.node), expressions.map(expression => getLocation(expression))\n+  ];\n }\n \n-export function unwrapMessagePartsFromTemplateLiteral(elements: t.TemplateElement[]):\n-    TemplateStringsArray {\n+export function unwrapMessagePartsFromTemplateLiteral(elements: NodePath<t.TemplateElement>[]):\n+    [TemplateStringsArray, (ɵSourceLocation | undefined)[]] {\n   const cooked = elements.map(q => {\n-    if (q.value.cooked === undefined) {\n+    if (q.node.value.cooked === undefined) {\n       throw new BabelParseError(\n-          q, `Unexpected undefined message part in \"${elements.map(q => q.value.cooked)}\"`);\n+          q.node,\n+          `Unexpected undefined message part in \"${elements.map(q => q.node.value.cooked)}\"`);\n     }\n-    return q.value.cooked;\n+    return q.node.value.cooked;\n   });\n-  const raw = elements.map(q => q.value.raw);\n-  return ɵmakeTemplateObject(cooked, raw);\n+  const raw = elements.map(q => q.node.value.raw);\n+  const locations = elements.map(q => getLocation(q));\n+  return [ɵmakeTemplateObject(cooked, raw), locations];\n+}\n+\n+export function unwrapExpressionsFromTemplateLiteral(quasi: NodePath<t.TemplateLiteral>):\n+    [t.Expression[], (ɵSourceLocation | undefined)[]] {\n+  return [quasi.node.expressions, quasi.get('expressions').map(e => getLocation(e))];\n }\n \n /**\n@@ -186,12 +196,14 @@ export function wrapInParensIfNecessary(expression: t.Expression): t.Expression\n  * Extract the string values from an `array` of string literals.\n  * @param array The array to unwrap.\n  */\n-export function unwrapStringLiteralArray(array: t.Expression): string[] {\n-  if (!isStringLiteralArray(array)) {\n+export function unwrapStringLiteralArray(array: NodePath<t.Expression>):\n+    [string[], (ɵSourceLocation | undefined)[]] {\n+  if (!isStringLiteralArray(array.node)) {\n     throw new BabelParseError(\n-        array, 'Unexpected messageParts for `$localize` (expected an array of strings).');\n+        array.node, 'Unexpected messageParts for `$localize` (expected an array of strings).');\n   }\n-  return array.elements.map((str: t.StringLiteral) => str.value);\n+  const elements = array.get('elements') as NodePath<t.StringLiteral>[];\n+  return [elements.map(str => str.node.value), elements.map(str => getLocation(str))];\n }\n \n /**\n@@ -295,8 +307,8 @@ export function isStringLiteralArray(node: t.Node): node is t.Expression&\n  * Are all the given `nodes` expressions?\n  * @param nodes The nodes to test.\n  */\n-export function isArrayOfExpressions(nodes: t.Node[]): nodes is t.Expression[] {\n-  return nodes.every(element => t.isExpression(element));\n+export function isArrayOfExpressions(paths: NodePath<t.Node>[]): paths is NodePath<t.Expression>[] {\n+  return paths.every(element => element.isExpression());\n }\n \n /** Options that affect how the `makeEsXXXTranslatePlugin()` functions work. */\n@@ -361,7 +373,8 @@ export function getLocation(startPath: NodePath, endPath?: NodePath): ɵSourceLo\n   return {\n     start: getLineAndColumn(startLocation.start),\n     end: getLineAndColumn(endLocation.end),\n-    file\n+    file,\n+    text: getText(startPath),\n   };\n }\n \n@@ -375,11 +388,18 @@ export function serializeLocationPosition(location: ɵSourceLocation): string {\n function getFileFromPath(path: NodePath|undefined): AbsoluteFsPath|null {\n   const opts = path?.hub.file.opts;\n   return opts?.filename ?\n-      resolve(opts.generatorOpts.sourceRoot, relative(opts.cwd, opts.filename)) :\n+      resolve(opts.generatorOpts.sourceRoot ?? opts.cwd, relative(opts.cwd, opts.filename)) :\n       null;\n }\n \n function getLineAndColumn(loc: {line: number, column: number}): {line: number, column: number} {\n   // Note we want 0-based line numbers but Babel returns 1-based.\n   return {line: loc.line - 1, column: loc.column};\n }\n+\n+function getText(path: NodePath): string|undefined {\n+  if (path.node.start === null || path.node.end === null) {\n+    return undefined;\n+  }\n+  return path.hub.file.code.substring(path.node.start, path.node.end);\n+}"
        },
        {
            "sha": "1c9735e2ccff9b1ef6322513a560fe67c924fe87",
            "filename": "packages/localize/src/tools/src/translate/source_files/es2015_translate_plugin.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Ftranslate%2Fsource_files%2Fes2015_translate_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Ftranslate%2Fsource_files%2Fes2015_translate_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Ftranslate%2Fsource_files%2Fes2015_translate_plugin.ts?ref=db3a21b382e564b285a62ffdb120955a8d3f0d94",
            "patch": "@@ -23,7 +23,8 @@ export function makeEs2015TranslatePlugin(\n         try {\n           const tag = path.get('tag');\n           if (isLocalize(tag, localizeName)) {\n-            const messageParts = unwrapMessagePartsFromTemplateLiteral(path.node.quasi.quasis);\n+            const [messageParts] =\n+                unwrapMessagePartsFromTemplateLiteral(path.get('quasi').get('quasis'));\n             const translated = translate(\n                 diagnostics, translations, messageParts, path.node.quasi.expressions,\n                 missingTranslation);"
        },
        {
            "sha": "7bcd78f6207c0d274c010862506c5f5f2a02befe",
            "filename": "packages/localize/src/tools/src/translate/source_files/es5_translate_plugin.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Ftranslate%2Fsource_files%2Fes5_translate_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Ftranslate%2Fsource_files%2Fes5_translate_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Ftranslate%2Fsource_files%2Fes5_translate_plugin.ts?ref=db3a21b382e564b285a62ffdb120955a8d3f0d94",
            "patch": "@@ -23,8 +23,8 @@ export function makeEs5TranslatePlugin(\n         try {\n           const calleePath = callPath.get('callee');\n           if (isLocalize(calleePath, localizeName)) {\n-            const messageParts = unwrapMessagePartsFromLocalizeCall(callPath);\n-            const expressions = unwrapSubstitutionsFromLocalizeCall(callPath.node);\n+            const [messageParts] = unwrapMessagePartsFromLocalizeCall(callPath);\n+            const [expressions] = unwrapSubstitutionsFromLocalizeCall(callPath);\n             const translated =\n                 translate(diagnostics, translations, messageParts, expressions, missingTranslation);\n             callPath.replaceWith(buildLocalizeReplacement(translated[0], translated[1]));"
        },
        {
            "sha": "48d380915c24c850d0ebd8f13fbe347c477c8fcf",
            "filename": "packages/localize/src/tools/test/extract/extractor_spec.ts",
            "status": "modified",
            "additions": 121,
            "deletions": 3,
            "changes": 124,
            "blob_url": "https://github.com/angular/angular/blob/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Ftest%2Fextract%2Fextractor_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Ftest%2Fextract%2Fextractor_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flocalize%2Fsrc%2Ftools%2Ftest%2Fextract%2Fextractor_spec.ts?ref=db3a21b382e564b285a62ffdb120955a8d3f0d94",
            "patch": "@@ -36,11 +36,50 @@ runInEachFileSystem(() => {\n         description: 'description',\n         meaning: 'meaning',\n         messageParts: ['a', 'b', 'c'],\n+        messagePartLocations: [\n+          {\n+            start: {line: 0, column: 10},\n+            end: {line: 0, column: 32},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: ':meaning|description:a',\n+          },\n+          {\n+            start: {line: 0, column: 36},\n+            end: {line: 0, column: 37},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: 'b',\n+          },\n+          {\n+            start: {line: 0, column: 41},\n+            end: {line: 0, column: 42},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: 'c',\n+          }\n+        ],\n         text: 'a{$PH}b{$PH_1}c',\n         placeholderNames: ['PH', 'PH_1'],\n         substitutions: jasmine.any(Object),\n+        substitutionLocations: {\n+          PH: {\n+            start: {line: 0, column: 34},\n+            end: {line: 0, column: 35},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: '1'\n+          },\n+          PH_1: {\n+            start: {line: 0, column: 39},\n+            end: {line: 0, column: 40},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: '2'\n+          }\n+        },\n         legacyIds: [],\n-        location: {start: {line: 0, column: 9}, end: {line: 0, column: 43}, file},\n+        location: {\n+          start: {line: 0, column: 9},\n+          end: {line: 0, column: 43},\n+          file,\n+          text: '`:meaning|description:a${1}b${2}c`',\n+        },\n       });\n \n       expect(messages[1]).toEqual({\n@@ -49,11 +88,51 @@ runInEachFileSystem(() => {\n         description: '',\n         meaning: '',\n         messageParts: ['a', 'b', 'c'],\n+        messagePartLocations: [\n+          {\n+            start: {line: 1, column: 69},\n+            end: {line: 1, column: 72},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: '\"a\"',\n+          },\n+          {\n+            start: {line: 1, column: 74},\n+            end: {line: 1, column: 97},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: '\":custom-placeholder:b\"',\n+          },\n+          {\n+            start: {line: 1, column: 99},\n+            end: {line: 1, column: 102},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: '\"c\"',\n+          }\n+        ],\n         text: 'a{$custom-placeholder}b{$PH_1}c',\n         placeholderNames: ['custom-placeholder', 'PH_1'],\n         substitutions: jasmine.any(Object),\n+        substitutionLocations: {\n+          'custom-placeholder': {\n+            start: {line: 1, column: 106},\n+            end: {line: 1, column: 107},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: '1'\n+          },\n+          PH_1: {\n+            start: {line: 1, column: 109},\n+            end: {line: 1, column: 110},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: '2'\n+          }\n+        },\n         legacyIds: [],\n-        location: {start: {line: 1, column: 0}, end: {line: 1, column: 111}, file},\n+        location: {\n+          start: {line: 1, column: 10},\n+          end: {line: 1, column: 107},\n+          file,\n+          text:\n+              '__makeTemplateObject([\"a\", \":custom-placeholder:b\", \"c\"], [\"a\", \":custom-placeholder:b\", \"c\"])',\n+        },\n       });\n \n       expect(messages[2]).toEqual({\n@@ -65,8 +144,47 @@ runInEachFileSystem(() => {\n         text: 'a{$PH}b{$PH_1}c',\n         placeholderNames: ['PH', 'PH_1'],\n         substitutions: jasmine.any(Object),\n+        substitutionLocations: {\n+          PH: {\n+            start: {line: 2, column: 26},\n+            end: {line: 2, column: 27},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: '1'\n+          },\n+          PH_1: {\n+            start: {line: 2, column: 31},\n+            end: {line: 2, column: 32},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: '2'\n+          }\n+        },\n+        messagePartLocations: [\n+          {\n+            start: {line: 2, column: 10},\n+            end: {line: 2, column: 24},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: ':@@custom-id:a'\n+          },\n+          {\n+            start: {line: 2, column: 28},\n+            end: {line: 2, column: 29},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: 'b'\n+          },\n+          {\n+            start: {line: 2, column: 33},\n+            end: {line: 2, column: 34},\n+            file: absoluteFrom('/root/path/relative/path.js'),\n+            text: 'c'\n+          }\n+        ],\n         legacyIds: [],\n-        location: {start: {line: 2, column: 9}, end: {line: 2, column: 35}, file},\n+        location: {\n+          start: {line: 2, column: 9},\n+          end: {line: 2, column: 35},\n+          file,\n+          text: '`:@@custom-id:a${1}b${2}c`'\n+        },\n       });\n     });\n   });"
        },
        {
            "sha": "582c051119e4afb26604b4cf3ce574428c9fafa4",
            "filename": "packages/localize/src/tools/test/source_file_utils_spec.ts",
            "status": "modified",
            "additions": 277,
            "deletions": 151,
            "changes": 428,
            "blob_url": "https://github.com/angular/angular/blob/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Ftest%2Fsource_file_utils_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/db3a21b382e564b285a62ffdb120955a8d3f0d94/packages%2Flocalize%2Fsrc%2Ftools%2Ftest%2Fsource_file_utils_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flocalize%2Fsrc%2Ftools%2Ftest%2Fsource_file_utils_spec.ts?ref=db3a21b382e564b285a62ffdb120955a8d3f0d94",
            "patch": "@@ -12,192 +12,303 @@ import {NodePath, TransformOptions, transformSync} from '@babel/core';\n import generate from '@babel/generator';\n \n import template from '@babel/template';\n-import {Expression, Identifier, TaggedTemplateExpression, ExpressionStatement, FunctionDeclaration, CallExpression, isParenthesizedExpression, numericLiteral, binaryExpression, NumericLiteral} from '@babel/types';\n+import {Expression, Identifier, TaggedTemplateExpression, ExpressionStatement, CallExpression, isParenthesizedExpression, numericLiteral, binaryExpression, NumericLiteral} from '@babel/types';\n import {isGlobalIdentifier, isNamedIdentifier, isStringLiteralArray, isArrayOfExpressions, unwrapStringLiteralArray, unwrapMessagePartsFromLocalizeCall, wrapInParensIfNecessary, buildLocalizeReplacement, unwrapSubstitutionsFromLocalizeCall, unwrapMessagePartsFromTemplateLiteral, getLocation} from '../src/source_file_utils';\n \n-describe('utils', () => {\n-  describe('isNamedIdentifier()', () => {\n-    it('should return true if the expression is an identifier with name `$localize`', () => {\n-      const taggedTemplate = getTaggedTemplate('$localize ``;');\n-      expect(isNamedIdentifier(taggedTemplate.get('tag'), '$localize')).toBe(true);\n-    });\n+runInEachFileSystem(() => {\n+  describe('utils', () => {\n+    describe('isNamedIdentifier()', () => {\n+      it('should return true if the expression is an identifier with name `$localize`', () => {\n+        const taggedTemplate = getTaggedTemplate('$localize ``;');\n+        expect(isNamedIdentifier(taggedTemplate.get('tag'), '$localize')).toBe(true);\n+      });\n \n-    it('should return false if the expression is an identifier without the name `$localize`',\n-       () => {\n-         const taggedTemplate = getTaggedTemplate('other ``;');\n-         expect(isNamedIdentifier(taggedTemplate.get('tag'), '$localize')).toBe(false);\n-       });\n+      it('should return false if the expression is an identifier without the name `$localize`',\n+         () => {\n+           const taggedTemplate = getTaggedTemplate('other ``;');\n+           expect(isNamedIdentifier(taggedTemplate.get('tag'), '$localize')).toBe(false);\n+         });\n \n-    it('should return false if the expression is not an identifier', () => {\n-      const taggedTemplate = getTaggedTemplate('$localize() ``;');\n-      expect(isNamedIdentifier(taggedTemplate.get('tag'), '$localize')).toBe(false);\n+      it('should return false if the expression is not an identifier', () => {\n+        const taggedTemplate = getTaggedTemplate('$localize() ``;');\n+        expect(isNamedIdentifier(taggedTemplate.get('tag'), '$localize')).toBe(false);\n+      });\n     });\n-  });\n \n-  describe('isGlobalIdentifier()', () => {\n-    it('should return true if the identifier is at the top level and not declared', () => {\n-      const taggedTemplate = getTaggedTemplate('$localize ``;');\n-      expect(isGlobalIdentifier(taggedTemplate.get('tag') as NodePath<Identifier>)).toBe(true);\n-    });\n+    describe('isGlobalIdentifier()', () => {\n+      it('should return true if the identifier is at the top level and not declared', () => {\n+        const taggedTemplate = getTaggedTemplate('$localize ``;');\n+        expect(isGlobalIdentifier(taggedTemplate.get('tag') as NodePath<Identifier>)).toBe(true);\n+      });\n \n-    it('should return true if the identifier is in a block scope and not declared', () => {\n-      const taggedTemplate = getTaggedTemplate('function foo() { $localize ``; } foo();');\n-      expect(isGlobalIdentifier(taggedTemplate.get('tag') as NodePath<Identifier>)).toBe(true);\n-    });\n+      it('should return true if the identifier is in a block scope and not declared', () => {\n+        const taggedTemplate = getTaggedTemplate('function foo() { $localize ``; } foo();');\n+        expect(isGlobalIdentifier(taggedTemplate.get('tag') as NodePath<Identifier>)).toBe(true);\n+      });\n \n-    it('should return false if the identifier is declared locally', () => {\n-      const taggedTemplate = getTaggedTemplate('function $localize() {} $localize ``;');\n-      expect(isGlobalIdentifier(taggedTemplate.get('tag') as NodePath<Identifier>)).toBe(false);\n-    });\n+      it('should return false if the identifier is declared locally', () => {\n+        const taggedTemplate = getTaggedTemplate('function $localize() {} $localize ``;');\n+        expect(isGlobalIdentifier(taggedTemplate.get('tag') as NodePath<Identifier>)).toBe(false);\n+      });\n \n-    it('should return false if the identifier is a function parameter', () => {\n-      const taggedTemplate = getTaggedTemplate('function foo($localize) { $localize ``; }');\n-      expect(isGlobalIdentifier(taggedTemplate.get('tag') as NodePath<Identifier>)).toBe(false);\n+      it('should return false if the identifier is a function parameter', () => {\n+        const taggedTemplate = getTaggedTemplate('function foo($localize) { $localize ``; }');\n+        expect(isGlobalIdentifier(taggedTemplate.get('tag') as NodePath<Identifier>)).toBe(false);\n+      });\n     });\n-  });\n \n-  describe('buildLocalizeReplacement', () => {\n-    it('should interleave the `messageParts` with the `substitutions`', () => {\n-      const messageParts = ɵmakeTemplateObject(['a', 'b', 'c'], ['a', 'b', 'c']);\n-      const substitutions = [numericLiteral(1), numericLiteral(2)];\n-      const expression = buildLocalizeReplacement(messageParts, substitutions);\n-      expect(generate(expression).code).toEqual('\"a\" + 1 + \"b\" + 2 + \"c\"');\n-    });\n+    describe('buildLocalizeReplacement', () => {\n+      it('should interleave the `messageParts` with the `substitutions`', () => {\n+        const messageParts = ɵmakeTemplateObject(['a', 'b', 'c'], ['a', 'b', 'c']);\n+        const substitutions = [numericLiteral(1), numericLiteral(2)];\n+        const expression = buildLocalizeReplacement(messageParts, substitutions);\n+        expect(generate(expression).code).toEqual('\"a\" + 1 + \"b\" + 2 + \"c\"');\n+      });\n \n-    it('should wrap \"binary expression\" substitutions in parentheses', () => {\n-      const messageParts = ɵmakeTemplateObject(['a', 'b'], ['a', 'b']);\n-      const binary = binaryExpression('+', numericLiteral(1), numericLiteral(2));\n-      const expression = buildLocalizeReplacement(messageParts, [binary]);\n-      expect(generate(expression).code).toEqual('\"a\" + (1 + 2) + \"b\"');\n+      it('should wrap \"binary expression\" substitutions in parentheses', () => {\n+        const messageParts = ɵmakeTemplateObject(['a', 'b'], ['a', 'b']);\n+        const binary = binaryExpression('+', numericLiteral(1), numericLiteral(2));\n+        const expression = buildLocalizeReplacement(messageParts, [binary]);\n+        expect(generate(expression).code).toEqual('\"a\" + (1 + 2) + \"b\"');\n+      });\n     });\n-  });\n \n-  describe('unwrapMessagePartsFromLocalizeCall', () => {\n-    it('should return an array of string literals from a direct call to a tag function', () => {\n-      const localizeCall = getLocalizeCall(`$localize(['a', 'b\\\\t', 'c'], 1, 2)`);\n-      const parts = unwrapMessagePartsFromLocalizeCall(localizeCall);\n-      expect(parts).toEqual(['a', 'b\\t', 'c']);\n-    });\n+    describe('unwrapMessagePartsFromLocalizeCall', () => {\n+      it('should return an array of string literals and locations from a direct call to a tag function',\n+         () => {\n+           const localizeCall = getLocalizeCall(`$localize(['a', 'b\\\\t', 'c'], 1, 2)`);\n+           const [parts, locations] = unwrapMessagePartsFromLocalizeCall(localizeCall);\n+           expect(parts).toEqual(['a', 'b\\t', 'c']);\n+           expect(locations).toEqual([\n+             {\n+               start: {line: 0, column: 11},\n+               end: {line: 0, column: 14},\n+               file: absoluteFrom('/test/file.js'),\n+               text: `'a'`,\n+             },\n+             {\n+               start: {line: 0, column: 16},\n+               end: {line: 0, column: 21},\n+               file: absoluteFrom('/test/file.js'),\n+               text: `'b\\\\t'`,\n+             },\n+             {\n+               start: {line: 0, column: 23},\n+               end: {line: 0, column: 26},\n+               file: absoluteFrom('/test/file.js'),\n+               text: `'c'`,\n+             },\n+           ]);\n+         });\n \n-    it('should return an array of string literals from a downleveled tagged template', () => {\n-      let localizeCall = getLocalizeCall(\n-          `$localize(__makeTemplateObject(['a', 'b\\\\t', 'c'], ['a', 'b\\\\\\\\t', 'c']), 1, 2)`);\n-      const parts = unwrapMessagePartsFromLocalizeCall(localizeCall);\n-      expect(parts).toEqual(['a', 'b\\t', 'c']);\n-      expect(parts.raw).toEqual(['a', 'b\\\\t', 'c']);\n-    });\n+      it('should return an array of string literals and locations from a downleveled tagged template',\n+         () => {\n+           let localizeCall = getLocalizeCall(\n+               `$localize(__makeTemplateObject(['a', 'b\\\\t', 'c'], ['a', 'b\\\\\\\\t', 'c']), 1, 2)`);\n+           const [parts, locations] = unwrapMessagePartsFromLocalizeCall(localizeCall);\n+           expect(parts).toEqual(['a', 'b\\t', 'c']);\n+           expect(parts.raw).toEqual(['a', 'b\\\\t', 'c']);\n+           expect(locations).toEqual([\n+             {\n+               start: {line: 0, column: 51},\n+               end: {line: 0, column: 54},\n+               file: absoluteFrom('/test/file.js'),\n+               text: `'a'`,\n+             },\n+             {\n+               start: {line: 0, column: 56},\n+               end: {line: 0, column: 62},\n+               file: absoluteFrom('/test/file.js'),\n+               text: `'b\\\\\\\\t'`,\n+             },\n+             {\n+               start: {line: 0, column: 64},\n+               end: {line: 0, column: 67},\n+               file: absoluteFrom('/test/file.js'),\n+               text: `'c'`,\n+             },\n+           ]);\n+         });\n \n-    it('should return an array of string literals from a lazy load template helper', () => {\n-      let localizeCall = getLocalizeCall(`\n+      it('should return an array of string literals and locations from a lazy load template helper',\n+         () => {\n+           let localizeCall = getLocalizeCall(`\n         function _templateObject() {\n-          var e = _taggedTemplateLiteral(['a', 'b', 'c'], ['a', 'b', 'c']);\n+          var e = _taggedTemplateLiteral(['a', 'b\\\\t', 'c'], ['a', 'b\\\\\\\\t', 'c']);\n           return _templateObject = function() { return e }, e\n         }\n         $localize(_templateObject(), 1, 2)`);\n-      const parts = unwrapMessagePartsFromLocalizeCall(localizeCall);\n-      expect(parts).toEqual(['a', 'b', 'c']);\n-      expect(parts.raw).toEqual(['a', 'b', 'c']);\n-    });\n+           const [parts, locations] = unwrapMessagePartsFromLocalizeCall(localizeCall);\n+           expect(parts).toEqual(['a', 'b\\t', 'c']);\n+           expect(parts.raw).toEqual(['a', 'b\\\\t', 'c']);\n+           expect(locations).toEqual([\n+             {\n+               start: {line: 2, column: 61},\n+               end: {line: 2, column: 64},\n+               file: absoluteFrom('/test/file.js'),\n+               text: `'a'`,\n+             },\n+             {\n+               start: {line: 2, column: 66},\n+               end: {line: 2, column: 72},\n+               file: absoluteFrom('/test/file.js'),\n+               text: `'b\\\\\\\\t'`,\n+             },\n+             {\n+               start: {line: 2, column: 74},\n+               end: {line: 2, column: 77},\n+               file: absoluteFrom('/test/file.js'),\n+               text: `'c'`,\n+             },\n+           ]);\n+         });\n \n-    it('should remove a lazy load template helper', () => {\n-      let localizeCall = getLocalizeCall(`\n+      it('should remove a lazy load template helper', () => {\n+        let localizeCall = getLocalizeCall(`\n         function _templateObject() {\n           var e = _taggedTemplateLiteral(['a', 'b', 'c'], ['a', 'b', 'c']);\n           return _templateObject = function() { return e }, e\n         }\n         $localize(_templateObject(), 1, 2)`);\n-      const localizeStatement = localizeCall.parentPath as NodePath<ExpressionStatement>;\n-      const statements = localizeStatement.container as object[];\n-      expect(statements.length).toEqual(2);\n-      unwrapMessagePartsFromLocalizeCall(localizeCall);\n-      expect(statements.length).toEqual(1);\n-      expect(statements[0]).toBe(localizeStatement.node);\n+        const localizeStatement = localizeCall.parentPath as NodePath<ExpressionStatement>;\n+        const statements = localizeStatement.container as object[];\n+        expect(statements.length).toEqual(2);\n+        unwrapMessagePartsFromLocalizeCall(localizeCall);\n+        expect(statements.length).toEqual(1);\n+        expect(statements[0]).toBe(localizeStatement.node);\n+      });\n     });\n-  });\n \n-  describe('unwrapSubstitutionsFromLocalizeCall', () => {\n-    it('should return the substitutions from a direct call to a tag function', () => {\n-      const ast = template.ast`$localize(['a', 'b\\t', 'c'], 1, 2)` as ExpressionStatement;\n-      const call = ast.expression as CallExpression;\n-      const substitutions = unwrapSubstitutionsFromLocalizeCall(call);\n-      expect(substitutions.map(s => (s as NumericLiteral).value)).toEqual([1, 2]);\n-    });\n+    describe('unwrapSubstitutionsFromLocalizeCall', () => {\n+      it('should return the substitutions and locations from a direct call to a tag function',\n+         () => {\n+           const call = getLocalizeCall(`$localize(['a', 'b\\t', 'c'], 1, 2)`);\n+           const [substitutions, locations] = unwrapSubstitutionsFromLocalizeCall(call);\n+           expect((substitutions as NumericLiteral[]).map(s => s.value)).toEqual([1, 2]);\n+           expect(locations).toEqual([\n+             {\n+               start: {line: 0, column: 28},\n+               end: {line: 0, column: 29},\n+               file: absoluteFrom('/test/file.js'),\n+               text: '1'\n+             },\n+             {\n+               start: {line: 0, column: 31},\n+               end: {line: 0, column: 32},\n+               file: absoluteFrom('/test/file.js'),\n+               text: '2'\n+             },\n+           ]);\n+         });\n \n-    it('should return the substitutions from a downleveled tagged template', () => {\n-      const ast = template.ast\n-      `$localize(__makeTemplateObject(['a', 'b', 'c'], ['a', 'b', 'c']), 1, 2)` as\n-          ExpressionStatement;\n-      const call = ast.expression as CallExpression;\n-      const substitutions = unwrapSubstitutionsFromLocalizeCall(call);\n-      expect(substitutions.map(s => (s as NumericLiteral).value)).toEqual([1, 2]);\n+      it('should return the substitutions and locations from a downleveled tagged template', () => {\n+        const call = getLocalizeCall(\n+            `$localize(__makeTemplateObject(['a', 'b', 'c'], ['a', 'b', 'c']), 1, 2)`);\n+        const [substitutions, locations] = unwrapSubstitutionsFromLocalizeCall(call);\n+        expect((substitutions as NumericLiteral[]).map(s => s.value)).toEqual([1, 2]);\n+        expect(locations).toEqual([\n+          {\n+            start: {line: 0, column: 66},\n+            end: {line: 0, column: 67},\n+            file: absoluteFrom('/test/file.js'),\n+            text: '1'\n+          },\n+          {\n+            start: {line: 0, column: 69},\n+            end: {line: 0, column: 70},\n+            file: absoluteFrom('/test/file.js'),\n+            text: '2'\n+          },\n+        ]);\n+      });\n     });\n-  });\n \n-  describe('unwrapMessagePartsFromTemplateLiteral', () => {\n-    it('should return a TemplateStringsArray built from the template literal elements', () => {\n-      const taggedTemplate = getTaggedTemplate('$localize `a${1}b\\\\t${2}c`;');\n-      expect(unwrapMessagePartsFromTemplateLiteral(taggedTemplate.node.quasi.quasis))\n-          .toEqual(ɵmakeTemplateObject(['a', 'b\\t', 'c'], ['a', 'b\\\\t', 'c']));\n+    describe('unwrapMessagePartsFromTemplateLiteral', () => {\n+      it('should return a TemplateStringsArray built from the template literal elements', () => {\n+        const taggedTemplate = getTaggedTemplate('$localize `a${1}b\\\\t${2}c`;');\n+        expect(unwrapMessagePartsFromTemplateLiteral(taggedTemplate.get('quasi').get('quasis'))[0])\n+            .toEqual(ɵmakeTemplateObject(['a', 'b\\t', 'c'], ['a', 'b\\\\t', 'c']));\n+      });\n     });\n-  });\n \n-  describe('wrapInParensIfNecessary', () => {\n-    it('should wrap the expression in parentheses if it is binary', () => {\n-      const ast = template.ast`a + b` as ExpressionStatement;\n-      const wrapped = wrapInParensIfNecessary(ast.expression);\n-      expect(isParenthesizedExpression(wrapped)).toBe(true);\n-    });\n+    describe('wrapInParensIfNecessary', () => {\n+      it('should wrap the expression in parentheses if it is binary', () => {\n+        const ast = template.ast`a + b` as ExpressionStatement;\n+        const wrapped = wrapInParensIfNecessary(ast.expression);\n+        expect(isParenthesizedExpression(wrapped)).toBe(true);\n+      });\n \n-    it('should return the expression untouched if it is not binary', () => {\n-      const ast = template.ast`a` as ExpressionStatement;\n-      const wrapped = wrapInParensIfNecessary(ast.expression);\n-      expect(isParenthesizedExpression(wrapped)).toBe(false);\n+      it('should return the expression untouched if it is not binary', () => {\n+        const ast = template.ast`a` as ExpressionStatement;\n+        const wrapped = wrapInParensIfNecessary(ast.expression);\n+        expect(isParenthesizedExpression(wrapped)).toBe(false);\n+      });\n     });\n-  });\n \n-  describe('unwrapStringLiteralArray', () => {\n-    it('should return an array of string from an array expression', () => {\n-      const ast = template.ast`['a', 'b', 'c']` as ExpressionStatement;\n-      expect(unwrapStringLiteralArray(ast.expression)).toEqual(['a', 'b', 'c']);\n-    });\n+    describe('unwrapStringLiteralArray', () => {\n+      it('should return an array of string from an array expression', () => {\n+        const array = getFirstExpression(`['a', 'b', 'c']`);\n+        const [expressions, locations] = unwrapStringLiteralArray(array);\n+        expect(expressions).toEqual(['a', 'b', 'c']);\n+        expect(locations).toEqual([\n+          {\n+            start: {line: 0, column: 1},\n+            end: {line: 0, column: 4},\n+            file: absoluteFrom('/test/file.js'),\n+            text: `'a'`,\n+          },\n+          {\n+            start: {line: 0, column: 6},\n+            end: {line: 0, column: 9},\n+            file: absoluteFrom('/test/file.js'),\n+            text: `'b'`,\n+          },\n+          {\n+            start: {line: 0, column: 11},\n+            end: {line: 0, column: 14},\n+            file: absoluteFrom('/test/file.js'),\n+            text: `'c'`,\n+          },\n+        ]);\n+      });\n \n-    it('should throw an error if any elements of the array are not literal strings', () => {\n-      const ast = template.ast`['a', 2, 'c']` as ExpressionStatement;\n-      expect(() => unwrapStringLiteralArray(ast.expression))\n-          .toThrowError('Unexpected messageParts for `$localize` (expected an array of strings).');\n+      it('should throw an error if any elements of the array are not literal strings', () => {\n+        const array = getFirstExpression(`['a', 2, 'c']`);\n+        expect(() => unwrapStringLiteralArray(array))\n+            .toThrowError(\n+                'Unexpected messageParts for `$localize` (expected an array of strings).');\n+      });\n     });\n-  });\n \n-  describe('isStringLiteralArray()', () => {\n-    it('should return true if the ast is an array of strings', () => {\n-      const ast = template.ast`['a', 'b', 'c']` as ExpressionStatement;\n-      expect(isStringLiteralArray(ast.expression)).toBe(true);\n-    });\n+    describe('isStringLiteralArray()', () => {\n+      it('should return true if the ast is an array of strings', () => {\n+        const ast = template.ast`['a', 'b', 'c']` as ExpressionStatement;\n+        expect(isStringLiteralArray(ast.expression)).toBe(true);\n+      });\n \n-    it('should return false if the ast is not an array', () => {\n-      const ast = template.ast`'a'` as ExpressionStatement;\n-      expect(isStringLiteralArray(ast.expression)).toBe(false);\n-    });\n+      it('should return false if the ast is not an array', () => {\n+        const ast = template.ast`'a'` as ExpressionStatement;\n+        expect(isStringLiteralArray(ast.expression)).toBe(false);\n+      });\n \n-    it('should return false if at least on of the array elements is not a string', () => {\n-      const ast = template.ast`['a', 1, 'b']` as ExpressionStatement;\n-      expect(isStringLiteralArray(ast.expression)).toBe(false);\n+      it('should return false if at least on of the array elements is not a string', () => {\n+        const ast = template.ast`['a', 1, 'b']` as ExpressionStatement;\n+        expect(isStringLiteralArray(ast.expression)).toBe(false);\n+      });\n     });\n-  });\n \n-  describe('isArrayOfExpressions()', () => {\n-    it('should return true if all the nodes are expressions', () => {\n-      const ast = template.ast`function foo(a, b, c) {}` as FunctionDeclaration;\n-      expect(isArrayOfExpressions(ast.params)).toBe(true);\n-    });\n+    describe('isArrayOfExpressions()', () => {\n+      it('should return true if all the nodes are expressions', () => {\n+        const call = getFirstExpression<CallExpression>('foo(a, b, c);');\n+        expect(isArrayOfExpressions(call.get('arguments'))).toBe(true);\n+      });\n \n-    it('should return false if any of the nodes is not an expression', () => {\n-      const ast = template.ast`function foo(a, b, ...c) {}` as FunctionDeclaration;\n-      expect(isArrayOfExpressions(ast.params)).toBe(false);\n+      it('should return false if any of the nodes is not an expression', () => {\n+        const call = getFirstExpression<CallExpression>('foo(a, b, ...c);');\n+        expect(isArrayOfExpressions(call.get('arguments'))).toBe(false);\n+      });\n     });\n-  });\n \n-  runInEachFileSystem(() => {\n     describe('getLocation()', () => {\n       it('should return a plain object containing the start, end and file of a NodePath', () => {\n         const taggedTemplate = getTaggedTemplate('const x = $localize `message`;', {\n@@ -214,7 +325,8 @@ describe('utils', () => {\n       });\n \n       it('should return `undefined` if the NodePath has no filename', () => {\n-        const taggedTemplate = getTaggedTemplate('const x = $localize ``;', {sourceRoot: '/root'});\n+        const taggedTemplate = getTaggedTemplate(\n+            'const x = $localize ``;', {sourceRoot: '/root', filename: undefined});\n         const location = getLocation(taggedTemplate);\n         expect(location).toBeUndefined();\n       });\n@@ -224,24 +336,38 @@ describe('utils', () => {\n \n function getTaggedTemplate(\n     code: string, options?: TransformOptions): NodePath<TaggedTemplateExpression> {\n-  const {expressions, plugin} = collectExpressionsPlugin();\n-  transformSync(code, {...options, plugins: [plugin]});\n-  return expressions.find(e => e.isTaggedTemplateExpression()) as any;\n+  return getExpressions<TaggedTemplateExpression>(code, options)\n+      .find(e => e.isTaggedTemplateExpression())!;\n+}\n+\n+function getFirstExpression<T extends Expression>(\n+    code: string, options?: TransformOptions): NodePath<T> {\n+  return getExpressions<T>(code, options)[0];\n }\n \n-function collectExpressionsPlugin() {\n+function getExpressions<T extends Expression>(\n+    code: string, options?: TransformOptions): NodePath<T>[] {\n   const expressions: NodePath<Expression>[] = [];\n-  const visitor = {\n-    Expression: (path: NodePath<Expression>) => {\n-      expressions.push(path);\n-    }\n-  };\n-  return {expressions, plugin: {visitor}};\n+  transformSync(code, {\n+    code: false,\n+    filename: '/test/file.js',\n+    plugins: [{\n+      visitor: {\n+        Expression: (path: NodePath<Expression>) => {\n+          expressions.push(path);\n+        }\n+      }\n+    }],\n+    ...options\n+  });\n+  return expressions as NodePath<T>[];\n }\n \n function getLocalizeCall(code: string): NodePath<CallExpression> {\n   let callPaths: NodePath<CallExpression>[] = [];\n   transformSync(code, {\n+    code: false,\n+    filename: '/test/file.js',\n     plugins: [{\n       visitor: {\n         CallExpression(path) {"
        }
    ],
    "stats": {
        "total": 650,
        "additions": 461,
        "deletions": 189
    }
}