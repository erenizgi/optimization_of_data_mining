{
    "author": "JoostK",
    "message": "refactor(compiler-cli): remove `listLazyRoutes` operation (#43591)\n\nNow that `Route.loadChildren` no longer accepts a string, there is no\nneed for tooling to find all string-based `loadChildren` to setup lazy\nimports for them. As a result, the `listLazyRoutes` operation that\nenumerates all string-based `loadChildren` occurrences is no longer\nneeded and is therefore removed from the compiler.\n\nThe `listLazyRoutes` API remains on the `Program` interface to avoid\nbreaking external tools that may be using this method, but those tools\nshould ultimately move away from using this API.\n\nPR Close #43591",
    "sha": "94c6dee708c7952487d6d7c9ba97c760e1285437",
    "files": [
        {
            "sha": "c6032204bf0daa01307d6ff916ace3bca1ac6986",
            "filename": "goldens/circular-deps/packages.json",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/goldens%2Fcircular-deps%2Fpackages.json",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/goldens%2Fcircular-deps%2Fpackages.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fcircular-deps%2Fpackages.json?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -33,10 +33,6 @@\n     \"packages/compiler-cli/src/ngtsc/partial_evaluator/src/interface.ts\",\n     \"packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.ts\"\n   ],\n-  [\n-    \"packages/compiler-cli/src/ngtsc/routing/src/analyzer.ts\",\n-    \"packages/compiler-cli/src/ngtsc/routing/src/lazy.ts\"\n-  ],\n   [\n     \"packages/compiler-cli/src/ngtsc/scope/src/component_scope.ts\",\n     \"packages/compiler-cli/src/ngtsc/scope/src/local.ts\""
        },
        {
            "sha": "5f7771c601a93e8e8d2f99e77e6b02797f6abda7",
            "filename": "packages/compiler-cli/integrationtest/test/test_ngtools_api.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 87,
            "changes": 87,
            "blob_url": "https://github.com/angular/angular/blob/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler-cli%2Fintegrationtest%2Ftest%2Ftest_ngtools_api.ts",
            "raw_url": "https://github.com/angular/angular/raw/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler-cli%2Fintegrationtest%2Ftest%2Ftest_ngtools_api.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fintegrationtest%2Ftest%2Ftest_ngtools_api.ts?ref=361273fad5030c900c83d333a779f6edbe20c688",
            "patch": "@@ -1,87 +0,0 @@\n-#!/usr/bin/env node\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-// Must be imported first, because Angular decorators throw on load.\n-import 'reflect-metadata';\n-\n-import * as path from 'path';\n-import * as ts from 'typescript';\n-import * as assert from 'assert';\n-import {createProgram, readConfiguration} from '@angular/compiler-cli';\n-\n-/* tslint:disable:no-console  */\n-/**\n- * Main method.\n- * Standalone program that executes codegen using the ngtools API and tests that files were\n- * properly read and wrote.\n- */\n-function main() {\n-  Promise.resolve()\n-      .then(() => lazyRoutesTest())\n-      .then(() => {\n-        process.exit(0);\n-      })\n-      .catch((err) => {\n-        console.error(err.stack);\n-        process.exit(1);\n-      });\n-}\n-\n-function lazyRoutesTest() {\n-  const basePath = path.join(__dirname, '../ngtools_src');\n-  const project = path.join(basePath, 'tsconfig-build.json');\n-\n-  const config = readConfiguration(project);\n-  const host = ts.createCompilerHost(config.options, true);\n-  const program = createProgram({\n-    rootNames: config.rootNames,\n-    options: config.options,\n-    host,\n-  });\n-\n-  config.options.basePath = basePath;\n-  config.options.rootDir = basePath;\n-\n-  const lazyRoutes = program.listLazyRoutes('app.module#AppModule');\n-  const expectations: {[route: string]: string} = {\n-    './lazy.module#LazyModule': 'lazy.module.ts',\n-    './feature/feature.module#FeatureModule': 'feature/feature.module.ts',\n-    './feature/lazy-feature.module#LazyFeatureModule': 'feature/lazy-feature.module.ts',\n-    './feature.module#FeatureModule': 'feature/feature.module.ts',\n-    './lazy-feature-nested.module#LazyFeatureNestedModule': 'feature/lazy-feature-nested.module.ts',\n-    'feature2/feature2.module#Feature2Module': 'feature2/feature2.module.ts',\n-    './default.module': 'feature2/default.module.ts',\n-    'feature/feature.module#FeatureModule': 'feature/feature.module.ts'\n-  };\n-\n-  lazyRoutes.forEach(lazyRoute => {\n-    const routeName = lazyRoute.route;\n-\n-    // Normalize the module path and the expected module path so that these can be compared\n-    // on Windows where path separators are not consistent with TypeScript internal paths.\n-    const modulePath = path.normalize(lazyRoute.referencedModule.filePath);\n-    const expectedModulePath = path.normalize(path.join(basePath, expectations[routeName]));\n-\n-    assert(routeName in expectations, `Found a route that was not expected: \"${routeName}\".`);\n-    assert(\n-        modulePath === expectedModulePath,\n-        `Route \"${routeName}\" does not point to the expected absolute path ` +\n-            `\"${expectedModulePath}\". It points to \"${modulePath}\"`);\n-  });\n-\n-  // Verify that all expectations were met.\n-  assert.deepEqual(\n-      lazyRoutes.map(lazyRoute => lazyRoute.route), Object.keys(expectations),\n-      `Expected routes listed to be: \\n` +\n-          `  ${JSON.stringify(Object.keys(expectations))}\\n` +\n-          `Actual:\\n` +\n-          `  ${JSON.stringify(Object.keys(lazyRoutes))}\\n`);\n-}\n-\n-main();"
        },
        {
            "sha": "3554e8f733109957111802fa31013475341306d5",
            "filename": "packages/compiler-cli/integrationtest/tsconfig-build.json",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fintegrationtest%2Ftsconfig-build.json",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fintegrationtest%2Ftsconfig-build.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fintegrationtest%2Ftsconfig-build.json?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -31,6 +31,5 @@\n     \"src/module\",\n     \"src/bootstrap\",\n     \"test/all_spec\",\n-    \"test/test_ngtools_api\"\n   ]\n }"
        },
        {
            "sha": "15d3ed9cab6bd76f74b67b8e5e740119c457b65d",
            "filename": "packages/compiler-cli/integrationtest/tsconfig-xi18n.json",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fintegrationtest%2Ftsconfig-xi18n.json",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fintegrationtest%2Ftsconfig-xi18n.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fintegrationtest%2Ftsconfig-xi18n.json?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -23,6 +23,5 @@\n     \"src/module\",\n     \"src/bootstrap\",\n     \"test/all_spec\",\n-    \"test/test_ngtools_api\"\n   ]\n }"
        },
        {
            "sha": "a15ece7d8205ebaae67895773668c12bbbfda4fa",
            "filename": "packages/compiler-cli/ngcc/src/analysis/decoration_analyzer.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fdecoration_analyzer.ts",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fdecoration_analyzer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fdecoration_analyzer.ts?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -138,8 +138,7 @@ export class DecorationAnalyzer {\n         /* errorOnDuplicateProv */ false),\n     new NgModuleDecoratorHandler(\n         this.reflectionHost, this.evaluator, this.fullMetaReader, this.fullRegistry,\n-        this.scopeRegistry, this.referencesRegistry, this.isCore, /* routeAnalyzer */ null,\n-        this.refEmitter,\n+        this.scopeRegistry, this.referencesRegistry, this.isCore, this.refEmitter,\n         /* factoryTracker */ null, !!this.compilerOptions.annotateForClosureCompiler,\n         this.injectableRegistry, NOOP_PERF_RECORDER),\n   ];"
        },
        {
            "sha": "ae47e62486b383ebf1d60309161eda44b71a200f",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2FBUILD.bazel?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -20,7 +20,6 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/partial_evaluator\",\n         \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n-        \"//packages/compiler-cli/src/ngtsc/routing\",\n         \"//packages/compiler-cli/src/ngtsc/scope\",\n         \"//packages/compiler-cli/src/ngtsc/shims:api\",\n         \"//packages/compiler-cli/src/ngtsc/transform\","
        },
        {
            "sha": "7a745a13b20a73745b120573bfee8fb37e0c7ab2",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/ng_module.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 11,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -16,7 +16,6 @@ import {InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../m\n import {PartialEvaluator, ResolvedValue} from '../../partial_evaluator';\n import {PerfEvent, PerfRecorder} from '../../perf';\n import {ClassDeclaration, Decorator, isNamedClassDeclaration, ReflectionHost, reflectObjectLiteral, typeNodeToValueExpr} from '../../reflection';\n-import {NgModuleRouteAnalyzer} from '../../routing';\n import {LocalModuleScopeRegistry, ScopeData} from '../../scope';\n import {FactoryTracker} from '../../shims/api';\n import {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence, ResolveResult} from '../../transform';\n@@ -129,8 +128,8 @@ export class NgModuleDecoratorHandler implements\n       private metaReader: MetadataReader, private metaRegistry: MetadataRegistry,\n       private scopeRegistry: LocalModuleScopeRegistry,\n       private referencesRegistry: ReferencesRegistry, private isCore: boolean,\n-      private routeAnalyzer: NgModuleRouteAnalyzer|null, private refEmitter: ReferenceEmitter,\n-      private factoryTracker: FactoryTracker|null, private annotateForClosureCompiler: boolean,\n+      private refEmitter: ReferenceEmitter, private factoryTracker: FactoryTracker|null,\n+      private annotateForClosureCompiler: boolean,\n       private injectableRegistry: InjectableClassRegistry, private perf: PerfRecorder,\n       private localeId?: string) {}\n \n@@ -218,16 +217,14 @@ export class NgModuleDecoratorHandler implements\n     }\n \n     let importRefs: Reference<ClassDeclaration>[] = [];\n-    let rawImports: ts.Expression|null = null;\n     if (ngModule.has('imports')) {\n-      rawImports = ngModule.get('imports')!;\n+      const rawImports = ngModule.get('imports')!;\n       const importsMeta = this.evaluator.evaluate(rawImports, moduleResolvers);\n       importRefs = this.resolveTypeList(rawImports, importsMeta, name, 'imports');\n     }\n     let exportRefs: Reference<ClassDeclaration>[] = [];\n-    let rawExports: ts.Expression|null = null;\n     if (ngModule.has('exports')) {\n-      rawExports = ngModule.get('exports')!;\n+      const rawExports = ngModule.get('exports')!;\n       const exportsMeta = this.evaluator.evaluate(rawExports, moduleResolvers);\n       exportRefs = this.resolveTypeList(rawExports, exportsMeta, name, 'exports');\n       this.referencesRegistry.add(node, ...exportRefs);\n@@ -331,10 +328,6 @@ export class NgModuleDecoratorHandler implements\n       injectorImports.push(new WrappedNodeExpr(ngModule.get('imports')!));\n     }\n \n-    if (this.routeAnalyzer !== null) {\n-      this.routeAnalyzer.add(node.getSourceFile(), name, rawImports, rawExports, rawProviders);\n-    }\n-\n     const injectorMetadata: R3InjectorMetadata = {\n       name,\n       type,"
        },
        {
            "sha": "258564afef97b1e324339c6d37645912cb57fd72",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/ng_module_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fng_module_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fng_module_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fng_module_spec.ts?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -71,7 +71,7 @@ runInEachFileSystem(() => {\n \n       const handler = new NgModuleDecoratorHandler(\n           reflectionHost, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry,\n-          /* isCore */ false, /* routeAnalyzer */ null, refEmitter, /* factoryTracker */ null,\n+          /* isCore */ false, refEmitter, /* factoryTracker */ null,\n           /* annotateForClosureCompiler */ false, injectableRegistry, NOOP_PERF_RECORDER);\n       const TestModule =\n           getDeclaration(program, _('/entry.ts'), 'TestModule', isNamedClassDeclaration);"
        },
        {
            "sha": "d1d151c0246e7cac3cb4cb78044d20eda54e1419",
            "filename": "packages/compiler-cli/src/ngtsc/core/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2FBUILD.bazel?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -28,7 +28,6 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/program_driver\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n         \"//packages/compiler-cli/src/ngtsc/resource\",\n-        \"//packages/compiler-cli/src/ngtsc/routing\",\n         \"//packages/compiler-cli/src/ngtsc/scope\",\n         \"//packages/compiler-cli/src/ngtsc/shims\",\n         \"//packages/compiler-cli/src/ngtsc/shims:api\","
        },
        {
            "sha": "7ebae6a82ff9e03afaa73ae124db9b4101369326",
            "filename": "packages/compiler-cli/src/ngtsc/core/api/src/interfaces.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fapi%2Fsrc%2Finterfaces.ts",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fapi%2Fsrc%2Finterfaces.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fapi%2Fsrc%2Finterfaces.ts?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -108,9 +108,3 @@ export interface TransformResourceResult {\n  */\n export interface ExtendedTsCompilerHost extends ts.CompilerHost, Partial<ResourceHost>,\n                                                 Partial<UnifiedModulesHost> {}\n-\n-export interface LazyRoute {\n-  route: string;\n-  module: {name: string, filePath: string};\n-  referencedModule: {name: string, filePath: string};\n-}"
        },
        {
            "sha": "139d7bb76b49b4cfc5b127164094f7ff8f921e8d",
            "filename": "packages/compiler-cli/src/ngtsc/core/src/compiler.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 50,
            "changes": 54,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -23,7 +23,6 @@ import {ActivePerfRecorder, DelegatingPerfRecorder, PerfCheckpoint, PerfEvent, P\n import {FileUpdate, ProgramDriver, UpdateMode} from '../../program_driver';\n import {DeclarationNode, isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\n import {AdapterResourceLoader} from '../../resource';\n-import {entryPointKeyFor, NgModuleRouteAnalyzer} from '../../routing';\n import {ComponentScopeReader, LocalModuleScopeRegistry, MetadataDtsModuleScopeResolver, TypeCheckScopeRegistry} from '../../scope';\n import {generatedFactoryTransform} from '../../shims';\n import {ivySwitchTransform} from '../../switch';\n@@ -34,9 +33,9 @@ import {ExtendedTemplateCheckerImpl} from '../../typecheck/extended';\n import {ExtendedTemplateChecker, TemplateCheck} from '../../typecheck/extended/api';\n import {InvalidBananaInBoxCheck} from '../../typecheck/extended/checks/invalid_banana_in_box';\n import {NullishCoalescingNotNullableCheck} from '../../typecheck/extended/checks/nullish_coalescing_not_nullable';\n-import {getSourceFileOrNull, isDtsPath, resolveModuleName, toUnredirectedSourceFile} from '../../util/src/typescript';\n+import {getSourceFileOrNull, isDtsPath, toUnredirectedSourceFile} from '../../util/src/typescript';\n import {Xi18nContext} from '../../xi18n';\n-import {LazyRoute, NgCompilerAdapter, NgCompilerOptions} from '../api';\n+import {NgCompilerAdapter, NgCompilerOptions} from '../api';\n \n /**\n  * State information about a compilation which is only generated once some data is requested from\n@@ -50,7 +49,6 @@ interface LazyCompilationState {\n   scopeRegistry: LocalModuleScopeRegistry;\n   typeCheckScopeRegistry: TypeCheckScopeRegistry;\n   exportReferenceGraph: ReferenceGraph|null;\n-  routeAnalyzer: NgModuleRouteAnalyzer;\n   dtsTransforms: DtsTransformRegistry;\n   aliasingHost: AliasingHost|null;\n   refEmitter: ReferenceEmitter;\n@@ -607,47 +605,6 @@ export class NgCompiler {\n     });\n   }\n \n-  /**\n-   * List lazy routes detected during analysis.\n-   *\n-   * This can be called for one specific route, or to retrieve all top-level routes.\n-   */\n-  listLazyRoutes(entryRoute?: string): LazyRoute[] {\n-    if (entryRoute) {\n-      // htts://github.com/angular/angular/blob/50732e156/packages/compiler-cli/src/transformers/compiler_host.ts#L175-L188).\n-      //\n-      // `@angular/cli` will always call this API with an absolute path, so the resolution step is\n-      // not necessary, but keeping it backwards compatible in case someone else is using the API.\n-\n-      // Relative entry paths are disallowed.\n-      if (entryRoute.startsWith('.')) {\n-        throw new Error(`Failed to list lazy routes: Resolution of relative paths (${\n-            entryRoute}) is not supported.`);\n-      }\n-\n-      // Non-relative entry paths fall into one of the following categories:\n-      // - Absolute system paths (e.g. `/foo/bar/my-project/my-module`), which are unaffected by the\n-      //   logic below.\n-      // - Paths to enternal modules (e.g. `some-lib`).\n-      // - Paths mapped to directories in `tsconfig.json` (e.g. `shared/my-module`).\n-      //   (See https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping.)\n-      //\n-      // In all cases above, the `containingFile` argument is ignored, so we can just take the first\n-      // of the root files.\n-      const containingFile = this.inputProgram.getRootFileNames()[0];\n-      const [entryPath, moduleName] = entryRoute.split('#');\n-      const resolvedModule =\n-          resolveModuleName(entryPath, containingFile, this.options, this.adapter, null);\n-\n-      if (resolvedModule) {\n-        entryRoute = entryPointKeyFor(resolvedModule.resolvedFileName, moduleName);\n-      }\n-    }\n-\n-    const compilation = this.ensureAnalyzed();\n-    return compilation.routeAnalyzer.listLazyRoutes(entryRoute);\n-  }\n-\n   /**\n    * Fetch transformers and other information which is necessary for a consumer to `emit` the\n    * program with Angular-added definitions.\n@@ -1037,8 +994,6 @@ export class NgCompiler {\n       referencesRegistry = new NoopReferencesRegistry();\n     }\n \n-    const routeAnalyzer = new NgModuleRouteAnalyzer(this.moduleResolver, evaluator);\n-\n     const dtsTransforms = new DtsTransformRegistry();\n \n     const isCore = isAngularCorePackage(this.inputProgram);\n@@ -1088,8 +1043,8 @@ export class NgCompiler {\n           this.delegatingPerfRecorder),\n       new NgModuleDecoratorHandler(\n           reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, isCore,\n-          routeAnalyzer, refEmitter, this.adapter.factoryTracker, this.closureCompilerEnabled,\n-          injectableRegistry, this.delegatingPerfRecorder, this.options.i18nInLocale),\n+          refEmitter, this.adapter.factoryTracker, this.closureCompilerEnabled, injectableRegistry,\n+          this.delegatingPerfRecorder, this.options.i18nInLocale),\n     ];\n \n     const traitCompiler = new TraitCompiler(\n@@ -1124,7 +1079,6 @@ export class NgCompiler {\n       scopeRegistry,\n       dtsTransforms,\n       exportReferenceGraph,\n-      routeAnalyzer,\n       metaReader,\n       typeCheckScopeRegistry,\n       aliasingHost,"
        },
        {
            "sha": "a200d0fc68de133e593619ac229c8946bf1bb981",
            "filename": "packages/compiler-cli/src/ngtsc/program.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -220,7 +220,7 @@ export class NgtscProgram implements api.Program {\n   }\n \n   listLazyRoutes(entryRoute?: string|undefined): api.LazyRoute[] {\n-    return this.compiler.listLazyRoutes(entryRoute);\n+    return [];\n   }\n \n   private emitXi18n(): void {"
        },
        {
            "sha": "84d14c119ba1c535f43aa38c7e4beed1b65bf541",
            "filename": "packages/compiler-cli/src/ngtsc/routing/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2FBUILD.bazel?ref=361273fad5030c900c83d333a779f6edbe20c688",
            "patch": "@@ -1,18 +0,0 @@\n-package(default_visibility = [\"//visibility:public\"])\n-\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"routing\",\n-    srcs = [\"index.ts\"] + glob([\n-        \"src/**/*.ts\",\n-    ]),\n-    module_name = \"@angular/compiler-cli/src/ngtsc/routing\",\n-    deps = [\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli/src/ngtsc/imports\",\n-        \"//packages/compiler-cli/src/ngtsc/partial_evaluator\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "7f0fc5ae0a0c91a3e29ecd014434cc3d5e594b12",
            "filename": "packages/compiler-cli/src/ngtsc/routing/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 12,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2Findex.ts?ref=361273fad5030c900c83d333a779f6edbe20c688",
            "patch": "@@ -1,12 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-/// <reference types=\"node\" />\n-\n-export {LazyRoute, NgModuleRouteAnalyzer} from './src/analyzer';\n-export {entryPointKeyFor} from './src/route';"
        },
        {
            "sha": "a148c39652db24c7565923e2e7db5c345a54da25",
            "filename": "packages/compiler-cli/src/ngtsc/routing/src/analyzer.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 103,
            "changes": 103,
            "blob_url": "https://github.com/angular/angular/blob/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2Fsrc%2Fanalyzer.ts",
            "raw_url": "https://github.com/angular/angular/raw/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2Fsrc%2Fanalyzer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2Fsrc%2Fanalyzer.ts?ref=361273fad5030c900c83d333a779f6edbe20c688",
            "patch": "@@ -1,103 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as ts from 'typescript';\n-\n-import {ModuleResolver} from '../../imports';\n-import {PartialEvaluator} from '../../partial_evaluator';\n-\n-import {scanForCandidateTransitiveModules, scanForRouteEntryPoints} from './lazy';\n-import {entryPointKeyFor, RouterEntryPointManager} from './route';\n-\n-export interface NgModuleRawRouteData {\n-  sourceFile: ts.SourceFile;\n-  moduleName: string;\n-  imports: ts.Expression|null;\n-  exports: ts.Expression|null;\n-  providers: ts.Expression|null;\n-}\n-\n-export interface LazyRoute {\n-  route: string;\n-  module: {name: string, filePath: string};\n-  referencedModule: {name: string, filePath: string};\n-}\n-\n-export class NgModuleRouteAnalyzer {\n-  private modules = new Map<string, NgModuleRawRouteData>();\n-  private entryPointManager: RouterEntryPointManager;\n-\n-  constructor(moduleResolver: ModuleResolver, private evaluator: PartialEvaluator) {\n-    this.entryPointManager = new RouterEntryPointManager(moduleResolver);\n-  }\n-\n-  add(sourceFile: ts.SourceFile, moduleName: string, imports: ts.Expression|null,\n-      exports: ts.Expression|null, providers: ts.Expression|null): void {\n-    const key = entryPointKeyFor(sourceFile.fileName, moduleName);\n-    if (this.modules.has(key)) {\n-      throw new Error(`Double route analyzing for '${key}'.`);\n-    }\n-    this.modules.set(key, {\n-      sourceFile,\n-      moduleName,\n-      imports,\n-      exports,\n-      providers,\n-    });\n-  }\n-\n-  listLazyRoutes(entryModuleKey?: string|undefined): LazyRoute[] {\n-    if ((entryModuleKey !== undefined) && !this.modules.has(entryModuleKey)) {\n-      throw new Error(`Failed to list lazy routes: Unknown module '${entryModuleKey}'.`);\n-    }\n-\n-    const routes: LazyRoute[] = [];\n-    const scannedModuleKeys = new Set<string>();\n-    const pendingModuleKeys = entryModuleKey ? [entryModuleKey] : Array.from(this.modules.keys());\n-\n-    // When listing lazy routes for a specific entry module, we need to recursively extract\n-    // \"transitive\" routes from imported/exported modules. This is not necessary when listing all\n-    // lazy routes, because all analyzed modules will be scanned anyway.\n-    const scanRecursively = entryModuleKey !== undefined;\n-\n-    while (pendingModuleKeys.length > 0) {\n-      const key = pendingModuleKeys.pop()!;\n-\n-      if (scannedModuleKeys.has(key)) {\n-        continue;\n-      } else {\n-        scannedModuleKeys.add(key);\n-      }\n-\n-      const data = this.modules.get(key)!;\n-      const entryPoints = scanForRouteEntryPoints(\n-          data.sourceFile, data.moduleName, data, this.entryPointManager, this.evaluator);\n-\n-      routes.push(...entryPoints.map(entryPoint => ({\n-                                       route: entryPoint.loadChildren,\n-                                       module: entryPoint.from,\n-                                       referencedModule: entryPoint.resolvedTo,\n-                                     })));\n-\n-      if (scanRecursively) {\n-        pendingModuleKeys.push(\n-            ...[\n-                // Scan the retrieved lazy route entry points.\n-                ...entryPoints.map(\n-                    ({resolvedTo}) => entryPointKeyFor(resolvedTo.filePath, resolvedTo.moduleName)),\n-                // Scan the current module's imported modules.\n-                ...scanForCandidateTransitiveModules(data.imports, this.evaluator),\n-                // Scan the current module's exported modules.\n-                ...scanForCandidateTransitiveModules(data.exports, this.evaluator),\n-        ].filter(key => this.modules.has(key)));\n-      }\n-    }\n-\n-    return routes;\n-  }\n-}"
        },
        {
            "sha": "a8cd76d88a5f2935522f26e99c3804942abc78c8",
            "filename": "packages/compiler-cli/src/ngtsc/routing/src/lazy.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 200,
            "changes": 200,
            "blob_url": "https://github.com/angular/angular/blob/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2Fsrc%2Flazy.ts",
            "raw_url": "https://github.com/angular/angular/raw/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2Fsrc%2Flazy.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2Fsrc%2Flazy.ts?ref=361273fad5030c900c83d333a779f6edbe20c688",
            "patch": "@@ -1,200 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as ts from 'typescript';\n-\n-import {Reference} from '../../imports';\n-import {ForeignFunctionResolver, PartialEvaluator, ResolvedValue} from '../../partial_evaluator';\n-\n-import {NgModuleRawRouteData} from './analyzer';\n-import {entryPointKeyFor, RouterEntryPoint, RouterEntryPointManager} from './route';\n-\n-const ROUTES_MARKER = '__ngRoutesMarker__';\n-\n-export interface LazyRouteEntry {\n-  loadChildren: string;\n-  from: RouterEntryPoint;\n-  resolvedTo: RouterEntryPoint;\n-}\n-\n-export function scanForCandidateTransitiveModules(\n-    expr: ts.Expression|null, evaluator: PartialEvaluator): string[] {\n-  if (expr === null) {\n-    return [];\n-  }\n-\n-  const candidateModuleKeys: string[] = [];\n-  const entries = evaluator.evaluate(expr);\n-\n-  function recursivelyAddModules(entry: ResolvedValue) {\n-    if (Array.isArray(entry)) {\n-      for (const e of entry) {\n-        recursivelyAddModules(e);\n-      }\n-    } else if (entry instanceof Map) {\n-      if (entry.has('ngModule')) {\n-        recursivelyAddModules(entry.get('ngModule')!);\n-      }\n-    } else if ((entry instanceof Reference) && hasIdentifier(entry.node)) {\n-      const filePath = entry.node.getSourceFile().fileName;\n-      const moduleName = entry.node.name.text;\n-      candidateModuleKeys.push(entryPointKeyFor(filePath, moduleName));\n-    }\n-  }\n-\n-  recursivelyAddModules(entries);\n-  return candidateModuleKeys;\n-}\n-\n-export function scanForRouteEntryPoints(\n-    ngModule: ts.SourceFile, moduleName: string, data: NgModuleRawRouteData,\n-    entryPointManager: RouterEntryPointManager, evaluator: PartialEvaluator): LazyRouteEntry[] {\n-  const loadChildrenIdentifiers: string[] = [];\n-  const from = entryPointManager.fromNgModule(ngModule, moduleName);\n-  if (data.providers !== null) {\n-    loadChildrenIdentifiers.push(...scanForProviders(data.providers, evaluator));\n-  }\n-  if (data.imports !== null) {\n-    loadChildrenIdentifiers.push(...scanForRouterModuleUsage(data.imports, evaluator));\n-  }\n-  if (data.exports !== null) {\n-    loadChildrenIdentifiers.push(...scanForRouterModuleUsage(data.exports, evaluator));\n-  }\n-  const routes: LazyRouteEntry[] = [];\n-  for (const loadChildren of loadChildrenIdentifiers) {\n-    const resolvedTo = entryPointManager.resolveLoadChildrenIdentifier(loadChildren, ngModule);\n-    if (resolvedTo !== null) {\n-      routes.push({\n-        loadChildren,\n-        from,\n-        resolvedTo,\n-      });\n-    }\n-  }\n-  return routes;\n-}\n-\n-function scanForProviders(expr: ts.Expression, evaluator: PartialEvaluator): string[] {\n-  const loadChildrenIdentifiers: string[] = [];\n-  const providers = evaluator.evaluate(expr);\n-\n-  function recursivelyAddProviders(provider: ResolvedValue): void {\n-    if (Array.isArray(provider)) {\n-      for (const entry of provider) {\n-        recursivelyAddProviders(entry);\n-      }\n-    } else if (provider instanceof Map) {\n-      if (provider.has('provide') && provider.has('useValue')) {\n-        const provide = provider.get('provide');\n-        const useValue = provider.get('useValue');\n-        if (isRouteToken(provide) && Array.isArray(useValue)) {\n-          loadChildrenIdentifiers.push(...scanForLazyRoutes(useValue));\n-        }\n-      }\n-    }\n-  }\n-\n-  recursivelyAddProviders(providers);\n-  return loadChildrenIdentifiers;\n-}\n-\n-function scanForRouterModuleUsage(expr: ts.Expression, evaluator: PartialEvaluator): string[] {\n-  const loadChildrenIdentifiers: string[] = [];\n-  const imports = evaluator.evaluate(expr, routerModuleFFR);\n-\n-  function recursivelyAddRoutes(imp: ResolvedValue) {\n-    if (Array.isArray(imp)) {\n-      for (const entry of imp) {\n-        recursivelyAddRoutes(entry);\n-      }\n-    } else if (imp instanceof Map) {\n-      if (imp.has(ROUTES_MARKER) && imp.has('routes')) {\n-        const routes = imp.get('routes');\n-        if (Array.isArray(routes)) {\n-          loadChildrenIdentifiers.push(...scanForLazyRoutes(routes));\n-        }\n-      }\n-    }\n-  }\n-\n-  recursivelyAddRoutes(imports);\n-  return loadChildrenIdentifiers;\n-}\n-\n-function scanForLazyRoutes(routes: ResolvedValue[]): string[] {\n-  const loadChildrenIdentifiers: string[] = [];\n-\n-  function recursivelyScanRoutes(routes: ResolvedValue[]): void {\n-    for (let route of routes) {\n-      if (!(route instanceof Map)) {\n-        continue;\n-      }\n-      if (route.has('loadChildren')) {\n-        const loadChildren = route.get('loadChildren');\n-        if (typeof loadChildren === 'string') {\n-          loadChildrenIdentifiers.push(loadChildren);\n-        }\n-      } else if (route.has('children')) {\n-        const children = route.get('children');\n-        if (Array.isArray(children)) {\n-          recursivelyScanRoutes(children);\n-        }\n-      }\n-    }\n-  }\n-\n-  recursivelyScanRoutes(routes);\n-  return loadChildrenIdentifiers;\n-}\n-\n-/**\n- * A foreign function resolver that converts `RouterModule.forRoot/forChild(X)` to a special object\n- * of the form `{__ngRoutesMarker__: true, routes: X}`.\n- *\n- * These objects are then recognizable inside the larger set of imports/exports.\n- */\n-const routerModuleFFR: ForeignFunctionResolver =\n-    function routerModuleFFR(\n-        ref: Reference<ts.FunctionDeclaration|ts.MethodDeclaration|ts.FunctionExpression>,\n-        args: ReadonlyArray<ts.Expression>): ts.Expression|null {\n-  if (!isMethodNodeReference(ref) || !ts.isClassDeclaration(ref.node.parent)) {\n-    return null;\n-  } else if (\n-      ref.bestGuessOwningModule === null ||\n-      ref.bestGuessOwningModule.specifier !== '@angular/router') {\n-    return null;\n-  } else if (ref.node.parent.name === undefined || ref.node.parent.name.text !== 'RouterModule') {\n-    return null;\n-  } else if (\n-      !ts.isIdentifier(ref.node.name) ||\n-      (ref.node.name.text !== 'forRoot' && ref.node.name.text !== 'forChild')) {\n-    return null;\n-  }\n-\n-  const routes = args[0];\n-  return ts.createObjectLiteral([\n-    ts.createPropertyAssignment(ROUTES_MARKER, ts.createTrue()),\n-    ts.createPropertyAssignment('routes', routes),\n-  ]);\n-};\n-\n-function hasIdentifier(node: ts.Node): node is ts.Node&{name: ts.Identifier} {\n-  const node_ = node as ts.NamedDeclaration;\n-  return (node_.name !== undefined) && ts.isIdentifier(node_.name);\n-}\n-\n-function isMethodNodeReference(\n-    ref: Reference<ts.FunctionDeclaration|ts.MethodDeclaration|ts.FunctionExpression>):\n-    ref is Reference<ts.MethodDeclaration> {\n-  return ts.isMethodDeclaration(ref.node);\n-}\n-\n-function isRouteToken(ref: ResolvedValue): boolean {\n-  return ref instanceof Reference && ref.bestGuessOwningModule !== null &&\n-      ref.bestGuessOwningModule.specifier === '@angular/router' && ref.debugName === 'ROUTES';\n-}"
        },
        {
            "sha": "3f35338ed3ec0485b5d29630bb88b45b76f16e7c",
            "filename": "packages/compiler-cli/src/ngtsc/routing/src/route.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 65,
            "changes": 65,
            "blob_url": "https://github.com/angular/angular/blob/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2Fsrc%2Froute.ts",
            "raw_url": "https://github.com/angular/angular/raw/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2Fsrc%2Froute.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Frouting%2Fsrc%2Froute.ts?ref=361273fad5030c900c83d333a779f6edbe20c688",
            "patch": "@@ -1,65 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as ts from 'typescript';\n-\n-import {ModuleResolver} from '../../imports';\n-\n-export abstract class RouterEntryPoint {\n-  abstract readonly filePath: string;\n-\n-  abstract readonly moduleName: string;\n-\n-  // Alias of moduleName for compatibility with what `ngtools_api` returned.\n-  abstract readonly name: string;\n-}\n-\n-class RouterEntryPointImpl implements RouterEntryPoint {\n-  constructor(readonly filePath: string, readonly moduleName: string) {}\n-\n-  get name(): string {\n-    return this.moduleName;\n-  }\n-\n-  // For debugging purposes.\n-  toString(): string {\n-    return `RouterEntryPoint(name: ${this.name}, filePath: ${this.filePath})`;\n-  }\n-}\n-\n-export class RouterEntryPointManager {\n-  private map = new Map<string, RouterEntryPoint>();\n-\n-  constructor(private moduleResolver: ModuleResolver) {}\n-\n-  resolveLoadChildrenIdentifier(loadChildrenIdentifier: string, context: ts.SourceFile):\n-      RouterEntryPoint|null {\n-    const [relativeFile, moduleName] = loadChildrenIdentifier.split('#');\n-    if (moduleName === undefined) {\n-      return null;\n-    }\n-    const resolvedSf = this.moduleResolver.resolveModule(relativeFile, context.fileName);\n-    if (resolvedSf === null) {\n-      return null;\n-    }\n-    return this.fromNgModule(resolvedSf, moduleName);\n-  }\n-\n-  fromNgModule(sf: ts.SourceFile, moduleName: string): RouterEntryPoint {\n-    const key = entryPointKeyFor(sf.fileName, moduleName);\n-    if (!this.map.has(key)) {\n-      this.map.set(key, new RouterEntryPointImpl(sf.fileName, moduleName));\n-    }\n-    return this.map.get(key)!;\n-  }\n-}\n-\n-export function entryPointKeyFor(filePath: string, moduleName: string): string {\n-  // Drop the extension to be compatible with how cli calls `listLazyRoutes(entryRoute)`.\n-  return `${filePath.replace(/\\.tsx?$/i, '')}#${moduleName}`;\n-}"
        },
        {
            "sha": "33d98894545a4a9d1807464caa33f372bbadc81c",
            "filename": "packages/compiler-cli/src/transformers/api.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fapi.ts?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -268,10 +268,7 @@ export interface Program {\n   loadNgStructureAsync(): Promise<void>;\n \n   /**\n-   * Returns the lazy routes in the program.\n-   * @param entryRoute A reference to an NgModule like `someModule#name`. If given,\n-   *              will recursively analyze routes starting from this symbol only.\n-   *              Otherwise will list all routes for all NgModules in the program/\n+   * This method is obsolete and always returns an empty array.\n    */\n   listLazyRoutes(entryRoute?: string): LazyRoute[];\n "
        },
        {
            "sha": "104f409d88eace06e3112fa4efceb7340b868b60",
            "filename": "packages/compiler-cli/src/transformers/program.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fprogram.ts",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fprogram.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fprogram.ts?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -250,9 +250,7 @@ class AngularCompilerProgram implements Program {\n   }\n \n   listLazyRoutes(route?: string): LazyRoute[] {\n-    // Note: Don't analyzedModules if a route is given\n-    // to be fast enough.\n-    return this.compiler.listLazyRoutes(route, route ? undefined : this.analyzedModules);\n+    return [];\n   }\n \n   emit(parameters: {"
        },
        {
            "sha": "3e3f209e70ea1835863343aebe9a1737c178b917",
            "filename": "packages/compiler-cli/test/ngtsc/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2FBUILD.bazel?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -12,7 +12,6 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/file_system/testing\",\n         \"//packages/compiler-cli/src/ngtsc/indexer\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n-        \"//packages/compiler-cli/src/ngtsc/routing\",\n         \"//packages/compiler-cli/src/ngtsc/testing\",\n         \"//packages/compiler-cli/src/ngtsc/util\",\n         \"//packages/compiler-cli/test:test_utils\","
        },
        {
            "sha": "a8b608ed11584d71cfb28c10835828da25085eb6",
            "filename": "packages/compiler-cli/test/ngtsc/env.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 8,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fenv.ts",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fenv.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fenv.ts?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -18,7 +18,6 @@ import {Folder, MockFileSystem} from '../../src/ngtsc/file_system/testing';\n import {IndexedComponent} from '../../src/ngtsc/indexer';\n import {NgtscProgram} from '../../src/ngtsc/program';\n import {DeclarationNode} from '../../src/ngtsc/reflection';\n-import {LazyRoute} from '../../src/ngtsc/routing';\n import {NgtscTestCompilerHost} from '../../src/ngtsc/testing';\n import {setWrapHostForTest} from '../../src/transformers/compiler_host';\n \n@@ -263,13 +262,6 @@ export class NgtscTestEnvironment {\n     return defaultGatherDiagnostics(program as api.Program) as ts.Diagnostic[];\n   }\n \n-  driveRoutes(entryPoint?: string): LazyRoute[] {\n-    const {rootNames, options} = readNgcCommandLineAndConfiguration(this.commandLineArgs);\n-    const host = createCompilerHost({options});\n-    const program = createProgram({rootNames, host, options});\n-    return program.listLazyRoutes(entryPoint);\n-  }\n-\n   driveIndexer(): Map<DeclarationNode, IndexedComponent> {\n     const {rootNames, options} = readNgcCommandLineAndConfiguration(this.commandLineArgs);\n     const host = createCompilerHost({options});"
        },
        {
            "sha": "d3ebe2f2af71a71aaa3a709e557b03937eee84d5",
            "filename": "packages/compiler-cli/test/ngtsc/ngtsc_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 621,
            "changes": 621,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -12,7 +12,6 @@ import * as ts from 'typescript';\n import {ErrorCode, ngErrorCode} from '../../src/ngtsc/diagnostics';\n import {absoluteFrom} from '../../src/ngtsc/file_system';\n import {runInEachFileSystem} from '../../src/ngtsc/file_system/testing';\n-import {LazyRoute} from '../../src/ngtsc/routing';\n import {loadStandardTestFiles} from '../../src/ngtsc/testing';\n import {restoreTypeScriptVersionForTesting, setTypeScriptVersionForTesting} from '../../src/typescript_support';\n \n@@ -6238,626 +6237,6 @@ function allTests(os: string) {\n          });\n     });\n \n-    describe('listLazyRoutes()', () => {\n-      // clang-format off\n-    const lazyRouteMatching = (\n-      route: string, fromModulePath: RegExp, fromModuleName: string, toModulePath: RegExp,\n-      toModuleName: string) => {\n-      return {\n-        route,\n-        module: jasmine.objectContaining({\n-          name: fromModuleName,\n-          filePath: jasmine.stringMatching(fromModulePath),\n-        }),\n-        referencedModule: jasmine.objectContaining({\n-          name: toModuleName,\n-          filePath: jasmine.stringMatching(toModulePath),\n-        }),\n-      } as unknown as LazyRoute;\n-    };\n-      // clang-format on\n-\n-      beforeEach(() => {\n-        env.write('node_modules/@angular/router/index.d.ts', `\n-        import {ModuleWithProviders, NgModuleDeclaration as NgModuleDeclaration} from '@angular/core';\n-\n-        export declare var ROUTES;\n-        export declare class RouterModule {\n-          static forRoot(arg1: any, arg2: any): ModuleWithProviders<RouterModule>;\n-          static forChild(arg1: any): ModuleWithProviders<RouterModule>;\n-          static mod: NgModuleDeclaration<RouterModule, never, never, never>;\n-        }\n-      `);\n-      });\n-\n-      describe('when called without arguments', () => {\n-        it('should list all routes', () => {\n-          env.write('test.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forRoot([\n-                {path: '1', loadChildren: './lazy/lazy-1#Lazy1Module'},\n-                {path: '2', loadChildren: './lazy/lazy-2#Lazy2Module'},\n-              ]),\n-            ],\n-          })\n-          export class TestModule {}\n-        `);\n-          env.write('lazy/lazy-1.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class Lazy1Module {}\n-        `);\n-          env.write('lazy/lazy-2.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forChild([\n-                {path: '3', loadChildren: './lazy-3#Lazy3Module'},\n-              ]),\n-            ],\n-          })\n-          export class Lazy2Module {}\n-        `);\n-          env.write('lazy/lazy-3.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class Lazy3Module {}\n-        `);\n-\n-          const routes = env.driveRoutes();\n-          expect(routes).toEqual([\n-            lazyRouteMatching(\n-                './lazy-3#Lazy3Module', /\\/lazy\\/lazy-2\\.ts$/, 'Lazy2Module', /\\/lazy\\/lazy-3\\.ts$/,\n-                'Lazy3Module'),\n-            lazyRouteMatching(\n-                './lazy/lazy-1#Lazy1Module', /\\/test\\.ts$/, 'TestModule', /\\/lazy\\/lazy-1\\.ts$/,\n-                'Lazy1Module'),\n-            lazyRouteMatching(\n-                './lazy/lazy-2#Lazy2Module', /\\/test\\.ts$/, 'TestModule', /\\/lazy\\/lazy-2\\.ts$/,\n-                'Lazy2Module'),\n-          ]);\n-        });\n-\n-        it('should detect lazy routes in simple children routes', () => {\n-          env.write('test.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @Component({\n-            selector: 'foo',\n-            template: '<div>Foo</div>'\n-          })\n-          class FooCmp {}\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forRoot([\n-                {path: '', children: [\n-                  {path: 'foo', component: FooCmp},\n-                  {path: 'lazy', loadChildren: './lazy#LazyModule'}\n-                ]},\n-              ]),\n-            ],\n-          })\n-          export class TestModule {}\n-        `);\n-          env.write('lazy.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({})\n-          export class LazyModule {}\n-        `);\n-\n-          const routes = env.driveRoutes();\n-          expect(routes).toEqual([\n-            lazyRouteMatching(\n-                './lazy#LazyModule', /\\/test\\.ts$/, 'TestModule', /\\/lazy\\.ts$/, 'LazyModule'),\n-          ]);\n-        });\n-\n-        it('should detect lazy routes in all root directories', () => {\n-          env.tsconfig({}, ['./foo/other-root-dir', './bar/other-root-dir']);\n-          env.write('src/test.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forRoot([\n-                {path: '', loadChildren: './lazy-foo#LazyFooModule'},\n-              ]),\n-            ],\n-          })\n-          export class TestModule {}\n-        `);\n-          env.write('foo/other-root-dir/src/lazy-foo.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forChild([\n-                {path: '', loadChildren: './lazy-bar#LazyBarModule'},\n-              ]),\n-            ],\n-          })\n-          export class LazyFooModule {}\n-        `);\n-          env.write('bar/other-root-dir/src/lazy-bar.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forChild([\n-                {path: '', loadChildren: './lazier-bar#LazierBarModule'},\n-              ]),\n-            ],\n-          })\n-          export class LazyBarModule {}\n-        `);\n-          env.write('bar/other-root-dir/src/lazier-bar.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class LazierBarModule {}\n-        `);\n-\n-          const routes = env.driveRoutes();\n-\n-          expect(routes).toEqual([\n-            lazyRouteMatching(\n-                './lazy-foo#LazyFooModule', /\\/test\\.ts$/, 'TestModule',\n-                /\\/foo\\/other-root-dir\\/src\\/lazy-foo\\.ts$/, 'LazyFooModule'),\n-            lazyRouteMatching(\n-                './lazy-bar#LazyBarModule', /\\/foo\\/other-root-dir\\/src\\/lazy-foo\\.ts$/,\n-                'LazyFooModule', /\\/bar\\/other-root-dir\\/src\\/lazy-bar\\.ts$/, 'LazyBarModule'),\n-            lazyRouteMatching(\n-                './lazier-bar#LazierBarModule', /\\/bar\\/other-root-dir\\/src\\/lazy-bar\\.ts$/,\n-                'LazyBarModule', /\\/bar\\/other-root-dir\\/src\\/lazier-bar\\.ts$/, 'LazierBarModule'),\n-          ]);\n-        });\n-      });\n-\n-      describe('when called with entry module', () => {\n-        it('should throw if the entry module hasn\\'t been analyzed', () => {\n-          env.write('test.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forChild([\n-                {path: '', loadChildren: './lazy#LazyModule'},\n-              ]),\n-            ],\n-          })\n-          export class TestModule {}\n-        `);\n-\n-          const entryModule1 = absoluteFrom('/test#TestModule');\n-          const entryModule2 = absoluteFrom('/not-test#TestModule');\n-          const entryModule3 = absoluteFrom('/test#NotTestModule');\n-\n-          expect(() => env.driveRoutes(entryModule1)).not.toThrow();\n-          expect(() => env.driveRoutes(entryModule2))\n-              .toThrowError(`Failed to list lazy routes: Unknown module '${entryModule2}'.`);\n-          expect(() => env.driveRoutes(entryModule3))\n-              .toThrowError(`Failed to list lazy routes: Unknown module '${entryModule3}'.`);\n-        });\n-\n-        it('should list all transitive lazy routes', () => {\n-          env.write('test.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-          import {Test1Module as Test1ModuleRenamed} from './test-1';\n-          import {Test2Module} from './test-2';\n-\n-          @NgModule({\n-            exports: [\n-              Test1ModuleRenamed,\n-            ],\n-            imports: [\n-              Test2Module,\n-              RouterModule.forRoot([\n-                {path: '', loadChildren: './lazy/lazy#LazyModule'},\n-              ]),\n-            ],\n-          })\n-          export class TestModule {}\n-        `);\n-          env.write('test-1.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forChild([\n-                {path: 'one', loadChildren: './lazy-1/lazy-1#Lazy1Module'},\n-              ]),\n-            ],\n-          })\n-          export class Test1Module {}\n-        `);\n-          env.write('test-2.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            exports: [\n-              RouterModule.forChild([\n-                {path: 'two', loadChildren: './lazy-2/lazy-2#Lazy2Module'},\n-              ]),\n-            ],\n-          })\n-          export class Test2Module {}\n-        `);\n-          env.write('lazy/lazy.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class LazyModule {}\n-        `);\n-          env.write('lazy-1/lazy-1.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class Lazy1Module {}\n-        `);\n-          env.write('lazy-2/lazy-2.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class Lazy2Module {}\n-        `);\n-\n-          const routes = env.driveRoutes(absoluteFrom('/test#TestModule'));\n-\n-          expect(routes).toEqual([\n-            lazyRouteMatching(\n-                './lazy/lazy#LazyModule', /\\/test\\.ts$/, 'TestModule', /\\/lazy\\/lazy\\.ts$/,\n-                'LazyModule'),\n-            lazyRouteMatching(\n-                './lazy-1/lazy-1#Lazy1Module', /\\/test-1\\.ts$/, 'Test1Module',\n-                /\\/lazy-1\\/lazy-1\\.ts$/, 'Lazy1Module'),\n-            lazyRouteMatching(\n-                './lazy-2/lazy-2#Lazy2Module', /\\/test-2\\.ts$/, 'Test2Module',\n-                /\\/lazy-2\\/lazy-2\\.ts$/, 'Lazy2Module'),\n-          ]);\n-        });\n-\n-        it('should ignore exports that do not refer to an `NgModule`', () => {\n-          env.write('test-1.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-          import {Test2Component, Test2Module} from './test-2';\n-\n-          @NgModule({\n-            exports: [\n-              Test2Component,\n-              Test2Module,\n-            ],\n-            imports: [\n-              Test2Module,\n-              RouterModule.forRoot([\n-                {path: '', loadChildren: './lazy-1/lazy-1#Lazy1Module'},\n-              ]),\n-            ],\n-          })\n-          export class Test1Module {}\n-        `);\n-          env.write('test-2.ts', `\n-          import {Component, NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @Component({\n-            selector: 'test-2',\n-            template: '',\n-          })\n-          export class Test2Component {}\n-\n-          @NgModule({\n-            declarations: [\n-              Test2Component,\n-            ],\n-            exports: [\n-              Test2Component,\n-              RouterModule.forChild([\n-                {path: 'two', loadChildren: './lazy-2/lazy-2#Lazy2Module'},\n-              ]),\n-            ],\n-          })\n-          export class Test2Module {}\n-        `);\n-          env.write('lazy-1/lazy-1.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class Lazy1Module {}\n-        `);\n-          env.write('lazy-2/lazy-2.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class Lazy2Module {}\n-        `);\n-\n-          const routes = env.driveRoutes(absoluteFrom('/test-1#Test1Module'));\n-\n-          expect(routes).toEqual([\n-            lazyRouteMatching(\n-                './lazy-1/lazy-1#Lazy1Module', /\\/test-1\\.ts$/, 'Test1Module',\n-                /\\/lazy-1\\/lazy-1\\.ts$/, 'Lazy1Module'),\n-            lazyRouteMatching(\n-                './lazy-2/lazy-2#Lazy2Module', /\\/test-2\\.ts$/, 'Test2Module',\n-                /\\/lazy-2\\/lazy-2\\.ts$/, 'Lazy2Module'),\n-          ]);\n-        });\n-\n-        it('should support `ModuleWithProviders`', () => {\n-          env.write('test.ts', `\n-          import {ModuleWithProviders, NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forChild([\n-                {path: '', loadChildren: './lazy-2/lazy-2#Lazy2Module'},\n-              ]),\n-            ],\n-          })\n-          export class TestRoutingModule {\n-            static forRoot(): ModuleWithProviders<TestRoutingModule> {\n-              return {\n-                ngModule: TestRoutingModule,\n-                providers: [],\n-              };\n-            }\n-          }\n-\n-          @NgModule({\n-            imports: [\n-              TestRoutingModule.forRoot(),\n-              RouterModule.forRoot([\n-                {path: '', loadChildren: './lazy-1/lazy-1#Lazy1Module'},\n-              ]),\n-            ],\n-          })\n-          export class TestModule {}\n-        `);\n-          env.write('lazy-1/lazy-1.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class Lazy1Module {}\n-        `);\n-          env.write('lazy-2/lazy-2.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class Lazy2Module {}\n-        `);\n-\n-          const routes = env.driveRoutes(absoluteFrom('/test#TestModule'));\n-\n-          expect(routes).toEqual([\n-            lazyRouteMatching(\n-                './lazy-1/lazy-1#Lazy1Module', /\\/test\\.ts$/, 'TestModule', /\\/lazy-1\\/lazy-1\\.ts$/,\n-                'Lazy1Module'),\n-            lazyRouteMatching(\n-                './lazy-2/lazy-2#Lazy2Module', /\\/test\\.ts$/, 'TestRoutingModule',\n-                /\\/lazy-2\\/lazy-2\\.ts$/, 'Lazy2Module'),\n-          ]);\n-        });\n-\n-        it('should only process each module once', () => {\n-          env.write('test.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forChild([\n-                {path: '', loadChildren: './lazy/lazy#LazyModule'},\n-              ]),\n-            ],\n-          })\n-          export class SharedModule {}\n-\n-          @NgModule({\n-            imports: [\n-              SharedModule,\n-              RouterModule.forRoot([\n-                {path: '', loadChildren: './lazy/lazy#LazyModule'},\n-              ]),\n-            ],\n-          })\n-          export class TestModule {}\n-        `);\n-          env.write('lazy/lazy.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forChild([\n-                {path: '', loadChildren: '../lazier/lazier#LazierModule'},\n-              ]),\n-            ],\n-          })\n-          export class LazyModule {}\n-        `);\n-          env.write('lazier/lazier.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class LazierModule {}\n-        `);\n-\n-          const routes = env.driveRoutes(absoluteFrom('/test#TestModule'));\n-\n-          // `LazyModule` is referenced in both `SharedModule` and `TestModule`,\n-          // but it is only processed once (hence one `LazierModule` entry).\n-          expect(routes).toEqual([\n-            lazyRouteMatching(\n-                './lazy/lazy#LazyModule', /\\/test\\.ts$/, 'TestModule', /\\/lazy\\/lazy\\.ts$/,\n-                'LazyModule'),\n-            lazyRouteMatching(\n-                './lazy/lazy#LazyModule', /\\/test\\.ts$/, 'SharedModule', /\\/lazy\\/lazy\\.ts$/,\n-                'LazyModule'),\n-            lazyRouteMatching(\n-                '../lazier/lazier#LazierModule', /\\/lazy\\/lazy\\.ts$/, 'LazyModule',\n-                /\\/lazier\\/lazier\\.ts$/, 'LazierModule'),\n-          ]);\n-        });\n-\n-        it('should detect lazy routes in all root directories', () => {\n-          env.tsconfig({}, ['./foo/other-root-dir', './bar/other-root-dir']);\n-          env.write('src/test.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forRoot([\n-                {path: '', loadChildren: './lazy-foo#LazyFooModule'},\n-              ]),\n-            ],\n-          })\n-          export class TestModule {}\n-        `);\n-          env.write('foo/other-root-dir/src/lazy-foo.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forChild([\n-                {path: '', loadChildren: './lazy-bar#LazyBarModule'},\n-              ]),\n-            ],\n-          })\n-          export class LazyFooModule {}\n-        `);\n-          env.write('bar/other-root-dir/src/lazy-bar.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forChild([\n-                {path: '', loadChildren: './lazier-bar#LazierBarModule'},\n-              ]),\n-            ],\n-          })\n-          export class LazyBarModule {}\n-        `);\n-          env.write('bar/other-root-dir/src/lazier-bar.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class LazierBarModule {}\n-        `);\n-\n-          const routes = env.driveRoutes(absoluteFrom('/src/test#TestModule'));\n-\n-          expect(routes).toEqual([\n-            lazyRouteMatching(\n-                './lazy-foo#LazyFooModule', /\\/test\\.ts$/, 'TestModule',\n-                /\\/foo\\/other-root-dir\\/src\\/lazy-foo\\.ts$/, 'LazyFooModule'),\n-            lazyRouteMatching(\n-                './lazy-bar#LazyBarModule', /\\/foo\\/other-root-dir\\/src\\/lazy-foo\\.ts$/,\n-                'LazyFooModule', /\\/bar\\/other-root-dir\\/src\\/lazy-bar\\.ts$/, 'LazyBarModule'),\n-            lazyRouteMatching(\n-                './lazier-bar#LazierBarModule', /\\/bar\\/other-root-dir\\/src\\/lazy-bar\\.ts$/,\n-                'LazyBarModule', /\\/bar\\/other-root-dir\\/src\\/lazier-bar\\.ts$/, 'LazierBarModule'),\n-          ]);\n-        });\n-\n-        it('should ignore modules not (transitively) referenced by the entry module', () => {\n-          env.write('test.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forRoot([\n-                {path: '', loadChildren: './lazy/lazy#Lazy1Module'},\n-              ]),\n-            ],\n-          })\n-          export class Test1Module {}\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forRoot([\n-                {path: '', loadChildren: './lazy/lazy#Lazy2Module'},\n-              ]),\n-            ],\n-          })\n-          export class Test2Module {}\n-        `);\n-          env.write('lazy/lazy.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class Lazy1Module {}\n-\n-          @NgModule({})\n-          export class Lazy2Module {}\n-        `);\n-\n-          const routes = env.driveRoutes(absoluteFrom('/test#Test1Module'));\n-\n-          expect(routes).toEqual([\n-            lazyRouteMatching(\n-                './lazy/lazy#Lazy1Module', /\\/test\\.ts$/, 'Test1Module', /\\/lazy\\/lazy\\.ts$/,\n-                'Lazy1Module'),\n-          ]);\n-        });\n-\n-        it('should ignore routes to unknown modules', () => {\n-          env.write('test.ts', `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forRoot([\n-                {path: '', loadChildren: './unknown/unknown#UnknownModule'},\n-                {path: '', loadChildren: './lazy/lazy#LazyModule'},\n-              ]),\n-            ],\n-          })\n-          export class TestModule {}\n-        `);\n-          env.write('lazy/lazy.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({})\n-          export class LazyModule {}\n-        `);\n-\n-          const routes = env.driveRoutes(absoluteFrom('/test#TestModule'));\n-\n-          expect(routes).toEqual([\n-            lazyRouteMatching(\n-                './lazy/lazy#LazyModule', /\\/test\\.ts$/, 'TestModule', /\\/lazy\\/lazy\\.ts$/,\n-                'LazyModule'),\n-          ]);\n-        });\n-      });\n-    });\n-\n     describe('ivy switch mode', () => {\n       it('should allow for symbols to be renamed when they use a SWITCH_IVY naming mechanism',\n          () => {"
        },
        {
            "sha": "32e80968ee9ff359b463f16df524061dac17b5d2",
            "filename": "packages/compiler-cli/test/transformers/program_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 344,
            "changes": 344,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fprogram_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fprogram_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fprogram_spec.ts?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -635,350 +635,6 @@ describe('ng program', () => {\n     });\n   });\n \n-  describe('listLazyRoutes', () => {\n-    function writeSomeRoutes() {\n-      testSupport.writeFiles({\n-        'src/main.ts': `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [RouterModule.forRoot([{loadChildren: './child#ChildModule'}])]\n-          })\n-          export class MainModule {}\n-        `,\n-        'src/child.ts': `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [RouterModule.forChild([{loadChildren: './child2#ChildModule2'}])]\n-          })\n-          export class ChildModule {}\n-        `,\n-        'src/child2.ts': `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule()\n-          export class ChildModule2 {}\n-        `,\n-      });\n-    }\n-\n-    function createProgram(rootNames: string[], overrideOptions: ng.CompilerOptions = {}) {\n-      const options = testSupport.createCompilerOptions(overrideOptions);\n-      const host = ng.createCompilerHost({options});\n-      const program = ng.createProgram(\n-          {rootNames: rootNames.map(p => path.resolve(testSupport.basePath, p)), options, host});\n-      return {program, options};\n-    }\n-\n-    function normalizeRoutes(lazyRoutes: LazyRoute[]) {\n-      return lazyRoutes.map(\n-          r => ({\n-            route: r.route,\n-            module: {name: r.module.name, filePath: r.module.filePath},\n-            referencedModule:\n-                {name: r.referencedModule.name, filePath: r.referencedModule.filePath},\n-          }));\n-    }\n-\n-    it('should list all lazyRoutes', () => {\n-      writeSomeRoutes();\n-      const {program, options} = createProgram(['src/main.ts', 'src/child.ts', 'src/child2.ts']);\n-      expectNoDiagnosticsInProgram(options, program);\n-      expect(normalizeRoutes(program.listLazyRoutes())).toEqual([\n-        {\n-          module:\n-              {name: 'MainModule', filePath: path.posix.join(testSupport.basePath, 'src/main.ts')},\n-          referencedModule: {\n-            name: 'ChildModule',\n-            filePath: path.posix.join(testSupport.basePath, 'src/child.ts')\n-          },\n-          route: './child#ChildModule'\n-        },\n-        {\n-          module: {\n-            name: 'ChildModule',\n-            filePath: path.posix.join(testSupport.basePath, 'src/child.ts')\n-          },\n-          referencedModule: {\n-            name: 'ChildModule2',\n-            filePath: path.posix.join(testSupport.basePath, 'src/child2.ts')\n-          },\n-          route: './child2#ChildModule2'\n-        },\n-      ]);\n-    });\n-\n-    it('should emit correctly after listing lazyRoutes', () => {\n-      testSupport.writeFiles({\n-        'src/main.ts': `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [RouterModule.forRoot([{loadChildren: './lazy/lazy#LazyModule'}])]\n-          })\n-          export class MainModule {}\n-        `,\n-        'src/lazy/lazy.ts': `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule()\n-          export class ChildModule {}\n-        `,\n-      });\n-      const {program, options} = createProgram(['src/main.ts', 'src/lazy/lazy.ts']);\n-      expectNoDiagnosticsInProgram(options, program);\n-      program.listLazyRoutes();\n-      program.emit();\n-\n-      const ngFactoryPath = path.resolve(testSupport.basePath, 'built/src/lazy/lazy.ngfactory.js');\n-      const lazyNgFactory = fs.readFileSync(ngFactoryPath, 'utf8');\n-\n-      expect(lazyNgFactory).toContain('import * as i1 from \"./lazy\";');\n-    });\n-\n-    it('should list lazyRoutes given an entryRoute recursively', () => {\n-      writeSomeRoutes();\n-      const {program, options} = createProgram(['src/main.ts']);\n-      expectNoDiagnosticsInProgram(options, program);\n-      expect(normalizeRoutes(program.listLazyRoutes('src/main#MainModule'))).toEqual([\n-        {\n-          module:\n-              {name: 'MainModule', filePath: path.posix.join(testSupport.basePath, 'src/main.ts')},\n-          referencedModule: {\n-            name: 'ChildModule',\n-            filePath: path.posix.join(testSupport.basePath, 'src/child.ts')\n-          },\n-          route: './child#ChildModule'\n-        },\n-        {\n-          module: {\n-            name: 'ChildModule',\n-            filePath: path.posix.join(testSupport.basePath, 'src/child.ts')\n-          },\n-          referencedModule: {\n-            name: 'ChildModule2',\n-            filePath: path.posix.join(testSupport.basePath, 'src/child2.ts')\n-          },\n-          route: './child2#ChildModule2'\n-        },\n-      ]);\n-\n-      expect(normalizeRoutes(program.listLazyRoutes('src/child#ChildModule'))).toEqual([\n-        {\n-          module: {\n-            name: 'ChildModule',\n-            filePath: path.posix.join(testSupport.basePath, 'src/child.ts')\n-          },\n-          referencedModule: {\n-            name: 'ChildModule2',\n-            filePath: path.posix.join(testSupport.basePath, 'src/child2.ts')\n-          },\n-          route: './child2#ChildModule2'\n-        },\n-      ]);\n-    });\n-\n-    it('should list lazyRoutes pointing to a default export', () => {\n-      testSupport.writeFiles({\n-        'src/main.ts': `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [RouterModule.forRoot([{loadChildren: './child'}])]\n-          })\n-          export class MainModule {}\n-        `,\n-        'src/child.ts': `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule()\n-          export default class ChildModule {}\n-        `,\n-      });\n-      const {program, options} = createProgram(['src/main.ts']);\n-      expect(normalizeRoutes(program.listLazyRoutes('src/main#MainModule'))).toEqual([\n-        {\n-          module:\n-              {name: 'MainModule', filePath: path.posix.join(testSupport.basePath, 'src/main.ts')},\n-          referencedModule: {\n-            name: undefined as any as string,  // TODO: Review use of `any` here (#19904)\n-            filePath: path.posix.join(testSupport.basePath, 'src/child.ts')\n-          },\n-          route: './child'\n-        },\n-      ]);\n-    });\n-\n-    it('should list lazyRoutes from imported modules', () => {\n-      testSupport.writeFiles({\n-        'src/main.ts': `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-          import {NestedMainModule} from './nested/main';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forRoot([{loadChildren: './child#ChildModule'}]),\n-              NestedMainModule,\n-            ]\n-          })\n-          export class MainModule {}\n-        `,\n-        'src/child.ts': `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule()\n-          export class ChildModule {}\n-        `,\n-        'src/nested/main.ts': `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [RouterModule.forChild([{loadChildren: './child#NestedChildModule'}])]\n-          })\n-          export class NestedMainModule {}\n-        `,\n-        'src/nested/child.ts': `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule()\n-          export class NestedChildModule {}\n-        `,\n-      });\n-      const {program, options} = createProgram(['src/main.ts']);\n-      expect(normalizeRoutes(program.listLazyRoutes('src/main#MainModule'))).toEqual([\n-        {\n-          module: {\n-            name: 'NestedMainModule',\n-            filePath: path.posix.join(testSupport.basePath, 'src/nested/main.ts')\n-          },\n-          referencedModule: {\n-            name: 'NestedChildModule',\n-            filePath: path.posix.join(testSupport.basePath, 'src/nested/child.ts')\n-          },\n-          route: './child#NestedChildModule'\n-        },\n-        {\n-          module:\n-              {name: 'MainModule', filePath: path.posix.join(testSupport.basePath, 'src/main.ts')},\n-          referencedModule: {\n-            name: 'ChildModule',\n-            filePath: path.posix.join(testSupport.basePath, 'src/child.ts')\n-          },\n-          route: './child#ChildModule'\n-        },\n-      ]);\n-    });\n-\n-    it('should dedupe lazyRoutes given an entryRoute', () => {\n-      writeSomeRoutes();\n-      testSupport.writeFiles({\n-        'src/index.ts': `\n-          import {NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @NgModule({\n-            imports: [\n-              RouterModule.forRoot([{loadChildren: './main#MainModule'}]),\n-              RouterModule.forRoot([{loadChildren: './child#ChildModule'}]),\n-            ]\n-          })\n-          export class MainModule {}\n-        `,\n-      });\n-      const {program, options} = createProgram(['src/index.ts']);\n-      expectNoDiagnosticsInProgram(options, program);\n-      expect(normalizeRoutes(program.listLazyRoutes('src/main#MainModule'))).toEqual([\n-        {\n-          module:\n-              {name: 'MainModule', filePath: path.posix.join(testSupport.basePath, 'src/main.ts')},\n-          referencedModule: {\n-            name: 'ChildModule',\n-            filePath: path.posix.join(testSupport.basePath, 'src/child.ts')\n-          },\n-          route: './child#ChildModule'\n-        },\n-        {\n-          module: {\n-            name: 'ChildModule',\n-            filePath: path.posix.join(testSupport.basePath, 'src/child.ts')\n-          },\n-          referencedModule: {\n-            name: 'ChildModule2',\n-            filePath: path.posix.join(testSupport.basePath, 'src/child2.ts')\n-          },\n-          route: './child2#ChildModule2'\n-        },\n-      ]);\n-    });\n-\n-    it('should list lazyRoutes given an entryRoute even with static errors', () => {\n-      testSupport.writeFiles({\n-        'src/main.ts': `\n-          import {NgModule, Component} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          @Component({\n-            selector: 'url-comp',\n-            // Non existent external template\n-            templateUrl: 'non-existent.html',\n-          })\n-          export class ErrorComp {}\n-\n-          @Component({\n-            selector: 'err-comp',\n-            // Error in template\n-            template: '<input/>{{',\n-          })\n-          export class ErrorComp2 {}\n-\n-          // Component with metadata errors.\n-          @Component(() => {if (1==1) return null as any;})\n-          export class ErrorComp3 {}\n-\n-          // Unused component\n-          @Component({\n-            selector: 'unused-comp',\n-            template: ''\n-          })\n-          export class UnusedComp {}\n-\n-          @NgModule({\n-            declarations: [ErrorComp, ErrorComp2, ErrorComp3, NonExistentComp],\n-            imports: [RouterModule.forRoot([{loadChildren: './child#ChildModule'}])]\n-          })\n-          export class MainModule {}\n-\n-          @NgModule({\n-            // Component used in 2 NgModules\n-            declarations: [ErrorComp],\n-          })\n-          export class Mod2 {}\n-        `,\n-        'src/child.ts': `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule()\n-          export class ChildModule {}\n-        `,\n-      });\n-      const program = createProgram(['src/main.ts'], {collectAllErrors: true}).program;\n-      expect(normalizeRoutes(program.listLazyRoutes('src/main#MainModule'))).toEqual([{\n-        module:\n-            {name: 'MainModule', filePath: path.posix.join(testSupport.basePath, 'src/main.ts')},\n-        referencedModule:\n-            {name: 'ChildModule', filePath: path.posix.join(testSupport.basePath, 'src/child.ts')},\n-        route: './child#ChildModule'\n-      }]);\n-    });\n-  });\n-\n   it('should report errors for ts and ng errors on emit with noEmitOnError=true', () => {\n     testSupport.writeFiles({\n       'src/main.ts': `"
        },
        {
            "sha": "204bc0786521e3a55ae36ebc9ed17cdae3ec7f8f",
            "filename": "packages/compiler/src/aot/compiler.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 38,
            "changes": 38,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler.ts?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -31,7 +31,6 @@ import {ViewCompiler, ViewCompileResult} from '../view_compiler/view_compiler';\n import {AotCompilerHost} from './compiler_host';\n import {AotCompilerOptions} from './compiler_options';\n import {GeneratedFile} from './generated_file';\n-import {LazyRoute, listLazyRoutes, parseLazyRoute} from './lazy_routes';\n import {PartialModule} from './partial_module';\n import {StaticReflector} from './static_reflector';\n import {StaticSymbol} from './static_symbol';\n@@ -621,43 +620,6 @@ export class AotCompiler {\n   private _codegenSourceModule(srcFileUrl: string, ctx: OutputContext): GeneratedFile {\n     return new GeneratedFile(srcFileUrl, ctx.genFilePath, ctx.statements);\n   }\n-\n-  listLazyRoutes(entryRoute?: string, analyzedModules?: NgAnalyzedModules): LazyRoute[] {\n-    const self = this;\n-    if (entryRoute) {\n-      const symbol = parseLazyRoute(entryRoute, this.reflector).referencedModule;\n-      return visitLazyRoute(symbol);\n-    } else if (analyzedModules) {\n-      const allLazyRoutes: LazyRoute[] = [];\n-      for (const ngModule of analyzedModules.ngModules) {\n-        const lazyRoutes = listLazyRoutes(ngModule, this.reflector);\n-        for (const lazyRoute of lazyRoutes) {\n-          allLazyRoutes.push(lazyRoute);\n-        }\n-      }\n-      return allLazyRoutes;\n-    } else {\n-      throw new Error(`Either route or analyzedModules has to be specified!`);\n-    }\n-\n-    function visitLazyRoute(\n-        symbol: StaticSymbol, seenRoutes = new Set<StaticSymbol>(),\n-        allLazyRoutes: LazyRoute[] = []): LazyRoute[] {\n-      // Support pointing to default exports, but stop recursing there,\n-      // as the StaticReflector does not yet support default exports.\n-      if (seenRoutes.has(symbol) || !symbol.name) {\n-        return allLazyRoutes;\n-      }\n-      seenRoutes.add(symbol);\n-      const lazyRoutes =\n-          listLazyRoutes(self._metadataResolver.getNgModuleMetadata(symbol, true)!, self.reflector);\n-      for (const lazyRoute of lazyRoutes) {\n-        allLazyRoutes.push(lazyRoute);\n-        visitLazyRoute(lazyRoute.referencedModule, seenRoutes, allLazyRoutes);\n-      }\n-      return allLazyRoutes;\n-    }\n-  }\n }\n \n function _createEmptyStub(outputCtx: OutputContext) {"
        },
        {
            "sha": "4dba3b4ba931ae37be194a5bb65bf1f35be63d19",
            "filename": "packages/compiler/src/aot/lazy_routes.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 60,
            "changes": 60,
            "blob_url": "https://github.com/angular/angular/blob/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler%2Fsrc%2Faot%2Flazy_routes.ts",
            "raw_url": "https://github.com/angular/angular/raw/361273fad5030c900c83d333a779f6edbe20c688/packages%2Fcompiler%2Fsrc%2Faot%2Flazy_routes.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Flazy_routes.ts?ref=361273fad5030c900c83d333a779f6edbe20c688",
            "patch": "@@ -1,60 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileNgModuleMetadata, tokenReference} from '../compile_metadata';\n-import {Route} from '../core';\n-\n-import {StaticReflector} from './static_reflector';\n-import {StaticSymbol} from './static_symbol';\n-\n-export interface LazyRoute {\n-  module: StaticSymbol;\n-  route: string;\n-  referencedModule: StaticSymbol;\n-}\n-\n-export function listLazyRoutes(\n-    moduleMeta: CompileNgModuleMetadata, reflector: StaticReflector): LazyRoute[] {\n-  const allLazyRoutes: LazyRoute[] = [];\n-  for (const {provider, module} of moduleMeta.transitiveModule.providers) {\n-    if (tokenReference(provider.token) === reflector.ROUTES) {\n-      const loadChildren = _collectLoadChildren(provider.useValue);\n-      for (const route of loadChildren) {\n-        allLazyRoutes.push(parseLazyRoute(route, reflector, module.reference));\n-      }\n-    }\n-  }\n-  return allLazyRoutes;\n-}\n-\n-function _collectLoadChildren(routes: string|Route|Route[], target: string[] = []): string[] {\n-  if (typeof routes === 'string') {\n-    target.push(routes);\n-  } else if (Array.isArray(routes)) {\n-    for (const route of routes) {\n-      _collectLoadChildren(route, target);\n-    }\n-  } else if (routes.loadChildren) {\n-    _collectLoadChildren(routes.loadChildren, target);\n-  } else if (routes.children) {\n-    _collectLoadChildren(routes.children, target);\n-  }\n-  return target;\n-}\n-\n-export function parseLazyRoute(\n-    route: string, reflector: StaticReflector, module?: StaticSymbol): LazyRoute {\n-  const [routePath, routeName] = route.split('#');\n-  const referencedModule = reflector.resolveExternalReference(\n-      {\n-        moduleName: routePath,\n-        name: routeName,\n-      },\n-      module ? module.filePath : undefined);\n-  return {route: route, module: module || referencedModule, referencedModule};\n-}"
        },
        {
            "sha": "792621666697f6583216fc2154271dc6e02d043d",
            "filename": "packages/compiler/src/compiler.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/94c6dee708c7952487d6d7c9ba97c760e1285437/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompiler.ts?ref=94c6dee708c7952487d6d7c9ba97c760e1285437",
            "patch": "@@ -50,7 +50,6 @@ export * from './aot/static_symbol';\n export * from './aot/static_symbol_resolver';\n export * from './aot/summary_resolver';\n export {isLoweredSymbol, createLoweredSymbol} from './aot/util';\n-export {LazyRoute} from './aot/lazy_routes';\n export * from './ast_path';\n export * from './summary_resolver';\n export {Identifiers} from './identifiers';"
        }
    ],
    "stats": {
        "total": 1657,
        "additions": 13,
        "deletions": 1644
    }
}