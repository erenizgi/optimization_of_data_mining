{
    "author": "JoostK",
    "message": "fix(core): prevent NgModule scope being overwritten in JIT compiler (#37795)\n\nIn JIT compiled apps, component definitions are compiled upon first\naccess. For a component class `A` that extends component class `B`, the\n`B` component is also compiled when the `InheritDefinitionFeature` runs\nduring the compilation of `A` before it has finalized. A problem arises\nwhen the compilation of `B` would flush the NgModule scoping queue,\nwhere the NgModule declaring `A` is still pending. The scope information\nwould be applied to the definition of `A`, but its compilation is still\nin progress so requesting the component definition would compile `A`\nagain from scratch. This \"inner compilation\" is correctly assigned the\nNgModule scope, but once the \"outer compilation\" of `A` finishes it\nwould overwrite the inner compilation's definition, losing the NgModule\nscope information.\n\nIn summary, flushing the NgModule scope queue could trigger a reentrant\ncompilation, where JIT compilation is non-reentrant. To avoid the\nreentrant compilation, a compilation depth counter is introduced to\navoid flushing the NgModule scope during nested compilations.\n\nFixes #37105\n\nPR Close #37795",
    "sha": "2e9fdbde9eb26fea17e3e68e272dc1c2cc9f4fa3",
    "files": [
        {
            "sha": "6da8acbbe980082dc79269cf43938d5ec01081a9",
            "filename": "packages/core/src/render3/jit/directive.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 11,
            "changes": 43,
            "blob_url": "https://github.com/angular/angular/blob/2e9fdbde9eb26fea17e3e68e272dc1c2cc9f4fa3/packages%2Fcore%2Fsrc%2Frender3%2Fjit%2Fdirective.ts",
            "raw_url": "https://github.com/angular/angular/raw/2e9fdbde9eb26fea17e3e68e272dc1c2cc9f4fa3/packages%2Fcore%2Fsrc%2Frender3%2Fjit%2Fdirective.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fjit%2Fdirective.ts?ref=2e9fdbde9eb26fea17e3e68e272dc1c2cc9f4fa3",
            "patch": "@@ -26,7 +26,20 @@ import {angularCoreEnv} from './environment';\n import {getJitOptions} from './jit_options';\n import {flushModuleScopingQueueAsMuchAsPossible, patchComponentDefWithScope, transitiveScopesFor} from './module';\n \n-\n+/**\n+ * Keep track of the compilation depth to avoid reentrancy issues during JIT compilation. This\n+ * matters in the following scenario:\n+ *\n+ * Consider a component 'A' that extends component 'B', both declared in module 'M'. During\n+ * the compilation of 'A' the definition of 'B' is requested to capture the inheritance chain,\n+ * potentially triggering compilation of 'B'. If this nested compilation were to trigger\n+ * `flushModuleScopingQueueAsMuchAsPossible` it may happen that module 'M' is still pending in the\n+ * queue, resulting in 'A' and 'B' to be patched with the NgModule scope. As the compilation of\n+ * 'A' is still in progress, this would introduce a circular dependency on its compilation. To avoid\n+ * this issue, the module scope queue is only flushed for compilations at the depth 0, to ensure\n+ * all compilations have finished.\n+ */\n+let compilationDepth = 0;\n \n /**\n  * Compile an Angular component according to its decorator metadata, and patch the resulting\n@@ -106,18 +119,26 @@ export function compileComponent(type: Type<any>, metadata: Component): void {\n           interpolation: metadata.interpolation,\n           viewProviders: metadata.viewProviders || null,\n         };\n-        if (meta.usesInheritance) {\n-          addDirectiveDefToUndecoratedParents(type);\n-        }\n \n-        ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);\n+        compilationDepth++;\n+        try {\n+          if (meta.usesInheritance) {\n+            addDirectiveDefToUndecoratedParents(type);\n+          }\n+          ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);\n+        } finally {\n+          // Ensure that the compilation depth is decremented even when the compilation failed.\n+          compilationDepth--;\n+        }\n \n-        // When NgModule decorator executed, we enqueued the module definition such that\n-        // it would only dequeue and add itself as module scope to all of its declarations,\n-        // but only if  if all of its declarations had resolved. This call runs the check\n-        // to see if any modules that are in the queue can be dequeued and add scope to\n-        // their declarations.\n-        flushModuleScopingQueueAsMuchAsPossible();\n+        if (compilationDepth === 0) {\n+          // When NgModule decorator executed, we enqueued the module definition such that\n+          // it would only dequeue and add itself as module scope to all of its declarations,\n+          // but only if  if all of its declarations had resolved. This call runs the check\n+          // to see if any modules that are in the queue can be dequeued and add scope to\n+          // their declarations.\n+          flushModuleScopingQueueAsMuchAsPossible();\n+        }\n \n         // If component compilation is async, then the @NgModule annotation which declares the\n         // component may execute and set an ngSelectorScope property on the component type. This"
        },
        {
            "sha": "3f6e167b9a7ee1410fad7ae84b36684f788c2348",
            "filename": "packages/core/test/acceptance/ngmodule_scope_spec.ts",
            "status": "added",
            "additions": 58,
            "deletions": 0,
            "changes": 58,
            "blob_url": "https://github.com/angular/angular/blob/2e9fdbde9eb26fea17e3e68e272dc1c2cc9f4fa3/packages%2Fcore%2Ftest%2Facceptance%2Fngmodule_scope_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2e9fdbde9eb26fea17e3e68e272dc1c2cc9f4fa3/packages%2Fcore%2Ftest%2Facceptance%2Fngmodule_scope_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fngmodule_scope_spec.ts?ref=2e9fdbde9eb26fea17e3e68e272dc1c2cc9f4fa3",
            "patch": "@@ -0,0 +1,58 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Component, destroyPlatform, NgModule, Pipe, PipeTransform} from '@angular/core';\n+import {BrowserModule} from '@angular/platform-browser';\n+import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\n+import {withBody} from '@angular/private/testing';\n+\n+describe('NgModule scopes', () => {\n+  beforeEach(destroyPlatform);\n+  afterEach(destroyPlatform);\n+\n+  it('should apply NgModule scope to a component that extends another component class',\n+     withBody('<my-app></my-app>', async () => {\n+       // Regression test for https://github.com/angular/angular/issues/37105\n+       //\n+       // This test reproduces a scenario that used to fail due to a reentrancy issue in Ivy's JIT\n+       // compiler. Extending a component from a decorated baseclass would inadvertently compile\n+       // the subclass twice. NgModule scope information would only be present on the initial\n+       // compilation, but then overwritten during the second compilation. This meant that the\n+       // baseclass did not have a NgModule scope, such that declarations are not available.\n+       //\n+       // The scenario cannot be tested using TestBed as it influences how NgModule\n+       // scopes are applied, preventing the issue from occurring.\n+\n+       @Pipe({name: 'multiply'})\n+       class MultiplyPipe implements PipeTransform {\n+         transform(value: number, factor: number): number {\n+           return value * factor;\n+         }\n+       }\n+\n+       @Component({template: '...'})\n+       class BaseComponent {\n+       }\n+\n+       @Component({selector: 'my-app', template: 'App - {{ 3 | multiply:2 }}'})\n+       class App extends BaseComponent {\n+       }\n+\n+       @NgModule({\n+         imports: [BrowserModule],\n+         declarations: [App, BaseComponent, MultiplyPipe],\n+         bootstrap: [App],\n+       })\n+       class Mod {\n+       }\n+\n+       const ngModuleRef = await platformBrowserDynamic().bootstrapModule(Mod);\n+       expect(document.body.textContent).toContain('App - 6');\n+       ngModuleRef.destroy();\n+     }));\n+});"
        }
    ],
    "stats": {
        "total": 101,
        "additions": 90,
        "deletions": 11
    }
}