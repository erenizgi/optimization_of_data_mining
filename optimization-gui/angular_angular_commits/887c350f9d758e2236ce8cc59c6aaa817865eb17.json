{
    "author": "dgp1130",
    "message": "refactor(compiler): wrap large strings in function (#38253)\n\nLarge strings constants are now wrapped in a function which is called whenever used. This works around a unique\nlimitation of Closure, where it will **always** inline string literals at **every** usage, regardless of how large the\nstring literal is or how many times it is used.The workaround is to use a function rather than a string literal.\nClosure has differently inlining semantics for functions, where it will check the length of the function and the number\nof times it is used before choosing to inline it. By using a function, `ngtsc` makes Closure more conservative about\ninlining large strings, and avoids blowing up the bundle size.This optimization is only used if the constant is a large\nstring. A wrapping function is not included for other use cases, since it would just increase the bundle size and add\nunnecessary runtime performance overhead.\n\nPR Close #38253",
    "sha": "887c350f9d758e2236ce8cc59c6aaa817865eb17",
    "files": [
        {
            "sha": "af1e79be95e7b3cbe472f4144fa5007be5682405",
            "filename": "packages/compiler-cli/src/ngtsc/transform/src/transform.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/887c350f9d758e2236ce8cc59c6aaa817865eb17/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftransform.ts",
            "raw_url": "https://github.com/angular/angular/raw/887c350f9d758e2236ce8cc59c6aaa817865eb17/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftransform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftransform.ts?ref=887c350f9d758e2236ce8cc59c6aaa817865eb17",
            "patch": "@@ -249,7 +249,7 @@ function transformIvySourceFile(\n     importRewriter: ImportRewriter, file: ts.SourceFile, isCore: boolean,\n     isClosureCompilerEnabled: boolean,\n     defaultImportRecorder: DefaultImportRecorder): ts.SourceFile {\n-  const constantPool = new ConstantPool();\n+  const constantPool = new ConstantPool(isClosureCompilerEnabled);\n   const importManager = new ImportManager(importRewriter);\n \n   // The transformation process consists of 2 steps:"
        },
        {
            "sha": "6e6848a80d56eff18414e2e3ab3f5d0cb6dd6491",
            "filename": "packages/compiler-cli/test/ngtsc/ngtsc_spec.ts",
            "status": "modified",
            "additions": 60,
            "deletions": 0,
            "changes": 60,
            "blob_url": "https://github.com/angular/angular/blob/887c350f9d758e2236ce8cc59c6aaa817865eb17/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/887c350f9d758e2236ce8cc59c6aaa817865eb17/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts?ref=887c350f9d758e2236ce8cc59c6aaa817865eb17",
            "patch": "@@ -6685,6 +6685,66 @@ export const Foo = Foo__PRE_R3__;\n                 // remains a string in the `styles` array.\n                 '\"img[_ngcontent-%COMP%] { background: url(/b/some-very-very-long-path.png); }\"]');\n       });\n+\n+      it('large strings are wrapped in a function for Closure', () => {\n+        env.tsconfig({\n+          annotateForClosureCompiler: true,\n+        });\n+\n+        env.write('test.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'comp-a',\n+            template: 'Comp A',\n+            styles: [\n+              'div { background: url(/a.png); }',\n+              'div { background: url(/some-very-very-long-path.png); }',\n+            ]\n+          })\n+          export class CompA {}\n+\n+          @Component({\n+            selector: 'comp-b',\n+            template: 'Comp B',\n+            styles: [\n+              'div { background: url(/b.png); }',\n+              'div { background: url(/some-very-very-long-path.png); }',\n+            ]\n+          })\n+          export class CompB {}\n+        `);\n+\n+        env.driveMain();\n+        const jsContents = env.getContents('test.js');\n+\n+        // Verify that long strings are extracted to a separate var. This should be wrapped in a\n+        // function to trick Closure not to inline the contents for very large strings.\n+        // See: https://github.com/angular/angular/pull/38253.\n+        expect(jsContents)\n+            .toContain(\n+                '_c0 = function () {' +\n+                ' return \"div[_ngcontent-%COMP%] {' +\n+                ' background: url(/some-very-very-long-path.png);' +\n+                ' }\";' +\n+                ' };');\n+\n+        expect(jsContents)\n+            .toContain(\n+                'styles: [' +\n+                // Check styles for component A.\n+                '\"div[_ngcontent-%COMP%] { background: url(/a.png); }\", ' +\n+                // Large string should be called from function definition.\n+                '_c0()]');\n+\n+        expect(jsContents)\n+            .toContain(\n+                'styles: [' +\n+                // Check styles for component B.\n+                '\"div[_ngcontent-%COMP%] { background: url(/b.png); }\", ' +\n+                // Large string should be called from function definition.\n+                '_c0()]');\n+      });\n     });\n \n     describe('non-exported classes', () => {"
        },
        {
            "sha": "ae9f7c3009b930c93b9f4a312dd18b38305f5003",
            "filename": "packages/compiler/src/constant_pool.ts",
            "status": "modified",
            "additions": 39,
            "deletions": 7,
            "changes": 46,
            "blob_url": "https://github.com/angular/angular/blob/887c350f9d758e2236ce8cc59c6aaa817865eb17/packages%2Fcompiler%2Fsrc%2Fconstant_pool.ts",
            "raw_url": "https://github.com/angular/angular/raw/887c350f9d758e2236ce8cc59c6aaa817865eb17/packages%2Fcompiler%2Fsrc%2Fconstant_pool.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fconstant_pool.ts?ref=887c350f9d758e2236ce8cc59c6aaa817865eb17",
            "patch": "@@ -102,8 +102,10 @@ export class ConstantPool {\n \n   private nextNameIndex = 0;\n \n+  constructor(private readonly isClosureCompilerEnabled: boolean = false) {}\n+\n   getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n-    if ((literal instanceof o.LiteralExpr && !isLongStringExpr(literal)) ||\n+    if ((literal instanceof o.LiteralExpr && !isLongStringLiteral(literal)) ||\n         literal instanceof FixupExpression) {\n       // Do no put simple literals into the constant pool or try to produce a constant for a\n       // reference to a constant.\n@@ -121,9 +123,39 @@ export class ConstantPool {\n     if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n       // Replace the expression with a variable\n       const name = this.freshName();\n-      this.statements.push(\n-          o.variable(name).set(literal).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n-      fixup.fixup(o.variable(name));\n+      let definition: o.WriteVarExpr;\n+      let usage: o.Expression;\n+      if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n+        // For string literals, Closure will **always** inline the string at\n+        // **all** usages, duplicating it each time. For large strings, this\n+        // unnecessarily bloats bundle size. To work around this restriction, we\n+        // wrap the string in a function, and call that function for each usage.\n+        // This tricks Closure into using inline logic for functions instead of\n+        // string literals. Function calls are only inlined if the body is small\n+        // enough to be worth it. By doing this, very large strings will be\n+        // shared across multiple usages, rather than duplicating the string at\n+        // each usage site.\n+        //\n+        // const myStr = function() { return \"very very very long string\"; };\n+        // const usage1 = myStr();\n+        // const usage2 = myStr();\n+        definition = o.variable(name).set(new o.FunctionExpr(\n+            [],  // Params.\n+            [\n+              // Statements.\n+              new o.ReturnStatement(literal),\n+            ],\n+            ));\n+        usage = o.variable(name).callFn([]);\n+      } else {\n+        // Just declare and use the variable directly, without a function call\n+        // indirection. This saves a few bytes and avoids an unncessary call.\n+        definition = o.variable(name).set(literal);\n+        usage = o.variable(name);\n+      }\n+\n+      this.statements.push(definition.toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n+      fixup.fixup(usage);\n     }\n \n     return fixup;\n@@ -314,7 +346,7 @@ function isVariable(e: o.Expression): e is o.ReadVarExpr {\n   return e instanceof o.ReadVarExpr;\n }\n \n-function isLongStringExpr(expr: o.LiteralExpr): boolean {\n-  return typeof expr.value === 'string' &&\n+function isLongStringLiteral(expr: o.Expression): boolean {\n+  return expr instanceof o.LiteralExpr && typeof expr.value === 'string' &&\n       expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n-}\n\\ No newline at end of file\n+}"
        }
    ],
    "stats": {
        "total": 108,
        "additions": 100,
        "deletions": 8
    }
}