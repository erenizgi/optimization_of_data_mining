{
    "author": "gkalpak",
    "message": "fix(service-worker): correctly handle relative base href (#37922)\n\nIn some cases, it is useful to use a relative base href in the app (e.g.\nwhen an app has to be accessible on different URLs, such as on an\nintranet and the internet - see #25055 for a related discussion).\n\nPreviously, the Angular ServiceWorker was not able to handle relative\nbase hrefs (for example when building the with `--base-href=./`).\n\nThis commit fixes this by normalizing all URLs from the ServiceWorker\nconfiguration wrt the ServiceWorker's scope.\n\nFixes #25055\n\nPR Close #37922",
    "sha": "d19ef6534fa6109e5900781fd416ea14c6133658",
    "files": [
        {
            "sha": "21127d3ade164003a968e5b0286e914c3f002ce9",
            "filename": "packages/service-worker/config/src/generator.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/d19ef6534fa6109e5900781fd416ea14c6133658/packages%2Fservice-worker%2Fconfig%2Fsrc%2Fgenerator.ts",
            "raw_url": "https://github.com/angular/angular/raw/d19ef6534fa6109e5900781fd416ea14c6133658/packages%2Fservice-worker%2Fconfig%2Fsrc%2Fgenerator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fconfig%2Fsrc%2Fgenerator.ts?ref=d19ef6534fa6109e5900781fd416ea14c6133658",
            "patch": "@@ -131,7 +131,10 @@ function matches(file: string, patterns: {positive: boolean, regex: RegExp}[]):\n \n function urlToRegex(url: string, baseHref: string, literalQuestionMark?: boolean): string {\n   if (!url.startsWith('/') && url.indexOf('://') === -1) {\n-    url = joinUrls(baseHref, url);\n+    // Prefix relative URLs with `baseHref`.\n+    // Strip a leading `.` from a relative `baseHref` (e.g. `./foo/`), since it would result in an\n+    // incorrect regex (matching a literal `.`).\n+    url = joinUrls(baseHref.replace(/^\\.(?=\\/)/, ''), url);\n   }\n \n   return globToRegex(url, literalQuestionMark);"
        },
        {
            "sha": "c2600490e5b28296e4c31267f415a9c13d1a53c8",
            "filename": "packages/service-worker/config/test/generator_spec.ts",
            "status": "modified",
            "additions": 53,
            "deletions": 1,
            "changes": 54,
            "blob_url": "https://github.com/angular/angular/blob/d19ef6534fa6109e5900781fd416ea14c6133658/packages%2Fservice-worker%2Fconfig%2Ftest%2Fgenerator_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d19ef6534fa6109e5900781fd416ea14c6133658/packages%2Fservice-worker%2Fconfig%2Ftest%2Fgenerator_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fconfig%2Ftest%2Fgenerator_spec.ts?ref=d19ef6534fa6109e5900781fd416ea14c6133658",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Generator} from '../src/generator';\n+import {Generator, processNavigationUrls} from '../src/generator';\n import {AssetGroup} from '../src/in';\n import {MockFilesystem} from '../testing/mock';\n \n@@ -255,4 +255,56 @@ describe('Generator', () => {\n       },\n     });\n   });\n+\n+  describe('processNavigationUrls()', () => {\n+    const customNavigationUrls = [\n+      'https://host/positive/external/**',\n+      '!https://host/negative/external/**',\n+      '/positive/absolute/**',\n+      '!/negative/absolute/**',\n+      'positive/relative/**',\n+      '!negative/relative/**',\n+    ];\n+\n+    it('uses the default `navigationUrls` if not provided', () => {\n+      expect(processNavigationUrls('/')).toEqual([\n+        {positive: true, regex: '^\\\\/.*$'},\n+        {positive: false, regex: '^\\\\/(?:.+\\\\/)?[^/]*\\\\.[^/]*$'},\n+        {positive: false, regex: '^\\\\/(?:.+\\\\/)?[^/]*__[^/]*$'},\n+        {positive: false, regex: '^\\\\/(?:.+\\\\/)?[^/]*__[^/]*\\\\/.*$'},\n+      ]);\n+    });\n+\n+    it('prepends `baseHref` to relative URL patterns only', () => {\n+      expect(processNavigationUrls('/base/href/', customNavigationUrls)).toEqual([\n+        {positive: true, regex: '^https:\\\\/\\\\/host\\\\/positive\\\\/external\\\\/.*$'},\n+        {positive: false, regex: '^https:\\\\/\\\\/host\\\\/negative\\\\/external\\\\/.*$'},\n+        {positive: true, regex: '^\\\\/positive\\\\/absolute\\\\/.*$'},\n+        {positive: false, regex: '^\\\\/negative\\\\/absolute\\\\/.*$'},\n+        {positive: true, regex: '^\\\\/base\\\\/href\\\\/positive\\\\/relative\\\\/.*$'},\n+        {positive: false, regex: '^\\\\/base\\\\/href\\\\/negative\\\\/relative\\\\/.*$'},\n+      ]);\n+    });\n+\n+    it('strips a leading single `.` from a relative `baseHref`', () => {\n+      expect(processNavigationUrls('./relative/base/href/', customNavigationUrls)).toEqual([\n+        {positive: true, regex: '^https:\\\\/\\\\/host\\\\/positive\\\\/external\\\\/.*$'},\n+        {positive: false, regex: '^https:\\\\/\\\\/host\\\\/negative\\\\/external\\\\/.*$'},\n+        {positive: true, regex: '^\\\\/positive\\\\/absolute\\\\/.*$'},\n+        {positive: false, regex: '^\\\\/negative\\\\/absolute\\\\/.*$'},\n+        {positive: true, regex: '^\\\\/relative\\\\/base\\\\/href\\\\/positive\\\\/relative\\\\/.*$'},\n+        {positive: false, regex: '^\\\\/relative\\\\/base\\\\/href\\\\/negative\\\\/relative\\\\/.*$'},\n+      ]);\n+\n+      // We can't correctly handle double dots in `baseHref`, so leave them as literal matches.\n+      expect(processNavigationUrls('../double/dots/', customNavigationUrls)).toEqual([\n+        {positive: true, regex: '^https:\\\\/\\\\/host\\\\/positive\\\\/external\\\\/.*$'},\n+        {positive: false, regex: '^https:\\\\/\\\\/host\\\\/negative\\\\/external\\\\/.*$'},\n+        {positive: true, regex: '^\\\\/positive\\\\/absolute\\\\/.*$'},\n+        {positive: false, regex: '^\\\\/negative\\\\/absolute\\\\/.*$'},\n+        {positive: true, regex: '^\\\\.\\\\.\\\\/double\\\\/dots\\\\/positive\\\\/relative\\\\/.*$'},\n+        {positive: false, regex: '^\\\\.\\\\.\\\\/double\\\\/dots\\\\/negative\\\\/relative\\\\/.*$'},\n+      ]);\n+    });\n+  });\n });"
        },
        {
            "sha": "01924454aac70be869597ac84a88709330abb050",
            "filename": "packages/service-worker/worker/src/app-version.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/d19ef6534fa6109e5900781fd416ea14c6133658/packages%2Fservice-worker%2Fworker%2Fsrc%2Fapp-version.ts",
            "raw_url": "https://github.com/angular/angular/raw/d19ef6534fa6109e5900781fd416ea14c6133658/packages%2Fservice-worker%2Fworker%2Fsrc%2Fapp-version.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fapp-version.ts?ref=d19ef6534fa6109e5900781fd416ea14c6133658",
            "patch": "@@ -52,6 +52,12 @@ export class AppVersion implements UpdateSource {\n    */\n   private navigationUrls: {include: RegExp[], exclude: RegExp[]};\n \n+  /**\n+   * The normalized URL to the file that serves as the index page to satisfy navigation requests.\n+   * Usually this is `/index.html`.\n+   */\n+  private indexUrl = this.adapter.normalizeUrl(this.manifest.index);\n+\n   /**\n    * Tracks whether the manifest has encountered any inconsistencies.\n    */\n@@ -67,7 +73,7 @@ export class AppVersion implements UpdateSource {\n       readonly manifestHash: string) {\n     // The hashTable within the manifest is an Object - convert it to a Map for easier lookups.\n     Object.keys(this.manifest.hashTable).forEach(url => {\n-      this.hashTable.set(url, this.manifest.hashTable[url]);\n+      this.hashTable.set(adapter.normalizeUrl(url), this.manifest.hashTable[url]);\n     });\n \n     // Process each `AssetGroup` declared in the manifest. Each declared group gets an `AssetGroup`\n@@ -179,10 +185,10 @@ export class AppVersion implements UpdateSource {\n \n     // Next, check if this is a navigation request for a route. Detect circular\n     // navigations by checking if the request URL is the same as the index URL.\n-    if (req.url !== this.manifest.index && this.isNavigationRequest(req)) {\n+    if (this.adapter.normalizeUrl(req.url) !== this.indexUrl && this.isNavigationRequest(req)) {\n       // This was a navigation request. Re-enter `handleFetch` with a request for\n       // the URL.\n-      return this.handleFetch(this.adapter.newRequest(this.manifest.index), context);\n+      return this.handleFetch(this.adapter.newRequest(this.indexUrl), context);\n     }\n \n     return null;"
        },
        {
            "sha": "4323c5400fe8d95933be7b17cc5e8418fb8e2cd7",
            "filename": "packages/service-worker/worker/src/assets.ts",
            "status": "modified",
            "additions": 28,
            "deletions": 17,
            "changes": 45,
            "blob_url": "https://github.com/angular/angular/blob/d19ef6534fa6109e5900781fd416ea14c6133658/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts",
            "raw_url": "https://github.com/angular/angular/raw/d19ef6534fa6109e5900781fd416ea14c6133658/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts?ref=d19ef6534fa6109e5900781fd416ea14c6133658",
            "patch": "@@ -26,6 +26,11 @@ export abstract class AssetGroup {\n    */\n   private inFlightRequests = new Map<string, Promise<Response>>();\n \n+  /**\n+   * Normalized resource URLs.\n+   */\n+  protected urls: string[] = [];\n+\n   /**\n    * Regular expression patterns.\n    */\n@@ -52,29 +57,33 @@ export abstract class AssetGroup {\n       protected idle: IdleScheduler, protected config: AssetGroupConfig,\n       protected hashes: Map<string, string>, protected db: Database, protected prefix: string) {\n     this.name = config.name;\n+\n+    // Normalize the config's URLs to take the ServiceWorker's scope into account.\n+    this.urls = config.urls.map(url => adapter.normalizeUrl(url));\n+\n     // Patterns in the config are regular expressions disguised as strings. Breathe life into them.\n-    this.patterns = this.config.patterns.map(pattern => new RegExp(pattern));\n+    this.patterns = config.patterns.map(pattern => new RegExp(pattern));\n \n     // This is the primary cache, which holds all of the cached requests for this group. If a\n     // resource\n     // isn't in this cache, it hasn't been fetched yet.\n-    this.cache = this.scope.caches.open(`${this.prefix}:${this.config.name}:cache`);\n+    this.cache = scope.caches.open(`${this.prefix}:${config.name}:cache`);\n \n     // This is the metadata table, which holds specific information for each cached URL, such as\n     // the timestamp of when it was added to the cache.\n-    this.metadata =\n-        this.db.open(`${this.prefix}:${this.config.name}:meta`, this.config.cacheQueryOptions);\n+    this.metadata = this.db.open(`${this.prefix}:${config.name}:meta`, config.cacheQueryOptions);\n   }\n \n   async cacheStatus(url: string): Promise<UpdateCacheStatus> {\n     const cache = await this.cache;\n     const meta = await this.metadata;\n-    const res = await cache.match(this.adapter.newRequest(url), this.config.cacheQueryOptions);\n+    const req = this.adapter.newRequest(url);\n+    const res = await cache.match(req, this.config.cacheQueryOptions);\n     if (res === undefined) {\n       return UpdateCacheStatus.NOT_CACHED;\n     }\n     try {\n-      const data = await meta.read<UrlMetadata>(url);\n+      const data = await meta.read<UrlMetadata>(req.url);\n       if (!data.used) {\n         return UpdateCacheStatus.CACHED_BUT_UNUSED;\n       }\n@@ -105,7 +114,7 @@ export abstract class AssetGroup {\n     // Either the request matches one of the known resource URLs, one of the patterns for\n     // dynamically matched URLs, or neither. Determine which is the case for this request in\n     // order to decide how to handle it.\n-    if (this.config.urls.indexOf(url) !== -1 || this.patterns.some(pattern => pattern.test(url))) {\n+    if (this.urls.indexOf(url) !== -1 || this.patterns.some(pattern => pattern.test(url))) {\n       // This URL matches a known resource. Either it's been cached already or it's missing, in\n       // which case it needs to be loaded from the network.\n \n@@ -235,7 +244,8 @@ export abstract class AssetGroup {\n     const metaTable = await this.metadata;\n \n     // Lookup the response in the cache.\n-    const response = await cache.match(this.adapter.newRequest(url), this.config.cacheQueryOptions);\n+    const request = this.adapter.newRequest(url);\n+    const response = await cache.match(request, this.config.cacheQueryOptions);\n     if (response === undefined) {\n       // It's not found, return null.\n       return null;\n@@ -244,7 +254,7 @@ export abstract class AssetGroup {\n     // Next, lookup the cached metadata.\n     let metadata: UrlMetadata|undefined = undefined;\n     try {\n-      metadata = await metaTable.read<UrlMetadata>(url);\n+      metadata = await metaTable.read<UrlMetadata>(request.url);\n     } catch {\n       // Do nothing, not found. This shouldn't happen, but it can be handled.\n     }\n@@ -258,9 +268,10 @@ export abstract class AssetGroup {\n    */\n   async unhashedResources(): Promise<string[]> {\n     const cache = await this.cache;\n-    // Start with the set of all cached URLs.\n+    // Start with the set of all cached requests.\n     return (await cache.keys())\n-        .map(request => request.url)\n+        // Normalize their URLs.\n+        .map(request => this.adapter.normalizeUrl(request.url))\n         // Exclude the URLs which have hashes.\n         .filter(url => !this.hashes.has(url));\n   }\n@@ -307,7 +318,7 @@ export abstract class AssetGroup {\n \n         // If the request is not hashed, update its metadata, especially the timestamp. This is\n         // needed for future determination of whether this cached response is stale or not.\n-        if (!this.hashes.has(req.url)) {\n+        if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) {\n           // Metadata is tracked for requests that are unhashed.\n           const meta: UrlMetadata = {ts: this.adapter.time, used};\n           const metaTable = await this.metadata;\n@@ -492,7 +503,7 @@ export class PrefetchAssetGroup extends AssetGroup {\n     // Cache all known resources serially. As this reduce proceeds, each Promise waits\n     // on the last before starting the fetch/cache operation for the next request. Any\n     // errors cause fall-through to the final Promise which rejects.\n-    await this.config.urls.reduce(async (previous: Promise<void>, url: string) => {\n+    await this.urls.reduce(async (previous: Promise<void>, url: string) => {\n       // Wait on all previous operations to complete.\n       await previous;\n \n@@ -527,8 +538,8 @@ export class PrefetchAssetGroup extends AssetGroup {\n           // First, narrow down the set of resources to those which are handled by this group.\n           // Either it's a known URL, or it matches a given pattern.\n           .filter(\n-              url => this.config.urls.indexOf(url) !== -1 ||\n-                  this.patterns.some(pattern => pattern.test(url)))\n+              url =>\n+                  this.urls.indexOf(url) !== -1 || this.patterns.some(pattern => pattern.test(url)))\n           // Finally, process each resource in turn.\n           .reduce(async (previous, url) => {\n             await previous;\n@@ -552,7 +563,7 @@ export class PrefetchAssetGroup extends AssetGroup {\n             // Write it into the cache. It may already be expired, but it can still serve\n             // traffic until it's updated (stale-while-revalidate approach).\n             await cache.put(req, res.response);\n-            await metaTable.write(url, {...res.metadata, used: false} as UrlMetadata);\n+            await metaTable.write(req.url, {...res.metadata, used: false} as UrlMetadata);\n           }, Promise.resolve());\n     }\n   }\n@@ -570,7 +581,7 @@ export class LazyAssetGroup extends AssetGroup {\n     const cache = await this.cache;\n \n     // Loop through the listed resources, caching any which are available.\n-    await this.config.urls.reduce(async (previous: Promise<void>, url: string) => {\n+    await this.urls.reduce(async (previous: Promise<void>, url: string) => {\n       // Wait on all previous operations to complete.\n       await previous;\n "
        },
        {
            "sha": "7506d11ad6d6f543cc3706597172bb4d51a935c5",
            "filename": "packages/service-worker/worker/test/happy_spec.ts",
            "status": "modified",
            "additions": 157,
            "deletions": 1,
            "changes": 158,
            "blob_url": "https://github.com/angular/angular/blob/d19ef6534fa6109e5900781fd416ea14c6133658/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d19ef6534fa6109e5900781fd416ea14c6133658/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts?ref=d19ef6534fa6109e5900781fd416ea14c6133658",
            "patch": "@@ -13,7 +13,7 @@ import {AssetGroupConfig, DataGroupConfig, Manifest} from '../src/manifest';\n import {sha1} from '../src/sha1';\n import {clearAllCaches, MockCache} from '../testing/cache';\n import {MockRequest, MockResponse} from '../testing/fetch';\n-import {MockFileSystem, MockFileSystemBuilder, MockServerStateBuilder, tmpHashTableForFs} from '../testing/mock';\n+import {MockFileSystem, MockFileSystemBuilder, MockServerState, MockServerStateBuilder, tmpHashTableForFs} from '../testing/mock';\n import {SwTestHarness, SwTestHarnessBuilder} from '../testing/scope';\n \n (function() {\n@@ -1306,6 +1306,162 @@ describe('Driver', () => {\n     });\n   });\n \n+  describe('with relative base href', () => {\n+    const createManifestWithRelativeBaseHref = (distDir: MockFileSystem): Manifest => ({\n+      configVersion: 1,\n+      timestamp: 1234567890123,\n+      index: './index.html',\n+      assetGroups: [\n+        {\n+          name: 'eager',\n+          installMode: 'prefetch',\n+          updateMode: 'prefetch',\n+          urls: [\n+            './index.html',\n+            './main.js',\n+            './styles.css',\n+          ],\n+          patterns: [\n+            '/unhashed/.*',\n+          ],\n+          cacheQueryOptions: {ignoreVary: true},\n+        },\n+        {\n+          name: 'lazy',\n+          installMode: 'lazy',\n+          updateMode: 'prefetch',\n+          urls: [\n+            './changed/chunk-1.js',\n+            './changed/chunk-2.js',\n+            './unchanged/chunk-3.js',\n+            './unchanged/chunk-4.js',\n+          ],\n+          patterns: [\n+            '/lazy/unhashed/.*',\n+          ],\n+          cacheQueryOptions: {ignoreVary: true},\n+        }\n+      ],\n+      navigationUrls: processNavigationUrls('./'),\n+      hashTable: tmpHashTableForFs(distDir, {}, './'),\n+    });\n+\n+    const createServerWithBaseHref = (distDir: MockFileSystem): MockServerState =>\n+        new MockServerStateBuilder()\n+            .withRootDirectory('/base/href')\n+            .withStaticFiles(distDir)\n+            .withManifest(createManifestWithRelativeBaseHref(distDir))\n+            .build();\n+\n+    const initialDistDir = new MockFileSystemBuilder()\n+                               .addFile('/index.html', 'This is index.html')\n+                               .addFile('/main.js', 'This is main.js')\n+                               .addFile('/styles.css', 'This is styles.css')\n+                               .addFile('/changed/chunk-1.js', 'This is chunk-1.js')\n+                               .addFile('/changed/chunk-2.js', 'This is chunk-2.js')\n+                               .addFile('/unchanged/chunk-3.js', 'This is chunk-3.js')\n+                               .addFile('/unchanged/chunk-4.js', 'This is chunk-4.js')\n+                               .build();\n+\n+    const serverWithBaseHref = createServerWithBaseHref(initialDistDir);\n+\n+    beforeEach(() => {\n+      serverWithBaseHref.reset();\n+\n+      scope = new SwTestHarnessBuilder('http://localhost/base/href/')\n+                  .withServerState(serverWithBaseHref)\n+                  .build();\n+      driver = new Driver(scope, scope, new CacheDatabase(scope, scope));\n+    });\n+\n+    it('initializes prefetched content correctly, after a request kicks it off', async () => {\n+      expect(await makeRequest(scope, '/base/href/index.html')).toBe('This is index.html');\n+      await driver.initialized;\n+      serverWithBaseHref.assertSawRequestFor('/base/href/ngsw.json');\n+      serverWithBaseHref.assertSawRequestFor('/base/href/index.html');\n+      serverWithBaseHref.assertSawRequestFor('/base/href/main.js');\n+      serverWithBaseHref.assertSawRequestFor('/base/href/styles.css');\n+      serverWithBaseHref.assertNoOtherRequests();\n+\n+      expect(await makeRequest(scope, '/base/href/main.js')).toBe('This is main.js');\n+      expect(await makeRequest(scope, '/base/href/styles.css')).toBe('This is styles.css');\n+      serverWithBaseHref.assertNoOtherRequests();\n+    });\n+\n+    it('prefetches updates to lazy cache when set', async () => {\n+      // Helper\n+      const request = (url: string) => makeRequest(scope, url);\n+\n+      expect(await request('/base/href/index.html')).toBe('This is index.html');\n+      await driver.initialized;\n+\n+      // Fetch some files from the `lazy` asset group.\n+      expect(await request('/base/href/changed/chunk-1.js')).toBe('This is chunk-1.js');\n+      expect(await request('/base/href/unchanged/chunk-3.js')).toBe('This is chunk-3.js');\n+\n+      // Install update.\n+      const updatedDistDir = initialDistDir.extend()\n+                                 .addFile('/changed/chunk-1.js', 'This is chunk-1.js v2')\n+                                 .addFile('/changed/chunk-2.js', 'This is chunk-2.js v2')\n+                                 .build();\n+      const updatedServer = createServerWithBaseHref(updatedDistDir);\n+\n+      scope.updateServerState(updatedServer);\n+      expect(await driver.checkForUpdate()).toBe(true);\n+\n+      // Previously requested and changed: Fetch from network.\n+      updatedServer.assertSawRequestFor('/base/href/changed/chunk-1.js');\n+      // Never requested and changed: Don't fetch.\n+      updatedServer.assertNoRequestFor('/base/href/changed/chunk-2.js');\n+      // Previously requested and unchanged: Fetch from cache.\n+      updatedServer.assertNoRequestFor('/base/href/unchanged/chunk-3.js');\n+      // Never requested and unchanged: Don't fetch.\n+      updatedServer.assertNoRequestFor('/base/href/unchanged/chunk-4.js');\n+\n+      updatedServer.clearRequests();\n+\n+      // Update client.\n+      await driver.updateClient(await scope.clients.get('default'));\n+\n+      // Already cached.\n+      expect(await request('/base/href/changed/chunk-1.js')).toBe('This is chunk-1.js v2');\n+      updatedServer.assertNoOtherRequests();\n+\n+      // Not cached: Fetch from network.\n+      expect(await request('/base/href/changed/chunk-2.js')).toBe('This is chunk-2.js v2');\n+      updatedServer.assertSawRequestFor('/base/href/changed/chunk-2.js');\n+\n+      // Already cached (copied from old cache).\n+      expect(await request('/base/href/unchanged/chunk-3.js')).toBe('This is chunk-3.js');\n+      updatedServer.assertNoOtherRequests();\n+\n+      // Not cached: Fetch from network.\n+      expect(await request('/base/href/unchanged/chunk-4.js')).toBe('This is chunk-4.js');\n+      updatedServer.assertSawRequestFor('/base/href/unchanged/chunk-4.js');\n+\n+      updatedServer.assertNoOtherRequests();\n+    });\n+\n+    describe('routing', () => {\n+      beforeEach(async () => {\n+        expect(await makeRequest(scope, '/base/href/index.html')).toBe('This is index.html');\n+        await driver.initialized;\n+        serverWithBaseHref.clearRequests();\n+      });\n+\n+      it('redirects to index on a route-like request', async () => {\n+        expect(await makeNavigationRequest(scope, '/base/href/baz')).toBe('This is index.html');\n+        serverWithBaseHref.assertNoOtherRequests();\n+      });\n+\n+      it('redirects to index on a request to the scope URL', async () => {\n+        expect(await makeNavigationRequest(scope, 'http://localhost/base/href/'))\n+            .toBe('This is index.html');\n+        serverWithBaseHref.assertNoOtherRequests();\n+      });\n+    });\n+  });\n+\n   describe('cleanupOldSwCaches()', () => {\n     it('should delete the correct caches', async () => {\n       const oldSwCacheNames = ["
        }
    ],
    "stats": {
        "total": 274,
        "additions": 251,
        "deletions": 23
    }
}