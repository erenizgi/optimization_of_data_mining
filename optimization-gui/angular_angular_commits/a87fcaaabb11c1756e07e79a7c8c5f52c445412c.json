{
    "author": "devversion",
    "message": "test: re-add downlevel decorator transform test (#44281)\n\nRe-adds the accidentally deleted downlevel decorator transform test.\n\nPR Close #44281",
    "sha": "a87fcaaabb11c1756e07e79a7c8c5f52c445412c",
    "files": [
        {
            "sha": "97319801e9ba60579eac38a76fcc2d241c7e6d37",
            "filename": "packages/compiler-cli/test/BUILD.bazel",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/a87fcaaabb11c1756e07e79a7c8c5f52c445412c/packages%2Fcompiler-cli%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/a87fcaaabb11c1756e07e79a7c8c5f52c445412c/packages%2Fcompiler-cli%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2FBUILD.bazel?ref=a87fcaaabb11c1756e07e79a7c8c5f52c445412c",
            "patch": "@@ -52,6 +52,28 @@ jasmine_node_test(\n     ],\n )\n \n+ts_library(\n+    name = \"downlevel_decorator_transform_lib\",\n+    testonly = True,\n+    srcs = [\n+        \"downlevel_decorators_transform_spec.ts\",\n+    ],\n+    deps = [\n+        \":test_utils\",\n+        \"//packages/compiler-cli/src/ngtsc/reflection\",\n+        \"//packages/compiler-cli/src/transformers/downlevel_decorators_transform\",\n+        \"@npm//typescript\",\n+    ],\n+)\n+\n+jasmine_node_test(\n+    name = \"downlevel_decorator_transform\",\n+    bootstrap = [\"//tools/testing:node_es5\"],\n+    deps = [\n+        \":downlevel_decorator_transform_lib\",\n+    ],\n+)\n+\n # perform_watch_spec\n ts_library(\n     name = \"perform_watch_lib\","
        },
        {
            "sha": "44a7951cad9dcedb17449db6f256162e564d4bf1",
            "filename": "packages/compiler-cli/test/downlevel_decorators_transform_spec.ts",
            "status": "added",
            "additions": 869,
            "deletions": 0,
            "changes": 869,
            "blob_url": "https://github.com/angular/angular/blob/a87fcaaabb11c1756e07e79a7c8c5f52c445412c/packages%2Fcompiler-cli%2Ftest%2Fdownlevel_decorators_transform_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a87fcaaabb11c1756e07e79a7c8c5f52c445412c/packages%2Fcompiler-cli%2Ftest%2Fdownlevel_decorators_transform_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fdownlevel_decorators_transform_spec.ts?ref=a87fcaaabb11c1756e07e79a7c8c5f52c445412c",
            "patch": "@@ -0,0 +1,869 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import ts from 'typescript';\n+\n+import {TypeScriptReflectionHost} from '../src/ngtsc/reflection';\n+import {getDownlevelDecoratorsTransform} from '../src/transformers/downlevel_decorators_transform/index';\n+\n+import {MockAotContext, MockCompilerHost} from './mocks';\n+\n+const TEST_FILE_INPUT = '/test.ts';\n+const TEST_FILE_OUTPUT = `/test.js`;\n+const TEST_FILE_DTS_OUTPUT = `/test.d.ts`;\n+\n+describe('downlevel decorator transform', () => {\n+  let host: MockCompilerHost;\n+  let context: MockAotContext;\n+  let diagnostics: ts.Diagnostic[];\n+  let isClosureEnabled: boolean;\n+  let skipClassDecorators: boolean;\n+\n+  beforeEach(() => {\n+    diagnostics = [];\n+    context = new MockAotContext('/', {\n+      'dom_globals.d.ts': `\n+         declare class HTMLElement {};\n+         declare class Document {};\n+       `\n+    });\n+    host = new MockCompilerHost(context);\n+    isClosureEnabled = false;\n+    skipClassDecorators = false;\n+  });\n+\n+  function transform(\n+      contents: string, compilerOptions: ts.CompilerOptions = {},\n+      preTransformers: ts.TransformerFactory<ts.SourceFile>[] = []) {\n+    context.writeFile(TEST_FILE_INPUT, contents);\n+    const program = ts.createProgram(\n+        [TEST_FILE_INPUT, '/dom_globals.d.ts'], {\n+          module: ts.ModuleKind.CommonJS,\n+          importHelpers: true,\n+          lib: ['dom', 'es2015'],\n+          target: ts.ScriptTarget.ES2017,\n+          declaration: true,\n+          experimentalDecorators: true,\n+          emitDecoratorMetadata: false,\n+          ...compilerOptions\n+        },\n+        host);\n+    const testFile = program.getSourceFile(TEST_FILE_INPUT);\n+    const typeChecker = program.getTypeChecker();\n+    const reflectionHost = new TypeScriptReflectionHost(typeChecker);\n+    const transformers: ts.CustomTransformers = {\n+      before: [\n+        ...preTransformers,\n+        getDownlevelDecoratorsTransform(\n+            program.getTypeChecker(), reflectionHost, diagnostics,\n+            /* isCore */ false, isClosureEnabled, skipClassDecorators)\n+      ]\n+    };\n+    let output: string|null = null;\n+    let dtsOutput: string|null = null;\n+    const emitResult = program.emit(\n+        testFile, ((fileName, outputText) => {\n+          if (fileName === TEST_FILE_OUTPUT) {\n+            output = outputText;\n+          } else if (fileName === TEST_FILE_DTS_OUTPUT) {\n+            dtsOutput = outputText;\n+          }\n+        }),\n+        undefined, undefined, transformers);\n+    diagnostics.push(...emitResult.diagnostics);\n+    expect(output).not.toBeNull();\n+    return {\n+      output: omitLeadingWhitespace(output!),\n+      dtsOutput: dtsOutput ? omitLeadingWhitespace(dtsOutput) : null\n+    };\n+  }\n+\n+  it('should downlevel decorators for @Injectable decorated class', () => {\n+    const {output} = transform(`\n+       import {Injectable} from '@angular/core';\n+\n+       export class ClassInject {};\n+\n+       @Injectable()\n+       export class MyService {\n+         constructor(v: ClassInject) {}\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       MyService.decorators = [\n+           { type: core_1.Injectable }\n+       ];\n+       MyService.ctorParameters = () => [\n+           { type: ClassInject }\n+       ];`);\n+    expect(output).not.toContain('tslib');\n+  });\n+\n+  it('should downlevel decorators for @Directive decorated class', () => {\n+    const {output} = transform(`\n+       import {Directive} from '@angular/core';\n+\n+       export class ClassInject {};\n+\n+       @Directive()\n+       export class MyDir {\n+         constructor(v: ClassInject) {}\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       MyDir.decorators = [\n+           { type: core_1.Directive }\n+       ];\n+       MyDir.ctorParameters = () => [\n+           { type: ClassInject }\n+       ];`);\n+    expect(output).not.toContain('tslib');\n+  });\n+\n+  it('should downlevel decorators for @Component decorated class', () => {\n+    const {output} = transform(`\n+       import {Component} from '@angular/core';\n+\n+       export class ClassInject {};\n+\n+       @Component({template: 'hello'})\n+       export class MyComp {\n+         constructor(v: ClassInject) {}\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       MyComp.decorators = [\n+         { type: core_1.Component, args: [{ template: 'hello' },] }\n+       ];\n+       MyComp.ctorParameters = () => [\n+         { type: ClassInject }\n+       ];`);\n+    expect(output).not.toContain('tslib');\n+  });\n+\n+  it('should downlevel decorators for @Pipe decorated class', () => {\n+    const {output} = transform(`\n+       import {Pipe} from '@angular/core';\n+\n+       export class ClassInject {};\n+\n+       @Pipe({selector: 'hello'})\n+       export class MyPipe {\n+         constructor(v: ClassInject) {}\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       MyPipe.decorators = [\n+         { type: core_1.Pipe, args: [{ selector: 'hello' },] }\n+       ];\n+       MyPipe.ctorParameters = () => [\n+         { type: ClassInject }\n+       ];`);\n+    expect(output).not.toContain('tslib');\n+  });\n+\n+  it('should not downlevel non-Angular class decorators', () => {\n+    const {output} = transform(`\n+       @SomeUnknownDecorator()\n+       export class MyClass {}\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       MyClass = (0, tslib_1.__decorate)([\n+         SomeUnknownDecorator()\n+       ], MyClass);\n+     `);\n+    expect(output).not.toContain('MyClass.decorators');\n+  });\n+\n+  it('should not downlevel non-Angular class decorators generated by a builder', () => {\n+    const {output} = transform(`\n+       @DecoratorBuilder().customClassDecorator\n+       export class MyClass {}\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       MyClass = (0, tslib_1.__decorate)([\n+         DecoratorBuilder().customClassDecorator\n+       ], MyClass);\n+     `);\n+    expect(output).not.toContain('MyClass.decorators');\n+  });\n+\n+  it('should downlevel Angular-decorated class member', () => {\n+    const {output} = transform(`\n+       import {Input} from '@angular/core';\n+\n+       export class MyDir {\n+         @Input() disabled: boolean = false;\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       MyDir.propDecorators = {\n+         disabled: [{ type: core_1.Input }]\n+       };\n+     `);\n+    expect(output).not.toContain('tslib');\n+  });\n+\n+  it('should not downlevel class member with unknown decorator', () => {\n+    const {output} = transform(`\n+       export class MyDir {\n+         @SomeDecorator() disabled: boolean = false;\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       (0, tslib_1.__decorate)([\n+         SomeDecorator()\n+       ], MyDir.prototype, \"disabled\", void 0);\n+     `);\n+    expect(output).not.toContain('MyClass.propDecorators');\n+  });\n+\n+  // Angular is not concerned with type information for decorated class members. Instead,\n+  // the type is omitted. This also helps with server side rendering as DOM globals which\n+  // are used as types, do not load at runtime. https://github.com/angular/angular/issues/30586.\n+  it('should downlevel Angular-decorated class member but not preserve type', () => {\n+    context.writeFile('/other-file.ts', `export class MyOtherClass {}`);\n+    const {output} = transform(`\n+       import {Input} from '@angular/core';\n+       import {MyOtherClass} from './other-file';\n+\n+       export class MyDir {\n+         @Input() trigger: HTMLElement;\n+         @Input() fromOtherFile: MyOtherClass;\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       MyDir.propDecorators = {\n+         trigger: [{ type: core_1.Input }],\n+         fromOtherFile: [{ type: core_1.Input }]\n+       };\n+     `);\n+    expect(output).not.toContain('HTMLElement');\n+    expect(output).not.toContain('MyOtherClass');\n+  });\n+\n+  it('should capture constructor type metadata with `emitDecoratorMetadata` enabled', () => {\n+    context.writeFile('/other-file.ts', `export class MyOtherClass {}`);\n+    const {output} = transform(\n+        `\n+       import {Directive} from '@angular/core';\n+       import {MyOtherClass} from './other-file';\n+\n+       @Directive()\n+       export class MyDir {\n+         constructor(other: MyOtherClass) {}\n+       }\n+     `,\n+        {emitDecoratorMetadata: true});\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain('const other_file_1 = require(\"./other-file\");');\n+    expect(output).toContain(dedent`\n+       MyDir.decorators = [\n+         { type: core_1.Directive }\n+       ];\n+       MyDir.ctorParameters = () => [\n+         { type: other_file_1.MyOtherClass }\n+       ];\n+     `);\n+  });\n+\n+  it('should capture constructor type metadata with `emitDecoratorMetadata` disabled', () => {\n+    context.writeFile('/other-file.ts', `export class MyOtherClass {}`);\n+    const {output, dtsOutput} = transform(\n+        `\n+       import {Directive} from '@angular/core';\n+       import {MyOtherClass} from './other-file';\n+\n+       @Directive()\n+       export class MyDir {\n+         constructor(other: MyOtherClass) {}\n+       }\n+     `,\n+        {emitDecoratorMetadata: false});\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain('const other_file_1 = require(\"./other-file\");');\n+    expect(output).toContain(dedent`\n+       MyDir.decorators = [\n+         { type: core_1.Directive }\n+       ];\n+       MyDir.ctorParameters = () => [\n+         { type: other_file_1.MyOtherClass }\n+       ];\n+     `);\n+    expect(dtsOutput).toContain('import');\n+  });\n+\n+  it('should properly serialize constructor parameter with external qualified name type', () => {\n+    context.writeFile('/other-file.ts', `export class MyOtherClass {}`);\n+    const {output} = transform(`\n+       import {Directive} from '@angular/core';\n+       import * as externalFile from './other-file';\n+\n+       @Directive()\n+       export class MyDir {\n+         constructor(other: externalFile.MyOtherClass) {}\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain('const externalFile = require(\"./other-file\");');\n+    expect(output).toContain(dedent`\n+       MyDir.decorators = [\n+         { type: core_1.Directive }\n+       ];\n+       MyDir.ctorParameters = () => [\n+         { type: externalFile.MyOtherClass }\n+       ];\n+     `);\n+  });\n+\n+  it('should properly serialize constructor parameter with local qualified name type', () => {\n+    const {output} = transform(`\n+       import {Directive} from '@angular/core';\n+\n+       namespace other {\n+         export class OtherClass {}\n+       };\n+\n+       @Directive()\n+       export class MyDir {\n+         constructor(other: other.OtherClass) {}\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain('var other;');\n+    expect(output).toContain(dedent`\n+       MyDir.decorators = [\n+         { type: core_1.Directive }\n+       ];\n+       MyDir.ctorParameters = () => [\n+         { type: other.OtherClass }\n+       ];\n+     `);\n+  });\n+\n+  it('should properly downlevel constructor parameter decorators', () => {\n+    const {output} = transform(`\n+       import {Inject, Directive, DOCUMENT} from '@angular/core';\n+\n+       @Directive()\n+       export class MyDir {\n+         constructor(@Inject(DOCUMENT) document: Document) {}\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       MyDir.decorators = [\n+         { type: core_1.Directive }\n+       ];\n+       MyDir.ctorParameters = () => [\n+         { type: Document, decorators: [{ type: core_1.Inject, args: [core_1.DOCUMENT,] }] }\n+       ];\n+     `);\n+  });\n+\n+  it('should properly downlevel constructor parameters with union type', () => {\n+    const {output} = transform(`\n+       import {Optional, Directive, NgZone} from '@angular/core';\n+\n+       @Directive()\n+       export class MyDir {\n+         constructor(@Optional() ngZone: NgZone|null) {}\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       MyDir.decorators = [\n+         { type: core_1.Directive }\n+       ];\n+       MyDir.ctorParameters = () => [\n+         { type: core_1.NgZone, decorators: [{ type: core_1.Optional }] }\n+       ];\n+     `);\n+  });\n+\n+  it('should add @nocollapse if closure compiler is enabled', () => {\n+    isClosureEnabled = true;\n+    const {output} = transform(`\n+       import {Directive} from '@angular/core';\n+\n+       export class ClassInject {};\n+\n+       @Directive()\n+       export class MyDir {\n+         constructor(v: ClassInject) {}\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */\n+       MyDir.decorators = [\n+         { type: core_1.Directive }\n+       ];\n+     `);\n+    expect(output).toContain(dedent`\n+       /**\n+        * @type {function(): !Array<(null|{\n+        *   type: ?,\n+        *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),\n+        * })>}\n+        * @nocollapse\n+        */\n+        MyDir.ctorParameters = () => [\n+         { type: ClassInject }\n+       ];\n+     `);\n+    expect(output).not.toContain('tslib');\n+  });\n+\n+  it('should not retain unused type imports due to decorator downleveling with ' +\n+         '`emitDecoratorMetadata` enabled.',\n+     () => {\n+       context.writeFile('/external.ts', `\n+       export class ErrorHandler {}\n+       export class ClassInject {}\n+     `);\n+       const {output} = transform(\n+           `\n+       import {Directive} from '@angular/core';\n+       import {ErrorHandler, ClassInject} from './external';\n+\n+       @Directive()\n+       export class MyDir {\n+         private _errorHandler: ErrorHandler;\n+         constructor(v: ClassInject) {}\n+       }\n+     `,\n+           {module: ts.ModuleKind.ES2015, emitDecoratorMetadata: true});\n+\n+       expect(diagnostics.length).toBe(0);\n+       expect(output).not.toContain('tslib');\n+       expect(output).not.toContain('ErrorHandler');\n+     });\n+\n+  it('should not retain unused type imports due to decorator downleveling with ' +\n+         '`emitDecoratorMetadata` disabled',\n+     () => {\n+       context.writeFile('/external.ts', `\n+       export class ErrorHandler {}\n+       export class ClassInject {}\n+     `);\n+       const {output} = transform(\n+           `\n+       import {Directive} from '@angular/core';\n+       import {ErrorHandler, ClassInject} from './external';\n+\n+       @Directive()\n+       export class MyDir {\n+         private _errorHandler: ErrorHandler;\n+         constructor(v: ClassInject) {}\n+       }\n+     `,\n+           {module: ts.ModuleKind.ES2015, emitDecoratorMetadata: false});\n+\n+       expect(diagnostics.length).toBe(0);\n+       expect(output).not.toContain('tslib');\n+       expect(output).not.toContain('ErrorHandler');\n+     });\n+\n+  it('should not generate invalid reference due to conflicting parameter name', () => {\n+    context.writeFile('/external.ts', `\n+       export class Dep {\n+         greet() {}\n+       }\n+     `);\n+    const {output} = transform(\n+        `\n+       import {Directive} from '@angular/core';\n+       import {Dep} from './external';\n+\n+       @Directive()\n+       export class MyDir {\n+         constructor(Dep: Dep) {\n+           Dep.greet();\n+         }\n+       }\n+     `,\n+        {emitDecoratorMetadata: false});\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).not.toContain('tslib');\n+    expect(output).toContain(`external_1 = require(\"./external\");`);\n+    expect(output).toContain(dedent`\n+       MyDir.decorators = [\n+         { type: core_1.Directive }\n+       ];\n+       MyDir.ctorParameters = () => [\n+         { type: external_1.Dep }\n+       ];\n+     `);\n+  });\n+\n+  it('should be able to serialize circular constructor parameter type', () => {\n+    const {output} = transform(`\n+       import {Directive, Optional, Inject, SkipSelf} from '@angular/core';\n+\n+       @Directive()\n+       export class MyDir {\n+         constructor(@Optional() @SkipSelf() @Inject(MyDir) parentDir: MyDir|null) {}\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       MyDir.decorators = [\n+         { type: core_1.Directive }\n+       ];\n+       MyDir.ctorParameters = () => [\n+         { type: MyDir, decorators: [{ type: core_1.Optional }, { type: core_1.SkipSelf }, { type: core_1.Inject, args: [MyDir,] }] }\n+       ];\n+     `);\n+  });\n+\n+  it('should create diagnostic if property name is non-serializable', () => {\n+    transform(`\n+       import {Directive, ViewChild, TemplateRef} from '@angular/core';\n+\n+       @Directive()\n+       export class MyDir {\n+         @ViewChild(TemplateRef) ['some' + 'name']: TemplateRef<any>|undefined;\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(1);\n+    expect(diagnostics[0].messageText as string)\n+        .toBe(`Cannot process decorators for class element with non-analyzable name.`);\n+  });\n+\n+  it('should not capture constructor parameter types when not resolving to a value', () => {\n+    context.writeFile('/external.ts', `\n+       export interface IState {}\n+       export type IOverlay = {hello: true}&IState;\n+       export default interface {\n+         hello: false;\n+       }\n+       export const enum KeyCodes {A, B}\n+     `);\n+    const {output} = transform(`\n+       import {Directive, Inject} from '@angular/core';\n+       import * as angular from './external';\n+       import {IOverlay, KeyCodes} from './external';\n+       import TypeFromDefaultImport from './external';\n+\n+       @Directive()\n+       export class MyDir {\n+         constructor(@Inject('$state') param: angular.IState,\n+                     @Inject('$overlay') other: IOverlay,\n+                     @Inject('$default') default: TypeFromDefaultImport,\n+                     @Inject('$keyCodes') keyCodes: KeyCodes) {}\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).not.toContain('external');\n+    expect(output).toContain(dedent`\n+       MyDir.decorators = [\n+         { type: core_1.Directive }\n+       ];\n+       MyDir.ctorParameters = () => [\n+         { type: undefined, decorators: [{ type: core_1.Inject, args: ['$state',] }] },\n+         { type: undefined, decorators: [{ type: core_1.Inject, args: ['$overlay',] }] },\n+         { type: undefined, decorators: [{ type: core_1.Inject, args: ['$default',] }] },\n+         { type: undefined, decorators: [{ type: core_1.Inject, args: ['$keyCodes',] }] }\n+       ];\n+     `);\n+  });\n+\n+  it('should allow preceding custom transformers to strip decorators', () => {\n+    const stripAllDecoratorsTransform: ts.TransformerFactory<ts.SourceFile> = context => {\n+      return (sourceFile: ts.SourceFile) => {\n+        const visitNode = (node: ts.Node): ts.Node => {\n+          if (ts.isClassDeclaration(node) || ts.isClassElement(node)) {\n+            const cloned = ts.getMutableClone(node);\n+            (cloned.decorators as undefined) = undefined;\n+            return cloned;\n+          }\n+          return ts.visitEachChild(node, visitNode, context);\n+        };\n+        return visitNode(sourceFile) as ts.SourceFile;\n+      };\n+    };\n+\n+    const {output} = transform(\n+        `\n+       import {Directive} from '@angular/core';\n+\n+       export class MyInjectedClass {}\n+\n+       @Directive()\n+       export class MyDir {\n+         constructor(someToken: MyInjectedClass) {}\n+       }\n+     `,\n+        {}, [stripAllDecoratorsTransform]);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).not.toContain('MyDir.decorators');\n+    expect(output).not.toContain('MyDir.ctorParameters');\n+    expect(output).not.toContain('tslib');\n+  });\n+\n+  it('should capture a non-const enum used as a constructor type', () => {\n+    const {output} = transform(`\n+       import {Component} from '@angular/core';\n+\n+       export enum Values {A, B};\n+\n+       @Component({template: 'hello'})\n+       export class MyComp {\n+         constructor(v: Values) {}\n+       }\n+     `);\n+\n+    expect(diagnostics.length).toBe(0);\n+    expect(output).toContain(dedent`\n+       MyComp.decorators = [\n+         { type: core_1.Component, args: [{ template: 'hello' },] }\n+       ];\n+       MyComp.ctorParameters = () => [\n+         { type: Values }\n+       ];`);\n+    expect(output).not.toContain('tslib');\n+  });\n+\n+  describe('class decorators skipped', () => {\n+    beforeEach(() => skipClassDecorators = true);\n+\n+    it('should not downlevel Angular class decorators', () => {\n+      const {output} = transform(`\n+         import {Injectable} from '@angular/core';\n+\n+         @Injectable()\n+         export class MyService {}\n+       `);\n+\n+      expect(diagnostics.length).toBe(0);\n+      expect(output).not.toContain('MyService.decorators');\n+      expect(output).toContain(dedent`\n+         MyService = (0, tslib_1.__decorate)([\n+           (0, core_1.Injectable)()\n+         ], MyService);\n+       `);\n+    });\n+\n+    it('should downlevel constructor parameters', () => {\n+      const {output} = transform(`\n+         import {Injectable} from '@angular/core';\n+\n+         @Injectable()\n+         export class InjectClass {}\n+\n+         @Injectable()\n+         export class MyService {\n+           constructor(dep: InjectClass) {}\n+         }\n+       `);\n+\n+      expect(diagnostics.length).toBe(0);\n+      expect(output).not.toContain('MyService.decorators');\n+      expect(output).toContain('MyService.ctorParameters');\n+      expect(output).toContain(dedent`\n+         MyService.ctorParameters = () => [\n+           { type: InjectClass }\n+         ];\n+         MyService = (0, tslib_1.__decorate)([\n+           (0, core_1.Injectable)()\n+         ], MyService);\n+       `);\n+    });\n+\n+    it('should downlevel constructor parameter decorators', () => {\n+      const {output} = transform(`\n+         import {Injectable, Inject} from '@angular/core';\n+\n+         @Injectable()\n+         export class InjectClass {}\n+\n+         @Injectable()\n+         export class MyService {\n+           constructor(@Inject('test') dep: InjectClass) {}\n+         }\n+       `);\n+\n+      expect(diagnostics.length).toBe(0);\n+      expect(output).not.toContain('MyService.decorators');\n+      expect(output).toContain('MyService.ctorParameters');\n+      expect(output).toContain(dedent`\n+         MyService.ctorParameters = () => [\n+           { type: InjectClass, decorators: [{ type: core_1.Inject, args: ['test',] }] }\n+         ];\n+         MyService = (0, tslib_1.__decorate)([\n+           (0, core_1.Injectable)()\n+         ], MyService);\n+       `);\n+    });\n+\n+    it('should downlevel class member Angular decorators', () => {\n+      const {output} = transform(`\n+         import {Injectable, Input} from '@angular/core';\n+\n+         export class MyService {\n+           @Input() disabled: boolean;\n+         }\n+       `);\n+\n+      expect(diagnostics.length).toBe(0);\n+      expect(output).not.toContain('tslib');\n+      expect(output).toContain(dedent`\n+         MyService.propDecorators = {\n+           disabled: [{ type: core_1.Input }]\n+         };\n+       `);\n+    });\n+  });\n+\n+  describe('transforming multiple files', () => {\n+    it('should work correctly for multiple files that import distinct declarations', () => {\n+      context.writeFile('foo_service.d.ts', `\n+         export declare class Foo {};\n+       `);\n+      context.writeFile('foo.ts', `\n+         import {Injectable} from '@angular/core';\n+         import {Foo} from './foo_service';\n+\n+         @Injectable()\n+         export class MyService {\n+           constructor(foo: Foo) {}\n+         }\n+       `);\n+\n+      context.writeFile('bar_service.d.ts', `\n+         export declare class Bar {};\n+       `);\n+      context.writeFile('bar.ts', `\n+         import {Injectable} from '@angular/core';\n+         import {Bar} from './bar_service';\n+\n+         @Injectable()\n+         export class MyService {\n+           constructor(bar: Bar) {}\n+         }\n+       `);\n+\n+      const {program, transformers} = createProgramWithTransform(['/foo.ts', '/bar.ts']);\n+      program.emit(undefined, undefined, undefined, undefined, transformers);\n+\n+      expect(context.readFile('/foo.js')).toContain(`import { Foo } from './foo_service';`);\n+      expect(context.readFile('/bar.js')).toContain(`import { Bar } from './bar_service';`);\n+    });\n+\n+    it('should not result in a stack overflow for a large number of files', () => {\n+      // The decorators transform used to patch `ts.EmitResolver.isReferencedAliasDeclaration`\n+      // repeatedly for each source file in the program, causing a stack overflow once a large\n+      // number of source files was reached. This test verifies that emit succeeds even when there's\n+      // lots of source files. See https://github.com/angular/angular/issues/40276.\n+      context.writeFile('foo.d.ts', `\n+         export declare class Foo {};\n+       `);\n+\n+      // A somewhat minimal number of source files that used to trigger a stack overflow.\n+      const numberOfTestFiles = 6500;\n+      const files: string[] = [];\n+      for (let i = 0; i < numberOfTestFiles; i++) {\n+        const file = `/${i}.ts`;\n+        files.push(file);\n+        context.writeFile(file, `\n+           import {Injectable} from '@angular/core';\n+           import {Foo} from './foo';\n+\n+           @Injectable()\n+           export class MyService {\n+             constructor(foo: Foo) {}\n+           }\n+         `);\n+      }\n+\n+      const {program, transformers} = createProgramWithTransform(files);\n+\n+      let written = 0;\n+      program.emit(undefined, (fileName, outputText) => {\n+        written++;\n+\n+        // The below assertion throws an explicit error instead of using a Jasmine expectation,\n+        // as we want to abort on the first failure, if any. This avoids as many as `numberOfFiles`\n+        // expectation failures, which would bloat the test output.\n+        if (!outputText.includes(`import { Foo } from './foo';`)) {\n+          throw new Error(`Transform failed to preserve the import in ${fileName}:\\n${outputText}`);\n+        }\n+      }, undefined, undefined, transformers);\n+      expect(written).toBe(numberOfTestFiles);\n+    });\n+\n+    function createProgramWithTransform(files: string[]) {\n+      const program = ts.createProgram(\n+          files, {\n+            moduleResolution: ts.ModuleResolutionKind.NodeJs,\n+            importHelpers: true,\n+            lib: [],\n+            module: ts.ModuleKind.ESNext,\n+            target: ts.ScriptTarget.Latest,\n+            declaration: false,\n+            experimentalDecorators: true,\n+            emitDecoratorMetadata: false,\n+          },\n+          host);\n+      const typeChecker = program.getTypeChecker();\n+      const reflectionHost = new TypeScriptReflectionHost(typeChecker);\n+      const transformers: ts.CustomTransformers = {\n+        before: [getDownlevelDecoratorsTransform(\n+            program.getTypeChecker(), reflectionHost, diagnostics,\n+            /* isCore */ false, isClosureEnabled, skipClassDecorators)]\n+      };\n+      return {program, transformers};\n+    }\n+  });\n+});\n+\n+/** Template string function that can be used to dedent a given string literal. */\n+export function dedent(strings: TemplateStringsArray, ...values: any[]) {\n+  let joinedString = '';\n+  for (let i = 0; i < values.length; i++) {\n+    joinedString += `${strings[i]}${values[i]}`;\n+  }\n+  joinedString += strings[strings.length - 1];\n+  return omitLeadingWhitespace(joinedString);\n+}\n+\n+/** Omits the leading whitespace for each line of the given text. */\n+function omitLeadingWhitespace(text: string): string {\n+  return text.replace(/^\\s+/gm, '');\n+}"
        }
    ],
    "stats": {
        "total": 891,
        "additions": 891,
        "deletions": 0
    }
}