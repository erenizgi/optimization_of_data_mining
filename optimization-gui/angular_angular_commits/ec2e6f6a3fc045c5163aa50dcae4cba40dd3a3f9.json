{
    "author": "atscott",
    "message": "fix(compiler): correct spans when parsing bindings with comments (#44785)\n\nThe previous fix for correcting spans with comments in\nhttps://github.com/angular/angular/commit/59eef29a6c5d568ca80595cd7018e21ad406c85d\nhad the unfortunate side effect of _breaking_ the spans with comments\nwhen there was leading whitespace. This happened because the previous\nfix was testing one without a comment, identifying that the offset shouldn't\nhave anything added to it, and then removing that offset adjustment\n(`offsets[i] + (expressionText.length - sourceToLex.length)`).\n\nUpon further investigation, this offset adjustment _was actually\nnecessary_ for when the input had comments, but this was only because\nthe `stripComments` function used `trim` to remove whitespace for these\ncases. This is the real problem -- not only does it create a ton of confusion\nbut also it means that the behavior of the lexer and resulting spans is\ndifferent between inputs with comments and inputs without comments.\n\nAfter reviewing how the `inputLength` of `_ParseAST` was used, it\nappears that the correct behavior would be to _not_ trim the input. The\n`inputLength` is used to advance the current index beyond points which\nhave been processed. This _should_ include any whitespace. Additionally,\n`inputLength` doesn't appear to be needed at all. When there was no\ncomment in the input, it was always equal to the `input.length` anyways.\nWhen there _is_ a comment, it should include that comment anyways to\nadvance the index beyond the comment.\n\nPR Close #44785",
    "sha": "ec2e6f6a3fc045c5163aa50dcae4cba40dd3a3f9",
    "files": [
        {
            "sha": "1e168755e861bbca660d9ed12a0d8f80142f32fd",
            "filename": "packages/compiler-cli/src/ngtsc/indexer/test/template_spec.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/ec2e6f6a3fc045c5163aa50dcae4cba40dd3a3f9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Ftest%2Ftemplate_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ec2e6f6a3fc045c5163aa50dcae4cba40dd3a3f9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Ftest%2Ftemplate_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Ftest%2Ftemplate_spec.ts?ref=ec2e6f6a3fc045c5163aa50dcae4cba40dd3a3f9",
            "patch": "@@ -62,6 +62,19 @@ runInEachFileSystem(() => {\n       });\n     });\n \n+    it('should handle whitespace and comments in interpolations', () => {\n+      const template = '{{   foo // comment   }}';\n+      const refs = getTemplateIdentifiers(bind(template));\n+\n+      const [ref] = Array.from(refs);\n+      expect(ref).toEqual({\n+        name: 'foo',\n+        kind: IdentifierKind.Property,\n+        span: new AbsoluteSourceSpan(5, 8),\n+        target: null,\n+      });\n+    });\n+\n     it('should generate nothing in empty template', () => {\n       const template = '';\n       const refs = getTemplateIdentifiers(bind(template));"
        },
        {
            "sha": "8121550104ceae927b749bf49ee99340bd59b3a5",
            "filename": "packages/compiler/src/expression_parser/parser.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 18,
            "changes": 32,
            "blob_url": "https://github.com/angular/angular/blob/ec2e6f6a3fc045c5163aa50dcae4cba40dd3a3f9/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/ec2e6f6a3fc045c5163aa50dcae4cba40dd3a3f9/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts?ref=ec2e6f6a3fc045c5163aa50dcae4cba40dd3a3f9",
            "patch": "@@ -41,9 +41,7 @@ export class Parser {\n     const sourceToLex = this._stripComments(input);\n     const tokens = this._lexer.tokenize(sourceToLex);\n     const ast =\n-        new _ParseAST(\n-            input, location, absoluteOffset, tokens, sourceToLex.length, true, this.errors, 0)\n-            .parseChain();\n+        new _ParseAST(input, location, absoluteOffset, tokens, true, this.errors, 0).parseChain();\n     return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n   }\n \n@@ -90,8 +88,7 @@ export class Parser {\n     this._checkNoInterpolation(input, location, interpolationConfig);\n     const sourceToLex = this._stripComments(input);\n     const tokens = this._lexer.tokenize(sourceToLex);\n-    return new _ParseAST(\n-               input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, 0)\n+    return new _ParseAST(input, location, absoluteOffset, tokens, false, this.errors, 0)\n         .parseChain();\n   }\n \n@@ -138,8 +135,8 @@ export class Parser {\n       absoluteValueOffset: number): TemplateBindingParseResult {\n     const tokens = this._lexer.tokenize(templateValue);\n     const parser = new _ParseAST(\n-        templateValue, templateUrl, absoluteValueOffset, tokens, templateValue.length,\n-        false /* parseAction */, this.errors, 0 /* relative offset */);\n+        templateValue, templateUrl, absoluteValueOffset, tokens, false /* parseAction */,\n+        this.errors, 0 /* relative offset */);\n     return parser.parseTemplateBindings({\n       source: templateKey,\n       span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),\n@@ -159,10 +156,9 @@ export class Parser {\n       const expressionText = expressions[i].text;\n       const sourceToLex = this._stripComments(expressionText);\n       const tokens = this._lexer.tokenize(sourceToLex);\n-      const ast = new _ParseAST(\n-                      input, location, absoluteOffset, tokens, sourceToLex.length, false,\n-                      this.errors, offsets[i])\n-                      .parseChain();\n+      const ast =\n+          new _ParseAST(input, location, absoluteOffset, tokens, false, this.errors, offsets[i])\n+              .parseChain();\n       expressionNodes.push(ast);\n     }\n \n@@ -180,7 +176,7 @@ export class Parser {\n     const sourceToLex = this._stripComments(expression);\n     const tokens = this._lexer.tokenize(sourceToLex);\n     const ast = new _ParseAST(\n-                    expression, location, absoluteOffset, tokens, sourceToLex.length,\n+                    expression, location, absoluteOffset, tokens,\n                     /* parseAction */ false, this.errors, 0)\n                     .parseChain();\n     const strings = ['', ''];  // The prefix and suffix strings are both empty\n@@ -275,7 +271,7 @@ export class Parser {\n \n   private _stripComments(input: string): string {\n     const i = this._commentStart(input);\n-    return i != null ? input.substring(0, i).trim() : input;\n+    return i != null ? input.substring(0, i) : input;\n   }\n \n   private _commentStart(input: string): number|null {\n@@ -392,8 +388,8 @@ export class _ParseAST {\n \n   constructor(\n       public input: string, public location: string, public absoluteOffset: number,\n-      public tokens: Token[], public inputLength: number, public parseAction: boolean,\n-      private errors: ParserError[], private offset: number) {}\n+      public tokens: Token[], public parseAction: boolean, private errors: ParserError[],\n+      private offset: number) {}\n \n   peek(offset: number): Token {\n     const i = this.index + offset;\n@@ -429,7 +425,7 @@ export class _ParseAST {\n     // No tokens have been processed yet; return the next token's start or the length of the input\n     // if there is no token.\n     if (this.tokens.length === 0) {\n-      return this.inputLength + this.offset;\n+      return this.input.length + this.offset;\n     }\n     return this.next.index + this.offset;\n   }\n@@ -587,7 +583,7 @@ export class _ParseAST {\n     if (exprs.length == 0) {\n       // We have no expressions so create an empty expression that spans the entire input length\n       const artificialStart = this.offset;\n-      const artificialEnd = this.offset + this.inputLength;\n+      const artificialEnd = this.offset + this.input.length;\n       return new EmptyExpr(\n           this.span(artificialStart, artificialEnd),\n           this.sourceSpan(artificialStart, artificialEnd));\n@@ -623,7 +619,7 @@ export class _ParseAST {\n           //\n           // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\n           // beginning of the next token, or until the end of input if the next token is EOF.\n-          fullSpanEnd = this.next.index !== -1 ? this.next.index : this.inputLength + this.offset;\n+          fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;\n \n           // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\n           // beyond the pipe character."
        },
        {
            "sha": "56bee6cbacaacf7eec8af104bb3466931300c72b",
            "filename": "packages/compiler/test/render3/r3_ast_absolute_span_spec.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/ec2e6f6a3fc045c5163aa50dcae4cba40dd3a3f9/packages%2Fcompiler%2Ftest%2Frender3%2Fr3_ast_absolute_span_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ec2e6f6a3fc045c5163aa50dcae4cba40dd3a3f9/packages%2Fcompiler%2Ftest%2Frender3%2Fr3_ast_absolute_span_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Frender3%2Fr3_ast_absolute_span_spec.ts?ref=ec2e6f6a3fc045c5163aa50dcae4cba40dd3a3f9",
            "patch": "@@ -17,6 +17,17 @@ describe('expression AST absolute source spans', () => {\n         .toContain(['foo', new AbsoluteSourceSpan(2, 5)]);\n   });\n \n+  it('should handle whitespace in interpolation', () => {\n+    expect(humanizeExpressionSource(parse('{{  foo  }}', {preserveWhitespaces: true}).nodes))\n+        .toContain(['foo', new AbsoluteSourceSpan(4, 7)]);\n+  });\n+\n+  it('should handle whitespace and comment in interpolation', () => {\n+    expect(humanizeExpressionSource(\n+               parse('{{  foo // comment  }}', {preserveWhitespaces: true}).nodes))\n+        .toContain(['foo', new AbsoluteSourceSpan(4, 7)]);\n+  });\n+\n   it('should handle comment in an action binding', () => {\n     expect(humanizeExpressionSource(parse('<button (click)=\"foo = true // comment\">Save</button>', {\n                                       preserveWhitespaces: true"
        }
    ],
    "stats": {
        "total": 56,
        "additions": 38,
        "deletions": 18
    }
}