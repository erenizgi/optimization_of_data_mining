{
    "author": "atscott",
    "message": "fix(language-service): Support 'go to definition' for two-way bindings (#40185)\n\nRather than expecting that a position in a template only targets a\nsingle node, this commit adjusts the approach to account for two way\nbindings. In particular, we attempt to get definitions for each targeted\nnode and then return the combination of all results, or `undefined` if\nnone of the target nodes had definitions.\n\nPR Close #40185",
    "sha": "a9d8c228d9a4f96c056018078ba541aeb1462ae0",
    "files": [
        {
            "sha": "b748f78eeca6892991fb4361845cbe4f60638121",
            "filename": "packages/language-service/ivy/definitions.ts",
            "status": "modified",
            "additions": 76,
            "deletions": 46,
            "changes": 122,
            "blob_url": "https://github.com/angular/angular/blob/a9d8c228d9a4f96c056018078ba541aeb1462ae0/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "raw_url": "https://github.com/angular/angular/raw/a9d8c228d9a4f96c056018078ba541aeb1462ae0/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts?ref=a9d8c228d9a4f96c056018078ba541aeb1462ae0",
            "patch": "@@ -41,17 +41,29 @@ export class DefinitionBuilder {\n       }\n       return getDefinitionForExpressionAtPosition(fileName, position, this.compiler);\n     }\n-    const definitionMeta = this.getDefinitionMetaAtPosition(templateInfo, position);\n-    // The `$event` of event handlers would point to the $event parameter in the shim file, as in\n-    // `_outputHelper(_t3[\"x\"]).subscribe(function ($event): any { $event }) ;`\n-    // If we wanted to return something for this, it would be more appropriate for something like\n-    // `getTypeDefinition`.\n-    if (definitionMeta === undefined || isDollarEvent(definitionMeta.node)) {\n+    const definitionMetas = this.getDefinitionMetaAtPosition(templateInfo, position);\n+    if (definitionMetas === undefined) {\n       return undefined;\n     }\n+    const definitions: ts.DefinitionInfo[] = [];\n+    for (const definitionMeta of definitionMetas) {\n+      // The `$event` of event handlers would point to the $event parameter in the shim file, as in\n+      // `_outputHelper(_t3[\"x\"]).subscribe(function ($event): any { $event }) ;`\n+      // If we wanted to return something for this, it would be more appropriate for something like\n+      // `getTypeDefinition`.\n+      if (isDollarEvent(definitionMeta.node)) {\n+        continue;\n+      }\n+\n+      definitions.push(\n+          ...(this.getDefinitionsForSymbol({...definitionMeta, ...templateInfo}) ?? []));\n+    }\n \n-    const definitions = this.getDefinitionsForSymbol({...definitionMeta, ...templateInfo});\n-    return {definitions, textSpan: getTextSpanOfNode(definitionMeta.node)};\n+    if (definitions.length === 0) {\n+      return undefined;\n+    }\n+\n+    return {definitions, textSpan: getTextSpanOfNode(definitionMetas[0].node)};\n   }\n \n   private getDefinitionsForSymbol({symbol, node, parent, component}: DefinitionMeta&\n@@ -123,42 +135,55 @@ export class DefinitionBuilder {\n     if (templateInfo === undefined) {\n       return;\n     }\n-    const definitionMeta = this.getDefinitionMetaAtPosition(templateInfo, position);\n-    if (definitionMeta === undefined) {\n+    const definitionMetas = this.getDefinitionMetaAtPosition(templateInfo, position);\n+    if (definitionMetas === undefined) {\n       return undefined;\n     }\n \n-    const {symbol, node} = definitionMeta;\n-    switch (symbol.kind) {\n-      case SymbolKind.Directive:\n-      case SymbolKind.DomBinding:\n-      case SymbolKind.Element:\n-      case SymbolKind.Template:\n-        return this.getTypeDefinitionsForTemplateInstance(symbol, node);\n-      case SymbolKind.Output:\n-      case SymbolKind.Input: {\n-        const bindingDefs = this.getTypeDefinitionsForSymbols(...symbol.bindings);\n-        // Also attempt to get directive matches for the input name. If there is a directive that\n-        // has the input name as part of the selector, we want to return that as well.\n-        const directiveDefs = this.getDirectiveTypeDefsForBindingNode(\n-            node, definitionMeta.parent, templateInfo.component);\n-        return [...bindingDefs, ...directiveDefs];\n-      }\n-      case SymbolKind.Pipe: {\n-        if (symbol.tsSymbol !== null) {\n-          return this.getTypeDefinitionsForSymbols(symbol);\n-        } else {\n-          // If there is no `ts.Symbol` for the pipe transform, we want to return the\n-          // type definition (the pipe class).\n-          return this.getTypeDefinitionsForSymbols(symbol.classSymbol);\n+    const definitions: ts.DefinitionInfo[] = [];\n+    for (const {symbol, node, parent} of definitionMetas) {\n+      switch (symbol.kind) {\n+        case SymbolKind.Directive:\n+        case SymbolKind.DomBinding:\n+        case SymbolKind.Element:\n+        case SymbolKind.Template:\n+          definitions.push(...this.getTypeDefinitionsForTemplateInstance(symbol, node));\n+          break;\n+        case SymbolKind.Output:\n+        case SymbolKind.Input: {\n+          const bindingDefs = this.getTypeDefinitionsForSymbols(...symbol.bindings);\n+          definitions.push(...bindingDefs);\n+          // Also attempt to get directive matches for the input name. If there is a directive that\n+          // has the input name as part of the selector, we want to return that as well.\n+          const directiveDefs =\n+              this.getDirectiveTypeDefsForBindingNode(node, parent, templateInfo.component);\n+          definitions.push(...directiveDefs);\n+          break;\n+        }\n+        case SymbolKind.Pipe: {\n+          if (symbol.tsSymbol !== null) {\n+            definitions.push(...this.getTypeDefinitionsForSymbols(symbol));\n+          } else {\n+            // If there is no `ts.Symbol` for the pipe transform, we want to return the\n+            // type definition (the pipe class).\n+            definitions.push(...this.getTypeDefinitionsForSymbols(symbol.classSymbol));\n+          }\n+          break;\n+        }\n+        case SymbolKind.Reference:\n+          definitions.push(\n+              ...this.getTypeDefinitionsForSymbols({shimLocation: symbol.targetLocation}));\n+          break;\n+        case SymbolKind.Expression:\n+          definitions.push(...this.getTypeDefinitionsForSymbols(symbol));\n+          break;\n+        case SymbolKind.Variable: {\n+          definitions.push(\n+              ...this.getTypeDefinitionsForSymbols({shimLocation: symbol.initializerLocation}));\n+          break;\n         }\n       }\n-      case SymbolKind.Reference:\n-        return this.getTypeDefinitionsForSymbols({shimLocation: symbol.targetLocation});\n-      case SymbolKind.Expression:\n-        return this.getTypeDefinitionsForSymbols(symbol);\n-      case SymbolKind.Variable:\n-        return this.getTypeDefinitionsForSymbols({shimLocation: symbol.initializerLocation});\n+      return definitions;\n     }\n   }\n \n@@ -221,21 +246,26 @@ export class DefinitionBuilder {\n   }\n \n   private getDefinitionMetaAtPosition({template, component}: TemplateInfo, position: number):\n-      DefinitionMeta|undefined {\n+      DefinitionMeta[]|undefined {\n     const target = getTargetAtPosition(template, position);\n     if (target === null) {\n       return undefined;\n     }\n     const {context, parent} = target;\n \n-    const node =\n-        context.kind === TargetNodeKind.TwoWayBindingContext ? context.nodes[0] : context.node;\n+    const nodes =\n+        context.kind === TargetNodeKind.TwoWayBindingContext ? context.nodes : [context.node];\n \n-    const symbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(node, component);\n-    if (symbol === null) {\n-      return undefined;\n+\n+    const definitionMetas: DefinitionMeta[] = [];\n+    for (const node of nodes) {\n+      const symbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(node, component);\n+      if (symbol === null) {\n+        continue;\n+      }\n+      definitionMetas.push({node, parent, symbol});\n     }\n-    return {node, parent, symbol};\n+    return definitionMetas.length > 0 ? definitionMetas : undefined;\n   }\n }\n "
        },
        {
            "sha": "d38c63406a6709b7e0ff27486362699091170669",
            "filename": "packages/language-service/ivy/test/legacy/definitions_spec.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 16,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/a9d8c228d9a4f96c056018078ba541aeb1462ae0/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fdefinitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a9d8c228d9a4f96c056018078ba541aeb1462ae0/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fdefinitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fdefinitions_spec.ts?ref=a9d8c228d9a4f96c056018078ba541aeb1462ae0",
            "patch": "@@ -43,7 +43,7 @@ describe('definitions', () => {\n       const {position} =\n           service.overwriteInlineTemplate(APP_COMPONENT, `<ng-templ¦ate></ng-template>`);\n       const definitionAndBoundSpan = ngLS.getDefinitionAndBoundSpan(APP_COMPONENT, position);\n-      expect(definitionAndBoundSpan!.definitions).toEqual([]);\n+      expect(definitionAndBoundSpan).toBeUndefined();\n     });\n   });\n \n@@ -181,17 +181,14 @@ describe('definitions', () => {\n           templateOverride: `<test-comp string-model [(mo¦del)]=\"title\"></test-comp>`,\n           expectedSpanText: 'model',\n         });\n-        // TODO(atscott): This should really return 2 definitions, 1 for the input and 1 for the\n-        // output.\n-        //  The TemplateTypeChecker also only returns the first match in the TCB for a given\n-        //  sourceSpan so even if we also requested the TmplAstBoundEvent, we'd still get back the\n-        //  symbol for the\n-        //  @Input because the input appears first in the TCB and they have the same sourceSpan.\n-        expect(definitions!.length).toEqual(1);\n+        expect(definitions!.length).toEqual(2);\n \n-        const [def] = definitions;\n-        expect(def.textSpan).toEqual('model');\n-        expect(def.contextSpan).toEqual(`@Input() model: string = 'model';`);\n+        const [inputDef, outputDef] = definitions;\n+        expect(inputDef.textSpan).toEqual('model');\n+        expect(inputDef.contextSpan).toEqual(`@Input() model: string = 'model';`);\n+        expect(outputDef.textSpan).toEqual('modelChange');\n+        expect(outputDef.contextSpan)\n+            .toEqual(`@Output() modelChange: EventEmitter<string> = new EventEmitter();`);\n       });\n     });\n \n@@ -245,12 +242,11 @@ describe('definitions', () => {\n \n   describe('references', () => {\n     it('should work for element reference declarations', () => {\n-      const definitions = getDefinitionsAndAssertBoundSpan({\n-        templateOverride: `<div #cha¦rt></div>{{chart}}`,\n-        expectedSpanText: 'chart',\n-      });\n+      const {position} =\n+          service.overwriteInlineTemplate(APP_COMPONENT, `<div #cha¦rt></div>{{chart}}`);\n+      const definitionAndBoundSpan = ngLS.getDefinitionAndBoundSpan(APP_COMPONENT, position);\n       // We're already at the definition, so nothing is returned\n-      expect(definitions).toEqual([]);\n+      expect(definitionAndBoundSpan).toBeUndefined();\n     });\n \n     it('should work for element reference uses', () => {"
        }
    ],
    "stats": {
        "total": 150,
        "additions": 88,
        "deletions": 62
    }
}