{
    "author": "JoostK",
    "message": "fix(compiler): evaluate safe navigation expressions in correct binding order (#37911)\n\nWhen using the safe navigation operator in a binding expression, a temporary\nvariable may be used for storing the result of a side-effectful call.\nFor example, the following template uses a pipe and a safe property access:\n\n```html\n<app-person-view [enabled]=\"enabled\" [firstName]=\"(person$ | async)?.name\"></app-person-view>\n```\n\nThe result of the pipe evaluation is stored in a temporary to be able to check\nwhether it is present. The temporary variable needs to be declared in a separate\nstatement and this would also cause the full expression itself to be pulled out\ninto a separate statement. This would compile into the following\npseudo-code instructions:\n\n```js\nvar temp = null;\nvar firstName = (temp = pipe('async', ctx.person$)) == null ? null : temp.name;\nproperty('enabled', ctx.enabled)('firstName', firstName);\n```\n\nNotice that the pipe evaluation happens before evaluating the `enabled` binding,\nsuch that the runtime's internal binding index would correspond with `enabled`,\nnot `firstName`. This introduces a problem when the pipe uses `WrappedValue` to\nforce a change to be detected, as the runtime would then mark the binding slot\ncorresponding with `enabled` as dirty, instead of `firstName`. This results\nin the `enabled` binding to be updated, triggering setters and affecting how\n`OnChanges` is called.\n\nIn the pseudo-code above, the intermediate `firstName` variable is not strictly\nnecessary---it only improved readability a bit---and emitting it inline with\nthe binding itself avoids the out-of-order execution of the pipe:\n\n```js\nvar temp = null;\nproperty('enabled', ctx.enabled)\n  ('firstName', (temp = pipe('async', ctx.person$)) == null ? null : temp.name);\n```\n\nThis commit introduces a new `BindingForm` that results in the above code to be\ngenerated and adds compiler and acceptance tests to verify the proper behavior.\n\nFixes #37194\n\nPR Close #37911",
    "sha": "9514fd90809fcbf8690c526cee6ef678b45f69d2",
    "files": [
        {
            "sha": "79cb9211bedcc97ebdd5bec536592359e81d8404",
            "filename": "packages/compiler-cli/test/compliance/r3_view_compiler_binding_spec.ts",
            "status": "modified",
            "additions": 78,
            "deletions": 0,
            "changes": 78,
            "blob_url": "https://github.com/angular/angular/blob/9514fd90809fcbf8690c526cee6ef678b45f69d2/packages%2Fcompiler-cli%2Ftest%2Fcompliance%2Fr3_view_compiler_binding_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9514fd90809fcbf8690c526cee6ef678b45f69d2/packages%2Fcompiler-cli%2Ftest%2Fcompliance%2Fr3_view_compiler_binding_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance%2Fr3_view_compiler_binding_spec.ts?ref=9514fd90809fcbf8690c526cee6ef678b45f69d2",
            "patch": "@@ -180,6 +180,44 @@ describe('compiler compliance: bindings', () => {\n          expectEmit(result.source, template, 'Incorrect template');\n        });\n \n+    it('should emit temporary evaluation within the binding expression for in-order execution',\n+       () => {\n+         // https://github.com/angular/angular/issues/37194\n+         // Verifies that temporary expressions used for expressions with potential side-effects in\n+         // the LHS of a safe navigation access are emitted within the binding expression itself, to\n+         // ensure that these temporaries are evaluated during the evaluation of the binding. This\n+         // is important for when the LHS contains a pipe, as pipe evaluation depends on the current\n+         // binding index.\n+         const files = {\n+           app: {\n+             'example.ts': `\n+            import {Component} from '@angular/core';\n+\n+            @Component({\n+              template: '<button [title]=\"myTitle\" [id]=\"(auth()?.identity() | async)?.id\" [tabindex]=\"1\"></button>'\n+            })\n+            export class MyComponent {\n+              myTitle = 'hello';\n+              auth?: () => { identity(): any; };\n+            }`\n+           }\n+         };\n+\n+         const result = compile(files, angularFiles);\n+         const template = `\n+          …\n+          template: function MyComponent_Template(rf, ctx) {\n+            …\n+            if (rf & 2) {\n+              var $tmp0$ = null;\n+              $r3$.ɵɵproperty(\"title\", ctx.myTitle)(\"id\", ($tmp0$ = $r3$.ɵɵpipeBind1(1, 3, ($tmp0$ = ctx.auth()) == null ? null : $tmp0$.identity())) == null ? null : $tmp0$.id)(\"tabindex\", 1);\n+            }\n+          }\n+        `;\n+\n+         expectEmit(result.source, template, 'Incorrect template');\n+       });\n+\n     it('should chain multiple property bindings into a single instruction', () => {\n       const files = {\n         app: {\n@@ -685,6 +723,46 @@ describe('compiler compliance: bindings', () => {\n       expectEmit(source, HostBindingDirDeclaration, 'Invalid host binding code');\n     });\n \n+    it('should support host bindings with temporary expressions', () => {\n+      const files = {\n+        app: {\n+          'spec.ts': `\n+            import {Directive, NgModule} from '@angular/core';\n+\n+            @Directive({\n+              selector: '[hostBindingDir]',\n+              host: {'[id]': 'getData()?.id'}\n+            })\n+            export class HostBindingDir {\n+              getData?: () => { id: number };\n+            }\n+\n+            @NgModule({declarations: [HostBindingDir]})\n+            export class MyModule {}\n+          `\n+        }\n+      };\n+\n+      const HostBindingDirDeclaration = `\n+      HostBindingDir.ɵdir = $r3$.ɵɵdefineDirective({\n+        type: HostBindingDir,\n+        selectors: [[\"\", \"hostBindingDir\", \"\"]],\n+          hostVars: 1,\n+          hostBindings: function HostBindingDir_HostBindings(rf, ctx) {\n+            if (rf & 2) {\n+              var $tmp0$ = null;\n+              $r3$.ɵɵhostProperty(\"id\", ($tmp0$ = ctx.getData()) == null ? null : $tmp0$.id);\n+            }\n+          }\n+        });\n+      `;\n+\n+      const result = compile(files, angularFiles);\n+      const source = result.source;\n+\n+      expectEmit(source, HostBindingDirDeclaration, 'Invalid host binding code');\n+    });\n+\n     it('should support host bindings with pure functions', () => {\n       const files = {\n         app: {"
        },
        {
            "sha": "533046c8ef436535ff8669c3561823087271cbdb",
            "filename": "packages/compiler-cli/test/compliance/r3_view_compiler_i18n_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/9514fd90809fcbf8690c526cee6ef678b45f69d2/packages%2Fcompiler-cli%2Ftest%2Fcompliance%2Fr3_view_compiler_i18n_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9514fd90809fcbf8690c526cee6ef678b45f69d2/packages%2Fcompiler-cli%2Ftest%2Fcompliance%2Fr3_view_compiler_i18n_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance%2Fr3_view_compiler_i18n_spec.ts?ref=9514fd90809fcbf8690c526cee6ef678b45f69d2",
            "patch": "@@ -805,8 +805,7 @@ describe('i18n support in the template compiler', () => {\n           }\n           if (rf & 2) {\n               var $tmp_0_0$ = null;\n-              const $currVal_0$ = ($tmp_0_0$ = ctx.valueA.getRawValue()) == null ? null : $tmp_0_0$.getTitle();\n-              $r3$.ɵɵi18nExp($currVal_0$);\n+              $r3$.ɵɵi18nExp(($tmp_0_0$ = ctx.valueA.getRawValue()) == null ? null : $tmp_0_0$.getTitle());\n               $r3$.ɵɵi18nApply(1);\n           }\n         }\n@@ -1320,9 +1319,8 @@ describe('i18n support in the template compiler', () => {\n           }\n           if (rf & 2) {\n             var $tmp_2_0$ = null;\n-            const $currVal_2$ = ($tmp_2_0$ = ctx.valueA.getRawValue()) == null ? null : $tmp_2_0$.getTitle();\n             $r3$.ɵɵadvance(2);\n-            $r3$.ɵɵi18nExp($r3$.ɵɵpipeBind1(2, 3, ctx.valueA))(ctx.valueA == null ? null : ctx.valueA.a == null ? null : ctx.valueA.a.b)($currVal_2$);\n+            $r3$.ɵɵi18nExp($r3$.ɵɵpipeBind1(2, 3, ctx.valueA))(ctx.valueA == null ? null : ctx.valueA.a == null ? null : ctx.valueA.a.b)(($tmp_2_0$ = ctx.valueA.getRawValue()) == null ? null : $tmp_2_0$.getTitle());\n             $r3$.ɵɵi18nApply(1);\n           }\n         }"
        },
        {
            "sha": "240c35b66ff1f9ef19e306cc999f814e0a131653",
            "filename": "packages/compiler/src/compiler_util/expression_converter.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/9514fd90809fcbf8690c526cee6ef678b45f69d2/packages%2Fcompiler%2Fsrc%2Fcompiler_util%2Fexpression_converter.ts",
            "raw_url": "https://github.com/angular/angular/raw/9514fd90809fcbf8690c526cee6ef678b45f69d2/packages%2Fcompiler%2Fsrc%2Fcompiler_util%2Fexpression_converter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompiler_util%2Fexpression_converter.ts?ref=9514fd90809fcbf8690c526cee6ef678b45f69d2",
            "patch": "@@ -154,6 +154,11 @@ export enum BindingForm {\n   // Try to generate a simple binding (no temporaries or statements)\n   // otherwise generate a general binding\n   TrySimple,\n+\n+  // Inlines assignment of temporaries into the generated expression. The result may still\n+  // have statements attached for declarations of temporary variables.\n+  // This is the only relevant form for Ivy, the other forms are only used in ViewEngine.\n+  Expression,\n }\n \n /**\n@@ -168,7 +173,6 @@ export function convertPropertyBinding(\n   if (!localResolver) {\n     localResolver = new DefaultLocalResolver();\n   }\n-  const currValExpr = createCurrValueExpr(bindingId);\n   const visitor =\n       new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n   const outputExpr: o.Expression = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n@@ -180,8 +184,11 @@ export function convertPropertyBinding(\n \n   if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {\n     return new ConvertPropertyBindingResult([], outputExpr);\n+  } else if (form === BindingForm.Expression) {\n+    return new ConvertPropertyBindingResult(stmts, outputExpr);\n   }\n \n+  const currValExpr = createCurrValueExpr(bindingId);\n   stmts.push(currValExpr.set(outputExpr).toDeclStmt(o.DYNAMIC_TYPE, [o.StmtModifier.Final]));\n   return new ConvertPropertyBindingResult(stmts, currValExpr);\n }"
        },
        {
            "sha": "2aaeddc1fe4373d2acced68e48f5f29fe2a9c3ef",
            "filename": "packages/compiler/src/render3/view/compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/9514fd90809fcbf8690c526cee6ef678b45f69d2/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/9514fd90809fcbf8690c526cee6ef678b45f69d2/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts?ref=9514fd90809fcbf8690c526cee6ef678b45f69d2",
            "patch": "@@ -714,7 +714,7 @@ function createHostBindingsFunction(\n \n function bindingFn(implicit: any, value: AST) {\n   return convertPropertyBinding(\n-      null, implicit, value, 'b', BindingForm.TrySimple, () => error('Unexpected interpolation'));\n+      null, implicit, value, 'b', BindingForm.Expression, () => error('Unexpected interpolation'));\n }\n \n function convertStylingCall("
        },
        {
            "sha": "4cb160191594cade7354c50b66bb13c3b0e6dd4b",
            "filename": "packages/compiler/src/render3/view/template.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/9514fd90809fcbf8690c526cee6ef678b45f69d2/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "raw_url": "https://github.com/angular/angular/raw/9514fd90809fcbf8690c526cee6ef678b45f69d2/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts?ref=9514fd90809fcbf8690c526cee6ef678b45f69d2",
            "patch": "@@ -1213,7 +1213,7 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n \n   private convertPropertyBinding(value: AST): o.Expression {\n     const convertedPropertyBinding = convertPropertyBinding(\n-        this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.TrySimple,\n+        this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.Expression,\n         () => error('Unexpected interpolation'));\n     const valExpr = convertedPropertyBinding.currValExpr;\n     this._tempVariables.push(...convertedPropertyBinding.stmts);"
        },
        {
            "sha": "22a38f77298c3ba65415262de9bd059504a7f135",
            "filename": "packages/core/test/acceptance/pipe_spec.ts",
            "status": "modified",
            "additions": 129,
            "deletions": 1,
            "changes": 130,
            "blob_url": "https://github.com/angular/angular/blob/9514fd90809fcbf8690c526cee6ef678b45f69d2/packages%2Fcore%2Ftest%2Facceptance%2Fpipe_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9514fd90809fcbf8690c526cee6ef678b45f69d2/packages%2Fcore%2Ftest%2Facceptance%2Fpipe_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fpipe_spec.ts?ref=9514fd90809fcbf8690c526cee6ef678b45f69d2",
            "patch": "@@ -6,9 +6,10 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, Inject, Injectable, InjectionToken, Input, NgModule, OnDestroy, Pipe, PipeTransform, ViewChild} from '@angular/core';\n+import {ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, Inject, Injectable, InjectionToken, Input, NgModule, OnChanges, OnDestroy, Pipe, PipeTransform, SimpleChanges, ViewChild, WrappedValue} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n+import {ivyEnabled} from '@angular/private/testing';\n \n describe('pipe', () => {\n   @Pipe({name: 'countingPipe'})\n@@ -285,6 +286,133 @@ describe('pipe', () => {\n     expect(fixture.nativeElement).toHaveText('a');\n   });\n \n+  describe('pipes within an optional chain', () => {\n+    it('should not dirty unrelated inputs', () => {\n+      // https://github.com/angular/angular/issues/37194\n+      // https://github.com/angular/angular/issues/37591\n+      // Using a pipe in the LHS of safe navigation operators would clobber unrelated bindings\n+      // iff the pipe returns WrappedValue, incorrectly causing the unrelated binding\n+      // to be considered changed.\n+      const log: string[] = [];\n+\n+      @Component({template: `<my-cmp [value1]=\"1\" [value2]=\"(value2 | pipe)?.id\"></my-cmp>`})\n+      class App {\n+        value2 = {id: 2};\n+      }\n+\n+      @Component({selector: 'my-cmp', template: ''})\n+      class MyCmp {\n+        @Input()\n+        set value1(value1: number) {\n+          log.push(`set value1=${value1}`);\n+        }\n+\n+        @Input()\n+        set value2(value2: number) {\n+          log.push(`set value2=${value2}`);\n+        }\n+      }\n+\n+      @Pipe({name: 'pipe'})\n+      class MyPipe implements PipeTransform {\n+        transform(value: any): any {\n+          log.push('pipe');\n+          return WrappedValue.wrap(value);\n+        }\n+      }\n+\n+      TestBed.configureTestingModule({declarations: [App, MyCmp, MyPipe]});\n+      const fixture = TestBed.createComponent(App);\n+      fixture.detectChanges(/* checkNoChanges */ false);\n+\n+      // Both bindings should have been set. Note: ViewEngine evaluates the pipe out-of-order,\n+      // before setting inputs.\n+      expect(log).toEqual(\n+          ivyEnabled ?\n+              [\n+                'set value1=1',\n+                'pipe',\n+                'set value2=2',\n+              ] :\n+              [\n+                'pipe',\n+                'set value1=1',\n+                'set value2=2',\n+              ]);\n+      log.length = 0;\n+\n+      fixture.componentInstance.value2 = {id: 3};\n+      fixture.detectChanges(/* checkNoChanges */ false);\n+\n+      // value1 did not change, so it should not have been set.\n+      expect(log).toEqual([\n+        'pipe',\n+        'set value2=3',\n+      ]);\n+    });\n+\n+    it('should not include unrelated inputs in ngOnChanges', () => {\n+      // https://github.com/angular/angular/issues/37194\n+      // https://github.com/angular/angular/issues/37591\n+      // Using a pipe in the LHS of safe navigation operators would clobber unrelated bindings\n+      // iff the pipe returns WrappedValue, incorrectly causing the unrelated binding\n+      // to be considered changed.\n+      const log: string[] = [];\n+\n+      @Component({template: `<my-cmp [value1]=\"1\" [value2]=\"(value2 | pipe)?.id\"></my-cmp>`})\n+      class App {\n+        value2 = {id: 2};\n+      }\n+\n+      @Component({selector: 'my-cmp', template: ''})\n+      class MyCmp implements OnChanges {\n+        @Input() value1!: number;\n+\n+        @Input() value2!: number;\n+\n+        ngOnChanges(changes: SimpleChanges): void {\n+          if (changes.value1) {\n+            const {previousValue, currentValue, firstChange} = changes.value1;\n+            log.push(`change value1: ${previousValue} -> ${currentValue} (${firstChange})`);\n+          }\n+          if (changes.value2) {\n+            const {previousValue, currentValue, firstChange} = changes.value2;\n+            log.push(`change value2: ${previousValue} -> ${currentValue} (${firstChange})`);\n+          }\n+        }\n+      }\n+\n+      @Pipe({name: 'pipe'})\n+      class MyPipe implements PipeTransform {\n+        transform(value: any): any {\n+          log.push('pipe');\n+          return WrappedValue.wrap(value);\n+        }\n+      }\n+\n+      TestBed.configureTestingModule({declarations: [App, MyCmp, MyPipe]});\n+      const fixture = TestBed.createComponent(App);\n+      fixture.detectChanges(/* checkNoChanges */ false);\n+\n+      // Both bindings should have been included in ngOnChanges.\n+      expect(log).toEqual([\n+        'pipe',\n+        'change value1: undefined -> 1 (true)',\n+        'change value2: undefined -> 2 (true)',\n+      ]);\n+      log.length = 0;\n+\n+      fixture.componentInstance.value2 = {id: 3};\n+      fixture.detectChanges(/* checkNoChanges */ false);\n+\n+      // value1 did not change, so it should not have been included in ngOnChanges\n+      expect(log).toEqual([\n+        'pipe',\n+        'change value2: 2 -> 3 (false)',\n+      ]);\n+    });\n+  });\n+\n   describe('pure', () => {\n     it('should call pure pipes only if the arguments change', () => {\n       @Component({"
        }
    ],
    "stats": {
        "total": 227,
        "additions": 219,
        "deletions": 8
    }
}