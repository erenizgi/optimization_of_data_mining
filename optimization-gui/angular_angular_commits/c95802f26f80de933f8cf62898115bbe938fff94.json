{
    "author": "jbogarthyde",
    "message": "docs: add lightweight token page to library section of docs (#36144)\n\nadds new DI technique recommendation for libraries to ensure tree-shaking for unused services\nincludes reasons for packaging schematics with libraries, clarify schematic usage recommendation\n\nPR Close #36144",
    "sha": "c95802f26f80de933f8cf62898115bbe938fff94",
    "files": [
        {
            "sha": "85eebecbc9d7a4c2fba219d260bb9482982bc144",
            "filename": ".pullapprove.yml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/c95802f26f80de933f8cf62898115bbe938fff94/.pullapprove.yml",
            "raw_url": "https://github.com/angular/angular/raw/c95802f26f80de933f8cf62898115bbe938fff94/.pullapprove.yml",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/.pullapprove.yml?ref=c95802f26f80de933f8cf62898115bbe938fff94",
            "patch": "@@ -315,6 +315,7 @@ groups:\n           'aio/content/images/guide/dependency-injection-in-action/**',\n           'aio/content/guide/dependency-injection-navtree.md',\n           'aio/content/guide/dependency-injection-providers.md',\n+          'aio/content/guide/lightweight-injection-tokens.md',\n           'aio/content/guide/displaying-data.md',\n           'aio/content/examples/displaying-data/**',\n           'aio/content/images/guide/displaying-data/**',"
        },
        {
            "sha": "0c185c79af422174fb782714049a79d12be7a990",
            "filename": "aio/content/guide/creating-libraries.md",
            "status": "modified",
            "additions": 35,
            "deletions": 28,
            "changes": 63,
            "blob_url": "https://github.com/angular/angular/blob/c95802f26f80de933f8cf62898115bbe938fff94/aio%2Fcontent%2Fguide%2Fcreating-libraries.md",
            "raw_url": "https://github.com/angular/angular/raw/c95802f26f80de933f8cf62898115bbe938fff94/aio%2Fcontent%2Fguide%2Fcreating-libraries.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fcreating-libraries.md?ref=c95802f26f80de933f8cf62898115bbe938fff94",
            "patch": "@@ -1,29 +1,32 @@\n ﻿# Creating libraries\n \n-You can create and publish new libraries to extend Angular functionality. If you find that you need to solve the same problem in more than one app (or want to share your solution with other developers), you have a candidate for a library.\n+This page provides a conceptual overview of how you can create and publish new libraries to extend Angular functionality.\n \n+If you find that you need to solve the same problem in more than one app (or want to share your solution with other developers), you have a candidate for a library.\n A simple example might be a button that sends users to your company website, that would be included in all apps that your company builds.\n \n-<div class=\"alert is-helpful\">\n-     <p>For more details on how a library project is structured you can refer the <a href=\"guide/file-structure#library-project-files\">Library Project Files</a></p>\n-</div>\n-\n ## Getting started\n \n-Use the Angular CLI to generate a new library skeleton with the following command:\n+Use the Angular CLI to generate a new library skeleton in a new workspace with the following commands.\n \n <code-example language=\"bash\">\n  ng new my-workspace --create-application=false\n  cd my-workspace\n  ng generate library my-lib\n </code-example>\n \n+The `ng generate` command creates the `projects/my-lib` folder in your workspace, which contains a component and a service inside an NgModule.\n+\n <div class=\"alert is-helpful\">\n-     <p>You can use the monorepo model to use the same workspace for multiple projects. See <a href=\"guide/file-structure#multiple-projects\">Setting up for a multi-project workspace</a>.</p>\n+\n+     For more details on how a library project is structured, refer to the [Library project files](guide/file-structure#library-project-files) section of the [Project File Structure guide](guide/file-structure).\n+\n+     You can use the monorepo model to use the same workspace for multiple projects.\n+     See [Setting up for a multi-project workspace](guide/file-structure#multiple-projects).\n+\n </div>\n \n-This creates the `projects/my-lib` folder in your workspace, which contains a component and a service inside an NgModule.\n-The workspace configuration file, `angular.json`, is updated with a project of type 'library'.\n+When you generate a new library, the workspace configuration file, `angular.json`, is updated with a project of type 'library'.\n \n <code-example format=\"json\">\n \"projects\": {\n@@ -69,47 +72,51 @@ Here are some things to consider in migrating application functionality to a lib\n \n * Components should expose their interactions through inputs for providing context, and outputs for communicating events to other components.\n \n-* Services should declare their own providers (rather than declaring providers in the NgModule or a component), so that they are *tree-shakable*. This allows the compiler to leave the service out of the bundle if it never gets injected into the application that imports the library. For more about this, see [Tree-shakable providers](guide/dependency-injection-providers#tree-shakable-providers).\n-\n-* If you register global service providers or share providers across multiple NgModules, use the [`forRoot()` and `forChild()` patterns](guide/singleton-services) provided by the [RouterModule](api/router/RouterModule).\n-\n * Check all internal dependencies.\n    * For custom classes or interfaces used in components or service, check whether they depend on additional classes or interfaces that also need to be migrated.\n    * Similarly, if your library code depends on a service, that service needs to be migrated.\n-   * If your library code or its templates depend on other libraries (such a Angular Material, for instance), you must configure your library with those dependencies.\n+   * If your library code or its templates depend on other libraries (such as Angular Material, for instance), you must configure your library with those dependencies.\n \n-## Reusable code and schematics\n+* Consider how you provide services to client applications.\n \n-A library typically includes *reusable code* that defines components, services, and other Angular artifacts (pipes, directives, and so on) that you simply import into a project.\n-A library is packaged into an npm package for publishing and sharing, and this package can also include [schematics](guide/glossary#schematic) that provide instructions for generating or transforming code directly in your project, in the same way that the CLI creates a generic skeleton app with `ng generate component`.\n-A schematic that is combined with a library can, for example, provide the Angular CLI with the information it needs to generate a particular component defined in that library.\n+   * Services should declare their own providers (rather than declaring providers in the NgModule or a component), so that they are *tree-shakable*. This allows the compiler to leave the service out of the bundle if it never gets injected into the application that imports the library. For more about this, see [Tree-shakable providers](guide/dependency-injection-providers#tree-shakable-providers).\n \n-What you include in your library is determined by the kind of task you are trying to accomplish.\n-For example, if you want a dropdown with some canned data to show how to add it to your app, your library could define a schematic to create it.\n-For a component like a dropdown that would contain different passed-in values each time, you could provide it as a component in a shared library.\n+   * If you register global service providers or share providers across multiple NgModules, use the [`forRoot()` and `forChild()` design patterns](guide/singleton-services) provided by the [RouterModule](api/router/RouterModule).\n \n-Suppose you want to read a configuration file and then generate a form based on that configuration.\n-If that form will need additional customization by the user, it might work best as a schematic.\n-However, if the forms will always be the same and not need much customization by developers, then you could create a dynamic component that takes the configuration and generates the form.\n-In general, the more complex the customization, the more useful the schematic approach.\n+   * If your library provides optional services that might not be used by all client applications, support proper tree-shaking for that case by using the [lightweight token design pattern](guide/lightweight-injection-tokens).\n \n {@a integrating-with-the-cli}\n \n-## Integrating with the CLI\n+## Integrating with the CLI using code-generation schematics\n+\n+A library typically includes *reusable code* that defines components, services, and other Angular artifacts (pipes, directives, and so on) that you simply import into a project.\n+A library is packaged into an npm package for publishing and sharing.\n+This package can also include [schematics](guide/glossary#schematic) that provide instructions for generating or transforming code directly in your project, in the same way that the CLI creates a generic new component with `ng generate component`.\n+A schematic that is packaged with a library can, for example, provide the Angular CLI with the information it needs to generate a component that configures and uses a particular feature, or set of features, defined in that library.\n+One example of this is Angular Material's navigation schematic which configures the CDK's `BreakpointObserver` and uses it with Material's `MatSideNav` and `MatToolbar` components.\n \n-A library can include [schematics](guide/glossary#schematic) that allow it to integrate with the Angular CLI.\n+You can create and include the following kinds of schematics.\n \n * Include an installation schematic so that `ng add` can add your library to a project.\n \n * Include generation schematics in your library so that `ng generate` can scaffold your defined artifacts (components, services, tests, and so on) in a project.\n \n * Include an update schematic so that `ng update` can update your library’s dependencies and provide migrations for breaking changes in new releases.\n \n+What you include in your library depends on your task.\n+For example, you could define a schematic to create a dropdown that is pre-populated with canned data to show how to add it to an app.\n+If you want a dropdown that would contain different passed-in values each time, your library could define a schematic to create it with a given configuration. Developers could then use `ng generate` to configure an instance for their own app.\n+\n+Suppose you want to read a configuration file and then generate a form based on that configuration.\n+If that form will need additional customization by the developer who is using your library, it might work best as a schematic.\n+However, if the forms will always be the same and not need much customization by developers, then you could create a dynamic component that takes the configuration and generates the form.\n+In general, the more complex the customization, the more useful the schematic approach.\n+\n To learn more, see [Schematics Overview](guide/schematics) and [Schematics for Libraries](guide/schematics-for-libraries).\n \n ## Publishing your library\n \n-Use the Angular CLI and the npm package manager to build and publish your library as an npm package. \n+Use the Angular CLI and the npm package manager to build and publish your library as an npm package.\n \n Before publishing a library to NPM, build it using the `--prod` flag which will use the older compiler and runtime known as View Engine instead of Ivy.\n "
        },
        {
            "sha": "d8fc94dac4726466ec2774c9423f7f2a01cf02f9",
            "filename": "aio/content/guide/lightweight-injection-tokens.md",
            "status": "added",
            "additions": 187,
            "deletions": 0,
            "changes": 187,
            "blob_url": "https://github.com/angular/angular/blob/c95802f26f80de933f8cf62898115bbe938fff94/aio%2Fcontent%2Fguide%2Flightweight-injection-tokens.md",
            "raw_url": "https://github.com/angular/angular/raw/c95802f26f80de933f8cf62898115bbe938fff94/aio%2Fcontent%2Fguide%2Flightweight-injection-tokens.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Flightweight-injection-tokens.md?ref=c95802f26f80de933f8cf62898115bbe938fff94",
            "patch": "@@ -0,0 +1,187 @@\n+# Optimizing client app size with lightweight injection tokens\n+\n+This page provides a conceptual overview of a dependency injection technique that is recommended for library developers.\n+Designing your library with *lightweight injection tokens* helps optimize the bundle size of client applications that use your library.\n+\n+You can manage the dependency structure among your components and injectable services to optimize bundle size by using [tree-shakable providers](guide/dependency-injection-providers#tree-shakable-providers).\n+This normally ensures that if a provided component or service is never actually used by the app, the compiler can eliminate its code from the bundle.\n+\n+However, due to the way Angular stores injection tokens, it is possible that such an unused component or service can end up in the bundle anyway.\n+This page describes a dependency-injection design pattern that supports proper tree-shaking by using lightweight injection tokens.\n+\n+The lightweight injection token design pattern is especially important for library developers. It ensures that when an application uses only some of your library's capabilities, the unused code can be eliminated from the client's app bundle.\n+\n+When an application uses your library, there might be some services that your library supplies which the client app doesn't use.\n+In this case, the app developer should expect that service to be tree-shaken, and not contribute to the size of the compiled app.\n+Because the application developer cannot know about or remedy a tree-shaking problem in the library, it is the responsibility of the library developer to do so.\n+To prevent the retention of unused components, your library should use the lightweight injection token design pattern.\n+\n+## When tokens are retained\n+\n+To better explain the condition under which token retention occurs, consider a library that provides a library-card component, which contains a body and can contain an optional header.\n+\n+```\n+<lib-card>\n+  <lib-header>...</lib-header>\n+</lib-card>\n+```\n+\n+In a likely implementation, the `<lib-card>` component uses `@ContentChild()` or `@ContentChildren()` to obtain `<lib-header>` and `<lib-body>`, as in the following.\n+\n+```\n+@Component({\n+  selector: 'lib-header',\n+  ...,\n+})\n+class LibHeaderComponent {}\n+\n+@Component({\n+  selector: 'lib-card',\n+  ...,\n+})\n+class LibCardComponent {\n+  @ContentChild(LibHeaderComponent)\n+  header: LibHeaderComponent|null = null;\n+}\n+```\n+\n+Because `<lib-header>` is optional, the element can appear in the template in its minimal form,\n+`<lib-card></lib-card>`.\n+In this case, `<lib-header>` is not used and you would expect it to be tree-shaken, but that is not what happens.\n+This is because `LibCardComponent` actually contains two references to the `LibHeaderComponent`.\n+\n+`@ContentChild(LibHeaderComponent) header: LibHeaderComponent;`\n+\n+* One of these reference is in the *type position*-- that is, it specifies `LibHeaderComponent` as a type: `header: LibHeaderComponent;`.\n+\n+* The other reference is in the *value position*-- that is, LibHeaderComponent is the value of the `@ContentChild()` parameter decorator: `@ContentChild(LibHeaderComponent)`.\n+\n+The compiler handles token references in these positions differently.\n+\n+* The compiler erases *type position* references after conversion from TypeScript, so they have no impact on tree-shaking.\n+\n+* The compiler must retain *value position*  references at runtime, which prevents the component from being tree-shaken.\n+\n+In the example, the compiler retains the `LibHeaderComponent` token that occurs in the value position, which prevents the referenced component from being tree-shaken, even if the application developer does not actually use `<lib-header>` anywhere.\n+If `LibHeaderComponent` is large (code, template, and styles), including it unnecessarily can significantly increase the size of the client application.\n+\n+## When to use the lightweight injection token pattern\n+\n+The tree-shaking problem arises when a component is used as an injection token.\n+There are two cases when that can happen.\n+\n+* The token is used in the value position of a [content query](guide/lifecycle-hooks#using-aftercontent-hooks \"See more about using content queries.\").\n+* The token is used as a type specifier for constructor injection.\n+\n+In the following example, both uses of the `OtherComponent` token cause retention of `OtherComponent` (that is, prevent it from being tree-shaken when it is not used).\n+\n+```\n+class MyComponent {\n+  constructor(@Optional() other: OtherComponent) {}\n+\n+  @ContentChild(OtherComponent)\n+  other: OtherComponent|null;\n+}\n+```\n+\n+Although tokens used only as type specifiers are removed when converted to JavaScript, all tokens used for dependency injection are needed at runtime.\n+These effectively change `constructor(@Optional() other: OtherComponent)` to `constructor(@Optional() @Inject(OtherComponent) other)`. The token is now in a value position, and causes the tree shaker to retain the reference.\n+\n+<div class=\"alert is helpful\">\n+\n+For all services, a library should use [tree-shakable providers](guide/dependency-injection-providers#tree-shakable-providers), providing dependencies at the root level rather than in component constructors.\n+\n+</div>\n+\n+## Using lightweight injection tokens\n+\n+The lightweight injection token design pattern consists of using a small abstract class as an injection token, and providing the actual implementation at a later stage.\n+The abstract class is retained (not tree-shaken), but it is small and has no material impact on the application size.\n+\n+The following example shows how this works for the `LibHeaderComponent`.\n+\n+```\n+abstract class LibHeaderToken {}\n+\n+@Component({\n+  selector: 'lib-header',\n+  providers: [\n+    {provide: LibHeaderToken, useExisting: LibHeaderComponent}\n+  ]\n+  ...,\n+})\n+class LibHeaderComponent extends LibHeaderToken {}\n+\n+@Component({\n+  selector: 'lib-card',\n+  ...,\n+})\n+class LibCardComponent {\n+  @ContentChild(LibHeaderToken) header: LibHeaderToken|null = null;\n+}\n+```\n+\n+In this example, the `LibCardComponent` implementation no longer refers to `LibHeaderComponent` in either the type position or the value position.\n+This allows full tree shaking of `LibHeaderComponent` to take place.\n+The `LibHeaderToken` is retained, but it is only a class declaration, with no concrete implementation. It is small and does not materially impact the application size when retained after compilation.\n+\n+Instead, `LibHeaderComponent` itself implements the abstract `LibHeaderToken` class. You can safely use that token as the provider in the component definition, allowing Angular to correctly inject the concrete type.\n+\n+To summarize, the lightweight injection token pattern consists of the following.\n+\n+1. A lightweight injection token that is represented as an abstract class.\n+2. A component definition that implements the abstract class.\n+3. Injection of the lightweight pattern, using ` @ContentChild()` or `@ContentChildren()`.\n+4. A provider in the implementation of the lightweight injection token which associates the lightweight injection token with the implementation.\n+\n+### Use the lightweight injection token for API definition\n+\n+A component that injects a lightweight injection token might need to invoke a method in the injected class.\n+Because the token is now an abstract class, and the injectable component implements that class, you must also declare an abstract method in the abstract lightweight injection token class.\n+The implementation of the method (with all of its code overhead) resides in the injectable component that can be tree-shaken.\n+This allows the parent to communicate with the child (if it is present) in a type-safe manner.\n+\n+For example, the `LibCardComponent` now queries`LibHeaderToken` rather than `LibHeaderComponent`.\n+The following example shows how the pattern allows `LibCardComponent` to communicate with the `LibHeaderComponent` without actually referring to `LibHeaderComponent`.\n+\n+```\n+abstract class LibHeaderToken {\n+  abstract doSomething(): void;\n+}\n+\n+@Component({\n+  selector: 'lib-header',\n+  providers: [\n+    {provide: LibHeaderToken, useExisting: LibHeader}\n+  ]\n+  ...,\n+})\n+class LibHeaderComponent extends LibHeaderToken {\n+  doSomething(): void {\n+    // Concrete implementation of `doSomething`\n+  }\n+}\n+\n+@Component({\n+  selector: 'lib-card',\n+  ...,\n+})\n+class LibCardComponent implement AfterContentInit {\n+  @ContentChild(LibHeaderToken)\n+  header: LibHeaderToken|null = null;\n+\n+  ngAfterContentInit(): void {\n+    this.header && this.header.doSomething();\n+  }\n+}\n+```\n+\n+In this example the parent  queries the token to obtain the child component, and stores the resulting component reference if it is present.\n+Before calling a method in the child, the parent component checks to see if the child component is present.\n+If the child component has been tree-shaken, there is no runtime reference to it, and no call to its method.\n+\n+### Naming your lightweight injection token\n+\n+Lightweight injection tokens are only useful with components. The Angular style guide suggests that you name components using the \"Component\" suffix. The example \"LibHeaderComponent\" follows this convention.\n+\n+To maintain the relationship between the component and its token while still distinguishing between them, the recommended style is to use the component base name with the suffix \"Token\" to name your lightweight injection tokens: \"LibHeaderToken\"."
        },
        {
            "sha": "82f782a9132f1e6c2e9d08ec32ca8001e006ba67",
            "filename": "aio/content/navigation.json",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/c95802f26f80de933f8cf62898115bbe938fff94/aio%2Fcontent%2Fnavigation.json",
            "raw_url": "https://github.com/angular/angular/raw/c95802f26f80de933f8cf62898115bbe938fff94/aio%2Fcontent%2Fnavigation.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fnavigation.json?ref=c95802f26f80de933f8cf62898115bbe938fff94",
            "patch": "@@ -552,6 +552,11 @@\n               \"url\": \"guide/creating-libraries\",\n               \"title\": \"Creating Libraries\",\n               \"tooltip\": \"Extend Angular by creating, publishing, and using your own libraries.\"\n+            },\n+            {\n+              \"url\": \"guide/lightweight-injection-tokens\",\n+              \"title\": \"Lightweight Injection Tokens for Libraries\",\n+              \"tooltip\": \"Optimize client app size by designing library services with lightweight injection tokens.\"\n             }\n           ]\n         },"
        }
    ],
    "stats": {
        "total": 256,
        "additions": 228,
        "deletions": 28
    }
}