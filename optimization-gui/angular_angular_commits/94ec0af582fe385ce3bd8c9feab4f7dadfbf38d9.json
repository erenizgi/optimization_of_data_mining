{
    "author": "alxhub",
    "message": "refactor(compiler-cli): replace the `IncrementalDriver` with a new design (#41475)\n\nThis commit replaces the `IncrementalDriver` abstraction which powered\nincremental compilation in the compiler with a new `IncrementalCompilation`\ndesign. Principally, it separates two concerns which were tied together in\nthe previous implementation:\n\n1. Tracking the reusable state of a compilation at any given point that\n   could be reused in a subsequent future compilation.\n\n2. Making use of a prior compilation's state to accelerate the current one.\n\nThe new abstraction adds explicit tracking and types to deal with both of\nthese concerns separately, which greatly reduces the complexity of the state\ntracking that `IncrementalDriver` used to perform.\n\nPR Close #41475",
    "sha": "94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
    "files": [
        {
            "sha": "2edd9dc7370542c31c53f9af1a0950408a85276b",
            "filename": "packages/compiler-cli/ngcc/src/analysis/ngcc_trait_compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fngcc_trait_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fngcc_trait_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fngcc_trait_compiler.ts?ref=94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
            "patch": "@@ -85,7 +85,7 @@ export class NgccTraitCompiler extends TraitCompiler {\n }\n \n class NoIncrementalBuild implements IncrementalBuild<any, any> {\n-  priorWorkFor(sf: ts.SourceFile): any[]|null {\n+  priorAnalysisFor(sf: ts.SourceFile): any[]|null {\n     return null;\n   }\n "
        },
        {
            "sha": "1c312c5fd1c99e75722358cd77d4ab3fae7381d4",
            "filename": "packages/compiler-cli/src/ngtsc/core/src/compiler.ts",
            "status": "modified",
            "additions": 42,
            "deletions": 32,
            "changes": 74,
            "blob_url": "https://github.com/angular/angular/blob/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts?ref=94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
            "patch": "@@ -15,7 +15,7 @@ import {COMPILER_ERRORS_WITH_GUIDES, ERROR_DETAILS_PAGE_BASE_URL, ErrorCode, ngE\n import {checkForPrivateExports, ReferenceGraph} from '../../entry_point';\n import {AbsoluteFsPath, LogicalFileSystem, resolve} from '../../file_system';\n import {AbsoluteModuleStrategy, AliasingHost, AliasStrategy, DefaultImportTracker, ImportRewriter, LocalIdentifierStrategy, LogicalProjectStrategy, ModuleResolver, NoopImportRewriter, PrivateExportAliasingHost, R3SymbolsImportRewriter, Reference, ReferenceEmitStrategy, ReferenceEmitter, RelativePathStrategy, UnifiedModulesAliasingHost, UnifiedModulesStrategy} from '../../imports';\n-import {IncrementalBuildStrategy, IncrementalDriver} from '../../incremental';\n+import {IncrementalBuildStrategy, IncrementalCompilation, IncrementalState} from '../../incremental';\n import {SemanticSymbol} from '../../incremental/semantic_graph';\n import {generateAnalysis, IndexedComponent, IndexingContext} from '../../indexer';\n import {ComponentResources, CompoundMetadataReader, CompoundMetadataRegistry, DtsMetadataReader, InjectableClassRegistry, LocalMetadataRegistry, MetadataReader, ResourceRegistry} from '../../metadata';\n@@ -89,11 +89,10 @@ export interface FreshCompilationTicket {\n export interface IncrementalTypeScriptCompilationTicket {\n   kind: CompilationTicketKind.IncrementalTypeScript;\n   options: NgCompilerOptions;\n-  oldProgram: ts.Program;\n   newProgram: ts.Program;\n   incrementalBuildStrategy: IncrementalBuildStrategy;\n+  incrementalCompilation: IncrementalCompilation;\n   programDriver: ProgramDriver;\n-  newDriver: IncrementalDriver;\n   enableTemplateTypeChecker: boolean;\n   usePoisonedData: boolean;\n   perfRecorder: ActivePerfRecorder;\n@@ -143,10 +142,11 @@ export function freshCompilationTicket(\n export function incrementalFromCompilerTicket(\n     oldCompiler: NgCompiler, newProgram: ts.Program,\n     incrementalBuildStrategy: IncrementalBuildStrategy, programDriver: ProgramDriver,\n-    modifiedResourceFiles: Set<string>, perfRecorder: ActivePerfRecorder|null): CompilationTicket {\n+    modifiedResourceFiles: Set<AbsoluteFsPath>,\n+    perfRecorder: ActivePerfRecorder|null): CompilationTicket {\n   const oldProgram = oldCompiler.getCurrentProgram();\n-  const oldDriver = oldCompiler.incrementalStrategy.getIncrementalDriver(oldProgram);\n-  if (oldDriver === null) {\n+  const oldState = oldCompiler.incrementalStrategy.getIncrementalState(oldProgram);\n+  if (oldState === null) {\n     // No incremental step is possible here, since no IncrementalDriver was found for the old\n     // program.\n     return freshCompilationTicket(\n@@ -158,18 +158,17 @@ export function incrementalFromCompilerTicket(\n     perfRecorder = ActivePerfRecorder.zeroedToNow();\n   }\n \n-  const newDriver = IncrementalDriver.reconcile(\n-      oldProgram, oldDriver, newProgram, modifiedResourceFiles, perfRecorder);\n+  const incrementalCompilation = IncrementalCompilation.incremental(\n+      newProgram, oldProgram, oldState, modifiedResourceFiles, perfRecorder);\n \n   return {\n     kind: CompilationTicketKind.IncrementalTypeScript,\n     enableTemplateTypeChecker: oldCompiler.enableTemplateTypeChecker,\n     usePoisonedData: oldCompiler.usePoisonedData,\n     options: oldCompiler.options,\n     incrementalBuildStrategy,\n+    incrementalCompilation,\n     programDriver,\n-    newDriver,\n-    oldProgram,\n     newProgram,\n     perfRecorder,\n   };\n@@ -179,24 +178,23 @@ export function incrementalFromCompilerTicket(\n  * Create a `CompilationTicket` directly from an old `ts.Program` and associated Angular compilation\n  * state, along with a new `ts.Program`.\n  */\n-export function incrementalFromDriverTicket(\n-    oldProgram: ts.Program, oldDriver: IncrementalDriver, newProgram: ts.Program,\n+export function incrementalFromStateTicket(\n+    oldProgram: ts.Program, oldState: IncrementalState, newProgram: ts.Program,\n     options: NgCompilerOptions, incrementalBuildStrategy: IncrementalBuildStrategy,\n-    programDriver: ProgramDriver, modifiedResourceFiles: Set<string>,\n+    programDriver: ProgramDriver, modifiedResourceFiles: Set<AbsoluteFsPath>,\n     perfRecorder: ActivePerfRecorder|null, enableTemplateTypeChecker: boolean,\n     usePoisonedData: boolean): CompilationTicket {\n   if (perfRecorder === null) {\n     perfRecorder = ActivePerfRecorder.zeroedToNow();\n   }\n-  const newDriver = IncrementalDriver.reconcile(\n-      oldProgram, oldDriver, newProgram, modifiedResourceFiles, perfRecorder);\n+  const incrementalCompilation = IncrementalCompilation.incremental(\n+      newProgram, oldProgram, oldState, modifiedResourceFiles, perfRecorder);\n   return {\n     kind: CompilationTicketKind.IncrementalTypeScript,\n-    oldProgram,\n     newProgram,\n     options,\n     incrementalBuildStrategy,\n-    newDriver,\n+    incrementalCompilation,\n     programDriver,\n     enableTemplateTypeChecker,\n     usePoisonedData,\n@@ -284,7 +282,7 @@ export class NgCompiler {\n             ticket.tsProgram,\n             ticket.programDriver,\n             ticket.incrementalBuildStrategy,\n-            IncrementalDriver.fresh(ticket.tsProgram),\n+            IncrementalCompilation.fresh(ticket.tsProgram),\n             ticket.enableTemplateTypeChecker,\n             ticket.usePoisonedData,\n             ticket.perfRecorder,\n@@ -296,7 +294,7 @@ export class NgCompiler {\n             ticket.newProgram,\n             ticket.programDriver,\n             ticket.incrementalBuildStrategy,\n-            ticket.newDriver,\n+            ticket.incrementalCompilation,\n             ticket.enableTemplateTypeChecker,\n             ticket.usePoisonedData,\n             ticket.perfRecorder,\n@@ -314,7 +312,7 @@ export class NgCompiler {\n       private inputProgram: ts.Program,\n       readonly programDriver: ProgramDriver,\n       readonly incrementalStrategy: IncrementalBuildStrategy,\n-      readonly incrementalDriver: IncrementalDriver,\n+      readonly incrementalCompilation: IncrementalCompilation,\n       readonly enableTemplateTypeChecker: boolean,\n       readonly usePoisonedData: boolean,\n       private livePerfRecorder: ActivePerfRecorder,\n@@ -343,7 +341,7 @@ export class NgCompiler {\n     this.resourceManager = new AdapterResourceLoader(adapter, this.options);\n     this.cycleAnalyzer = new CycleAnalyzer(\n         new ImportGraph(inputProgram.getTypeChecker(), this.delegatingPerfRecorder));\n-    this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, inputProgram);\n+    this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, inputProgram);\n \n     this.ignoreForDiagnostics =\n         new Set(inputProgram.getSourceFiles().filter(sf => this.adapter.isShim(sf)));\n@@ -367,6 +365,16 @@ export class NgCompiler {\n     return this.livePerfRecorder;\n   }\n \n+  /**\n+   * Exposes the `IncrementalCompilation` under an old property name that the CLI uses, avoiding a\n+   * chicken-and-egg problem with the rename to `incrementalCompilation`.\n+   *\n+   * TODO(alxhub): remove when the CLI uses the new name.\n+   */\n+  get incrementalDriver(): IncrementalCompilation {\n+    return this.incrementalCompilation;\n+  }\n+\n   private updateWithChangedResources(\n       changedResources: Set<string>, perfRecorder: ActivePerfRecorder): void {\n     this.livePerfRecorder = perfRecorder;\n@@ -411,7 +419,7 @@ export class NgCompiler {\n   getResourceDependencies(file: ts.SourceFile): string[] {\n     this.ensureAnalyzed();\n \n-    return this.incrementalDriver.depGraph.getResourceDependencies(file);\n+    return this.incrementalCompilation.depGraph.getResourceDependencies(file);\n   }\n \n   /**\n@@ -684,7 +692,7 @@ export class NgCompiler {\n \n       // At this point, analysis is complete and the compiler can now calculate which files need to\n       // be emitted, so do that.\n-      this.incrementalDriver.recordSuccessfulAnalysis(traitCompiler);\n+      this.incrementalCompilation.recordSuccessfulAnalysis(traitCompiler);\n \n       this.perfRecorder.memory(PerfCheckpoint.Resolve);\n     });\n@@ -829,7 +837,7 @@ export class NgCompiler {\n     }\n \n     const program = this.programDriver.getProgram();\n-    this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, program);\n+    this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);\n     this.currentProgram = program;\n \n     return diagnostics;\n@@ -846,7 +854,7 @@ export class NgCompiler {\n     }\n \n     const program = this.programDriver.getProgram();\n-    this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, program);\n+    this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);\n     this.currentProgram = program;\n \n     return diagnostics;\n@@ -935,15 +943,16 @@ export class NgCompiler {\n       aliasingHost = new UnifiedModulesAliasingHost(this.adapter.unifiedModulesHost);\n     }\n \n-    const evaluator = new PartialEvaluator(reflector, checker, this.incrementalDriver.depGraph);\n+    const evaluator =\n+        new PartialEvaluator(reflector, checker, this.incrementalCompilation.depGraph);\n     const dtsReader = new DtsMetadataReader(checker, reflector);\n     const localMetaRegistry = new LocalMetadataRegistry();\n     const localMetaReader: MetadataReader = localMetaRegistry;\n     const depScopeReader = new MetadataDtsModuleScopeResolver(dtsReader, aliasingHost);\n     const scopeRegistry =\n         new LocalModuleScopeRegistry(localMetaReader, depScopeReader, refEmitter, aliasingHost);\n     const scopeReader: ComponentScopeReader = scopeRegistry;\n-    const semanticDepGraphUpdater = this.incrementalDriver.getSemanticDepGraphUpdater();\n+    const semanticDepGraphUpdater = this.incrementalCompilation.semanticDepGraphUpdater;\n     const metaRegistry = new CompoundMetadataRegistry([localMetaRegistry, scopeRegistry]);\n     const injectableRegistry = new InjectableClassRegistry(reflector);\n \n@@ -992,8 +1001,9 @@ export class NgCompiler {\n           this.options.i18nUseExternalIds !== false,\n           this.options.enableI18nLegacyMessageIdFormat !== false, this.usePoisonedData,\n           this.options.i18nNormalizeLineEndingsInICUs, this.moduleResolver, this.cycleAnalyzer,\n-          cycleHandlingStrategy, refEmitter, this.incrementalDriver.depGraph, injectableRegistry,\n-          semanticDepGraphUpdater, this.closureCompilerEnabled, this.delegatingPerfRecorder),\n+          cycleHandlingStrategy, refEmitter, this.incrementalCompilation.depGraph,\n+          injectableRegistry, semanticDepGraphUpdater, this.closureCompilerEnabled,\n+          this.delegatingPerfRecorder),\n \n       // TODO(alxhub): understand why the cast here is necessary (something to do with `null`\n       // not being assignable to `unknown` when wrapped in `Readonly`).\n@@ -1020,21 +1030,21 @@ export class NgCompiler {\n     ];\n \n     const traitCompiler = new TraitCompiler(\n-        handlers, reflector, this.delegatingPerfRecorder, this.incrementalDriver,\n+        handlers, reflector, this.delegatingPerfRecorder, this.incrementalCompilation,\n         this.options.compileNonExportedClasses !== false, compilationMode, dtsTransforms,\n         semanticDepGraphUpdater);\n \n     // Template type-checking may use the `ProgramDriver` to produce new `ts.Program`(s). If this\n     // happens, they need to be tracked by the `NgCompiler`.\n     const notifyingDriver =\n         new NotifyingProgramDriverWrapper(this.programDriver, (program: ts.Program) => {\n-          this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, program);\n+          this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);\n           this.currentProgram = program;\n         });\n \n     const templateTypeChecker = new TemplateTypeCheckerImpl(\n         this.inputProgram, notifyingDriver, traitCompiler, this.getTypeCheckingConfig(), refEmitter,\n-        reflector, this.adapter, this.incrementalDriver, scopeRegistry, typeCheckScopeRegistry,\n+        reflector, this.adapter, this.incrementalCompilation, scopeRegistry, typeCheckScopeRegistry,\n         this.delegatingPerfRecorder);\n \n     return {"
        },
        {
            "sha": "5a52c8627e33131c670ca709944a1cda419ee42e",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/api.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fapi.ts?ref=94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
            "patch": "@@ -21,7 +21,7 @@ export interface IncrementalBuild<AnalysisT, FileTypeCheckDataT> {\n   /**\n    * Retrieve the prior analysis work, if any, done for the given source file.\n    */\n-  priorWorkFor(sf: ts.SourceFile): AnalysisT[]|null;\n+  priorAnalysisFor(sf: ts.SourceFile): AnalysisT[]|null;\n \n   /**\n    * Retrieve the prior type-checking work, if any, that's been done for the given source file."
        },
        {
            "sha": "8bcda25025786f2afbac72dd20fcf36b1af16dd1",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/index.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Findex.ts?ref=94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
            "patch": "@@ -6,6 +6,8 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+export {IncrementalCompilation} from './src/incremental';\n export {NOOP_INCREMENTAL_BUILD} from './src/noop';\n-export {IncrementalDriver} from './src/state';\n+export {AnalyzedIncrementalState, DeltaIncrementalState, FreshIncrementalState, IncrementalState, IncrementalStateKind} from './src/state';\n+\n export * from './src/strategy';"
        },
        {
            "sha": "63a557da16cabfd74fd0afd385df1753f03743d0",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/src/dependency_tracking.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 11,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fdependency_tracking.ts",
            "raw_url": "https://github.com/angular/angular/raw/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fdependency_tracking.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fdependency_tracking.ts?ref=94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
            "patch": "@@ -8,7 +8,7 @@\n \n import * as ts from 'typescript';\n \n-import {AbsoluteFsPath} from '../../file_system';\n+import {absoluteFromSourceFile, AbsoluteFsPath} from '../../file_system';\n import {DependencyTracker} from '../api';\n \n /**\n@@ -28,7 +28,7 @@ export class FileDependencyGraph<T extends {fileName: string} = ts.SourceFile> i\n   private nodes = new Map<T, FileNode>();\n \n   addDependency(from: T, on: T): void {\n-    this.nodeFor(from).dependsOn.add(on.fileName);\n+    this.nodeFor(from).dependsOn.add(absoluteFromSourceFile(on));\n   }\n \n   addResourceDependency(from: T, resource: AbsoluteFsPath): void {\n@@ -67,15 +67,17 @@ export class FileDependencyGraph<T extends {fileName: string} = ts.SourceFile> i\n    * P(n) = the physically changed files from build n - 1 to build n.\n    */\n   updateWithPhysicalChanges(\n-      previous: FileDependencyGraph<T>, changedTsPaths: Set<string>, deletedTsPaths: Set<string>,\n-      changedResources: Set<AbsoluteFsPath>): Set<string> {\n-    const logicallyChanged = new Set<string>();\n+      previous: FileDependencyGraph<T>, changedTsPaths: Set<AbsoluteFsPath>,\n+      deletedTsPaths: Set<AbsoluteFsPath>,\n+      changedResources: Set<AbsoluteFsPath>): Set<AbsoluteFsPath> {\n+    const logicallyChanged = new Set<AbsoluteFsPath>();\n \n     for (const sf of previous.nodes.keys()) {\n+      const sfPath = absoluteFromSourceFile(sf);\n       const node = previous.nodeFor(sf);\n       if (isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources)) {\n-        logicallyChanged.add(sf.fileName);\n-      } else if (!deletedTsPaths.has(sf.fileName)) {\n+        logicallyChanged.add(sfPath);\n+      } else if (!deletedTsPaths.has(sfPath)) {\n         this.nodes.set(sf, {\n           dependsOn: new Set(node.dependsOn),\n           usesResources: new Set(node.usesResources),\n@@ -90,7 +92,7 @@ export class FileDependencyGraph<T extends {fileName: string} = ts.SourceFile> i\n   private nodeFor(sf: T): FileNode {\n     if (!this.nodes.has(sf)) {\n       this.nodes.set(sf, {\n-        dependsOn: new Set<string>(),\n+        dependsOn: new Set<AbsoluteFsPath>(),\n         usesResources: new Set<AbsoluteFsPath>(),\n         failedAnalysis: false,\n       });\n@@ -104,16 +106,19 @@ export class FileDependencyGraph<T extends {fileName: string} = ts.SourceFile> i\n  * changed files and resources.\n  */\n function isLogicallyChanged<T extends {fileName: string}>(\n-    sf: T, node: FileNode, changedTsPaths: ReadonlySet<string>, deletedTsPaths: ReadonlySet<string>,\n+    sf: T, node: FileNode, changedTsPaths: ReadonlySet<AbsoluteFsPath>,\n+    deletedTsPaths: ReadonlySet<AbsoluteFsPath>,\n     changedResources: ReadonlySet<AbsoluteFsPath>): boolean {\n   // A file is assumed to have logically changed if its dependencies could not be determined\n   // accurately.\n   if (node.failedAnalysis) {\n     return true;\n   }\n \n+  const sfPath = absoluteFromSourceFile(sf);\n+\n   // A file is logically changed if it has physically changed itself (including being deleted).\n-  if (changedTsPaths.has(sf.fileName) || deletedTsPaths.has(sf.fileName)) {\n+  if (changedTsPaths.has(sfPath) || deletedTsPaths.has(sfPath)) {\n     return true;\n   }\n \n@@ -134,7 +139,7 @@ function isLogicallyChanged<T extends {fileName: string}>(\n }\n \n interface FileNode {\n-  dependsOn: Set<string>;\n+  dependsOn: Set<AbsoluteFsPath>;\n   usesResources: Set<AbsoluteFsPath>;\n   failedAnalysis: boolean;\n }"
        },
        {
            "sha": "42fc22213776ce2a30d33486afae738dacd97e70",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/src/incremental.ts",
            "status": "added",
            "additions": 348,
            "deletions": 0,
            "changes": 348,
            "blob_url": "https://github.com/angular/angular/blob/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fincremental.ts",
            "raw_url": "https://github.com/angular/angular/raw/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fincremental.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fincremental.ts?ref=94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
            "patch": "@@ -0,0 +1,348 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript';\n+\n+import {absoluteFromSourceFile, AbsoluteFsPath, resolve} from '../../file_system';\n+import {PerfPhase, PerfRecorder} from '../../perf';\n+import {ClassRecord, TraitCompiler} from '../../transform';\n+import {FileTypeCheckingData} from '../../typecheck';\n+import {toUnredirectedSourceFile} from '../../util/src/typescript';\n+import {IncrementalBuild} from '../api';\n+import {SemanticDepGraphUpdater} from '../semantic_graph';\n+import {FileDependencyGraph} from './dependency_tracking';\n+import {AnalyzedIncrementalState, DeltaIncrementalState, IncrementalState, IncrementalStateKind} from './state';\n+\n+/**\n+ * Information about the previous compilation being used as a starting point for the current one,\n+ * including the delta of files which have logically changed and need to be reanalyzed.\n+ */\n+interface IncrementalStep {\n+  priorState: AnalyzedIncrementalState;\n+  logicallyChangedTsFiles: Set<AbsoluteFsPath>;\n+}\n+\n+/**\n+ * Discriminant of the `Phase` type union.\n+ */\n+enum PhaseKind {\n+  Analysis,\n+  TypeCheckAndEmit,\n+}\n+\n+/**\n+ * An incremental compilation undergoing analysis, and building a semantic dependency graph.\n+ */\n+interface AnalysisPhase {\n+  kind: PhaseKind.Analysis;\n+  semanticDepGraphUpdater: SemanticDepGraphUpdater;\n+}\n+\n+/**\n+ * An incremental compilation that completed analysis and is undergoing template type-checking and\n+ * emit.\n+ */\n+interface TypeCheckAndEmitPhase {\n+  kind: PhaseKind.TypeCheckAndEmit;\n+  needsEmit: Set<AbsoluteFsPath>;\n+  needsTypeCheckEmit: Set<AbsoluteFsPath>;\n+}\n+\n+/**\n+ * Represents the current phase of a compilation.\n+ */\n+type Phase = AnalysisPhase|TypeCheckAndEmitPhase;\n+\n+/**\n+ * Manages the incremental portion of an Angular compilation, allowing for reuse of a prior\n+ * compilation if available, and producing an output state for reuse of the current compilation in a\n+ * future one.\n+ */\n+export class IncrementalCompilation implements IncrementalBuild<ClassRecord, FileTypeCheckingData> {\n+  private phase: Phase;\n+\n+  /**\n+   * `IncrementalState` of this compilation if it were to be reused in a subsequent incremental\n+   * compilation at the current moment.\n+   *\n+   * Exposed via the `state` read-only getter.\n+   */\n+  private _state: IncrementalState;\n+\n+  private constructor(\n+      state: IncrementalState, readonly depGraph: FileDependencyGraph,\n+      private step: IncrementalStep|null) {\n+    this._state = state;\n+\n+    // The compilation begins in analysis phase.\n+    this.phase = {\n+      kind: PhaseKind.Analysis,\n+      semanticDepGraphUpdater:\n+          new SemanticDepGraphUpdater(step !== null ? step.priorState.semanticDepGraph : null),\n+    };\n+  }\n+\n+  /**\n+   * Begin a fresh `IncrementalCompilation`.\n+   */\n+  static fresh(program: ts.Program): IncrementalCompilation {\n+    const state: IncrementalState = {\n+      kind: IncrementalStateKind.Fresh,\n+    };\n+    return new IncrementalCompilation(state, new FileDependencyGraph(), /* reuse */ null);\n+  }\n+\n+  static incremental(\n+      program: ts.Program, oldProgram: ts.Program, oldState: IncrementalState,\n+      modifiedResourceFiles: Set<AbsoluteFsPath>|null, perf: PerfRecorder): IncrementalCompilation {\n+    return perf.inPhase(PerfPhase.Reconciliation, () => {\n+      let priorAnalysis: AnalyzedIncrementalState;\n+      const physicallyChangedTsFiles = new Set<AbsoluteFsPath>();\n+      const changedResourceFiles = new Set<AbsoluteFsPath>(modifiedResourceFiles ?? []);\n+\n+      switch (oldState.kind) {\n+        case IncrementalStateKind.Fresh:\n+          // Since this line of program has never been successfully analyzed to begin with, treat\n+          // this as a fresh compilation.\n+          return IncrementalCompilation.fresh(program);\n+        case IncrementalStateKind.Analyzed:\n+          // The most recent program was analyzed successfully, so we can use that as our prior\n+          // state and don't need to consider any other deltas except changes in the most recent\n+          // program.\n+          priorAnalysis = oldState;\n+          break;\n+        case IncrementalStateKind.Delta:\n+          // There is an ancestor program which was analyzed successfully and can be used as a\n+          // starting point, but we need to determine what's changed since that program.\n+          priorAnalysis = oldState.lastAnalyzedState;\n+          for (const sfPath of oldState.physicallyChangedTsFiles) {\n+            physicallyChangedTsFiles.add(sfPath);\n+          }\n+          for (const resourcePath of oldState.changedResourceFiles) {\n+            changedResourceFiles.add(resourcePath);\n+          }\n+          break;\n+      }\n+\n+      const oldFilesArray = oldProgram.getSourceFiles().map(sf => toUnredirectedSourceFile(sf));\n+      const oldFiles = new Set(oldFilesArray);\n+      const deletedTsFiles = new Set(oldFilesArray.map(sf => absoluteFromSourceFile(sf)));\n+\n+      for (const possiblyRedirectedNewFile of program.getSourceFiles()) {\n+        const sf = toUnredirectedSourceFile(possiblyRedirectedNewFile);\n+        const sfPath = absoluteFromSourceFile(sf);\n+        // Since we're seeing a file in the incoming program with this name, it can't have been\n+        // deleted.\n+        deletedTsFiles.delete(sfPath);\n+\n+        if (oldFiles.has(sf)) {\n+          // This file hasn't changed.\n+          continue;\n+        }\n+\n+        // Bail out if a .d.ts file changes - the semantic dep graph is not able to process such\n+        // changes correctly yet.\n+        if (sf.isDeclarationFile) {\n+          return IncrementalCompilation.fresh(program);\n+        }\n+\n+        // The file has changed physically, so record it.\n+        physicallyChangedTsFiles.add(sfPath);\n+      }\n+\n+      // Remove any files that have been deleted from the list of physical changes.\n+      for (const deletedFileName of deletedTsFiles) {\n+        physicallyChangedTsFiles.delete(resolve(deletedFileName));\n+      }\n+\n+      // Use the prior dependency graph to project physical changes into a set of logically changed\n+      // files.\n+      const depGraph = new FileDependencyGraph();\n+      const logicallyChangedTsFiles = depGraph.updateWithPhysicalChanges(\n+          priorAnalysis.depGraph, physicallyChangedTsFiles, deletedTsFiles, changedResourceFiles);\n+\n+      // Physically changed files aren't necessarily counted as logically changed by the dependency\n+      // graph (files do not have edges to themselves), so add them to the logical changes\n+      // explicitly.\n+      for (const sfPath of physicallyChangedTsFiles) {\n+        logicallyChangedTsFiles.add(sfPath);\n+      }\n+\n+      // Start off in a `DeltaIncrementalState` as a delta against the previous successful analysis,\n+      // until this compilation completes its own analysis.\n+      const state: DeltaIncrementalState = {\n+        kind: IncrementalStateKind.Delta,\n+        physicallyChangedTsFiles,\n+        changedResourceFiles,\n+        lastAnalyzedState: priorAnalysis,\n+      };\n+\n+      return new IncrementalCompilation(state, depGraph, {\n+        priorState: priorAnalysis,\n+        logicallyChangedTsFiles,\n+      });\n+    });\n+  }\n+\n+  get state(): IncrementalState {\n+    return this._state;\n+  }\n+\n+  get semanticDepGraphUpdater(): SemanticDepGraphUpdater {\n+    if (this.phase.kind !== PhaseKind.Analysis) {\n+      throw new Error(\n+          `AssertionError: Cannot update the SemanticDepGraph after analysis completes`);\n+    }\n+    return this.phase.semanticDepGraphUpdater;\n+  }\n+\n+  recordSuccessfulAnalysis(traitCompiler: TraitCompiler): void {\n+    if (this.phase.kind !== PhaseKind.Analysis) {\n+      throw new Error(`AssertionError: Incremental compilation in phase ${\n+          PhaseKind[this.phase.kind]}, expected Analysis`);\n+    }\n+\n+    const {needsEmit, needsTypeCheckEmit, newGraph} = this.phase.semanticDepGraphUpdater.finalize();\n+\n+    // Determine the set of files which have already been emitted.\n+    let emitted: Set<AbsoluteFsPath>;\n+    if (this.step === null) {\n+      // Since there is no prior compilation, no files have yet been emitted.\n+      emitted = new Set();\n+    } else {\n+      // Begin with the files emitted by the prior successful compilation, but remove those which we\n+      // know need to bee re-emitted.\n+      emitted = new Set(this.step.priorState.emitted);\n+\n+      // Files need re-emitted if they've logically changed.\n+      for (const sfPath of this.step.logicallyChangedTsFiles) {\n+        emitted.delete(sfPath);\n+      }\n+\n+      // Files need re-emitted if they've semantically changed.\n+      for (const sfPath of needsEmit) {\n+        emitted.delete(sfPath);\n+      }\n+    }\n+\n+    // Transition to a successfully analyzed compilation. At this point, a subsequent compilation\n+    // could use this state as a starting point.\n+    this._state = {\n+      kind: IncrementalStateKind.Analyzed,\n+      depGraph: this.depGraph,\n+      semanticDepGraph: newGraph,\n+      traitCompiler,\n+      typeCheckResults: null,\n+      emitted,\n+    };\n+\n+    // We now enter the type-check and emit phase of compilation.\n+    this.phase = {\n+      kind: PhaseKind.TypeCheckAndEmit,\n+      needsEmit,\n+      needsTypeCheckEmit,\n+    };\n+  }\n+\n+  recordSuccessfulTypeCheck(results: Map<AbsoluteFsPath, FileTypeCheckingData>): void {\n+    if (this._state.kind !== IncrementalStateKind.Analyzed) {\n+      throw new Error(`AssertionError: Expected successfully analyzed compilation.`);\n+    } else if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {\n+      throw new Error(`AssertionError: Incremental compilation in phase ${\n+          PhaseKind[this.phase.kind]}, expected TypeCheck`);\n+    }\n+\n+    this._state.typeCheckResults = results;\n+  }\n+\n+\n+  recordSuccessfulEmit(sf: ts.SourceFile): void {\n+    if (this._state.kind !== IncrementalStateKind.Analyzed) {\n+      throw new Error(`AssertionError: Expected successfully analyzed compilation.`);\n+    }\n+    this._state.emitted.add(absoluteFromSourceFile(sf));\n+  }\n+\n+  priorAnalysisFor(sf: ts.SourceFile): ClassRecord[]|null {\n+    if (this.step === null) {\n+      return null;\n+    }\n+\n+    const sfPath = absoluteFromSourceFile(sf);\n+\n+    // If the file has logically changed, its previous analysis cannot be reused.\n+    if (this.step.logicallyChangedTsFiles.has(sfPath)) {\n+      return null;\n+    }\n+\n+    return this.step.priorState.traitCompiler.recordsFor(sf);\n+  }\n+\n+  priorTypeCheckingResultsFor(sf: ts.SourceFile): FileTypeCheckingData|null {\n+    if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {\n+      throw new Error(`AssertionError: Expected successfully analyzed compilation.`);\n+    }\n+\n+    if (this.step === null) {\n+      return null;\n+    }\n+\n+    const sfPath = absoluteFromSourceFile(sf);\n+\n+    // If the file has logically changed, or its template type-checking results have semantically\n+    // changed, then past type-checking results cannot be reused.\n+    if (this.step.logicallyChangedTsFiles.has(sfPath) ||\n+        this.phase.needsTypeCheckEmit.has(sfPath)) {\n+      return null;\n+    }\n+\n+    // Past results also cannot be reused if they're not available.\n+    if (this.step.priorState.typeCheckResults === null ||\n+        !this.step.priorState.typeCheckResults.has(sfPath)) {\n+      return null;\n+    }\n+\n+    const priorResults = this.step.priorState.typeCheckResults.get(sfPath)!;\n+    // If the past results relied on inlining, they're not safe for reuse.\n+    if (priorResults.hasInlines) {\n+      return null;\n+    }\n+\n+    return priorResults;\n+  }\n+\n+  safeToSkipEmit(sf: ts.SourceFile): boolean {\n+    // If this is a fresh compilation, it's never safe to skip an emit.\n+    if (this.step === null) {\n+      return false;\n+    }\n+\n+    const sfPath = absoluteFromSourceFile(sf);\n+\n+    // If the file has itself logically changed, it must be emitted.\n+    if (this.step.logicallyChangedTsFiles.has(sfPath)) {\n+      return false;\n+    }\n+\n+    if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {\n+      throw new Error(\n+          `AssertionError: Expected successful analysis before attempting to emit files`);\n+    }\n+\n+    // If during analysis it was determined that this file has semantically changed, it must be\n+    // emitted.\n+    if (this.phase.needsEmit.has(sfPath)) {\n+      return false;\n+    }\n+\n+    // Generally it should be safe to assume here that the file was previously emitted by the last\n+    // successful compilation. However, as a defense-in-depth against incorrectness, we explicitly\n+    // check that the last emit included this file, and re-emit it otherwise.\n+    return this.step.priorState.emitted.has(sfPath);\n+  }\n+}"
        },
        {
            "sha": "378afd375cb215b6e806988725407a6dddf8aa9b",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/src/noop.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fnoop.ts",
            "raw_url": "https://github.com/angular/angular/raw/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fnoop.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fnoop.ts?ref=94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
            "patch": "@@ -9,7 +9,7 @@\n import {IncrementalBuild} from '../api';\n \n export const NOOP_INCREMENTAL_BUILD: IncrementalBuild<any, any> = {\n-  priorWorkFor: () => null,\n+  priorAnalysisFor: () => null,\n   priorTypeCheckingResultsFor: () => null,\n   recordSuccessfulTypeCheck: () => {},\n };"
        },
        {
            "sha": "6c7c4fb7680cfd348bdc58c0a0f804d70a9dd1c3",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/src/state.ts",
            "status": "modified",
            "additions": 61,
            "deletions": 369,
            "changes": 430,
            "blob_url": "https://github.com/angular/angular/blob/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fstate.ts",
            "raw_url": "https://github.com/angular/angular/raw/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fstate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fstate.ts?ref=94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
            "patch": "@@ -6,409 +6,101 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import * as ts from 'typescript';\n-\n-import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath} from '../../file_system';\n-import {PerfEvent, PerfPhase, PerfRecorder} from '../../perf';\n-import {ClassDeclaration} from '../../reflection';\n-import {ClassRecord, TraitCompiler} from '../../transform';\n+import {AbsoluteFsPath} from '../../file_system';\n+import {TraitCompiler} from '../../transform';\n import {FileTypeCheckingData} from '../../typecheck/src/checker';\n-import {toUnredirectedSourceFile} from '../../util/src/typescript';\n-import {IncrementalBuild} from '../api';\n-import {SemanticDepGraph, SemanticDepGraphUpdater} from '../semantic_graph';\n+import {SemanticDepGraph} from '../semantic_graph';\n \n import {FileDependencyGraph} from './dependency_tracking';\n \n /**\n- * Drives an incremental build, by tracking changes and determining which files need to be emitted.\n+ * Discriminant of the `IncrementalState` union.\n  */\n-export class IncrementalDriver implements IncrementalBuild<ClassRecord, FileTypeCheckingData> {\n-  /**\n-   * State of the current build.\n-   *\n-   * This transitions as the compilation progresses.\n-   */\n-  private state: BuildState;\n-\n-  private constructor(\n-      state: PendingBuildState, readonly depGraph: FileDependencyGraph,\n-      private logicalChanges: Set<string>|null) {\n-    this.state = state;\n-  }\n-\n-  /**\n-   * Construct an `IncrementalDriver` with a starting state that incorporates the results of a\n-   * previous build.\n-   *\n-   * The previous build's `BuildState` is reconciled with the new program's changes, and the results\n-   * are merged into the new build's `PendingBuildState`.\n-   */\n-  static reconcile(\n-      oldProgram: ts.Program, oldDriver: IncrementalDriver, newProgram: ts.Program,\n-      modifiedResourceFiles: Set<string>|null, perf: PerfRecorder): IncrementalDriver {\n-    return perf.inPhase(PerfPhase.Reconciliation, () => {\n-      // Initialize the state of the current build based on the previous one.\n-      let state: PendingBuildState;\n-      if (oldDriver.state.kind === BuildStateKind.Pending) {\n-        // The previous build never made it past the pending state. Reuse it as the starting state\n-        // for this build.\n-        state = oldDriver.state;\n-      } else {\n-        let priorGraph: SemanticDepGraph|null = null;\n-        if (oldDriver.state.lastGood !== null) {\n-          priorGraph = oldDriver.state.lastGood.semanticDepGraph;\n-        }\n-\n-        // The previous build was successfully analyzed. `pendingEmit` is the only state carried\n-        // forward into this build.\n-        state = {\n-          kind: BuildStateKind.Pending,\n-          pendingEmit: oldDriver.state.pendingEmit,\n-          pendingTypeCheckEmit: oldDriver.state.pendingTypeCheckEmit,\n-          changedResourcePaths: new Set<AbsoluteFsPath>(),\n-          changedTsPaths: new Set<string>(),\n-          lastGood: oldDriver.state.lastGood,\n-          semanticDepGraphUpdater: new SemanticDepGraphUpdater(priorGraph),\n-        };\n-      }\n-\n-      // Merge the freshly modified resource files with any prior ones.\n-      if (modifiedResourceFiles !== null) {\n-        for (const resFile of modifiedResourceFiles) {\n-          state.changedResourcePaths.add(absoluteFrom(resFile));\n-        }\n-      }\n-\n-      // Next, process the files in the new program, with a couple of goals:\n-      // 1) Determine which TS files have changed, if any, and merge them into `changedTsFiles`.\n-      // 2) Produce a list of TS files which no longer exist in the program (they've been deleted\n-      //    since the previous compilation). These need to be removed from the state tracking to\n-      //    avoid leaking memory.\n-\n-      // All files in the old program, for easy detection of changes.\n-      const oldFiles =\n-          new Set<ts.SourceFile>(oldProgram.getSourceFiles().map(toUnredirectedSourceFile));\n-\n-      // Assume all the old files were deleted to begin with. Only TS files are tracked.\n-      const deletedTsPaths = new Set<string>(tsOnlyFiles(oldProgram).map(sf => sf.fileName));\n-\n-      for (const possiblyRedirectedNewFile of newProgram.getSourceFiles()) {\n-        const newFile = toUnredirectedSourceFile(possiblyRedirectedNewFile);\n-        if (!newFile.isDeclarationFile) {\n-          // This file exists in the new program, so remove it from `deletedTsPaths`.\n-          deletedTsPaths.delete(newFile.fileName);\n-        }\n-\n-        if (oldFiles.has(newFile)) {\n-          // This file hasn't changed; no need to look at it further.\n-          continue;\n-        }\n-\n-        // The file has changed since the last successful build. The appropriate reaction depends on\n-        // what kind of file it is.\n-        if (!newFile.isDeclarationFile) {\n-          // It's a .ts file, so track it as a change.\n-          state.changedTsPaths.add(newFile.fileName);\n-        } else {\n-          // It's a .d.ts file. Currently the compiler does not do a great job of tracking\n-          // dependencies on .d.ts files, so bail out of incremental builds here and do a full\n-          // build. This usually only happens if something in node_modules changes.\n-          return IncrementalDriver.fresh(newProgram);\n-        }\n-      }\n-\n-      // The next step is to remove any deleted files from the state.\n-      for (const filePath of deletedTsPaths) {\n-        state.pendingEmit.delete(filePath);\n-        state.pendingTypeCheckEmit.delete(filePath);\n-\n-        // Even if the file doesn't exist in the current compilation, it still might have been\n-        // changed in a previous one, so delete it from the set of changed TS files, just in case.\n-        state.changedTsPaths.delete(filePath);\n-      }\n-\n-      perf.eventCount(PerfEvent.SourceFilePhysicalChange, state.changedTsPaths.size);\n-\n-      // Now, changedTsPaths contains physically changed TS paths. Use the previous program's\n-      // logical dependency graph to determine logically changed files.\n-      const depGraph = new FileDependencyGraph();\n-\n-      // If a previous compilation exists, use its dependency graph to determine the set of\n-      // logically changed files.\n-      let logicalChanges: Set<string>|null = null;\n-      if (state.lastGood !== null) {\n-        // Extract the set of logically changed files. At the same time, this operation populates\n-        // the current (fresh) dependency graph with information about those files which have not\n-        // logically changed.\n-        logicalChanges = depGraph.updateWithPhysicalChanges(\n-            state.lastGood.depGraph, state.changedTsPaths, deletedTsPaths,\n-            state.changedResourcePaths);\n-        perf.eventCount(PerfEvent.SourceFileLogicalChange, logicalChanges.size);\n-        for (const fileName of state.changedTsPaths) {\n-          logicalChanges.add(fileName);\n-        }\n-\n-        // Any logically changed files need to be re-emitted. Most of the time this would happen\n-        // regardless because the new dependency graph would _also_ identify the file as stale.\n-        // However there are edge cases such as removing a component from an NgModule without adding\n-        // it to another one, where the previous graph identifies the file as logically changed, but\n-        // the new graph (which does not have that edge) fails to identify that the file should be\n-        // re-emitted.\n-        for (const change of logicalChanges) {\n-          state.pendingEmit.add(change);\n-          state.pendingTypeCheckEmit.add(change);\n-        }\n-      }\n-\n-      // `state` now reflects the initial pending state of the current compilation.\n-      return new IncrementalDriver(state, depGraph, logicalChanges);\n-    });\n-  }\n-\n-  static fresh(program: ts.Program): IncrementalDriver {\n-    // Initialize the set of files which need to be emitted to the set of all TS files in the\n-    // program.\n-    const tsFiles = tsOnlyFiles(program);\n-\n-    const state: PendingBuildState = {\n-      kind: BuildStateKind.Pending,\n-      pendingEmit: new Set<string>(tsFiles.map(sf => sf.fileName)),\n-      pendingTypeCheckEmit: new Set<string>(tsFiles.map(sf => sf.fileName)),\n-      changedResourcePaths: new Set<AbsoluteFsPath>(),\n-      changedTsPaths: new Set<string>(),\n-      lastGood: null,\n-      semanticDepGraphUpdater: new SemanticDepGraphUpdater(/* priorGraph */ null),\n-    };\n-\n-    return new IncrementalDriver(state, new FileDependencyGraph(), /* logicalChanges */ null);\n-  }\n-\n-  getSemanticDepGraphUpdater(): SemanticDepGraphUpdater {\n-    if (this.state.kind !== BuildStateKind.Pending) {\n-      throw new Error('Semantic dependency updater is only available when pending analysis');\n-    }\n-    return this.state.semanticDepGraphUpdater;\n-  }\n-\n-  recordSuccessfulAnalysis(traitCompiler: TraitCompiler): void {\n-    if (this.state.kind !== BuildStateKind.Pending) {\n-      // Changes have already been incorporated.\n-      return;\n-    }\n-\n-    const {needsEmit, needsTypeCheckEmit, newGraph} = this.state.semanticDepGraphUpdater.finalize();\n-\n-    const pendingEmit = this.state.pendingEmit;\n-    for (const path of needsEmit) {\n-      pendingEmit.add(path);\n-    }\n-\n-    const pendingTypeCheckEmit = this.state.pendingTypeCheckEmit;\n-    for (const path of needsTypeCheckEmit) {\n-      pendingTypeCheckEmit.add(path);\n-    }\n-\n-    // Update the state to an `AnalyzedBuildState`.\n-    this.state = {\n-      kind: BuildStateKind.Analyzed,\n-      pendingEmit,\n-      pendingTypeCheckEmit,\n-\n-      // Since this compilation was successfully analyzed, update the \"last good\" artifacts to the\n-      // ones from the current compilation.\n-      lastGood: {\n-        depGraph: this.depGraph,\n-        semanticDepGraph: newGraph,\n-        traitCompiler: traitCompiler,\n-        typeCheckingResults: null,\n-      },\n-\n-      priorTypeCheckingResults:\n-          this.state.lastGood !== null ? this.state.lastGood.typeCheckingResults : null,\n-    };\n-  }\n-\n-  recordSuccessfulTypeCheck(results: Map<AbsoluteFsPath, FileTypeCheckingData>): void {\n-    if (this.state.lastGood === null || this.state.kind !== BuildStateKind.Analyzed) {\n-      return;\n-    }\n-    this.state.lastGood.typeCheckingResults = results;\n-\n-    // Delete the files for which type-check code was generated from the set of pending type-check\n-    // files.\n-    for (const fileName of results.keys()) {\n-      this.state.pendingTypeCheckEmit.delete(fileName);\n-    }\n-  }\n-\n-  recordSuccessfulEmit(sf: ts.SourceFile): void {\n-    this.state.pendingEmit.delete(sf.fileName);\n-  }\n-\n-  safeToSkipEmit(sf: ts.SourceFile): boolean {\n-    return !this.state.pendingEmit.has(sf.fileName);\n-  }\n-\n-  priorWorkFor(sf: ts.SourceFile): ClassRecord[]|null {\n-    if (this.state.lastGood === null || this.logicalChanges === null) {\n-      // There is no previous good build, so no prior work exists.\n-      return null;\n-    } else if (this.logicalChanges.has(sf.fileName)) {\n-      // Prior work might exist, but would be stale as the file in question has logically changed.\n-      return null;\n-    } else {\n-      // Prior work might exist, and if it does then it's usable!\n-      return this.state.lastGood.traitCompiler.recordsFor(sf);\n-    }\n-  }\n-\n-  priorTypeCheckingResultsFor(sf: ts.SourceFile): FileTypeCheckingData|null {\n-    if (this.state.kind !== BuildStateKind.Analyzed ||\n-        this.state.priorTypeCheckingResults === null || this.logicalChanges === null) {\n-      return null;\n-    }\n-\n-    if (this.logicalChanges.has(sf.fileName) || this.state.pendingTypeCheckEmit.has(sf.fileName)) {\n-      return null;\n-    }\n-\n-    const fileName = absoluteFromSourceFile(sf);\n-    if (!this.state.priorTypeCheckingResults.has(fileName)) {\n-      return null;\n-    }\n-    const data = this.state.priorTypeCheckingResults.get(fileName)!;\n-    if (data.hasInlines) {\n-      return null;\n-    }\n-\n-    return data;\n-  }\n+export enum IncrementalStateKind {\n+  Fresh,\n+  Delta,\n+  Analyzed,\n }\n \n-type BuildState = PendingBuildState|AnalyzedBuildState;\n-\n-enum BuildStateKind {\n-  Pending,\n-  Analyzed,\n+/**\n+ * Placeholder state for a fresh compilation that has never been successfully analyzed.\n+ */\n+export interface FreshIncrementalState {\n+  kind: IncrementalStateKind.Fresh;\n }\n \n-interface BaseBuildState {\n-  kind: BuildStateKind;\n+/**\n+ * State captured from a compilation that completed analysis successfully, that can serve as a\n+ * starting point for a future incremental build.\n+ */\n+export interface AnalyzedIncrementalState {\n+  kind: IncrementalStateKind.Analyzed;\n \n   /**\n-   * The heart of incremental builds. This `Set` tracks the set of files which need to be emitted\n-   * during the current compilation.\n-   *\n-   * This starts out as the set of files which are still pending from the previous program (or the\n-   * full set of .ts files on a fresh build).\n-   *\n-   * After analysis, it's updated to include any files which might have changed and need a re-emit\n-   * as a result of incremental changes.\n-   *\n-   * If an emit happens, any written files are removed from the `Set`, as they're no longer\n-   * pending.\n-   *\n-   * Thus, after compilation `pendingEmit` should be empty (on a successful build) or contain the\n-   * files which still need to be emitted but have not yet been (due to errors).\n-   *\n-   * `pendingEmit` is tracked as as `Set<string>` instead of a `Set<ts.SourceFile>`, because the\n-   * contents of the file are not important here, only whether or not the current version of it\n-   * needs to be emitted. The `string`s here are TS file paths.\n-   *\n-   * See the README.md for more information on this algorithm.\n+   * Dependency graph extracted from the build, to be used to determine the logical impact of\n+   * physical file changes.\n    */\n-  pendingEmit: Set<string>;\n+  depGraph: FileDependencyGraph;\n \n   /**\n-   * Similar to `pendingEmit`, but then for representing the set of files for which the type-check\n-   * file should be regenerated. It behaves identically with respect to errored compilations as\n-   * `pendingEmit`.\n+   * The semantic dependency graph from the build.\n+   *\n+   * This is used to perform in-depth comparison of Angular decorated classes, to determine\n+   * which files have to be re-emitted and/or re-type-checked.\n    */\n-  pendingTypeCheckEmit: Set<string>;\n-\n+  semanticDepGraph: SemanticDepGraph;\n \n   /**\n-   * Specific aspects of the last compilation which successfully completed analysis, if any.\n+   * `TraitCompiler` which contains records of all analyzed classes within the build.\n    */\n-  lastGood: {\n-    /**\n-     * The dependency graph from the last successfully analyzed build.\n-     *\n-     * This is used to determine the logical impact of physical file changes.\n-     */\n-    depGraph: FileDependencyGraph;\n-\n-    /**\n-     * The semantic dependency graph from the last successfully analyzed build.\n-     *\n-     * This is used to perform in-depth comparison of Angular decorated classes, to determine\n-     * which files have to be re-emitted and/or re-type-checked.\n-     */\n-    semanticDepGraph: SemanticDepGraph;\n-\n-    /**\n-     * The `TraitCompiler` from the last successfully analyzed build.\n-     *\n-     * This is used to extract \"prior work\" which might be reusable in this compilation.\n-     */\n-    traitCompiler: TraitCompiler;\n-\n-    /**\n-     * Type checking results which will be passed onto the next build.\n-     */\n-    typeCheckingResults: Map<AbsoluteFsPath, FileTypeCheckingData>| null;\n-  }|null;\n-}\n-\n-/**\n- * State of a build before the Angular analysis phase completes.\n- */\n-interface PendingBuildState extends BaseBuildState {\n-  kind: BuildStateKind.Pending;\n+  traitCompiler: TraitCompiler;\n \n   /**\n-   * Set of files which are known to need an emit.\n-   *\n-   * Before the compiler's analysis phase completes, `pendingEmit` only contains files that were\n-   * still pending after the previous build.\n+   * All generated template type-checking files produced as part of this compilation, or `null` if\n+   * type-checking was not (yet) performed.\n    */\n-  pendingEmit: Set<string>;\n+  typeCheckResults: Map<AbsoluteFsPath, FileTypeCheckingData>|null;\n \n   /**\n-   * Set of TypeScript file paths which have changed since the last successfully analyzed build.\n+   * Cumulative set of source file paths which were definitively emitted by this compilation or\n+   * carried forward from a prior one.\n    */\n-  changedTsPaths: Set<string>;\n+  emitted: Set<AbsoluteFsPath>;\n+}\n \n-  /**\n-   * Set of resource file paths which have changed since the last successfully analyzed build.\n-   */\n-  changedResourcePaths: Set<AbsoluteFsPath>;\n+/**\n+ * Incremental state for a compilation that has not been successfully analyzed, but that can be\n+ * based on a previous compilation which was.\n+ *\n+ * This is the state produced by an incremeental compilation until its own analysis succeeds. If\n+ * analysis fails, this state carries forward information about which files have changed since the\n+ * last successful build (the `lastAnalyzedState`), so that the next incremental build can consider\n+ * the total delta between the `lastAnalyzedState` and the current program in its incremental\n+ * analysis.\n+ */\n+export interface DeltaIncrementalState {\n+  kind: IncrementalStateKind.Delta;\n \n   /**\n-   * In a pending state, the semantic dependency graph is available to the compilation to register\n-   * the incremental symbols into.\n+   * If available, the `AnalyzedIncrementalState` for the most recent ancestor of the current\n+   * program which was successfully analyzed.\n    */\n-  semanticDepGraphUpdater: SemanticDepGraphUpdater;\n-}\n-\n-interface AnalyzedBuildState extends BaseBuildState {\n-  kind: BuildStateKind.Analyzed;\n+  lastAnalyzedState: AnalyzedIncrementalState;\n \n   /**\n-   * Set of files which are known to need an emit.\n-   *\n-   * After analysis completes (that is, the state transitions to `AnalyzedBuildState`), the\n-   * `pendingEmit` set takes into account any on-disk changes made since the last successfully\n-   * analyzed build.\n+   * Set of file paths which have changed since the `lastAnalyzedState` compilation.\n    */\n-  pendingEmit: Set<string>;\n+  physicallyChangedTsFiles: Set<AbsoluteFsPath>;\n \n   /**\n-   * Type checking results from the previous compilation, which can be reused in this one.\n+   * Set of resource file paths which have changed since the `lastAnalyzedState` compilation.\n    */\n-  priorTypeCheckingResults: Map<AbsoluteFsPath, FileTypeCheckingData>|null;\n+  changedResourceFiles: Set<AbsoluteFsPath>;\n }\n \n-function tsOnlyFiles(program: ts.Program): ReadonlyArray<ts.SourceFile> {\n-  return program.getSourceFiles().filter(sf => !sf.isDeclarationFile);\n-}\n+/**\n+ * State produced by a compilation that's usable as the starting point for a subsequent compilation.\n+ *\n+ * Discriminated by the `IncrementalStateKind` enum.\n+ */\n+export type IncrementalState = AnalyzedIncrementalState|DeltaIncrementalState|FreshIncrementalState;"
        },
        {
            "sha": "94525a767aeff6cdf10f2499dc6e232c18e181e3",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/src/strategy.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 19,
            "changes": 42,
            "blob_url": "https://github.com/angular/angular/blob/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fstrategy.ts",
            "raw_url": "https://github.com/angular/angular/raw/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fstrategy.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fstrategy.ts?ref=94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
            "patch": "@@ -7,7 +7,7 @@\n  */\n \n import * as ts from 'typescript';\n-import {IncrementalDriver} from './state';\n+import {IncrementalState} from './state';\n \n /**\n  * Strategy used to manage the association between a `ts.Program` and the `IncrementalDriver` which\n@@ -17,13 +17,13 @@ export interface IncrementalBuildStrategy {\n   /**\n    * Determine the Angular `IncrementalDriver` for the given `ts.Program`, if one is available.\n    */\n-  getIncrementalDriver(program: ts.Program): IncrementalDriver|null;\n+  getIncrementalState(program: ts.Program): IncrementalState|null;\n \n   /**\n    * Associate the given `IncrementalDriver` with the given `ts.Program` and make it available to\n    * future compilations.\n    */\n-  setIncrementalDriver(driver: IncrementalDriver, program: ts.Program): void;\n+  setIncrementalState(driver: IncrementalState, program: ts.Program): void;\n \n   /**\n    * Convert this `IncrementalBuildStrategy` into a possibly new instance to be used in the next\n@@ -37,11 +37,11 @@ export interface IncrementalBuildStrategy {\n  * incremental data.\n  */\n export class NoopIncrementalBuildStrategy implements IncrementalBuildStrategy {\n-  getIncrementalDriver(): null {\n+  getIncrementalState(): null {\n     return null;\n   }\n \n-  setIncrementalDriver(): void {}\n+  setIncrementalState(): void {}\n \n   toNextBuildStrategy(): IncrementalBuildStrategy {\n     return this;\n@@ -52,22 +52,22 @@ export class NoopIncrementalBuildStrategy implements IncrementalBuildStrategy {\n  * Tracks an `IncrementalDriver` within the strategy itself.\n  */\n export class TrackedIncrementalBuildStrategy implements IncrementalBuildStrategy {\n-  private driver: IncrementalDriver|null = null;\n+  private state: IncrementalState|null = null;\n   private isSet: boolean = false;\n \n-  getIncrementalDriver(): IncrementalDriver|null {\n-    return this.driver;\n+  getIncrementalState(): IncrementalState|null {\n+    return this.state;\n   }\n \n-  setIncrementalDriver(driver: IncrementalDriver): void {\n-    this.driver = driver;\n+  setIncrementalState(state: IncrementalState): void {\n+    this.state = state;\n     this.isSet = true;\n   }\n \n   toNextBuildStrategy(): TrackedIncrementalBuildStrategy {\n     const strategy = new TrackedIncrementalBuildStrategy();\n-    // Only reuse a driver that was explicitly set via `setIncrementalDriver`.\n-    strategy.driver = this.isSet ? this.driver : null;\n+    // Only reuse state that was explicitly set via `setIncrementalState`.\n+    strategy.state = this.isSet ? this.state : null;\n     return strategy;\n   }\n }\n@@ -77,16 +77,16 @@ export class TrackedIncrementalBuildStrategy implements IncrementalBuildStrategy\n  * program under `SYM_INCREMENTAL_DRIVER`.\n  */\n export class PatchedProgramIncrementalBuildStrategy implements IncrementalBuildStrategy {\n-  getIncrementalDriver(program: ts.Program): IncrementalDriver|null {\n-    const driver = (program as any)[SYM_INCREMENTAL_DRIVER];\n-    if (driver === undefined || !(driver instanceof IncrementalDriver)) {\n+  getIncrementalState(program: ts.Program): IncrementalState|null {\n+    const state = (program as MayHaveIncrementalState)[SYM_INCREMENTAL_STATE];\n+    if (state === undefined) {\n       return null;\n     }\n-    return driver;\n+    return state;\n   }\n \n-  setIncrementalDriver(driver: IncrementalDriver, program: ts.Program): void {\n-    (program as any)[SYM_INCREMENTAL_DRIVER] = driver;\n+  setIncrementalState(state: IncrementalState, program: ts.Program): void {\n+    (program as MayHaveIncrementalState)[SYM_INCREMENTAL_STATE] = state;\n   }\n \n   toNextBuildStrategy(): IncrementalBuildStrategy {\n@@ -108,4 +108,8 @@ export class PatchedProgramIncrementalBuildStrategy implements IncrementalBuildS\n  * support this behind the API of passing an old `ts.Program`, the `IncrementalDriver` is stored on\n  * the `ts.Program` under this symbol.\n  */\n-const SYM_INCREMENTAL_DRIVER = Symbol('NgIncrementalDriver');\n+const SYM_INCREMENTAL_STATE = Symbol('NgIncrementalState');\n+\n+interface MayHaveIncrementalState {\n+  [SYM_INCREMENTAL_STATE]?: IncrementalState;\n+}"
        },
        {
            "sha": "8fab53d43a9b7d6b98534f3ca34c76b22156f477",
            "filename": "packages/compiler-cli/src/ngtsc/program.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts",
            "raw_url": "https://github.com/angular/angular/raw/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts?ref=94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
            "patch": "@@ -253,7 +253,7 @@ export class NgtscProgram implements api.Program {\n                   continue;\n                 }\n \n-                this.compiler.incrementalDriver.recordSuccessfulEmit(writtenSf);\n+                this.compiler.incrementalCompilation.recordSuccessfulEmit(writtenSf);\n               }\n             }\n             this.host.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles);\n@@ -274,7 +274,7 @@ export class NgtscProgram implements api.Program {\n           continue;\n         }\n \n-        if (this.compiler.incrementalDriver.safeToSkipEmit(targetSourceFile)) {\n+        if (this.compiler.incrementalCompilation.safeToSkipEmit(targetSourceFile)) {\n           this.compiler.perfRecorder.eventCount(PerfEvent.EmitSkipSourceFile);\n           continue;\n         }"
        },
        {
            "sha": "aabc0cf5a78ce8a6e3a77d9b0442cf7b1a6451bd",
            "filename": "packages/compiler-cli/src/ngtsc/transform/src/compilation.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fcompilation.ts",
            "raw_url": "https://github.com/angular/angular/raw/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fcompilation.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fcompilation.ts?ref=94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
            "patch": "@@ -118,7 +118,7 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n     // type of 'void', so `undefined` is used instead.\n     const promises: Promise<void>[] = [];\n \n-    const priorWork = this.incrementalBuild.priorWorkFor(sf);\n+    const priorWork = this.incrementalBuild.priorAnalysisFor(sf);\n     if (priorWork !== null) {\n       for (const priorRecord of priorWork) {\n         this.adopt(priorRecord);"
        },
        {
            "sha": "7f90bd12a7c18882718ca079496bd639ebb49289",
            "filename": "packages/compiler-cli/src/ngtsc/tsc_plugin.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 12,
            "changes": 23,
            "blob_url": "https://github.com/angular/angular/blob/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftsc_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftsc_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftsc_plugin.ts?ref=94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
            "patch": "@@ -8,9 +8,9 @@\n \n import * as ts from 'typescript';\n \n-import {CompilationTicket, freshCompilationTicket, incrementalFromDriverTicket, NgCompiler, NgCompilerHost} from './core';\n+import {CompilationTicket, freshCompilationTicket, incrementalFromStateTicket, NgCompiler, NgCompilerHost} from './core';\n import {NgCompilerOptions, UnifiedModulesHost} from './core/api';\n-import {NodeJSFileSystem, setFileSystem} from './file_system';\n+import {AbsoluteFsPath, NodeJSFileSystem, resolve, setFileSystem} from './file_system';\n import {PatchedProgramIncrementalBuildStrategy} from './incremental';\n import {ActivePerfRecorder, PerfPhase} from './perf';\n import {TsCreateProgramDriver} from './program_driver';\n@@ -109,25 +109,24 @@ export class NgTscPlugin implements TscPlugin {\n     const programDriver = new TsCreateProgramDriver(\n         program, this.host, this.options, this.host.shimExtensionPrefixes);\n     const strategy = new PatchedProgramIncrementalBuildStrategy();\n-    const oldDriver = oldProgram !== undefined ? strategy.getIncrementalDriver(oldProgram) : null;\n+    const oldState = oldProgram !== undefined ? strategy.getIncrementalState(oldProgram) : null;\n     let ticket: CompilationTicket;\n \n-    let modifiedResourceFiles: Set<string>|undefined = undefined;\n+    const modifiedResourceFiles = new Set<AbsoluteFsPath>();\n     if (this.host.getModifiedResourceFiles !== undefined) {\n-      modifiedResourceFiles = this.host.getModifiedResourceFiles();\n-    }\n-    if (modifiedResourceFiles === undefined) {\n-      modifiedResourceFiles = new Set<string>();\n+      for (const resourceFile of this.host.getModifiedResourceFiles() ?? []) {\n+        modifiedResourceFiles.add(resolve(resourceFile));\n+      }\n     }\n \n-    if (oldProgram === undefined || oldDriver === null) {\n+    if (oldProgram === undefined || oldState === null) {\n       ticket = freshCompilationTicket(\n           program, this.options, strategy, programDriver, perfRecorder,\n           /* enableTemplateTypeChecker */ false, /* usePoisonedData */ false);\n     } else {\n-      strategy.toNextBuildStrategy().getIncrementalDriver(oldProgram);\n-      ticket = incrementalFromDriverTicket(\n-          oldProgram, oldDriver, program, this.options, strategy, programDriver,\n+      strategy.toNextBuildStrategy().getIncrementalState(oldProgram);\n+      ticket = incrementalFromStateTicket(\n+          oldProgram, oldState, program, this.options, strategy, programDriver,\n           modifiedResourceFiles, perfRecorder, false, false);\n     }\n     this._compiler = NgCompiler.fromTicket(ticket, this.host);"
        },
        {
            "sha": "b424d027619d5c854813cd5e6105eeda29165eb6",
            "filename": "packages/language-service/ivy/compiler_factory.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Flanguage-service%2Fivy%2Fcompiler_factory.ts",
            "raw_url": "https://github.com/angular/angular/raw/94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9/packages%2Flanguage-service%2Fivy%2Fcompiler_factory.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompiler_factory.ts?ref=94ec0af582fe385ce3bd8c9feab4f7dadfbf38d9",
            "patch": "@@ -8,6 +8,7 @@\n \n import {CompilationTicket, freshCompilationTicket, incrementalFromCompilerTicket, NgCompiler, resourceChangeTicket} from '@angular/compiler-cli/src/ngtsc/core';\n import {NgCompilerOptions} from '@angular/compiler-cli/src/ngtsc/core/api';\n+import {AbsoluteFsPath, resolve} from '@angular/compiler-cli/src/ngtsc/file_system';\n import {TrackedIncrementalBuildStrategy} from '@angular/compiler-cli/src/ngtsc/incremental';\n import {ProgramDriver} from '@angular/compiler-cli/src/ngtsc/program_driver';\n \n@@ -34,7 +35,10 @@ export class CompilerFactory {\n \n   getOrCreate(): NgCompiler {\n     const program = this.programStrategy.getProgram();\n-    const modifiedResourceFiles = this.adapter.getModifiedResourceFiles() ?? new Set();\n+    const modifiedResourceFiles = new Set<AbsoluteFsPath>();\n+    for (const fileName of this.adapter.getModifiedResourceFiles() ?? []) {\n+      modifiedResourceFiles.add(resolve(fileName));\n+    }\n \n     if (this.compiler !== null && program === this.compiler.getCurrentProgram()) {\n       if (modifiedResourceFiles.size > 0) {"
        }
    ],
    "stats": {
        "total": 966,
        "additions": 515,
        "deletions": 451
    }
}