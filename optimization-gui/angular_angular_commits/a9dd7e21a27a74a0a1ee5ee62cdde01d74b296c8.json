{
    "author": "JoostK",
    "message": "refactor(compiler-cli): enable relative imports in the type parameter emitter (#42492)\n\nPreviously, the template type checker would only opt-in to inline type\nconstructors if it could import all type references from absolute module\nspecifiers. This limitation was put into place in an abundance of\ncaution as there was a safe, but less performant, fallback available.\n\nThe language service is not capable of using this fallback, which now\nmeans that the limitation of absolute module specifiers limits the\nlanguage service's ability to use accurate types for component/directive\nclasses that have generic type parameters.\n\nThis commit loosens the restriction such that type references are now\neligible for emit as long as they are exported.\n\nPR Close #42492",
    "sha": "a9dd7e21a27a74a0a1ee5ee62cdde01d74b296c8",
    "files": [
        {
            "sha": "4c7ed9151f3947ec8199afe02083693673ccde67",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_emitter.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 9,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/a9dd7e21a27a74a0a1ee5ee62cdde01d74b296c8/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_emitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/a9dd7e21a27a74a0a1ee5ee62cdde01d74b296c8/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_emitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_emitter.ts?ref=a9dd7e21a27a74a0a1ee5ee62cdde01d74b296c8",
            "patch": "@@ -10,7 +10,8 @@ import {Reference} from '../../imports';\n \n /**\n  * A resolved type reference can either be a `Reference`, the original `ts.TypeReferenceNode` itself\n- * or null to indicate the no reference could be resolved.\n+ * or null. A value of null indicates that no reference could be resolved or that the reference can\n+ * not be emitted.\n  */\n export type ResolvedTypeReference = Reference|ts.TypeReferenceNode|null;\n \n@@ -69,10 +70,9 @@ export function canEmitType(type: ts.TypeNode, resolver: TypeReferenceResolver):\n       return false;\n     }\n \n-    // If the type is a reference without a owning module, consider the type not to be eligible for\n-    // emitting.\n-    if (reference instanceof Reference && !reference.hasOwningModuleGuess) {\n-      return false;\n+    // If the type is a reference, consider the type to be eligible for emitting.\n+    if (reference instanceof Reference) {\n+      return true;\n     }\n \n     // The type can be emitted if either it does not have any type arguments, or all of them can be\n@@ -157,10 +157,6 @@ export class TypeEmitter {\n     // Emit the type name.\n     let typeName = type.typeName;\n     if (reference instanceof Reference) {\n-      if (!reference.hasOwningModuleGuess) {\n-        throw new Error('A type reference to emit must be imported from an absolute module');\n-      }\n-\n       const emittedType = this.emitReference(reference);\n       if (!ts.isTypeReferenceNode(emittedType)) {\n         throw new Error(`Expected TypeReferenceNode for emitted reference, got ${"
        },
        {
            "sha": "61a5f6d97282cc5eb1c220ecd0c09ef5f60f17f0",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/a9dd7e21a27a74a0a1ee5ee62cdde01d74b296c8/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_parameter_emitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/a9dd7e21a27a74a0a1ee5ee62cdde01d74b296c8/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_parameter_emitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_parameter_emitter.ts?ref=a9dd7e21a27a74a0a1ee5ee62cdde01d74b296c8",
            "patch": "@@ -8,7 +8,7 @@\n import * as ts from 'typescript';\n \n import {OwningModule, Reference} from '../../imports';\n-import {DeclarationNode, ReflectionHost} from '../../reflection';\n+import {DeclarationNode, isNamedClassDeclaration, ReflectionHost} from '../../reflection';\n \n import {canEmitType, ResolvedTypeReference, TypeEmitter} from './type_emitter';\n \n@@ -92,9 +92,19 @@ export class TypeParameterEmitter {\n       };\n     }\n \n+    // If no owning module is known, the reference needs to be exported to be able to emit an import\n+    // statement for it. If the declaration is not exported, null is returned to prevent emit.\n+    if (owningModule === null && !this.isStaticallyExported(declaration.node)) {\n+      return null;\n+    }\n+\n     return new Reference(declaration.node, owningModule);\n   }\n \n+  private isStaticallyExported(decl: DeclarationNode): boolean {\n+    return isNamedClassDeclaration(decl) && this.reflector.isStaticallyExported(decl);\n+  }\n+\n   private isLocalTypeParameter(decl: DeclarationNode): boolean {\n     // Checking for local type parameters only occurs during resolution of type parameters, so it is\n     // guaranteed that type parameters are present."
        },
        {
            "sha": "ed56a33a50d014546715c0e0cd92364cb91241e4",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_parameter_emitter_spec.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 16,
            "changes": 37,
            "blob_url": "https://github.com/angular/angular/blob/a9dd7e21a27a74a0a1ee5ee62cdde01d74b296c8/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_parameter_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a9dd7e21a27a74a0a1ee5ee62cdde01d74b296c8/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_parameter_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_parameter_emitter_spec.ts?ref=a9dd7e21a27a74a0a1ee5ee62cdde01d74b296c8",
            "patch": "@@ -116,26 +116,34 @@ runInEachFileSystem(() => {\n       expect(emit(emitter)).toEqual('<T, U extends test.NgIterable<T>>');\n     });\n \n-    it('cannot emit references to local declarations', () => {\n+    it('can emit references to local, exported declarations', () => {\n       const emitter = createEmitter(`\n-          export class Local {};\n+          class Local {};\n+          export {Local};\n+          export class TestClass<T extends Local> {}`);\n+\n+      expect(emitter.canEmit()).toBe(true);\n+      expect(emit(emitter)).toEqual('<T extends test.Local>');\n+    });\n+\n+    it('cannot emit references to non-exported local declarations', () => {\n+      const emitter = createEmitter(`\n+          class Local {};\n           export class TestClass<T extends Local> {}`);\n \n       expect(emitter.canEmit()).toBe(false);\n-      expect(() => emit(emitter))\n-          .toThrowError('A type reference to emit must be imported from an absolute module');\n+      expect(() => emit(emitter)).toThrowError('Unable to emit an unresolved reference');\n     });\n \n     it('cannot emit references to local declarations as nested type arguments', () => {\n       const emitter = createEmitter(`\n           import {NgIterable} from '@angular/core';\n \n-          export class Local {};\n+          class Local {};\n           export class TestClass<T extends NgIterable<Local>> {}`);\n \n       expect(emitter.canEmit()).toBe(false);\n-      expect(() => emit(emitter))\n-          .toThrowError('A type reference to emit must be imported from an absolute module');\n+      expect(() => emit(emitter)).toThrowError('Unable to emit an unresolved reference');\n     });\n \n     it('can emit references into external modules within array types', () => {\n@@ -150,15 +158,14 @@ runInEachFileSystem(() => {\n \n     it('cannot emit references to local declarations within array types', () => {\n       const emitter = createEmitter(`\n-          export class Local {};\n+          class Local {};\n           export class TestClass<T extends Local[]> {}`);\n \n       expect(emitter.canEmit()).toBe(false);\n-      expect(() => emit(emitter))\n-          .toThrowError('A type reference to emit must be imported from an absolute module');\n+      expect(() => emit(emitter)).toThrowError('Unable to emit an unresolved reference');\n     });\n \n-    it('cannot emit references into relative files', () => {\n+    it('can emit references into relative files', () => {\n       const additionalFiles: TestFile[] = [{\n         name: absoluteFrom('/internal.ts'),\n         contents: `export class Internal {}`,\n@@ -170,9 +177,8 @@ runInEachFileSystem(() => {\n           export class TestClass<T extends Internal> {}`,\n           additionalFiles);\n \n-      expect(emitter.canEmit()).toBe(false);\n-      expect(() => emit(emitter))\n-          .toThrowError('A type reference to emit must be imported from an absolute module');\n+      expect(emitter.canEmit()).toBe(true);\n+      expect(emit(emitter)).toEqual('<T extends test.Internal>');\n     });\n \n     it('can emit references to interfaces', () => {\n@@ -246,8 +252,7 @@ runInEachFileSystem(() => {\n           export class TestClass<T extends object = Local> {}`);\n \n       expect(emitter.canEmit()).toBe(false);\n-      expect(() => emit(emitter))\n-          .toThrowError('A type reference to emit must be imported from an absolute module');\n+      expect(() => emit(emitter)).toThrowError('Unable to emit an unresolved reference');\n     });\n   });\n });"
        }
    ],
    "stats": {
        "total": 63,
        "additions": 37,
        "deletions": 26
    }
}