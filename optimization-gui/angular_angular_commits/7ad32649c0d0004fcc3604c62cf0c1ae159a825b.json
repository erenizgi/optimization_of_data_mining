{
    "author": "atscott",
    "message": "fix(router): support lazy loading for empty path named outlets (#38379)\n\nIn general, the router only matches and loads a single Route config tree. However,\nnamed outlets with empty paths are a special case where the router can\nand should actually match two different `Route`s and ensure that the\nmodules are loaded for each match.\n\nThis change updates the \"ApplyRedirects\" stage to ensure that named\noutlets with empty paths finish loading their configs before proceeding\nto the next stage in the routing pipe. This is necessary because if the\nnamed outlet has `loadChildren` but the associated lazy config is not loaded\nbefore following stages attempt to match and activate relevant `Route`s,\nan error will occur.\n\nfixes #12842\n\nPR Close #38379",
    "sha": "7ad32649c0d0004fcc3604c62cf0c1ae159a825b",
    "files": [
        {
            "sha": "b6c8981eb9cb2740c1810901242a87fde9c15d50",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/7ad32649c0d0004fcc3604c62cf0c1ae159a825b/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/7ad32649c0d0004fcc3604c62cf0c1ae159a825b/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=7ad32649c0d0004fcc3604c62cf0c1ae159a825b",
            "patch": "@@ -39,7 +39,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2289,\n-        \"main-es2015\": 245351,\n+        \"main-es2015\": 245885,\n         \"polyfills-es2015\": 36938,\n         \"5-es2015\": 751\n       }"
        },
        {
            "sha": "21b7b00234519fcea536e985278dc2b43be7af21",
            "filename": "packages/router/src/apply_redirects.ts",
            "status": "modified",
            "additions": 45,
            "deletions": 24,
            "changes": 69,
            "blob_url": "https://github.com/angular/angular/blob/7ad32649c0d0004fcc3604c62cf0c1ae159a825b/packages%2Frouter%2Fsrc%2Fapply_redirects.ts",
            "raw_url": "https://github.com/angular/angular/raw/7ad32649c0d0004fcc3604c62cf0c1ae159a825b/packages%2Frouter%2Fsrc%2Fapply_redirects.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Fapply_redirects.ts?ref=7ad32649c0d0004fcc3604c62cf0c1ae159a825b",
            "patch": "@@ -8,7 +8,7 @@\n \n import {Injector, NgModuleRef} from '@angular/core';\n import {defer, EmptyError, Observable, Observer, of} from 'rxjs';\n-import {catchError, concatAll, first, map, mergeMap, tap} from 'rxjs/operators';\n+import {catchError, first, map, mergeMap, switchMap, tap} from 'rxjs/operators';\n \n import {LoadedRouterConfig, Route, Routes} from './config';\n import {CanLoadFn} from './interfaces';\n@@ -148,28 +148,47 @@ class ApplyRedirects {\n       ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[],\n       segments: UrlSegment[], outlet: string,\n       allowRedirects: boolean): Observable<UrlSegmentGroup> {\n-    return of(...routes).pipe(\n-        map((r: any) => {\n-          const expanded$ = this.expandSegmentAgainstRoute(\n-              ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n-          return expanded$.pipe(catchError((e: any) => {\n-            if (e instanceof NoMatch) {\n-              // TODO(i): this return type doesn't match the declared Observable<UrlSegmentGroup> -\n-              // talk to Jason\n-              return of(null) as any;\n-            }\n-            throw e;\n-          }));\n-        }),\n-        concatAll(), first((s: any) => !!s), catchError((e: any, _: any) => {\n-          if (e instanceof EmptyError || e.name === 'EmptyError') {\n-            if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n-              return of(new UrlSegmentGroup([], {}));\n-            }\n-            throw new NoMatch(segmentGroup);\n-          }\n-          throw e;\n-        }));\n+    type MatchedSegment = {segment: UrlSegmentGroup, outlet: string};\n+    // This logic takes each route and switches to a new observable that depends on the result of\n+    // the previous route expansion. In this way, we compose a list of results where each one can\n+    // depend on and look at the previous to determine how to proceed with expansion of the\n+    // current route.\n+    return routes\n+        .reduce(\n+            (accumulatedResults: Observable<Array<MatchedSegment>>, r: Route) => {\n+              return accumulatedResults.pipe(switchMap(resultsThusFar => {\n+                // If we already matched a previous `Route` with the same outlet as the current,\n+                // we should not process the current one.\n+                if (resultsThusFar.some(result => result && result.outlet === getOutlet(r))) {\n+                  return of(resultsThusFar);\n+                }\n+                const expanded$ = this.expandSegmentAgainstRoute(\n+                    ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n+                return expanded$.pipe(\n+                    map((segment) => resultsThusFar.concat({segment, outlet: getOutlet(r)})),\n+                    catchError((e: any) => {\n+                      if (e instanceof NoMatch) {\n+                        return of(resultsThusFar);\n+                      }\n+                      throw e;\n+                    }));\n+              }));\n+            },\n+            of([] as MatchedSegment[]))\n+        .pipe(\n+            // Find the matched segment whose outlet matches the one we're looking for.\n+            map(results => results.find(s => s.outlet === outlet)?.segment),\n+            first((s): s is UrlSegmentGroup => s !== undefined),\n+            catchError((e: any, _: any) => {\n+              if (e instanceof EmptyError || e.name === 'EmptyError') {\n+                if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n+                  return of(new UrlSegmentGroup([], {}));\n+                }\n+                throw new NoMatch(segmentGroup);\n+              }\n+              throw e;\n+            }),\n+        );\n   }\n \n   private noLeftoversInUrl(segmentGroup: UrlSegmentGroup, segments: UrlSegment[], outlet: string):\n@@ -180,7 +199,9 @@ class ApplyRedirects {\n   private expandSegmentAgainstRoute(\n       ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n       paths: UrlSegment[], outlet: string, allowRedirects: boolean): Observable<UrlSegmentGroup> {\n-    if (getOutlet(route) !== outlet) {\n+    // Empty string segments are special because multiple outlets can match a single path, i.e.\n+    // `[{path: '', component: B}, {path: '', loadChildren: () => {}, outlet: \"about\"}]`\n+    if (getOutlet(route) !== outlet && route.path !== '') {\n       return noMatch(segmentGroup);\n     }\n "
        },
        {
            "sha": "812b7b83bb7385f1eacb60439f42acf42d425ca6",
            "filename": "packages/router/test/apply_redirects.spec.ts",
            "status": "modified",
            "additions": 125,
            "deletions": 2,
            "changes": 127,
            "blob_url": "https://github.com/angular/angular/blob/7ad32649c0d0004fcc3604c62cf0c1ae159a825b/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7ad32649c0d0004fcc3604c62cf0c1ae159a825b/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts?ref=7ad32649c0d0004fcc3604c62cf0c1ae159a825b",
            "patch": "@@ -7,9 +7,9 @@\n  */\n \n import {NgModuleRef} from '@angular/core';\n-import {TestBed} from '@angular/core/testing';\n+import {fakeAsync, TestBed, tick} from '@angular/core/testing';\n import {Observable, of} from 'rxjs';\n-import {delay} from 'rxjs/operators';\n+import {delay, tap} from 'rxjs/operators';\n \n import {applyRedirects} from '../src/apply_redirects';\n import {LoadedRouterConfig, Route, Routes} from '../src/config';\n@@ -482,6 +482,89 @@ describe('applyRedirects', () => {\n             expect((config[0] as any)._loadedConfig).toBe(loadedConfig);\n           });\n     });\n+\n+    it('should load all matching configurations of empty path, including an auxiliary outlets',\n+       fakeAsync(() => {\n+         const loadedConfig =\n+             new LoadedRouterConfig([{path: '', component: ComponentA}], testModule);\n+         let loadCalls = 0;\n+         let loaded: string[] = [];\n+         const loader = {\n+           load: (injector: any, p: Route) => {\n+             loadCalls++;\n+             return of(loadedConfig)\n+                 .pipe(\n+                     delay(100 * loadCalls),\n+                     tap(() => loaded.push(p.loadChildren! as string)),\n+                 );\n+           }\n+         };\n+\n+         const config: Routes =\n+             [{path: '', loadChildren: 'root'}, {path: '', loadChildren: 'aux', outlet: 'popup'}];\n+\n+         applyRedirects(testModule.injector, <any>loader, serializer, tree(''), config).subscribe();\n+         expect(loadCalls).toBe(1);\n+         tick(100);\n+         expect(loaded).toEqual(['root']);\n+         tick(200);\n+         expect(loadCalls).toBe(2);\n+         expect(loaded).toEqual(['root', 'aux']);\n+       }));\n+\n+    it('loads only the first match when two Routes with the same outlet have the same path', () => {\n+      const loadedConfig = new LoadedRouterConfig([{path: '', component: ComponentA}], testModule);\n+      let loadCalls = 0;\n+      let loaded: string[] = [];\n+      const loader = {\n+        load: (injector: any, p: Route) => {\n+          loadCalls++;\n+          return of(loadedConfig)\n+              .pipe(\n+                  tap(() => loaded.push(p.loadChildren! as string)),\n+              );\n+        }\n+      };\n+\n+      const config: Routes =\n+          [{path: 'a', loadChildren: 'first'}, {path: 'a', loadChildren: 'second'}];\n+\n+      applyRedirects(testModule.injector, <any>loader, serializer, tree('a'), config).subscribe();\n+      expect(loadCalls).toBe(1);\n+      expect(loaded).toEqual(['first']);\n+    });\n+\n+    it('should load the configuration of empty root path if the entry is an aux outlet',\n+       fakeAsync(() => {\n+         const loadedConfig =\n+             new LoadedRouterConfig([{path: '', component: ComponentA}], testModule);\n+         let loaded: string[] = [];\n+         const rootDelay = 100;\n+         const auxDelay = 1;\n+         const loader = {\n+           load: (injector: any, p: Route) => {\n+             const delayMs = p.loadChildren! as string === 'aux' ? auxDelay : rootDelay;\n+             return of(loadedConfig)\n+                 .pipe(\n+                     delay(delayMs),\n+                     tap(() => loaded.push(p.loadChildren! as string)),\n+                 );\n+           }\n+         };\n+\n+         const config: Routes = [\n+           // Define aux route first so it matches before the primary outlet\n+           {path: 'modal', loadChildren: 'aux', outlet: 'popup'},\n+           {path: '', loadChildren: 'root'},\n+         ];\n+\n+         applyRedirects(testModule.injector, <any>loader, serializer, tree('(popup:modal)'), config)\n+             .subscribe();\n+         tick(auxDelay);\n+         expect(loaded).toEqual(['aux']);\n+         tick(rootDelay);\n+         expect(loaded).toEqual(['aux', 'root']);\n+       }));\n   });\n \n   describe('empty paths', () => {\n@@ -754,6 +837,46 @@ describe('applyRedirects', () => {\n     });\n   });\n \n+  describe('multiple matches with empty path named outlets', () => {\n+    it('should work with redirects when other outlet comes before the one being activated', () => {\n+      applyRedirects(\n+          testModule.injector, null!, serializer, tree(''),\n+          [\n+            {\n+              path: '',\n+              children: [\n+                {path: '', component: ComponentA, outlet: 'aux'},\n+                {path: '', redirectTo: 'b', pathMatch: 'full'},\n+                {path: 'b', component: ComponentB},\n+              ],\n+            },\n+          ])\n+          .subscribe(\n+              (tree: UrlTree) => {\n+                expect(tree.toString()).toEqual('/b');\n+              },\n+              () => {\n+                fail('should not be reached');\n+              });\n+    });\n+\n+    it('should work when entry point is named outlet', () => {\n+      applyRedirects(\n+          testModule.injector, null!, serializer, tree('(popup:modal)'),\n+          [\n+            {path: '', component: ComponentA},\n+            {path: 'modal', component: ComponentB, outlet: 'popup'},\n+          ])\n+          .subscribe(\n+              (tree: UrlTree) => {\n+                expect(tree.toString()).toEqual('/(popup:modal)');\n+              },\n+              (e) => {\n+                fail('should not be reached' + e.message);\n+              });\n+    });\n+  });\n+\n   describe('redirecting to named outlets', () => {\n     it('should work when using absolute redirects', () => {\n       checkRedirect("
        }
    ],
    "stats": {
        "total": 198,
        "additions": 171,
        "deletions": 27
    }
}