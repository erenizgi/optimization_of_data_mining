{
    "author": "JoostK",
    "message": "refactor(compiler-cli): remove `ModuleWithProviders` generic type transform (#41996)\n\nThe `ModuleWithProviders` type has required a generic type since Angular 10,\nso it is no longer necessary for the compiler to transform usages of the\n`ModuleWithProviders` type without the generic type, as that should have\nbeen reported as a compile error. This commit removes the detection logic\nfrom ngtsc.\n\nPR Close #41996",
    "sha": "ce8720910d34ed30c9c854b57d9faab054e98417",
    "files": [
        {
            "sha": "03f7b7aef0ef37f72b93d381eff9febd7e028fef",
            "filename": "packages/compiler-cli/src/ngtsc/core/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/ce8720910d34ed30c9c854b57d9faab054e98417/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/ce8720910d34ed30c9c854b57d9faab054e98417/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2FBUILD.bazel?ref=ce8720910d34ed30c9c854b57d9faab054e98417",
            "patch": "@@ -23,7 +23,6 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/incremental/semantic_graph\",\n         \"//packages/compiler-cli/src/ngtsc/indexer\",\n         \"//packages/compiler-cli/src/ngtsc/metadata\",\n-        \"//packages/compiler-cli/src/ngtsc/modulewithproviders\",\n         \"//packages/compiler-cli/src/ngtsc/partial_evaluator\",\n         \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"//packages/compiler-cli/src/ngtsc/program_driver\","
        },
        {
            "sha": "f7c2c605a6e68d1c41c4960b99b4c903350c4f04",
            "filename": "packages/compiler-cli/src/ngtsc/core/src/compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 19,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/ce8720910d34ed30c9c854b57d9faab054e98417/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/ce8720910d34ed30c9c854b57d9faab054e98417/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts?ref=ce8720910d34ed30c9c854b57d9faab054e98417",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Type} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {ComponentDecoratorHandler, DirectiveDecoratorHandler, InjectableDecoratorHandler, NgModuleDecoratorHandler, NoopReferencesRegistry, PipeDecoratorHandler, ReferencesRegistry} from '../../annotations';\n@@ -19,7 +18,6 @@ import {IncrementalBuildStrategy, IncrementalCompilation, IncrementalState} from\n import {SemanticSymbol} from '../../incremental/semantic_graph';\n import {generateAnalysis, IndexedComponent, IndexingContext} from '../../indexer';\n import {ComponentResources, CompoundMetadataReader, CompoundMetadataRegistry, DirectiveMeta, DtsMetadataReader, InjectableClassRegistry, LocalMetadataRegistry, MetadataReader, PipeMeta, ResourceRegistry} from '../../metadata';\n-import {ModuleWithProvidersScanner} from '../../modulewithproviders';\n import {PartialEvaluator} from '../../partial_evaluator';\n import {ActivePerfRecorder, DelegatingPerfRecorder, PerfCheckpoint, PerfEvent, PerfPhase} from '../../perf';\n import {ProgramDriver, UpdateMode} from '../../program_driver';\n@@ -51,7 +49,6 @@ interface LazyCompilationState {\n   exportReferenceGraph: ReferenceGraph|null;\n   routeAnalyzer: NgModuleRouteAnalyzer;\n   dtsTransforms: DtsTransformRegistry;\n-  mwpScanner: ModuleWithProvidersScanner;\n   aliasingHost: AliasingHost|null;\n   refEmitter: ReferenceEmitter;\n   templateTypeChecker: TemplateTypeChecker;\n@@ -565,7 +562,6 @@ export class NgCompiler {\n         }\n \n         let analysisPromise = this.compilation.traitCompiler.analyzeAsync(sf);\n-        this.scanForMwp(sf);\n         if (analysisPromise !== undefined) {\n           promises.push(analysisPromise);\n         }\n@@ -693,7 +689,6 @@ export class NgCompiler {\n           continue;\n         }\n         this.compilation.traitCompiler.analyzeSync(sf);\n-        this.scanForMwp(sf);\n       }\n \n       this.perfRecorder.memory(PerfCheckpoint.Analysis);\n@@ -888,16 +883,6 @@ export class NgCompiler {\n     return this.nonTemplateDiagnostics;\n   }\n \n-  private scanForMwp(sf: ts.SourceFile): void {\n-    this.compilation!.mwpScanner.scan(sf, {\n-      addTypeReplacement: (node: ts.Declaration, type: Type): void => {\n-        // Only obtain the return type transform for the source file once there's a type to replace,\n-        // so that no transform is allocated when there's nothing to do.\n-        this.compilation!.dtsTransforms!.getReturnTypeTransform(sf).addTypeReplacement(node, type);\n-      }\n-    });\n-  }\n-\n   private makeCompilation(): LazyCompilationState {\n     const checker = this.inputProgram.getTypeChecker();\n \n@@ -992,8 +977,6 @@ export class NgCompiler {\n \n     const dtsTransforms = new DtsTransformRegistry();\n \n-    const mwpScanner = new ModuleWithProvidersScanner(reflector, evaluator, refEmitter);\n-\n     const isCore = isAngularCorePackage(this.inputProgram);\n \n     const resourceRegistry = new ResourceRegistry();\n@@ -1071,7 +1054,6 @@ export class NgCompiler {\n       dtsTransforms,\n       exportReferenceGraph,\n       routeAnalyzer,\n-      mwpScanner,\n       metaReader,\n       typeCheckScopeRegistry,\n       aliasingHost,\n@@ -1207,4 +1189,4 @@ function versionMapFromProgram(\n     versions.set(absoluteFromSourceFile(sf), driver.getSourceFileVersion(sf));\n   }\n   return versions;\n-}\n\\ No newline at end of file\n+}"
        },
        {
            "sha": "2dfe50b6ba7d8f6c774a038f6686a9b16fc0c4e9",
            "filename": "packages/compiler-cli/src/ngtsc/modulewithproviders/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 17,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/751cd83ae3ee5c971f2d4b72af1aaa691305a866/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/751cd83ae3ee5c971f2d4b72af1aaa691305a866/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2FBUILD.bazel?ref=751cd83ae3ee5c971f2d4b72af1aaa691305a866",
            "patch": "@@ -1,17 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-package(default_visibility = [\"//visibility:public\"])\n-\n-ts_library(\n-    name = \"modulewithproviders\",\n-    srcs = [\"index.ts\"] + glob([\n-        \"src/**/*.ts\",\n-    ]),\n-    deps = [\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli/src/ngtsc/imports\",\n-        \"//packages/compiler-cli/src/ngtsc/partial_evaluator\",\n-        \"//packages/compiler-cli/src/ngtsc/reflection\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "135e00c3b9f36e589e0d3aa0ed6bd0822d3a29d0",
            "filename": "packages/compiler-cli/src/ngtsc/modulewithproviders/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 9,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/751cd83ae3ee5c971f2d4b72af1aaa691305a866/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/751cd83ae3ee5c971f2d4b72af1aaa691305a866/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2Findex.ts?ref=751cd83ae3ee5c971f2d4b72af1aaa691305a866",
            "patch": "@@ -1,9 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-export * from './src/scanner';"
        },
        {
            "sha": "573dd20a2d4f31565766fa1731342eb896eb22a1",
            "filename": "packages/compiler-cli/src/ngtsc/modulewithproviders/src/scanner.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 166,
            "changes": 166,
            "blob_url": "https://github.com/angular/angular/blob/751cd83ae3ee5c971f2d4b72af1aaa691305a866/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2Fsrc%2Fscanner.ts",
            "raw_url": "https://github.com/angular/angular/raw/751cd83ae3ee5c971f2d4b72af1aaa691305a866/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2Fsrc%2Fscanner.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2Fsrc%2Fscanner.ts?ref=751cd83ae3ee5c971f2d4b72af1aaa691305a866",
            "patch": "@@ -1,166 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ExpressionType, ExternalExpr, R3Identifiers as Identifiers, Type} from '@angular/compiler';\n-import * as ts from 'typescript';\n-\n-import {ImportFlags, Reference, ReferenceEmitter} from '../../imports';\n-import {PartialEvaluator, ResolvedValueMap} from '../../partial_evaluator';\n-import {ReflectionHost} from '../../reflection';\n-\n-export interface DtsHandler {\n-  addTypeReplacement(node: ts.Declaration, type: Type): void;\n-}\n-\n-export class ModuleWithProvidersScanner {\n-  constructor(\n-      private host: ReflectionHost, private evaluator: PartialEvaluator,\n-      private emitter: ReferenceEmitter) {}\n-\n-  scan(sf: ts.SourceFile, dts: DtsHandler): void {\n-    for (const stmt of sf.statements) {\n-      this.visitStatement(dts, stmt);\n-    }\n-  }\n-\n-  private visitStatement(dts: DtsHandler, stmt: ts.Statement): void {\n-    // Detect whether a statement is exported, which is used as one of the hints whether to look\n-    // more closely at possible MWP functions within. This is a syntactic check, not a semantic\n-    // check, so it won't detect cases like:\n-    //\n-    // var X = ...;\n-    // export {X}\n-    //\n-    // This is intentional, because the alternative is slow and this will catch 99% of the cases we\n-    // need to handle.\n-    const isExported = stmt.modifiers !== undefined &&\n-        stmt.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword);\n-\n-    if (!isExported) {\n-      return;\n-    }\n-\n-    if (ts.isClassDeclaration(stmt)) {\n-      for (const member of stmt.members) {\n-        if (!ts.isMethodDeclaration(member) || !isStatic(member)) {\n-          continue;\n-        }\n-\n-        this.visitFunctionOrMethodDeclaration(dts, member);\n-      }\n-    } else if (ts.isFunctionDeclaration(stmt)) {\n-      this.visitFunctionOrMethodDeclaration(dts, stmt);\n-    }\n-  }\n-\n-  private visitFunctionOrMethodDeclaration(\n-      dts: DtsHandler, decl: ts.MethodDeclaration|ts.FunctionDeclaration): void {\n-    // First, some sanity. This should have a method body with a single return statement.\n-    if (decl.body === undefined || decl.body.statements.length !== 1) {\n-      return;\n-    }\n-    const retStmt = decl.body.statements[0];\n-    if (!ts.isReturnStatement(retStmt) || retStmt.expression === undefined) {\n-      return;\n-    }\n-    const retValue = retStmt.expression;\n-\n-    // Now, look at the return type of the method. Maybe bail if the type is already marked, or if\n-    // it's incompatible with a MWP function.\n-    const returnType = this.returnTypeOf(decl);\n-    if (returnType === ReturnType.OTHER || returnType === ReturnType.MWP_WITH_TYPE) {\n-      // Don't process this declaration, it either already declares the right return type, or an\n-      // incompatible one.\n-      return;\n-    }\n-\n-    const value = this.evaluator.evaluate(retValue);\n-    if (!(value instanceof Map) || !value.has('ngModule')) {\n-      // The return value does not provide sufficient information to be able to add a generic type.\n-      return;\n-    }\n-\n-    if (returnType === ReturnType.INFERRED && !isModuleWithProvidersType(value)) {\n-      // The return type is inferred but the returned object is not of the correct shape, so we\n-      // shouldn's modify the return type to become `ModuleWithProviders`.\n-      return;\n-    }\n-\n-    // The return type has been verified to represent the `ModuleWithProviders` type, but either the\n-    // return type is inferred or the generic type argument is missing. In both cases, a new return\n-    // type is created where the `ngModule` type is included as generic type argument.\n-    const ngModule = value.get('ngModule');\n-    if (!(ngModule instanceof Reference) || !ts.isClassDeclaration(ngModule.node)) {\n-      return;\n-    }\n-\n-    const ngModuleExpr =\n-        this.emitter.emit(ngModule, decl.getSourceFile(), ImportFlags.ForceNewImport);\n-    const ngModuleType = new ExpressionType(ngModuleExpr.expression);\n-    const mwpNgType = new ExpressionType(\n-        new ExternalExpr(Identifiers.ModuleWithProviders), [/* modifiers */], [ngModuleType]);\n-\n-    dts.addTypeReplacement(decl, mwpNgType);\n-  }\n-\n-  private returnTypeOf(decl: ts.FunctionDeclaration|ts.MethodDeclaration|\n-                       ts.VariableDeclaration): ReturnType {\n-    if (decl.type === undefined) {\n-      return ReturnType.INFERRED;\n-    } else if (!ts.isTypeReferenceNode(decl.type)) {\n-      return ReturnType.OTHER;\n-    }\n-\n-    // Try to figure out if the type is of a familiar form, something that looks like it was\n-    // imported.\n-    let typeId: ts.Identifier;\n-    if (ts.isIdentifier(decl.type.typeName)) {\n-      // def: ModuleWithProviders\n-      typeId = decl.type.typeName;\n-    } else if (ts.isQualifiedName(decl.type.typeName) && ts.isIdentifier(decl.type.typeName.left)) {\n-      // def: i0.ModuleWithProviders\n-      typeId = decl.type.typeName.right;\n-    } else {\n-      return ReturnType.OTHER;\n-    }\n-\n-    const importDecl = this.host.getImportOfIdentifier(typeId);\n-    if (importDecl === null || importDecl.from !== '@angular/core' ||\n-        importDecl.name !== 'ModuleWithProviders') {\n-      return ReturnType.OTHER;\n-    }\n-\n-    if (decl.type.typeArguments === undefined || decl.type.typeArguments.length === 0) {\n-      // The return type is indeed ModuleWithProviders, but no generic type parameter was found.\n-      return ReturnType.MWP_NO_TYPE;\n-    } else {\n-      // The return type is ModuleWithProviders, and the user has already specified a generic type.\n-      return ReturnType.MWP_WITH_TYPE;\n-    }\n-  }\n-}\n-\n-enum ReturnType {\n-  INFERRED,\n-  MWP_NO_TYPE,\n-  MWP_WITH_TYPE,\n-  OTHER,\n-}\n-\n-/** Whether the resolved value map represents a ModuleWithProviders object */\n-function isModuleWithProvidersType(value: ResolvedValueMap): boolean {\n-  const ngModule = value.has('ngModule');\n-  const providers = value.has('providers');\n-\n-  return ngModule && (value.size === 1 || (providers && value.size === 2));\n-}\n-\n-function isStatic(node: ts.Node): boolean {\n-  return node.modifiers !== undefined &&\n-      node.modifiers.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword);\n-}"
        },
        {
            "sha": "f0d4e36d21ae1d5dc743106b517defea351e7476",
            "filename": "packages/compiler-cli/src/ngtsc/transform/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/ce8720910d34ed30c9c854b57d9faab054e98417/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/ce8720910d34ed30c9c854b57d9faab054e98417/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2FBUILD.bazel?ref=ce8720910d34ed30c9c854b57d9faab054e98417",
            "patch": "@@ -15,7 +15,6 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/incremental:api\",\n         \"//packages/compiler-cli/src/ngtsc/incremental/semantic_graph\",\n         \"//packages/compiler-cli/src/ngtsc/indexer\",\n-        \"//packages/compiler-cli/src/ngtsc/modulewithproviders\",\n         \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n         \"//packages/compiler-cli/src/ngtsc/translator\","
        },
        {
            "sha": "fa292f7edf9bc6b7b1d6a3884b28896b5790a458",
            "filename": "packages/compiler-cli/test/ngtsc/modulewithproviders_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 298,
            "changes": 298,
            "blob_url": "https://github.com/angular/angular/blob/751cd83ae3ee5c971f2d4b72af1aaa691305a866/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fmodulewithproviders_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/751cd83ae3ee5c971f2d4b72af1aaa691305a866/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fmodulewithproviders_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fmodulewithproviders_spec.ts?ref=751cd83ae3ee5c971f2d4b72af1aaa691305a866",
            "patch": "@@ -1,298 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {runInEachFileSystem} from '../../src/ngtsc/file_system/testing';\n-import {loadStandardTestFiles} from '../../src/ngtsc/testing';\n-\n-import {NgtscTestEnvironment} from './env';\n-\n-const trim = (input: string): string => input.replace(/\\s+/g, ' ').trim();\n-\n-const testFiles = loadStandardTestFiles();\n-\n-runInEachFileSystem(() => {\n-  describe('ModuleWithProviders generic type transform', () => {\n-    let env!: NgtscTestEnvironment;\n-\n-    beforeEach(() => {\n-      env = NgtscTestEnvironment.setup(testFiles);\n-      env.tsconfig();\n-    });\n-\n-    it('should add a generic type for static methods on exported classes', () => {\n-      env.write('test.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule()\n-        export class TestModule {\n-          static forRoot() {\n-            return {\n-              ngModule: TestModule,\n-            };\n-          }\n-        }\n-      `);\n-\n-      env.driveMain();\n-\n-      const dtsContents = trim(env.getContents('test.d.ts'));\n-      expect(dtsContents).toContain('import * as i0 from \"@angular/core\";');\n-      expect(dtsContents).toContain('static forRoot(): i0.ModuleWithProviders<TestModule>;');\n-    });\n-\n-    it('should not add a generic type for non-static methods', () => {\n-      env.write('test.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule()\n-        export class TestModule {\n-          forRoot() {\n-            return {\n-              ngModule: TestModule,\n-            };\n-          }\n-        }\n-      `);\n-\n-      env.driveMain();\n-\n-      const dtsContents = trim(env.getContents('test.d.ts'));\n-      expect(dtsContents).toContain('import * as i0 from \"@angular/core\";');\n-      expect(dtsContents).toContain('forRoot(): { ngModule: typeof TestModule; };');\n-      expect(dtsContents).not.toContain('static forRoot()');\n-    });\n-\n-    it('should add a generic type for exported functions', () => {\n-      env.write('test.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        export function forRoot() {\n-          return {\n-            ngModule: TestModule,\n-          };\n-        }\n-\n-        @NgModule()\n-        export class TestModule {}\n-      `);\n-\n-      env.driveMain();\n-\n-      const dtsContents = trim(env.getContents('test.d.ts'));\n-      expect(dtsContents).toContain('import * as i0 from \"@angular/core\";');\n-      expect(dtsContents)\n-          .toContain('export declare function forRoot(): i0.ModuleWithProviders<TestModule>;');\n-    });\n-\n-    it('should not add a generic type when already present', () => {\n-      env.write('test.ts', `\n-        import {NgModule, ModuleWithProviders} from '@angular/core';\n-\n-        export class TestModule {\n-          forRoot(): ModuleWithProviders<InternalTestModule> {\n-            return {\n-              ngModule: TestModule,\n-            };\n-          }\n-        }\n-\n-        @NgModule()\n-        export class InternalTestModule {}\n-      `);\n-\n-      env.driveMain();\n-\n-      const dtsContents = trim(env.getContents('test.d.ts'));\n-      expect(dtsContents).toContain('forRoot(): ModuleWithProviders<InternalTestModule>;');\n-    });\n-\n-    it('should add a generic type when missing the generic type parameter', () => {\n-      env.write('test.ts', `\n-        import {NgModule, ModuleWithProviders} from '@angular/core';\n-\n-        @NgModule()\n-        export class TestModule {\n-          static forRoot(): ModuleWithProviders {\n-            return {\n-              ngModule: TestModule,\n-            };\n-          }\n-        }\n-      `);\n-\n-      env.driveMain();\n-\n-      const dtsContents = trim(env.getContents('test.d.ts'));\n-      expect(dtsContents).toContain('static forRoot(): i0.ModuleWithProviders<TestModule>;');\n-    });\n-\n-    it('should add a generic type when missing the generic type parameter (qualified name)', () => {\n-      env.write('test.ts', `\n-        import * as ng from '@angular/core';\n-\n-        @ng.NgModule()\n-        export class TestModule {\n-          static forRoot(): ng.ModuleWithProviders {\n-            return {\n-              ngModule: TestModule,\n-            };\n-          }\n-        }\n-      `);\n-\n-      env.driveMain();\n-\n-      const dtsContents = trim(env.getContents('test.d.ts'));\n-      expect(dtsContents).toContain('static forRoot(): i0.ModuleWithProviders<TestModule>;');\n-    });\n-\n-    it('should add a generic type and add an import for external references', () => {\n-      env.write('test.ts', `\n-        import {ModuleWithProviders} from '@angular/core';\n-        import {InternalTestModule} from './internal';\n-\n-        export class TestModule {\n-          static forRoot(): ModuleWithProviders {\n-            return {\n-              ngModule: InternalTestModule,\n-            };\n-          }\n-        }\n-      `);\n-      env.write('internal.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule()\n-        export class InternalTestModule {}\n-      `);\n-\n-      env.driveMain();\n-\n-      const dtsContents = trim(env.getContents('test.d.ts'));\n-      expect(dtsContents).toContain('import * as i1 from \"./internal\";');\n-      expect(dtsContents)\n-          .toContain('static forRoot(): i0.ModuleWithProviders<i1.InternalTestModule>;');\n-    });\n-\n-    it('should not add a generic type if the return type is not ModuleWithProviders', () => {\n-      env.write('test.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule()\n-        export class TestModule {\n-          static forRoot(): { ngModule: typeof TestModule } {\n-            return {\n-              ngModule: TestModule,\n-            };\n-          }\n-        }\n-      `);\n-\n-      env.driveMain();\n-\n-      const dtsContents = trim(env.getContents('test.d.ts'));\n-      expect(dtsContents).toContain('static forRoot(): { ngModule: typeof TestModule; };');\n-    });\n-\n-    it('should not add a generic type if the return type is not ModuleWithProviders from @angular/core',\n-       () => {\n-         env.write('test.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {ModuleWithProviders} from './mwp';\n-\n-        @NgModule()\n-        export class TestModule {\n-          static forRoot(): ModuleWithProviders {\n-            return {\n-              ngModule: TestModule,\n-            };\n-          }\n-        }\n-      `);\n-         env.write('mwp.ts', `\n-      export type ModuleWithProviders = { ngModule: any };\n-      `);\n-\n-         env.driveMain();\n-\n-         const dtsContents = trim(env.getContents('test.d.ts'));\n-         expect(dtsContents).toContain('static forRoot(): ModuleWithProviders;');\n-       });\n-\n-    it('should not add a generic type when the \"ngModule\" property is not a reference', () => {\n-      env.write('test.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule()\n-        export class TestModule {\n-          static forRoot() {\n-            return {\n-              ngModule: 'test',\n-            };\n-          }\n-        }\n-      `);\n-\n-      env.driveMain();\n-\n-      const dtsContents = trim(env.getContents('test.d.ts'));\n-      expect(dtsContents).toContain('static forRoot(): { ngModule: string; };');\n-    });\n-\n-    it('should not add a generic type when the class is not exported', () => {\n-      env.write('test.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule()\n-        class TestModule {\n-          static forRoot() {\n-            return {\n-              ngModule: TestModule,\n-            };\n-          }\n-        }\n-      `);\n-\n-      env.driveMain();\n-\n-      // The TestModule class is not exported so doesn't even show up in the declaration file\n-      const dtsContents = trim(env.getContents('test.d.ts'));\n-      expect(dtsContents).not.toContain('static forRoot()');\n-    });\n-\n-    it('should add a generic type only when ngModule/providers are present', () => {\n-      env.write('test.ts', `\n-        import {NgModule, ModuleWithProviders} from '@angular/core';\n-\n-        @NgModule()\n-        export class TestModule {\n-          static hasNgModuleAndProviders() {\n-            return {\n-              ngModule: TestModule,\n-              providers: [],\n-            };\n-          }\n-          static hasNgModuleAndFoo() {\n-            return {\n-              ngModule: TestModule,\n-              foo: 'test',\n-            };\n-          }\n-        }\n-      `);\n-\n-      env.driveMain();\n-\n-      const dtsContents = trim(env.getContents('test.d.ts'));\n-      expect(dtsContents)\n-          .toContain('static hasNgModuleAndProviders(): i0.ModuleWithProviders<TestModule>;');\n-      expect(dtsContents)\n-          .toContain('static hasNgModuleAndFoo(): { ngModule: typeof TestModule; foo: string; };');\n-    });\n-  });\n-});"
        }
    ],
    "stats": {
        "total": 512,
        "additions": 1,
        "deletions": 511
    }
}