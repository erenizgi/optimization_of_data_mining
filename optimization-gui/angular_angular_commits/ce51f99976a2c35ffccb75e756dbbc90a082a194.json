{
    "author": "gkalpak",
    "message": "refactor(docs-infra): move `deploy-to-firebase` util functions to a separate file (#43963)\n\nMove some util functions from `deploy-to-firebase/index.mjs` to a\nseparate file (`deploy-to-firebase/utils.mjs`) to keep `index.mjs` small\nand easier to maintain.\n\nNOTE:\nTo make it easier to mock functions in tests, `utils.mjs` uses a default\nexport (instead of multiple named exports) and references local\nfunctions through the default exported object.\n\nPR Close #43963",
    "sha": "ce51f99976a2c35ffccb75e756dbbc90a082a194",
    "files": [
        {
            "sha": "13a105aee6409d1d423ae54118442548b637072d",
            "filename": "aio/scripts/deploy-to-firebase/index.mjs",
            "status": "modified",
            "additions": 24,
            "deletions": 93,
            "changes": 117,
            "blob_url": "https://github.com/angular/angular/blob/ce51f99976a2c35ffccb75e756dbbc90a082a194/aio%2Fscripts%2Fdeploy-to-firebase%2Findex.mjs",
            "raw_url": "https://github.com/angular/angular/raw/ce51f99976a2c35ffccb75e756dbbc90a082a194/aio%2Fscripts%2Fdeploy-to-firebase%2Findex.mjs",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fscripts%2Fdeploy-to-firebase%2Findex.mjs?ref=ce51f99976a2c35ffccb75e756dbbc90a082a194",
            "patch": "@@ -3,26 +3,20 @@\n // WARNING: `CI_SECRET_AIO_DEPLOY_FIREBASE_TOKEN` should NOT be printed.\n //\n \n-import {dirname} from 'path';\n import sh from 'shelljs';\n import {fileURLToPath} from 'url';\n+import u from './utils.mjs';\n \n sh.set('-e');\n \n \n // Constants\n-const REPO_SLUG = 'angular/angular';\n-const NG_REMOTE_URL = `https://github.com/${REPO_SLUG}.git`;\n-const GIT_REMOTE_REFS_CACHE = new Map();\n+const DIRNAME = u.getDirname(import.meta.url);\n \n // Exports\n export {\n   computeDeploymentsInfo,\n   computeInputVars,\n-  computeMajorVersion,\n-  getDirname,\n-  getLatestCommit,\n-  getMostRecentMinorBranch,\n   skipDeployment,\n   validateDeploymentsInfo,\n };\n@@ -69,26 +63,26 @@ if (fileURLToPath(import.meta.url) === process.argv[1]) {\n \n // Helpers\n function build({deployedUrl, deployEnv}) {\n-  logSectionHeader('Build the AIO app.');\n-  yarn(`build --configuration=${deployEnv} --progress=false`);\n+  u.logSectionHeader('Build the AIO app.');\n+  u.yarn(`build --configuration=${deployEnv} --progress=false`);\n \n-  logSectionHeader('Add any mode-specific files into the AIO distribution.');\n+  u.logSectionHeader('Add any mode-specific files into the AIO distribution.');\n   sh.cp('-rf', `src/extra-files/${deployEnv}/.`, 'dist/');\n \n-  logSectionHeader('Update opensearch descriptor for AIO with `deployedUrl`.');\n-  yarn(`set-opensearch-url ${deployedUrl.replace(/[^/]$/, '$&/')}`);  // The URL must end with `/`.\n+  u.logSectionHeader('Update opensearch descriptor for AIO with `deployedUrl`.');\n+  u.yarn(`set-opensearch-url ${deployedUrl.replace(/[^/]$/, '$&/')}`); // The URL must end with `/`.\n }\n \n function checkPayloadSize() {\n-  logSectionHeader('Check payload size and upload the numbers to Firebase DB.');\n-  yarn('payload-size');\n+  u.logSectionHeader('Check payload size and upload the numbers to Firebase DB.');\n+  u.yarn('payload-size');\n }\n \n function computeDeploymentsInfo(\n     {currentBranch, currentCommit, isPullRequest, repoName, repoOwner, stableBranch}) {\n   // Do not deploy if we are running in a fork.\n-  if (`${repoOwner}/${repoName}` !== REPO_SLUG) {\n-    return [skipDeployment(`Skipping deploy because this is not ${REPO_SLUG}.`)];\n+  if (`${repoOwner}/${repoName}` !== u.REPO_SLUG) {\n+    return [skipDeployment(`Skipping deploy because this is not ${u.REPO_SLUG}.`)];\n   }\n \n   // Do not deploy if this is a PR. PRs are deployed in the `aio_preview` CircleCI job.\n@@ -97,7 +91,7 @@ function computeDeploymentsInfo(\n   }\n \n   // Do not deploy if the current commit is not the latest on its branch.\n-  const latestCommit = getLatestCommit(currentBranch);\n+  const latestCommit = u.getLatestCommit(currentBranch);\n   if (currentCommit !== latestCommit) {\n     return [\n       skipDeployment(\n@@ -106,7 +100,7 @@ function computeDeploymentsInfo(\n   }\n \n   // The deployment mode is computed based on the branch we are building.\n-  const currentBranchMajorVersion = computeMajorVersion(currentBranch);\n+  const currentBranchMajorVersion = u.computeMajorVersion(currentBranch);\n   const deploymentInfoPerTarget = {\n     // PRIMARY DEPLOY TARGETS\n     //\n@@ -183,7 +177,7 @@ function computeDeploymentsInfo(\n \n   // Determine if there is an active RC version by checking whether the most recent minor branch is\n   // the stable branch or not.\n-  const mostRecentMinorBranch = getMostRecentMinorBranch();\n+  const mostRecentMinorBranch = u.getMostRecentMinorBranch();\n   const rcBranch = (mostRecentMinorBranch !== stableBranch) ? mostRecentMinorBranch : null;\n \n   // If the current branch is the RC branch, deploy as `rc`.\n@@ -214,7 +208,7 @@ function computeDeploymentsInfo(\n   //   2. The current branch must have a major version that is lower than the stable major version.\n \n   // Do not deploy if it is not the branch with the highest minor for the given major version.\n-  const mostRecentMinorBranchForMajor = getMostRecentMinorBranch(currentBranchMajorVersion);\n+  const mostRecentMinorBranchForMajor = u.getMostRecentMinorBranch(currentBranchMajorVersion);\n   if (currentBranch !== mostRecentMinorBranchForMajor) {\n     return [\n       skipDeployment(\n@@ -225,7 +219,7 @@ function computeDeploymentsInfo(\n   }\n \n   // Do not deploy if it does not have a lower major version than stable.\n-  const stableBranchMajorVersion = computeMajorVersion(stableBranch);\n+  const stableBranchMajorVersion = u.computeMajorVersion(stableBranch);\n   if (currentBranchMajorVersion >= stableBranchMajorVersion) {\n     return [\n       skipDeployment(\n@@ -262,10 +256,6 @@ function computeInputVars({\n   };\n }\n \n-function computeMajorVersion(branchName) {\n-  return +branchName.split('.', 1)[0];\n-}\n-\n function deploy(data) {\n   const {\n     currentCommit,\n@@ -276,75 +266,26 @@ function deploy(data) {\n     siteId,\n   } = data;\n \n-  sh.cd(`${getDirname(import.meta.url)}/../..`);\n+  sh.cd(`${DIRNAME}/../..`);\n \n-  logSectionHeader('Run pre-deploy actions.');\n+  u.logSectionHeader('Run pre-deploy actions.');\n   preDeployActions.forEach(fn => fn(data));\n \n-  logSectionHeader('Deploy AIO to Firebase hosting.');\n-  const firebase = cmd => yarn(`firebase ${cmd} --token \"${firebaseToken}\"`);\n+  u.logSectionHeader('Deploy AIO to Firebase hosting.');\n+  const firebase = cmd => u.yarn(`firebase ${cmd} --token \"${firebaseToken}\"`);\n   firebase(`use \"${projectId}\"`);\n   firebase('target:clear hosting aio');\n   firebase(`target:apply hosting aio \"${siteId}\"`);\n   firebase(`deploy --only hosting:aio --message \"Commit: ${currentCommit}\" --non-interactive`);\n \n-  logSectionHeader('Run post-deploy actions.');\n+  u.logSectionHeader('Run post-deploy actions.');\n   postDeployActions.forEach(fn => fn(data));\n }\n \n-function getDirname(fileUrl) {\n-  return dirname(fileURLToPath(fileUrl));\n-}\n-\n-function getRemoteRefs(refOrPattern, {remote = NG_REMOTE_URL, retrieveFromCache = true} = {}) {\n-  // If remote refs for the same `refOrPattern` and `remote` have been requested before, return the\n-  // cached results. This improves the performance and ensures a more stable behavior.\n-  //\n-  // NOTE:\n-  // This shouldn't make any difference during normal execution (since there are no duplicate\n-  // requests atm), but makes the tests more stable (for example, avoiding errors caused by pushing\n-  // a new commit on a branch while the tests execute, which would cause `getLatestCommit()` to\n-  // return a different value).\n-  const cmd = `git ls-remote ${remote} ${refOrPattern}`;\n-  const result = (retrieveFromCache && GIT_REMOTE_REFS_CACHE.has(cmd)) ?\n-    GIT_REMOTE_REFS_CACHE.get(cmd) :\n-    sh.exec(cmd, {silent: true}).trim().split('\\n');\n-\n-  // Cache the result for future use (regardless of the value of `retrieveFromCache`).\n-  GIT_REMOTE_REFS_CACHE.set(cmd, result);\n-\n-  return result;\n-}\n-\n-function getMostRecentMinorBranch(major = '*', options = undefined) {\n-  // List the branches that start with the given major version (or any major if none given).\n-  return getRemoteRefs(`refs/heads/${major}.*.x`, options)\n-      // Extract the branch name.\n-      .map(line => line.split('/')[2])\n-      // Filter out branches that are not of the format `<number>.<number>.x`.\n-      .filter(name => /^\\d+\\.\\d+\\.x$/.test(name))\n-      // Sort by version.\n-      .sort((a, b) => {\n-        const [majorA, minorA] = a.split('.');\n-        const [majorB, minorB] = b.split('.');\n-        return (majorA - majorB) || (minorA - minorB);\n-      })\n-      // Get the branch corresponding to the highest version.\n-      .pop();\n-}\n-\n-function getLatestCommit(branchName, options = undefined) {\n-  return getRemoteRefs(branchName, options)[0].slice(0, 40);\n-}\n-\n function listDeployTargetNames(deploymentsList) {\n   return deploymentsList.map(({name = '<no name>'}) => name).join(', ') || '-';\n }\n \n-function logSectionHeader(message) {\n-  console.log(`\\n\\n\\n==== ${message} ====\\n`);\n-}\n-\n function redirectToAngularIo() {\n   // Update the Firebase hosting configuration redirect all non-file requests (i.e. requests that do\n   // not contain a dot in their last path segment) to `angular.io`.\n@@ -369,7 +310,7 @@ function skipDeployment(reason) {\n }\n \n function testNoActiveRcDeployment({deployedUrl}) {\n-  logSectionHeader(\n+  u.logSectionHeader(\n       'Verify deployed RC version redirects to stable (and disables old ServiceWorker).');\n \n   const deployedOrigin = deployedUrl.replace(/\\/$/, '');\n@@ -410,8 +351,8 @@ function testNoActiveRcDeployment({deployedUrl}) {\n }\n \n function testPwaScore({deployedUrl, minPwaScore}) {\n-  logSectionHeader('Run PWA-score tests.');\n-  yarn(`test-pwa-score \"${deployedUrl}\" \"${minPwaScore}\"`);\n+  u.logSectionHeader('Run PWA-score tests.');\n+  u.yarn(`test-pwa-score \"${deployedUrl}\" \"${minPwaScore}\"`);\n }\n \n function validateDeploymentsInfo(deploymentsList) {\n@@ -490,13 +431,3 @@ function validateDeploymentsInfo(deploymentsList) {\n         nonMatchingSecondaryTargets.map(t => `${t.name} (deployEnv: ${t.deployEnv})`).join(', '));\n   }\n }\n-\n-function yarn(cmd) {\n-  // Using `--silent` to ensure no secret env variables are printed.\n-  //\n-  // NOTE:\n-  // This is not strictly necessary, since CircleCI will mask secret environment variables in the\n-  // output (see https://circleci.com/docs/2.0/env-vars/#secrets-masking), but is an extra\n-  // precaution.\n-  return sh.exec(`yarn --silent ${cmd}`);\n-}"
        },
        {
            "sha": "69bc9a99083063247e269bcf679be301155bdb6e",
            "filename": "aio/scripts/deploy-to-firebase/index.spec.mjs",
            "status": "modified",
            "additions": 12,
            "deletions": 15,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/ce51f99976a2c35ffccb75e756dbbc90a082a194/aio%2Fscripts%2Fdeploy-to-firebase%2Findex.spec.mjs",
            "raw_url": "https://github.com/angular/angular/raw/ce51f99976a2c35ffccb75e756dbbc90a082a194/aio%2Fscripts%2Fdeploy-to-firebase%2Findex.spec.mjs",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fscripts%2Fdeploy-to-firebase%2Findex.spec.mjs?ref=ce51f99976a2c35ffccb75e756dbbc90a082a194",
            "patch": "@@ -2,26 +2,23 @@ import {execSync} from 'child_process';\n import {\n   computeDeploymentsInfo,\n   computeInputVars,\n-  computeMajorVersion,\n-  getDirname,\n-  getLatestCommit,\n-  getMostRecentMinorBranch,\n   skipDeployment,\n   validateDeploymentsInfo,\n } from './index.mjs';\n+import u from './utils.mjs';\n \n \n describe('deploy-to-firebase:', () => {\n   // Pre-computed values to avoid unnecessary re-computations.\n-  const mostRecentMinorBranch = getMostRecentMinorBranch();\n+  const mostRecentMinorBranch = u.getMostRecentMinorBranch();\n   const latestCommits = {\n-    master: getLatestCommit('master'),\n-    '2.1.x': getLatestCommit('2.1.x'),\n-    '2.4.x': getLatestCommit('2.4.x'),\n-    '4.3.x': getLatestCommit('4.3.x'),\n-    '4.4.x': getLatestCommit('4.4.x'),\n-    '9.1.x': getLatestCommit('9.1.x'),\n-    [mostRecentMinorBranch]: getLatestCommit(mostRecentMinorBranch),\n+    master: u.getLatestCommit('master'),\n+    '2.1.x': u.getLatestCommit('2.1.x'),\n+    '2.4.x': u.getLatestCommit('2.4.x'),\n+    '4.3.x': u.getLatestCommit('4.3.x'),\n+    '4.4.x': u.getLatestCommit('4.4.x'),\n+    '9.1.x': u.getLatestCommit('9.1.x'),\n+    [mostRecentMinorBranch]: u.getLatestCommit(mostRecentMinorBranch),\n   };\n \n   // Helpers\n@@ -148,7 +145,7 @@ describe('deploy-to-firebase:', () => {\n         type: 'primary',\n         deployEnv: 'stable',\n         projectId: 'angular-io',\n-        siteId: `v${computeMajorVersion(mostRecentMinorBranch)}-angular-io-site`,\n+        siteId: `v${u.computeMajorVersion(mostRecentMinorBranch)}-angular-io-site`,\n         deployedUrl: 'https://angular.io/',\n         preDeployActions: ['function:build', 'function:checkPayloadSize'],\n         postDeployActions: ['function:testPwaScore'],\n@@ -421,8 +418,8 @@ describe('deploy-to-firebase:', () => {\n     // This test executes a new instance of the `deploy-to-firebase` script on a separate process\n     // and thus does not share the `getRemoteRefs()` cache. To improve stability, we retrieve the\n     // latest commit from master ignoring any cached entries.\n-    const latestCommitOnMaster = getLatestCommit('master', {retrieveFromCache: false});\n-    const scriptPath = `${getDirname(import.meta.url)}/index.mjs`;\n+    const latestCommitOnMaster = u.getLatestCommit('master', {retrieveFromCache: false});\n+    const scriptPath = `${u.getDirname(import.meta.url)}/index.mjs`;\n     const cmd = `\"${process.execPath}\" \"${scriptPath}\" --dry-run`;\n     const env = {\n       CI_REPO_OWNER: 'angular',"
        },
        {
            "sha": "655fa222850ea646eec9b41b0899aee69a7129ab",
            "filename": "aio/scripts/deploy-to-firebase/utils.mjs",
            "status": "added",
            "additions": 90,
            "deletions": 0,
            "changes": 90,
            "blob_url": "https://github.com/angular/angular/blob/ce51f99976a2c35ffccb75e756dbbc90a082a194/aio%2Fscripts%2Fdeploy-to-firebase%2Futils.mjs",
            "raw_url": "https://github.com/angular/angular/raw/ce51f99976a2c35ffccb75e756dbbc90a082a194/aio%2Fscripts%2Fdeploy-to-firebase%2Futils.mjs",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fscripts%2Fdeploy-to-firebase%2Futils.mjs?ref=ce51f99976a2c35ffccb75e756dbbc90a082a194",
            "patch": "@@ -0,0 +1,90 @@\n+import {dirname} from 'path';\n+import sh from 'shelljs';\n+import {fileURLToPath} from 'url';\n+\n+\n+// Constants\n+const REPO_SLUG = 'angular/angular';\n+const NG_REMOTE_URL = `https://github.com/${REPO_SLUG}.git`;\n+const _GIT_REMOTE_REFS_CACHE = new Map();\n+\n+// Exports\n+const exp = {\n+  _GIT_REMOTE_REFS_CACHE,\n+  NG_REMOTE_URL,\n+  REPO_SLUG,\n+\n+  computeMajorVersion,\n+  getDirname,\n+  getLatestCommit,\n+  getMostRecentMinorBranch,\n+  getRemoteRefs,\n+  logSectionHeader,\n+  yarn,\n+};\n+export default exp;\n+\n+// Helpers\n+function computeMajorVersion(branchName) {\n+  return +branchName.split('.', 1)[0];\n+}\n+\n+function getDirname(fileUrl) {\n+  return dirname(fileURLToPath(fileUrl));\n+}\n+\n+function getRemoteRefs(\n+    refOrPattern, {remote = exp.NG_REMOTE_URL, retrieveFromCache = true} = {}) {\n+  // If remote refs for the same `refOrPattern` and `remote` have been requested before, return the\n+  // cached results. This improves the performance and ensures a more stable behavior.\n+  //\n+  // NOTE:\n+  // This shouldn't make any difference during normal execution (since there are no duplicate\n+  // requests atm), but makes the tests more stable (for example, avoiding errors caused by pushing\n+  // a new commit on a branch while the tests execute, which would cause `getLatestCommit()` to\n+  // return a different value).\n+  const cmd = `git ls-remote ${remote} ${refOrPattern}`;\n+  const result = (retrieveFromCache && exp._GIT_REMOTE_REFS_CACHE.has(cmd)) ?\n+    exp._GIT_REMOTE_REFS_CACHE.get(cmd) :\n+    sh.exec(cmd, {silent: true}).trim().split('\\n');\n+\n+  // Cache the result for future use (regardless of the value of `retrieveFromCache`).\n+  exp._GIT_REMOTE_REFS_CACHE.set(cmd, result);\n+\n+  return result;\n+}\n+\n+function getMostRecentMinorBranch(major = '*', options = undefined) {\n+  // List the branches that start with the given major version (or any major if none given).\n+  return exp.getRemoteRefs(`refs/heads/${major}.*.x`, options)\n+      // Extract the branch name.\n+      .map(line => line.split('/')[2])\n+      // Filter out branches that are not of the format `<number>.<number>.x`.\n+      .filter(name => /^\\d+\\.\\d+\\.x$/.test(name))\n+      // Sort by version.\n+      .sort((a, b) => {\n+        const [majorA, minorA] = a.split('.');\n+        const [majorB, minorB] = b.split('.');\n+        return (majorA - majorB) || (minorA - minorB);\n+      })\n+      // Get the branch corresponding to the highest version.\n+      .pop();\n+}\n+\n+function getLatestCommit(branchName, options = undefined) {\n+  return exp.getRemoteRefs(branchName, options)[0].slice(0, 40);\n+}\n+\n+function logSectionHeader(message) {\n+  console.log(`\\n\\n\\n==== ${message} ====\\n`);\n+}\n+\n+function yarn(cmd) {\n+  // Using `--silent` to ensure no secret env variables are printed.\n+  //\n+  // NOTE:\n+  // This is not strictly necessary, since CircleCI will mask secret environment variables in the\n+  // output (see https://circleci.com/docs/2.0/env-vars/#secrets-masking), but is an extra\n+  // precaution.\n+  return sh.exec(`yarn --silent ${cmd}`);\n+}"
        },
        {
            "sha": "2275c6d44fe96b3b3885d2bb7d199000de16afab",
            "filename": "aio/scripts/deploy-to-firebase/utils.spec.mjs",
            "status": "added",
            "additions": 255,
            "deletions": 0,
            "changes": 255,
            "blob_url": "https://github.com/angular/angular/blob/ce51f99976a2c35ffccb75e756dbbc90a082a194/aio%2Fscripts%2Fdeploy-to-firebase%2Futils.spec.mjs",
            "raw_url": "https://github.com/angular/angular/raw/ce51f99976a2c35ffccb75e756dbbc90a082a194/aio%2Fscripts%2Fdeploy-to-firebase%2Futils.spec.mjs",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fscripts%2Fdeploy-to-firebase%2Futils.spec.mjs?ref=ce51f99976a2c35ffccb75e756dbbc90a082a194",
            "patch": "@@ -0,0 +1,255 @@\n+import sh from 'shelljs';\n+import u from './utils.mjs';\n+\n+\n+describe('deploy-to-firebase/utils:', () => {\n+  beforeEach(() => {\n+    // Clear the `getRemoteRefs()` cache before each test to prevent previous executions from\n+    // affecting subsequent tests.\n+    u._GIT_REMOTE_REFS_CACHE.clear();\n+  });\n+\n+  describe('computeMajorVersion()', () => {\n+    it('should extract the major version from a branch name', () => {\n+      expect(u.computeMajorVersion('1.2.3')).toBe(1);\n+      expect(u.computeMajorVersion('4.5.6-rc.7')).toBe(4);\n+      expect(u.computeMajorVersion('89.0')).toBe(89);\n+    });\n+  });\n+\n+  describe('getDirname()', () => {\n+    it('should return the directory path given a file URL', () => {\n+      expect(u.getDirname(import.meta.url)).toMatch(/aio[\\\\/]scripts[\\\\/]deploy-to-firebase$/);\n+      expect(u.getDirname('file:///C:/foo/bar/baz.ext'))\n+          .toBe((process.platform === 'win32') ? 'C:\\\\foo\\\\bar' : '/C:/foo/bar');\n+    });\n+  });\n+\n+  describe('getLatestCommit()', () => {\n+    let getRemoteRefsSpy;\n+\n+    beforeEach(() => {\n+      getRemoteRefsSpy = spyOn(u, 'getRemoteRefs').and.returnValue([\n+        '1aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa40        refs/heads/3.0.x',\n+      ]);\n+    });\n+\n+    it('should return the latest commit of a branch', () => {\n+      expect(u.getLatestCommit('3.0.x')).toBe('1aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa40');\n+      expect(getRemoteRefsSpy).toHaveBeenCalledWith('3.0.x', undefined);\n+    });\n+\n+    it('should pass any options to `getRemoteRefs()`', () => {\n+      const opts = {custom: true};\n+      expect(u.getLatestCommit('3.0.x', opts)).toBe('1aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa40');\n+      expect(getRemoteRefsSpy).toHaveBeenCalledWith('3.0.x', opts);\n+    });\n+  });\n+\n+  describe('getMostRecentMinorBranch()', () => {\n+    let getRemoteRefsSpy;\n+\n+    beforeEach(() => {\n+      const mockRefs3 = [\n+        '1aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa40        refs/heads/3.1.x',\n+        '1ccccccccccccccccccccccccccccccccccccc40        refs/heads/3.3.x',\n+        '1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb40        refs/heads/3.2.x',\n+      ];\n+      const mockRefs4 = [\n+        '1ddddddddddddddddddddddddddddddddddddd40        refs/heads/4.5.x',\n+        '1eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee40        refs/heads/4.6.x',\n+      ];\n+      const mockRefsAll = [\n+        ...mockRefs3,\n+        ...mockRefs4,\n+        '1fffffffffffffffffffffffffffffffffffff40        refs/heads/5.0.x',\n+      ];\n+\n+      getRemoteRefsSpy = spyOn(u, 'getRemoteRefs')\n+          .withArgs('refs/heads/3.*.x', undefined).and.returnValue(mockRefs3)\n+          .withArgs('refs/heads/3.*.x', jasmine.anything()).and.returnValue(mockRefs3)\n+          .withArgs('refs/heads/4.*.x', undefined).and.returnValue(mockRefs4)\n+          .withArgs('refs/heads/4.*.x', jasmine.anything()).and.returnValue(mockRefs4)\n+          .withArgs('refs/heads/*.*.x', undefined).and.returnValue(mockRefsAll)\n+          .withArgs('refs/heads/*.*.x', jasmine.anything()).and.returnValue(mockRefsAll);\n+    });\n+\n+    it('should get all minor branches for the specified major version', () => {\n+      u.getMostRecentMinorBranch('3');\n+      expect(getRemoteRefsSpy).toHaveBeenCalledWith('refs/heads/3.*.x', undefined);\n+\n+      u.getMostRecentMinorBranch('4');\n+      expect(getRemoteRefsSpy).toHaveBeenCalledWith('refs/heads/4.*.x', undefined);\n+    });\n+\n+    it('should get all minor branches when no major version is specified', () => {\n+      u.getMostRecentMinorBranch();\n+      expect(getRemoteRefsSpy).toHaveBeenCalledWith('refs/heads/*.*.x', undefined);\n+\n+      u.getMostRecentMinorBranch(undefined);\n+      expect(getRemoteRefsSpy).toHaveBeenCalledWith('refs/heads/*.*.x', undefined);\n+    });\n+\n+    it('should pass any options to `getRemoteRefs()`', () => {\n+      u.getMostRecentMinorBranch();\n+      expect(getRemoteRefsSpy).toHaveBeenCalledWith('refs/heads/*.*.x', undefined);\n+\n+      u.getMostRecentMinorBranch('3');\n+      expect(getRemoteRefsSpy).toHaveBeenCalledWith('refs/heads/3.*.x', undefined);\n+\n+      u.getMostRecentMinorBranch(undefined, {custom: 1});\n+      expect(getRemoteRefsSpy).toHaveBeenCalledWith('refs/heads/*.*.x', {custom: 1});\n+\n+      u.getMostRecentMinorBranch('4', {custom: 2});\n+      expect(getRemoteRefsSpy).toHaveBeenCalledWith('refs/heads/4.*.x', {custom: 2});\n+    });\n+\n+    it('should return the most recent branch', () => {\n+      expect(u.getMostRecentMinorBranch('3')).toBe('3.3.x');\n+      expect(u.getMostRecentMinorBranch('4')).toBe('4.6.x');\n+      expect(u.getMostRecentMinorBranch()).toBe('5.0.x');\n+    });\n+\n+    it('should ignore branches that do not match the expected pattern', () => {\n+      getRemoteRefsSpy.withArgs('refs/heads/*.*.x', undefined).and.returnValue([\n+        '1aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa40        refs/heads/6.0.x',\n+        '1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb40        refs/heads/6.1.x',\n+        '1ccccccccccccccccccccccccccccccccccccc40        refs/heads/6.2.z',\n+        '1ddddddddddddddddddddddddddddddddddddd40        refs/heads/7.3.x-rc.0',\n+      ]);\n+\n+      expect(u.getMostRecentMinorBranch()).toBe('6.1.x');\n+    });\n+  });\n+\n+  describe('getRemoteRefs()', () => {\n+    let execSpy;\n+\n+    beforeEach(() => {\n+      execSpy = spyOn(sh, 'exec').and.callFake(() => ([\n+        '     ',\n+        '1aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa40        refs/heads/3.1.x',\n+        '1ccccccccccccccccccccccccccccccccccccc40        refs/heads/3.3.x',\n+        '1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb40        refs/heads/3.2.x',\n+        '1ddddddddddddddddddddddddddddddddddddd40        refs/heads/4.5.x',\n+        '1eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee40        refs/heads/4.6.x',\n+        '1fffffffffffffffffffffffffffffffffffff40        refs/heads/5.0.x',\n+        '     ',\n+      ].join('\\n')));\n+    });\n+\n+    it('should retrieve the remote refs based on the speficied pattern/remote', () => {\n+      u.getRemoteRefs('some-pattern', {remote: 'https://example.com/repo.git'});\n+      expect(execSpy).toHaveBeenCalledWith(\n+          'git ls-remote https://example.com/repo.git some-pattern', jasmine.anything());\n+    });\n+\n+    it('should use the `angular/angular` repo if not remote is specified', () => {\n+      u.getRemoteRefs('some-pattern');\n+      expect(execSpy).toHaveBeenCalledWith(\n+          `git ls-remote ${u.NG_REMOTE_URL} some-pattern`, jasmine.anything());\n+\n+      u.getRemoteRefs('other-pattern', {other: 'option'});\n+      expect(execSpy).toHaveBeenCalledWith(\n+          `git ls-remote ${u.NG_REMOTE_URL} other-pattern`, jasmine.anything());\n+    });\n+\n+    it('should run the git command in silent mode', () => {\n+      u.getRemoteRefs('some-pattern');\n+      expect(execSpy).toHaveBeenCalledWith(jasmine.any(String), {silent: true});\n+    });\n+\n+    it('should return a list of refs', () => {\n+      expect(u.getRemoteRefs('some-pattern')).toEqual([\n+        '1aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa40        refs/heads/3.1.x',\n+        '1ccccccccccccccccccccccccccccccccccccc40        refs/heads/3.3.x',\n+        '1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb40        refs/heads/3.2.x',\n+        '1ddddddddddddddddddddddddddddddddddddd40        refs/heads/4.5.x',\n+        '1eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee40        refs/heads/4.6.x',\n+        '1fffffffffffffffffffffffffffffffffffff40        refs/heads/5.0.x',\n+      ]);\n+    });\n+\n+    it('should retrieve results from the cache (if available)', () => {\n+      // Initially, retrieve results by executing the command.\n+      const results1 = u.getRemoteRefs('some-pattern');\n+      expect(execSpy).toHaveBeenCalledTimes(1);\n+\n+      // On subsequent calls with the same command, retrieve results from the cache.\n+      expect(u.getRemoteRefs('some-pattern')).toBe(results1);\n+      expect(u.getRemoteRefs('some-pattern', {remote: u.NG_REMOTE_URL})).toBe(results1);\n+      expect(execSpy).toHaveBeenCalledTimes(1);\n+\n+      // Retrieve results for different command (different remote) by executing the command.\n+      const results2 = u.getRemoteRefs('some-pattern', {remote: 'other-remote'});\n+      expect(results2).not.toBe(results1);\n+      expect(execSpy).toHaveBeenCalledTimes(2);\n+\n+      // Retrieve results for different command (different pattern) by executing the command.\n+      const results3 = u.getRemoteRefs('other-pattern');\n+      expect(results3).not.toBe(results1);\n+      expect(results3).not.toBe(results2);\n+      expect(execSpy).toHaveBeenCalledTimes(3);\n+\n+      // Retrieve results from the cache once available.\n+      expect(u.getRemoteRefs('other-pattern', {remote: u.NG_REMOTE_URL})).toBe(results3);\n+      expect(execSpy).toHaveBeenCalledTimes(3);\n+    });\n+\n+    it('should not retrieve results from the cache with `retrieveFromCache: false`', () => {\n+      // Initial call to retrieve and cache the results.\n+      const results1 = u.getRemoteRefs('some-pattern');\n+      expect(execSpy).toHaveBeenCalledTimes(1);\n+\n+      // Do not use cached results with `retrieveFromCache: false`.\n+      const results2 = u.getRemoteRefs('some-pattern', {retrieveFromCache: false});\n+      expect(results2).not.toBe(results1);\n+      expect(execSpy).toHaveBeenCalledTimes(2);\n+\n+      const results3 = u.getRemoteRefs(\n+          'some-pattern', {remote: u.NG_REMOTE_URL, retrieveFromCache: false});\n+      expect(results3).not.toBe(results1);\n+      expect(results3).not.toBe(results2);\n+      expect(execSpy).toHaveBeenCalledTimes(3);\n+    });\n+\n+    it('should cache the results for future use even with `retrieveFromCache: false`', () => {\n+      // Initial call with `retrieveFromCache: false` (should still cache the results).\n+      const results = u.getRemoteRefs('some-pattern', {retrieveFromCache: false});\n+      expect(execSpy).toHaveBeenCalledTimes(1);\n+\n+      // Subsequent call uses the cached results.\n+      expect(u.getRemoteRefs('some-pattern')).toBe(results);\n+      expect(u.getRemoteRefs('some-pattern', {other: 'option'})).toBe(results);\n+      expect(u.getRemoteRefs('some-pattern', {retrieveFromCache: true})).toBe(results);\n+      expect(execSpy).toHaveBeenCalledTimes(1);\n+    });\n+  });\n+\n+  describe('logSectionHeader()', () => {\n+    let logSpy;\n+\n+    beforeEach(() => logSpy = spyOn(console, 'log'));\n+\n+    it('should log a section header', () => {\n+      u.logSectionHeader('Foo header');\n+      expect(logSpy).toHaveBeenCalledWith('\\n\\n\\n==== Foo header ====\\n');\n+    });\n+  });\n+\n+  describe('yarn()', () => {\n+    let execSpy;\n+\n+    beforeEach(() => execSpy = spyOn(sh, 'exec'));\n+\n+    it('should execute yarn in silent mode', () => {\n+      u.yarn('foo --bar');\n+      expect(execSpy).toHaveBeenCalledWith('yarn --silent foo --bar');\n+    });\n+\n+    it('should return the output from the command\\'s execution', () => {\n+      execSpy.and.returnValue('command output\\n');\n+      expect(u.yarn('foo --bar')).toBe('command output\\n');\n+    });\n+  });\n+});"
        }
    ],
    "stats": {
        "total": 489,
        "additions": 381,
        "deletions": 108
    }
}