{
    "author": "zarend",
    "message": "feat(language-service): add perf tracing to LanguageService (#41319)\n\nAdds perf tracing for the public methods in LanguageService. If the log level is verbose or higher,\ntrace performance results to the tsServer logger. This logger is implemented on the extension side\nin angular/vscode-ng-language-service.\n\nPR Close #41319",
    "sha": "90f85da2de72f320653e6292968f70c87876bada",
    "files": [
        {
            "sha": "39e2a44bc0f600647cbee2660c07c0a43054529b",
            "filename": "packages/compiler-cli/src/ngtsc/perf/src/api.ts",
            "status": "modified",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/90f85da2de72f320653e6292968f70c87876bada/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/90f85da2de72f320653e6292968f70c87876bada/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Fapi.ts?ref=90f85da2de72f320653e6292968f70c87876bada",
            "patch": "@@ -110,6 +110,40 @@ export enum PerfPhase {\n    */\n   LsReferencesAndRenames,\n \n+  /**\n+   * Time spent by the Angular Language Service calculating a \"quick info\" operation.\n+   */\n+  LsQuickInfo,\n+\n+  /**\n+   * Time spent by the Angular Language Service calculating a \"get type definition\" or \"get\n+   * definition\" operation.\n+   */\n+  LsDefinition,\n+\n+  /**\n+   * Time spent by the Angular Language Service calculating a \"get completions\" (AKA autocomplete)\n+   * operation.\n+   */\n+  LsCompletions,\n+\n+  /**\n+   * Time spent by the Angular Language Service calculating a \"view template typecheck block\"\n+   * operation.\n+   */\n+  LsTcb,\n+\n+  /**\n+   * Time spent by the Angular Language Service calculating diagnostics.\n+   */\n+  LsDiagnostics,\n+\n+  /**\n+   * Time spent by the Angular Language Service calculating a \"get component locations for template\"\n+   * operation.\n+   */\n+  LsComponentLocations,\n+\n   /**\n    * Tracks the number of `PerfPhase`s, and must appear at the end of the list.\n    */"
        },
        {
            "sha": "cbbff8d4621f915d6090825a3aeb0c6b0281ef68",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 180,
            "deletions": 138,
            "changes": 318,
            "blob_url": "https://github.com/angular/angular/blob/90f85da2de72f320653e6292968f70c87876bada/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/90f85da2de72f320653e6292968f70c87876bada/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=90f85da2de72f320653e6292968f70c87876bada",
            "patch": "@@ -11,6 +11,7 @@ import {CompilerOptions, ConfigurationHost, readConfiguration} from '@angular/co\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {ErrorCode, ngErrorCode} from '@angular/compiler-cli/src/ngtsc/diagnostics';\n import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n+import {PerfPhase} from '@angular/compiler-cli/src/ngtsc/perf';\n import {isNamedClassDeclaration} from '@angular/compiler-cli/src/ngtsc/reflection';\n import {TypeCheckShimGenerator} from '@angular/compiler-cli/src/ngtsc/typecheck';\n import {OptimizeFor, TypeCheckingProgramStrategy} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n@@ -63,51 +64,54 @@ export class LanguageService {\n   }\n \n   getSemanticDiagnostics(fileName: string): ts.Diagnostic[] {\n-    const compiler = this.compilerFactory.getOrCreate();\n-    const ttc = compiler.getTemplateTypeChecker();\n-    const diagnostics: ts.Diagnostic[] = [];\n-    if (isTypeScriptFile(fileName)) {\n-      const program = compiler.getNextProgram();\n-      const sourceFile = program.getSourceFile(fileName);\n-      if (sourceFile) {\n-        const ngDiagnostics = compiler.getDiagnosticsForFile(sourceFile, OptimizeFor.SingleFile);\n-        // There are several kinds of diagnostics returned by `NgCompiler` for a source file:\n-        //\n-        // 1. Angular-related non-template diagnostics from decorated classes within that file.\n-        // 2. Template diagnostics for components with direct inline templates (a string literal).\n-        // 3. Template diagnostics for components with indirect inline templates (templates computed\n-        //    by expression).\n-        // 4. Template diagnostics for components with external templates.\n-        //\n-        // When showing diagnostics for a TS source file, we want to only include kinds 1 and 2 -\n-        // those diagnostics which are reported at a location within the TS file itself. Diagnostics\n-        // for external templates will be shown when editing that template file (the `else` block)\n-        // below.\n-        //\n-        // Currently, indirect inline template diagnostics (kind 3) are not shown at all by the\n-        // Language Service, because there is no sensible location in the user's code for them. Such\n-        // templates are an edge case, though, and should not be common.\n-        //\n-        // TODO(alxhub): figure out a good user experience for indirect template diagnostics and\n-        // show them from within the Language Service.\n-        diagnostics.push(...ngDiagnostics.filter(\n-            diag => diag.file !== undefined && diag.file.fileName === sourceFile.fileName));\n-      }\n-    } else {\n-      const components = compiler.getComponentsWithTemplateFile(fileName);\n-      for (const component of components) {\n-        if (ts.isClassDeclaration(component)) {\n-          diagnostics.push(...ttc.getDiagnosticsForComponent(component));\n+    return this.withCompilerAndPerfTracing(PerfPhase.LsDiagnostics, (compiler) => {\n+      const ttc = compiler.getTemplateTypeChecker();\n+      const diagnostics: ts.Diagnostic[] = [];\n+      if (isTypeScriptFile(fileName)) {\n+        const program = compiler.getNextProgram();\n+        const sourceFile = program.getSourceFile(fileName);\n+        if (sourceFile) {\n+          const ngDiagnostics = compiler.getDiagnosticsForFile(sourceFile, OptimizeFor.SingleFile);\n+          // There are several kinds of diagnostics returned by `NgCompiler` for a source file:\n+          //\n+          // 1. Angular-related non-template diagnostics from decorated classes within that\n+          // file.\n+          // 2. Template diagnostics for components with direct inline templates (a string\n+          // literal).\n+          // 3. Template diagnostics for components with indirect inline templates (templates\n+          // computed\n+          //    by expression).\n+          // 4. Template diagnostics for components with external templates.\n+          //\n+          // When showing diagnostics for a TS source file, we want to only include kinds 1 and\n+          // 2 - those diagnostics which are reported at a location within the TS file itself.\n+          // Diagnostics for external templates will be shown when editing that template file\n+          // (the `else` block) below.\n+          //\n+          // Currently, indirect inline template diagnostics (kind 3) are not shown at all by\n+          // the Language Service, because there is no sensible location in the user's code for\n+          // them. Such templates are an edge case, though, and should not be common.\n+          //\n+          // TODO(alxhub): figure out a good user experience for indirect template diagnostics\n+          // and show them from within the Language Service.\n+          diagnostics.push(...ngDiagnostics.filter(\n+              diag => diag.file !== undefined && diag.file.fileName === sourceFile.fileName));\n+        }\n+      } else {\n+        const components = compiler.getComponentsWithTemplateFile(fileName);\n+        for (const component of components) {\n+          if (ts.isClassDeclaration(component)) {\n+            diagnostics.push(...ttc.getDiagnosticsForComponent(component));\n+          }\n         }\n       }\n-    }\n-    this.compilerFactory.registerLastKnownProgram();\n-    return diagnostics;\n+      return diagnostics;\n+    });\n   }\n \n   getDefinitionAndBoundSpan(fileName: string, position: number): ts.DefinitionInfoAndBoundSpan\n       |undefined {\n-    return this.withCompiler((compiler) => {\n+    return this.withCompilerAndPerfTracing(PerfPhase.LsDefinition, (compiler) => {\n       if (!isInAngularContext(compiler.getNextProgram(), fileName, position)) {\n         return undefined;\n       }\n@@ -118,7 +122,7 @@ export class LanguageService {\n \n   getTypeDefinitionAtPosition(fileName: string, position: number):\n       readonly ts.DefinitionInfo[]|undefined {\n-    return this.withCompiler((compiler) => {\n+    return this.withCompilerAndPerfTracing(PerfPhase.LsDefinition, (compiler) => {\n       if (!isTemplateContext(compiler.getNextProgram(), fileName, position)) {\n         return undefined;\n       }\n@@ -128,64 +132,70 @@ export class LanguageService {\n   }\n \n   getQuickInfoAtPosition(fileName: string, position: number): ts.QuickInfo|undefined {\n-    return this.withCompiler((compiler) => {\n-      if (!isTemplateContext(compiler.getNextProgram(), fileName, position)) {\n-        return undefined;\n-      }\n+    return this.withCompilerAndPerfTracing(PerfPhase.LsQuickInfo, (compiler) => {\n+      return this.getQuickInfoAtPositionImpl(fileName, position, compiler);\n+    });\n+  }\n \n-      const templateInfo = getTemplateInfoAtPosition(fileName, position, compiler);\n-      if (templateInfo === undefined) {\n-        return undefined;\n-      }\n-      const positionDetails = getTargetAtPosition(templateInfo.template, position);\n-      if (positionDetails === null) {\n-        return undefined;\n-      }\n+  private getQuickInfoAtPositionImpl(\n+      fileName: string,\n+      position: number,\n+      compiler: NgCompiler,\n+      ): ts.QuickInfo|undefined {\n+    if (!isTemplateContext(compiler.getNextProgram(), fileName, position)) {\n+      return undefined;\n+    }\n \n-      // Because we can only show 1 quick info, just use the bound attribute if the target is a two\n-      // way binding. We may consider concatenating additional display parts from the other target\n-      // nodes or representing the two way binding in some other manner in the future.\n-      const node = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?\n-          positionDetails.context.nodes[0] :\n-          positionDetails.context.node;\n-      return new QuickInfoBuilder(this.tsLS, compiler, templateInfo.component, node).get();\n-    });\n+    const templateInfo = getTemplateInfoAtPosition(fileName, position, compiler);\n+    if (templateInfo === undefined) {\n+      return undefined;\n+    }\n+    const positionDetails = getTargetAtPosition(templateInfo.template, position);\n+    if (positionDetails === null) {\n+      return undefined;\n+    }\n+\n+    // Because we can only show 1 quick info, just use the bound attribute if the target is a two\n+    // way binding. We may consider concatenating additional display parts from the other target\n+    // nodes or representing the two way binding in some other manner in the future.\n+    const node = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?\n+        positionDetails.context.nodes[0] :\n+        positionDetails.context.node;\n+    return new QuickInfoBuilder(this.tsLS, compiler, templateInfo.component, node).get();\n   }\n \n   getReferencesAtPosition(fileName: string, position: number): ts.ReferenceEntry[]|undefined {\n-    const compiler = this.compilerFactory.getOrCreate();\n-    const results = new ReferencesAndRenameBuilder(this.strategy, this.tsLS, compiler)\n-                        .getReferencesAtPosition(fileName, position);\n-    this.compilerFactory.registerLastKnownProgram();\n-    return results;\n+    return this.withCompilerAndPerfTracing(PerfPhase.LsReferencesAndRenames, (compiler) => {\n+      return new ReferencesAndRenameBuilder(this.strategy, this.tsLS, compiler)\n+          .getReferencesAtPosition(fileName, position);\n+    });\n   }\n \n   getRenameInfo(fileName: string, position: number): ts.RenameInfo {\n-    const compiler = this.compilerFactory.getOrCreate();\n-    const renameInfo = new ReferencesAndRenameBuilder(this.strategy, this.tsLS, compiler)\n-                           .getRenameInfo(absoluteFrom(fileName), position);\n-    if (!renameInfo.canRename) {\n-      return renameInfo;\n-    }\n+    return this.withCompilerAndPerfTracing(PerfPhase.LsReferencesAndRenames, (compiler) => {\n+      const renameInfo = new ReferencesAndRenameBuilder(this.strategy, this.tsLS, compiler)\n+                             .getRenameInfo(absoluteFrom(fileName), position);\n+      if (!renameInfo.canRename) {\n+        return renameInfo;\n+      }\n \n-    const quickInfo = this.getQuickInfoAtPosition(fileName, position) ??\n-        this.tsLS.getQuickInfoAtPosition(fileName, position);\n-    const kind = quickInfo?.kind ?? ts.ScriptElementKind.unknown;\n-    const kindModifiers = quickInfo?.kindModifiers ?? ts.ScriptElementKind.unknown;\n-    return {...renameInfo, kind, kindModifiers};\n+      const quickInfo = this.getQuickInfoAtPositionImpl(fileName, position, compiler) ??\n+          this.tsLS.getQuickInfoAtPosition(fileName, position);\n+      const kind = quickInfo?.kind ?? ts.ScriptElementKind.unknown;\n+      const kindModifiers = quickInfo?.kindModifiers ?? ts.ScriptElementKind.unknown;\n+      return {...renameInfo, kind, kindModifiers};\n+    });\n   }\n \n   findRenameLocations(fileName: string, position: number): readonly ts.RenameLocation[]|undefined {\n-    const compiler = this.compilerFactory.getOrCreate();\n-    const results = new ReferencesAndRenameBuilder(this.strategy, this.tsLS, compiler)\n-                        .findRenameLocations(fileName, position);\n-    this.compilerFactory.registerLastKnownProgram();\n-    return results;\n+    return this.withCompilerAndPerfTracing(PerfPhase.LsReferencesAndRenames, (compiler) => {\n+      return new ReferencesAndRenameBuilder(this.strategy, this.tsLS, compiler)\n+          .findRenameLocations(fileName, position);\n+    });\n   }\n \n-  private getCompletionBuilder(fileName: string, position: number):\n+  private getCompletionBuilder(fileName: string, position: number, compiler: NgCompiler):\n       CompletionBuilder<TmplAstNode|AST>|null {\n-    const compiler = this.compilerFactory.getOrCreate();\n     const templateInfo = getTemplateInfoAtPosition(fileName, position, compiler);\n     if (templateInfo === undefined) {\n       return null;\n@@ -208,29 +218,35 @@ export class LanguageService {\n   getCompletionsAtPosition(\n       fileName: string, position: number, options: ts.GetCompletionsAtPositionOptions|undefined):\n       ts.WithMetadata<ts.CompletionInfo>|undefined {\n-    return this.withCompiler((compiler) => {\n-      if (!isTemplateContext(compiler.getNextProgram(), fileName, position)) {\n-        return undefined;\n-      }\n-\n-      const builder = this.getCompletionBuilder(fileName, position);\n-      if (builder === null) {\n-        return undefined;\n-      }\n-      return builder.getCompletionsAtPosition(options);\n+    return this.withCompilerAndPerfTracing(PerfPhase.LsCompletions, (compiler) => {\n+      return this.getCompletionsAtPositionImpl(fileName, position, options, compiler);\n     });\n   }\n \n+  private getCompletionsAtPositionImpl(\n+      fileName: string, position: number, options: ts.GetCompletionsAtPositionOptions|undefined,\n+      compiler: NgCompiler): ts.WithMetadata<ts.CompletionInfo>|undefined {\n+    if (!isTemplateContext(compiler.getNextProgram(), fileName, position)) {\n+      return undefined;\n+    }\n+\n+    const builder = this.getCompletionBuilder(fileName, position, compiler);\n+    if (builder === null) {\n+      return undefined;\n+    }\n+    return builder.getCompletionsAtPosition(options);\n+  }\n+\n   getCompletionEntryDetails(\n       fileName: string, position: number, entryName: string,\n       formatOptions: ts.FormatCodeOptions|ts.FormatCodeSettings|undefined,\n       preferences: ts.UserPreferences|undefined): ts.CompletionEntryDetails|undefined {\n-    return this.withCompiler((compiler) => {\n+    return this.withCompilerAndPerfTracing(PerfPhase.LsCompletions, (compiler) => {\n       if (!isTemplateContext(compiler.getNextProgram(), fileName, position)) {\n         return undefined;\n       }\n \n-      const builder = this.getCompletionBuilder(fileName, position);\n+      const builder = this.getCompletionBuilder(fileName, position, compiler);\n       if (builder === null) {\n         return undefined;\n       }\n@@ -240,12 +256,12 @@ export class LanguageService {\n \n   getCompletionEntrySymbol(fileName: string, position: number, entryName: string): ts.Symbol\n       |undefined {\n-    return this.withCompiler((compiler) => {\n+    return this.withCompilerAndPerfTracing(PerfPhase.LsCompletions, (compiler) => {\n       if (!isTemplateContext(compiler.getNextProgram(), fileName, position)) {\n         return undefined;\n       }\n \n-      const builder = this.getCompletionBuilder(fileName, position);\n+      const builder = this.getCompletionBuilder(fileName, position, compiler);\n       if (builder === null) {\n         return undefined;\n       }\n@@ -256,30 +272,31 @@ export class LanguageService {\n   }\n \n   getComponentLocationsForTemplate(fileName: string): GetComponentLocationsForTemplateResponse {\n-    return this.withCompiler<GetComponentLocationsForTemplateResponse>((compiler) => {\n-      const components = compiler.getComponentsWithTemplateFile(fileName);\n-      const componentDeclarationLocations: ts.DocumentSpan[] =\n-          Array.from(components.values()).map(c => {\n-            let contextSpan: ts.TextSpan|undefined = undefined;\n-            let textSpan: ts.TextSpan;\n-            if (isNamedClassDeclaration(c)) {\n-              textSpan = ts.createTextSpanFromBounds(c.name.getStart(), c.name.getEnd());\n-              contextSpan = ts.createTextSpanFromBounds(c.getStart(), c.getEnd());\n-            } else {\n-              textSpan = ts.createTextSpanFromBounds(c.getStart(), c.getEnd());\n-            }\n-            return {\n-              fileName: c.getSourceFile().fileName,\n-              textSpan,\n-              contextSpan,\n-            };\n-          });\n-      return componentDeclarationLocations;\n-    });\n+    return this.withCompilerAndPerfTracing<GetComponentLocationsForTemplateResponse>(\n+        PerfPhase.LsComponentLocations, (compiler) => {\n+          const components = compiler.getComponentsWithTemplateFile(fileName);\n+          const componentDeclarationLocations: ts.DocumentSpan[] =\n+              Array.from(components.values()).map(c => {\n+                let contextSpan: ts.TextSpan|undefined = undefined;\n+                let textSpan: ts.TextSpan;\n+                if (isNamedClassDeclaration(c)) {\n+                  textSpan = ts.createTextSpanFromBounds(c.name.getStart(), c.name.getEnd());\n+                  contextSpan = ts.createTextSpanFromBounds(c.getStart(), c.getEnd());\n+                } else {\n+                  textSpan = ts.createTextSpanFromBounds(c.getStart(), c.getEnd());\n+                }\n+                return {\n+                  fileName: c.getSourceFile().fileName,\n+                  textSpan,\n+                  contextSpan,\n+                };\n+              });\n+          return componentDeclarationLocations;\n+        });\n   }\n \n   getTcb(fileName: string, position: number): GetTcbResponse|undefined {\n-    return this.withCompiler<GetTcbResponse|undefined>(compiler => {\n+    return this.withCompilerAndPerfTracing<GetTcbResponse|undefined>(PerfPhase.LsTcb, compiler => {\n       const templateInfo = getTemplateInfoAtPosition(fileName, position, compiler);\n       if (templateInfo === undefined) {\n         return undefined;\n@@ -323,10 +340,34 @@ export class LanguageService {\n     });\n   }\n \n-  private withCompiler<T>(p: (compiler: NgCompiler) => T): T {\n+  /**\n+   * Provides an instance of the `NgCompiler` and traces perf results. Perf results are logged only\n+   * if the log level is verbose or higher. This method is intended to be called once per public\n+   * method call.\n+   *\n+   * Here is an example of the log output.\n+   *\n+   * Perf 245  [16:16:39.353] LanguageService#getQuickInfoAtPosition(): {\"events\":{},\"phases\":{\n+   * \"Unaccounted\":379,\"TtcSymbol\":4},\"memory\":{}}\n+   *\n+   * Passing name of caller instead of using `arguments.caller` because 'caller', 'callee', and\n+   * 'arguments' properties may not be accessed in strict mode.\n+   *\n+   * @param phase the `PerfPhase` to execute the `p` callback in\n+   * @param p callback to be run synchronously with an instance of the `NgCompiler` as argument\n+   * @return the result of running the `p` callback\n+   */\n+  private withCompilerAndPerfTracing<T>(phase: PerfPhase, p: (compiler: NgCompiler) => T): T {\n     const compiler = this.compilerFactory.getOrCreate();\n-    const result = p(compiler);\n+    const result = compiler.perfRecorder.inPhase(phase, () => p(compiler));\n     this.compilerFactory.registerLastKnownProgram();\n+\n+    const logger = this.project.projectService.logger;\n+    if (logger.hasLevel(ts.server.LogLevel.verbose)) {\n+      logger.perftrc(`LanguageService#${PerfPhase[phase]}: ${\n+          JSON.stringify(compiler.perfRecorder.finalize())}`);\n+    }\n+\n     return result;\n   }\n \n@@ -336,26 +377,27 @@ export class LanguageService {\n       return [];\n     }\n \n-    const diagnostics: ts.Diagnostic[] = [];\n-    const configSourceFile = ts.readJsonConfigFile(\n-        project.getConfigFilePath(), (path: string) => project.readFile(path));\n-\n-    if (!this.options.strictTemplates && !this.options.fullTemplateTypeCheck) {\n-      diagnostics.push({\n-        messageText: 'Some language features are not available. ' +\n-            'To access all features, enable `strictTemplates` in `angularCompilerOptions`.',\n-        category: ts.DiagnosticCategory.Suggestion,\n-        code: ngErrorCode(ErrorCode.SUGGEST_STRICT_TEMPLATES),\n-        file: configSourceFile,\n-        start: undefined,\n-        length: undefined,\n-      });\n-    }\n+    return this.withCompilerAndPerfTracing(PerfPhase.LsDiagnostics, (compiler) => {\n+      const diagnostics: ts.Diagnostic[] = [];\n+      const configSourceFile = ts.readJsonConfigFile(\n+          project.getConfigFilePath(), (path: string) => project.readFile(path));\n+\n+      if (!this.options.strictTemplates && !this.options.fullTemplateTypeCheck) {\n+        diagnostics.push({\n+          messageText: 'Some language features are not available. ' +\n+              'To access all features, enable `strictTemplates` in `angularCompilerOptions`.',\n+          category: ts.DiagnosticCategory.Suggestion,\n+          code: ngErrorCode(ErrorCode.SUGGEST_STRICT_TEMPLATES),\n+          file: configSourceFile,\n+          start: undefined,\n+          length: undefined,\n+        });\n+      }\n \n-    const compiler = this.compilerFactory.getOrCreate();\n-    diagnostics.push(...compiler.getOptionDiagnostics());\n+      diagnostics.push(...compiler.getOptionDiagnostics());\n \n-    return diagnostics;\n+      return diagnostics;\n+    });\n   }\n \n   private watchConfigFile(project: ts.server.Project) {"
        },
        {
            "sha": "3fadd8f966c3565d1732b5de4efa17b9b54ab32f",
            "filename": "packages/language-service/ivy/test/diagnostic_spec.ts",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/90f85da2de72f320653e6292968f70c87876bada/packages%2Flanguage-service%2Fivy%2Ftest%2Fdiagnostic_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/90f85da2de72f320653e6292968f70c87876bada/packages%2Flanguage-service%2Fivy%2Ftest%2Fdiagnostic_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fdiagnostic_spec.ts?ref=90f85da2de72f320653e6292968f70c87876bada",
            "patch": "@@ -275,6 +275,28 @@ describe('getSemanticDiagnostics', () => {\n     expect(diag.category).toBe(ts.DiagnosticCategory.Suggestion);\n     expect(getTextOfDiagnostic(diag)).toBe('user');\n   });\n+\n+  it('logs perf tracing', () => {\n+    const files = {\n+      'app.ts': `\n+        import {Component} from '@angular/core';\n+        @Component({ template: '' })\n+        export class MyComponent {}\n+      `\n+    };\n+\n+    const project = createModuleAndProjectWithDeclarations(env, 'test', files);\n+\n+    const logger = project.getLogger();\n+    spyOn(logger, 'hasLevel').and.returnValue(true);\n+    spyOn(logger, 'perftrc').and.callFake(() => {});\n+\n+    const diags = project.getDiagnosticsForFile('app.ts');\n+    expect(diags.length).toEqual(0);\n+    expect(logger.perftrc)\n+        .toHaveBeenCalledWith(jasmine.stringMatching(\n+            /LanguageService\\#LsDiagnostics\\:.*\\\"LsDiagnostics\\\":\\s*\\d+.*/g));\n+  });\n });\n \n function getTextOfDiagnostic(diag: ts.Diagnostic): string {"
        },
        {
            "sha": "37ae237eda035e63eacdcfd7156f5309b495fdd7",
            "filename": "packages/language-service/ivy/testing/src/project.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/90f85da2de72f320653e6292968f70c87876bada/packages%2Flanguage-service%2Fivy%2Ftesting%2Fsrc%2Fproject.ts",
            "raw_url": "https://github.com/angular/angular/raw/90f85da2de72f320653e6292968f70c87876bada/packages%2Flanguage-service%2Fivy%2Ftesting%2Fsrc%2Fproject.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftesting%2Fsrc%2Fproject.ts?ref=90f85da2de72f320653e6292968f70c87876bada",
            "patch": "@@ -179,6 +179,10 @@ export class Project {\n   getTemplateTypeChecker(): TemplateTypeChecker {\n     return this.ngLS.compilerFactory.getOrCreate().getTemplateTypeChecker();\n   }\n+\n+  getLogger(): ts.server.Logger {\n+    return this.tsProject.projectService.logger;\n+  }\n }\n \n function getClassOrError(sf: ts.SourceFile, name: string): ts.ClassDeclaration {"
        }
    ],
    "stats": {
        "total": 378,
        "additions": 240,
        "deletions": 138
    }
}