{
    "author": "crisbeto",
    "message": "feat(router): add migration for ActivatedRouteSnapshot.fragment (#41092)\n\nAdds a migration that casts the value of `ActivatedRouteSnapshot.fragment` to be non-nullable.\n\nAlso moves some code from the `AbstractControl.parent` migration so that it can be reused.\n\nRelates to #37336.\n\nPR Close #41092",
    "sha": "190fa07b9a416defb581d2bf76d1deef7baefce6",
    "files": [
        {
            "sha": "5887aa17a34eb92ed7d9aeba85879430633f6bfa",
            "filename": "packages/core/schematics/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2FBUILD.bazel?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -11,6 +11,7 @@ pkg_npm(\n     visibility = [\"//packages/core:__pkg__\"],\n     deps = [\n         \"//packages/core/schematics/migrations/abstract-control-parent\",\n+        \"//packages/core/schematics/migrations/activated-route-snapshot-fragment\",\n         \"//packages/core/schematics/migrations/can-activate-with-redirect-to\",\n         \"//packages/core/schematics/migrations/dynamic-queries\",\n         \"//packages/core/schematics/migrations/initial-navigation\","
        },
        {
            "sha": "85f5fe8371d397420808bdb55694bb5903f8a634",
            "filename": "packages/core/schematics/migrations.json",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations.json?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -84,6 +84,11 @@\n       \"version\": \"11.1.0-beta\",\n       \"description\": \"Removes `canActivate` from a `Route` config when `redirectTo` is also present\",\n       \"factory\": \"./migrations/can-activate-with-redirect-to/index\"\n+    },\n+    \"migration-v12-activated-route-snapshot-fragment\": {\n+      \"version\": \"12.0.0-beta\",\n+      \"description\": \"In Angular version 12, the type of ActivatedRouteSnapshot.fragment is nullable. This migration automatically adds non-null assertions to it.\",\n+      \"factory\": \"./migrations/activated-route-snapshot-fragment/index\"\n     }\n   }\n-}\n\\ No newline at end of file\n+}"
        },
        {
            "sha": "37d5cbff8f5d097755fff1ca20481fff8f39fa37",
            "filename": "packages/core/schematics/migrations/abstract-control-parent/util.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 104,
            "changes": 110,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Futil.ts?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -8,14 +8,11 @@\n \n import {normalize} from 'path';\n import * as ts from 'typescript';\n+import {isNullCheck, isSafeAccess} from '../../utils/typescript/nodes';\n+import {hasOneOfTypes, isNullableType} from '../../utils/typescript/symbol';\n \n /** Names of symbols from `@angular/forms` whose `parent` accesses have to be migrated. */\n-const abstractControlSymbols = new Set<string>([\n-  'AbstractControl',\n-  'FormArray',\n-  'FormControl',\n-  'FormGroup',\n-]);\n+const abstractControlSymbols = ['AbstractControl', 'FormArray', 'FormControl', 'FormGroup'];\n \n /**\n  * Finds the `PropertyAccessExpression`-s that are accessing the `parent` property in\n@@ -38,78 +35,6 @@ export function findParentAccesses(\n   return results;\n }\n \n-/** Checks whether a node's type is nullable (`null`, `undefined` or `void`). */\n-function isNullableType(typeChecker: ts.TypeChecker, node: ts.Node) {\n-  // Skip expressions in the form of `foo.bar!.baz` since the `TypeChecker` seems\n-  // to identify them as null, even though the user indicated that it won't be.\n-  if (node.parent && ts.isNonNullExpression(node.parent)) {\n-    return false;\n-  }\n-\n-  const type = typeChecker.getTypeAtLocation(node);\n-  const typeNode = typeChecker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.None);\n-  let hasSeenNullableType = false;\n-\n-  // Trace the type of the node back to a type node, walk\n-  // through all of its sub-nodes and look for nullable tyes.\n-  if (typeNode) {\n-    (function walk(current: ts.Node) {\n-      if (current.kind === ts.SyntaxKind.NullKeyword ||\n-          current.kind === ts.SyntaxKind.UndefinedKeyword ||\n-          current.kind === ts.SyntaxKind.VoidKeyword) {\n-        hasSeenNullableType = true;\n-        // Note that we don't descend into type literals, because it may cause\n-        // us to mis-identify the root type as nullable, because it has a nullable\n-        // property (e.g. `{ foo: string | null }`).\n-      } else if (!hasSeenNullableType && !ts.isTypeLiteralNode(current)) {\n-        current.forEachChild(walk);\n-      }\n-    })(typeNode);\n-  }\n-\n-  return hasSeenNullableType;\n-}\n-\n-/**\n- * Checks whether a particular node is part of a null check. E.g. given:\n- * `control.parent ? control.parent.value : null` the null check would be `control.parent`.\n- */\n-function isNullCheck(node: ts.PropertyAccessExpression): boolean {\n-  if (!node.parent) {\n-    return false;\n-  }\n-\n-  // `control.parent && control.parent.value` where `node` is `control.parent`.\n-  if (ts.isBinaryExpression(node.parent) && node.parent.left === node) {\n-    return true;\n-  }\n-\n-  // `control.parent && control.parent.parent && control.parent.parent.value`\n-  // where `node` is `control.parent`.\n-  if (node.parent.parent && ts.isBinaryExpression(node.parent.parent) &&\n-      node.parent.parent.left === node.parent) {\n-    return true;\n-  }\n-\n-  // `if (control.parent) {...}` where `node` is `control.parent`.\n-  if (ts.isIfStatement(node.parent) && node.parent.expression === node) {\n-    return true;\n-  }\n-\n-  // `control.parent ? control.parent.value : null` where `node` is `control.parent`.\n-  if (ts.isConditionalExpression(node.parent) && node.parent.condition === node) {\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n-/** Checks whether a property access is safe (e.g. `foo.parent?.value`). */\n-function isSafeAccess(node: ts.PropertyAccessExpression): boolean {\n-  return node.parent != null && ts.isPropertyAccessExpression(node.parent) &&\n-      node.parent.expression === node && node.parent.questionDotToken != null;\n-}\n-\n /** Checks whether a property access is on an `AbstractControl` coming from `@angular/forms`. */\n function isAbstractControlReference(\n     typeChecker: ts.TypeChecker, node: ts.PropertyAccessExpression): boolean {\n@@ -119,37 +44,14 @@ function isAbstractControlReference(\n   // If such a node is found, we check whether the type is one of the `AbstractControl` symbols\n   // and whether it comes from the `@angular/forms` directory in the `node_modules`.\n   while (ts.isPropertyAccessExpression(current)) {\n-    const type = typeChecker.getTypeAtLocation(current.expression);\n-    const symbol = type.getSymbol();\n-    if (symbol && type) {\n+    const symbol = typeChecker.getTypeAtLocation(current.expression)?.getSymbol();\n+    if (symbol) {\n       const sourceFile = symbol.valueDeclaration?.getSourceFile();\n       return sourceFile != null &&\n           formsPattern.test(normalize(sourceFile.fileName).replace(/\\\\/g, '/')) &&\n-          hasAbstractControlType(typeChecker, type);\n+          hasOneOfTypes(typeChecker, current.expression, abstractControlSymbols);\n     }\n     current = current.expression;\n   }\n   return false;\n }\n-\n-/**\n- * Walks through the sub-types of a type, looking for a type that\n- * has the same name as one of the `AbstractControl` types.\n- */\n-function hasAbstractControlType(typeChecker: ts.TypeChecker, type: ts.Type): boolean {\n-  const typeNode = typeChecker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.None);\n-  let hasMatch = false;\n-  if (typeNode) {\n-    (function walk(current: ts.Node) {\n-      if (ts.isIdentifier(current) && abstractControlSymbols.has(current.text)) {\n-        hasMatch = true;\n-        // Note that we don't descend into type literals, because it may cause\n-        // us to mis-identify the root type as nullable, because it has a nullable\n-        // property (e.g. `{ foo: FormControl }`).\n-      } else if (!hasMatch && !ts.isTypeLiteralNode(current)) {\n-        current.forEachChild(walk);\n-      }\n-    })(typeNode);\n-  }\n-  return hasMatch;\n-}"
        },
        {
            "sha": "ff42f9dc839ea1de1c42ec8219d942b5f922d7df",
            "filename": "packages/core/schematics/migrations/activated-route-snapshot-fragment/BUILD.bazel",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2FBUILD.bazel?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -0,0 +1,18 @@\n+load(\"//tools:defaults.bzl\", \"ts_library\")\n+\n+ts_library(\n+    name = \"activated-route-snapshot-fragment\",\n+    srcs = glob([\"**/*.ts\"]),\n+    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n+    visibility = [\n+        \"//packages/core/schematics:__pkg__\",\n+        \"//packages/core/schematics/migrations/google3:__pkg__\",\n+        \"//packages/core/schematics/test:__pkg__\",\n+    ],\n+    deps = [\n+        \"//packages/core/schematics/utils\",\n+        \"@npm//@angular-devkit/schematics\",\n+        \"@npm//@types/node\",\n+        \"@npm//typescript\",\n+    ],\n+)"
        },
        {
            "sha": "b7bc129091b4449fbb24fbd2b895e64b9d9a910b",
            "filename": "packages/core/schematics/migrations/activated-route-snapshot-fragment/README.md",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2FREADME.md?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -0,0 +1,34 @@\n+## `ActivatedRouteSnapshot.fragment` migration\n+\n+The value if `ActivatedRouteSnapshot.fragment` is becoming nullable. This migration adds non-null\n+assertions to it.\n+\n+#### Before\n+```ts\n+import { Component } from '@angular/core';\n+import { ActivatedRouteSnapshot } from '@angular/router';\n+\n+@Component({})\n+export class YourComponent {\n+  private _activatedRouteSnapshot: ActivatedRouteSnapshot;\n+\n+  getFragmentValue() {\n+    return this._activatedRouteSnapshot.fragment.value;\n+  }\n+}\n+```\n+\n+#### After\n+```ts\n+import { Component } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+\n+@Component({})\n+export class YourComponent {\n+  private _activatedRouteSnapshot: ActivatedRouteSnapshot;\n+\n+  getFragmentValue() {\n+    return this._activatedRouteSnapshot.fragment!.value;\n+  }\n+}\n+```"
        },
        {
            "sha": "447ceec7cb7852eb777303a48eea973bc789aec4",
            "filename": "packages/core/schematics/migrations/activated-route-snapshot-fragment/index.ts",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2Findex.ts?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -0,0 +1,62 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n+import {relative} from 'path';\n+import * as ts from 'typescript';\n+\n+import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n+import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n+import {findFragmentAccesses, migrateActivatedRouteSnapshotFragment} from './util';\n+\n+\n+/**\n+ * Migration that marks accesses of `ActivatedRouteSnapshot.fragment` as non-null.\n+ */\n+export default function(): Rule {\n+  return (tree: Tree) => {\n+    const {buildPaths, testPaths} = getProjectTsConfigPaths(tree);\n+    const basePath = process.cwd();\n+    const allPaths = [...buildPaths, ...testPaths];\n+\n+    if (!allPaths.length) {\n+      throw new SchematicsException(\n+          'Could not find any tsconfig file. Cannot migrate ' +\n+          '`ActivatedRouteSnapshot.fragment` accesses.');\n+    }\n+\n+    for (const tsconfigPath of allPaths) {\n+      runActivatedRouteSnapshotFragmentMigration(tree, tsconfigPath, basePath);\n+    }\n+  };\n+}\n+\n+function runActivatedRouteSnapshotFragmentMigration(\n+    tree: Tree, tsconfigPath: string, basePath: string) {\n+  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n+  const typeChecker = program.getTypeChecker();\n+  const sourceFiles =\n+      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n+  const printer = ts.createPrinter();\n+\n+  sourceFiles.forEach(sourceFile => {\n+    const nodesToMigrate = findFragmentAccesses(typeChecker, sourceFile);\n+\n+    if (nodesToMigrate.size > 0) {\n+      const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n+      nodesToMigrate.forEach(node => {\n+        update.remove(node.getStart(), node.getWidth());\n+        update.insertRight(\n+            node.getStart(),\n+            printer.printNode(\n+                ts.EmitHint.Unspecified, migrateActivatedRouteSnapshotFragment(node), sourceFile));\n+      });\n+      tree.commitUpdate(update);\n+    }\n+  });\n+}"
        },
        {
            "sha": "681882f39d9bd3bd31fba015c63ba530d2d5c858",
            "filename": "packages/core/schematics/migrations/activated-route-snapshot-fragment/util.ts",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2Futil.ts?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -0,0 +1,39 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript';\n+import {isNullCheck, isSafeAccess} from '../../utils/typescript/nodes';\n+import {hasOneOfTypes, isNullableType} from '../../utils/typescript/symbol';\n+\n+/**\n+ * Finds all the accesses of `ActivatedRouteSnapshot.fragment`\n+ * that need to be migrated within a particular file.\n+ */\n+export function findFragmentAccesses(\n+    typeChecker: ts.TypeChecker, sourceFile: ts.SourceFile): Set<ts.PropertyAccessExpression> {\n+  const results = new Set<ts.PropertyAccessExpression>();\n+\n+  sourceFile.forEachChild(function walk(node: ts.Node) {\n+    if (ts.isPropertyAccessExpression(node) && node.name.text === 'fragment' &&\n+        !results.has(node) && !isNullCheck(node) && !isSafeAccess(node) &&\n+        hasOneOfTypes(typeChecker, node.expression, ['ActivatedRouteSnapshot']) &&\n+        isNullableType(typeChecker, node)) {\n+      results.add(node);\n+    }\n+\n+    node.forEachChild(walk);\n+  });\n+\n+  return results;\n+}\n+\n+/** Migrates an `ActivatedRouteSnapshot.fragment` access. */\n+export function migrateActivatedRouteSnapshotFragment(node: ts.PropertyAccessExpression): ts.Node {\n+  // Turns `foo.fragment` into `foo.fragment!`.\n+  return ts.createNonNullExpression(node);\n+}"
        },
        {
            "sha": "bd21e587de1a43da8dfbbd33f03c0f02bf980fb3",
            "filename": "packages/core/schematics/migrations/google3/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -6,6 +6,7 @@ ts_library(\n     tsconfig = \"//packages/core/schematics:tsconfig.json\",\n     visibility = [\"//packages/core/schematics/test/google3:__pkg__\"],\n     deps = [\n+        \"//packages/core/schematics/migrations/activated-route-snapshot-fragment\",\n         \"//packages/core/schematics/migrations/can-activate-with-redirect-to\",\n         \"//packages/core/schematics/migrations/dynamic-queries\",\n         \"//packages/core/schematics/migrations/initial-navigation\","
        },
        {
            "sha": "4b55b2bc3c78d75ffdfddd13c74ba84e9143135b",
            "filename": "packages/core/schematics/migrations/google3/activatedRouteSnapshotFragmentRule.ts",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FactivatedRouteSnapshotFragmentRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FactivatedRouteSnapshotFragmentRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FactivatedRouteSnapshotFragmentRule.ts?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -0,0 +1,40 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Replacement, RuleFailure, Rules} from 'tslint';\n+import * as ts from 'typescript';\n+\n+import {findFragmentAccesses, migrateActivatedRouteSnapshotFragment} from '../activated-route-snapshot-fragment/util';\n+\n+export class Rule extends Rules.TypedRule {\n+  applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n+    if (sourceFile.isDeclarationFile || program.isSourceFileFromExternalLibrary(sourceFile)) {\n+      return [];\n+    }\n+\n+    const failures: RuleFailure[] = [];\n+    const typeChecker = program.getTypeChecker();\n+    const nodesToMigrate = findFragmentAccesses(typeChecker, sourceFile);\n+\n+    if (nodesToMigrate.size > 0) {\n+      const printer = ts.createPrinter();\n+      nodesToMigrate.forEach(node => {\n+        const sourceFile = node.getSourceFile();\n+        const migratedNode = migrateActivatedRouteSnapshotFragment(node);\n+        const replacement = new Replacement(\n+            node.getStart(), node.getWidth(),\n+            printer.printNode(ts.EmitHint.Unspecified, migratedNode, sourceFile));\n+        failures.push(new RuleFailure(\n+            sourceFile, node.getStart(), node.getEnd(),\n+            '`ActivatedRouteSnapshot.fragment` is nullable.', this.ruleName, replacement));\n+      });\n+    }\n+\n+    return failures;\n+  }\n+}"
        },
        {
            "sha": "93a4fec3f23badaa2a80551d26e3978627d80be2",
            "filename": "packages/core/schematics/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -9,6 +9,7 @@ ts_library(\n     ],\n     deps = [\n         \"//packages/core/schematics/migrations/abstract-control-parent\",\n+        \"//packages/core/schematics/migrations/activated-route-snapshot-fragment\",\n         \"//packages/core/schematics/migrations/can-activate-with-redirect-to\",\n         \"//packages/core/schematics/migrations/dynamic-queries\",\n         \"//packages/core/schematics/migrations/initial-navigation\","
        },
        {
            "sha": "4d352e524f5c7897d17a6a6566c41e3182423e60",
            "filename": "packages/core/schematics/test/activated_route_snapshot_fragment_migration_spec.ts",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Ftest%2Factivated_route_snapshot_fragment_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Ftest%2Factivated_route_snapshot_fragment_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Factivated_route_snapshot_fragment_migration_spec.ts?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -0,0 +1,186 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n+import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n+import {HostTree} from '@angular-devkit/schematics';\n+import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n+import * as shx from 'shelljs';\n+\n+describe('ActivatedRouteSnapshot.fragment migration', () => {\n+  let runner: SchematicTestRunner;\n+  let host: TempScopedNodeJsSyncHost;\n+  let tree: UnitTestTree;\n+  let tmpDirPath: string;\n+  let previousWorkingDir: string;\n+\n+  beforeEach(() => {\n+    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n+    host = new TempScopedNodeJsSyncHost();\n+    tree = new UnitTestTree(new HostTree(host));\n+\n+    writeFile('/tsconfig.json', JSON.stringify({\n+      compilerOptions: {lib: ['es2015'], strictNullChecks: true},\n+    }));\n+    writeFile('/angular.json', JSON.stringify({\n+      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n+    }));\n+    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n+    writeFile('/node_modules/@angular/router.d.ts', `\n+      export declare class ActivatedRoute {\n+        get children(): ActivatedRoute[];\n+        fragment: Observable<string | null>;\n+        snapshot: ActivatedRouteSnapshot;\n+        url: Observable<unknown[]>;\n+      }\n+\n+      export declare class ActivatedRouteSnapshot {\n+        fragment: string | null;\n+        url: unknown[];\n+      }\n+    `);\n+\n+    previousWorkingDir = shx.pwd();\n+    tmpDirPath = getSystemPath(host.root);\n+\n+    // Switch into the temporary directory path. This allows us to run\n+    // the schematic against our custom unit test tree.\n+    shx.cd(tmpDirPath);\n+  });\n+\n+  afterEach(() => {\n+    shx.cd(previousWorkingDir);\n+    shx.rm('-r', tmpDirPath);\n+  });\n+\n+  it('should add non-null assertions to accesses of `ActivatedRouteSnapshot.fragment`',\n+     async () => {\n+       writeFile('/index.ts', `\n+          import {ActivatedRoute} from '@angular/router';\n+\n+          class App {\n+            private _route: ActivatedRoute;\n+\n+            getFragment() {\n+              return this._getSnapshot().fragment.foo;\n+            }\n+\n+            private _getSnapshot() {\n+              return this._route.snapshot;\n+            }\n+          }\n+        `);\n+\n+       await runMigration();\n+\n+       expect(tree.readContent('/index.ts')).toContain('return this._getSnapshot().fragment!.foo');\n+     });\n+\n+  it('should not add non-null assertions to accesses of `ActivatedRouteSnapshot.fragment` if there is one already',\n+     async () => {\n+       writeFile('/index.ts', `\n+        import {ActivatedRoute} from '@angular/router';\n+\n+        class App {\n+          private _route: ActivatedRoute;\n+\n+          getFragment() {\n+            return this._route.snapshot.fragment!.foo;\n+          }\n+        }\n+      `);\n+\n+       await runMigration();\n+\n+       expect(tree.readContent('/index.ts'))\n+           .toContain('return this._route.snapshot.fragment!.foo;');\n+     });\n+\n+  it('should not add non-null assertions if the `ActivatedRouteSnapshot.fragment` has been null checked in an if statement',\n+     async () => {\n+       writeFile('/index.ts', `\n+        import {ActivatedRouteSnapshot} from '@angular/router';\n+\n+        function getFragmentValue(snapshot: ActivatedRouteSnapshot) {\n+          if (snapshot.fragment) {\n+            return snapshot.fragment.value;\n+          }\n+\n+          return null;\n+        }\n+      `);\n+\n+       await runMigration();\n+\n+       const content = tree.readContent('/index.ts');\n+       expect(content).toContain(`if (snapshot.fragment) {`);\n+       expect(content).toContain(`return snapshot.fragment.value;`);\n+     });\n+\n+  it('should not add non-null assertions if the `ActivatedRouteSnapshot.fragment` has been null checked in an else if statement',\n+     async () => {\n+       writeFile('/index.ts', `\n+        import {ActivatedRouteSnapshot} from '@angular/router';\n+\n+        function getSnapshotValue(foo: boolean, snapshot: ActivatedRouteSnapshot) {\n+          if (foo) {\n+            return foo;\n+          } else if (snapshot.fragment) {\n+            return snapshot.fragment.value;\n+          }\n+\n+          return null;\n+        }\n+      `);\n+\n+       await runMigration();\n+\n+       const content = tree.readContent('/index.ts');\n+       expect(content).toContain(`} else if (snapshot.fragment) {`);\n+       expect(content).toContain(`return snapshot.fragment.value;`);\n+     });\n+\n+  it('should not add non-null assertions if the `ActivatedRouteSnapshot.fragment` has been null checked in a ternary expression',\n+     async () => {\n+       writeFile('/index.ts', `\n+        import {ActivatedRouteSnapshot} from '@angular/router';\n+\n+        function getSnapshotValue(snapshot: ActivatedRouteSnapshot) {\n+          return snapshot.fragment ? snapshot.fragment.value : null;\n+        }\n+      `);\n+\n+       await runMigration();\n+\n+       expect(tree.readContent('/index.ts'))\n+           .toContain(`return snapshot.fragment ? snapshot.fragment.value : null;`);\n+     });\n+\n+  it('should not add non-null assertion to `ActivatedRouteSnapshot.fragment` if there is a safe access',\n+     async () => {\n+       writeFile('/index.ts', `\n+        import {ActivatedRouteSnapshot} from '@angular/router';\n+\n+        function getSnapshotValue(snapshot: ActivatedRouteSnapshot) {\n+          return snapshot.fragment?.value;\n+        }\n+      `);\n+\n+       await runMigration();\n+       expect(tree.readContent('/index.ts')).toContain(`return snapshot.fragment?.value;`);\n+     });\n+\n+  function writeFile(filePath: string, contents: string) {\n+    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n+  }\n+\n+  function runMigration() {\n+    return runner.runSchematicAsync('migration-v12-activated-route-snapshot-fragment', {}, tree)\n+        .toPromise();\n+  }\n+});"
        },
        {
            "sha": "19232cf1a90049f20d698e69ce09b4b0b707d2ca",
            "filename": "packages/core/schematics/test/google3/activated_route_snapshot_fragment_spec.ts",
            "status": "added",
            "additions": 210,
            "deletions": 0,
            "changes": 210,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Factivated_route_snapshot_fragment_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Factivated_route_snapshot_fragment_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Factivated_route_snapshot_fragment_spec.ts?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -0,0 +1,210 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {readFileSync, writeFileSync} from 'fs';\n+import {dirname, join} from 'path';\n+import * as shx from 'shelljs';\n+import {Configuration, Linter} from 'tslint';\n+\n+describe('Google3 ActivatedRouteSnapshot.fragment TSLint rule', () => {\n+  const rulesDirectory =\n+      dirname(require.resolve('../../migrations/google3/activatedRouteSnapshotFragmentRule'));\n+\n+  let tmpDir: string;\n+\n+  beforeEach(() => {\n+    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n+    shx.mkdir('-p', tmpDir);\n+\n+    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n+    writeFile('router.d.ts', `\n+      export declare class ActivatedRoute {\n+        get children(): ActivatedRoute[];\n+        fragment: Observable<string | null>;\n+        snapshot: ActivatedRouteSnapshot;\n+        url: Observable<UrlSegment[]>;\n+      }\n+\n+      export declare class ActivatedRouteSnapshot {\n+        fragment: string | null;\n+        url: UrlSegment[];\n+      }\n+    `);\n+\n+    writeFile('tsconfig.json', JSON.stringify({\n+      compilerOptions: {\n+        module: 'es2015',\n+        baseUrl: './',\n+        strictNullChecks: true,\n+        paths: {\n+          '@angular/router': ['router.d.ts'],\n+        }\n+      },\n+    }));\n+  });\n+\n+  afterEach(() => shx.rm('-r', tmpDir));\n+\n+  function runTSLint(fix: boolean) {\n+    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n+    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n+    const config =\n+        Configuration.parseConfigFile({rules: {'activated-route-snapshot-fragment': true}});\n+\n+    program.getRootFileNames().forEach(fileName => {\n+      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n+    });\n+\n+    return linter;\n+  }\n+\n+  function writeFile(fileName: string, content: string) {\n+    writeFileSync(join(tmpDir, fileName), content);\n+  }\n+\n+  function getFile(fileName: string) {\n+    return readFileSync(join(tmpDir, fileName), 'utf8');\n+  }\n+\n+  it('should flag accesses to `ActivatedRouteSnapshot.fragment`', () => {\n+    writeFile('/index.ts', `\n+      import {ActivatedRoute} from '@angular/router';\n+\n+      class App {\n+        private _route: ActivatedRoute;\n+\n+        ngOnInit() {\n+          this._route.fragment.subscribe();\n+        }\n+\n+        getFragment() {\n+          return this._route.snapshot.fragment.foo;\n+        }\n+      }\n+  `);\n+\n+    const linter = runTSLint(false);\n+    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n+    expect(failures).toEqual(['`ActivatedRouteSnapshot.fragment` is nullable.']);\n+  });\n+\n+  it('should add non-null assertions to accesses of `ActivatedRouteSnapshot.fragment`', () => {\n+    writeFile('/index.ts', `\n+      import {ActivatedRoute} from '@angular/router';\n+\n+      class App {\n+        private _route: ActivatedRoute;\n+\n+        getFragment() {\n+          return this._getSnapshot().fragment.foo;\n+        }\n+\n+        private _getSnapshot() {\n+          return this._route.snapshot;\n+        }\n+      }\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(getFile('/index.ts')).toContain('return this._getSnapshot().fragment!.foo');\n+  });\n+\n+  it('should not add non-null assertions to accesses of `ActivatedRouteSnapshot.fragment` if there is one already',\n+     () => {\n+       writeFile('/index.ts', `\n+        import {ActivatedRoute} from '@angular/router';\n+\n+        class App {\n+          private _route: ActivatedRoute;\n+\n+          getFragment() {\n+            return this._route.snapshot.fragment!.foo;\n+          }\n+        }\n+      `);\n+\n+       runTSLint(true);\n+\n+       expect(getFile('/index.ts')).toContain('return this._route.snapshot.fragment!.foo;');\n+     });\n+\n+  it('should not add non-null assertions if the `ActivatedRouteSnapshot.fragment` has been null checked in an if statement',\n+     () => {\n+       writeFile('/index.ts', `\n+        import {ActivatedRouteSnapshot} from '@angular/router';\n+\n+        function getFragmentValue(snapshot: ActivatedRouteSnapshot) {\n+          if (snapshot.fragment) {\n+            return snapshot.fragment.value;\n+          }\n+\n+          return null;\n+        }\n+      `);\n+\n+       runTSLint(true);\n+\n+       const content = getFile('/index.ts');\n+       expect(content).toContain(`if (snapshot.fragment) {`);\n+       expect(content).toContain(`return snapshot.fragment.value;`);\n+     });\n+\n+  it('should not add non-null assertions if the `ActivatedRouteSnapshot.fragment` has been null checked in an else if statement',\n+     () => {\n+       writeFile('/index.ts', `\n+        import {ActivatedRouteSnapshot} from '@angular/router';\n+\n+        function getSnapshotValue(foo: boolean, snapshot: ActivatedRouteSnapshot) {\n+          if (foo) {\n+            return foo;\n+          } else if (snapshot.fragment) {\n+            return snapshot.fragment.value;\n+          }\n+\n+          return null;\n+        }\n+      `);\n+\n+       runTSLint(true);\n+\n+       const content = getFile('/index.ts');\n+       expect(content).toContain(`} else if (snapshot.fragment) {`);\n+       expect(content).toContain(`return snapshot.fragment.value;`);\n+     });\n+\n+  it('should not add non-null assertions if the `ActivatedRouteSnapshot.fragment` has been null checked in a ternary expression',\n+     () => {\n+       writeFile('/index.ts', `\n+        import {ActivatedRouteSnapshot} from '@angular/router';\n+\n+        function getSnapshotValue(snapshot: ActivatedRouteSnapshot) {\n+          return snapshot.fragment ? snapshot.fragment.value : null;\n+        }\n+      `);\n+\n+       runTSLint(true);\n+\n+       expect(getFile('/index.ts'))\n+           .toContain(`return snapshot.fragment ? snapshot.fragment.value : null;`);\n+     });\n+\n+  it('should not add non-null assertion to `ActivatedRouteSnapshot.fragment` if there is a safe access',\n+     () => {\n+       writeFile('/index.ts', `\n+        import {ActivatedRouteSnapshot} from '@angular/router';\n+\n+        function getSnapshotValue(snapshot: ActivatedRouteSnapshot) {\n+          return snapshot.fragment?.value;\n+        }\n+      `);\n+\n+       runTSLint(true);\n+       expect(getFile('/index.ts')).toContain(`return snapshot.fragment?.value;`);\n+     });\n+});"
        },
        {
            "sha": "f14f4ef46b80b0cea90471d6d9734a1024e1c120",
            "filename": "packages/core/schematics/utils/typescript/nodes.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fnodes.ts",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fnodes.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fnodes.ts?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -26,3 +26,43 @@ export function closestNode<T extends ts.Node>(node: ts.Node, kind: ts.SyntaxKin\n \n   return null;\n }\n+\n+/**\n+ * Checks whether a particular node is part of a null check. E.g. given:\n+ * `foo.bar ? foo.bar.value : null` the null check would be `foo.bar`.\n+ */\n+export function isNullCheck(node: ts.Node): boolean {\n+  if (!node.parent) {\n+    return false;\n+  }\n+\n+  // `foo.bar && foo.bar.value` where `node` is `foo.bar`.\n+  if (ts.isBinaryExpression(node.parent) && node.parent.left === node) {\n+    return true;\n+  }\n+\n+  // `foo.bar && foo.bar.parent && foo.bar.parent.value`\n+  // where `node` is `foo.bar`.\n+  if (node.parent.parent && ts.isBinaryExpression(node.parent.parent) &&\n+      node.parent.parent.left === node.parent) {\n+    return true;\n+  }\n+\n+  // `if (foo.bar) {...}` where `node` is `foo.bar`.\n+  if (ts.isIfStatement(node.parent) && node.parent.expression === node) {\n+    return true;\n+  }\n+\n+  // `foo.bar ? foo.bar.value : null` where `node` is `foo.bar`.\n+  if (ts.isConditionalExpression(node.parent) && node.parent.condition === node) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+/** Checks whether a property access is safe (e.g. `foo.parent?.value`). */\n+export function isSafeAccess(node: ts.Node): boolean {\n+  return node.parent != null && ts.isPropertyAccessExpression(node.parent) &&\n+      node.parent.expression === node && node.parent.questionDotToken != null;\n+}"
        },
        {
            "sha": "a63cc3a98964835ba2d90b1d1d307a4570b965af",
            "filename": "packages/core/schematics/utils/typescript/symbol.ts",
            "status": "modified",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/angular/angular/blob/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fsymbol.ts",
            "raw_url": "https://github.com/angular/angular/raw/190fa07b9a416defb581d2bf76d1deef7baefce6/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fsymbol.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fsymbol.ts?ref=190fa07b9a416defb581d2bf76d1deef7baefce6",
            "patch": "@@ -27,3 +27,57 @@ export function isReferenceToImport(\n   return !!(nodeSymbol && importSymbol) &&\n       nodeSymbol.valueDeclaration === importSymbol.valueDeclaration;\n }\n+\n+/** Checks whether a node's type is nullable (`null`, `undefined` or `void`). */\n+export function isNullableType(typeChecker: ts.TypeChecker, node: ts.Node) {\n+  // Skip expressions in the form of `foo.bar!.baz` since the `TypeChecker` seems\n+  // to identify them as null, even though the user indicated that it won't be.\n+  if (node.parent && ts.isNonNullExpression(node.parent)) {\n+    return false;\n+  }\n+\n+  const type = typeChecker.getTypeAtLocation(node);\n+  const typeNode = typeChecker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.None);\n+  let hasSeenNullableType = false;\n+\n+  // Trace the type of the node back to a type node, walk\n+  // through all of its sub-nodes and look for nullable tyes.\n+  if (typeNode) {\n+    (function walk(current: ts.Node) {\n+      if (current.kind === ts.SyntaxKind.NullKeyword ||\n+          current.kind === ts.SyntaxKind.UndefinedKeyword ||\n+          current.kind === ts.SyntaxKind.VoidKeyword) {\n+        hasSeenNullableType = true;\n+        // Note that we don't descend into type literals, because it may cause\n+        // us to mis-identify the root type as nullable, because it has a nullable\n+        // property (e.g. `{ foo: string | null }`).\n+      } else if (!hasSeenNullableType && !ts.isTypeLiteralNode(current)) {\n+        current.forEachChild(walk);\n+      }\n+    })(typeNode);\n+  }\n+\n+  return hasSeenNullableType;\n+}\n+\n+/**\n+ * Walks through the types and sub-types of a node, looking for a\n+ * type that has the same name as one of the passed-in ones.\n+ */\n+export function hasOneOfTypes(\n+    typeChecker: ts.TypeChecker, node: ts.Node, types: string[]): boolean {\n+  const type = typeChecker.getTypeAtLocation(node);\n+  const typeNode =\n+      type ? typeChecker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.None) : undefined;\n+  let hasMatch = false;\n+  if (typeNode) {\n+    (function walk(current: ts.Node) {\n+      if (ts.isIdentifier(current) && types.includes(current.text)) {\n+        hasMatch = true;\n+      } else if (!hasMatch && !ts.isTypeLiteralNode(current)) {\n+        current.forEachChild(walk);\n+      }\n+    })(typeNode);\n+  }\n+  return hasMatch;\n+}"
        }
    ],
    "stats": {
        "total": 803,
        "additions": 698,
        "deletions": 105
    }
}