{
    "author": "petebacondarwin",
    "message": "fix(ngcc): compute the correct package paths for target entry-points (#40376)\n\nPreviously, if there were path-mapped entry-points, where one contaied the\nstring of another - for example `worker-client` and `worker` - then the\nbase paths were incorrectly computed resulting in the wrong package path\nfor the longer entry-point. This was because, when searching for a matching\nbase path, the strings were tested using `startsWith()`, whereas we should\nonly match if the path was contained in a directory from a file-system\npoint of view.\n\nNow we not only check whether the target path \"starts with\" the base path\nbut then also whether the target path is actually contained in the base path\nusing `fs.relative()`.\n\nFixes #40352\nFixes #40357\n\nPR Close #40376",
    "sha": "afd11662a36f1954c3af9db0f110db9e1130a0c0",
    "files": [
        {
            "sha": "9b729e2183c87532ad0fd18901820673097e3751",
            "filename": "packages/compiler-cli/ngcc/src/entry_point_finder/targeted_entry_point_finder.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 2,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/afd11662a36f1954c3af9db0f110db9e1130a0c0/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Ftargeted_entry_point_finder.ts",
            "raw_url": "https://github.com/angular/angular/raw/afd11662a36f1954c3af9db0f110db9e1130a0c0/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Ftargeted_entry_point_finder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Ftargeted_entry_point_finder.ts?ref=afd11662a36f1954c3af9db0f110db9e1130a0c0",
            "patch": "@@ -119,7 +119,7 @@ export class TargetedEntryPointFinder extends TracingEntryPointFinder {\n   private computePackagePath(entryPointPath: AbsoluteFsPath): AbsoluteFsPath {\n     // First try the main basePath, to avoid having to compute the other basePaths from the paths\n     // mappings, which can be computationally intensive.\n-    if (entryPointPath.startsWith(this.basePath)) {\n+    if (this.isPathContainedBy(this.basePath, entryPointPath)) {\n       const packagePath = this.computePackagePathFromContainingPath(entryPointPath, this.basePath);\n       if (packagePath !== null) {\n         return packagePath;\n@@ -129,7 +129,7 @@ export class TargetedEntryPointFinder extends TracingEntryPointFinder {\n     // The main `basePath` didn't work out so now we try the `basePaths` computed from the paths\n     // mappings in `tsconfig.json`.\n     for (const basePath of this.getBasePaths()) {\n-      if (entryPointPath.startsWith(basePath)) {\n+      if (this.isPathContainedBy(basePath, entryPointPath)) {\n         const packagePath = this.computePackagePathFromContainingPath(entryPointPath, basePath);\n         if (packagePath !== null) {\n           return packagePath;\n@@ -147,6 +147,18 @@ export class TargetedEntryPointFinder extends TracingEntryPointFinder {\n     return this.computePackagePathFromNearestNodeModules(entryPointPath);\n   }\n \n+  /**\n+   * Compute whether the `test` path is contained within the `base` path.\n+   *\n+   * Note that this doesn't use a simple `startsWith()` since that would result in a false positive\n+   * for `test` paths such as `a/b/c-x` when the `base` path is `a/b/c`.\n+   *\n+   * Since `fs.relative()` can be quite expensive we check the fast possibilities first.\n+   */\n+  private isPathContainedBy(base: AbsoluteFsPath, test: AbsoluteFsPath): boolean {\n+    return test === base ||\n+        (test.startsWith(base) && !this.fs.relative(base, test).startsWith('..'));\n+  }\n \n   /**\n    * Search down to the `entryPointPath` from the `containingPath` for the first `package.json` that"
        },
        {
            "sha": "87885a2c9bb2300014d9722a766a1bd4ca64ab0a",
            "filename": "packages/compiler-cli/ngcc/test/entry_point_finder/targeted_entry_point_finder_spec.ts",
            "status": "modified",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/angular/angular/blob/afd11662a36f1954c3af9db0f110db9e1130a0c0/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fentry_point_finder%2Ftargeted_entry_point_finder_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/afd11662a36f1954c3af9db0f110db9e1130a0c0/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fentry_point_finder%2Ftargeted_entry_point_finder_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fentry_point_finder%2Ftargeted_entry_point_finder_spec.ts?ref=afd11662a36f1954c3af9db0f110db9e1130a0c0",
            "patch": "@@ -355,6 +355,56 @@ runInEachFileSystem(() => {\n            ]);\n          });\n \n+      it('should correctly compute the package path for a target whose name contains the string of another package',\n+         () => {\n+           // Create the \"my-lib\" package - it doesn't need to be a real entry-point\n+           const myLibPath = _Abs('/project/dist/my-lib');\n+           loadTestFiles([{\n+             name: fs.resolve(myLibPath, 'package.json'),\n+             contents: JSON.stringify({name: 'my-lib'})\n+           }]);\n+\n+           // Create the \"my-lib-other\" Angular entry-point\n+           const myLibOtherPath = _Abs('/project/dist/my-lib-other');\n+           loadTestFiles([\n+             {\n+               name: fs.resolve(myLibOtherPath, 'package.json'),\n+               contents: JSON.stringify({\n+                 name: `my-lib-other`,\n+                 typings: `./my-lib-other.d.ts`,\n+                 fesm2015: `./fesm2015/my-lib-other.js`,\n+                 esm5: `./esm5/my-lib-other.js`,\n+                 main: `./common/my-lib-other.js`,\n+               })\n+             },\n+             {name: fs.resolve(myLibOtherPath, 'my-lib-other.metadata.json'), contents: 'metadata'},\n+             {name: fs.resolve(myLibOtherPath, 'my-lib-other.d.ts'), contents: 'typings'},\n+             {name: fs.resolve(myLibOtherPath, 'fesm2015/my-lib-other.js'), contents: ''},\n+             {name: fs.resolve(myLibOtherPath, 'esm5/my-lib-other.js'), contents: ''},\n+             {name: fs.resolve(myLibOtherPath, 'commonjs/my-lib-other.js'), contents: ''},\n+           ]);\n+\n+           const basePath = _Abs('/project/node_modules');\n+           const pathMappings: PathMappings = {\n+             baseUrl: '/project',\n+             paths: {\n+               'lib1': ['dist/my-lib'],\n+               'lib2': ['dist/my-lib-other'],\n+             }\n+           };\n+\n+           const srcHost = new EsmDependencyHost(fs, new ModuleResolver(fs, pathMappings));\n+           const dtsHost = new DtsDependencyHost(fs, pathMappings);\n+           resolver = new DependencyResolver(fs, logger, config, {esm2015: srcHost}, dtsHost);\n+           const finder = new TargetedEntryPointFinder(\n+               fs, config, logger, resolver, basePath, pathMappings, myLibOtherPath);\n+           const {entryPoints} = finder.findEntryPoints();\n+\n+           expect(dumpEntryPointPaths(basePath, entryPoints)).toEqual([\n+             ['../dist/my-lib-other', '../dist/my-lib-other'],\n+           ]);\n+         });\n+\n       it('should handle pathMappings that map to files or non-existent directories', () => {\n         const basePath = _Abs('/path_mapped/node_modules');\n         const targetPath = _Abs('/path_mapped/node_modules/test');"
        }
    ],
    "stats": {
        "total": 66,
        "additions": 64,
        "deletions": 2
    }
}