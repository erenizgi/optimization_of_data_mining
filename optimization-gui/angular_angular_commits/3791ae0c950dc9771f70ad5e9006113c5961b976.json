{
    "author": "atscott",
    "message": "refactor(router): Adjust behavior for computed navigation restoration (#42751)\n\nWhen another navigation is triggered during an in-process navigation and\nthe `canceledNavigationResolution` is `'computed'`, we should not\nattempt to restore the browser history using `history.go`. Doing that\nwould trigger a third navigation through the router which would conflict\nwith the new navigation that we were trying to process. Instead, we\ntreat this as a redirect and skip the history restoration attempt. This\nacts similarly to returning `UrlTree` from a guard.\n\nFixes issue described in https://github.com/angular/angular/pull/38884#issuecomment-863767152\n\nPR Close #42751",
    "sha": "3791ae0c950dc9771f70ad5e9006113c5961b976",
    "files": [
        {
            "sha": "b62672a85f40735e9102ca9dfcc2740536ce34ac",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 58,
            "deletions": 29,
            "changes": 87,
            "blob_url": "https://github.com/angular/angular/blob/3791ae0c950dc9771f70ad5e9006113c5961b976/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/3791ae0c950dc9771f70ad5e9006113c5961b976/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=3791ae0c950dc9771f70ad5e9006113c5961b976",
            "patch": "@@ -33,7 +33,6 @@ import {Checks, getAllRouteGuards} from './utils/preactivation';\n import {isUrlTree} from './utils/type_guards';\n \n \n-\n /**\n  * @description\n  *\n@@ -384,7 +383,6 @@ export const subsetMatchOptions: IsActiveMatchOptions = {\n   queryParams: 'subset'\n };\n \n-\n /**\n  * @description\n  *\n@@ -419,8 +417,20 @@ export class Router {\n   /**\n    * The id of the currently active page in the router.\n    * Updated to the transition's target id on a successful navigation.\n+   *\n+   * This is used to track what page the router last activated. When an attempted navigation fails,\n+   * the router can then use this to compute how to restore the state back to the previously active\n+   * page.\n    */\n   private currentPageId: number = 0;\n+  /**\n+   * The ɵrouterPageId of whatever page is currently active in the browser history. This is\n+   * important for computing the target page id for new navigations because we need to ensure each\n+   * page id in the browser history is 1 more than the previous entry.\n+   */\n+  private get browserPageId(): number|undefined {\n+    return (this.location.getState() as RestoredState | null)?.ɵrouterPageId;\n+  }\n   private configLoader: RouterConfigLoader;\n   private ngModule: NgModuleRef<any>;\n   private console: Console;\n@@ -761,7 +771,7 @@ export class Router {\n \n                      filter(t => {\n                        if (!t.guardsResult) {\n-                         this.cancelNavigationTransition(t, '');\n+                         this.cancelNavigationTransitionRestoreHistory(t, '');\n                          return false;\n                        }\n                        return true;\n@@ -786,7 +796,7 @@ export class Router {\n                                      next: () => dataResolved = true,\n                                      complete: () => {\n                                        if (!dataResolved) {\n-                                         this.cancelNavigationTransition(\n+                                         this.cancelNavigationTransitionRestoreHistory(\n                                              t,\n                                              `At least one route resolver didn't emit any value.`);\n                                        }\n@@ -869,17 +879,28 @@ export class Router {\n                         * event is fired when a navigation gets cancelled but not caught by other\n                         * means. */\n                        if (!completed && !errored) {\n-                         // Must reset to current URL tree here to ensure history.state is set. On a\n-                         // fresh page load, if a new navigation comes in before a successful\n-                         // navigation completes, there will be nothing in\n-                         // history.state.navigationId. This can cause sync problems with AngularJS\n-                         // sync code which looks for a value here in order to determine whether or\n-                         // not to handle a given popstate event or to leave it to the Angular\n-                         // router.\n-                         this.cancelNavigationTransition(\n-                             t,\n-                             `Navigation ID ${t.id} is not equal to the current navigation id ${\n-                                 this.navigationId}`);\n+                         const cancelationReason = `Navigation ID ${\n+                             t.id} is not equal to the current navigation id ${this.navigationId}`;\n+                         if (this.canceledNavigationResolution === 'replace') {\n+                           // Must reset to current URL tree here to ensure history.state is set. On\n+                           // a fresh page load, if a new navigation comes in before a successful\n+                           // navigation completes, there will be nothing in\n+                           // history.state.navigationId. This can cause sync problems with\n+                           // AngularJS sync code which looks for a value here in order to determine\n+                           // whether or not to handle a given popstate event or to leave it to the\n+                           // Angular router.\n+                           this.cancelNavigationTransitionRestoreHistory(t, cancelationReason);\n+                         } else {\n+                           // We cannot trigger a `location.historyGo` if the\n+                           // cancellation was due to a new navigation before the previous could\n+                           // complete. This is because `location.historyGo` triggers a `popstate`\n+                           // which would also trigger another navigation. Instead, treat this as a\n+                           // redirect and do not reset the state.\n+                           this.cancelNavigationTransition(t, cancelationReason);\n+                           // TODO(atscott): The same problem happens here with a fresh page load\n+                           // and a new navigation before that completes where we won't set a page\n+                           // id.\n+                         }\n                        }\n                        // currentNavigation should always be reset to null here. If navigation was\n                        // successful, lastSuccessfulTransition will have already been set. Therefore\n@@ -993,9 +1014,9 @@ export class Router {\n     if (!this.locationSubscription) {\n       this.locationSubscription = this.location.subscribe(event => {\n         const currentChange = this.extractLocationChangeInfoFromEvent(event);\n+        // The `setTimeout` was added in #12160 and is likely to support Angular/AngularJS\n+        // hybrid apps.\n         if (this.shouldScheduleNavigation(this.lastLocationChangeInfo, currentChange)) {\n-          // The `setTimeout` was added in #12160 and is likely to support Angular/AngularJS\n-          // hybrid apps.\n           setTimeout(() => {\n             const {source, state, urlTree} = currentChange;\n             const extras: NavigationExtras = {replaceUrl: true};\n@@ -1213,15 +1234,7 @@ export class Router {\n     const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n     const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n \n-    let restoredState: RestoredState|null = null;\n-    if (this.canceledNavigationResolution === 'computed') {\n-      const isInitialPage = this.currentPageId === 0;\n-      if (isInitialPage || extras.skipLocationChange || extras.replaceUrl) {\n-        restoredState = this.location.getState() as RestoredState | null;\n-      }\n-    }\n-\n-    return this.scheduleNavigation(mergedTree, 'imperative', restoredState, extras);\n+    return this.scheduleNavigation(mergedTree, 'imperative', null, extras);\n   }\n \n   /**\n@@ -1345,6 +1358,7 @@ export class Router {\n     if (this.disposed) {\n       return Promise.resolve(false);\n     }\n+\n     // * Imperative navigations (router.navigate) might trigger additional navigations to the same\n     //   URL via a popstate event and the locationChangeListener. We should skip these duplicate\n     //   navs. Duplicates may also be triggered by attempts to sync AngularJS and Angular router\n@@ -1388,12 +1402,23 @@ export class Router {\n     const id = ++this.navigationId;\n     let targetPageId: number;\n     if (this.canceledNavigationResolution === 'computed') {\n+      const isInitialPage = this.currentPageId === 0;\n+      if (isInitialPage) {\n+        restoredState = this.location.getState() as RestoredState | null;\n+      }\n       // If the `ɵrouterPageId` exist in the state then `targetpageId` should have the value of\n-      // `ɵrouterPageId`\n+      // `ɵrouterPageId`. This is the case for something like a page refresh where we assign the\n+      // target id to the previously set value for that page.\n       if (restoredState && restoredState.ɵrouterPageId) {\n         targetPageId = restoredState.ɵrouterPageId;\n       } else {\n-        targetPageId = this.currentPageId + 1;\n+        // If we're replacing the URL or doing a silent navigation, we do not want to increment the\n+        // page id because we aren't pushing a new entry to history.\n+        if (extras.replaceUrl || extras.skipLocationChange) {\n+          targetPageId = this.browserPageId ?? 0;\n+        } else {\n+          targetPageId = (this.browserPageId ?? 0) + 1;\n+        }\n       }\n     } else {\n       // This is unused when `canceledNavigationResolution` is not computed.\n@@ -1453,7 +1478,7 @@ export class Router {\n    * - triggers the `NavigationCancel` event\n    * - resolves the transition promise with `false`\n    */\n-  private cancelNavigationTransition(t: NavigationTransition, reason: string) {\n+  private cancelNavigationTransitionRestoreHistory(t: NavigationTransition, reason: string) {\n     if (this.canceledNavigationResolution === 'computed') {\n       // The navigator change the location before triggered the browser event,\n       // so we need to go back to the current url if the navigation is canceled.\n@@ -1470,6 +1495,10 @@ export class Router {\n     } else {\n       this.resetUrlToCurrentUrlTree();\n     }\n+    this.cancelNavigationTransition(t, reason);\n+  }\n+\n+  private cancelNavigationTransition(t: NavigationTransition, reason: string) {\n     const navCancel = new NavigationCancel(t.id, this.serializeUrl(t.extractedUrl), reason);\n     this.triggerEvent(navCancel);\n     t.resolve(false);"
        },
        {
            "sha": "fb5211f2d51ada25b7939a624276093906b2b999",
            "filename": "packages/router/test/integration.spec.ts",
            "status": "modified",
            "additions": 106,
            "deletions": 31,
            "changes": 137,
            "blob_url": "https://github.com/angular/angular/blob/3791ae0c950dc9771f70ad5e9006113c5961b976/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/3791ae0c950dc9771f70ad5e9006113c5961b976/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fintegration.spec.ts?ref=3791ae0c950dc9771f70ad5e9006113c5961b976",
            "patch": "@@ -18,6 +18,7 @@ import {delay, filter, first, map, mapTo, tap} from 'rxjs/operators';\n \n import {RouterInitializer} from '../src/router_module';\n import {forEach} from '../src/utils/collection';\n+import {isUrlTree} from '../src/utils/type_guards';\n import {RouterTestingModule, SpyNgModuleFactoryLoader} from '../testing';\n \n describe('Integration', () => {\n@@ -2740,7 +2741,6 @@ describe('Integration', () => {\n \n         const url = path + (query.length > 0 ? ('?' + query) : '');\n         this.urlChanges.push(url);\n-        this._subject.emit({'url': url, 'pop': false});\n       }\n \n       replaceState(path: string, query: string = '', state: any = null) {\n@@ -2825,7 +2825,16 @@ describe('Integration', () => {\n     @Injectable({providedIn: 'root'})\n     class MyCanActivateGuard implements CanActivate {\n       allow: boolean = true;\n-      canActivate(): boolean {\n+      redirectTo: string|null|UrlTree = null;\n+\n+      constructor(private router: Router) {}\n+\n+      canActivate(): boolean|UrlTree {\n+        if (typeof this.redirectTo === 'string') {\n+          this.router.navigateByUrl(this.redirectTo);\n+        } else if (isUrlTree(this.redirectTo)) {\n+          return this.redirectTo;\n+        }\n         return this.allow;\n       }\n     }\n@@ -2879,16 +2888,23 @@ describe('Integration', () => {\n           canActivate: [MyCanActivateGuard],\n           resolve: [MyResolve]\n         },\n+        {\n+          path: 'unguarded',\n+          component: SimpleCmp,\n+        },\n         {path: 'loaded', loadChildren: () => of(LoadedModule), canLoad: ['alwaysFalse']}\n       ]);\n       router.navigateByUrl('/first');\n       advance(fixture);\n+      expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n \n       router.navigateByUrl('/second');\n       advance(fixture);\n+      expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n \n       router.navigateByUrl('/third');\n       advance(fixture);\n+      expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n \n       location.back();\n       advance(fixture);\n@@ -2898,30 +2914,30 @@ describe('Integration', () => {\n          const location = TestBed.inject(Location);\n          const router = TestBed.inject(Router);\n          expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n \n          TestBed.inject(MyCanActivateGuard).allow = false;\n          location.back();\n          advance(fixture);\n          expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n \n          TestBed.inject(MyCanActivateGuard).allow = true;\n          location.back();\n          advance(fixture);\n          expect(location.path()).toEqual('/first');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n \n          TestBed.inject(MyCanActivateGuard).allow = false;\n          location.forward();\n          advance(fixture);\n          expect(location.path()).toEqual('/first');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n \n          router.navigateByUrl('/second');\n          advance(fixture);\n          expect(location.path()).toEqual('/first');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n        }));\n \n \n@@ -2933,56 +2949,56 @@ describe('Integration', () => {\n          location.back();\n          advance(fixture);\n          expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n \n          location.forward();\n          advance(fixture);\n          expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n \n          router.navigateByUrl('third');\n          advance(fixture);\n          expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n \n \n          TestBed.inject(MyCanDeactivateGuard).allow = true;\n          location.forward();\n          advance(fixture);\n          expect(location.path()).toEqual('/third');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 4}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n        }));\n \n     it('should work when using `NavigationExtras.skipLocationChange`', fakeAsync(() => {\n          const location = TestBed.inject(Location);\n          const router = TestBed.inject(Router);\n \n          expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n \n          router.navigateByUrl('/first', {skipLocationChange: true});\n          advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n \n          router.navigateByUrl('/third');\n          advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 4}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n \n          location.back();\n          advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n        }));\n \n     it('should work when using `NavigationExtras.replaceUrl`', fakeAsync(() => {\n          const location = TestBed.inject(Location);\n          const router = TestBed.inject(Router);\n \n          expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n \n          router.navigateByUrl('/first', {replaceUrl: true});\n          advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n          expect(location.path()).toEqual('/first');\n        }));\n \n@@ -2993,53 +3009,53 @@ describe('Integration', () => {\n          router.navigateByUrl('/loaded');\n          advance(fixture);\n          expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n        }));\n \n     it('should work when resolve empty', fakeAsync(() => {\n          const location = TestBed.inject(Location);\n          const router = TestBed.inject(Router);\n \n          expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n \n          TestBed.inject(MyResolve).myresolve = EMPTY;\n \n          location.back();\n          advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n          expect(location.path()).toEqual('/second');\n \n          TestBed.inject(MyResolve).myresolve = of(2);\n \n          location.back();\n          advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n          expect(location.path()).toEqual('/first');\n \n          TestBed.inject(MyResolve).myresolve = EMPTY;\n \n          // We should cancel the navigation to `/third` when myresolve is empty\n          router.navigateByUrl('/third');\n          advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n          expect(location.path()).toEqual('/first');\n \n          location.historyGo(2);\n          advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n          expect(location.path()).toEqual('/first');\n \n          TestBed.inject(MyResolve).myresolve = of(2);\n          location.historyGo(2);\n          advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 4}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n          expect(location.path()).toEqual('/third');\n \n          TestBed.inject(MyResolve).myresolve = EMPTY;\n          location.historyGo(-2);\n          advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 4}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n          expect(location.path()).toEqual('/third');\n        }));\n \n@@ -3049,37 +3065,96 @@ describe('Integration', () => {\n          const router = TestBed.inject(Router);\n \n          expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n \n \n          router.navigateByUrl('/invalid').catch(() => null);\n          advance(fixture);\n          expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n \n          location.back();\n          advance(fixture);\n          expect(location.path()).toEqual('/first');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n        }));\n \n-    it('should work when urlUpdateStrategy=\"eagar\"', fakeAsync(() => {\n+    it('should work when urlUpdateStrategy=\"eager\"', fakeAsync(() => {\n          const location = TestBed.inject(Location) as SpyLocation;\n          const router = TestBed.inject(Router);\n          expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n          router.urlUpdateStrategy = 'eager';\n \n          TestBed.inject(MyCanActivateGuard).allow = false;\n          router.navigateByUrl('/first');\n          advance(fixture);\n          expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n \n          location.back();\n          advance(fixture);\n          expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+       }));\n+\n+    it('should work when CanActivate redirects', fakeAsync(() => {\n+         const location = TestBed.inject(Location);\n+\n+         TestBed.inject(MyCanActivateGuard).redirectTo = '/unguarded';\n+         location.back();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/unguarded');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+         TestBed.inject(MyCanActivateGuard).redirectTo = null;\n+\n+         location.back();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/first');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+       }));\n+\n+    it('should work when CanActivate redirects and urlUpdateStrategy=\"eager\"', fakeAsync(() => {\n+         const location = TestBed.inject(Location);\n+         const router = TestBed.inject(Router);\n+         router.urlUpdateStrategy = 'eager';\n+\n+         TestBed.inject(MyCanActivateGuard).redirectTo = '/unguarded';\n+         router.navigateByUrl('/third');\n+         advance(fixture);\n+         expect(location.path()).toEqual('/unguarded');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 4}));\n+\n+         TestBed.inject(MyCanActivateGuard).redirectTo = null;\n+\n+         location.back();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/third');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+       }));\n+\n+    it('should work when CanActivate redirects with UrlTree and urlUpdateStrategy=\"eager\"',\n+       fakeAsync(() => {\n+         // Note that this test is different from the above case because we are able to specifically\n+         // handle the `UrlTree` case as a proper redirect and set `replaceUrl: true` on the\n+         // follow-up navigation.\n+         const location = TestBed.inject(Location);\n+         const router = TestBed.inject(Router);\n+         router.urlUpdateStrategy = 'eager';\n+\n+         TestBed.inject(MyCanActivateGuard).redirectTo = router.createUrlTree(['unguarded']);\n+         router.navigateByUrl('/third');\n+         advance(fixture);\n+         expect(location.path()).toEqual('/unguarded');\n          expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+         TestBed.inject(MyCanActivateGuard).redirectTo = null;\n+\n+         location.back();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n        }));\n   });\n   describe('guards', () => {"
        }
    ],
    "stats": {
        "total": 224,
        "additions": 164,
        "deletions": 60
    }
}