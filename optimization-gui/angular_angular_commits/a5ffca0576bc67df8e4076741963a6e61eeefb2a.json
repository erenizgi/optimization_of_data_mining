{
    "author": "atscott",
    "message": "fix(router): fix navigation ignoring logic to compare to the browser url (#37716)\n\nThis PR changes the logic for determining when to skip route processing from\nusing the URL of the last attempted navigation to the actual resulting URL after\nthat transition.\n\nBecause guards may prevent navigation and reset the browser URL, the raw\nURL of the previous transition may not match the actual URL of the\nbrowser at the end of the navigation process. For that reason, we need to use\n`urlAfterRedirects` instead.\n\nOther notes:\nThese checks in scheduleNavigation were added in https://github.com/angular/angular/commit/eb2ceff4ba19a09a5f400f81e371ec176878cd37\nThe test still passes and, more surprisingly, passes if the checks are removed\ncompletely. There have likely been changes to the navigation handling that\nhandle the test in a different way. That said, it still appears to be important\nto keep the checks there in some capacity because it does affect how many\nnavigation events occur. This addresses an issue that came up in #16710: https://github.com/angular/angular/issues/16710#issuecomment-634869739\nThis also partially addresses #13586 in fixing history for imperative\nnavigations that are cancelled by guards.\n\nPR Close #37716",
    "sha": "a5ffca0576bc67df8e4076741963a6e61eeefb2a",
    "files": [
        {
            "sha": "f8508655c2c9f3d3982e552a4337d166719de2cb",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 5,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/a5ffca0576bc67df8e4076741963a6e61eeefb2a/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/a5ffca0576bc67df8e4076741963a6e61eeefb2a/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=a5ffca0576bc67df8e4076741963a6e61eeefb2a",
            "patch": "@@ -1126,12 +1126,28 @@ export class Router {\n       rawUrl: UrlTree, source: NavigationTrigger, restoredState: RestoredState|null,\n       extras: NavigationExtras,\n       priorPromise?: {resolve: any, reject: any, promise: Promise<boolean>}): Promise<boolean> {\n+    // * Imperative navigations (router.navigate) might trigger additional navigations to the same\n+    //   URL via a popstate event and the locationChangeListener. We should skip these duplicate\n+    //   navs. Duplicates may also be triggered by attempts to sync AngularJS and Angular router\n+    //   states.\n+    // * Imperative navigations can be cancelled by router guards, meaning the URL won't change. If\n+    //   the user follows that with a navigation using the back/forward button or manual URL change,\n+    //   the destination may be the same as the previous imperative attempt. We should not skip\n+    //   these navigations because it's a separate case from the one above -- it's not a duplicate\n+    //   navigation.\n     const lastNavigation = this.getTransition();\n-    // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),\n-    // and that navigation results in 'replaceState' that leads to the same URL,\n-    // we should skip those.\n-    if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&\n-        lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n+    // We don't want to skip duplicate successful navs if they're imperative because\n+    // onSameUrlNavigation could be 'reload' (so the duplicate is intended).\n+    const browserNavPrecededByRouterNav =\n+        source !== 'imperative' && lastNavigation?.source === 'imperative';\n+    const lastNavigationSucceeded = this.lastSuccessfulId === lastNavigation.id;\n+    // If the last navigation succeeded or is in flight, we can use the rawUrl as the comparison.\n+    // However, if it failed, we should compare to the final result (urlAfterRedirects).\n+    const lastNavigationUrl = (lastNavigationSucceeded || this.currentNavigation) ?\n+        lastNavigation.rawUrl :\n+        lastNavigation.urlAfterRedirects;\n+    const duplicateNav = lastNavigationUrl.toString() === rawUrl.toString();\n+    if (browserNavPrecededByRouterNav && duplicateNav) {\n       return Promise.resolve(true);  // return value is not used\n     }\n "
        },
        {
            "sha": "8b3d5d23c10fdb4daa24b812af9594680f5803dd",
            "filename": "packages/router/test/integration.spec.ts",
            "status": "modified",
            "additions": 182,
            "deletions": 5,
            "changes": 187,
            "blob_url": "https://github.com/angular/angular/blob/a5ffca0576bc67df8e4076741963a6e61eeefb2a/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a5ffca0576bc67df8e4076741963a6e61eeefb2a/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fintegration.spec.ts?ref=a5ffca0576bc67df8e4076741963a6e61eeefb2a",
            "patch": "@@ -909,7 +909,7 @@ describe('Integration', () => {\n        expect(cmp.recordedUrls()).toEqual(['one/two', 'three/four']);\n      })));\n \n-  describe('should reset location if a navigation by location is successful', () => {\n+  describe('duplicate in-flight navigations', () => {\n     beforeEach(() => {\n       TestBed.configureTestingModule({\n         providers: [{\n@@ -924,7 +924,29 @@ describe('Integration', () => {\n       });\n     });\n \n-    it('work', fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+    it('should ignore the duplicate resulting from a location sync', fakeAsync(() => {\n+         const router = TestBed.inject(Router);\n+         const fixture = createRoot(router, RootCmp);\n+         const location = TestBed.inject(Location) as SpyLocation;\n+         router.resetConfig([{path: 'simple', component: SimpleCmp, canActivate: ['in1Second']}]);\n+\n+         const recordedEvents: any[] = [];\n+         router.events.forEach(e => onlyNavigationStartAndEnd(e) && recordedEvents.push(e));\n+\n+         // setTimeout used so this navigation resolves at the same time as the one that results\n+         // from the location PopStateEvent (see Router#setUpLocationChangeListener).\n+         setTimeout(() => {\n+           router.navigateByUrl('/simple');\n+         }, 0);\n+         location.simulateUrlPop('/simple');\n+         tick(1000);\n+         advance(fixture);\n+         expectEvents(recordedEvents, [[NavigationStart, '/simple'], [NavigationEnd, '/simple']]);\n+       }));\n+\n+    it('should reset location if a navigation by location is successful', fakeAsync(() => {\n+         const router = TestBed.inject(Router);\n+         const location = TestBed.inject(Location) as SpyLocation;\n          const fixture = createRoot(router, RootCmp);\n \n          router.resetConfig([{path: 'simple', component: SimpleCmp, canActivate: ['in1Second']}]);\n@@ -936,14 +958,14 @@ describe('Integration', () => {\n          // - location change 'simple'\n          // - the first location change gets canceled, the URL gets reset to '/'\n          // - the second location change gets finished, the URL should be reset to '/simple'\n-         (<any>location).simulateUrlPop('/simple');\n-         (<any>location).simulateUrlPop('/simple');\n+         location.simulateUrlPop('/simple');\n+         location.simulateUrlPop('/simple');\n \n          tick(2000);\n          advance(fixture);\n \n          expect(location.path()).toEqual('/simple');\n-       })));\n+       }));\n   });\n \n   it('should support secondary routes', fakeAsync(inject([Router], (router: Router) => {\n@@ -2569,6 +2591,161 @@ describe('Integration', () => {\n            })));\n       });\n \n+      describe('should not break the history', () => {\n+        @Injectable({providedIn: 'root'})\n+        class MyGuard implements CanDeactivate<any> {\n+          allow: boolean = true;\n+          canDeactivate(): boolean {\n+            return this.allow;\n+          }\n+        }\n+\n+        @Component({selector: 'parent', template: '<router-outlet></router-outlet>'})\n+        class Parent {\n+        }\n+\n+        @Component({selector: 'home', template: 'home'})\n+        class Home {\n+        }\n+\n+        @Component({selector: 'child1', template: 'child1'})\n+        class Child1 {\n+        }\n+\n+        @Component({selector: 'child2', template: 'child2'})\n+        class Child2 {\n+        }\n+\n+        @Component({selector: 'child3', template: 'child3'})\n+        class Child3 {\n+        }\n+\n+        @Component({selector: 'child4', template: 'child4'})\n+        class Child4 {\n+        }\n+\n+        @Component({selector: 'child5', template: 'child5'})\n+        class Child5 {\n+        }\n+\n+        @NgModule({\n+          declarations: [Parent, Home, Child1, Child2, Child3, Child4, Child5],\n+          entryComponents: [Child1, Child2, Child3, Child4, Child5],\n+          imports: [RouterModule]\n+        })\n+        class TestModule {\n+        }\n+\n+        let fixture: ComponentFixture<unknown>;\n+\n+        beforeEach(fakeAsync(() => {\n+          TestBed.configureTestingModule({imports: [TestModule]});\n+          const router = TestBed.get(Router);\n+          const location = TestBed.get(Location);\n+          fixture = createRoot(router, Parent);\n+\n+          router.resetConfig([\n+            {path: '', component: Home},\n+            {path: 'first', component: Child1},\n+            {path: 'second', component: Child2},\n+            {path: 'third', component: Child3, canDeactivate: [MyGuard]},\n+            {path: 'fourth', component: Child4},\n+            {path: 'fifth', component: Child5},\n+          ]);\n+\n+          // Create a navigation history of pages 1-5, and go back to 3 so that there is both\n+          // back and forward history.\n+          router.navigateByUrl('/first');\n+          advance(fixture);\n+          router.navigateByUrl('/second');\n+          advance(fixture);\n+          router.navigateByUrl('/third');\n+          advance(fixture);\n+          router.navigateByUrl('/fourth');\n+          advance(fixture);\n+          router.navigateByUrl('/fifth');\n+          advance(fixture);\n+          location.back();\n+          advance(fixture);\n+          location.back();\n+          advance(fixture);\n+        }));\n+\n+        // TODO(https://github.com/angular/angular/issues/13586)\n+        // A fix to this requires much more design\n+        xit('when navigate back using Back button', fakeAsync(() => {\n+              const location = TestBed.get(Location);\n+              expect(location.path()).toEqual('/third');\n+\n+              TestBed.get(MyGuard).allow = false;\n+              location.back();\n+              advance(fixture);\n+              expect(location.path()).toEqual('/third');\n+              expect(fixture.nativeElement).toHaveText('child3');\n+\n+              TestBed.get(MyGuard).allow = true;\n+              location.back();\n+              advance(fixture);\n+              expect(location.path()).toEqual('/second');\n+              expect(fixture.nativeElement).toHaveText('child2');\n+            }));\n+\n+        it('when navigate back imperatively', fakeAsync(() => {\n+             const router = TestBed.get(Router);\n+             const location = TestBed.get(Location);\n+             expect(location.path()).toEqual('/third');\n+\n+             TestBed.get(MyGuard).allow = false;\n+             router.navigateByUrl('/second');\n+             advance(fixture);\n+             expect(location.path()).toEqual('/third');\n+             expect(fixture.nativeElement).toHaveText('child3');\n+\n+             TestBed.get(MyGuard).allow = true;\n+             location.back();\n+             advance(fixture);\n+             expect(location.path()).toEqual('/second');\n+             expect(fixture.nativeElement).toHaveText('child2');\n+           }));\n+\n+        // TODO(https://github.com/angular/angular/issues/13586)\n+        // A fix to this requires much more design\n+        xit('when navigate back using Foward button', fakeAsync(() => {\n+              const location = TestBed.get(Location);\n+              expect(location.path()).toEqual('/third');\n+\n+              TestBed.get(MyGuard).allow = false;\n+              location.forward();\n+              advance(fixture);\n+              expect(location.path()).toEqual('/third');\n+              expect(fixture.nativeElement).toHaveText('child3');\n+\n+              TestBed.get(MyGuard).allow = true;\n+              location.forward();\n+              advance(fixture);\n+              expect(location.path()).toEqual('/fourth');\n+              expect(fixture.nativeElement).toHaveText('child4');\n+            }));\n+\n+        it('when navigate forward imperatively', fakeAsync(() => {\n+             const router = TestBed.get(Router);\n+             const location = TestBed.get(Location);\n+             expect(location.path()).toEqual('/third');\n+\n+             TestBed.get(MyGuard).allow = false;\n+             router.navigateByUrl('/fourth');\n+             advance(fixture);\n+             expect(location.path()).toEqual('/third');\n+             expect(fixture.nativeElement).toHaveText('child3');\n+\n+             TestBed.get(MyGuard).allow = true;\n+             location.forward();\n+             advance(fixture);\n+             expect(location.path()).toEqual('/fourth');\n+             expect(fixture.nativeElement).toHaveText('child4');\n+           }));\n+      });\n+\n       describe('should redirect when guard returns UrlTree', () => {\n         beforeEach(() => TestBed.configureTestingModule({\n           providers: ["
        }
    ],
    "stats": {
        "total": 213,
        "additions": 203,
        "deletions": 10
    }
}