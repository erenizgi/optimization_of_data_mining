{
    "author": "ayazhafiz",
    "message": "feat(compiler): Recover on malformed keyed reads and keyed writes (#39004)\n\nThis patch adds support for recovering well-formed (and near-complete)\nASTs for semantically malformed keyed reads and keyed writes. See the\nadded tests for details on the types of semantics we can now recover;\nin particular, notice that some assumptions are made about the form of\na keyed read/write intended by a user. For example, in the malformed\nexpression `a[1 + = 2`, we assume that the user meant to write a binary\nexpression for the key of `a`, and assign that key the value `2`. In\nparticular, we now parse this as `a[1 + <empty expression>] = 2`. There\nare some different interpretations that can be made here, but I think\nthis is reasonable.\n\nThe actual changes in the parser code are fairly minimal (a nice\nsurprise!); the biggest addition is a `writeContext` that marks whether\nthe `=` operator can serve as a recovery point after error detection.\n\nPart of #38596\n\nPR Close #39004",
    "sha": "3bbbf39b582bb3e26d1d17840fd658c3b9a6b257",
    "files": [
        {
            "sha": "ccdb08d4563cc513f88c679a08f487e6563bb5c2",
            "filename": "packages/compiler/src/expression_parser/parser.ts",
            "status": "modified",
            "additions": 72,
            "deletions": 26,
            "changes": 98,
            "blob_url": "https://github.com/angular/angular/blob/3bbbf39b582bb3e26d1d17840fd658c3b9a6b257/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/3bbbf39b582bb3e26d1d17840fd658c3b9a6b257/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts?ref=3bbbf39b582bb3e26d1d17840fd658c3b9a6b257",
            "patch": "@@ -288,10 +288,24 @@ export class IvyParser extends Parser {\n   simpleExpressionChecker = IvySimpleExpressionChecker;  //\n }\n \n+/** Describes a stateful context an expression parser is in. */\n+enum ParseContextFlags {\n+  None = 0,\n+  /**\n+   * A Writable context is one in which a value may be written to an lvalue.\n+   * For example, after we see a property access, we may expect a write to the\n+   * property via the \"=\" operator.\n+   *   prop\n+   *        ^ possible \"=\" after\n+   */\n+  Writable = 1,\n+}\n+\n export class _ParseAST {\n   private rparensExpected = 0;\n   private rbracketsExpected = 0;\n   private rbracesExpected = 0;\n+  private context = ParseContextFlags.None;\n \n   // Cache of expression start and input indeces to the absolute source span they map to, used to\n   // prevent creating superfluous source spans in `sourceSpan`.\n@@ -368,6 +382,16 @@ export class _ParseAST {\n     this.index++;\n   }\n \n+  /**\n+   * Executes a callback in the provided context.\n+   */\n+  private withContext<T>(context: ParseContextFlags, cb: () => T): T {\n+    this.context |= context;\n+    const ret = cb();\n+    this.context ^= context;\n+    return ret;\n+  }\n+\n   consumeOptionalCharacter(code: number): boolean {\n     if (this.next.isCharacter(code)) {\n       this.advance();\n@@ -384,6 +408,12 @@ export class _ParseAST {\n     return this.next.isKeywordAs();\n   }\n \n+  /**\n+   * Consumes an expected character, otherwise emits an error about the missing expected character\n+   * and skips over the token stream until reaching a recoverable point.\n+   *\n+   * See `this.error` and `this.skip` for more details.\n+   */\n   expectCharacter(code: number) {\n     if (this.consumeOptionalCharacter(code)) return;\n     this.error(`Missing expected ${String.fromCharCode(code)}`);\n@@ -631,18 +661,23 @@ export class _ParseAST {\n         result = this.parseAccessMemberOrMethodCall(result, true);\n \n       } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n-        this.rbracketsExpected++;\n-        const key = this.parsePipe();\n-        this.rbracketsExpected--;\n-        this.expectCharacter(chars.$RBRACKET);\n-        if (this.consumeOptionalOperator('=')) {\n-          const value = this.parseConditional();\n-          result = new KeyedWrite(\n-              this.span(resultStart), this.sourceSpan(resultStart), result, key, value);\n-        } else {\n-          result = new KeyedRead(this.span(resultStart), this.sourceSpan(resultStart), result, key);\n-        }\n-\n+        this.withContext(ParseContextFlags.Writable, () => {\n+          this.rbracketsExpected++;\n+          const key = this.parsePipe();\n+          if (key instanceof EmptyExpr) {\n+            this.error(`Key access cannot be empty`);\n+          }\n+          this.rbracketsExpected--;\n+          this.expectCharacter(chars.$RBRACKET);\n+          if (this.consumeOptionalOperator('=')) {\n+            const value = this.parseConditional();\n+            result = new KeyedWrite(\n+                this.span(resultStart), this.sourceSpan(resultStart), result, key, value);\n+          } else {\n+            result =\n+                new KeyedRead(this.span(resultStart), this.sourceSpan(resultStart), result, key);\n+          }\n+        });\n       } else if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n         this.rparensExpected++;\n         const args = this.parseCallArguments();\n@@ -994,6 +1029,10 @@ export class _ParseAST {\n     this.consumeOptionalCharacter(chars.$SEMICOLON) || this.consumeOptionalCharacter(chars.$COMMA);\n   }\n \n+  /**\n+   * Records an error and skips over the token stream until reaching a recoverable point. See\n+   * `this.skip` for more details on token skipping.\n+   */\n   error(message: string, index: number|null = null) {\n     this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n     this.skip();\n@@ -1005,25 +1044,32 @@ export class _ParseAST {\n                                           `at the end of the expression`;\n   }\n \n-  // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n-  // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n-  // '}' and ']' as conditional recovery points if one of calling productions is expecting\n-  // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n-  // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n-  // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n-  // must be conditional as they must be skipped if none of the calling productions are not\n-  // expecting the closing token else we will never make progress in the case of an\n-  // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n-  // parseChain() is always the root production and it expects a ';'.\n-\n-  // If a production expects one of these token it increments the corresponding nesting count,\n-  // and then decrements it just prior to checking if the token is in the input.\n+  /**\n+   * Error recovery should skip tokens until it encounters a recovery point. skip() treats\n+   * the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n+   * '}' and ']' as conditional recovery points if one of calling productions is expecting\n+   * one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n+   * more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n+   * of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n+   * must be conditional as they must be skipped if none of the calling productions are not\n+   * expecting the closing token else we will never make progress in the case of an\n+   * extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n+   * parseChain() is always the root production and it expects a ';'.\n+   *\n+   * Furthermore, the presence of a stateful context can add more recovery points.\n+   *   - in a `Writable` context, we are able to recover after seeing the `=` operator, which\n+   *     signals the presence of an independent rvalue expression following the `=` operator.\n+   *\n+   * If a production expects one of these token it increments the corresponding nesting count,\n+   * and then decrements it just prior to checking if the token is in the input.\n+   */\n   private skip() {\n     let n = this.next;\n     while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n            (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n            (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n-           (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))) {\n+           (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET)) &&\n+           (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {\n       if (this.next.isError()) {\n         this.errors.push(\n             new ParserError(this.next.toString()!, this.input, this.locationText(), this.location));"
        },
        {
            "sha": "8c9f85651eb0e0456921c8d124e16119bfacd3db",
            "filename": "packages/compiler/test/expression_parser/parser_spec.ts",
            "status": "modified",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/angular/angular/blob/3bbbf39b582bb3e26d1d17840fd658c3b9a6b257/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/3bbbf39b582bb3e26d1d17840fd658c3b9a6b257/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts?ref=3bbbf39b582bb3e26d1d17840fd658c3b9a6b257",
            "patch": "@@ -154,6 +154,84 @@ describe('parser', () => {\n       });\n     });\n \n+    describe('keyed read', () => {\n+      it('should parse keyed reads', () => {\n+        checkAction('a[\"a\"]');\n+        checkAction('this.a[\"a\"]', 'a[\"a\"]');\n+        checkAction('a.a[\"a\"]');\n+      });\n+\n+      describe('malformed keyed reads', () => {\n+        it('should recover on missing keys', () => {\n+          checkActionWithError('a[]', 'a[]', 'Key access cannot be empty');\n+        });\n+\n+        it('should recover on incomplete expression keys', () => {\n+          checkActionWithError('a[1 + ]', 'a[1 + ]', 'Unexpected token ]');\n+        });\n+\n+        it('should recover on unterminated keys', () => {\n+          checkActionWithError(\n+              'a[1 + 2', 'a[1 + 2]', 'Missing expected ] at the end of the expression');\n+        });\n+\n+        it('should recover on incomplete and unterminated keys', () => {\n+          checkActionWithError(\n+              'a[1 + ', 'a[1 + ]', 'Missing expected ] at the end of the expression');\n+        });\n+      });\n+    });\n+\n+    describe('keyed write', () => {\n+      it('should parse keyed writes', () => {\n+        checkAction('a[\"a\"] = 1 + 2');\n+        checkAction('this.a[\"a\"] = 1 + 2', 'a[\"a\"] = 1 + 2');\n+        checkAction('a.a[\"a\"] = 1 + 2');\n+      });\n+\n+      describe('malformed keyed writes', () => {\n+        it('should recover on empty rvalues', () => {\n+          checkActionWithError('a[\"a\"] = ', 'a[\"a\"] = ', 'Unexpected end of expression');\n+        });\n+\n+        it('should recover on incomplete rvalues', () => {\n+          checkActionWithError('a[\"a\"] = 1 + ', 'a[\"a\"] = 1 + ', 'Unexpected end of expression');\n+        });\n+\n+        it('should recover on missing keys', () => {\n+          checkActionWithError('a[] = 1', 'a[] = 1', 'Key access cannot be empty');\n+        });\n+\n+        it('should recover on incomplete expression keys', () => {\n+          checkActionWithError('a[1 + ] = 1', 'a[1 + ] = 1', 'Unexpected token ]');\n+        });\n+\n+        it('should recover on unterminated keys', () => {\n+          checkActionWithError('a[1 + 2 = 1', 'a[1 + 2] = 1', 'Missing expected ]');\n+        });\n+\n+        it('should recover on incomplete and unterminated keys', () => {\n+          const ast = parseAction('a[1 + = 1');\n+          expect(unparse(ast)).toEqual('a[1 + ] = 1');\n+          validate(ast);\n+\n+          const errors = ast.errors.map(e => e.message);\n+          expect(errors.length).toBe(2);\n+          expect(errors[0]).toContain('Unexpected token =');\n+          expect(errors[1]).toContain('Missing expected ]');\n+        });\n+\n+        it('should error on writes after a keyed write', () => {\n+          const ast = parseAction('a[1] = 1 = 2');\n+          expect(unparse(ast)).toEqual('a[1] = 1');\n+          validate(ast);\n+\n+          expect(ast.errors.length).toBe(1);\n+          expect(ast.errors[0].message).toContain('Unexpected token \\'=\\'');\n+        });\n+      });\n+    });\n+\n     describe('conditional', () => {\n       it('should parse ternary/conditional expressions', () => {\n         checkAction('7 == 3 + 4 ? 10 : 20');\n@@ -926,3 +1004,12 @@ function expectActionError(text: string, message: string) {\n function expectBindingError(text: string, message: string) {\n   expectError(validate(parseBinding(text)), message);\n }\n+\n+/**\n+ * Check that an malformed action parses to a recovered AST while emitting an\n+ * error.\n+ */\n+function checkActionWithError(text: string, expected: string, error: string) {\n+  checkAction(text, expected);\n+  expectActionError(text, error);\n+}"
        }
    ],
    "stats": {
        "total": 185,
        "additions": 159,
        "deletions": 26
    }
}