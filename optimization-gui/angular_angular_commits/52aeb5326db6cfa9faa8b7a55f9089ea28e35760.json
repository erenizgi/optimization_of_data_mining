{
    "author": "alxhub",
    "message": "refactor(compiler-cli): split template parsing into declaration/parse steps (#40561)\n\nTo prepare for the optimization of template-only changes, this commit\nrefactors the `ComponentDecoratorHandler`'s handling of template parsing.\nPreviously, templates were extracted from the raw decorator metadata and\nparsed in a single operation.\n\nTo better handle incremental template updates, this commit splits this\noperation into a \"declaration\" step where the template info is extracted\nfrom the decorator metadata, and a \"parsing\" step where the declared\ntemplate is read and parsed. This allows for re-reading and re-parsing of\nthe declared template at a future point, using the same template declaration\nextracted from the decorator.\n\nPR Close #40561",
    "sha": "52aeb5326db6cfa9faa8b7a55f9089ea28e35760",
    "files": [
        {
            "sha": "980eb03c50ea5769b9d221d5a543a37a69a5a907",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 184,
            "deletions": 127,
            "changes": 311,
            "blob_url": "https://github.com/angular/angular/blob/52aeb5326db6cfa9faa8b7a55f9089ea28e35760/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/52aeb5326db6cfa9faa8b7a55f9089ea28e35760/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=52aeb5326db6cfa9faa8b7a55f9089ea28e35760",
            "patch": "@@ -11,7 +11,7 @@ import * as ts from 'typescript';\n \n import {CycleAnalyzer} from '../../cycles';\n import {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\n-import {absoluteFrom, relative} from '../../file_system';\n+import {absoluteFrom, AbsoluteFsPath, relative} from '../../file_system';\n import {DefaultImportRecorder, ModuleResolver, Reference, ReferenceEmitter} from '../../imports';\n import {DependencyTracker} from '../../incremental/api';\n import {IndexingContext} from '../../indexer';\n@@ -246,24 +246,14 @@ export class ComponentDecoratorHandler implements\n \n       template = preanalyzed;\n     } else {\n-      // The template was not already parsed. Either there's a templateUrl, or an inline template.\n-      if (component.has('templateUrl')) {\n-        const templateUrlExpr = component.get('templateUrl')!;\n-        const templateUrl = this.evaluator.evaluate(templateUrlExpr);\n-        if (typeof templateUrl !== 'string') {\n-          throw createValueHasWrongTypeError(\n-              templateUrlExpr, templateUrl, 'templateUrl must be a string');\n-        }\n-        const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n-        template = this._extractExternalTemplate(node, component, templateUrlExpr, resourceUrl);\n-      } else {\n-        // Expect an inline template to be present.\n-        template = this._extractInlineTemplate(node, decorator, component, containingFile);\n-      }\n+      const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n+      template = this.extractTemplate(node, templateDecl);\n     }\n-    const templateResource = template.isInline ?\n-        {path: null, expression: component.get('template')!} :\n-        {path: absoluteFrom(template.templateUrl), expression: template.sourceMapping.node};\n+    const templateResource =\n+        template.isInline ? {path: null, expression: component.get('template')!} : {\n+          path: absoluteFrom(template.declaration.resolvedTemplateUrl),\n+          expression: template.sourceMapping.node\n+        };\n \n     // Figure out the set of styles. The ordering here is important: external resources (styleUrls)\n     // precede inline styles, and styles defined in the template override styles defined in the\n@@ -732,135 +722,104 @@ export class ComponentDecoratorHandler implements\n       // URLs to resolve.\n       if (templatePromise !== undefined) {\n         return templatePromise.then(() => {\n-          const template =\n-              this._extractExternalTemplate(node, component, templateUrlExpr, resourceUrl);\n+          const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n+          const template = this.extractTemplate(node, templateDecl);\n           this.preanalyzeTemplateCache.set(node, template);\n           return template;\n         });\n       } else {\n         return Promise.resolve(null);\n       }\n     } else {\n-      const template = this._extractInlineTemplate(node, decorator, component, containingFile);\n+      const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n+      const template = this.extractTemplate(node, templateDecl);\n       this.preanalyzeTemplateCache.set(node, template);\n       return Promise.resolve(template);\n     }\n   }\n \n-  private _extractExternalTemplate(\n-      node: ClassDeclaration, component: Map<string, ts.Expression>, templateUrlExpr: ts.Expression,\n-      resourceUrl: string): ParsedTemplateWithSource {\n-    const templateStr = this.resourceLoader.load(resourceUrl);\n-    if (this.depTracker !== null) {\n-      this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));\n-    }\n-\n-    const template = this._parseTemplate(\n-        component, templateStr, /* templateLiteral */ null, sourceMapUrl(resourceUrl),\n-        /* templateRange */ undefined,\n-        /* escapedString */ false);\n-\n-    return {\n-      ...template,\n-      sourceMapping: {\n-        type: 'external',\n-        componentClass: node,\n-        node: templateUrlExpr,\n-        template: templateStr,\n-        templateUrl: resourceUrl,\n-      },\n-    };\n-  }\n+  private extractTemplate(node: ClassDeclaration, template: TemplateDeclaration):\n+      ParsedTemplateWithSource {\n+    if (template.isInline) {\n+      let templateStr: string;\n+      let templateLiteral: ts.Node|null = null;\n+      let templateUrl: string = '';\n+      let templateRange: LexerRange|null = null;\n+      let sourceMapping: TemplateSourceMapping;\n+      let escapedString = false;\n+      // We only support SourceMaps for inline templates that are simple string literals.\n+      if (ts.isStringLiteral(template.expression) ||\n+          ts.isNoSubstitutionTemplateLiteral(template.expression)) {\n+        // the start and end of the `templateExpr` node includes the quotation marks, which we must\n+        // strip\n+        templateRange = getTemplateRange(template.expression);\n+        templateStr = template.expression.getSourceFile().text;\n+        templateLiteral = template.expression;\n+        templateUrl = template.templateUrl;\n+        escapedString = true;\n+        sourceMapping = {\n+          type: 'direct',\n+          node: template.expression,\n+        };\n+      } else {\n+        const resolvedTemplate = this.evaluator.evaluate(template.expression);\n+        if (typeof resolvedTemplate !== 'string') {\n+          throw createValueHasWrongTypeError(\n+              template.expression, resolvedTemplate, 'template must be a string');\n+        }\n+        templateStr = resolvedTemplate;\n+        sourceMapping = {\n+          type: 'indirect',\n+          node: template.expression,\n+          componentClass: node,\n+          template: templateStr,\n+        };\n+      }\n \n-  private _extractInlineTemplate(\n-      node: ClassDeclaration, decorator: Decorator, component: Map<string, ts.Expression>,\n-      containingFile: string): ParsedTemplateWithSource {\n-    if (!component.has('template')) {\n-      throw new FatalDiagnosticError(\n-          ErrorCode.COMPONENT_MISSING_TEMPLATE, Decorator.nodeForError(decorator),\n-          'component is missing a template');\n-    }\n-    const templateExpr = component.get('template')!;\n-\n-    let templateStr: string;\n-    let templateLiteral: ts.Node|null = null;\n-    let templateUrl: string = '';\n-    let templateRange: LexerRange|undefined = undefined;\n-    let sourceMapping: TemplateSourceMapping;\n-    let escapedString = false;\n-    // We only support SourceMaps for inline templates that are simple string literals.\n-    if (ts.isStringLiteral(templateExpr) || ts.isNoSubstitutionTemplateLiteral(templateExpr)) {\n-      // the start and end of the `templateExpr` node includes the quotation marks, which we\n-      // must\n-      // strip\n-      templateRange = getTemplateRange(templateExpr);\n-      templateStr = templateExpr.getSourceFile().text;\n-      templateLiteral = templateExpr;\n-      templateUrl = containingFile;\n-      escapedString = true;\n-      sourceMapping = {\n-        type: 'direct',\n-        node: templateExpr as (ts.StringLiteral | ts.NoSubstitutionTemplateLiteral),\n+      return {\n+        ...this._parseTemplate(template, templateStr, templateRange, escapedString),\n+        sourceMapping,\n+        declaration: template,\n       };\n     } else {\n-      const resolvedTemplate = this.evaluator.evaluate(templateExpr);\n-      if (typeof resolvedTemplate !== 'string') {\n-        throw createValueHasWrongTypeError(\n-            templateExpr, resolvedTemplate, 'template must be a string');\n+      const templateStr = this.resourceLoader.load(template.resolvedTemplateUrl);\n+      if (this.depTracker !== null) {\n+        this.depTracker.addResourceDependency(\n+            node.getSourceFile(), absoluteFrom(template.resolvedTemplateUrl));\n       }\n-      templateStr = resolvedTemplate;\n-      sourceMapping = {\n-        type: 'indirect',\n-        node: templateExpr,\n-        componentClass: node,\n-        template: templateStr,\n+\n+      return {\n+        ...this._parseTemplate(\n+            template, templateStr, /* templateRange */ null,\n+            /* escapedString */ false),\n+        sourceMapping: {\n+          type: 'external',\n+          componentClass: node,\n+          // TODO(alxhub): TS in g3 is unable to make this inference on its own, so cast it here\n+          // until g3 is able to figure this out.\n+          node: (template as ExternalTemplateDeclaration).templateUrlExpression,\n+          template: templateStr,\n+          templateUrl: template.resolvedTemplateUrl,\n+        },\n+        declaration: template,\n       };\n     }\n-\n-    const template = this._parseTemplate(\n-        component, templateStr, templateLiteral, templateUrl, templateRange, escapedString);\n-\n-    return {...template, sourceMapping};\n   }\n \n   private _parseTemplate(\n-      component: Map<string, ts.Expression>, templateStr: string, templateLiteral: ts.Node|null,\n-      templateUrl: string, templateRange: LexerRange|undefined,\n+      template: TemplateDeclaration, templateStr: string, templateRange: LexerRange|null,\n       escapedString: boolean): ParsedComponentTemplate {\n-    let preserveWhitespaces: boolean = this.defaultPreserveWhitespaces;\n-    if (component.has('preserveWhitespaces')) {\n-      const expr = component.get('preserveWhitespaces')!;\n-      const value = this.evaluator.evaluate(expr);\n-      if (typeof value !== 'boolean') {\n-        throw createValueHasWrongTypeError(expr, value, 'preserveWhitespaces must be a boolean');\n-      }\n-      preserveWhitespaces = value;\n-    }\n-\n-    let interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;\n-    if (component.has('interpolation')) {\n-      const expr = component.get('interpolation')!;\n-      const value = this.evaluator.evaluate(expr);\n-      if (!Array.isArray(value) || value.length !== 2 ||\n-          !value.every(element => typeof element === 'string')) {\n-        throw createValueHasWrongTypeError(\n-            expr, value, 'interpolation must be an array with 2 elements of string type');\n-      }\n-      interpolationConfig = InterpolationConfig.fromArray(value as [string, string]);\n-    }\n-\n     // We always normalize line endings if the template has been escaped (i.e. is inline).\n     const i18nNormalizeLineEndingsInICUs = escapedString || this.i18nNormalizeLineEndingsInICUs;\n \n-    const isInline = component.has('template');\n-    const parsedTemplate = parseTemplate(templateStr, templateUrl, {\n-      preserveWhitespaces,\n-      interpolationConfig,\n-      range: templateRange,\n+    const parsedTemplate = parseTemplate(templateStr, template.sourceMapUrl, {\n+      preserveWhitespaces: template.preserveWhitespaces,\n+      interpolationConfig: template.interpolationConfig,\n+      range: templateRange ?? undefined,\n       escapedString,\n       enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n       i18nNormalizeLineEndingsInICUs,\n-      isInline,\n+      isInline: template.isInline,\n     });\n \n     // Unfortunately, the primary parse of the template above may not contain accurate source map\n@@ -876,27 +835,87 @@ export class ComponentDecoratorHandler implements\n     // In order to guarantee the correctness of diagnostics, templates are parsed a second time\n     // with the above options set to preserve source mappings.\n \n-    const {nodes: diagNodes} = parseTemplate(templateStr, templateUrl, {\n+    const {nodes: diagNodes} = parseTemplate(templateStr, template.sourceMapUrl, {\n       preserveWhitespaces: true,\n-      interpolationConfig,\n-      range: templateRange,\n+      interpolationConfig: template.interpolationConfig,\n+      range: templateRange ?? undefined,\n       escapedString,\n       enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n       i18nNormalizeLineEndingsInICUs,\n       leadingTriviaChars: [],\n-      isInline,\n+      isInline: template.isInline,\n     });\n \n     return {\n       ...parsedTemplate,\n       diagNodes,\n-      template: templateLiteral !== null ? new WrappedNodeExpr(templateLiteral) : templateStr,\n-      templateUrl,\n-      isInline,\n-      file: new ParseSourceFile(templateStr, templateUrl),\n+      template: template.isInline ? new WrappedNodeExpr(template.expression) : templateStr,\n+      templateUrl: template.resolvedTemplateUrl,\n+      isInline: template.isInline,\n+      file: new ParseSourceFile(templateStr, template.resolvedTemplateUrl),\n     };\n   }\n \n+  private parseTemplateDeclaration(\n+      decorator: Decorator, component: Map<string, ts.Expression>,\n+      containingFile: string): TemplateDeclaration {\n+    let preserveWhitespaces: boolean = this.defaultPreserveWhitespaces;\n+    if (component.has('preserveWhitespaces')) {\n+      const expr = component.get('preserveWhitespaces')!;\n+      const value = this.evaluator.evaluate(expr);\n+      if (typeof value !== 'boolean') {\n+        throw createValueHasWrongTypeError(expr, value, 'preserveWhitespaces must be a boolean');\n+      }\n+      preserveWhitespaces = value;\n+    }\n+\n+    let interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;\n+    if (component.has('interpolation')) {\n+      const expr = component.get('interpolation')!;\n+      const value = this.evaluator.evaluate(expr);\n+      if (!Array.isArray(value) || value.length !== 2 ||\n+          !value.every(element => typeof element === 'string')) {\n+        throw createValueHasWrongTypeError(\n+            expr, value, 'interpolation must be an array with 2 elements of string type');\n+      }\n+      interpolationConfig = InterpolationConfig.fromArray(value as [string, string]);\n+    }\n+\n+    if (component.has('templateUrl')) {\n+      const templateUrlExpr = component.get('templateUrl')!;\n+      const templateUrl = this.evaluator.evaluate(templateUrlExpr);\n+      if (typeof templateUrl !== 'string') {\n+        throw createValueHasWrongTypeError(\n+            templateUrlExpr, templateUrl, 'templateUrl must be a string');\n+      }\n+      const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n+\n+      return {\n+        isInline: false,\n+        interpolationConfig,\n+        preserveWhitespaces,\n+        templateUrl,\n+        templateUrlExpression: templateUrlExpr,\n+        resolvedTemplateUrl: resourceUrl,\n+        sourceMapUrl: sourceMapUrl(resourceUrl),\n+      };\n+    } else if (component.has('template')) {\n+      return {\n+        isInline: true,\n+        interpolationConfig,\n+        preserveWhitespaces,\n+        expression: component.get('template')!,\n+        templateUrl: containingFile,\n+        resolvedTemplateUrl: containingFile,\n+        sourceMapUrl: containingFile,\n+      };\n+    } else {\n+      throw new FatalDiagnosticError(\n+          ErrorCode.COMPONENT_MISSING_TEMPLATE, Decorator.nodeForError(decorator),\n+          'component is missing a template');\n+    }\n+  }\n+\n   private _expressionToImportedFile(expr: Expression, origin: ts.SourceFile): ts.SourceFile|null {\n     if (!(expr instanceof ExternalExpr)) {\n       return null;\n@@ -978,4 +997,42 @@ export interface ParsedComponentTemplate extends ParsedTemplate {\n \n export interface ParsedTemplateWithSource extends ParsedComponentTemplate {\n   sourceMapping: TemplateSourceMapping;\n+  declaration: TemplateDeclaration;\n }\n+\n+/**\n+ * Common fields extracted from the declaration of a template.\n+ */\n+interface CommonTemplateDeclaration {\n+  preserveWhitespaces: boolean;\n+  interpolationConfig: InterpolationConfig;\n+  templateUrl: string;\n+  resolvedTemplateUrl: string;\n+  sourceMapUrl: string;\n+}\n+\n+/**\n+ * Information extracted from the declaration of an inline template.\n+ */\n+interface InlineTemplateDeclaration extends CommonTemplateDeclaration {\n+  isInline: true;\n+  expression: ts.Expression;\n+}\n+\n+/**\n+ * Information extracted from the declaration of an external template.\n+ */\n+interface ExternalTemplateDeclaration extends CommonTemplateDeclaration {\n+  isInline: false;\n+  templateUrlExpression: ts.Expression;\n+}\n+\n+/**\n+ * The declaration of a template extracted from a component decorator.\n+ *\n+ * This data is extracted and stored separately to faciliate re-interpreting the template\n+ * declaration whenever the compiler is notified of a change to a template file. With this\n+ * information, `ComponentDecoratorHandler` is able to re-read the template and update the component\n+ * record without needing to parse the original decorator again.\n+ */\n+type TemplateDeclaration = InlineTemplateDeclaration|ExternalTemplateDeclaration;"
        }
    ],
    "stats": {
        "total": 311,
        "additions": 184,
        "deletions": 127
    }
}