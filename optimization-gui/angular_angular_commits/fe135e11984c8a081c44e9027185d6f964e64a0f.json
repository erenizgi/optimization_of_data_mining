{
    "author": "gkalpak",
    "message": "refactor(service-worker): remove duplicate `Context` type (in favor of `ExtendableEvent`) (#42736)\n\nThis commit removes the duplicate `Context` interface and uses the\n`ExtendableEvent` interface instead.\n\nThis is in preparation of switching from our custom typings to the\nofficial TypeScript typings (`lib.webworker.d.ts`).\n\nPR Close #42736",
    "sha": "fe135e11984c8a081c44e9027185d6f964e64a0f",
    "files": [
        {
            "sha": "ad56aee12ae51baec4531f40260120731dde92ff",
            "filename": "packages/service-worker/worker/src/adapter.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 11,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/fe135e11984c8a081c44e9027185d6f964e64a0f/packages%2Fservice-worker%2Fworker%2Fsrc%2Fadapter.ts",
            "raw_url": "https://github.com/angular/angular/raw/fe135e11984c8a081c44e9027185d6f964e64a0f/packages%2Fservice-worker%2Fworker%2Fsrc%2Fadapter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fadapter.ts?ref=fe135e11984c8a081c44e9027185d6f964e64a0f",
            "patch": "@@ -104,14 +104,3 @@ export class Adapter<T extends CacheStorage = CacheStorage> {\n     });\n   }\n }\n-\n-/**\n- * An event context in which an operation is taking place, which allows\n- * the delaying of Service Worker shutdown until certain triggers occur.\n- */\n-export interface Context {\n-  /**\n-   * Delay shutdown of the Service Worker until the given promise resolves.\n-   */\n-  waitUntil(fn: Promise<any>): void;\n-}"
        },
        {
            "sha": "b6ad4412794b0f41bf5475469aca30c490dc940f",
            "filename": "packages/service-worker/worker/src/app-version.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/fe135e11984c8a081c44e9027185d6f964e64a0f/packages%2Fservice-worker%2Fworker%2Fsrc%2Fapp-version.ts",
            "raw_url": "https://github.com/angular/angular/raw/fe135e11984c8a081c44e9027185d6f964e64a0f/packages%2Fservice-worker%2Fworker%2Fsrc%2Fapp-version.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fapp-version.ts?ref=fe135e11984c8a081c44e9027185d6f964e64a0f",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Adapter, Context} from './adapter';\n+import {Adapter} from './adapter';\n import {CacheState, NormalizedUrl, UpdateCacheStatus, UpdateSource} from './api';\n import {AssetGroup, LazyAssetGroup, PrefetchAssetGroup} from './assets';\n import {DataGroup} from './data';\n@@ -135,7 +135,7 @@ export class AppVersion implements UpdateSource {\n     }\n   }\n \n-  async handleFetch(req: Request, context: Context): Promise<Response|null> {\n+  async handleFetch(req: Request, event: ExtendableEvent): Promise<Response|null> {\n     // Check the request against each `AssetGroup` in sequence. If an `AssetGroup` can't handle the\n     // request,\n     // it will return `null`. Thus, the first non-null response is the SW's answer to the request.\n@@ -152,7 +152,7 @@ export class AppVersion implements UpdateSource {\n       }\n \n       // No response has been found yet. Maybe this group will have one.\n-      return group.handleFetch(req, context);\n+      return group.handleFetch(req, event);\n     }, Promise.resolve<Response|null>(null));\n \n     // The result of the above is the asset response, if there is any, or null otherwise. Return the\n@@ -170,7 +170,7 @@ export class AppVersion implements UpdateSource {\n         return resp;\n       }\n \n-      return group.handleFetch(req, context);\n+      return group.handleFetch(req, event);\n     }, Promise.resolve<Response|null>(null));\n \n     // If the data caching group returned a response, go with it.\n@@ -195,7 +195,7 @@ export class AppVersion implements UpdateSource {\n \n       // This was a navigation request. Re-enter `handleFetch` with a request for\n       // the URL.\n-      return this.handleFetch(this.adapter.newRequest(this.indexUrl), context);\n+      return this.handleFetch(this.adapter.newRequest(this.indexUrl), event);\n     }\n \n     return null;"
        },
        {
            "sha": "c29707a45f54b9f92336e7e60531590758552b41",
            "filename": "packages/service-worker/worker/src/assets.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/fe135e11984c8a081c44e9027185d6f964e64a0f/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts",
            "raw_url": "https://github.com/angular/angular/raw/fe135e11984c8a081c44e9027185d6f964e64a0f/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts?ref=fe135e11984c8a081c44e9027185d6f964e64a0f",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Adapter, Context} from './adapter';\n+import {Adapter} from './adapter';\n import {CacheState, NormalizedUrl, UpdateCacheStatus, UpdateSource, UrlMetadata} from './api';\n import {Database, Table} from './database';\n import {CacheTable} from './db-cache';\n@@ -114,7 +114,7 @@ export abstract class AssetGroup {\n   /**\n    * Process a request for a given resource and return it, or return null if it's not available.\n    */\n-  async handleFetch(req: Request, ctx: Context): Promise<Response|null> {\n+  async handleFetch(req: Request, _event: ExtendableEvent): Promise<Response|null> {\n     const url = this.adapter.normalizeUrl(req.url);\n     // Either the request matches one of the known resource URLs, one of the patterns for\n     // dynamically matched URLs, or neither. Determine which is the case for this request in"
        },
        {
            "sha": "636d6321fa0bb0e53af265e9aa6e6284a89eb30a",
            "filename": "packages/service-worker/worker/src/data.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/fe135e11984c8a081c44e9027185d6f964e64a0f/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdata.ts",
            "raw_url": "https://github.com/angular/angular/raw/fe135e11984c8a081c44e9027185d6f964e64a0f/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdata.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdata.ts?ref=fe135e11984c8a081c44e9027185d6f964e64a0f",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Adapter, Context} from './adapter';\n+import {Adapter} from './adapter';\n import {Database, Table} from './database';\n import {CacheTable} from './db-cache';\n import {DebugHandler} from './debug';\n@@ -294,7 +294,7 @@ export class DataGroup {\n    * Process a fetch event and return a `Response` if the resource is covered by this group,\n    * or `null` otherwise.\n    */\n-  async handleFetch(req: Request, ctx: Context): Promise<Response|null> {\n+  async handleFetch(req: Request, event: ExtendableEvent): Promise<Response|null> {\n     // Do nothing\n     if (!this.patterns.some(pattern => pattern.test(req.url))) {\n       return null;\n@@ -314,9 +314,9 @@ export class DataGroup {\n         // Handle the request with whatever strategy was selected.\n         switch (this.config.strategy) {\n           case 'freshness':\n-            return this.handleFetchWithFreshness(req, ctx, lru);\n+            return this.handleFetchWithFreshness(req, event, lru);\n           case 'performance':\n-            return this.handleFetchWithPerformance(req, ctx, lru);\n+            return this.handleFetchWithPerformance(req, event, lru);\n           default:\n             throw new Error(`Unknown strategy: ${this.config.strategy}`);\n         }\n@@ -337,7 +337,7 @@ export class DataGroup {\n     }\n   }\n \n-  private async handleFetchWithPerformance(req: Request, ctx: Context, lru: LruList):\n+  private async handleFetchWithPerformance(req: Request, event: ExtendableEvent, lru: LruList):\n       Promise<Response|null> {\n     let res: Response|null|undefined = null;\n \n@@ -348,7 +348,7 @@ export class DataGroup {\n       res = fromCache.res;\n       // Check the age of the resource.\n       if (this.config.refreshAheadMs !== undefined && fromCache.age >= this.config.refreshAheadMs) {\n-        ctx.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));\n+        event.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));\n       }\n     }\n \n@@ -367,7 +367,7 @@ export class DataGroup {\n       res = this.adapter.newResponse(null, {status: 504, statusText: 'Gateway Timeout'});\n \n       // Cache the network response eventually.\n-      ctx.waitUntil(this.safeCacheResponse(req, networkFetch, lru));\n+      event.waitUntil(this.safeCacheResponse(req, networkFetch, lru));\n     } else {\n       // The request completed in time, so cache it inline with the response flow.\n       await this.safeCacheResponse(req, res, lru);\n@@ -376,7 +376,7 @@ export class DataGroup {\n     return res;\n   }\n \n-  private async handleFetchWithFreshness(req: Request, ctx: Context, lru: LruList):\n+  private async handleFetchWithFreshness(req: Request, event: ExtendableEvent, lru: LruList):\n       Promise<Response|null> {\n     // Start with a network fetch.\n     const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);\n@@ -392,7 +392,7 @@ export class DataGroup {\n \n     // If the network fetch times out or errors, fall back on the cache.\n     if (res === undefined) {\n-      ctx.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));\n+      event.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));\n \n       // Ignore the age, the network response will be cached anyway due to the\n       // behavior of freshness."
        },
        {
            "sha": "9531efe7d43dc64851c9219066e9280f9dddc023",
            "filename": "packages/service-worker/worker/test/prefetch_spec.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 8,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/fe135e11984c8a081c44e9027185d6f964e64a0f/packages%2Fservice-worker%2Fworker%2Ftest%2Fprefetch_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fe135e11984c8a081c44e9027185d6f964e64a0f/packages%2Fservice-worker%2Fworker%2Ftest%2Fprefetch_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Ftest%2Fprefetch_spec.ts?ref=fe135e11984c8a081c44e9027185d6f964e64a0f",
            "patch": "@@ -12,7 +12,7 @@ import {IdleScheduler} from '../src/idle';\n import {MockCache} from '../testing/cache';\n import {MockRequest} from '../testing/fetch';\n import {MockFileSystemBuilder, MockServerStateBuilder, tmpHashTable, tmpManifestSingleAssetGroup} from '../testing/mock';\n-import {SwTestHarness, SwTestHarnessBuilder} from '../testing/scope';\n+import {MockExtendableEvent, SwTestHarness, SwTestHarnessBuilder} from '../testing/scope';\n \n (function() {\n // Skip environments that don't support the minimum APIs needed to run the SW tests.\n@@ -33,6 +33,8 @@ const scope = new SwTestHarnessBuilder().withServerState(server).build();\n \n const db = new CacheDatabase(scope);\n \n+const testEvent = new MockExtendableEvent('test');\n+\n \n describe('prefetch assets', () => {\n   let group: PrefetchAssetGroup;\n@@ -50,8 +52,8 @@ describe('prefetch assets', () => {\n   it('fully caches the two files', async () => {\n     await group.initializeFully();\n     scope.updateServerState();\n-    const res1 = await group.handleFetch(scope.newRequest('/foo.txt'), scope);\n-    const res2 = await group.handleFetch(scope.newRequest('/bar.txt'), scope);\n+    const res1 = await group.handleFetch(scope.newRequest('/foo.txt'), testEvent);\n+    const res2 = await group.handleFetch(scope.newRequest('/bar.txt'), testEvent);\n     expect(await res1!.text()).toEqual('this is foo');\n     expect(await res2!.text()).toEqual('this is bar');\n   });\n@@ -63,14 +65,14 @@ describe('prefetch assets', () => {\n         freshScope, freshScope, idle, manifest.assetGroups![0], tmpHashTable(manifest),\n         new CacheDatabase(freshScope), 'test');\n     await group.initializeFully();\n-    const res1 = await group.handleFetch(scope.newRequest('/foo.txt'), scope);\n-    const res2 = await group.handleFetch(scope.newRequest('/bar.txt'), scope);\n+    const res1 = await group.handleFetch(scope.newRequest('/foo.txt'), testEvent);\n+    const res2 = await group.handleFetch(scope.newRequest('/bar.txt'), testEvent);\n     expect(await res1!.text()).toEqual('this is foo');\n     expect(await res2!.text()).toEqual('this is bar');\n   });\n   it('caches properly if resources are requested before initialization', async () => {\n-    const res1 = await group.handleFetch(scope.newRequest('/foo.txt'), scope);\n-    const res2 = await group.handleFetch(scope.newRequest('/bar.txt'), scope);\n+    const res1 = await group.handleFetch(scope.newRequest('/foo.txt'), testEvent);\n+    const res2 = await group.handleFetch(scope.newRequest('/bar.txt'), testEvent);\n     expect(await res1!.text()).toEqual('this is foo');\n     expect(await res2!.text()).toEqual('this is bar');\n     scope.updateServerState();\n@@ -90,7 +92,7 @@ describe('prefetch assets', () => {\n   it('CacheQueryOptions are passed through', async () => {\n     await group.initializeFully();\n     const matchSpy = spyOn(MockCache.prototype, 'match').and.callThrough();\n-    await group.handleFetch(scope.newRequest('/foo.txt'), scope);\n+    await group.handleFetch(scope.newRequest('/foo.txt'), testEvent);\n     expect(matchSpy).toHaveBeenCalledWith(new MockRequest('/foo.txt'), {ignoreVary: true});\n   });\n });"
        },
        {
            "sha": "0b507d59e780500505a3efd0f26b59cffa535f5a",
            "filename": "packages/service-worker/worker/testing/scope.ts",
            "status": "modified",
            "additions": 59,
            "deletions": 14,
            "changes": 73,
            "blob_url": "https://github.com/angular/angular/blob/fe135e11984c8a081c44e9027185d6f964e64a0f/packages%2Fservice-worker%2Fworker%2Ftesting%2Fscope.ts",
            "raw_url": "https://github.com/angular/angular/raw/fe135e11984c8a081c44e9027185d6f964e64a0f/packages%2Fservice-worker%2Fworker%2Ftesting%2Fscope.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Ftesting%2Fscope.ts?ref=fe135e11984c8a081c44e9027185d6f964e64a0f",
            "patch": "@@ -8,7 +8,7 @@\n \n import {Subject} from 'rxjs';\n \n-import {Adapter, Context} from '../src/adapter';\n+import {Adapter} from '../src/adapter';\n import {AssetGroupConfig, Manifest} from '../src/manifest';\n import {sha1} from '../src/sha1';\n \n@@ -105,8 +105,7 @@ export class MockClients implements Clients {\n   async claim(): Promise<any> {}\n }\n \n-export class SwTestHarness extends Adapter<MockCacheStorage> implements Context,\n-                                                                        ServiceWorkerGlobalScope {\n+export class SwTestHarness extends Adapter<MockCacheStorage> implements ServiceWorkerGlobalScope {\n   readonly clients = new MockClients();\n   private eventHandlers = new Map<string, Function>();\n   private skippedWaiting = false;\n@@ -239,8 +238,6 @@ export class SwTestHarness extends Adapter<MockCacheStorage> implements Context,\n     this.skippedWaiting = true;\n   }\n \n-  waitUntil(promise: Promise<void>): void {}\n-\n   handleFetch(req: Request, clientId = ''): [Promise<Response|undefined>, Promise<void>] {\n     if (!this.eventHandlers.has('fetch')) {\n       throw new Error('No fetch handler registered');\n@@ -376,7 +373,49 @@ export class ConfigBuilder {\n   }\n }\n \n-class OneTimeContext implements Context {\n+class MockEvent implements Event {\n+  readonly AT_TARGET = -1;\n+  readonly BUBBLING_PHASE = -1;\n+  readonly CAPTURING_PHASE = -1;\n+  readonly NONE = -1;\n+\n+  readonly bubbles = false;\n+  cancelBubble = false;\n+  readonly cancelable = false;\n+  readonly composed = false;\n+  readonly currentTarget = null;\n+  readonly defaultPrevented = false;\n+  readonly eventPhase = -1;\n+  readonly isTrusted = false;\n+  returnValue = false;\n+  readonly srcElement = null;\n+  readonly target = null;\n+  readonly timeStamp = Date.now();\n+\n+  constructor(readonly type: string) {}\n+\n+  composedPath(): EventTarget[] {\n+    this.notImplemented();\n+  }\n+  initEvent(type: string, bubbles?: boolean, cancelable?: boolean): void {\n+    this.notImplemented();\n+  }\n+  preventDefault(): void {\n+    this.notImplemented();\n+  }\n+  stopImmediatePropagation(): void {\n+    this.notImplemented();\n+  }\n+  stopPropagation(): void {\n+    this.notImplemented();\n+  }\n+\n+  private notImplemented(): never {\n+    throw new Error('Method not implemented in `MockEvent`.');\n+  }\n+}\n+\n+export class MockExtendableEvent extends MockEvent implements ExtendableEvent {\n   private queue: Promise<void>[] = [];\n \n   waitUntil(promise: Promise<void>): void {\n@@ -392,14 +431,12 @@ class OneTimeContext implements Context {\n   }\n }\n \n-class MockExtendableEvent extends OneTimeContext {}\n-\n class MockFetchEvent extends MockExtendableEvent {\n   response: Promise<Response|undefined> = Promise.resolve(undefined);\n \n   constructor(\n       readonly request: Request, readonly clientId: string, readonly resultingClientId: string) {\n-    super();\n+    super('fetch');\n   }\n \n   respondWith(promise: Promise<Response>): Promise<Response> {\n@@ -410,13 +447,13 @@ class MockFetchEvent extends MockExtendableEvent {\n \n class MockMessageEvent extends MockExtendableEvent {\n   constructor(readonly data: Object, readonly source: MockClient|null) {\n-    super();\n+    super('message');\n   }\n }\n \n class MockPushEvent extends MockExtendableEvent {\n   constructor(private _data: Object) {\n-    super();\n+    super('push');\n   }\n   data = {\n     json: () => this._data,\n@@ -425,11 +462,19 @@ class MockPushEvent extends MockExtendableEvent {\n \n class MockNotificationEvent extends MockExtendableEvent {\n   constructor(private _notification: any, readonly action?: string) {\n-    super();\n+    super('notification');\n   }\n   readonly notification = {...this._notification, close: () => undefined};\n }\n \n-class MockInstallEvent extends MockExtendableEvent {}\n+class MockInstallEvent extends MockExtendableEvent {\n+  constructor() {\n+    super('install');\n+  }\n+}\n \n-class MockActivateEvent extends MockExtendableEvent {}\n+class MockActivateEvent extends MockExtendableEvent {\n+  constructor() {\n+    super('activate');\n+  }\n+}"
        }
    ],
    "stats": {
        "total": 134,
        "additions": 85,
        "deletions": 49
    }
}