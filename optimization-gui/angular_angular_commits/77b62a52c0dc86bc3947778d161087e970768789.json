{
    "author": "benbraou",
    "message": "fix(forms): handle form groups/arrays own pending async validation (#22575)\n\nintroduce a boolean to track form groups/arrays own pending async validation to distinguish between pending state due to children and pending state due to own validation\n\nFixes #10064\n\nPR Close #22575",
    "sha": "77b62a52c0dc86bc3947778d161087e970768789",
    "files": [
        {
            "sha": "3bc064915dd30aceffaff954b7352e1c72a960d3",
            "filename": "packages/forms/src/model.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 3,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/77b62a52c0dc86bc3947778d161087e970768789/packages%2Fforms%2Fsrc%2Fmodel.ts",
            "raw_url": "https://github.com/angular/angular/raw/77b62a52c0dc86bc3947778d161087e970768789/packages%2Fforms%2Fsrc%2Fmodel.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fmodel.ts?ref=77b62a52c0dc86bc3947778d161087e970768789",
            "patch": "@@ -137,6 +137,13 @@ export abstract class AbstractControl {\n   // TODO(issue/24571): remove '!'.\n   _pendingDirty!: boolean;\n \n+  /**\n+   * Indicates that a control has its own pending asynchronous validation in progress.\n+   *\n+   * @internal\n+   */\n+  _hasOwnPendingAsyncValidator = false;\n+\n   /** @internal */\n   // TODO(issue/24571): remove '!'.\n   _pendingTouched!: boolean;\n@@ -675,15 +682,22 @@ export abstract class AbstractControl {\n   private _runAsyncValidator(emitEvent?: boolean): void {\n     if (this.asyncValidator) {\n       (this as {status: string}).status = PENDING;\n+      this._hasOwnPendingAsyncValidator = true;\n       const obs = toObservable(this.asyncValidator(this));\n-      this._asyncValidationSubscription =\n-          obs.subscribe((errors: ValidationErrors|null) => this.setErrors(errors, {emitEvent}));\n+      this._asyncValidationSubscription = obs.subscribe((errors: ValidationErrors|null) => {\n+        this._hasOwnPendingAsyncValidator = false;\n+        // This will trigger the recalculation of the validation status, which depends on\n+        // the state of the asynchronous validation (whether it is in progress or not). So, it is\n+        // necessary that we have updated the `_hasOwnPendingAsyncValidator` boolean flag first.\n+        this.setErrors(errors, {emitEvent});\n+      });\n     }\n   }\n \n   private _cancelExistingSubscription(): void {\n     if (this._asyncValidationSubscription) {\n       this._asyncValidationSubscription.unsubscribe();\n+      this._hasOwnPendingAsyncValidator = false;\n     }\n   }\n \n@@ -838,7 +852,7 @@ export abstract class AbstractControl {\n   private _calculateStatus(): string {\n     if (this._allControlsDisabled()) return DISABLED;\n     if (this.errors) return INVALID;\n-    if (this._anyControlsHaveStatus(PENDING)) return PENDING;\n+    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;\n     if (this._anyControlsHaveStatus(INVALID)) return INVALID;\n     return VALID;\n   }"
        },
        {
            "sha": "c46026e5157b9a5600074201f41a8965df48beea",
            "filename": "packages/forms/test/form_group_spec.ts",
            "status": "modified",
            "additions": 565,
            "deletions": 0,
            "changes": 565,
            "blob_url": "https://github.com/angular/angular/blob/77b62a52c0dc86bc3947778d161087e970768789/packages%2Fforms%2Ftest%2Fform_group_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/77b62a52c0dc86bc3947778d161087e970768789/packages%2Fforms%2Ftest%2Fform_group_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Fform_group_spec.ts?ref=77b62a52c0dc86bc3947778d161087e970768789",
            "patch": "@@ -39,6 +39,39 @@ function asyncValidator(expected: string, timeouts = {}) {\n   };\n }\n \n+function simpleAsyncValidator({\n+  timeout = 0,\n+  shouldFail,\n+  customError =\n+  {\n+    async: true\n+  }\n+}: {timeout?: number, shouldFail: boolean, customError?: any}) {\n+  return (c: AbstractControl) => {\n+    const res = shouldFail ? customError : null;\n+\n+    if (timeout === 0) {\n+      return of(res);\n+    }\n+\n+    let resolve: (result: any) => void = undefined!;\n+    const promise = new Promise<ValidationErrors|null>(res => {\n+      resolve = res;\n+    });\n+\n+    setTimeout(() => {\n+      resolve(res);\n+    }, timeout);\n+\n+    return promise;\n+  };\n+}\n+\n+function currentStateOf(controls: AbstractControl[]):\n+    {errors: any; pending: boolean; status: string;}[] {\n+  return controls.map(c => ({errors: c.errors, pending: c.pending, status: c.status}));\n+}\n+\n function asyncValidatorReturningObservable(c: AbstractControl) {\n   const e = new EventEmitter();\n   Promise.resolve(null).then(() => {\n@@ -981,6 +1014,538 @@ describe('FormGroup', () => {\n          expect(g.errors).toEqual({'async': true});\n          expect(g.get('one')!.errors).toEqual({'async': true});\n        }));\n+\n+    it('should handle successful async FormGroup resolving synchronously before a successful async child validator',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 1, shouldFail: false}));\n+         const g = new FormGroup(\n+             {'one': c}, null!, simpleAsyncValidator({timeout: 0, shouldFail: false}));\n+\n+         // Initially, the form control validation is pending, and the form group own validation has\n+         // synchronously resolved. Still, the form is in pending state due to its child\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: true, status: 'PENDING'},  // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, the form control validation has resolved\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: false, status: 'VALID'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},  // Control\n+         ]);\n+       }));\n+\n+    it('should handle successful async FormGroup resolving after a synchronously and successfully resolving child validator',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 0, shouldFail: false}));\n+         const g = new FormGroup(\n+             {'one': c}, null!, simpleAsyncValidator({timeout: 1, shouldFail: false}));\n+\n+         // Initially, form control validator has synchronously resolved. However, g has its own\n+         // pending validation\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},   // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, the form group validation has resolved\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: false, status: 'VALID'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},  // Control\n+         ]);\n+       }));\n+\n+    it('should handle successful async FormGroup and child control validators resolving synchronously',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 0, shouldFail: false}));\n+         const g = new FormGroup(\n+             {'one': c}, null!, simpleAsyncValidator({timeout: 0, shouldFail: false}));\n+\n+         // Both form control and form group successful async validators have resolved synchronously\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: false, status: 'VALID'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},  // Control\n+         ]);\n+       }));\n+\n+    it('should handle failing async FormGroup and failing child control validators resolving synchronously',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 0, shouldFail: true}));\n+         const g =\n+             new FormGroup({'one': c}, null!, simpleAsyncValidator({timeout: 0, shouldFail: true}));\n+\n+         // FormControl async validator has executed and failed synchronously with the default error\n+         // `{async: true}`. Next, the form group status is calculated. Since one of its children is\n+         // failing, the form group itself is marked `INVALID`. And its asynchronous validation is\n+         // not even triggered. Therefore, we end up with form group that is `INVALID` but whose\n+         // errors are null (child errors do not propagate and own async validation not event\n+         // triggered).\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: false, status: 'INVALID'},           // Group\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // Control\n+         ]);\n+       }));\n+\n+    it('should handle failing async FormGroup and successful child control validators resolving synchronously',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 0, shouldFail: false}));\n+         const g =\n+             new FormGroup({'one': c}, null!, simpleAsyncValidator({timeout: 0, shouldFail: true}));\n+\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},             // Control\n+         ]);\n+       }));\n+\n+    it('should handle failing async FormArray and successful children validators resolving synchronously',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 0, shouldFail: false}));\n+         const g = new FormGroup(\n+             {'one': c}, null!, simpleAsyncValidator({timeout: 0, shouldFail: false}));\n+\n+         const c2 =\n+             new FormControl('fcVal', null!, simpleAsyncValidator({timeout: 0, shouldFail: false}));\n+\n+         const a =\n+             new FormArray([g, c2], null!, simpleAsyncValidator({timeout: 0, shouldFail: true}));\n+\n+         expect(currentStateOf([a, a.at(0)!, a.at(1)!])).toEqual([\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // Array\n+           {errors: null, pending: false, status: 'VALID'},             // Group p\n+           {errors: null, pending: false, status: 'VALID'},             // Control c2\n+         ]);\n+       }));\n+\n+    it('should handle failing FormGroup validator resolving after successful child validator',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 1, shouldFail: false}));\n+         const g =\n+             new FormGroup({'one': c}, null!, simpleAsyncValidator({timeout: 2, shouldFail: true}));\n+\n+         // Initially, the form group and nested control are in pending state\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: true, status: 'PENDING'},  // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, only form control validation has resolved\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},   // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, the form group validation fails\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},             // Control\n+         ]);\n+       }));\n+\n+    it('should handle failing FormArray validator resolving after successful child validator',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 1, shouldFail: false}));\n+         const a = new FormArray([c], null!, simpleAsyncValidator({timeout: 2, shouldFail: true}));\n+\n+         // Initially, the form array and nested control are in pending state\n+         expect(currentStateOf([a, a.at(0)!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // FormArray\n+           {errors: null, pending: true, status: 'PENDING'},  // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, only form control validation has resolved\n+         expect(currentStateOf([a, a.at(0)!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // FormArray\n+           {errors: null, pending: false, status: 'VALID'},   // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, the form array validation fails\n+         expect(currentStateOf([a, a.at(0)!])).toEqual([\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // FormArray\n+           {errors: null, pending: false, status: 'VALID'},             // Control\n+         ]);\n+       }));\n+\n+    it('should handle successful FormGroup validator resolving after successful child validator',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 1, shouldFail: false}));\n+         const g = new FormGroup(\n+             {'one': c}, null!, simpleAsyncValidator({timeout: 2, shouldFail: false}));\n+\n+         // Initially, the form group and nested control are in pending state\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: true, status: 'PENDING'},  // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, only form control validation has resolved\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},   // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, the form group validation resolves\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: false, status: 'VALID'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},  // Control\n+         ]);\n+       }));\n+\n+    it('should handle successful FormArray validator resolving after successful child validators',\n+       fakeAsync(() => {\n+         const c1 = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 1, shouldFail: false}));\n+         const g = new FormGroup(\n+             {'one': c1}, null!, simpleAsyncValidator({timeout: 2, shouldFail: false}));\n+         const c2 =\n+             new FormControl('fcVal', null!, simpleAsyncValidator({timeout: 3, shouldFail: false}));\n+\n+         const a =\n+             new FormArray([g, c2], null!, simpleAsyncValidator({timeout: 4, shouldFail: false}));\n+\n+         // Initially, the form array and the tested form group and form control c2 are in pending\n+         // state\n+         expect(currentStateOf([a, a.at(0)!, a.at(1)!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // FormArray\n+           {errors: null, pending: true, status: 'PENDING'},  // g\n+           {errors: null, pending: true, status: 'PENDING'},  // c2\n+         ]);\n+\n+         tick(2);\n+\n+         // After 2ms, g validation has resolved\n+         expect(currentStateOf([a, a.at(0)!, a.at(1)!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // FormArray\n+           {errors: null, pending: false, status: 'VALID'},   // g\n+           {errors: null, pending: true, status: 'PENDING'},  // c2\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, c2 validation has resolved\n+         expect(currentStateOf([a, a.at(0)!, a.at(1)!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // FormArray\n+           {errors: null, pending: false, status: 'VALID'},   // g\n+           {errors: null, pending: false, status: 'VALID'},   // c2\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, FormArray own validation has resolved\n+         expect(currentStateOf([a, a.at(0)!, a.at(1)!])).toEqual([\n+           {errors: null, pending: false, status: 'VALID'},  // FormArray\n+           {errors: null, pending: false, status: 'VALID'},  // g\n+           {errors: null, pending: false, status: 'VALID'},  // c2\n+         ]);\n+       }));\n+\n+    it('should handle failing FormArray validator resolving after successful child validators',\n+       fakeAsync(() => {\n+         const c1 = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 1, shouldFail: false}));\n+         const g = new FormGroup(\n+             {'one': c1}, null!, simpleAsyncValidator({timeout: 2, shouldFail: false}));\n+         const c2 =\n+             new FormControl('fcVal', null!, simpleAsyncValidator({timeout: 3, shouldFail: false}));\n+\n+         const a =\n+             new FormArray([g, c2], null!, simpleAsyncValidator({timeout: 4, shouldFail: true}));\n+\n+         // Initially, the form array and the tested form group and form control c2 are in pending\n+         // state\n+         expect(currentStateOf([a, a.at(0)!, a.at(1)!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // FormArray\n+           {errors: null, pending: true, status: 'PENDING'},  // g\n+           {errors: null, pending: true, status: 'PENDING'},  // c2\n+         ]);\n+\n+         tick(2);\n+\n+         // After 2ms, g validation has resolved\n+         expect(currentStateOf([a, a.at(0)!, a.at(1)!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // FormArray\n+           {errors: null, pending: false, status: 'VALID'},   // g\n+           {errors: null, pending: true, status: 'PENDING'},  // c2\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, c2 validation has resolved\n+         expect(currentStateOf([a, a.at(0)!, a.at(1)!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // FormArray\n+           {errors: null, pending: false, status: 'VALID'},   // g\n+           {errors: null, pending: false, status: 'VALID'},   // c2\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, FormArray own validation has failed\n+         expect(currentStateOf([a, a.at(0)!, a.at(1)!])).toEqual([\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // FormArray\n+           {errors: null, pending: false, status: 'VALID'},             // g\n+           {errors: null, pending: false, status: 'VALID'},             // c2\n+         ]);\n+       }));\n+\n+    it('should handle multiple successful FormGroup validators resolving after successful child validator',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 1, shouldFail: false}));\n+         const g = new FormGroup({'one': c}, null!, [\n+           simpleAsyncValidator({timeout: 2, shouldFail: false}),\n+           simpleAsyncValidator({timeout: 3, shouldFail: false})\n+         ]);\n+\n+         // Initially, the form group and nested control are in pending state\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: true, status: 'PENDING'},  // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, only form control validation has resolved\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},   // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, one form async validator has resolved but not the second\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},   // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, the form group validation resolves\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: false, status: 'VALID'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},  // Control\n+         ]);\n+       }));\n+\n+    it('should handle multiple FormGroup validators (success then failure) resolving after successful child validator',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 1, shouldFail: false}));\n+         const g = new FormGroup({'one': c}, null!, [\n+           simpleAsyncValidator({timeout: 2, shouldFail: false}),\n+           simpleAsyncValidator({timeout: 3, shouldFail: true})\n+         ]);\n+\n+         // Initially, the form group and nested control are in pending state\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: true, status: 'PENDING'},  // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, only form control validation has resolved\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},   // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, one form async validator has resolved but not the second\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},   // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, the form group validation fails\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},             // Control\n+         ]);\n+       }));\n+\n+\n+    it('should handle multiple FormGroup validators (failure then success) resolving after successful child validator',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 1, shouldFail: false}));\n+         const g = new FormGroup({'one': c}, null!, [\n+           simpleAsyncValidator({timeout: 2, shouldFail: true}),\n+           simpleAsyncValidator({timeout: 3, shouldFail: false})\n+         ]);\n+\n+         // Initially, the form group and nested control are in pending state\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: true, status: 'PENDING'},  // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, only form control validation has resolved\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},   // Control\n+         ]);\n+\n+\n+         tick(1);\n+\n+         // All async validators are composed into one function. So, after 2ms, the FormGroup g is\n+         // still in pending state without errors\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},   // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, the form group validation fails\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},             // Control\n+         ]);\n+       }));\n+\n+\n+    it('should handle async validators in nested form groups / arrays', fakeAsync(() => {\n+         const c1 = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 1, shouldFail: false}));\n+\n+         const g1 = new FormGroup(\n+             {'one': c1}, null!, simpleAsyncValidator({timeout: 2, shouldFail: true}));\n+\n+         const c2 =\n+             new FormControl('fcVal', null!, simpleAsyncValidator({timeout: 3, shouldFail: false}));\n+\n+         const g2 =\n+             new FormArray([c2], null!, simpleAsyncValidator({timeout: 4, shouldFail: false}));\n+\n+         const g = new FormGroup(\n+             {'g1': g1, 'g2': g2}, null!, simpleAsyncValidator({timeout: 5, shouldFail: false}));\n+\n+         // Initially, the form group and nested control are in pending state\n+         expect(currentStateOf([g, g.get('g1')!, g.get('g2')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group g\n+           {errors: null, pending: true, status: 'PENDING'},  // Group g1\n+           {errors: null, pending: true, status: 'PENDING'},  // Group g2\n+         ]);\n+\n+         tick(2);\n+\n+         // After 2ms, g1 validation fails\n+         expect(currentStateOf([g, g.get('g1')!, g.get('g2')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},            // Group g\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // Group g1\n+           {errors: null, pending: true, status: 'PENDING'},            // Group g2\n+         ]);\n+\n+         tick(2);\n+\n+         // After 2ms, g2 validation resolves\n+         expect(currentStateOf([g, g.get('g1')!, g.get('g2')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},            // Group g\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // Group g1\n+           {errors: null, pending: false, status: 'VALID'},             // Group g2\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, g validation fails because g1 is invalid, but since errors do not cascade, so\n+         // we still have null errors for g\n+         expect(currentStateOf([g, g.get('g1')!, g.get('g2')!])).toEqual([\n+           {errors: null, pending: false, status: 'INVALID'},           // Group g\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // Group g1\n+           {errors: null, pending: false, status: 'VALID'},             // Group g2\n+         ]);\n+       }));\n+\n+    it('should handle failing FormGroup validator resolving before successful child validator',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 2, shouldFail: false}));\n+         const g =\n+             new FormGroup({'one': c}, null!, simpleAsyncValidator({timeout: 1, shouldFail: true}));\n+\n+         // Initially, the form group and nested control are in pending state\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // Group\n+           {errors: null, pending: true, status: 'PENDING'},  // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, form group validation fails\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // Group\n+           {errors: null, pending: true, status: 'PENDING'},            // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, child validation resolves\n+         expect(currentStateOf([g, g.get('one')!])).toEqual([\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // Group\n+           {errors: null, pending: false, status: 'VALID'},             // Control\n+         ]);\n+       }));\n+\n+    it('should handle failing FormArray validator resolving before successful child validator',\n+       fakeAsync(() => {\n+         const c = new FormControl(\n+             'fcValue', null!, simpleAsyncValidator({timeout: 2, shouldFail: false}));\n+         const a = new FormArray([c], null!, simpleAsyncValidator({timeout: 1, shouldFail: true}));\n+\n+         // Initially, the form array and nested control are in pending state\n+         expect(currentStateOf([a, a.at(0)!])).toEqual([\n+           {errors: null, pending: true, status: 'PENDING'},  // FormArray\n+           {errors: null, pending: true, status: 'PENDING'},  // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, form array validation fails\n+         expect(currentStateOf([a, a.at(0)!])).toEqual([\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // FormArray\n+           {errors: null, pending: true, status: 'PENDING'},            // Control\n+         ]);\n+\n+         tick(1);\n+\n+         // After 1ms, child validation resolves\n+         expect(currentStateOf([a, a.at(0)!])).toEqual([\n+           {errors: {async: true}, pending: false, status: 'INVALID'},  // FormArray\n+           {errors: null, pending: false, status: 'VALID'},             // Control\n+         ]);\n+       }));\n   });\n \n   describe('disable() & enable()', () => {"
        },
        {
            "sha": "b6e3fb37401bfd588d689618bafb5a5ef5135031",
            "filename": "packages/forms/test/reactive_integration_spec.ts",
            "status": "modified",
            "additions": 86,
            "deletions": 2,
            "changes": 88,
            "blob_url": "https://github.com/angular/angular/blob/77b62a52c0dc86bc3947778d161087e970768789/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/77b62a52c0dc86bc3947778d161087e970768789/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts?ref=77b62a52c0dc86bc3947778d161087e970768789",
            "patch": "@@ -2074,6 +2074,72 @@ import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n            expect(control.valid).toEqual(false);\n          }));\n \n+      it('should handle async validation changes in parent and child controls', fakeAsync(() => {\n+           const fixture = initTest(FormGroupComp);\n+           const control = new FormControl(\n+               '', Validators.required, asyncValidator(c => !!c.value && c.value.length > 3, 100));\n+           const form = new FormGroup(\n+               {'login': control}, null,\n+               asyncValidator(c => c.get('login')!.value.includes('angular'), 200));\n+           fixture.componentInstance.form = form;\n+           fixture.detectChanges();\n+           tick();\n+\n+           // Initially, the form is invalid because the nested mandatory control is empty\n+           expect(control.hasError('required')).toEqual(true);\n+           expect(form.value).toEqual({'login': ''});\n+           expect(form.invalid).toEqual(true);\n+\n+           // Setting a value in the form control that will trigger the registered asynchronous\n+           // validation\n+           const input = fixture.debugElement.query(By.css('input'));\n+           input.nativeElement.value = 'angul';\n+           dispatchEvent(input.nativeElement, 'input');\n+\n+           // The form control asynchronous validation is in progress (for 100 ms)\n+           expect(control.pending).toEqual(true);\n+\n+           tick(100);\n+\n+           // Now the asynchronous validation has resolved, and since the form control value\n+           // (`angul`) has a length > 3, the validation is successful\n+           expect(control.invalid).toEqual(false);\n+\n+           // Even if the child control is valid, the form control is pending because it is still\n+           // waiting for its own validation\n+           expect(form.pending).toEqual(true);\n+\n+           tick(100);\n+\n+           // Login form control is valid. However, the form control is invalid because `angul` does\n+           // not include `angular`\n+           expect(control.invalid).toEqual(false);\n+           expect(form.pending).toEqual(false);\n+           expect(form.invalid).toEqual(true);\n+\n+           // Setting a value that would be trigger \"VALID\" form state\n+           input.nativeElement.value = 'angular!';\n+           dispatchEvent(input.nativeElement, 'input');\n+\n+           // Since the form control value changed, its asynchronous validation runs for 100ms\n+           expect(control.pending).toEqual(true);\n+\n+           tick(100);\n+\n+           // Even if the child control is valid, the form control is pending because it is still\n+           // waiting for its own validation\n+           expect(control.invalid).toEqual(false);\n+           expect(form.pending).toEqual(true);\n+\n+           tick(100);\n+\n+           // Now, the form is valid because its own asynchronous validation has resolved\n+           // successfully, because the form control value `angular` includes the `angular` string\n+           expect(control.invalid).toEqual(false);\n+           expect(form.pending).toEqual(false);\n+           expect(form.invalid).toEqual(false);\n+         }));\n+\n       it('should cancel observable properly between validation runs', fakeAsync(() => {\n            const fixture = initTest(FormControlComp);\n            const resultArr: number[] = [];\n@@ -2383,18 +2449,36 @@ import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n   });\n }\n \n-function uniqLoginAsyncValidator(expectedValue: string, timeout: number = 0) {\n+/**\n+ * Creates an async validator using a checker function, a timeout and the error to emit in case of\n+ * validation failure\n+ *\n+ * @param checker A function to decide whether the validator will resolve with success or failure\n+ * @param timeout When the validation will resolve\n+ * @param error The error message to be emitted in case of validation failure\n+ *\n+ * @returns An async validator created using a checker function, a timeout and the error to emit in\n+ * case of validation failure\n+ */\n+function asyncValidator(\n+    checker: (c: AbstractControl) => boolean, timeout: number = 0, error: any = {\n+      'async': true\n+    }) {\n   return (c: AbstractControl) => {\n     let resolve: (result: any) => void;\n     const promise = new Promise<any>(res => {\n       resolve = res;\n     });\n-    const res = (c.value == expectedValue) ? null : {'uniqLogin': true};\n+    const res = checker(c) ? null : error;\n     setTimeout(() => resolve(res), timeout);\n     return promise;\n   };\n }\n \n+function uniqLoginAsyncValidator(expectedValue: string, timeout: number = 0) {\n+  return asyncValidator(c => c.value === expectedValue, timeout, {'uniqLogin': true});\n+}\n+\n function observableValidator(resultArr: number[]): AsyncValidatorFn {\n   return (c: AbstractControl) => {\n     return timer(100).pipe(tap((resp: any) => resultArr.push(resp)));"
        }
    ],
    "stats": {
        "total": 673,
        "additions": 668,
        "deletions": 5
    }
}