{
    "author": "petebacondarwin",
    "message": "refactor(compiler): use a named type for cooked/raw string objects (#38775)\n\nUsing an interface makes the code cleaner and more readable.\nThis change also adds the `range` property to the type to be used\nfor source-mapping.\n\nPR Close #38775",
    "sha": "6158dc16b497dda05e2307d185c4d2b8547a5cc2",
    "files": [
        {
            "sha": "d74bff43891b018eff8684867be5015d6eeed4ae",
            "filename": "packages/compiler/src/output/output_ast.ts",
            "status": "modified",
            "additions": 22,
            "deletions": 7,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/6158dc16b497dda05e2307d185c4d2b8547a5cc2/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_ast.ts",
            "raw_url": "https://github.com/angular/angular/raw/6158dc16b497dda05e2307d185c4d2b8547a5cc2/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_ast.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_ast.ts?ref=6158dc16b497dda05e2307d185c4d2b8547a5cc2",
            "patch": "@@ -545,7 +545,7 @@ export class LocalizedString extends Expression {\n    * @param meta The metadata to serialize\n    * @param messagePart The first part of the tagged string\n    */\n-  serializeI18nHead(): {cooked: string, raw: string} {\n+  serializeI18nHead(): CookedRawString {\n     const MEANING_SEPARATOR = '|';\n     const ID_SEPARATOR = '@@';\n     const LEGACY_ID_INDICATOR = 'âŸ';\n@@ -562,7 +562,8 @@ export class LocalizedString extends Expression {\n         metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n       });\n     }\n-    return createCookedRawString(metaBlock, this.messageParts[0].text);\n+    return createCookedRawString(\n+        metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n   }\n \n   getMessagePartSourceSpan(i: number): ParseSourceSpan|null {\n@@ -581,13 +582,24 @@ export class LocalizedString extends Expression {\n    * @param placeholderName The placeholder name to serialize\n    * @param messagePart The following message string after this placeholder\n    */\n-  serializeI18nTemplatePart(partIndex: number): {cooked: string, raw: string} {\n+  serializeI18nTemplatePart(partIndex: number): CookedRawString {\n     const placeholderName = this.placeHolderNames[partIndex - 1].text;\n     const messagePart = this.messageParts[partIndex];\n-    return createCookedRawString(placeholderName, messagePart.text);\n+    return createCookedRawString(\n+        placeholderName, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n   }\n }\n \n+/**\n+ * A structure to hold the cooked and raw strings of a template literal element, along with its\n+ * source-span range.\n+ */\n+export interface CookedRawString {\n+  cooked: string;\n+  raw: string;\n+  range: ParseSourceSpan|null;\n+}\n+\n const escapeSlashes = (str: string): string => str.replace(/\\\\/g, '\\\\\\\\');\n const escapeStartingColon = (str: string): string => str.replace(/^:/, '\\\\:');\n const escapeColons = (str: string): string => str.replace(/:/g, '\\\\:');\n@@ -608,17 +620,20 @@ const escapeForMessagePart = (str: string): string =>\n  * @param metaBlock Any metadata that should be prepended to the string\n  * @param messagePart The message part of the string\n  */\n-function createCookedRawString(metaBlock: string, messagePart: string) {\n+function createCookedRawString(\n+    metaBlock: string, messagePart: string, range: ParseSourceSpan|null): CookedRawString {\n   if (metaBlock === '') {\n     return {\n       cooked: messagePart,\n-      raw: escapeForMessagePart(escapeStartingColon(escapeSlashes(messagePart)))\n+      raw: escapeForMessagePart(escapeStartingColon(escapeSlashes(messagePart))),\n+      range,\n     };\n   } else {\n     return {\n       cooked: `:${metaBlock}:${messagePart}`,\n       raw: escapeForMessagePart(\n-          `:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`)\n+          `:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),\n+      range,\n     };\n   }\n }"
        },
        {
            "sha": "2ed1dba0f7544093eb1ba364d779585a628cea6b",
            "filename": "packages/compiler/test/render3/view/i18n_spec.ts",
            "status": "modified",
            "additions": 52,
            "deletions": 21,
            "changes": 73,
            "blob_url": "https://github.com/angular/angular/blob/6158dc16b497dda05e2307d185c4d2b8547a5cc2/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Fi18n_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6158dc16b497dda05e2307d185c4d2b8547a5cc2/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Fi18n_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Fi18n_spec.ts?ref=6158dc16b497dda05e2307d185c4d2b8547a5cc2",
            "patch": "@@ -223,76 +223,107 @@ describe('Utils', () => {\n \n     it('serializeI18nHead()', () => {\n       expect(o.localizedString(meta(), [literal('')], [], []).serializeI18nHead())\n-          .toEqual({cooked: '', raw: ''});\n+          .toEqual({cooked: '', raw: '', range: jasmine.any(ParseSourceSpan)});\n       expect(o.localizedString(meta('', '', 'desc'), [literal('')], [], []).serializeI18nHead())\n-          .toEqual({cooked: ':desc:', raw: ':desc:'});\n+          .toEqual({cooked: ':desc:', raw: ':desc:', range: jasmine.any(ParseSourceSpan)});\n       expect(o.localizedString(meta('id', '', 'desc'), [literal('')], [], []).serializeI18nHead())\n-          .toEqual({cooked: ':desc@@id:', raw: ':desc@@id:'});\n+          .toEqual({cooked: ':desc@@id:', raw: ':desc@@id:', range: jasmine.any(ParseSourceSpan)});\n       expect(\n           o.localizedString(meta('', 'meaning', 'desc'), [literal('')], [], []).serializeI18nHead())\n-          .toEqual({cooked: ':meaning|desc:', raw: ':meaning|desc:'});\n+          .toEqual({\n+            cooked: ':meaning|desc:',\n+            raw: ':meaning|desc:',\n+            range: jasmine.any(ParseSourceSpan)\n+          });\n       expect(o.localizedString(meta('id', 'meaning', 'desc'), [literal('')], [], [])\n                  .serializeI18nHead())\n-          .toEqual({cooked: ':meaning|desc@@id:', raw: ':meaning|desc@@id:'});\n+          .toEqual({\n+            cooked: ':meaning|desc@@id:',\n+            raw: ':meaning|desc@@id:',\n+            range: jasmine.any(ParseSourceSpan)\n+          });\n       expect(o.localizedString(meta('id', '', ''), [literal('')], [], []).serializeI18nHead())\n-          .toEqual({cooked: ':@@id:', raw: ':@@id:'});\n+          .toEqual({cooked: ':@@id:', raw: ':@@id:', range: jasmine.any(ParseSourceSpan)});\n \n       // Escaping colons (block markers)\n       expect(o.localizedString(meta('id:sub_id', 'meaning', 'desc'), [literal('')], [], [])\n                  .serializeI18nHead())\n-          .toEqual({cooked: ':meaning|desc@@id:sub_id:', raw: ':meaning|desc@@id\\\\:sub_id:'});\n+          .toEqual({\n+            cooked: ':meaning|desc@@id:sub_id:',\n+            raw: ':meaning|desc@@id\\\\:sub_id:',\n+            range: jasmine.any(ParseSourceSpan)\n+          });\n       expect(o.localizedString(meta('id', 'meaning:sub_meaning', 'desc'), [literal('')], [], [])\n                  .serializeI18nHead())\n-          .toEqual(\n-              {cooked: ':meaning:sub_meaning|desc@@id:', raw: ':meaning\\\\:sub_meaning|desc@@id:'});\n+          .toEqual({\n+            cooked: ':meaning:sub_meaning|desc@@id:',\n+            raw: ':meaning\\\\:sub_meaning|desc@@id:',\n+            range: jasmine.any(ParseSourceSpan)\n+          });\n       expect(o.localizedString(meta('id', 'meaning', 'desc:sub_desc'), [literal('')], [], [])\n                  .serializeI18nHead())\n-          .toEqual({cooked: ':meaning|desc:sub_desc@@id:', raw: ':meaning|desc\\\\:sub_desc@@id:'});\n+          .toEqual({\n+            cooked: ':meaning|desc:sub_desc@@id:',\n+            raw: ':meaning|desc\\\\:sub_desc@@id:',\n+            range: jasmine.any(ParseSourceSpan)\n+          });\n       expect(o.localizedString(meta('id', 'meaning', 'desc'), [literal('message source')], [], [])\n                  .serializeI18nHead())\n           .toEqual({\n             cooked: ':meaning|desc@@id:message source',\n-            raw: ':meaning|desc@@id:message source'\n+            raw: ':meaning|desc@@id:message source',\n+            range: jasmine.any(ParseSourceSpan)\n           });\n       expect(o.localizedString(meta('id', 'meaning', 'desc'), [literal(':message source')], [], [])\n                  .serializeI18nHead())\n           .toEqual({\n             cooked: ':meaning|desc@@id::message source',\n-            raw: ':meaning|desc@@id::message source'\n+            raw: ':meaning|desc@@id::message source',\n+            range: jasmine.any(ParseSourceSpan)\n           });\n       expect(o.localizedString(meta('', '', ''), [literal('message source')], [], [])\n                  .serializeI18nHead())\n-          .toEqual({cooked: 'message source', raw: 'message source'});\n+          .toEqual({\n+            cooked: 'message source',\n+            raw: 'message source',\n+            range: jasmine.any(ParseSourceSpan)\n+          });\n       expect(o.localizedString(meta('', '', ''), [literal(':message source')], [], [])\n                  .serializeI18nHead())\n-          .toEqual({cooked: ':message source', raw: '\\\\:message source'});\n+          .toEqual({\n+            cooked: ':message source',\n+            raw: '\\\\:message source',\n+            range: jasmine.any(ParseSourceSpan)\n+          });\n     });\n \n     it('serializeI18nPlaceholderBlock()', () => {\n       expect(o.localizedString(meta('', '', ''), [literal(''), literal('')], [literal('')], [])\n                  .serializeI18nTemplatePart(1))\n-          .toEqual({cooked: '', raw: ''});\n+          .toEqual({cooked: '', raw: '', range: jasmine.any(ParseSourceSpan)});\n       expect(o.localizedString(\n                   meta('', '', ''), [literal(''), literal('')],\n                   [new o.LiteralPiece('abc', {} as any)], [])\n                  .serializeI18nTemplatePart(1))\n-          .toEqual({cooked: ':abc:', raw: ':abc:'});\n+          .toEqual({cooked: ':abc:', raw: ':abc:', range: jasmine.any(ParseSourceSpan)});\n       expect(\n           o.localizedString(meta('', '', ''), [literal(''), literal('message')], [literal('')], [])\n               .serializeI18nTemplatePart(1))\n-          .toEqual({cooked: 'message', raw: 'message'});\n+          .toEqual({cooked: 'message', raw: 'message', range: jasmine.any(ParseSourceSpan)});\n       expect(o.localizedString(\n                   meta('', '', ''), [literal(''), literal('message')], [literal('abc')], [])\n                  .serializeI18nTemplatePart(1))\n-          .toEqual({cooked: ':abc:message', raw: ':abc:message'});\n+          .toEqual(\n+              {cooked: ':abc:message', raw: ':abc:message', range: jasmine.any(ParseSourceSpan)});\n       expect(\n           o.localizedString(meta('', '', ''), [literal(''), literal(':message')], [literal('')], [])\n               .serializeI18nTemplatePart(1))\n-          .toEqual({cooked: ':message', raw: '\\\\:message'});\n+          .toEqual({cooked: ':message', raw: '\\\\:message', range: jasmine.any(ParseSourceSpan)});\n       expect(o.localizedString(\n                   meta('', '', ''), [literal(''), literal(':message')], [literal('abc')], [])\n                  .serializeI18nTemplatePart(1))\n-          .toEqual({cooked: ':abc::message', raw: ':abc::message'});\n+          .toEqual(\n+              {cooked: ':abc::message', raw: ':abc::message', range: jasmine.any(ParseSourceSpan)});\n     });\n \n     function meta(customId?: string, meaning?: string, description?: string): I18nMeta {\n@@ -563,4 +594,4 @@ function literal(text: string, span: any = jasmine.any(ParseSourceSpan)): o.Lite\n \n function placeholder(name: string, span: any = jasmine.any(ParseSourceSpan)): o.PlaceholderPiece {\n   return new o.PlaceholderPiece(name, span);\n-}\n+}\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 102,
        "additions": 74,
        "deletions": 28
    }
}