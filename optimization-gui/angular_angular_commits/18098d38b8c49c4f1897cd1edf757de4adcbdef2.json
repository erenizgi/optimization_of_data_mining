{
    "author": "JoostK",
    "message": "fix(compiler-cli): avoid creating value expressions for symbols from type-only imports (#37912)\n\nIn TypeScript 3.8 support was added for type-only imports, which only brings in\nthe symbol as a type, not their value. The Angular compiler did not yet take\nthe type-only keyword into account when representing symbols in type positions\nas value expressions. The class metadata that the compiler emits would include\nthe value expression for its parameter types, generating actual imports as\nnecessary. For type-only imports this should not be done, as it introduces an\nactual import of the module that was originally just a type-only import.\n\nThis commit lets the compiler deal with type-only imports specially, preventing\na value expression from being created.\n\nFixes #37900\n\nPR Close #37912",
    "sha": "18098d38b8c49c4f1897cd1edf757de4adcbdef2",
    "files": [
        {
            "sha": "579ab00546a9c2267e455af07c26ce4deac9c199",
            "filename": "packages/compiler-cli/ngcc/src/host/esm2015_host.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fesm2015_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fesm2015_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fesm2015_host.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -10,7 +10,7 @@ import * as ts from 'typescript';\n import {absoluteFromSourceFile} from '../../../src/ngtsc/file_system';\n \n import {Logger} from '../../../src/ngtsc/logging';\n-import {ClassDeclaration, ClassMember, ClassMemberKind, CtorParameter, Declaration, Decorator, EnumMember, isDecoratorIdentifier, isNamedClassDeclaration, isNamedFunctionDeclaration, isNamedVariableDeclaration, KnownDeclaration, reflectObjectLiteral, SpecialDeclarationKind, TypeScriptReflectionHost, TypeValueReference} from '../../../src/ngtsc/reflection';\n+import {ClassDeclaration, ClassMember, ClassMemberKind, CtorParameter, Declaration, Decorator, EnumMember, isDecoratorIdentifier, isNamedClassDeclaration, isNamedFunctionDeclaration, isNamedVariableDeclaration, KnownDeclaration, reflectObjectLiteral, SpecialDeclarationKind, TypeScriptReflectionHost, TypeValueReference, TypeValueReferenceKind, ValueUnavailableKind} from '../../../src/ngtsc/reflection';\n import {isWithinPackage} from '../analysis/util';\n import {BundleProgram} from '../packages/bundle_program';\n import {findAll, getNameText, hasNameIdentifier, isDefined, stripDollarSuffix} from '../utils';\n@@ -1594,7 +1594,7 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n           {decorators: null, typeExpression: null};\n       const nameNode = node.name;\n \n-      let typeValueReference: TypeValueReference|null = null;\n+      let typeValueReference: TypeValueReference;\n       if (typeExpression !== null) {\n         // `typeExpression` is an expression in a \"type\" context. Resolve it to a declared value.\n         // Either it's a reference to an imported type, or a type declared locally. Distinguish the\n@@ -1603,19 +1603,24 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n         if (decl !== null && decl.node !== null && decl.viaModule !== null &&\n             isNamedDeclaration(decl.node)) {\n           typeValueReference = {\n-            local: false,\n+            kind: TypeValueReferenceKind.IMPORTED,\n             valueDeclaration: decl.node,\n             moduleName: decl.viaModule,\n             importedName: decl.node.name.text,\n             nestedPath: null,\n           };\n         } else {\n           typeValueReference = {\n-            local: true,\n+            kind: TypeValueReferenceKind.LOCAL,\n             expression: typeExpression,\n             defaultImportStatement: null,\n           };\n         }\n+      } else {\n+        typeValueReference = {\n+          kind: TypeValueReferenceKind.UNAVAILABLE,\n+          reason: {kind: ValueUnavailableKind.MISSING_TYPE},\n+        };\n       }\n \n       return {"
        },
        {
            "sha": "922b88f777f39fa30d8a644bd395db3ad5b91b6d",
            "filename": "packages/compiler-cli/ngcc/test/host/commonjs_host_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fcommonjs_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fcommonjs_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fcommonjs_host_spec.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -10,7 +10,7 @@ import * as ts from 'typescript';\n import {absoluteFrom, getFileSystem, getSourceFileOrError} from '../../../src/ngtsc/file_system';\n import {runInEachFileSystem, TestFile} from '../../../src/ngtsc/file_system/testing';\n import {MockLogger} from '../../../src/ngtsc/logging/testing';\n-import {ClassMemberKind, ConcreteDeclaration, CtorParameter, DownleveledEnum, InlineDeclaration, isNamedClassDeclaration, isNamedFunctionDeclaration, isNamedVariableDeclaration, KnownDeclaration, TypeScriptReflectionHost} from '../../../src/ngtsc/reflection';\n+import {ClassMemberKind, ConcreteDeclaration, CtorParameter, DownleveledEnum, InlineDeclaration, isNamedClassDeclaration, isNamedFunctionDeclaration, isNamedVariableDeclaration, KnownDeclaration, TypeScriptReflectionHost, TypeValueReferenceKind} from '../../../src/ngtsc/reflection';\n import {getDeclaration} from '../../../src/ngtsc/testing';\n import {loadFakeCore, loadTestFiles} from '../../../test/helpers';\n import {CommonJsReflectionHost} from '../../src/host/commonjs_host';\n@@ -1599,7 +1599,7 @@ exports.MissingClass2 = MissingClass2;\n               isNamedVariableDeclaration);\n           const ctrDecorators = host.getConstructorParameters(classNode)!;\n           const identifierOfViewContainerRef = (ctrDecorators[0].typeValueReference! as {\n-                                                 local: true,\n+                                                 kind: TypeValueReferenceKind.LOCAL,\n                                                  expression: ts.Identifier,\n                                                  defaultImportStatement: null,\n                                                }).expression;"
        },
        {
            "sha": "20a8c35a8b2409fc09992059536c97dea6bdf5a5",
            "filename": "packages/compiler-cli/ngcc/test/host/esm2015_host_import_helper_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm2015_host_import_helper_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm2015_host_import_helper_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm2015_host_import_helper_spec.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -11,7 +11,7 @@ import * as ts from 'typescript';\n import {absoluteFrom, getFileSystem, getSourceFileOrError} from '../../../src/ngtsc/file_system';\n import {runInEachFileSystem, TestFile} from '../../../src/ngtsc/file_system/testing';\n import {MockLogger} from '../../../src/ngtsc/logging/testing';\n-import {ClassMemberKind, isNamedVariableDeclaration} from '../../../src/ngtsc/reflection';\n+import {ClassMemberKind, isNamedVariableDeclaration, TypeValueReferenceKind} from '../../../src/ngtsc/reflection';\n import {getDeclaration} from '../../../src/ngtsc/testing';\n import {loadFakeCore, loadTestFiles, loadTsLib} from '../../../test/helpers';\n import {Esm2015ReflectionHost} from '../../src/host/esm2015_host';\n@@ -484,7 +484,7 @@ runInEachFileSystem(() => {\n                 isNamedVariableDeclaration);\n             const ctrDecorators = host.getConstructorParameters(classNode)!;\n             const identifierOfViewContainerRef = (ctrDecorators[0].typeValueReference! as {\n-                                                   local: true,\n+                                                   kind: TypeValueReferenceKind.LOCAL,\n                                                    expression: ts.Identifier,\n                                                    defaultImportStatement: null,\n                                                  }).expression;"
        },
        {
            "sha": "5e7251bfc33cfd96facb1843054fa00db38cf573",
            "filename": "packages/compiler-cli/ngcc/test/host/esm5_host_import_helper_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm5_host_import_helper_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm5_host_import_helper_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm5_host_import_helper_spec.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -10,7 +10,7 @@ import * as ts from 'typescript';\n import {absoluteFrom, getFileSystem, getSourceFileOrError} from '../../../src/ngtsc/file_system';\n import {runInEachFileSystem, TestFile} from '../../../src/ngtsc/file_system/testing';\n import {MockLogger} from '../../../src/ngtsc/logging/testing';\n-import {ClassMemberKind, isNamedFunctionDeclaration, isNamedVariableDeclaration} from '../../../src/ngtsc/reflection';\n+import {ClassMemberKind, isNamedFunctionDeclaration, isNamedVariableDeclaration, TypeValueReferenceKind} from '../../../src/ngtsc/reflection';\n import {getDeclaration} from '../../../src/ngtsc/testing';\n import {loadFakeCore, loadTestFiles, loadTsLib} from '../../../test/helpers';\n import {getIifeBody} from '../../src/host/esm2015_host';\n@@ -544,7 +544,7 @@ export { AliasedDirective$1 };\n                 isNamedVariableDeclaration);\n             const ctrDecorators = host.getConstructorParameters(classNode)!;\n             const identifierOfViewContainerRef = (ctrDecorators[0].typeValueReference! as {\n-                                                   local: true,\n+                                                   kind: TypeValueReferenceKind.LOCAL,\n                                                    expression: ts.Identifier,\n                                                    defaultImportStatement: null,\n                                                  }).expression;"
        },
        {
            "sha": "6e219658c5c95aee5fa166bd28f8c40e18308a49",
            "filename": "packages/compiler-cli/ngcc/test/host/esm5_host_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm5_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm5_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm5_host_spec.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -11,7 +11,7 @@ import * as ts from 'typescript';\n import {absoluteFrom, getFileSystem, getSourceFileOrError} from '../../../src/ngtsc/file_system';\n import {runInEachFileSystem, TestFile} from '../../../src/ngtsc/file_system/testing';\n import {MockLogger} from '../../../src/ngtsc/logging/testing';\n-import {ClassMemberKind, ConcreteDeclaration, CtorParameter, Decorator, DownleveledEnum, isNamedClassDeclaration, isNamedFunctionDeclaration, isNamedVariableDeclaration, KnownDeclaration, TypeScriptReflectionHost} from '../../../src/ngtsc/reflection';\n+import {ClassMemberKind, ConcreteDeclaration, CtorParameter, Decorator, DownleveledEnum, isNamedClassDeclaration, isNamedFunctionDeclaration, isNamedVariableDeclaration, KnownDeclaration, TypeScriptReflectionHost, TypeValueReferenceKind} from '../../../src/ngtsc/reflection';\n import {getDeclaration} from '../../../src/ngtsc/testing';\n import {loadFakeCore, loadTestFiles} from '../../../test/helpers';\n import {DelegatingReflectionHost} from '../../src/host/delegating_host';\n@@ -1670,7 +1670,7 @@ runInEachFileSystem(() => {\n             bundle.program, SOME_DIRECTIVE_FILE.name, 'SomeDirective', isNamedVariableDeclaration);\n         const ctrDecorators = host.getConstructorParameters(classNode)!;\n         const identifierOfViewContainerRef = (ctrDecorators[0].typeValueReference! as {\n-                                               local: true,\n+                                               kind: TypeValueReferenceKind.LOCAL,\n                                                expression: ts.Identifier,\n                                                defaultImportStatement: null,\n                                              }).expression;"
        },
        {
            "sha": "01a10eb4bb8bce6018af67d9263a78f8f1ff69e2",
            "filename": "packages/compiler-cli/ngcc/test/host/umd_host_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fumd_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fumd_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fumd_host_spec.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -11,7 +11,7 @@ import * as ts from 'typescript';\n import {absoluteFrom, getFileSystem, getSourceFileOrError} from '../../../src/ngtsc/file_system';\n import {runInEachFileSystem, TestFile} from '../../../src/ngtsc/file_system/testing';\n import {MockLogger} from '../../../src/ngtsc/logging/testing';\n-import {ClassMemberKind, ConcreteDeclaration, CtorParameter, DownleveledEnum, Import, InlineDeclaration, isNamedClassDeclaration, isNamedFunctionDeclaration, isNamedVariableDeclaration, KnownDeclaration, TypeScriptReflectionHost} from '../../../src/ngtsc/reflection';\n+import {ClassMemberKind, ConcreteDeclaration, CtorParameter, DownleveledEnum, Import, InlineDeclaration, isNamedClassDeclaration, isNamedFunctionDeclaration, isNamedVariableDeclaration, KnownDeclaration, TypeScriptReflectionHost, TypeValueReferenceKind} from '../../../src/ngtsc/reflection';\n import {getDeclaration} from '../../../src/ngtsc/testing';\n import {loadFakeCore, loadTestFiles} from '../../../test/helpers';\n import {DelegatingReflectionHost} from '../../src/host/delegating_host';\n@@ -1709,7 +1709,7 @@ runInEachFileSystem(() => {\n             bundle.program, SOME_DIRECTIVE_FILE.name, 'SomeDirective', isNamedVariableDeclaration);\n         const ctrDecorators = host.getConstructorParameters(classNode)!;\n         const identifierOfViewContainerRef = (ctrDecorators[0].typeValueReference! as {\n-                                               local: true,\n+                                               kind: TypeValueReferenceKind.LOCAL,\n                                                expression: ts.Identifier,\n                                                defaultImportStatement: null,\n                                              }).expression;"
        },
        {
            "sha": "c27594c6cf7359ea82dea14d1e63d4993dded92d",
            "filename": "packages/compiler-cli/ngcc/test/host/util.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Futil.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -1,4 +1,3 @@\n-\n /**\n  * @license\n  * Copyright Google LLC All Rights Reserved.\n@@ -7,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n import * as ts from 'typescript';\n-import {CtorParameter} from '../../../src/ngtsc/reflection';\n+import {CtorParameter, TypeValueReferenceKind} from '../../../src/ngtsc/reflection';\n \n /**\n  * Check that a given list of `CtorParameter`s has `typeValueReference`s of specific `ts.Identifier`\n@@ -18,19 +17,21 @@ export function expectTypeValueReferencesForParameters(\n   parameters!.forEach((param, idx) => {\n     const expected = expectedParams[idx];\n     if (expected !== null) {\n-      if (param.typeValueReference === null) {\n+      if (param.typeValueReference.kind === TypeValueReferenceKind.UNAVAILABLE) {\n         fail(`Incorrect typeValueReference generated, expected ${expected}`);\n-      } else if (param.typeValueReference.local && fromModule !== null) {\n+      } else if (\n+          param.typeValueReference.kind === TypeValueReferenceKind.LOCAL && fromModule !== null) {\n         fail(`Incorrect typeValueReference generated, expected non-local`);\n-      } else if (!param.typeValueReference.local && fromModule === null) {\n+      } else if (\n+          param.typeValueReference.kind !== TypeValueReferenceKind.LOCAL && fromModule === null) {\n         fail(`Incorrect typeValueReference generated, expected local`);\n-      } else if (param.typeValueReference.local) {\n+      } else if (param.typeValueReference.kind === TypeValueReferenceKind.LOCAL) {\n         if (!ts.isIdentifier(param.typeValueReference.expression)) {\n-          fail(`Incorrect typeValueReference generated, expected identifer`);\n+          fail(`Incorrect typeValueReference generated, expected identifier`);\n         } else {\n           expect(param.typeValueReference.expression.text).toEqual(expected);\n         }\n-      } else if (param.typeValueReference !== null) {\n+      } else if (param.typeValueReference.kind === TypeValueReferenceKind.IMPORTED) {\n         expect(param.typeValueReference.moduleName).toBe(fromModule!);\n         expect(param.typeValueReference.importedName).toBe(expected);\n       }"
        },
        {
            "sha": "af855d3b431b794b3516c5342c394b567f60b2b7",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/metadata.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fmetadata.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fmetadata.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fmetadata.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -10,7 +10,7 @@ import {Expression, ExternalExpr, FunctionExpr, Identifiers, InvokeFunctionExpr,\n import * as ts from 'typescript';\n \n import {DefaultImportRecorder} from '../../imports';\n-import {CtorParameter, Decorator, ReflectionHost} from '../../reflection';\n+import {CtorParameter, Decorator, ReflectionHost, TypeValueReferenceKind} from '../../reflection';\n \n import {valueReferenceToExpression, wrapFunctionExpressionsInParens} from './util';\n \n@@ -105,7 +105,7 @@ function ctorParameterToMetadata(\n     isCore: boolean): Expression {\n   // Parameters sometimes have a type that can be referenced. If so, then use it, otherwise\n   // its type is undefined.\n-  const type = param.typeValueReference !== null ?\n+  const type = param.typeValueReference.kind !== TypeValueReferenceKind.UNAVAILABLE ?\n       valueReferenceToExpression(param.typeValueReference, defaultImportRecorder) :\n       new LiteralExpr(undefined);\n "
        },
        {
            "sha": "6db327724cac5ecb6efa3a782886be1e5c37a12f",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/util.ts",
            "status": "modified",
            "additions": 88,
            "deletions": 32,
            "changes": 120,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Futil.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -12,13 +12,9 @@ import * as ts from 'typescript';\n import {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\n import {DefaultImportRecorder, ImportFlags, Reference, ReferenceEmitter} from '../../imports';\n import {ForeignFunctionResolver, PartialEvaluator} from '../../partial_evaluator';\n-import {ClassDeclaration, CtorParameter, Decorator, Import, isNamedClassDeclaration, ReflectionHost, TypeValueReference} from '../../reflection';\n+import {ClassDeclaration, CtorParameter, Decorator, Import, ImportedTypeValueReference, isNamedClassDeclaration, LocalTypeValueReference, ReflectionHost, TypeValueReference, TypeValueReferenceKind, UnavailableValue, ValueUnavailableKind} from '../../reflection';\n import {DeclarationData} from '../../scope';\n \n-export enum ConstructorDepErrorKind {\n-  NO_SUITABLE_TOKEN,\n-}\n-\n export type ConstructorDeps = {\n   deps: R3DependencyMetadata[];\n }|{\n@@ -29,7 +25,7 @@ export type ConstructorDeps = {\n export interface ConstructorDepError {\n   index: number;\n   param: CtorParameter;\n-  kind: ConstructorDepErrorKind;\n+  reason: UnavailableValue;\n }\n \n export function getConstructorDependencies(\n@@ -94,10 +90,14 @@ export function getConstructorDependencies(\n       resolved = R3ResolvedDependencyType.ChangeDetectorRef;\n     }\n     if (token === null) {\n+      if (param.typeValueReference.kind !== TypeValueReferenceKind.UNAVAILABLE) {\n+        throw new Error(\n+            'Illegal state: expected value reference to be unavailable if no token is present');\n+      }\n       errors.push({\n         index: idx,\n-        kind: ConstructorDepErrorKind.NO_SUITABLE_TOKEN,\n         param,\n+        reason: param.typeValueReference.reason,\n       });\n     } else {\n       deps.push({token, attribute, optional, self, skipSelf, host, resolved});\n@@ -118,35 +118,26 @@ export function getConstructorDependencies(\n  * file in which the `TypeValueReference` originated.\n  */\n export function valueReferenceToExpression(\n-    valueRef: TypeValueReference, defaultImportRecorder: DefaultImportRecorder): Expression;\n-export function valueReferenceToExpression(\n-    valueRef: null, defaultImportRecorder: DefaultImportRecorder): null;\n+    valueRef: LocalTypeValueReference|ImportedTypeValueReference,\n+    defaultImportRecorder: DefaultImportRecorder): Expression;\n export function valueReferenceToExpression(\n-    valueRef: TypeValueReference|null, defaultImportRecorder: DefaultImportRecorder): Expression|\n-    null;\n+    valueRef: TypeValueReference, defaultImportRecorder: DefaultImportRecorder): Expression|null;\n export function valueReferenceToExpression(\n-    valueRef: TypeValueReference|null, defaultImportRecorder: DefaultImportRecorder): Expression|\n-    null {\n-  if (valueRef === null) {\n+    valueRef: TypeValueReference, defaultImportRecorder: DefaultImportRecorder): Expression|null {\n+  if (valueRef.kind === TypeValueReferenceKind.UNAVAILABLE) {\n     return null;\n-  } else if (valueRef.local) {\n+  } else if (valueRef.kind === TypeValueReferenceKind.LOCAL) {\n     if (defaultImportRecorder !== null && valueRef.defaultImportStatement !== null &&\n         ts.isIdentifier(valueRef.expression)) {\n       defaultImportRecorder.recordImportedIdentifier(\n           valueRef.expression, valueRef.defaultImportStatement);\n     }\n     return new WrappedNodeExpr(valueRef.expression);\n   } else {\n-    // TODO(alxhub): this cast is necessary because the g3 typescript version doesn't narrow here.\n-    const ref = valueRef as {\n-      moduleName: string;\n-      importedName: string;\n-      nestedPath: string[]|null;\n-    };\n     let importExpr: Expression =\n-        new ExternalExpr({moduleName: ref.moduleName, name: ref.importedName});\n-    if (ref.nestedPath !== null) {\n-      for (const property of ref.nestedPath) {\n+        new ExternalExpr({moduleName: valueRef.moduleName, name: valueRef.importedName});\n+    if (valueRef.nestedPath !== null) {\n+      for (const property of valueRef.nestedPath) {\n         importExpr = new ReadPropExpr(importExpr, property);\n       }\n     }\n@@ -195,15 +186,80 @@ export function validateConstructorDependencies(\n     return deps.deps;\n   } else {\n     // TODO(alxhub): this cast is necessary because the g3 typescript version doesn't narrow here.\n-    const {param, index} = (deps as {errors: ConstructorDepError[]}).errors[0];\n     // There is at least one error.\n-    throw new FatalDiagnosticError(\n-        ErrorCode.PARAM_MISSING_TOKEN, param.nameNode,\n-        `No suitable injection token for parameter '${param.name || index}' of class '${\n-            clazz.name.text}'.\\n` +\n-            (param.typeNode !== null ? `Found ${param.typeNode.getText()}` :\n-                                       'no type or decorator'));\n+    const error = (deps as {errors: ConstructorDepError[]}).errors[0];\n+    throw createUnsuitableInjectionTokenError(clazz, error);\n+  }\n+}\n+\n+/**\n+ * Creates a fatal error with diagnostic for an invalid injection token.\n+ * @param clazz The class for which the injection token was unavailable.\n+ * @param error The reason why no valid injection token is available.\n+ */\n+function createUnsuitableInjectionTokenError(\n+    clazz: ClassDeclaration, error: ConstructorDepError): FatalDiagnosticError {\n+  const {param, index, reason} = error;\n+  let chainMessage: string|undefined = undefined;\n+  let hints: ts.DiagnosticRelatedInformation[]|undefined = undefined;\n+  switch (reason.kind) {\n+    case ValueUnavailableKind.UNSUPPORTED:\n+      chainMessage = 'Consider using the @Inject decorator to specify an injection token.';\n+      hints = [\n+        makeRelatedInformation(reason.typeNode, 'This type is not supported as injection token.'),\n+      ];\n+      break;\n+    case ValueUnavailableKind.NO_VALUE_DECLARATION:\n+      chainMessage = 'Consider using the @Inject decorator to specify an injection token.';\n+      hints = [\n+        makeRelatedInformation(\n+            reason.typeNode,\n+            'This type does not have a value, so it cannot be used as injection token.'),\n+        makeRelatedInformation(reason.decl, 'The type is declared here.'),\n+      ];\n+      break;\n+    case ValueUnavailableKind.TYPE_ONLY_IMPORT:\n+      chainMessage =\n+          'Consider changing the type-only import to a regular import, or use the @Inject decorator to specify an injection token.';\n+      hints = [\n+        makeRelatedInformation(\n+            reason.typeNode,\n+            'This type is imported using a type-only import, which prevents it from being usable as an injection token.'),\n+        makeRelatedInformation(reason.importClause, 'The type-only import occurs here.'),\n+      ];\n+      break;\n+    case ValueUnavailableKind.NAMESPACE:\n+      chainMessage = 'Consider using the @Inject decorator to specify an injection token.';\n+      hints = [\n+        makeRelatedInformation(\n+            reason.typeNode,\n+            'This type corresponds with a namespace, which cannot be used as injection token.'),\n+        makeRelatedInformation(reason.importClause, 'The namespace import occurs here.'),\n+      ];\n+      break;\n+    case ValueUnavailableKind.UNKNOWN_REFERENCE:\n+      chainMessage = 'The type should reference a known declaration.';\n+      hints = [makeRelatedInformation(reason.typeNode, 'This type could not be resolved.')];\n+      break;\n+    case ValueUnavailableKind.MISSING_TYPE:\n+      chainMessage =\n+          'Consider adding a type to the parameter or use the @Inject decorator to specify an injection token.';\n+      break;\n   }\n+\n+  const chain: ts.DiagnosticMessageChain = {\n+    messageText: `No suitable injection token for parameter '${param.name || index}' of class '${\n+        clazz.name.text}'.`,\n+    category: ts.DiagnosticCategory.Error,\n+    code: 0,\n+    next: [{\n+      messageText: chainMessage,\n+      category: ts.DiagnosticCategory.Message,\n+      code: 0,\n+    }],\n+  };\n+\n+  return new FatalDiagnosticError(ErrorCode.PARAM_MISSING_TOKEN, param.nameNode, chain, hints);\n }\n \n export function toR3Reference("
        },
        {
            "sha": "3d28a12d319408bffa54f4037aa1ae7e31138e63",
            "filename": "packages/compiler-cli/src/ngtsc/reflection/src/host.ts",
            "status": "modified",
            "additions": 135,
            "deletions": 25,
            "changes": 160,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Fhost.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Fhost.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Fhost.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -224,25 +224,39 @@ export interface ClassMember {\n   decorators: Decorator[]|null;\n }\n \n+export const enum TypeValueReferenceKind {\n+  LOCAL,\n+  IMPORTED,\n+  UNAVAILABLE,\n+}\n+\n /**\n- * A reference to a value that originated from a type position.\n- *\n- * For example, a constructor parameter could be declared as `foo: Foo`. A `TypeValueReference`\n- * extracted from this would refer to the value of the class `Foo` (assuming it was actually a\n- * type).\n- *\n- * There are two kinds of such references. A reference with `local: false` refers to a type that was\n- * imported, and gives the symbol `name` and the `moduleName` of the import. Note that this\n- * `moduleName` may be a relative path, and thus is likely only valid within the context of the file\n- * which contained the original type reference.\n- *\n- * A reference with `local: true` refers to any other kind of type via a `ts.Expression` that's\n- * valid within the local file where the type was referenced.\n+ * A type reference that refers to any type via a `ts.Expression` that's valid within the local file\n+ * where the type was referenced.\n+ */\n+export interface LocalTypeValueReference {\n+  kind: TypeValueReferenceKind.LOCAL;\n+\n+  /**\n+   * The synthesized expression to reference the type in a value position.\n+   */\n+  expression: ts.Expression;\n+\n+  /**\n+   * If the type originates from a default import, the import statement is captured here to be able\n+   * to track its usages, preventing the import from being elided if it was originally only used in\n+   * a type-position. See `DefaultImportTracker` for details.\n+   */\n+  defaultImportStatement: ts.ImportDeclaration|null;\n+}\n+\n+/**\n+ * A reference that refers to a type that was imported, and gives the symbol `name` and the\n+ * `moduleName` of the import. Note that this `moduleName` may be a relative path, and thus is\n+ * likely only valid within the context of the file which contained the original type reference.\n  */\n-export type TypeValueReference = {\n-  local: true; expression: ts.Expression; defaultImportStatement: ts.ImportDeclaration | null;\n-}|{\n-  local: false;\n+export interface ImportedTypeValueReference {\n+  kind: TypeValueReferenceKind.IMPORTED;\n \n   /**\n    * The module specifier from which the `importedName` symbol should be imported.\n@@ -262,7 +276,107 @@ export type TypeValueReference = {\n   nestedPath: string[]|null;\n \n   valueDeclaration: ts.Declaration;\n-};\n+}\n+\n+/**\n+ * A representation for a type value reference that is used when no value is available. This can\n+ * occur due to various reasons, which is indicated in the `reason` field.\n+ */\n+export interface UnavailableTypeValueReference {\n+  kind: TypeValueReferenceKind.UNAVAILABLE;\n+\n+  /**\n+   * The reason why no value reference could be determined for a type.\n+   */\n+  reason: UnavailableValue;\n+}\n+\n+/**\n+ * The various reasons why the compiler may be unable to synthesize a value from a type reference.\n+ */\n+export const enum ValueUnavailableKind {\n+  /**\n+   * No type node was available.\n+   */\n+  MISSING_TYPE,\n+\n+  /**\n+   * The type does not have a value declaration, e.g. an interface.\n+   */\n+  NO_VALUE_DECLARATION,\n+\n+  /**\n+   * The type is imported using a type-only imports, so it is not suitable to be used in a\n+   * value-position.\n+   */\n+  TYPE_ONLY_IMPORT,\n+\n+  /**\n+   * The type reference could not be resolved to a declaration.\n+   */\n+  UNKNOWN_REFERENCE,\n+\n+  /**\n+   * The type corresponds with a namespace.\n+   */\n+  NAMESPACE,\n+\n+  /**\n+   * The type is not supported in the compiler, for example union types.\n+   */\n+  UNSUPPORTED,\n+}\n+\n+\n+export interface UnsupportedType {\n+  kind: ValueUnavailableKind.UNSUPPORTED;\n+  typeNode: ts.TypeNode;\n+}\n+\n+export interface NoValueDeclaration {\n+  kind: ValueUnavailableKind.NO_VALUE_DECLARATION;\n+  typeNode: ts.TypeNode;\n+  decl: ts.Declaration;\n+}\n+\n+export interface TypeOnlyImport {\n+  kind: ValueUnavailableKind.TYPE_ONLY_IMPORT;\n+  typeNode: ts.TypeNode;\n+  importClause: ts.ImportClause;\n+}\n+\n+export interface NamespaceImport {\n+  kind: ValueUnavailableKind.NAMESPACE;\n+  typeNode: ts.TypeNode;\n+  importClause: ts.ImportClause;\n+}\n+\n+export interface UnknownReference {\n+  kind: ValueUnavailableKind.UNKNOWN_REFERENCE;\n+  typeNode: ts.TypeNode;\n+}\n+\n+export interface MissingType {\n+  kind: ValueUnavailableKind.MISSING_TYPE;\n+}\n+\n+/**\n+ * The various reasons why a type node may not be referred to as a value.\n+ */\n+export type UnavailableValue =\n+    UnsupportedType|NoValueDeclaration|TypeOnlyImport|NamespaceImport|UnknownReference|MissingType;\n+\n+/**\n+ * A reference to a value that originated from a type position.\n+ *\n+ * For example, a constructor parameter could be declared as `foo: Foo`. A `TypeValueReference`\n+ * extracted from this would refer to the value of the class `Foo` (assuming it was actually a\n+ * type).\n+ *\n+ * See the individual types for additional information.\n+ */\n+export type TypeValueReference =\n+    LocalTypeValueReference|ImportedTypeValueReference|UnavailableTypeValueReference;\n \n /**\n  * A parameter to a constructor.\n@@ -288,14 +402,10 @@ export interface CtorParameter {\n    * Reference to the value of the parameter's type annotation, if it's possible to refer to the\n    * parameter's type as a value.\n    *\n-   * This can either be a reference to a local value, in which case it has `local` set to `true` and\n-   * contains a `ts.Expression`, or it's a reference to an imported value, in which case `local` is\n-   * set to `false` and the symbol and module name of the imported value are provided instead.\n-   *\n-   * If the type is not present or cannot be represented as an expression, `typeValueReference` is\n-   * `null`.\n+   * This can either be a reference to a local value, a reference to an imported value, or no\n+   * value if no is present or cannot be represented as an expression.\n    */\n-  typeValueReference: TypeValueReference|null;\n+  typeValueReference: TypeValueReference;\n \n   /**\n    * TypeScript `ts.TypeNode` representing the type node found in the type position."
        },
        {
            "sha": "acef6754090fe4670a11b073d27a4a8672503fad",
            "filename": "packages/compiler-cli/src/ngtsc/reflection/src/type_to_value.ts",
            "status": "modified",
            "additions": 76,
            "deletions": 12,
            "changes": 88,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Ftype_to_value.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Ftype_to_value.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Ftype_to_value.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -8,7 +8,7 @@\n \n import * as ts from 'typescript';\n \n-import {TypeValueReference} from './host';\n+import {TypeValueReference, TypeValueReferenceKind, UnavailableTypeValueReference, ValueUnavailableKind} from './host';\n \n /**\n  * Potentially convert a `ts.TypeNode` to a `TypeValueReference`, which indicates how to use the\n@@ -18,22 +18,26 @@ import {TypeValueReference} from './host';\n  * declaration, or if it is not possible to statically understand.\n  */\n export function typeToValue(\n-    typeNode: ts.TypeNode|null, checker: ts.TypeChecker): TypeValueReference|null {\n+    typeNode: ts.TypeNode|null, checker: ts.TypeChecker): TypeValueReference {\n   // It's not possible to get a value expression if the parameter doesn't even have a type.\n-  if (typeNode === null || !ts.isTypeReferenceNode(typeNode)) {\n-    return null;\n+  if (typeNode === null) {\n+    return missingType();\n+  }\n+\n+  if (!ts.isTypeReferenceNode(typeNode)) {\n+    return unsupportedType(typeNode);\n   }\n \n   const symbols = resolveTypeSymbols(typeNode, checker);\n   if (symbols === null) {\n-    return null;\n+    return unknownReference(typeNode);\n   }\n \n   const {local, decl} = symbols;\n   // It's only valid to convert a type reference to a value reference if the type actually\n   // has a value declaration associated with it.\n   if (decl.valueDeclaration === undefined) {\n-    return null;\n+    return noValueDeclaration(typeNode, decl.declarations[0]);\n   }\n \n   // The type points to a valid value declaration. Rewrite the TypeReference into an\n@@ -47,8 +51,13 @@ export function typeToValue(\n       // This is a default import.\n       //   import Foo from 'foo';\n \n+      if (firstDecl.isTypeOnly) {\n+        // Type-only imports cannot be represented as value.\n+        return typeOnlyImport(typeNode, firstDecl);\n+      }\n+\n       return {\n-        local: true,\n+        kind: TypeValueReferenceKind.LOCAL,\n         // Copying the name here ensures the generated references will be correctly transformed\n         // along with the import.\n         expression: ts.updateIdentifier(firstDecl.name),\n@@ -60,6 +69,11 @@ export function typeToValue(\n       // or\n       //   import {Foo as Bar} from 'foo';\n \n+      if (firstDecl.parent.parent.isTypeOnly) {\n+        // Type-only imports cannot be represented as value.\n+        return typeOnlyImport(typeNode, firstDecl.parent.parent);\n+      }\n+\n       // Determine the name to import (`Foo`) from the import specifier, as the symbol names of\n       // the imported type could refer to a local alias (like `Bar` in the example above).\n       const importedName = (firstDecl.propertyName || firstDecl.name).text;\n@@ -70,7 +84,7 @@ export function typeToValue(\n \n       const moduleName = extractModuleName(firstDecl.parent.parent.parent);\n       return {\n-        local: false,\n+        kind: TypeValueReferenceKind.IMPORTED,\n         valueDeclaration: decl.valueDeclaration,\n         moduleName,\n         importedName,\n@@ -80,9 +94,14 @@ export function typeToValue(\n       // The import is a namespace import\n       //   import * as Foo from 'foo';\n \n+      if (firstDecl.parent.isTypeOnly) {\n+        // Type-only imports cannot be represented as value.\n+        return typeOnlyImport(typeNode, firstDecl.parent);\n+      }\n+\n       if (symbols.symbolNames.length === 1) {\n         // The type refers to the namespace itself, which cannot be represented as a value.\n-        return null;\n+        return namespaceImport(typeNode, firstDecl.parent);\n       }\n \n       // The first symbol name refers to the local name of the namespace, which is is discarded\n@@ -92,7 +111,7 @@ export function typeToValue(\n \n       const moduleName = extractModuleName(firstDecl.parent.parent);\n       return {\n-        local: false,\n+        kind: TypeValueReferenceKind.IMPORTED,\n         valueDeclaration: decl.valueDeclaration,\n         moduleName,\n         importedName,\n@@ -105,15 +124,60 @@ export function typeToValue(\n   const expression = typeNodeToValueExpr(typeNode);\n   if (expression !== null) {\n     return {\n-      local: true,\n+      kind: TypeValueReferenceKind.LOCAL,\n       expression,\n       defaultImportStatement: null,\n     };\n   } else {\n-    return null;\n+    return unsupportedType(typeNode);\n   }\n }\n \n+function unsupportedType(typeNode: ts.TypeNode): UnavailableTypeValueReference {\n+  return {\n+    kind: TypeValueReferenceKind.UNAVAILABLE,\n+    reason: {kind: ValueUnavailableKind.UNSUPPORTED, typeNode},\n+  };\n+}\n+\n+function noValueDeclaration(\n+    typeNode: ts.TypeNode, decl: ts.Declaration): UnavailableTypeValueReference {\n+  return {\n+    kind: TypeValueReferenceKind.UNAVAILABLE,\n+    reason: {kind: ValueUnavailableKind.NO_VALUE_DECLARATION, typeNode, decl},\n+  };\n+}\n+\n+function typeOnlyImport(\n+    typeNode: ts.TypeNode, importClause: ts.ImportClause): UnavailableTypeValueReference {\n+  return {\n+    kind: TypeValueReferenceKind.UNAVAILABLE,\n+    reason: {kind: ValueUnavailableKind.TYPE_ONLY_IMPORT, typeNode, importClause},\n+  };\n+}\n+\n+function unknownReference(typeNode: ts.TypeNode): UnavailableTypeValueReference {\n+  return {\n+    kind: TypeValueReferenceKind.UNAVAILABLE,\n+    reason: {kind: ValueUnavailableKind.UNKNOWN_REFERENCE, typeNode},\n+  };\n+}\n+\n+function namespaceImport(\n+    typeNode: ts.TypeNode, importClause: ts.ImportClause): UnavailableTypeValueReference {\n+  return {\n+    kind: TypeValueReferenceKind.UNAVAILABLE,\n+    reason: {kind: ValueUnavailableKind.NAMESPACE, typeNode, importClause},\n+  };\n+}\n+\n+function missingType(): UnavailableTypeValueReference {\n+  return {\n+    kind: TypeValueReferenceKind.UNAVAILABLE,\n+    reason: {kind: ValueUnavailableKind.MISSING_TYPE},\n+  };\n+}\n+\n /**\n  * Attempt to extract a `ts.Expression` that's equivalent to a `ts.TypeNode`, as the two have\n  * different AST shapes but can reference the same symbols."
        },
        {
            "sha": "fa8626c78a0771c8d29775c213412f9ba38a6ae6",
            "filename": "packages/compiler-cli/src/ngtsc/reflection/src/typescript.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Ftypescript.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Ftypescript.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Ftypescript.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -68,8 +68,6 @@ export class TypeScriptReflectionHost implements ReflectionHost {\n \n         if (childTypeNodes.length === 1) {\n           typeNode = childTypeNodes[0];\n-        } else {\n-          typeNode = null;\n         }\n       }\n "
        },
        {
            "sha": "f4cfd540acc120bf3195215b3fbe97311ec4ffbf",
            "filename": "packages/compiler-cli/src/ngtsc/reflection/test/ts_host_spec.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Ftest%2Fts_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Ftest%2Fts_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Ftest%2Fts_host_spec.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -9,7 +9,7 @@ import * as ts from 'typescript';\n import {absoluteFrom, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n import {getDeclaration, makeProgram} from '../../testing';\n-import {ClassMember, ClassMemberKind, CtorParameter} from '../src/host';\n+import {ClassMember, ClassMemberKind, CtorParameter, TypeValueReferenceKind} from '../src/host';\n import {TypeScriptReflectionHost} from '../src/typescript';\n import {isNamedClassDeclaration} from '../src/util';\n \n@@ -178,7 +178,7 @@ runInEachFileSystem(() => {\n         const args = host.getConstructorParameters(clazz)!;\n         expect(args.length).toBe(1);\n         const param = args[0].typeValueReference;\n-        if (param === null || !param.local) {\n+        if (param === null || param.kind !== TypeValueReferenceKind.LOCAL) {\n           return fail('Expected local parameter');\n         }\n         expect(param).not.toBeNull();\n@@ -548,17 +548,20 @@ runInEachFileSystem(() => {\n     if (type === undefined) {\n       expect(param.typeValueReference).toBeNull();\n     } else {\n-      if (param.typeValueReference === null) {\n+      if (param.typeValueReference.kind === TypeValueReferenceKind.UNAVAILABLE) {\n         return fail(`Expected parameter ${name} to have a typeValueReference`);\n       }\n-      if (param.typeValueReference.local && typeof type === 'string') {\n+      if (param.typeValueReference.kind === TypeValueReferenceKind.LOCAL &&\n+          typeof type === 'string') {\n         expect(argExpressionToString(param.typeValueReference.expression)).toEqual(type);\n-      } else if (!param.typeValueReference.local && typeof type !== 'string') {\n+      } else if (\n+          param.typeValueReference.kind === TypeValueReferenceKind.IMPORTED &&\n+          typeof type !== 'string') {\n         expect(param.typeValueReference.moduleName).toEqual(type.moduleName);\n         expect(param.typeValueReference.importedName).toEqual(type.name);\n       } else {\n         return fail(`Mismatch between typeValueReference and expected type: ${param.name} / ${\n-            param.typeValueReference.local}`);\n+            param.typeValueReference.kind}`);\n       }\n     }\n     if (decorator !== undefined) {"
        },
        {
            "sha": "58575c1a4ea0bc88c0dcdb563944c8ab32caefff",
            "filename": "packages/compiler-cli/test/ngtsc/ngtsc_spec.ts",
            "status": "modified",
            "additions": 186,
            "deletions": 5,
            "changes": 191,
            "blob_url": "https://github.com/angular/angular/blob/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/18098d38b8c49c4f1897cd1edf757de4adcbdef2/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts?ref=18098d38b8c49c4f1897cd1edf757de4adcbdef2",
            "patch": "@@ -2079,7 +2079,13 @@ runInEachFileSystem(os => {\n \n              const errors = env.driveDiagnostics();\n              expect(errors.length).toBe(1);\n-             expect(errors[0].messageText).toContain('No suitable injection token for parameter');\n+             expect(ts.flattenDiagnosticMessageText(errors[0].messageText, '\\n'))\n+                 .toBe(\n+                     `No suitable injection token for parameter 'notInjectable' of class 'Test'.\\n` +\n+                     `  Consider using the @Inject decorator to specify an injection token.`);\n+             expect(errors[0].relatedInformation!.length).toBe(1);\n+             expect(errors[0].relatedInformation![0].messageText)\n+                 .toBe('This type is not supported as injection token.');\n            });\n \n         it('should give a compile-time error if an invalid @Injectable is used with an argument',\n@@ -2096,9 +2102,139 @@ runInEachFileSystem(os => {\n \n              const errors = env.driveDiagnostics();\n              expect(errors.length).toBe(1);\n-             expect(errors[0].messageText).toContain('No suitable injection token for parameter');\n+             expect(ts.flattenDiagnosticMessageText(errors[0].messageText, '\\n'))\n+                 .toBe(\n+                     `No suitable injection token for parameter 'notInjectable' of class 'Test'.\\n` +\n+                     `  Consider using the @Inject decorator to specify an injection token.`);\n+             expect(errors[0].relatedInformation!.length).toBe(1);\n+             expect(errors[0].relatedInformation![0].messageText)\n+                 .toBe('This type is not supported as injection token.');\n            });\n \n+        it('should report an error when using a type-only import as injection token', () => {\n+          env.tsconfig({strictInjectionParameters: true});\n+          env.write(`types.ts`, `\n+             export class TypeOnly {}\n+           `);\n+          env.write(`test.ts`, `\n+             import {Injectable} from '@angular/core';\n+             import type {TypeOnly} from './types';\n+\n+             @Injectable()\n+             export class MyService {\n+               constructor(param: TypeOnly) {}\n+             }\n+          `);\n+\n+          const diags = env.driveDiagnostics();\n+          expect(diags.length).toBe(1);\n+          expect(ts.flattenDiagnosticMessageText(diags[0].messageText, '\\n'))\n+              .toBe(\n+                  `No suitable injection token for parameter 'param' of class 'MyService'.\\n` +\n+                  `  Consider changing the type-only import to a regular import, ` +\n+                  `or use the @Inject decorator to specify an injection token.`);\n+          expect(diags[0].relatedInformation!.length).toBe(2);\n+          expect(diags[0].relatedInformation![0].messageText)\n+              .toBe(\n+                  'This type is imported using a type-only import, ' +\n+                  'which prevents it from being usable as an injection token.');\n+          expect(diags[0].relatedInformation![1].messageText)\n+              .toBe('The type-only import occurs here.');\n+        });\n+\n+        it('should report an error when using a primitive type as injection token', () => {\n+          env.tsconfig({strictInjectionParameters: true});\n+          env.write(`test.ts`, `\n+             import {Injectable} from '@angular/core';\n+\n+             @Injectable()\n+             export class MyService {\n+               constructor(param: string) {}\n+             }\n+          `);\n+\n+          const diags = env.driveDiagnostics();\n+          expect(diags.length).toBe(1);\n+          expect(ts.flattenDiagnosticMessageText(diags[0].messageText, '\\n'))\n+              .toBe(\n+                  `No suitable injection token for parameter 'param' of class 'MyService'.\\n` +\n+                  `  Consider using the @Inject decorator to specify an injection token.`);\n+          expect(diags[0].relatedInformation!.length).toBe(1);\n+          expect(diags[0].relatedInformation![0].messageText)\n+              .toBe('This type is not supported as injection token.');\n+        });\n+\n+        it('should report an error when using a union type as injection token', () => {\n+          env.tsconfig({strictInjectionParameters: true});\n+          env.write(`test.ts`, `\n+             import {Injectable} from '@angular/core';\n+\n+             export class ClassA {}\n+             export class ClassB {}\n+\n+             @Injectable()\n+             export class MyService {\n+               constructor(param: ClassA|ClassB) {}\n+             }\n+          `);\n+\n+          const diags = env.driveDiagnostics();\n+          expect(diags.length).toBe(1);\n+          expect(ts.flattenDiagnosticMessageText(diags[0].messageText, '\\n'))\n+              .toBe(\n+                  `No suitable injection token for parameter 'param' of class 'MyService'.\\n` +\n+                  `  Consider using the @Inject decorator to specify an injection token.`);\n+          expect(diags[0].relatedInformation!.length).toBe(1);\n+          expect(diags[0].relatedInformation![0].messageText)\n+              .toBe('This type is not supported as injection token.');\n+        });\n+\n+        it('should report an error when using an interface as injection token', () => {\n+          env.tsconfig({strictInjectionParameters: true});\n+          env.write(`test.ts`, `\n+             import {Injectable} from '@angular/core';\n+\n+             export interface Interface {}\n+\n+             @Injectable()\n+             export class MyService {\n+               constructor(param: Interface) {}\n+             }\n+          `);\n+\n+          const diags = env.driveDiagnostics();\n+          expect(diags.length).toBe(1);\n+          expect(ts.flattenDiagnosticMessageText(diags[0].messageText, '\\n'))\n+              .toBe(\n+                  `No suitable injection token for parameter 'param' of class 'MyService'.\\n` +\n+                  `  Consider using the @Inject decorator to specify an injection token.`);\n+          expect(diags[0].relatedInformation!.length).toBe(2);\n+          expect(diags[0].relatedInformation![0].messageText)\n+              .toBe('This type does not have a value, so it cannot be used as injection token.');\n+          expect(diags[0].relatedInformation![1].messageText).toBe('The type is declared here.');\n+        });\n+\n+        it('should report an error when no type is present', () => {\n+          env.tsconfig({strictInjectionParameters: true, noImplicitAny: false});\n+          env.write(`test.ts`, `\n+             import {Injectable} from '@angular/core';\n+\n+             @Injectable()\n+             export class MyService {\n+               constructor(param) {}\n+             }\n+          `);\n+\n+          const diags = env.driveDiagnostics();\n+          expect(diags.length).toBe(1);\n+          expect(ts.flattenDiagnosticMessageText(diags[0].messageText, '\\n'))\n+              .toBe(\n+                  `No suitable injection token for parameter 'param' of class 'MyService'.\\n` +\n+                  `  Consider adding a type to the parameter or ` +\n+                  `use the @Inject decorator to specify an injection token.`);\n+          expect(diags[0].relatedInformation).toBeUndefined();\n+        });\n+\n         it('should not give a compile-time error if an invalid @Injectable is used with useValue',\n            () => {\n              env.tsconfig({strictInjectionParameters: true});\n@@ -2240,7 +2376,8 @@ runInEachFileSystem(os => {\n \n           const errors = env.driveDiagnostics();\n           expect(errors.length).toBe(1);\n-          expect(errors[0].messageText).toContain('No suitable injection token for parameter');\n+          expect(ts.flattenDiagnosticMessageText(errors[0].messageText, '\\n'))\n+              .toContain('No suitable injection token for parameter');\n         });\n       });\n \n@@ -4194,9 +4331,16 @@ runInEachFileSystem(os => {\n \n         const diags = env.driveDiagnostics();\n         expect(diags.length).toBe(1);\n-        expect(diags[0].messageText)\n+        expect(ts.flattenDiagnosticMessageText(diags[0].messageText, '\\n'))\n+            .toBe(\n+                `No suitable injection token for parameter 'foo' of class 'MyService'.\\n` +\n+                `  Consider using the @Inject decorator to specify an injection token.`);\n+        expect(diags[0].relatedInformation!.length).toBe(2);\n+        expect(diags[0].relatedInformation![0].messageText)\n             .toBe(\n-                `No suitable injection token for parameter 'foo' of class 'MyService'.\\nFound Foo`);\n+                'This type corresponds with a namespace, which cannot be used as injection token.');\n+        expect(diags[0].relatedInformation![1].messageText)\n+            .toBe('The namespace import occurs here.');\n       });\n     });\n \n@@ -4225,6 +4369,43 @@ runInEachFileSystem(os => {\n          expect(jsContents).toMatch(setClassMetadataRegExp('type: undefined'));\n        });\n \n+    it('should use `undefined` in setClassMetadata if types originate from type-only imports',\n+       () => {\n+         env.write(`types.ts`, `\n+           export default class {}\n+           export class TypeOnly {}\n+         `);\n+         env.write(`test.ts`, `\n+           import {Component, Inject, Injectable} from '@angular/core';\n+           import type DefaultImport from './types';\n+           import type {TypeOnly} from './types';\n+           import type * as types from './types';\n+\n+           @Component({\n+             selector: 'some-comp',\n+             template: '...',\n+           })\n+           export class SomeComp {\n+             constructor(\n+               @Inject('token') namedImport: TypeOnly,\n+               @Inject('token') defaultImport: DefaultImport,\n+               @Inject('token') namespacedImport: types.TypeOnly,\n+             ) {}\n+           }\n+        `);\n+\n+         env.driveMain();\n+         const jsContents = trim(env.getContents('test.js'));\n+         // Module specifier for type-only import should not be emitted\n+         expect(jsContents).not.toContain('./types');\n+         // Default type-only import should not be emitted\n+         expect(jsContents).not.toContain('DefaultImport');\n+         // Named type-only import should not be emitted\n+         expect(jsContents).not.toContain('TypeOnly');\n+         // The parameter type in class metadata should be undefined\n+         expect(jsContents).toMatch(setClassMetadataRegExp('type: undefined'));\n+       });\n+\n     it('should not throw in case whitespaces and HTML comments are present inside <ng-content>',\n        () => {\n          env.write('test.ts', `"
        }
    ],
    "stats": {
        "total": 630,
        "additions": 524,
        "deletions": 106
    }
}