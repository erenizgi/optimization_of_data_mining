{
    "author": "alxhub",
    "message": "refactor(compiler): add getEntitiesInTemplateScope to template binder (#39048)\n\nThe template binding API in @angular/compiler exposes information about a\ntemplate that is synthesized from the template structure and its scope\n(associated directives and pipes).\n\nThis commit introduces a new API, `getEntitiesInTemplateScope`, which\naccepts a `Template` object (or `null` to indicate the root template) and\nreturns all `Reference` and `Variable` nodes that are visible at that level\nof the template, including those declared in parent templates.\n\nThis API is needed by the template type-checker to support autocompletion\nAPIs for the Language Service.\n\nPR Close #39048",
    "sha": "72755eadd21fd82220fb553676b241ec2e49374e",
    "files": [
        {
            "sha": "e87ee6cb94fae7fac726cb4c40b7fc19475a07c4",
            "filename": "packages/compiler/src/render3/view/t2_api.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/72755eadd21fd82220fb553676b241ec2e49374e/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_api.ts",
            "raw_url": "https://github.com/angular/angular/raw/72755eadd21fd82220fb553676b241ec2e49374e/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_api.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_api.ts?ref=72755eadd21fd82220fb553676b241ec2e49374e",
            "patch": "@@ -149,6 +149,12 @@ export interface BoundTarget<DirectiveT extends DirectiveMeta> {\n    */\n   getNestingLevel(template: Template): number;\n \n+  /**\n+   * Get all `Reference`s and `Variables` visible within the given `Template` (or at the top level,\n+   * if `null` is passed).\n+   */\n+  getEntitiesInTemplateScope(template: Template|null): ReadonlySet<Reference|Variable>;\n+\n   /**\n    * Get a list of all the directives used by the target.\n    */"
        },
        {
            "sha": "5226823a53d08a8ac52fdf74c8fd9d29dbbd263e",
            "filename": "packages/compiler/src/render3/view/t2_binder.ts",
            "status": "modified",
            "additions": 59,
            "deletions": 7,
            "changes": 66,
            "blob_url": "https://github.com/angular/angular/blob/72755eadd21fd82220fb553676b241ec2e49374e/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_binder.ts",
            "raw_url": "https://github.com/angular/angular/raw/72755eadd21fd82220fb553676b241ec2e49374e/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_binder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_binder.ts?ref=72755eadd21fd82220fb553676b241ec2e49374e",
            "patch": "@@ -37,6 +37,10 @@ export class R3TargetBinder<DirectiveT extends DirectiveMeta> implements TargetB\n     // scopes in the template and makes them available for later use.\n     const scope = Scope.apply(target.template);\n \n+\n+    // Use the `Scope` to extract the entities present at every level of the template.\n+    const templateEntities = extractTemplateEntities(scope);\n+\n     // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n     //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n     //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n@@ -49,7 +53,8 @@ export class R3TargetBinder<DirectiveT extends DirectiveMeta> implements TargetB\n     const {expressions, symbols, nestingLevel, usedPipes} =\n         TemplateBinder.apply(target.template, scope);\n     return new R3BoundTarget(\n-        target, directives, bindings, references, expressions, symbols, nestingLevel, usedPipes);\n+        target, directives, bindings, references, expressions, symbols, nestingLevel,\n+        templateEntities, usedPipes);\n   }\n }\n \n@@ -71,14 +76,18 @@ class Scope implements Visitor {\n    */\n   readonly childScopes = new Map<Template, Scope>();\n \n-  private constructor(readonly parentScope?: Scope) {}\n+  private constructor(readonly parentScope: Scope|null, readonly template: Template|null) {}\n+\n+  static newRootScope(): Scope {\n+    return new Scope(null, null);\n+  }\n \n   /**\n    * Process a template (either as a `Template` sub-template with variables, or a plain array of\n    * template `Node`s) and construct its `Scope`.\n    */\n-  static apply(template: Template|Node[]): Scope {\n-    const scope = new Scope();\n+  static apply(template: Node[]): Scope {\n+    const scope = Scope.newRootScope();\n     scope.ingest(template);\n     return scope;\n   }\n@@ -113,7 +122,7 @@ class Scope implements Visitor {\n     template.references.forEach(node => this.visitReference(node));\n \n     // Next, create an inner scope and process the template within it.\n-    const scope = new Scope(this);\n+    const scope = new Scope(this, template);\n     scope.ingest(template);\n     this.childScopes.set(template, scope);\n   }\n@@ -153,7 +162,7 @@ class Scope implements Visitor {\n     if (this.namedEntities.has(name)) {\n       // Found in the local scope.\n       return this.namedEntities.get(name)!;\n-    } else if (this.parentScope !== undefined) {\n+    } else if (this.parentScope !== null) {\n       // Not in the local scope, but there's a parent scope so check there.\n       return this.parentScope.lookup(name);\n     } else {\n@@ -517,7 +526,13 @@ export class R3BoundTarget<DirectiveT extends DirectiveMeta> implements BoundTar\n               {directive: DirectiveT, node: Element|Template}|Element|Template>,\n       private exprTargets: Map<AST, Reference|Variable>,\n       private symbols: Map<Reference|Variable, Template>,\n-      private nestingLevel: Map<Template, number>, private usedPipes: Set<string>) {}\n+      private nestingLevel: Map<Template, number>,\n+      private templateEntities: Map<Template|null, ReadonlySet<Reference|Variable>>,\n+      private usedPipes: Set<string>) {}\n+\n+  getEntitiesInTemplateScope(template: Template|null): ReadonlySet<Reference|Variable> {\n+    return this.templateEntities.get(template) ?? new Set();\n+  }\n \n   getDirectivesOfNode(node: Element|Template): DirectiveT[]|null {\n     return this.directives.get(node) || null;\n@@ -555,3 +570,40 @@ export class R3BoundTarget<DirectiveT extends DirectiveMeta> implements BoundTar\n     return Array.from(this.usedPipes);\n   }\n }\n+\n+function extractTemplateEntities(rootScope: Scope): Map<Template|null, Set<Reference|Variable>> {\n+  const entityMap = new Map<Template|null, Map<string, Reference|Variable>>();\n+\n+  function extractScopeEntities(scope: Scope): Map<string, Reference|Variable> {\n+    if (entityMap.has(scope.template)) {\n+      return entityMap.get(scope.template)!;\n+    }\n+\n+    const currentEntities = scope.namedEntities;\n+\n+    let templateEntities: Map<string, Reference|Variable>;\n+    if (scope.parentScope !== null) {\n+      templateEntities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);\n+    } else {\n+      templateEntities = new Map(currentEntities);\n+    }\n+\n+    entityMap.set(scope.template, templateEntities);\n+    return templateEntities;\n+  }\n+\n+  const scopesToProcess: Scope[] = [rootScope];\n+  while (scopesToProcess.length > 0) {\n+    const scope = scopesToProcess.pop()!;\n+    for (const childScope of scope.childScopes.values()) {\n+      scopesToProcess.push(childScope);\n+    }\n+    extractScopeEntities(scope);\n+  }\n+\n+  const templateEntities = new Map<Template|null, Set<Reference|Variable>>();\n+  for (const [template, entities] of entityMap) {\n+    templateEntities.set(template, new Set(entities.values()));\n+  }\n+  return templateEntities;\n+}"
        }
    ],
    "stats": {
        "total": 72,
        "additions": 65,
        "deletions": 7
    }
}